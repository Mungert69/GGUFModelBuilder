[
  {
    "input": "What is the purpose of the introduction chapter in the book?",
    "summary": "The book \"Python for Kids\" is written by Jason R. Briggs, an experienced programmer, and illustrated by Miran Lipovaca. It is designed for beginners, including children, to learn programming through fun and engaging activities. The book covers Python basics, turtle graphics, tkinter modules, and game development, with examples, exercises, and puzzles to help readers understand and practice programming concepts.",
    "output": "About the Author\nJason R. Briggs has been a programmer since the age of eight,\nwhen he first learned BASIC on a Radio Shack TRS-80. He\nhas written software professionally as a developer and systems\narchitect and served as Contributing Editor for Java Developer’s\nJournal. His articles have appeared in JavaWorld, ONJava, and\nONLamp. Python for Kids is his first book.\nJason can be reached at http://jasonrbriggs.com/ or by email\nat mail@jasonrbriggs.com.\nAbout the Illustrator\nMiran Lipovaca is the author of Learn You a Haskell for Great\nGood!. He enjoys boxing, playing bass guitar, and, of course,\ndrawing. He has a fascination with dancing skeletons and the\nnumber 71, and when he walks through automatic doors he pre-\ntends that he’s actually opening them with his mind.\nAbout the technical Reviewers\nA recent graduate of The Nueva School, 15-year-old Josh Pollock\nis a freshman at Lick-Wilmerding High School in San Francisco.\nHe first started programming in Scratch when he was 9 years old,\nbegan using TI-BASIC when he was in 6th grade, and moved on\nto Java and Python in 7th and UnityScript in 8th. In addition to\nprogramming, he loves playing the trumpet, developing computer\ngames, and teaching people about interesting STEM topics.\nMaria Fernandez has a master’s degree in applied linguistics and\nhas been interested in computers and technology for more than\n20 years. She taught English to young refugee women with the\nGlobal Village Project in Georgia and currently resides in northern\nCalifornia working with ETS (Educational Testing Service).\nAcknowledgments\nThis must be what it’s like when you get up on stage to accept\nan award, only to realize you’ve left the list of people you have to\nthank in your other trousers: You’re guaranteed to forget someone,\nand that music will soon start rolling to quickly usher you off the\nstage.\nSo that being said, here’s the (no doubt) incomplete list of people\nto whom I owe a huge debt of gratitude for helping make this book\nas good as I think it now is.\nThanks to the No Starch team, particularly Bill Pollock, for\napplying a liberal dose of “what-would-a-kid-think” while editing it.\nWhen you’ve been programming for a long time, it’s all too easy to\nforget how difficult some of this stuff is for learners, and Bill was\ninvaluable at pointing out those oft-overlooked, over-complicated\nparts. And thanks to Serena Yang, production manager extra-\nordinaire; here’s hoping you haven’t torn out too much hair getting\n300+ pages of code correctly colorized.\nA big thank you must go to Miran Lipovac�a for utterly bril-\nliant illustrations. Beyond brilliant. No really! If I had done the\nartwork, we’d be lucky to have the occasional smudged figure\nthat doesn’t resemble anything in particular. Is it a bear . . . ?\nIs it a dog . . . ? No, wait . . . is that supposed to be a tree?\nThanks to the reviewers. I apologize if some of your sugges-\ntions weren’t implemented in the end. You were probably right, and\nI can only blame a personal character flaw for any probable goofs.\nParticular thanks to Josh for some great suggestions and some\nreally good catches. And apologies to Maria for having to deal with\noccasionally dodgily formatted code.\nThanks to my wife and daughter, for putting up with a hus-\nband and father who had his nose buried in a computer screen\neven more than usual.\nTo Mum, for endless amounts of encouragement over the years.\nFinally, thanks to my father, for buying a computer back in the\n1970s and putting up with someone who wanted to use it as much\nas he did. None of this would have been possible without him.\nIntRoDUCtIon\nWhy learn computer programming?\nProgramming fosters creativity, reasoning, and\nproblem solving. The programmer gets the opportunity\nto create something from nothing, use logic to turn\nprogramming constructs into a form that a computer\ncan run, and, when things don’t work quite as well\nas expected, use problem solving to figure out what\nhas gone wrong. Programming is a fun, sometimes\nchallenging (and occasionally frustrating) activity, and the skills\nlearned from it can be useful both in school and at work . . . even if\nyour career has nothing to do with computers.\nAnd, if nothing else, programming is a great way to spend an\nafternoon when the weather outside is dreary.\nWhy Python?\nPython is an easy-to-learn programming language that has some\nreally useful features for a beginning programmer. The code is quite\neasy to read when compared to other programming languages, and\nit has an interactive shell into which you can enter your programs\nand see them run. In addition to its simple language structure and\nan interactive shell with which to experiment, Python has some\nfeatures that greatly augment the learning process and allow you\nto put together simple animations for creating your own games.\nOne is the turtle module, inspired by Turtle graphics (used by the\nLogo programming language back in the 1960s) and designed for\neducational use. Another is the tkinter module, an interface for the\nTk GUI toolkit, which provides a simple way to create programs\nwith slightly more advanced graphics and animation.\nHow to Learn to Code\nLike anything you try for the first time, it’s always best to start\nwith the basics, so begin with the first chapters and resist the urge\nto skip ahead to the later chapters. No one can play an orchestral\nsymphony the first time they pick up an instrument. Student pilots\ndon’t start flying a plane before they understand the basic controls.\nGymnasts aren’t (usually) able to do back flips on their first try. If\nyou jump ahead too quickly, not only will the basic ideas not stick\nin your head, but you’ll also find the content of the later chapters\nmore complicated than it actually is.\nAs you go through this book, try each of the examples, so you\ncan see how they work. There are also programming puzzles at the\nend of most chapters for you to try, which will help improve your\nprogramming skills. Remember that the better you understand the\nbasics, the easier it will be to understand more complicated ideas\nlater on.\nxx Introduction\nWhen you find something frustrating or too challenging, here\nare some things that I find helpful:\n1. Break a problem down into smaller pieces. Try to understand\nwhat a small piece of code is doing, or think about only a small\npart of a difficult idea (focus on a small piece of code rather\nthan trying to understand the whole thing at once).\n2. If that still doesn’t help, sometimes it’s best to just leave it\nalone for a while. Sleep on it, and come back to it another day.\nThis is a good way to solve many problems, and it can be par-\nticularly helpful for computer programmers.\nWho should Read this Book\nThis book is for anyone interested in computer programming,\nwhether that’s a child or an adult coming to programming for the\nfirst time. If you want to learn how to write your own software\nrather than just use the programs developed by others, Python for\nKids is a great place to start.\nIn the following chapters, you’ll find information to help you\ninstall Python, start the Python shell and perform basic calcula-\ntions, print text on the screen and create lists, and perform simple\ncontrol flow operations using if statements and for loops (and\nlearn what if statements and for loops are!). You’ll learn how to\nreuse code with functions, the basics of classes and objects, and\ndescriptions of some of the many built-in Python functions and\nmodules.\nYou’ll find chapters on both simple and advanced turtle graph-\nics, as well as on using the tkinter module to draw on the computer\nscreen. There are programming puzzles of varying complexity at\nthe ends of many chapters, which will help readers cement their\nnewfound knowledge by giving them a chance to write small pro-\ngrams by themselves.\nOnce you’ve built up your fundamental programming knowl-\nedge, you’ll learn how to write your own games. You’ll develop two\ngraphical games and learn about collision detection, events, and\ndifferent animation techniques.\nMost of the examples in this book use Python’s IDLE (Inte-\ngrated DeveLopment Environment) shell. IDLE provides syntax\nhighlighting, copy-and-paste functionality (similar to what you\nIntroduction xxi\nwould use in other applications), and an editor window where you\ncan save your code for later use, which means IDLE works as both\nan interactive environment for experimentation and something\na bit like a text editor. The examples will work just as well with\nthe standard console and a regular text editor, but IDLE’s syntax\nhighlighting and slightly more user-friendly environment can aid\nunderstanding, so the very first chapter shows you how to set it up.\nWhat’s in this Book\nHere’s a brief rundown of what you’ll find in each chapter.\nChapter 1 is an introduction to programming with instruc-\ntions for installing Python for the first time.\nChapter 2 introduces basic calculations and variables, and\nChapter 3 describes some of the basic Python types, such as\nstrings, lists, and tuples.\nChapter 4 is the first taste of the turtle module. We’ll jump\nfrom basic programming to moving a turtle (in the shape of an\narrow) around the screen.\nChapter 5 covers the variations of conditions and if state-\nments, and Chapter 6 moves on to for loops and while loops.\nChapter 7 is where we start to use and create functions, and\nthen in Chapter 8 we cover classes and objects. We cover enough\nof the basic ideas to support some of the programming techniques\nwe’ll need in the games development chapters later on in the book.\nAt this point, the material starts get a little more complicated.\nChapter 9 goes through most of the built-in functions in\nPython, and Chapter 10 continues with a few modules (basically\nbuckets of useful functionality) that are installed by default with\nPython.\nChapter 11 returns to the turtle module as the reader experi-\nments with more complicated shapes. Chapter 12 moves on to\nusing the tkinter module for more advanced graphics creation.\nIn Chapters 13 and 14, we create our first game, “Bounce!,”\nwhich builds on the knowledge gained from the preceding chapters,\nand in Chapters 15–18, we create another game, “Mr. Stick Man\nRaces for the Exit.” The game development chapters are where\nthings could start to go seriously wrong. If all else fails, download\nthe code from the companion website (http://python-for-kids.com/),\nand compare your code with these working examples.\nxxii Introduction\nIn the Afterword, we wrap up with a look at PyGame and\nsome other popular programming languages.\nFinally, in the Appendix, you’ll learn about Python’s key-\nwords in detail, and in the Glossary, you’ll find definitions of the\nprogramming terms used throughout this book.\nthe Companion Website\nIf you find that you need help as you read, try the companion site,\nhttp://python-for-kids.com/, where you’ll find downloads for all the\nexamples in this book and more programming puzzles. You’ll also\nfind solutions to all the programming puzzles in the book on the\ncompanion site, in case you get stumped or want to check your work.\nHave fun!\nRemember as you work your way through this book that pro-\ngramming can be fun. Don’t think of this as work. Think of\nprogramming as a way to create some fun games or applications\nthat you can share with your friends or others.\nLearning to program is a wonderful mental exercise and the\nresults can be very rewarding. But most of all, whatever you do,\nhave fun!\nIntroduction xxiii"
  },
  {
    "input": "",
    "summary": "A computer program is a set of instructions that tell a computer what to do, and software is a collection of these programs. Programs are essential for controlling various devices and systems, from computers to cars and home appliances. Python is a beginner-friendly programming language that allows for simple and efficient coding, and variables are used to store and label information for easier use in calculations.",
    "output": "1\nnot ALL s nAKes sLItHeR\nA computer program is a set of instructions that causes\na computer to perform some kind of action. It isn’t the\nphysical parts of a computer—like the wires, micro-\nchips, cards, hard drive, and such—but the hidden\nstuff running on that hardware. A computer program,\nwhich I’ll usually refer to as just a program, is the set\nof commands that tell that dumb hardware what to do.\nSoftware is a collection of computer programs.\nWithout computer programs, almost every device you use daily\nwould either stop working or be much less useful than it is now.\nComputer programs, in one form or another, control not only your\npersonal computer but also video game systems, cell phones, and\nthe GPS units in cars. Software also controls less obvious items\nlike LCD TVs and their remote controllers, as well as some of the\nnewest radios, DVD players, ovens, and some fridges. Even car\nengines, traffic lights, street lamps, train signals, electronic bill-\nboards, and elevators are controlled by programs.\nPrograms are a bit like thoughts. If you didn’t have thoughts,\nyou would probably just sit on the floor, staring vacantly and drool-\ning down the front of your shirt. Your thought “get up off the floor”\nis an instruction, or command, that tells your body to stand up. In\nthe same way, computer programs tell computers what to do.\nIf you know how to write computer programs, you can do all\nsorts of useful things. Sure, you may not be able to write programs\nto control cars, traffic lights, or your fridge (well, at least not at\nfirst), but you could create web pages, write your own games, or\neven make a program to help with your homework.\nA few Words About Language\nLike humans, computers use multiple languages to communicate—\nin this case, programming languages. A program ming language\nis simply a particular way to talk to a computer—a way to use\ninstructions that both humans and the computer can understand.\nThere are programming languages named after people (like Ada\nand Pascal), those named using simple acronyms (like BASIC and\nFORTRAN), and even a few named after TV shows, like Python.\nYes, the Python programming language was named after the Monty\nPython’s Flying Circus TV show, not after python the snake.\nnote Monty Python’s Flying Circus was an alternative British comedy\nshow first broadcast in the 1970s, and it remains hugely popular\ntoday among a certain audience. The show had sketches like “The\nMinistry of Silly Walks,” “The Fish-Slapping Dance,” and “The\nCheese Shop” (which didn’t sell any cheese).\n4 Chapter 1\nA number of things about the Python programming language\nmake it extremely useful for beginners. Most importantly, you\ncan use Python to write simple, efficient programs really quickly.\nPython doesn’t have a lot of complicated symbols, like braces ({ }),\nhashes (#), and dollar signs ($), which make other programming\nlanguages a lot more difficult to read and, therefore, a lot less\nfriendly to beginners.\nInstalling Python\nInstalling Python is fairly straightforward. Here, we’ll go over\nthe steps for installing it on Windows 7, Mac OS X, and Ubuntu.\nWhen installing Python, you’ll also set up a shortcut for the IDLE\nprogram, which is the Integrated DeveLopment Environment that\nlets you write programs for Python. If Python has already been\ninstalled on your computer, jump ahead to “Once You’ve Installed\nPython” on page 10.\nInstalling Python on Windows 7\nTo install Python for Microsoft Windows 7, point a web browser to\nhttp://www.python.org/ and download the latest Windows installer\nfor Python 3. Look for a section in the menu titled Quick Links,\nas shown here:\nnote The exact version of Python that you download is not important, as\nlong as it starts with the number 3.\nNot All Snakes Slither 5\nAfter you download the Windows installer, double-click its\nicon, and then follow the instructions to install Python in the\ndefault location, as follows:\n1. Select Install for All Users, and then click Next.\n2. Leave the default directory unchanged, but note the name\nof the installation directory (probably C:\\Python31 or C:\\\nPython32). Click Next.\n3. Ignore the Customize Python section of the installation, and\nclick Next.\nAt the end of this process, you should have a Python 3 entry in\nyour Start menu:\nNext, follow these steps to add a Python 3 shortcut to your\ndesktop:\n1. Right-click your desktop, and select New4Shortcut from the\npop-up menu.\n2. Enter the following in the box where it says Type the location\nof the item (make sure that the directory you enter is the same\nas the one you noted earlier):\nc:\\Python32\\Lib\\idlelib\\idle.pyw –n\n6 Chapter 1\nYour dialog should look like this:\n3. Click Next to move to the next dialog.\n4. Enter the name as IDLE, and click Finish to create the\nshortcut.\nNow you can skip to “Once You’ve Installed Python” on page 10\nto get started with Python.\nInstalling Python on Mac os X\nIf you’re using a Mac, you should find a version of Python pre-\ninstalled, but it’s probably an older version of the language. To be\nsure that you’re running the newest version, point your browser to\nhttp://www.python.org/getit/ to download the latest installer for\nthe Mac.\nThere are two different installers. The one you should down-\nload depends on which version of Mac OS X you have installed.\n(To find out, click the Apple icon in the top menu bar, and choose\nAbout this Mac.) Pick an installer as follows:\n• If you’re running a Mac OS X version between 10.3 and 10.6,\ndownload the 32-bit version of Python 3 for i386/PPC.\n• If you’re running Mac OS X version 10.6 or higher, download\nthe 64-bit/32-bit version of Python 3 for x86-64.\nNot All Snakes Slither 7\nOnce the file has downloaded (it will have the filename exten-\nsion .dmg), double-click it. You’ll see a window showing the file’s\ncontents.\nIn this window, double-click Python.mpkg, and then follow the\ninstructions to install the software. You’ll be prompted for the admin-\nistrator password for your Mac before Python installs. (Don’t have\nthe administrator password? Your parent may need to enter it.)\nNext, you need to add a script to the desktop for launching\nPython’s IDLE application, as follows:\n1. Click the Spotlight icon, the small magnifying glass at the\ntop-right corner of the screen.\n2. In the box that appears, enter Automator.\n3. Click the application that looks like a robot when it appears in\nthe menu. It will either be in the section labeled Top Hit or in\nApplications.\n4. Once Automator starts, select the Application template:\n8 Chapter 1\n5. Click Choose to continue.\n6. In the list of actions, find Run Shell Script, and drag it to the\nempty panel on the right. You’ll see something like this:\n7. In the text box, you’ll see the word cat. Select the word and\nreplace it with the following text (everything from open to -n):\nopen -a \"/Applications/Python 3.2/IDLE.app\" --args -n\nYou may need to change the directory depending on the\nversion of Python you installed.\n8. Select File4Save, and enter IDLE as the name.\n9. Select Desktop from the Where dialog, and then click Save.\nNow you can skip to “Once You’ve Installed Python” on page 10\nto get started with Python.\nInstalling Python on Ubuntu\nPython comes preinstalled on the Ubuntu Linux distribution, but\nit may be an older version. Follow these steps to install Python 3\non Ubuntu 12.x:\n1. Click the button for the Ubuntu Software Center in the Side-\nbar (it’s the icon that looks like an orange bag—if you don’t\nsee it, you can always click the Dash Home icon and enter\nSoftware in the dialog).\n2. Enter Python in the search box in the top-right corner of the\nSoftware Center.\nNot All Snakes Slither 9\n3. In the list of software presented, select the latest version of\nIDLE, which is IDLE (using Python 3.2) in this example:\n4. Click Install.\n5. Enter your administrator password to install the software, and\nthen click Authenticate. (Don’t have the administrator pass-\nword? Your parent may need to enter it.)\nnote On some versions of Ubuntu you might only see Python (v3.2) in the\nmain menu (rather than IDLE)—you can install this instead.\nNow that you’ve got the latest version of Python installed, let’s\ngive it a try.\nonce You’ve Installed Python\nYou should now have an icon on your\nWindows or Mac OS X desktop labeled\nIDLE. If you’re using Ubuntu, in the\nApplications menu, you should see\na new group named Programming\nwith the application IDLE (using\nPython 3.2) (or a later version).\n10 Chapter 1\nDouble-click the icon or choose the menu option, and you should\nsee this window:\nThis is the Python shell, which is part of Python’s integrated\ndevelopment environment. The three greater-than signs (>>>) are\ncalled the prompt.\nLet’s enter some commands at the prompt, beginning with the\nfollowing:\n>>> print(\"Hello World\")\nMake sure to include the double quotes (\" \"). Press enter on\nyour keyboard when you’re finished typing the line. If you’ve entered\nthe command correctly, you should see something like this:\n>>> print(\"Hello World\")\nHello World\n>>>\nThe prompt should reappear to let\nyou know that the Python shell is ready\nto accept more commands.\nCongratulations! You’ve just created\nyour first Python p rogram. The word\nprint is a type of Python command called\na function, and it prints out whatever is\ninside the parentheses to the screen. In\nessence, you have given the computer an\ninstruction to display the words “Hello\nWorld”—an instruction that both you\nand the computer can understand.\nNot All Snakes Slither 11\nsaving Your Python Programs\nPython programs wouldn’t be very useful if you needed to rewrite\nthem every time you wanted to use them, never mind print them\nout so you could reference them. Sure, it might be fine to just\nrewrite short programs, but a large program, like a word proces-\nsor, could contain millions of lines of code. Print that all out, and\nyou could have well over 100,000 pages. Just imagine trying to\ncarry that huge stack of paper home. Better hope that you won’t\nmeet up with a big gust of wind.\nLuckily, we can save our programs for future use. To save a\nnew program, open IDLE and choose File4New Window. An\nempty window will appear, with *Untitled* in the menu bar.\nEnter the following code into the new shell window:\nprint(\"Hello World\")\nNow, choose File4Save. When prompted for a filename, enter\nhello.py, and save the file to your desktop. Then choose Run4Run\nModule. With any luck, your saved program should run, like this:\nNow, if you close the shell win-\ndow but leave the hello.py window\nopen and then choose Run4Run\nModule, the Python shell should\nreappear, and your program should\nrun again. (To reopen the Python\nshell without running the program,\nchoose Run4Python Shell.)\n12 Chapter 1\nAfter running the code, you’ll find a new icon on your desktop\nlabeled hello.py. If you double-click the icon, a black window will\nappear briefly and then vanish. What happened?\nYou’re seeing the Python command-line console (similar to the\nshell) starting up, printing “Hello World,” and then exiting. Here’s\nwhat would appear if you had superhero-like speed vision and\ncould see the window before it closed:\nIn addition to the menus, you can also use keyboard shortcuts\nto create a new shell window, save a file, and run a program:\n• On Windows and Ubuntu, use ctrl-N to create a new shell\nwindow, use ctrl-S to save your file after you’ve finished edit-\ning, and press F5 to run your program.\n• On Mac OS X, use z-N to create a new shell window, use z-S\nto save your file, and hold down the function (fn) key and press\nF5 to run your program.\nWhat You Learned\nWe began simply in this chapter with a Hello World application—\nthe program nearly everyone starts with when they learn computer\nprogramming. In the next chapter, we’ll do some more useful things\nwith the Python shell.\nNot All Snakes Slither 13\n2\nCALCULAtIons AnD\nVARIABLes\nNow that you have Python installed and know how to\nstart the Python shell, you’re ready to do something\nwith it. We’ll begin with some simple calculations and\nthen move on to variables. Variables are a way of stor-\ning things in a computer program, and they can help\nyou write useful programs.\nCalculating with Python\nNormally, when asked to find the product of two numbers like\n8 × 3.57, you would use a calculator or a pencil and paper. Well,\nhow about using the Python shell to perform your calculation?\nLet’s try it.\nStart the Python shell by double-clicking the IDLE icon on\nyour desktop or, if you’re using Ubuntu, by clicking the IDLE icon\nin the Applications menu. At the prompt, enter this equation:\n>>> 8 * 3.57\n28.56\nNotice that when entering a multiplication calculation in Python,\nyou use the asterisk symbol (*) instead of a multiplication sign (×).\nHow about if we try an equation that’s a bit more useful?\nSuppose you are digging in your backyard and uncover a bag\nof 20 gold coins. The next day, you sneak down to the basement\nand stick the coins inside your grandfather’s steam-powered repli-\ncating invention (luckily, you can just fit the 20 coins inside). You\nhear a whiz and a pop and, a few hours later, out shoot another 10\ngleaming coins.\nHow many coins would you have in your treasure chest if you\ndid this every day for a year? On paper, the equations might look\nlike this:\n10 × 365 = 3650\n20 + 3650 = 3670\nSure, it’s easy enough to do these calculations on a calculator\nor on paper, but we can do all of these calculations with the Python\nshell as well. First, we multiply 10 coins by 365 days in a year to\nget 3650. Next, we add the original 20 coins to get 3670.\n>>> 10 * 365\n3650\n>>> 20 + 3650\n3670\nNow, what if a raven spots the shiny gold sitting in your bed-\nroom, and every week flies in and manages to steal three coins?\n16 Chapter 2\nHow many coins would you have left at the end of the year? Here’s\nhow this calculation looks in the shell:\n>>> 3 * 52\n156\n>>> 3670 - 156\n3514\nFirst, we multiply 3 coins by 52 weeks in the year. The result\nis 156. We subtract that number from our total coins (3670), which\ntells us that we would have 3514 coins remaining at the end of\nthe year.\nThis is a very simple program. In this book, you’ll learn how to\nexpand on these ideas to write programs that are even more useful.\nPython operators\nYou can do multiplication, addition, subtraction, and division in\nthe Python shell, among other mathematical operations that we\nwon’t go into right now. The basic symbols used by Python to per-\nform mathematical operations are called operators, as listed in\nTable 2-1.\nTable 2-1: Basic Python Operators\nSymbol Operation\n+ Addition\n- Subtraction\n* Multiplication\n/ Division\nThe forward slash (/) is used for divi-\nsion because it’s similar to the division line\nthat you would use when writing a frac-\ntion. For example, if you had 100 pirates\nand 20 large barrels and you wanted to\ncalculate how many pirates you could\nhide in each barrel, you could divide\n100 pirates by 20 barrels (100 ÷ 20)\nby entering 100 / 20 in the Python shell.\nJust remember that the forward slash is\nthe one whose top falls to the right.\nCalculations and Variables 17\nthe order of operations\nWe use parentheses in a programming language to control the\norder of operations. An operation is anything that uses an operator.\nMultiplication and division have a higher order than addition and\nsubtraction, which means that they’re performed first. In other\nwords, if you enter an equation in Python, multiplication or divi-\nsion is performed before addition or subtraction.\nFor example, in the following equation, the numbers 30 and 20\nare multiplied first, and the number 5 is added to their product.\n>>> 5 + 30 * 20\n605\nThis equation is another way of saying, “multiply 30 by 20,\nand then add 5 to the result.” The result is 605. We can change\nthe order of operations by adding parentheses around the first two\nnumbers, like so:\n>>> (5 + 30) * 20\n700\nThe result of this equation is\n700 (not 605) because the parenthe-\nses tell Python to do the operation\nin the parentheses first, and then\ndo the operation outside the paren-\ntheses. This example is saying “add\n5 to 30, and then multiply the result\nby 20.”\nParentheses can be nested,\nwhich means that there can be\nparentheses inside parentheses,\nlike this:\n>>> ((5 + 30) * 20) / 10\n70.0\nIn this case, Python evaluates the innermost parentheses\nfirst, then the outer ones, and then the final division operator.\n18 Chapter 2\nIn other words, this equation is saying, “add 5 to 30, then multiply\nthe result by 20, and divide that result by 10.” Here’s what happens:\n• Adding 5 to 30 gives 35.\n• Multiplying 35 by 20 gives 700.\n• Dividing 700 by 10 gives the final answer of 70.\nIf we had not used parentheses, the result would be slightly\ndifferent:\n>>> 5 + 30 * 20 / 10\n65.0\nIn this case, 30 is first multiplied by 20 (giving 600), and\nthen 600 is divided by 10 (giving 60). Finally, 5 is added to get\nthe result of 65.\nWARnInG Remember that multiplication and division always go before\naddition and subtraction, unless parentheses are used to control\nthe order of operations.\nVariables Are Like Labels\nThe word variable in programming describes a place to store infor-\nmation such as numbers, text, lists of numbers and text, and so\non. Another way of looking at a variable is that it’s like a label for\nsomething.\nFor example, to create a variable named fred, we use an equal\nsign (=) and then tell Python what information the variable should\nbe the label for. Here, we create the variable fred and tell Python\nthat it labels the number 100 (note that this doesn’t mean that\nanother variable can’t have the same value):\n>>> fred = 100\nTo find out what value a variable labels, enter print in the\nshell, followed by the variable name in parentheses, like this:\n>>> print(fred)\n100\nCalculations and Variables 19\nWe can also tell Python to change the variable fred so that it\nlabels something else. For example, here’s how to change fred to\nthe number 200:\n>>> fred = 200\n>>> print(fred)\n200\nOn the first line, we say that fred labels the number 200. In\nthe second line, we ask what fred is labeling, just to confirm the\nchange. Python prints the result on the last line.\nWe can also use more than one label (more than one variable)\nfor the same item:\n>>> fred = 200\n>>> john = fred\n>>> print(john)\n200\nIn this example, we’re telling Python that we want the name\n(or variable) john to label the same thing as fred by using the equal\nsign between john and fred.\nOf course, fred probably isn’t a very useful name for a variable\nbecause it most likely doesn’t tell us anything about what the vari-\nable is used for. Let’s call our variable number_of_coins instead of\nfred, like this:\n>>> number_of_coins = 200\n>>> print(number_of_coins)\n200\nThis makes it clear that we’re talking about 200 coins.\nVariable names can be made up of letters, numbers, and the\nunderscore character (_ ), but they can’t start with a number. You\ncan use anything from single letters (such as a) to long sentences\nfor variable names. (A variable can’t contain a space, so use an\nunderscore to separate words.) Sometimes, if you’re doing some-\nthing quick, a short variable name is best. The name you choose\nshould depend on how meaningful you need the variable name\nto be.\nNow that you know how to create variables, let’s look at how to\nuse them.\n20 Chapter 2\nUsing Variables\nRemember our equation for figuring out how many coins you would\nhave at the end of the year if you could magically create new coins\nwith your grandfather’s crazy invention in the basement? We have\nthis equation:\n>>> 20 + 10 * 365\n3670\n>>> 3 * 52\n156\n>>> 3670 - 156\n3514\nWe can turn this into a single line of code:\n>>> 20 + 10 * 365 – 3 * 52\n3514\nNow, what if we turn the numbers into variables? Try entering\nthe following:\n>>> found_coins = 20\n>>> magic_coins = 10\n>>> stolen_coins = 3\nThese entries create the variables found_coins, magic_coins, and\nstolen_coins.\nNow, we can reenter the equation like this:\n>>> found_coins + magic_coins * 365 - stolen_coins * 52\n3514\nYou can see that\nthis gives us the same\nanswer. So who cares,\nright? Ah, but here’s\nthe magic of variables.\nWhat if you stick a\nscarecrow in your win-\ndow, and the raven\nsteals only two coins\nCalculations and Variables 21\ninstead of three? When we use a variable, we can simply change\nthe variable to hold that new number, and it will change every-\nwhere it is used in the equation. We can change the stolen_coins\nvariable to 2 by entering this:\n>>> stolen_coins = 2\nWe can then copy and paste the equation to calculate the\nanswer again, like so:\n1. Select the text to copy by clicking with the mouse and drag-\nging from the beginning to the end of the line, as shown here:\n2. Hold down the ctrl key (or, if you’re using a Mac, the z key)\nand press C to copy the selected text. (You’ll see this as ctrl-C\nfrom now on.)\n3. Click the last prompt line (after stolen_coins = 2).\n4. Hold down the ctrl key and press V to paste the selected text.\n(You’ll see this as ctrl-V from now on.)\n5. Press enter to see the new result:\n22 Chapter 2\nIsn’t that a lot easier than retyping the whole equation? It\nsure is.\nYou can try changing the other variables, and then copy\n(ctrl-C) and paste (ctrl-V) the calculation to see the effect of\nyour changes. For example, if you bang the sides of your grand-\nfather’s invention at the right moment, and it spits out an extra\n3 coins each time, you’ll find that you end up with 4661 coins at\nthe end of the year:\n>>> magic_coins = 13\n>>> found_coins + magic_coins * 365 - stolen_coins * 52\n4661\nOf course, using variables for a simple equation like this one is\nstill only slightly useful. We haven’t gotten to really useful yet. For\nnow, just remember that variables are a way of labeling things so\nthat you can use them later.\nWhat You Learned\nIn this chapter you learned how to do simple equations using\nPython operators and how to use parentheses to control the order\nof operations (the order in which Python evaluates the parts of\nthe equations). We then created variables to label values and used\nthose variables in our calculations.\nCalculations and Variables 23"
  },
  {
    "input": "What are the differences between strings, lists, tuples, and maps in Python, and how are they used to store and manipulate data?",
    "summary": "This chapter covers strings, lists, tuples, and maps in Python. Strings are used to store text and can include letters, numbers, and symbols. Lists and tuples store multiple items, with lists being mutable and tuples being immutable. Maps (dictionaries) store key-value pairs, allowing for efficient lookups and modifications. The chapter also explains how to handle string formatting, avoid syntax errors, and perform basic list operations like adding, removing, and joining items.",
    "output": "3\nstRInGs, LIsts,\ntUPLes, AnD MAPs\nIn Chapter 2, we did some basic calculations with\nPython, and you learned about variables. In this\nchapter, we’ll work with some other items in Python\nprograms: strings, lists, tuples, and maps. You’ll use\nstrings to display messages in your programs (such as\n“Get Ready” and “Game Over” messages in a game).\nYou’ll also discover how lists, tuples, and maps are\nused to store collections of things.\nstrings\nIn programming terms, we usually call text a string. When you\nthink of a string as a collection of letters, the term makes sense.\nAll the letters, numbers, and symbols in this book could be a string.\nFor that matter, your name could be a string, and so could your\naddress. In fact, the first Python pro-\ngram we created in Chapter 1 used a\nstring: “Hello World.”\nCreating strings\nIn Python, we create a string by put-\nting quotes around text. For example,\nwe could take our other wise useless\nfred variable from Chapter 2 and use it\nto label a string, like this:\nfred = \"Why do gorillas have big nostrils? Big fingers!!\"\nThen, to see what’s inside fred, we could enter print(fred),\nlike this:\n>>> print(fred)\nWhy do gorillas have big nostrils? Big fingers!!\nYou can also use single quotes to create a string, like this:\n>>> fred = 'What is pink and fluffy? Pink fluff!!'\n>>> print(fred)\nWhat is pink and fluffy? Pink fluff!!\nHowever, if you try to enter more than one line of text for your\nstring using only a single quote (') or double quote (\") or if you\nstart with one type of quote and try to finish with another, you’ll\nget an error message in the Python shell. For example, enter the\nfollowing line:\n>>> fred = \"How do dinosaurs pay their bills?\nYou’ll see this result:\nSyntaxError: EOL while scanning string literal\n26 Chapter 3\nThis is an error message complaining about syntax because\nyou did not follow the rules for ending a string with a single or\ndouble quote.\nSyntax means the arrangement and order of words in a sen-\ntence or, in this case, the arrangement and order of words and\nsymbols in a program. So SyntaxError means that you did some-\nthing in an order Python was not expecting, or Python was\nexpecting something that you missed. EOL means end-of-line,\nso the rest of the error message is telling you that Python hit the\nend of the line and did not find a double quote to close the string.\nTo use more than one line of text in your string (called a\nmultiline string), use three single quotes ('''), and then hit enter\nbetween lines, like this:\n>>> fred = '''How do dinosaurs pay their bills?\nWith tyrannosaurus checks!'''\nNow let’s print out the contents of fred to see if this worked:\n>>> print(fred)\nHow do dinosaurs pay their bills?\nWith tyrannosaurus checks!\nHandling Problems with strings\nNow consider this crazy example of a string, which causes Python\nto display an error message:\n>>> silly_string = 'He said, \"Aren't can't shouldn't wouldn't.\"'\nSyntaxError: invalid syntax\nIn the first line, we try to create a string (defined as the vari-\nable silly_string) enclosed by single quotes, but also containing a\nmixture of single quotes in the words can't, shouldn't, and wouldn't,\nas well as double quotes. What a mess!\nRemember that Python itself is not as smart as a human\nbeing, so all it sees is a string containing He said, \"Aren, followed\nby a bunch of other characters that it doesn’t expect. When Python\nsees a quotation mark (either a single or double quote), it expects a\nstring to start following the first mark and the string to end after\nthe next matching quotation mark (either single or double) on that\nline. In this case, the start of the string is the single quotation mark\nStrings, Lists, Tuples, and Maps 27\nbefore He, and the end of the string, as far as Python is concerned,\nis the single quote after the n in Aren. IDLE highlights the point\nwhere things have gone wrong:\nThe last line of IDLE tells us what sort of error occurred—in\nthis case, a syntax error.\nUsing double instead of single quotes still produces an error:\n>>> silly_string = \"He said, \"Aren't can't shouldn't wouldn't.\"\"\nSyntaxError: invalid syntax\nHere, Python sees a string bounded by double quotes, contain-\ning the letters He said, (and a space). Everything following that\nstring (from Aren't on) causes the error:\nThis is because, from Python’s perspective, all that extra stuff\njust isn’t supposed to be there. Python looks for the next matching\nquote and doesn’t know what you want it to do with anything that\nfollows that quote on the same line.\n28 Chapter 3\nThe solution to this prob-\nlem is a multiline string, which\nwe learned about earlier, using\nthree single quotes ('''), which\nallows us to combine double and\nsingle quotes in our string with-\nout causing errors. In fact, if we\nuse three single quotes, we can\nput any combination of single\nand double quotes inside the\nstring (as long as we don’t try to\nput three single quotes there).\nThis is what the error-free ver-\nsion of our string looks like:\nsilly_string = '''He said, \"Aren't can't shouldn't wouldn't.\"'''\nBut wait, there’s more. If you really want to use single or dou-\nble quotes to surround a string in Python, instead of three single\nquotes, you can add a backslash (\\) before each quotation mark\nwithin the string. This is called escaping. It’s a way of saying to\nPython, “Yes, I know I have quotes inside my string, and I want\nyou to ignore them until you see the end quote.”\nEscaping strings can make them harder to read, so it’s prob-\nably better to use multiline strings. Still, you might come across\nsnippets of code that use escaping, so it’s good to know why the\nbackslashes are there.\nHere are a few examples of how escaping works:\nu >>> single_quote_str = 'He said, \"Aren\\'t can\\'t shouldn\\'t wouldn\\'t.\"'\nv >>> double_quote_str = \"He said, \\\"Aren't can't shouldn't wouldn't.\\\"\"\n>>> print(single_quote_str)\nHe said, \"Aren't can't shouldn't wouldn't.\"\n>>> print(double_quote_str)\nHe said, \"Aren't can't shouldn't wouldn't.\"\nFirst, at u, we create a string with single quotes, using the\nbackslash in front of the single quotes inside that string. At v, we\ncreate a string with double quotes, and use the backslash in front\nof those quotes in the string. In the lines that follow, we print the\nvariables we’ve just created. Notice that the backslash character\ndoesn’t appear in the strings when we print them.\nStrings, Lists, Tuples, and Maps 29\nembedding Values in strings\nIf you want to display a message using the contents of a vari-\nable, you can embed values in a string using %s, which is like a\nmarker for a value that you want to add later. (Embedding values\nis programmer-speak for “inserting values.”) For example, to have\nPython calculate or store the number of points you scored in a\ngame, and then add it to a sentence like “I scored points,” use\n%s in the sentence in place of the value, and then tell Python that\nvalue, like this:\n>>> myscore = 1000\n>>> message = 'I scored %s points'\n>>> print(message % myscore)\nI scored 1000 points\nHere, we create the variable myscore with the value 1000 and the\nvariable m essage with a string that contains the words “I scored %s\npoints,” where %s is a placeholder for the number of points. On the\nnext line, we call print(message) with the % symbol to tell Python to\nreplace %s with the value stored in the variable myscore. The result\nof printing this message is I scored 1000 points. We don’t need to\nuse a variable for the value. We could do the same example and\njust use print(message % 1000).\nWe can also pass in different values for the %s placeholder,\nusing different variables, as in this example:\n>>> joke_text = '%s: a device for finding furniture in the dark'\n>>> bodypart1 = 'Knee'\n>>> bodypart2 = 'Shin'\n>>> print(joke_text % bodypart1)\nKnee: a device for finding furniture in the dark\n>>> print(joke_text % bodypart2)\nShin: a device for finding furniture in the dark\nHere, we create three variables. The first,\njoke_text, includes the string with the %s marker.\nThe other variables are bodypart1 and bodypart2.\nWe can print the variable joke_text, and once\nagain use the % operator to replace it with the\ncontents of the variables bodypart1 and bodypart2\nto produce different messages.\n30 Chapter 3\nYou can also use more than one placeholder in a string,\nlike this:\n>>> nums = 'What did the number %s say to the number %s? Nice belt!!'\n>>> print(nums % (0, 8))\nWhat did the number 0 say to the number 8? Nice belt!!\nWhen using more than one placeholder, be sure to wrap the\nreplacement values in parentheses, as shown in the example. The\norder of the values is the order in which they’ll be used in the string.\nMultiplying strings\nWhat is 10 multiplied by 5? The answer is 50, of course. But\nwhat’s 10 multiplied by a? Here’s Python’s answer:\n>>> print(10 * 'a')\naaaaaaaaaa\nPython programmers might use this approach to line up strings\nwith a specific number of spaces when displaying messages in the\nshell, for example. How about printing a letter in the shell (select\nFile4New Window, and enter the following code):\nspaces = ' ' * 25\nprint('%s 12 Butts Wynd' % spaces)\nprint('%s Twinklebottom Heath' % spaces)\nprint('%s West Snoring' % spaces)\nprint()\nprint()\nprint('Dear Sir')\nprint()\nprint('I wish to report that tiles are missing from the')\nprint('outside toilet roof.')\nprint('I think it was bad wind the other night that blew them away.')\nprint()\nprint('Regards')\nprint('Malcolm Dithering')\nOnce you’ve typed the code into the shell window, select\nFile4Save As. Name your file myletter.py.\nStrings, Lists, Tuples, and Maps 31\nnote From now on, when you see Save As: somefilename.py above a chunk\nof code, you’ll know you need to select File4New Window, enter the\ncode into the window that appears, and then save it as we did in\nthis example.\nIn the first line of this example, we create the variable spaces\nby multiplying a space character by 25. We then use that variable\nin the next three lines to align the text to the right of the shell.\nYou can see the result of these print statements below:\nIn addition to using multiplication for alignment, we can also\nuse it to fill the screen with annoying messages. Try this example\nfor yourself:\n>>> print(1000 * 'snirt')\nLists Are More Powerful\nthan strings\n“Spider legs, toe of frog, eye of newt, bat wing,\nslug butter, and snake dandruff ” is not quite a\nnormal shopping list (unless you happen to be\na wizard), but we’ll use it as our first example\nof the differences between strings and lists.\n32 Chapter 3\nWe could store this list of items in the wizard_list variable using a\nstring like this:\n>>> wizard_list = 'spider legs, toe of frog, eye of newt, bat wing,\nslug butter, snake dandruff'\n>>> print(wizard_list)\nspider legs, toe of frog, eye of newt, bat wing, slug butter, snake\ndandruff\nBut we could also create a list, a somewhat magical kind of\nPython object that we can manipulate. Here’s what these items\nwould look like written as a list:\n>>> wizard_list = ['spider legs', 'toe of frog', 'eye of newt',\n'bat wing', 'slug butter', 'snake dandruff']\n>>> print(wizard_list)\n['spider legs', 'toe of frog', 'eye of newt', 'bat wing', 'slug\nbutter', 'snake dandruff']\nCreating a list takes a bit more typing than creating a string,\nbut a list is more useful than a string because it can be manipu-\nlated. For example, we could print the third item in the wizard_list\n(eye of newt) by entering its position in the list (called the index\nposition) inside square brackets ([]), like this:\n>>> print(wizard_list[2])\neye of newt\nHuh? Isn’t it the third item on the list? Yes, but lists start at\nindex position 0, so the first item in a list is 0, the second is 1, and\nthe third is 2. That may not make a lot of sense to humans, but it\ndoes to computers.\nWe can also change an item in a list much more easily than we\ncould in a string. Perhaps instead of eye of newt we needed a snail\ntongue. Here’s how we would do that with our list:\n>>> wizard_list[2] = 'snail tongue'\n>>> print(wizard_list)\n['spider legs', 'toe of frog', 'snail tongue', 'bat wing', 'slug\nbutter', 'snake dandruff']\nThis sets the item in index position 2, previously eye of newt,\nto snail tongue.\nStrings, Lists, Tuples, and Maps 33\nAnother option is to show a subset\nof the items in the list. We do this by\nusing a colon (:) inside square brack-\nets. For example, enter the following to\nsee the third to fifth items in a list (a\nbrilliant set of ingredients for a lovely\nsandwich):\n>>> print(wizard_list[2:5])\n['snail tongue', 'bat wing', 'slug butter']\nWriting [2:5] is the same as saying, “show the items from index\nposition 2 up to (but not including) index position 5”—or in other\nwords, items 2, 3, and 4.\nLists can be used to store all sorts of items, like numbers:\n>>> some_numbers = [1, 2, 5, 10, 20]\nThey can also hold strings:\n>>> some_strings = ['Which', 'Witch', 'Is', 'Which']\nThey might have mixtures of numbers and strings:\n>>> numbers_and_strings = ['Why', 'was', 6, 'afraid', 'of', 7,\n'because', 7, 8, 9]\n>>> print(numbers_and_strings)\n['Why', 'was', 6, 'afraid', 'of', 7, 'because', 7, 8, 9]\nAnd lists might even store other lists:\n>>> numbers = [1, 2, 3, 4]\n>>> strings = ['I', 'kicked', 'my', 'toe', 'and', 'it', 'is', 'sore']\n>>> mylist = [numbers, strings]\n>>> print(mylist)\n[[1, 2, 3, 4], ['I', 'kicked', 'my', 'toe', 'and', 'it', 'is', 'sore']]\nThis list-within-list example creates three variables: numbers with\nfour numbers, strings with eight strings, and mylist using numbers\nand strings. The third list (mylist) has only two elements because\nit’s a list of variable names, not the contents of the variables.\n34 Chapter 3\nAdding Items to a List\nTo add items to a list, we use the append function. A function is a\nchunk of code that tells Python to do something. In this case, append\nadds an item to the end of a list.\nFor example, to add a bear burp (I’m sure there is such a\nthing) to the wizard’s shopping list, do this:\n>>> wizard_list.append('bear burp')\n>>> print(wizard_list)\n['spider legs', 'toe of frog', 'snail tongue', 'bat wing', 'slug\nbutter', 'snake dandruff', 'bear burp']\nYou can keep adding more magical items to the wizard’s list in\nthe same way, like so:\n>>> wizard_list.append('mandrake')\n>>> wizard_list.append('hemlock')\n>>> wizard_list.append('swamp gas')\nNow the wizard’s list looks like this:\n>>> print(wizard_list)\n['spider legs', 'toe of frog', 'snail tongue', 'bat wing', 'slug\nbutter', 'snake dandruff', 'bear burp', 'mandrake', 'hemlock', 'swamp\ngas']\nThe wizard is clearly ready to work some serious magic!\nRemoving Items from a List\nTo remove items from a list, use the del command (short for delete).\nFor example, to remove the sixth item in the wizard’s list, snake\ndandruff, do this:\n>>> del wizard_list[5]\n>>> print(wizard_list)\n['spider legs', 'toe of frog', 'snail tongue', 'bat wing', 'slug\nbutter', 'bear burp', 'mandrake', 'hemlock', 'swamp gas']\nnote Remember that positions start at zero, so wizard_list[5] actually\nrefers to the sixth item in the list.\nStrings, Lists, Tuples, and Maps 35\nAnd here’s how to remove the items we just added (mandrake,\nhemlock, and swamp gas):\n>>> del wizard_list[8]\n>>> del wizard_list[7]\n>>> del wizard_list[6]\n>>> print(wizard_list)\n['spider legs', 'toe of frog', 'snail tongue', 'bat wing', 'slug\nbutter', 'bear burp']\nList Arithmetic\nWe can join lists by adding them, just like adding numbers, using\na plus (+) sign. For example, suppose we have two lists: list1, con-\ntaining the numbers 1 through 4, and list2, containing some words.\nWe can add them using print and the + sign, like so:\n>>> list1 = [1, 2, 3, 4]\n>>> list2 = ['I', 'tripped', 'over', 'and', 'hit', 'the', 'floor']\n>>> print(list1 + list2)\n[1, 2, 3, 4, 'I', 'tripped', 'over', 'and', 'hit', 'the', 'floor']\nWe can also add the two lists and set the result equal to\nanother variable.\n>>> list1 = [1, 2, 3, 4]\n>>> list2 = ['I', 'ate', 'chocolate', 'and', 'I', 'want', 'more']\n>>> list3 = list1 + list2\n>>> print(list3)\n[1, 2, 3, 4, 'I', 'ate', 'chocolate', 'and', 'I', 'want', 'more']\nAnd we can multiply a list by a number. For example, to multi-\nply list1 by 5, we write list1 * 5:\n>>> list1 = [1, 2]\n>>> print(list1 * 5)\n[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\nThis is actually telling Python to repeat list1 five times,\nresulting in 1, 2, 1, 2, 1, 2, 1, 2, 1, 2.\n36 Chapter 3\nOn the other hand, division (/) and subtraction (-) give only\nerrors, as in these examples:\n>>> list1 / 20\nTraceback (most recent call last):\nFile \"<pyshell>\", line 1, in <module>\nlist1 / 20\nTypeError: unsupported operand type(s) for /: 'list' and 'int'\n>>> list1 - 20\nTraceback (most recent call last):\nFile \"<pyshell>\", line 1, in <module>\nlist1 - 20\nTypeError: unsupported operand type(s) for -: 'list' and 'int'\nBut why? Well, joining lists with + and repeating lists with *\nare straightforward enough operations. These concepts also make\nsense in the real world. For example, if I were to hand you two\npaper shopping lists and say, “Add these two lists,” you might write\nout all the items on another sheet of paper in order, end to end. The\nsame might be true if I said, “Multiply this list by 3.” You could\nimagine writing a list of all of the list’s items three times on another\nsheet of paper.\nBut how would you divide a list? For example, consider how\nyou would divide a list of six numbers (1 through 6) in two. Here\nare just three different ways:\n[1, 2, 3] [4, 5, 6]\n[1] [2, 3, 4, 5, 6]\n[1, 2, 3, 4] [5, 6]\nWould we divide the list in the middle,\nsplit it after the first item, or just pick some\nrandom place and divide it there? There’s no\nsimple answer, and when you ask Python to\ndivide a list, it doesn’t know what to do, either.\nThat’s why it responds with an error.\nStrings, Lists, Tuples, and Maps 37\nThe same goes for adding anything other than a list to a list.\nYou can’t do that either. For example, here’s what happens when\nwe try to add the number 50 to list1:\n>>> list1 + 50\nTraceback (most recent call last):\nFile \"<pyshell>\", line 1, in <module>\nlist1 + 50\nTypeError: can only concatenate list (not \"int\") to list\nWhy do we get an error here? Well, what does it mean to add\n50 to a list? Does it mean add 50 to each item? But what if the\nitems aren’t numbers? Does it mean add the number 50 to the end\nor beginning of the list?\nIn computer programming, commands should work in exactly\nthe same way every time you enter them. That dumb computer\nsees things only in black and white. Ask it to make a complicated\ndecision, and it throws up its hands with errors.\ntuples\nA tuple is like a list that uses parentheses, as in this example:\n>>> fibs = (0, 1, 1, 2, 3)\n>>> print(fibs[3])\n2\nHere we define the variable fibs as the numbers 0, 1, 1, 2, and\n3. Then, as with a list, we print the item in index position 3 in the\ntuple using print(fibs[3]).\nThe main difference between a tuple and a list is that a tuple\ncannot change once you’ve created it. For example, if we try to\nreplace the first value in the tuple fibs with the number 4 ( just as\nwe replaced values in our wizard_list), we get an error message:\n>>> fibs[0] = 4\nTraceback (most recent call last):\nFile \"<pyshell>\", line 1, in <module>\nfibs[0] = 4\nTypeError: 'tuple' object does not support item assignment\n38 Chapter 3\nWhy would you use a tuple instead of a list? Basically because\nsometimes it is useful to use something that you know can never\nchange. If you create a tuple with two elements inside, it will\nalways have those two elements inside.\nPython Maps Won’t Help You find\nYour Way\nIn Python, a map (also referred to as a dict, short for dictionary) is\na collection of things, like lists and tuples. The difference between\nmaps and lists or tuples is that each item in a map has a key and a\ncorresponding value.\nFor example, say we have a list of people and their favorite\nsports. We could put this information into a Python list, with the\nperson’s name followed by their sport, like so:\n>>> favorite_sports = ['Ralph Williams, Football',\n'Michael Tippett, Basketball',\n'Edward Elgar, Baseball',\n'Rebecca Clarke, Netball',\n'Ethel Smyth, Badminton',\n'Frank Bridge, Rugby']\nIf I asked you what Rebecca Clarke’s favorite\nsport is, you could skim through that list and find\nthe answer is netball. But what if the list included\n100 (or many more) people?\nNow, if we store this same information in a\nmap, with the person’s name as the key and their\nfavorite sport as the value, the Python code would\nlook like this:\n>>> favorite_sports = {'Ralph Williams' : 'Football',\n'Michael Tippett' : 'Basketball',\n'Edward Elgar' : 'Baseball',\n'Rebecca Clarke' : 'Netball',\n'Ethel Smyth' : 'Badminton',\n'Frank Bridge' : 'Rugby'}\nWe use colons to separate each key from its value, and each\nkey and value is surrounded by single quotes. Notice, too, that\nthe items in a map are enclosed in braces ({}), not parentheses or\nsquare brackets.\nStrings, Lists, Tuples, and Maps 39\nThe result is a map (each key maps to a particular value), as\nshown in Table 3-1.\nTable 3-1: Keys Pointing to Values in a Map of Favorite Sports\nKey Value\nRalph Williams Football\nMichael Tippett Basketball\nEdward Elgar Baseball\nRebecca Clarke Netball\nEthel Smyth Badminton\nFrank Bridge Rugby\nNow, to get Rebecca Clarke’s favorite sport, we access our map\nfavorite_sports using her name as the key, like so:\n>>> print(favorite_sports['Rebecca Clarke'])\nNetball\nAnd the answer is netball.\nTo delete a value in a map, use its key. For example, here’s how\nto remove Ethel Smyth:\n>>> del favorite_sports['Ethel Smyth']\n>>> print(favorite_sports)\n{'Rebecca Clarke': 'Netball', 'Michael Tippett': 'Basketball', 'Ralph\nWilliams': 'Football', 'Edward Elgar': 'Baseball', 'Frank Bridge':\n'Rugby'}\nTo replace a value in a map, we also use its key:\n>>> favorite_sports['Ralph Williams'] = 'Ice Hockey'\n>>> print(favorite_sports)\n{'Rebecca Clarke': 'Netball', 'Michael Tippett': 'Basketball', 'Ralph\nWilliams': 'Ice Hockey', 'Edward Elgar': 'Baseball', 'Frank Bridge':\n'Rugby'}\nWe replace the favorite sport of Football with Ice Hockey by\nusing the key Ralph Williams.\n40 Chapter 3\nAs you can see, working with maps is kind of like working with\nlists and tuples, except that you can’t join maps with the plus oper-\nator (+). If you try to do that, you’ll get an error message:\n>>> favorite_sports = {'Rebecca Clarke': 'Netball',\n'Michael Tippett': 'Basketball',\n'Ralph Williams': 'Ice Hockey',\n'Edward Elgar': 'Baseball',\n'Frank Bridge': 'Rugby'}\n>>> favorite_colors = {'Malcolm Warner' : 'Pink polka dots',\n'James Baxter' : 'Orange stripes',\n'Sue Lee' : 'Purple paisley'}\n>>> favorite_sports + favorite_colors\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: unsupported operand type(s) for +: 'dict' and 'dict'\nJoining maps doesn’t make sense to Python, so it just throws\nup its hands.\nWhat You Learned\nIn this chapter, you learned how Python uses strings to store text,\nand how it uses lists and tuples to handle multiple items. You saw\nthat the items in lists can be changed, and that you can join one\nlist to another list, but that the values in a tuple cannot change.\nYou also learned how to use maps to store values with keys that\nidentify them.\nProgramming Puzzles\nThe following are a few experiments you can try yourself. The\nanswers can be found at http://python-for-kids.com/.\n#1: favorites\nMake a list of your favorite hobbies and give the list the variable\nname games. Now make a list of your favorite foods and name the\nvariable foods. Join the two lists and name the result favorites.\nFinally, print the variable favorites.\nStrings, Lists, Tuples, and Maps 41\n#2: Counting Combatants\nIf there are 3 buildings with 25 ninjas hiding on each roof and\n2 tunnels with 40 samurai hiding inside each tunnel, how many\nninjas and samurai are about to do battle? (You can do this with\none equation in the Python shell.)\n#3: Greetings!\nCreate two variables: one that points to your first name and\none that points to your last name. Now create a string and use\nplaceholders to print your name with a message using those two\nvariables, such as “Hi there, Brando Ickett!”\n42 Chapter 3"
  },
  {
    "input": "What is the purpose of the turtle module in Python and how does it help in learning computer graphics?",
    "summary": "The Python turtle is a simple tool for drawing graphics, resembling a slow-moving arrow that leaves a trail. This chapter explains how to use the turtle module to draw shapes and lines, and how to control the turtle's movement with commands like forward, left, and right. It also covers using the turtle to draw two parallel lines by moving it backward, lifting the pen, turning, and then putting it back down. \n\nThe chapter then moves on to discuss if statements, which allow programmers to make decisions based on conditions. It explains how to use if, elif, and else statements to handle different scenarios, and how to combine conditions with the and and or keywords. Additionally, it covers how to handle user input, converting strings to numbers using int, str, and float functions.\n\nFinally, the chapter introduces loops, specifically for loops and while loops, which are used to repeat tasks automatically. It demonstrates how to use for loops to iterate over lists and how to use while loops for repeated actions until a certain condition is met. The break keyword is also introduced to exit loops when a specific condition is satisfied.",
    "output": "4\nDRAWInG WItH tURtLes\nA turtle in Python is sort of like a turtle in the real\nworld. We know a turtle as a reptile that moves around\nvery slowly and carries its house on its back. In the\nworld of Python, a turtle is a small, black arrow that\nmoves slowly around the screen. Actually, considering\nthat a Python turtle leaves a trail as it moves around\nthe screen, it’s actually less like a turtle and more like\na snail or a slug.\nThe turtle is a nice way to learn some of the basics\nof computer graphics, so in this chapter, we’ll use a\nPython turtle to draw some simple shapes and lines.\nUsing Python’s turtle Module\nA module in Python is a way of\nproviding useful code to be used\nby another program (among other\nthings, the module can contain\nfunctions we can use). We’ll learn\nmore about modules in Chapter 7.\nPython has a special module called\nturtle that we can use to learn\nhow computers draw pictures on a\nscreen. The turtle module is a way\nof programming vector graphics,\nwhich is basically just drawing\nwith simple lines, dots, and curves.\nLet’s see how the turtle works. First, start the Python shell\nby clicking the desktop icon (or if you’re using Ubuntu, select\nApplications4Programming4IDLE). Next, tell Python to\nuse the turtle by importing the turtle module, as follows:\n>>> import turtle\nImporting a module tells Python that you want to use it.\nnote If you’re using Ubuntu and you get an error at this point, you might\nneed to install tkinter. To do so, open the Ubuntu Software Center\nand enter python-tk in the search box. “Tkinter – Writing Tk Appli-\ncations with Python” should appear in the window. Click Install to\ninstall this package.\nCreating a Canvas\nNow that we have imported the turtle module, we need to create a\ncanvas—a blank space to draw on, like an artist’s canvas. To do so,\nwe call the function Pen from the turtle module, which automati-\ncally creates a canvas. Enter this into the Python shell:\n>>> t = turtle.Pen()\n44 Chapter 4\nYou should see a blank box (the canvas), with an arrow in the\ncenter, something like this:\nThe arrow in the middle of the screen is the turtle, and you’re\nright—it isn’t very turtle-like.\nIf the Turtle window appears behind the Python Shell window,\nyou may find that it doesn’t seem to be working properly. When you\nmove your mouse over the Turtle window, the cursor turns into an\nhourglass, like this:\nThis could happen for several reasons: you haven’t started the\nshell from the icon on your desktop (if you’re using Windows or a\nMac), you clicked IDLE (Python GUI) in the Windows Start menu,\nDrawing with Turtles 45\nor IDLE isn’t installed correctly. Try exiting and restarting the\nshell from the desktop icon. If that fails, try using the Python con-\nsole instead of the shell, as follows:\n• In Windows, select Start4All Programs, and then in the\nPython 3.2 group, click Python (command line).\n• In Mac OS X, click the Spotlight icon at the top-right corner\nof the screen and enter Terminal in the input box. Then enter\npython when the terminal opens.\n• In Ubuntu, open the terminal from your Applications menu\nand enter python.\nMoving the turtle\nYou send instructions to the\nturtle by using functions\navailable on the variable t\nwe just created, similar to\nusing the Pen function in the\nturtle module. For example,\nthe forward instruction tells the turtle to move forward. To tell the\nturtle to advance 50 pixels, enter the following command:\n>>> t.forward(50)\nYou should see something like this:\n46 Chapter 4\nThe turtle has moved forward 50 pixels. A pixel is a single\npoint on the screen—the smallest element that can be represented.\nEverything you see on your computer monitor is made up of pixels,\nwhich are tiny, square dots. If you could zoom in on the canvas\nand the line drawn by the turtle, you would be able to see that\nthe arrow representing the turtle’s path is just a bunch of pixels.\nThat’s simple computer graphics.\nDots!\nNow we’ll tell the turtle to turn left 90 degrees with the follow-\ning command:\n>>> t.left(90)\nIf you haven’t learned about degrees yet, here’s how to think\nabout them. Imagine that you’re standing in the center of a circle.\n• The direction you’re facing is 0 degrees.\n• If you hold out your left arm, that’s 90 degrees left.\n• If you hold out your right arm, that’s 90 degrees right.\nYou can see this 90-degree turn to the left or right here:\n0\n90˚ 90˚\nleft right\nDrawing with Turtles 47\nIf you continue around the circle to the right from where\nyour right arm is pointing, 180 degrees is directly behind you,\n270 degrees is the direction your left arm is pointing, and\n360 degrees is back where you started; degrees go from 0 to 360.\nThe degrees in a full circle, when turning to the right, can be seen\nhere in 45-degree increments:\n0\n315 45\n270 90\n225 135\n180\nWhen Python’s turtle turns left, it swivels around to face the\nnew direction (just as if you turned your body to face where your\narm is pointing 90 degrees left).\nThe t.left(90) command points the arrow up (since it started\nby pointing to the right):\nnote When you call t.left(90), it’s the same as calling t.right(270). This\nis also true of calling t.right(90), which is the same as t.left(270).\nJust imagine that circle and follow along with the degrees.\nNow we’ll draw a square. Add the following code to the lines\nyou’ve already entered:\n>>> t.forward(50)\n>>> t.left(90)\n48 Chapter 4\n>>> t.forward(50)\n>>> t.left(90)\n>>> t.forward(50)\n>>> t.left(90)\nYour turtle should have drawn a square and should now be\nfacing in the same direction it started:\nTo erase the canvas, enter reset. This clears the canvas and\nputs the turtle back at its starting position.\n>>> t.reset()\nYou can also use clear, which just clears the screen and leaves\nthe turtle where it is.\n>>> t.clear()\nWe can also turn our turtle right or move it backward. We can\nuse up to lift the pen off the page (in other words, tell the turtle to\nstop drawing), and down to start drawing. These functions are writ-\nten in the same way as the others we’ve used.\nLet’s try another drawing using some of these commands. This\ntime, we’ll have the turtle draw two lines. Enter the following code:\n>>> t.reset()\n>>> t.backward(100)\n>>> t.up()\n>>> t.right(90)\nDrawing with Turtles 49\n>>> t.forward(20)\n>>> t.left(90)\n>>> t.down()\n>>> t.forward(100)\nFirst, we reset the can-\nvas and move the turtle back\nto its starting position with\nt.reset(). Next, we move the\nturtle backward 100 pixels with\nt.backward(100), and then use\nt.up() to pick up the pen and\nstop drawing.\nThen, with the command\nt.right(90), we turn the turtle\nright 90 degrees to point down,\ntoward the bottom of the screen,\nand with t.forward(20), we move\nforward 20 pixels. Nothing is drawn because of the use of up com-\nmand on the third line. We turn the turtle left 90 degrees to face\nright with t.left(90), and then with the down command, we tell the\nturtle to put the pen back down and start drawing again. Finally,\nwe draw a line forward, parallel to the first line we drew, with\nt.forward(100). The two parallel lines we’ve drawn end up looking\nlike this:\n50 Chapter 4\nWhat You Learned\nIn this chapter, you learned how to use Python’s turtle module.\nWe drew some simple lines, using left and right turns and forward\nand backward commands. You found out how to stop the turtle from\ndrawing using up, and start drawing again with down. You also dis-\ncovered that the turtle turns by degrees.\nProgramming Puzzles\nTry drawing some of the following shapes with the turtle. The\nanswers can be found at http://python-for-kids.com/.\n#1: A Rectangle\nCreate a new canvas using the turtle module’s Pen function and\nthen draw a rectangle.\n#2: A triangle\nCreate another canvas, and this time, draw a triangle. Look back\nat the diagram of the circle with the degrees (“Moving the Turtle”\non page 46) to remind yourself which direction to turn the turtle\nusing degrees.\n#3: A Box Without Corners\nWrite a program to draw the four lines shown here (the size isn’t\nimportant, just the shape):\nDrawing with Turtles 51\n5\nAsKInG QUestIons\nWItH I f AnD eLse\nIn programming, we often ask yes or no questions, and\ndecide to do something based on the answer. For exam-\nple, we might ask, “Are you older than 20?” and if the\nanswer is yes, respond with “You are too old!”\nThese sorts of questions are called conditions, and\nwe combine these conditions and the responses into if\nstatements. Conditions can be more complicated than\na single question, and if statements can also be com-\nbined with multiple questions and different responses\nbased on the answer to each question.\nIn this chapter, you’ll learn how to use if statements to build\nprograms.\nIf statements\nAn if statement might be written in Python like this:\n>>> age = 13\n>>> if age > 20:\nprint('You are too old!')\nAn if statement is\nmade up of the if keyword,\nfollowed by a condition and\na colon (:), as in if age > 20:.\nThe lines following the colon\nmust be in a block, and if\nthe answer to the question\nis yes (or true, as we say in\nPython programming), the\ncommands in the block will\nbe run. Now, let’s explore\nhow to write blocks and\nconditions.\nA Block Is a Group of Programming\nstatements\nA block of code is a grouped set of programming statements. For\nexample, when if age > 20: is true, you might want to do more\nthan just print “You are too old!” Perhaps you want to print out\na few other choice sentences, like this:\n>>> age = 25\n>>> if age > 20:\nprint('You are too old!')\nprint('Why are you here?')\nprint('Why aren\\'t you mowing a lawn or sorting papers?')\n54 Chapter 5\nThis block of code is made up of three print statements that\nare run only if the condition age > 20 is found to be true. Each line\nin the block has four spaces at the beginning, when you compare it\nwith the if statement above it. Let’s look at that code again, with\nvisible spaces:\n>>> age = 25\n>>> if age > 20:\n▯▯▯▯print('You are too old!')\n▯▯▯▯print('Why are you here?')\n▯▯▯▯print('Why aren\\'t you mowing a lawn or sorting papers?')\nIn Python, whitespace, such as a tab (inserted when you press\nthe tab key) or a space (inserted when you press the spacebar), is\nmeaningful. Code that is at the same position (indented the same\nnumber of spaces from the left margin) is grouped into a block, and\nwhenever you start a new line with more spaces than the previous\none, you are starting a new block that is part of the previous one,\nlike this:\nline of code block 1\nline of code\nline of code\nline of code block 2\nline of code\nline of code\nline of code block 3\nline of code\nline of code\nline of code\nline of code\nWe group statements together into blocks because they are\nrelated. The statements need to be run together.\nWhen you change the indentation, you’re generally creating\nnew blocks. The following example shows three separate blocks\nthat are created just by changing the indentation.\nAsking Questions with if and else 55\nline of code block 1\nline of code\nline of code\nline of code block 2\nline of code\nline of code\nline of code\nline of code\nline of code\nline of code block 3\nline of code\nline of code\nHere, even though blocks 2 and 3 have the same indentation,\nthey are considered different blocks because there is a block with\nless indentation (fewer spaces) between them.\nFor that matter, a block with four spaces on one line and six\nspaces on the next will produce an indentation error when you run\nit, because Python expects you to use the same number of spaces\nfor all the lines in a block. So if you start a block with four spaces,\nyou should consistently use four spaces for that block. Here’s an\nexample:\n>>> if age > 20:\n▯▯▯▯print('You are too old!')\n▯▯▯▯▯▯print('Why are you here?')\nI’ve made the spaces visible so that you can see the differences.\nNotice that the third line has six spaces instead of four.\nWhen we try to run this code, IDLE highlights the line where\nit sees a problem with a red block and displays an explanatory\nS yntaxError message:\n>>> age = 25\n>>> if age > 20:\nprint('You are too old!')\nprint('Why are you here?')\nSyntaxError: unexpected indent\nPython didn’t expect to see two extra spaces at the beginning\nof the second print line.\n56 Chapter 5\nnote Use consistent spacing to make your code easier to read. If you start\nwriting a program and put four spaces at the beginning of a block,\nkeep using four spaces at the beginning of the other blocks in your\nprogram. Also, be sure to indent each line in the same block with\nthe same number of spaces.\nConditions Help Us Compare things\nA condition is a programming statement that compares things and\ntells us whether the criteria set by the comparison are either True\n(yes) or False (no). For example, age > 10 is a condition, and is another\nway of saying, “Is the value of the age variable greater than 10?”\nThis is also a condition: hair_color == 'mauve', which is another way\nof saying, “Is the value of the hair_color variable mauve?”\nWe use symbols in Python (called operators) to create our con-\nditions, such as equal to, greater than, and less than. Table 5-1\nlists some symbols for conditions.\nTable 5-1: Symbols for Conditions\nSymbol Definition\n== Equal to\n!= Not equal to\n> Greater than\n< Less than\n>= Greater than or equal to\n<= Less than or equal to\nFor example, if you are 10 years old, the condition your_age == 10\nwould return True; otherwise, it would return False. If you are\n12 years old, the condition your_age > 10 would return True.\nWarning Be sure to use a double equal sign (==) when defining an equal-to\ncondition.\nLet’s try a few more examples. Here, we set our age as equal to\n10 and then write a conditional statement that will print “You are\ntoo old for my jokes!” if age is greater than 10:\n>>> age = 10\n>>> if age > 10:\nprint('You are too old for my jokes!')\nAsking Questions with if and else 57\nWhat happens when we type this into\nIDLE and press enter?\nNothing.\nBecause the value returned by age is not\ngreater than 10, Python does not execute\n(run) the print block. However, if we had set\nthe variable age to 20, the message would be\nprinted.\nNow let’s change the previous example\nto use a greater-than-or-equal-to (>=)\ncondition:\n>>> age = 10\n>>> if age >= 10:\nprint('You are too old for my jokes!')\nYou should see “You are too old for my jokes!” printed to the\nscreen because the value of age is equal to 10.\nNext, let’s try using an equal-to (==) condition:\n>>> age = 10\n>>> if age == 10:\nprint('What\\'s brown and sticky? A stick!!')\nYou should see the message “What’s brown and sticky? A\nstick!!” printed to the screen.\nIf-then-else statements\nIn addition to using if statements to do something when a condi-\ntion is met (True), we can also use if statements to do something\nwhen a condition is not true. For example, we might print one mes-\nsage to the screen if your age is 12 and another if it’s not 12 (False).\nThe trick here is to use an if-then-else statement, which essen-\ntially says “If something is true, then do this; or else, do that.”\nLet’s create an if-then-else statement. Enter the following into\nthe shell:\n>>> print(\"Want to hear a dirty joke?\")\nWant to hear a dirty joke?\n58 Chapter 5\n>>> age = 12\n>>> if age == 12:\nprint(\"A pig fell in the mud!\")\nelse:\nprint(\"Shh. It's a secret.\")\nA pig fell in the mud!\nBecause we’ve set the age vari-\nable to 12, and the condition is\nasking whether age is equal to\n12, you should see the first print\nmessage on the screen. Now try\nchanging the value of age to a num-\nber other than 12, like this:\n>>> print(\"Want to hear a dirty joke?\")\nWant to hear a dirty joke?\n>>> age = 8\n>>> if age == 12:\nprint(\"A pig fell in the mud!\")\nelse:\nprint(\"Shh. It's a secret.\")\nShh. It's a secret.\nThis time, you should see the second print message.\nif and elif statements\nWe can extend an if statement even further with elif (which is\nshort for else-if). For example, we can check if a person’s age is 10,\n11, or 12 (and so on) and have our program do something different\nbased on the answer. These statements are different from if-then-\nelse statements in that there can be more than one elif in the\nsame statement:\n>>> age = 12\nu >>> if age == 10:\nv print(\"What do you call an unhappy cranberry?\")\nprint(\"A blueberry!\")\nAsking Questions with if and else 59\nw elif age == 11:\nprint(\"What did the green grape say to the blue grape?\")\nprint(\"Breathe! Breathe!\")\nx elif age == 12:\ny print(\"What did 0 say to 8?\")\nprint(\"Hi guys!\")\nelif age == 13:\nprint(\"Why wasn't 10 afraid of 7?\")\nprint(\"Because rather than eating 9, 7 8 pi.\")\nelse:\nprint(\"Huh?\")\nWhat did 0 say to 8? Hi guys!\nIn this example, the if statement on the second line checks\nto see if the value of the age variable is equal to 10 at u. The print\nstatement that follows at v is run if age is equal to 10. However,\nsince we’ve set age equal to 12, the computer jumps to the next if\nstatement at w and checks if the value of age is equal to 11. It isn’t,\nso the computer jumps to the next if statement at x to see if age\nis equal to 12. It is, so this time, the computer executes the print\ncommand at y.\nWhen you enter this code in the IDLE, it will automatically\nindent, so be sure to press the backspace or delete key once you’ve\ntyped each print statement, so that your if, elif, and else state-\nments will start at the far-left margin. This is the same position\nthe if statement would be in if the prompt (>>>) were absent.\n60 Chapter 5\nCombining Conditions\nYou can combine conditions by using the keywords and and or, which\nproduces shorter and simpler code. Here’s an example of using or:\n>>> if age == 10 or age == 11 or age == 12 or age == 13:\nprint('What is 13 + 49 + 84 + 155 + 97? A headache!')\nelse:\nprint('Huh?')\nIn this code, if any of the conditions on the first line are true\n(in other words, if age is 10, 11, 12, or 13), the block of code on the\nnext line beginning with print will run.\nIf the conditions in the first line are not true (else), Python\nmoves to the block in the last line, displaying Huh? on the screen.\nTo shrink this example even further, we could use the and\nkeyword, along with the greater than or equal-to operator (>=)\nand less-than-or-equal-to operator (<=), as follows:\n>>> if age >= 10 and age <= 13:\nprint('What is 13 + 49 + 84 + 155 + 97? A headache!')\nelse:\nprint('Huh?')\nHere, if age is greater than or\nequal to 10 and less than or equal\nto 13, as defined on the first line\nwith if age >= 10 and age <= 13:, the\nblock of code beginning with print\non the following line will run. For\nexample, if the value of age is 12,\nthen What is 13 + 49 + 84 + 155 + 97?\nA headache! will be printed to the\nscreen, because 12 is more than 10\nand less than 13.\nVariables with no Value—none\nJust as we can assign numbers, strings, and lists to a variable,\nwe can also assign nothing, or an empty value, to a variable. In\nPython, an empty value is referred to as None, and it is the absence\nof value. And it’s important to note that the value None is different\nAsking Questions with if and else 61\nfrom the value 0 because it is the absence of a value, rather than a\nnumber with a value of 0. The only value that a variable has when\nwe give it the empty value None is nothing. Here’s an example:\n>>> myval = None\n>>> print(myval)\nNone\nAssigning a value of None to a variable is one way to reset it\nto its original, empty state. Setting a variable to None is also a\nway to define a variable without setting its value. You might do\nthis when you know you’re going to need a variable later in your\nprogram, but you want to define all your variables at the begin-\nning. Programmers often define their variables at the beginning\nof a program because placing them there makes it easy to see the\nnames of all the variables used by a chunk of code.\nYou can check for None in an if statement as well, as in the fol-\nlowing example:\n>>> myval = None\n>>> if myval == None:\nprint(\"The variable myval doesn't have a value\")\nThe variable myval doesn't have a value\nThis is useful when you only want to calculate a value for a\nvariable if it hasn’t already been calculated.\nthe Difference Between strings and\nnumbers\nUser input is what a person enters on the keyboard—whether\nthat’s a character, a pressed arrow or enter key, or anything else.\nUser input comes into Python as a string, which means that when\nyou type the number 10 on your keyboard, Python saves the num-\nber 10 into a variable as a string, not a number.\nWhat’s the difference between the number 10 and the string\n'10'? Both look the same to us, with the only difference being that\none is surrounded by quotes. But to a computer, the two are very\ndifferent.\n62 Chapter 5\nFor example, suppose that we compare the value of the vari-\nable age to a number in an if statement, like this:\n>>> if age == 10:\nprint(\"What's the best way to speak to a monster?\")\nprint(\"From as far away as possible!\")\nThen we set the variable age to the number 10:\n>>> age = 10\n>>> if age == 10:\nprint(\"What's the best way to speak to a monster?\")\nprint(\"From as far away as possible!\")\nWhat's the best way to speak to a monster?\nFrom as far away as possible!\nAs you can see, the print statement executes.\nNext, we set age to the string '10' (with quotes), like this:\n>>> age = '10'\n>>> if age == 10:\nprint(\"What's the best way to speak to a monster?\")\nprint(\"From as far away as possible!\")\nHere, the code in the print\nstatement doesn’t run because\nPython doesn’t see the number in\nquotes (a string) as a number.\nFortunately, Python has magic\nfunctions that can turn strings\ninto numbers and numbers into\nstrings. For example, you can con-\nvert the string '10' into a number\nwith int:\n>>> age = '10'\n>>> converted_age = int(age)\nThe variable converted_age would now hold the number 10.\nAsking Questions with if and else 63\nTo convert a number into a string, use str:\n>>> age = 10\n>>> converted_age = str(age)\nIn this case, converted_age would hold the string 10 instead of\nthe number 10.\nRemember that if age == 10 statement that didn’t print any-\nthing when the variable was set to a string (age = '10')? If we\nconvert the variable first, we get an entirely different result:\n>>> age = '10'\n>>> converted_age = int(age)\n>>> if converted_age == 10:\nprint(\"What's the best way to speak to a monster?\")\nprint(\"From as far away as possible!\")\nWhat's the best way to speak to a monster?\nFrom as far away as possible!\nBut hear this: If you try to convert a number with a decimal\npoint, you’ll get an error because the int function expects an integer.\n>>> age = '10.5'\n>>> converted_age = int(age)\nTraceback (most recent call last):\nFile \"<pyshell#35>\", line 1, in <module>\nconverted_age = int(age)\nValueError: invalid literal for int() with base 10: '10.5'\nA ValueError is what Python uses to tell you that the value you\nhave tried to use isn’t appropriate. To fix this, use the function\nfloat instead of int. The float function can handle numbers that\naren’t integers.\n>>> age = '10.5'\n>>> converted_age = float(age)\n>>> print(converted_age)\n10.5\nYou will also get a ValueError if you try to convert a string that\ndoesn’t contain a number in digits:\n>>> age = 'ten'\n>>> converted_age = int(age)\nTraceback (most recent call last):\nFile \"<pyshell#1>\", line 1, in <module>\n64 Chapter 5\nconverted_age = int(age)\nValueError: invalid literal for int() with base 10: 'ten'\nWhat You Learned\nIn this chapter, you learned how to work with if statements to\ncreate blocks of code that are executed only when particular condi-\ntions are true. You saw how to extend if statements using elif so\nthat different sections of code will execute as a result of different\nconditions, and how to use the else keyword to execute code if none\nof the conditions turn out to be true. You also learned how to com-\nbine conditions using the and and or keywords so that you can see if\nnumbers fall in a range, and how to change strings into numbers\nwith int, str, and float. And you discovered that nothing (None) has\nmeaning in Python and can be used to reset variables to their ini-\ntial, empty state.\nProgramming Puzzles\nTry the following puzzles using if statement and conditions. The\nanswers can be found at http://python-for-kids.com/.\n#1: Are You Rich?\nWhat do you think the following code will do? Try to figure out\nthe answer without typing it into the shell, and then check your\nanswer.\n>>> money = 2000\n>>> if money > 1000:\nprint(\"I'm rich!!\")\nelse:\nprint(\"I'm not rich!!\")\nprint(\"But I might be later...\")\n#2: twinkies!\nCreate an if statement that checks whether a number of Twinkies\n(in the variable twinkies) is less than 100 or greater than 500. Your\nprogram should print the message “Too few or too many” if the\ncondition is true.\nAsking Questions with if and else 65\n#3: Just the Right number\nCreate an if statement that checks whether the amount of money\ncontained in the variable money is between 100 and 500 or between\n1,000 and 5,000.\n#4: I Can fight those ninjas\nCreate an if statement that prints the string “That’s too many”\nif the variable ninjas contains a number that’s less than 50, prints\n“It’ll be a struggle, but I can take ’em” if it’s less than 30, and\nprints “I can fight those ninjas!” if it’s less than 10. You might\ntry out your code with:\n>>> ninjas = 5\n66 Chapter 5\n6\nGoI nG LooPY\nNothing is worse than having to do the same thing over\nand over again. There’s a reason why some people count\nsheep when they’re having trouble falling asleep, and\nit has nothing to do with the amazing sleep-inducing\npowers of woolly mammals. It’s because endlessly\nrepeating something is boring, and your mind can\ndrop off to sleep more easily if you’re not focusing on\nsomething interesting.\nProgrammers don’t particularly like repeat-\ning themselves either, unless they’re also trying\nto fall asleep. Thankfully, most programming\nlanguages have what is called a for loop, which\nrepeats things like other programming state-\nments and blocks of code automatically.\nIn this chapter, we’ll look at for loops, as\nwell as another type of loop that Python offers:\nthe while loop.\nUsing for Loops\nTo print hello five times in Python, you could do the following:\n>>> print(\"hello\")\nhello\n>>> print(\"hello\")\nhello\n>>> print(\"hello\")\nhello\n>>> print(\"hello\")\nhello\n>>> print(\"hello\")\nhello\nBut this is rather tedious. Instead, you can use a for loop to\nreduce the amount of typing and repetition, like this:\nu >>> for x in range(0, 5):\nv print('hello')\nhello\nhello\nhello\nhello\nhello\nThe range function at u can be used to create a list of numbers\nranging from a starting number up to the number just before the\nending number. That may sound a little confusing. Let’s combine\nthe range function with the list function to see exactly how this\n68 Chapter 6\nworks. The range function doesn’t actually create a list of numbers;\nit returns an iterator, which is a type of Python object specially\ndesigned to work with loops. However, if we combine range with\nlist, we get a list of numbers.\n>>> print(list(range(10, 20)))\n[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\nIn the case of the for loop, the code at u is actually telling\nPython to do the following:\n• Start counting from 0 and stop before reaching 5.\n• For each number we count, store the value in the variable x.\nThen Python executes the block of code at v. Note that there\nare four additional spaces at the beginning of line v (when you\ncompare with line u). IDLE will have automatically indented this\nfor you.\nWhen we hit enter after the second line, Python prints “hello”\nfive times.\nWe could also use the x in our print statement to count the hellos:\n>>> for x in range(0, 5):\nprint('hello %s' % x)\nhello 0\nhello 1\nhello 2\nhello 3\nhello 4\nIf we get rid of the for loop again, our code might look some-\nthing like this:\n>>> x = 0\n>>> print('hello %s' % x)\nhello 0\n>>> x = 1\n>>> print('hello %s' % x)\nhello 1\n>>> x = 2\n>>> print('hello %s' % x)\nhello 2\nGoing Loopy 69\n>>> x = 3\n>>> print('hello %s' % x)\nhello 3\n>>> x = 4\n>>> print('hello %s' % x)\nhello 4\nSo using the loop has actually saved us from writing eight\nextra lines of code. Good programmers hate doing things more\nthan once, so the for loop is one of the more popular statements\nin a programming language.\nYou don’t need to stick to using the range and list functions\nwhen making for loops. You could also use a list you’ve already\ncreated, such as the shopping list from Chapter 3, as follows:\n>>> wizard_list = ['spider legs', 'toe of frog', 'snail tongue',\n'bat wing', 'slug butter', 'bear burp']\n>>> for i in wizard_list:\nprint(i)\nspider legs\ntoe of frog\nsnail tongue\nbat wing\nslug butter\nbear burp\nThis code is a way of saying, “For\neach item in wizard_list, store the value\nin the variable i, and then print the con-\ntents of that variable.” Again, if we got\nrid of the for loop, we would need to do\nsomething like this:\n>>> wizard_list = ['spider legs', 'toe of frog', 'snail tongue',\n'bat wing', 'slug butter', 'bear burp']\n>>> print(wizard_list[0])\nspider legs\n>>> print(wizard_list[1])\ntoe of frog\n>>> print(wizard_list[2])\nsnail tongue\n70 Chapter 6\n>>> print(wizard_list[3])\nbat wing\n>>> print(wizard_list[4])\nslug butter\n>>> print(wizard_list[5])\nbear burp\nSo once again, the loop has saved us a lot of typing.\nLet’s create another loop. Type the following code into the\nshell. It should automatically indent the code for you.\nu >>> hugehairypants = ['huge', 'hairy', 'pants']\nv >>> for i in hugehairypants:\nw print(i)\nx print(i)\ny\nz huge\nhuge\nhairy\nhairy\npants\npants\nIn the first line u, we create a list containing\n'huge', 'hairy', and 'pants'. In the next line v, we\nloop through the items in that list, and each item\nis then assigned to the variable i. We print the con-\ntents of the variable twice in the next two lines (w\nand x). Pressing enter on the next blank line y\ntells Python to end the block, and it then runs the\ncode and prints each element of the list twice z.\nRemember that if you enter the wrong number of spaces, you’ll\nend up with an error message. If you entered the preceding code\nwith an extra space on the fourth line x, Python would display an\nindentation error:\n>>> hugehairypants = ['huge', 'hairy', 'pants']\n>>> for i in hugehairypants:\nprint(i)\nprint(i)\nSyntaxError: unexpected indent\nGoing Loopy 71\nAs you learned in Chapter 5, Python expects the number\nof spaces in a block to be consistent. It doesn’t matter how many\nspaces you insert, as long as you use the same number for every\nnew line (plus it makes the code easier for humans to read).\nHere’s a more complicated example of a for loop with two\nblocks of code:\n>>> hugehairypants = ['huge', 'hairy', 'pants']\n>>> for i in hugehairypants:\nprint(i)\nfor j in hugehairypants:\nprint(j)\nWhere are the blocks in this code? The first block is the first\nfor loop:\nhugehairypants = ['huge', 'hairy', 'pants']\nfor i in hugehairypants:\nprint(i) #\nfor j in hugehairypants: # These lines are the FIRST block.\nprint(j) #\nThe second block is the single print line in the second for loop:\nu hugehairypants = ['huge', 'hairy', 'pants']\nfor i in hugehairypants:\nprint(i)\nv for j in hugehairypants:\nw print(j) # This line is also the SECOND block.\nCan you figure out what this little bit of code is going to do?\nAfter a list called hugehairypants is created at u, we can tell\nfrom the next two lines that it’s going to loop through the items in\nthe list and print out each one. However, at v, it will loop over the\nlist again, this time assigning the value to the variable j, and then\nprint each item again at w. The code at v and w is still part of the\nfor loop, which means they will be executed for each item as the for\nloop goes through the list.\nSo when this code runs, we should see huge followed by huge,\nhairy, pants, and then hairy followed by huge, hairy, pants, and so on.\n72 Chapter 6\nEnter the code into the Python shell and see for yourself:\n>>> hugehairypants = ['huge', 'hairy', 'pants']\n>>> for i in hugehairypants:\nu print(i)\nfor j in hugehairypants:\nv print(j)\n huge\nhuge\nhairy\npants\n hairy\nhuge\nhairy\npants\n pants\nhuge\nhairy\npants\nPython enters the first loop and prints an item from the list at\nu. Next, it enters the second loop and prints all the items in the\nlist at v. Then it continues with the print(i) command, printing\nthe next item in the list, and then prints the complete list again\nwith print(j). In the output, the lines marked  are printed by the\nprint(i) statement. The unmarked lines are printed by print(j).\nHow about something more practical than printing silly words?\nRemember that calculation we came up with in Chapter 2 to work\nout how many gold coins you would have at the end of the year if\nyou used your grandfather’s crazy invention to duplicate coins? It\nlooked like this:\n>>> 20 + 10 * 365 – 3 * 52\nThis represents 20 found coins plus\n10 magic coins multiplied by 365 days in\nthe year, minus the 3 coins a week stolen\nby the raven.\nGoing Loopy 73\nIt might be useful to see how your pile of gold coins will increase\neach week. We can do this with another for loop, but first, we need\nto change the value of our magic_coins variable so it represents the\ntotal number of magic coins per week. That’s 10 magic coins per\nday times 7 days in a week, so magic_coins should be 70:\n>>> found_coins = 20\n>>> magic_coins = 70\n>>> stolen_coins = 3\nWe can see our treasure increase each week by creating\nanother variable, called coins, and using a loop:\n>>> found_coins = 20\n>>> magic_coins = 70\n>>> stolen_coins = 3\nu >>> coins = found_coins\nv >>> for week in range(1, 53):\nw coins = coins + magic_coins - stolen_coins\nx print('Week %s = %s' % (week, coins))\nAt u, the variable coins is loaded with the value of the variable\nfound_coins; this is our starting number. The next line at v sets up\nthe for loop, which will run the commands in the block (the block is\nmade up of the lines at w and x). Each time it loops, the variable\nweek is loaded with the next number in the range of 1 through 52.\nThe line at w is a bit more complicated. Basically, each week\nwe want to add the number of coins we’ve magically created and\nsubtract the number of coins that were stolen by the raven. Think\nof the variable coins as something like a treasure chest. Every week,\nthe new coins are piled into the chest. So this line really means,\n“Replace the contents of the variable coins with the number of my\ncurrent coins, plus what I’ve created this week.” Basically, the\nequal sign (=) is a bossy piece of code that says, “Work out some\nstuff on the right first, and then save it for later, using the name\non the left.”\nThe line at x is a print statement using placeholders, which\nprints the week number and the total number of coins (so far) to\nthe screen. (If that doesn’t make sense to you, reread “Embedding\n74 Chapter 6\nValues in Strings” on page 30.) So, if you run this program,\nyou’ll see something like this:\nWhile We’re talking About Looping . . .\nA for loop isn’t the only kind of loop you can make in Python.\nThere’s also the while loop. A for loop is a loop of a specific length,\nwhereas a while loop is a loop that is used when you don’t know\nahead of time when it needs to stop looping.\nImagine a staircase with 20 steps. The staircase is indoors,\nand you know you can easily climb 20 steps. A for loop is like that.\n>>> for step in range(0, 20):\nprint(step)\nNow imagine a staircase going up a mountainside. The moun-\ntain is really tall, and you might run out of energy before you reach\nthe top, or the weather might turn bad, forcing you to stop. This is\nwhat a while loop is like.\nGoing Loopy 75\nstep = 0\nwhile step < 10000:\nprint(step)\nif tired == True:\nbreak\nelif badweather == True:\nbreak\nelse:\nstep = step + 1\nIf you try to enter and run this\ncode, you’ll get an error. Why? The\nerror happens because we haven’t cre-\nated the variables tired and badweather.\nAlthough there isn’t enough code here\nto actually make a working program,\nit does demonstrate a basic example of\na while loop.\nWe start by creating a variable\ncalled step with step = 0. Next, we cre-\nate a while loop that checks whether\nthe value of the variable step is less than 10,000 (step < 10000), which\nis the total number of steps from the bottom of the mountain to the\ntop. As long as step is less than 10,000, Python will execute the\nrest of the code.\nWith print(step), we print the value of the variable and\nthen check whether the value of the variable tired is True with\nif tired == True:. (True is called a Boolean value, which we’ll learn\nabout in Chapter 8.) If it is, we use the break keyword to exit the\nloop. The break keyword is a way of jumping out of a loop (in other\nwords, stopping it) immediately, and it works with both while and\nfor loops. Here it has the effect of jumping out of the block and into\nthe line step = step + 1.\nThe line elif badweather == True: checks to see if the variable\nb adweather is set to True. If so, the break keyword exits the loop.\nIf neither tired nor badweather is True (else), we add 1 to the step\nvariable with step = step + 1, and the loop continues.\n76 Chapter 6\nSo the steps of a while loop are as follows:\n1. Check the condition.\n2. Execute the code in the block.\n3. Repeat.\nMore commonly, a while loop might be created with a couple of\nconditions, rather than just one, like this:\nu >>> x = 45\nv >>> y = 80\nw >>> while x < 50 and y < 100:\nx = x + 1\ny = y + 1\nprint(x, y)\nHere, we create a variable x with the value 45 at u, and a vari-\nable y with the value 80 at v. The loop checks for two conditions\nat w: whether x is less than 50 and whether y is less than 100.\nWhile both conditions are true, the lines that follow are executed,\nadding 1 to both variables and then printing them. Here’s the out-\nput of this code:\n46 81\n47 82\n48 83\n49 84\n50 85\nCan you figure out how this works?\nWe start counting at 45 for the variable x and at 80 for the vari-\nable y, and then increment (add 1 to each variable) every time the\ncode in the loop is run. The loop will run as long as x is less than\n50 and y is less than 100. After looping five times (1 is added to each\nvariable each time), the value in x reaches 50. Now the first condi-\ntion (x < 50) is no longer true, so Python knows to stop looping.\nAnother common use of a while loop is to create semi-eternal\nloops. This is a type of loop that could go on forever, but actually\nGoing Loopy 77\ncontinues until something happens in the code to break out of it.\nHere’s an example:\nwhile True:\nlots of code here\nlots of code here\nlots of code here\nif some_value == True:\nbreak\nThe condition for the while loop is just True, which is always\ntrue, so the code in the block will always run (thus, the loop is eter-\nnal). Only if the variable some_value is true will Python break out\nof the loop. You can see a better example of this in “Using randint\nto Pick a Random Number” on page 134, but you might want to\nwait until you’ve read Chapter 7 before taking a look at it.\nWhat You Learned\nIn this chapter, we used loops to perform repetitive tasks without\nall the repetition. We told Python what we wanted repeated by\nwriting the tasks inside blocks of code, which we put inside loops.\nWe used two types of loops: for loops and while loops, which are\nsimilar but can be used in different ways. We also used the break\nkeyword to stop looping—that is, to break out of a loop.\nProgramming Puzzles\nHere are some examples of loops that you can try out for yourself.\nThe answers can be found at http://python-for-kids.com/.\n#1: the Hello Loop\nWhat do you think the following code will do? First, guess what\nwill happen, and then run the code in Python to see if you were\nright.\n>>> for x in range(0, 20):\nprint('hello %s' % x)\nif x < 9:\nbreak\n78 Chapter 6\n#2: even numbers\nCreate a loop that prints even numbers until it reaches your year\nof age or, if your age is an odd number, prints out odd numbers\nuntil it reaches your age. For example, it might print out some-\nthing like this:\n2\n4\n6\n8\n10\n12\n14\n#3: My five favorite Ingredients\nCreate a list containing five different sandwich ingredients, such\nas the following:\n>>> ingredients = ['snails', 'leeches', 'gorilla belly-button lint',\n'caterpillar eyebrows', 'centipede toes']\nNow create a loop that prints out the list (including the numbers):\n1 snails\n2 leeches\n3 gorilla belly-button lint\n4 caterpillar eyebrows\n5 centipede toes\n#4: Your Weight on the Moon\nIf you were standing on the moon right now, your weight would be\n16.5 percent of what it is on Earth. You can calculate that by mul-\ntiplying your Earth weight by 0.165.\nIf you gained a kilo in weight every year for the next 15 years,\nwhat would your weight be when you visited the moon each year\nand at the end of the 15 years? Write a program using a for loop\nthat prints your moon weight for each year.\nGoing Loopy 79"
  },
  {
    "input": "How can functions and modules help in reusing code in Python?",
    "summary": "Recycling code in programming means reusing functions and modules to make code shorter, easier to read, and more efficient. Functions are reusable chunks of code that perform specific tasks, and modules group functions together to create larger, more powerful programs. In Python, you can use functions like `range` and `list` to generate sequences, and modules like `time` or `sys` to access additional features and functionality.",
    "output": "7\nReCYCLInG YoUR CoDe WItH\nfUnCtIons AnD MoDULes\nThink about how much stuff you throw away each\nday: water bottles, soda cans, potato chip bags, plas-\ntic sandwich wrappers, bags that held carrot sticks or\napple slices, shopping bags, newspapers, magazines,\nand so on. Now imagine what would happen if all of\nthat trash just got dumped in a pile at the end of your\ndriveway, without separating out the paper, the plastic,\nand the tin cans.\nOf course, you probably recycle as much as\npossible, which is good, because no one likes to\nclimb over a pile of trash on the way to school.\nRather than sitting in an enormous, gross pile,\nthose glass bottles that you recycle are melted\ndown and turned into new jars and bottles;\npaper is pulped into recycled paper; and plas-\ntic is turned into heavier plastic goods. So we\nreuse things we would otherwise throw away.\nIn the programming world, reuse is just as\nimportant. Obviously, your program won’t dis-\nappear under a pile of garbage, but if you don’t\nreuse some of what you’re doing, you’ll eventu-\nally wear your fingers down to painful stubs\nthrough overtyping. Reuse also makes your\ncode shorter and easier to read.\nAs you’ll learn in this chapter, Python offers a number of dif-\nferent ways to reuse code.\nUsing functions\nYou’ve already seen one of the ways to recycle Python code. In the\nprevious chapter, we used the functions range and list to make\nPython count.\n>>> list(range(0, 5))\n[0,1,2,3,4]\nIf you know how to count, it’s not too hard to create a list of\nconsecutive numbers by typing them yourself, but the larger the\nlist, the more typing you need to do. However, if you use functions,\nyou can just as easily create a list with a thousand numbers.\nHere’s an example that uses the list and range functions to pro-\nduce a list of numbers:\n>>> list(range(0, 1000))\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16...,997,998,999]\nFunctions are chunks of code that tell Python to do something.\nThey are one way to reuse code—you can use functions in your\nprograms again and again.\n82 Chapter 7\nWhen you’re writing simple programs, functions are handy.\nOnce you start writing long, more complicated programs, like\ngames, functions are essential (assuming you want to finish writ-\ning your program this century).\nParts of a function\nA function has three parts: a name, parameters, and a body. Here’s\nan example of a simple function:\n>>> def testfunc(myname):\nprint('hello %s' % myname)\nThe name of this function is testfunc. It has a single param-\neter, myname, and its body is the block of code immediately following\nthe line beginning with def (short for define). A parameter is a\nvariable that exists only while a function is being used.\nYou can run the function by calling its name, using parenthe-\nses around the parameter value:\n>>> testfunc('Mary')\nhello Mary\nThe function could take two, three, or any number of param-\neters, instead of just one:\n>>> def testfunc(fname, lname):\nprint('Hello %s %s' % (fname, lname))\nThe two values for these parameters are separated by a comma:\n>>> testfunc('Mary', 'Smith')\nHello Mary Smith\nWe could also create some variables first and then call the\nfunction with them:\n>>> firstname = 'Joe'\n>>> lastname = 'Robertson'\n>>> testfunc(firstname, lastname)\nHello Joe Robertson\nRecycling Your Code with Functions and Modules 83\nA function is often used to return a value, using a return state-\nment. For example, you could write a function to calculate how\nmuch money you were saving:\n>>> def savings(pocket_money, paper_route, spending):\nreturn pocket_money + paper_route – spending\nThis function takes three parameters. It adds the first two\n(pocket_money and paper_route) and subtracts the last (spending). The\nresult is returned and can be assigned to a variable (the same way\nwe set other values to variables) or printed:\n>>> print(savings(10, 10, 5))\n15\nVariables and scope\nA variable that’s inside the body of a function can’t be used again\nwhen the function has finished running because it exists only\ninside the function. In the world of programming, this is called\nscope.\nLet’s look at a simple function that uses a couple of variables\nbut doesn’t have any parameters:\nu >>> def variable_test():\nfirst_variable = 10\nsecond_variable = 20\nv return first_variable * second_variable\nIn this example, we create the function called variable_test at u,\nwhich multiplies two variables (first_variable and second_variable)\nand returns the result at v.\n>>> print(variable_test())\n200\nIf we call this function using print, we get the result: 200.\nHowever, if we try to print the contents of first_variable (or\n84 Chapter 7\nsecond_variable, for that matter) outside of the block of code in\nthe function, we get an error message:\n>>> print(first_variable)\nTraceback (most recent call last):\nFile \"<pyshell#50>\", line 1, in <module>\nprint(first_variable)\nNameError: name 'first_variable' is not defined\nIf a variable is defined outside the function, it has a different\nscope. For example, let’s define a variable before we create our\nfunction, and then try using it inside the function:\nu >>> another_variable = 100\n>>> def variable_test2():\nfirst_variable = 10\nsecond_variable = 20\nv return first_variable * second_variable * another_variable\nIn this code, even though the variables first_variable and\nsecond_variable can’t be used outside the function, the variable\nanother_variable (which was created outside the function at u)\ncan be used inside it at v.\nHere’s the result of calling this function:\n>>> print(variable_test2())\n20000\nNow, suppose you were building a\nspaceship out of something economi-\ncal like used tin cans. You think you\ncan flatten 2 cans a week to create the\ncurved walls of your spaceship, but\nyou’ll need something like 500 cans\nto finish the fuselage. We can easily\nwrite a function to help work out how\nlong it will take to flatten 500 cans if\nwe do 2 cans a week.\nRecycling Your Code with Functions and Modules 85\nLet’s create a function to show how many cans we’ve flattened\neach week up to a year. Our function will take the number of cans\nas a parameter:\n>>> def spaceship_building(cans):\ntotal_cans = 0\nfor week in range(1, 53):\ntotal_cans = total_cans + cans\nprint('Week %s = %s cans' % (week, total_cans))\nOn the first line of the function, we create a variable called\ntotal_cans and set its value to 0. We then create a loop for the weeks\nin the year and add the number of cans flattened each week. This\nblock of code makes up the content of our function. But there’s also\nanother block of code in this function: its last two lines, which\nmake up the block of the for loop.\nLet’s try entering that function in the shell and calling it with\ndifferent values for the number of cans:\n>>> spaceship_building(2)\nWeek 1 = 2 cans\nWeek 2 = 4 cans\nWeek 3 = 6 cans\nWeek 4 = 8 cans\nWeek 5 = 10 cans\nWeek 6 = 12 cans\nWeek 7 = 14 cans\nWeek 8 = 16 cans\nWeek 9 = 18 cans\nWeek 10 = 20 cans\n(continues on...)\n>>> spaceship_building(13)\nWeek 1 = 13 cans\nWeek 2 = 26 cans\nWeek 3 = 39 cans\nWeek 4 = 52 cans\nWeek 5 = 65 cans\n(continues on...)\nThis function can be reused with different values for the num-\nber of cans per week, which is a bit more efficient than retyping\nthe for loop every time you want to try it with different numbers.\n86 Chapter 7\nFunctions can also be grouped together into modules, which\nis where Python becomes really useful, as opposed to just mildly\nuseful.\nUsing Modules\nModules are used to group functions, variables, and other things\ntogether into larger, more powerful programs. Some modules are\nbuilt in to Python, and you\ncan download other modules\nseparately. You’ll find modules\nto help you write games (such\nas tkinter, which is built in,\nand PyGame, which is not), mod-\nules for manipulating images\n(such as PIL, the Python Imag-\ning Library), and modules for\ndrawing three-dimensional\ngraphics (such as Panda3D).\nModules can be used to do all sorts of useful things. For exam-\nple, if you were designing a simulation game, and you wanted the\nworld of the game to change realistically, you could calculate the\ncurrent date and time using a built-in module called time:\n>>> import time\nHere, the import command is used to tell Python that we want\nto use the module time.\nWe can then call functions that are available in this module,\nusing the dot symbol. (Remember that we used functions like this\nto work with the turtle module in Chapter 4, such as t.forward(50).)\nFor example, here’s how we might call the asctime function with the\ntime module:\n>>> print(time.asctime())\n'Mon Nov 5 12:40:27 2012'\nThe function asctime is a part of the time module that returns\nthe current date and time, as a string.\nRecycling Your Code with Functions and Modules 87\nNow suppose that you want to ask someone\nusing your program to enter a value, perhaps\ntheir date of birth or their age. You can do this\nusing a print statement, to display a message,\nand the sys (short for system) module, which con-\ntains utilities for interacting with the Python\nsystem itself. First, we import the sys module:\n>>> import sys\nInside the sys module is a special object called stdin (for\nstandard input), which provides a rather useful function called\nreadline. The readline function is used to read a line of text typed\non the keyboard until you press enter. (We’ll look at how objects\nwork in Chapter 8.) To test readline, enter the following code in the\nshell:\n>>> import sys\n>>> print(sys.stdin.readline())\nIf you then type some words and press enter, those words will\nbe printed out in the shell.\nThink back to the code we wrote in Chapter 5, using an if\nstatement:\n>>> if age >= 10 and age <= 13:\nprint('What is 13 + 49 + 84 + 155 + 97? A headache!')\nelse:\nprint('Huh?')\nRather than creating the variable age and giving it a specific\nvalue before the if statement, we can now ask someone to enter\nthe value instead. But first, let’s turn the code into a function:\n>>> def silly_age_joke(age):\nif age >= 10 and age <= 13:\nprint('What is 13 + 49 + 84 + 155 + 97? A headache!')\nelse:\nprint('Huh?')\nNow you can call the function by entering its name, and then\ntell it what number to use by entering the number in parentheses.\nDoes it work?\n88 Chapter 7\n>>> silly_age_joke(9)\nHuh?\n>>> silly_age_joke(10)\nWhat is 13 + 49 + 84 + 155 + 97? A headache!\nIt works! Now let’s make the function ask for a person’s age.\n(You can add to or change a function as many times as you want.)\n>>> def silly_age_joke():\nprint('How old are you?')\nu age = int(sys.stdin.readline())\nv if age >= 10 and age <= 13:\nprint('What is 13 + 49 + 84 + 155 + 97? A headache!')\nelse:\nprint('Huh?')\nDid you recognize the function int at u, which converts a\nstring to a number? We included that function because readline()\nreturns whatever someone enters as a string, but we want a num-\nber so that we can compare it with the numbers 10 and 13 at v.\nTo try this yourself, call the function without any parameters, and\nthen type a number when How old are you? appears:\n>>> silly_age_joke()\nHow old are you?\n10\nWhat is 13 + 49 + 84 + 155 + 97? A headache!\n>>> silly_age_joke()\nHow old are you?\n15\nHuh?\nWhat You Learned\nIn this chapter, you’ve seen how to make reusable chunks of code\nin Python with functions and how to use functions provided by\nmodules. You learned how the scope of variables controls whether\nthey can be seen inside or outside of functions, and how to create\nfunctions using the def keyword. You also found out how to import\nmodules so you can use their contents.\nRecycling Your Code with Functions and Modules 89\nProgramming Puzzles\nGive the following examples a try, to experiment with creat-\ning your own functions. The answers can be found at http://\npython-for-kids.com/.\n#1: Basic Moon\nWeight function\nIn Chapter 6, one programming\npuzzle was to create a for loop to\ndetermine your weight on the moon\nover a period of 15 years. That for\nloop could easily be turned into a\nfunction. Try creating a function\nthat takes a starting weight and\nincreases the weight amount each\nyear. You might call the new func-\ntion using code like this:\n>>> moon_weight(30, 0.25)\n#2: Moon Weight function and Years\nTake the function you’ve just created, and change it to work out\nthe weight over different periods, such as 5 years or 20 years. Be\nsure to change the function so that it takes three arguments: ini-\ntial weight, weight gained each year, and number of years:\n>>> moon_weight(90, 0.25, 5)\n#3: Moon Weight Program\nInstead of a simple function, where you pass in the values as\nparameters, you can make a mini-program that prompts for the\nvalues using sys.stdin.readline(). In this case, you call the function\nwithout any parameters at all:\n>>> moon_weight()\n90 Chapter 7\nThe function will display a message asking for the starting\nweight, then a second message asking for the amount the weight\nwill increase each year, and finally a message asking for the num-\nber of years. You would see something like the following:\nPlease enter your current Earth weight\n45\nPlease enter the amount your weight might increase each year\n0.4\nPlease enter the number of years\n12\nRemember to import the sys module first before creating your\nfunction:\n>>> import sys\nRecycling Your Code with Functions and Modules 91"
  },
  {
    "input": "How do classes and objects help in organizing and understanding code in Python?",
    "summary": "Classes and objects are used to organize code and classify things in Python. Objects are members of classes, and classes can have functions that define what the objects can do. By using inheritance, child classes can inherit functions from parent classes, making code more organized and easier to understand.",
    "output": "8\nHoW to Use CLAsses\nAnD oBJeCts\nWhy is a giraffe like a sidewalk? Because both a giraffe\nand a sidewalk are things, known in the English lan-\nguage as nouns and in Python as objects.\nThe idea of objects is an important one in the world\nof computers. Objects are a way of organizing code in\na program and breaking things down to make it easier\nto think about complex ideas. (We used an object in\nChapter 4 when we worked with the turtle—Pen.)\nTo really understand how objects work in Python, we need to\nthink about types of objects. Let’s start with giraffes and sidewalks.\nA giraffe is a type of mammal, which is a\ntype of animal. A giraffe is also an animate\nobject—it’s alive.\nNow consider a sidewalk. There’s not\nmuch to say about a sidewalk other than\nit’s not a living thing. Let’s call it an inani-\nmate object (in other words, it’s not alive).\nThe terms mammal, animal, animate, and\ninanimate are all ways of classifying things.\nBreaking things into Classes\nIn Python, objects are defined by classes, which we can think of as\na way to classify objects into groups. Here is a tree diagram of the\nclasses that giraffes and sidewalks would fit into based on our pre-\nceding definitions:\nThings\nInanimate Animate\nSidewalks Animals\nMammals\nGiraffes\nThe main class is Things. Below the Things class, we have\nInanimate and Animate. These are further broken down into just\nS idewalks for Inanimate, and Animals, Mammals, and Giraffes for Animate.\n94 Chapter 8\nWe can use classes to organize bits of Python code. For\nexample, consider the turtle module. All the things that Python’s\nturtle module can do—such as moving forward, moving backward,\nturning left, and turning right—are functions in the Pen class. An\nobject can be thought of as a member of a class, and we can create\nany number of objects for a class—which we will get to shortly.\nNow let’s create the same set of classes as shown in our tree\ndiagram, starting from the top. We define classes using the class\nkeyword followed by a name. Since Things is the broadest class,\nwe’ll create it first:\n>>> class Things:\npass\nWe name the class Things and use the pass statement to let\nPython know that we’re not going to give any more information.\npass is used when we want to provide a class or function but don’t\nwant to fill in the details at the moment.\nNext, we’ll add the other classes and build some relationships\nbetween them.\nChildren and Parents\nIf a class is a part of another class, then it’s a child of that class,\nand the other class is its parent. Classes can be both children of and\nparents to other classes. In our tree diagram, the class above another\nclass is its parent, and the class below it is its child. For example,\nInanimate and Animate are both children of the class Things, meaning\nthat Things is their parent.\nTo tell Python that a class is a child of another class, we add\nthe name of the parent class in parentheses after the name of our\nnew class, like this:\n>>> class Inanimate(Things):\npass\n>>> class Animate(Things):\npass\nHere, we create a class called Inanimate and tell Python that its\nparent class is Things with the code class Inanimate(Things). Next,\nwe create a class called Animate and tell Python that its parent\nclass is also Things, using class Animate(Things).\nHow to Use Classes and Objects 95\nLet’s try the same thing with the Sidewalks class. We create the\nSidewalks class with the parent class Inanimate like so:\n>>> class Sidewalks(Inanimate):\npass\nAnd we can organize the Animals, Mammals, and Giraffes classes\nusing their parent classes as well:\n>>> class Animals(Animate):\npass\n>>> class Mammals(Animals):\npass\n>>> class Giraffes(Mammals):\npass\nAdding objects to Classes\nWe now have a bunch of classes, but what about putting some\nthings into those classes? Say we have a giraffe named Reginald.\nWe know that he belongs in the class Giraffes, but what do we use,\nin programming terms, to describe single giraffe called Reginald?\nWe call Reginald an object of the class Giraffes (you may also see\nthe term instance of the class). To “introduce” Reginald to Python,\nwe use this little snippet of code:\n>>> reginald = Giraffes()\nThis code tells Python to create an object in the Giraffes class\nand assign it to the variable reginald. Like a function, the class\nname is followed by parentheses. Later in this chapter we’ll see\nhow to create objects and use parameters in the parentheses.\nBut what does the reginald object do? Well, nothing at the\nmoment. To make our objects useful, when we create our classes,\nwe also need to define functions that can be used with the objects\nin that class. Rather than just using the pass keyword immediately\nafter the class definition, we can add function definitions.\n96 Chapter 8\nDefining functions of Classes\nChapter 7 introduced functions as a way to reuse code. When we\ndefine a function that is associated with a class, we do so in the\nsame way that we define any other function, except that we indent\nit beneath the class definition. For example, here’s a normal func-\ntion that isn’t associated with a class:\n>>> def this_is_a_normal_function():\nprint('I am a normal function')\nAnd here are a couple of functions that belong to a class:\n>>> class ThisIsMySillyClass:\ndef this_is_a_class_function():\nprint('I am a class function')\ndef this_is_also_a_class_function():\nprint('I am also a class function. See?')\nAdding Class Characteristics As\nfunctions\nConsider the child classes of the Animate class we defined on\npage 95. We can add characteristics to each class to describe\nwhat it is and what it can do. A characteristic is a trait that all\nof the members of the class (and its children) share.\nFor example, what do all animals have in common? Well, to\nstart with, they all breathe. They also move and eat. What about\nmammals? Mammals all feed their young with milk. And they\nbreathe, move, and eat. We know that giraffes eat leaves from high\nup in trees, and like all mammals, they feed their young with milk,\nbreathe, move, and eat food. When we add these characteristics to\nour tree diagram, we get something like this:\nBreathe\nAnimals Move\nEat food\nMammals Feed young with milk\nGiraffes Eat leaves from trees\nHow to Use Classes and Objects 97\nThese characteristics can be thought of as actions, or functions—\nthings that an object of that class can do.\nTo add a function to a class, we use the def keyword. So the\nAnimals class will look like this:\n>>> class Animals(Animate):\ndef breathe(self):\npass\ndef move(self):\npass\ndef eat_food(self):\npass\nIn the first line of this listing, we define the\nclass as we did before, but instead of using the\npass keyword on the next line, we define a func-\ntion called breathe, and give it one parameter:\nself. The self parameter is a way for one func-\ntion in the class to call another function in the\nclass (and in the parent class). We will see this\nparameter in use later.\nOn the next line, the pass keyword tells Python we’re not going\nto provide any more information about the breathe function because\nit’s going to do nothing for now. Then we add the functions move and\neat_food, which also do nothing for now. We’ll re-create our classes\nshortly and put some proper code in the functions. This is a common\nway to develop programs. Often, programmers will create classes\nwith functions that do nothing as a way to figure out what the class\nshould do, before getting into the details of the individual functions.\nWe can also add functions to the other two classes, Mammals\nand Giraffes. Each class will be able to use the characteristics (the\nfunctions) of its parent. This means that you don’t need to make\none really complicated class; you can put your functions in the\nhighest parent where the characteristic applies. (This is a good\nway to make your classes simpler and easier to understand.)\n>>> class Mammals(Animals):\ndef feed_young_with_milk(self):\npass\n>>> class Giraffes(Mammals):\ndef eat_leaves_from_trees(self):\npass\n98 Chapter 8\nWhy Use Classes and objects?\nWe’ve now added functions to our classes, but why use classes and\nobjects at all, when you could just write normal functions called\nbreathe, move, eat_food, and so on?\nTo answer that question, we’ll use our giraffe called Reginald,\nwhich we created earlier as an object of the Giraffes class, like this:\n>>> reginald = Giraffes()\nBecause reginald is an object, we can call (or run) functions pro-\nvided by his class (the Giraffes class) and its parent classes. We call\nfunctions on an object by using the dot operator and the name of the\nfunction. To tell Reginald the giraffe to move or eat, we can call the\nfunctions like this:\n>>> reginald = Giraffes()\n>>> reginald.move()\n>>> reginald.eat_leaves_from_trees()\nSuppose Reginald has a giraffe friend named Harold. Let’s cre-\nate another Giraffes object called harold:\n>>> harold = Giraffes()\nBecause we’re using objects and classes, we can tell Python\nexactly which giraffe we’re talking about when we want to run the\nmove function. For example, if we wanted to make Harold move but\nleave Reginald in place, we could call the move function using our\nharold object, like this:\n>>> harold.move()\nIn this case, only Harold would be moving.\nLet’s change our classes a little to make this a bit more obvious.\nWe’ll add a print statement to each function, instead of using pass:\n>>> class Animals(Animate):\ndef breathe(self):\nprint('breathing')\ndef move(self):\nprint('moving')\ndef eat_food(self):\nprint('eating food')\nHow to Use Classes and Objects 99\n>>> class Mammals(Animals):\ndef feed_young_with_milk(self):\nprint('feeding young')\n>>> class Giraffes(Mammals):\ndef eat_leaves_from_trees(self):\nprint('eating leaves')\nNow when we create our reginald and harold objects and call\nfunctions on them, we can see something actually happen:\n>>> reginald = Giraffes()\n>>> harold = Giraffes()\n>>> reginald.move()\nmoving\n>>> harold.eat_leaves_from_trees()\neating leaves\nOn the first two lines, we create the vari-\nables reginald and harold, which are objects\nof the Giraffes class. Next, we call the move\nfunction on reginald, and Python prints moving\non the following line. In the same way, we call\nthe eat_leaves_from_trees function on harold, and\nPython prints eating leaves. If these were real\ngiraffes, rather than objects in a computer, one\ngiraffe would be walking, and the other would\nbe eating.\nobjects and Classes in Pictures\nHow about taking a more graphical approach to objects and classes?\nLet’s return to the turtle module we toyed with in Chapter 4.\nWhen we use turtle.Pen(), Python creates an object of the Pen class\nthat is provided by the turtle module (similar to our reginald and\nharold objects in the previous section). We can create two turtle\nobjects (named Avery and Kate), just as we created two giraffes:\n>>> import turtle\n>>> avery = turtle.Pen()\n>>> kate = turtle.Pen()\nEach turtle object (avery and kate) is a member of the Pen class.\n100 Chapter 8\nNow here’s where objects start to become powerful. Having\ncreated our turtle objects, we can call functions on each, and they\nwill draw independently. Try this:\n>>> avery.forward(50)\n>>> avery.right(90)\n>>> avery.forward(20)\nWith this series of instructions, we tell Avery to move forward\n50 pixels, turn right 90 degrees, and move forward 20 pixels so\nthat she finishes facing downward. Remember that turtles always\nstart off facing to the right.\nNow it’s time to move Kate.\n>>> kate.left(90)\n>>> kate.forward(100)\nWe tell Kate to turn left 90 degrees, and then move forward\n100 pixels so that she ends facing up.\nSo far, we have a line with arrowheads moving in two differ-\nent directions, with the head of each arrow representing a different\nturtle object: Avery pointing down, and Kate facing up.\nNow let’s add another turtle, Jacob, and move him, too, with-\nout bugging Kate or Avery.\n>>> jacob = turtle.Pen()\n>>> jacob.left(180)\n>>> jacob.forward(80)\nHow to Use Classes and Objects 101\nFirst, we create a new Pen object called jacob, then we turn him\nleft 180 degrees, and then move him forward 80 pixels. Our draw-\ning now looks like this, with three turtles:\nRemember that every time we call turtle.Pen() to create a\nturtle, we add a new, independent object. Each object is still an\ninstance of the class Pen, and we can use the same functions on\neach object, but because we’re using objects, we can move each\nturtle independently. Like our independent giraffe objects (Regi-\nnald and Harold), Avery, Kate, and Jacob are independent turtle\nobjects. If we create a new object with the same variable name\nas an object we’ve already created, the old object won’t necessar-\nily vanish. Try it for yourself: Create another Kate turtle and try\nmoving it around.\nother Useful features of objects\nand Classes\nClasses and objects make it easy to group functions. They’re also\nreally useful when we want to think about a program in smaller\nchunks.\n102 Chapter 8\nFor example, consider a really large software application,\nlike a word processor or a 3D computer game. It’s nearly impos-\nsible for most people to understand large programs like these as\na whole because there’s just so much code. But break these mon-\nster programs into smaller pieces, and each piece starts to make\nsense—as long as you know the language, of course!\nWhen writing a large program, breaking it up also allows you\nto divide the work among other programmers. The most compli-\ncated programs that you use (like your web browser) were written\nby many people, or teams of people, working on different parts at\nthe same time around the world.\nNow imagine that we want to\nexpand some of the classes we’ve cre-\nated in this chapter (Animals, Mammals,\nand Giraffes), but we have too much\nwork to do, and we want our friends to\nhelp. We could divide the work of writ-\ning the code so that one person worked\non the A nimals class, another on the\nMammals class, and still another on the\nGiraffes class.\nInherited functions\nThose of you who have been paying attention may realize that\nwhoever ends up working on the Giraffes class is lucky, because\nany functions created by the people working on the Animals and\nMammals classes can also be used by the Giraffes class. The Giraffes\nclass inherits functions from the Mammals class, which, in turn, inher-\nits from the Animals class. In other words, when we create a giraffe\nobject, we can use functions defined in the Giraffes class, as well\nas functions defined in the Mammals and Animals classes. And, by the\nsame token, if we create a mammal object, we can use functions\ndefined in the Mammals class as well as its parent class Animals.\nTake a look at the rela-\nBreathe\ntionship between the Animals,\nAnimals Move\nMammals, and Giraffes classes\nEat food\nagain. The Animals class is\nthe parent of the Mammals\nI can also use\nclass, and Mammals is the Mammals those functions.\nparent of Giraffes.\nHow to Use Classes and Objects 103\nEven though Reginald is an object of the Giraffes class, we\ncan still call the move function that we defined in the Animals class\nbecause functions defined in any parent class are available to its\nchild classes:\n>>> reginald = Giraffes()\n>>> reginald.move()\nmoving\nIn fact, all of the functions we defined in both the Animals and\nMammals classes can be called from our reginald object because the\nfunctions are inherited:\n>>> reginald = Giraffes()\n>>> reginald.breathe()\nbreathing\n>>> reginald.eat_food()\neating food\n>>> reginald.feed_young_with_milk()\nfeeding young\nfunctions Calling other functions\nWhen we call functions on an object, we use the object’s variable\nname. For example, here’s how to call the move function on Regi-\nnald the giraffe:\n>>> reginald.move()\nTo have a function in the Giraffes class call the move function,\nwe would use the self parameter instead. The self parameter\nis a way for one function in the class to call another function.\nFor example, suppose we add a function called find_food to the\nGiraffes class:\n>>> class Giraffes(Mammals):\ndef find_food(self):\nself.move()\nprint(\"I've found food!\")\nself.eat_food()\nWe have now created a function that combines two other func-\ntions, which is quite common in programming. Often, you will\nwrite a function that does something useful, which you can then\n104 Chapter 8\nuse inside another function. (We’ll do this in Chapter 13, where\nwe’ll write more complicated functions to create a game.)\nLet’s use self to add some functions to the Giraffes class:\n>>> class Giraffes(Mammals):\ndef find_food(self):\nself.move()\nprint(\"I've found food!\")\nself.eat_food()\ndef eat_leaves_from_trees(self):\nself.eat_food()\ndef dance_a_jig(self):\nself.move()\nself.move()\nself.move()\nself.move()\nWe use the eat_food and move functions from the\nparent A nimals class to define eat_leaves_from_trees\nand dance_a_jig for the Giraffes class because these\nare inherited functions. By adding functions that\ncall other functions in this way, when we create\nobjects of these classes, we can call a single func-\ntion that does more than just one thing. You can\nsee what happens when we call the dance_a_jig\nfunction below—our giraffe moves 4 times (that\nis, the text “moving” is printed 4 times):\n>>> reginald = Giraffes()\n>>> reginald.dance_a_jig()\nmoving\nmoving\nmoving\nmoving\nInitializing an object\nSometimes when creating an object, we want to set some values\n(also called properties) for later use. When we initialize an object,\nwe are getting it ready to be used.\nFor example, suppose we want to set the number of spots on\nour giraffe objects when they are created—that is, when they’re\ninitialized. To do this, we create an __init__ function (notice that\nthere are two underscore characters on each side, for a total of four).\nHow to Use Classes and Objects 105\nThis is a special type of function in Python classes and must have\nthis name. The init function is a way to set the properties for an\nobject when the object is first created, and Python will automati-\ncally call this function when we create a new object. Here’s how to\nuse it:\n>>> class Giraffes:\ndef __init__(self, spots):\nself.giraffe_spots = spots\nFirst, we define the init function with two parameters, self\nand spots, with the code def __init__(self, spots):. Just like the\nother functions we have defined in the class, the init function also\nneeds to have self as the first parameter. Next, we set the param-\neter spots to an object variable (its property) called giraffe_spots\nusing the self parameter, with the code self.giraffe_spots = spots.\nYou might think of this line of code as saying, “Take the value of\nthe parameter spots and save it for later (using the object variable\ngiraffe_spots).” Just as one function in a class can call another\nfunction using the self parameter, variables in the class are also\naccessed using self.\nNext, if we create a couple of new giraffe objects (Ozwald and\nGertrude) and display their number of spots, you can see the ini-\ntialization function in action:\n>>> ozwald = Giraffes(100)\n>>> gertrude = Giraffes(150)\n>>> print(ozwald.giraffe_spots)\n100\n>>> print(gertrude.giraffe_spots)\n150\nFirst, we create an instance of the Giraffes class, using the\nparameter value 100. This has the effect of calling the __init__\nfunction and using 100 for the value of the spots parameter. Next,\nwe create another instance of the Giraffes class, this time with\n150. Finally, we print the object variable giraffe_spots for each of\nour giraffe objects, and we see that the results are 100 and 150.\nIt worked!\nRemember, when we create an object of a class, such as ozwald\nabove, we can refer to its variables or functions using the dot opera-\ntor and the name of the variable or function we want to use (for\n106 Chapter 8\nexample, ozwald.giraffe_spots). But when we’re creating functions\ninside a class, we refer to those same variables (and other func-\ntions) using the self parameter (self.giraffe_spots).\nWhat You Learned\nIn this chapter, we used classes to create categories of things and\nmade objects (instances) of those classes. You learned how the child\nof a class inherits the functions of its parent, and that even though\ntwo objects are of the same class, they’re not necessarily clones.\nFor example, a giraffe object can have its own number of spots. You\nlearned how to call (or run) functions on an object and how object\nvariables are a way of saving values in those objects. Finally, we\nused the self parameter in functions to refer to other functions and\nvariables. These concepts are fundamental to Python, and you’ll see\nthem again and again as you read the rest of this book.\nProgramming Puzzles\nSome of the ideas in this chapter will start to make sense the more\nyou use them. Try them out with the following examples, and then\nfind the answers at http://python-for-kids.com/.\n#1: the Giraffe shuffle\nAdd functions to the Giraffes class to move the giraffe’s left and\nright feet forward and backward. A function for moving the left\nfoot forward might look like this:\n>>> def left_Foot_Forward(self):\nprint('left foot forward')\nThen create a function called dance to teach Reginald to dance\n(the function will call the four foot functions you’ve just created).\nThe result of calling this new function will be a simple dance:\n>>> reginald = Giraffes()\n>>> reginald.dance()\nleft foot forward\nleft foot back\nright foot forward\nright foot back\nleft foot back\nHow to Use Classes and Objects 107\nright foot back\nright foot forward\nleft foot forward\n#2: turtle Pitchfork\nCreate the following picture of a sideways pitchfork using four\nturtle Pen objects (the exact length of the lines isn’t important).\nRemember to import the turtle module first!\n108 Chapter 8"
  },
  {
    "input": "What are some of the more useful built-in functions in Python and what do they do?",
    "summary": "Python has many built-in functions that are ready to use, such as abs, bool, float, int, len, max, min, range, and sum. These functions can simplify programming tasks, like calculating absolute values, checking if a value is set, or working with files. The open function allows you to read from and write to files in Python. This chapter focuses on the open function and how it can be used to handle file operations.",
    "output": "9\nPYtHon’s BUILt-In\nfUnCtIons\nPython has a well-stocked box of programming tools,\nincluding a large number of functions and modules that\nare ready-made for you to use. Like a trusty hammer\nor a bicycle wrench, these built-in tools—chunks of\ncode, really—can make writing programs a lot easier.\nAs you learned in Chapter 7, modules need to be\nimported before they can be used. Python’s built-in\nfunctions don’t need to be imported first; they’re avail-\nable as soon as the Python shell starts. In this chapter,\nwe’ll look at some of the more useful built-in functions, and then\nfocus on one: the open function, which lets you open files in order to\nread and write from them.\nUsing Built-in functions\nWe’ll look at 12 built-in functions that are commonly used by Python\nprogrammers. I’ll describe what they do and how to use them, and\nthen show examples of how they can help in your programs.\nthe abs function\nThe abs function returns the absolute value of a number, which is\nthe value of a number without its sign. For example, the absolute\nvalue of 10 is 10, and the absolute value of –10 is 10.\nTo use the abs function, simply call it with a number or vari-\nable as its parameter, like this:\n>>> print(abs(10))\n10\n>>> print(abs(-10))\n10\nYou might use the abs function to\ndo something like calculate an absolute\namount of movement of a character in a\ngame, no matter in which the direction\nthat character is traveling. For example,\nsay the character takes three steps to his\nright (positive 3) and then ten steps to\nhis left (negative 10, or –10). If we didn’t\ncare about the direction (positive or nega-\ntive), the absolute value of these numbers\nwould be 3 and 10. You might use this in\na board game where you roll two dice and\nthen move your character a maximum num-\nber of steps in any direction, based on the\ntotal of the dice. Now, if we store the number of steps in a vari-\nable, we can determine if the character is moving with the code\n110 Chapter 9\nbelow. We might want to display some information when the player\nhas decided to move (in this case, we’ll just display “Character is\nmoving”):\n>>> steps = -3\n>>> if abs(steps) > 0:\nprint('Character is moving')\nIf we hadn’t used abs, the if statement might look like this:\n>>> steps = -3\n>>> if steps < 0 or steps > 0:\nprint('Character is moving')\nAs you can see, using abs makes the if statement just a little\nshorter and easier to understand.\nthe bool function\nThe name bool is short for Boolean, the word programmers use to\ndescribe a type of data that can have one of two possible values,\nusually either true or false.\nThe bool function takes a single parameter and returns either\nTrue or False based on its value. When using bool for numbers, 0\nreturns False, while any other number returns True. Here’s how\nyou might use bool with various numbers:\n>>> print(bool(0))\nFalse\n>>> print(bool(1))\nTrue\n>>> print(bool(1123.23))\nTrue\n>>> print(bool(-500))\nTrue\nWhen you use bool for other values, like strings, it returns False\nif there’s no value for the string (in other words, the keyword None\nor an empty string). Otherwise, it will return True, as shown here:\n>>> print(bool(None))\nFalse\n>>> print(bool('a'))\nTrue\nPython’s Built-in Functions 111\n>>> print(bool(' '))\nTrue\n>>> print(bool('What do you call a pig doing karate? Pork Chop!'))\nTrue\nThe bool function will also return False for lists, tuples, and\nmaps that do not contain any values, or True when they do:\n>>> my_silly_list = []\n>>> print(bool(my_silly_list))\nFalse\n>>> my_silly_list = ['s', 'i', 'l', 'l', 'y']\n>>> print(bool(my_silly_list))\nTrue\nYou might use bool when you need to decide whether a value\nhas been set or not. For example, if we ask people using our pro-\ngram to enter the year they were born, our if statement could use\nbool to test the value they enter:\n>>> year = input('Year of birth: ')\nYear of birth:\n>>> if not bool(year.rstrip()):\nprint('You need to enter a value for your year of birth')\nYou need to enter a value for your year of birth\nThe first line of this example uses\ninput to store what someone enters\non the keyboard as the variable year.\nPressing enter on the next line (with-\nout typing anything else) stores the\nvalue of the enter key in the vari-\nable. (We used sys.stdin.readline()\nback in Chapter 7, which is another\nway to do the same thing.)\nOn the following line, the if state-\nment checks the Boolean value of the\nvariable after using the rstrip func-\ntion (which removes any spaces and enter characters from the\nend of the string). Because the user didn’t enter anything in this\nexample, the bool function returns false. Because this if statement\nuses the not keyword, it is a way of saying, “do this if the function\ndoes not return true,” and so the code prints You need to enter a\nvalue for your year of birth on the next line.\n112 Chapter 9\nthe dir function\nThe dir function (short for directory) returns information about any\nvalue. Basically, it tells you the functions that can be used with\nthat value in alphabetical order.\nFor example, to display the functions that are available for a\nlist value, enter this:\n>>> dir(['a', 'short', 'list'])\n['__add__', '__class__', '__contains__', '__delattr__',\n'__delitem__', '__doc__', '__eq__', '__format__', '__ge__',\n'__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__',\n'__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__',\n'__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',\n'__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__',\n'__sizeof__', '__str__', '__subclasshook__', 'append', 'count',\n'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']\nThe dir function works on pretty much anything, includ-\ning strings, numbers, functions, modules, objects, and classes.\nBut sometimes the information it returns may not be very useful.\nFor example, if you call dir on the number 1, it displays a number\nof special functions (those that start and end with underscores)\nused by Python itself, which isn’t really useful (you can usually\nignore most of them):\n>>> dir(1)\n['__abs__', '__add__', '__and__', '__bool__', '__ceil__',\n'__class__', '__delattr__', '__divmod__', '__doc__', '__eq__',\n'__float__', '__floor__', '__floordiv__', '__format__', '__ge__',\n'__getattribute__', '__getnewargs__', '__gt__', '__hash__',\n'__index__', '__init__', '__int__', '__invert__', '__le__',\n'__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__',\n'__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__',\n'__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__',\n'__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__',\n'__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__',\n'__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__',\n'__sub__', '__subclasshook__', '__truediv__', '__trunc__',\n'__xor__', 'bit_length', 'conjugate', 'denominator', 'imag',\n'numerator', 'real']\nThe dir function can be useful when you have a variable and\nquickly want to find out what you can do with it. For example, run\nPython’s Built-in Functions 113\ndir using the variable popcorn containing a string value, and you\nget the list of functions provided by the string class (all strings are\nmembers of the string class):\n>>> popcorn = 'I love popcorn!'\n>>> dir(popcorn)\n['__add__', '__class__', '__contains__', '__delattr__', '__doc__',\n'__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__',\n'__getnewargs__', '__gt__', '__hash__', '__init__', '__iter__',\n'__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__',\n'__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__',\n'__rmul__', '__setattr__', '__sizeof__', '__str__',\n'__subclasshook__', 'capitalize', 'center', 'count', 'encode',\n'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index',\n'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier',\n'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle',\n'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'parti-\ntion', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition',\n'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip',\n'swapcase', 'title', 'translate', 'upper', 'zfill']\nAt this point, you could use help to get a short description of\nany function in the list. Here’s an example of running help against\nthe upper function:\n>>> help(popcorn.upper)\nHelp on built-in function upper:\nupper(...)\nS.upper() -> str\nReturn a copy of S converted to uppercase.\nThe information returned can be a little confusing, so let’s\ntake a closer look. The ellipsis (...) means that upper is a built-in\nfunction of the string class and, in this case, takes no parameters.\nThe arrow (->) on the next line means that this function returns a\nstring (str). The last line offers a brief description of what the func-\ntion does.\nthe eval function\nThe eval function (short for evaluate) takes a string as a parameter\nand runs it as though it were a Python expression. For example,\neval('print(\"wow\")') will actually run the statement print(\"wow\").\n114 Chapter 9\nThe eval function works only with simple expressions, such as\nthe following:\n>>> eval('10*5')\n50\nExpressions that are split over more than one line (such as if\nstatements) generally won’t evaluate, as in this example:\n>>> eval('''if True:\nprint(\"this won't work at all\")''')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"<string>\", line 1\nif True: print(\"this won't work at all')\n^\nSyntaxError: invalid syntax\nThe eval function is often used to turn user input into Python\nexpressions. For example, you could write a simple calculator pro-\ngram that reads equations entered into Python and then calculates\n(evaluates) the answers.\nSince user input is read in as a string, Python needs to convert\nit into numbers and operators before doing any calculations. The\neval function makes that conversion easy:\n>>> your_calculation = input('Enter a calculation: ')\nEnter a calculation: 12*52\n>>> eval(your_calculation)\n624\nPython’s Built-in Functions 115\nIn this example, we use input to read what the user enters into\nthe variable your_calculation. On the next line, we enter the expres-\nsion 12*52 (perhaps your age multiplied by the number of weeks\nin a year). We use eval to run this calculation, and the result is\nprinted on the final line.\nthe exec function\nThe exec function is like eval, except that you can use it to run more\ncomplicated programs. The difference between the two is that eval\nreturns a value (something that you can save in a variable), whereas\nexec does not. Here’s an example:\n>>> my_small_program = '''print('ham')\nprint('sandwich')'''\n>>> exec(my_small_program)\nham\nsandwich\nIn the first two lines, we create a variable with a multiline\nstring containing two print statements, and then use exec to run\nthe string.\nYou could use exec to run mini programs that your Python pro-\ngram reads in from files—really, programs inside programs! This\ncan be quite useful when writing long, complicated applications.\nFor example, you could create a Dueling Robots game, where two\nrobots move around a screen and try to attack each other. Players\nof the game would provide the instructions for their robot as mini\nPython programs. The Dueling Robots game would read in these\nscripts and use exec to run.\nthe float function\nThe float function converts a\nstring or a number into a floating-\npoint number, which is a number\nwith a decimal place (also called\na real number). For example, the\nnumber 10 is an integer (also\ncalled a whole number), but 10.0,\n10.1, and 10.253 are all floating-\npoint numbers (also called floats).\n116 Chapter 9\nYou can convert a string to a float simply by calling float,\nlike this:\n>>> float('12')\n12.0\nYou can use a decimal place in a string as well:\n>>> float('123.456789')\n123.456789\nYou might use float to convert values entered into your pro-\ngram into proper numbers, which is particularly useful when you\nneed to compare the value a person enters with other values. For\nexample, to check whether a person’s age is above a certain num-\nber, we could do this:\n>>> your_age = input('Enter your age: ')\nEnter your age: 20\n>>> age = float(your_age)\n>>> if age > 13:\nprint('You are %s years too old' % (age - 13))\nYou are 7.0 years too old\nthe int function\nThe int function converts a string or a number into a whole num-\nber (or integer), which basically means that everything after the\ndecimal point is dropped. For example, here’s how to convert a\nfloating-point number into a plain integer:\n>>> int(123.456)\n123\nThis example converts a string to an integer:\n>>> int('123')\n123\nBut try to convert a string containing a floating-point number\ninto an integer, and you get an error message. For example, here\nPython’s Built-in Functions 117\nwe try to convert a string containing a floating-point number using\nthe int function:\n>>> int('123.456')\nTraceback (most recent call last):\nFile \"<pyshell>\", line 1, in <module>\nint('123.456')\nValueError: invalid literal for int() with base 10: '123.456'\nAs you can see, the result is a ValueError message.\nthe len function\nThe len function returns\nthe length of an object or,\nin the case of a string, the\nnumber of characters in the\nstring. For example, to get\nthe length of this is a test\nstring, you would do this:\n>>> len('this is a test string')\n21\nWhen used with a list or a tuple, len returns the number of\nitems in that list or tuple:\n>>> creature_list = ['unicorn', 'cyclops', 'fairy', 'elf', 'dragon',\n'troll']\n>>> print(len(creature_list))\n6\nUsed with a map, len also returns the number of items in\nthe map:\n>>> enemies_map = {'Batman' : 'Joker',\n'Superman' : 'Lex Luthor',\n'Spiderman' : 'Green Goblin'}\n>>> print(len(enemies_map))\n3\n118 Chapter 9\nThe len function is particularly useful when you’re working\nwith loops. For example, we could use it to display the index posi-\ntions of the elements in a list like this:\n>>> fruit = ['apple', 'banana', 'clementine', 'dragon fruit']\nu >>> length = len(fruit)\nv >>> for x in range(0, length):\nw print('the fruit at index %s is %s' % (x, fruit[x]))\nthe fruit at index 0 is apple\nthe fruit at index 1 is banana\nthe fruit at index 2 is clementine\nthe fruit at index 3 is dragon fruit\nHere, we store the length of the list in\nthe variable length at u, and then use that\nvariable in the range function to create our\nloop at v. At w, as we loop through each item\nin the list, we print a message showing the\nitem’s index position and value. You could\nalso use the len function, if you had a list of\nstrings and wanted to print every second or\nthird item in the list.\nthe max and min functions\nThe max function returns the largest item in a\nlist, tuple, or string. For example, here’s how\nto use it with a list of numbers:\n>>> numbers = [5, 4, 10, 30, 22]\n>>> print(max(numbers))\n30\nA string with the characters separated by commas or spaces\nwill also work:\n>>> strings = 's,t,r,i,n,g,S,T,R,I,N,G'\n>>> print(max(strings))\nt\nPython’s Built-in Functions 119\nAs this example shows, letters are ranked alphabetically, and\nlowercase letters come after uppercase letters, so t is more than T.\nBut you don’t have to use lists, tuples, or strings. You can also\ncall the max function directly, and enter the items that you want to\ncompare into the parentheses as parameters:\n>>> print(max(10, 300, 450, 50, 90))\n450\nThe min function works like max, except that it returns the\nsmallest item in the list, tuple, or string. Here’s our list of num-\nbers example using min instead of max:\n>>> numbers = [5, 4, 10, 30, 22]\n>>> print(min(numbers))\n4\nSuppose you were playing a guessing game with a team of four\nplayers, and each had to guess a number that was less than your\nnumber. If any player guesses above your number, all players lose,\nbut if they all guess lower, they win. We could use max to quickly\nfind whether all of the guesses are lower, like so:\n>>> guess_this_number = 61\n>>> player_guesses = [12, 15, 70, 45]\n>>> if max(player_guesses) > guess_this_number:\nprint('Boom! You all lose')\nelse:\nprint('You win')\nBoom! You all lose\nIn this example, we store the number to guess using the vari-\nable guess_this_number. The team members’ guesses are stored in\nthe list player_guesses. The if statement checks the maximum guess\nagainst the number in guess_this_number, and if any player guesses\nover the number, we print the message “Boom! You all lose.”\n120 Chapter 9\nthe range function\nThe range function, as we’ve\nseen before, is mainly used in\nfor loops, to loop through a sec-\ntion of code a specific number of\ntimes. The first two parameters\ngiven to range are called the start\nand the stop. You saw range with\nthese two parameters in the ear-\nlier example of using the len\nfunc tion to work with a loop.\nThe numbers that range generates begin with the number given\nas the first parameter and end with the number that’s one less than\nthe second parameter. For example, the following shows what hap-\npens when we print the numbers that range creates between 0 and 5:\n>>> for x in range(0, 5):\nprint(x)\n0\n1\n2\n3\n4\nThe range function actually returns a special object called an\niterator that repeats an action a number of times. In this case, it\nreturns the next highest number each time it is called.\nYou can convert the iterator into a list (using the function list).\nIf you then print the returned value when calling range, you’ll see\nthe numbers it contains as well:\n>>> print(list(range(0, 5)))\n[0, 1, 2, 3, 4]\nPython’s Built-in Functions 121\nYou can also add a third parameter to range, called step. If\nthe step value is not included, the number 1 is used as the step by\ndefault. But what happens when we pass in the number 2 as the\nstep? Here’s the result:\n>>> count_by_twos = list(range(0, 30, 2))\n>>> print(count_by_twos)\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28]\nEach number in the list increases by two from the previous\nnumber, and the list ends with the number 28, which is 2 less\nthan 30. You can also use negative steps:\n>>> count_down_by_twos = list(range(40, 10, -2))\n>>> print(count_down_by_twos)\n[40, 38, 36, 34, 32, 30, 28, 26, 24, 22, 20, 18, 16, 14, 12]\nthe sum function\nThe sum function adds items in a list and returns the total. Here’s\nan example:\n>>> my_list_of_numbers = list(range(0, 500, 50))\n>>> print(my_list_of_numbers)\n[0, 50, 100, 150, 200, 250, 300, 350, 400, 450]\n>>> print(sum(my_list_of_numbers))\n2250\nOn the first line, we create a list of numbers between 0 and\n500, using range with a step of 50. Next, we print the list to see the\nresult. Finally, passing the variable my_list_of_numbers to the sum\nfunction with print(sum(my_list_of_numbers)) adds all the items in\nthe list, giving the total of 2250.\nWorking with files\nPython files are the same as other files on your computer: docu-\nments, pictures, music, games . . . indeed, everything on your\ncomputer is stored as files.\nLet’s look at how to open and work with files in Python by\nusing the built-in function open. But first we need to create a\nnew file to play with.\n122 Chapter 9\nCreating a test file\nWe’ll experiment with a text file we’ll call test.txt. Follow the steps\nfor the operating system you’re using.\nCreating a new file in Windows\nIf you’re using Windows, follow these steps to create test.txt:\n1. Select Start4All Programs4Accessories4Notepad.\n2. Enter a few lines into the empty file.\n3. Select File4Save.\n4. When the dialog appears, select the C: drive by double-clicking\nMy Computer and then double-clicking Local Disk (C:).\n5. Enter test.txt in the File name box at the bottom of the dialog.\n6. Finally, click the Save button.\nCreating a new file in Mac os X\nIf you’re using a Mac, follow these steps to create test.txt:\n1. Click the Spotlight icon in the menu bar at the top of the\nscreen.\n2. Enter TextEdit in the search box that appears.\nPython’s Built-in Functions 123\n3. TextEdit should appear in the Applications section. Click it to\nopen the editor (you can also find TextEdit in the Applications\nfolder in Finder).\n4. Type a few lines of text into the empty file.\n5. Select Format4Make Plain Text.\n6. Select File4Save.\n7. In the Save As box, enter test.txt.\n8. In the Places list, click your username—the name you logged\nin with or the name of the person who owns the computer\nyou’re using.\n9. Finally, click the Save button.\nCreating a new file in Ubuntu\nIf you’re using Ubuntu, follow these steps to create test.txt:\n1. Open your editor, which is usually called Text Editor. If you\nhaven’t used it before, search for it in the Applications menu.\n2. Enter a few lines of text in the editor.\n3. Select File4Save.\n4. In the Name box, enter test.txt for the filename. Your home\ndirectory may already be selected in the box labeled Save in\nFolder, but if not, click it in the Places list. (Your home direc-\ntory is the username that you are logged in with.)\n124 Chapter 9\n5. Click the Save button.\nopening a file in Python\nPython’s built-in open function opens a file in the Python shell and\ndisplays its contents. How you tell the function which file to open\ndepends on your operating system. Look over the example for a\nWindows file, and then read the Mac- or Ubuntu-specific section\nif you’re using one of those systems.\nopening a Windows file\nIf you’re using Windows, enter the following code to open test.txt:\n>>> test_file = open('c:\\\\test.txt')\n>>> text = test_file.read()\n>>> print(text)\nThere once was a boy named Marcelo\nWho dreamed he ate a marshmallow\nHe awoke with a start\nAs his bed fell apart\nAnd he found he was a much rounder fellow\nOn the first line, we use open, which returns a file object with\nfunctions for working with files. The parameter we use with the\nopen function is a string telling Python where to find the file. If\nyou’re using Windows, you saved test.txt to the local disk on the C:\ndrive, so you specify the location of your file as c:\\\\test.txt.\nPython’s Built-in Functions 125\nThe two backslashes in the Windows filename tell Python\nthat the backslash is just that, and not some sort of command. (As\nyou learned in Chapter 3, backslashes on their own have a special\nmeaning in Python, particularly in strings.) We save the file object\nto the variable test_file.\nOn the second line, we use the read function, provided by the\nfile object, to read the contents of the file and store it in the vari-\nable text. We print the variable on the final line to display the\ncontents of the file.\nopening a Mac os X file\nIf you are using Mac OS X, you’ll need to enter a different loca-\ntion on the first line of the Windows example to open test.txt. Use\nthe username you clicked when saving the text file in the string.\nFor example, if the username is sarahwinters, the open parameter\nshould look like this:\n>>> test_file = open('/Users/sarahwinters/test.txt')\nopening an Ubuntu file\nIf you are using Ubuntu, you’ll need to enter a different location\non the first line of the Windows example to open test.txt. Use the\nusername you clicked when saving the text file. For example, if\nthe username is jacob, the open parameter should look like this:\n>>> test_file = open('/home/jacob/test.txt')\nWriting to files\nThe file object returned by open has other functions besides read.\nWe can create a new, empty file by using a second parameter, the\nstring 'w', when we call the function:\n>>> test_file = open('c:\\\\myfile.txt', 'w')\nThe parameter 'w' tells Python that we want to write to the\nfile object, rather than read from it.\n126 Chapter 9\nWe can now add information to this new file using the write\nfunction:\n>>> test_file = open('c:\\\\myfile.txt', 'w')\n>>> test_file.write('this is my test file')\nFinally, we need to tell Python when we’re finished writing to\nthe file, using the close function:\n>>> test_file = open('c:\\\\myfile.txt', 'w')\n>>> test_file.write('What is green and loud? A froghorn!')\n>>> test_file.close()\nNow, if you open the file with your text editor, you should see\nthat it contains the text “What is green\nand loud? A froghorn!” Or, you can use\nPython to read it again:\n>>> test_file = open('myfile.txt')\n>>> print(test_file.read())\nWhat is green and loud? A froghorn!\nWhat You Learned\nIn this chapter, you learned about Python’s built-in functions, such\nas float and int, which can turn numbers with decimal points into\nintegers and vice versa. You also saw how the len function can make\nlooping easier, and how Python can be used to open files in order\nto read from them and write to them.\nProgramming Puzzles\nTry the following examples to experiment with some of Python’s\nbuilt-in functions. Find the answers at http://python-for-kids.com/.\n#1: Mystery Code\nWhat will be the result of running the following code? Guess, and\nthen run the code to see if you’re right.\nPython’s Built-in Functions 127\n>>> a = abs(10) + abs(-10)\n>>> print(a)\n>>> b = abs(-10) + -10\n>>> print(b)\n#2: A Hidden Message\nTry using dir and help to find out how to break a string into words,\nand then create a small program to print every other word in the\nfollowing string, starting with the first word (this):\n\"this if is you not are a reading very this good then way you to have\nhide done a it message wrong\"\n#3: Copying a file\nCreate a Python program to copy a file. (Hint: You’ll need to open\nthe file that you want to copy, read it in, and then create a new\nfile—the copy.) Check that your program works by printing the\ncontents of the new file on the screen.\n128 Chapter 9"
  },
  {
    "input": "What are some of the most useful Python modules discussed in this chapter and what are their primary functions?",
    "summary": "Python modules group functions, classes, and variables to make them easier to use. This chapter covers useful modules like copy, random, time, and pickle, which allow for object copying, random number generation, time handling, and saving/loading data. The turtle module is also explored, showing how to draw shapes, use colors, and fill them.",
    "output": "10\nUsefUL PYtHon\nMoDULes\nAs you learned in Chapter 7, a Python module is\nany combination of functions, classes, and variables.\nPython uses modules to group functions and classes\nin order to make them easier to use. For example, the\nturtle module, which we used in previous chapters,\ngroups functions and classes that are used to create\na canvas for a turtle to draw on the screen.\nWhen you import a module into a program, you can use all of\nits contents. For example, when we imported the turtle module in\nChapter 4, we had access to the Pen class, which we used to create\nan object representing the turtle’s canvas:\n>>> import turtle\n>>> t = turtle.Pen()\nPython has a lot of modules for doing all sorts of different\ntasks. In this chapter, we’ll look at some of the most useful ones\nand try some of their functions.\nMaking Copies with the copy Module\nThe copy module contains functions\nfor creating copies of objects. Usu-\nally, when writing a program, you’ll\ncreate new objects, but sometimes\nit’s useful to create a copy of an\nobject, and then use that copy to\ncreate a new object, particularly\nwhen the process of creating an\nobject takes several steps.\nFor example, suppose we have\nan Animal class, with an __init__\nfunction that takes the parameters\nname, number_of_legs, and color.\n>>> class Animal:\ndef __init__(self, species, number_of_legs, color):\nself.species = species\nself.number_of_legs = number_of_legs\nself.color = color\nWe could create a new object in the class Animal using the fol-\nlowing code. Let’s create a pink hippogriff with six legs, called harry.\n>>> harry = Animal('hippogriff', 6, 'pink')\n130 Chapter 10\nSuppose we want a herd of pink hippogriffs with six legs? We\ncould repeat the previous code over and over again, or use copy,\nwhich can be found in the copy module:\n>>> import copy\n>>> harry = Animal('hippogriff', 6, 'pink')\n>>> harriet = copy.copy(harry)\n>>> print(harry.species)\nhippogriff\n>>> print(harriet.species)\nhippogriff\nIn this example, we create an object and label it with the\nvariable harry, and then we create a copy of that object and label\nit harriet. These are two completely different objects, even though\nthey have the same species. This saves only a bit of typing, but\nwhen the objects are a lot more complicated, being able to copy\nthem can be useful.\nWe can also create and copy a list of Animal objects.\n>>> harry = Animal('hippogriff', 6, 'pink')\n>>> carrie = Animal('chimera', 4, 'green polka dots')\n>>> billy = Animal('bogill', 0, 'paisley')\n>>> my_animals = [harry, carrie, billy]\n>>> more_animals = copy.copy(my_animals)\n>>> print(more_animals[0].species)\nhippogriff\n>>> print(more_animals[1].species)\nchimera\nIn the first three lines, we create\nthree Animal objects and store them in\nharry, carrie, and billy. On the fourth line,\nwe add these objects to the list my_animals.\nNext, we use copy to create a new list,\nmore_animals. Finally, we print the species\nof the first two objects ([0] and [1]) in the\nmore_animals list and see that they’re the\nsame as in the original list: hippogriff\nand chimera. We’ve made a copy of the list\nwithout needing to create the objects all\nover again.\nUseful Python Modules 131\nBut look what happens if we change the species of one of our\nAnimal objects in the original my_animals list (hippogriff to ghoul).\nPython changes the species in more_animals, too.\n>>> my_animals[0].species = 'ghoul'\n>>> print(my_animals[0].species)\nghoul\n>>> print(more_animals[0].species)\nghoul\nThat’s odd. Didn’t we change the species in my_animals only?\nWhy did the species change in both lists?\nThe species changed because copy actually makes a shallow\ncopy, which means it doesn’t copy objects inside the objects we cop-\nied. Here, it has copied the main list object but not the individual\nobjects inside the list. So we end up with a new list that does not\nhave its own new objects—the list more_animals has the same three\nobjects inside it.\nBy the same token, if we add a new animal to the first list\n(my_animals), it doesn’t appear in the copy (more_animals). As proof,\nprint the length of each list after adding another animal, like this:\n>>> sally = Animal('sphinx', 4, 'sand')\n>>> my_animals.append(sally)\n>>> print(len(my_animals))\n4\n>>> print(len(more_animals))\n3\nAs you can see, when we append a new animal to the first list,\nmy_animals, it isn’t added to the copy of that list, more_animals. When\nwe use len and print the results, the first list has four elements\nand the second has three.\nAnother function in the copy module, deepcopy, actually creates\ncopies of all objects inside the object being copied. When we use\ndeepcopy to copy my_animals, we get a new list complete with copies of\nall of its objects. As a result, changes to one of our original Animal\nobjects won’t affect the objects in the new list. Here’s an example:\n>>> more_animals = copy.deepcopy(my_animals)\n>>> my_animals[0].species = 'wyrm'\n>>> print(my_animals[0].species)\nwyrm\n132 Chapter 10\n>>> print(more_animals[0].species)\nghoul\nWhen we change the species of the first object in the original\nlist from ghoul to wyrm, the copied list doesn’t change, as we can see\nwhen we print the species of the first object in each list.\nKeeping track of Keywords with the\nkeyword Module\nA Python keyword is any word in Python that is part of the lan-\nguage itself, such as if, else, and for. The keyword module contains\na function named iskeyword and a variable called kwlist. The func-\ntion iskeyword returns true if any string is a Python keyword. The\nvariable kwlist returns a list of all Python keywords.\nNotice in the following code that the function iskeyword returns\ntrue for the string if and false for the string ozwald. You can see\nthe full list of keywords when we print the contents of the variable,\nwhich is useful because keywords don’t always stay the same. New\nversions (or older versions) of Python may have different keywords.\n>>> import keyword\n>>> print(keyword.iskeyword('if'))\nTrue\n>>> print(keyword.iskeyword('ozwald'))\nFalse\n>>> print(keyword.kwlist)\n['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class',\n'continue', 'def', 'del', 'elif', 'else', 'except', 'finally',\n'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda',\n'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while',\n'with', 'yield']\nYou can find a description of each keyword in the Appendix.\nGetting Random numbers with the\nRandom Module\nThe random module contains a number of functions that are useful\nfor generating random numbers—kind of like asking the c omputer\nto “pick a number.” The most useful functions in the random module\nare randint, choice, and shuffle.\nUseful Python Modules 133\nUsing randint to Pick a Random number\nThe randint function picks a random number between a range\nof numbers, say between 1 and 100, between 100 and 1000, or\nbetween 1000 and 5000. Here’s an example:\n>>> import random\n>>> print(random.randint(1, 100))\n58\n>>> print(random.randint(100, 1000))\n861\n>>> print(random.randint(1000, 5000))\n3795\nYou might use randint to do something like create a simple (and\nannoying) guessing game, using a while loop, like this:\n>>> import random\n>>> num = random.randint(1, 100)\nu >>> while True:\nv print('Guess a number between 1 and 100')\nw guess = input()\nx i = int(guess)\ny if i == num:\nprint('You guessed right')\nz break\n{ elif i < num:\nprint('Try higher')\n| elif i > num:\nprint('Try lower')\nFirst, we import the random module, and\nthen we set the variable num to a random num-\nber using randint with a range of 1 to 100. We\nthen create a while loop at u that will loop\nforever (or at least until the player guesses\nthe number).\nNext, we print a message at v, and then use input to get input\nfrom the user, which we store in the variable guess at w. We con-\nvert the input to a number using int, and save it in the variable i\nat x. Then we compare it with the randomly selected number at y.\nIf the input and the randomly generated number are equal, we\nprint “You guessed right,” and then exit the loop at z. If the num-\nbers aren’t equal, we check to see if the number the player guessed\n134 Chapter 10\nis higher than the random number at {, or lower at |, and print a\nhint message accordingly.\nThis code is a bit long, so you may want to type it into a new\nshell window or create a text document, save it, and then run it in\nIDLE. Here’s a reminder of how to open and run a saved program:\n1. Start IDLE and choose File4Open.\n2. Browse to the directory where you saved the file, and click the\nfilename to select it.\n3. Click Open.\n4. After the new window opens, choose Run4Run Module.\nHere’s what happens when we run the program:\nUsing choice to Pick a Random Item\nfrom a List\nIf you want to pick a random item from a list instead of a random\nnumber from a given range, you can use choice. For example, you\nmight want Python to choose your dessert for you.\n>>> import random\n>>> desserts = ['ice cream', 'pancakes', 'brownies', 'cookies',\n'candy']\nUseful Python Modules 135\n>>> print(random.choice(desserts))\nbrownies\nLooks like you’ll be having brownies—not a bad choice at all.\nUsing shuffle to shuffle a List\nThe shuffle function shuffles a list, mixing up the items. If you’re\nworking along in IDLE and you just imported random and created\nthe desserts list in the previous example, you could skip right to the\nrandom.shuffle command in the following code.\n>>> import random\n>>> desserts = ['ice cream', 'pancakes', 'brownies', 'cookies',\n'candy']\n>>> random.shuffle(desserts)\n>>> print(desserts)\n['pancakes', 'ice cream', 'candy', 'brownies', 'cookies']\nYou can see the results of the shuffle when we print the list—\nthe order is completely different. If you were writing a card game,\nyou might use this to shuffle a list representing a deck of cards.\nControlling the shell with the\nsys Module\nThe sys module contains system functions that you can use to\ncontrol the Python shell itself. Here, we’ll look at how to use exit\nfunction, stdin and stdout objects, and version variable.\nexiting the shell with the exit function\nThe exit function is a way of stopping the Python shell or console.\nEnter the following code, and you’ll be prompted with a dialog ask-\ning if you want to exit. Click Yes, and the shell will shut down.\n>>> import sys\n>>> sys.exit()\n136 Chapter 10\nThis won’t work if you’re not using the modified version of\nIDLE that we set up in Chapter 1. Instead, you’ll get an error,\nlike this:\n>>> import sys\n>>> sys.exit()\nTraceback (most recent call last):\nFile \"<pyshell#1>\", line 1, in <module>\nsys.exit()\nSystemExit\nReading with the stdin object\nThe stdin object (short for standard input) in the sys module prompts\na user to enter information to be read into the shell and used by the\nprogram. As you learned in Chapter 7, this object has a readline\nfunction, which is used to read a line of text typed on the keyboard\nuntil the user presses enter. It works like the input function that\nwe used in the random number guessing game earlier in this chap-\nter. For example, enter the following:\n>>> import sys\n>>> v = sys.stdin.readline()\nHe who laughs last thinks slowest\nPython will store the string He who laughs last thinks slowest in\nthe variable v. To confirm this, print the contents of v:\n>>> print(v)\nHe who laughs last thinks slowest\nOne of the differences between input and the readline function\nis that with readline, you can specify the number of characters to\nread as a parameter. For example:\n>>> v = sys.stdin.readline(13)\nHe who laughs last thinks slowest\n>>> print(v)\nHe who laughs\nUseful Python Modules 137\nWriting with the stdout object\nUnlike stdin, the stdout object (short for standard output) can be\nused to write messages to the shell (or console), rather than read-\ning them in. In some ways, it’s the same as print, but stdout is a file\nobject, so it has the same functions we used in Chapter 9, such as\nwrite. Here’s an example:\n>>> import sys\n>>> sys.stdout.write(\"What does a fish say when it swims into a wall?\nDam.\")\nWhat does a fish say when it swims into a wall? Dam.52\nNotice that when write finishes, it returns a count of the num-\nber of characters it has written. You can see 52 printed into the\nshell at the end of the message. We could save this value to a vari-\nable in order to record, over time, how many characters we have\nwritten to the screen.\nWhich Version of Python Am I Using?\nThe variable version displays your ver-\nsion of Python, which can be useful if\nyou want to make sure you’re up-to-date.\nSome programmers like to print infor-\nmation when their programs start up.\nFor example, you might put the version\nof Python into an About window of your\nprogram, like this:\n>>> import sys\n>>> print(sys.version)\n3.1.2 (r312:79149, Mar 21 2013, 00:41:52) [MSC v.1500 32 bit (Intel)]\nDoing time with the time module\nPython’s time module contains functions for displaying the time,\nthough not necessarily as you might expect. Try this:\n>>> import time\n>>> print(time.time())\n1300139149.34\n138 Chapter 10\nThe number returned by the call to\ntime() is actually the number of seconds\nsince January 1, 1970, at 00:00:00 AM\nto be exact. On its own, this unusual ref-\nerence point may not seem immediately\nuseful, but it can serve a purpose. For example, to find out how\nlong parts of your program take to run, you can record the time at\nthe beginning and end, and compare the values. Let’s try this to\nfind out how long it will take to print all numbers from 0 to 999.\nFirst, create a function like this:\n>>> def lots_of_numbers(max):\nfor x in range(0, max):\nprint(x)\nNext, call the function with max set to 1000:\n>>> lots_of_numbers(1000)\nThen work out how long the function takes by modifying our\nprogram with the time module.\n>>> def lots_of_numbers(max):\nu t1 = time.time()\nv for x in range(0, max):\nprint(x)\nw t2 = time.time()\nx print('it took %s seconds' % (t2-t1))\nCalling the program again, we get the following result (which\nwill vary depending on the speed of your system):\n>>> lots_of_numbers(1000)\n0\n1\n2\n3\n.\n.\n.\n997\n998\n999\nit took 50.159196853637695 seconds\nUseful Python Modules 139\nHere’s how this works: The first time we call the time() func-\ntion, we assign the value returned to the variable t1 at u. We then\nloop and print all the numbers in the third and fourth lines at v.\nAfter the loop, we again call time(), and assign the value returned\nto the variable t2 at w. Since it took several seconds for the loop to\ncomplete, the value in t2 will be higher than t1 because more sec-\nonds will have passed since January 1, 1970. Subtracting t1 from\nt2 as we do at x, we get the number of seconds it took to print all\nthose numbers.\nConverting a Date with asctime\nThe function asctime takes a date as a tuple and converts it into\nsomething more readable. (Remember that a tuple is like a list\nwith items that you can’t change.) As you saw in Chapter 7, calling\nasctime without any parameters will display the current date and\ntime in a readable form.\n>>> import time\n>>> print(time.asctime())\nMon Mar 11 22:03:41 2013\nTo call asctime with a parameter, we first create a tuple with\nvalues for the date and time. For example, here we assign the tuple\nto the variable t:\n>>> t = (2007, 5, 27, 10, 30, 48, 6, 0, 0)\nThe values in the sequence are year, month, day, hours, min-\nutes, seconds, day of the week (0 is Monday, 1 is Tuesday, and so\non), day of the year (we put 0 as a placeholder), and whether or not\nit is daylight saving time (0 if it isn’t; 1 if it is). Calling asctime with\na similar tuple, we get this:\n>>> import time\n>>> t = (2020, 2, 23, 10, 30, 48, 6, 0, 0)\n>>> print(time.asctime(t))\nSun Feb 23 10:30:48 2020\nGetting the Date and time with l ocaltime\nUnlike asctime, the function localtime returns the current date\nand time as an object, with the values in roughly the same order\n140 Chapter 10\nas asctime input. If you print the object, you’ll see the name of the\nclass, and each of the values labeled as tm_year, tm_mon (for month),\ntm_mday (for day of the month), tm_hour, and so on.\n>>> import time\n>>> print(time.localtime())\ntime.struct_time(tm_year=2020, tm_mon=2, tm_mday=23, tm_hour=22,\ntm_min=18, tm_sec=39, tm_wday=0, tm_yday=73, tm_isdst=0)\nTo print the current year and month, you can use their index\npositions (as with the tuple we used with asctime). Based on our\nexample, we know that year is in the first position (position 0) and\nmonth is in the second position (1). Therefore, we use year = t[0]\nand month = t[1], like this:\n>>> t = time.localtime()\n>>> year = t[0]\n>>> month = t[1]\n>>> print(year)\n2020\n>>> print(month)\n2\nAnd we see that we’re in the second month of 2020.\ntaking some time off with sleep\nThe function sleep is quite use-\nful when you want to delay or\nslow down your program. For\nexample, to print every second\nfrom 1 to 61, we could use the\nfollowing loop:\n>>> for x in range(1, 61):\nprint(x)\nThis code will rapidly print all numbers from 1 to 60. However,\nwe can tell Python to sleep for a second between each print state-\nment, like this:\n>>> for x in range(1, 61):\nprint(x)\ntime.sleep(1)\nUseful Python Modules 141\nThis adds a delay between the display of each number. In\nChapter 12, we’ll use the sleep function to make an animation a\nbit more realistic.\nUsing the pickle Module to save\nInformation\nThe pickle module is used to convert\nPython objects into something that can\nbe written into a file and then easily read\nback out. You might find pickle useful if\nyou’re writing a game and want to save\ninformation about a player’s progress. For\nexample, here’s how we might add a save\nfeature to a game:\n>>> game_data = {\n'player-position' : 'N23 E45',\n'pockets' : ['keys', 'pocket knife', 'polished stone'],\n'backpack' : ['rope', 'hammer', 'apple'],\n'money' : 158.50\n}\nHere, we create a Python map containing the player’s current\nposition in our imaginary game, a list of the items in the player’s\npockets and backpack, and the amount of money the player is carry-\ning. We can save this map to a file by opening the file for writing\nand then calling pickle’s dump function, like this:\nu >>> import pickle\nv >>> game_data = {\n'player-position' : 'N23 E45',\n'pockets' : ['keys', 'pocket knife', 'polished stone'],\n'backpack' : ['rope', 'hammer', 'apple'],\n'money' : 158.50\n}\nw >>> save_file = open('save.dat', 'wb')\nx >>> pickle.dump(game_data, save_file)\ny >>> save_file.close()\n142 Chapter 10\nWe import the pickle module first at u, and create a map\nof our game data at v. At w, we open the file save.dat with\nthe parameter wb, which tells Python to write the file in binary\nmode (you might need to save this in a directory like /Users/\nmalcolmozwald, /home/susanb/ or C:\\\\Users\\JimmyIpswich, as\nwe did in Chapter 9. At x, we use dump to pass in the map and the\nfile variable as two parameters. Finally, at y, we close the file,\nbecause we’re finished with it.\nnote Plain text files contain only characters that humans can read.\nImages, music files, movies, and pickled Python objects have infor-\nmation that isn’t always readable by humans, so they’re known as\nbinary files. If you were to open the save.dat file, you would see that\nit doesn’t look like a text file; it looks like a jumbled mixture of nor-\nmal text and special characters.\nWe can unpickle objects we’ve written to the file using pickle’s\nload function. When we unpickle something, we reverse the pickle\nprocess: We take the information written into the file and convert\nit back into values that our program can use. The process is simi-\nlar to using the dump function.\n>>> load_file = open('save.dat', 'rb')\n>>> loaded_game_data = pickle.load(load_file)\n>>> load_file.close()\nFirst, we open the file using rb as the parameter, which means\nread binary. We then pass the file to load and set the return value\nto the variable loaded_game_data. Finally, we close the file.\nTo prove that our saved data has been loaded correctly, print\nthe variable:\n>>> print(loaded_game_data)\n{'money': 158.5, 'backpack': ['rope', 'hammer', 'apple'],\n'player-position': 'N23 E45', 'pockets': ['keys', 'pocket knife',\n'polished stone']}\nUseful Python Modules 143\nWhat You Learned\nIn this chapter, you learned how Python modules group functions,\nclasses, and variables, and how to use these functions by import-\ning modules. You’ve seen how to copy objects, generate random\nnumbers, and randomly shuffle lists of objects, as well as how to\nwork with time in Python. Finally, you learned how to save and\nload information from a file using pickle.\nProgramming Puzzles\nTry the following to practice using Python’s modules. Check your\nanswers at http://python-for-kids.com/.\n#1: Copied Cars\nWhat will the following code print?\n>>> import copy\n>>> class Car:\npass\n>>> car1 = Car()\n>>> car1.wheels = 4\n>>> car2 = car1\n>>> car2.wheels = 3\n>>> print(car1.wheels)\nWhat is\nprinted here?\n>>> car3 = copy.copy(car1)\n>>> car3.wheels = 6\n>>> print(car1.wheels)\nWhat is\nprinted here?\n#2: Pickled favorites\nCreate a list of your favorite things, and then use pickle to save\nthem to a file called favorites.dat. Close the Python shell, and then\nreopen it and display your list of favorites by loading the file.\n144 Chapter 10\n11\nMoRe tUR tLe GRAPHICs\nLet’s take another look at the turtle module we began\nusing in Chapter 4. As you’ll see in this chapter, in\nPython, turtles can do a lot more than just draw plain\nblack lines. For example, you can use them to draw\nmore advanced geometric shapes, create different\ncolors, and even fill your shapes with color.\nstarting with the Basic square\nWe’ve already learned how to make the turtle draw simple shapes.\nBefore using the turtle, we need to import the turtle module and\ncreate the Pen object:\n>>> import turtle\n>>> t = turtle.Pen()\nHere’s the code we used to create a square in Chapter 4:\n>>> t.forward(50)\n>>> t.left(90)\n>>> t.forward(50)\n>>> t.left(90)\n>>> t.forward(50)\n>>> t.left(90)\n>>> t.forward(50)\nIn Chapter 6, you learned about for loops. With our newfound\nknowledge, we can make this somewhat tedious code for a square\nsimpler using a for loop:\n>>> t.reset()\n>>> for x in range(1, 5):\nt.forward(50)\nt.left(90)\nOn the first line, we tell the Pen\nobject to reset itself. Next, we start\na for loop that will count from 1 to\n4 with the code range(1, 5). Then,\nwith the following lines, in each\nrun of the loop, we move forward\n50 pixels and turn left 90 degrees.\nBecause we’ve used a for loop, this\ncode is a little shorter than the pre-\nvious version—ignoring the reset\nline, we’ve gone from six lines down\nto three.\n146 Chapter 11\nDrawing stars\nNow, with a few simple changes to our for loop, we can create\nsomething even more interesting. Type in the following:\n>>> t.reset()\n>>> for x in range(1, 9):\nt.forward(100)\nt.left(225)\nThis code produces an eight-point star:\nThe code itself is very similar to the code we used to draw a\nsquare, with a few exceptions:\n• Rather than looping four times with range(1, 5), we loop eight\ntimes with range(1, 9).\n• Rather than moving forward 50 pixels, we move forward\n100 pixels.\n• Rather than turning 90 degrees, we turn 225 degrees to the left.\nNow let’s develop our star just a bit more. By using a 175-degree\nangle and looping 37 times, we can make a star with even more\npoints, using this code:\n>>> t.reset()\n>>> for x in range(1, 38):\nt.forward(100)\nt.left(175)\nMore Turtle Graphics 147\nHere’s the result of running this code:\nWhile we’re playing with stars, here’s the code to produce a\nspiraling star:\n>>> t.reset()\n>>> for x in range(1, 20):\nt.forward(100)\nt.left(95)\nBy changing the degree of the turn and reducing the number\nof loops, the turtle ends up drawing quite a different style of star:\n148 Chapter 11\nUsing similar code, we can\ncreate a variety of shapes, from a\nbasic square to a spiral star. As\nyou can see, by using for loops,\nwe’ve made it much simpler to\ndraw these shapes. Without\nfor loops, our code would have\nrequired a lot of tedious typing.\nNow let’s use an if state-\nment to control how the turtle\nwill turn and draw another star\nvariation. In this example, we\nwant the turtle to turn one angle\nthe first time, and then another\nangle the next time.\n>>> t.reset()\n>>> for x in range(1, 19):\nt.forward(100)\nif x % 2 == 0:\nt.left(175)\nelse:\nt.left(225)\nHere, we create a loop that will run 18 times (range(1, 19)) and\ntell the turtle to move forward 100 pixels (t.forward(100)). New here\nis the if statement (if x % 2 == 0:). This statement checks to see if\nthe variable x contains an even number by using a modulo opera-\ntor, the % in the expression x % 2 == 0, which is a way of saying, “x\nmod 2” is equal to 0.\nThe expression x % 2 essentially says, “What is the amount\nleft over when you divide the number in variable x into two equal\nparts?” For example, if we were to divide 5 balls into two parts, we\nwould get two groups of 2 balls (making a total of 4 balls), and the\nremainder (the amount left over) would be 1 ball, as shown here.\nThis is the\nremainder.\n5 2 2\nMore Turtle Graphics 149\nIf we divided 13 balls into two parts, we would get two groups\nof 6 balls with 1 ball remaining:\nThis is the\nremainder.\n13 6 6\nWhen we check to see if the remainder equals zero after divid-\ning x by 2, we are actually asking whether it can be broken into\ntwo parts with no remainder. This method is a nice way to see if a\nnumber in a variable is even, because even numbers can always be\ndivided into two equal parts.\nOn the fifth line of our code, we tell the turtle to turn left\n175 degrees (t.left(175)) if the number in x is even (if x % 2 == 0:);\notherwise (else), on the final line, we tell it to turn 225 degrees\n(t.left(225)).\nHere’s the result of running this code:\n150 Chapter 11\nDrawing a Car\nThe turtle can do more than just draw stars and simple geometric\nshapes. For our next example, we’ll draw a rather primitive-looking\ncar. First, we draw the body of the car. In IDLE, select File4New\nWindow, and then enter the following code in the window.\nt.reset()\nt.color(1,0,0)\nt.begin_fill()\nt.forward(100)\nt.left(90)\nt.forward(20)\nt.left(90)\nt.forward(20)\nt.right(90)\nt.forward(20)\nt.left(90)\nt.forward(60)\nt.left(90)\nt.forward(20)\nt.right(90)\nt.forward(20)\nt.left(90)\nt.forward(20)\nt.end_fill()\nNext, we draw the first wheel.\nt.color(0,0,0)\nt.up()\nt.forward(10)\nt.down()\nt.begin_fill()\nt.circle(10)\nt.end_fill()\nFinally, we draw the second wheel.\nt.setheading(0)\nt.up()\nt.forward(90)\nt.right(90)\nt.forward(10)\nt.setheading(0)\nMore Turtle Graphics 151\nt.begin_fill()\nt.down()\nt.circle(10)\nt.end_fill()\nSelect File4Save As. Give the file a name, such as car.py.\nSelect Run4Run Module to try out the code. And here’s our car:\nYou may have noticed that a few new turtle functions have\nsnuck into this code:\n• color is used to change the color of the pen.\n• begin_fill and end_fill are used to fill in an area of the canvas\nwith a color.\n• circle draws a circle of a particular size.\n• setheading turns the turtle to face a particular direction.\nLet’s take a look at how we can use these functions to add color\nto our drawings.\nColoring things In\nThe color function takes three parameters. The first specifies the\namount of red, the second the amount of green, and the third\nthe amount of blue. For example, to get the bright red of the car,\nwe used color(1,0,0), which tells the turtle to use a 100 percent\nred pen.\n152 Chapter 11\nThis red, green, and blue color recipe\nis called RGB. It’s the way that colors are\nrepresented on your computer monitor, and\nthe relative mix of these primary colors\nproduces other colors, just like when you\nmix blue and red paint to make purple or\nyellow and red to make orange. The colors\nred, green, and blue are called primary\ncolors because you cannot mix other\nshades to produce them.\nAlthough we’re not using paint when we create colors on a\ncomputer monitor (we’re using light), it may help to understand\nthis RGB recipe by thinking about three pots of paint: one red,\none green, and one blue. Each pot is full, and we give each full pot\na value of 1 (or 100 percent). We then mix all of the red paint and\nall of the green paint in a vat to produce yellow (that’s 1 and 1 of\neach, or 100 percent of each color).\nNow let’s return to the world of code. To draw a yellow circle\nwith the turtle, we would use 100 percent of both the red and\ngreen paint, but no blue, like this:\n>>> t.color(1,1,0)\n>>> t.begin_fill()\n>>> t.circle(50)\n>>> t.end_fill()\nThe 1,1,0 in the first line represents 100 percent red, 100 per-\ncent green, and 0 percent blue. On the next line, we tell the turtle to\nfill the shapes it draws with this RGB color (t.begin_fill), and then\nwe tell it to draw a circle with (t.circle). On the final line, end_fill\ntells the turtle to fill the circle with the RGB color.\nA function to Draw a filled Circle\nTo make it easier to experiment with different colors, let’s create a\nfunction from the code we used to draw a filled circle.\n>>> def mycircle(red, green, blue):\nt.color(red, green, blue)\nt.begin_fill()\nt.circle(50)\nt.end_fill()\nMore Turtle Graphics 153\nWe can draw a bright green circle by using only the green\npaint, with this code:\n>>> mycircle(0, 1, 0)\nOr we can draw a darker green circle by using only half the\ngreen paint (0.5):\n>>> mycircle(0, 0.5, 0)\nTo play with the RGB colors on your screen, try drawing a cir-\ncle first with full red then half red (1 and 0.5), and then with full\nblue and finally half blue, like this:\n>>> mycircle(1, 0, 0)\n>>> mycircle(0.5, 0, 0)\n>>> mycircle(0, 0, 1)\n>>> mycircle(0, 0, 0.5)\nnote If your canvas starts to get cluttered, use t.reset() to delete your\nold drawings. Also remember that you can move the turtle without\ndrawing lines by using t.up() to lift the pen (use t.down() to set it\nback down again).\nVarious combinations of red, green, and blue will produce a\nhuge variety of colors, like gold:\n>>> mycircle(0.9, 0.75, 0)\nHere’s light pink:\n>>> mycircle(1, 0.7, 0.75)\nAnd here are two versions for different shades of orange:\n>>> mycircle(1, 0.5, 0)\n>>> mycircle(0.9, 0.5, 0.15)\nTry mixing some colors yourself!\n154 Chapter 11\nCreating Pure Black and White\nWhat happens when you turn off all the\nlights at night? Everything goes black. The\nsame thing happens with colors on a com-\nputer. No light means no color, so a circle\nwith 0 for all of the primary colors creates\nblack:\n>>> mycircle(0, 0, 0)\nHere’s the result:\nThe opposite is true if you use 100 percent of all three colors.\nIn this case, you get white. Enter the following to wipe out your\nblack circle:\n>>> mycircle(1, 1, 1)\nA square-Drawing function\nYou’ve seen that we fill shapes with color by telling the turtle to\nstart filling using begin_fill, and the shapes are filled only once\nwe use the end_fill function. Now we’ll try a few more experiments\nwith shapes and filling. Let’s use the square-drawing function from\nthe beginning of the chapter and pass it the size of the square as a\nparameter.\nMore Turtle Graphics 155\n>>> def mysquare(size):\nfor x in range(1, 5):\nt.forward(size)\nt.left(90)\nTest your function by calling it with size 50, like so:\n>>> mysquare(50)\nThis produces a small square:\nNow let’s try our function with different sizes. The following\ncode creates five consecutive squares of size 25, 50, 75, 100, and 125.\n>>> t.reset()\n>>> mysquare(25)\n>>> mysquare(50)\n>>> mysquare(75)\n>>> mysquare(100)\n>>> mysquare(125)\nHere’s what those squares should look like:\n156 Chapter 11\nDrawing filled squares\nTo draw a filled square, first we need to reset the canvas, begin\nfilling, and then call the square function again, with this code:\n>>> t.reset()\n>>> t.begin_fill()\n>>> mysquare(50)\nYou should see an empty square until you end filling:\n>>> t.end_fill()\nAnd your square should look like this:\nLet’s change this function so that we can draw either a filled\nor an unfilled square. To do so, we need another parameter and\nslightly more complicated code.\n>>> def mysquare(size, filled):\nif filled == True:\nt.begin_fill()\nfor x in range(1, 5):\nt.forward(size)\nt.left(90)\nif filled == True:\nt.end_fill()\nOn the first line, we change the definition of our function to\ntake two parameters: size and filled. Next, we check to see whether\nthe value of filled is set to True with if filled == True. If it is, we\ncall begin_fill, to tell the turtle to fill the shape we drew. We then\nloop four times (for x in range(0, 4)) to draw the four sides of the\nMore Turtle Graphics 157\nrectangle (moving forward and left), before checking again to see\nwhether filled is True with if filled == True. If it is, we turn filling\noff again with t.end_fill, and the turtle fills the square with color.\nNow we can draw a filled square with this line:\n>>> mysquare(50, True)\nOr we can create an unfilled square with this line:\n>>> mysquare(150, False)\nAfter these two calls to the mysquare function, we get the follow-\ning image, which looks a bit like a square eye.\nBut there’s no sense in stopping here. You can draw all sorts of\nshapes and fill them with color.\nDrawing filled stars\nFor our final example, we’ll add some color to the star we drew\nearlier. The original code looked like this:\nfor x in range(1, 19):\nt.forward(100)\nif x % 2 == 0:\nt.left(175)\nelse:\nt.left(225)\nNow we’ll make a mystar function. We’ll use the if statements\nfrom the mysquare function and add the size parameter.\n158 Chapter 11\n>>> def mystar(size, filled):\nif filled == True:\nt.begin_fill()\nfor x in range(1, 19):\nt.forward(size)\nif x % 2 == 0:\nt.left(175)\nelse:\nt.left(225)\nif filled == True:\nt.end_fill()\nIn the first two lines of this function, we check to see if filled\nis True, and if it is we begin filling. We check again in the last two\nlines, and if filled is True, we stop filling. Also, as with the mysquare\nfunction, we pass the size of the star in the parameter size, and\nuse that value when we call t.forward.\nNow let’s set the color to gold (90 percent red, 75 percent green,\nand 0 percent blue), and then call the function again.\n>>> t.color(0.9, 0.75, 0)\n>>> mystar(120, True)\nThe turtle will draw this filled star:\nTo add an outline to the star, change the color to black and\nredraw the star without filling:\n>>> t.color(0,0,0)\n>>> mystar(120, False)\nMore Turtle Graphics 159"
  },
  {
    "input": "What is the process for creating a bouncing ball game using the tkinter module, and how can the ball's movement be controlled to bounce off the sides of the canvas?",
    "summary": "In this chapter, you learned to create a bouncing ball game using the tkinter module. You created a Ball class that allows the ball to move and bounce off the sides of the canvas. You also added a paddle to the game and introduced an element of chance to make the game more challenging. The game now includes a main loop that continuously updates the screen and handles the ball's movement and bouncing.",
    "output": "And the star is now gold with a black outline, like this:\nWhat You Learned\nIn this chapter, you learned how\nto use the turtle module to draw a\nfew basic geometric shapes, using\nfor loops and if statements to con-\ntrol what the turtle does on the\nscreen. We changed the color of the\nturtle’s pen and filled the shapes\nthat it drew. We also reused the\ndrawing code in some functions to\nmake it easier to draw shapes with\ndifferent colors with a single call\nto a function.\nProgramming Puzzles\nIn the following experiments, you will draw your own shapes\nwith the turtle. As always, the solutions can be found at http://\npython-for-kids.com/.\n#1: Drawing an octagon\nWe’ve drawn stars, squares, and rectangles in this chapter. How\nabout creating a function to draw an eight-sided shape like an\noctagon? (Hint: Try turning the turtle 45 degrees.)\n160 Chapter 11\n#2: Drawing a filled octagon\nNow that you have a function to draw an octagon, modify it so that\nit draws a filled octagon. Try drawing an octagon with an outline,\nas we did with the star.\n#3: Another star-drawing function\nCreate a function to draw a star that will take two parameters:\nthe size and number of points. The beginning of the function will\nlook something like this:\ndef draw_star(size, points):\nMore Turtle Graphics 161\n12\nUsInG tKInteR foR\nBetteR GRAPHICs\nThe problem with using a turtle to draw is . . . that . . .\nturtles . . . are . . . really . . . slow. Even when a turtle is\ngoing at top speed, it’s still not going very fast. That’s\nnot really a problem for turtles, but it is a problem for\ncomputer graphics.\nComputer graphics, especially in games, usually\nneed to move fast. If you have a game console or you\nplay games on your computer, think for a moment about\nthe graphics you see on the screen. Two-dimensional\n(2D) graphics are flat—the characters generally move\nonly up and down or left and right—\nas in many Nintendo DS, PlayStation\nPortable (PSP), and mobile phone\ngames. In pseudo-three-dimensional\n(3D) games—ones that are almost\n3D—images look a little more real,\nbut the characters generally move\nonly in relation to a flat plane (this\nis also known as isometric graphics).\nAnd, finally, we have 3D games, where the pictures drawn on\nthe screen attempt to mimic reality. Whether the games use 2D,\npseudo-3D, or 3D graphics, all have one thing in common: the need\nto draw on the computer screen very quickly.\nIf you’ve never tried to create your own animation, try this\nsimple project:\n1. Get a blank pad of paper, and in the bottom corner of the first\npage, draw something (perhaps a stick figure).\n2. On the corner of the next page, draw the same stick figure, but\nmove its leg slightly.\n3. On the next page, draw the stick figure again, with the leg\nmoved a little more.\n4. Gradually go through each page, drawing a modified stick fig-\nure on the bottom corner.\nWhen you’re finished, flip quickly through the pages, and you\nshould see your stick figure moving. This is the basic method used\nwith all animation, whether it’s cartoons on TV or games on your\nconsole or computer. An image is drawn, and then drawn again\nwith a slight change to create the illusion of movement. To make\nan image look like it is moving, you need to display each frame, or\npiece of the animation, very quickly.\nPython offers different ways to create graphics. In addition to\nthe turtle module, you can use external modules (which need to\nbe installed separately), as well as the tkinter module, which you\nshould already have in your standard Python installation. tkinter\ncan be used to create full applications, like a simple word proces-\nsor, as well as for simple drawing. In this chapter, we’ll explore\nhow to use tkinter to create graphics.\n164 Chapter 12\nCreating a Clickable Button\nFor our first example, we’ll use tkinter to create a basic application\nwith a button. Enter this code:\n>>> from tkinter import *\n>>> tk = Tk()\n>>> btn = Button(tk, text=\"click me\")\n>>> btn.pack()\nOn the first line, we import\nthe contents of the tkinter module.\nUsing from module-name import * allows\nus to use the contents of a module\nwithout using its name. In contrast,\nwhen using import turtle in p revious\nexamples, we needed to include the\nmodule name to access its contents:\nimport turtle\nt = turtle.Pen()\nWhen we use import *, we don’t need to call turtle.Pen, as we\ndid in Chapters 4 and 11. This isn’t so useful with the turtle mod-\nule, but it is when you are using modules with a lot of classes and\nfunctions, because it reduces the amount you need to type.\nfrom turtle import *\nt = Pen()\nOn the next line in our button example, we create a variable\ncontaining an object of the class Tk with tk = Tk(), just like we\ncreate a Pen object for the turtle. The tk object creates a basic win-\ndow to which we can then add other things, such as buttons, input\nboxes, or a canvas to draw on. This is the main class provided by\nthe tkinter module—without creating an object of the Tk class, you\nwon’t be able to do any graphics or animations.\nOn the third line, we create a button, with btn = Button and\npass the tk variable as the first parameter, and \"click me\" as\nthe text that the button will display, with (tk, text=\"click me\").\nAlthough we’ve added this button to the window, it won’t be dis-\nplayed until you enter the line btn.pack(), which tells the button to\nUsing tkinter for Better Graphics 165\nappear. It also lines everything up correctly on the screen, if there\nare other buttons or objects to display. The result should be some-\nthing like this:\nThe click me button doesn’t do much. You can click it all day,\nbut nothing will happen until we change the code just a bit. (Be\nsure to close the window you created earlier!)\nFirst, we create a function to print some text:\n>>> def hello():\nprint('hello there')\nThen we modify our example to use this new function:\n>>> from tkinter import *\n>>> tk = Tk()\n>>> btn = Button(tk, text=\"click me\", command=hello)\n>>> btn.pack()\nNotice that we’ve made only a slight change to the previous\nversion of this code: We’ve added the parameter command, which tells\nPython to use the hello function when the button is clicked.\nNow when you click the button, you will see “hello there” writ-\nten to the shell. This will appear each time the button is clicked.\nIn the following example, I’ve clicked the button five times.\n166 Chapter 12\nThis is the first time we’ve used named parameters in any of\nour code examples, so let’s talk about them a bit before continuing\nwith our drawing.\nUsing named Parameters\nNamed parameters are just like normal parameters, except that,\nrather than using the specific order of the values provided to a\nfunction to determine which value belongs to which parameter\n(the first value is the first parameter, the second value is the sec-\nond parameter, the third value is the third parameter, and so on),\nwe explicitly name the values, so they can appear in any order.\nSometimes functions have a lot of parameters, and we may not\nalways need to provide a value for every parameter. Named param-\neters are a way we can provide values for only the parameters that\nwe need to give values.\nFor example, suppose we have a function called person that\ntakes two parameters: width and height.\n>>> def person(width, height):\nprint('I am %s feet wide, %s feet high' % (width, height))\nNormally, we might call this function like this:\n>>> person(4, 3)\nI am 4 feet wide, 3 feet high\nUsing named parameters, we could call this function and spec-\nify the parameter name with each value:\n>>> person(height=3, width=4)\nI am 4 feet wide, 3 feet high\nNamed parameters will become particularly useful as we do\nmore with the tkinter module.\nCreating a Canvas for Drawing\nButtons are nice tools, but they’re not particularly useful when we\nwant to draw things on the screen. When it’s time to really draw\nsomething, we need a different component: a canvas object, which is\nan object of the class Canvas (provided by the tkinter module).\nUsing tkinter for Better Graphics 167\nWhen creating a canvas, we pass the width and height (in\npixels) of the canvas to Python. Otherwise, the code is similar to\nthe button code. Here’s an example:\n>>> from tkinter import *\n>>> tk = Tk()\n>>> canvas = Canvas(tk, width=500, height=500)\n>>> canvas.pack()\nAs with the button example,\na window will appear when you\nenter tk = Tk(). On the last line,\nwe pack the canvas with canvas.\npack(), which changes the size\nof the canvas to a width of 500\npixels and a height of 500 p ixels,\nas specified in the third line\nof code.\nAlso as with the button\nexample, the pack function tells\nthe canvas to display itself in the\ncorrect position within the win-\ndow. If that function isn’t called,\nnothing will display properly.\nDrawing Lines\nTo draw a line on the canvas, we use pixel coordinates. Coordinates\ndetermine the positions of pixels on a surface. On a tkinter canvas,\ncoordinates describe how far across the canvas (from left to right)\nand how far down the canvas (top to bottom) to place the pixel.\nFor example, since our canvas is 500 pixels wide by 500 pix-\nels high, the coordinates of the bottom-right corner of the screen\nare (500, 500). To draw the line shown in the following image, we\nwould use the starting coordinates (0, 0) and ending coordinates\n(500, 500).\n168 Chapter 12\nWe specify the coordinates using the create_line function, as\nshown here:\n>>> from tkinter import *\n>>> tk = Tk()\n>>> canvas = Canvas(tk, width=500, height=500)\n>>> canvas.pack()\n>>> canvas.create_line(0, 0, 500, 500)\n1\nThe create_line function returns 1, which is an identifier—we’ll\nlearn more about that later. If we had done the same thing with the\nturtle module, we would have needed the following code:\n>>> import turtle\n>>> turtle.setup(width=500, height=500)\n>>> t = turtle.Pen()\n>>> t.up()\n>>> t.goto(-250, 250)\n>>> t.down()\n>>> t.goto(500, -500)\nUsing tkinter for Better Graphics 169\nSo the tkinter code is already an improvement. It’s slightly\nshorter and a bit simpler.\nNow let’s look at some of the functions available on the canvas\nobject that we can use for some more interesting drawings.\nDrawing Boxes\nWith the turtle module, we drew a\nbox by moving forward, turning, mov-\ning forward, turning again, and so on.\nEventually, we were able to draw a rect-\nangular or square box by changing how\nfar we moved forward.\nThe tkinter module makes it a lot\neasier to draw a square or rectangle. All you need to know are the\ncoordinates for the corners. Here’s an example (you can close the\nother windows now):\n>>> from tkinter import *\n>>> tk = Tk()\n>>> canvas = Canvas(tk, width=400, height=400)\n>>> canvas.pack()\n>>> canvas.create_rectangle(10, 10, 50, 50)\nIn this code, we use tkinter to create a canvas that is 400 pixels\nwide by 400 pixels high, and we then draw a square in the top-left\ncorner of the window, like this:\nThe parameters we pass to canvas.create_rectangle in the last\nline of the code are the coordinates for the top-left and bottom-right\ncorners of the square. We provide these coordinates as the distance\nfrom the left-hand side of the canvas and the distance from the top\nof the canvas. In this case, the first two coordinates (the top-left\n170 Chapter 12\ncorner) are 10 pixels across from the left and 10 pixels down from\nthe top (those are the first numbers: 10, 10). The bottom-right corner\nof the square is 50 pixels across from the left and 50 pixels down\n(the second numbers: 50, 50).\nWe’ll refer to these two sets of coordinates as x1, y1 and x2, y2.\nTo draw a rectangle, we can increase the distance of the second\ncorner from the side of the canvas (increasing the value of the x2\nparameter), like this:\n>>> from tkinter import *\n>>> tk = Tk()\n>>> canvas = Canvas(tk, width=400, height=400)\n>>> canvas.pack()\n>>> canvas.create_rectangle(10, 10, 300, 50)\nIn this example, the top-left coordinates of the rectangle (its\nposition on the screen) are (10, 10), and the bottom-right coor-\ndinates are (300, 50). The result is a rectangle that is the same\nheight as our original square (50 pixels), but a lot wider.\nWe can also draw a rectangle by increasing the distance of the\nsecond corner from the top of the canvas (increasing the value of\nthe y2 parameter), like this:\n>>> from tkinter import *\n>>> tk = Tk()\n>>> canvas = Canvas(tk, width=400, height=400)\n>>> canvas.pack()\n>>> canvas.create_rectangle(10, 10, 50, 300)\nIn this call to the create_rectangle function, we are basically\nsaying, in order:\n• Go 10 pixels across the canvas (from the top left).\n• Go 10 pixels down the canvas. This is the starting corner of\nthe rectangle.\nUsing tkinter for Better Graphics 171\n• Draw the rectangle across to 50 pixels.\n• Draw down to 300 pixels.\nThe end result should look something like this:\nDrawing a Lot of Rectangles\nHow about filling the canvas with different-sized rectangles?\nWe can do this by importing the module random and then creating\na function that uses a random number for the coordinates at the\ntop-left and bottom-right corners of the rectangle.\nWe’ll use the function provided by the random module called\nrandrange. When we give this function a number, it returns a ran-\ndom integer between 0 and the number we give it. For example,\ncalling randrange(10) would return a number between 0 and 9,\nrandrange(100) would return a number between 0 and 99, and\nso on.\nHere’s how we use randrange in a function. Create a new\nwindow by selecting File4New Window, and enter the follow-\ning code:\nfrom tkinter import *\nimport random\ntk = Tk()\ncanvas = Canvas(tk, width=400, height=400)\ncanvas.pack()\n172 Chapter 12\ndef random_rectangle(width, height):\nx1 = random.randrange(width)\ny1 = random.randrange(height)\nx2 = x1 + random.randrange(width)\ny2 = y1 + random.randrange(height)\ncanvas.create_rectangle(x1, y1, x2, y2)\nWe first define our function (def random_rectangle) as taking two\nparameters: width and height. Next, we create variables for the top-\nleft corner of the rectangle using the randrange function, passing the\nwidth and the height as parameters with x1 = random.randrange(width)\nand y1 = random.randrange(height), respectively. In effect, with the\nsecond line of this function, we’re saying, “Create a variable called\nx1, and set its value to a random number between 0 and the value\nin the parameter width.”\nThe next two lines create variables for the bottom-right corner\nof the rectangle, taking into account the top-left coordinates (either\nx1 or y1) and adding a random number to those values. The third\nline of the function is effectively saying, “Create the variable x2 by\nadding a random number to the value that we already calculated\nfor x1.”\nFinally, with canvas.create_rectangle, we use the variables x1,\ny1, x2, and y2 to draw the rectangle on the canvas.\nTo try our random_rectangle function, we’ll pass it the width and\nheight of the canvas. Add the following code below the function\nyou’ve just entered:\nrandom_rectangle(400, 400)\nSave the code you’ve entered (select File4Save and enter\na filename such as randomrect.py) and then select Run4Run\nModule. Once you’ve seen the function working, fill the screen\nwith rectangles by creating a loop to call random_rectangle a number\nof times. Let’s try a for loop of 100 random rectangles. Add the fol-\nlowing code, save your work, and try running it again:\nfor x in range(0, 100):\nrandom_rectangle(400, 400)\nUsing tkinter for Better Graphics 173\nThis code produces a bit of a mess, but it’s kind of like mod-\nern art:\nsetting the Color\nOf course, we want to add color to our graphics. Let’s change the\nrandom_rectangle function to pass in a color for the rectangle as an\nadditional parameter (fill_color). Enter this code in a new window,\nand when you save, call the file colorrect.py:\nfrom tkinter import *\nimport random\ntk = Tk()\ncanvas = Canvas(tk, width=400, height=400)\ncanvas.pack()\ndef random_rectangle(width, height, fill_color):\nx1 = random.randrange(width)\ny1 = random.randrange(height)\nx2 = random.randrange(x1 + random.randrange(width))\ny2 = random.randrange(y1 + random.randrange(height))\ncanvas.create_rectangle(x1, y1, x2, y2, fill=fill_color)\nThe create_rectangle function now takes a parameter fill_color,\nwhich specifies the color to use when drawing the rectangle.\nWe can pass named colors into the function like this (using\na canvas 400 pixels wide by 400 pixels high) to create a bunch of\ndifferent-colored rectangles. If you try this example, you might\n174 Chapter 12\nlike to copy and paste to save on typing.\nTo do so, select the text to copy, press\nctrl-C to copy it, click a blank line, and\npress ctrl-V to paste. Add this code to\ncolorrect.py, just below the function):\nrandom_rectangle(400, 400, 'green')\nrandom_rectangle(400, 400, 'red')\nrandom_rectangle(400, 400, 'blue')\nrandom_rectangle(400, 400, 'orange')\nrandom_rectangle(400, 400, 'yellow')\nrandom_rectangle(400, 400, 'pink')\nrandom_rectangle(400, 400, 'purple')\nrandom_rectangle(400, 400, 'violet')\nrandom_rectangle(400, 400, 'magenta')\nrandom_rectangle(400, 400, 'cyan')\nMany of these named colors will display the color you expect\nto see, but others may produce an error message (depending on\nwhether you’re using Windows, Mac OS X, or Linux).\nBut what about a custom color that isn’t exactly the same as\na named color? Recall in Chapter 11 that we set the color of the\nturtle’s pen using percentages of the colors red, green, and blue.\nSetting the amount of each primary color (red, green, and blue)\nto use in a color combination with tkinter is slightly more compli-\ncated, but we’ll work through it.\nWhen working with the turtle module, we created gold using\n90 percent red, 75 percent green, and no blue. In tkinter, we can\ncreate the same gold color using this line:\nrandom_rectangle(400, 400, '#ffd800')\nThe hash mark (#) before the value ffd800 tells Python we’re pro-\nviding a hexadecimal number. Hexadecimal is a way of representing\nnumbers that is commonly used in computer programming. It uses\na base of 16 (0 through 9 then A through F) rather than decimal,\nwhich has a base of 10 (0 through 9). If you haven’t learned about\nbases in mathematics, just know that you can convert a normal deci-\nmal number to hexadecimal using a format placeholder in a string:\n%x (see “Embedding Values in Strings” on page 30). For example,\nto convert the decimal number 15 to hexadecimal, you could do this:\n>>> print('%x' % 15)\nf\nUsing tkinter for Better Graphics 175\nTo make sure our number has at least two digits, we can\nchange the format placeholder slightly, to this:\n>>> print('%02x' % 15)\n0f\nThe tkinter module provides an easy way to get a hexadecimal\ncolor value. Try adding the following code to colorrect.py (you can\nremove the other calls to the random_rectangle function).\nfrom tkinter import *\ncolorchooser.askcolor()\nThis shows you a color chooser:\nWhen you select a color and click OK, a tuple will be displayed.\nThis tuple contains another tuple with three numbers and a string:\n>>> colorchooser.askcolor()\n((235.91796875, 86.3359375, 153.59765625), '#eb5699')\nThe three numbers represent the amounts of red, green, and\nblue. In tkinter, the amount of each primary color to use in a color\ncombination is represented by a number between 0 and 255 (which\nis different from using a percentage for each primary color with the\nturtle module). The string in the tuple contains the hexadecimal\nversion of those three numbers.\nYou can either copy and paste the string value to use or store\nthe tuple as a variable, and then use the index position of the hexa-\ndecimal value.\n176 Chapter 12\nLet’s use the random_rectangle function to see how this works.\n>>> c = colorchooser.askcolor()\n>>> random_rectangle(400, 400, c[1])\nHere’s the result:\nDrawing Arcs\nAn arc is a segment of the\ncircumference of a circle or\nanother curve, but in order\nto draw one with tkinter, you\nneed to draw it inside a rect-\nangle using the create_arc\nfunction, with code like this:\ncanvas.create_arc(10, 10, 200, 100, extent=180, style=ARC)\nUsing tkinter for Better Graphics 177\nIf you’ve closed all the tkinter windows, or restarted IDLE,\nmake sure to reimport tkinter and then re-create the canvas with\nthis code:\n>>> from tkinter import *\n>>> tk = Tk()\n>>> canvas = Canvas(tk, width=400, height=400)\n>>> canvas.pack()\n>>> canvas.create_arc(10, 10, 200, 100, extent=180, style=ARC)\nThis code places the top-left corner of the rectangle that\nwill contain the arc at the coordinates (10, 10), which is 10 pixels\nacross and 10 pixels down, and its bottom-right corner at coordi-\nnates (200, 100), or 200 pixels across and 100 pixels down. The\nnext parameter, extent, is used to specify the degrees of the angle\nof the arc. Recall from Chapter 4 that degrees are a way of mea-\nsuring the distance to travel around a circle. Here are examples\nof two arcs, where we travel 45 degrees and 270 degrees around\na circle:\n90˚ 270˚\nThe following code draws several different arcs down the page\nso that you can see what happens when we use different degrees\nwith the create_arc function.\n>>> from tkinter import *\n>>> tk = Tk()\n>>> canvas = Canvas(tk, width=400, height=400)\n>>> canvas.pack()\n>>> canvas.create_arc(10, 10, 200, 80, extent=45, style=ARC)\n>>> canvas.create_arc(10, 80, 200, 160, extent=90, style=ARC)\n>>> canvas.create_arc(10, 160, 200, 240, extent=135, style=ARC)\n>>> canvas.create_arc(10, 240, 200, 320, extent=180, style=ARC)\n>>> canvas.create_arc(10, 320, 200, 400, extent=359, style=ARC)\n178 Chapter 12\nnote We use 359 degrees in the final circle, rather than 360, because\ntkinter considers 360 to be the same as 0 degrees, and would draw\nnothing if we used 360.\nDrawing Polygons\nA polygon is any shape with three or more sides. There are regu-\nlarly shaped polygons like triangles, squares, rectangles, pentagons,\nhexagons, and so on, as well as irregular ones with uneven edges,\nmany more sides, and odd shapes.\nWhen drawing polygons with tkinter, you need to provide coor-\ndinates for each point of the polygon. Here’s how we can draw a\ntriangle:\nfrom tkinter import *\ntk = Tk()\ncanvas = Canvas(tk, width=400, height=400)\ncanvas.pack()\ncanvas.create_polygon(10, 10, 100, 10, 100, 110, fill=\"\",\noutline=\"black\")\nThis example draws a\ntriangle by starting with the\nx and y coordinates (10, 10),\nthen moving across to (100,\n10), and finishing at (100,\n110). Here’s the result:\nUsing tkinter for Better Graphics 179\nWe can add another irregular polygon (a shape with uneven\nangles or sides) using this code:\ncanvas.create_polygon(200, 10, 240, 30, 120, 100, 140, 120, fill=\"\",\noutline=\"black\")\nThis code begins with the coordinates (200, 10), moves to\n(240, 30), then to (120, 100), and finally to (100, 140). tkinter auto-\nmatically joins the line back to the first coordinate. And here’s the\nresult of running the code:\nDisplaying text\nIn addition to drawing shapes, you can also write on the canvas\nusing create_text. This function takes only two coordinates (the\nx and y positions of the text), along with a named parameter for\nthe text to display. In the following code, we create our canvas as\nbefore and then display a sentence positioned at the coordinates\n(150, 100). Save this code as text.py.\nfrom tkinter import *\ntk = Tk()\ncanvas = Canvas(tk, width=400, height=400)\ncanvas.pack()\ncanvas.create_text(150, 100, text='There once was a man from Toulouse,')\nThe create_text function takes some other useful param-\neters, such as a text fill color. In the following code, we call the\ncreate_text function with coordinates (130, 120), the text we want\nto display, and a red fill color.\ncanvas.create_text(130, 120, text='Who rode around on a moose.',\nfill='red')\n180 Chapter 12\nYou can also specify the font (the type-\nface used for the displayed text) as a tuple\nwith the font name and the size of the text.\nFor example, the tuple for the Times font\nof size 20 is ('Times', 20). In the following\ncode, we display text using the Times font\nset at size 15, the Helvetica font at size 20,\nand the Courier font at sizes 22 and then 30.\ncanvas.create_text(150, 150, text='He said, \"It\\'s my curse,',\nfont=('Times', 15))\ncanvas.create_text(200, 200, text='But it could be worse,',\nfont=('Helvetica', 20))\ncanvas.create_text(220, 250, text='My cousin rides round',\nfont=('Courier', 22))\ncanvas.create_text(220, 300, text='on a goose.\"', font=('Courier', 30))\nAnd here’s the result of these functions using the three speci-\nfied fonts at five different sizes:\nDisplaying Images\nTo display an image on a canvas using tkinter, first load the image\nand then use the create_image function on the canvas object.\nAny image that you load must be in a directory that’s acces-\nsible to Python. For this example, we put our image test.gif in the\nC:\\ directory, which is the root directory (the base directory) of\nthe C: drive, but you could put it anywhere.\nUsing tkinter for Better Graphics 181\nIf you’re using a Mac or Linux system, you can put the image\nin your Home directory. If you aren’t able to put files on your C:\ndrive, you can put the image on your desktop.\nnote With tkinter, you can load only GIF images, that is, image files with\nthe extension .gif. You can display other types of images, such as\nPNG (.png) and JPG (.jpg), but you’ll need to use a different mod-\nule, such as the Python Imaging Library (http://www.pythonware\n.com/products/pil/).\nWe can display the test.gif image like this:\nfrom tkinter import *\ntk = Tk()\ncanvas = Canvas(tk, width=400, height=400)\ncanvas.pack()\nmy_image = PhotoImage(file='c:\\\\test.gif')\ncanvas.create_image(0, 0, anchor=NW, image=myimage)\nIn the first four lines, we set up the canvas as with the previous\nexamples. In the fifth line, the image is loaded into the variable\nmy_image. We create PhotoImage with the directory 'c:\\\\test.gif'. If you\nsaved your image to the desktop, you should create the PhotoImage\nwith that directory, something like this:\nmy_image = PhotoImage(file='C:\\\\Users\\\\Joe Smith\\\\Desktop\\\\test.gif')\n182 Chapter 12\nOnce the image has been loaded into the variable, canvas.create_\nimage(0, 0, anchor=NW, image=myimage) displays it using the create_image\nfunction. The coordinates (0, 0) are where the image will be dis-\nplayed, and anchor=NW tells the function to use the top-left (NW, for\nnorthwest) edge of the image as the starting point when drawing\n(otherwise, it will use the center of the image as the starting point\nby default). The final named parameter, image, points at the vari-\nable for the loaded image. Here’s the result:\nCreating Basic Animation\nWe’ve covered how to create static drawings—pictures that don’t\nmove. What about creating animation?\nAnimation is not necessarily a specialty of the tkinter module,\nbut it can handle the basics. For example, we can create a filled\ntriangle and then make it move across the screen using this code\n(don’t forget, select File4New Window, save your work, and then\nrun the code with Run4Run Module):\nimport time\nfrom tkinter import *\ntk = Tk()\ncanvas = Canvas(tk, width=400, height=200)\ncanvas.pack()\ncanvas.create_polygon(10, 10, 10, 60, 50, 35)\nUsing tkinter for Better Graphics 183\nfor x in range(0, 60):\ncanvas.move(1, 5, 0)\ntk.update()\ntime.sleep(0.05)\nWhen you run this code, the triangle will start moving across\nthe screen to the end of its path:\nHow does this work? As before, we’ve used the first three lines\nafter importing tkinter to do the basic setup to display a canvas. In\nthe fourth line, we create the triangle with this function:\ncanvas.create_polygon(10, 10, 10, 60, 50, 35)\nnote When you enter this line, a number will be printed to the screen.\nThis is an identifier for the polygon. We can use it to refer to the\nshape later, as described in the following example.\nNext, we create a simple for loop\nto count from 0 to 59, beginning with\nfor x in range(0, 60):. The block of code\ninside the loop moves the tri angle across\nthe screen. The canvas.move function will\nmove any drawn object by adding values\nto its x and y coordinates. For example,\nwith canvas.move(1, 5, 0), we move the\nobject with ID 1 (the identifier for the\ntriangle) 5 pixels across and 0 pixels down. To move it back again,\nwe could use the function call canvas.move(1, -5, 0).\nThe function tk.update() forces tkinter to update the screen\n(redraw it). If we didn’t use update, tkinter would wait until the loop\nfinished before moving the triangle, which means you would see\n184 Chapter 12\nit jump to the last position, rather than move smoothly across the\ncanvas. The final line of the loop, time.sleep(0.05), tells Python to\nsleep for one-twentieth of a second (0.05 seconds), before continuing.\nTo make the triangle move diagonally down the screen, we\ncan modify this code by calling move(1, 5, 5). To try this, close the\ncanvas, and create a new file (File4New Window) for the follow-\ning code:\nimport time\nfrom tkinter import *\ntk = Tk()\ncanvas = Canvas(tk, width=400, height=400)\ncanvas.pack()\ncanvas.create_polygon(10, 10, 10, 60, 50, 35)\nfor x in range(0, 60):\ncanvas.move(1, 5, 5)\ntk.update()\ntime.sleep(0.05)\nThis code differs from the original in two ways:\n• We make the height of the canvas 400, rather than 200,\nwith canvas = Canvas(tk, width=400, height=400).\n• We add 5 to the triangle’s x and y coordinates with\ncanvas.move(1, 5, 5).\nOnce you save your code and run it, here’s the triangle’s posi-\ntion at the end of the loop:\nUsing tkinter for Better Graphics 185\nTo move the triangle diagonally back up the screen to its start-\ning position, use -5, -5 (add this code to the bottom of the file):\nfor x in range(0, 60):\ncanvas.move(1, -5, -5)\ntk.update()\ntime.sleep(0.05)\nMaking an object React to something\nWe can make the triangle react when someone presses a key by\nusing event bindings. Events are things that occur while a program\nis running, such as someone moving the mouse, pressing a key, or\nclosing a window. You can tell tkinter to watch for these events and\nthen do something in response.\nTo begin handling events (making Python do something when\nan event occurs), we first create a function. The binding part comes\nwhen we tell tkinter that a particular function is bound (or associ-\nated) to a specific event; in other words, it will be automatically\ncalled by tkinter to handle that event.\nFor example, to make the triangle move when the enter key is\npressed, we can define this function:\ndef movetriangle(event):\ncanvas.move(1, 5, 0)\nThe function takes a single parameter (event), which tkinter\nuses to send information to the function about the event. We now\ntell tkinter that this function should be used for a particular event,\nusing the bind_all function on the canvas. The full code now looks\nlike this:\nfrom tkinter import *\ntk = Tk()\ncanvas = Canvas(tk, width=400, height=400)\ncanvas.pack()\ncanvas.create_polygon(10, 10, 10, 60, 50, 35)\ndef movetriangle(event):\ncanvas.move(1, 5, 0)\ncanvas.bind_all('<KeyPress-Return>', movetriangle)\nThe first parameter in this function describes the event that we\nwant tkinter to watch for. In this case, it’s called <KeyPress-Return>,\n186 Chapter 12\nwhich is a press of the enter or\nreturn key. We tell tkinter that\nthe movetriangle function should\nbe called whenever this KeyPress\nevent occurs. Run this code, click\nthe canvas with your mouse, and\nthen try pressing enter on your\nkeyboard.\nHow about changing the direction of the triangle depending on\ndifferent key presses, such as the arrow keys? That’s no problem.\nWe just need to change the movetriangle function to the following:\ndef movetriangle(event):\nif event.keysym == 'Up':\ncanvas.move(1, 0, -3)\nelif event.keysym == 'Down':\ncanvas.move(1, 0, 3)\nelif event.keysym == 'Left':\ncanvas.move(1, -3, 0)\nelse:\ncanvas.move(1, 3, 0)\nThe event object passed to movetriangle contains several vari-\nables. One of these variables is called keysym (for key symbol), which\nis a string that holds the value of the actual key pressed. The line\nif event.keysym == 'Up': says that if the keysym variable contains the\nstring 'Up', we should call canvas.move with the parameters (1, 0, -3),\nas we do in the following line. If keysym contains 'Down', as in elif\nevent.keysym == 'Down':, we call it with the parameters (1, 0, 3),\nand so on.\nRemember that the first parameter is the identifying number\nfor the shape drawn on the canvas, the second is the value to add\nto the x (horizontal) coordinate, and the third is the value to add to\nthe y (vertical) coordinate.\nWe then tell tkinter that the movetriangle function should be\nused to handle events from four different keys (up, down, left,\nand right). The following shows how the code looks at this point.\nWhen you enter this code, it will again be a lot easier if you cre-\nate a new shell window by selecting File4New Window. Before\nrunning the code, save it with a meaningful filename, such as\nmovingtriangle.py.\nUsing tkinter for Better Graphics 187\nfrom tkinter import *\ntk = Tk()\ncanvas = Canvas(tk, width=400, height=400)\ncanvas.pack()\ncanvas.create_polygon(10, 10, 10, 60, 50, 35)\ndef movetriangle(event):\nu if event.keysym == 'Up':\nv canvas.move(1, 0, -3)\nw elif event.keysym == 'Down':\nx canvas.move(1, 0, 3)\ny elif event.keysym == 'Left':\nz canvas.move(1, -3, 0)\n{ else:\n| canvas.move(1, 3, 0)\ncanvas.bind_all('<KeyPress-Up>', movetriangle)\ncanvas.bind_all('<KeyPress-Down>', movetriangle)\ncanvas.bind_all('<KeyPress-Left>', movetriangle)\ncanvas.bind_all('<KeyPress-Right>', movetriangle)\nOn the first line of the movetriangle function, we check whether\nthe keysym variable contains 'Up' at u. If it does, we move the tri-\nangle upward using the move function with the parameters 1, 0, -3\nat v. The first parameter is the identifier of the triangle, the\nsecond is the amount to move to the right (we don’t want to move\nhorizontally, so the value is 0), and the third is the amount to\nmove downward (–3 pixels).\nWe then check whether keysym contains 'Down' at w, and if\nso, we move the triangle down (3 pixels) at x. The final check is\nwhether the value is 'Left' at y, and if so, we move the triangle\nleft ( –3 pixels) at z. If none of the values are matched, the final\nelse at { moves the triangle right at |.\nNow the triangle should move in the direction of the pressed\narrow key.\nMore Ways to Use the Identifier\nWhenever we use a create_ function from the canvas, such as\nc reate_polygon or create_rectangle, an identifier is returned. This\nidentifying number can be used with other canvas functions, as we\ndid earlier with the move function:\n>>> from tkinter import *\n>>> tk = Tk()\n188 Chapter 12\n>>> canvas = Canvas(tk, width=400, height=400)\n>>> canvas.pack()\n>>> canvas.create_polygon(10, 10, 10, 60, 50, 35)\n1\n>>> canvas.move(1, 5, 0)\nThe problem with this example is that create_polygon won’t\nalways return 1. For example, if you’ve created other shapes, it\nmight return 2, 3, or even 100 for that matter (depending on the\nnumber of shapes that have been created). If we change the code to\nstore the value returned as a variable, and then use the variable\n(rather than just referring to the number 1), the code will work no\nmatter what number is returned:\n>>> mytriangle = canvas.create_polygon(10, 10, 10, 60, 50, 35)\n>>> canvas.move(mytriangle, 5, 0)\nThe move function allows us to move objects around the screen\nusing their identifier. But there are other canvas functions that can\nalso change something we’ve drawn. For example, the itemconfig\nfunction of the canvas can be used to change some of the param-\neters of a shape, such as its fill and outline colors.\nSay we create a red triangle:\n>>> from tkinter import *\n>>> tk = Tk()\n>>> canvas = Canvas(tk, width=400, height=400)\n>>> canvas.pack()\n>>> mytriangle = canvas.create_polygon(10, 10, 10, 60, 50, 35,\nfill='red')\nWe can change the triangle to another color using itemconfig\nand use the identifier as the first parameter. The following code\nsays, “Change the fill color of the object identified by the number\nin variable mytriangle to blue.”\n>>> canvas.itemconfig(mytriangle, fill='blue')\nWe could also give the triangle a different-colored outline,\nagain using the identifier as the first parameter:\n>>> canvas.itemconfig(mytriangle, outline='red')\nUsing tkinter for Better Graphics 189\nLater, we’ll learn how to make other\nchanges to a drawing, such as hide it and\nmake it visible again. You’ll find it useful\nto be able to change a drawing once it’s dis-\nplayed on the screen when we start writing\ngames in the next chapter.\nWhat You Learned\nIn this chapter, you used the tkinter module to draw simple geo-\nmetric shapes on a canvas, display images, and perform basic\nanimation. You learned how to use event bindings to make draw-\nings react to someone pressing a key, which will be useful once we\nstart working on programming a game. You learned how the create\nfunctions in tkinter return an identifying number, which can be\nused to modify shapes after they’ve been drawn, such as to move\nthem around on the screen or change their color.\nProgramming Puzzles\nTry the following to play with the tkinter module and basic anima-\ntion. Visit http://python-for-kids.com/ for solutions.\n#1: fill the screen with triangles\nCreate a program using tkinter to fill the screen with triangles.\nThen change the code to fill the screen with different-colored\n(filled) triangles instead.\n#2: the Moving triangle\nModify the code for the moving triangle (“Creating Basic Anima-\ntion” on page 183) to make it move across the screen to the right,\nthen down, then back to the left, and then back to its starting\nposition.\n#3: the Moving Photo\nTry displaying a photo of yourself on the canvas using tkinter.\nMake sure it’s a GIF image! Can you make it move across the\nscreen?\n190 Chapter 12\n13\nBeGInn In G YoUR\nfIRst GAMe: BoUnCe!\nSo far, we’ve covered the basics of computer program-\nming. You’ve learned how to use variables to store\ninformation, if statements for conditional code, and for\nloops for repeating code. You know how to create func-\ntions to reuse your code, and how to use classes and\nobjects to divide your code into smaller chunks that\nmake it easier to understand. You’ve learned how to\ndraw graphics on the screen with both the turtle and\ntkinter modules. Now it’s time to use that knowledge\nto create your first game.\nWhack the Bouncing Ball\nWe’re going to develop a game with a bouncing ball and a paddle.\nThe ball will fly around the screen, and the player will bounce it\noff the paddle. If the ball hits the bottom of the screen, the game\ncomes to an end. Here’s a preview of the finished game:\nOur game may look quite simple, but the code will be a bit\ntrickier than what we’ve written so far because there are a lot of\nthings that it needs to handle. For example, it needs to animate\nthe paddle and the ball, and detect when the ball hits the paddle\nor the walls.\nIn this chapter, we’ll begin creating the game by adding a\ngame canvas and a bouncing ball. In the next chapter, we’ll com-\nplete the game by adding the paddle.\nCreating the Game Canvas\nTo create your game, first open a new file in the Python shell\n(select File4New Window). Then import tkinter and create a\ncanvas to draw on:\nfrom tkinter import *\nimport random\nimport time\n194 Chapter 13\ntk = Tk()\ntk.title(\"Game\")\ntk.resizable(0, 0)\ntk.wm_attributes(\"-topmost\", 1)\ncanvas = Canvas(tk, width=500, height=400, bd=0, highlightthickness=0)\ncanvas.pack()\ntk.update()\nThis is a little different from previous examples. First, we import\nthe time and random modules with import random and import time, for\nuse a bit later in the code.\nWith tk.title(\"Game\"), we use the title function of the tk\nobject we created with tk = Tk() to give the window a title. Then\nwe use resizable to make the window a fixed size. The parameters\n0, 0 say “the size of the window cannot be changed either horizon-\ntally or vertically.” Next, we call wm_attributes to tell tkinter to place\nthe win dow containing our canvas in front of all other windows\n(\"- topmost\").\nNotice that when we create a canvas object with canvas =, we\npass in a few more named parameters than with previous exam-\nples. For example, both bd=0 and highlightthickness=0 make sure\nthat there’s no border around the outside of the canvas, which\nmakes it look better on our game screen.\nThe line canvas.pack()\ntells the canvas to size itself\naccording to the width and\nheight parameters given in\nthe preceding line. Finally,\ntk.update() tells tkinter to\ninitialize itself for the ani-\nmation in our game. Without\nthis last line, nothing would\nwork quite as expected.\nMake sure you save\nyour code as you go. Give it\na meaningful filename the\nfirst time you save it, such\nas paddleball.py.\nBeginning Your First Game: Bounce! 195\nCreating the Ball Class\nNow we’ll create the class for the ball. We’ll begin with the code we\nneed for the ball to draw itself on the canvas. Here’s what we need\nto do:\n• Create a class called Ball that takes parameters for the canvas\nand the color of the ball we’re going to draw.\n• Save the canvas as an object variable because we’ll draw our\nball on it.\n• Draw a filled circle on the canvas using the value of the color\nparameter as the fill color.\n• Save the identifier that tkinter returns when it draws the circle\n(oval) because we’re going use this to move the ball around the\nscreen.\n• Move the oval to the middle of the canvas.\nThis code should be added just after the first two lines in the\nfile (after import time):\nfrom tkinter import *\nimport random\nimport time\nu class Ball:\nv def __init__(self, canvas, color):\nw self.canvas = canvas\nx self.id = canvas.create_oval(10, 10, 25, 25, fill=color)\ny self.canvas.move(self.id, 245, 100)\ndef draw(self):\npass\nFirst, we name our class Ball at u. Then we create an ini-\ntialization function (as described in Chapter 8) that takes the\nparameters canvas and color at v. At w, we set the object variable\ncanvas to the value of the parameter canvas.\nAt x, we call the create_oval function with five parameters: x\nand y coordinates for the top-left corner (10 and 10), x and y coor-\ndinates for the bottom-right corner (25 and 25), and finally, the fill\ncolor for the oval.\n196 Chapter 13\nThe create_oval function returns an\nidentifier for the shape that is drawn, which\nwe store in the object variable id. At y, we\nmove the oval to the middle of the canvas\n(position 245, 100), and the canvas knows\nwhat to move, because we use the stored\nshape identifier (the object variable id) to\nidentify it.\nOn the last two lines of the Ball class, we\ncreate the draw function with def draw(self),\nand the body of the function is simply the\npass keyword. At the moment it does noth-\ning. We’ll add more to this function shortly.\nNow that we’ve created our Ball class,\nwe need to create an object of this class\n(remember that a class describes what it can do, but the object is\nthe thing that actually does it). Add the following code to the bot-\ntom of the program to create a red ball object:\nball = Ball(canvas, 'red')\nIf you run this program now using Run4Run Module, the\ncanvas will appear for a split second and then vanish. To stop the\nwindow from closing immediately, we need to add an animation\nloop, which is called the main loop of our game.\nA main loop is the central part of a program that generally\ncontrols most of what it does. Our main loop, for the moment, just\ntells tkinter to redraw the screen. The loop keeps running forever\n(or at least until we close the window), constantly telling tkinter to\nredraw the screen, and then sleeping for one hundredth of a sec-\nond. We’ll add this code to the end of our program:\nball = Ball(canvas, 'red')\nwhile 1:\ntk.update_idletasks()\ntk.update()\ntime.sleep(0.01)\nBeginning Your First Game: Bounce! 197\nNow if you run the code, the ball should appear almost in the\ncenter of the canvas:\nAdding some Action\nNow that we have the Ball class\nset up, it’s time to animate the ball.\nWe’ll make it move, bounce, and\nchange direction.\nMaking the Ball Move\nTo move the ball, change the draw function as follows:\nclass Ball:\ndef __init__(self, canvas, color):\nself.canvas = canvas\nself.id = canvas.create_oval(10, 10, 25, 25, fill=color)\nself.canvas.move(self.id, 245, 100)\ndef draw(self):\nself.canvas.move(self.id, 0, -1)\nSince __init__ saved the canvas parameter as the object variable\ncanvas, we use that variable with self.canvas, and call the function\nmove on the canvas.\n198 Chapter 13\nWe pass three parameters to move: the id of the oval, and the\nnumbers 0 and -1. The 0 says don’t move horizontally, and the -1\nsays move 1 pixel up the screen.\nWe’re making this small change because it’s a good idea to\ntry things out as we go. Imagine if we wrote the entire code for\nour game at once, and then discovered that it didn’t work. Where\nwould we start looking to figure out why?\nThe other change is to the main loop at the bottom of our pro-\ngram. In the block of the while loop (that’s our main loop!), we add\na call to the ball object’s draw function, like so:\nwhile 1:\nball.draw()\ntk.update_idletasks()\ntk.update()\ntime.sleep(0.01)\nIf you run this code now, the ball should move up the canvas\nand vanish, because the code forces tkinter to redraw the screen\nquickly—the commands update_idletasks and update tell tkinter to\nhurry up and draw what is on the canvas.\nThe command time.sleep is a call to the sleep function of the\ntime module, which tells Python to sleep for one hundredth of a\nsecond (0.01). This is to make sure that our program won’t run so\nfast that the ball vanishes before you even see it.\nSo the loop is basically saying: move the ball a little, redraw\nthe screen with the new position, sleep for a moment, and then\nstart over again.\nnote You may see error messages written to the shell when you close the\ngame window. This is because when you close the window, the code\nis breaking out of the while loop, and Python is complaining about it.\nYour game should now look like this:\nfrom tkinter import *\nimport random\nimport time\nclass Ball:\ndef __init__(self, canvas, color):\nself.canvas = canvas\nself.id = canvas.create_oval(10, 10, 25, 25, fill=color)\nself.canvas.move(self.id, 245, 100)\nBeginning Your First Game: Bounce! 199\ndef draw(self):\nself.canvas.move(self.id, 0, -1)\ntk = Tk()\ntk.title(\"Game\")\ntk.resizable(0, 0)\ntk.wm_attributes(\"-topmost\", 1)\ncanvas = Canvas(tk, width=500, height=400, bd=0, highlightthickness=0)\ncanvas.pack()\ntk.update()\nball = Ball(canvas, 'red')\nwhile 1:\nball.draw()\ntk.update_idletasks()\ntk.update()\ntime.sleep(0.01)\nMaking the Ball Bounce\nA ball that vanishes off the top of the screen isn’t particularly\nuseful for a game, so let’s make it bounce. First, we save a few\nadditional object variables in the initialization function of the Ball\nclass, like this:\ndef __init__(self, canvas, color):\nself.canvas = canvas\nself.id = canvas.create_oval(10, 10, 25, 25, fill=color)\nself.canvas.move(self.id, 245, 100)\nself.x = 0\nself.y = -1\nself.canvas_height = self.canvas.winfo_height()\nWe’ve added three more lines to our program. With self.x = 0,\nwe set the object variable x to 0, and then with self.y = -1, we set\nthe variable y to -1. Finally, we set the object variable canvas_height\nby calling the canvas function winfo_height. This function returns\nthe current height of the canvas.\nNext, we change the draw function again:\ndef draw(self):\nu self.canvas.move(self.id, self.x, self.y)\nv pos = self.canvas.coords(self.id)\n200 Chapter 13\nw if pos[1] <= 0:\nself.y = 1\nx if pos[3] >= self.canvas_height:\nself.y = -1\nAt u, we change the call to the canvas’s move function by passing\nthe object variables x and y. Next, we create a variable called pos\nat v, by calling the canvas function coords. This function returns\nthe current x and y coordinates of anything drawn on the canvas\nas long as you know its identifying number. In this case, we pass\ncoords the object variable id, which contains the oval’s identifier.\nThe coords function returns the coordinates as a list of four\nnumbers. If we print the results of calling this function, we’ll see\nsomething like this:\nprint(self.canvas.coords(self.id))\n[255.0, 29.0, 270.0, 44.0]\nThe first two numbers in the list (255.0 and 29.0) contain the\ntop-left coordinates of the oval (x1 and y1); the second two (270.0\nand 44.0) are the bottom-right x2 and y2 coordinates. We’ll use\nthese values in the next few lines of code.\nAt w, we see if the y1 coordinate (that’s the top of the ball!)\nis less than or equal to 0. If so, we set the y object variable to 1.\nIn effect, we’re saying if you\nhit the top of the screen, stop\nsubtracting one from the verti-\ncal position, and therefore stop\nmoving up.\nAt x, we see if the y2 coor-\ndinate (that’s the bottom of the\nball!) is greater than or equal\nto the variable canvas_height. If\nit is, we set the y object variable\nback to -1.\nRun this code now, and the\nball should bounce up and down\nthe canvas until you close the\nwindow.\nBeginning Your First Game: Bounce! 201\nChanging the Ball’s\nstarting Direction\nMaking a ball bounce slowly up and\ndown isn’t much of a game, so let’s\nenhance things a bit by changing the\nball’s starting direction—the angle that\nit flies off when the game starts. In the\n__init__ function, change these lines:\nself.x = 0\nself.y = -1\nto the following (make sure you have the right number of spaces—\nthere are eight—at the beginning of each line):\nu starts = [-3, -2, -1, 1, 2, 3]\nv random.shuffle(starts)\nw self.x = starts[0]\nx self.y = -3\nAt u, we create the variable starts with a list of six numbers,\nand then mix up the list at v by calling random.shuffle. At w, we\nset the value of x to the first item in the list, so that x can be any\nnumber in the list, from –3 to 3.\nIf we then change y to –3 at x (to speed up the ball), we need\nto make a few more additions to be sure that the ball won’t just\nvanish off the side of the screen. Add the following line to the end\nof the __init__ function to save the width of the canvas to a new\nobject variable, canvas_width:\nself.canvas_width = self.canvas.winfo_width()\nWe’ll use this new object variable in the draw function to see if\nthe ball has hit the top or bottom of the canvas:\nif pos[0] <= 0:\nself.x = 3\nif pos[2] >= self.canvas_width:\nself.x = -3\n202 Chapter 13\nSince we’re setting x to 3 and –3, we’ll do the same with y, so\nthat the ball moves at the same speed in all directions. Your draw\nfunction should now look like this:\ndef draw(self):\nself.canvas.move(self.id, self.x, self.y)\npos = self.canvas.coords(self.id)\nif pos[1] <= 0:\nself.y = 3\nif pos[3] >= self.canvas_height:\nself.y = -3\nif pos[0] <= 0:\nself.x = 3\nif pos[2] >= self.canvas_width:\nself.x = -3\nSave and run the code, and the ball should bounce around\nthe screen without vanishing. And here is what the full program\nshould look like now:\nfrom tkinter import *\nimport random\nimport time\nclass Ball:\ndef __init__(self, canvas, color):\nself.canvas = canvas\nself.id = canvas.create_oval(10, 10, 25, 25, fill=color)\nself.canvas.move(self.id, 245, 100)\nstarts = [-3, -2, -1, 1, 2, 3]\nrandom.shuffle(starts)\nself.x = starts[0]\nself.y = -3\nself.canvas_height = self.canvas.winfo_height()\nself.canvas_width = self.canvas.winfo_width()\ndef draw(self):\nself.canvas.move(self.id, self.x, self.y)\npos = self.canvas.coords(self.id)\nif pos[1] <= 0:\nself.y = 3\nif pos[3] >= self.canvas_height:\nself.y = -3\nif pos[0] <= 0:\nself.x = 3\nif pos[2] >= self.canvas_width:\nself.x = -3\nBeginning Your First Game: Bounce! 203\ntk = Tk()\ntk.title(\"Game\")\ntk.resizable(0, 0)\ntk.wm_attributes(\"-topmost\", 1)\ncanvas = Canvas(tk, width=500, height=400, bd=0, highlightthickness=0)\ncanvas.pack()\ntk.update()\nball = Ball(canvas, 'red')\nwhile 1:\nball.draw()\ntk.update_idletasks()\ntk.update()\ntime.sleep(0.01)\nWhat You Learned\nIn this chapter, we started creating our first game using the\ntkinter module. We created a class for a ball and animated it so\nthat it moves around the screen. We used coordinates to check\nwhen the ball hits the sides of the canvas, so that we can make it\nbounce. We also used the shuffle function in the random module, so\nour ball doesn’t always start moving in the exact same direction.\nIn the next chapter, we’ll complete the game by adding the paddle.\n204 Chapter 13\n14\nfIn IsHIn G YoUR fIRst\nGAMe: BoUnCe!\nIn the previous chapter, we got started creating our\nfirst game: Bounce! We created a canvas and added\na bouncing ball to our game code. But our ball will\nbounce around the screen forever (or at least until you\nturn your computer off), which doesn’t make for much\nof a game. Now we’ll add a paddle for the player to use.\nWe’ll also add an element of chance to the game, which\nwill make it a bit more challenging and fun to play."
  },
  {
    "input": "How can you modify the code to make the paddle move left and right based on the left and right arrow key presses?",
    "summary": "The text explains how to create a bouncing ball game using Python and the tkinter module. It includes adding a paddle class, making the paddle move with arrow keys, and detecting when the ball hits the paddle. The game also ends when the ball hits the bottom of the canvas, adding an element of chance. Finally, it suggests ways to enhance the game, such as adding a game start delay, a game over message, accelerating the ball, and recording the player's score.",
    "output": "Adding the Paddle\nThere’s not much fun to be had with a bounc-\ning ball when there’s nothing to hit it with.\nTime to create a paddle!\nBegin by adding the following code just\nafter the Ball class, to create a paddle (you’ll\nstick this in a new line below the Ball draw\nfunction):\ndef draw(self):\nself.canvas.move(self.id, self.x, self.y)\npos = self.canvas.coords(self.id)\nif pos[1] <= 0:\nself.y = 3\nif pos[3] >= self.canvas_height:\nself.y = -3\nif pos[0] <= 0:\nself.x = 3\nif pos[2] >= self.canvas_width:\nself.x = -3\nclass Paddle:\ndef __init__(self, canvas, color):\nself.canvas = canvas\nself.id = canvas.create_rectangle(0, 0, 100, 10, fill=color)\nself.canvas.move(self.id, 200, 300)\ndef draw(self):\npass\nThis added code is almost exactly the same as that of the Ball\nclass, except that we call create_rectangle (rather than create_oval),\nand we move the rectangle to position 200, 300 (200 pixels\nacross and 300 pixels down).\nNext, at the bottom of your code listing, create an object of the\nPaddle class, and then change the main loop to call the paddle’s draw\nfunction, as shown here:\npaddle = Paddle(canvas, 'blue')\nball = Ball(canvas, 'red')\nwhile 1:\nball.draw()\npaddle.draw()\n206 Chapter 14\ntk.update_idletasks()\ntk.update()\ntime.sleep(0.01)\nIf you run the game now, you should see the bouncing ball and\na stationary rectangular paddle:\nMaking the Paddle Move\nTo make the paddle move left and right,\nwe’ll use event bindings to bind the left and\nright arrow keys to new functions in the\nPaddle class. When the player presses the\nleft arrow key, the x variable will be set to\n-2 (to move left). Pressing the right arrow\nkey sets the x variable to 2 (to move right).\nThe first step is to add the x object\nvariable to the __init__ function of our\nPaddle class, and also a variable for the can-\nvas width, as we did with the Ball class:\ndef __init__(self, canvas, color):\nself.canvas = canvas\nself.id = canvas.create_rectangle(0, 0, 100, 10, fill=color)\nself.canvas.move(self.id, 200, 300)\nself.x = 0\nself.canvas_width = self.canvas.winfo_width()\nFinishing Your First Game: Bounce! 207\nNow we need the functions for changing the direction between\nleft (turn_left) and right (turn_right). We’ll add these just after the\ndraw function:\ndef turn_left(self, evt):\nself.x = -2\ndef turn_right(self, evt):\nself.x = 2\nWe can bind these functions to the correct key in the __init__\nfunction of the class with these two lines. We used binding in “Mak-\ning an Object React to Something” on page 187 to make Python\ncall a function when a key is pressed. In this case, we bind the\nturn_left function of our Paddle class to the left arrow key using the\nevent name '<KeyPress-Left>'. We then bind the turn_right function\nto the right arrow key using the event name '<KeyPress-Right>'.\nOur __init__ function now looks like this:\ndef __init__(self, canvas, color):\nself.canvas = canvas\nself.id = canvas.create_rectangle(0, 0, 100, 10, fill=color)\nself.canvas.move(self.id, 200, 300)\nself.x = 0\nself.canvas_width = self.canvas.winfo_width()\nself.canvas.bind_all('<KeyPress-Left>', self.turn_left)\nself.canvas.bind_all('<KeyPress-Right>', self.turn_right)\nThe draw function for the Paddle class is similar to that for the\nBall class:\ndef draw(self):\nself.canvas.move(self.id, self.x, 0)\npos = self.canvas.coords(self.id)\nif pos[0] <= 0:\nself.x = 0\nelif pos[2] >= self.canvas_width:\nself.x = 0\nWe use the canvas’s move function to move the paddle in the\ndirection of the x variable with self.canvas.move(self.id, self.x, 0).\nThen we get the paddle’s coordinates to see if it has hit the left or\nright side of the screen using the value in pos.\n208 Chapter 14\nRather than bouncing like the ball, the paddle should stop\nmoving. So, when the left x coordinate (pos[0]) is less than or equal\nto 0 (<= 0), we set the x variable to 0 with self.x = 0. In the same\nway, when the right x coordinate (pos[2]) is greater than or equal\nto the canvas width (>= self.canvas_width), we also set the x vari-\nable to 0 with self.x = 0.\nnote If you run the program now, you’ll need to click the canvas before\nthe game will recognize the left and right arrow key actions. Click-\ning the canvas gives the canvas focus, which means it knows to\ntake charge when someone presses a key on the keyboard.\nfinding out When the\nBall Hits the Paddle\nAt this point in our code, the ball\nwon’t hit the paddle; in fact, the ball\nwill fly straight through the paddle.\nThe ball needs to know when it has\nhit the paddle, just as the ball needs\nto know when it has hit a wall.\nWe could solve this problem by adding code to the draw function\n(where we have code that checks for walls), but it’s a better idea\nto move this sort of code into new functions to break things into\nsmaller chunks. If we put too much code in one place (inside one\nfunction, for example), we can make the code much more difficult\nto understand. Let’s make the necessary changes.\nFirst, we change the ball’s __init__ function so that we can\npass in the paddle object as a parameter:\nclass Ball:\nu def __init__(self, canvas, paddle, color):\nself.canvas = canvas\nv self.paddle = paddle\nself.id = canvas.create_oval(10, 10, 25, 25, fill=color)\nself.canvas.move(self.id, 245, 100)\nstarts = [-3, -2, -1, 1, 2, 3]\nrandom.shuffle(starts)\nself.x = starts[0]\nself.y = -3\nself.canvas_height = self.canvas.winfo_height()\nself.canvas_width = self.canvas.winfo_width()\nFinishing Your First Game: Bounce! 209\nNotice at u that we change the parameters of __init__ to\ninclude the paddle. Then at v, we assign the paddle parameter\nto the object variable paddle.\nHaving saved the paddle object, we need to change the code\nwhere we create the ball object. This change is at the bottom of\nthe program, just before the main loop:\npaddle = Paddle(canvas, 'blue')\nball = Ball(canvas, paddle, 'red')\nwhile 1:\nball.draw()\npaddle.draw()\ntk.update_idletasks()\ntk.update()\ntime.sleep(0.01)\nThe code we need to see if the ball has struck the paddle is a\nlittle more complicated than the code to check for walls. We’ll call\nthis function hit_paddle and add it to the draw function of the Ball\nclass, where we see if the ball has hit the bottom of the screen:\ndef draw(self):\nself.canvas.move(self.id, self.x, self.y)\npos = self.canvas.coords(self.id)\nif pos[1] <= 0:\nself.y = 3\nif pos[3] >= self.canvas_height:\nself.y = -3\nif self.hit_paddle(pos) == True:\nself.y = -3\nif pos[0] <= 0:\nself.x = 3\nif pos[2] >= self.canvas_width:\nself.x = -3\nAs you can see in the new code we added, if hit_paddle returns\nTrue, we change the direction of the ball by setting the y object vari-\nable to -3 with self.y = -3. But don’t try to run the game now—we\nhaven’t created the hit_paddle function yet. Let’s do that now.\nAdd the hit_paddle function just before the draw function.\n210 Chapter 14\nu def hit_paddle(self, pos):\nv paddle_pos = self.canvas.coords(self.paddle.id)\nw if pos[2] >= paddle_pos[0] and pos[0] <= paddle_pos[2]:\nx if pos[3] >= paddle_pos[1] and pos[3] <= paddle_pos[3]:\nreturn True\nreturn False\nFirst, we define the function with the parameter pos at u. This\nline contains the ball’s current coordinates. Then, at v, we get the\npaddle’s coordinates and store them in the variable paddle_pos.\nAt w, we have the first part of our if-then statement, and we\nsay, “If the right side of the ball is greater than the left side of\nthe paddle, and the left side of the ball is less than the right side\nof the paddle . . .” Here, pos[2] contains the x coordinate for the\nball’s right side, and pos[0] contains the x coordinate for its left\nside. The variable paddle_pos[0] contains the x coordinate for the\npaddle’s left side, and paddle_pos[2] contains its x coordinate for\nthe right side. The following diagram shows how these coordinates\nlook when the ball is about to hit the paddle.\npos[0] pos[2]\npaddle_pos[0] paddle_pos[2]\nThe ball is falling toward the paddle, but in this case, you see\nthat the right side of the ball (pos[2]) hasn’t yet crossed over the\nleft side of the paddle (that’s paddle_pos[0]).\nAt x, we see if the bottom of the ball (pos[3]) is between the\npaddle’s top (paddle_pos[1]) and bottom (paddle_pos[3]). In the next\ndiagram, you can see that the bottom of the ball (pos[3]) has yet to\nhit the top of the paddle (paddle_pos[1]).\nFinishing Your First Game: Bounce! 211\npos[1]\npos[3]\npaddle_pos[1]\npaddle_pos[3]\nSo, based on the current position of the ball, the hit_paddle\nfunction would return false.\nnote Why do we need to see if the bottom of the ball is between the top\nand bottom of the paddle? Why not just see if the bottom of the ball\nhas hit the top of the paddle? Because each time we move the ball\nacross the canvas, we move in 3-pixel jumps. If we just checked to\nsee if the ball had reached the top of the paddle (pos[1]), we might\nhave jumped past that position. In that case, the ball would con-\ntinue traveling, and it would pass through the paddle without\nstopping.\nAdding an element of Chance\nNow it’s time to turn our program\ninto a game rather than just a bounc-\ning ball and a paddle. Games need\nan element of chance—some way for\nthe player to lose. In our current\ngame, the ball will bounce forever,\nso there’s nothing to lose.\nWe’ll finish our game by adding\ncode that says that the game ends if\nthe ball hits the bottom of the can-\nvas (in other words, once it hits the\nground).\n212 Chapter 14\nFirst, we add the hit_bottom object variable to the bottom of the\nBall class’s __init__ function:\nself.canvas_height = self.canvas.winfo_height()\nself.canvas_width = self.canvas.winfo_width()\nself.hit_bottom = False\nThen we change the main loop at the bottom of the program,\nlike this:\nwhile 1:\nif ball.hit_bottom == False:\nball.draw()\npaddle.draw()\ntk.update_idletasks()\ntk.update()\ntime.sleep(0.01)\nNow the loop keeps checking hit_bottom to see if the ball has\nindeed hit the bottom of the screen. The code should continue mov-\ning the ball and paddle only if the ball hasn’t touched the bottom,\nas you can see in our if statement. The game ends when the ball\nand paddle stop moving. (We no longer animate them.)\nThe final change is to the draw function of the Ball class:\ndef draw(self):\nself.canvas.move(self.id, self.x, self.y)\npos = self.canvas.coords(self.id)\nif pos[1] <= 0:\nself.y = 3\nif pos[3] >= self.canvas_height:\nself.hit_bottom = True\nif self.hit_paddle(pos) == True:\nself.y = -3\nif pos[0] <= 0:\nself.x = 3\nif pos[2] >= self.canvas_width:\nself.x = -3\nWe altered the if statement to see if the ball has hit the bottom\nof the screen (that is, if it is greater than or equal to canvas_height).\nIf so, in the following line, we set hit_bottom to True, rather than\nchanging the value of the y variable, because there’s no need to\nbounce the ball once it hits the bottom of the screen.\nFinishing Your First Game: Bounce! 213\nWhen you run the game now and miss hitting the ball with\nthe paddle, all movement on your screen should stop, and the game\nwill end once the ball touches the bottom of the canvas:\nYour program should now look like the following code. If you\nhave trouble getting your game to work, check what you’ve entered\nagainst this code.\nfrom tkinter import *\nimport random\nimport time\nclass Ball:\ndef __init__(self, canvas, paddle, color):\nself.canvas = canvas\nself.paddle = paddle\nself.id = canvas.create_oval(10, 10, 25, 25, fill=color)\nself.canvas.move(self.id, 245, 100)\nstarts = [-3, -2, -1, 1, 2, 3]\nrandom.shuffle(starts)\nself.x = starts[0]\nself.y = -3\nself.canvas_height = self.canvas.winfo_height()\nself.canvas_width = self.canvas.winfo_width()\nself.hit_bottom = False\n214 Chapter 14\ndef hit_paddle(self, pos):\npaddle_pos = self.canvas.coords(self.paddle.id)\nif pos[2] >= paddle_pos[0] and pos[0] <= paddle_pos[2]:\nif pos[3] >= paddle_pos[1] and pos[3] <= paddle_pos[3]:\nreturn True\nreturn False\ndef draw(self):\nself.canvas.move(self.id, self.x, self.y)\npos = self.canvas.coords(self.id)\nif pos[1] <= 0:\nself.y = 3\nif pos[3] >= self.canvas_height:\nself.hit_bottom = True\nif self.hit_paddle(pos) == True:\nself.y = -3\nif pos[0] <= 0:\nself.x = 3\nif pos[2] >= self.canvas_width:\nself.x = -3\nclass Paddle:\ndef __init__(self, canvas, color):\nself.canvas = canvas\nself.id = canvas.create_rectangle(0, 0, 100, 10, fill=color)\nself.canvas.move(self.id, 200, 300)\nself.x = 0\nself.canvas_width = self.canvas.winfo_width()\nself.canvas.bind_all('<KeyPress-Left>', self.turn_left)\nself.canvas.bind_all('<KeyPress-Right>', self.turn_right)\ndef draw(self):\nself.canvas.move(self.id, self.x, 0)\npos = self.canvas.coords(self.id)\nif pos[0] <= 0:\nself.x = 0\nelif pos[2] >= self.canvas_width:\nself.x = 0\ndef turn_left(self, evt):\nself.x = -2\ndef turn_right(self, evt):\nself.x = 2\nFinishing Your First Game: Bounce! 215\ntk = Tk()\ntk.title(\"Game\")\ntk.resizable(0, 0)\ntk.wm_attributes(\"-topmost\", 1)\ncanvas = Canvas(tk, width=500, height=400, bd=0, highlightthickness=0)\ncanvas.pack()\ntk.update()\npaddle = Paddle(canvas, 'blue')\nball = Ball(canvas, paddle, 'red')\nwhile 1:\nif ball.hit_bottom == False:\nball.draw()\npaddle.draw()\ntk.update_idletasks()\ntk.update()\ntime.sleep(0.01)\nWhat You Learned\nIn this chapter, we finished creating\nour first game using the tkinter module.\nWe created classes for the paddle used in\nour game, and used coordinates to check\nwhen the ball hits the paddle or the walls\nof our game canvas. We used event bind-\nings to bind the left and right arrow keys\nto the movement of the paddle, and used\nthe main loop to call the draw function, to\nanimate it. Finally, we changed our code\nto give our game an element of chance, so\nthat when the player misses the ball, the\ngame is over when the ball hits the bot-\ntom of the canvas.\nProgramming Puzzles\nAt the moment, our game is a bit simple. There’s a lot you could\nchange to create a more professional game. Try enhancing your\ncode in the following ways to make it more interesting, and then\ncheck your answers at http://python-for-kids.com/.\n216 Chapter 14\n#1: Delay the Game start\nOur game starts a bit quickly, and you need to click the canvas\nbefore it will recognize pressing the left and right arrow keys on\nyour keyboard. Can you add a delay to the start of the game in\norder to give the player enough time to click the canvas? Or even\nbetter, can you add an event binding for a mouse click, which\nstarts the game only then?\nHint 1: You’ve already added event bindings to the Paddle class,\nso that might be a good place to start.\nHint 2: The event binding for the left mouse button is the\nstring '<Button-1>'.\n#2: A Proper “Game over”\nEverything just freezes when the game ends, and that’s not very\nplayer-friendly. Try adding the text “Game Over” when the ball\nhits the bottom of the screen. You can use the create_text func-\ntion, but you might also find the named parameter state useful (it\ntakes values such as normal and hidden). Have a look at itemconfig in\n“More Ways to Use the Identifier” on page 188. As an additional\nchallenge, add a delay so that the text doesn’t appear right away.\n#3: Accelerate the Ball\nIf you play tennis, you know that when a ball hits your racket, it\nsometimes flies away faster than the speed at which it arrived,\ndepending on how hard you swing. The ball in our game goes at\nthe same speed, whether or not the paddle is moving. Try chang-\ning the program so that the paddle’s speed is passed on to the\nspeed of the ball.\n#4: Record the Player’s score\nHow about recording the score? Every time the ball hits the paddle,\nthe score should increase. Try displaying the score at the top-right\ncorner of the canvas. You might want to look back at itemconfig in\n“More Ways to Use the Identifier” on page 188 for a hint.\nFinishing Your First Game: Bounce! 217\nPart III\nM r. s tick Man\nRaces for\nthe e xit"
  },
  {
    "input": "What is the purpose of using transparent backgrounds when creating graphics for the Mr. Stick Man game?",
    "summary": "We should create a plan for our game, including its description, major elements, and characters. For the Mr. Stick Man game, we need images of the character, platforms, door, and background, with transparent backgrounds for the non-background elements. Using GIMP, we can create these graphics, ensuring transparency for proper game visuals.",
    "output": "15\nCReAtInG GRAPHICs foR\ntHe MR. stICK MAn GAMe\nIt’s a good idea to develop a plan when creating a game\n(or any program). Your plan should include a descrip-\ntion of what the game is about, as well as a description\nof the game’s major elements and characters. When it’s\ntime to start programming, your description will help\nkeep you focused on what you are trying to develop.\nYour game might not turn out exactly like the original\ndescription—and that’s okay as well.\nIn this chapter, we’ll begin developing a fun game\ncalled Mr. Stick Man Races for the Exit.\nMr. stick Man Game Plan\nHere’s the description of our new game:\n• Secret agent Mr. Stick Man is trapped in\nthe lair of Dr. Innocuous, and you want to\nhelp him escape through the exit on the\ntop floor.\n• The game has a stick figure that can\nrun from left to right and jump up. There\nare platforms on each floor that he must\njump to.\n• The goal of the game is to reach the door\nto the exit, before it’s too late and the\ngame ends.\nBased on this description, we know we’ll need several images,\nincluding ones for Mr. Stick Man, the platforms, and the door.\nWe’ll obviously need code to pull all this together, but before we\nget there, we’ll create the graphics for our game in this chapter.\nThat way, we’ll have something to work with in the next chapter.\nHow will we draw the elements in our game? We could use\ngraphics like the ones that we created for the bouncing ball and\npaddle in the previous chapters, but those are far too simple for\nthis game. Instead, we’re going to create sprites.\nSprites are the things in a game—typically a character of\nsome kind. Sprites are usually prerendered, meaning they are\ndrawn in advance (before the program runs) rather than being\ncreated by the program itself using polygons, as in our Bounce!\ngame. Mr. Stick Man will be a sprite, and the platforms will be\nsprites, too. In order to create these images, you’ll need to install\na graphics program.\nGetting GIMP\nSeveral graphics programs are available, but for this game, we\nneed one that supports transparency (sometimes called the alpha\nchannel), which lets images have sections where no colors are\ndrawn on the screen. We need images with transparent parts\n222 Chapter 15\nbecause when one image passes over or near another as it moves\nacross the screen, we don’t want the background of one image to\nwipe out part of another. For example, in this image, the checker-\nboard pattern in the background represents the transparent area:\nSo if we copy the entire image and paste it over the top of\nanother image, the background won’t wipe anything out:\nCreating Graphics for the Mr. Stick Man Game 223\nGIMP (http://www.gimp.org/), short for GNU Image Manipu-\nlation Program, is a free graphics program for Linux, Mac OS X,\nand Windows that supports transparent images. Download and\ninstall it as follows:\n• If you’re using Windows, you’ll be able to find Windows\ninstallers on the GIMP-WIN project page at http://gimp-win\n.sourceforge.net/stable.html.\n• If you’re using Ubuntu, install GIMP by opening the Ubuntu\nSoftware Center and entering gimp in the search box. Click\nthe Install button for the GIMP Image Editor when it appears\nin the results.\n• If you’re using Mac OS X, download an application bundle\nfrom http://gimp.lisanet.de/Website/Download.html.\nYou should also create a directory for your game. To do so,\nright-click your desktop anywhere there is empty space and select\nNew4Folder (on Ubuntu, the option is Create New Folder; on\nMac OS X, it’s New Folder). In the dialog, enter stickman for the\nfolder name.\nCreating the Game elements\nOnce you have your graphics program installed, you’re ready to\ndraw. We’ll create these images for our game elements:\n• Images for a stick figure that can run left and right and jump\n• Images for the platform, in three different sizes\n• Images for the door: one open and one closed\n• An image for the game’s background (because a plain white or\ngray background makes for a boring game)\nBefore we start drawing, we need to prepare our images with\ntransparent backgrounds.\nPreparing a transparent Image\nTo set up an image with transparency—an alpha channel—start\nup GIMP, and then follow these steps:\n1. Select File4New.\n224 Chapter 15\n2. In the dialog, enter 27 pixels for the image width and 30 pixels\nfor its height.\n3. Select Layer4Transparency4Add Alpha Channel.\n4. Select Select4All.\n5. Select Edit4Cut.\nThe end result should be an image filled with a checkerboard\nof dark gray and light gray, as shown here (zoomed in):\nNow we can begin creating our secret agent: Mr. Stick Man.\nDrawing Mr. stick Man\nTo draw our first stick figure image, click\nthe Paintbrush tool in the GIMP Toolbox,\nand then select the brush that looks like\na small dot in the Brushes toolbar (usu-\nally at the bottom right of the screen), as\nshown on the right.\nWe’ll draw three different images\n(or frames) for our stick figure to show\nhim running and jumping to the right.\nWe’ll use these frames to animate\nMr. Stick Man, as we did for the ani-\nmation in C hapter 12.\nCreating Graphics for the Mr. Stick Man Game 225\nIf you zoom in to look at these images, they might look\nlike this:\nYour images don’t need to look exactly the same, but they should\nhave the stick figure with three different positions of movement.\nRemember that each one is 27 pixels wide by 30 pixels tall.\nMr. stick Man Running to the Right\nFirst, we’ll draw a sequence of frames for Mr. Stick Man running\nto the right. Create the first image as follows:\n1. Draw the first image (the leftmost image in the preceding\nillustration).\n2. Select File4Save As.\n3. In the dialog, enter figure-R1.gif for the name. Then click the\nsmall plus (+) button labeled Select File Type.\n4. Select GIF image in the list that appears.\n5. Save the file to the stickman directory you created earlier (click\nBrowse for Other Folders to find the correct directory).\nFollow the same steps to create\na new 27 pixel by 30 pixel image,\nand then draw the next Mr. Stick\nMan image. Save this image as\nfigure-R2.gif. Repeat the process\nfor the final image, and save it as\nfigure-R3.gif.\n226 Chapter 15\nMr. stick Man Running to the Left\nRather than re-creating our drawings for the stick figure moving\nto the left, we can use GIMP to flip our frames of Mr. Stick Man\nmoving to the right.\nIn GIMP, open each image in sequence, and then select Tools4\nTransform Tools4Flip. When you click the image, you should see\nit flip from side to side. Save the images as figure-L1.gif, figure-L2\n.gif, and figure-L3.gif.\nNow we’ve created six images for Mr. Stick Man, but we still\nneed images for the platforms and the door for the exit.\nDrawing the Platforms\nWe’ll create three platforms in differ-\nent sizes: 100 pixels wide by 10 pixels\ntall, 60 pixels wide by 10 pixels tall, and\n30 pixels wide by 10 pixels tall. You can\ndraw the platforms any way that you\nlike, but make sure that their back-\ngrounds are transparent, as with the\nstick figure images.\nCreating Graphics for the Mr. Stick Man Game 227\nHere’s what the three platform images might look like\nzoomed in:\nAs with the stick figure images, save these in the stickman\ndirectory. Call the smallest platform platform1.gif, the middle-\nsized one platform2.gif, and the largest one platform3.gif.\nDrawing the Door\nThe size of the door should be proportional to the size of Mr. Stick\nMan (27 pixels wide by 30 pixels tall), and we need two images:\none for the closed door and another for the open door. The doors\nmight look like this (again zoomed in):\nTo create these images, follow these steps:\n1. Click the foreground color box (at the bot-\ntom of the GIMP Toolbox) to display the\ncolor chooser. Select the color you want for\nyour door. On the right is an example with\nyellow selected.\n2. Choose the Bucket tool (shown selected\nin the Toolbox), and fill the screen with the\ncolor you chose.\n3. Change the foreground color to black.\n228 Chapter 15\n4. Choose either the Pencil or Paintbrush tool (to the right of the\nBucket tool), and draw the black outline of the door and the\ndoorknob.\n5. Save these in the stickman directory, and call them door1.gif\nand door2.gif.\nDrawing the Background\nThe final image we need to create is the background. We’ll make\nthis image 100 pixels wide by 100 pixels tall. It does not need a\ntransparent background because we’ll fill it with a single color that\nwill be the background “wallpaper” behind all the other elements\nof the game.\nTo create the background, select File4New and give the\nimage’s size as 100 pixels wide and 100 pixels tall. Choose a suit-\nably evil color for the wallpaper of a villain’s lair. I chose a darker\nshade of pink.\nYou can dress up your wallpaper with flowers, stripes, stars,\nand such—whatever you think looks suitable for the game. For\nexample, if you want to add stars to the wallpaper, choose another\ncolor, select the Pencil tool, and draw your first star. Then use the\nSelection tool to select a box around the star, and copy and paste\nit around the image (select Edit4Copy, and then Edit4Paste).\nYou should be able to drag the pasted image around the screen by\nclicking it. Here’s an example with some stars, and the Selection\ntool selected in the Toolbox:\nCreating Graphics for the Mr. Stick Man Game 229\nOnce you’re happy with your drawing, save the image as\nbackground.gif in the stickman directory.\ntransparency\nWith our graphics created, you can get a better of idea of why our\nimages (other than the background) need transparency. What\nwould happen if we placed Mr. Stick Man in front of our back-\nground wallpaper and he didn’t have a transparent background?\nHere’s the answer:\nThe white background of Mr. Stick Man wipes out part of the\nwallpaper. But if we use our transparent image, we get this:\nNothing in the background is obscured by the stick figure\nimage, except for whatever he covers himself. That’s much more\nprofessional!\n230 Chapter 15\nWhat You Learned\nIn this chapter, you learned how to\nwrite a basic plan for a game (Mr. Stick\nMan Races for the Exit in this case)\nand figured out where to begin. Because\nwe need graphical elements before we\ncan make a game, we used a graphics\nprogram to create the basic graphics for\nour game. In the process, you learned\nhow to make the backgrounds of these\nimages transparent so they don’t cover\nup other images on the screen.\nIn the next chapter, we’ll create\nsome of the classes for our game.\nCreating Graphics for the Mr. Stick Man Game 231"
  },
  {
    "input": "",
    "summary": "The text explains how to develop a Mr. Stick Man game by creating a `Game` class to set up the window and canvas,",
    "output": "16\nDeVeLoPI nG tHe\nMR. stICK MAn GAMe\nNow that we’ve created the images for our Mr. Stick\nMan Races for the Exit game, we can begin to develop\nthe code. The description of the game in the previous\nchapter gives us a basic idea of what we need: a stick\nfigure that can run and jump, and platforms that he\nmust jump to.\nWe’ll need code to display the stick figure and\nmove it across the screen, as well as to draw platforms.\nBut before we write that code, we need to create the\ncanvas to display our background image.\nCreating the Game Class\nFirst, we’ll create a class called Game, which will be our program’s\nmain controller. The Game class will have an __init__ function for ini-\ntializing the game and a mainloop function for doing the animation.\nsetting the Window title and\nCreating the Canvas\nIn the first part of the __init__ function, we’ll set the window title\nand create the canvas. As you’ll see, this part of the code is simi-\nlar to the code that we wrote for the Bounce! game in Chapter 13.\nOpen your editor and enter the following code, and then save your\nfile as stickmangame.py. Make sure you save it in the directory we\ncreated in Chapter 15 (called stickman).\nfrom tkinter import *\nimport random\nimport time\nclass Game:\ndef __init__(self):\nself.tk = Tk()\nself.tk.title(\"Mr. Stick Man Races for the Exit\")\nself.tk.resizable(0, 0)\nself.tk.wm_attributes(\"-topmost\", 1)\nself.canvas = Canvas(self.tk, width=500, height=500, \\\nhighlightthickness=0)\nself.canvas.pack()\nself.tk.update()\nself.canvas_height = 500\nself.canvas_width = 500\nIn the first half of this program (from from tkinter import * to\nself.tk.wm_attributes), we create the tk object and then set the win-\ndow title with self.tk.title to (\"Mr. Stick Man Races for the Exit\").\nWe make the window fixed (so it can’t be resized) by calling the\nresizable function, and then we move the window in front of all\nother windows with the wm_attributes function.\nNext, we create the canvas with the self.canvas = Canvas line,\nand call the pack and update functions of the tk object. Finally, we\ncreate two variables for our Game class, height and width, to store the\nheight and width of the canvas.\n234 Chapter 16\nnote The backslash (\\) in the self.canvas = Canvas line is used only to\nseparate the long line of code. It’s not required, but I’ve included it\nhere for readability since the entire line won’t fit on the page.\nfinishing the _init_ function\nNow enter the rest of the __init__ function into the stickfiguregame\n.py file that you just created. This code will load the background\nimage and then display it on the canvas:\nself.tk.update()\nself.canvas_height = 500\nself.canvas_width = 500\nu self.bg = PhotoImage(file=\"background.gif\")\nv w = self.bg.width()\nh = self.bg.height()\nw for x in range(0, 5):\nx for y in range(0, 5):\ny self.canvas.create_image(x * w, y * h, \\\nimage=self.bg, anchor='nw')\nz self.sprites = []\nself.running = True\nAt u, we create the variable bg, which contains a PhotoImage\nobject—the background image file called background.gif that we\ncreated in Chapter 15. Next, beginning at v, we store the width\nand height of the image in the variables w and h. The PhotoImage\nclass functions width and height return the size of the image once\nit has been loaded.\nNext come two loops inside this func-\ntion. To understand what they do, imagine\nthat you have a small square rubber stamp,\nan ink pad, and a large piece of paper. How\nare you going to fill the paper with colored\nsquares using the stamp? Well, you could\njust randomly cover the page with stamps\nuntil it’s filled. The result would be a mess,\nand it would take a while to complete, but\nit would fill the page. Or you could start\nstamping down the page in a column and\nthen move back to the top and start stamp-\ning down the page in the next column, as\nshown on the right.\nDeveloping the Mr. Stick Man Game 235\nThe background image we created in the previous chapter\nis our stamp. We know that the canvas is 500 pixels across and\n500 pixels down, and that we created a background image of\n100 pixels square. This tells us that we need five columns across\nand five rows down to fill the screen with images. We use the loop\nat w to calculate the columns across, and the loop at x to calculate\nrows going down.\nAt y, we multiply the first loop variable x by the width of the\nimage (x * w) to determine how far across we’re drawing, and then\nmultiply the second loop variable y by the height of the image (y * h)\nto calculate how far down to draw. We use the create_image function\nof the canvas object (self.canvas.create_image) to draw the image on\nthe screen using those coordinates.\nFinally, beginning with z, we create the variables sprites,\nwhich holds an empty list, and running, which contains the Boolean\nvalue True. We’ll use these variables later in our game code.\nCreating the mainloop function\nWe’ll use the mainloop function in the Game class to animate our\ngame. This function looks a lot like the main loop (or animation\nloop) we created for the Bounce! game in Chapter 13. Here it is:\nfor x in range(0, 5):\nfor y in range(0, 5):\nself.canvas.create_image(x * w, y * h, \\\nimage=self.bg, anchor='nw')\nself.sprites = []\nself.running = True\ndef mainloop(self):\nu while 1:\nv if self.running == True:\nw for sprite in self.sprites:\nx sprite.move()\ny self.tk.update_idletasks()\nself.tk.update()\ntime.sleep(0.01)\nAt u, we create a while loop that will run until the game win-\ndow is closed. Next, at v, we check to see if the variable running\nis equal to True. If it is, we loop through any sprites in the list of\nsprites (self.sprites) at w, calling the function move for each one\nat x. (Of course, we have yet to create any sprites, so this code\n236 Chapter 16\nwouldn’t do anything if you ran the program\nnow, but it will be useful later.)\nThe last three lines of the function, begin-\nning at y, force the tk object to redraw the\nscreen and sleep for a fraction of a second, as\nwe did with the Bounce! game in Chapter 13.\nSo that you can run this code, add the\nfollowing two lines (note that there’s no inden-\ntation required for these two lines) and save\nthe file.\ng = Game()\ng.mainloop()\nnote Be sure to add this code to the bottom of your game file. Also, make\nsure that your images are in the same directory as the Python file.\nIf you created the stickman directory in Chapter 15 and saved all\nyour images there, the Python file for this game should be there\nas well.\nThis code creates an object of the Game class and saves it as the\nvariable g. We then call the mainloop function on the new object to\ndraw the screen.\nOnce you’ve saved the program, run it in IDLE by choosing\nRun4Run Module. You will see a window appear with the back-\nground image filling the canvas.\nDeveloping the Mr. Stick Man Game 237\nWe’ve added a nice background for our game, and created\nan animation loop that will draw sprites for us (once we’ve cre-\nated them).\nCreating the Coords Class\nNow we’ll create the class that we’ll use to specify the position of\nsomething on our game screen. This class will store the top-left (x1\nand y1) and bottom-right (x2 and y2) coordinates of any component\nof our game.\nHere’s how you might record the position of the stick figure\nimage using these coordinates:\nx1,y1\nx2,y2\nWe’ll call our new class Coords, and it will contain only an\n__init__ function, where we pass the four parameters (x1, y1, x2,\nand y2). Here’s the code to add (put it at the beginning of the\nstickmangame.py file):\nclass Coords:\ndef __init__(self, x1=0, y1=0, x2=0, y2=0):\nself.x1 = x1\nself.y1 = y1\nself.x2 = x2\nself.y2 = y2\nNotice that each parameter is saved as an object variable of\nthe same name (x1, y1, x2, and y2). We’ll be using objects of this\nclass shortly.\n238 Chapter 16\nChecking for Collisions\nOnce we know how to store the position of our game sprites, we\nneed a way to tell if one sprite has collided with another, like when\nMr. Stick Man jumps around the screen and bangs into one of\nthe platforms. To make this problem easier to solve, we can break\nit down into two smaller problems: checking if sprites are collid-\ning vertically and checking if sprites are colliding horizontally.\nThen we can combine our two smaller solutions to easily see if two\nsprites are colliding in any direction!\nsprites Colliding Horizontally\nFirst, we’ll create the within_x function to determine if one set of\nx coordinates (x1 and x2) has crossed over another set of x coordi-\nnates (again, x1 and x2). There’s more than one way to do this, but\nhere’s a simple approach which you can add just below the Coords\nclass:\nclass Coords:\ndef __init__(self, x1=0, y1=0, x2=0, y2=0):\nself.x1 = x1\nself.y1 = y1\nself.x2 = x2\nself.y2 = y2\ndef within_x(co1, co2):\nu if co1.x1 > co2.x1 and co1.x1 < co2.x2:\nv return True\nw elif co1.x2 > co2.x1 and co1.x2 < co2.x2:\nx return True\ny elif co2.x1 > co1.x1 and co2.x1 < co1.x2:\nreturn True\nz elif co2.x2 > co1.x1 and co2.x2 < co1.x1:\nreturn True\n{ else:\n| return False\nThe within_x function takes the parameters co1 and co2, both\nCoords objects. At u, we check to see if the leftmost position of\nthe first coordinate object (co1.x1) is between the leftmost position\n(co2.x1) and the rightmost position (co2.x2) of the second coordinate\nobject. We return True at v if it is.\nDeveloping the Mr. Stick Man Game 239\nLet’s take a look at two lines with overlapping x coordinates to\nunderstand how this works. Each line starts at x1 and finishes at x2.\nx1=50 x2=100\nx1=40 x2=150\nThe first line in this diagram (co1) starts at pixel position 50\n(x1) and finishes at 100 (x2). The second line (co2) starts at position\n40 and finishes at 150. In this case, because the x1 position of the\nfirst line is between the x1 and x2 positions of the second line,\nthe first if statement in the function would be true for these two\nsets of coordinates.\nWith the elif at w, we see whether the rightmost position of\nthe first line (co1.x2) is between the leftmost position (co2.x1) and\nrightmost position (co2.x2) of the second. If it is, we return True at x.\nThe two elif statements at y and z do almost the same thing: They\ncheck the leftmost and rightmost positions of the second line (co2)\nagainst the first (co1).\nIf none of the if statements match, we reach else at {, and\nreturn False at |. This is effectively saying, “No, the two coordi-\nnate objects do not cross over each other horizontally.”\nTo see an example of the function working, look back at the\ndiagram showing the first and second lines. The x1 and x2 positions\nof the first coordinate object are 40 and 100, and the x1 and x2 posi-\ntions of the second coordinate object are 50 and 150. Here’s what\nhappens when we call the within_x function that we wrote:\n>>> c1 = Coords(40, 40, 100, 100)\n>>> c2 = Coords(50, 50, 150, 150)\n>>> print(within_x(c1, c2))\nTrue\nThe function returns True. This is the first step to being\nable to determine whether one sprite has bumped into another.\nFor example, when we create a class for Mr. Stick Man and for\nthe platforms, we will be able to tell if their x coordinates have\ncrossed one another.\n240 Chapter 16\nIt’s not really good programming practice to have lots of if or\nelif statements that return the same value. To solve this problem,\nwe can shorten the within_x function by surrounding each of its\nconditions with parentheses, separated by the or keyword. If you\nwant a slightly neater function, with a few less lines of code, you\ncan change the function so it looks like this:\ndef within_x(co1, co2):\nif (co1.x1 > co2.x1 and co1.x1 < co2.x2) \\\nor (co1.x2 > co2.x1 and co1.x2 < co2.x2) \\\nor (co2.x1 > co1.x1 and co2.x1 < co1.x2) \\\nor (co2.x2 > co1.x1 and co2.x2 < co1.x1):\nreturn True\nelse:\nreturn False\nTo extend the if statement across multiple lines so that we\ndon’t end up with one really long line containing all the conditions,\nwe use a backslash (\\), as shown above.\nsprites Colliding Vertically\nWe also need to know if sprites collide\nvertically. The within_y function is very\nsimilar to the within_x function. To create\nit, we check whether the y1 position of the\nfirst coordinate has crossed over the y1\nand y2 positions of the second, and then\nvice versa. Here’s the function to add (put\nit below the within_x function)—this time\nwe’ll write it using the shorter version of\nthe code (rather than lots of if statements):\ndef within_y(co1, co2):\nif (co1.y1 > co2.y1 and co1.y1 < co2.y2) \\\nor (co1.y2 > co2.y1 and co1.y2 < co2.y2) \\\nor (co2.y1 > co1.y1 and co2.y1 < co1.y2) \\\nor (co2.y2 > co1.y1 and co2.y2 < co1.y1):\nreturn True\nelse:\nreturn False\nDeveloping the Mr. Stick Man Game 241\nPutting It All together:\nour final Collision-Detection Code\nOnce we’ve determined whether one set of x coordinates has\ncrossed over another, and done the same for y coordinates, we can\nwrite functions to see whether a sprite has hit another sprite and\non which side. We’ll do this with the functions collided_left, col-\nlided_right, collided_top, and collided_bottom.\nthe collided_left function\nHere’s the code for the collided_left function, which you can add\nbelow the two within functions we just created:\nu def collided_left(co1, co2):\nv if within_y(co1, co2):\nw if co1.x1 <= co2.x2 and co1.x1 >= co2.x1:\nx return True\ny return False\nThis function tells us whether the left-hand side (the x1 value)\nof a first coordinate object has hit another coordinate object.\nThe function takes two parameters: co1 (the first coordinate\nobject) and co2 (the second coordinate object). As you can see at u,\nwe check whether the two coordinate objects have crossed over verti-\ncally, using the within_y function at v. After all, there’s no point in\nchecking whether Mr. Stick Man has hit a platform if he is floating\nway above it, like this:\nx1,y1\nx1,y1\nx1,y1\nx2,y2\n242 Chapter 16\nAt w, we see if the value of the left-\nmost position of the first coordinate object\n(co1.x1) has hit the x2 position of the sec-\nond coordinate object (co2.x2)—that it is\nless than or equal to the x2 position. We\nalso check to make sure that it hasn’t\ngone past the x1 position. If it has hit the\nside, we return True at x. If none of the if\nstatements are true, we return False at y.\nthe collided_right function\nThe collided_right function looks a lot like collided_left:\ndef collided_right(co1, co2):\nu if within_y(co1, co2):\nv if co1.x2 >= co2.x1 and co1.x2 <= co2.x2:\nw return True\nx return False\nAs with collided_left, we check to see if the y coordinates have\ncrossed over each other using the within_y function at u. We then\ncheck to see if the x2 value is between the x1 and x2 positions of the\nsecond coordinate object at v, and return True at w if it is. Other-\nwise, we return False at x.\nthe collided_top function\nThe collided_top function is very similar to the two functions we\njust added.\ndef collided_top(co1, co2):\nu if within_x(co1, co2):\nv if co1.y1 <= co2.y2 and co1.y1 >= co2.y1:\nreturn True\nreturn False\nThe difference is that this time, we check to see if the coordi-\nnates have crossed over horizontally, using the within_x function\nat u. Next, at v, we see if the topmost position of the first coor-\ndinate (co1.y1) has crossed over the y2 position of the second\ncoordinate, but not its y1 position. If so, we return True (mean-\ning that yes, the top of the first coordinate has hit the second\ncoordinate).\nDeveloping the Mr. Stick Man Game 243\nthe collided_bottom function\nOf course, you knew that one of these four functions had to be just\na bit different, and it is. Here’s the collided_bottom function:\ndef collided_bottom(y, co1, co2):\nu if within_x(co1, co2):\nv y_calc = co1.y2 + y\nw if y_calc >= co2.y1 and y_calc <= co2.y2:\nx return True\ny return False\nThis function takes an additional parameter, y, a value that\nwe add to the y position of the first coordinate. At u, we see if\nthe coordinates have crossed over horizontally (as we did with\nc ollided_top). Next, we add the value of the y parameter to the first\ncoordinate’s y2 position, and store the result in the variable y_calc\nat v. If at w the newly calculated value is between the y1 and y2\nvalues of the second coordinate, we return True at x because the\nbottom of coordinate co1 has hit the top of coordinate co2. However,\nif none of the if statements are true, we return False at y.\nWe need the additional y parameter because Mr. Stick Man\ncould fall off a platform. Unlike with the other collided functions,\nwe need to be able to test to see if he would collide at the bottom,\nrather than whether he already has. If he walks off a platform and\nkeeps floating in midair, our game won’t be very realistic; so as he\nwalks, we check to see if he has collided with something on the left\nor right. However, when we check below him, we see if he would\ncollide with the platform; if not, he needs to go crashing down!\nCreating the sprite Class\nWe’ll call the parent class for our game items Sprite. This class will\nprovide two functions: move to move the sprite and coords to return\nthe sprite’s current position on the screen. Here’s the code for the\nSprite class.\nclass Sprite:\nu def __init__(self, game):\nv self.game = game\nw self.endgame = False\nx self.coordinates = None\n244 Chapter 16\ny def move(self):\nz pass\n{ def coords(self):\n| return self.coordinates\nThe Sprite class’s __init__ function defined at u takes a single\nparameter: game. This parameter will be the game object. We need it\nso that any sprite we create will be able to access the list of other\nsprites in the game. We store the game parameter as an object vari-\nable at v.\nAt w, we store the object variable endgame, which we’ll use to\nindicate the end of the game. (At the moment, it’s set to False.) The\nfinal object variable, coordinates at x, is set to nothing (None).\nThe move function defined at y does nothing in this parent\nclass, so we use the pass keyword in the body of this function\nat z. The coords function at { simply returns the object variable\nc oordinates at |.\nSo our Sprite class has a move function\nthat does nothing and a coords function that\nreturns no coordinates. It doesn’t sound\nvery useful, does it? However, we know\nthat any classes that have Sprite as their\nparent will always have move and coords\nfunctions. So, in the main loop of the game,\nwhen we loop through a list of sprites, we\ncan call the function move, and it won’t\ncause any errors. Why not? Because each\nsprite has that function.\nnote Classes with functions that don’t do very much are actually quite\ncommon in programming. In a way, they’re a kind of agreement\nor contract that makes sure all the children of a class provide the\nsame sort of functionality, even if in some cases the functions in\nthe child classes do nothing.\nAdding the Platforms\nNow we’ll add the platforms. We’ll call our class for platform objects\nPlatformSprite, and it will be a child class of Sprite. The __init__\nfunction for this class will take a game parameter (as the Sprite\nDeveloping the Mr. Stick Man Game 245\nparent class does), as well as an image, x and y positions, and the\nimage width and height. Here’s the code for the PlatformSprite class:\nu class PlatformSprite(Sprite):\nv def __init__(self, game, photo_image, x, y, width, height):\nw Sprite.__init__(self, game)\nx self.photo_image = photo_image\ny self.image = game.canvas.create_image(x, y, \\\nimage=self.photo_image, anchor='nw')\nz self.coordinates = Coords(x, y, x + width, y + height)\nWhen we define the PlatformSprite class at u, we give it a sin-\ngle parameter: the name of the parent class (Sprite). The __init__\nfunction, at v, has seven parameters: self, game, photo_image, x, y,\nwidth, and height.\nAt w, we call the __init__ function of the parent\nclass, Sprite, using self and game as the parameter val-\nues, because other than the self keyword, the Sprite\nclass’s __init__ function takes only one parameter: game.\nAt this point, if we were to create a PlatformSprite\nobject, it would have all the object variables from its\nparent class (game, endgame, and coordinates), simply\nbecause we’ve called the __init__ function in Sprite.\nAt x, we save the photo_image parameter as an object variable,\nand at y we use the canvas variable of the game object to draw the\nimage on screen with create_image.\nFinally, we create a Coords object with the x and y parameters\nas the first two arguments. We then add the width and height param-\neters to these parameters for the second two arguments at z.\nEven though the coordinates variable is set to None in the Sprite\nparent class, we have changed it in our PlatformSprite child class\nto a real Coords object, containing the real location of the platform\nimage on the screen.\nAdding a Platform object\nLet’s add a platform to the game to see how it looks. Change the\nlast two lines of the game file (stickmangame.py) as follows:\nu g = Game()\nv platform1 = PlatformSprite(g, PhotoImage(file=\"platform1.gif\"), \\\n0, 480, 100, 10)\nw g.sprites.append(platform1)\nx g.mainloop()\n246 Chapter 16\nAs you can see, lines u and x have not changed, but at v, we\ncreate an object of the PlatformSprite class, passing it the variable\nfor our game (g), along with a PhotoImage object (which uses the first\nof our platform images, platform1.gif ). We also pass it the position\nwhere we want to draw the platform (0 pixels across and 480 pixels\ndown, near the bottom of the canvas), along with the height and\nwidth of our image (100 pixels across and 10 pixels high). We add\nthis sprite to the list of sprites in our game object at w.\nIf you run the game now, you should see a platform drawn at\nthe bottom-left side of the screen, like this:\nAdding a Bunch of P latforms\nLet’s add a whole bunch of platforms. Each platform will have\ndifferent x and y positions, so that they will be drawn scattered\naround the screen. Here’s the code to use:\ng = Game()\nplatform1 = PlatformSprite(g, PhotoImage(file=\"platform1.gif\"), \\\n0, 480, 100, 10)\nplatform2 = PlatformSprite(g, PhotoImage(file=\"platform1.gif\"), \\\n150, 440, 100, 10)\nplatform3 = PlatformSprite(g, PhotoImage(file=\"platform1.gif\"), \\\n300, 400, 100, 10)\nplatform4 = PlatformSprite(g, PhotoImage(file=\"platform1.gif\"), \\\n300, 160, 100, 10)\nDeveloping the Mr. Stick Man Game 247\nplatform5 = PlatformSprite(g, PhotoImage(file=\"platform2.gif\"), \\\n175, 350, 66, 10)\nplatform6 = PlatformSprite(g, PhotoImage(file=\"platform2.gif\"), \\\n50, 300, 66, 10)\nplatform7 = PlatformSprite(g, PhotoImage(file=\"platform2.gif\"), \\\n170, 120, 66, 10)\nplatform8 = PlatformSprite(g, PhotoImage(file=\"platform2.gif\"), \\\n45, 60, 66, 10)\nplatform9 = PlatformSprite(g, PhotoImage(file=\"platform3.gif\"), \\\n170, 250, 32, 10)\nplatform10 = PlatformSprite(g, PhotoImage(file=\"platform3.gif\"), \\\n230, 200, 32, 10)\ng.sprites.append(platform1)\ng.sprites.append(platform2)\ng.sprites.append(platform3)\ng.sprites.append(platform4)\ng.sprites.append(platform5)\ng.sprites.append(platform6)\ng.sprites.append(platform7)\ng.sprites.append(platform8)\ng.sprites.append(platform9)\ng.sprites.append(platform10)\ng.mainloop()\nWe create a lot of PlatformSprite objects, saving them as vari-\nables platform1, platform2, platform3, and so on, up to platform10. We\nthen add each platform to the variable sprites, which we created in\nour Game class. If you run the game now, it should look like this:\n248 Chapter 16\nWe’ve created the basics of our game! Now we’re ready to add\nour main character, Mr. Stick Man.\nWhat You Learned\nIn this chapter, you created the Game class and drew the background\nimage onto the screen like a kind of wallpaper. You learned how to\ndetermine whether a horizontal or vertical position is within the\nbounds of two other horizontal or vertical positions by creating the\nfunctions within_x and within_y. You then used these functions to\ncreate new functions to determine whether one coordinate object\nhad collided with another. We’ll use these functions in the next\nchapters when we animate Mr. Stick Man and need to detect\nwhether he has collided with a platform as he moves around the\ncanvas.\nWe also created a parent class Sprite and its first child class,\nPlatformSprite, which we used to draw the platforms onto the canvas.\nProgramming Puzzles\nThe following coding puzzles are some ways that you can experi-\nment with the game’s background image. Check your answers at\nhttp://python-for-kids.com/.\n#1: Checkerboard\nTry changing the Game class so that the background image is drawn\nlike a checkerboard:\nDeveloping the Mr. Stick Man Game 249\n#2: two-Image Checkerboard\nOnce you’ve figured out how to create a checkerboard effect, try\nusing two alternating images. Come up with another wallpaper\nimage (using your graphics program), and then change the Game\nclass so it displays a checkerboard with two alternating images\ninstead of one image and the blank background.\n#3: Bookshelf and Lamp\nYou can create different wallpaper images to make the background\nof the game look more interesting. Create a copy of the background\nimage, and then draw a simple bookshelf on it. Or you could draw\na table with a lamp or a window. Then dot these images around\nthe screen by changing the Game class so that it loads (and dis-\nplays) three or four different wallpaper images.\n250 Chapter 16"
  },
  {
    "input": "What is the purpose of the StickFigureSprite class in the game?",
    "summary": "This chapter introduces the StickFigureSprite class for Mr. Stick Man, which allows him to run left and right, jump, and interact with platforms. The class loads images for animation and sets up variables for movement and jumping. It also binds keyboard events to control Mr. Stick Man's actions. The next chapter will complete the game by adding animation and movement functionality for Mr. Stick Man.",
    "output": "17\nCReAtInG M R. stICK MAn\nIn this chapter, we’ll create the main character of\nour Mr. Stick Man Races for the Exit game. This will\nrequire the most complicated coding we’ve done so\nfar, because Mr. Stick Man needs to run left and right,\njump, stop when he runs into a platform, and fall when\nhe runs off the edge of a platform. We’ll use event bind-\nings for the left and right arrow keys to make the stick\nfigure run left and right, and we’ll have him jump\nwhen the player presses the spacebar.\nInitializing the stick figure\nThe __init__ function for our new stick figure class will look a lot\nlike it does in the other classes in our game so far. We start by\ngiving our new class a name: StickFigureSprite. As with previous\nclasses, this class has a parent class: Sprite.\nclass StickFigureSprite(Sprite):\ndef __init__(self, game):\nSprite.__init__(self, game)\nThis code looks like what we wrote for the PlatformSprite class\nin Chapter 16, except that we’re not using any additional param-\neters (other than self and game). The reason is that, unlike with the\nPlatformSprite class, there will be only one S tickFigureSprite object\nused in the game.\nLoading the stick figure Images\nBecause we have a lot of platform\nobjects on the screen, which each\ncan use a different-sized image,\nwe pass the platform image as a\nparameter of the PlatformSprite’s\n__init__ function (kind of like say-\ning, “Here, Platform Sprite, use\nthis image when you draw yourself\non the screen.”). But since there’s\nonly one stick figure on the screen,\nit doesn’t make sense to load the\nimage outside the sprite and then\npass it in as a parameter. The\nStickFigureSprite class will know\nhow to load its own images.\nThe next few lines of the __init__ function do this very job:\nThey load each of the three left images (which we’ll use to animate\nthe stick figure running left) and the three right images (used\nto animate the stick figure running right). We need to load these\nimages now, because we don’t want to have to load them every time\nwe display the stick figure on the screen (doing so would take too\nlong and make our game run slowly).\n252 Chapter 17\nclass StickFigureSprite(Sprite):\ndef __init__(self, game):\nSprite.__init__(self, game)\nu self.images_left = [\nPhotoImage(file=\"figure-L1.gif\"),\nPhotoImage(file=\"figure-L2.gif\"),\nPhotoImage(file=\"figure-L3.gif\")\n]\nv self.images_right = [\nPhotoImage(file=\"figure-R1.gif\"),\nPhotoImage(file=\"figure-R2.gif\"),\nPhotoImage(file=\"figure-R3.gif\")\n]\nw self.image = game.canvas.create_image(200, 470, \\\nimage=self.images_left[0], anchor='nw')\nThis code loads each of the three left images, which we’ll\nuse to animate the stick figure running left, and the three right\nimages, which we’ll use to animate the stick figure running right.\nAt u and v, we create the object variables images_left and\nimages_right. Each contains a list of PhotoImage objects that we cre-\nated in Chapter 15, showing the stick figure facing left and right.\nWe draw the first image at w with images_left[0] using the\ncanvas’s create_image function at position (200, 470), which puts the\nstick figure in the middle of the game screen, at the bottom of the\ncanvas. The create_image function returns a number that identifies\nthe image on the canvas. We store this identifier in the object vari-\nable image for later use.\nsetting Up Variables\nThe next part of the __init__ function sets up some more variables\nthat we’ll be using later in this code.\nself.images_right = [\nPhotoImage(file=\"figure-R1.gif\"),\nPhotoImage(file=\"figure-R2.gif\"),\nPhotoImage(file=\"figure-R3.gif\")\n]\nself.image = game.canvas.create_image(200, 470, \\\nimage=self.images_left[0], anchor='nw')\nu self.x = -2\nv self.y = 0\nw self.current_image = 0\nCreating Mr. Stick Man 253\nx self.current_image_add = 1\ny self.jump_count = 0\nz self.last_time = time.time()\n{ self.coordinates = Coords()\nAt u and v, the object variables x and y will store the amount\nwe’ll be adding to the stick figure’s horizontal (x1 and x2) or verti-\ncal (y1 and y2) coordinates when he is moving around the screen.\nAs you learned in Chapter 13, in order to animate something\nwith the tkinter module, we add values to the object’s x or y posi-\ntion to move it around the canvas. By setting x to –2, and y to 0, we\nsubtract 2 from the x position later in the code and add nothing to\nthe vertical position, to make the stick figure run to the left.\nnote Remember that a negative x number means move left on the canvas,\nand a positive x number means move right. A negative y number\nmeans move up, and a positive y number means move down.\nAt w, we create the object variable current_image to store\nthe image’s index position as currently displayed on the screen.\nOur list of left-facing images, images_left, contains figure-L1.gif,\nfigure-L2.gif, and figure-L3.gif. Those are index positions 0, 1,\nand 2.\nAt x, the variable current_image_add will contain the number\nwe’ll add to that index position stored in current_image to get the\nnext index position. For example, if the image at index position 0\nis displayed, we add 1 to get the next image at index position 1,\nand then add 1 again to get the final image in the list at index\nposition 2. (You’ll see how we use this variable for animation in\nthe next chapter.)\nThe variable jump_count at y is a counter we’ll use while the\nstick figure is jumping. The variable last_time will record the\nlast time we changed the image when animating our stick figure.\nWe store the current time using the time function of the time mod-\nule at z.\nAt {, we set the coordinates object variable to an object of the\nCoords class, with no initialization parameters set (x1, y1, x2, and y2\nare all 0). Unlike with the platforms, the stick figure’s coordinates\nwill change, so we’ll set these values later.\n254 Chapter 17\nBinding to Keys\nIn the final part of the __init__ function, the bind functions bind a\nkey to something in our code that needs to be run when the key is\npressed.\nself.jump_count = 0\nself.last_time = time.time()\nself.coordinates = Coords()\ngame.canvas.bind_all('<KeyPress-Left>', self.turn_left)\ngame.canvas.bind_all('<KeyPress-Right>', self.turn_right)\ngame.canvas.bind_all('<space>', self.jump)\nWe bind <KeyPress-Left> to the function turn_left, <KeyPress-Right>\nto the function turn_right, and <space> to the function jump. Now we\nneed to create those functions to make the stick figure move.\nturning the stick figure\nLeft and Right\nThe turn_left and turn_right functions\nmake sure that the stick figure is not\njumping, and then set the value of the\nobject variable x to move him left and\nright. (If our character is jumping, our\ngame doesn’t allow us to change his\ndirection in midair.)\ngame.canvas.bind_all('<KeyPress-Left>', self.turn_left)\ngame.canvas.bind_all('<KeyPress-Right>', self.turn_right)\ngame.canvas.bind_all('<space>', self.jump)\nu def turn_left(self, evt):\nv if self.y == 0:\nw self.x = -2\nx def turn_right(self, evt):\ny if self.y == 0:\nz self.x = 2\nPython calls the turn_left function when the player presses the\nleft arrow key, and it passes an object with information about what\nthe player did as a parameter. This object is called an event object,\nand we give it the parameter name evt.\nCreating Mr. Stick Man 255\nnote The event object isn’t important for our purposes, but we need to\ninclude it as a parameter of our functions (at u and x) or we’ll\nget an error because Python is expecting it to be there. The event\nobject contains things like the x and y positions of the mouse (mouse\nevent), a code identifying a particular key (keyboard event), and\nother information. For this game, none of that information is use-\nful, so we can safely ignore it.\nTo see if the stick figure is jumping, we check the value of\nthe y object variable at v and y. If the value is not 0, the stick\nfigure is jumping. In this example, if the value of y is 0, we set x\nto –2 to run left (w) or we set it to 2 to run right (z), because set-\nting the value to –1 or 1 wouldn’t make the stick figure move across\nthe screen fast enough. (Once you have the animation working for\nyour stick figure, try changing this value to see what difference it\nmakes.)\nMaking the stick figure Jump\nThe jump function is very similar to the turn_left and turn_right\nfunctions.\ndef turn_right(self, evt):\nif self.y == 0:\nself.x = 2\ndef jump(self, evt):\nu if self.y == 0:\nv self.y = -4\nw self.jump_count = 0\nThis function takes a parameter\nevt (the event object), which we can\nignore because we don’t need any more\ninformation about the event. If this\nfunction is called, we know it’s because\nthe spacebar was pressed.\nBecause we want our stick figure\nto jump only if he is not already jump-\ning, at u we check to see if y is equal\nto 0. If the stick figure is not jump-\ning, at v we set y to –4 (to move him\n256 Chapter 17\nvertically up the screen), and we set jump_count to 0 at w. We’ll use\njump_count to make sure the stick figure doesn’t just keep jumping\nforever. Instead, we’ll let him jump for a specific count and then\nhave him come down again, as if gravity were pulling him. We’ll\nadd this code in the next chapter.\nWhat We Have so far\nLet’s review the definitions of the classes and functions we now\nhave in our game, and where they should be in your file.\nAt the top of your program, you should have your import state-\nments, followed by the Game and Coords classes. The Game class will\nbe used to create an object which will be the main controller for\nour game, and objects of the Coords class are used to hold the posi-\ntions of things in our game (like the platforms and Mr. Stick Man):\nfrom tkinter import *\nimport random\nimport time\nclass Game:\n...\nclass Coords:\n...\nNext, you should have the within functions (which tell whether\nthe coordinates of one sprite are “within” the same area of another\nsprite), the Sprite parent class (which is the parent class of all the\nsprites in our game), the PlatformSprite class, and the beginning\nof the StickFigureSprite class. PlatformSprite was used to create\nplatform objects, which our stick figure will jump across, and we\ncreated one object of the StickFigureSprite class, to represent the\nmain character in our game:\ndef within_x(co1, co2):\n...\ndef within_y(co1, co2):\n...\nclass Sprite:\n...\nclass PlatformSprite(Sprite):\n...\nclass StickFigureSprite(Sprite):\n...\nCreating Mr. Stick Man 257\nFinally, at the end of your program, you should have code that\ncreates all the objects in our game so far: the game object itself and\nthe platforms. The final line is where we call the mainloop function.\ng = Game()\nplatform1 = PlatformSprite(g, PhotoImage(file=\"platform1.gif\"), \\\n0, 480, 100, 10)\n...\ng.sprites.append(platform1)\n...\ng.mainloop()\nIf your code looks a bit different, or you’re having trouble get-\nting it working, you can always skip ahead to the end of Chapter 18,\nwhere you’ll find the full listing for the entire game.\nWhat You Learned\nIn this chapter, we began working on the class for our stick figure.\nAt the moment, if we created an object of this class, it wouldn’t\nreally do much besides loading the images it needs for animat-\ning the stick figure, and setting up a few object variables to be\nused later in the code. This class contains a couple of functions for\nchanging the values in those object variables based on keyboard\nevents (when the player presses the left or right arrow, or the\nspacebar).\nIn the next chapter, we’ll finish our game. We’ll write the\nfunctions for the StickFigureSprite class to display and animate the\nstick figure, and move him around the screen. We’ll also add the\nexit (the door) that Mr. Stick Man is trying to reach.\n258 Chapter 17"
  },
  {
    "input": "What is the process for animating the stick figure and making him move around the screen while detecting collisions with platforms, the door, and the edges of the canvas?",
    "summary": "In this chapter, the Mr. Stick Man game is completed by adding animation to the stick figure, creating a door, and implementing collision detection. The stick figure can now run, jump, and interact with platforms and the door. The door is added as a new sprite that triggers the end of the game when Mr. Stick Man reaches it. The game's code includes functions for moving the stick figure, checking for collisions, and animating his movements. The final code allows players to run, jump, and reach the door to win the game.",
    "output": "18\nCoMPLetInG tHe\nMR. stICK MAn GAMe\nIn the previous three chapters, we’ve been develop-\ning our game: Mr. Stick Man Races for the Exit. We\ncreated the graphics, and then wrote code to add the\nbackground image, platforms, and stick figure. In this\nchapter, we’ll fill in the missing pieces to animate the\nstick figure and add the door.\nYou’ll find the full listing for the complete game\nat the end of this chapter. If you get lost or become\nconfused when writing some of this code, compare\nyour code with that listing to see where you might\nhave gone wrong.\nAnimating the stick figure\nSo far, we’ve created a basic class for our stick\nfigure, loading the images we’ll be using and\nbinding keys to some functions. But none of our\ncoding will do anything particularly interesting\nif you run our game at this point.\nNow we’ll add the remaining functions to the\nStickFigureSprite class we created in Chapter 17:\nanimate, move, and coords. The animate function will\ndraw the different stick figure images, move will\ndetermine where the character needs to move to,\nand coords will return the stick figure’s current\nposition. (Unlike with the platform sprites, we\nneed to recalculate the position of the stick fig-\nure as he moves around the screen.)\nCreating the Animate function\nFirst, we’ll add the animate function, which will need to check for\nmovement and change the image accordingly.\nChecking for Movement\nWe don’t want to change the stick figure image too quickly in our\nanimation or its movement won’t look realistic. Think about a flip\nanimation, drawn in the corner of a notepad—if you flip the pages\ntoo quickly, you may not get the full effect of what you’ve drawn.\nThe first half of the animate function checks to see if the stick\nfigure is running left or right, and then uses the last_time vari-\nable to decide whether to change the current image. This variable\nwill help us control the speed of our animation. The function will\ngo after the jump function, which we added to our StickFigureSprite\nclass in Chapter 17.\ndef jump(self, evt):\nif self.y == 0:\nself.y = -4\nself.jump_count = 0\ndef animate(self):\nu if self.x != 0 and self.y == 0:\nv if time.time() - self.last_time > 0.1:\n260 Chapter 18\nw self.last_time = time.time()\nx self.current_image += self.current_image_add\ny if self.current_image >= 2:\nz self.current_image_add = -1\n{ if self.current_image <= 0:\n| self.current_image_add = 1\nIn the if statement at u, we check to see if x is not 0 in order\nto determine whether the stick figure is moving (either left or right),\nand we check to see if y is 0 in order to determine that the stick\nfigure is not jumping. If this if statement is true, we need to ani-\nmate our stick figure; if not, he’s standing still, so there’s no need\nto keep drawing. If the stick figure isn’t moving, we drop out of the\nfunction, and the rest of the code in this listing is ignored.\nAt v, we calculate the amount of time since the animate\nfunction was last called, by subtracting the value of the last_time\nvariable from the current time, using time.time(). This calculation\nis used to decide whether to draw the next image in the sequence,\nand if the result is greater than a tenth of a second (0.1), we con-\ntinue with the block of code at w. We set the last_time variable to\nthe current time, basically resetting the stopwatch to start timing\nagain for the next change of image.\nAt x, we add the value of the object variable current_image_add\nto the variable current_image, which stores the index position of\nthe currently displayed image. Remember that we created the\ncurrent_image_add variable in the stick figure’s __init__ function in\nChapter 17, so when the animate function is first called, the value\nof the variable has already been set to 1.\nAt y, we check to see if the value of the index position in\nc urrent_image is greater than or equal to 2, and if so, we change the\nvalue of current_image_add to –1 at z. The process is similar at {—\nonce we reach 0, we need to start counting up again, which we do\nat |.\nnote If you’re having trouble figuring out how to indent this code, here’s\na hint: There are 8 spaces at the beginning of u and 20 spaces at\nthe beginning of |.\nTo help you understand what’s going on in the function so far,\nimagine that you have a sequence of colored blocks in a line on the\nfloor. You move your finger from one block to the next, and each\nblock that your finger points to (1, 2, 3, 4, and so on) has a n umber\nCompleting the Mr. Stick Man Game 261\n(the current_image variable). The number of the block your finger\nmoves to (it points at one block at a time) is the number stored in\nthe variable current_image_add. When your finger moves one way\nup the line of blocks, you’re adding 1 each time, and when it hits\nthe end of the line and moves back down, you’re subtracting 1\n(that is, adding –1).\nThe code we’ve added to our animate function performs this\nprocess, but instead of colored blocks, we have the three stick fig-\nure images for each direction stored in a list. The index positions\nof these images are 0, 1, and 2. As we animate the stick figure,\nonce we reach the last image, we start counting down, and once\nwe reach the first image, we need to start counting up again. As a\nresult, we create the effect of a running figure.\nThe following shows how we move through the list of images,\nusing the index positions we calculate in the animate function.\nPosition 0 Position 1 Position 2 Position 1 Position 0 Position 1\nCounting up Counting up Counting up Counting Counting Counting up\ndown down\nChanging the Image\nIn the next half of the animate function, we change the currently\ndisplayed image, using the calculated index position.\ndef animate(self):\nif self.x != 0 and self.y == 0:\nif time.time() - self.last_time > 0.1:\nself.last_time= time.time()\nself.current_image += self.current_image_add\nif self.current_image >= 2:\nself.current_image_add = -1\nif self.current_image <= 0:\nself.current_image_add = 1\nu if self.x < 0:\nv if self.y != 0:\nw self.game.canvas.itemconfig(self.image, \\\nimage=self.images_left[2])\nx else:\ny self.game.canvas.itemconfig(self.image, \\\nimage=self.images_left[self.current_image])\n262 Chapter 18\nz elif self.x > 0:\n{ if self.y != 0:\n| self.game.canvas.itemconfig(self.image, \\\nimage=self.images_right[2])\n} else:\n~ self.game.canvas.itemconfig(self.image, \\\nimage=self.images_right[self.current_image])\nAt u, if x is less than 0, the stick figure is moving left, so\nPython moves into the block of code shown at v through y, which\nchecks whether y is not equal to 0 (meaning the stick figure is\njumping). If y is not equal to 0 (the stick figure is moving up or\ndown—in other words, jumping), we use the canvas’s itemconfig\nfunction to change the displayed image to the last image in our list\nof left-facing images at w (images_left[2]). Because the stick figure\nis jumping, we’ll use the image showing him in full stride to make\nthe animation look a bit more realistic:\nIf the stick figure is not jumping (that is, y is equal to 0), the\nelse statement starting at x uses itemconfig to change the displayed\nimage to whatever index position is in the variable current_image,\nas shown in the code at y.\nAt z, we see if the stick figure is running right (x is greater\nthan 0), and Python moves into the block shown at { through ~.\nThis code is very similar to the first block, again checking whether\nthe stick figure is jumping, and drawing the correct image if so,\nexcept that it uses the images_right list.\nGetting the stick figure’s Position\nBecause we’ll need to determine where the stick figure is on the\nscreen (since he is moving around), the coords function will differ\nfrom the other Sprite class functions. We’ll use the coords function\nof the canvas to determine where the stick figure is, and then use\nthose values to set the x1, y1 and x2, y2 values of the coordinates\nCompleting the Mr. Stick Man Game 263\nvariable we created in the __init__ function at the beginning of\nChapter 17. Here’s the code, which can be added after the animate\nfunction:\nif self.x < 0:\nif self.y != 0:\nself.game.canvas.itemconfig(self.image, \\\nimage=self.images_left[2])\nelse:\nself.game.canvas.itemconfig(self.image, \\\nimage=self.images_left[self.current_image])\nelif self.x > 0:\nif self.y != 0:\nself.game.canvas.itemconfig(self.image, \\\nimage=self.images_right[2])\nelse:\nself.game.canvas.itemconfig(self.image, \\\nimage=self.images_right[self.current_image])\ndef coords(self):\nu xy = self.game.canvas.coords(self.image)\nv self.coordinates.x1 = xy[0]\nw self.coordinates.y1 = xy[1]\nx self.coordinates.x2 = xy[0] + 27\ny self.coordinates.y2 = xy[1] + 30\nreturn self.coordinates\nWhen we created the Game class in Chapter 16, one of the object\nvariables was the canvas. At u, we use the coords function of this\ncanvas variable, with self.game.canvas.coords, to return the x and\ny positions of the current image. This function uses the number\nstored in the object variable image, the identifier for the image\ndrawn on the canvas.\nWe store the resulting list in the variable xy, which now con-\ntains two values: the top-left x position stored as the x1 variable of\ncoordinates at v, and the top-left y position stored as the y1 variable\nof coordinates at w.\nBecause all of the stick figure images we created are 27 pixels\nwide by 30 pixels high, we can determine what the x2 and y2 vari-\nables should be by adding the width at x and the height at y to\nthe x and y numbers, respectively.\nFinally, on the last line of the function, we return the object\nvariable coordinates.\n264 Chapter 18\nMaking the stick figure Move\nThe final function of the StickFigureSprite class, move, is in charge\nof actually moving our game character around the screen. It also\nneeds to be able to tell us when the character has bumped into\nsomething.\nstarting the move function\nHere’s the code for the first part of the move function—this will go\nafter coords:\ndef coords(self):\nxy = self.game.canvas.coords(self.image)\nself.coordinates.x1 = xy[0]\nself.coordinates.y1 = xy[1]\nself.coordinates.x2 = xy[0] + 27\nself.coordinates.y2 = xy[1] + 30\nreturn self.coordinates\ndef move(self):\nu self.animate()\nv if self.y < 0:\nw self.jump_count += 1\nx if self.jump_count > 20:\ny self.y = 4\nz if self.y > 0:\n{ self.jump_count -= 1\nAt u, this part of the function calls the animate function we cre-\nated earlier in this chapter, which changes the currently displayed\nimage if necessary. At v, we see whether the value of y is less than\n0. If it is, we know that the stick figure is jumping because a nega-\ntive value will move him up the screen. (Remember that 0 is at the\ntop of the canvas, and the bottom of the canvas is pixel position\n500.)\nAt w, we add 1 to jump_count, and at x, we say that if the value\nof jump_count reaches 20, we should change y to 4 to start the stick\nfigure falling again (y).\nAt z, we see if the value of y is greater than 0 (meaning the\ncharacter must be falling), and if it is, we subtract 1 from jump_count\nbecause once we’ve counted up to 20, we need to count back down\nagain. (Move your hand slowly up in the air while counting to 20,\nCompleting the Mr. Stick Man Game 265\nthen move it back down again while counting down from 20, and\nyou’ll get a sense of how calculating the stick figure jumping up\nand down is supposed to work.)\nIn the next few lines of the move function, we call the coords\nfunction, which tells us where our character is on the screen and\nstores its result in the variable co. We then create the variables\nleft, right, top, bottom, and falling. We’ll use each in the remainder\nof this function.\nif self.y > 0:\nself.jump_count -= 1\nco = self.coords()\nleft = True\nright = True\ntop = True\nbottom = True\nfalling = True\nNotice that each variable has been set to the Boolean value\nTrue. We’ll use these as indicators to check whether the character\nhas hit something on the screen or is falling.\nHas the stick figure Hit the Bottom or top of\nthe Canvas?\nThe next section of the move function checks whether our character\nhas hit the bottom or top of the canvas. Here’s the code:\nbottom = True\nfalling = True\nu if self.y > 0 and co.y2 >= self.game.canvas_height:\nv self.y = 0\nw bottom = False\n266 Chapter 18\nx elif self.y < 0 and co.y1 <= 0:\ny self.y = 0\nz top = False\nIf the character is falling down the screen, y will be greater\nthan 0, so we need to make sure it hasn’t yet hit the bottom of the\ncanvas (or it will vanish off the bottom of the screen). To do so, at u,\nwe see if its y2 position (the bottom of the stick figure) is greater than\nor equal to the canvas_height variable of the game object. If it is, we set\nthe value of y to 0 at v to stop the stick figure from falling, and then\nset the bottom variable to False at w, which tells the remaining code\nthat we no longer need to see if the stick figure has hit the bottom.\nThe process of determining whether the stick figure has hit the\ntop of the screen is very similar to the way we determine whether\nhe has hit the bottom. To do so, at x, we first see if the stick figure\nis jumping (y is less than 0), then we see if his y1 position is less\nthan or equal to 0, meaning he has hit the top of the canvas. If\nboth conditions are true, we set y equal to 0 at y to stop the move-\nment. We also set the top variable to True at z to tell the remaining\ncode that we no longer need to see if the stick figure has hit the top.\nHas the stick figure Hit the side of the Canvas?\nWe follow almost exactly the same process as in the preceding code\nto determine whether the stick figure has hit the left and right\nsides of the canvas, as follows:\nelif self.y < 0 and co.y1 <= 0:\nself.y = 0\ntop = False\nu if self.x > 0 and co.x2 >= self.game.canvas_width:\nv self.x = 0\nw right = False\nx elif self.x < 0 and co.x1 <= 0:\ny self.x = 0\nz left = False\nThe code at u is based on the fact that we know the stick fig-\nure is running to the right if x is greater than 0. We also know\nwhether he has hit the right-hand side of the screen by seeing if\nthe x2 pos ition (co.x2) is greater than or equal to the width of the\ncanvas stored in game_width. If both statements are true, we set x\nequal to 0 (to stop the stick figure from running), and we set the\nright variable to False at w.\nCompleting the Mr. Stick Man Game 267\nColliding with other sprites\nOnce we’ve determined whether the figure has hit the sides of the\nscreen, we need to see if he has hit anything else on the screen.\nWe use the following code to loop through the list of sprite objects\nstored in the game object to see if the stick figure has hit any of them.\nelif self.x < 0 and co.x1 <= 0:\nself.x = 0\nleft = False\nu for sprite in self.game.sprites:\nv if sprite == self:\nw continue\nx sprite_co = sprite.coords()\ny if top and self.y < 0 and collided_top(co, sprite_co):\nz self.y = -self.y\n{ top = False\nAt u, we loop through the list of sprites, assigning each one in\nturn to the variable sprite. At v, we say that if the sprite is equal\nto self (that’s another way of saying, “if this sprite is the same as\nme”), we don’t need to determine whether the stick figure has col-\nlided because he would have only hit himself. If the sprite variable\nis equal to self, we use continue to jump to the next sprite in the list.\nNext, we get the coordinates of the new sprite by calling its\ncoords function at x and storing the results in the variable sprite_co.\nThen the code at y checks for the following:\n• The stick figure has not hit the top of the canvas (the top vari-\nable is still true).\n• The stick figure is jumping (the value of y is less than 0).\n• The top of the stick figure has collided with the sprite from the\nlist (using the collided_top function we created in Chapter 16).\n268 Chapter 18\nIf all of these conditions are true, we want the sprite to start\nfalling back down again, so at z, we reverse the value of the y using\nminus (-). The top variable is set to False at {, because once the\nstick figure has hit the top, we don’t need to keep checking for a\ncollision.\nColliding at the Bottom\nThe next part of the loop checks to see if the bottom of our charac-\nter has hit something:\nif top and self.y < 0 and collided_top(co, sprite_co):\nself.y = -self.y\ntop = False\nu if bottom and self.y > 0 and collided_bottom(self.y, \\\nco, sprite_co):\nv self.y = sprite_co.y1 - co.y2\nw if self.y < 0:\nx self.y = 0\ny bottom = False\nz top = False\nThere are three similar checks at u: whether the bottom variable\nis still set, whether the character is falling (y is greater than 0), and\nwhether the bottom of our character has hit the sprite. If all three\nchecks are true, we subtract the bottom y value (y2) of the stick fig-\nure from the top y value of the sprite (y1) at v. This might seem\nstrange, so let’s see why we do this.\nImagine that our game character has fallen off a platform. He\nmoves down the screen 4 pixels each time the mainloop function runs,\nand the foot of the stick figure is 3 pixels above another platform.\nLet’s say the stick figure’s bottom (y2) is at position 57 and the top\nof the platform (y1) is at position 60. In this case, the collided_bottom\nfunction would return true, because its code will add the value of y\n(which is 4) to the stick figure’s y2 variable, resulting in 61.\nHowever, we don’t want Mr. Stick Man to stop falling as soon\nas it looks like he will hit a platform or the bottom of the screen,\nbecause that would be like taking a huge jump off a step and stop-\nping in midair, an inch above the ground. That may be a neat\ntrick, but it won’t look right in our game. Instead, if we subtract\nthe character’s y2 value (of 57) from the platform’s y1 value (of 60)\nwe get 3, the amount the stick figure should drop in order to land\nproperly on the top of the platform.\nCompleting the Mr. Stick Man Game 269\nAt w, we make sure that the calculation doesn’t result in a\nnegative number; if it does, we set y equal to 0 at x. (If we let the\nnumber be negative, the stick figure would fly back up again, and\nwe don’t want that to happen in this game.)\nFinally, we set the top z and bottom y flags to False, so we no\nlonger need to check whether the stick figure has collided at the\ntop or bottom with another sprite.\nWe’ll do one more bottom check to see whether the stick fig-\nure has run off the edge of a platform. Here’s the code for this if\nstatement:\nif self.y < 0:\nself.y = 0\nbottom = False\ntop = False\nif bottom and falling and self.y == 0 \\\nand co.y2 < self.game.canvas_height \\\nand collided_bottom(1, co, sprite_co):\nfalling = False\nFive checks here must all be true in order for the falling vari-\nable to be set to False:\n• We still need to check that the bottom flag is set to True.\n• We need to check whether the stick figure should be falling\n(the falling flag is still set to True).\n• The stick figure isn’t already falling (y is 0).\n• The bottom of the sprite hasn’t hit the bottom of the screen\n(it’s less than the canvas height).\n• The stick figure has hit the top of a platform (collided_bottom\nreturns True).\nThen we set the falling variable to False.\nChecking Left and Right\nWe’ve checked whether the stick figure has hit a sprite at the bot-\ntom or the top. Now we need to check whether he has hit the left or\nright side, with this code:\nif bottom and falling and self.y == 0 \\\nand co.y2 < self.game.canvas_height \\\nand collided_bottom(1, co, sprite_co):\nfalling = False\n270 Chapter 18\nu if left and self.x < 0 and collided_left(co, sprite_co):\nv self.x = 0\nw left = False\nx if right and self.x > 0 and collided_right(co, sprite_co):\ny self.x = 0\nz right = False\nAt u, we see if we should\nstill be looking for collisions to\nthe left (left is still set to True)\nand whether the stick figure\nis moving to the left (x is less\nthan 0). We also check to see\nif the stick figure has col-\nlided with a sprite using the\ncollided_left function. If these three conditions are true, we set x\nequal to 0 at v (to make the stick figure stop running), and set left\nto False at w, so that we no longer check for collisions on the left.\nThe code is similar for collisions to the right, as shown at x.\nWe set x equal to 0 again at y, and right to False at z, to stop\nchecking for right-hand collisions.\nNow, with checks for collisions in all four directions, our for\nloop should look like this:\nelif self.x < 0 and co.x1 <= 0:\nself.x = 0\nleft = False\nfor sprite in self.game.sprites:\nif sprite == self:\ncontinue\nsprite_co = sprite.coords()\nif top and self.y < 0 and collided_top(co, sprite_co):\nself.y = -self.y\ntop = False\nif bottom and self.y > 0 and collided_bottom(self.y, \\\nco, sprite_co):\nself.y = sprite_co.y1 - co.y2\nif self.y < 0:\nself.y = 0\nbottom = False\ntop = False\nif bottom and falling and self.y == 0 \\\nand co.y2 < self.game.canvas_height \\\nand collided_bottom(1, co, sprite_co):\nfalling = False\nCompleting the Mr. Stick Man Game 271\nif left and self.x < 0 and collided_left(co, sprite_co):\nself.x = 0\nleft = False\nif right and self.x > 0 and collided_right(co, sprite_co):\nself.x = 0\nright = False\nWe need to add only a few more lines to the move function, as\nfollows:\nif right and self.x > 0 and collided_right(co, sprite_co):\nself.x = 0\nright = False\nu if falling and bottom and self.y == 0 \\\nand co.y2 < self.game.canvas_height:\nv self.y = 4\nw self.game.canvas.move(self.image, self.x, self.y)\nAt u, we check whether both the falling and bottom variables\nare set to True. If so, we’ve looped through every platform sprite in\nthe list without colliding at the bottom.\nThe final check in this line determines whether the bottom of\nour character is less than the canvas height—that is, above the\nground (the bottom of the canvas). If the stick figure hasn’t collided\nwith anything and he is above the ground, he is standing in mid-\nair, so he should start falling (in other words, he has run off the\nend of a platform). To make him run off the end of any platform,\nwe set y equal to 4 at v.\nAt w, we move the image across the screen, according to the\nvalues we set in the variables x and y. The fact that we’ve looped\nthrough the sprites checking for collisions may mean that we’ve set\nboth variables to 0, because the stick figure has collided on the left\nand with the bottom. In that case, the call to the move function of\nthe canvas will do nothing.\nIt may also be the case that Mr. Stick Man has walked off the\nedge of a platform. If that happens, y will be set to 4, and Mr. Stick\nMan will fall downward.\nPhew, that was a long function!\n272 Chapter 18\ntesting our stick figure sprite\nHaving created the StickFigureSprite class, let’s try it out by adding\nthe following two lines just before the call to the mainloop function.\nu sf = StickFigureSprite(g)\nv g.sprites.append(sf)\ng.mainloop()\nAt u, we create a StickFigureSprite object and set it equal to the\nvariable sf. As we did with the platforms, we add this new variable\nto the list of sprites stored in the game object at v.\nNow run the program. You will find that Mr. Stick Man can\nrun, jump from platform to platform, and fall!\nthe Door!\nThe only thing missing from our game is the door to the exit. We’ll\nfinish up by creating a sprite for the door, adding code to detect the\ndoor, and giving our program a door object.\nCompleting the Mr. Stick Man Game 273\nCreating the Doorsprite Class\nYou guessed it—we need to create one more class: DoorSprite.\nHere’s the start of the code:\nclass DoorSprite(Sprite):\nu def __init__(self, game, photo_image, x, y, width, height):\nv Sprite.__init__(self, game)\nw self.photo_image = photo_image\nx self.image = game.canvas.create_image(x, y, \\\nimage=self.photo_image, anchor='nw')\ny self.coordinates = Coords(x, y, x + (width / 2), y + height)\nz self.endgame = True\nAs shown at u, the __init__ function of\nthe DoorSprite class has parameters for self,\na game object, a photo_image object, the x and y\ncoordinates, and the width and height of the\nimage. At v, we call __init__ as with our\nother sprite classes.\nAt w, we save the parameter photo_image\nusing an object variable with the same name,\nas we did with PlatformSprite. We create a\ndisplay image using the canvas create_image function and save the\nidentifying number returned by that function using the object vari-\nable image at x.\nAt y, we set the coordinates of DoorSprite to the x and y param-\neters (which become the x1 and y1 positions of the door), and then\ncalculate the x2 and y2 positions. We calculate the x2 position by\nadding half of the width (the width variable, divided by 2) to the x\nparameter. For example, if x is 10 (the x1 coordinate is also 10), and\nthe width is 40, the x2 coordinate would be 30 (10 plus half of 40).\nWhy use this confusing little calculation? Because, unlike with\nthe platforms, where we want Mr. Stick Man to stop running as\nsoon as he collides with the side of the platform, we want him to\nstop in front of the door. (It won’t look good if Mr. Stick Man stops\nrunning next to the door!) You’ll see this in action when you play\nthe game and make it to the door.\nUnlike the x1 position, the y1 position is simple to calculate.\nWe just add the value of the height variable to the y parameter, and\nthat’s it.\nFinally, at z, we set the endgame object variable to True. This says\nthat when the stick figure reaches the door, the game should end.\n274 Chapter 18\nDetecting the Door\nNow we need to change the code in the StickFigureSprite class of\nthe move function that determines when the stick figure has col-\nlided with a sprite on the left or the right. Here’s the first change:\nif left and self.x < 0 and collided_left(co, sprite_co):\nself.x = 0\nleft = False\nif sprite.endgame:\nself.game.running = False\nWe check to see if the sprite that the stick figure has collided\nwith has an endgame variable that is set to True. If it does, we set the\nrunning variable to False, and everything stops—we’ve reached the\nend of the game.\nWe’ll add these same lines to the code that checks for a colli-\nsion on the right. Here’s the code:\nif right and self.x > 0 and collided_right(co, sprite_co):\nself.x = 0\nright = False\nif sprite.endgame:\nself.game.running = False\nAdding the Door object\nOur final addition to the game code is an object for the door. We’ll\nadd this before the main loop. Just before creating the stick fig-\nure object, we’ll create a door object, and then add it to the list of\nsprites. Here’s the code:\ng.sprites.append(platform7)\ng.sprites.append(platform8)\ng.sprites.append(platform9)\ng.sprites.append(platform10)\ndoor = DoorSprite(g, PhotoImage(file=\"door1.gif\"), 45, 30, 40, 35)\ng.sprites.append(door)\nsf = StickFigureSprite(g)\ng.sprites.append(sf)\ng.mainloop()\nWe create a door object using the variable for our game object, g,\nfollowed by a PhotoImage (the door image we created in Chapter 15).\nWe set the x and y parameters to 45 and 30 to put the door on a\nCompleting the Mr. Stick Man Game 275\nplatform near the top of the screen, and set the width and height to\n40 and 35. We add the door object to the list of sprites, as with all\nthe other sprites in the game.\nYou can see the result when Mr. Stick Man reaches the door.\nHe stops running in front of the door, rather than next to it, as\nshown here:\nthe final Game\nThe full listing of our game is now a bit more than 200 lines of\ncode. The following is the complete code for the game. If you have\ntrouble getting your game to work, compare each function (and\neach class) to this listing and see where you’ve gone wrong.\nfrom tkinter import *\nimport random\nimport time\nclass Game:\ndef __init__(self):\nself.tk = Tk()\nself.tk.title(\"Mr. Stick Man Races for the Exit\")\nself.tk.resizable(0, 0)\n276 Chapter 18\nself.tk.wm_attributes(\"-topmost\", 1)\nself.canvas = Canvas(self.tk, width=500, height=500, \\\nhighlightthickness=0)\nself.canvas.pack()\nself.tk.update()\nself.canvas_height = 500\nself.canvas_width = 500\nself.bg = PhotoImage(file=\"background.gif\")\nw = self.bg.width()\nh = self.bg.height()\nfor x in range(0, 5):\nfor y in range(0, 5):\nself.canvas.create_image(x * w, y * h, \\\nimage=self.bg, anchor='nw')\nself.sprites = []\nself.running = True\ndef mainloop(self):\nwhile 1:\nif self.running == True:\nfor sprite in self.sprites:\nsprite.move()\nself.tk.update_idletasks()\nself.tk.update()\ntime.sleep(0.01)\nclass Coords:\ndef __init__(self, x1=0, y1=0, x2=0, y2=0):\nself.x1 = x1\nself.y1 = y1\nself.x2 = x2\nself.y2 = y2\ndef within_x(co1, co2):\nif (co1.x1 > co2.x1 and co1.x1 < co2.x2) \\\nor (co1.x2 > co2.x1 and co1.x2 < co2.x2) \\\nor (co2.x1 > co1.x1 and co2.x1 < co1.x2) \\\nor (co2.x2 > co1.x1 and co2.x2 < co1.x1):\nreturn True\nelse:\nreturn False\ndef within_y(co1, co2):\nif (co1.y1 > co2.y1 and co1.y1 < co2.y2) \\\nor (co1.y2 > co2.y1 and co1.y2 < co2.y2) \\\nor (co2.y1 > co1.y1 and co2.y1 < co1.y2) \\\nor (co2.y2 > co1.y1 and co2.y2 < co1.y1):\nreturn True\nCompleting the Mr. Stick Man Game 277\nelse:\nreturn False\ndef collided_left(co1, co2):\nif within_y(co1, co2):\nif co1.x1 <= co2.x2 and co1.x1 >= co2.x1:\nreturn True\nreturn False\ndef collided_right(co1, co2):\nif within_y(co1, co2):\nif co1.x2 >= co2.x1 and co1.x2 <= co2.x2:\nreturn True\nreturn False\ndef collided_top(co1, co2):\nif within_x(co1, co2):\nif co1.y1 <= co2.y2 and co1.y1 >= co2.y1:\nreturn True\nreturn False\ndef collided_bottom(y, co1, co2):\nif within_x(co1, co2):\ny_calc = co1.y2 + y\nif y_calc >= co2.y1 and y_calc <= co2.y2:\nreturn True\nreturn False\nclass Sprite:\ndef __init__(self, game):\nself.game = game\nself.endgame = False\nself.coordinates = None\ndef move(self):\npass\ndef coords(self):\nreturn self.coordinates\nclass PlatformSprite(Sprite):\ndef __init__(self, game, photo_image, x, y, width, height):\nSprite.__init__(self, game)\nself.photo_image = photo_image\nself.image = game.canvas.create_image(x, y, \\\nimage=self.photo_image, anchor='nw')\nself.coordinates = Coords(x, y, x + width, y + height)\n278 Chapter 18\nclass StickFigureSprite(Sprite):\ndef __init__(self, game):\nSprite.__init__(self, game)\nself.images_left = [\nPhotoImage(file=\"figure-L1.gif\"),\nPhotoImage(file=\"figure-L2.gif\"),\nPhotoImage(file=\"figure-L3.gif\")\n]\nself.images_right = [\nPhotoImage(file=\"figure-R1.gif\"),\nPhotoImage(file=\"figure-R2.gif\"),\nPhotoImage(file=\"figure-R3.gif\")\n]\nself.image = game.canvas.create_image(200, 470, \\\nimage=self.images_left[0], anchor='nw')\nself.x = -2\nself.y = 0\nself.current_image = 0\nself.current_image_add = 1\nself.jump_count = 0\nself.last_time = time.time()\nself.coordinates = Coords()\ngame.canvas.bind_all('<KeyPress-Left>', self.turn_left)\ngame.canvas.bind_all('<KeyPress-Right>', self.turn_right)\ngame.canvas.bind_all('<space>', self.jump)\ndef turn_left(self, evt):\nif self.y == 0:\nself.x = -2\ndef turn_right(self, evt):\nif self.y == 0:\nself.x = 2\ndef jump(self, evt):\nif self.y == 0:\nself.y = -4\nself.jump_count = 0\ndef animate(self):\nif self.x != 0 and self.y == 0:\nif time.time() - self.last_time > 0.1:\nself.last_time= time.time()\nself.current_image += self.current_image_add\nCompleting the Mr. Stick Man Game 279\nif self.current_image >= 2:\nself.current_image_add = -1\nif self.current_image <= 0:\nself.current_image_add = 1\nif self.x < 0:\nif self.y != 0:\nself.game.canvas.itemconfig(self.image, \\\nimage=self.images_left[2])\nelse:\nself.game.canvas.itemconfig(self.image, \\\nimage=self.images_left[self.current_image])\nelif self.x > 0:\nif self.y != 0:\nself.game.canvas.itemconfig(self.image, \\\nimage=self.images_right[2])\nelse:\nself.game.canvas.itemconfig(self.image, \\\nimage=self.images_right[self.current_image])\ndef coords(self):\nxy = self.game.canvas.coords(self.image)\nself.coordinates.x1 = xy[0]\nself.coordinates.y1 = xy[1]\nself.coordinates.x2 = xy[0] + 27\nself.coordinates.y2 = xy[1] + 30\nreturn self.coordinates\ndef move(self):\nself.animate()\nif self.y < 0:\nself.jump_count += 1\nif self.jump_count > 20:\nself.y = 4\nif self.y > 0:\nself.jump_count -= 1\nco = self.coords()\nleft = True\nright = True\ntop = True\nbottom = True\nfalling = True\nif self.y > 0 and co.y2 >= self.game.canvas_height:\nself.y = 0\nbottom = False\nelif self.y < 0 and co.y1 <= 0:\nself.y = 0\ntop = False\n280 Chapter 18\nif self.x > 0 and co.x2 >= self.game.canvas_width:\nself.x = 0\nright = False\nelif self.x < 0 and co.x1 <= 0:\nself.x = 0\nleft = False\nfor sprite in self.game.sprites:\nif sprite == self:\ncontinue\nsprite_co = sprite.coords()\nif top and self.y < 0 and collided_top(co, sprite_co):\nself.y = -self.y\ntop = False\nif bottom and self.y > 0 and collided_bottom(self.y, \\\nco, sprite_co):\nself.y = sprite_co.y1 - co.y2\nif self.y < 0:\nself.y = 0\nbottom = False\ntop = False\nif bottom and falling and self.y == 0 \\\nand co.y2 < self.game.canvas_height \\\nand collided_bottom(1, co, sprite_co):\nfalling = False\nif left and self.x < 0 and collided_left(co, sprite_co):\nself.x = 0\nleft = False\nif sprite.endgame:\nself.game.running = False\nif right and self.x > 0 and collided_right(co, sprite_co):\nself.x = 0\nright = False\nif sprite.endgame:\nself.game.running = False\nif falling and bottom and self.y == 0 \\\nand co.y2 < self.game.canvas_height:\nself.y = 4\nself.game.canvas.move(self.image, self.x, self.y)\nclass DoorSprite(Sprite):\ndef __init__(self, game, photo_image, x, y, width, height):\nSprite.__init__(self, game)\nself.photo_image = photo_image\nself.image = game.canvas.create_image(x, y, \\\nimage=self.photo_image, anchor='nw')\nself.coordinates = Coords(x, y, x + (width / 2), y + height)\nself.endgame = True\nCompleting the Mr. Stick Man Game 281\ng = Game()\nplatform1 = PlatformSprite(g, PhotoImage(file=\"platform1.gif\"), \\\n0, 480, 100, 10)\nplatform2 = PlatformSprite(g, PhotoImage(file=\"platform1.gif\"), \\\n150, 440, 100, 10)\nplatform3 = PlatformSprite(g, PhotoImage(file=\"platform1.gif\"), \\\n300, 400, 100, 10)\nplatform4 = PlatformSprite(g, PhotoImage(file=\"platform1.gif\"), \\\n300, 160, 100, 10)\nplatform5 = PlatformSprite(g, PhotoImage(file=\"platform2.gif\"), \\\n175, 350, 66, 10)\nplatform6 = PlatformSprite(g, PhotoImage(file=\"platform2.gif\"), \\\n50, 300, 66, 10)\nplatform7 = PlatformSprite(g, PhotoImage(file=\"platform2.gif\"), \\\n170, 120, 66, 10)\nplatform8 = PlatformSprite(g, PhotoImage(file=\"platform2.gif\"), \\\n45, 60, 66, 10)\nplatform9 = PlatformSprite(g, PhotoImage(file=\"platform3.gif\"), \\\n170, 250, 32, 10)\nplatform10 = PlatformSprite(g, PhotoImage(file=\"platform3.gif\"), \\\n230, 200, 32, 10)\ng.sprites.append(platform1)\ng.sprites.append(platform2)\ng.sprites.append(platform3)\ng.sprites.append(platform4)\ng.sprites.append(platform5)\ng.sprites.append(platform6)\ng.sprites.append(platform7)\ng.sprites.append(platform8)\ng.sprites.append(platform9)\ng.sprites.append(platform10)\ndoor = DoorSprite(g, PhotoImage(file=\"door1.gif\"), 45, 30, 40, 35)\ng.sprites.append(door)\nsf = StickFigureSprite(g)\ng.sprites.append(sf)\ng.mainloop()\nWhat You Learned\nIn this chapter, we completed our game, Mr. Stick Man Races for\nthe Exit. We created a class for our animated stick figure and\nwrote functions to move him around the screen and animate him\nas he moves (changing from one image to the next to give the illu-\nsion of running). We’ve used basic collision detection to tell when\nhe has hit the left or right sides of the canvas, and when he has hit\n282 Chapter 18\nanother sprite, such as a platform or a\ndoor. We’ve also added collision code to\ntell when he hits the top of the screen\nor the bottom, and to make sure that\nwhen he runs off the edge of a plat-\nform, he tumbles down accordingly.\nWe added code to tell when Mr. Stick\nMan has reached the door, so the game\ncomes to an end.\nProgramming Puzzles\nThere’s a lot more we can do to improve the game. At the moment,\nit’s very simple, so we can add code to make it more professional\nlooking and more interesting to play. Try adding the f ollowing fea-\ntures and then check your code at http://python-for-kids.com/.\n#1: “You Win!”\nLike the “Game Over” text in the Bounce! game we completed in\nChapter 14, add the “You Win!” text when the stick figure reaches\nthe door, so players can see that they have won.\n#2: Animating the Door\nIn Chapter 15, we created two images\nfor the door: one open and one closed.\nWhen Mr. Stick Man reaches the door,\nthe door image should change to the\nopen door, Mr. Stick Man should vanish,\nand the door image should revert to the\nclosed door. This will give the illusion\nthat Mr. Stick Man is exiting and clos-\ning the door as he leaves. You can do this\nby changing the DoorSprite class and the\nStickFigureSprite class.\n#3: Moving Platforms\nTry adding a new class called MovingPlatformSprite. This plat-\nform should move from side to side, making it more difficult for\nMr. Stick Man to reach the door at the top.\nCompleting the Mr. Stick Man Game 283"
  },
  {
    "input": "What programming languages are commonly used as alternatives to Python for games and graphics programming?",
    "summary": "After learning basic Python programming, you'll find it easier to work with other languages. Python is useful but not always the best choice for every task, so exploring alternatives is encouraged. This section covers other programming languages commonly used for games and graphics.",
    "output": "Afterword\nWHeRe to Go fRoM HeRe\nYou’ve learned some basic programming concepts\nin your tour of Python, and now you’ll find it much\neasier to work with other programming languages.\nWhile Python is incredibly useful, one language is not\nalways the best tool for every task, so don’t be afraid to\ntry other ways to program your computer. Here, we’ll\nlook at some alternatives for games and graphics pro-\ngramming, and then take a peek at some of the most\ncommonly used programming languages."
  },
  {
    "input": "What are some programming tools and languages available for game and graphics development, and how does PyGame differ from tkinter in terms of its usage and functionality?",
    "summary": "The text discusses various tools for games and graphics programming, including BlitzBasic, Adobe Flash, Alice, Scratch, and Unity3D, as well as PyGame for Python. PyGame uses an off-screen buffer to reduce flickering and requires proper cleanup to shut down correctly. The example shows how to load and display an image using PyGame, which is more complex than using tkinter.",
    "output": "Games and Graphics Programming\nIf you want to do more with games or graphics programming,\nyou’ll find many options available. Here are just a few:\n• BlitzBasic (http://www.blitzbasic.com/), which uses a special\nversion of the BASIC programming language designed specifi-\ncally for games\n• Adobe Flash, a type of animation software designed to run in\nthe browser, which has its own programming language called\nActionScript (http://www.adobe.com/devnet/actionscript.html)\n• Alice (http://www.alice.org/), a 3D programming environment\n(for Microsoft Windows and Mac OS X only)\n• Scratch (http://scratch.mit.edu/), a tool for developing games\n• Unity3D (http://unity3d.com/), another tool for creating games\nAn online search will uncover a wealth of resources to help\nyou get started with any of these options.\nOn the other hand, if you would like to continue playing with\nPython, you could use PyGame, the Python module designed for\ngame development. Let’s explore that option.\nPyGame\nPyGame Reloaded (pgreloaded or pygame2) is the version of PyGame\nthat works with Python 3 (earlier versions work only with Python 2).\nA good place to start reading is the pgreloaded tutorial at http://\ncode.google.com/p/pgreloaded/.\nnote As of this writing, there is no installer for pgreloaded on Mac OS X\nor Linux, so there is no straightforward way to use it on either of\nthese operating systems.\nWriting a game with PyGame is a little more complicated\nthan using tkinter. For example, in Chapter 12, we displayed an\nimage using tkinter with this code:\nfrom tkinter import *\ntk = Tk()\ncanvas = Canvas(tk, width=400, height=400)\ncanvas.pack()\nmyimage = PhotoImage(file='c:\\\\test.gif')\ncanvas.create_image(0, 0, anchor=NW, image=myimage)\n286 Afterword\nThe same code using PyGame (loading a .bmp file rather than\na .gif file) would look like this:\nimport sys\nimport time\nimport pygame2\nimport pygame2.sdl.constants as constants\nimport pygame2.sdl.image as image\nimport pygame2.sdl.video as video\nu video.init()\nv img = image.load_bmp(\"c:\\\\test.bmp\")\nw screen = video.set_mode(img.width, img.height)\nx screen.fill(pygame2.Color(255, 255, 255))\ny screen.blit(img, (0, 0))\nz screen.flip()\n{ time.sleep(10)\n| video.quit()\nAfter importing the pygame2 modules, we call the init func-\ntion on the PyGame video module at u, which is a bit like the call\nto create the canvas and then pack it in the tkinter example. We\nload a BMP image using the load_bmp function at v, and then cre-\nate a screen object using the set_mode function, passing in the width\nand height of the loaded image as parameters at w. With the next\n(optional) line, we wipe the screen by filling it with white at x,\nand then use the blit function of the screen object to display the\nimage at y. The parameters for this function are the img object and\na tuple containing the position where we want to display the image\n(0 pixels across, 0 pixels down).\nPyGame uses an off-screen buffer (also known as a double-\nbuffer). An off-screen buffer is a technique used to draw graphics\nin an area of the computer’s memory where it isn’t visible, and then\nto copy that entire area into the visible display (onto your screen)\nall at once. Off-screen buffering reduces the flickering effect if you\nhappen to be drawing a lot of different objects on a display. Copy-\ning from the off-screen buffer to the visible display is performed\nusing the flip function at z.\nFinally, we sleep for 10 seconds at { because, unlike tkinter’s\ncanvas, the screen will immediately close if we don’t stop it from\ndoing so. At |, we clean up using video.init so that PyGame will\nshut down properly. There’s a lot more to PyGame, but this short\nexample gives you an idea of what it’s like.\nWhere to Go from Here 287"
  },
  {
    "input": "",
    "summary": "This text introduces several popular programming languages, including Java, C/C++, C#, PHP, Objective-C, Perl, Ruby, and JavaScript, and provides examples of how to write a \"Hello World\" program in each. It also explains that while these languages are not specifically designed for beginners, they are widely used in various applications such as mobile development, web programming, and game development. The text highlights the differences between these languages and Python, and mentions that understanding these concepts can be beneficial even if one does not continue with programming.",
    "output": "Programming Languages\nIf you’re interested in other programming languages, some that\nare currently popular are Java, C/C++, C#, PHP, Objective-C, Perl,\nRuby, and JavaScript. We’ll take a brief tour of these languages\nand see how a Hello World program (like the Python version we\nstarted with in Chapter 1) would look in each one. Note that none\nof these languages are specifically intended for beginning pro-\ngrammers, and most are significantly different from Python.\nJava\nJava (http://www.oracle.com/technetwork/java/index.html) is a\nmoderately complicated programming language with a large built-\nin library of modules (called packages). A lot of free documentation\nis available online. You can use Java on most operating systems.\nJava is also the language used on Android mobile phones.\nHere’s an example of Hello World in Java:\npublic class HelloWorld {\npublic static final void main(String[] args) {\nSystem.out.println(\"Hello World\");\n}\n}\nC/C++\nC (http://www.cprogramming.com/) and C++ (http://www\n.stroustrup/C++.html) are complicated programming languages\nthat are used on all operating systems. You’ll find both free and\ncommercial versions available. Both languages (though perhaps\nC++ more than C) have a steep learning curve. For example, you’ll\nfind that you need to manually code some features that Python pro-\nvides (like telling the computer that you need to use a chunk of\nmemory to store an object). Many commercial games and game\nconsoles are programmed in some form of C or C++.\nHere’s an example of Hello World in C:\n#include <stdio.h>\nint main ()\n{\nprintf (\"Hello World\\n\");\n}\n288 Afterword\nAn example in C++ might look like this:\n#include <iostream>\nint main()\n{\nstd::cout << \"Hello World\\n\";\nreturn 0;\n}\nC#\nC# (http://msdn.microsoft.com/en-us/vstudio/hh388566/), pro-\nnounced “C sharp,” is a moderately complicated programming\nlanguage for Windows that is very similar to Java. It’s a bit easier\nthan C and C++.\nHere’s an example of Hello World in C#:\npublic class Hello\n{\npublic static void Main()\n{\nSystem.Console.WriteLine(\"Hello World\");\n}\n}\nPHP\nPHP (http://www.php.net/) is a programming language for\nbuilding websites. You will need a web server (software used to\ndeliver web pages to a web browser) with PHP installed, but all\nthe software required is freely available for all the major operating\nsystems. In order to work with PHP, you will need to learn HTML\n(a simple language for building web pages). You can find a free\nPHP tutorial at http://php.net/manual/en/tutorial.php, and an\nHTML tutorial at http://www.w3schools.com/html.\nAn HTML page that displays “Hello World” in a browser might\nlook like this:\n<html>\n<body>\n<p>Hello World</p>\n</body>\n</html>\nWhere to Go from Here 289\nA PHP page to do the same thing might look like this:\n<?php\necho \"Hello World\\n\";\n?>\nobjective-C\nObjective-C (http://classroomm.com/objective-c/) is very similar to\nC (in fact, it’s an extension of the C programming language) and\nmost commonly used on Apple computers. It’s the programming\nlanguage for the iPhone and iPad.\nHere’s an example of Hello World in Objective-C:\n#import <Foundation/Foundation.h>\nint main (int argc, const char * argv[]) {\nNSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];\nNSLog (@\"Hello World\");\n[pool drain];\nreturn 0;\n}\nPerl\nThe Perl programming language (http://www.perl.org/) is avail-\nable for free for all major operating systems. It’s usually used for\ndeveloping websites (similar to PHP).\nHere’s an example of Hello World in Perl:\nprint(\"Hello World\\n\");\nRuby\nRuby (http://www.ruby-lang.org/) is a free programming language\navailable on all major operating systems. It’s mostly used for creat-\ning websites, specifically using the framework Ruby on Rails. (A\nframework is a set of libraries supporting the development of spe-\ncific types of applications.)\nHere’s an example of Hello World in Ruby:\nputs \"Hello World\"\n290 Afterword\nJavascript\nJavaScript (https://developer.mozilla.org/en/javascript/) is a pro-\ngramming language that is usually used inside web pages but is\nincreasingly being used for game programming. The syntax is basi-\ncally similar to Java, but perhaps it’s a little easier to get started\nwith JavaScript. (You can create a simple HTML page that con-\ntains a JavaScript program and run it inside a browser without\nneeding a shell, command line, or anything else.) A good place to\nstart learning JavaScript might be Codecademy at http://www\n.codecademy.com/.\nA “Hello World” example in JavaScript will be different depend-\ning on whether you run it in a browser or in a shell. In a shell, the\nexample looks like this:\nprint('Hello World');\nIn a browser, it might look like this:\n<html>\n<body>\n<script type=\"text/javascript\">\nalert(\"Hello World\");\n</script>\n</body>\n</html>\nfInal Words\nWhether you stick with Python or decide to try out another pro-\ngramming language (and there are many more than those listed\nhere), you should still find the concepts that you’ve discovered in\nthis book useful. Even if you don’t continue with computer pro-\ngramming, understanding some of the fundamental ideas can help\nwith all sorts of activities, whether in school or later on, at work.\nGood luck and have fun with your programming!\nWhere to Go from Here 291\nAppendix\nPYtHon KeYWoRDs\nKeywords in Python (and in most programming lan-\nguages) are words that have special meaning. They\nare used as part of the programming language itself,\nand therefore must not be used for anything else. For\nexample, if you try to use keywords as variables, or\nuse them in the wrong way, you will get strange (some-\ntimes funny, sometimes confusing) error messages\nfrom the Python console.\nThis appendix describes each of the Python key-\nwords. You should find this to be a handy reference as\nyou continue to program.\nand\nThe keyword and is used to join two expressions together in a state-\nment (like an if statement) to say that both expressions must be\ntrue. Here’s an example:\nif age > 10 and age < 20:\nprint('Beware the teenager!!!!')\nThis code means that the value of the variable age must be\ngreater than 10 and less than 20 before the message will be printed.\nas\nThe keyword as can be used to give another name to an imported\nmodule. For example, suppose you had a module with a very\nlong name:\ni_am_a_python_module_that_is_not_very_useful\nIt would be enormously annoying to need to type this module\nname every time you wanted to use it:\nimport i_am_a_python_module_that_is_not_very_useful\ni_am_a_python_module_that_is_not_very_useful.do_something()\nI have done something that is not useful.\ni_am_a_python_module_that_is_not_very_useful.do_something_else()\nI have done something else that is not useful!!\nInstead, you can give the module a new, shorter name when\nyou import it, and then simply use that new name (a bit like a\nnickname), as follows:\nimport i_am_a_python_module_that_is_not_very_useful as notuseful\nnotuseful.do_something()\nI have done something that is not useful.\nnotuseful.do_something_else()\nI have done something else that is not useful!!\nassert\nassert is a keyword used to say that some code must be true. It’s\nanother way of catching errors and problems in code, usually in\n294 Appendix\nmore advanced programs (which is why we don’t use assert in this\nbook). Here’s a simple assert statement:\n>>> mynumber = 10\n>>> assert mynumber < 5\nTraceback (most recent call last):\nFile \"<pyshell#1>\", line 1, in <module>\nassert a < 5\nAssertionError\nIn this example, we assert that the value of the variable\nm ynumber is less than 5. It isn’t, and so Python displays an error\n(called an AssertionError).\nbreak\nThe break keyword is used to stop some code from running. You\nmight use a break inside a for loop, like this:\nage = 10\nfor x in range(1, 100):\nprint('counting %s' % x)\nif x == age:\nprint('end counting')\nbreak\nSince the variable age is set to 10 here, this code will print out\nthe following:\ncounting 1\ncounting 2\ncounting 3\ncounting 4\ncounting 5\ncounting 6\ncounting 7\ncounting 8\ncounting 9\ncounting 10\nend counting\nOnce the value of the variable x reaches 10, the code prints the\ntext “end counting” and then breaks out of the loop.\nPython Keywords 295\nclass\nThe keyword class is used to define a type of object, like a vehicle,\nanimal, or person. Classes can have a function called __init__,\nwhich is used to perform all the tasks an object of the class needs\nwhen it is created. For example, an object of the class Car might\nneed a variable color when it’s created:\nclass Car:\ndef __init__(self, color):\nself.color = color\ncar1 = Car('red')\ncar2 = Car('blue')\nprint(car1.color)\nred\nprint(car2.color)\nblue\nContInUe\nThe continue keyword is a way to “jump” to the next item in a\nloop—so that the remaining code in the loop block is not executed.\nUnlike break we don’t jump out of the loop, we just carry on with\nthe next item. For example, if we had a list of items and wanted to\nskip items starting with b, we could use the following code:\nu >>> my_items = ['apple', 'aardvark', 'banana', 'badger', 'clementine',\n'camel']\nv >>> for item in my_items:\nw if item.startswith('b'):\nx continue\ny print(item)\napple\naardvark\nclementine\ncamel\nWe create our list of items at u, and then use a for loop to loop\nover the items and run a block of code for each at v. If the item\nstarts with the letter b at w, we continue to the next item at x.\nOtherwise, at y we print out the item.\n296 Appendix\nDef\nThe def keyword is used to define a function. For example, to cre-\nate a function to convert a number of years into the equivalent\nnumber of minutes:\n>>> def minutes(years):\nreturn years * 365 * 24 * 60\n>>> minutes(10)\n5256000\ndel\nThe del function is used to remove something. For example, if you\nhad a list of things you wanted for your birthday in your diary, but\nthen changed your mind about one of them, you might cross it off\nthe list and add something new:\nremote controlled car\nnew bike\ncomputer game\nroboreptile\nIn Python, the original list would look like this:\nwhat_i_want = ['remote controlled car', 'new bike', 'computer game']\nYou could remove the computer game by using del and the\nindex of the item you want to delete. You could then add the new\nitem with the function append:\ndel what_i_want[2]\nwhat_i_want.append('roboreptile')\nAnd then print the new list:\nprint(what_i_want)\n['remote controlled car', 'new bike', 'roboreptile']\nelif\nThe keyword elif is used as part of an if statement. See the\ndescription of the if keyword for an example.\nPython Keywords 297\nelse\nThe keyword else is used as part of an if statement. See the\ndescription of the if keyword for an example.\nexcept\nThe keyword except is used for catching problems in code. It’s\ntypically used in fairly complicated programs, so we don’t use it\nin this book.\nfinally\nThe keyword finally is used to make sure that if an error occurs,\ncertain code runs (usually to tidy up any mess that a piece of code\nhas left behind). This keyword isn’t used in this book because it’s\nfor more advanced programming.\nfor\nThe for keyword is used to create a loop of code that runs a certain\nnumber of times. Here’s an example:\nfor x in range(0, 5):\nprint('x is %s' % x)\nThis for loop executes the block of code (the print statement)\nfive times, resulting in the following output:\nx is 0\nx is 1\nx is 2\nx is 3\nx is 4\nfrom\nWhen importing a module, you can import just the part you need\nusing the from keyword. For example, the turtle module intro-\nduced in Chapter 4 has a class called Pen, which we use to create\na Pen object (the canvas on which the turtle moves). Here’s how we\nimport the entire turtle module and then use the Pen class:\nimport turtle\nt = turtle.Pen()\n298 Appendix\nYou could also just import the Pen class on its own, and then\nuse it directly (without referring to the turtle module at all):\nfrom turtle import Pen\nt = Pen()\nYou might do this so that the next time you look at the top\nof that program, you can see all the functions and classes that\nyou’re using (which is particularly useful in larger programs that\nimport a lot of modules). However, if you choose to do this, you\nwon’t be able to use the parts of the module you haven’t imported.\nFor example, the time module has functions called localtime and\ngmtime, but if you import only localtime and then try to use gmtime,\nyou’ll get an error:\n>>> from time import localtime\n>>> print(localtime())\n(2007, 1, 30, 20, 53, 42, 1, 30, 0)\n>>> print(gmtime())\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: name 'gmtime' is not defined\nThe error message name 'gmtime' is not defined means that\nPython doesn’t know anything about the function gmtime, which is\nbecause you haven’t imported it.\nIf there are a number of functions in a particular module that\nyou want to use, and you don’t want to refer to them by using the\nmodule name (for example, time.localtime, or time.gmtime), you can\nimport everything in the module using an asterisk (*), like this:\n>>> from time import *\n>>> print(localtime())\n(2007, 1, 30, 20, 57, 7, 1, 30, 0)\n>>> print(gmtime())\n(2007, 1, 30, 13, 57, 9, 1, 30, 0)\nThis form imports everything from the time module, and you\ncan now refer to the individual functions by name.\nglobal\nThe idea of scope in programs is introduced in Chapter 7. Scope\nrefers to the visibility of a variable. If a variable is defined outside\nPython Keywords 299\na function, usually it can be seen (in other words, it’s visible) inside\nthe function. On the other hand, if the variable is defined inside a\nfunction, usually it can’t be seen outside that function. The global\nkeyword is one exception to this rule. A variable that is defined as\nglobal can be seen everywhere. Here’s an example:\n>>> def test():\nglobal a\na = 1\nb = 2\nWhat do you think happens when you call print(a) and then\nprint(b), after running the function test? The first will work, but\nthe second will display an error message:\n>>> test()\n>>> print(a)\n1\n>>> print(b)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: name 'b' is not defined\nThe variable a has been changed to global inside the function,\nso it’s visible, even once the function has completed, but b is still\nvisible only inside the function. (You must use the global keyword\nbefore setting the value of your variable.)\nif\nThe if keyword is used to make a decision about something. It\ncan also be used with the keywords else and elif (else if). An if\nstatement is a way of saying, “If something is true, then perform\nan action of some kind.” Here’s an example:\nu if toy_price > 1000:\nv print('That toy is overpriced')\nw elif toy_price > 100:\nx print('That toy is expensive')\ny else:\nz print('I can afford that toy')\nThis if statement says that if a toy price is over $1,000 at u,\ndisplay a message that it is overpriced at v; otherwise, if the toy\n300 Appendix\nprice is over $100 as at w, then display a message that it’s expen-\nsive at x. If neither of those conditions is true as at y, it should\ndisplay the message “I can afford that toy” at z.\nimport\nThe import keyword is used to tell Python to load a module so it\ncan be used. For example, the following code tells Python to use\nthe module sys:\nimport sys\nin\nThe in keyword is used in expressions to see if an item is within\na collection of items. For example, can the number 1 be found in a\nlist (a collection) of numbers?\n>>> if 1 in [1,2,3,4]:\n>>> print('number is in list')\nnumber is in list\nHere’s how to find out if the string 'pants' is in a list of cloth-\ning items:\n>>> clothing_list = ['shorts', 'undies', 'boxers', 'long johns',\n'knickers']\n>>> if 'pants' in clothing_list:\nprint('pants is in the list')\nelse:\nprint('pants is not in the list')\npants is not in the list\nis\nThe is keyword is a bit like the equal to operator (==), which is\nused to tell if two things are equal (for example 10 == 10 is true,\nand 10 == 11 is false). However, there is a fundamental difference\nbetween is and ==. If you are comparing two things, == may return\ntrue, while is may not (even if you think the things are the same).\nThis is an advanced programming concept, and we stick with\nusing == in this book.\nPython Keywords 301\nlambda\nThe lambda keyword is used to create anonymous, or inline, func-\ntions. This keyword is used in more advanced programs, and we\ndon’t discuss it in this book.\nnot\nIf something is true, the not keyword makes it false. For example,\nif we create a variable x and set it to the value True, and then print\nthe value of this variable using not, we get the following result:\n>>> x = True\n>>> print(not x)\nFalse\nThis doesn’t seem very useful, until you start using the key-\nword in if statements. For example, to find out whether an item is\nnot in a list, we could write something like this:\n>>> clothing_list = ['shorts', 'undies', 'boxers', 'long johns',\n'knickers']\n>>> if 'pants' not in clothing_list:\nprint('You really need to buy some pants')\nYou really need to buy some pants\nor\nThe or keyword is used to join two conditions together in a state-\nment (such as an if statement) to say that at least one of the condi-\ntions should be true. Here’s an example:\nif dino == 'Tyrannosaurus' or dino == 'Allosaurus':\nprint('Carnivores')\nelif dino == 'Ankylosaurus' or dino == 'Apatosaurus':\nprint('Herbivores')\nIn this case, if the variable dino contains Tyrannosaurus\nor A llosaurus, the program prints “Carnivores.” If it contains\nA nkylosaurus or Apatosaurus, the program prints “Herbivores.”\n302 Appendix\npass\nSometimes when you’re developing a program, you want to write\nonly small pieces of it, to try things out. The problem with doing\nthis is that you can’t have an if statement without the block of\ncode that should be run if the expression in the if statement is\ntrue. You also cannot have a for loop without the block of code that\nshould be run in the loop. For example, the following code works\njust fine:\n>>> age = 15\n>>> if age > 10:\nprint('older than 10')\nolder than 10\nBut if you don’t fill in the block of code (the body) for the if\nstatement, you’ll get an error message:\n>>> age = 15\n>>> if age > 10:\nFile \"<stdin>\", line 2\n^\nIndentationError: expected an indented block\nThis is the error message Python displays when you should\nhave a block of code after a statement of some kind (it won’t even\nlet you type this kind of code if you’re using IDLE). In cases like\nthese, you can use the pass keyword to write a statement but not\nprovide the block of code that goes with it.\nFor example, say you want to create a for loop with an if state-\nment inside it. Perhaps you haven’t decided what to put in the if\nstatement yet—maybe you’ll use the print function, put in a break,\nor something else. You can use pass, and the code will still work\n(even if it doesn’t do exactly what you want yet).\nHere’s our if statement again, this time using the pass keyword:\n>>> age = 15\n>>> if age > 10:\npass\nPython Keywords 303\nThe following code shows another use of the pass keyword:\n>>> for x in range(0, 7):\n>>> print('x is %s' % x)\n>>> if x == 4:\npass\nx is 0\nx is 1\nx is 2\nx is 3\nx is 4\nx is 5\nx is 6\nPython still checks whether the variable x contains the value\n4 every time it executes the block of code in the loop, but it will\ndo nothing as a consequence, so it will print every number in the\nrange 0 to 7.\nLater, you could add the code in the block for the if statement,\nreplacing the pass keyword with something else, such as break:\n>>> for x in range(1, 7):\nprint('x is %s' % x)\nif x == 5:\nbreak\nx is 1\nx is 2\nx is 3\nx is 4\nx is 5\nThe pass keyword is most commonly used when you’re creating\na function but don’t want to write the code for the function yet.\nraise\nThe raise keyword can be used to cause an error to happen.\nThat might sound like a strange thing to do, but in advanced\nprogramming, it can actually be quite useful. (We don’t use this\nkeyword in this book.)\n304 Appendix\nreturn\nThe return keyword is used to return a value from a function. For\nexample, you might create a function to calculate the number of\nseconds you’ve been alive up till your last birthday:\ndef age_in_seconds(age_in_years):\nreturn age_in_years * 365 * 24 * 60 * 60\nWhen you call this function, the returned value can be assigned\nto another variable or printed:\n>>> seconds = age_in_seconds(9)\n>>> print(seconds)\n283824000\n>>> print(age_in_seconds())\n378432000\ntry\nThe try keyword begins a block of code that ends with the except\nand finally keywords. Together, these try/except/finally blocks of\ncode are used to handle errors in a program, such as to make sure\nthat the program displays a useful message to the user, rather\nthan an unfriendly Python error. These keywords aren’t used in\nthis book.\nwhile\nThe while keyword is a bit like for, except that a for loop counts\nthrough a range (of numbers), but a while loop keeps on running\nwhile an expression is true. Be careful with while loops because if\nthe expression is always true, the loop will never end (this is called\nan infinite loop). Here’s an example:\n>>> x = 1\n>>> while x == 1:\nprint('hello')\nIf you run this code, it will loop forever, or at least until you\nclose the Python shell or press ctrl-C to interrupt it. However, the\nfollowing code will print “hello” nine times (each time adding 1 to\nthe variable x, until x is no longer less than 10).\nPython Keywords 305\n>>> x = 1\n>>> while x < 10:\nprint('hello')\nx = x + 1\nwith\nThe with keyword is used with an object to create a block of code in\na similar way to the try and finally keywords. This keyword is not\nused in this book.\nyield\nThe yield keyword is a little bit like return, except that it is used\nwith a specific class of object called a generator. Generators cre-\nate values on the fly (which is another way of saying that they\ncreate values on request), so in that respect, the range function\nbehaves like a generator. This keyword is not used in this book.\n306 Appendix"
  },
  {
    "input": "What are the key programming terms and their definitions provided in the glossary?",
    "summary": "This glossary provides definitions for programming terms to help you understand and progress when encountering unfamiliar words. It covers key concepts like animation, class, function, and variable, which are essential in programming. The glossary also explains terms related to graphics, events, and error handling, making it a useful reference for anyone learning to code.",
    "output": "GLossARY\nSometimes, when you’re programming for the first\ntime, you’ll encounter a new term that just doesn’t\nmake much sense. That lack of understanding can\nget in the way of making any real progress. But\nthere’s a simple solution to that problem!\nI’ve created this glossary to help you through\nthose times when a new word or term holds you up.\nYou’ll find definitions of many of the programming\nterms used in this book, so look here if you encounter\na word that you don’t understand.\nanimation The process of displaying a sequence of images fast\nenough that it looks like something is moving.\nblock A group of computer statements in a program.\nBoolean A type of value that can be either true or false. (In\nPython, it’s True or False, with capital T and F.)\ncall Run the code in a function. When we use a function, we say\nwe are “calling” it.\ncanvas An area of the screen for drawing on. canvas is a class\nprovided by the tkinter module.\nchild When we’re talking about classes, we describe the relation-\nships between classes as that of parents and children. A child class\ninherits the characteristics of its parent class.\nclass A description or definition of a type of thing. In program-\nming terms, a class is a collection of functions and variables.\nclick Press one of the mouse buttons to push an on-screen but-\nton, select a menu option, and so on.\ncollision In computer games, when one character in the game\ncrashes into another character or object on the screen.\ncondition An expression in a program that is a bit like a ques-\ntion. Conditions evaluate to true or false.\ncoordinates The position of a pixel on the screen. This is usu-\nally described as a number of pixels across the screen (x) and a\nnumber of pixels down (y).\ndegrees A unit of measurement for angles.\ndata Usually refers to information stored and manipulated by a\ncomputer.\ndialog A dialog is typically a small window in an application\nthat presents some contextual information, such as an alert or an\nerror message, or asks you to respond to a question. For example,\nwhen you choose to open a file, the window that appears is usually\nthe File dialog.\ndimensions In the context of graphics programming, two-\ndimensional or three-dimensional refers to how images are dis-\nplayed on a computer monitor. Two-dimensional (2D) graphics\nare flat images on a screen that have width and height—like\n308 Glossary\nthe old cartoons you might see on TV. Three-dimensional (3D)\ngraphics are images on the screen that have width, height, and\nthe appearance of depth—the sort of graphics you might see in\na more realistic computer game.\ndirectory The location of a group of files on the hard disk of\nyour computer.\nembed Replace values inside a string. The replaced values are\nsometimes called placeholders.\nerror When something goes wrong with a program on your com-\nputer, this is an error. When programming with Python, you might\nsee all sorts of messages displayed in response to an error. If you\nenter your code incorrectly you might see an IndentationError, for\nexample.\nevent Something that occurs when a program is running. For\nexample, an event might be someone moving the mouse, clicking\nthe mouse button, or typing on a keyboard.\nexception A type of error that can occur when running a\nprogram.\nexecute Run some code, like a program, a small snippet of code,\nor a function.\nframe One of a series of images that makes up an animation.\nfunction A command in a programming language that is usu-\nally a collection of statements that perform some action.\nhexadecimal A way of representing numbers, particularly in\ncomputer programming. Hexadecimal numbers are base 16, which\nmeans the numbers go from 0 through 9 and then A, B, C, D, E,\nand F.\nhorizontal The left and right directions on the screen (repre-\nsented by x).\nidentifier A number that uniquely names something in a pro-\ngram. For example, in Python’s tkinter module, the identifier is\nused to refer to shapes drawn on the canvas.\nimage A picture on the computer screen.\nimport In Python terms, importing makes a module available\nfor your program to use.\nGlossary 309\ninitialize Refers to setting up the initial state of an object (that\nis, setting variables in the object when it is first created).\ninstallation The process of copying a software application’s files\nonto your computer so that the application is available for use.\ninstance The instance of a class—in other words, an object.\nkeyword A special word used by a programming language.\nKeywords are also referred to as reserved words, which basically\nmeans you can’t use them for anything else (for example, you can’t\nuse a keyword as the name of a variable).\nloop A repeated command or set of commands.\nmemory A device or component in your computer that is used to\ntemporarily store information.\nmodule A group of functions and variables.\nnull The absence of value (in Python, also referred to as None).\nobject The specific instance of a class. When you create an\nobject of a class, Python sets aside some of your computer’s mem-\nory to store information about a member of that class.\noperator An element in a computer program used for mathemat-\nics or for comparing values.\nparameter A value used with a function when calling it or when\ncreating an object (when calling the Python __init__ function, for\nexample). Parameters are sometimes referred to as arguments.\nparent When referring to classes and objects, the parent of a\nclass is another class that functions and variables are inherited\nfrom. In other words, a child class inherits the characteristics of\nits parent class. When we’re not talking Python, a parent is the\nperson who tells you to brush your teeth before going to bed at\nnight.\npixel A single point on your computer screen—the smallest dot\nthat the computer is capable of drawing.\nprogram A set of commands that tells a computer what to do.\nscope The part, or section, of a program where a variable can be\n“seen” (or used). (A variable inside a function may not be visible to\ncode outside the function.)\n310 Glossary\nshell In computing, a shell is a command-line interface of\nsome kind. In this book, “the Python shell” refers to the IDLE\napplication.\nsoftware A collection of computer programs.\nsprite A character or an object in a computer game.\nstring A collection of alphanumeric characters (letters, numbers,\npunctuation, and whitespace).\nsyntax The arrangement and order of words in a program.\ntransparency In graphics programming, part of an image that\nisn’t displayed, meaning it doesn’t overwrite whatever is displayed\nbehind it.\nvariable Something used to store values. A variable is like a\nlabel for information held in the computer’s memory. Variables\naren’t permanently tied to a specific value, hence the name “vari-\nable,” meaning it can change.\nvertical The up and down directions on the screen (represented\nby y).\nGlossary 311"
  },
  {
    "input": "",
    "summary": "",
    "output": "Index\nsymbols and alpha channel, 222, 224 braces ({}), for creating\nnumbers and keyword, 61, 294 maps, 39\nAndroid mobile phones, 288 brackets ([]), for creating\n+ (addition operator), 17\nanimation, 164, 183, 198 lists, 33\n\\ (backslash)\ndefined, 308 break keyword, 78, 295\nto separate lines\nin Mr. Stick Man Races built-in functions, 109\nof code, 235\nfor the Exit, 225, abs, 109–111\nin strings, 29, 126\n260–264 bool, 111\n{} (braces), for creating\nwith sprites, 222 dir, 113\nmaps, 39\nanimation frames, eval, 114\n[] (brackets), for creating\ndefined, 309 exec, 116\nlists, 33\nappend function, 35 float, 64, 116\n: (colon)\nas keyword, 294 int, 63, 117\nin if statements, 54\nassert keyword, 294 len, 118\nin lists, 34\nAssertionError, 295 max, 119\nin maps, 39\nmin, 120\n/ (division operator), 17–18 B open, 125\n. (dot operator), 106–107\nbackslash (\\) range function, 121–122\n* (multiplication operator),\nto separate lines in for loops, 68–69, 119\n16–18\nof code, 235 with list function, 82\n() ( parentheses)\nin strings, 29, 126 sum, 122\nwith classes and\nBASIC, 4\nobjects, 96\nBlitzBasic, 286 C\nfor creating tuples, 38\nblocks of code, 54–55, 72 C programming\n% ( percent sign)\ndefined, 308 language, 288\nas modulo operator, 149\nbody of a function, 83 C++ programming\nas placeholder operator,\nbool function, 111 language, 289\n30–31, 175\nBoolean, 111 C# programming\n- (subtraction operator), 17\ndefined, 308 language, 289\n2D (two-dimensional)\nBounce! (game), 193–216 calculating, 16, 115\ngraphics, 163\nadding an element of calling a function, 83\n3D (three-dimensional)\nchange, 212–213 defined, 308\ngraphics, 164\nball, 196–198 canvases\nA changing direction, 202 creating with tkinter\nhitting the paddle, module, 167–168\nabs function, 109–111\n209–212 creating with turtle\nadding items to lists, 35\nmaking bounce, 200 module, 44\nadding objects to classes, 96\nmoving, 198 defined, 308\naddition operator (+), 17\ncanvas, 194 characteristics, of classes,\nAdobe Flash, 286\npaddle, 206 97–98\nAlice, 286\nmoving, 207–208 child classes, 95\ndefined, 308\nclass keyword, 94, 296 converting division operator (/),\nclasses, 94 dates, 140 17–18\nadding objects to, 96 numbers from strings, 63 dot operator (.), 106–107\nclass functions calling numbers to strings, 64 drawing\nother functions, 104 coordinates, 168 for Mr. Stick Man Races\nchild classes, 95, 308 Coords class, 238 for the Exit\ndefining functions, 97 copy module, 130 background, 229\ndescribed using turtle deep copy, 132 door, 228\nmodule, 100 shallow copy, 132 Mr. Stick Man, 225\ninheriting functions, copying and pasting, platforms, 227\n103–104 in IDLE, 22 with tkinter module,\nparent classes, 95 creating files 163–190\nclassifying things using on Mac OS X, 123–124 arcs, 177–179\nclasses and on Ubuntu Linux, boxes, 170–174, 206\nobjects, 94 124–125 lines, 168–169\nclicking a button, 308 on Windows, 123 ovals (circles), 196–197\ncollision detection, 209, creating lists of numbers, polygons, 179–180\n239–244 48, 82 with turtle module,\nin Bounce!, 209–212 creating variables, 19 43–50, 145–160\nin Mr. Stick Man Races 8-point star, 147\nfor the Exit, D boxes, 146, 206\n266–272 data, defined, 308 car, 151\ncollisions, defined, 308 data types filled circle, 153\ncolon (:) Boolean, 111 filled square, 157\nin if statements, 54 floating-point filled stars, 158\nin lists, 34 numbers, 116 line, 169\nin maps, 39 integers, 64, 116 spiral star, 148\ncolors strings, 26–32\nchanging with the dates e\nitemconfig converting, 140 elif keyword, 59, 297. See\nfunction, 189 as objects, 140–141 also if statements\nsetting def keyword, 98, 297 else keyword, 58, 298. See\nwith tkinter module, degrees, 47–48 also if statements\n174–175 in arcs, 178–179 embedding values in strings,\nwith turtle module, defined, 308 30, 175\n152–155, 159 in stars, 147–148 EOL (end-of-line), 27\nusing the color chooser in del keyword, 35, 297 errors\ntkinter module, 176 delaying programs, 141 AssertionError, 295\ncommand-line console, 13 deleting items defined, 309\nconditions, 57–58 from lists, 35 indentation, 56, 71, 303\nand keyword, 61 from maps, 40 highlighting in IDLE,\ncombining, 61 dialogs, defined, 308 56, 71\ndefined, 308 dict. See maps NameError, 85, 299, 300\noperators, 57 dimensions, defined, 308 SyntaxError, 27, 28, 56, 71\nor keyword, 61 dir function, 113 SystemExit, 137\ncontinue keyword, 296 directories, defined, 309 TypeError, 37, 38, 41\nValueError, 64, 118\n314 INDEX\nescaping strings, 29 functions, 11, 35, 82. See also if keyword, 300\neval function, 114 built-in functions if statements, 54. See also\nevent bindings, with tkinter append, 35 elif keyword; else\nmodule, 186, 208 calling, 83 keyword\nevent objects, 255–256 defined, 308 images\nevents, defined, 309 different values, 86 defined, 309\nexcept keyword, 298 defined, 309 displaying with tkinter\nexceptions, defined, 309 list, 69, 82 module, 181\nexec function, 116 parts of a function, 83 flipping, in GIMP, 227\nexecute, defined, 309 print, 12 GIF, 182, 226\nexpressions, 115, 149 sleep, 141 import keyword, 301\nstr, 64 importing modules, 44, 87\nf defined, 309\nfile locations, 126 G in keyword, 301\nfile objects games. See Bounce!; indentation\nclose function, 127 Mr. Stick Man consistent spacing,\ncreating files Races for the Exit 57, 72\non Mac OS X, 123–124 GIF images, 182, 226 errors, 56, 71, 303\non Ubuntu Linux, GIMP (GNU Image in IDLE, 56, 69, 71\n124–125 Manipulation indenting blocks, 54\non Windows, 123 Program), 222 index positions, in lists, 33\nopening files global keyword, 299 inheritance, 103–104\non Mac OS X, 126 graphics initialization, defined, 310\non Ubuntu Linux, 126 isometric, 164 installation, defined, 310\non Windows, 125 three-dimensional installing Python, 5\nread function, 126 (3D), 164 on Mac OS X, 7\nwrite function, 127 two-dimensional on Ubuntu Linux, 9\nfiles (2D), 163 on Windows, 5\ncreating, 123–125 instances, 96\nopening, 125–126 H defined, 310\nreading from, 125, 127 help function, 114 int function, 63, 117\nwriting to, 126 hexadecimal numbers, 175 integers, 64, 116\nfinally keyword, 298 defined, 309 integrated development\nfloat function, 64, 116 horizontal, defined, 309 environment.\nfloating-point numbers, 116 HTML, 289 See IDLE\nfor keyword, 298 is keyword, 301\nfor loops, 68 I isometric graphics, 164\ncomparing code without identifiers, 169, 184, 188 iterators, 69, 121\nusing loops, 69 defined, 309\ninside loops, 73 IDLE (integrated devel-\nJ\nand lists, 70 opment environ-\nJava programming\nand range function, 68 ment), 10\nlanguage, 288\nand turtle module, 147 copying and pasting, 22\nJavaScript programming\nformat placeholder, error highlighting, 56, 71\nlanguage, 291\n30–31, 175 setting up on Mac OS X, 8\njoining lists, 36\nframes, animation, 309 setting up on Windows, 6\nfrom keyword, 298 starting, 11\nINDEX 315\nK joining, 36 pickle, 142\nkeyword module, 133 length of, 118 dump function, 142\nkeywords, 293–306 minimum value of, 120 load function, 143\nand, 294 of numbers, creating, random. See random module\nas, 294 48, 82 sys. See sys module\nassert, 294 printing contents of, 33 time. See time module\nbreak, 78, 295 and range function, 82 tkinter. See tkinter\nclass, 94, 296 subsets of, 34 module\ncontinue, 296 type errors, 37, 38 turtle. See turtle module\ndef, 98, 297 loops modulo operator (%), 149\ndefined, 310 defined, 310 Monty Python’s Flying\ndel, 35, 297 for loops. See for loops Circus, 4\nelif, 59, 297. See also if while loops, 75–78 Mr. Stick Man Races for the\nstatements Exit (game)\nelse, 58, 298. See also if M background, drawing,\nstatements Mac OS X 229–230\nexcept, 298 creating files on, 123–124 collision detection,\nfinally, 298 file locations on, 126 239–244\nfor, 298 installing Python on, 7 Coords class, 238\nfrom, 298 opening files on, 126 door, drawing, 228–229\nglobal, 299 setting up IDLE on, 8 DoorSprite class, 274–275\nif, 300 main loops, 197, 236 Game class, 234–238\nimport, 301 maps, 39 platforms\nin, 301 deleting values from, 40 adding, 245–248\nis, 301 length of, 118 drawing, 227–228\nlambda, 302 obtaining values of, 40 sprites, creating, 244–245\nnot, 302 replacing values in, 40 Mr. Stick Man, 252–256\nor, 61, 302 type errors, 41 animating, 260-272\npass, 95, 303 mathematical operations binding to keys, 255\nraise, 304 addition, 17 drawing, 225–227\nreturn, 305 division, 17–18 loading images,\ntry, 305 modulo, 149 252–253\nwhile, 305 multiplication, 16–18 moving, 255–257\nwith, 306 with strings, 31 multiline strings, 27, 116\nyield, 306 with variables, 84 multiplication, 16–18\nsubtraction, 17 with strings, 31\nL max function, 119 with variables, 84\nlambda keyword, 302 memory, defined, 310\nlen function, 118 min function, 120 n\nLinux. See Ubuntu Linux modules, 87 NameError, 85, 299, 300\nlists, 33 copy, 130 None, 61–62\nadding items to, 35 deep copy, 132 not keyword, 302\nchanging, 33 shallow copy, 132 null, defined, 310\ndeleting items from, 35 defined, 310 numbers,\nand for loops, 70 importing, 44, 87 converting from\nindex positions, 33 keyword, 133 strings, 63\nconverting to strings, 64\n316 INDEX\nfloating-point, 116 PERL programming raise keyword, 304\nintegers, 64, 116 language, 290 reading input, 89\nvs. strings, 62 PHP programming reading objects from\nand ValueError, 64, 118 language, 289–290 files, 143\npickle module, 142 replacing map values, 40\no dump function, 142 resetting variables, 62\nObjective-C programming load function, 143 return keyword, 305\nlanguage, 290 pixels, 47 Ruby programming\nobjects, 88, 95–96 defined, 310 language, 290\nadding to classes, 96 placeholders, 30, 175 running programs, 13\ndefined, 310 printing\nidentifiers, 188 contents of lists, 33 s\ninitializing, 105 contents of variables, 20 saving programs, 12\nreading from files, 143 programming languages, scope\nstandard input, 88 4, 288–291 defined, 310\nstandard output, 138 for mobile phone of variables, 84, 85\nwriting to files, 142 development, Scratch, 286\nopening files 288, 290 shell, 11. See also IDLE\non Mac OS X, 126 for website development, creating a new window, 13\non Ubuntu Linux, 126 289, 290, 291 defined, 311\non Windows, 125 programs sleep function, 141\noperators, 17 defined, 310 software, 3\ndefined, 310 delaying, 141 defined, 311\nmodulo (%), 149 running, 13 sprites, defined, 222, 311.\norder of operations, 19 saving, 12 See also Bounce!\nplaceholder (%), 30 prompt, 11 (game); Mr. Stick\nor keyword, 61, 302 PyGame2, 286–287 Man Races for the\norder of operations, 18 Python, 4 Exit (game)\nOS X. See Mac OS X console, using, 46 standard input (stdin), 88\ninstalling, 5 standard output (stdout), 138\nP on Mac OS X, 7 str function, 64\non Ubuntu Linux, 9 strings, 26\nparameters, 83\non Windows, 5 defined, 311\ndefined, 310\nsaving programs, 12 embedding values in,\nnamed, 167\nshell. See shell 30, 175\nparent classes, 95\nescaping, 29\ndefined, 310\nR multiline, 27, 116\nparentheses (), 18\nrandom module, 133 multiplying, 31\nwith classes and\nchoice function 135 vs. numbers, 62\nobjects, 96\ncreating random syntax errors in strings,\nfor creating tuples, 38\nrectangles, 172 27, 28\npass keyword, 95, 303\nrandint function, 134 and whitespace, 112\npercent sign (%)\nshuffle function, 136, 202 subset of a list, 34\nas module operator, 149\nrange function, 121–122 subtraction, 17\nas placeholder operator,\nin for loops, 68–69, 119 sum function, 122\n30–31, 175\nwith list function, 82\nINDEX 317\nsyntax, 27 event binding, 186, 208 turning\ndefined, 311 and identifiers, 169, left, 47\nSyntaxError, 27, 28, 56, 71 184, 188 right, 49\nsys module, 88, 136 itemconfig function of the using with for loops, 147\nexit function, 136 canvas, 189 two-dimensional (2D)\nstdin object, 137 keysym variable 187 graphics, 163\nstdout object, 138 move function, 207 TypeError, 37, 38, 41\nversion function, 138 pack function, 168, 195\nSystemExit, 137 PhotoImage, 182 U\ntk object Ubuntu Linux\nt title function, 195 creating files on, 124–125\nupdate function, 197 file locations on, 126\ntime module, 87, 138\nupdate_idletasks installing Python on, 10\nasctime function, 140\nfunction, 197 opening files on, 126\nlocaltime function,\nwm_attributes Unity3D, 286\n140–141\nfunction, 195 user input, 62\nsleep function, 141\ntransparency in images,\ntime function, 139 222–223, 230 V\nthree-dimensional (3D)\ncreating with GIMP, 224 ValueError, 64, 118\ngraphics, 164\ndefined, 311 variables\ntkinter module, 163\ntry keyword, 305 creating, 19\nanimation, 183–186, 198\ntuples, 38, 176, 181 defined, 311\naskcolor function, 176\nturtle module, 44–50, printing the contents\nCanvas object\n145–160 of, 20\ncoords function,\nbegin_fill function, 153 resetting, 62\n200–201\nclear function, 49 scope of, 84\nwinfo_height\ncolor function, 152 using, 21\nfunction, 200\ncreating canvas, 44 vertical, defined, 311\nwinfo_width\ndrawing\nfunction, 202\n8-point star, 147 W\nand colors, 174–177\nboxes, 146, 206 while keyword, 305\ncoords function, 201\ncar, 151 while loops, 75–78\ncreating\nfilled circle, 153 whitespace, 55\nbutton, 165–166\nfilled square, 157 whole numbers, 116\ncanvas, 167–168\nfilled stars, 158 Windows\ndisplaying\nline, 169 creating files on, 123\nimages, 181–183\nspiral star, 148 file locations on, 126\ntext, 180–181\nend_fill function, 153 installing Python on, 5\ndrawing\nimporting, 44 opening files on, 125\narcs, 177–179\nmoving setting up IDLE on, 6\nboxes, 170–174, 206\nbackward, 49 with keyword, 306\nlines, 168–169\nforward, 46 writing objects to files, 142\novals (circles), 196–197\nPen class, 44\npolygons, 179–180\nreset function, 49 Y\nyield keyword, 306\n318 INDEX\nUPDAtes\nVisit http://python-for-kids.com/ for updates, errata, and other\ninformation.\nMore no-nonsense books from no Starch preSS\nSuper Scratch eLoquent JavaScript think Like a programmer\nprogramming adventure! a modern introduction to programming an introduction to creative\nLearn to program by making cool games by marijn haverbeke problem Solving\nby the lead project january 2011, 224 pp., $29.95 by v. anton spraul\naugust 2012, 160 pp., $24.95 isbn 978-1-59327-282-1 august 2012, 256 pp., $34.95\nisbn 978-1-59327-409-2 isbn 978-1-59327-424-5\nfull color\nthe unofficiaL Lego® WonderfuL Life With the manga guide™\ntechnic BuiLder’S guide the eLementS to phySicS\nby pawel “sariel” kmiec the periodic table personified by hideo nitta, keita takatsu,\nnovember 2012, 352 pp., $29.95 by bunpei yorifuji and trend-pro co., ltd.\nisbn 978-1-59327-434-4 september 2012, 208 pp., $17.95 may 2009, 248 pp., $19.95\nfull color isbn 978-1-59327-423-8 isbn 978-1-59327-196-1\nhardcover with pull-out poster\nphone: email:\n800.420.7240 or sales@nostarch.com\n415.863.9900 web:\nwww.nostarch.com\nP Y T H O N\nP Y T H O N\nF O R K I D S\nF O R K I D S\nPython is a powerful, expressive program- As you strike out on your programming\nming language that’s easy to learn and fun to adventure, you’ll learn how to:\nuse! But books about learning to program in\nM Use fundamental data structures like lists,\nPython can be kind of dull, gray, and boring,\ntuples, and maps\nand that’s no fun for anyone. A Playful Introduction to Programming\nM Organize and reuse your code with func-\nPython for Kids brings Python to life and\ntions and modules\nbrings you (and your parents) into the world of\nprogramming. The ever-patient Jason R. Briggs M Use control structures like loops and\nwill guide you through the basics as you experi- conditional statements J a s o n R . B r i g g s\nment with unique (and often hilarious) example M Draw shapes and patterns with Python’s\nprograms that feature ravenous monsters, secret turtle module\nagents, thieving ravens, and more. New terms\nM Create games, animations, and other\nare defined; code is colored, dissected, and\ngraphical wonders with tkinter\nexplained; and quirky, full-color illustrations\nWhy should serious adults have all the fun?\nkeep things on the lighter side.\nPython for Kids is your ticket into the amaz-\nChapters end with programming puzzles\ning world of computer programming.\ndesigned to stretch your brain and strengthen\nyour understanding. By the end of the book ABOUT THE AUTHOR\nyou’ll have programmed two complete games:\nJason R. Briggs has been a programmer since\na clone of the famous Pong and “Mr. Stick Man\nthe age of eight, when he first learned BASIC on\nRaces for the Exit”—a platform game with\na Radio Shack TRS-80. He has written software\njumps, animation, and much more.\nprofessionally as a developer and systems archi-\ntect and served as Contributing Editor for Java\nDeveloper’s Journal. His articles have appeared\nin JavaWorld, ONJava, and ONLamp. Python\nfor Kids is his first book.\nPROGRAMMING\nLANGUAGES/PYTHON\nSHELVE\nIN:\nFor kids aged 10+ (and their parents)\nrReEaAlL pPrrooggrraammmmiinngg..\nrReEaAlL eEaAsSyY..\nIllustrations by Miran Lipovaca\n$34.95 ($36.95 CDN)\nwww.nostarch.com\nTHE FINEST IN\nGEEK ENTERTAINMENT™\nPPYYTTHHOONN\nFFOORR\nKKIIDDSS\nB\nr\ni\ng\ng\ns"
  }
]