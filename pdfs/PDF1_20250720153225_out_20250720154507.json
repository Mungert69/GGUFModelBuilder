[
  {
    "input": "What is the core security problem that web applications face, and how does it contribute to their vulnerability to attacks?",
    "summary": "The book \"The Web Application Hacker’s Handbook: Discovering and Exploiting Security Flaws\" explores the security issues and vulnerabilities in web applications. It highlights that most web applications are insecure due to the core problem of users submitting arbitrary input, which can be exploited to gain unauthorized access. The text discusses common vulnerabilities such as broken authentication, SQL injection, and cross-site scripting, along with the factors contributing to weak security, including immature security awareness and resource constraints. It also covers the evolving threat landscape and the importance of securing web applications as the security perimeter shifts to the application layer. The book provides practical guidance on identifying and exploiting these flaws, emphasizing the need for robust defense mechanisms and proper handling of user input.",
    "output": "70779ffirs.qxd:WileyRed 9/17/07 12:11 PM Page i\nThe Web Application\nHacker’s Handbook\nDiscovering and Exploiting Security Flaws\nDafydd Stuttard\nMarcus Pinto\nWiley Publishing, Inc.\n70779ffirs.qxd:WileyRed 9/17/07 12:11 PM Page ii\nThe Web Application Hacker’s Handbook: Discovering and Exploiting Security Flaws\nPublished by\nWiley Publishing, Inc.\n10475 Crosspoint Boulevard\nIndianapolis, IN 46256\nwww.wiley.com\nCopyright © 2008 by Dafydd Stuttard and Marcus Pinto.\nPublished by Wiley Publishing, Inc., Indianapolis, Indiana\nPublished simultaneously in Canada\nISBN: 978-0-470-17077-9\nManufactured in the United States of America\n10 9 8 7 6 5 4 3 2 1\nNo part of this publication may be reproduced, stored in a retrieval system or transmitted in any form\nor by any means, electronic, mechanical, photocopying, recording, scanning or otherwise, except as\npermitted under Sections 107 or 108 of the 1976 United States Copyright Act, without either the prior\nwritten permission of the Publisher, or authorization through payment of the appropriate per-copy fee\nto the Copyright Clearance Center, 222 Rosewood Drive, Danvers, MA 01923, (978) 750-8400, fax (978)\n646-8600. Requests to the Publisher for permission should be addressed to the Legal Department, Wiley\nPublishing, Inc., 10475 Crosspoint Blvd., Indianapolis, IN 46256, (317) 572-3447, fax (317) 572-4355, or\nonline at http://www.wiley.com/go/permissions.\nLimit of Liability/Disclaimer of Warranty:The publisher and the author make no representations or\nwarranties with respect to the accuracy or completeness of the contents of this work and specifically\ndisclaim all warranties, including without limitation warranties of fitness for a particular purpose. No\nwarranty may be created or extended by sales or promotional materials. The advice and strategies con-\ntained herein may not be suitable for every situation. This work is sold with the understanding that the\npublisher is not engaged in rendering legal, accounting, or other professional services. If professional\nassistance is required, the services of a competent professional person should be sought. Neither the\npublisher nor the author shall be liable for damages arising herefrom. The fact that an organization or\nWebsite is referred to in this work as a citation and/or a potential source of further information does\nnot mean that the author or the publisher endorses the information the organization or Website may\nprovide or recommendations it may make. Further, readers should be aware that Internet Websites\nlisted in this work may have changed or disappeared between when this work was written and when\nit is read.\nFor general information on our other products and services or to obtain technical support, please con-\ntact our Customer Care Department within the U.S. at (800) 762-2974, outside the U.S. at (317) 572-3993\nor fax (317) 572-4002.\nLibrary of Congress Cataloging-in-Publication Data\nStuttard, Dafydd, 1972-\nThe web application hacker's handbook : discovering and exploiting security flaws / Dafydd Stut-\ntard, Marcus Pinto.\np. cm.\nIncludes index.\nISBN 978-0-470-17077-9 (pbk.)\n1. Internet--Security measures. 2. Computer security. I. Pinto, Marcus, 1978- II. Title.\nTK5105.875.I57S85 2008\n005.8--dc22\n2007029983\nTrademarks:Wiley and related trade dress are registered trademarks of Wiley Publishing, Inc., in the\nUnited States and other countries, and may not be used without written permission. All other trade-\nmarks are the property of their respective owners. Wiley Publishing, Inc., is not associated with any\nproduct or vendor mentioned in this book.\nWiley also publishes its books in a variety of electronic formats. Some content that appears in print may\nnot be available in electronic books.\n70779ffirs.qxd:WileyRed 9/17/07 12:11 PM Page iii\nAbout the Authors\nDafydd Stuttard is a Principal Security Consultant at Next Generation Secu-\nrity Software, where he leads the web application security competency. He has\nnine years’ experience in security consulting and specializes in the penetration\ntesting of web applications and compiled software.\nDafydd has worked with numerous banks, retailers, and other enterprises\nto help secure their web applications, and has provided security consulting to\nseveral software manufacturers and governments to help secure their com-\npiled software. Dafydd is an accomplished programmer in several languages,\nand his interests include developing tools to facilitate all kinds of software\nsecurity testing.\nDafydd has developed and presented training courses at the Black Hat secu-\nrity conferences around the world. Under the alias “PortSwigger,” Dafydd cre-\nated the popular Burp Suite of web application hacking tools. Dafydd holds\nmaster’s and doctorate degrees in philosophy from the University of Oxford.\nMarcus Pinto is a Principal Security Consultant at Next Generation Security\nSoftware, where he leads the database competency development team, and\nhas lead the development of NGS’ primary training courses. He has eight\nyears’ experience in security consulting and specializes in penetration testing\nof web applications and supporting architectures.\nMarcus has worked with numerous banks, retailers, and other enterprises to\nhelp secure their web applications, and has provided security consulting to the\ndevelopment projects of several security-critical applications. He has worked\nextensively with large-scale web application deployments in the financial ser-\nvices industry.\nMarcus has developed and presented database and web application train-\ning courses at the Black Hat and other security conferences around the world.\nMarcus holds a master’s degree in physics from the University of Cambridge.\niii\n70779ffirs.qxd:WileyRed 9/17/07 12:11 PM Page iv\nCredits\nExecutive Editor Vice President and Executive Publisher\nCarol Long Joseph B. Wikert\nDevelopment Editor Project Coordinator, Cover\nAdaobi Obi Tulton Lynsey Osborn\nProduction Editor Compositor\nChristine O’Connor Happenstance Type-O-Rama\nCopy Editor Proofreader\nFoxxe Editorial Services Kathryn Duggan\nEditorial Manager Indexer\nMary Beth Wakefield Johnna VanHoose Dinse\nProduction Manager Anniversary Logo Design\nTim Tate Richard Pacifico\nVice President and Executive Group\nPublisher\nRichard Swadley\niv\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page v\nContents\nAcknowledgments xxiii\nIntroduction xxv\nChapter 1 Web Application (In)security 1\nThe Evolution of Web Applications 2\nCommon Web Application Functions 3\nBenefits of Web Applications 4\nWeb Application Security 5\n“This Site Is Secure” 6\nThe Core Security Problem: Users Can Submit Arbitrary Input 8\nKey Problem Factors 9\nImmature Security Awareness 9\nIn-House Development 9\nDeceptive Simplicity 9\nRapidly Evolving Threat Profile 10\nResource and Time Constraints 10\nOverextended Technologies 10\nThe New Security Perimeter 10\nThe Future of Web Application Security 12\nChapter Summary 13\nChapter 2 Core Defense Mechanisms 15\nHandling User Access 16\nAuthentication 16\nSession Management 17\nAccess Control 18\nHandling User Input 19\nVarieties of Input 20\nApproaches to Input Handling 21\nv\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page vi\nvi Contents\n“Reject Known Bad” 21\n“Accept Known Good” 21\nSanitization 22\nSafe Data Handling 22\nSemantic Checks 23\nBoundary Validation 23\nMultistep Validation and Canonicalization 26\nHandling Attackers 27\nHandling Errors 27\nMaintaining Audit Logs 29\nAlerting Administrators 30\nReacting to Attacks 31\nManaging the Application 32\nChapter Summary 33\nQuestions 34\nChapter 3 Web Application Technologies 35\nThe HTTP Protocol 35\nHTTP Requests 36\nHTTP Responses 37\nHTTP Methods 38\nURLs 40\nHTTP Headers 41\nGeneral Headers 41\nRequest Headers 41\nResponse Headers 42\nCookies 43\nStatus Codes 44\nHTTPS 45\nHTTP Proxies 46\nHTTP Authentication 47\nWeb Functionality 47\nServer-Side Functionality 48\nThe Java Platform 49\nASP.NET 50\nPHP 50\nClient-Side Functionality 51\nHTML 51\nHyperlinks 51\nForms 52\nJavaScript 54\nThick Client Components 54\nState and Sessions 55\nEncoding Schemes 56\nURL Encoding 56\nUnicode Encoding 57\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page vii\nContents vii\nHTML Encoding 57\nBase64 Encoding 58\nHex Encoding 59\nNext Steps 59\nQuestions 59\nChapter 4 Mapping the Application 61\nEnumerating Content and Functionality 62\nWeb Spidering 62\nUser-Directed Spidering 65\nDiscovering Hidden Content 67\nBrute-Force Techniques 67\nInference from Published Content 70\nUse of Public Information 72\nLeveraging the Web Server 75\nApplication Pages vs. Functional Paths 76\nDiscovering Hidden Parameters 79\nAnalyzing the Application 79\nIdentifying Entry Points for User Input 80\nIdentifying Server-Side Technologies 82\nBanner Grabbing 82\nHTTP Fingerprinting 82\nFile Extensions 84\nDirectory Names 86\nSession Tokens 86\nThird-Party Code Components 87\nIdentifying Server-Side Functionality 88\nDissecting Requests 88\nExtrapolating Application Behavior 90\nMapping the Attack Surface 91\nChapter Summary 92\nQuestions 93\nChapter 5 Bypassing Client-Side Controls 95\nTransmitting Data via the Client 95\nHidden Form Fields 96\nHTTP Cookies 99\nURL Parameters 99\nThe Referer Header 100\nOpaque Data 101\nThe ASP.NET ViewState 102\nCapturing User Data: HTML Forms 106\nLength Limits 106\nScript-Based Validation 108\nDisabled Elements 110\nCapturing User Data: Thick-Client Components 111\nJava Applets 112\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page viii\nviii Contents\nDecompiling Java Bytecode 114\nCoping with Bytecode Obfuscation 117\nActiveX Controls 119\nReverse Engineering 120\nManipulating Exported Functions 122\nFixing Inputs Processed by Controls 123\nDecompiling Managed Code 124\nShockwave Flash Objects 124\nHandling Client-Side Data Securely 128\nTransmitting Data via the Client 128\nValidating Client-Generated Data 129\nLogging and Alerting 131\nChapter Summary 131\nQuestions 132\nChapter 6 Attacking Authentication 133\nAuthentication Technologies 134\nDesign Flaws in Authentication Mechanisms 135\nBad Passwords 135\nBrute-Forcible Login 136\nVerbose Failure Messages 139\nVulnerable Transmission of Credentials 142\nPassword Change Functionality 144\nForgotten Password Functionality 145\n“Remember Me” Functionality 148\nUser Impersonation Functionality 149\nIncomplete Validation of Credentials 152\nNon-Unique Usernames 152\nPredictable Usernames 154\nPredictable Initial Passwords 154\nInsecure Distribution of Credentials 155\nImplementation Flaws in Authentication 156\nFail-Open Login Mechanisms 156\nDefects in Multistage Login Mechanisms 157\nInsecure Storage of Credentials 161\nSecuring Authentication 162\nUse Strong Credentials 162\nHandle Credentials Secretively 163\nValidate Credentials Properly 164\nPrevent Information Leakage 166\nPrevent Brute-Force Attacks 167\nPrevent Misuse of the Password Change Function 170\nPrevent Misuse of the Account Recovery Function 170\nLog, Monitor, and Notify 172\nChapter Summary 172\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page ix\nContents ix\nChapter 7 Attacking Session Management 175\nThe Need for State 176\nAlternatives to Sessions 178\nWeaknesses in Session Token Generation 180\nMeaningful Tokens 180\nPredictable Tokens 182\nConcealed Sequences 184\nTime Dependency 185\nWeak Random Number Generation 187\nWeaknesses in Session Token Handling 191\nDisclosure of Tokens on the Network 192\nDisclosure of Tokens in Logs 196\nVulnerable Mapping of Tokens to Sessions 198\nVulnerable Session Termination 200\nClient Exposure to Token Hijacking 201\nLiberal Cookie Scope 203\nCookie Domain Restrictions 203\nCookie Path Restrictions 205\nSecuring Session Management 206\nGenerate Strong Tokens 206\nProtect Tokens throughout Their Lifecycle 208\nPer-Page Tokens 211\nLog, Monitor, and Alert 212\nReactive Session Termination 212\nChapter Summary 213\nQuestions 214\nChapter 8 Attacking Access Controls 217\nCommon Vulnerabilities 218\nCompletely Unprotected Functionality 219\nIdentifier-Based Functions 220\nMultistage Functions 222\nStatic Files 222\nInsecure Access Control Methods 223\nAttacking Access Controls 224\nSecuring Access Controls 228\nA Multi-Layered Privilege Model 231\nChapter Summary 234\nQuestions 235\nChapter 9 Injecting Code 237\nInjecting into Interpreted Languages 238\nInjecting into SQL 240\nExploiting a Basic Vulnerability 241\nBypassing a Login 243\nFinding SQL Injection Bugs 244\nInjecting into Different Statement Types 247\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page x\nx Contents\nThe UNION Operator 251\nFingerprinting the Database 255\nExtracting Useful Data 256\nAn Oracle Hack 257\nAn MS-SQL Hack 260\nExploiting ODBC Error Messages (MS-SQL Only) 262\nEnumerating Table and Column Names 263\nExtracting Arbitrary Data 265\nUsing Recursion 266\nBypassing Filters 267\nSecond-Order SQL Injection 271\nAdvanced Exploitation 272\nRetrieving Data as Numbers 273\nUsing an Out-of-Band Channel 274\nUsing Inference: Conditional Responses 277\nBeyond SQL Injection: Escalating the Database Attack 285\nMS-SQL 286\nOracle 288\nMySQL 288\nSQL Syntax and Error Reference 289\nSQL Syntax 290\nSQL Error Messages 292\nPreventing SQL Injection 296\nPartially Effective Measures 296\nParameterized Queries 297\nDefense in Depth 299\nInjecting OS Commands 300\nExample 1: Injecting via Perl 300\nExample 2: Injecting via ASP 302\nFinding OS Command Injection Flaws 304\nPreventing OS Command Injection 307\nInjecting into Web Scripting Languages 307\nDynamic Execution Vulnerabilities 307\nDynamic Execution in PHP 308\nDynamic Execution in ASP 308\nFinding Dynamic Execution Vulnerabilities 309\nFile Inclusion Vulnerabilities 310\nRemote File Inclusion 310\nLocal File Inclusion 311\nFinding File Inclusion Vulnerabilities 312\nPreventing Script Injection Vulnerabilities 312\nInjecting into SOAP 313\nFinding and Exploiting SOAP Injection 315\nPreventing SOAP Injection 316\nInjecting into XPath 316\nSubverting Application Logic 317\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xi\nContents xi\nInformed XPath Injection 318\nBlind XPath Injection 319\nFinding XPath Injection Flaws 320\nPreventing XPath Injection 321\nInjecting into SMTP 321\nEmail Header Manipulation 322\nSMTP Command Injection 323\nFinding SMTP Injection Flaws 324\nPreventing SMTP Injection 326\nInjecting into LDAP 326\nInjecting Query Attributes 327\nModifying the Search Filter 328\nFinding LDAP Injection Flaws 329\nPreventing LDAP Injection 330\nChapter Summary 331\nQuestions 331\nChapter 10 Exploiting Path Traversal 333\nCommon Vulnerabilities 333\nFinding and Exploiting Path Traversal Vulnerabilities 335\nLocating Targets for Attack 335\nDetecting Path Traversal Vulnerabilities 336\nCircumventing Obstacles to Traversal Attacks 339\nCoping with Custom Encoding 342\nExploiting Traversal Vulnerabilities 344\nPreventing Path Traversal Vulnerabilities 344\nChapter Summary 346\nQuestions 346\nChapter 11 Attacking Application Logic 349\nThe Nature of Logic Flaws 350\nReal-World Logic Flaws 350\nExample 1: Fooling a Password Change Function 351\nThe Functionality 351\nThe Assumption 351\nThe Attack 352\nExample 2: Proceeding to Checkout 352\nThe Functionality 352\nThe Assumption 353\nThe Attack 353\nExample 3: Rolling Your Own Insurance 354\nThe Functionality 354\nThe Assumption 354\nThe Attack 355\nExample 4: Breaking the Bank 356\nThe Functionality 356\nThe Assumption 357\nThe Attack 358\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xii\nxii Contents\nExample 5: Erasing an Audit Trail 359\nThe Functionality 359\nThe Assumption 359\nThe Attack 359\nExample 6: Beating a Business Limit 360\nThe Functionality 360\nThe Assumption 361\nThe Attack 361\nExample 7: Cheating on Bulk Discounts 362\nThe Functionality 362\nThe Assumption 362\nThe Attack 362\nExample 8: Escaping from Escaping 363\nThe Functionality 363\nThe Assumption 364\nThe Attack 364\nExample 9: Abusing a Search Function 365\nThe Functionality 365\nThe Assumption 365\nThe Attack 365\nExample 10: Snarfing Debug Messages 366\nThe Functionality 366\nThe Assumption 367\nThe Attack 367\nExample 11: Racing against the Login 368\nThe Functionality 368\nThe Assumption 368\nThe Attack 368\nAvoiding Logic Flaws 370\nChapter Summary 372\nQuestions 372\nChapter 12 Attacking Other Users 375\nCross-Site Scripting 376\nReflected XSS Vulnerabilities 377\nExploiting the Vulnerability 379\nStored XSS Vulnerabilities 383\nStoring XSS in Uploaded Files 385\nDOM-Based XSS Vulnerabilities 386\nReal-World XSS Attacks 388\nChaining XSS and Other Attacks 390\nPayloads for XSS Attacks 391\nVirtual Defacement 391\nInjecting Trojan Functionality 392\nInducing User Actions 394\nExploiting Any Trust Relationships 394\nEscalating the Client-Side Attack 396\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xiii\nContents xiii\nDelivery Mechanisms for XSS Attacks 399\nDelivering Reflected and DOM-Based XSS Attacks 399\nDelivering Stored XSS Attacks 400\nFinding and Exploiting XSS Vulnerabilities 401\nFinding and Exploiting Reflected XSS Vulnerabilities 402\nFinding and Exploiting Stored XSS Vulnerabilities 415\nFinding and Exploiting DOM-Based XSS Vulnerabilities 417\nHttpOnly Cookies and Cross-Site Tracing 421\nPreventing XSS Attacks 423\nPreventing Reflected and Stored XSS 423\nPreventing DOM-Based XSS 427\nPreventing XST 428\nRedirection Attacks 428\nFinding and Exploiting Redirection Vulnerabilities 429\nCircumventing Obstacles to Attack 431\nPreventing Redirection Vulnerabilities 433\nHTTP Header Injection 434\nExploiting Header Injection Vulnerabilities 434\nInjecting Cookies 435\nDelivering Other Attacks 436\nHTTP Response Splitting 436\nPreventing Header Injection Vulnerabilities 438\nFrame Injection 438\nExploiting Frame Injection 439\nPreventing Frame Injection 440\nRequest Forgery 440\nOn-Site Request Forgery 441\nCross-Site Request Forgery 442\nExploiting XSRF Flaws 443\nPreventing XSRF Flaws 444\nJSON Hijacking 446\nJSON 446\nAttacks against JSON 447\nOverriding the Array Constructor 447\nImplementing a Callback Function 448\nFinding JSON Hijacking Vulnerabilities 449\nPreventing JSON Hijacking 450\nSession Fixation 450\nFinding and Exploiting Session Fixation Vulnerabilities 452\nPreventing Session Fixation Vulnerabilities 453\nAttacking ActiveX Controls 454\nFinding ActiveX Vulnerabilities 455\nPreventing ActiveX Vulnerabilities 456\nLocal Privacy Attacks 458\nPersistent Cookies 458\nCached Web Content 458\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xiv\nxiv Contents\nBrowsing History 459\nAutocomplete 460\nPreventing Local Privacy Attacks 460\nAdvanced Exploitation Techniques 461\nLeveraging Ajax 461\nMaking Asynchronous Off-Site Requests 463\nAnti-DNS Pinning 464\nA Hypothetical Attack 465\nDNS Pinning 466\nAttacks against DNS Pinning 466\nBrowser Exploitation Frameworks 467\nChapter Summary 469\nQuestions 469\nChapter 13 Automating Bespoke Attacks 471\nUses for Bespoke Automation 472\nEnumerating Valid Identifiers 473\nThe Basic Approach 474\nDetecting Hits 474\nHTTP Status Code 474\nResponse Length 475\nResponse Body 475\nLocation Header 475\nSet-cookie Header 475\nTime Delays 476\nScripting the Attack 476\nJAttack 477\nHarvesting Useful Data 484\nFuzzing for Common Vulnerabilities 487\nPutting It All Together: Burp Intruder 491\nPositioning Payloads 492\nChoosing Payloads 493\nConfiguring Response Analysis 494\nAttack 1: Enumerating Identifiers 495\nAttack 2: Harvesting Information 498\nAttack 3: Application Fuzzing 500\nChapter Summary 502\nQuestions 502\nChapter 14 Exploiting Information Disclosure 505\nExploiting Error Messages 505\nScript Error Messages 506\nStack Traces 507\nInformative Debug Messages 508\nServer and Database Messages 509\nUsing Public Information 511\nEngineering Informative Error Messages 512\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xv\nContents xv\nGathering Published Information 513\nUsing Inference 514\nPreventing Information Leakage 516\nUse Generic Error Messages 516\nProtect Sensitive Information 517\nMinimize Client-Side Information Leakage 517\nChapter Summary 518\nQuestions 518\nChapter 15 Attacking Compiled Applications 521\nBuffer Overflow Vulnerabilities 522\nStack Overflows 522\nHeap Overflows 523\n“Off-by-One” Vulnerabilities 524\nDetecting Buffer Overflow Vulnerabilities 527\nInteger Vulnerabilities 529\nInteger Overflows 529\nSignedness Errors 529\nDetecting Integer Vulnerabilities 530\nFormat String Vulnerabilities 531\nDetecting Format String Vulnerabilities 532\nChapter Summary 533\nQuestions 534\nChapter 16 Attacking Application Architecture 535\nTiered Architectures 535\nAttacking Tiered Architectures 536\nExploiting Trust Relationships between Tiers 537\nSubverting Other Tiers 538\nAttacking Other Tiers 539\nSecuring Tiered Architectures 540\nMinimize Trust Relationships 540\nSegregate Different Components 541\nApply Defense in Depth 542\nShared Hosting and Application Service Providers 542\nVirtual Hosting 543\nShared Application Services 543\nAttacking Shared Environments 544\nAttacks against Access Mechanisms 545\nAttacks between Applications 546\nSecuring Shared Environments 549\nSecure Customer Access 549\nSegregate Customer Functionality 550\nSegregate Components in a Shared Application 551\nChapter Summary 551\nQuestions 551\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xvi\nxvi Contents\nChapter 17 Attacking the Web Server 553\nVulnerable Web Server Configuration 553\nDefault Credentials 554\nDefault Content 555\nDebug Functionality 555\nSample Functionality 556\nPowerful Functions 557\nDirectory Listings 559\nDangerous HTTP Methods 560\nThe Web Server as a Proxy 562\nMisconfigured Virtual Hosting 564\nSecuring Web Server Configuration 565\nVulnerable Web Server Software 566\nBuffer Overflow Vulnerabilities 566\nMicrosoft IIS ISAPI Extensions 567\nApache Chunked Encoding Overflow 567\nMicrosoft IIS WebDav Overflow 567\niPlanet Search Overflow 567\nPath Traversal Vulnerabilities 568\nAccipiter DirectServer 568\nAlibaba 568\nCisco ACS Acme.server 568\nMcAfee EPolicy Orcestrator 568\nEncoding and Canonicalization Vulnerabilities 568\nAllaire JRun Directory Listing Vulnerability 569\nMicrosoft IIS Unicode Path Traversal Vulnerabilities 569\nOracle PL/SQL Exclusion List Bypasses 570\nFinding Web Server Flaws 571\nSecuring Web Server Software 572\nChoose Software with a Good Track Record 572\nApply Vendor Patches 572\nPerform Security Hardening 573\nMonitor for New Vulnerabilities 573\nUse Defense-in-Depth 573\nChapter Summary 574\nQuestions 574\nChapter 18 Finding Vulnerabilities in Source Code 577\nApproaches to Code Review 578\nBlack-Box vs. White-Box Testing 578\nCode Review Methodology 579\nSignatures of Common Vulnerabilities 580\nCross-Site Scripting 580\nSQL Injection 581\nPath Traversal 582\nArbitrary Redirection 583\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xvii\nContents xvii\nOS Command Injection 584\nBackdoor Passwords 584\nNative Software Bugs 585\nBuffer Overflow Vulnerabilities 585\nInteger Vulnerabilities 586\nFormat String Vulnerabilities 586\nSource Code Comments 586\nThe Java Platform 587\nIdentifying User-Supplied Data 587\nSession Interaction 589\nPotentially Dangerous APIs 589\nFile Access 589\nDatabase Access 590\nDynamic Code Execution 591\nOS Command Execution 591\nURL Redirection 592\nSockets 592\nConfiguring the Java Environment 593\nASP.NET 594\nIdentifying User-Supplied Data 594\nSession Interaction 595\nPotentially Dangerous APIs 596\nFile Access 596\nDatabase Access 597\nDynamic Code Execution 598\nOS Command Execution 598\nURL Redirection 599\nSockets 600\nConfiguring the ASP.NET Environment 600\nPHP 601\nIdentifying User-Supplied Data 601\nSession Interaction 603\nPotentially Dangerous APIs 604\nFile Access 604\nDatabase Access 606\nDynamic Code Execution 607\nOS Command Execution 607\nURL Redirection 608\nSockets 608\nConfiguring the PHP Environment 609\nRegister Globals 609\nSafe Mode 610\nMagic Quotes 610\nMiscellaneous 611\nPerl 611\nIdentifying User-Supplied Data 612\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xviii\nxviii Contents\nSession Interaction 613\nPotentially Dangerous APIs 613\nFile Access 613\nDatabase Access 613\nDynamic Code Execution 614\nOS Command Execution 614\nURL Redirection 615\nSockets 615\nConfiguring the Perl Environment 615\nJavaScript 616\nDatabase Code Components 617\nSQL Injection 617\nCalls to Dangerous Functions 618\nTools for Code Browsing 619\nChapter Summary 620\nQuestions 621\nChapter 19 A Web Application Hacker’s Toolkit 623\nWeb Browsers 624\nInternet Explorer 624\nFirefox 624\nOpera 626\nIntegrated Testing Suites 627\nHow the Tools Work 628\nIntercepting Proxies 628\nWeb Application Spiders 633\nApplication Fuzzers and Scanners 636\nManual Request Tools 637\nFeature Comparison 640\nBurp Suite 643\nParos 644\nWebScarab 645\nAlternatives to the Intercepting Proxy 646\nTamper Data 647\nTamperIE 647\nVulnerability Scanners 649\nVulnerabilities Detected by Scanners 649\nInherent Limitations of Scanners 651\nEvery Web Application Is Different 652\nScanners Operate on Syntax 652\nScanners Do Not Improvise 652\nScanners Are Not Intuitive 653\nTechnical Challenges Faced by Scanners 653\nAuthentication and Session Handling 653\nDangerous Effects 654\nIndividuating Functionality 655\nOther Challenges to Automation 655\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xix\nContents xix\nCurrent Products 656\nUsing a Vulnerability Scanner 658\nOther Tools 659\nNikto 660\nHydra 660\nCustom Scripts 661\nWget 662\nCurl 662\nNetcat 663\nStunnel 663\nChapter Summary 664\nChapter 20 A Web Application Hacker’s Methodology 665\nGeneral Guidelines 667\n1. Map the Application’s Content 669\n1.1. Explore Visible Content 669\n1.2. Consult Public Resources 670\n1.3. Discover Hidden Content 670\n1.4. Discover Default Content 671\n1.5. Enumerate Identifier-Specified Functions 671\n1.6. Test for Debug Parameters 672\n2. Analyze the Application 672\n2.1. Identify Functionality 673\n2.2. Identify Data Entry Points 673\n2.3. Identify the Technologies Used 673\n2.4. Map the Attack Surface 674\n3. Test Client-Side Controls 675\n3.1. Test Transmission of Data via the Client 675\n3.2. Test Client-Side Controls over User Input 676\n3.3. Test Thick-Client Components 677\n3.3.1. Test Java Applets 677\n3.3.2. Test ActiveX controls 678\n3.3.3. Test Shockwave Flash objects 678\n4. Test the Authentication Mechanism 679\n4.1. Understand the Mechanism 680\n4.2. Test Password Quality 680\n4.3. Test for Username Enumeration 680\n4.4. Test Resilience to Password Guessing 681\n4.5. Test Any Account Recovery Function 682\n4.6. Test Any Remember Me Function 682\n4.7. Test Any Impersonation Function 683\n4.8. Test Username Uniqueness 683\n4.9. Test Predictability of Auto-Generated Credentials 684\n4.10. Check for Unsafe Transmission of Credentials 684\n4.11. Check for Unsafe Distribution of Credentials 685\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xx\nxx Contents\n4.12. Test for Logic Flaws 685\n4.12.1. Test for Fail-Open Conditions 685\n4.12.2. Test Any Multistage Mechanisms 686\n4.13. Exploit Any Vulnerabilities to Gain Unauthorized Access 687\n5. Test the Session Management Mechanism 688\n5.1. Understand the Mechanism 689\n5.2. Test Tokens for Meaning 689\n5.3. Test Tokens for Predictability 690\n5.4. Check for Insecure Transmission of Tokens 691\n5.5. Check for Disclosure of Tokens in Logs 692\n5.6. Check Mapping of Tokens to Sessions 692\n5.7. Test Session Termination 693\n5.8. Check for Session Fixation 694\n5.9. Check for XSRF 694\n5.10. Check Cookie Scope 695\n6. Test Access Controls 696\n6.1. Understand the Access Control Requirements 696\n6.2. Testing with Multiple Accounts 697\n6.3. Testing with Limited Access 697\n6.4. Test for Insecure Access Control Methods 698\n7. Test for Input-Based Vulnerabilities 699\n7.1. Fuzz All Request Parameters 699\n7.2. Test for SQL Injection 702\n7.3. Test for XSS and Other Response Injection 704\n7.3.1. Identify Reflected Request Parameters 704\n7.3.2. Test for Reflected XSS 705\n7.3.3. Test for HTTP Header Injection 705\n7.3.4. Test for Arbitrary Redirection 706\n7.3.5. Test for Stored Attacks 706\n7.4. Test for OS Command Injection 707\n7.5. Test for Path Traversal 709\n7.6. Test for Script Injection 711\n7.7. Test for File Inclusion 711\n8. Test for Function-Specific Input Vulnerabilities 712\n8.1. Test for SMTP Injection 712\n8.2. Test for Native Software Vulnerabilities 713\n8.2.1. Test for Buffer Overflows 713\n8.2.2. Test for Integer Vulnerabilities 714\n8.2.3. Test for Format String Vulnerabilities 714\n8.3. Test for SOAP Injection 715\n8.4. Test for LDAP Injection 715\n8.5. Test for XPath Injection 716\n9. Test for Logic Flaws 717\n9.1. Identify the Key Attack Surface 717\n9.2. Test Multistage Processes 718\n9.3. Test Handling of Incomplete Input 718\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xxi\nContents xxi\n9.4. Test Trust Boundaries 719\n9.5. Test Transaction Logic 719\n10. Test for Shared Hosting Vulnerabilities 720\n10.1. Test Segregation in Shared Infrastructures 720\n10.2. Test Segregation between ASP-Hosted Applications 721\n11. Test for Web Server Vulnerabilities 721\n11.1. Test for Default Credentials 722\n11.2. Test for Default Content 722\n11.3. Test for Dangerous HTTP Methods 722\n11.4. Test for Proxy Functionality 723\n11.5. Test for Virtual Hosting Misconfiguration 723\n11.6. Test for Web Server Software Bugs 723\n12. Miscellaneous Checks 724\n12.1. Check for DOM-Based Attacks 724\n12.2. Check for Frame Injection 725\n12.3. Check for Local Privacy Vulnerabilities 726\n12.4. Follow Up Any Information Leakage 726\n12.5. Check for Weak SSL Ciphers 727\nIndex 729\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xxii\n70779flast.qxd:WileyRed 9/14/07 3:12 PM Page xxiii\nAcknowledgments\nOur primary debt is to the directors and our other colleagues at Next Genera-\ntion Security Software, who have provided a creative working environment,\npromoted sharing of knowledge, and supported us during the months spent\nproducing this book. In particular, we received direct assistance from Chris\nAnley, Dave Armstrong, Dominic Beecher, David Litchfield, Adam Matthews,\nDave Spencer, and Peter Winter-Smith.\nIn addition to our immediate colleagues, we are greatly indebted to the\nwider community of researchers who have shared their ideas and contributed\nto the collective understanding of web application security issues that exists\ntoday. Because this is a practical handbook rather than a work of scholarship,\nwe deliberately avoided filling it with a thousand citations of influential arti-\ncles, books, and blog postings which spawned the ideas involved. We hope\nthat people whose work we discuss anonymously are content with the general\ncredit given here.\nWe are grateful to the people at Wiley, in particular to Carol Long for enthusi-\nastically supporting our project from the outset, to Adaobi Obi Tulton for helping\nto polish our manuscript and coaching us in the quirks of “American English,”\nand to Christine O’Connor’s team for delivering a first-rate production.\nA large measure of thanks is due to our respective partners, Becky and\nSusan, for tolerating the significant distraction and time involved in producing\na book of this size.\nBoth authors are indebted to the people who led us into our unusual line of\nwork. Dafydd would like to thank Martin Law. Martin is a great guy who first\ntaught me how to hack, and encouraged me to spend my time developing tech-\nniques and tools for attacking applications. Marcus would like to thank his par-\nents for a great many things, a significant one being getting me into computers.\nI’ve been getting into computers ever since.\nxxiii\n70779flast.qxd:WileyRed 9/14/07 3:12 PM Page xxiv\n70779flast.qxd:WileyRed 9/14/07 3:12 PM Page xxv\nIntroduction\nThis book is a practical guide to discovering and exploiting security flaws in\nweb applications. By “web application” we mean an application that is accessed\nby using a web browser to communicate with a web server. We examine a wide\nvariety of different technologies, such as databases, file systems, and web ser-\nvices, but only in the context in which these are employed by web applications.\nIf you want to learn how to run port scans, attack firewalls, or break into\nservers in other ways, we suggest you look elsewhere. But if you want to know\nhow to hack into a web application, steal sensitive data, and perform unau-\nthorized actions, then this is the book for you. There is enough that is interest-\ning and fun to say on that subject without straying into any other territory.\nOverview of This Book\nThe focus of this book is highly practical. While we include sufficient back-\nground and theory for you to understand the vulnerabilities that web applica-\ntions contain, our primary concern is with the tasks and techniques that you\nneed to master in order to break into them. Throughout the book, we spell out\nthe specific steps that you need to take to detect each type of vulnerability, and\nhow to exploit it to perform unauthorized actions. We also include a wealth of\nreal-world examples, derived from the authors’ many years of experience, illus-\ntrating how different kinds of security flaw manifest themselves in today’s web\napplications.\nSecurity awareness is usually a two-edged sword. Just as application devel-\nopers can benefit from understanding the methods used by attackers, hackers\nxxv\n70779flast.qxd:WileyRed 9/14/07 3:12 PM Page xxvi\nxxvi Introduction\ncan gain from knowing how applications can effectively defend themselves. In\naddition to describing security vulnerabilities and attack techniques, we also\ndescribe in detail the countermeasures that applications can take to thwart an\nattacker. For those of you who perform penetration tests of web applications,\nthis will enable you to provide high-quality remediation advice to the owners\nof the applications you compromise.\nWho Should Read This Book\nThe primary audience for this book is anyone with a personal or professional\ninterest in attacking web applications. It is also aimed at anyone responsible\nfor developing and administering web applications—knowing how your\nenemy operates will help you to defend against them.\nWe assume that the reader is familiar with core security concepts, such as\nlogins and access controls, and has a basic grasp of core web technologies,\nsuch as browsers, web servers, and HTTP. However, any gaps in your current\nknowledge of these areas will be easy to remedy, through either the explana-\ntions contained within this book or references elsewhere.\nIn the course of illustrating many categories of security flaws, we provide\ncode extracts showing how applications can be vulnerable. These examples\nare simple enough to be understood without any prior knowledge of the lan-\nguage in question but will be most useful if you have some basic experience of\nreading or writing code.\nHow This Book Is Organized\nThis book is organized roughly in line with the dependencies between the dif-\nferent topics covered. If you are new to web application hacking, you should\nread the book through from start to finish, acquiring the knowledge and under-\nstanding you need to tackle later chapters. If you already have some experience\nin this area, you can jump straight into any chapter or subsection that particu-\nlarly interests you. Where necessary, we have included cross-references to other\nchapters, which you can use to fill in any gaps in your understanding.\nWe begin with three context-setting chapters describing the current state of\nweb application security and the trends that indicate how it is likely to evolve\nin the near future. We examine the core security problem affecting web appli-\ncations and the defense mechanisms that applications implement to address\nthis problem. We also provide a primer in the key technologies used in today’s\nweb applications.\nThe bulk of the book is concerned with our core topic—the techniques that\nyou can use to break into web applications. This material is organized around\n70779flast.qxd:WileyRed 9/14/07 3:12 PM Page xxvii\nIntroduction xxvii\nthe key tasks that you need to perform to carry out a comprehensive attack:\nfrom mapping the application’s functionality, scrutinizing and attacking its\ncore defense mechanisms, to probing for specific categories of security flaws.\nThe book concludes with three chapters that pull together the various\nstrands introduced within the book. We describe the process of finding vul-\nnerabilities in an application’s source code, review the tools that can assist you\nwhen hacking web applications, and present a detailed methodology for per-\nforming a comprehensive and deep attack against a specific target.\nChapter 1, “Web Application (In)security,” describes the current state of\nsecurity in web applications on the Internet today. Despite common assur-\nances, the majority of applications are insecure and can be compromised in\nsome way with a modest degree of skill. Vulnerabilities in web applications\narise because of a single core problem: users can submit arbitrary input. In this\nchapter, we examine the key factors that contribute to the weak security pos-\nture of today’s applications, and describe how defects in web applications can\nleave an organization’s wider technical infrastructure highly vulnerable to\nattack.\nChapter 2, “Core Defense Mechanisms,” describes the key security mecha-\nnisms that web applications employ to address the fundamental problem that\nall user input is untrusted. These mechanisms are the means by which an\napplication manages user access, handles user input, and responds to attack-\ners, and the functions provided for administrators to manage and monitor the\napplication itself. The application’s core security mechanisms also represent\nits primary attack surface, and you need to understand how these mechanisms\nare intended to function before you can effectively attack them.\nChapter 3, “Web Application Technologies,” provides a short primer on the\nkey technologies that you are likely to encounter when attacking web applica-\ntions. This covers all relevant aspects of the HTTP protocol, the technologies\ncommonly used on the client and server sides, and various schemes used for\nencoding data. If you are already familiar with the main web technologies,\nthen you can quickly skim through this chapter.\nChapter 4, “Mapping the Application,” describes the first exercise that you\nneed to take when targeting a new application, which is to gather as much\ninformation as possible about it, in order to map its attack surface and formu-\nlate your plan of attack. This process includes exploring and probing the appli-\ncation to catalogue all of its content and functionality, identifying all of the\nentry points for user input and discovering the technologies in use.\nChapter 5, “Bypassing Client-Side Controls,” describes the first area of\nactual vulnerability, which arises when an application relies upon controls\nimplemented on the client side for its security. This approach is normally\nflawed, because any client-side controls can, of course, be circumvented. The\ntwo main ways in which applications make themselves vulnerable are (a) to\ntransmit data via the client in the assumption that this will not be modified,\n70779flast.qxd:WileyRed 9/14/07 3:12 PM Page xxviii\nxxviii Introduction\nand (b) to rely upon client-side checks on user input. In this chapter, we exam-\nine a range of interesting technologies, including lightweight controls imple-\nmented within HTML, HTTP, and JavaScript, and more heavyweight controls\nusing Java applets, ActiveX controls, and Shockwave Flash objects.\nChapters 6 to 8 examine some of the most important defense mechanisms\nimplemented within web applications: those responsible for controlling user\naccess. Chapter 6, “Attacking Authentication,” examines the various functions\nby which applications gain assurance of the identity of their users. This\nincludes the main login function and also the more peripheral authentication-\nrelated functions such as user registration, password changing, and account\nrecovery. Authentication mechanisms contain a wealth of different vulnerabil-\nities, in both design and implementation, which an attacker can leverage to\ngain unauthorized access. These range from obvious defects, such as bad pass-\nwords and susceptibility to brute-force attacks, to more obscure problems\nwithin the authentication logic. We also examine in detail the type of multi-\nstage login mechanisms used in many security-critical applications, and\ndescribe the new kinds of vulnerability which these frequently contain.\nChapter 7, “Attacking Session Management,” examines the mechanism by\nwhich most applications supplement the stateless HTTP protocol with the con-\ncept of a stateful session, enabling them to uniquely identify each user across\nseveral different requests. This mechanism is a key target when you are attack-\ning a web application, because if you can break it, then you can effectively\nbypass the login and masquerade as other users without knowing their cre-\ndentials. We look at various common defects in the generation and transmis-\nsion of session tokens, and describe the steps you can take to discover and\nexploit these.\nChapter 8, “Attacking Access Controls,” examines the ways in which appli-\ncations actually enforce access controls, relying upon the authentication and\nsession management mechanisms to do so. We describe various ways in which\naccess controls can be broken and the ways in which you can detect and\nexploit these weaknesses.\nChapter 9, “Injecting Code,” covers a large category of related vulnerabili-\nties, which arise when applications embed user input into interpreted code in\nan unsafe way. We begin with a detailed examination of SQL injection vulner-\nabilities, covering the full range of attacks from the most obvious and trivial to\nadvanced exploitation techniques involving out-of-band channels, inference,\nand time delays. For each kind of vulnerability and attack technique, we\ndescribe the relevant differences between three common types of databases:\nMS-SQL, Oracle, and MySQL. We then cover several other categories of injec-\ntion vulnerability, including the injection of operating system commands,\ninjection into web scripting languages, and injection into the SOAP, XPath,\nSMTP, and LDAP protocols.\n70779flast.qxd:WileyRed 9/14/07 3:12 PM Page xxix\nIntroduction xxix\nChapter 10, “Exploiting Path Traversal,” examines a small but important\ncategory of vulnerabilities that arise when user input is passed to file system\nAPIs in an unsafe way, enabling an attacker to retrieve or modify arbitrary\nfiles on the web server. We describe various bypasses that may be effective\nagainst the defenses commonly implemented to prevent path traversal\nattacks.\nChapter 11, “Attacking Application Logic,” examines a significant, and fre-\nquently overlooked, area of every application’s attack surface: the internal\nlogic which it carries out to implement its functionality. Defects in an applica-\ntion’s logic are extremely varied and are harder to characterize than common\nvulnerabilities like SQL injection and cross-site scripting. For this reason, we\npresent a series of real-world examples where defective logic has left an appli-\ncation vulnerable, and thereby illustrate the variety of faulty assumptions\nmade by application designers and developers. From these different individ-\nual flaws, we w derive a series of specific tests that you can perform to locate\nmany types of logic flaws that often go undetected.\nChapter 12, “Attacking Other Users,” covers a large and very topical area of\nrelated vulnerabilities which arise when defects within a web application can\nenable a malicious user of the application to attack other users and compro-\nmise them in various ways. The largest vulnerability of this kind is cross-site\nscripting, a hugely prevalent flaw affecting the vast majority of web applica-\ntions on the Internet. We examine in detail all of the different flavors of XSS\nvulnerabilities, and describe an effective methodology for detecting and\nexploiting even the most obscure manifestations of these. We then look at sev-\neral other types of attacks against other users, including redirection attacks,\nHTTP header injection, frame injection, cross-site request forgery, session fixa-\ntion, exploiting bugs in ActiveX controls, and local privacy attacks.\nChapter 13, “Automating Bespoke Attacks,” does not introduce any new\ncategories of vulnerability, but instead, describes a crucial technique which\nyou need to master to attack web applications effectively. Because every web\napplication is different, most attacks are bespoke (or custom-made) in some\nway, tailored to the application’s specific behavior and the ways you have dis-\ncovered to manipulate it to your advantage. They also frequently require issu-\ning a large number of similar requests and monitoring the application’s\nresponses. Performing these requests manually is extremely laborious and one\nis prone to make mistakes. To become a truly accomplished web application\nhacker, you need to automate as much of this work as possible, to make your\nbespoke attacks easier, faster, and more effective. In this chapter, we describe\nin detail a proven methodology for achieving this.\nChapter 14, “Exploiting Information Disclosure,” examines various ways in\nwhich applications leak information when under active attack. When you are\nperforming all of the other types of attacks described in this book, you should\nalways monitor the application to identify further sources of information\n70779flast.qxd:WileyRed 9/14/07 3:12 PM Page xxx\nxxx Introduction\ndisclosure that you can exploit. We describe how you can investigate anom-\nalous behavior and error messages to gain a deeper understanding of the\napplication’s internal workings and fine-tune your attack. We also cover ways\nof manipulating defective error handling to systematically retrieve sensitive\ninformation from the application.\nChapter 15, “Attacking Compiled Applications,” examines a set of impor-\ntant vulnerabilities which arise in applications written in native code lan-\nguages like C and C++. These vulnerabilities include buffer overflows, integer\nvulnerabilities, and format string flaws. This is a potentially huge topic, and\nwe focus on ways of detecting these vulnerabilities in web applications, and\nlook at some real-world examples of how these have arisen and been\nexploited.\nChapter 16, “Attacking Application Architecture,” examines an important\narea of web application security that is frequently overlooked. Many applica-\ntions employ a tiered architecture, and a failure to segregate different tiers\nproperly often leaves an application vulnerable, enabling an attacker who has\nfound a defect in one component to quickly compromise the entire applica-\ntion. A different range of threats arises in shared hosting environments, where\ndefects or malicious code in one application can sometimes be exploited to\ncompromise the environment itself and other applications running within it.\nChapter 17, “Attacking the Web Server,” describes various ways in which\nyou can target a web application by targeting the web server on which it is\nrunning. Vulnerabilities in web servers are broadly composed of defects in\ntheir configuration and security flaws within the web server software. This\ntopic is on the boundary of the scope of this book, because the web server is\nstrictly a different component in the technology stack. However, most web\napplications are intimately bound up with the web server on which they run;\ntherefore, attacks against the web server are included in the book because they\ncan often be used to compromise an application directly, rather than indirectly\nby first compromising the underlying host.\nChapter 18, “Finding Vulnerabilities in Source Code,” describes a com-\npletely different approach to finding security flaws than those described else-\nwhere within this book. There are many situations in which it may be possible\nto perform a review of an application’s source code, not all of which require\nany cooperation from the application’s owner. Reviewing an application’s\nsource code can often be highly effective in discovering vulnerabilities that\nwould be difficult or time-consuming to detect by probing the running appli-\ncation. We describe a methodology, and provide a language-by-language cheat\nsheet, to enable you to perform an effective code review even if you have very\nlimited programming experience yourself.\nChapter 19, “A Web Application Hacker’s Toolkit,” pulls together in one place\nthe various tools described in the course of this book, and which the authors use\nwhen attacking real-world web applications. We describe the strengths and\n70779flast.qxd:WileyRed 9/14/07 3:12 PM Page xxxi\nIntroduction xxxi\nweaknesses of different tools, explain the extent to which any fully automated\ntool can be effective in finding web application vulnerabilities, and provide\nsome tips and advice for getting the most out of your toolkit.\nChapter 20, “A Web Application Hacker’s Methodology,” contains a com-\nprehensive and structured collation of all the procedures and techniques\ndescribed in this book. These are organized and ordered according to the logi-\ncal dependencies between tasks when you are carrying out an actual attack. If\nyou have read and understood all of the vulnerabilities and techniques\ndescribed in this book, you can use this methodology as a complete checklist\nand work plan when carrying out an attack against a web application.\nTools You Will Need\nThis book is strongly geared towards the hands-on techniques that you can use\nto attack web applications. After reading the book, you will understand the\nspecifics of each individual task, what it involves technically, and why it works\nin helping you detect and exploit vulnerabilities. The book is emphatically not\nabout downloading some tool, pointing it at a target application, and believing\nwhat the tool’s output tells you about the state of the application’s security.\nThat said, there are several tools which you will find useful, and sometimes\nindispensable, when performing the tasks and techniques that we describe. All\nof these are easily available on the Internet, and we recommended that you\ndownload and experiment with each tool at the point where it appears in the\ncourse of the book.\nWhat's on the Web Site\nThe companion web site for this book at www.wiley.com/go/webhacker con-\ntains several resources that you will find useful in the course of mastering the\ntechniques we describe and using them to attack actual applications. In partic-\nular, the web site contains the following:\n■■ Source code to some of the scripts we present in the book.\n■■ A list of current links to all of the tools and other resources discussed in\nthe book.\n■■ A handy checklist of the tasks involved in attacking a typical application.\n■■ Answers to the questions posed at the end of each chapter.\n■■ A hacking challenge containing many of the vulnerabilities described in\nthe book.\n70779flast.qxd:WileyRed 9/14/07 3:12 PM Page xxxii\nxxxii Introduction\nBring It On\nWeb application security is a fun and thriving subject. We enjoyed writing this\nbook as much as we continue to enjoy hacking into web applications on a daily\nbasis. We hope that you will also take pleasure from learning about the differ-\nent techniques we describe and how these can be defended against.\nBefore going any further, we should mention an important caveat. In most\ncountries, attacking computer systems without the owner’s permission is\nagainst the law. The majority of the techniques we describe are illegal if carried\nout without consent.\nThe authors are professional penetration testers who routinely attack web\napplications on behalf of clients, to help them improve their security. In recent\nyears, numerous security professionals and others have acquired criminal\nrecords, and ended their careers, by experimenting on or actively attacking\ncomputer systems without permission. We urge you to use the information\ncontained in this book only for lawful purposes.\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 1\nCHAPTER\n1\nWeb Application (In)security\nThere is no doubt that web application security is a current and very news-\nworthy subject. For all concerned, the stakes are high: for businesses that\nderive increasing revenue from Internet commerce, for users who trust web\napplications with sensitive information, and for criminals who can make big\nmoney by stealing payment details or compromising bank accounts. Reputa-\ntion plays a critical role: few people want to do business with an insecure web\nsite, and so few organizations want to disclose details about their own security\nvulnerabilities or breaches. Hence, it is not trivial to obtain reliable informa-\ntion about the state of web application security today.\nThis chapter takes a brief look at how web applications have evolved and the\nmany benefits they provide. We present some metrics about vulnerabilities in\ncurrent web applications, drawn from the authors’ direct experience, demon-\nstrating that the majority of applications are far from secure. We describe the\ncore security problem facing web applications—that users can supply arbi-\ntrary input—and the various factors that contribute to their weak security pos-\nture. Finally, we describe the latest trends in web application security and the\nways in which these may be expected to develop in the near future.\n1\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 2\n2 Chapter 1 ■ Web Application (In)security\nThe Evolution of Web Applications\nIn the early days of the Internet, the World Wide Web consisted only of web sites.\nThese were essentially information repositories containing static documents,\nand web browsers were invented as a means of retrieving and displaying those\ndocuments, as shown in Figure1-1. The flow of interesting information was one-\nway, from server to browser. Most sites did not authenticate users, because there\nwas no need to—each user was treated in the same way and presented with the\nsame information. Any security threats arising from hosting a web site related\nlargely to vulnerabilities in web server software (of which there were many). If\nan attacker compromised a web server, he would not normally gain access to\nany sensitive information, because the information held on the server was\nalready open to public view. Rather, an attacker would typically modify the files\non the server to deface the web site’s contents, or use the server’s storage and\nbandwidth to distribute “warez.”\nFigure 1-1: A traditional web site containing static information\nToday, the World Wide Web is almost unrecognizable from its earlier form.\nThe majority of sites on the web are in fact applications (see Figure1-2). They\nare highly functional, and rely upon two-way flow of information between the\nserver and browser. They support registration and login, financial transactions,\nsearch, and the authoring of content by users. The content presented to users is\ngenerated dynamically on the fly, and is often tailored to each specific user.\nMuch of the information processed is private and highly sensitive. Security is\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 3\nChapter 1 ■ Web Application (In)security 3\ntherefore a big issue: no one wants to use a web application if they believe their\ninformation will be disclosed to unauthorized parties.\nWeb applications bring with them new and significant security threats. Each\napplication is different and may contain unique vulnerabilities. Most applica-\ntions are developed in-house, and many by developers who have little under-\nstanding of the security problems that may arise in the code they are\nproducing. To deliver their core functionality, web applications normally\nrequire connectivity to internal computer systems that contain highly sensitive\ndata and are able to perform powerful business functions. Ten years ago, if you\nwanted to make a funds transfer, you visited your bank and someone per-\nformed it for you; today, you can visit their web application and perform it\nyourself. An attacker who compromises a web application may be able to steal\npersonal information, carry out financial fraud, and perform malicious actions\nagainst other users.\nFigure 1-2 A typical web application\nCommon Web Application Functions\nWeb applications have been created to perform practically every useful func-\ntion one could possibly implement online. Examples of web application func-\ntions that have risen to prominence in recent years include:\n■■ Shopping (Amazon)\n■■ Social networking (MySpace)\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 4\n4 Chapter 1 ■ Web Application (In)security\n■■ Banking (Citibank)\n■■ Web search (Google)\n■■ Auctions (eBay)\n■■ Gambling (Betfair)\n■■ Web logs (Blogger)\n■■ Web mail (Hotmail)\n■■ Interactive information (Wikipedia)\nIn addition to the public Internet, web applications have been widely\nadopted inside organizations to perform key business functions, including\naccessing HR services and managing company resources. They are also fre-\nquently used to provide an administrative interface to hardware devices such\nas printers, and other software such as web servers and intrusion detection\nsystems.\nNumerous applications that predated the rise of web applications have been\nmigrated to this technology. Business applications like enterprise resource\nplanning (ERP) software, which were previously accessed using a proprietary\nthick-client application, can now be accessed using a web browser. Software\nservices such as email, which originally required a separate email client, can\nnow be accessed via web interfaces like Outlook Web Access. This trend is con-\ntinuing as traditional desktop office applications such as word processors and\nspreadsheets are migrated to web applications, through services like Google\nApps and Microsoft Office Live.\nThe time is fast approaching when the only client software that most com-\nputer users will need is a web browser. A hugely diverse range of functions\nwill have been implemented using a shared set of protocols and technologies,\nand in so doing will have inherited a distinctive range of common security\nvulnerabilities.\nBenefits of Web Applications\nIt is not difficult to see why web applications have enjoyed such a dramatic\nrise to prominence. Several technical factors have worked alongside the obvi-\nous commercial incentives to drive the revolution that has occurred in the way\nwe use the Internet:\n■■ HTTP, the core communications protocol used to access the World Wide\nWeb, is lightweight and connectionless. This provides resilience in the\nevent of communication errors and avoids the need for the server to\nhold open a network connection to every user as was the case in many\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 5\nChapter 1 ■ Web Application (In)security 5\nlegacy client-server applications. HTTP can also be proxied and tun-\nneled over other protocols, allowing for secure communication in any\nnetwork configuration.\n■■ Every web user already has a browser installed on their computer.\nWeb applications deploy their user interface dynamically to the\nbrowser, avoiding the need to distribute and manage separate client\nsoftware, as was the case with pre-web applications. Changes to the\ninterface only need to be implemented once, on the server, and take\neffect immediately.\n■■ Today’s browsers are highly functional, enabling rich and satisfying\nuser interfaces to be built. Web interfaces use standard navigational and\ninput controls that are immediately familiar to users, avoiding the need\nto learn how each individual application functions. Client-side scripting\nenables applications to push part of their processing to the client side,\nand browsers’ capabilities can be extended in arbitrary ways using\nthick-client components where necessary.\n■■ The core technologies and languages used to develop web applications\nare relatively simple. A wide range of platforms and development tools\nare available to facilitate the development of powerful applications by\nrelative beginners, and a large quantity of open source code and other\nresources is available for incorporation into custom-built applications.\nWeb Application Security\nAs with any new class of technology, web applications have brought with\nthem a new range of security vulnerabilities. The set of most commonly\nencountered defects has evolved somewhat over time. New attacks have been\nconceived that were not considered when existing applications were devel-\noped. Some problems have become less prevalent as awareness of them has\nincreased. New technologies have been developed that have introduced new\npossibilities for exploitation. Some categories of flaws have largely gone away\nas the result of changes made to web browser software.\nThroughout this evolution, compromises of prominent web applications\nhave remained in the news, and there is no sense that a corner has been turned\nand that these security problems are on the wane. Arguably, web application\nsecurity is today the most significant battleground between attackers and\nthose with computer resources and data to defend, and it is likely to remain so\nfor the foreseeable future.\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 6\n6 Chapter 1 ■ Web Application (In)security\n“This Site Is Secure”\nThere is a widespread awareness that security is an “issue” for web applica-\ntions. Consult the FAQ page of a typical application, and you will be reassured\nthat it is in fact secure. For example:\nThis site is absolutely secure. It has been designed to use 128-bit Secure Socket\nLayer (SSL) technology to prevent unauthorized users from viewing any of your\ninformation. You may use this site with peace of mind that your data is safe with us.\nIn virtually every case, web applications state that they are secure because\nthey use SSL. Users are often urged to verify the site’s certificate, admire the\nadvanced cryptographic protocols in use, and on this basis, trust it with their\npersonal information.\nIn fact, the majority of web applications are insecure, and in ways that have\nnothing to do with SSL. The authors of this book have tested hundreds of web\napplications in recent years. Figure 1-3 shows the proportions of those appli-\ncations tested during 2006 and 2007 that were found to be affected by some\ncommon categories of vulnerability. These are explained briefly below:\n■■ Broken authentication (67%) — This category of vulnerability encom-\npasses various defects within the application’s login mechanism, which\nmay enable an attacker to guess weak passwords, launch a brute-force\nattack, or bypass the login altogether.\n■■ Broken access controls (78%) — This involves cases where the appli-\ncation fails to properly protect access to its data and functionality,\npotentially enabling an attacker to view other users’ sensitive data held\non the server, or carry out privileged actions.\n■■ SQL injection (36%) — This vulnerability enables an attacker to sub-\nmit crafted input to interfere with the application’s interaction with\nback-end databases. An attacker may be able to retrieve arbitrary data\nfrom the application, interfere with its logic, or execute commands on\nthe database server itself.\n■■ Cross-site scripting (91%) — This vulnerability enables an attacker to\ntarget other users of the application, potentially gaining access to their\ndata, performing unauthorized actions on their behalf, or carrying out\nother attacks against them.\n■■ Information leakage (81%) — This involves cases where an applica-\ntion divulges sensitive information that is of use to an attacker in devel-\noping an assault against the application, through defective error\nhandling or other behavior.\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 7\nChapter 1 ■ Web Application (In)security 7\nBroken authentication 67%\nBroken access controls 78%\nSQL injection 36%\nCross-site scripting 91%\nInformation leakage 81%\n0% 10% 20% 30% 40% 50% 60% 70% 80% 90% 100%\nIncidence in recently tested applications\nFigure 1-3 The incidence of some common web application vulnerabilities in\napplications recently tested by the authors (based on a sample of more than 100)\nSSL is an excellent technology that protects the confidentiality and integrity\nof data in transit between the user’s browser and the web server. It helps to\ndefend against eavesdroppers, and it can provide assurance to the user of the\nidentity of the web server they are dealing with. But it does not stop attacks\nthat directly target the server or client components of an application, as most\nsuccessful attacks do. Specifically, it does not prevent any of the vulnerabilities\nlisted previously, or many others that can render an application critically\nexposed to attack. Regardless of whether or not they use SSL, most web appli-\ncations still contain security flaws.\nNOTE Although SSL has nothing to do with the majority of web application\nvulnerabilities, do not infer that it is unnecessary to an application’s security.\nProperly used, SSL provides an effective defense against several important\nattacks. An occasional mistake by developers is to eschew industry-standard\ncryptography in favor of a home-grown solution, which as a rule is more\nexpensive and less effective. Consider the following (actual) FAQ answer, which\nrings even louder alarm bells than the orthodox wisdom described previously:\nThis site is secure. For your safety (and our peace of mind) we do not use\n“standard” security procedures such as SSL but proprietary protocols which we\nwon’t disclose in detail here but permit immediate transfer of any data you\nsubmit to a completely secure location. In other words the data never stays on\na server “floating in cyberspace,” which allows us to keep potential\nmalfeasants in the dark.\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 8\n8 Chapter 1 ■ Web Application (In)security\nThe Core Security Problem:\nUsers Can Submit Arbitrary Input\nAs with most distributed applications, web applications face a fundamental\nproblem which they must address in order to be secure. Because the client is\noutside of the application’s control, users can submit completely arbitrary\ninput to the server-side application. The application must assume that all input\nis potentially malicious, and must take steps to ensure that attackers cannot use\ncrafted input to compromise the application by interfering with its logic and\nbehavior and gaining unauthorized access to its data and functionality.\nThis core problem manifests itself in various ways:\n■■ Users can interfere with any piece of data transmitted between the\nclient and the server, including request parameters, cookies, and HTTP\nheaders. Any security controls implemented on the client side, such as\ninput validation checks, can be easily circumvented.\n■■ Users can send requests in any sequence, and can submit parameters at\na different stage than the application expects, more than once, or not at\nall. Any assumption which developers make about how users will\ninteract with the application may be violated.\n■■ Users are not restricted to using only a web browser to access the appli-\ncation. There are numerous widely available tools that operate along-\nside, or independently of, a browser, to help attack web applications.\nThese tools can make requests that no browser would ordinarily make,\nand can generate huge numbers of requests quickly to find and exploit\nproblems.\nThe majority of attacks against web applications involve sending input to\nthe server which is crafted to cause some event that was not expected or\ndesired by the application’s designer. Some examples of submitting crafted\ninput to achieve this objective are as follows:\n■■ Changing the price of a product transmitted in a hidden HTML form\nfield, to fraudulently purchase the product for a cheaper amount.\n■■ Modifying a session token transmitted in an HTTP cookie, to hijack the\nsession of another authenticated user.\n■■ Removing certain parameters that are normally submitted, to exploit a\nlogic flaw in the application’s processing.\n■■ Altering some input that will be processed by a back-end database, to\ninject a malicious database query and so access sensitive data.\nNeedless to say, SSL does nothing to stop an attacker from submitting\ncrafted input to the server. If the application uses SSL, this simply means that\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 9\nChapter 1 ■ Web Application (In)security 9\nother users on the network cannot view or modify the attacker’s data in tran-\nsit. Because the attacker controls her end of the SSL tunnel, she can send any-\nthing she likes to the server through this tunnel. If any of the previously\nmentioned attacks are successful, then the application is emphatically vulner-\nable, regardless of what its FAQ may tell you.\nKey Problem Factors\nThe core security problem faced by web applications arises in any situation\nwhere an application must accept and process untrusted data that may be\nmalicious. However, in the case of web applications, there are several factors\nwhich have combined to exacerbate the problem, and which explain why\nso many web applications on the Internet today do such a poor job of address-\ning it.\nImmature Security Awareness\nThere is a less mature level of awareness of web application security issues\nthan there is in longer-established areas such as networks and operating sys-\ntems. While most people working in IT security have a reasonable grasp of the\nessentials of securing networks and hardening hosts, there is still widespread\nconfusion and misconception about many of the core concepts involved in\nweb application security. It is common to meet experienced web application\ndevelopers to whom an explanation of many basic types of flaws comes as a\ncomplete revelation.\nIn-House Development\nMost web applications are developed in-house by an organization’s own staff\nor contractors. Even where an application employs third-party components,\nthese are typically customized or bolted together using new code. In this situ-\nation, every application is different and may contain its own unique defects.\nThis stands in contrast to a typical infrastructure deployment in which an\norganization can purchase a best-of-breed product and install it in line with\nindustry-standard guidelines.\nDeceptive Simplicity\nWith today’s web application platforms and development tools, it is possible\nfor a novice programmer to create a powerful application from scratch in a\nshort period of time. But there is a huge difference between producing code\nthat is functional and code that is secure. Many web applications are created\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 10\n10 Chapter 1 ■ Web Application (In)security\nby well-meaning individuals who simply lack the knowledge and experience\nto identify where security problems may arise.\nRapidly Evolving Threat Profile\nAs a result of its relative immaturity, research into web application attacks and\ndefenses is a thriving area in which new concepts and threats are conceived at\na faster rate than is now the case for older technologies. A development team\nthat begins a project with a complete knowledge of current threats may well\nhave lost this status by the time the application is completed and deployed.\nResource and Time Constraints\nMost web application development projects are subject to strict constraints on\ntime and resources, arising from the economics of in-house, one-off develop-\nment. It is not usually possible to employ dedicated security expertise in the\ndesign or development teams, and due to project slippage security testing by\nspecialists is often left until very late in the project’s lifecycle. In the balancing\nof competing priorities, the need to produce a stable and functional applica-\ntion by a deadline normally overrides less tangible security considerations. A\ntypical small organization may be willing to pay for only a few man-days of\nconsulting time to evaluate a new application. A quick penetration test will\noften find the low-hanging fruit, but it may miss more subtle vulnerabilities\nthat require time and patience to identify.\nOverextended Technologies\nMany of the core technologies employed in web applications began life when\nthe landscape of the World Wide Web was very different, and have since been\npushed far beyond the purposes for which they were originally conceived—\nfor example, the use of JavaScript as a means of data transmission in many\nAJAX-based applications. As the expectations placed on web application func-\ntionality have rapidly evolved, the technologies used to implement this func-\ntionality have lagged behind the curve, with old technologies stretched and\nadapted to meet new requirements. Unsurprisingly, this has led to security\nvulnerabilities as unforeseen side effects emerge.\nThe New Security Perimeter\nBefore the rise of web applications, organizations’ efforts to secure themselves\nagainst external attack were largely focused on the network perimeter. Defend-\ning this perimeter entailed hardening and patching the services that it needed\nto expose, and firewalling access to others.\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 11\nChapter 1 ■ Web Application (In)security 11\nWeb applications have changed all of this. For an application to be accessi-\nble by its users, the perimeter firewall must allow inbound connections to the\nserver over HTTP/S. And for the application to function, the server must be\nallowed to connect to supporting back-end systems, such as databases, main-\nframes, and financial and logistical systems. These systems often lie at the core\nof the organization’s operations and reside behind several layers of network-\nlevel defenses.\nIf a vulnerability exists within a web application, then an attacker on the\npublic Internet may be able to compromise the organization’s core back-end\nsystems solely by submitting crafted data from his web browser. This data will\nsail past all of the organization’s network defenses, in just the same way as\ndoes ordinary, benign traffic to the web application.\nThe effect of widespread deployment of web applications is that the security\nperimeter of a typical organization has moved. Part of that perimeter is still\nembodied in firewalls and bastion hosts. But a significant part of it is now\noccupied by the organization’s web applications. Because of the manifold\nways in which web applications receive user input and pass this to sensitive\nback-end systems, they are the potential gateways for a wide range of attacks,\nand defenses against these attacks must be implemented within the applica-\ntions themselves. A single line of defective code in a single web application can\nrender an organization’s internal systems vulnerable. The statistics described\npreviously, of the incidence of vulnerabilities within this new security perime-\nter, should give every organization pause for thought.\nNOTE For an attacker targeting an organization, gaining access to the\nnetwork or executing arbitrary commands on servers may well not be what\nthey really want to achieve. Often, and perhaps typically, what an attacker\nreally desires is to perform some application-level action such as stealing\npersonal information, transferring funds, or making cheap purchases. And the\nrelocation of the security perimeter to the application layer may greatly assist\nan attacker in achieving these objectives.\nFor example, suppose that an attacker wishes to “hack in” to a bank’s systems\nand steal money from users’ accounts. Before the bank deployed a web\napplication, the attacker might have needed to find a vulnerability in a publicly\nreachable service, exploit this to gain a toehold on the bank’s DMZ, penetrate\nthe firewall restricting access to its internal systems, map the network to find\nthe mainframe computer, decipher the arcane protocol used to access it, and\nthen guess some credentials in order to log in. However, if the bank deploys a\nvulnerable web application, then the attacker may be able to achieve the same\noutcome simply by modifying an account number in a hidden field of an HTML\nform.\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 12\n12 Chapter 1 ■ Web Application (In)security\nA second way in which web applications have moved the security perime-\nter arises from the threats that users themselves face when they access a vul-\nnerable application. A malicious attacker can leverage a benign but vulnerable\nweb application to attack any user who visits it. If that user is located on an\ninternal corporate network, the attacker may harness the user’s browser to\nlaunch an attack against the local network from the user’s trusted position.\nWithout any cooperation from the user, the attacker may be able to carry out\nany action that the user could perform if she were herself malicious.\nNetwork administrators are familiar with the idea of preventing their users\nfrom visiting malicious web sites, and end users themselves are gradually\nbecoming more aware of this threat. But the nature of web application vulner-\nabilities means that a vulnerable application may present no less of a threat to\nits users and their organization than a web site that is overtly malicious. Cor-\nrespondingly, the new security perimeter imposes a duty of care on all appli-\ncation owners to protect their users from attacks against them delivered via\nthe application.\nThe Future of Web Application Security\nSeveral years after their widespread adoption, web applications on the Internet\ntoday are still rife with vulnerabilities. Understanding of the security threats\nfacing web applications, and effective ways of addressing these, remains imma-\nture within the industry. There is currently little indication that the problem fac-\ntors described previouslyare going to go away in the near future.\nThat said, the details of the web application security landscape are not sta-\ntic. While old and well understood vulnerabilities like SQL injection continue\nto appear, their prevalence is gradually diminishing. Further, the instances\nthat remain are becoming more difficult to find and exploit. Much current\nresearch is focused on developing advanced techniques for attacking more\nsubtle manifestations of vulnerabilities which a few years ago could be easily\ndetected and exploited using only a browser.\nA second prominent trend is a gradual shift in attention from traditional\nattacks against the server side of the application to those that target other\nusers. The latter kind of attack still leverages defects within the application\nitself, but it generally involves some kind of interaction with another user, to\ncompromise that user’s dealings with the vulnerable application. This is a\ntrend that has been replicated in other areas of software security. As awareness\nof security threats matures, flaws in the server side are the first to be well\nunderstood and addressed, leaving the client side as a key battleground as the\nlearning process continues. Of all the attacks described in this book, those\nagainst other users are evolving the most quickly, and are the focus of most\ncurrent research.\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 13\nChapter 1 ■ Web Application (In)security 13\nChapter Summary\nIn a few short years, the World Wide Web has evolved from purely static infor-\nmation repositories into highly functional applications that process sensitive\ndata and perform powerful actions with real-world consequences. During this\ndevelopment, several factors have combined to bring about the weak security\nposture demonstrated by the majority of today’s web applications.\nMost applications face the core security problem that users can submit arbi-\ntrary input. Every aspect of the user’s interaction with the application may be\nmalicious and should be regarded as such unless proven otherwise. Failure to\nproperly address this problem can leave applications vulnerable to attack in\nnumerous ways.\nAll of the evidence about the current state of web application security indi-\ncates that this problem has not been resolved on any significant scale, and that\nattacks against web applications present a serious threat both to the organiza-\ntions that deploy them and to the users who access them.\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 14"
  },
  {
    "input": "What are the core defense mechanisms used by web applications to protect against security threats?",
    "summary": "Web applications face a core security challenge: all user input is untrusted, leading to the use of various defense mechanisms to prevent unauthorized access and malicious behavior. These mechanisms include authentication, session management, access control, and input validation, each playing a critical role in securing the application. Proper understanding and implementation of these core defense elements are essential to effectively identify and mitigate vulnerabilities in web applications.",
    "output": "70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 15\nCHAPTER\n2\nCore Defense Mechanisms\nThe fundamental security problem with web applications—that all user\ninput is untrusted—gives rise to a number of security mechanisms that appli-\ncations use to defend themselves against attack. Virtually all applications\nemploy mechanisms that are conceptually similar, although the details of the\ndesign and the effectiveness of the implementation differ very widely indeed.\nThe defense mechanisms employed by web applications comprise the fol-\nlowing core elements:\n■■ Handling user access to the application’s data and functionality, to pre-\nvent users from gaining unauthorized access.\n■■ Handling user input to the application’s functions, to prevent mal-\nformed input from causing undesirable behavior.\n■■ Handling attackers, to ensure that the application behaves appropri-\nately when being directly targeted, taking suitable defensive and offen-\nsive measures to frustrate the attacker.\n■■ Managing the application itself, by enabling administrators to monitor\nits activities and configure its functionality.\nBecause of their central role in addressing the core security problem, these\nmechanisms also make up the vast majority of a typical application’s attack\nsurface. If knowing your enemy is the first rule of warfare, then understanding\nthese mechanisms thoroughly is the main prerequisite to being able to attack\n15\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 16\n16 Chapter 2 ■ Core Defense Mechanisms\napplications effectively. If you are new to hacking web applications, and even\nif you are not, you should be sure to take time to understand how these core\nmechanisms work in each of the applications you encounter, and identify the\nweak points that leave them vulnerable to attack.\nHandling User Access\nA central security requirement that virtually any application needs to meet is\nto control users’ access to its data and functionality. In a typical situation, there\nare several different categories of user; for example, anonymous users, ordi-\nnary authenticated users, and administrative users. Further, in many situa-\ntions different users are permitted to access a different set of data; for example,\nusers of a web mail application should be able to read their own email but not\nother people’s.\nMost web applications handle access using a trio of interrelated security\nmechanisms:\n■■ Authentication\n■■ Session management\n■■ Access control\nEach of these mechanisms represents a significant area of an application’s\nattack surface, and each is absolutely fundamental to an application’s overall\nsecurity posture. Because of their interdependencies, the overall security pro-\nvided by the mechanisms is only as strong as the weakest link in the chain. A\ndefect in any single component may enable an attacker to gain unrestricted\naccess to the application’s functionality and data.\nAuthentication\nThe authentication mechanism is logically the most basic dependency in an\napplication’s handling of user access. Authenticating a user involves estab-\nlishing that the user is in fact who he claims to be. Without this facility, the\napplication would need to treat all users as anonymous—the lowest possible\nlevel of trust.\nThe majority of today’s web applications employ the conventional authenti-\ncation model in which the user submits a username and password, which the\napplication checks for validity. Figure2-1 shows a typical login function. In secu-\nrity-critical applications such as those used by online banks, this basic model is\nusually supplemented by additional credentials and a multistage login process.\nWhen security requirements are higher still, other authentication models may be\nused, based on client certificates, smartcards, or challenge-response tokens. In\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 17\nChapter 2 ■ Core Defense Mechanisms 17\naddition to the core login process, authentication mechanisms often employ a\nrange of other supporting functionality, such as self-registration, account recov-\nery, and a password change facility.\nFigure 2-1: A typical login function\nDespite their superficial simplicity, authentication mechanisms suffer from\na wide range of defects, in both design and implementation. Common prob-\nlems may enable an attacker to identify other users’ usernames, guess their\npasswords, or bypass the login function altogether by exploiting defects in its\nlogic. When you are attacking a web application, you should invest a signifi-\ncant amount of attention in the various authentication-related functions that it\ncontains. Surprisingly frequently, defects in this functionality will enable you\nto gain unauthorized access to sensitive data and functionality.\nSession Management\nThe next logical task in the process of handling user access is to manage the\nauthenticated user’s session. After successfully logging in to the application,\nthe user will access various pages and functions, making a series of HTTP\nrequests from their browser. At the same time, the application will be receiving\ncountless other requests from different users, some of whom are authenticated\nand some of whom are anonymous. In order to enforce effective access control,\nthe application needs a way of identifying and processing the series of requests\nthat originate from each unique user.\nVirtually all web applications meet this requirement by creating a session\nfor each user and issuing the user a token that identifies the session. The ses-\nsion itself is a set of data structures held on the server, which are used to track\nthe state of the user’s interaction with the application. The token is a unique\nstring that the application maps to the session. When a user has received a\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 18\n18 Chapter 2 ■ Core Defense Mechanisms\ntoken, the browser automatically submits this back to the server in each sub-\nsequent HTTP request, enabling the application to associate the request with\nthat user. HTTP cookies are the standard method for transmitting session\ntokens, although many applications use hidden form fields or the URL query\nstring for this purpose. If a user does not make a request for a given period,\nthen the session is ideally expired, as in Figure2-2.\nIn terms of attack surface, the session management mechanism is highly\ndependent on the security of its tokens, and the majority of attacks against it\nseek to compromise the tokens issued to other users. If this is possible, an\nattacker can masquerade as the victim user and use the application just as if\nthey had actually authenticated as that user. The principal areas of vulnerabil-\nity arise from defects in the way tokens are generated, enabling an attacker to\nguess the tokens issued to other users, and defects in the way tokens are sub-\nsequently handled, enabling an attacker to capture other users’ tokens.\nFigure 2-2: An application enforcing session timeout\nA small number of applications dispense with the need for session tokens by\nusing other means of re-identifying users across multiple requests. If HTTP’s\nbuilt-in authentication mechanism is used, then the browser automatically\nresubmits the user’s credentials with each request, enabling the application to\nidentify the user directly from these. In other cases, the application stores the\nstate information on the client side rather than the server, usually in encrypted\nform to prevent tampering.\nAccess Control\nThe final logical step in the process of handling user access is to make and\nenforce correct decisions regarding whether each individual request should be\npermitted or denied. If the preceding mechanisms are functioning correctly,\nthe application knows the identity of the user from whom each request is\nreceived. On this basis, it needs to decide whether that user is authorized to\nperform the action, or access the data, that he is requesting (see Figure2-3).\nThe access control mechanism usually needs to implement some fine-\ngrained logic, with different considerations being relevant to different areas of\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 19\nChapter 2 ■ Core Defense Mechanisms 19\nthe application and different types of functionality. An application might sup-\nport numerous different user roles, each involving different combinations of\nspecific privileges. Individual users may be permitted to access a subset of the\ntotal data held within the application. Specific functions may implement trans-\naction limits and other checks, all of which need to be properly enforced based\non the user’s identity.\nFigure 2-3: An application enforcing access control\nBecause of the complex nature of typical access control requirements, this\nmechanism is a frequent source of security vulnerabilities that enable an\nattacker to gain unauthorized access to data and functionality. Developers\nvery often make flawed assumptions about how users will interact with the\napplication, and frequently make oversights by omitting access control checks\nfrom some application functions. Probing for these vulnerabilities is often\nlaborious because essentially the same checks need to be repeated for each\nitem of functionality. Because of the prevalence of access control flaws, how-\never, this effort is always a worthwhile investment when you are attacking a\nweb application.\nHandling User Input\nRecall the fundamental security problem described in Chapter 1: all user input\nis untrusted. A huge variety of different attacks against web applications\ninvolve submitting unexpected input, crafted to cause behavior that was not\nintended by the application’s designers. Correspondingly, a key requirement\nfor an application’s security defenses is that it must handle user input in a safe\nmanner.\nInput-based vulnerabilities can arise anywhere within an application’s func-\ntionality, and in relation to practically every type of technology in common use.\n“Input validation” is often cited as the necessary defense against these attacks.\nHowever, there is no single protective mechanism that can be employed every-\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 20\n20 Chapter 2 ■ Core Defense Mechanisms\nwhere, and defending against malicious input is often not as straightforward as\nit sounds.\nVarieties of Input\nA typical web application processes user-supplied data in a range of different\nforms. Some kinds of input validation may not be feasible or desirable for all\nof these forms of input. Figure 2-4 shows the kind of input validation often\nperformed by a user registration function.\nIn many cases, an application may be able to impose very stringent valida-\ntion checks on a specific item of input. For example, a username submitted to\na login function may be required to have a maximum length of eight charac-\nters and contain only alphabetical letters.\nIn other cases, the application must tolerate a wider range of possible input.\nFor example, an address field submitted to a personal details page might legit-\nimately contain letters, numbers, spaces, hyphens, apostrophes, and other char-\nacters. For this item, there are still restrictions that can feasibly be imposed,\nhowever. The data should not exceed a reasonable length limit (such as 50 char-\nacters), and should not contain any HTML mark-up.\nIn some situations, an application may need to accept completely arbitrary\ninput from users. For example, a user of a blogging application may create a\nblog whose subject is web application hacking. Posts and comments made to\nthe blog may quite legitimately contain explicit attack strings that are being\ndiscussed. The application may need to store this input within a database,\nwrite it to disk, and display it back to users in a safe way. It cannot simply\nreject the input because it looks potentially malicious without substantially\ndiminishing the value of the application to some of its user base.\nFigure 2-4: An application performing input validation\nIn addition to the various kinds of input that is entered by users via the\nbrowser interface, a typical application also receives numerous items of data\nthat began their life on the server and that are sent to the client so that the client\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 21\nChapter 2 ■ Core Defense Mechanisms 21\ncan transmit them back to the server on subsequent requests. This includes\nitems such as cookies and hidden form fields, which are not seen by ordinary\nusers of the application but which an attacker can of course view and modify.\nIn these cases, applications can often perform very specific validation of the\ndata received. For example, a parameter might be required to have one of a\nspecific set of known values, such as a cookie indicating the user’s preferred\nlanguage, or to be in a specific format, such as a customer ID number. Further,\nwhen an application detects that server-generated data has been modified in a\nway that is not possible for an ordinary user with a standard browser, this is\noften an indication that the user is attempting to probe the application for vul-\nnerabilities. In these cases, the application should reject the request and log the\nincident for potential investigation (see the “Handling Attackers” sectionlater\nin this chapter).\nApproaches to Input Handling\nThere are various broad approaches that are commonly taken to the problem\nof handling user input. Different approaches are often preferable for different\nsituations and different types of input, and a combination of approaches may\nsometimes be desirable.\n“Reject Known Bad”\nThis approach typically employs a blacklist containing a set of literal strings or\npatterns that are known to be used in attacks. The validation mechanism\nblocks any data that matches the blacklist and allows everything else.\nIn general, this is regarded as the least effective approach to validating user\ninput, for two main reasons. First, a typical vulnerability in a web application\ncan be exploited using a wide variety of different input, which may be\nencoded or represented in various different ways. Except in the simplest of\ncases, it is likely that a blacklist will omit some patterns of input that can be\nused to attack the application. Second, techniques for exploitation are con-\nstantly evolving. Novel methods for exploiting existing categories of vulnera-\nbility are unlikely to be blocked by current blacklists.\n“Accept Known Good”\nThis approach employs a white list containing a set of literal strings or pat-\nterns, or a set of criteria, that is known to match only benign input. The vali-\ndation mechanism allows data that matches the white list, and blocks\neverything else. For example, before looking up a requested product code in\nthe database, an application might validate that it contains only alphanumeric\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 22\n22 Chapter 2 ■ Core Defense Mechanisms\ncharacters and is exactly six characters long. Given the subsequent processing\nthat will be done on the product code, the developers know that input passing\nthis test cannot possibly cause any problems.\nIn cases where this approach is feasible, it is regarded as the most effective\nway of handling potentially malicious input. Provided that due care is taken in\nconstructing the white list, an attacker will not be able to use crafted input to\ninterfere with the application’s behavior. However, there are numerous situa-\ntions in which an application must accept data for processing that does not\nmeet any reasonable criteria for what is known to be “good.” For example,\nsome people’s names contain the apostrophe and hyphen characters. These\ncan be used in attacks against databases, but it may be a requirement that the\napplication should permit anyone to register under their real name. Hence,\nwhile it is often extremely effective, the white-list-based approach does not\nrepresent an all-purpose solution to the problem of handling user input.\nSanitization\nThis approach recognizes the need to sometimes accept data that cannot be\nguaranteed as safe. Instead of rejecting this input, the application sanitizes it in\nvarious ways to prevent it from having any adverse effects. Potentially mali-\ncious characters may be removed from the data altogether, leaving only what\nis known to be safe, or they may be suitably encoded or “escaped” before fur-\nther processing is performed.\nApproaches based on data sanitization are often highly effective, and in\nmany situations they can be relied upon as a general solution to the problem of\nmalicious input. For example, the usual defense against cross-site scripting\nattacks is to HTML-encode dangerous characters before these are embedded\ninto pages of the application (see Chapter 12). However, effective sanitization\nmay be difficult to achieve if several kinds of potentially malicious data need\nto be accommodated within one item of input. In this situation, a boundary\nvalidation approach is desirable, as described later.\nSafe Data Handling\nVery many web application vulnerabilities arise because user-supplied data is\nprocessed in unsafe ways. It is often the case that vulnerabilities can be\navoided, not by validating the input itself but by ensuring that the processing\nthat is performed on it is inherently safe. In some situations, there are safe pro-\ngramming methods available that avoid common problems. For example, SQL\ninjection attacks can be prevented through the correct use of parameterized\nqueries for database access (see Chapter 9). In other situations, application\nfunctionality can be designed in such a way that inherently unsafe practices,\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 23\nChapter 2 ■ Core Defense Mechanisms 23\nsuch as passing user input to an operating system command interpreter, are\navoided altogether.\nThis approach cannot be applied to every kind of task that web applications\nneed to perform, but where it is available it is an effective general approach to\nhandling potentially malicious input.\nSemantic Checks\nThe defenses described so far all address the need to defend the application\nagainst various kinds of malformed data whose content has been crafted to\ninterfere with the application’s processing. However, with some vulnerabili-\nties the input supplied by the attacker is identical to the input that an ordinary,\nnon-malicious user may submit. What makes it malicious is the different cir-\ncumstances in which it is submitted. For example, an attacker might seek to\ngain access to another user’s bank account by changing an account number\ntransmitted in a hidden form field. No amount of syntactic validation will dis-\ntinguish between the user’s data and the attacker’s. To prevent unauthorized\naccess, the application needs to validate that the account number submitted\nbelongs to the user who has submitted it.\nBoundary Validation\nThe idea of validating data across trust boundaries is a familiar one. The core\nsecurity problem with web applications arises because data received from\nusers is untrusted. While input validation checks implemented on the client\nside may improve performance and the user’s experience, they do not provide\nany assurance over the data that actually reaches the server. The point at\nwhich user data is first received by the server-side application represents a\nhuge trust boundary, at which the application needs to take measures to\ndefend itself against malicious input.\nGiven the nature of the core problem, it is tempting to think of the input val-\nidation problem in terms of a frontier between the Internet, which is “bad” and\nuntrusted, and the server-side application, which is “good” and trusted. In\nthis picture, the role of input validation is to clean potentially malicious data\non arrival and then pass the clean data to the trusted application. From this\npoint onwards, the data may be trusted and processed without any further\nchecks or concern about possible attacks.\nAs will become evident when we begin to examine some actual vulnerabil-\nities, this simple picture of input validation is inadequate, for several reasons:\n■■ Given the wide range of functionality that applications implement, and\nthe different technologies in use, a typical application needs to defend\nitself against a huge variety of input-based attacks, each of which may\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 24\n24 Chapter 2 ■ Core Defense Mechanisms\nemploy a diverse set of crafted data. It would be very difficult to devise\na single mechanism at the external boundary to defend against all of\nthese attacks.\n■■ Many application functions involve chaining together a series of\ndifferent types of processing. A single piece of user-supplied input\nmight result in a number of operations in different components, with\nthe output of each being used as the input for the next. As the data is\ntransformed, it might come to bear no resemblance to the original\ninput, and a skilled attacker may be able to manipulate the application\nto cause malicious input to be generated at a key stage of the process-\ning, attacking the component which receives this data. It would be\nextremely difficult to implement a validation mechanism at the external\nboundary to foresee all of the possible results of processing each piece\nof user input.\n■■ Defending against different categories of input-based attack may entail\nperforming different validation checks on user input that are incompat-\nible with one another. For example, preventing cross-site scripting\nattacks may require HTML-encoding the >character as &gt;while pre-\nventing command injection attacks may require blocking input contain-\ning the &and ;characters. Attempting to prevent all categories of attack\nsimultaneously at the application’s external boundary may sometimes\nbe impossible.\nA more effective model uses the concept of boundary validation. Here, each\nindividual component or functional unit of the server-side application treats\nits inputs as coming from a potentially malicious source. Data validation is\nperformed at each of these trust boundaries, in addition to the external frontier\nbetween the client and server. This model provides a solution to the problems\ndescribed in the previous list. Each component can defend itself against the\nspecific types of crafted input to which it may be vulnerable. As data passes\nthrough different components, validation checks can be performed against\nwhatever value the data has as a result of previous transformations. And\nbecause the various validation checks are implemented at different stages of\nprocessing, they are unlikely to come into conflict with one another.\nFigure 2-5 illustrates a typical situation where boundary validation is the\nmost effective approach to defending against malicious input. The user login\nresults in several steps of processing being performed on user-supplied input,\nand suitable validation is performed at each step:\n1. The application receives the user’s login details. The form handler vali-\ndates that each item of input contains only permitted characters, is\nwithin a specific length limit, and does not contain any known attack\nsignatures.\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 25\nChapter 2 ■ Core Defense Mechanisms 25\n2. The application performs an SQL query to verify the user’s credentials.\nTo prevent SQL injection attacks, any characters within the user input\nthat may be used to attack the database are escaped before the query is\nconstructed.\n3. If the login succeeds, the application passes certain data from the user’s\nprofile to a SOAP service to retrieve further information about her\naccount. To prevent SOAP injection attacks, any XML metacharacters\nwithin the user’s profile data are suitably encoded.\n4. The application displays the user’s account information back to the\nuser’s browser. To prevent cross-site scripting attacks, the application\nHTML-encodes any user-supplied data that is embedded into the\nreturned page.\n2. Clean SQL\n1. General checks\nSQL query\nLogin submission\nDatabase\nDisplay account\nUser\ndetails\nApplication\nserver 3. Encode XML\n4. Sanitize output metacharacters\nSOAP\nmessage\nSOAP service\nFigure 2-5: An application function using boundary validation at multiple stages of\nprocessing\nThe specific vulnerabilities and defenses involved in the described scenario\nwill be examined in detail in later chapters. If variations on this functionality\ninvolved passing data to further application components, then similar\ndefenses would need to be implemented at the relevant trust boundaries. For\nexample, if a failed login caused the application to send a warning email to the\nuser, then any user data incorporated into the email may need to be checked\nfor SMTP injection attacks.\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 26\n26 Chapter 2 ■ Core Defense Mechanisms\nMultistep Validation and Canonicalization\nA common problem encountered by input-handling mechanisms arises when\nuser-supplied input is manipulated across several steps as part of the valida-\ntion logic. If this process is not handled carefully, then an attacker may be able\nto construct crafted input that succeeds in smuggling malicious data through\nthe validation mechanism. One version of this problem occurs when an appli-\ncation attempts to sanitize user input by removing or encoding certain charac-\nters or expressions. For example, an application may attempt to defend against\nsome cross-site scripting attacks by stripping the expression\n<script>\nfrom any user-supplied data. However, an attacker may be able to bypass the\nfilter by supplying the following input:\n<scr<script>ipt>\nWhen the blocked expression is removed, the surrounding data contracts to\nrestore the malicious payload, because the filter is not being applied recursively.\nSimilarly, if more than one validation step is performed on user input, an\nattacker may be able to exploit the ordering of these steps to bypass the filter.\nFor example, if the application first removes script tags recursively and then\nstrips any quotation marks, the following input can be used to defeat the vali-\ndation:\n<scr”ipt>\nA different problem arises in relation to data canonicalization. When input\nis sent from the user’s browser, it may be encoded in various ways. These\nencoding schemes exist in order that unusual characters and binary data may\nbe transmitted safely over HTTP (see Chapter 3 for more details). Canonical-\nization is the process of converting or decoding data into a common character\nset. If any canonicalization is carried out after input filters have been applied,\nthen an attacker may be able to use encoding to bypass the validation mecha-\nnism. For example, an application may attempt to defend against some SQL\ninjection attacks by removing the apostrophe character from user input. How-\never, if the sanitized data is subsequently canonicalized, then an attacker may\nbe able to use the URL-encoded form\n%27\nto defeat the validation. If the application strips this URL-encoded form, but also\nperforms further canonicalization, then the following bypass may be effective:\n%%2727"
  },
  {
    "input": "What are the key technologies and encoding schemes used in web applications, and how do they impact the application's security?",
    "summary": "This chapter discusses the core technologies used in web applications, including HTTP, cookies, and various encoding schemes, and how they can be exploited by attackers. It highlights the importance of handling user input and access properly to prevent security vulnerabilities. The chapter also explains how applications can react to attacks by blocking malicious requests or alerting administrators, and emphasizes the need for secure practices in both server-side and client-side functionalities.",
    "output": "70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 27\nChapter 2 ■ Core Defense Mechanisms 27\nThroughout this book, we will describe numerous attacks of this kind which\nare effective in defeating many applications’ defenses against common input-\nbased vulnerabilities.\nAvoiding problems with multistep validation and canonicalization can\nsometimes be difficult, and there is no single solution to the problem. One\napproach is to perform sanitization steps recursively, continuing until no fur-\nther modifications have been made on an item of input. However, where the\ndesired sanitization involves escaping a problematic character, this may result\nin an infinite loop. Often, the problem can only be addressed on a case-by-case\nbasis, based upon the types of validation being performed. Where feasible, it\nmay be preferable to avoid attempting to clean some kinds of bad input, and\nsimply reject it altogether.\nHandling Attackers\nAnyone designing an application for which security is remotely important\nmust work on the assumption that it will be directly targeted by dedicated and\nskilled attackers. A key function of the application’s security mechanisms is to\nbe able to handle and react to these attacks in a controlled way. These mecha-\nnisms often incorporate a mix of defensive and offensive measures designed to\nfrustrate an attacker as much as possible, and provide appropriate notification\nand evidence to the application’s owners of what has taken place. Measures\nimplemented to handle attackers typically include the following tasks:\n■■ Handling errors\n■■ Maintaining audit logs\n■■ Alerting administrators\n■■ Reacting to attacks\nHandling Errors\nHowever careful an application’s developers are in validating user input, it is\nvirtually inevitable that some unanticipated errors will occur. Errors resulting\nfrom the actions of ordinary users are likely to be identified during functional-\nity and user acceptance testing, and so will be taken account of before the\napplication is deployed in a production context. However, it is very difficult to\nanticipate every possible way in which a malicious user may interact with the\napplication, and so further errors should be expected when the application\ncomes under attack.\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 28\n28 Chapter 2 ■ Core Defense Mechanisms\nA key defense mechanism is for the application to handle unexpected\nerrors in a graceful manner, and either recover from them or present a suit-\nable error message to the user. In a production context, the application\nshould never return any system-generated messages or other debug infor-\nmation in its responses. As you will see throughout this book, overly verbose\nerror messages can greatly assist malicious users in furthering their attacks\nagainst the application. In some situations, an attacker can leverage defective\nerror handling to retrieve sensitive information within the error messages\nthemselves, providing a valuable channel for stealing data from the applica-\ntion. Figure 2-6 shows an example of an unhandled error resulting in a ver-\nbose error message.\nFigure 2-6: An unhandled error\nMost web development languages provide good error-handling support\nthrough try-catch blocks and checked exceptions. Application code should\nmake extensive use of these constructs to catch specific and general errors and\nhandle them appropriately. Further, most application servers can be configured\nto deal with unhandled application errors in customized ways, for example by\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 29\nChapter 2 ■ Core Defense Mechanisms 29\npresenting an uninformative error message. See Chapter 14 for more details of\nthese measures.\nEffective error handling is often integrated with the application’s logging\nmechanisms, which record as much debug information as possible about\nunanticipated errors. Very often, unexpected errors point to defects within the\napplication’s defenses that can be addressed at the source if the application’s\nowner has the required information.\nMaintaining Audit Logs\nAudit logs are primarily of value when investigating intrusion attempts against\nan application. Following such an incident, effective audit logs should enable\nthe application’s owners to understand exactly what has taken place, which\nvulnerabilities (if any) were exploited, whether the attacker gained unautho-\nrized access to data or performed any unauthorized actions, and as far as pos-\nsible, provide evidence as to the intruder’s identity.\nIn any application for which security is important, key events should be\nlogged as a matter of course. At a minimum, these typically include:\n■■ All events relating to the authentication functionality, such as successful\nand failed login, and change of password.\n■■ Key transactions, such as credit card payments and funds transfers.\n■■ Access attempts that are blocked by the access control mechanisms.\n■■ Any requests containing known attack strings that indicate overtly\nmalicious intentions.\nIn many security-critical applications, such as those used by online banks,\nevery single client request is logged in full, providing a complete forensic\nrecord that can be used to investigate any incidents.\nEffective audit logs typically record the time of each event, the IP address\nfrom which the request was received, the session token, and the user’s account\n(if authenticated). Such logs need to be strongly protected against unautho-\nrized read or write access. An effective approach is to store audit logs on an\nautonomous system that accepts only update messages from the main appli-\ncation. In some situations, logs may be flushed to write-once media to ensure\ntheir integrity in the event of a successful attack.\nIn terms of attack surface, poorly protected audit logs can provide a gold\nmine of information to an attacker, disclosing a host of sensitive information\nsuch as session tokens and request parameters that may enable them to imme-\ndiately compromise the entire application (see Figure2-7).\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 30\n30 Chapter 2 ■ Core Defense Mechanisms\nFigure 2-7: Poorly protected application logs containing sensitive\ninformation submitted by other users\nAlerting Administrators\nAudit logs enable an application’s owners to retrospectively investigate intru-\nsion attempts, and if possible, take legal action against the perpetrator. How-\never, in many situations it is desirable to take much more immediate action, in\nreal time, in response to attempted attacks. For example, administrators may\nblock the IP address or user account being used by an attacker. In extreme\ncases, they may even take the application offline while the attack is investi-\ngated and remedial action taken. Even if a successful intrusion has already\noccurred, its practical effects may be mitigated if defensive action is taken at an\nearly stage.\nIn most situations, alerting mechanisms must balance the conflicting objec-\ntives of reporting each genuine attack reliably and of not generating so many\nalerts that these come to be ignored. A well-designed alerting mechanism can\nuse a combination of factors to diagnose that a determined attack is underway,\nand can aggregate related events into a single alert where possible. Anomalous\nevents monitored by alerting mechanisms often include:\n■■ Usage anomalies, such as large numbers of requests being received\nfrom a single IP address or user, indicating a scripted attack.\n■■ Business anomalies, such as an unusual number of funds transfers\nbeing made to or from a single bank account.\n■■ Requests containing known attack strings.\n■■ Requests where data that is hidden from ordinary users has been\nmodified.\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 31\nChapter 2 ■ Core Defense Mechanisms 31\nSome of these functions can be provided reasonably well by off-the-shelf\napplication firewalls and intrusion detection products. These typically use a\nmixture of signature- and anomaly-based rules to identify malicious use of the\napplication, and may reactively block malicious requests as well as issue alerts\nto administrators. These products can form a valuable layer of defense pro-\ntecting a web application, particularly in the case of existing applications\nknown to contain problems but where resources to fix these are not immedi-\nately available. However, their effectiveness is normally limited by the fact\nthat each web application is different, and so the rules employed are inevitably\ngeneric to some extent. Web application firewalls are normally good at identi-\nfying the most obvious attacks, where an attacker submits standard attack\nstrings in each request parameter. However, many attacks are more subtle than\nthis, for example modifying the account number in a hidden field to access\nanother user’s data, or submitting requests out of sequence to exploit defects\nin the application’s logic. In these cases, a request submitted by an attacker\nmay be identical to that submitted by a benign user—what makes it mali-\ncious are the circumstances in which it is made.\nIn any security-critical application, the most effective way to implement\nreal-time alerting is to integrate this tightly with the application’s input vali-\ndation mechanisms and other controls. For example, if a cookie is expected to\nhave one of a specific set of values, then any violation of this indicates that its\nvalue has been modified in way that is not possible for ordinary users of the\napplication. Similarly, if a user changes an account number in a hidden field to\nidentify a different user’s account, this strongly indicates malicious intent. The\napplication should already be checking for these attacks as part of its primary\ndefenses, and these protective mechanisms can easily hook into the applica-\ntion’s alerting mechanism to provide fully customized indicators of malicious\nactivity. Because these checks have been tailored to the application’s actual\nlogic, with a fine-grained knowledge of how ordinary users should be behav-\ning, they are much less prone to false positives than any off-the-shelf solution,\nhowever configurable or able to learn that solution may be.\nReacting to Attacks\nIn addition to alerting administrators, many security-critical applications con-\ntain built-in mechanisms to react defensively to users who are identified as\npotentially malicious.\nBecause each application is different, most real-world attacks require an\nattacker to probe systematically for vulnerabilities, submitting numerous\nrequests containing crafted input designed to indicate the presence of various\ncommon vulnerabilities. Effective input validation mechanisms will identify\nmany of these requests as potentially malicious, and block the input from\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 32\n32 Chapter 2 ■ Core Defense Mechanisms\nhaving any undesirable effect on the application. However, it is sensible to\nassume that some bypasses to these filters exist, and that the application does\ncontain some actual vulnerabilities waiting to be discovered and exploited. At\nsome point, an attacker working systematically is likely to discover these\ndefects.\nFor this reason, some applications take automatic reactive measures to frus-\ntrate the activities of an attacker who is working in this way, for example by\nresponding increasingly slowly to the attacker’s requests or by terminating the\nattacker’s session, requiring him to log in or perform other steps before con-\ntinuing the attack. While these measures will not defeat the most patient and\ndetermined attacker, they will deter many more casual attackers, and will buy\nadditional time for administrators to monitor the situation and take more\ndrastic action if desired.\nReacting to apparent attackers is not, of course, a substitute for fixing any\nvulnerabilities that exist within the application. However, in the real world,\neven the most diligent efforts to purge an application of security flaws may\nleave some exploitable defects remaining. Placing further obstacles in the way\nof an attacker is an effective defense-in-depth measure that reduces the likeli-\nhood that any residual vulnerabilities will be found and exploited.\nManaging the Application\nAny useful application needs to be managed and administered, and this facil-\nity often forms a key part of the application’s security mechanisms, providing\na way for administrators to manage user accounts and roles, access monitoring\nand audit functions, perform diagnostic tasks, and configure aspects of the\napplication’s functionality.\nIn many applications, administrative functions are implemented within the\napplication itself, accessible through the same web interface as its core nonse-\ncurity functionality, as shown in Figure2-8. Where this is the case, the admin-\nistrative mechanism represents a critical part of the application’s attack\nsurface. Its primary attraction for an attacker is as a vehicle for privilege esca-\nlation, for example:\n■■ Weaknesses in the authentication mechanism may enable an attacker\nto gain administrative access, effectively compromising the entire\napplication.\n■■ Many applications do not implement effective access control of some of\ntheir administrative functions. An attacker may find a means of creat-\ning a new user account with powerful privileges.\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 33\nChapter 2 ■ Core Defense Mechanisms 33\n■■ Administrative functionality often involves displaying data that origi-\nnated from ordinary users. Any cross-site scripting flaws within the\nadministrative interface can lead to compromise of a user session that is\nguaranteed to have powerful privileges.\n■■ Administrative functionality is often subjected to less rigorous security\ntesting, because its users are deemed to be trusted, or because penetra-\ntion testers are given access to only low-privileged accounts. Further, it\noften has a need to perform inherently dangerous operations, involving\naccess to files on disk or operating system commands. If an attacker can\ncompromise the administrative function, they can often leverage it to\ntake control of the entire server.\nFigure 2-8: An administrative interface within a web application.\nChapter Summary\nDespite their extensive differences, virtually all web applications employ the\nsame core security mechanisms in some shape or form. These mechanisms\nrepresent an application’s primary defenses against malicious users, and\ntherefore also comprise the bulk of the application’s attack surface. The vul-\nnerabilities we shall examine later in this book mainly arise from defects\nwithin these core mechanisms.\nOf these components, the mechanisms for handling user access and user\ninput are the most important and should take up most of your attention when\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 34\n34 Chapter 2 ■ Core Defense Mechanisms\nyou are targeting an application. Defects in these mechanisms often lead to\ncomplete compromise of the application, enabling you to access data belong-\ning to other users, perform unauthorized actions, and inject arbitrary code and\ncommands.\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. Why are an application’s mechanisms for handling user access only as\nstrong as the weakest of these components?\n2. What is the difference between a session and a session token?\n3. Why is it not always possible to use a whitelist-based approach to input\nvalidation?\n4. You are attacking an application that implements an administrative\nfunction. You do not have any valid credentials to use the function.\nWhy should you nevertheless pay very close attention to it?\n5. An input validation mechanism designed to block cross-site scripting\nattacks performs the following sequence of steps on an item of input:\n1. Strip any <script>expressions that appear.\n2. Truncate the input to 50 characters.\n3. Remove any quotation marks within the input.\n4. URL-decode the input.\n5. If any items were deleted, return to step 1.\nCan you bypass this validation mechanism to smuggle the following\ndata past it?\n“><script>alert(“foo”)</script>\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 35\nCHAPTER\n3\nWeb Application Technologies\nWeb applications employ a myriad of different technologies to implement\ntheir functionality. This chapter contains a short primer on the key technolo-\ngies that you are likely to encounter when attacking web applications. We shall\nexamine the HTTP protocol, the technologies commonly employed on the\nserver and client sides, and the encoding schemes used to represent data in\ndifferent situations. These technologies are in general easy to understand, and\na grasp of their relevant features is key to performing effective attacks against\nweb applications.\nIf you are already familiar with the key technologies used in web applications,\nyou can quickly skim through this chapter to confirm that there is nothing new\nin here for you. If you are still learning how web applications work, you should\nread this primer before continuing to the later chapters on specific vulnerabili-\nties. For further reading on any of the areas covered, we recommended HTTP:\nThe Definitive Guideby David Gourley and Brian Totty (O’Reilly, 2002).\nThe HTTP Protocol\nThe hypertext transfer protocol (HTTP) is the core communications protocol\nused to access the World Wide Web and is used by all of today’s web applica-\ntions. It is a simple protocol that was originally developed for retrieving static\ntext-based resources, and has since been extended and leveraged in various\n35\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 36\n36 Chapter 3 ■ Web Application Technologies\nways to enable it to support the complex distributed applications that are now\ncommonplace.\nHTTP uses a message-based model in which a client sends a request mes-\nsage, and the server returns a response message. The protocol is essentially\nconnectionless: although HTTP uses the stateful TCP protocol as its transport\nmechanism, each exchange of request and response is an autonomous transac-\ntion, and may use a different TCP connection.\nHTTP Requests\nAll HTTP messages (requests and responses) consist of one or more headers,\neach on a separate line, followed by a mandatory blank line, followed by an\noptional message body. A typical HTTP request is as follows:\nGET /books/search.asp?q=wahh HTTP/1.1\nAccept: image/gif, image/xxbitmap, image/jpeg, image/pjpeg,\napplication/xshockwaveflash, application/vnd.msexcel,\napplication/vnd.mspowerpoint, application/msword, */*\nReferer: http://wahh-app.com/books/default.asp\nAccept-Language: en-gb,en-us;q=0.5\nAccept-Encoding: gzip, deflate\nUser-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\nHost: wahh-app.com\nCookie: lang=en; JSESSIONID=0000tI8rk7joMx44S2Uu85nSWc_:vsnlc502\nThe first line of every HTTP request consists of three items, separated by\nspaces:\n■■ A verb indicating the HTTP method. The most commonly used method\nis GET, whose function is to retrieve a resource from the web server. GET\nrequests do not have a message body, so there is no further data follow-\ning the blank line after the message headers.\n■■ The requested URL. The URL functions as a name for the resource\nbeing requested, together with an optional query string containing\nparameters that the client is passing to that resource. The query string is\nindicated by the ?character in the URL, and in the example there is a\nsingle parameter with the name qand the value wahh.\n■■ The HTTP version being used. The only HTTP versions in common use\non the Internet are 1.0 and 1.1, and most browsers use version 1.1 by\ndefault. There are a few differences between the specifications of these\ntwo versions; however, the only difference you are likely to encounter\nwhen attacking web applications is that in version 1.1 the Hostrequest\nheader is mandatory.\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 37\nChapter 3 ■ Web Application Technologies 37\nSome other points of interest in the example request are:\n■■ The Refererheader is used to indicate the URL from which the request\noriginated (for example, because the user clicked a link on that page).\nNote that this header was misspelled in the original HTTP specification,\nand the misspelled version has been retained ever since.\n■■ The User-Agentheader is used to provide information about the\nbrowser or other client software that generated the request. Note that\nthe Mozilla prefix is included by most browsers for historical reasons—\nthis was the User-Agentstring used by the originally dominant Net -\nscape browser, and other browsers wished to assert to web sites that\nthey were compatible with this standard. As with many quirks from\ncomputing history, it has become so established that it is still retained,\neven on the current version of Internet Explorer, which made the\nrequest shown in the example.\n■■ The Hostheader is used to specify the hostname that appeared in the\nfull URL being accessed. This is necessary when multiple web sites are\nhosted on the same server, because the URL sent in the first line of the\nrequest does not normally contain a hostname. (See Chapter 16 for\nmore information about virtually hosted web sites.)\n■■ The Cookieheader is used to submit additional parameters that the\nserver has issued to the client (described in more detail later in this\nchapter).\nHTTP Responses\nA typical HTTP response is as follows:\nHTTP/1.1 200 OK\nDate: Sat, 19 May 2007 13:49:37 GMT\nServer: IBM_HTTP_SERVER/1.3.26.2 Apache/1.3.26 (Unix)\nSet-Cookie: tracking=tI8rk7joMx44S2Uu85nSWc\nPragma: no-cache\nExpires: Thu, 01 Jan 1970 00:00:00 GMT\nContent-Type: text/html;charset=ISO-8859-1\nContent-Language: en-US\nContent-Length: 24246\n<!DOCTYPE html PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN”>\n<html lang=”en”>\n<head>\n<meta http-equiv=”Content-Type” content=”text/html;\ncharset=iso-8859-1”>\n...\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 38\n38 Chapter 3 ■ Web Application Technologies\nThe first line of every HTTP response consists of three items, separated by\nspaces:\n■■ The HTTP version being used.\n■■ A numeric status code indicating the result of the request. 200 is the\nmost common status code; it means that the request was successful and\nthe requested resource is being returned.\n■■ A textual “reason phrase” further describing the status of the response.\nThis can have any value and is not used for any purpose by current\nbrowsers.\nSome other points of interest in the previous response are:\n■■ The Serverheader contains a banner indicating the web server soft-\nware being used, and sometimes other details such as installed modules\nand the server operating system. The information contained may or\nmay not be accurate.\n■■ The Set-Cookieheader is issuing the browser a further cookie; this will\nbe submitted back in the Cookieheader of subsequent requests to this\nserver.\n■■ The Pragmaheader is instructing the browser not to store the response\nin its cache, and the Expiresheader also indicates that the response\ncontent expired in the past and so should not be cached. These instruc-\ntions are frequently issued when dynamic content is being returned, to\nensure that browsers obtain a fresh version of this content on subse-\nquent occasions.\n■■ Almost all HTTP responses contain a message body following the blank\nline after the headers, and the Content-Typeheader indicates that the\nbody of this message contains an HTML document.\n■■ The Content-Lengthheader indicates the length of the message body in\nbytes.\nHTTP Methods\nWhen you are attacking web applications, you will be dealing almost exclu-\nsively with the most commonly used methods: GETand POST. There are some\nimportant differences between these methods which you need to be aware of,\nand which can affect an application’s security if overlooked.\nThe GETmethod is designed for retrieval of resources. It can be used to send\nparameters to the requested resource in the URL query string. This enables users\nto bookmark a URL for a dynamic resource that can be reused by themselves or\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 39\nChapter 3 ■ Web Application Technologies 39\nother users to retrieve the equivalent resource on a subsequent occasion (as in a\nbookmarked search query). URLs are displayed on-screen, and are logged in\nvarious places, such as the browser history and the web server’s access logs.\nThey are also transmitted in the Referer header to other sites when external\nlinks are followed. For these reasons, the query string should not be used to\ntransmit any sensitive information.\nThe POST method is designed for performing actions. With this method,\nrequest parameters can be sent both in the URL query string and in the body\nof the message. Although the URL can still be bookmarked, any parameters\nsent in the message body will be excluded from the bookmark. These parame-\nters will also be excluded from the various locations in which logs of URLs are\nmaintained and from the Referer header. Because the POST method is\ndesigned for performing actions, if a user clicks the Back button of the browser\nto return to a page that was accessed using this method, the browser will not\nautomatically reissue the request but will warn the user of what it is about to\ndo, as shown in Figure 3-1. This prevents users from unwittingly performing\nan action more than once. For this reason, POSTrequests should always be used\nwhen an action is being performed.\nFigure 3-1: Browsers do not automatically reissue POST requests made by users,\nbecause these might result in an action being performed more than once\nIn addition to the GET and POST methods, the HTTP protocol supports\nnumerous other methods that have been created for specific purposes. The\nother methods you are most likely to require knowledge of are:\n■■ HEAD — This functions in the same way as a GETrequest except that\nthe server should not return a message body in its response. The server\nshould return the same headers that it would have returned to the cor-\nresponding GETrequest. Hence, this method can be used for checking\nwhether a resource is present before making a GETrequest for it.\n■■ TRACE — This method is designed for diagnostic purposes. The server\nshould return in the response body the exact contents of the request\nmessage that it received. This can be used to detect the effect of any\nproxy servers between the client and server that may manipulate the\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 40\n40 Chapter 3 ■ Web Application Technologies\nrequest. It can also sometimes be used as part of an attack against other\napplication users (see Chapter 12).\n■■ OPTIONS — This method asks the server to report the HTTP methods\nthat are available for a particular resource. The server will typically\nreturn a response containing an Allowheader that lists the available\nmethods.\n■■ PUT — This method attempts to upload the specified resource to the\nserver, using the content contained in the body of the request. If this\nmethod is enabled, then you may be able to leverage it to attack the\napplication; for example, by uploading an arbitrary script and execut-\ning this on the server.\nMany other HTTP methods exist that are not directly relevant to attacking\nweb applications. However, a web server may expose itself to attack if certain\ndangerous methods are available. See Chapter 17 for further details on these\nand examples of using them in an attack.\nURLs\nA uniform resource locator (URL) is a unique identifier for a web resource, via\nwhich that resource can be retrieved. The format of most URLs is as follows:\nprotocol://hostname[:port]/[path/]file[?param=value]\nSeveral components in this scheme are optional, and the port number is nor-\nmally only included if it diverges from the default used by the relevant proto-\ncol. The URL used to generate the HTTP request shown earlier is:\nhttp://wahh-app.comm/books/search.asp?q=wahh\nIn addition to this absolute form, URLs may be specified relative to a partic-\nular host, or relative to a particular path on that host, for example:\n/books/search.asp?q=wahh\nsearch.asp?q=wahh\nThese relative forms are often used in web pages to describe navigation\nwithin the web site or application itself.\nNOTE The correct technical term for a URL is actually URI(or uniform\nresource identifier), but this term is really only used in formal specifications\nand by those who wish to exhibit their pedantry.\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 41\nChapter 3 ■ Web Application Technologies 41\nHTTP Headers\nHTTP supports a large number of different headers, some of which are\ndesigned for specific unusual purposes. Some headers can be used for both\nrequests and responses, while others are specific to one of these message types.\nThe headers you are likely to encounter when attacking web applications are\nlisted here.\nGeneral Headers\n■■ Connection — This is used to inform the other end of the communica-\ntion whether it should close the TCP connection after the HTTP trans-\nmission has completed or keep it open for further messages.\n■■ Content-Encoding— This is used to specify what kind of encoding is\nbeing used for the content contained in the message body, such as gzip,\nwhich is used by some applications to compress responses for faster\ntransmission.\n■■ Content-Length— This is used to specify the length of the message\nbody, in bytes (except in the case of responses to HEADrequests, when it\nindicates the length of the body in the response to the corresponding\nGETrequest).\n■■ Content-Type— This is used to specify the type of content contained in\nthe message body; for example, text/htmlfor HTML documents.\n■■ Transfer-Encoding— This is used to specify any encoding that was\nperformed on the message body to facilitate its transfer over HTTP. It is\nnormally used to specify chunked encoding when this is employed.\nRequest Headers\n■■ Accept — This is used to tell the server what kinds of content the client\nis willing to accept, such as image types, office document formats, and\nso on.\n■■ Accept-Encoding— This is used to tell the server what kinds of content\nencoding the client is willing to accept.\n■■ Authorization — This is used to submit credentials to the server for one\nof the built-in HTTP authentication types.\n■■ Cookie — This is used to submit cookies to the server which were pre-\nviously issued by it.\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 42\n42 Chapter 3 ■ Web Application Technologies\n■■ Host — This is used to specify the hostname that appeared in the full\nURL being requested.\n■■ If-Modified-Since— This is used to specify the time at which the\nbrowser last received the requested resource. If the resource has not\nchanged since that time, the server may instruct the client to use its\ncached copy, using a response with status code 304.\n■■ If-None-Match— This is used to specify an entity tag, which is an iden-\ntifier denoting the contents of the message body. The browser submits\nthe entity tag that the server issued with the requested resource when it\nwas last received. The server can use the entity tag to determine\nwhether the browser may use its cached copy of the resource.\n■■ Referer — This is used to specify the URL from which the current\nrequest originated.\n■■ User-Agent— This is used to provide information about the browser or\nother client software that generated the request.\nResponse Headers\n■■ Cache-Control— This is used to pass caching directives to the browser\n(for example, no-cache).\n■■ ETag — This is used to specify an entity tag. Clients can submit this\nidentifier in future requests for the same resource in the If-None-Match\nheader to notify the server which version of the resource the browser\ncurrently holds in its cache.\n■■ Expires — This is used to instruct the browser how long the contents of\nthe message body are valid for. The browser may use the cached copy\nof this resource until this time.\n■■ Location — This is used in redirection responses (those with a status\ncode starting with 3) to specify the target of the redirect.\n■■ Pragma — This is used to pass caching directives to the browser (for\nexample, no-cache).\n■■ Server — This is used to provide information about the web server soft-\nware being used.\n■■ Set-Cookie— This is used to issue cookies to the browser that it will\nsubmit back to the server in subsequent requests.\n■■ WWW-Authenticate— This is used in responses with a 401 status code\nto provide details of the type(s) of authentication supported by the\nserver.\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 43\nChapter 3 ■ Web Application Technologies 43\nCookies\nCookies are a key part of the HTTP protocol which most web applications rely\nupon, and which can frequently be used as a vehicle for exploiting vulnerabil-\nities. The cookie mechanism enables the server to send items of data to the\nclient, which the client stores and resubmits back to the server. Unlike the\nother types of request parameters (those within the URL query string or the\nmessage body), cookies continue to be resubmitted in each subsequent request\nwithout any particular action required by the application or the user.\nA server issues a cookie using the Set-Cookie response header, as already\nobserved:\nSet-Cookie: tracking=tI8rk7joMx44S2Uu85nSWc\nThe user’s browser will then automatically add the following header to sub-\nsequent requests back to the same server:\nCookie: tracking=tI8rk7joMx44S2Uu85nSWc\nCookies normally consist of a name/value pair, as shown, but may consist\nof any string that does not contain a space. Multiple cookies can be issued by\nusing multiple Set-Cookie headers in the server’s response, and are all sub-\nmitted back to the server in the same Cookie header, with a semicolon sepa-\nrating different individual cookies.\nIn addition to the cookie’s actual value, the Set-Cookie header can also\ninclude any of the following optional attributes, which can be used to control\nhow the browser handles the cookie:\n■■ expires — Used to set a date until which the cookie is valid. This will\ncause the browser to save the cookie to persistent storage, and it will be\nreused in subsequent browser sessions until the expiration date is\nreached. If this attribute is not set, the cookie is used only in the current\nbrowser session.\n■■ domain — Used to specify the domain for which the cookie is valid.\nThis must be the same or a parent of the domain from which the cookie\nis received.\n■■ path — Used to specify the URL path for which the cookie is valid.\n■■ secure– If this attribute is set, then the cookie will only ever be submit-\nted in HTTPS requests.\n■■ HttpOnly — If this attribute is set, then the cookie cannot be directly\naccessed via client-side JavaScript, although not all browsers support\nthis restriction.\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 44\n44 Chapter 3 ■ Web Application Technologies\nEach of these cookie attributes can impact the security of the application,\nand the primary impact is on the ability of an attacker to directly target other\nusers of the application. See Chapter 12 for further details.\nStatus Codes\nEach HTTP response message must contain a status code in its first line, indi-\ncating the result of the request. The status codes fall into five groups, accord-\ning to the first digit of the code:\n■■ 1xx — Informational.\n■■ 2xx — The request was successful.\n■■ 3xx — The client is redirected to a different resource.\n■■ 4xx — The request contains an error of some kind.\n■■ 5xx — The server encountered an error fulfilling the request.\nThere are numerous specific status codes, many of which are used only in\nspecialized circumstances. The status codes you are most likely to encounter\nwhen attacking a web application are listed here, together with the usual rea-\nson phrase associated with them:\n■■ 100 Continue— This response is sent in some circumstances when a\nclient submits a request containing a body. The response indicates that\nthe request headers were received and that the client should continue\nsending the body. The server will then return a second response when\nthe request has been completed.\n■■ 200 Ok — This indicates that the request was successful and the\nresponse body contains the result of the request.\n■■ 201 Created — This is returned in response to a PUTrequest to indicate\nthat the request was successful.\n■■ 301 Moved Permanently — This redirects the browser permanently to a\ndifferent URL, which is specified in the Locationheader. The client\nshould use the new URL in the future rather than the original.\n■■ 302 Found — This redirects the browser temporarily to a different URL,\nwhich is specified in the Locationheader. The client should revert to\nthe original URL in subsequent requests.\n■■ 304 Not Modified — This instructs the browser to use its cached copy\nof the requested resource. The server uses the If-Modified-Sinceand\nIf-None-Matchrequest headers to determine whether the client has the\nlatest version of the resource.\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 45\nChapter 3 ■ Web Application Technologies 45\n■■ 400 Bad Request — This indicates that the client submitted an invalid\nHTTP request. You will probably encounter this when you have modi-\nfied a request in certain invalid ways, for example by placing a space\ncharacter into the URL.\n■■ 401 Unauthorized — The server requires HTTP authentication before\nthe request will be granted. The WWW-Authenticateheader contains\ndetails of the type(s) of authentication supported.\n■■ 403 Forbidden — This indicates that no one is allowed to access the\nrequested resource, regardless of authentication.\n■■ 404 Not Found — This indicates that the requested resource does not\nexist.\n■■ 405 Method Not Allowed — This indicates that the method used in the\nrequest is not supported for the specified URL. For example, you may\nreceive this status code if you attempt to use the PUTmethod where it is\nnot supported.\n■■ 413 Request Entity Too Large — If you are probing for buffer overflow\nvulnerabilities in native code, and so submitting long strings of data,\nthis indicates that the body of your request is too large for the server to\nhandle.\n■■ 414 Request URI Too Long — Similar to the previous response, this\nindicates that the URL used in the request is too large for the server to\nhandle.\n■■ 500 Internal Server Error — This indicates that the server encountered\nan error fulfilling the request. This normally occurs when you have sub-\nmitted unexpected input that caused an unhandled error somewhere\nwithin the application’s processing. You should review the full contents\nof the server’s response closely for any details indicating the nature of\nthe error.\n■■ 503 Service Unavailable — This normally indicates that, although\nthe web server itself is functioning and able to respond to requests, the\napplication accessed via the server is not responding. You should verify\nwhether this is the result of any action that you have performed.\nHTTPS\nThe HTTP protocol uses plain TCP as its transport mechanism, which is unen-\ncrypted and so can be intercepted by an attacker who is suitably positioned on\nthe network. HTTPS is essentially the same application-layer protocol as\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 46\n46 Chapter 3 ■ Web Application Technologies\nHTTP, but this is tunneled over the secure transport mechanism, Secure Sock-\nets Layer (SSL). This protects the privacy and integrity of all data passing over\nthe network, considerably reducing the possibilities for noninvasive intercep-\ntion attacks. HTTP requests and responses function in exactly the same way\nregardless of whether SSL is used for transport.\nNOTE SSL has now strictly been superseded by transport layer security (TLS),\nbut the latter is still normally referred to using the older name.\nHTTP Proxies\nAn HTTP proxy server is a server that mediates access between the client\nbrowser and the destination web server. When a browser has been configured\nto use a proxy server, it makes all of its requests to that server, and the proxy\nrelays the requests to the relevant web servers, and forwards their responses\nback to the browser. Most proxies also provide additional services, including\ncaching, authentication, and access control.\nThere are two differences in the way HTTP works when a proxy server is\nbeing used, which you should be aware of:\n■■ When a browser issues an HTTP request to a proxy server, it places the\nfull URL into the request, including the protocol prefix http://and the\nhostname of the server. The proxy server extracts the hostname and\nuses this to direct the request to the correct destination web server.\n■■ When HTTPS is being used, the browser cannot perform the SSL hand-\nshake with the proxy server, as this would break the secure tunnel and\nleave the communications vulnerable to interception attacks. Hence, the\nbrowser must use the proxy as a pure TCP-level relay, which passes all\nnetwork data in both directions between the browser and the destina-\ntion web server, with which the browser performs an SSL handshake as\nnormal. To establish this relay, the browser makes an HTTP request to\nthe proxy server using the CONNECTmethod and specifying the destina-\ntion hostname and port number as the URL. If the proxy allows the\nrequest, it returns an HTTP response with a 200 status, keeps the TCP\nconnection open, and from that point onwards acts as a pure TCP-level\nrelay to the destination web server.\nBy some measure, the most useful item in your toolkit when attacking web\napplications is a specialized kind of proxy server that sits between your\nbrowser and the target web site and allows you to intercept and modify all\nrequests and responses, even those using HTTPS. We will begin examining\nhow you can use this kind of tool in the next chapter.\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 47\nChapter 3 ■ Web Application Technologies 47\nHTTP Authentication\nThe HTTP protocol includes its own mechanisms for authenticating users,\nusing various authentication schemes, including:\n■■ Basic — This is a very simple authentication mechanism that sends\nuser credentials as a Base64-encoded string in a request header with\neach message.\n■■ NTLM — This is a challenge-response mechanism and uses a version of\nthe Windows NTLM protocol.\n■■ Digest — This is a challenge-response mechanism and uses MD5\nchecksums of a nonce with the user’s credentials.\nIt is relatively rare to encounter these authentication protocols being used by\nweb applications deployed on the Internet, although they are more commonly\nused within organizations to access intranet-based services.\nCOMMON MYTH “Basic authentication is insecure.”\nBasic authentication places credentials in unencrypted form within the HTTP\nrequest, and so it is frequently stated that the protocol is insecure and should\nnot be used. But forms-based authentication, as used by numerous banks, also\nplaces credentials in unencrypted form within the HTTP request.\nAny HTTP message can be protected from eavesdropping attacks by\nusing HTTPS as a transport mechanism, which should be done by every\nsecurity-conscious application. In relation to eavesdropping at least, basic\nauthentication is in itself no worse than the methods used by the majority of\ntoday’s web applications.\nWeb Functionality\nIn addition to the core communications protocol used to send messages\nbetween client and server, web applications employ numerous different tech-\nnologies to deliver their functionality. Any reasonably functional application\nmay employ dozens of distinct technologies within its server and client com-\nponents. Before you can mount a serious attack against a web application, you\nneed a basic understanding of how its functionality is implemented, how the\ntechnologies used are designed to behave, and where their weak points are\nlikely to lie.\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 48\n48 Chapter 3 ■ Web Application Technologies\nServer-Side Functionality\nThe early World Wide Web contained entirely static content. Web sites con-\nsisted of various resources such as HTML pages and images, which were sim-\nply loaded onto a web server and delivered to any user who requested them.\nEach time a particular resource was requested, the server responded with the\nsame content.\nToday’s web applications still typically employ a fair number of static\nresources. However, a large amount of the content that they present to users is\ngenerated dynamically. When a user requests a dynamic resource, the server’s\nresponse is created on the fly, and each user may receive content that is\nuniquely customized for them.\nDynamic content is generated by scripts or other code executing on the\nserver. These scripts are akin to computer programs in their own right—they\nhave various inputs, perform processing on these, and return their outputs to\nthe user.\nWhen a user’s browser makes a request for a dynamic resource, it does not\nnormally simply ask for a copy of that resource. In general, it will also submit\nvarious parameters along with its request. It is these parameters that enable\nthe server-side application to generate content that is tailored to the individual\nuser. There are three main ways in which HTTP requests can be used to send\nparameters to the application:\n■■ In the URL query string.\n■■ In HTTP cookies.\n■■ In the body of requests using the POSTmethod.\nIn addition to these primary sources of input, the server-side application\nmay in principle use any part of the HTTP request as an input to its processing.\nFor example, an application may process the User-Agent header to generate\ncontent that is optimized for the type of browser being used.\nLike computer software in general, web applications employ a wide range\nof technologies on the server side to deliver their functionality. These include:\n■■ Scripting languages such as PHP, VBScript, and Perl.\n■■ Web application platforms such as ASP.NET and Java.\n■■ Web servers such as Apache, IIS, and Netscape Enterprise.\n■■ Databases such as MS-SQL, Oracle, and MySQL.\n■■ Other back-end components such as file systems, SOAP-based web ser-\nvices, and directory services.\nAll of these technologies and the types of vulnerabilities that can arise in\nrelation to them will be examined in detail throughout this book. Some of the\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 49\nChapter 3 ■ Web Application Technologies 49\nmost common web application platforms and languages you are likely to\nencounter are described in the following sections.\nThe Java Platform\nFor several years, the Java Platform, Enterprise Edition (formerly known as\nJ2EE) has been a de facto standard for large-scale enterprise applications.\nDeveloped by Sun Microsystems, it lends itself to multi-tiered and load-bal-\nanced architectures, and is well suited to modular development and code\nreuse. Because of its long history and widespread adoption, there are many\nhigh-quality development tools, application servers, and frameworks avail-\nable to assist developers. The Java Platform can be run on several underlying\noperating systems, including Windows, Linux, and Solaris.\nDescriptions of Java-based web applications often employ a number of\npotentially confusing terms that you may need to be aware of:\n■■ An Enterprise Java Bean(EJB) is a relatively heavyweight software\ncomponent that encapsulates the logic of a specific business function\nwithin the application. EJBs are intended to take care of various techni-\ncal challenges that application developers must address, such as trans-\nactional integrity.\n■■ A Plain Old Java Object(POJO) is an ordinary Java object, as distinct\nfrom a special object like an EJB. POJO is normally used to denote\nobjects that are user-defined and much simpler and more lightweight\nthan EJBs and those used in other frameworks.\n■■ A Java Servletis an object that resides on an application server and\nreceives HTTP requests from clients and returns HTTP responses. There\nare numerous useful interfaces that Servlet implementations can use to\nfacilitate the development of useful applications.\n■■ A Java web containeris a platform or engine that provides a runtime\nenvironment for Java-based web applications. Examples of Java web\ncontainers are Apache Tomcat, BEA WebLogic, and JBoss.\nMany Java web applications employ third-party and open source compo-\nnents alongside custom-built code. This is an attractive option because it\nreduces development effort, and Java is well-suited to this modular approach.\nExamples of components commonly used for key application functions are:\n■■ Authentication — JAAS, ACEGI\n■■ Presentation layer— SiteMesh, Tapestry\n■■ Database object relational mapping— Hibernate\n■■ Logging — Log4J\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 50\n50 Chapter 3 ■ Web Application Technologies\nIf you can determine which open source packages are used in the applica-\ntion you are attacking, you can download these and perform a code review or\ninstall them to experiment on. A vulnerability in any of these may be\nexploitable to compromise the wider application.\nASP.NET\nASP.NET is Microsoft’s web application framework and is a direct competitor\nto the Java Platform. ASP.NET is several years younger than its counterpart\nbut has made some inroads into Java’s territory.\nASP.NET uses Microsoft’s .NET Framework, which provides a virtual\nmachine (the Common Language Runtime) and a set of powerful APIs. Hence,\nASP.NET applications can be written in any .NET language, such as C# or\nVB.NET.\nASP.NET lends itself to the event-driven programming paradigm which is\nnormally used in conventional desktop software, rather than the script-based\napproach used in most earlier web application frameworks. This, together\nwith the powerful development tools provided with Visual Studio, make\ndeveloping a functional web application extremely easy for anyone with min-\nimal programming skills.\nThe ASP.NET framework helps to protect against some common web appli-\ncation vulnerabilities such as cross-site scripting, without requiring any effort by\nthe developer. However, one practical downside of its apparent simplicity is that\nmany small-scale ASP.NET applications are actually created by beginners who\nlack any awareness of the core security problems faced by web applications.\nPHP\nThe PHP language emerged out of a hobby project (the acronym originally\nstood for personal home page). It has since evolved almost unrecognizably\ninto a highly powerful and rich framework for developing web applications. It\nis often used in conjunction with other free technologies in what is known as\nthe LAMP stack (comprising Linux, Apache, MySQL, and PHP).\nNumerous open source applications and components have been developed\nusing PHP. Many of these provide off-the-shelf solutions for common applica-\ntion functions, which are often incorporated into wider custom-built applica-\ntions, for example:\n■■ Bulletin boards— PHPBB, PHP-Nuke\n■■ Administrative front ends— PHPMyAdmin\n■■ Web mail— SquirrelMail, IlohaMail\n■■ Photo galleries— Gallery\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 51\nChapter 3 ■ Web Application Technologies 51\n■■ Shopping carts— osCommerce, ECW-Shop\n■■ Wikis— MediaWiki, WakkaWikki\nBecause PHP is free and easy to use, it has often been the language of choice\nfor many beginners writing web applications. Further, the design and default\nconfiguration of the PHP framework has historically made it easy for pro-\ngrammers to unwittingly introduce security bugs into their code. These factors\nhave meant that applications written in PHP have suffered from a dispropor-\ntionate number of security vulnerabilities. In addition to this, several defects\nhave existed within the PHP platform itself, which could often be exploited via\napplications running on it. See Chapter 18 for details of common defects aris-\ning in PHP applications.\nClient-Side Functionality\nIn order for the server-side application to receive user input and actions, and\npresent the results of these back to the user, it needs to provide a client-side\nuser interface. Because all web applications are accessed via a web browser,\nthese interfaces all share a common core of technologies. However, these have\nbeen built upon in various diverse ways, and the ways in which applications\nleverage client-side technology has continued to evolve rapidly in recent\nyears.\nHTML\nThe core technology used to build web interfaces is the hypertext markup lan-\nguage (HTML). This is a tag-based language that is used to describe the struc-\nture of documents that are rendered within the browser. From its simple\nbeginnings as a means of providing basic formatting to text documents,\nHTML has developed into a rich and powerful language that can be used to\ncreate highly complex and functional user interfaces.\nHyperlinks\nA large amount of communication from client to server is driven by the user\nclicking on hyperlinks. In web applications, hyperlinks frequently contain pre-\nset request parameters. These are items of data which are never entered by the\nuser but which are submitted because the server placed them into the target\nURL of the hyperlink on which the user clicks. For example, a web application\nmight present a series of links to news stories, each having the following form:\n<a href=”/news/showStory?newsid=19371130&lang=en”>Sale now on!</a>\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 52\n52 Chapter 3 ■ Web Application Technologies\nWhen a user clicks on this link, the browser makes the following request:\nGET /news/showStory?newsid=19371130&lang=en HTTP/1.1\nHost: wahh-app.com\n...\nThe server receives the two parameters in the query string (newsid and\nlang) and uses their values to determine what content should be presented to\nthe user.\nForms\nWhile hyperlink-based navigation is responsible for the majority of client-to-\nserver communications, in most web applications there is a need for more flex-\nible ways of gathering input and receiving actions from users. HTML forms\nare the usual mechanism for allowing users to enter arbitrary input via their\nbrowser. A typical form is as follows:\n<form action=”/secure/login.php?app=quotations” method=”post”>\nusername: <input type=”text” name=”username”><br>\npassword: <input type=”password” name=”password”>\n<input type=”hidden” name=”redir” value=”/secure/home.php”>\n<input type=”submit” name=”submit” value=”log in”>\n</form>\nWhen the user enters values into the form and clicks the submit button, the\nbrowser makes a request like the following:\nPOST /secure/login.php?app=quotations HTTP/1.1\nHost: wahh-app.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 39\nCookie: SESS=GTnrpx2ss2tSWSnhXJGyG0LJ47MXRsjcFM6Bd\nusername=daf&password=foo&redir=/secure/home.php&submit=log+in\nIn this request, there are several points of interest reflecting how different\naspects of the request are used to control server-side processing:\n■■ Because the HTML form tag contained an attribute specifying the POST\nmethod, the browser uses this method to submit the form, and places\nthe data from the form into the body of the request message.\n■■ In addition to the two items of data entered by the user, the form con-\ntains a hidden parameter (redir) and a submit parameter (submit).\nBoth of these are submitted in the request and may be used by the\nserver-side application to control its logic.\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 53\nChapter 3 ■ Web Application Technologies 53\n■■ The target URL for the form submission contains a preset parameter\n(app), as in the hyperlink example shown previously. This parameter\nmay be used to control the server-side processing.\n■■ The request contains a cookie parameter (SESS), which was issued to\nthe browser in an earlier response from the server. This parameter may\nbe used to control the server-side processing.\nThe previous request contains a header specifying that the type of content in\nthe message body is x-www-form-urlencoded. This means that parameters are\nrepresented in the message body as name/value pairs in the same way as they\nare in the URL query string. The other content type you are likely to encounter\nwhen form data is submitted is multipart/form-data. An application can\nrequest that browsers use multipart encoding by specifying this in an enctype\nattribute in the form tag. With this form of encoding, the Content-Typeheader\nin the request will also specify a random string that is used as a separator for\nthe parameters contained in the request body. For example, if the form speci-\nfied multipart encoding, the resulting request would look like the following:\nPOST /secure/login.php?app=quotations HTTP/1.1\nHost: wahh-app.com\nContent-Type: multipart/form-data; boundary=------------7d71385d0a1a\nContent-Length: 369\nCookie: SESS=GTnrpx2ss2tSWSnhXJGyG0LJ47MXRsjcFM6Bd\n------------7d71385d0a1a\nContent-Disposition: form-data; name=”username”\ndaf\n------------7d71385d0a1a\nContent-Disposition: form-data; name=”password”\nfoo\n------------7d71385d0a1a\nContent-Disposition: form-data; name=”redir”\n/secure/home.php\n------------7d71385d0a1a\nContent-Disposition: form-data; name=”submit”\nlog in\n------------7d71385d0a1a--\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 54\n54 Chapter 3 ■ Web Application Technologies\nJavaScript\nHyperlinks and forms can be used to create a rich user interface capable of eas-\nily gathering most kinds of input which web applications require. However,\nmost applications employ a more distributed model, in which the client side is\nused not simply to submit user data and actions but also to perform actual pro-\ncessing of data. This is done for two primary reasons:\n■■ It can improve the application’s performance, because certain tasks can\nbe carried out entirely on the client component, without needing to\nmake a round trip of request and response to the server.\n■■ It can enhance usability, because parts of the user interface can be\ndynamically updated in response to user actions, without needing to\nload an entirely new HTML page delivered by the server.\nJavaScript is a relatively simple but powerful programming language that\ncan be easily used to extend web interfaces in ways that are not possible using\nHTML alone. It is commonly used to perform the following tasks:\n■■ Validating user-entered data before this is submitted to the server, to\navoid unnecessary requests if the data contains errors.\n■■ Dynamically modifying the user interface in response to user actions;\nfor example, to implement drop-down menus and other controls famil-\niar from non-web interfaces.\n■■ Querying and updating the document object model (DOM) within the\nbrowser to control the browser’s behavior.\nA significant development in the use of JavaScript has been the appearance\nof AJAX techniques for creating a smoother user experience which is closer to\nthat provided by traditional desktop applications. AJAX (or Asynchronous\nJavaScript and XML) involves issuing dynamic HTTP requests from within an\nHTML page, to exchange data with the server and update the current web\npage accordingly, without loading a new page altogether. These techniques\ncan provide very rich and satisfying user interfaces. They can also sometimes\nbe used by attackers to powerful effect, and may introduce vulnerabilities of\ntheir own if not carefully implemented (see Chapter 12).\nThick Client Components\nGoing beyond the capabilities of JavaScript, some web applications employ\nthicker client technologies that use custom binary code to extend the browser’s\nbuilt-in capabilities in arbitrary ways. These components may be deployed as\nbytecode that is executed by a suitable browser plug-in, or may involve\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 55\nChapter 3 ■ Web Application Technologies 55\ninstalling native executables onto the client computer itself. The thick-client\ntechnologies you are likely to encounter when attacking web applications are:\n■■ Java applets\n■■ ActiveX controls\n■■ Shockwave Flash objects\nThese technologies are described in detail in Chapter 5.\nState and Sessions\nThe technologies described so far enable the server and client components of a\nweb application to exchange and process data in numerous ways. To imple-\nment most kinds of useful functionality, however, applications need to track\nthe state of each user’s interaction with the application across multiple\nrequests. For example, a shopping application may allow users to browse a\nproduct catalogue, add items to a cart, view and update the cart contents, pro-\nceed to checkout, and provide personal and payment details.\nTo make this kind of functionality possible, the application must maintain a\nset of stateful data generated by the user’s actions across several requests. This\ndata is normally held within a server-side structure called a session. When a\nuser performs an action, such as adding an item to her shopping cart, the\nserver-side application updates the relevant details within the user’s session.\nWhen the user later views the contents of her cart, data from the session is\nused to return the correct information to the user.\nIn some applications, state information is stored on the client component\nrather than the server. The current set of data is passed to the client in each\nserver response, and is sent back to the server in each client request. Of course,\nbecause any data transmitted via the client component may be modified by the\nuser, applications need to take measures to protect themselves from attackers\nwho may change this state information in an attempt to interfere with the\napplication’s logic. The ASP.NET platform makes use of a hidden form field\ncalled the ViewState to store state information about the user’s web interface\nand so reduce overhead on the server. By default, the contents of the ViewState\ninclude a keyed hash to prevent tampering.\nBecause the HTTP protocol is itself stateless, most applications need a\nmeans of re-identifying individual users across multiple requests, in order for\nthe correct set of state data to be used to process each request. This is normally\nachieved by issuing each user a token which uniquely identifies that user’s\nsession. These tokens may be transmitted using any type of request parameter,\nbut HTTP cookies are used by most applications. Several kinds of vulnerabil-\nity arise in relation to session handling, and these are described in detail in\nChapter 7.\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 56\n56 Chapter 3 ■ Web Application Technologies\nEncoding Schemes\nWeb applications employ several different encoding schemes for their data.\nBoth the HTTP protocol and the HTML language are historically text-based,\nand different encoding schemes have been devised to ensure that unusual\ncharacters and binary data can be safely handled by these mechanisms. When\nyou are attacking a web application, you will frequently need to encode data\nusing a relevant scheme to ensure that it is handled in the way you intend. Fur-\nther, in many cases you may be able to manipulate the encoding schemes used\nby an application to cause behavior that its designers did not intend.\nURL Encoding\nURLs are permitted to contain only the printable characters in the US-ASCII\ncharacter set—that is, those whose ASCII code is in the range 0x20–0x7e\ninclusive. Further, several characters within this range are restricted because\nthey have special meaning within the URL scheme itself or within the HTTP\nprotocol.\nThe URL encoding scheme is used to encode any problematic characters\nwithin the extended ASCII character set so that they can be safely transported\nover HTTP. The URL-encoded form of any character is the %prefix followed by\nthe character’s two-digit ASCII code expressed in hexadecimal. Some exam-\nples of characters that are commonly URL-encoded are shown here:\n%3d =\n%25 %\n%20 space\n%0a new line\n%00 null byte\nA further encoding to be aware of is the +character, which represents a URL-\nencoded space (in addition to the %20representation of a space).\nNOTE For the purpose of attacking web applications, you should URL-encode\nany of the following characters when you are inserting them as datainto an\nHTTP request:\nspace % ? & = ; + #\n(Of course, you will often need to use these characters with their special\nmeaning when modifying a request—for example, to add an additional request\nparameter to the query string. In this case, they should be used in their literal\nform.)\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 57\nChapter 3 ■ Web Application Technologies 57\nUnicode Encoding\nUnicode is a character encoding standard that is designed to support all of the\nwriting systems used in the world. It employs various encoding schemes, some\nof which can be used to represent unusual characters in web applications.\n16-bit Unicode encoding works in a similar way to URL-encoding. For\ntransmission over HTTP, the 16-bit Unicode-encoded form of a character is the\n%u prefix followed by the character’s Unicode code point expressed in hexa-\ndecimal. For example:\n%u2215 /\n%u00e9 é\nUTF-8 is a variable-length encoding standard that employs one or more\nbytes to express each character. For transmission over HTTP, the UTF-8\nencoded form of a multi-byte character simply uses each byte expressed in\nhexadecimal and preceded by the %prefix. For example:\n%c2%a9 ©\n%e2%89%a0 ≠\nFor the purpose of attacking web applications, Unicode encoding is primar-\nily of interest because it can sometimes be used to defeat input validation\nmechanisms. If an input filter blocks certain malicious expressions, but the\ncomponent that subsequently processes the input understands Unicode\nencoding, then it may be possible to bypass the filter using various standard\nand malformed Unicode encodings.\nHTML Encoding\nHTML encoding is a scheme used to represent problematic characters so that\nthey can be safely incorporated into an HTML document. Various characters\nhave special meaning as meta-characters within HTML and are used to define\nthe structure of a document rather than its content. To use these characters\nsafely as part of the document’s content, it is necessary to HTML-encode them.\nHTML encoding defines numerous HTML entities to represent specific lit-\neral characters, for example:\n&quot; “\n&apos; ‘\n&amp; &\n&lt; <\n&gt; >\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 58\n58 Chapter 3 ■ Web Application Technologies\nIn addition, any character can be HTML-encoded using its ASCII code in\ndecimal form, for example:\n&#34; “\n&#39; ‘\nor by using its ASCII code in hexadecimal form (prefixed by an x), for example:\n&#x22; “\n&#x27; ‘\nWhen you are attacking a web application, your main interest in HTML\nencoding is likely to be when probing for cross-site scripting vulnerabilities. If\nan application returns user input unmodified within its responses, then it is\nprobably vulnerable, whereas if dangerous characters are HTML-encoded\nthen it is probably safe. See Chapter 12 for more details of these vulnerabilities.\nBase64 Encoding\nBase64 encoding allows any binary data to be safely represented using only\nprintable ASCII characters. It is commonly used for encoding email attach-\nments for safe transmission over SMTP, and is also used to encode user cre-\ndentials in basic HTTP authentication.\nBase64 encoding processes input data in blocks of three bytes. Each of these\nblocks is divided into four chunks of six bits each. Six bits of data allow for 64\ndifferent possible permutations, and so each chunk can be represented using a\nset of 64 characters. Base64 encoding employs the following character set,\nwhich contains only printable ASCII characters:\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\nIf the final block of input data results in less than three chunks of output\ndata, then the output is padded with one or two =characters.\nFor example, the Base64-encoded form of The Web Application Hacker’s Hand-\nbookis:\nVGhlIFdlYiBBcHBsaWNhdGlvbiBIYWNrZXIncyBIYW5kYm9vaw==\nMany web applications make use of Base64 encoding for transmitting\nbinary data within cookies and other parameters, and even for obfuscating\nsensitive data to prevent trivial modification. You should always look out for,\nand decode, any Base64 data that is issued to the client. Base64-encoded\nstrings can often be easily recognized from their specific character set and the\npresence of padding characters at the end of the string.\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 59\nChapter 3 ■ Web Application Technologies 59\nHex Encoding\nMany applications use straightforward hexadecimal encoding when transmit-\nting binary data, using ASCII characters to represent the hexadecimal block.\nFor example, hex-encoding the username “daf” within a cookie would result in:\n646166\nAs with Base64, hex-encoded data is usually easy to spot, and you should\nalways attempt to decode any such data that the server sends to the client, to\nunderstand its function.\nNext Steps\nSo far, we have described the current state of web application (in)security,\nexamined the core mechanisms by which web applications can defend them-\nselves, and taken a brief look at the key technologies employed in today’s\napplications. With this groundwork in place, we are now in a position to start\nlooking at the actual practicalities of attacking web applications.\nIn any attack, your first task is to map the target application’s content and\nfunctionality, to establish how it functions, how it attempts to defend itself,\nand what technologies it uses. The next chapter examines this mapping\nprocess in detail and shows how you can use it to obtain a deep understand-\ning of an application’s attack surface that will prove vital when it comes to\nfinding and exploiting security flaws within your target.\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. What is the OPTIONSmethod used for?\n2. What are the If-Modified-Sinceand If-None-Matchheaders used for?\nWhy might you be interested in these when attacking an application?\n3. What is the significance of the secureflag when a server sets a cookie?\n4. What is the difference between the common status codes 301 and 302?\n5. How does a browser interoperate with a web proxy when SSL is being\nused?\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 60"
  },
  {
    "input": "What is the purpose and process of mapping an application during a security assessment?",
    "summary": "Mapping an application involves identifying its content and functionality to understand its structure and potential vulnerabilities. This process includes manual browsing, automated spidering, and discovering hidden content through techniques like brute-forcing and analyzing server responses. It also involves identifying server-side technologies and common vulnerabilities such as SQL injection, path traversal, and cross-site scripting. The goal is to create a comprehensive map of the application's attack surface to prioritize testing for exploitable weaknesses.",
    "output": "70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 61\nCHAPTER\n4\nMapping the Application\nThe first step in the process of attacking an application is to gather and exam-\nine some key information about it, in order to gain a better understanding of\nwhat you are up against.\nThe mapping exercise begins by enumerating the application’s content and\nfunctionality, in order to understand what the application actually does and\nhow it behaves. Much of this functionality will be easy to identify, but some of\nit may be hidden away, and require a degree of guesswork and luck in order to\ndiscover.\nHaving assembled a catalogue of the application’s functionality, the princi-\npal task is to closely examine every aspect of its behavior, its core security\nmechanisms, and the technologies being employed (on both client and server).\nThis will enable you to identify the key attack surface that the application\nexposes and hence the most interesting areas on which to target subsequent\nprobing to find exploitable vulnerabilities.\nIn this chapter, we will describe the practical steps you need to follow dur-\ning application mapping, various techniques and tricks you can use to maxi-\nmize its effectiveness, and some tools that can assist you in the process.\n61\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 62\n62 Chapter 4 ■ Mapping the Application\nEnumerating Content and Functionality\nIn a typical application, the majority of the content and functionality can be\nidentified via manual browsing. The basic approach is to walk through the\napplication starting from the main initial page, following every link and navi-\ngating through all multistage functions (such as user registration or password\nresetting). If the application contains a “site map,” this can provide a useful\nstarting point for enumerating content.\nHowever, to perform a rigorous inspection of the enumerated content, and\nto obtain a comprehensive record of everything identified, it is necessary to\nemploy some more advanced techniques than simple browsing.\nWeb Spidering\nVarious tools exist which perform automated spidering of web sites. These\ntools work by requesting a web page, parsing it for links to other content,\nand then requesting these, continuing recursively until no new content is\ndiscovered.\nBuilding on this basic function, web application spiders attempt to achieve\na higher level of coverage by also parsing HTML forms and submitting these\nback to the application using various preset or random values. This can enable\nthem to walk through multistage functionality, and to follow forms-based nav-\nigation (e.g., where drop-down lists are used as content menus). Some tools\nalso perform some parsing of client-side JavaScript to extract URLs pointing to\nfurther content. The following free tools all do a decent job of enumerating\napplication content and functionality (see Chapter 19 for a detailed analysis of\ntheir capabilities):\n■■ Paros\n■■ Burp Spider (part of Burp Suite)\n■■ WebScarab\nFigure4-1 shows the results of using Burp Spider to map part of an application.\nTIP Many web servers contain a file named robots.txtin the web root,\nwhich contains a list of URLs that the site does not wish web spiders to visit or\nsearch engines to index. Sometimes, this file contains references to sensitive\nfunctionality, which you are certainly interested in spidering. Some spidering\ntools designed for attacking web applications will check for the robots.txt\nfile and use all URLs within it as seeds in the spidering process.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 63\nChapter 4 ■ Mapping the Application 63\nFigure4-1: Mapping part of an application using Burp Spider\nWhile it can often be effective, there are some important limitations of this\nkind of fully automated approach to content enumeration:\n■■ Unusual navigation mechanisms (such as menus dynamically created\nand handled using complicated JavaScript code) are often not handled\nproperly by these tools, and so they may miss whole areas of an appli-\ncation.\n■■ Multistage functionality often implements fine-grained input validation\nchecks, which do not accept the values that may be submitted by an auto-\nmated tool. For example, a user registration form may contain fields for\nname, email address, telephone number, and ZIP code. An automated\napplication spider will typically submit a single test string in each\neditable form field, and the application will return an error message say-\ning that one or more of the items submitted were invalid. Because the spi-\nder is not intelligent enough to understand and act upon this message, it\nwill not proceed past the registration form and so will not discover any\nfurther content or functions accessible beyond it.\n■■ Automated spiders typically use URLs as identifiers of unique content.\nTo avoid continuing spidering indefinitely, they recognize when linked\ncontent has already been requested and do not request it again. How-\never, many applications use forms-based navigation in which the same\nURL may return very different content and functions. For example, a\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 64\n64 Chapter 4 ■ Mapping the Application\nbanking application may implement every user action via a POST\nrequest to /account.jsp, and use parameters to communicate the\naction being performed. If a spider refuses to make multiple requests to\nthis URL, it will miss most of the application’s content. Some applica-\ntion spiders attempt to handle this situation (for example, Burp Spider\ncan be configured to individuate form submissions based on parameter\nnames and values); however, there may still be situations where a fully\nautomated approach is not completely effective.\n■■ Conversely to the previous point, some applications place volatile data\nwithin URLs that is not actually used to identify resources or functions\n(for example, parameters containing timers or random number seeds).\nEach page of the application may contain what appears to be a new set\nof URLs that the spider must request, causing it to continue running\nindefinitely.\n■■ Where an application uses authentication, an effective application spi-\nder must be able to handle this in order to access the functionality that\nit protects. The spiders mentioned previously can achieve this, by man-\nually configuring them either with a token for an authenticated session\nor with credentials to submit to the login function. However, even\nwhen this is done, it is common to find that the operation of the spider\nbreaks the authenticated session for various reasons:\n■■ By following all URLs, the spider will at some point request the\nlogout function, causing its session to break.\n■■ If the spider submits invalid input to a sensitive function, the appli-\ncation may defensively terminate the session.\n■■ If the application uses per-page tokens, the spider will almost cer-\ntainly fail to handle these properly by requesting pages out of their\nexpected sequence, probably causing the entire session to be termi-\nnated.\nWARNING In some applications, running even a simple web spider that\nparses and requests links can be extremely dangerous. For example, an\napplication may contain administrative functionality that deletes users, shuts\ndown a database, restarts the server, and the like. If an application-aware\nspider is used, great damage can be done if the spider discovers and uses\nsensitive functionality. The authors have encountered an application that\nincluded functionality to edit the actual content of the main application. This\nfunctionality was discoverable via the site map and was not protected by any\naccess control. If an automated spider were run against this site, it would find\nthe edit function and begin sending arbitrary data, resulting in the main web\nsite being defaced in real time while the spider was running.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 65\nChapter 4 ■ Mapping the Application 65\nUser-Directed Spidering\nThis is a more sophisticated and controlled technique, which is usually prefer-\nable to automated spidering. Here, the user walks through the application in\nthe normal way using a standard browser, attempting to navigate through all\nof the application’s functionality. As he does so, the resulting traffic is passed\nthrough a tool combining an intercepting proxy and spider, which monitors all\nrequests and responses. The tool builds up a map of the application, incorpo-\nrating all of the URLs visited by the browser, and also parses all of the applica-\ntion’s responses in the same way as a normal application-aware spider and\nupdates the site map with the content and functionality it discovers. The spi-\nders within Burp Suite and WebScarab can be used in this way (see Chapter 19\nfor further information).\nCompared with the basic spidering approach, this technique carries numer-\nous benefits:\n■■ Where the application uses unusual or complex mechanisms for navi-\ngation, the user can follow these using a browser in the normal way.\nAny functions and content accessed by the user will be processed by\nthe proxy/spider tool.\n■■ The user controls all data submitted to the application and can ensure\nthat data validation requirements are met.\n■■ The user can log in to the application in the usual way, and ensure that\nthe authenticated session remains active throughout the mapping\nprocess. If any action performed results in session termination, the user\ncan log in again and continue browsing.\n■■ Any dangerous functionality, such as deleteUser.jsp, will be fully\nenumerated and incorporated into the site map, because links to it will\nbe parsed out of the application’s responses. But the user can use his\ndiscretion in deciding which functions to actually request or carry out.\nTIP In addition to the proxy/spider tools just described, another range of\ntools that are often useful during application mapping are the various browser\nextensions that can perform HTTP and HTML analysis from within the browser\ninterface. For example, the IEWatch tool illustrated in Figure4-2, which runs\nwithin Microsoft Internet Explorer, monitors all details of requests and\nresponses, including headers, request parameters, and cookies, and analyzes\nevery application page to display links, scripts, forms, and thick-client\ncomponents. While all of this information can, of course, be viewed in\nyour intercepting proxy, having a second record of useful mapping data can\nonly help you better understand the application and enumerate all of its\nfunctionality. See Chapter 19 for more information about tools of this kind.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 66\n66 Chapter 4 ■ Mapping the Application\nFigure4-2:IEWatch performing HTTP and HTML analysis from within the browser\nHACK STEPS\n■ Configure your browser to use either Burp or WebScarab as a local proxy\n(see Chapter 19 for specific details about how to do this if you are unsure).\n■ Browse the entire application normally, attempting to visit every single\nlink/URL you discover, submitting every single form, and proceeding\nthrough all multistep functions to completion. Try browsing with\nJavaScript enabled and disabled, and with cookies enabled and disabled.\nMany applications can handle various browser configurations, and you\nmay reach different content and code paths within the application.\n■ Review the site map generated by the proxy/spider tool, and identify any\napplication content or functions that you did not browse manually.\nEstablish how the spider enumerated each item—for example, in Burp\nSpider, check the Linked From details. Using your browser, access the\nitem manually, so that the response from the server is parsed by the\nproxy/spider tool to identify any further content. Continue this step\nrecursively until no further content or functionality is identified.\n■ Optionally, tell the tool to actively spider the site using all of the already\nenumerated content as a starting point. To do this, first identify any URLs\nthat are dangerous or likely to break the application session, and config-\nure the spider to exclude these from its scope. Run the spider and review\nthe results for any additional content that it discovers.\n■ The site map generated by the proxy/spider tool contains a wealth of\ninformation about the target application, which will be useful later in\nidentifying the various attack surfaces exposed by the application.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 67\nChapter 4 ■ Mapping the Application 67\nDiscovering Hidden Content\nIt is very common for applications to contain content and functionality which\nis not directly linked or reachable from the main visible content. A common\nexample of this is functionality that has been implemented for testing or\ndebugging purposes and has never been removed.\nAnother example arises where the application presents different functional-\nity to different categories of users (for example, anonymous users, authenti-\ncated regular users, and administrators). Users at one privilege level who\nperform exhaustive spidering of the application may miss functionality that is\nvisible to users at other levels. An attacker who discovers the functionality\nmay be able to exploit it to elevate her privileges within the application.\nThere are countless other cases in which interesting content and functional-\nity may exist that the mapping techniques previously described would not\nidentify, including:\n■■ Backup copies of live files. In the case of dynamic pages, their file exten-\nsion may have changed to one that is not mapped as executable,\nenabling you to review the page source for vulnerabilities that can then\nbe exploited on the main page.\n■■ Backup archives that contain a full snapshot of files within (or indeed\noutside) the web root, possibly enabling you to easily identify all con-\ntent and functionality within the application.\n■■ New functionality that has been deployed to the server for testing but\nnot yet linked from the main application.\n■■ Old versions of files that have not been removed from the server. In the\ncase of dynamic pages, these may contain vulnerabilities that have been\nfixed in the current version but can still be exploited in the old version.\n■■ Configuration and include files containing sensitive data such as data-\nbase credentials.\n■■ Source files out of which the live application’s functionality has been\ncompiled.\n■■ Log files that may contain sensitive information such as valid user-\nnames, session tokens, URLs visited, actions performed, and so on.\nEffective discovery of hidden content requires a combination of automated\nand manual techniques, and often relies upon a degree of luck.\nBrute-Force Techniques\nIn Chapter 13, we will describe how automated techniques can be leveraged to\nspeed up just about any attack against an application. In the present context,\nautomation can be used to make huge numbers of requests to the web server,\nattempting to guess the names or identifiers of hidden functionality.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 68\n68 Chapter 4 ■ Mapping the Application\nFor example, suppose that your user-directed spidering has identified the\nfollowing application content:\nhttps://wahh-app.com/login.php\nhttps://wahh-app.com/home/myaccount.php\nhttps://wahh-app.com/home/logout.php\nhttps://wahh-app.com/help/\nhttps://wahh-app.com/register.php\nhttps://wahh-app.com/menu.js\nhttps://wahh-app.com/scripts/validate.js\nThe first step in an automated effort to identify hidden content might\ninvolve the following requests, to locate additional directories:\nhttps://wahh-app.com/access/\nhttps://wahh-app.com/account/\nhttps://wahh-app.com/accounts/\nhttps://wahh-app.com/accounting/\nhttps://wahh-app.com/admin/\nhttps://wahh-app.com/agent/\nhttps://wahh-app.com/agents/\n...\nNext, the following requests could be made, to locate additional pages:\nhttps://wahh-app.com/access.php\nhttps://wahh-app.com/account.php\nhttps://wahh-app.com/accounts.php\nhttps://wahh-app.com/accounting.php\nhttps://wahh-app.com/admin.php\nhttps://wahh-app.com/agent.php\nhttps://wahh-app.com/agents.php\n...\nhttps://wahh-app.com/home/access.php\nhttps://wahh-app.com/home/account.php\nhttps://wahh-app.com/home/accounts.php\nhttps://wahh-app.com/home/accounting.php\nhttps://wahh-app.com/home/admin.php\nhttps://wahh-app.com/home/agent.php\nhttps://wahh-app.com/home/agents.php\n...\nNOTE Do not assume that the application will respond with “200 OK” if a\nrequested resource exists, and “404 Not Found” if it does not. Many\napplications handle requests for nonexistent resources in a customized way,\noften returning a bespoke error message and a 200 response code. Further,\nsome requests for existent resources may receive a non-200 response. The\nfollowing is a rough guide to the likely meaning of the response codes that you\nmay encounter during a brute-forcing exercise looking for hidden content:\n■■ 302 Found—If the redirect is to a login page, the resource may be\naccessible only by authenticated users. If it is to an error message, this\nmay disclose a different reason. If it is to another location, the redirect\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 69\nChapter 4 ■ Mapping the Application 69\nmay be part of the application’s intended logic, and this should be\ninvestigated further.\n■■ 400 Bad Request – The application may use a custom naming scheme\nfor directories and files within URLs, which a particular request has not\ncomplied with. More likely, however, is that the wordlist you are using\ncontains some whitespace characters or other invalid syntax.\n■■ 401 Unauthorized or 403 Forbidden – This usually indicates that the\nrequested resource exists but may not be accessed by any user,\nregardless of authentication status or privilege level. It often occurs when\ndirectories are requested, and you may infer that the directory exists.\n■■ 500 Internal Server Error – During content discovery, this usually\nindicates that the application expects certain parameters to be\nsubmitted when requesting the resource.\nThe various possible responses that may indicate the presence of interesting\ncontent mean that is difficult to write a fully automated script to output a list-\ning of valid resources. The best approach is to capture as much information as\npossible about the application’s responses during the brute-force exercise, and\nmanually review it.\nBurp Intruder can be used to iterate through a list of common directory\nnames and capture details of the server’s responses, which can be reviewed to\nidentify valid directories. Figure4-3 shows Burp Intruder being configured to\nprobe for common directories residing at the web root.\nFigure4-3: Burp Intruder being configured to probe for common directories\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 70\n70 Chapter 4 ■ Mapping the Application\nWhen the attack has been executed, clicking on column headers such as\n“status” and “length” will sort the results accordingly, enabling anomalies to\nbe quickly picked out, as shown in Figure4-4.\nFigure4-4: The results of a test probing for common directories\nHACK STEPS\n■ Make some manual requests for known valid and invalid resources, and\nidentify how the server handles the latter.\n■ Use the site map generated through user-directed spidering as a basis for\nautomated discovery of hidden content.\n■ Make automated requests for common filenames and directories within\neach directory or path known to exist within the application. Use Burp\nIntruder or a custom script, together with wordlists of common files and\ndirectories, to quickly generate large numbers of requests. If you have\nidentified a particular way in which the application handles requests for\ninvalid resources (e.g., a customized “file not found” page), configure\nIntruder or your script to highlight these results so they can be ignored.\n■ Capture the responses received from the server, and manually review\nthese to identify valid resources.\n■ Perform the exercise recursively as new content is discovered.\nInference from Published Content\nMost applications employ some kind of naming scheme for their content and\nfunctionality. By inferring from the resources already identified within the\napplication, it is possible to fine-tune your automated enumeration exercise to\nincrease the likelihood of discovering further hidden content.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 71\nChapter 4 ■ Mapping the Application 71\nHACK STEPS\n■ Review the results of your user-directed browsing and basic brute-force\nexercises. Compile lists of the names of all enumerated subdirectories,\nfile stems, and file extensions.\n■ Review these lists to identify any naming schemes in use. For example,\nif there are pages called AddDocument.jspand ViewDocument.jsp,\nthen there may also be pages called EditDocument.jspand\nRemoveDocument.jsp. You can often get a feel for the naming habits of\ndevelopers just by reading a few examples. For example, depending on\ntheir personal style, developers may be verbose (AddANewUser.asp),\nsuccinct (AddUser.asp), use abbreviations (AddUsr.asp), or even be\nmore cryptic (AddU.asp). Getting a feel for the naming styles in use may\nhelp you guess the precise names of content that you have not already\nidentified.\n■ Sometimes, the naming scheme used for different content employs\nidentifiers such as numbers and dates, which can make inferring hidden\ncontent extremely easy. This is most commonly encountered in the\nnames of static resources, rather than dynamic scripts. For example,\nif a company’s web site links to AnnualReport2004.pdfand Annual\nReport2005.pdf, it ought to be a short step to identifying what the next\nreport will be called. Somewhat incredibly, there have been notorious\ncases of companies placing files containing financial results onto their\nweb servers before these were publicly announced, only to have wily\njournalists discover them based on the naming scheme used in earlier\nyears.\n■ Review all client-side code such as HTML and JavaScript to identify any\nclues about hidden server-side content. These may include HTML com-\nments relating to protected or unlinked functions, and HTML forms with\ndisabled SUBMITelements, and the like. Often, comments are automati-\ncally generated by the software that has been used to generate web con-\ntent, or by the platform on which the application is running. References\nto items such as server-side include files are of particular interest—\nthese files may actually be publicly downloadable and may contain\nhighly sensitive information such as database connection strings and\npasswords. In other cases, developers’ comments may contain all kinds\nof useful tidbits, such as database names, references to back-end com-\nponents, SQL query strings, and so on. Thick-client components such as\nJava applets and ActiveX controls may also contain sensitive data that\nyou can extract. See Chapter 14 for further ways in which the application\nmay disclose information about itself.\n(continued)\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 72\n72 Chapter 4 ■ Mapping the Application\nHACK STEPS (continued)\n■ Add to the lists of enumerated items any further potential names conjec-\ntured on the basis of these. Also add to the file extension list common\nextensions such as txt, bak, src, inc, and old, which may uncover the\nsource to backup versions of live pages, as well as extensions associated\nwith the development languages in use, such as Java and cs, which may\nuncover source files that have been compiled into live pages (see the tips\ndescribed later in this chapter for identifying technologies in use). The\nParos tool carries out this test when used to perform a vulnerability scan\n(see Chapter 19).\n■ Search for temporary files which may have been created inadvertently by\ndeveloper tools and file editors—for example, the .DS_Storefile, which\ncontains a directory index under OSX, or file.php~1, which is a tempo-\nrary file created when file.phpis edited.\n■ Perform further automated exercises, combining the lists of directories,\nfile stems, and file extensions to request large numbers of potential\nresources. For example, in a given directory, request each file stem com-\nbined with each file extension. Or request each directory name as a sub-\ndirectory of every known directory.\n■ Where a consistent naming scheme has been identified, consider per-\nforming a more focused brute-force exercise on the basis of this. For\nexample, if AddDocument.jspand ViewDocument.jspare known to\nexist, you may create a list of actions (edit, delete, create, etc.) and make\nrequests of the form XxxDocument.jsp. Alternatively, create a list of\ntypes of item (user, account, file, etc.) and make requests of the form\nAddXxx.jsp.\n■ Perform each exercise recursively, using new enumerated content and\npatterns as the basis for further user-directed spidering, and further\nautomated content discovery. You are limited only by your imagination,\ntime available, and the importance you attach to discovering hidden con-\ntent within the application you are targeting.\nUse of Public Information\nThere may be content and functionality within the application that is not\npresently linked from its main content, but has been linked in the past. In this\nsituation, it is likely that various historical repositories will still contain refer-\nences to the hidden content. There are two main types of publicly available\nresources that are useful here:\n■■ Search enginessuch as Google, Yahoo and MSN. These maintain a\nfine-grained index of all content which their powerful spiders have\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 73\nChapter 4 ■ Mapping the Application 73\ndiscovered, and also cached copies of much of this content, which per-\nsists even after the original content has been removed.\n■■ Web archivessuch as the WayBack Machine located at\nweb.archive.org. These archives maintain a historical record of a very\nlarge number of web sites, and in many cases allow users to browse a\nfully replicated snapshot of a given site as it existed at various dates\ngoing back several years.\nIn addition to content that has been linked in the past, these resources are\nalso likely to contain references to content that is linked from third-party sites,\nbut not from within the target application itself. For example, some applica-\ntions contain restricted functionality for use by their business partners. Those\npartners may disclose the existence of the functionality in ways that the appli-\ncation itself does not.\nHACK STEPS\n■ Use several different search engines and web archives (listed previously)\nto discover what content they indexed or stored for the application you\nare attacking.\n■ When querying a search engine, you can use various advanced tech-\nniques to maximize the effectiveness of your research. The following sug-\ngestions apply to Google—you can find the corresponding queries on\nother engines by selecting their Advanced Search option:\n■ site:www.wahh-target.com—This will return every resource within\nthe target site which Google has a reference to.\n■ site:www.wahh-target.com login—This will return all of the\npages containing the expression login. In a very large and complex\napplication, this technique can be used to quickly home in on interest-\ning resources, such as site maps, password reset functions, adminis-\ntrative menus, and the like.\n■ link:www.wahh-target.com—This will return all of the pages on\nother web sites and applications that contain a link to the target. This\nmay include links to old content, or functionality that is intended for\nuse only by third parties, such as partner links.\n■ related:www.wahh-target.com—This returns pages that are “simi-\nlar” to the target, and so will include a lot of irrelevant material. How-\never, it may also include discussion about the target on other sites,\nwhich may be of interest.\n■ For each search, perform it not only in the default Web section of\nGoogle, but also Groups and News, which may contain different\nresults.\n(continued)\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 74\n74 Chapter 4 ■ Mapping the Application\nHACK STEPS (continued)\n■ Browse to the last page of search results for a given query, and select\nRepeat the Search with the Omitted Results Included. By default,\nGoogle attempts to filter out redundant results by removing pages that\nit believes are sufficiently similar to others included in the results.\nOverriding this behavior may uncover subtly different pages that are\nof interest to you when attacking the application.\n■ View the cached version of interesting pages, including any content\nthat is no longer present in the actual application. In some cases,\nsearch engine caches contain resources that cannot be directly\naccessed in the application without authentication or payment.\n■ Perform the same queries on other domain names belonging to the\nsame organization, which may contain useful information about the\napplication you are targeting.\n■ If your research identifies old content and functionality that is no longer\nlinked to within the main application, it may still be present and usable.\nThe old functionality may contain vulnerabilities that do not exist else-\nwhere within the application.\n■ Even where old content has been removed from the live application,\ndetails about the content obtained from a search engine cache or web\narchive may contain references to or clues about other functionality that is\nstill present within the live application, and that can be used to attack it.\nA further public source of useful information about the target application is\nany posts that developers and others have made to Internet forums. There are\nnumerous such forums in which software designers and programmers ask\nand answer technical questions. Often, items posted to these forums will con-\ntain information about an application that is of direct benefit to an attacker,\nincluding the technologies in use, the functionality implemented, problems\nencountered during development, known security bugs, configuration and\nlog files submitted to assist troubleshooting, and even extracts of source code.\nHACK STEPS\n■ Compile a list containing every name and email address you can discover\nrelating to the target application and its development. This should include\nany known developers, names found within HTML source code, names found\nin the contact information section of the main company web site, and any\nnames disclosed within the application itself, such as administrative staff.\n■ Using the search techniques described previously, search for each identi-\nfied name, to find any questions and answers they have posted to Inter-\nnet forums. Review any information found for clues about functionality\nor vulnerabilities within the target application.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 75\nChapter 4 ■ Mapping the Application 75\nLeveraging the Web Server\nVulnerabilities may exist at the web server layer that enable you to discover\ncontent and functionality that is not linked within the web application itself.\nFor example, there have been numerous bugs within web server software that\nallow an attacker to list the contents of directories, or obtain the raw source for\ndynamic server-executable pages. See Chapter 17 for some examples of these\nvulnerabilities, and ways in which you can identify them. If such a bug exists,\nyou may be able to exploit it to directly obtain a listing of all pages and other\nresources within the application.\nMany web servers ship with default content that may assist you in attacking\nthem—for example, sample and diagnostic scripts that may contain known\nvulnerabilities, or contain functionality that may be leveraged for some mali-\ncious purpose. Further, many web applications incorporate common third-\nparty components that they use for various standard functions—for example,\nscripts to implement a shopping cart or interface to email servers. Nikto is a\nhandy tool that issues requests for a wide range of default web server content,\nthird-party application components, and common directory names. While\nNikto will not rigorously test for any hidden bespoke functionality, it can often\nbe useful in discovering other resources that are not linked within the applica-\ntion and that may be of interest in formulating an attack:\nmanicsprout@king nikto-1.35]# perl nikto.pl\n-----------------------------------------------------------------------\n- Nikto 1.34/1.29 - www.cirt.net\n+ Target IP: 127.0.0.1\n+ Target Hostname: localhost\n+ Target Port: 80\n+ Start Time: Sat Feb 3 12:03:36 2007\n-----------------------------------------------------------------------\n- Scan is dependent on “Server” string which can be faked, use -g to\noverride\n+ Server ID string not sent\n- Server did not understand HTTP 1.1, switching to HTTP 1.0\n+ /bin/ - This might be interesting... (GET)\n+ /client/ - This might be interesting... (GET)\n+ /oracle - Redirects to /oracle/ , This might be interesting...\n+ /temp/ - This might be interesting... (GET)\n+ /cgi-bin/login.pl - This might be interesting... (GET)\n+ 3198 items checked - 6 item(s) found on remote host(s)\n+ End Time: Sat Feb 3 12:03:55 2007 (19 seconds)\n-----------------------------------------------------------------------\n+ 1 host(s) tested\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 76\n76 Chapter 4 ■ Mapping the Application\nHACK STEPS\nThere are several useful options available when running Nikto:\n■ If you believe that the server is using a nonstandard location for interest-\ning content that Nikto checks for (for example /cgi/cgi-bininstead of\n/cgi-bin) you can specify this alternate location using the option –root\n/cgi/. For the specific case of CGI directories, these can also be speci-\nfied using the option –Cgidirs.\n■ If the site uses a custom “file not found” page that does not return the\nHTTP 404 status code, you can specify a particular string that identifies\nthis page by using the -404option.\n■ Be aware that Nikto does not perform any intelligent verification of\npotential issues and so is prone to report false positives. Always check\nany results returned by Nikto manually.\nApplication Pages vs. Functional Paths\nThe enumeration techniques described so far have been implicitly driven by\none particular picture of how web application content may be conceptualized\nand catalogued. This picture is inherited from the pre-application days of the\nWorld Wide Web, in which web servers functioned as repositories of static\ninformation, retrieved using URLs that were effectively filenames. To publish\nsome web content, an author simply generated a bunch of HTML files and\ncopied these into the relevant directory on a web server. When users followed\nhyperlinks, they navigated around the set of files created by the author,\nrequesting each file via its name within the directory tree residing on the\nserver.\nAlthough the evolution of web applications has fundamentally changed the\nexperience of interacting with the Web, the picture just described is still applic-\nable to the majority of web application content and functionality. Individual\nfunctions are typically accessed via a unique URL, which is usually the name\nof the server-side script that implements the function. The parameters to the\nrequest (residing in either the URL query string or the body of a POSTrequest)\ndo not tell the application what function to perform—they tell it what infor-\nmation to use when performing it. In this context, the methodology of con-\nstructing a URL-based map can be effective in cataloging the functionality of\nthe application.\nIn some applications, however, the picture based on application “pages” is\ninappropriate. While it may be logically possible to shoehorn any application’s\nstructure into this form of representation, there are many cases in which a\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 77\nChapter 4 ■ Mapping the Application 77\ndifferent picture, based on functional paths, is far more useful for cataloging\nits content and functionality. Consider an application that is accessed using\nonly requests of the following form:\nPOST /bank.jsp HTTP/1.1\nHost: wahh-bank.com\nContent-Length: 106\nservlet=TransferFunds&method=confirmTransfer&fromAccount=10372918&toAcco\nunt=3910852&amount=291.23&Submit=Ok\nHere, every request is made to a single URL. The parameters to the request\nare used to tell the application what function to perform, by naming the Java\nservlet and method to invoke. Further parameters provide the information to\nuse in performing the function. In the picture based on application pages, the\napplication will appear to have only a single function, and a URL-based map\nwill not elucidate its functionality. However, if we map the application in\nterms of functional paths, we can obtain a much more informative and useful\ncatalogue of its functionality. Figure4-5 is a partial map of the functional paths\nthat exist within the application.\nWahhBank.\nlogin\nWahhBank.\nhome\nTransferFunds. BillPayment. BillPayment. WahhBank.\nselectAccounts addPayee selectPayee logout\nTransferFunds. BillPayment.\nenterAmount enterAmount\nTransferFunds. BillPayment.\nconfirmTransfer confirmPayment\nFigure4-5: A mapping of the functional paths within a web application\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 78\n78 Chapter 4 ■ Mapping the Application\nRepresenting an application’s functionality in this way is often more useful\neven in cases where the usual picture based on application pages can be\napplied without any problems. The logical relationships and dependencies\nbetween different functions may not correspond to the directory structure\nused within URLs. It is these logical relationships that are of most interest to\nyou, both in understanding the core functionality of the application, and in\nformulating possible attacks against it. By identifying these, you can better\nunderstand the expectations and assumptions of the application’s developers\nwhen implementing the functions, and attempt to find ways of violating these\nassumptions, causing unexpected behavior within the application.\nIn applications where functions are identified using a request parameter,\nrather than the URL, this has implications for the enumeration of application\ncontent. In the previousexample, the content discovery exercises described so\nfar are unlikely to uncover any hidden content. Those techniques need to be\nadapted to the mechanisms actually used by the application for accessing\nfunctionality.\nHACK STEPS\n■ Identify any instances where application functionality is accessed not by\nrequesting a specific page for that function (e.g., /admin/editUser.jsp)\nbut by passing the name of a function in a parameter (e.g., /admin\n.jsp?action=editUser).\n■ Modify the automated techniques described for discovering URL-\nspecified content to work on the content-access mechanisms in use\nwithin the application. For example, if the application uses parameters\nwhich specify servlet and method names, first determine its behavior\nwhen an invalid servlet and/or method is requested, and when a valid\nmethod is requested with invalid other parameters. Try to identify attrib-\nutes of the server’s responses that indicate “hits”—i.e., valid servlets and\nmethods. If possible, find a way of attacking the problem in two stages,\nfirst enumerating servlets and then methods within these. Using a similar\nmethod to the one used for URL-specified content, compile lists of com-\nmon items, add to these by inferring from the names actually observed,\nand generate large numbers of requests based on these.\n■ If applicable, compile a map of application content based on functional\npaths, showing all of the enumerated functions and the logical paths and\ndependencies between them.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 79\nChapter 4 ■ Mapping the Application 79\nDiscovering Hidden Parameters\nA variation on the situation where an application uses request parameters to\nspecify which function should be performed arises where other parameters\nare used to control the application’s logic in significant ways. For example, an\napplication may behave differently if the parameter debug=true is added to\nthe query string of any URL—it might turn off certain input validation\nchecks, allow the user to bypass certain access controls, or display verbose\ndebug information in its response. In many cases, the fact that the application\nhandles this parameter cannot be directly inferred from any of its content (for\nexample, it does not include debug=false in the URLs that it publishes as\nhyperlinks). The effect of the parameter can only be detected by guessing a\nrange of values until the correct one is submitted.\nHACK STEPS\n■ Using lists of common debug parameter names (debug, test, hide, source,\netc.) and common values (true, yes, on, 1, etc.), make a large number of\nrequests to a known application page or function, iterating through all\npermutations of name and value. For POSTrequests, insert the added\nparameter both into the URL query string and into the message body.\n■ Burp Intruder can be used to perform this test using multiple payload\nsets and the “cluster bomb” attack type (see Chapter 13 for more\ndetails).\n■ Monitor all responses received to identify any anomalies that may indi-\ncate that the added parameter has had an effect on the application’s\nprocessing.\n■ Depending on the time available, target a number of different pages or\nfunctions for hidden parameter discovery. Choose functions where it is\nmost likely that developers have implemented debug logic, such as login,\nsearch, file uploading and downloading, and the like.\nAnalyzing the Application\nEnumerating as much of the application’s content as possible is only one ele-\nment of the mapping process. Equally important is the task of analyzing the\napplication’s functionality, behavior, and technologies employed, in order to\nidentify the key attack surfaces that it exposes, and begin formulating an\napproach to probing the application for exploitable vulnerabilities.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 80\n80 Chapter 4 ■ Mapping the Application\nSome key areas to investigate are:\n■■ The core functionality of the application—the actions that it can be\nleveraged to perform when used as intended.\n■■ Other more peripheral behavior of the application, including off-site\nlinks, error messages, administrative and logging functions, use of redi-\nrects, and so on.\n■■ The core security mechanisms and how they function, in particular\nmanagement of session state, access controls, and authentication mech-\nanisms and supporting logic (user registration, password change,\naccount recovery, etc.).\n■■ All of the different locations at which user-supplied input is processed\nby the application—every URL, query string parameter, item of POST\ndata, cookie, and the like.\n■■ The technologies employed on the client side, including forms, client-\nside scripts, thick-client components (Java applets, ActiveX controls,\nand Flash), and cookies.\n■■ The technologies employed on the server side, including static and\ndynamic pages, the types of request parameters employed, use of SSL,\nweb server software, interaction with databases, email systems and\nother back-end components.\n■■ Any other details that may be gleaned about the internal structure and\nfunctionality of the server-side application—the mechanisms it uses\nbehind the scenes to deliver the functionality and behavior that is visi-\nble from the client perspective.\nIdentifying Entry Points for User Input\nThe majority of ways in which the application captures user input for server-\nside processing should be obvious when reviewing the HTTP requests that are\ngenerated as you walk through the application’s functionality. The key loca-\ntions to pay attention to are:\n■■ Every URL string up to the query string marker.\n■■ Every parameter submitted within the URL query string.\n■■ Every parameter submitted within the body of a POSTrequest.\n■■ Every cookie.\n■■ Every other HTTP header that in rare cases may be processed by the\napplication, in particular the User-Agent, Referer, Accept, Accept-\nLanguage, and Hostheaders.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 81\nChapter 4 ■ Mapping the Application 81\nSome applications do not employ the standard query string format (which\nwas described in Chapter 3), but employ their own custom scheme, which\nmay use nonstandard query string markers and field separators, may embed\nother data schemes such as XML within the query string, or may effectively\nplace the query string within what appears to be the directory or filename por-\ntion of the URL. Here are some examples of nonstandard query string formats\nthat the authors have encountered in the wild:\n■■ /dir/file;foo=bar&foo2=bar2\n■■ /dir/file?foo=bar$foo2=bar2\n■■ /dir/file/foo%3dbar%26foo2%3dbar2\n■■ /dir/foo.bar/file\n■■ /dir/foo=bar/file\n■■ /dir/file?param=foo:bar\n■■ /dir/file?data=\n%3cfoo%3ebar%3c%2ffoo%3e%3cfoo2%3ebar2%3c%2ffoo2%3e\nIf a nonstandard query string format is being used, then you will need to\ntake account of this when probing the application for all kinds of common vul-\nnerabilities. For example, when testing the final URL in this list, if you were to\nignore the custom format and simply treat the query string as containing a sin-\ngle parameter called data, and so submit various kinds of attack payloads as\nthe value of this parameter, you would miss many kinds of vulnerability that\nmay exist in the processing of the query string. If, conversely, you dissect the\nformat and place your payloads within the embedded XML data fields, you\nmay immediately discover a critical bug such as SQL injection or path\ntraversal.\nA final class of entry points for user input includes any out-of-band channel\nby which the application receives data that you may be able to control. Some\nof these entry points may be entirely undetectable if you simply inspect the\nHTTP traffic generated by the application, and finding them usually requires\nan understanding of the wider context of the functionality that the application\nimplements. Some examples of web applications that receive user-controllable\ndata via an out-of-band channel include:\n■■ A web mail application which processes and renders email messages\nreceived via SMTP.\n■■ A publishing application that contains a function to retrieve content via\nHTTP from another server.\n■■ An intrusion detection application that gathers data using a network\nsniffer and presents this using a web application interface.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 82\n82 Chapter 4 ■ Mapping the Application\nIdentifying Server-Side Technologies\nIt is normally possible to fingerprint the technologies employed on the server\nvia various clues and indicators.\nBanner Grabbing\nMany web servers disclose fine-grained version information, both about the\nweb server software itself and about other components that have been\ninstalled. For example, the HTTP Server header discloses a huge amount of\ndetail about some installations:\nServer: Apache/1.3.31 (Unix) mod_gzip/1.3.26.1a mod_auth_passthrough/1.8\nmod_log_bytes/1.2 mod_bwlimited/1.4 PHP/4.3.9 FrontPage/5.0.2.2634a\nmod_ssl/2.8.20 OpenSSL/0.9.7a\nIn addition to the Serverheader, other locations where the type and version\nof software may be disclosed are:\n■■ Templates used to build HTML pages\n■■ Custom HTTP headers\n■■ URL query string parameters\nHTTP Fingerprinting\nIn principle, any item of information returned by the server may be cus-\ntomized or even deliberately falsified, and banners like the Serverheader are\nno exception. Some web server software includes a facility for administrators\nto set an arbitrary value for the Serverheader. Further, there are security prod-\nucts that use various methods to try to prevent a web server’s software from\nbeing detected, such as ServerMask by Port80 Software.\nAttempting to grab the server banner from Port80’s own web server does\nnot appear to disclose much useful information:\nHEAD / HTTP/1.0\nHost: www.port80software.com\nHTTP/1.1 200 OK\nDate: Sun, 04 Mar 2007 16:14:26 GMT\nServer: Yes we are using ServerMask!\nSet-Cookie: countrycode=UK; path=/\nSet-Cookie: ALT.COOKIE.NAME.2=89QMSN102,S62OS21C51N2NP,,0105,N7; path=/\nCache-control: private\nContent-Length: 27399\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 83\nChapter 4 ■ Mapping the Application 83\nConnection: Keep-Alive\nContent-Type: text/html\nSet-Cookie: Coyote-2-d1f579d9=ac1000d9:0; path=/\nDespite measures such as this, it is usually possible for a determined\nattacker to use other aspects of the web server’s behavior to determine the\nsoftware in use, or at least narrow down the range of possibilities. The HTTP\nspecification contains a lot of detail that is optional or left to an implementer’s\ndiscretion. Further, many web servers deviate from or extend the specification\nin various different ways. As a result, there are numerous subtle ways in which\na web server can be fingerprinted, other than via its Serverbanner. Httprint is\na handy tool that performs a number of tests in an attempt to fingerprint a web\nserver’s software. In the case of Port80 Software’s server, it reports with a 58%\ndegree of confidence that the server software in use is in fact Microsoft IIS ver-\nsion 5.1, as shown in Figure4-6.\nFigure4-6: Httprint fingerprinting various different web servers\nThe screenshot also illustrates how Httprint can defeat other kinds of\nattempts to mislead about the web server software being used. The Found-\nstone web site uses a misleading banner, but Httprint can still discover the\nactual software. And the RedHat server is configured to present the nonver-\nbose banner “Apache,” but Httprint is able to deduce the specific version of\nApache being used with a high degree of confidence.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 84\n84 Chapter 4 ■ Mapping the Application\nFile Extensions\nFile extensions used within URLs often disclose the platform or programming\nlanguage used to implement the relevant functionality. For example:\n■■ asp—Microsoft Active Server Pages\n■■ aspx—Microsoft ASP.NET\n■■ jsp—Java Server Pages\n■■ cfm—Cold Fusion\n■■ php—the PHP language\n■■ d2w—WebSphere\n■■ pl—the Perl language\n■■ py—the Python language\n■■ dll—usually compiled native code (C or C++)\n■■ nsfor ntf—Lotus Domino\nEven if an application does not employ a particular file extension in its pub-\nlished content, it is usually possible to verify whether the technology support-\ning that extension is implemented on the server. For example, if ASP.NET is\ninstalled, requesting a nonexistent .aspx file will return a customized error\npage generated by the ASP.NET framework, as shown in Figure 4-7, whereas\nrequesting a nonexistent file with a different extension returns a generic error\nmessage generated by the web server, as shown in Figure4-8.\nFigure4-7: A customized error page indicating that the ASP.NET platform is present\non the server\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 85\nChapter 4 ■ Mapping the Application 85\nFigure4-8: A generic error message created when an unrecognized file extension is\nrequested\nUsing the automated content discovery techniques already described, it is\npossible to request a large number of common file extensions and quickly con-\nfirm whether any of the associated technologies are implemented on the\nserver.\nThe divergent behavior described arises because many web servers map\nspecific file extensions to particular server-side components. Each different\ncomponent may handle errors (including requests for nonexistent content) in\na different way. Figure 4-9 shows the various extensions that are mapped to\ndifferent handler DLLs in a default installation of IIS 5.0.\nFigure4-9: File extension mappings in IIS 5.0\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 86\n86 Chapter 4 ■ Mapping the Application\nIt is possible to detect the presence of each file extension mapping via the\ndifferent error messages generated when that file extension is requested.\nIn some cases, discovering a particular mapping may indicate the presence\nof a web server vulnerability—for example, the .printer and .ida/.idq\nhandlers in IIS have in the past been found vulnerable to buffer overflow\nvulnerabilities.\nAnother common fingerprint to be aware of are URLs that look like the\nfollowing:\nhttps://wahh-app/news/0,,2-421206,00.html\nThe comma-separated numbers towards the end of the URL are usually gen-\nerated by the Vignette content management platform.\nDirectory Names\nIt is common to encounter subdirectory names that indicate the presence of an\nassociated technology. For example:\n■■ servlet—Java servlets\n■■ pls—Oracle Application Server PL/SQL gateway\n■■ cfdocsor cfide—Cold Fusion\n■■ SilverStream—The SilverStream web server\n■■ WebObjectsor {function}.woa—Apple WebObjects\n■■ rails—Ruby on Rails\nSession Tokens\nMany web servers and web application platforms generate session tokens by\ndefault with names that provide information about the technology in use. For\nexample:\n■■ JSESSIONID—The Java Platform\n■■ ASPSESSIONID—Microsoft IIS server\n■■ ASP.NET_SessionId—Microsoft ASP.NET\n■■ CFID/CFTOKEN—Cold Fusion\n■■ PHPSESSID—PHP\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 87\nChapter 4 ■ Mapping the Application 87\nThird-Party Code Components\nMany web applications incorporate third-party code components to imple-\nment common functionality such as shopping carts, login mechanisms, and\nmessage boards. These may be open source or may have been purchased from\nan external software developer. When this is the case, the same components\noften appear within numerous other web applications on the Internet, which\nyou can inspect to understand how the component functions. Often, different\nfeatures of the same component will be made use of by other applications,\nenabling you to identify additional behavior and functionality beyond what is\ndirectly visible in the target application. Also, the software may contain known\nvulnerabilities that have been discussed elsewhere, or you may be able to\ndownload and install the component yourself and perform a source code\nreview or probe it for defects in a controlled way.\nHACK STEPS\n■ Identify all entry points for user input, including URLs, query string para-\nmeters, POSTdata, cookies, and other HTTP headers processed by the\napplication.\n■ Examine the query string format used by the application. If it does not\nemploy the standard format described in Chapter 3, try to understand\nhow parameters are being transmitted via the URL. Virtually all custom\nschemes still employ some variation on the name/value model, so try to\nunderstand how name/value pairs are being encapsulated into the non-\nstandard URLs you have identified.\n■ Identify any out-of-bound channels via which user-controllable or other\nthird-party data is being introduced into the application’s processing.\n■ View the HTTP Server banner returned by the application. Note that in\nsome cases, different areas of the application are handled by different\nback-end components, and so different Serverheaders may be\nreceived.\n■ Check for any other software identifiers contained within any custom\nHTTP headers or HTML source code comments.\n■ Run the Httprint tool to fingerprint the web server.\n■ If fine-grained information is obtained about the web server and other\ncomponents, research the software versions in use to identify any vulner-\nabilities that may be exploited to advance an attack (see Chapter 17).\n■ Review your map of application URLs, to identify any interesting-looking\nfile extensions, directories, or other subsequences that may provide clues\nabout the technologies in use on the server.\n(continued)\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 88\n88 Chapter 4 ■ Mapping the Application\nHACK STEPS (continued)\n■ Review the names of all session tokens issued by the application to iden-\ntify the technologies being used.\n■ Use lists of common technologies, or Google, to establish which tech-\nnologies may be in use on the server, or discover other web sites and\napplications that appear to be employing the same technologies.\n■ Perform searches on Google for the names of any unusual cookies,\nscripts, HTTP headers, and the like that may belong to third-party soft-\nware components. If you locate other applications in which the same\ncomponents are being used, review these to identify any additional\nfunctionality and parameters that the components support, and verify\nwhether these are also present in your target application. Note that third-\nparty components may look and feel quite different in each implementa-\ntion, due to branding customizations, but the core functionality, including\nscript and parameter names, is often the same. If possible, download and\ninstall the component and analyze it to fully understand its capabilities\nand if possible discover any vulnerabilities. Consult repositories of\nknown vulnerabilities to identify any known defects with the component\nin question.\nIdentifying Server-Side Functionality\nIt is often possible to infer a great deal about server-side functionality and\nstructure, or at least make an educated guess, by observing clues that the\napplication discloses to the client.\nDissecting Requests\nConsider the following URL, which is used to access a search function:\nhttps://wahh-app.com/calendar.jsp?name=new%20applicants&isExpired=\n0&startDate=22%2F09%2F2006&endDate=22%2F03%2F2007&OrderBy=name\nAs we have seen, the .jspfile extension indicates that Java Server Pages are\nin use. You may guess that a search function will retrieve its information from\neither an indexing system or a database; the presence of the OrderByparame-\nter suggests that a back-end database is being used, and that the value you\nsubmit may be used as the ORDER BY clause of a SQL query. This parameter\nmay well be vulnerable to SQL injection, as may any of the other parameters if\nthey are used in database queries (see Chapter 9).\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 89\nChapter 4 ■ Mapping the Application 89\nAlso of interest among the other parameters is the isExpired field. This\nappears to be a Boolean flag specifying whether the search query should\ninclude content which is expired. If the application designers did not expect\nordinary users to be able retrieve any expired content, changing this parame-\nter from 0 to 1 could identify an access control vulnerability (see Chapter 8).\nThe following URL, which allows users to access a content management\nsystem, contains a different set of clues:\nhttps://wahh-app.com/workbench.aspx?template=NewBranch.tpl&loc=\n/default&ver=2.31&edit=false\nHere, the .aspxfile extension indicates that this is an ASP.NET application.\nIt also appears highly likely that the template parameter is used to specify a\nfilename, and the locparameter is used to specify a directory. The possible file\nextension .tpl appears to confirm this, as does the location /default, which\ncould very well be a directory name. It is possible that the application retrieves\nthe template file specified and includes the contents into its response. These\nparameters may well be vulnerable to path traversal attacks, allowing arbi-\ntrary files to be read from the server (see Chapter 10).\nAlso of interest is the edit parameter, which is set to false. It may be that\nchanging this value to true will modify the registration functionality, poten-\ntially enabling an attacker to edit items that the application developer did not\nintend to be editable. The verparameter does not have any readily guessable\npurpose, but it may be that modifying this will cause the application to per-\nform a different set of functions that may be exploitable by an attacker.\nFinally, consider the following request, which is used to submit a question to\napplication administrators:\nPOST /feedback.php HTTP/1.1\nHost: wahh-app.com\nContent-Length: 389\nfrom=user@wahh-mail.com&to=helpdesk@wahh-app.com&subject=\nProblem+logging+in&message=Please+help...\nAs with the other examples, the .php file extension indicates that the func-\ntion is implemented using the PHP language. Further, it is extremely likely\nthat the application is interfacing with an external email system, and it appears\nthat user-controllable input is being passed to that system in all relevant fields\nof the email. The function may be exploitable to send arbitrary messages to\nany recipient, and any of the fields may also be vulnerable to email header\ninjection (see Chapter 9).\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 90\n90 Chapter 4 ■ Mapping the Application\nHACK STEPS\n■ Review the names and values of all parameters being submitted to the\napplication, in the context of the functionality which they support.\n■ Try to think like a programmer, and imagine what server-side mecha-\nnisms and technologies are likely to have been used to implement the\nbehavior that you can observe.\nExtrapolating Application Behavior\nOften, an application behaves in a consistent way across the range of its func-\ntionality. This may be because different functions were written by the same\ndeveloper, or to the same design specification, or share some common code\ncomponents. In this situation, it may be possible to draw conclusions about\nserver-side functionality in one area and extrapolate these to another area.\nFor example, the application may enforce some global input validation\nchecks, such as sanitizing various kinds of potentially malicious input before\nit is processed. Having identified a blind SQL injection vulnerability, you may\nencounter problems exploiting it, because your crafted requests are being\nmodified in unseen ways by the input validation logic. However, there may be\nother functions within the application that provide good feedback about the\nkind of sanitization being performed—for example, a function that echoes\nsome user-supplied data back to the browser. You may be able to use this func-\ntion to test different encodings and variations of your SQL injection payload,\nto determine what raw input must be submitted to achieve the desired attack\nstring after the input validation logic has been applied. If you are lucky, the\nvalidation works in the same way across the application, enabling you to\nexploit the injection flaw.\nSome applications use custom obfuscation schemes when storing sensitive\ndata on the client, to prevent casual inspection and modification of this data by\nusers (see Chapter 5). Some such schemes may be extremely difficult to deci-\npher given access to only a sample of obfuscated data. However, there may be\nfunctions within the application where a user can supply an obfuscated string\nand retrieve the original—for example, an error message may include the\ndeobfuscated data which led to the error. If the same obfuscation scheme is\nused throughout the application, it may be possible to take an obfuscated\nstring from one location (for example a cookie), and feed it into the other func-\ntion to decipher its meaning. It may also be possible to reverse engineer the\nobfuscation scheme by submitting systematically varying values to the func-\ntion and monitoring their deobfuscated equivalents.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 91\nChapter 4 ■ Mapping the Application 91\nFinally, errors are often handled in an inconsistent manner within the appli-\ncation, with some areas trapping and handling errors gracefully, while other\nareas simply crash and return verbose debugging information to the user (see\nChapter 14). In this situation, it may be possible to gather information from the\nerror messages returned in one area and apply it to other areas where errors\nare gracefully handled. For example, by manipulating request parameters in\nsystematic ways and monitoring the error messages received, it may be possi-\nble to determine the internal structure and logic of the application component\nconcerned; if you are lucky, aspects of this structure may be replicated in other\nareas.\nHACK STEPS\n■ Try to identify any locations within the application that may contain clues\nabout the internal structure and functionality of other areas.\n■ It may not be possible to draw any firm conclusions here; however, the\ncases identified may prove useful at a later stage of the attack when\nattempting to exploit any potential vulnerabilities.\nMapping the Attack Surface\nThe final stage of the mapping process is to identify the various attack surfaces\nexposed by the application, and the potential vulnerabilities that are com-\nmonly associated with each one. The following is a rough guide to some key\ntypes of behavior and functionality that you may identify, and the kinds of\nvulnerability that are most commonly found within each one. The remainder\nof this book will be concerned with the practical details of how you can detect\nand exploit each of these problems:\n■■ Client-side validation—Checks may not be replicated on the server.\n■■ Database interaction—SQL injection.\n■■ File uploading and downloading—Path traversal vulnerabilities.\n■■ Display of user-supplied data—Cross-site scripting.\n■■ Dynamic redirects—Redirection and header injection attacks.\n■■ Login—Username enumeration, weak passwords, ability to use brute\nforce.\n■■ Multistage login—Logic flaws.\n■■ Session state—Predictable tokens, insecure handling of tokens.\n■■ Access controls—Horizontal and vertical privilege escalation.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 92\n92 Chapter 4 ■ Mapping the Application\n■■ User impersonation functions—Privilege escalation.\n■■ Use of cleartext communications—Session hijacking, capture of cre-\ndentials and other sensitive data.\n■■ Off-site links—Leakage of query string parameters in the Referer\nheader.\n■■ Interfaces to external systems—Shortcuts in handling of sessions\nand/or access controls.\n■■ Error messages—Information leakage.\n■■ Email interaction—Email and/or command injection.\n■■ Native code components or interaction—Buffer overflows.\n■■ Use of third-party application components—Known vulnerabilities.\n■■ Identifiable web server software—Common configuration weak-\nnesses, known software bugs.\nHACK STEPS\n■ Understand the core functionality implemented within the application\nand the main security mechanisms in use.\n■ Identity all features of the application’s functionality and behavior that\nare often associated with common vulnerabilities.\n■ Formulate a plan of attack prioritizing the most interesting-looking func-\ntionality and the most serious of the associated potential vulnerabilities.\nChapter Summary\nMapping the application is a key prerequisite to attacking it. While it may be\ntempting to dive straight in and start probing for actual bugs, taking time to\ngain a sound understanding of the application’s functionality, technologies,\nand attack surface will pay dividends down the line.\nAs with almost all of web application hacking, the most effective approach\nis to use manual techniques supplemented where appropriate by controlled\nautomation. There is no fully automated tool that can carry out a thorough\nmapping of the application in a safe way. To do this, you need to use your\nhands and draw on your own experience. The core methodology we have out-\nlined involves:\n■■ Manual browsing and user-directed spidering, to enumerate the appli-\ncation’s visible content and functionality."
  },
  {
    "input": "What information can be inferred about the server technologies and potential vulnerabilities from the provided URLs and HTTP response headers?",
    "summary": "The main ideas of the text focus on the process of mapping an application, which involves using brute force with human intuition to uncover hidden content, conducting intelligent analysis to identify key features and security aspects, and assessing the application's attack surface to find exploitable vulnerabilities. It also discusses how to determine server technologies and application behavior through URL analysis and response headers. Additionally, the text provides examples of how specific URLs and headers can reveal information about the application's structure and potential weaknesses.",
    "output": "70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 93\nChapter 4 ■ Mapping the Application 93\n■■ Use of brute force combined with human inference and intuition to dis-\ncover as much hidden content as possible.\n■■ An intelligent analysis of the application, to identify its key functional-\nity, behavior, security mechanisms, and technologies.\n■■ An assessment of the application’s attack surface, highlighting the most\npromising functions and behavior for more focused probing into\nexploitable vulnerabilities.\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. While mapping an application, you encounter the following URL:\nhttps://wahh-app.com/CookieAuth.dll?GetLogon?curl=\nZ2Fdefault.aspx\nWhat information can you deduce about the technologies employed on\nthe server, and how it is likely to behave?\n2. The application you are targeting implements web forum functionality.\nThe only URL you have discovered is:\nhttp://wahh-app.com/forums/ucp.php?mode=register\nHow might you obtain a listing of forum members?\n3. While mapping an application, you encounter the following URL:\nhttps://wahh-app.com/public/profile/Address.asp?action=\nview&location=default\nWhat information can you infer about server-side technologies? What\ncan you conjecture about other content and functionality that may\nexist?\n4. A web server’s responses include the following header:\nServer: Apache-Coyote/1.1\nWhat does this indicate about the technologies in use on the server?\n5. You are mapping two different web applications, and you request the\nURL /admin.cpffrom each application. The response headers returned\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 94\n94 Chapter 4 ■ Mapping the Application\nby each request are shown here. From these headers alone, what can\nyou deduce about the presence of the requested resource within each\napplication?\nHTTP/1.1 200 OK\nServer: Microsoft-IIS/5.0\nExpires: Mon, 25 Jun 2007 14:59:21 GMT\nContent-Location: http://wahh-app.com/includes/error.htm?404;http://\nwahh-app.com/admin.cpf\nDate: Mon, 25 Jun 2007 14:59:21 GMT\nContent-Type: text/html\nAccept-Ranges: bytes\nContent-Length: 2117\nHTTP/1.1 401 Unauthorized\nServer: Apache-Coyote/1.1\nWWW-Authenticate: Basic realm=”Wahh Administration Site”\nContent-Type: text/html;charset=utf-8\nContent-Length: 954\nDate: Mon, 25 Jun 2007 15:07:27 GMT\nConnection: close"
  },
  {
    "input": "How can web applications bypass client-side controls to restrict user input and what are the potential vulnerabilities that arise from this approach?",
    "summary": "Web applications often rely on client-side controls like hidden form fields, cookies, and URL parameters to restrict user input, but these measures are inherently insecure because the client can bypass them. Attackers can use intercepting proxies to modify data before it is sent to the server, allowing them to exploit vulnerabilities such as SQL injection or cross-site scripting. Thick-client technologies like Java applets, ActiveX controls, and Flash objects can also be manipulated by analyzing their code or using reverse engineering tools. To securely handle client-side data, applications should validate it on the server and avoid transmitting sensitive information to the client. Client-side validation alone is not sufficient to prevent attacks, as it can be easily circumvented.",
    "output": "70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 95\nCHAPTER\n5\nBypassing Client-Side Controls\nChapter 1 described how the core security problem with web applications\narises because clients can submit arbitrary input. Despite this fact, a large pro-\nportion of web applications nevertheless rely upon various kinds of measures\nimplemented on the client side to control the data that it submits to the server.\nIn general, this represents a fundamental security flaw: the user has full con-\ntrol over the client and the data it submits, and can bypass any controls which\nare implemented on the client side and not replicated on the server.\nThere are two broad ways in which an application may rely upon client-side\ncontrols to restrict user input. First, an application may transmit data via the\nclient component, using some mechanism that it assumes will prevent the user\nfrom modifying that data. Second, when an application gathers data that is\nentered by the user, it may implement measures on the client side that control\nthe contents of that data before it is submitted. This may be achieved using\nHTML form features, client-side scripts, or thick-client technologies.\nWe will look at examples of each kind of client-side control and describe\nways in which they can be bypassed.\nTransmitting Data via the Client\nIt is very common to see an application passing data to the client in a form that\nis not directly visible or modifiable by the end user, in the expectation that this\n95\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 96\n96 Chapter 5 ■ Bypassing Client-Side Controls\ndata will be sent back to the server in a subsequent request. Often, the appli-\ncation’s developers simply assume that the transmission mechanism used\nwill ensure that the data transmitted via the client will not be modified along\nthe way.\nBecause everything submitted from the client to the server is within the\nuser’s full control, the assumption that data transmitted via the client will not\nbe modified is usually false, and often leaves the application vulnerable to one\nor more attacks.\nYou may reasonably wonder why, if a particular item of data is known and\nspecified by the server, the application would ever need to transmit this value\nto the client and then read it back. In fact, writing applications in this way is\noften an easier task for developers, because it removes the need to keep track\nof all kinds of data within the user’s session. Reducing the amount of per-\nsession data being stored on the server can also improve the application’s\nperformance. Further, if an application is deployed on several load-balanced\nservers, with users potentially interacting with more than one server to per-\nform a multistep action, then it may not be straightforward to share server-\nside data between the hosts that may handle the same user’s requests. Using\nthe client to transmit data can present a tempting solution to the problem.\nHowever, transmitting sensitive data in this way is usually unsafe and has\nbeen the cause of countless vulnerabilities in applications.\nHidden Form Fields\nHidden HTML form fields are a common mechanism for transmitting data\nvia the client in a superficially unmodifiable way. If a field is flagged as hid-\nden, it is not displayed on-screen. However, the field’s name and value are\nstored within the form and sent back to the application when the user submits\nthe form.\nThe classic example of this security flaw is a retailing application that stores\nthe prices of products within hidden form fields. In the early days of web\napplications, this vulnerability was extremely widespread, and it by no means\nhas been eliminated today. Figure5-1 shows a typical form.\nFigure 5-1: A typical HTML form\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 97\nChapter 5 ■ Bypassing Client-Side Controls 97\nThe code behind this form is as follows:\n<form action=”order.asp” method=”post”>\n<p>Product: Sony VAIO A217S</p>\n<p>Quantity: <input size=”2” name=”quantity”>\n<input name=”price” type=”hidden” value=”1224.95”>\n<input type=”submit” value=”Buy!”></p>\n</form>\nNotice the form field called price, which is flagged as hidden. This field will\nbe sent to the server when the user submits the form:\nPOST /order.asp HTTP/1.1\nHost: wahh-app.com\nContent-Length: 23\nquantity=1&price=1224.95\nNow, although the price field is not displayed on-screen, and it is not\neditable by the user, this is solely because the application has instructed the\nbrowser to hide the field. Because everything that occurs on the client side is\nultimately within the user’s control, this restriction can be circumvented in\norder to edit the price.\nOne way to achieve this is to save the source code for the HTML page, edit\nthe value of the field, reload the source into a browser, and click the Buy but-\nton. However, a more elegant and easier method is to use an intercepting\nproxy to modify the desired data on the fly.\nAn intercepting proxy is tremendously useful when attacking a web appli-\ncation and is the one truly indispensable tool that you need in your arsenal.\nThere are numerous such tools available, but the most functional and popu-\nlar are:\n■■ Burp Proxy (part of Burp Suite)\n■■ WebScarab\n■■ Paros\nThe proxy sits between your web browser and the target application. It\nintercepts every request issued to the application, and every response received\nback, for both HTTP and HTTPS. It can trap any intercepted message for\ninspection or modification by the user. The proxies listedalso have numerous\nadvanced functions to make your job easier, including:\n■■ Fine-grained rules to control which messages are trapped.\n■■ Regex-based replacement of message content.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 98\n98 Chapter 5 ■ Bypassing Client-Side Controls\n■■ Automatic updating of the Content-Lengthheader when messages are\nmodified.\n■■ Browsing history and message cache.\n■■ Ability to replay and remodify individual requests.\n■■ Integration with other tools such as spiders and fuzzers.\nIf you have not installed or used a proxy tool before, see Chapter 19 for\ninstructions and for a comparison of the main tools available.\nOnce an intercepting proxy has been installed and suitably configured, you\ncan trap the request that submits the form, and modify the pricefield to any\nvalue, as shown in Figure5-2.\nFigure 5-2: Modifying the values of hidden form fields using an intercepting proxy\nIf the application processes the transaction based on the price submitted,\nthen you can purchase the product for any price of your choosing.\nTIP If you find an application that is vulnerable in this way, see whether you\ncan submit a negative amount as the price. In some cases, applications have\nactually accepted transactions using negative prices. The attacker receives a\nrefund to their credit card and also the goods which they ordered — a win-win\nsituation if ever there was one.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 99\nChapter 5 ■ Bypassing Client-Side Controls 99\nHTTP Cookies\nAnother common mechanism for transmitting data via the client is HTTP cook-\nies. As with hidden form fields, these are not normally displayed on-screen or\ndirectly modifiable by the user. They can, of course, be modified using an inter-\ncepting proxy, either by changing the server response that sets them, or subse-\nquent client requests that issue them.\nConsider the following variation on the previous example. When a cus-\ntomer logs in to the application, she receives the following response:\nHTTP/1.1 302 Found\nLocation: /home.asp\nSet-Cookie: SessId=191041-1042\nSet-Cookie: UID=1042\nSet-Cookie: DiscountAgreed=25\nThis response sets three cookies, all of which are interesting. The first\nappears to be a session token, which may be vulnerable to sequencing or other\nattacks. The second appears to be a user identifier, which can potentially be\nleveraged to exploit access control weaknesses. The third appears to represent\na discount rate that the customer will receive on purchases.\nThis third cookie points towards a classic case of relying on client-side con-\ntrols (the fact that cookies are normally unmodifiable) to protect data trans-\nmitted via the client. If the application trusts the value of the DiscountAgreed\ncookie when it is submitted back to the server, then customers can obtain arbi-\ntrary discounts by modifying its value. For example:\nPOST /order.asp HTTP/1.1\nHost: wahh-app.com\nCookie: SessId=191041-1042; UID=1042; DiscountAgreed=99\nContent-Length: 23\nquantity=1&price=1224.95\nURL Parameters\nApplications frequently transmit data via the client using preset URL parame-\nters. For example, when a user browses the product catalogue, the application\nmay provide them with hyperlinks to URLs like the following:\nhttps://wahh-app.com/browse.asp?product=VAIOA217S&price=1224.95\nWhen a URL containing parameters is displayed in the browser’s location\nbar, any parameters can be trivially modified by any user without the use of\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 100\n100 Chapter 5 ■ Bypassing Client-Side Controls\ntools. However, there are many instances in which an application may expect\nthat ordinary users cannot view or modify URL parameters. For example:\n■■ Where embedded images are loaded using URLs containing parameters.\n■■ Where URLs containing parameters are used to load the contents of a\nframe.\n■■ Where a form uses the POSTmethod and its target URL contains preset\nparameters.\n■■ Where an application uses pop-up windows or other techniques to con-\nceal the browser location bar.\nOf course, in any such case the values of any URL parameters can be modi-\nfied as previously using an intercepting proxy.\nThe Referer Header\nBrowsers include the Refererheader within most HTTP requests. This is used\nto indicate the URL of the page from which the current request originated—\neither because the user clicked a hyperlink or submitted a form, or because the\npage referenced other resources such as images. Hence, it can be leveraged as\na mechanism for transmitting data via the client: because the URLs processed\nby the application are within its control, developers may assume that the Ref-\nererheader can be used to reliably determine which URL generated a partic-\nular request.\nFor example, consider a mechanism that enables users to reset their pass-\nword if they have forgotten it. The application requires users to proceed\nthrough several steps in a defined sequence, before they actually reset their\npassword’s value with the following request:\nPOST /customer/ResetForgotPassword.asp HTTP/1.1\nReferer: http://wahh-app.com/customer/ForgotPassword.asp\nHost: wahh-app.com\nContent-Length: 44\nuname=manicsprout&pass=secret&confirm=secret\nThe application may use the Refererheader to verify that this request orig-\ninated from the correct stage (ForgotPassword.asp), and if so allow the user to\nreset their password.\nHowever, because the user controls every aspect of every request, including\nthe HTTP headers, this control can be trivially circumvented by proceeding\ndirectly to ResetForgotPassword.asp, and using an intercepting proxy to fix\nthe value of the Refererheader to the value that the application requires.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 101\nChapter 5 ■ Bypassing Client-Side Controls 101\nThe Referer header is strictly optional according to w3.org standards.\nHence although most browsers implement it, using it to control application\nfunctionality should be regarded as a “hack.”\nCOMMON MYTH It is often assumed that HTTP headers are somehow\nmore “tamper-proof” than other parts of the request, such as the URL. This\nmay lead developers to implement functionality that trusts the values\nsubmitted in headers such as Cookieand Referer, while performing proper\nvalidation of other data such as URL parameters. This perception is false—\ngiven the multitude of intercepting proxy tools that are freely available, any\namateur hacker who targets an application can change all request data with\ntrivial ease. It is rather like supposing that when the teacher comes to search\nyour desk, it is safer to hide your water pistol in the bottom drawer, because\nshe will need to bend down further to discover it.\nHACK STEPS\n■ Locate all instances within the application where hidden form fields,\ncookies, and URL parameters are apparently being used to transmit data\nvia the client.\n■ Attempt to determine or guess the purpose that the item plays in the\napplication’s logic, based on the context in which it appears and on clues\nsuch as the parameter’s name.\n■ Modify the item’s value in ways that are relevant to its purpose in the\napplication. Ascertain whether the application processes arbitrary values\nsubmitted in the parameter, and whether this exposes the application to\nany vulnerabilities.\nOpaque Data\nSometimes, data transmitted via the client is not transparently intelligible,\nbecause it has been encrypted or obfuscated in some way. For example, instead\nof seeing a product’s price stored in a hidden field, you may see some cryptic\nvalue being transmitted:\n<form action=”order.asp” method=”post”>\n<p>Product: Sony VAIO A217S</p>\n<p>Quantity: <input size=”2” name=”quantity”>\n<input name=”enc” type=”hidden” value=”262a4844206559224f456864206668643\n265772031383932654448a352484634667233683277384f2245556533327233666455225\n242452a526674696f6471”>\n<input type=”submit” value=”Buy!”></p>\n</form>\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 102\n102 Chapter 5 ■ Bypassing Client-Side Controls\nWhen this is observed, you may reasonably infer that when the form is sub-\nmitted, the server-side application will decrypt or deobfuscate the opaque string\nand perform some processing on its plaintext value. This further processing may\nbe vulnerable to any kind of bug; however, in order to probe for and exploit this,\nyou will first need to wrap up your payload in the appropriate way.\nHACK STEPS\nFaced with opaque data being transmitted via the client, there are a several\npossible avenues of attack:\n■ If you know the value of the plaintext behind the opaque string, you can\nattempt to decipher the obfuscation algorithm being employed.\n■ As described in Chapter 4, the application may contain functions else-\nwhere that you can leverage to return the opaque string resulting from a\npiece of plaintext you control. In this situation, you may be able to\ndirectly obtain the required string to deliver an arbitrary payload to the\nfunction you are targeting.\n■ Even if the opaque string is completely impenetrable, it may be possible\nto replay its value in other contexts, to achieve some malicious effect. For\nexample, the encparameter in the previously shown form may contain\nan encrypted version of the product’s price. Although it is not possible to\nproduce the encrypted equivalent for an arbitrary price of your choosing,\nyou may be able to copy the encrypted price from a different, cheaper\nproduct and submit this in its place.\n■ If all else fails, you can attempt to attack the server-side logic that will\ndecrypt or deobfuscate the opaque string, by submitting malformed vari-\nations of it—for example, containing overlong values, different character\nsets, and the like.\nThe ASP.NET ViewState\nOne commonly encountered mechanism for transmitting opaque data via the\nclient is the ASP.NET ViewState. This is a hidden field that is created by default\nin all ASP.NET web applications, and contains serialized information about\nthe state of the current page. The ASP.NET platform employs the ViewState to\nenhance server performance—it enables the server to preserve elements\nwithin the user interface across successive requests without needing to main-\ntain all of the relevant state information on the server side. For example, the\nserver may populate a drop-down list on the basis of parameters submitted by\nthe user. When the user makes subsequent requests, the browser does not\ns ubmit the contents of the list back to the server. However, the browser does\nsubmit the hidden ViewState field, which contains a serialized form of the list.\nThe server deserializes the ViewState and recreates the same list that is pre-\nsented back to the user again.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 103\nChapter 5 ■ Bypassing Client-Side Controls 103\nIn addition to this core purpose of the ViewState, developers can use it to\nstore arbitrary information across successive requests. For example, instead of\nsaving the product’s price in a hidden form field, an application may save it in\nthe ViewState as follows:\nstring price = getPrice(prodno);\nViewState.Add(“price”, price);\nThe form returned to the user will now look something like this:\n<form method=”post” action=”order.aspx”>\n<input type=”hidden” name=”__VIEWSTATE” id=”__VIEWSTATE”\nvalue=”/wEPDwUKMTIxNDIyOTM0Mg8WAh4FcHJpY2UFBzEyMjQuOTVkZA==” />\n<p>Product: Sony VAIO A217S</p>\n<p>Quantity: <input name=”quantity” id=”quantity” />\n<input type=”submit” name=”buy” value=”Buy!” />\n</form>\nand when the user submits the form, their browser will send the following:\nPOST /order.aspx HTTP/1.1\nHost: wahh-app.com\nContent-Length: 95\n__VIEWSTATE=%2FwEPDwUKMTIxNDIyOTM0Mg8WAh4FcHJpY2UFBzEyMjQuOTVkZA%3D%3D&q\nuantity=1&buy=Buy%21\nThe request apparently does not contain the product price—only the quan-\ntity ordered and the opaque ViewState parameter. Changing that parameter at\nrandom results in an error message, and the purchase is not processed.\nThe ViewState parameter is actually a Base64-encoded string, which can be\neasily decoded:\nFF 01 0F 0F 05 0D 0A 31 32 31 34 32 32 39 33 34 ; ÿ......121422934\n32 0F 16 02 1E 05 70 72 69 63 65 05 07 31 32 32 ; 2.....price..122\n34 2E 39 35 64 64 ; 4.95dd\nTIP When you are attempting to decode what appears to be a Base64-\nencoded string, a common mistake is to begin decoding at the wrong position\nwithin the string. Because of the way Base64 encoding works, if you start at the\nwrong position, the decoded string will contain gibberish. Base64 is a block-\nbased format in which each 4 bytes of encoded data translates into 3 bytes of\ndecoded data. Hence, if your attempts to decode a Base64 string do not\nuncover anything meaningful, try starting from four adjacent offsets into the\nencoded string. For example, cycling through the first four offsets into\nHh4aGVsbG8gd29ybGQugenerates the following results:\n— — [ È ÛÜ>\n‡††VÆÆò v÷&Æ\ná¡•±±¼ ´Y½É±\nhello world.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 104\n104 Chapter 5 ■ Bypassing Client-Side Controls\nThere are two versions of the ViewState format, corresponding to different\nversions of ASP.NET. Version 1.1 is a simple text-based format that is effec-\ntively a compressed form of XML. Version 2, which is becoming more preva-\nlent, is a binary format and is shown in the example. String-based data can be\neasily spotted, and the decoded ViewState clearly contains the product price\nthat was previously stored in a hidden HTML form field. You can simply\nchange the value of the price parameter in a hex editor.\nFF 01 0F 0F 05 0D 0A 31 32 31 34 32 32 39 33 34 ; ÿ......121422934\n32 0F 16 02 1E 05 70 72 69 63 65 05 01 31 64 64 ; 2.....price..1dd\nNOTE Strings within version 2 of the ViewState are length-prepended, so\nchanging the price parameter from 1224.95 to 1 also requires that you change\nthe length from 7 to 1, shown here.\nYou can then reencode the modified structure as Base64, and submit the\nnew ViewState value to the application:\nPOST /order.aspx HTTP/1.1\nHost: wahh-app.com\nContent-Length: 87\n__VIEWSTATE=%2FwEPDwUKMTIxNDIyOTM0Mg8WAh4FcHJpY2UFATFkZA%3d%3d&quantity=\n1&cmdBuy=Buy%21\nwhich enables you to purchase the product at a price of 1.\nUnfortunately, however, hacking ASP.NET applications is not usually as\nsimple as this. There is an option within ASP.NET for the platform to include a\nkeyed hash within the ViewState structure. This option is often on by default\nbut can be explicitly activated by adding the following to the page declaration:\nEnableViewStateMac=”true”\nThe EnableViewStateMac option is activated in around 90% of today’s\nASP.NET applications, meaning that the ViewState parameter cannot be\ntampered with without breaking the hash. In the previous example, using this\noption results in the following ViewState:\nFF 01 0F 0F 05 0A 31 32 31 34 32 32 39 33 34 32 ; ÿ.....1214229342\n0F 16 02 1E 05 70 72 69 63 65 05 07 31 32 32 34 ; .....price..1224\n2E 39 35 64 64 C4 75 60 70 9F 10 8B 61 04 15 27 ; .95ddÄu`pŸ.‹a..’\nA1 06 1E F0 35 16 F0 46 A8 ; ¡..ð5.ðF¨\nThe additional data after the end of the serialized form data is the keyed hash\nof the preceding structure. If you now try to modify the price parameter, you\ncannot create a valid hash without knowing the secret key, which is stored on the\nserver. Changing the price alone returns the error message shown in Figure5-3.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 105\nChapter 5 ■ Bypassing Client-Side Controls 105\nFigure 5-3: ASP.NET rejects requests containing a modified ViewState\nwhen the EnableViewStateMac option is set.\nEven if the ViewState parameter is properly protected to prevent tampering,\nit may still contain sensitive data stored by the application that could be of use\nto an attacker. You can use the ViewState deserializer in Burp Proxy to decode\nand render the ViewState on any given page to identify any sensitive data it\ncontains, as shown in Figure5-4.\nFigure 5-4: Burp Proxy can decode and render the ViewState, allowing you to review its\ncontents and edit these if the EnableViewStateMac option is not set.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 106\n106 Chapter 5 ■ Bypassing Client-Side Controls\nHACK STEPS\n■ If you are attacking an ASP.NET application, verify whether the\nEnableViewStateMacoption is activated. This is indicated by the pres-\nence of a 20-byte hash at the end of the ViewState structure, and you can\nuse the decoder in Burp Proxy to confirm whether this is present.\n■ Even if the ViewState is protected, decode the ViewState parameter on\nvarious different application pages to discover whether the application is\nusing the ViewState to transmit any sensitive data via the client.\n■ Try to modify the value of a specific parameter within the ViewState,\nwithout interfering with its structure, and see whether an error message\nresults.\n■ If you can modify the ViewState without causing errors, you should\nreview the function of each parameter within the ViewState, and whether\nthe application uses it to store any custom data. Try to submit crafted\nvalues as each parameter, to probe for common vulnerabilities, as you\nwould for any other item of data being transmitted via the client.\n■ Note that the keyed hash option may be enabled or disabled on a per-\npage basis, so it may be necessary to test each significant page of the\napplication for ViewState hacking vulnerabilities.\nCapturing User Data: HTML Forms\nThe other principal way in which applications use client-side controls to\nrestrict data submitted by clients occurs with data that was not originally spec-\nified by the server but was gathered on the client computer itself.\nHTML forms are the simplest and most common mechanism for capturing\ninput from the user and submitting it to the server. In the most basic uses of this\nmethod, users type data into named text fields, which are submitted to the server\nas name/value pairs. However, forms can be used in other ways, which are\ndesigned to impose restrictions or perform validation checks on the user-supplied\ndata. When an application employs these client-side controls as a security mech-\nanism, to defend itself against malicious input, the controls can usually be triv-\nially circumvented, leaving the application potentially vulnerable to attack.\nLength Limits\nConsider the following variation on the original HTML form, which imposes a\nmaximum length of 3 on the quantity field:\n<form action=”order.asp” method=”post”>\n<p>Product: Sony VAIO A217S</p>\n<p>Quantity: <input size=”2” maxlength=”3” name=”quantity”>\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 107\nChapter 5 ■ Bypassing Client-Side Controls 107\n<input name=”price” type=”hidden” value=”1224.95”>\n<input type=”submit” value=”Buy!”></p>\n</form>\nHere, the browser will prevent the user from entering any more than three\ncharacters into the input field, and so the server-side application may assume\nthat the quantity parameter it receives will be no longer than this. However,\nthe restriction can be easily circumvented either by intercepting the request\ncontaining the form submission to enter an arbitrary value, or by intercepting\nthe response containing the form to remove the maxlengthattribute.\nINTERCEPTING RESPONSES\nWhen you are attempting to intercept and modify server responses, you may\nfind that the relevant message displayed in your proxy looks like this:\nHTTP/1.1 304 Not Modified\nDate: Wed, 21 Feb 2007 22:40:20 GMT\nEtag: “6c7-5fcc0900”\nExpires: Thu, 22 Feb 2007 00:40:20 GMT\nCache-Control: max-age=7200\nThis response arises because the browser already possesses a cached copy\nof the resource it requested. When the browser requests a cached resource, it\ntypically adds two additional headers to the request, called If-Modified-\nSinceand If-None-Match:\nGET /scripts/validate.js HTTP/1.1\nHost: wahh-app.com\nIf-Modified-Since: Sat, 17 Feb 2007 19:48:20 GMT\nIf-None-Match: “6c7-5fcc0900”\nThese headers tell the server the time at which the browser last updated its\ncached copy, and the Etagstring, which the server provided with that copy of\nthe resource. The Etagis a kind of serial number that the server assigns to\neach cacheable resource and that it updates each time the resource is\nmodified. If the server possesses a newer version of the resource than the date\nspecified in the If-Modified-Sinceheader, or if the Etagof the current\nversion does match the one specified in the If-None-Matchheader, then the\nserver will respond with the latest version of the resource. Otherwise, it will\nreturn a 304 response as shown here, informing the browser that the resource\nhas not been modified and that the browser should use its cached copy.\nWhen this occurs, and you need to intercept and modify the resource that\nthe browser has cached, you can intercept the relevant request and remove the\nIf-Modified-Sinceand If-None-Matchheaders, causing the server to\nrespond with the full version of the requested resource. Burp Proxy contains an\noption to strip these headers from every request, thereby overriding all cache\ninformation sent by the browser.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 108\n108 Chapter 5 ■ Bypassing Client-Side Controls\nHACK STEPS\n■ Look for form elements containing a maxlengthattribute. Submit data\nthat is longer than this length but that is validly formatted in other\nrespects (e.g., is numeric if the application is expecting a number).\n■ If the application accepts the overlong data, you may infer that the\nclient-side validation is not replicated on the server.\n■ Depending on the subsequent processing that the application performs\non the parameter, you may be able to leverage the defects in validation\nto exploit other vulnerabilities such as SQL injection, cross-site scripting,\nor buffer overflows.\nScript-Based Validation\nThe input validation mechanisms built into HTML forms themselves are\nextremely simple, and are insufficiently fine-grained to perform relevant vali-\ndation of many kinds of input. For example, a user registration form might\ncontain fields for name, email address, telephone number, and ZIP code, all of\nwhich expect different types of input. It is therefore very common to see cus-\ntomized client-side input validation implemented within scripts. Consider the\nfollowing variation on the original example:\n<script>\nfunction ValidateForm(theForm)\n{\nvar isInteger = /^\\d+$/\nif(!isInteger.test(theForm.quantity.value))\n{\nalert(“Please enter a valid quantity”);\nreturn false;\n}\nreturn true;\n}\n</script>\n<form action=”order.asp” method=”post” onsubmit=”return\nValidateForm(this)“>\n<p>Product: Sony VAIO A217S</p>\n<p>Quantity: <input size=”2” name=”quantity”>\n<input name=”price” type=”hidden” value=”1224.95”>\n<input type=”submit” name=”buy” value=”Buy!”></p>\n</form>\nThe onsubmit attribute of the form tag instructs the browser to execute the\nValidateFormfunction when the user clicks the submit button and to submit the\nform only if this function returns true. This mechanism enables the client-side\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 109\nChapter 5 ■ Bypassing Client-Side Controls 109\nlogic to intercept an attempted form submission, perform customized validation\nchecks on the user’s input, and decide whether to accept that input accordingly.\nIn the above example, the validation is extremely simple and checks whether the\ndata entered in the amount field is an integer.\nClient-side controls of this kind are usually trivial to circumvent, and it is\nnormally sufficient to disable JavaScript within the browser. If this is done, the\nonsubmit attribute is ignored, and the form is submitted without any custom\nvalidation.\nHowever, disabling JavaScript altogether may break the application if it\ndepends upon client-side scripting for its normal operation (such as construct-\ning parts of the user interface). A neater approach is to enter a benign value\ninto the input field in the browser, and then intercept the validated submission\nwith your proxy and modify the data to your desired value.\nAlternatively, you can intercept the server’s response that contains the\nJavaScript validation routine and modify the script to neutralize its effect—in\nthe previous example, by changing the ValidateFormfunction to return true in\nevery case.\nHACK STEPS\n■ Identify any cases where client-side JavaScript is used to perform input\nvalidation prior to form submission.\n■ Submit data to the server that the validation would ordinarily have\nblocked, either by modifying the submission request to inject invalid\ndata or by modifying the form validation code to neutralize it.\n■ As with length restrictions, determine whether the client-side controls\nare replicated on the server, and if not, whether this can be exploited for\nany malicious purpose.\n■ Note that if multiple input fields are subjected to client-side validation\nprior to form submission, you need to test each field individually with\ninvalid data, while leaving valid values in all of the other fields. If you\nsubmit invalid data in multiple fields simultaneously, it is possible that\nthe server will stop processing the form when it identifies the first invalid\nfield, and so your testing is not reaching all possible code paths within\nthe application.\nNOTE Client-side JavaScript routines to validate user input are extremely\ncommon in web applications but do not infer that every such application is\nvulnerable. The application is exposed only if client-side validation is not\nreplicated on the server, and even then only if crafted input that circumvents\nclient-side validation can be used to cause some undesirable behavior by the\napplication.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 110\n110 Chapter 5 ■ Bypassing Client-Side Controls\nIn the majority of cases, client-side validation of user input has beneficial\neffects on the application’s performance and the quality of the user experience.\nFor example, when filling out a detailed registration form, an ordinary user\nmight make various mistakes, such as omitting required fields or formatting\ntheir telephone number incorrectly. In the absence of client-side validation,\ncorrecting these mistakes may entail several reloads of the page, and round-\ntrip messages to the server. Implementing basic validation checks on the client\nside makes the user’s experience much smoother and reduces the load on the\nserver.\nDisabled Elements\nIf an element on an HTML form is flagged as disabled, it appears on-screen but\nis usually grayed out and is not editable or usable in the way an ordinary con-\ntrol is. Also, it is not sent to the server when the form is submitted. For exam-\nple, consider the following form:\n<form action=”order.asp” method=”post”>\n<p>Product: <input disabled=”true” name=”product” value=”Sony VAIO\nA217S”></p>\n<p>Quantity: <input size=”2” name=”quantity”>\n<input name=”price” type=”hidden” value=”1224.95”>\n<input type=”submit” value=”Buy!”></p>\n</form>\nThis includes the name of the product as a disabled text field and appears on-\nscreen as shown in Figure5-5.\nFigure 5-5: A form containing a disabled input field\nThe behavior of this form is identical to the original example: the only para-\nmeters submitted are quantity and price. However, the presence of a dis-\nabled field suggests that this parameter may originally have been used by the\napplication. Earlier versions of the form may have included a hidden or\neditable field containing the product name. This would have been submitted\nto the server and may have been processed by the application. Modifying the\nname of the product may not appear to be as promising an attack as modify-\ning its price. However, if this parameter is processed, then it may be vulnera-\nble to many kinds of bugs such as SQL injection or cross-site scripting, which\nare of interest to an attacker.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 111\nChapter 5 ■ Bypassing Client-Side Controls 111\nHACK STEPS\n■ Look for disabled elements within each form of the application. When-\never one is found, try submitting it to the server along with the form’s\nother parameters, to determine whether it has any effect.\n■ Often, submit elements are flagged as disabled so that buttons appear as\ngrayed out in contexts when the relevant action is not available. You\nshould always try to submit the names of these elements, to determine\nwhether the application performs a server-side check before attempting\nto carry out the requested action.\n■ Note that browsers do not include disabled form elements when forms\nare submitted, and so you will not identify these if you simply walk\nthrough the application’s functionality monitoring the requests issued by\nthe browser. To identify disabled elements, you need to monitor the\nserver’s responses or view the page source in your browser. You can also\nuse the automated “find and replace” function of your intercepting proxy\nto remove occurrences of the disabled attribute within input tags. See\nChapter 19 for details of this feature.\nCapturing User Data: Thick-Client Components\nBesides HTML forms, the other main method for capturing, validating, and\nsubmitting user data is to use a thick-client component. The technologies you\nare most likely to encounter here are Java applets, ActiveX controls, and\nShockwave Flash objects.\nThick-client components can capture data in various different ways, both via\ninput forms and in some cases by interacting with the client operating system’s\nfile system or registry. They can perform arbitrarily complex validation and\nmanipulation of captured data prior to submission to the server. Further,\nbecause their internal workings are less transparently visible than HTML forms\nand JavaScript, developers are more likely to assume that the validation they\nperform cannot be circumvented. For this reason, thick-client components are\noften a fruitful means of discovering vulnerabilities within web applications.\nNOTE Whatever validation and processing a thick-client component performs,\nif it submits data to the server in a transparent manner, then this data can be\nmodified using an intercepting proxy in just the same way as described for HTML\nform data. For example, a thick-client component supporting an authentication\nmechanism might capture user credentials, perform some validation on these,\nand submit the values to the server as plaintext parameters within the request.\nThe validation can be trivially circumvented without performing any analysis or\nattack on the component itself.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 112\n112 Chapter 5 ■ Bypassing Client-Side Controls\nThick-client components present a more interesting and challenging target\nwhen the data they capture is obfuscated in some manner before being\ntransmitted to the server. In this situation, modifying the submitted values\nwill typically break the obfuscation and so will be rejected by the server.\nTo circumvent the validation, it is necessary to look inside the thick-client\ncomponent itself, understand the validation and obfuscation it performs,\nand subvert its processing in some way so as to achieve your objective.\nJava Applets\nJava applets are a popular choice of technology for implementing thick-client\ncomponents because they are cross-platform and they run in a sandboxed\nenvironment which mitigates against various kinds of security problems that\ncan afflict more heavyweight thick-client technologies.\nAs a result of running in a sandbox, Java applets cannot normally access\noperating system resources such as the file system. Hence, their main use as a\nclient-side control is to capture user input or other in-browser information.\nConsider the following extract of HTML source, which loads a Java applet con-\ntaining a game:\n<script>\nfunction play()\n{\nalert(“you scored “ + TheApplet.getScore());\ndocument.location = “submitScore.jsp?score=” +\nTheApplet.getObsScore() + “&name=” +\ndocument.playForm.yourName.value;\n}\n</script>\n<form name=playForm>\n<p>Enter name: <input type=”text” name=”yourName” value=”“></p>\n<input type=”button” value=”Play” onclick=JavaScript:play()>\n</form>\n<applet code=”https://wahh-game.com/JavaGame.class”\nid=”TheApplet”></applet>\nIn this code, the applet tag instructs the browser to load a Java applet from\nthe specified URL and instantiate it with the name TheApplet. When the user\nclicks the Play button, a JavaScript routine executes that invokes the getScore\nmethod of the applet. This is when the actual game play takes place, after which\nthe score is displayed in an alert dialog. The script then invokes the getObsScore\nmethod of the applet, and submits the returned value as a parameter to the\nsubmitScore.jspURL, together with the name entered by the user.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 113\nChapter 5 ■ Bypassing Client-Side Controls 113\nFor example, playing the game results in a dialog like the one shown in Fig-\nure5-6, followed by a request for a URL with this form:\nhttps://wahh-game.com/submitScore.jsp?score=\nc1cc3139323c3e4544464d51515352585a61606a6b&name=daf\nwhich generates an entry in the high-scores table with a value of 38.\nFigure 5-6: A dialog produced when\nthe applet-based game is played\nIt appears, therefore, that the long string that is returned by the getObsScore\nmethod, and submitted in the score parameter, contains an obfuscated repre-\nsentation of your score. If you want to cheat the game and submit an arbitrary\nhigh score, you will need to figure out a way of correctly obfuscating your cho-\nsen score, so that it is decoded in the normal way by the server.\nOne approach you may consider is to harvest a large number of scores\ntogether with their obfuscated equivalents, and attempt to reverse engineer\nthe obfuscation algorithm. However, suppose that you play the game several\ntimes, always scoring 38 and observe the following values being submitted:\nbb58303981393b424d4a5059575c616a676d72757b818683\n5f48303981393b41474951585861606a656f6f7377817f828b\nfd20303981393b4149495651555c66686a6c73797680848489\n370c303981393b42494a505359606361696e76787b828584\nb5bc303981393b454549545a5a5e6365656971717d818388\n1744303981393b43464d515a585f5f646b6f7477767f7e86\nf3d4303981393b494a4b5653556162616e6d6f7577827e\nde08303981393b474a4d5357595b5d69676a7178757b\nda40303981393b43464b54545b6060676e6d70787e7b7e85\n1aec303981393b434d4b5054556266646c6b6e717a7f80\nEach time you submit a score of 38, a portion of the obfuscated string\nremains constant, but the majority of it changes in unpredictable ways. You\nfind that if you modify any of the obfuscated score, it is rejected by the server.\nAttempting to reverse engineer the algorithm based on observed values could\nbe a very difficult task.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 114\n114 Chapter 5 ■ Bypassing Client-Side Controls\nNOTE The idea of attacking a Java-based game to submit an arbitrary score\nmay appear frivolous. However, thick-client components are employed by many\ncasino web sites, which play for real money. Posting an arbitrary score to an\napplication like this may be a very serious business!\nDecompiling Java Bytecode\nA much more promising approach is to decompile the applet to obtain its\nsource code. Languages like Java are not compiled into native machine\ninstructions, but to an intermediate language called bytecode, which is inter-\npreted at runtime by a virtual machine. Normally, Java bytecode can be\ndecompiled to recover its original source code without too many problems.\nTo decompile a client-side applet, you first need to save a copy of it to disk.\nYou can do this simply by using your browser to request the URL specified in\nthe codeattribute of the applettag shown previously.\nThere are various tools available that can decompile Java bytecode. The fol-\nlowing example shows partial output from one such tool, Jad:\nE:\\>jad.exe JavaGame.class\nParsing JavaGame.class... Generating JavaGame.jad\nE:\\>type JavaGame.jad\n// Decompiled by Jad v1.5.8f. Copyright 2001 Pavel Kouznetsov.\n// Jad home page: http://www.kpdus.com/jad.html\n// Decompiler options: packimports(3)\n// Source File Name: JavaGame.java\nimport java.applet.Applet;\nimport java.awt.Graphics;\npublic class JavaGame extends Applet\n{\npublic int getScore()\n{\nplay();\nreturn score;\n}\npublic String getObsScore()\n{\nreturn obfuscate(Integer.toString(score) + “|” +\nDouble.toString(Math.random()));\n}\npublic static String obfuscate(String input)\n{\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 115\nChapter 5 ■ Bypassing Client-Side Controls 115\nreturn hexEncode(checksum(input) + scramble(input));\n}\nprivate static String scramble(String input)\n{\nStringBuffer output = new StringBuffer();\nfor(int i = 0; i < input.length(); i++)\noutput.append((char)((input.charAt(i) - 3) + i * 4));\nreturn output.toString();\n}\nprivate static String checksum(String input)\n{\nchar checksum = ‘\\0’;\nfor(int i = 0; i < input.length(); i++)\n{\nchecksum ^= input.charAt(i);\nchecksum <<= ‘\\002’;\n}\nreturn new String(new char[] {\n(char)(checksum / 256), (char)(checksum % 256)\n});\n}\n...\nNOTE For various reasons, Jad sometimes does not do a perfect job of\ndecompiling bytecode, and you may need to tidy up some of its output before it\ncan be recompiled.\nWith access to this source code, you can immediately see how your score is\nconverted into a long obfuscated string that has the characteristics observed.\nThe applet first appends some random data to your score (separated by the\npipe character). It takes a checksum of the resulting string, and also scrambles\nit. It then prepends the checksum to the scrambled string and finally hex-\nencodes the result for safe transmission within a URL parameter.\nThe addition of some random data accounts for the length and unpre-\ndictability of the obfuscated string, and the addition of a checksum explains\nwhy changing any part of the obfuscated string causes the server-side decoder\nto reject it.\nHaving decompiled the applet back to its source code, there are various\nways in which you could leverage this to bypass the client-side controls and\nsubmit an arbitrary high score to the server:\n■■ You can modify the decompiled source to change the behavior of the\napplet, recompile it to bytecode, and modify the source code of the\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 116\n116 Chapter 5 ■ Bypassing Client-Side Controls\nHTML page to load the modified applet in place of the original. For\nexample, you could change the getObsScoremethod to:\nreturn obfuscate(“99999|0.123456789”);\nTo recompile your modified code, you should use the Java compiler\njavacprovided with Sun’s Java SDK.\n■■ You can add a main method to the decompiled source to provide the\nfunctionality to obfuscate arbitrary inputs:\npublic static void main(String[] args)\n{\nSystem.out.println(obfuscate(args[0]));\n}\nYou can then run the recompiled byte code from the command line to\nobfuscate any score you like:\nE:\\>java JavaGame “99999|0.123456789“\n6ca4363a3e42468d45474e53585d62676c7176\n■■ You can review the public methods exposed by the applet to determine\nwhether any of them can be leveraged to achieve your objectives with-\nout actually modifying the applet. In the present case, you can see that\nthe obfuscatemethod is marked as public, meaning that you can call it\ndirectly from JavaScript with arbitrary input. Hence, you can submit\nyour chosen score simply by modifying the source code of the HTML\npage as follows:\nfunction play()\n{\nalert(“you scored “ + TheApplet.getScore());\ndocument.location = “submitScore.jsp?score=” +\nTheApplet.obfuscate(“99999|0.123456789”) + “&name=” +\ndocument.playForm.yourName.value;\n}\nTIP Often, Java applets are packed up as JAR (Java ARchive) files, which\ncontain multiple class files and other resources such as sounds and images.\nJAR files are really just ZIP archives with the .jarfile extension. You can\nunpack and repack them using standard archive readers like WinRar or WinZip,\nand also using the Jar tool, which is included in Sun’s Java SDK.\nTIP Other useful tools for analyzing and manipulating Java applets are Jode\n(a decompiler and bytecode obfuscator) and JSwat (a Java debugger).\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 117\nChapter 5 ■ Bypassing Client-Side Controls 117\nHACK STEPS\n■ Review all calls made to an applet’s methods, and determine whether\ndata returned from the applet is being submitted to the server.\n■ If that data is transparent in nature (i.e., is not obfuscated or encrypted),\nprobe and attack the server’s processing of the submitted data in the\nsame way as for any other parameter.\n■ If the data is opaque, decompile the applet to obtain its source code.\n■ Review the relevant source code (starting with the implementation of the\nmethod that returns the opaque data) to understand what processing is\nbeing performed.\n■ Determine whether the applet contains any public methods that can be\nused to perform the relevant obfuscation on arbitrary input.\n■ If not, modify and recompile the applet’s source in such a way as to neu-\ntralize any validation it performs or allow you to obfuscate arbitrary\ninput.\n■ Then, submit various suitably obfuscated attack strings to the server to\nprobe for vulnerabilities, as you would for any other parameter.\nCoping with Bytecode Obfuscation\nBecause of the ease with which Java bytecode can be decompiled to recover its\nsource, various techniques have been developed to obfuscate the bytecode\nitself. Applying these techniques results in bytecode that is harder to decom-\npile or that decompiles to misleading or invalid source code that may be very\ndifficult to understand and impossible to recompile without substantial effort.\nFor example:\npackage myapp.interface;\nimport myapp.class.public;\nimport myapp.interface.else.class;\nimport myapp.throw.throw;\nimport if.if.if.if.else;\nimport if.if.if.if.if;\nimport java.awt.event.KeyEvent;\npublic class double extends public implements strict\n{\npublic double(j j1)\n{\n_mthif();\n_fldif = j1;\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 118\n118 Chapter 5 ■ Bypassing Client-Side Controls\n}\nprivate void _mthif(ActionEvent actionevent)\n{\n_mthif(((KeyEvent) (null)));\nswitch(_fldif._mthnew()._fldif)\n{\ncase 0:\n_fldfloat.setEnabled(false);\n_fldboolean.setEnabled(false);\n_fldinstanceof.setEnabled(false);\n_fldint.setEnabled(false);\nbreak;\ncase 3:\n_fldfloat.setEnabled(true);\n_fldboolean.setEnabled(true);\n_fldinstanceof.setEnabled(false);\n_fldint.setEnabled(false);\nbreak;\n...\nThe obfuscation techniques commonly employed are as follows:\n■■ Meaningful class, method, and member variable names are replaced\nwith meaningless expressions like a, b, c. This forces the reader of\ndecompiled code to identify the purpose of each item by studying how\nit is used, and can make it very difficult to keep track of different items\nwhile tracing them through the source code.\n■■ Going further, some obfuscators replace item names with Java key-\nwords such as newand int. Although this technically renders the byte-\ncode illegal, most JVMs will tolerate the illegal code and it will execute\nnormally. However, even if a decompiler can handle the illegal byte-\ncode, the resulting source code will be even less readable than that\ndescribed in the previous point. More importantly, the source will not\nbe recompilable without extensive reworking to rename illegally named\nitems in a consistent manner.\n■■ Many obfuscators strip unnecessary debug and meta-information from\nthe bytecode, including source file names and line numbers (which\nmakes stack traces less informative), local variable names (which frus-\ntrates debugging), and inner class information (which stops reflection\nfrom working properly).\n■■ Redundant code may be added that creates and manipulates various\nkinds of data in significant-looking ways but that is autonomous from\nthe real data actually being used by the application’s functionality.\n■■ The path of execution through code can be modified in convoluted\nways, through the use of jump instructions, so that the logical sequence\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 119\nChapter 5 ■ Bypassing Client-Side Controls 119\nof execution is hard to discern when reading through the decompiled\nsource.\n■■ Illegal programming constructs may be introduced, such as unreach-\nable statements, and code paths with missing return statements. Most\nJVMs will tolerate these phenomena in bytecode, but the decompiled\nsource cannot be recompiled without correcting the illegal code.\nHACK STEPS\nEffective tactics for coping with bytecode obfuscation depend upon the\ntechniques used and the purpose for which you are analyzing the source. Here\nare some suggestions:\n■ You can review an applet for public methods without fully understanding\nthe source. It should be obvious which methods can be invoked from\nJavaScript, and what their signatures are, enabling you to test the behav-\nior of the methods by passing in various inputs.\n■ If class, method, and member variable names have been replaced with\nmeaningless expressions (but not Java keywords), then you can use the\nrefactoring functionality built into many IDEs to assist you in understand-\ning the code. By studying how items are used, you can start to assign\nthem meaningful names. If you use the “rename” tool within the IDE, it\nwill do a lot of work for you, tracing the use of the item throughout the\ncodebase and renaming it everywhere.\n■ You can actually undo a lot of obfuscation by running the obfuscated\nbytecode through an obfuscator a second time and choosing suitable\noptions. A useful obfuscator to use here is Jode, which can remove\nredundant code paths added by another obfuscator, and facilitate the\nprocess of understanding obfuscated names by assigning globally unique\nnames to items.\nActiveX Controls\nActiveX controls are a much more heavyweight technology than Java applets.\nThey are effectively native Win32 executables that, once accepted and installed\nby the user, execute with the full privileges of that user and can carry out arbi-\ntrary actions, including interacting with the operating system.\nActiveX can be used to implement practically any client-side control,\nincluding capturing user input and other in-browser data, and verifying that\nthe client computer meets certain security standards before allowing access to\nsome function.\nFrom the point of view of HTML page source, ActiveX controls are instanti-\nated and invoked in a very similar way to Java applets. For example, if you\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 120\n120 Chapter 5 ■ Bypassing Client-Side Controls\nhave installed the Adobe Acrobat plug-in for Internet Explorer, the following\ncode will display a dialog showing the version of Acrobat installed:\n<object id=”TheAxControl”\nclassid=”CLSID:4F878398-E58A-11D3-BEE9-00C04FA0D6BA”>\n</object>\n<form>\n<input type=”button” value=”Show version”\nonclick=JavaScript:alert(document.TheAxControl.AcrobatVersion)>\n</form>\nIn addition to looking for code like this, you can easily identify instances\nwhere an application attempts to install a new ActiveX control, because your\nbrowser will present an alert asking for your permission to install it.\nNOTE Poorly written ActiveX controls have been a major source of security\nvulnerabilities in recent years, and unwitting users who install defective\ncontrols often leave themselves open to full system compromise at the hands\nof any malicious web site that invokes and exploits the control. In Chapter 12,\nwe describe how you can find and exploit common vulnerabilities in ActiveX\ncontrols to attack other users of an application.\nThere are various techniques that can be used to circumvent client-side con-\ntrols implemented using ActiveX.\nReverse Engineering\nBecause ActiveX controls are typically written in native languages like C and\nC++, they cannot be trivially decompiled back to source code in the way that\nJava applets can be. Nevertheless, because all of the processing performed by\nan ActiveX control occurs on the client computer, it is in principle possible for\na user on that computer to fully scrutinize and control that processing, thereby\ncircumventing any security functions that it implements.\nReverse engineering is a complex and advanced topic, which extends\nbeyond the scope of this book. However, there are some basic techniques that\neven a relatively inexperienced reverse engineer can use to defeat the client-\nside security mechanisms implemented within many ActiveX controls.\nHACK STEPS\n■ Rather than pursuing a full static disassembly of the component’s code, use\nan intuitive GUI-based debugger to monitor and control its execution at run-\ntime. For example, OllyDbg is an accessible yet powerful debugger that can\nbe used to achieve many kinds of attacks on compiled software at runtime:\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 121\nChapter 5 ■ Bypassing Client-Side Controls 121\nHACK STEPS (continued)\n■ Identify the methods exported by the control and its subcomponents,\nand also any interesting operating system functions which the control\nimports—in particular, any cryptographic functions. Set breakpoints on\nthese functions within the debugger.\n■ When a breakpoint is hit, review the call stack to identify any relevant\ndata being passed to the function—in particular, any user-supplied data\nthat is being subjected to validation. By tracing the path of this data,\nattempt to understand the processing being performed on it.\n■ It is often easy to use a debugger to subvert the execution path of a\nprocess in useful ways—for example, by modifying the parameters on\nthe stack being passed as inputs to a function, modifying the EAX regis-\nter used to pass the return value back from a function, or rewriting key\ninstructions like comparisons and jumps to change the logic imple-\nmented within a function. If possible, use these techniques to circumvent\nvalidation controls, causing potentially malicious data to be accepted for\nfurther processing.\n■ If data validation is performed before further manipulation such as\nencryption or obfuscation, you can exploit this separation by supplying\nvalid data to the control, and then intercept and modify the data after it\nhas passed the validation steps, so that your potentially malicious data is\nappropriately manipulated before being transmitted to the server-side\napplication.\n■ If you find a means of manually altering the control’s processing to\ndefeat the validation it is performing, you can automate the execution of\nthis attack either by modifying the control’s binary on-disk (OllyDbg has\na facility to update binaries to reflect changes you have made to its code\nwithin the debugger) or by hooking into the target process at runtime,\nusing an instrumentation framework such as Microsoft Detours.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 122\n122 Chapter 5 ■ Bypassing Client-Side Controls\nThe following are some useful resources if you’d like to find out more about\nreverse engineering and related topics:\n■■ Reversing: Secrets of Reverse Engineeringby Eldad Eilam\n■■ Hacker Disassembling Uncoveredby Kris Kaspersky\n■■ The Art of Software Security Assessmentby Mark Dowd, John McDonald,\nand Justin Schuh\n■■ www.acm.uiuc.edu/sigmil/RevEng\n■■ www.uninformed.org/?v=1&a=7\nManipulating Exported Functions\nAs with Java applets, it may be possible to manipulate and repurpose an\nActiveX control’s processing solely by invoking methods that it exposes to the\nbrowser through its normal interface.\nActiveX controls may expose numerous methods that the application never\nactually invokes from HTML, which you may not be aware of without exam-\nining the control itself. COMRaider by iDefense is a useful tool that can dis-\nplay all of a control’s methods and their signatures, as shown in Figure5-7.\nFigure 5-7: COMRaider showing the methods exposed by an ActiveX control\nHACK STEPS\n■ Developers typically use meaningful names for ActiveX methods, and it\nmay be possible to identify useful methods simply from their names.\n■ You can sometimes determine the purpose of a function by systemati-\ncally invoking it with different inputs and monitoring both the visible\nbehavior of the control and its internal workings using your debugger.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 123\nChapter 5 ■ Bypassing Client-Side Controls 123\nFixing Inputs Processed by Controls\nA common use to which ActiveX controls are put is as a client-side control to\nverify that the client computer complies with specific security standards before\naccess is granted to certain server-side functionality. For example, in an attempt\nto mitigate against keylogging attacks, an online banking application may\ninstall a control that checks for the presence of a virus scanner, and the operat-\ning system patch level, before permitting a user to log in to the application.\nIf you need to circumvent this type of client-side control, it is usually easy to\ndo. The ActiveX control will typically read various details from the local com-\nputer’s file system and registry as input data for its checks. You can monitor\nthe information being read and feed arbitrary inputs into the control that com-\nply with its security checks.\nThe Filemon and Regmon tools originally developed by Sysinternals (and\nnow owned by Microsoft) enable you to monitor all of a process’s interaction\nwith the computer’s file system and registry. You can filter the tools’ output to\ndisplay only the activity of the process you are interested in. When an ActiveX\ncontrol is performing security checks on the client computer, you will typically\nsee it querying security-relevant files and registry keys, such as items created\nby antivirus products, as shown in Figure5-8.\nFigure 5-8: Regmon being used to capture the registry access carried\nout by an ActiveX control\nIn this situation, it is usually sufficient to manually create the relevant file or\nregistry key, to convince the control that the corresponding software is installed.\nIf for some reason you do not wish to interfere with the actual operating system,\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 124\n124 Chapter 5 ■ Bypassing Client-Side Controls\nyou can achieve the same effect using the debugging or instrumentation tech-\nniques described previously, to fix the data returned to the control by the rele-\nvant file system or registry APIs.\nDecompiling Managed Code\nOccasionally, you may encounter thick-client components written in C#. As\nwith Java applets, these can normally be decompiled to recover the original\nsource code.\nA useful tool for performing this task is .NET Reflector by Lutz Roeder (see\nFigure5-9).\nFigure 5-9: The .NET Reflector tool being used to decompile an\nActiveX control written in C#\nSimilar code obfuscation issues can arise in relation to C# assemblies as arise\nwith Java bytecode.\nShockwave Flash Objects\nFlash is very popular on the Internet. It is often used as a means of providing\nincreased interactivity in informational web sites, but it is also employed in\nweb applications. Some online stores have Flash-based user interfaces, and it\nis often used in jukebox software such as Pandora radio. The most common\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 125\nChapter 5 ■ Bypassing Client-Side Controls 125\nuse of Flash in an application context is in online games. These vary in nature\nfrom purely recreational games to serious casino functionality, where real\nmoney is involved. Many such games have been targeted by correspondingly\nrecreational and serious attackers.\nGiven what we have observed about the fallible nature of client-side con-\ntrols, the idea of implementing an online gambling application using a thick-\nclient component that runs locally on a potential attacker’s machine is an\nintriguing one. If any aspect of the game play is controlled within the Flash\ncomponent instead of by the server, an attacker could manipulate the game\nwith fine precision to improve odds, change the rules, or alter the scores sub-\nmitted back to the server.\nLike the other thick-client components examined, Flash objects are con-\ntained within a compiled file that the browser downloads from the server and\nexecutes in a virtual machine, which in this case is a Flash player implemented\nin a browser plug-in. The SWF file contains bytecode that is interpreted by the\nFlash VM (virtual machine), and as with Java bytecode, this can be decompiled\nto recover the original ActionScript source code, using appropriate tools. An\nalternative means of attack, which is often more effective, is to disassemble\nand modify the bytecode itself, without actually fully decompiling it to source.\nFlasm is a disassembler and assembler for SWF bytecode and can be used to\nextract a human-readable representation of the bytecode from an SWF file and\nthen reassemble modified bytecode into a new SWF file:\nC:\\flash>flasm\nFlasm 1.61 build May 31 2006\n(c) 2001 Opaque Industries, (c) 2002-2005 Igor Kogan, (c) 2005 Wang Zhen\nAll rights reserved. See LICENSE.TXT for terms of use.\nUsage: flasm [command] filename\nCommands:\n-d Disassemble SWF file to the console\n-a Assemble Flasm project (FLM)\n-u Update SWF file, replace Flasm macros\n-b Assemble actions to __bytecode__ instruction or byte sequence\n-z Compress SWF with zLib\n-x Decompress SWF\nBackups with $wf extension are created for altered SWF files.\nTo save disassembly or __bytecode__ to file, redirect it:\nflasm -d foo.swf > foo.flm\nflasm -b foo.txt > foo.as\nRead flasm.html for more information.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 126\n126 Chapter 5 ■ Bypassing Client-Side Controls\nThe following example shows Flasm being used to extract a human-\nr eadable representation of bytecode from an SWF file for a simple Flash-based\ncar racing game:\nC:\\flash>flasm racer.swf > racer.flm\nC:\\flash>more racer.flm\nmovie ‘racer.swf’ compressed // flash 7, total frames: 3, frame rate: 24\nfps, 64\n0x500 px\nexportAssets\n1 as ‘engineStart’\nend // of exportAssets\nexportAssets\n2 as ‘engineLoop’\nend // of exportAssets\nframe 0\nstop\npush ‘car1’\ngetVariable\npush ‘code’, ‘player’\nsetMember\npush ‘totalLaps’, 10\nsetVariable\npush ‘acceleration’, 1.9\nsetVariable\npush ‘gravity’, 0.4\nsetVariable\npush ‘speedDecay’, 0.96\nsetVariable\npush ‘rotationStep’, 10\nsetVariable\npush ‘maxSpeed’, 10\nsetVariable\npush ‘backSpeed’, 1\nsetVariable\npush ‘currentCheckpoint1’, 1\nsetVariable\npush ‘currentLap1’, 0.0\nsetVariable\npush ‘checkpoints’, 2\nsetVariable\npush ‘currentLapTXT’, ‘1/10’\nsetVariable\nend // of frame 0\nframe 0\nconstants ‘car’, ‘code’, ‘player’, ‘speed’, ‘speedDecay’, ‘Key’,\n‘isDown’, ‘\n...\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 127\nChapter 5 ■ Bypassing Client-Side Controls 127\nHere, you can immediately see various bytecode instructions that are of\ninterest to someone wishing to attack and modify the game. For example, you\ncould change the value of the maxSpeed variable from 10 to something a bit\nmore competitive. After doing this, the modified disassembly can then be con-\nverted back into bytecode in a new SWF file, as follows:\nC:\\flash>flasm –a racer.flm\nracer.flm successfully assembled to racer.swf, 31212 bytes\nThe car should now virtually fly around the track (to make it literally fly,\nyou could try changing the gravityvariable!).\nIn the previous example, the functionality implemented within the Flash\nobject was sufficiently simple that an attacker could fundamentally reengineer\nthe object by inspecting the disassembled bytecode and changing a single vari-\nable. In more complex Flash objects, this may not be possible, and it may be\nnecessary to recover the original source and review it in detail to discover how\nthe object works and where best to attack it. The Flare tool can be used to\ndecompile an SWF file back into the original ActionScript source:\nC:\\flash>flare racer.swf && more racer.flr\nmovie ‘racer.swf’ {\n// flash 7, total frames: 3, frame rate: 24 fps, 640x500 px, compressed\nframe 1 {\nstop();\ncar1.code = ‘player’;\ntotalLaps = 10;\nacceleration = 1.9;\ngravity = 0.4\nspeedDecay = 0.96;\nrotationStep = 10;\nmaxSpeed = 10;\nbackSpeed = 1;\ncurrentCheckpoint1 = 1;\ncurrentLap1 = 0;\ncheckpoints = 2;\ncurrentLapTXT = ‘1/10’;\n}\n...\nWhile modifying recreational games is usually straightforward and may be\nfun for personal amusement and beating a coworker, the client-side controls\nimplemented within the Flash objects used by enterprise applications and\nonline casinos are typically better protected. As with Java, obfuscation tech-\nniques have been devised in an attempt to hinder decompilation attacks. Two\navailable tools are ActionScript Obfuscator and Viewer Screwer, which can\nchange both meaningful variable names and text references into scrambled\nsequences of letters, making the decompiled code harder to understand.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 128\n128 Chapter 5 ■ Bypassing Client-Side Controls\nThe tools described can be obtained from:\n■■ Flasm—www.nowrap.de/flasm\n■■ Flare—www.nowrap.de/flare\n■■ ActionScript Obfuscator—www.genable.com/aso.html\n■■ Viewer Screwer—www.debreuil.com/vs\nHACK STEPS\n■ Explore the functionality of the Flash object within your browser. Use an\nintercepting proxy to monitor any requests made to the server, to under-\nstand which actions are executed entirely within the client-side compo-\nnent itself and which may involve some server-side processing and\ncontrols.\n■ Any time you see data being submitted to the server, determine whether\nthis is transparent in nature, or has been obfuscated or encrypted in\nsome way. If the former is the case, you can bypass any controls imple-\nmented within the object by simply modifying this data directly.\n■ If the data that the object submits is opaque in nature, use Flasm to dis-\nassemble the object into human-readable bytecode, and use Flare to\ndecompile the object into ActionScript source.\n■ As with decompiled Java applets, review the bytecode and source to\nidentify any attack points that will enable you to reengineer the Flash\nobject and bypass any controls implemented within it.\nHandling Client-Side Data Securely\nAs you have seen, the core security problem with web applications arises\nbecause client-side components and user input are outside of the server’s\ndirect control. The client, and all of the data received from it, is inherently\nuntrustworthy.\nTransmitting Data via the Client\nMany applications leave themselves exposed because they transmit critical\ndata such as product prices and discount rates via the client in an unsafe\nmanner.\nIf possible, applications should avoid transmitting this kind of data via the\nclient altogether. In virtually any conceivable scenario, it is possible to hold\nsuch data on the server, and reference it directly from server-side logic when\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 129\nChapter 5 ■ Bypassing Client-Side Controls 129\nneeded. For example, an application that receives users’ orders for various dif-\nferent products should allow users to submit a product code and quantity, and\nlook up the price of each requested product in a server-side database. There is\nno need for users to submit the prices of items back to the server. Even where\nan application offers different prices or discounts to different users, there is no\nneed to depart from this model. Prices can be held within the database on a\nper-user basis, and discount rates can be stored in user profiles or even session\nobjects. The application already possesses, server-side, all of the information it\nneeds to calculate the price of a specific product for a specific user—it must,\notherwise it would not be able, on the insecure model, to store this price in a\nhidden form field.\nIf developers decide they have no alternative but to transmit critical data via\nthe client, then the data should be signed and/or encrypted to prevent tam-\npering by the user. If this course of action is taken, then there are two impor-\ntant pitfalls to avoid:\n■■ Some ways of using signed or encrypted data may be vulnerable\nto replay attacks. For example, if the product price is encrypted\nbefore being stored in a hidden field, it may be possible to copy the\nencrypted price of a cheaper product, and submit this in place of the\noriginal price. To prevent this attack, the application needs to include\nsufficient context within the encrypted data to prevent it from being\nreplayed in a different context. For example, the application could con-\ncatenate the product code and price, encrypt the result as a single item,\nand then validate that the encrypted string submitted with an order\nactually matches the product being ordered.\n■■ If users know and/or control the plaintext value of encrypted strings\nthat are sent to them, then they may be able to mount various crypto-\ngraphic attacks to discover the encryption key being used by the server.\nHaving done this, they can encrypt arbitrary values and fully circum-\nvent the protection offered by the solution.\nIn applications running on the ASP.NET platform, it is advisable to never\nstore any customized data within the ViewState, and certainly never anything\nsensitive that you would not want to be displayed on-screen to users. The\noption to enable the ViewState MAC should always be activated.\nValidating Client-Generated Data\nData generated on the client and transmitted to the server cannot in principle\nbe validated securely on the client:\n■■ Lightweight client-side controls like HTML form fields and JavaScript\ncan be very trivially circumvented, and provide zero assurance about\nthe input received by the server.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 130\n130 Chapter 5 ■ Bypassing Client-Side Controls\n■■ Controls implemented in thick-client components are sometimes more\ndifficult to circumvent, but this may merely slow down an attacker for a\nshort period.\n■■ Using heavily obfuscated or packed client-side code provides addi-\ntional obstacles; however, a determined attacker will always be able to\novercome these. (A point of comparison in other areas is the use of\nDRM technologies to prevent users from copying digital media files.\nMany companies have invested very heavily in these client-side con-\ntrols, and each new solution is usually broken within a short interval.)\nThe only secure way to validate client-generated data is on the server side of\nthe application. Every item of data received from the client should be regarded\nas tainted and potentially malicious.\nCOMMON MYTH It is sometimes perceived that any use of client-\nside controls must be automatically bad. In particular, some professional\npenetration testers report the presence of client-side controls as a “finding”\nwithout verifying whether they are replicated on the server or whether there is\nany nonsecurity explanation for their existence. In fact, despite the significant\ncaveats arising from the various attacks described in this chapter, there are\nnevertheless ways of using client-side controls in ways that do not give rise to\nany security vulnerabilities:\n■■ Client-side scripts can be used to validate input as a means of\nenhancing usability, avoiding the need for round-trip communication\nwith the server. For example, if the user enters their date of birth in an\nincorrect format, alerting them to the problem via a client-side script\nprovides a much more seamless experience. Of course, the application\nmust revalidate the item submitted when it arrives at the server.\n■■ There are occasional cases where client-side data validation can be\neffective as a security measure—for example, as a defense against\nDOM-based cross-site scripting attacks. However, these are cases\nwhere the direct focus of the attack is another application user, rather\nthan the server-side application, and exploiting a potential\nvulnerability does not necessarily depend upon transmitting any\nmalicious data to the server. See Chapter 12 for further details of this\nkind of scenario.\n■■ As described previously, there are ways of transmitting encrypted data\nvia the client that are not vulnerable to tampering or replay attacks.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 131\nChapter 5 ■ Bypassing Client-Side Controls 131\nLogging and Alerting\nWhen mechanisms such as length limits and JavaScript-based validation are\nemployed by an application to enhance performance and usability, these\nshould be integrated with server-side intrusion detection defenses. The server-\nside logic which performs validation of client-submitted data should be aware\nof the validation that has already occurred on the client side. If data that would\nhave been blocked by client-side validation is received, the application may\ninfer that a user is actively circumventing this validation, and so is likely to be\nmalicious. Anomalies should be logged and, if appropriate, application\nadministrators should be alerted in real time so that they can monitor any\nattempted attack and take suitable action as required. The application may\nalso actively defend itself by terminating the user’s session or even suspend-\ning his account.\nNOTE In some cases where JavaScript is employed, the application is still\nusable by users who have disabled JavaScript within their browser. In this\nsituation, JavaScript-based form validation code is simply skipped by the\nbrowser, and the raw input entered by the user is submitted. To avoid false\npositives, the logging and alerting mechanism should be aware of where and\nhow this can arise.\nChapter Summary\nVirtually all client-server applications must accept the fact that the client com-\nponent, and all processing that occurs on it, cannot be trusted to behave as\nexpected. As you have seen, the transparent communications methods gener-\nally employed by web applications mean that an attacker equipped with sim-\nple tools and minimal skill can trivially circumvent most controls\nimplemented on the client. Even where an application makes attempts to\nobfuscate data and processing residing on the client side, a determined\nattacker will be able to compromise these defenses.\nIn every instance where you identify data being transmitted via the client, or\nvalidation of user-supplied input being implemented on the client, you should\ntest how the server responds to unexpected data that bypasses those controls.\nVery often, serious vulnerabilities are to be found lurking behind an applica-\ntion’s assumptions about the protection afforded to it by defenses that are\nimplemented at the client.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 132\n132 Chapter 5 ■ Bypassing Client-Side Controls\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. How can data be transmitted via the client in a way that prevents tam-\npering attacks?\n2. An application developer wishes to stop an attacker from performing\nbrute-force attacks against the login function. Because the attacker may\ntarget multiple usernames, the developer decides to store the number of\nfailed attempts in an encrypted cookie, blocking any request if the num-\nber of failed attempts exceeds five.\nHow can this defense be bypassed?\n3. An application contains an administrative page that is subject to rigor-\nous access controls. The page contains links to diagnostic functions\nlocated on a different web server. Access to these functions should also\nbe restricted to administrators only. Without implementing a second\nauthentication mechanism, which of the following client-side mecha-\nnisms (if any) could be used to safely control access to the diagnostic\nfunctionality? Is there any further information you would need to help\nchoose a solution?\n(a) The diagnostic functions could check the HTTP Refererheader, to\nconfirm that the request originated on the main administrative page.\n(b) The diagnostic functions could validate the supplied cookies, to con-\nfirm that these contain a valid session token for the main applica-\ntion.\n(c) The main application could set an authentication token in a hidden\nfield that is included within the request. The diagnostic function\ncould validate this to confirm that the user has a session on the main\napplication.\n4. If a form field includes the attribute disabled=true, it will not be sub-\nmitted with the rest of the form. How can you change this behavior?\n5. Are there any means by which an application can ensure that a piece of\ninput validation logic has been run on the client?"
  },
  {
    "input": "What are the key vulnerabilities in web application authentication mechanisms and how can they be addressed?",
    "summary": "Authentication is a critical but often overlooked security mechanism in web applications, as it is the first line of defense against unauthorized access. However, many applications have design and implementation flaws that make them vulnerable to attacks like weak passwords, brute-force logins, and insecure data transmission. This chapter details various vulnerabilities and provides methods to identify and exploit them, emphasizing the importance of robust authentication practices to prevent unauthorized access and data breaches.",
    "output": "70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 133\nCHAPTER\n6\nAttacking Authentication\nOn the face of it, authentication is conceptually among the simplest of all the\nsecurity mechanisms employed within web applications. In the typical case, a\nuser supplies her username and password, and the application must verify\nthat these items are correct. If so, it lets the user in. If not, it does not.\nAuthentication also lies at the heart of an application’s protection against\nmalicious attack. It is the front line of defense against unauthorized access, and\nif an attacker can defeat those defenses, they will often gain full control of the\napplication’s functionality, and unrestricted access to the data held within it.\nWithout robust authentication to rely upon, none of the other core security\nmechanisms (such as session management and access control) can be effective.\nIn fact, despite its apparent simplicity, devising a secure authentication\nfunction is an extremely subtle business, and in real-world web applications\nauthentication is very often the weakest link, which enables an attacker to gain\nunauthorized access. The authors have lost count of the number of applica-\ntions that we have fundamentally compromised as a result of various defects\nin authentication logic.\nThis chapter will look in detail at the wide variety of design and implemen-\ntation flaws that commonly afflict web applications. These typically arise\nbecause the application designers and developers fail to ask a simple question:\nWhat could an attacker achieve if he were to target our authentication mecha-\nnism? In the majority of cases, as soon as this question is asked in earnest of a\n133\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 134\n134 Chapter 6 ■ Attacking Authentication\nparticular application, a number of potential vulnerabilities materialize, any\none of which may be sufficient to break the application.\nMany of the most common authentication vulnerabilities are literally no-\nbrainers. Anyone can type dictionary words into a login form in an attempt to\nguess valid passwords. In other cases, subtle defects may lurk deep within the\napplication’s processing, which can only be uncovered and exploited after\npainstaking analysis of a complex multistage login mechanism. We will\ndescribe the full spectrum of these attacks, including techniques which have\nsucceeded in breaking the authentication of some of the most security-critical\nand robustly defended web applications on the planet.\nAuthentication Technologies\nThere is a wide range of different technologies available to web application\ndevelopers when implementing authentication mechanisms:\n■■ HTML forms-based authentication.\n■■ Multi-factor mechanisms, such as those combining passwords and\nphysical tokens.\n■■ Client SSL certificates and/or smartcards.\n■■ HTTP basic and digest authentication.\n■■ Windows-integrated authentication using NTLM or Kerberos.\n■■ Authentication services.\nBy far the most common authentication mechanism employed by web\napplications uses HTML forms to capture a username and password and sub-\nmit these to the application. This mechanism accounts for well over 90% of\napplications you are likely to encounter on the Internet.\nIn more security-critical Internet applications, such as online banking, this\nbasic mechanism is often expanded into multiple stages, requiring the user to\nsubmit additional credentials, such as PIN numbers or selected characters from\na secret word. HTML forms are still typically used to capture relevant data.\nIn the most security-critical applications, such as private banking for high-\nworth individuals, it is common to encounter multi-factor mechanisms using\nphysical tokens. These tokens typically produce a stream of one-time pass-\ncodes, or perform a challenge-response function based on input specified by\nthe application. As the cost of this technology falls over time, it is likely that\nmore applications will employ this kind of mechanism. However, many of\nthese solutions do not actually address the threats for which they were\ndevised—primarily phishing attacks and those employing client-side Trojans.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 135\nChapter 6 ■ Attacking Authentication 135\nSome web applications employ client-side SSL certificates or cryptographic\nmechanisms implemented within smartcards. Because of the overhead of\nadministering and distributing these items, they are typically used only in\nsecurity-critical contexts where an application’s user base is small.\nThe HTTP-based authentication mechanisms (basic, digest, and Windows-\nintegrated) are rarely used on the Internet, and are much more commonly\nencountered in intranet environments where an organization’s internal users\ngain access to corporate applications by supplying their normal network or\ndomain credentials, which are processed by the application via one of these\ntechnologies.\nThird-party authentication services such as Microsoft Passport are occasion-\nally encountered, but at the present time have not been adopted on any signif-\nicant scale.\nMost of the vulnerabilities and attacks that arise in relation to authentication\ncan be applied to any of the technologies mentioned. Because of its over-\nwhelming dominance, we will describe each specific vulnerability and attack\nin the context of HTML forms-based authentication, and where relevant will\npoint towards any specific differences and attack methodologies that are rele-\nvant to the other available technologies.\nDesign Flaws in Authentication Mechanisms\nAuthentication functionality is subject to more design weaknesses than any\nother security mechanism commonly employed in web applications. Even in\nthe apparently simple, standard model where an application authenticates\nusers based on their username and password, shortcomings in the design of\nthis model can leave the application highly vulnerable to unauthorized access.\nBad Passwords\nMany web applications employ no or minimal controls over the quality of\nusers’ passwords. It is common to encounter applications that allow pass-\nwords that are:\n■■ Very short or blank\n■■ Common dictionary words or names\n■■ Set to the same as the username\n■■ Still set to a default value\nFigure 6-1 shows an example of weak password quality rules. End users\ntypically display little awareness of security issues. Hence, it is highly likely\nthat an application that does not enforce strong password standards will con-\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 136\n136 Chapter 6 ■ Attacking Authentication\ntain a large number of user accounts with weak passwords set. These pass-\nwords can be easily guessed by an attacker, granting them unauthorized\naccess to the application.\nFigure 6-1: An application that enforces weak password quality rules\nHACK STEPS\nAttempt to discover any rules regarding password quality:\n■ Review the web site for any description of the rules.\n■ If self-registration is possible, attempt to register several accounts with\ndifferent kinds of weak passwords to discover what rules are in place.\n■ If you control a single account and password change is possible, attempt\nto change your password to various weak values.\nNOTE If password quality rules are enforced only through client-side controls,\nthis is not itself a security issue because ordinary users will still be protected. It\nis not normally a threat to an application’s security that a crafty attacker can\nassign themselves a weak password.\nBrute-Forcible Login\nLogin functionality presents an open invitation for an attacker to try and guess\nusernames and passwords, and so gain unauthorized access to the application.\nIf the application allows an attacker to make repeated login attempts with dif-\nferent passwords until the correct one is guessed, then it is highly vulnerable\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 137\nChapter 6 ■ Attacking Authentication 137\neven to an amateur attacker who manually enters some common usernames\nand passwords into their browser. Values frequently encountered even in pro-\nduction systems include:\n■■ test\n■■ testuser\n■■ admin\n■■ administrator\n■■ demo\n■■ demouser\n■■ password\n■■ password1\n■■ password123\n■■ qwerty\n■■ test123\n■■ letmein\n■■ [organization’s name]\nIn this situation, any serious attacker will use automated techniques to\nattempt to guess passwords, based on lengthy lists of common values. Given\ntoday’s bandwidth and processing capabilities, it is possible to make thou-\nsands of login attempts per minute from a standard PC and DSL connection.\nEven the most robust passwords will be eventually broken in this scenario.\nVarious techniques and tools for using automation in this way are described\nin detail in Chapter 13. Figure6-2 demonstrates a successful password guess-\ning attack against a single account using Burp Intruder. The successful login\nattempt can be clearly distinguished by the difference in the HTTP response\ncode, the response length, and the absence of the “login incorrect” message.\nNOTE In some applications, client-side controls are employed in an attempt\nto prevent password-guessing attacks. For example, an application may set a\ncookie such as failedlogins=1, and increment this following each\nunsuccessful attempt. When a certain threshold is reached, the server will\ndetect this in the submitted cookie and refuse to process the login attempt.\nThis kind of client-side defense may prevent a manual attack being launched\nusing only a browser, but it can of course be trivially bypassed as described in\nChapter 5.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 138\n138 Chapter 6 ■ Attacking Authentication\nFigure 6-2: A successful password-guessing attack\nHACK STEPS\n■ Manually submit several bad login attempts for an account you control,\nmonitoring the error messages received.\n■ After around 10 failed logins, if the application has not returned any\nmessage about account lockout, attempt to login correctly. If this suc-\nceeds, there is probably no account lockout policy.\n■ If you do not control any accounts, attempt to enumerate a valid username\n(see the “Verbose Failure Messages” section) and make several bad logins\nusing this, monitoring for any error messages about account lockout.\n■ To mount a brute-force attack, first identify a difference in the application’s\nbehavior in response to successful and failed logins, which can be used to\ndiscriminate between these during the course of the automated attack.\n■ Obtain a list of enumerated or common usernames and a list of common\npasswords. Use any information obtained about password quality rules\nto tailor the password list so as to avoid superfluous test cases.\n■ Use a suitable tool or a custom script to quickly generate login requests\nusing all permutations of these usernames and passwords. Monitor the\nserver’s responses to identify login attempts that are successful. Chapter\n13 describes in detail various techniques and tools for performing cus-\ntomised attacks using automation.\n■ If you are targeting several usernames at once, it is usually preferable to\nperform this kind of brute-force attack in a breadth-first rather than a\ndepth-first manner. This involves iterating through a list of passwords\n(starting with the most common) and attempting each password in turn\non every username. This approach has two benefits: first, you will dis-\ncover accounts with common passwords more quickly, and second, you\nare less likely to trigger any account lockout defenses, because there is a\ntime delay between successive attempts using each individual account.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 139\nChapter 6 ■ Attacking Authentication 139\nVerbose Failure Messages\nA typical login form requires the user to enter two pieces of information (user-\nname and password), and some applications require several more (for exam-\nple, date of birth, a memorable place, or a PIN number).\nWhen a login attempt fails, you can of course infer that at least one piece of\ninformation was incorrect. However, if the application informs you as to\nwhich piece of information was invalid, you can exploit this behavior to con-\nsiderably diminish the effectiveness of the login mechanism.\nIn the simplest case, where a login requires a username and password, an\napplication might respond to a failed login attempt by indicating whether the\nreason for the failure was an unrecognized username or the wrong password,\nas illustrated in Figure6-3.\nFigure 6-3: Verbose login failure messages indicating when a valid username has been\nguessed\nIn this instance, you can use an automated attack to iterate through a large\nlist of common usernames to enumerate which of these are valid. Of course,\nusernames are not normally considered a secret (they are not masked during\nlogin, for instance). However, providing an easy means for an attacker to iden-\ntify valid usernames increases the likelihood that they will compromise the\napplication with a given level of time, skill, and effort. A list of enumerated\nusernames can be used as the basis for various subsequent attacks, including\npassword guessing, attacks on user data or sessions, or social engineering.\nNOTE Many authentication mechanisms disclose usernames either implicitly\nor explicitly. In a web mail account, the username is often the email address,\nwhich is common knowledge by design. Many other sites expose usernames\nwithin the application without considering the advantage this grants to an\nattacker, or allow usernames to be easily guessed (for example, user1842).\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 140\n140 Chapter 6 ■ Attacking Authentication\nIn more complex login mechanisms, where an application requires the user\nto submit several pieces of information, or proceed through several stages,\nverbose failure messages or other discriminators can enable an attacker to tar-\nget each stage of the login process in turn, increasing the likelihood that they\nwill gain unauthorized access.\nNOTE This vulnerability may arise in more subtle ways than illustrated\nhere. Even if the error messages returned in response to a valid and invalid\nusername are superficially similar, there may be small differences between\nthem that can be used to enumerate valid usernames. For example, if multiple\ncode paths within the application return the “same” failure message, there may\nbe minor typographical differences between each instance of the message. In\nsome cases, the application’s responses may be identical on-screen but contain\nsubtle differences hidden within the HTML source, such as comments or layout\ndifferences. If no obvious means of enumerating usernames presents itself, you\nshould perform a very close comparison of the application’s responses to valid\nand invalid usernames.\nHACK STEPS\n■ If you already know one valid username (for example, an account you\ncontrol), submit one login using this username and an incorrect pass-\nword, and another login using a completely random username.\n■ Record every detail of the server’s responses to each login attempt,\nincluding the status code, any redirects, information displayed on screen,\nand any differences hidden away in the HTML page source. Use your\nintercepting proxy to maintain a full history of all traffic to and from the\nserver.\n■ Attempt to discover any obvious or subtle differences in the server’s\nresponses to the two login attempts.\n■ If this fails, repeat the exercise everywhere within the application where\na username can be submitted (for example, self-registration, password\nchange, and forgotten password).\n■ If a difference is detected in the server’s responses to valid and invalid\nusernames, obtain a list of common usernames and use a custom script\nor automated tool to quickly submit each username and filter the\nresponses that signify that the username is valid (see Chapter 13).\n(continued)\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 141\nChapter 6 ■ Attacking Authentication 141\nHACK STEPS (continued)\n■ Before commencing your enumeration exercise, verify whether the appli-\ncation performs any account lockout after a certain number of failed\nlogin attempts (see the “Brute-Forcible Login” section). If so, it is desir-\nable to design your enumeration attack with this fact in mind. For exam-\nple, if the application will grant you only three failed login attempts with\nany given account, you run the risk of “wasting” one of these for every\nusername that you discover through automated enumeration. Therefore,\nwhen performing your enumeration attack, do not submit a completely\nfar-fetched password with each login attempt, but rather submit either\n(a) a single common password such as “password1” or (b) the username\nitself as the password. If password quality rules are weak, it is highly\nlikely that some of the attempted logins that you perform as part of your\nenumeration exercise will actually be successful and disclose both the\nusername and password in one single hit. To implement option (b) and\nset the password field to the same as the username, you can use the\n“battering ram” attack mode in Burp Intruder to insert the same payload\nat multiple positions in your login request.\nEven if an application’s responses to login attempts containing valid and\ninvalid usernames are identical in every intrinsic respect, it may yet be possi-\nble to enumerate usernames based on the time taken for the application to\nrespond to the login request. Applications often perform very different back-\nend processing on a login request, depending on whether it contains a valid\nusername. For example, when a valid username is submitted, the application\nmay retrieve user details from a back-end database, perform various process-\ning on these details (for example, checking whether the account is expired),\nand then validate the password (which may involve a resource-intensive hash\nalgorithm), before returning a generic message if the password is incorrect.\nThe timing difference between the two responses may be too subtle to detect\nwhen working with only a browser, but an automated tool may be able to dis-\ncriminate between them. Even if the results of such an exercise contain a large\nratio of false positives, it is still better to have a list of 100 usernames approxi-\nmately 50% of which are valid than a list of 10,000 usernames approximately\n0.5% of which are valid. See Chapter 14 for a detailed methodology for how to\ndetect and exploit this type of timing difference to extract information from the\napplication.\nTIP In addition to the login functionality itself, there may be other sources of\ninformation where you can obtain valid usernames. Review all of the source code\ncomments discovered during application mapping (see Chapter 4) to identify any\napparent usernames. Any email addresses of developers or other personnel\nwithin the organization may be valid usernames, either in full or just the user-\nspecific prefix. Any accessible logging functionality may disclose usernames.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 142\n142 Chapter 6 ■ Attacking Authentication\nVulnerable Transmission of Credentials\nIf an application uses an unencrypted HTTP connection to transmit login cre-\ndentials, an eavesdropper who is suitably positioned on the network will of\ncourse be able to intercept them. Depending on the user’s location, potential\neavesdroppers may reside:\n■■ On the user’s local network\n■■ Within the user’s IT department\n■■ Within the user’s ISP\n■■ On the Internet backbone\n■■ Within the ISP hosting the application\n■■ Within the IT department managing the application\nNOTE Any of these locations may be occupied by authorized personnel but\nalso potentially by an external attacker who has compromised the relevant\ninfrastructure through some other means. Even if the intermediaries on a\nparticular network are believed to be trusted, it is safer to use secure transport\nmechanisms when passing sensitive data over it.\nEven if login occurs over HTTPS, credentials may still be disclosed to unau-\nthorized parties if the application handles them in an unsafe manner:\n■■ If credentials are transmitted as query string parameters, as opposed to\nin the body of a POSTrequest, then these are liable to be logged in vari-\nous places—for example, within the user’s browser history, within the\nweb server logs, and within the logs of any reverse proxies employed\nwithin the hosting infrastructure. If an attacker succeeds in compromis-\ning any of these resources, then he may be able to escalate privileges by\ncapturing the user credentials stored there.\n■■ Although most web applications do use the body of a POSTrequest to\nsubmit the HTML login form itself, it is surprisingly common to see the\nlogin request being handled via a redirect to a different URL with the\nsame credentials passed as query string parameters. Why application\ndevelopers consider it necessary to perform these bounces is not clear,\nbut having elected to do so, it is easier to implement them as 302 redi-\nrects to a URL than as POSTrequests using a second HTML form sub-\nmitted via JavaScript.\n■■ Web applications sometimes store user credentials in cookies, usually to\nimplement poorly designed mechanisms for login, password change,\n“remember me,” and so on. These credentials are vulnerable to capture\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 143\nChapter 6 ■ Attacking Authentication 143\nvia attacks that compromise user cookies, and in the case of persistent\ncookies, by anyone who gains access to the client’s local file system.\nEven if the credentials are encrypted, an attacker can still simply replay\nthe cookie and so log in as a user without actually knowing her creden-\ntials. Chapter 12 describes various ways in which an attacker can target\nother users to capture their cookies.\nMany applications use HTTP for unauthenticated areas of the application\nand switch to HTTPS at the point of login. If this is the case, then the correct\nplace to switch to HTTPS is when the login page is loaded in the browser,\nenabling a user to verify that the page is authentic before entering credentials.\nHowever, it is common to encounter applications that load the login page itself\nusing HTTP, and switch to HTTPS at the point where credentials are submit-\nted. This is unsafe, because a user cannot verify the authenticity of the login\npage itself and so has no assurance that the credentials will be submitted\nsecurely. A suitably positioned attacker can intercept and modify the login\npage, changing the target URL of the login form to use HTTP. By the time an\nastute user realizes that the credentials have been submitted using HTTP, they\nwill have been compromised.\nHACK STEPS\n■■ Carry out a successful login while monitoring all traffic in both directions\nbetween the client and server.\n■■ Identify every case in which the credentials are transmitted in either\ndirection. You can set interception rules in your intercepting proxy to flag\nmessages containing specific strings (see Chapter 19).\n■■ If any instances are found in which credentials are submitted in a URL\nquery string, or as a cookie, or are transmitted back from the server to\nthe client, understand what is happening and try to ascertain what pur-\npose the application developers were attempting to achieve. Try to find\nevery means by which an attacker might interfere with the application’s\nlogic to compromise other users’ credentials.\n■■ If any sensitive information is transmitted over an unencrypted channel,\nthis is, of course, vulnerable to interception.\n■■ If no cases of actual credentials being transmitted insecurely are identi-\nfied, pay close attention to any data that appears to be encoded or\nobfuscated. If this includes sensitive data, it may be possible to reverse\nengineer the obfuscation algorithm.\n■■ If credentials are submitted using HTTPS but the login form is loaded\nusing HTTP, then the application is vulnerable to a man-in-the-middle\nattack, which may be used to capture credentials.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 144\n144 Chapter 6 ■ Attacking Authentication\nPassword Change Functionality\nSurprisingly, many web applications do not provide any way for users to\nchange their password. However, this functionality is necessary for a well-\ndesigned authentication mechanism for two reasons:\n■■ Periodic enforced password change mitigates the threat of password\ncompromise by reducing the window in which a given password can be\ntargeted in a guessing attack and by reducing the window in which a\ncompromised password can be used without detection by the attacker.\n■■ Users who suspect that their passwords may have been compromised\nneed to be able to quickly change their password to reduce the threat of\nunauthorized use.\nAlthough it is a necessary part of an effective authentication mechanism,\npassword change functionality is often vulnerable by design. It is frequently\nthe case that vulnerabilities that are deliberately avoided in the main login\nfunction reappear in the password change function. There are many web\napplications whose password change functions are accessible without authen-\ntication and that:\n■■ Provide a verbose error message indicating whether the requested user-\nname is valid.\n■■ Allow unrestricted guesses of the “existing password” field.\n■■ Only check whether the “new password” and “confirm new password”\nfields have the same value after validating the existing password,\nthereby allowing an attack to succeed in discovering the existing pass-\nword noninvasively.\nHACK STEPS\n■ Identify any password change functionality within the application. If this\nis not explicitly linked from published content, it may still be imple-\nmented. Chapter 4 describes various techniques for discovering hidden\ncontent within an application.\n■ Make various requests to the password change function, using invalid\nusernames, invalid existing passwords, and mismatched “new password”\nand “confirm new password” values.\n■ Try to identify any behavior that can be used for username enumeration\nor brute-force attacks (as described in the “Brute-Forcible Login” and\n“Verbose Failure Messages” sections).\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 145\nChapter 6 ■ Attacking Authentication 145\nTIP If the password change form is only accessible by authenticated users\nand does not contain a username field, it may still be possible to supply an\narbitrary username. The form may store the username in a hidden field, which\ncan easily be modified. If not, try supplying an additional parameter containing\nthe username, using the same parameter name as is used in the main login\nform. This trick sometimes succeeds in overriding the username of the current\nuser, enabling you to brute force the credentials of other users even when this\nis not possible at the main login.\nForgotten Password Functionality\nLike password change functionality, mechanisms for recovering from a forgot-\nten password situation often introduce problems that may have been avoided\nin the main login function, such as username enumeration.\nIn addition to this range of defects, design weaknesses in forgotten pass-\nword functions frequently make this the weakest link at which to attack the\napplication’s overall authentication logic. Several kinds of design weaknesses\ncan often be found:\n■■ The forgotten password functionality often involves presenting the user\nwith a secondary challenge in place of the main login, as shown in Fig-\nure6-4. This challenge is often much easier for an attacker to respond to\nthan attempting to guess the user’s password. Questions about moth-\ners’ maiden names, memorable dates, favorite colors, and the like will\ngenerally have a much smaller set of potential answers than the set of\npossible passwords. Further, they often concern information that is\npublicly known or that a determined attacker can discover with a\nmodest degree of effort.\nFigure 6-4: A secondary challenge used in an account\nrecovery function\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 146\n146 Chapter 6 ■ Attacking Authentication\nIn many cases, the application allows users to set their own password\nrecovery challenge and response during registration, and users are\ninclined to set extremely insecure challenges, presumably on the false\nassumption that only they will ever be presented with them, for example:\n“Do I own a boat?” In this situation, an attacker wishing to gain access\ncan use an automated attack to iterate through a list of enumerated or\ncommon usernames, log all of the password recovery challenges, and\nselect those that appear most easily guessable. (See Chapter 13 for tech-\nniques regarding how to grab this kind of data in a scripted attack.)\n■■ As with password change functionality, application developers com-\nmonly overlook the possibility of brute forcing the response to a pass-\nword recovery challenge, even when they block this attack on the main\nlogin page. If an application allows unrestricted attempts to answer\npassword recovery challenges, then it is highly likely to be compro-\nmised by a determined attacker.\n■■ In some applications, the recovery challenge is replaced with a simple\npassword “hint” that is configurable by users during registration. Users\ncommonly set extremely obvious hints, even one that is identical to the\npassword itself, on the false assumption that only they will ever see them.\nAgain, an attacker with a list of common or enumerated usernames can\neasily capture a large number of password hints and then start guessing.\n■■ The mechanism by which an application enables users to regain control\nof their account after correctly responding to a challenge is often vul-\nnerable. One reasonably secure means of implementing this is to send a\nunique, unguessable, time-limited recovery URL to the email address\nthat the user provided during registration. Visiting this URL within a\nfew minutes enables the user to set a new password. However, other\nmechanisms for account recovery are often encountered that are inse-\ncure by design:\n■■ Some applications disclose the existing, forgotten password to the\nuser after successful completion of a challenge, enabling an attacker\nto use the account indefinitely without any risk of detection by the\nowner. Even if the account owner subsequently changes the blown\npassword, the attacker can simply repeat the same challenge to\nobtain the new password.\n■■ Some applications immediately drop the user into an authenticated\nsession after successful completion of a challenge, again enabling an\nattacker to use the account indefinitely without detection, and with-\nout ever needing to know the user’s password.\n■■ Some applications employ the mechanism of sending a unique\nrecovery URL but send this to an email address specified by the user\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 147\nChapter 6 ■ Attacking Authentication 147\nat the time the challenge is completed. This provides absolutely no\nenhanced security of the recovery process beyond possibly logging\nthe email address used by an attacker.\nTIP Even if the application does not provide an on-screen field for you to\nprovide an email address to receive the recovery URL, the application may\ntransmit the address via a hidden form field or cookie. This presents a double\nopportunity: you can discover the email address of the user you have\ncompromised, and you can modify its value to receive the recovery URL at an\naddress of your choosing.\n■■ Some applications allow users to reset their password’s value directly\nafter successful completion of a challenge and do not send any email\nnotification to the user. This means that the compromising of an\naccount by an attacker will not be noticed until the owner happens to\nattempt to log in again, and may even remain unnoticed if the owner\nassumes that they must have forgotten their own password and so\nresets it in the same way. An attacker who simply desires someaccess\nto the application can then compromise a different user’s account for\na period and so continue using the application indefinitely.\nHACK STEPS\n■ Identify any forgotten password functionality within the application. If\nthis is not explicitly linked from published content, it may still be imple-\nmented (see Chapter 4).\n■ Understand how the forgotten password function works by doing a com-\nplete walk-through using an account you control.\n■ If the mechanism uses a challenge, determine whether users are able to\nset or select their own challenge and response. If so, use a list of enu-\nmerated or common usernames to harvest a list of challenges, and\nreview this for any that appear easily guessable.\n■ If the mechanism uses a password “hint,” do the same exercise to har-\nvest a list of password hints, and target any that are easily guessable.\n■ Try to identify any behavior in the forgotten password mechanism that\ncan be exploited as the basis for username enumeration or brute-force\nattacks (see the previous details).\n■ If the application generates an email containing a recovery URL in\nresponse to a forgotten password request, obtain a number of these\nURLs, and attempt to identify any patterns that may enable you to predict\nthe URLs issued to other users. Employ the same techniques as are rele-\nvant to analyzing session tokens for predictability (see Chapter 7).\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 148\n148 Chapter 6 ■ Attacking Authentication\n“Remember Me” Functionality\nApplications often implement “remember me” functions as a convenience to\nusers, to prevent them needing to reenter their username and password each\ntime they use the application from a specific computer. These functions are\noften insecure by design and leave the user exposed to attack both locally and\nby users on othercomputers:\n■■ Some “remember me” functions are implemented using a simple per-\nsistent cookie, such as RememberUser=peterwiener(see Figure6-5).\nWhen this cookie is submitted to the initial application page, the appli-\ncation trusts the cookie to authenticate the user, and creates an applica-\ntion session for that person, bypassing the login. An attacker can use a\nlist of common or enumerated usernames to gain full access to the\napplication without any authentication.\nFigure 6-5: A vulnerable “remember me” function\n■■ Some “remember me” functions set a cookie which does not contain\nthe username but rather a kind of persistent session identifier—for\nexample, RememberUser=1328. When the identifier is submitted to the\nlogin page, the application looks up the user associated with it and\ncreates an application session for that user. As with ordinary session\ntokens, if the session identifiers of other users can be predicted or\nextrapolated, an attacker can iterate through a large number of poten-\ntial identifiers to find those associated with application users, and so\ngain access to their accounts without authentication. See Chapter 7 for\ntechniques for performing this attack.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 149\nChapter 6 ■ Attacking Authentication 149\n■■ Even if the information stored in a cookie for re-identifying users is\nsuitably protected (e.g., encrypted) to prevent other users from deter-\nmining or guessing it, the information may still be vulnerable to cap-\nture through a bug such as cross-site scripting (see Chapter 12).\nHACK STEPS\n■ Activate any “remember me” functionality, and determine whether the\nfunctionality indeed does fully “remember” the user or whether it only\nremembers their username and still requires them to enter a password\non subsequent visits. If the latter is the case, the functionality is much\nless likely to expose any security flaw.\n■ Closely inspect all persistent cookies that are set. Look for any saved\ndata that identifies the user explicitly or appears to contain some pre-\ndictable identifier of the user.\n■ Even where data stored appears to be heavily encoded or obfuscated,\nreview this closely and compare the results of “remembering” several\nvery similar usernames and/or passwords to identify any opportunities\nfor reverse engineering the original data. Here, use the same techniques\nthat are described in Chapter 7 for detecting meaning and patterns in\nsession tokens.\n■ Attempt to modify the contents of the persistent cookie to try and con-\nvince the application that another user has saved his details on your\ncomputer.\nUser Impersonation Functionality\nSome applications implement the facility for a privileged user of the applica-\ntion to impersonate other users, in order to access data and carry out actions\nwithin their user context. For example, some banking applications allow\nhelpdesk operators to verbally authenticate a telephone user and then switch\ntheir application session into that user’s context in order to assist them.\nVarious design flaws commonly exist within impersonation functionality:\n■■ It may be implemented as a “hidden” function, which is not subject to\nproper access controls. For example, anyone who knows or guesses the\nURL /admin/ImpersonateUser.jspmay be able to make use of the\nfunction and impersonate any other user (see Chapter 8).\n■■ The application may trust user-controllable data when determining\nwhether the user is performing impersonation. For example, in addition\nto a valid session token, a user may also submit a cookie specifying\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 150\n150 Chapter 6 ■ Attacking Authentication\nwhich account their session is currently using. An attacker may be able\nto modify this value and gain access to other user accounts without\nauthentication, as shown in Figure6-6.\nFigure 6-6: A vulnerable user impersonation function\n■■ If an application allows administrative users to be impersonated, then\nany weakness in the impersonation logic may result in a vertical privi-\nlege escalation vulnerability—rather than simply gaining access to\nother ordinary users’ data, an attacker may gain full control of the\napplication.\n■■ Some impersonation functionality is implemented as a simple “back-\ndoor” password that can be submitted to the standard login page along\nwith any username in order to authenticate as that user. This design is\nhighly insecure for many reasons, but the biggest opportunity for\nattackers is that they are likely to discover this password when per-\nforming standard attacks such as brute forcing of the login. If the back-\ndoor password is matched before the user’s actual password, then the\nattacker is likely to discover the function of the backdoor password and\nso gain access to every user’s account. Similarly, a brute-force attack\nmight result in two different “hits,” thereby revealing the backdoor\npassword as shown in Figure6-7.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 151\nChapter 6 ■ Attacking Authentication 151\nFigure 6-7: A password-guessing attack with two “hits,”\nindicating the presence of a backdoor password\nHACK STEPS\n■ Identify any impersonation functionality within the application. If this is\nnot explicitly linked from published content, it may still be implemented\n(see Chapter 4).\n■ Attempt to use the impersonation functionality directly to impersonate\nother users.\n■ Attempt to manipulate any user-supplied data that is processed by the\nimpersonation function in an attempt to impersonate other users. Pay\nparticular attention to any cases where your username is being submit-\nted other than during normal login.\n■ If you succeed in making use of the functionality, attempt to impersonate\nany known or guessed administrative users, in order to elevate privileges.\n■ When carrying out password guessing attacks (see the “Brute-Forcible\nLogin” section), review whether any users appear to have more than one\nvalid password, or whether a specific password has been matched\nagainst several usernames. Also, log in as many different users with the\ncredentials captured in a brute-force attack, and review whether every-\nthing appears normal. Pay close attention to any “logged in as X” status\nmessage.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 152\n152 Chapter 6 ■ Attacking Authentication\nIncomplete Validation of Credentials\nWell-designed authentication mechanisms enforce various requirements on\npasswords, such as a minimum length or the presence of both uppercase and\nlowercase characters. Correspondingly, some poorly designed authentication\nmechanisms not only do not enforce these good practices but also do not take\naccount of users’ own attempts to comply with them.\nFor example, some applications truncate passwords and so only validate the\nfirst ncharacters. Some applications perform a case-insensitive check of pass-\nwords. Some applications strip out unusual characters (sometimes on the pre-\ntext of performing input validation) before checking passwords.\nEach of these limitations on password validation reduces by an order of\nmagnitude the number of variations available in the set of possible passwords.\nThrough experimentation, you can determine whether a password is being\nfully validated, or whether any limitations are in effect. You can then fine-tune\nyour automated attacks against the login to remove unnecessary test cases,\nthereby massively reducing the number of requests necessary to compromise\nuser accounts.\nHACK STEPS\n■ Using an account you control, attempt to log in with variations on your\nown password: removing the last character, changing the case of a char-\nacter, and removing any special typographical characters. If any of these\nattempts is successful, continue experimenting to try and understand\nwhat validation is actually occurring.\n■ Feed any results back into your automated password guessing attacks, to\nremove superfluous test cases and improve the chances of success.\nNon-Unique Usernames\nSome applications that support self-registration allow users to specify their\nown username, and do not enforce a requirement that usernames be unique.\nAlthough rare, the authors have encountered more than one application with\nthis behavior.\nThis represents a design flaw for two reasons:\n■■ One user who shares a username with another user may also happen to\nselect the same password as that user, either during registration or in a\nsubsequent password change. In this eventuality, the application will\neither reject the second user’s chosen password or will allow two\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 153\nChapter 6 ■ Attacking Authentication 153\naccounts to have identical credentials. In the first instance, the applica-\ntion’s behavior will effectively disclose to one user the credentials of a\ndifferent user. In the second instance, subsequent logins by one of the\nusers will result in access to the other user’s account.\n■■ An attacker may exploit this behavior to carry out a successful brute-\nforce attack, even though this may not be possible elsewhere due to\nrestrictions on failed login attempts. An attacker can register a specific\nusername multiple times with different passwords, while monitoring\nfor the differential response that indicates that an account with that\nusername and password already existed. The attacker will have ascer-\ntained a target user’s password without making a single attempt to log\nin as that user.\nBadly designed self-registration functionality can also provide a means for\nusername enumeration. If an application disallows duplicate usernames, then\nan attacker may attempt to register large numbers of common usernames to\nidentify the existing usernames that are rejected.\nHACK STEPS\n■ If self-registration is possible, attempt to register the same username\ntwice with different passwords.\n■ If the application blocks the second registration attempt, you can exploit\nthis behavior to enumerate existing usernames even if this is not possi-\nble on the main login page or elsewhere. Make multiple registration\nattempts with a list of common usernames to identify the already regis-\ntered names that the application blocks.\n■ If the registration of duplicate usernames succeeds, attempt to register\nthe same username twice with the same password, and determine the\napplication’s behavior:\n■ If an error message results, you can exploit this behavior to carry out a\nbrute-force attack, even if this is not possible on the main login page.\nTarget an enumerated or guessed username, and attempt to register\nthis username multiple times with a list of common passwords. When\nthe application rejects one specific password, you have probably\nfound the existing password for the targeted account.\n■ If no error message results, log in using the credentials you specified\nand see what happens. You may need to register several users, and\nmodify different data held within each account, to understand\nwhether this behavior can be used to gain unauthorized access to\nother users’ accounts.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 154\n154 Chapter 6 ■ Attacking Authentication\nPredictable Usernames\nSome applications automatically generate account usernames according to\nsome predictable sequence (for example, cust5331, cust5332, etc.). When an\napplication behaves like this, an attacker who can discern the sequence can\nvery quickly arrive at a potentially exhaustive list of all valid usernames,\nwhich can be used as the basis for further attacks. Unlike enumeration meth-\nods that rely on making repeated requests driven by wordlists, this means of\ndetermining usernames can be carried out very non-intrusively with minimal\ninteraction with the application.\nHACK STEPS\n■ If usernames are generated by the application, try to obtain several user-\nnames in quick succession and determine whether any sequence or pat-\ntern can be discerned.\n■ If so, extrapolate backwards to obtain a list of possible valid usernames.\nThis can be used as the basis for a brute-force attack against the login\nand other attacks where valid usernames are required, such as the\nexploitation of access control flaws (see Chapter 8).\nPredictable Initial Passwords\nIn some applications, users are created all at once or in sizeable batches and are\nautomatically assigned initial passwords, which are then distributed to them\nthrough some means. The means of generating passwords may enable an\nattacker to predict the passwords of other application users. This kind of vul-\nnerability is more common on intranet-based corporate applications—for\nexample, where every employee has an account created on their behalf, and\nreceives a printed notification of their password.\nIn the most vulnerable cases, all users receive the same password, or one\nclosely derived from their username or job function. In other cases, generated\npasswords may contain sequences that could be identified or guessed with\naccess to a very small sample of initial passwords.\nHACK STEPS\n■ If passwords are generated by the application, try to obtain several pass-\nwords in quick succession and determine whether any sequence or pat-\ntern can be discerned.\n■ If so, extrapolate the pattern to obtain a list of passwords for other appli-\ncation users.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 155\nChapter 6 ■ Attacking Authentication 155\nHACK STEPS (continued)\n■ If passwords demonstrate a pattern that can be correlated with user-\nnames, you can try to log in using known or guessed usernames and the\ncorresponding inferred passwords.\n■ Otherwise, you can use the list of inferred passwords as the basis for a\nbrute-force attack with a list of enumerated or common usernames.\nInsecure Distribution of Credentials\nMany applications employ a process in which credentials for newly created\naccounts are distributed to users out-of-band of their normal interaction with\nthe application (for example, via post or email). Sometimes, this is done for rea-\nsons motivated by security concerns—for example, to provide assurance that\nthe postal or email address supplied by the user actually belongs to that person.\nIn some cases, this process can present a security risk. For example, if the\nmessage distributed contains both username and password, there is no time\nlimit on their use, and there is no requirement for the user to change password\non first login, then it is highly likely that a large number, even a majority, of\napplication users will not modify their initial credentials and that the distribu-\ntion messages will remain in existence for a lengthy period during which they\nmay be accessed by an unauthorized party.\nSometimes, what is distributed is not the credentials themselves, but rather\nan “account activation” URL, which enables users to set their own initial pass-\nword. If the series of these URLs sent to successive users manifests any kind of\nsequence, then an attacker can identify this by registering multiple users in\nclose succession, and then infer the activation URLs sent to recent and forth-\ncoming users.\nHACK STEPS\n■ Obtain a new account. If you are not required to set all credentials during\nregistration, determine the means by which the application distributes\ncredentials to new users.\n■ If an account activation URL is used, try to register several new accounts\nin close succession and identify any sequence in the URLs you receive. If\na pattern can be determined, try to predict the activation URLs sent to\nrecent and forthcoming users, and attempt to use these URLs to take\nownership of their accounts.\n■ Try to reuse a single reactivation URL multiple times, and see if the appli-\ncation allows this. If not, try locking out the target account before reusing\nthe URL, and see if it now works.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 156\n156 Chapter 6 ■ Attacking Authentication\nImplementation Flaws in Authentication\nEven a well-designed authentication mechanism may be highly insecure due\nto mistakes made in its implementation. These mistakes may lead to informa-\ntion leakage, complete login bypassing, or a weakening of the overall security\nof the mechanism as designed. Implementation flaws tend to be more subtle\nand harder to detect than design defects such as poor quality passwords and\nbrute forcibility. For this reason, they are often a fruitful target for attacks\nagainst the most security-critical applications, where numerous threat models\nand penetration tests are likely to have claimed any low-hanging fruit. The\nauthors have identified each of the implementation flaws described here\nwithin the web applications deployed by large banks.\nFail-Open Login Mechanisms\nFail-open logic is a species of logic flaw (described in detail in Chapter 11) and\none that has particularly serious consequences in the context of authentication\nmechanisms.\nThe following is a fairly contrived example of a login mechanism that fails\nopen. If the call to db.getUser() throws an exception for some reason (for\nexample, a null pointer exception arising because the user’s request did not\ncontain a username or password parameter), then the login will be successful.\nAlthough the resulting session may not be bound to a particular user identity,\nand so may not be fully functional, this may still enable an attacker to access\nsome sensitive data or functionality.\npublic Response checkLogin(Session session) {\ntry {\nString uname = session.getParameter(“username”);\nString passwd = session.getParameter(“password”);\nUser user = db.getUser(uname, passwd);\nif (user == null) {\n// invalid credentials\nsession.setMessage(“Login failed.”);\nreturn doLogin(session);\n}\n}\ncatch (Exception e) {}\n// valid user\nsession.setMessage(“Login successful.”);\nreturn doMainMenu(session);\n}\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 157\nChapter 6 ■ Attacking Authentication 157\nIn the field, one would not expect code like this to pass even the most cur-\nsory security review. However, the same conceptual flaw is much more likely\nto exist in more complex mechanisms in which numerous layered method\ninvocations are made, in which many potential errors may arise and be han-\ndled in different places, and where the more complicated validation logic may\ninvolve maintaining significant state about the progress of the login.\nHACK STEPS\n■ Perform a complete, valid login using an account you control. Record\nevery piece of data submitted to the application, and every response\nreceived, using your intercepting proxy.\n■ Repeat the login process numerous times, modifying pieces of the data\nsubmitted in unexpected ways. For example, for each request parameter\nor cookie sent by the client:\n■ Submit an empty string as the value.\n■ Remove the name/value pair altogether.\n■ Submit very long and very short values.\n■ Submit strings instead of numbers and vice versa.\n■ Submit the same item multiple times, with the same and different values.\n■ For each malformed request submitted, review closely the application’s\nresponse to identify any divergences from the base case.\n■ Feed these observations back into framing your test cases. When one\nmodification causes a change in behavior, try to combine this with other\nchanges to push the application’s logic to its limits.\nDefects in Multistage Login Mechanisms\nSome applications use elaborate login mechanisms involving multiple stages.\nFor example:\n■■ Entry of a username and password.\n■■ A challenge for specific digits from a PIN or a memorable word.\n■■ The submission of a value displayed on a changing physical token.\nMultistage login mechanisms are designed to provide enhanced security\nover the simple model based on username and password. Typically, the first\nstage requires the user to identify themselves with a username or similar item,\nand subsequent stages perform various authentication checks. Such mecha-\nnisms frequently contain security vulnerabilities, and in particular various\nlogic flaws (see Chapter 11).\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 158\n158 Chapter 6 ■ Attacking Authentication\nCOMMON MYTH It is often assumed that multistage login mechanisms\nare less prone to security bypasses than standard username/password\nauthentication. This belief is misleading. Performing several authentication\nchecks may add considerable security to the mechanism. Counterbalancing this,\nthe process is more prone to flaws in implementation. In several cases where a\ncombination of flaws is present, it can even result in a solution that is less\nsecure than a normal login based on username and password.\nSome implementations of multistage login mechanisms make potentially\nunsafe assumptions at each stage about the user’s interaction with earlier\nstages. For example:\n■■ An application may assume that a user who accesses stage three must\nhave cleared stages one and two. Therefore, it may authenticate an\nattacker who proceeds directly from stage one to stage three and cor-\nrectly completes it, enabling an attacker to log in with only one part of\nthe various credentials normally required.\n■■ An application may trust some of the data being processed at stage two\nbecause this was validated at stage one. However, an attacker may be\nable to manipulate this data at stage two, giving it a different value than\nwas validated at stage one. For example, at stage one the application\nmight determine whether the user’s account has expired, is locked out,\nor is in the administrative group, or whether it needs to complete fur-\nther stages of the login beyond stage two. If an attacker can interfere\nwith these flags as the login transitions between different stages, they\nmay be able to modify the behavior of the application and cause it to\nauthenticate them with only partial credentials or otherwise elevate\nprivileges.\n■■ An application may assume that the same user identity is used to com-\nplete each stage; however, it might not explicitly check this. For exam-\nple, stage one might involve submitting a valid username and\npassword, and stage two might involve resubmitting the username\n(now in a hidden form field) and a value from a changing physical\ntoken. If an attacker submits valid data pairs at each stage, but for dif-\nferent users, then the application might authenticate the user as either\none of the identities used in the two stages. This would enable an\nattacker who possesses his own physical token and discovers another\nuser’s password to log in as that user (or vice versa). Although the\nlogin mechanism cannot be completely compromised without any prior\ninformation, its overall security posture is substantially weakened and\nthe substantial expense and effort of implementing the two-factor\nmechanism does not deliver the benefits expected.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 159\nChapter 6 ■ Attacking Authentication 159\nHACK STEPS\n■ Perform a complete, valid login using an account you control. Record\nevery piece of data submitted to the application using your intercepting\nproxy.\n■ Identify each distinct stage of the login and the data that is collected at\neach stage. Determine whether any single piece of information is col-\nlected more than once or is ever transmitted back to the client and\nresubmitted, via a hidden form field, cookie, or preset URL parameter\n(see Chapter 5).\n■ Repeat the login process numerous times with various malformed\nrequests:\n■ Try performing the login steps in a different sequence.\n■ Try proceeding directly to any given stage and continuing from there.\n■ Try skipping each stage and continuing with the next.\n■ Use your imagination to think of further ways of accessing the differ-\nent stages that the developers may not have anticipated.\n■ If any data is submitted more than once, try submitting a different value\nat different stages, and see whether the login is still successful. It may\nbe that some of the submissions are superfluous and are not actually\nprocessed by the application. It might be that the data is validated at one\nstage and then trusted subsequently—in this instance, try to provide the\ncredentials of one user at one stage, and then switch at the next to actu-\nally authenticate as a different user. It might be that the same piece of\ndata is validated at more than one stage, but against different checks—\nin this instance, try to provide (for example) the username and password\nof one user at the first stage, and the username and PIN number of a dif-\nferent user at the second stage.\n■ Pay close attention to any data being transmitted via the client that was\nnot directly entered by the user. This may be used by the application to\nstore information about the state of the login progress, and may be\ntrusted by the application. For example, if the request for stage three\nincludes the parameter “stage2complete=true” then it may be possible\nto advance straight to stage three by setting this value. Try to modify the\nvalues being submitted and determine whether this enables you to\nadvance or skip stages.\nSome login mechanisms employ a randomly varying question at one of the\nstages of the login process. For example, after submitting a username and\npassword, the user might be asked one of various “secret” questions (regard-\ning their mother’s maiden name, place of birth, name of first school, etc.) or to\nsubmit two random letters from a secret phrase. The rationale for this behav-\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 160\n160 Chapter 6 ■ Attacking Authentication\nior is that even if an attacker captures everything that a user enters on a single\noccasion, this will not enable them to log in as that user on a different occasion,\nbecause different questions will be asked.\nIn some implementations, this functionality is broken and does not achieve\nits objectives:\n■■ The application may present a randomly chosen question, and store\nthe details of the question within a hidden HTML form field or cookie,\nrather than on the server. The user subsequently submits both the\nanswer and the question itself. This effectively allows an attacker to\nchoose which question to answer, enabling the attacker to repeat a\nlogin after capturing a user’s input on a single occasion.\n■■ The application may present a randomly chosen question on each login\nattempt but not remember which question a given user was asked in the\nevent that he or she fails to submit an answer. If the same user initiates a\nfresh login attempt a moment later, a different random question will be\ngenerated. This effectively allows an attacker to cycle through questions\nuntil they receive one to which they know the answer, enabling them to\nrepeat a login having captured a user’s input on a single occasion.\nNOTE The second of these conditions is really quite subtle, and as a result,\nmany real-world applications are vulnerable. An application that challenges a\nuser for two random letters of a memorable word may appear at first glance to\nbe functioning properly and providing enhanced security. However, if the letters\nare randomly chosen each time the previous authentication stage is passed,\nthen an attacker who has captured a user’s login on a single occasion can\nsimply reauthenticate up to this point until the two letters that he knows are\nrequested, without the risk of account lockout.\nHACK STEPS\n■ If one of the login stages uses a randomly varying question, verify\nwhether the details of the question are being submitted together with\nthe answer. If so, change the question, and submit the correct answer\nassociated with that question, and verify whether the login is still\nsuccessful.\n■ If the application does not enable an attacker to submit an arbitrary\nquestion and answer, perform a partial login several times with a single\naccount, proceeding each time as far as the varying question. If the ques-\ntion changes on each occasion, then an attacker can still effectively\nchoose which question to answer.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 161\nChapter 6 ■ Attacking Authentication 161\nNOTE In some applications where one component of the login varies\nrandomly, the application collects all of a user’s credentials at a single stage.\nFor example, the main login page may present a form containing fields for\nusername, password, and one of various secret questions. Each time the login\npage is loaded, the secret question changes. In this situation, the randomness\nof the secret question does nothing to prevent an attacker from replaying a\nvalid login request having captured a user’s input on one occasion, and the\nlogin process cannot be modified to do so in its present form, because an\nattacker can simply reload the page until he receives the varying question to\nwhich he knows the answer. In a variation on this scenario, the application may\nset a persistent cookie to “ensure” that the same varying question is presented\nto any given user until that person answers it correctly. This measure can of\ncourse be trivially circumvented by modifying or deleting the cookie.\nInsecure Storage of Credentials\nIf an application stores login credentials in an insecure manner, then the secu-\nrity of the login mechanism is undermined, even though there may be no\ninherent flaw in the authentication process itself.\nIt is very common to encounter web applications in which user credentials\nare stored in unencrypted form within the database. Because the database\naccount used by the application must have full read/write access to those cre-\ndentials, many kinds of other vulnerabilities within the application may be\nexploitable to enable you to access these credentials—for example, command\nor SQL injection flaws (Chapter 9) or access control weaknesses (Chapter 8).\nHACK STEPS\n■ Review the entire authentication-related functionality of the application,\nand also any functions relating to user maintenance. If any instances are\nfound in which a user’s password is transmitted back to the client, then\nthis may indicate that passwords are being stored in an insecure manner.\n■ If any kind of arbitrary command or query execution vulnerability is\nidentified within the application, attempt to find the location within the\napplication’s database or file system where user credentials are stored.\nQuery these to determine whether passwords are being stored in unen-\ncrypted form.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 162\n162 Chapter 6 ■ Attacking Authentication\nSecuring Authentication\nImplementing a secure authentication solution involves attempting to simul-\ntaneously meet several key security objectives, and in many cases trade off\nagainst other objectives such as functionality, usability, and total cost. In some\ncases “more” security can actually be counterproductive—for example, forc-\ning users to set very long passwords and change them frequently will often\nlead users to write their passwords down.\nBecause of the enormous variety of possible authentication vulnerabilities,\nand the potentially complex defenses that an application may need to deploy\nin order to mitigate against all of them, many application designers and devel-\nopers choose to accept certain threats as a given and concentrate their efforts\non preventing the most serious attacks. Factors to consider in striking an\nappropriate balance include:\n■■ The criticality of security given the functionality offered by the applica-\ntion.\n■■ The degree to which users will tolerate and work with different types of\nauthentication controls.\n■■ The cost of supporting a less user-friendly system.\n■■ The financial cost of competing alternatives in relation to the revenue\nlikely to be generated by the application or the value of the assets it is\nprotecting.\nIn this section we will describe the most effective ways possible to defeat the\nvarious attacks against authentication mechanisms and leave readers to\ndecide which kinds of defenses are most appropriate for them in individual\ncases.\nUse Strong Credentials\n■■ Suitable minimum password quality requirements should be enforced.\nThese may include rules regarding: minimum length; the appearance of\nalphabetical, numeric, and typographical characters; the appearance of\nboth uppercase and lowercase characters; the avoidance of dictionary\nwords, names, and other common passwords; the prevention of a pass-\nword being set to the username; and the prevention of a similarity or\nmatch with previously set passwords. As with most security measures,\ndifferent password quality requirements may be appropriate for differ-\nent categories of user.\n■■ Usernames should be unique.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 163\nChapter 6 ■ Attacking Authentication 163\n■■ Any system-generated usernames and passwords should be created\nwith sufficient entropy that they cannot feasibly be sequenced or pre-\ndicted even by an attacker who gains access to a large sample of succes-\nsively generated instances.\n■■ Users should be permitted to set sufficiently strong passwords—for\nexample, long passwords should be allowed, and a wide range of char-\nacters should be allowed.\nHandle Credentials Secretively\n■■ All credentials should be created, stored, and transmitted in a manner\nthat does not lead to unauthorized disclosure.\n■■ All client-server communications should be protected using a well-\nestablished cryptographic technology, such as SSL. Custom solutions\nfor protecting data in transit are neither necessary nor desirable.\n■■ If it is considered preferable to use HTTP for the unauthenticated areas\nof the application, ensure that the login form itself is loaded using\nHTTPS, rather than switching to HTTPS at the point of the login\nsubmission.\n■■ Only POSTrequests should be used for transmitting credentials to the\nserver. Credentials should never be placed in URL parameters or cook-\nies (even ephemeral ones). Credentials should never be transmitted\nback to the client, even in parameters to a redirect.\n■■ All server-side application components should store credentials in a\nmanner that does not allow their original values to be easily recovered\neven by an attacker who gains full access to all the relevant data within\nthe application’s database. The usual means of achieving this objective\nis to use a strong hash function (such as SHA-256, at the time of this\nwriting), appropriately salted to reduce the effectiveness of precom-\nputed offline attacks.\n■■ Client-side “remember me” functionality should in general only\nremember nonsecret items such as usernames. In less security-critical\napplications, it may be considered appropriate to allow users to opt\nin to a facility to remember passwords. In this situation, no clear-text\ncredentials should be stored on the client (the password should be\nstored reversibly encrypted using a key known only to the server), and\nusers should be warned about the risks from an attacker with physical\naccess to their computer or who compromises their computer remotely.\nParticular attention should be paid to eliminating cross-site scripting\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 164\n164 Chapter 6 ■ Attacking Authentication\nvulnerabilities within the application that may be used to steal stored\ncredentials (see Chapter 12).\n■■ A password change facility should be implemented (see the “Prevent\nMisuse of the Password Change Function” section), and users should\nbe obliged to change their password periodically.\n■■ Where credentials for new accounts are distributed to users out-of-\nband, these should be sent as securely as possible, be time-limited, and\nrequire the user to change them on first login, and the user should be\ntold to destroy the communication after first use.\n■■ Where applicable, consider capturing some of the user’s login informa-\ntion (for example, single letters from a memorable word) using drop-\ndown menus rather than text fields. This will prevent any keyloggers\ninstalled on the user’s computer from capturing all of the data they\nsubmit. (Note, however, that a simple keylogger is only one means by\nwhich an attacker can capture user input. If he or she has already com-\npromised a user’s computer, then in principle an attacker can log every\ntype of event, including mouse movements, form submissions over\nHTTPS, and screen captures.)\nValidate Credentials Properly\n■■ Passwords should be validated in full—that is, in a case-sensitive way,\nwithout filtering or modifying any characters, and without truncating\nthe password.\n■■ The application should be aggressive in defending itself against unex-\npected events occurring during login processing. For example, depend-\ning on the development language in use, the application should use\ncatch-all exception handlers around all API calls. These should explic-\nitly delete all session and method-local data being used to control the\nstate of the login processing and should explicitly invalidate the current\nsession, thereby causing a forced logout by the server even if authenti-\ncation is somehow bypassed.\n■■ All authentication logic should be closely code-reviewed, both as\npseudo-code and as actual application source code, to identify logic\nerrors such as fail-open conditions.\n■■ If functionality to support user impersonation is implemented, this\nshould be strictly controlled to ensure that it cannot be misused to\ngain unauthorized access. Because of the criticality of the functionality,\nit is often worthwhile to remove this functionality entirely from the\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 165\nChapter 6 ■ Attacking Authentication 165\npublic-facing application, and implement it only for internal adminis-\ntrative users, whose use of impersonation should be tightly controlled\nand audited.\n■■ Multistage logins should be strictly controlled to prevent an attacker\nfrom interfering with the transitions and relationships between the\nstages:\n■■ All data about progress through the stages and the results of previ-\nous validation tasks should be held in the server-side session object\nand should never be transmitted to or read from the client.\n■■ No items of information should be submitted more than once by the\nuser, and there should be no means for the user to modify data that\nhas already been collected and/or validated. Where an item of data\nsuch as a username is used at multiple stages, this should be stored\nin a session variable when first collected, and referenced from there\nsubsequently.\n■■ The first task carried out at every stage should be to verify that all\nprior stages have been correctly completed. If this is not the case, the\nauthentication attempt should immediately be marked as bad.\n■■ To prevent information leakage about which stage of the login failed\n(which would enable an attacker to target each stage in turn), the\napplication should always proceed through all stages of the login,\neven if the user has failed to complete earlier stages correctly, and\neven if the original username was invalid. After proceeding through\nall of the stages, the application should present a generic “login\nfailed” message at the conclusion of the final stage, without provid-\ning any information about where the failure occurred.\n■■ Where a login process includes a randomly varying question, ensure\nthat an attacker is not able to effectively choose his own question:\n■■ Always employ a multistage process in which users identify them-\nselves at an initial stage, and the randomly varying question is pre-\nsented to them at a later stage.\n■■ When a given user has been presented with a given varying ques-\ntion, store that question within their persistent user profile, and\nensure that the same user is presented with the same question on\neach attempted login until they successfully answer it.\n■■ When a randomly varying challenge is presented to the user, store\nthe question that has been asked within a server-side session vari-\nable, rather than a hidden field in an HTML form, and validate the\nsubsequent answer against that saved question.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 166\n166 Chapter 6 ■ Attacking Authentication\nNOTE The subtleties of devising a secure authentication mechanism run\ndeep here. If care is not taken in the asking of a randomly varying question,\nthen this can lead to new opportunities for username enumeration. For\nexample, in order to prevent an attacker from choosing his own question, an\napplication may store within each user’s profile the last question that user was\nasked, and continue presenting that question until the user answers it correctly.\nAn attacker who initiates several logins using any given user’s username will\nbe met with the same question. However, if the attacker carries out the same\nprocess using an invalid username, the application may behave differently:\nbecause there is no user profile associated with an invalid username, there\nwill be no stored question, and so a varying question will be presented. The\nattacker can use this difference in behavior, manifested across several login\nattempts, to infer the validity of a given username. In a scripted attack, he will\nbe able to harvest numerous usernames quickly.\nIf an application wishes to defend itself against this possibility, it must go to\nsome lengths. When a login attempt is initiated with an invalid username, the\napplication must record somewhere the random question that it presented for\nthat invalid username and ensure that subsequent login attempts using the\nsame username are met with the same question. Going even further, the\napplication could switch to a different question periodically, to simulate the\nnonexistent user having logged in as normal, resulting in a change in their next\nquestion! At some point, however, the application designer must draw a line\nand concede that a total victory against an attacker as determined as this is\nprobably not achievable.\nPrevent Information Leakage\n■■ The various authentication mechanisms used by the application should\nnot disclose any information about authentication parameters, either\nthrough overt messages or through inference from other aspects of the\napplication’s behavior. An attacker should have no means of determin-\ning which piece of the various items submitted has caused a problem.\n■■ A single code component should be responsible for responding to all\nfailed login attempts, with a generic message. This avoids a subtle vul-\nnerability that can occur when a supposedly uninformative message\nreturned from different code paths can actually be discriminated by an\nattacker, due to typographical differences in the message, different\nHTTP status codes, other information hidden in HTML, and the like.\n■■ If the application enforces some kind of account lockout to prevent\nbrute-force attacks (as discussed in the next section), then care should\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 167\nChapter 6 ■ Attacking Authentication 167\nbe taken that this does not lead to any information leakage. For exam-\nple, if an application discloses that a specific account has been sus-\npended for X minutes due to Y failed logins, then this behavior can\neasily be used to enumerate valid usernames. In addition, disclosing\nthe precise metrics of the lockout policy enables an attacker to optimize\nany attempt to continue guessing passwords in spite of the policy. To\navoid enumeration of usernames, the application should respond to any\nseries of failed login attempts from the same browser with a generic\nmessage advising that accounts are suspended if multiple failures occur\nand that the user should try again later. This can be achieved using a\ncookie or hidden field to track repeated failures originating from the\nsame browser. (Of course, this mechanism should not be used to\nenforce any actual security control—only to provide a helpful message\nto ordinary users who are struggling to remember their credentials.)\n■■ If the application supports self-registration, then it can prevent this func-\ntion from being used to enumerate existing usernames in two ways:\n■■ Instead of permitting self-selection of usernames, the application can\ncreate a unique (and unpredictable) username for each new user,\nthereby obviating the need to disclose that a username selected\nalready exists.\n■■ The application can use email addresses as usernames. Here, the\nfirst stage of the registration process requires the user to enter their\nemail address, whereupon they are told simply to wait for an email\nand follow the instructions contained within it. If the email address\nis already registered, the user can be informed of this in the email. If\nthe address is not already registered, the user can be provided with\na unique, unguessable URL to visit to continue the registration\nprocess. This prevents the attacker from enumerating valid user-\nnames (unless they happen to have already compromised a large\nnumber of email accounts).\nPrevent Brute-Force Attacks\n■■ Measures need to be enforced within all of the various challenges\nimplemented by the authentication functionality in order to prevent\nattacks that attempt to meet those challenges using automation. This\nincludes the login itself, as well as functions to change password, to\nrecover from a forgotten password situation, and the like.\n■■ Using unpredictable usernames and preventing their enumeration pre-\nsents a significant obstacle to completely blind brute-force attacks, and\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 168\n168 Chapter 6 ■ Attacking Authentication\nrequires an attacker to have somehow discovered one or more specific\nusernames before mounting an attack.\n■■ Some security-critical applications (such as online banks) simply\ndisable an account after a small number of failed logins (e.g., three)\nand require that the account owner take various out-of-band steps to\nreactivate the account, such as telephoning customer support and\nanswering a series of security questions. Disadvantages of this policy\nare that it allows an attacker to deny service to legitimate users by\nrepeatedly disabling their accounts, and the cost of providing the\naccount recovery service. A more balanced policy, suitable for most\nsecurity-aware applications, is to suspend accounts for a short period\n(e.g., 30 minutes) following a small number of failed login attempts\n(e.g., three). This serves to massively slow down any password-\nguessing attack, while mitigating the risk of denial-of-service attacks\nand also reducing call center work.\n■■ If a policy of temporary account suspension is implemented, care\nshould be taken to ensure its effectiveness:\n■■ To prevent information leakage leading to username enumeration,\nthe application should never indicate that any specific account has\nbeen suspended. Rather, it should respond to any series of failed\nlogins, even those using an invalid username, with a message advis-\ning that accounts are suspended if multiple failures occur and that\nthe user should try again later (as discussed previously).\n■■ The metrics of the policy should not be disclosed to users. Telling\nlegitimate users simply to “try again later” does not seriously dimin-\nish their quality of service. But informing an attacker exactly how\nmany failed attempts are tolerated, and how long the suspension\nperiod is for, enables them to optimize any attempt to continue\nguessing passwords in spite of the policy.\n■■ If an account is suspended, then login attempts should be rejected\nwithout even checking the credentials. Some applications that have\nimplemented a suspension policy remain vulnerable to brute forcing\nbecause they continue to fully process login attempts during the sus-\npension period, and return a subtly (or not so subtly) different mes-\nsage when valid credentials are submitted. This behavior enables an\neffective brute-force attack to proceed at full speed regardless of the\nsuspension policy.\n■■ Per-account countermeasures such as account lockout do not help to\nprotect against one kind of brute-force attack that is often highly effec-\ntive—namely to iterate through a long list of enumerated usernames\nchecking a single weak password, such as password. If, for example, five\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 169\nChapter 6 ■ Attacking Authentication 169\nfailed attempts trigger an account suspension, this means an attacker\ncan attempt four different passwords on every account without causing\nany disruption to users. In a typical application containing many weak\npasswords, such an attacker is likely to compromise many accounts.\nThe effectiveness of this kind of attack will, of course, be massively\nreduced if other areas of the authentication mechanism are designed\nsecurely. If usernames cannot be enumerated or reliably predicted, an\nattacker will be slowed down by the need to perform a brute-force exer-\ncise in guessing usernames. And if strong requirements are in place for\npassword quality, it is far less likely that the attacker will choose a pass-\nword for testing that even a single user of the application has chosen.\nIn addition to these controls, an application can specifically protect\nitself against this kind of attack through the use of CAPTCHA (“Com-\npletely Automated Public Turing test to tell Computers and Humans\nApart”) challenges on every page that may be a target for brute-force\nattacks (see Figure6-8). If effective, this measure can prevent any auto-\nmated submission of data to any application page, thereby restricting\nall kinds of password-guessing attacks from being executed manually.\nNote that much research has been done into CAPTCHA technologies,\nand automated attacks against them have in some cases been reliable.\nFurther, some attackers have been known to devise CAPTCHA-solving\ncompetitions, in which unwitting members of the public are leveraged\nas drones to assist the attacker. However, even if a particular kind of\nchallenge is not entirely effective, it will still lead most casual attackers\nto desist and find an application that does not employ the technique.\nFigure 6-8: A CAPTCHA control\ndesigned to hinder automated attacks\nTIP If you are attacking an application that uses CAPTCHA controls to hinder\nautomation, always closely review the HTML source for the page in which the\nimage appears. The authors have encountered cases where the solution to the\npuzzle appears in literal form within the ALTattribute of the image tag, or\nwithin a hidden form field, enabling a scripted attack to defeat the protection\nwithout actually solving the puzzle itself.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 170\n170 Chapter 6 ■ Attacking Authentication\nPrevent Misuse of the Password Change Function\n■■ A password change function should always be implemented, to allow\nperiodic password expiration (if required) and to allow users to change\npasswords if they wish to for any reason. As a key security mechanism,\nthis needs to be very well defended against misuse.\n■■ The function should only be accessible from within an authenticated\nsession.\n■■ There should be no facility to provide a username, either explicitly or\nvia a hidden form field or cookie—users have no legitimate need to\nattempt to change other people’s passwords.\n■■ As a defense-in-depth measure, the function should be protected from\nunauthorized access gained via some other security defect in the appli-\ncation—such as a session hijacking vulnerability, cross-site scripting,\nor even an unattended terminal. To this end, users should be required\nto reenter their existing password.\n■■ The new password should be entered twice to prevent mistakes, and\nthe application should compare the “new password” and “confirm new\npassword” fields as its first step and return an informative error if they\ndo not match.\n■■ The function should prevent the various attacks that can be made\nagainst the main login mechanism: a single generic error message\nshould be used to notify users of any error in existing credentials, and\nthe function should be temporarily suspended following a small num-\nber of failed attempts to change password.\n■■ Users should be notified out-of-band (e.g., via email) that their pass-\nword has been changed, but the message should not contain either their\nold or new credentials.\nPrevent Misuse of the Account Recovery Function\n■■ In the most security-critical applications, such as online banking,\naccount recovery in the event of a forgotten password is handled out-\nof-band: a user must make a telephone call and answer a series of secu-\nrity questions, and new credentials or a reactivation code are also sent\nout-of-band (via conventional mail) to the user’s registered home\naddress. The majority of applications do not want or need this level of\nsecurity, and so an automated recovery function may be appropriate.\n■■ A well-designed password recovery mechanism needs to prevent\naccounts from being compromised by an unauthorized party, and mini-\nmize any disruption to legitimate users.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 171\nChapter 6 ■ Attacking Authentication 171\n■■ Features such as password “hints” should absolutely never be used,\nsince they mainly serve to assist an attacker in trawling for accounts\nwith obvious hints set.\n■■ The best automated solution for enabling users to regain control of\naccounts is to email the user a unique, time-limited, unguessable,\nsingle-use recovery URL. This email should be sent to the address that\nthe user provided during registration. Visiting the URL will allow the\nuser to set a new password. After this has been done, a second email\nshould be sent, indicating that a password change was made. To pre-\nvent an attacker denying service to users by continually requesting\npassword reactivation emails, the user’s existing credentials should\nremain valid until such time as they are changed.\n■■ To further protect against unauthorized access, applications may pre-\nsent users with a secondary challenge that they must complete before\ngaining access to the password reset function. Care must taken to\nensure that the design of this challenge does not introduce new\nvulnerabilities:\n■■ The challenge should implement the same question or set of ques-\ntions for everyone, mandated by the application during registration.\nIf users provide their own challenge, it is likely that some of these\nwill be very weak, and this also enables an attacker to enumerate\nvalid accounts by identifying those which have a challenge set.\n■■ Responses to the challenge should contain sufficient entropy that\nthey cannot be easily guessed. For example, asking the user for the\nname of their first school is preferable to asking for their favorite\ncolor.\n■■ Accounts should be temporarily suspended following a number of\nfailed attempts to complete the challenge, to prevent brute-force\nattacks.\n■■ The application should not leak any information in the event of\nfailed responses to the challenge—regarding the validity of the\nusername, any suspension of the account, and so on.\n■■ Successful completion of the challenge should be followed by the\nprocess described previously, in which a message is sent to the\nuser’s registered email address containing a reactivation URL.\nUnder no circumstances should the application disclose the user’s\nforgotten password or simply drop the user into an authenticated\nsession. Even proceeding directly to the password reset function is\nundesirable, because the response to the account recovery challenge\nwill in general be easier for an attacker to guess than the original\npassword, and so it should not be relied upon on its own to authen-\nticate the user.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 172\n172 Chapter 6 ■ Attacking Authentication\nLog, Monitor, and Notify\n■■ All authentication-related events should be logged by the application,\nincluding login, logout, password change, password reset, account sus-\npension, and account recovery. Where applicable, both failed and suc-\ncessful attempts should be logged. The logs should contain all relevant\ndetails (e.g., username, and IP address) but no security secrets (e.g.,\npasswords). Logs should be strongly protected from unauthorized\naccess, as they are a critical source of information leakage.\n■■ Anomalies in authentication events should be processed by the applica-\ntion’s real-time alerting and intrusion prevention functionality. For\nexample, application administrators should be made aware of patterns\nindicating brute-force attacks, so that appropriate defensive and offen-\nsive measures can be considered.\n■■ Users should be notified out-of-band of any critical security events. For\nexample, the application should send a message to a user’s registered\nemail address whenever he changes hispassword.\n■■ Users should be notified in-band of frequently occurring security\nevents. For example, after a successful login, the application should\ninform users of the time and source IP/domain of the last login, and\nthe number of invalid login attempts made since then. If a user is\nmade aware that her account is being subjected to a password-\nguessing attack, she is more likely to change her password\nfrequently and set it to a strong value.\nChapter Summary\nAuthentication functions are perhaps the most prominent target in a typical\napplication’s attack surface. By definition, they can be reached by unprivi-\nleged, anonymous users. If broken, they grant access to protected functional-\nity and sensitive data. They lie at the core of the security mechanisms that an\napplication employs to defend itself, and are the front line of defense against\nunauthorized access.\nReal-world authentication mechanisms contain a myriad of design and\nimplementation flaws. An effective assault against them needs to proceed sys-\ntematically, using a structured methodology to work through every possible\navenue of attack. In many cases, open goals present themselves—bad pass-\nwords, ways to find out usernames, and vulnerability to brute-force attacks. At\nthe other end of the spectrum, defects may be very hard to uncover, and it may\nrequire meticulous examination of a convoluted login process to establish the\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 173\nChapter 6 ■ Attacking Authentication 173\nassumptions being made and spot the subtle logic flaw that can be exploited to\nwalk right through the door.\nThe most important lesson when attacking authentication functionality is to\nlook everywhere. In addition to the main login form, there may be functions to\nregister new accounts, change passwords, remember passwords, recover for-\ngotten passwords, and impersonate other users. Each of these presents a rich\ntarget of potential defects, and problems that have been consciously elimi-\nnated within one function very often reemerge within others. Invest the time\nto scrutinize and probe every inch of attack surface you can find, and your\nrewards may be great.\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. While testing a web application you log in using your credentials of joe\nand pass. During the login process, you see a request for the following\nURL appear in your intercepting proxy:\nhttp://www.wahh-app.com/app?action=login&uname=\njoe&password=pass\nWhat three vulnerabilities can you diagnose without probing any\nfurther?\n2. How can self-registration functions introduce username enumeration\nvulnerabilities? How can these vulnerabilities be prevented?\n3. A login mechanism involves the following steps:\n(a) The application requests the user’s username and passcode.\n(b) The application requests two randomly chosen letters from the\nuser’s memorable word.\nWhy is the required information requested in two separate steps? What\ndefect would the mechanism contain if this were not the case?\n4. A multistage login mechanism first requests the user’s username and\nthen various other items across successive stages. If any supplied item\nis invalid, the user is immediately returned to the first stage.\nWhat is wrong with this mechanism, and how can the vulnerability be\ncorrected?\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 174\n174 Chapter 6 ■ Attacking Authentication\n5. An application incorporates an anti-phishing mechanism into its login\nfunctionality. During registration, each user selects a specific image\nfrom a large bank of memorable images presented to them by the appli-\ncation. The login function involves the following steps:\n(a) The user enters their username and date of birth.\n(b) If these details are correct, the application displays to the user their\nchosen image; otherwise, a random image is displayed.\n(c) The user verifies that the correct image is displayed, and if so, enters\ntheir password.\nThe idea behind the anti-phishing mechanism is that it enables the user\nto confirm that they are dealing with the authentic application, and not\na clone, because only the real application knows the correct image to\ndisplay to the user.\nWhat vulnerability does the anti-phishing mechanism introduce into\nthe login function? Is the mechanism effective in preventing phishing?"
  },
  {
    "input": "",
    "summary": "Session management is a critical security component in web applications, enabling user identification across multiple requests. Weaknesses in session token generation or handling can allow attackers to bypass authentication and compromise user sessions. Common vulnerabilities include predictable tokens, improper handling of tokens, and insecure transmission methods like HTTP instead of HTTPS. Defensive measures involve generating strong, unpredictable tokens, using HTTPS, restricting cookie scope, and implementing per-page tokens to prevent session hijacking. Applications should also ensure proper session termination and monitor for suspicious activity to protect against attacks.",
    "output": "70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 175\nCHAPTER\n7\nAttacking Session Management\nThe session management mechanism is a fundamental security component in\nthe majority of web applications. It is what enables the application to uniquely\nidentify a given user across a number of different requests, and to handle the\ndata that it accumulates about the state of that user’s interaction with the\napplication. Where an application implements login functionality, session\nmanagement is of particular importance, as it is what enables the application\nto persist its assurance of any given user’s identity beyond the request in\nwhich they supply their credentials.\nBecause of the key role played by session management mechanisms, they\nare a prime target for malicious attacks against the application. If an attacker\ncan break an application’s session management, then she can effectively\nbypass its authentication controls and masquerade as other application users\nwithout knowing their credentials. If an attacker compromises an administra-\ntive user in this way, then the attacker can own the entire application.\nAs with authentication mechanisms, there is a wide variety of defects that can\ncommonly be found in session management functions. In the most vulnerable\ncases, an attacker simply needs to increment the value of a token issued to them\nby the application in order to switch their context to that of a different user. In\nthis situation, the application is wide open for anyone to access all areas. At the\nother end of the spectrum, an attacker may have to work extremely hard, deci-\nphering several layers of obfuscation and devising a sophisticated automated\nattack, before finding a chink in the application’s armor.\n175\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 176\n176 Chapter 7 ■ Attacking Session Management\nIn this chapter, we will look at all of the types of weakness that the authors\nhave encountered in real-world web applications. We will set out in detail the\npractical steps that you need to take to find and exploit these defects. Finally,\nwe will describe the defensive measures that applications should take to pro-\ntect themselves against these attacks.\nCOMMON MYTH “We use smartcards for authentication, and users’\nsessions cannot be compromised without the card.”\nHowever robust an application’s authentication mechanism, subsequent\nrequests from users are only linked back to that authentication via the resulting\nsession. If the application’s session management is flawed, then an attacker\ncan bypass the robust authentication altogether and still compromise users.\nThe Need for State\nThe HTTP protocol is essentially stateless. It is based on a simple request-\nresponse model, in which each pair of messages represents an independent\ntransaction. The protocol itself contains no mechanism for linking together the\nseries of requests made by one particular user and distinguishing these from\nall of the other requests received by the web server. In the early days of the\nWeb, there was no need for any such mechanism: web sites were used to pub-\nlish static HTML pages for anyone to view. Today, things are very different.\nThe majority of web “sites” are in fact web applications. They allow you to\nregister and log in. They let you buy and sell goods. They remember your pref-\nerences next time you visit. They deliver rich, multimedia experiences with\ncontent created dynamically based on what you click and type. In order to\nimplement any of this functionality, web applications need to use the concept\nof a session.\nThe most obvious use of sessions is in applications that support logging in.\nAfter entering your username and password, you can go ahead and use the\napplication as the user whose credentials you have entered, until such time as\nyou log out or the session expires due to inactivity. Users do not want to have\nto reenter their password on every single page of the application. Hence, after\nauthenticating the user once, the application creates a session for them, and\ntreats all requests belonging to that session as coming from that user.\nApplications that do not have a login function also typically need to use ses-\nsions. Many sites selling merchandise do not require customers to create\naccounts. However, they allow users to browse the catalog, add items to a\nshopping basket, provide delivery details, and make payment. In this sce-\nnario, there is no need to authenticate the identity of the user: for the majority\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 177\nChapter 7 ■ Attacking Session Management 177\nof their visit, the application does not know or care who the user is. But, in\norder to do business with them, it needs to know which series of requests it\nreceives has originated from the same user.\nThe simplest and still most common means of implementing sessions is to\nissue each user with a unique session token or identifier. On each subsequent\nrequest to the application, the user resubmits this token, enabling the application\nto determine which sequence of earlier requests the current request relates to.\nIn most cases, applications use HTTP cookies as the transmission mecha-\nnism for passing these session tokens between server and client. The server’s\nfirst response to a new client contains an HTTP header like the following:\nSet-Cookie: ASP.NET_SessionId=mza2ji454s04cwbgwb2ttj55\nand subsequent requests from the client contain the header:\nCookie: ASP.NET_SessionId=mza2ji454s04cwbgwb2ttj55\nThere are various categories of attack to which this standard session man-\nagement mechanism is inherently vulnerable. An attacker’s primary objective\nin targeting the mechanism is to somehow hijack the session of a legitimate\nuser and thereby masquerade as them. If the user has been authenticated to the\napplication, the attacker may be able to access private data belonging to the\nuser or carry out unauthorized actions on that person’s behalf. If the user is\nunauthenticated, the attacker may still be able to view sensitive information\nsubmitted by the user during her session.\nAs in the previous example of a Microsoft IIS server running ASP.NET, most\ncommercial web servers and web application platforms implement their own\noff-the-shelf session management solution based on HTTP cookies. They pro-\nvide APIs that web application developers can use to integrate their own\nsession-dependent functionality with this solution.\nSome off-the-shelf implementations of session management have been\nfound vulnerable to various attacks, which result in users’ sessions being com-\npromised (these are discussed later in this chapter). In addition, some devel-\nopers find that they need more fine-grained control over session behavior than\nis provided for them by the built-in solutions, or wish to avoid some vulnera-\nbilities inherent in cookie-based solutions. For these reasons, it is fairly\nc ommon to see bespoke and/or non-cookie-based session management mech-\nanisms used in security-critical applications such as online banking.\nThe vulnerabilities that exist in session management mechanisms largely\nfall into two categories:\n■■ Weaknesses in the generation of session tokens.\n■■ Weaknesses in the handling of session tokens throughout their lifecycle.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 178\n178 Chapter 7 ■ Attacking Session Management\nWe will look at each of these areas in turn, describing the different types of\ndefects that are commonly found in real-world session management mecha-\nnisms, and practical techniques for discovering and exploiting these. Finally,\nwe will describe measures that applications can take to defend themselves\nagainst these attacks.\nHACK STEPS\nIn many applications that use the standard cookie mechanism for transmitting\nsession tokens, it is straightforward to identify which item of data contains the\ntoken. However, in other cases it may require some detective work.\n■ The application may often employ several different items of data collec-\ntively as a token, including cookies, URL parameters, and hidden form\nfields. Some of these items may be used to maintain session state on dif-\nferent back-end components. Do not assume that a particular parameter\nis the session token without proving it, or that sessions are being tracked\nusing only one item.\n■ Sometimes, items that appear to be the application’s session token may\nnot be. In particular, the standard session cookie generated by the web\nserver or application platform may be present but not actually used by\nthe application.\n■ Observe which new items are passed to the browser after authentication.\nOften, new session tokens are created after a user authenticates herself.\n■ To verify which items are actually being employed as tokens, find a page\nthat is certainly session-dependent (such as a user-specific “my details”\npage), and make several requests for it, systematically removing each\nitem that you suspect is being used as a token. If removing an item\ncauses the session-dependent page not to be returned, then this may\nconfirm that the item is a session token. Burp Repeater is a useful tool\nfor performing these tests.\nAlternatives to Sessions\nNot every web application employs sessions, and some security-critical appli-\ncations containing authentication mechanisms and complex functionality opt\nto use other techniques for managing state. There are two possible alternatives\nthat you are likely to encounter:\n■■ HTTP authentication—Applications using the various HTTP-based\nauthentication technologies (basic, digest, NTLM, etc.) sometimes avoid\nthe need to use sessions. With HTTP authentication, the client compo-\nnent interacts with the authentication mechanism directly via the\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 179\nChapter 7 ■ Attacking Session Management 179\nbrowser, using HTTP headers, and not via application-specific code\ncontained within any individual page. Once a user has entered his\ncredentials into a browser dialog, the browser effectively resubmits\nthese credentials (or reperforms any required handshake) with every\nsubsequent request to the same server. This is the equivalent to an\napplication that uses HTML forms-based authentication and places a\nlogin form on every application page, requiring users to reauthenticate\nthemselves with every action they perform. Hence, when HTTP-based\nauthentication is used, it is possible for an application to re-identify the\nuser across multiple requests without using sessions. However, HTTP\nauthentication is rarely used on Internet-based applications of any com-\nplexity, and the other very versatile benefits that fully fledged session\nmechanisms offer mean that virtually all web applications do in fact\nemploy them.\n■■ Sessionless state mechanisms—Some applications do not issue ses-\nsion tokens in order to manage the state of a user’s interaction with the\napplication but rather transmit all data required to manage that state\nvia the client, usually in a cookie or a hidden form field. In effect, this\nmechanism uses sessionless state in a similar way to the ASP.NET\nViewState. In order for this type of mechanism to be secure, the data\ntransmitted via the client must be properly protected. This usually\ninvolves constructing a binary blob containing all of the state informa-\ntion, and encrypting or signing this using a recognized algorithm. Suffi-\ncient context must be included within the data to prevent an attacker\nfrom collecting a state object at one location within the application and\nsubmitting it to another location to cause some undesirable behavior.\nThe application may also include an expiration time within the object’s\ndata, to perform the equivalent of session timeouts. Chapter 5 describes\nin more detail secure mechanisms for transmitting data via the client.\nHACK STEPS\n■ If HTTP authentication is being used, it is possible that no session man-\nagement mechanism is implemented. Use the methods described previ-\nously to examine the role played by any token-like items of data.\n■ If the application uses a sessionless state mechanism, transmitting all\ndata required to maintain state via the client, this may sometimes be dif-\nficult to detect with certainty, but the following are strong indicators that\nthis kind of mechanism is being used:\n■ Token-like data items issued to the client are fairly long (e.g., 100 or\nmore bytes).\n(continued)\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 180\n180 Chapter 7 ■ Attacking Session Management\nHACK STEPS (continued)\n■ The application issues a new item in response to every request.\n■ The data in the item appears to be encrypted (and so has no dis-\ncernible structure) or signed (and so contains meaningful structure\naccompanied by a few bytes of meaningless binary data).\n■ The application may reject attempts to submit the same item with\nmore than one request.\n■ If the evidence suggests strongly that the application is not using session\ntokens to manage state, then it is unlikely that any of the attacks\ndescribed within this chapter will achieve anything. Your time is likely to\nbe much better spent looking for other serious issues such as broken\naccess controls or code injection.\nWeaknesses in Session Token Generation\nSession management mechanisms are often vulnerable to attack because\ntokens are generated in an unsafe manner that enables an attacker to identify\nthe values of tokens that have been issued to other users.\nMeaningful Tokens\nSome session tokens are created using a transformation of the user’s user-\nname or email address, or other information associated with them. This infor-\nmation may be encoded or obfuscated in some way, and may be combined\nwith other data.\nFor example, the following token may initially appear to be a long random\nstring:\n757365723d6461663b6170703d61646d696e3b646174653d30312f31322f3036\nHowever, on closer inspection, it contains only hexadecimal characters.\nGuessing that the string may actually be a hex-encoding of a string of ASCII\ncharacters, we can run it through a decoder to reveal:\nuser=daf;app=admin;date=10/09/07\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 181\nChapter 7 ■ Attacking Session Management 181\nAttackers can exploit the meaning within this session token to attempt to\nguess the current sessions of other application users. Using a list of enumer-\nated or common usernames, they can quickly generate large numbers of\npotentially valid tokens and test these to confirm which are valid.\nTokens that contain meaningful data often exhibit some structure—that is,\nthey contain several components, often separated by a delimiter, which can be\nextracted and analyzed separately to allow an attacker to understand their\nfunction and means of generation. Components that may be encountered\nwithin structured tokens include:\n■■ The account username.\n■■ The numeric identifier used by the application to distinguish between\naccounts.\n■■ The user’s first/last human name.\n■■ The user’s email address.\n■■ The user’s group or role within the application.\n■■ A date/time stamp.\n■■ An incrementing or predictable number.\n■■ The client IP address.\nEach different component within a structured token, or indeed the entire\ntoken, may be encoded in different ways, either as a deliberate measure to\nobfuscate their content, or simply to ensure safe transport of binary data via\nHTTP. Encoding schemes that are commonly encountered include XOR,\nBase64, and hexadecimal representation using ASCII characters (see Chapter 3).\nIt may be necessary to test various different decodings on each component of\na structured token to unpack it to its original form.\nNOTE When an application handles a request containing a structured token,\nit may not actually process every component with the token or all of the data\ncontained within each component. In the previous example, the application\nmay Base64-decode the token and then process only the “user” and “date”\ncomponents. In cases where a token contains a blob of binary data, much of\nthis data may be padding, and only a small part of it may actually be relevant\nto the validation that the server performs on the token. Narrowing down the\nsubparts of a token that are actually required can often reduce considerably the\namount of apparent entropy and complexity that the token contains.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 182\n182 Chapter 7 ■ Attacking Session Management\nHACK STEPS\n■ Obtain a single token from the application, and modify it in systematic\nways to determine whether the entire token is validated, or whether\nsome subcomponents of the token are ignored. Try changing the token’s\nvalue one byte at a time (or even one bit at a time) and submitting the\nmodified token back to the application to determine whether it is still\naccepted. If you find that certain portions of the token are not actually\nrequired to be correct, you can exclude these from any further analysis,\npotentially reducing the amount of work that you need to perform.\n■ Log in as several different users at different times and record the tokens\nreceived from the server. If self-registration is available and you can\nchoose your username, log in with a series of similar usernames contain-\ning small variations between them, such as A, AA, AAA, AAAA, AAAB,\nAAAC, AABA, and so on. If other user-specific data is submitted at the\nlogin or stored in user profiles (such as an email address), perform a\nsimilar exercise to vary that data systematically and record the tokens\nreceived following login.\n■ Analyze the tokens for any correlations that appear to be related to the\nusername and other user-controllable data.\n■ Analyze the tokens for any detectable encoding or obfuscation. Where the\nusername contains a sequence of the same character, look for a corre-\nsponding character sequence in the token, which may indicate the use of\nXOR obfuscation. Look for sequences in the token containing only hexa-\ndecimal characters, which may indicate a hex-encoding of an ASCII string\nor other information. Look for sequences ending in an equals sign and/or\nonly containing the other valid Base64 characters: a–z, A–Z, 0–9, +, and /.\n■ If any meaning can be reverse engineered from the sample of session\ntokens, consider whether you have sufficient information to attempt to\nguess the tokens recently issued to other application users. Find a page\nof the application that is session-dependent (e.g., one that returns an\nerror message or a redirect elsewhere if accessed without a valid ses-\nsion), and use a tool such as Burp Intruder to make large numbers of\nrequests to this page using guessed tokens. Monitor the results for any\ncases where the page is loaded correctly, indicating a valid session token.\nPredictable Tokens\nSome session tokens do not contain any meaningful data associating them\nwith a particular user but are nevertheless guessable because they contain\nsequences or patterns that allow an attacker to extrapolate from a sample of\ntokens to find other valid tokens recently issued by the application. Even if the\nextrapolation involves an amount of trial and error (for example, one valid\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 183\nChapter 7 ■ Attacking Session Management 183\nguess per 1,000 attempts), this will still enable an automated attack to identify\nlarge numbers of valid tokens in a relatively short period of time.\nVulnerabilities relating to predictable token generation may be much easier\nto discover in commercial implementations of session management, such as\nweb servers or web application platforms, than they are in bespoke applica-\ntions. When you are remotely targeting a bespoke session management mech-\nanism, your sample of issued tokens may be restricted by the capacity of the\nserver, the activity of other users, your bandwidth, network latency, and so on.\nIn a laboratory environment, however, you can quickly create millions of sam-\nple tokens, all precisely sequenced and time-stamped, and can eliminate inter-\nference caused by other users.\nIn the simplest and most brazenly vulnerable cases, an application may use\na simple sequential number as the session token. In this case, you only need to\nobtain a sample of two or three tokens before launching an attack that will cap-\nture 100% of currently valid sessions very quickly.\nFigure 7-1 shows Burp Intruder being used to cycle the last two digits of a\nsequential session token to find values where the session is still active and can\nbe hijacked. The length of the server’s response is here a reliable indicator that\na valid session has been found.\nFigure7-1: An attack to discover valid sessions where the session token is predictable\nIn other cases, an application’s tokens may contain more elaborate sequences\nthat take some effort to discover. The types of potential variations one might\nencounter here are open ended, but the authors’ experience in the field indicates\nthat predictable session tokens commonly arise from three different sources:\n■■ Concealed sequences\n■■ Time dependency\n■■ Weak random number generation\nWe will look at each of these areas in turn.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 184\n184 Chapter 7 ■ Attacking Session Management\nConcealed Sequences\nIt is common to encounter session tokens that cannot be trivially predicted\nwhen analyzed in their raw form but that contain sequences that reveal them-\nselves when the tokens are suitably decoded or unpacked.\nConsider the following series of values, which form one component of a\nstructured session token:\nlwjVJA\nLs3Ajg\nxpKr+A\nXleXYg\n9hyCzA\njeFuNg\nJaZZoA\nNo immediate pattern is discernible; however, a cursory inspection indi-\ncates that the tokens may contain Base64-encoded data—in addition to the\nmixed-case alphabetical and numeric characters, there is a + character, which\nis also valid in a Base64-encoded string. Running the tokens through a Base64\ndecoder reveals the following:\n--Õ$\n.ÍÀŽ\nÆ’«ø\n^W-b\nö‚Ì\n?án6\n%¦Y\nThese strings appear to be gibberish and also contain nonprinting charac-\nters. This normally indicates that you are dealing with binary data rather than\nASCII text. Rendering the decoded data as hexadecimal numbers gives you:\n9708D524\n2ECDC08E\nC692ABF8\n5E579762\nF61C82CC\n8DE16E36\n25A659A0\nThere is still no visible pattern. However, if you subtract each number from\nthe previous one, you arrive at the following:\nFF97C4EB6A\n97C4EB6A\nFF97C4EB6A\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 185\nChapter 7 ■ Attacking Session Management 185\n97C4EB6A\nFF97C4EB6A\nFF97C4EB6A\nwhich immediately reveals the concealed pattern. The algorithm used to gen-\nerate tokens adds 0x97C4EB6A to the previous value, truncates the result to a\n32-bit number, and Base64-encodes this binary data to allow it to be trans-\nported using the text-based protocol HTTP. Using this knowledge, you can\neasily write a script to produce the series of tokens that the server will next\nproduce, and the series that it produced prior to the captured sample.\nTime Dependency\nSome web servers and applications employ algorithms for generating session\ntokens that use the time of generation as an input to the token’s value. If insuf-\nficient other entropy is incorporated into the algorithm, then you may be able\nto predict other users’ tokens. Although any given sequence of tokens on its\nown may appear to be completely random, the same sequence coupled with\ninformation about the time at which each token was generated may contain a\ndiscernible pattern. In a busy application, with large numbers of sessions\nbeing created per second, a scripted attack may succeed in identifying large\nnumbers of other users’ tokens.\nWhen testing the web application of an online retailer, the authors encoun-\ntered the following sequence of session tokens:\n3124538-1172764258718\n3124539-1172764259062\n3124540-1172764259281\n3124541-1172764259734\n3124542-1172764260046\n3124543-1172764260156\n3124544-1172764260296\n3124545-1172764260421\n3124546-1172764260812\n3124547-1172764260890\nEach token is clearly composed of two separate numeric components. The\nfirst number follows a simple incrementing sequence and is trivial to predict.\nThe second number is increasing by a varying amount each time. Calculating\nthe differences between its value in each successive token reveals the following:\n344\n219\n453\n312\n110\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 186\n186 Chapter 7 ■ Attacking Session Management\n140\n125\n391\n78\nThe sequence does not appear to contain a reliably predictable pattern; how-\never, it would clearly be possible to brute force the relevant number range in\nan automated attack to discover valid values in the sequence. Before attempt-\ning this attack, however, we wait a few minutes and gather a further sequence\nof tokens:\n3124553-1172764800468\n3124554-1172764800609\n3124555-1172764801109\n3124556-1172764801406\n3124557-1172764801703\n3124558-1172764802125\n3124559-1172764802500\n3124560-1172764802656\n3124561-1172764803125\n3124562-1172764803562\nComparing this second sequence of tokens with the first, two points are\nimmediately obvious:\n■■ The first numeric sequence continues to progress incrementally; how-\never, five values have been skipped since the end of our first sequence.\nThis is presumably because the missing values have been issued to\nother users, who logged into the application in the window between\nthe two tests.\n■■ The second numeric sequence continues to progress by similar intervals\nas before; however, the first value we obtain is a massive 539,578\ngreater than the previous value.\nThis second observation immediately alerts us to the role played by time in\ngenerating session tokens. Apparently, only five tokens have been issued\nbetween the two token-grabbing exercises. However, a period of approxi-\nmately 10 minutes has also elapsed. The most likely explanation is that the sec-\nond number is time-dependent and is probably a simple count of milliseconds.\nIndeed, our hunch is correct, and in a subsequent phase of our testing\nwe perform a code review, which reveals the following token-generation\nalgorithm:\nString sessId = Integer.toString(s_SessionIndex++) +\n“-“ +\nSystem.currentTimeMillis();\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 187\nChapter 7 ■ Attacking Session Management 187\nGiven our analysis of how tokens are created, it is straightforward to con-\nstruct a scripted attack to harvest the session tokens that the application issues\nto other users:\n■■ We continue polling the server to obtain new session tokens in quick\nsuccession.\n■■ We monitor the increments in the first number. When this increases by\nmore than one, we know that a token has been issued to another user.\n■■ When a token has been issued to another user, we know the upper and\nlower bounds of the second number that was issued to them, because\nwe possess the tokens that were issued immediately before and after\ntheirs. Because we are obtaining new session tokens frequently, the\nrange between these bounds will typically consist of only a few hun-\ndred values.\n■■ Each time a token is issued to another user, we launch a brute-force\nattack to iterate through each number in the range, appending this to\nthe missing incremental number that we know was issued to the other\nuser. We attempt to access a protected page using each token we con-\nstruct, until the attempt succeeds and we have compromised the user’s\nsession.\n■■ Running this scripted attack continuously will enable us to capture the\nsession token of every other application user. When an administrative\nuser logs in, we will fully compromise the entire application.\nWeak Random Number Generation\nVery little that occurs inside a computer is random. Therefore, when random-\nness is required for some purpose, software uses various techniques to gener-\nate numbers in a pseudo-random manner. Some of the algorithms used\nproduce sequences that appear to be stochastic and manifest an even spread\nacross the range of possible values, but can nevertheless be extrapolated for-\nwards or backwards with perfect accuracy by anyone who obtains a small\nsample of values.\nWhen a predictable pseudo-random number generator is used for produc-\ning session tokens, the resulting tokens are vulnerable to sequencing by an\nattacker.\nJetty is a popular web server written in 100% Java, which provides a session\nmanagement mechanism for use by applications running on it. In 2006, Chris\nAnley of NGSSoftware discovered that the mechanism was vulnerable to a\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 188\n188 Chapter 7 ■ Attacking Session Management\nsession token prediction attack. The server used the Java API java.util\n.Random to generate session tokens. This implements a “linear congruential\ngenerator,” which generates the next number in the sequence as follows:\nsynchronized protected int next(int bits) {\nseed = (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1);\nreturn (int)(seed >>> (48 - bits));\n}\nThis algorithm in effect takes the last number generated, multiplies it by one\nconstant, and adds another constant, to obtain the next number. The number is\ntruncated to 48 bits, and the algorithm shifts the result to return the specific\nnumber of bits requested by the caller.\nKnowing this algorithm and a single number generated by it, we can easily\nderive the sequence of numbers that the algorithm will generate next, and also\n(with a little number theory) derive the sequence that it generated previously.\nThis means that an attacker who obtains a single session token from the server\ncan obtain the tokens of all current and future sessions.\nNOTE Sometimes when tokens are created based on the output of a pseudo-\nrandom number generator, developers decide to construct each token by\nconcatenating together several sequential outputs from the generator. The\nperceived rationale for this is that it creates a longer, and therefore “stronger”\ntoken. However, this tactic is usually a mistake. If an attacker can obtain\nseveral consecutive outputs from the generator, this may enable them to infer\nsome information about its internal state, and may in fact make it easier for\nthem to extrapolate the generator’s sequence of outputs, either forward or\nbackward.\nHACK STEPS\n■ First, determine when and how session tokens are issued by walking\nthrough the application from the first application page through any login\nfunctions. The most common behaviors are: (a) the application creates a\nnew session any time a request is received that does not submit a token,\nand (b) the application creates a new session following a successful\nlogin. In order to harvest large numbers of tokens in an automated way,\nideally identify a single request (typically either GET /or a login submis-\nsion) that results in a new token being issued.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 189\nChapter 7 ■ Attacking Session Management 189\nHACK STEPS (continued)\n■ If a bespoke session management mechanism is in use, and you only\nhave remote access to the application, obtain a large sample of tokens\n(at least a few hundred). Gather these tokens in as quick succession as\npossible, to minimize the loss of tokens issued to other users and reduce\nthe influence of any time dependency. The following screenshot shows\nBurp Intruder being used to make large numbers of requests and log the\nreturned cookies, which can then be exported for further analysis.\n■ If a commercial session management mechanism is in use and/or you\nhave local access to the application, you can obtain indefinitely large\nsequences of session tokens in controlled conditions.\n■ Attempt to identify any patterns within your sample of cookies. There are\nvarious tools (including the testing suite WebScarab) that will attempt to\nperform some automated analysis on a sample of cookies. This kind of\ntool is often a useful starting point to get a feel for the amount of varia-\ntion contained within a sample of tokens. However, in the authors’ expe-\nrience these tools suffer from two limitations. First, they are usually only\neffective when the patterns within the sample are relatively obvious and\ncould be quickly identified through manual analysis; they are poor at\ndeciphering any encoding and structure within tokens. Second, they\noften produce graphical output, which gives the visual impression of\nsome kind of pattern, even though further analysis establishes that the\npattern is a red herring.\n(continued)\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 190\n190 Chapter 7 ■ Attacking Session Management\nHACK STEPS (continued)\n■ In most cases, there is no real substitute for a manual analysis of the\nsample of tokens. There is no magic formula for this, but the following\nsteps should get you on your way:\n■ Apply the knowledge you have already gleaned regarding which com-\nponents and bytes of the token are actually being processed by the\nserver. Ignore anything that is not processed, even if it varies between\nsamples.\n■ If it is unclear what type of data is contained within the token, or any\nindividual component of it, try applying various decodings to see if\nany more meaningful data emerges. It may be necessary to apply sev-\neral decodings in sequence.\n■ Try to identify any patterns in the sequences of values contained\nwithin each decoded token or component. Calculate the differences\nbetween successive values. Even if these appear to be chaotic, there\nmay be a fixed set of observed differences that narrows down the\nscope of any brute-force attack considerably.\n■ Obtain a similar sample of cookies after waiting for a few minutes,\nand repeat the same analysis. Try to detect whether any of the tokens’\ncontent is time-dependent.\n■ If a pattern is detected, reperform the token harvesting exercise from a\ndifferent IP address and (if relevant) a different username, to identify\nwhether the same pattern is detected, and whether tokens received in\nthe first exercise could be extrapolated to identify tokens received in the\nsecond. Sometimes, the sequence of tokens received by a script running\non a single machine will manifest a pattern, but this will not allow\nstraightforward extrapolation to the tokens issued to other users\nbecause information such as source IP is used as a source of entropy\n(such as a seed to a random number generator).\n■ If you believe you have enough insight into the token generation algo-\nrithm to mount an automated attack against other users’ sessions, it is\nlikely that the best means of achieving this is via a customized script,\nwhich can generate tokens using the specific patterns you have observed,\nand apply any necessary encoding. See Chapter 13 for some generic tech-\nniques for applying automation to this type of problem.\n■ If source code is available, closely review the code responsible for gener-\nating session tokens to understand the mechanism used and determine\nwhether it is vulnerable to prediction.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 191\nChapter 7 ■ Attacking Session Management 191\nFull-Blown Tests for Randomness\nDue to the importance of robust session token generation, performing an effec-\ntive attack against a security-critical application such as an online bank may\nrequire carrying out a full-blown methodology to test the randomness of its\ntokens. If you do not have access to source code, this will be a black-box exercise.\nHACK STEPS\n■ Determine the theoretical maximum number of unique tokens that are\navailable, based on the character set being used and number of bytes\nwithin the token that are actually being validated (as described earlier).\n■ Compare each character transition from one token to the next to deter-\nmine whether particular transitions are more common than others. If\nparticular transitions are preferred, there is a likelihood that the algo-\nrithm is flawed in some way.\n■ Perform NIST FIPS-140-2 statistical tests, identifying any statistically\nanomalous distribution of bits.\n■ Check for correlations between arbitrary bits; a truly random token will\nexhibit no correlation between the state of one bit and the state of\nanother.\n■ These tests cannot be carried out effectively simply by visual inspection.\nOf the publicly available tools, Stompy is most effective at carrying out\nfull-blown tests of randomness.\nWeaknesses in Session Token Handling\nNo matter how effective an application is at ensuring that the session tokens it\ngenerates do not contain any meaningful information and are not susceptible\nto analysis or prediction, its session mechanism will be wide open to attack if\nthose tokens are not handled carefully after generation. For example, if tokens\nare disclosed to an attacker via some means, then the attacker can hijack user\nsessions even if predicting the tokens is impossible.\nThere are various ways in which an application’s unsafe handling of tokens\ncan make it vulnerable to attack.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 192\n192 Chapter 7 ■ Attacking Session Management\nCOMMON MYTH “Our token is secure from disclosure to third parties\nbecause we use SSL.”\nProper use of SSL certainly helps to protect session tokens from being\ncaptured. But various mistakes can still result in tokens being transmitted in\nclear text even when SSL is in place. And there are various direct attacks\nagainst end users that can be used to obtain their token.\nDisclosure of Tokens on the Network\nThis area of vulnerability arises when the session token is transmitted across\nthe network in unencrypted form, enabling a suitably positioned eavesdrop-\nper to obtain the token and so masquerade as the legitimate user. Suitable posi-\ntions for eavesdropping include the user’s local network, within the user’s IT\ndepartment, within the user’s ISP, on the Internet backbone, within the appli-\ncation’s ISP, and within the IT department of the organization hosting the\napplication. In each case, this includes both authorized personnel of the rele-\nvant organization and any external attackers who have compromised the\ninfrastructure concerned.\nIn the simplest case, where an application uses an unencrypted HTTP con-\nnection for communications, an attacker can capture all data transmitted\nbetween client and server, including login credentials, personal information,\npayment details, and so on. In this situation, an attack against the user’s ses-\nsion is often unnecessary because the attacker can already view privileged\ninformation and can log in using captured credentials to perform other mali-\ncious actions. However, there may still be instances where the user’s session is\nthe primary target. For example, if the captured credentials are not sufficient to\nperform a second login (e.g., in a banking application, they may include a\nnumber displayed on a changing physical token, or specific digits from the\nuser’s PIN), the attacker may need to hijack the eavesdropped session in order\nto perform arbitrary actions. Or if there is close auditing of logins, and notifi-\ncation to the user of each successful login, then an attacker may wish to avoid\nperforming his own login in order to be as stealthy as possible.\nIn other cases, an application may use HTTPS to protect key client-server\ncommunications yet may still be vulnerable to interception of session tokens\non the network. There are various ways in which this weakness may occur,\nmany of which can arise specifically when HTTP cookies are used as the trans-\nmission mechanism for session tokens:\n■■ Some applications elect to use HTTPS to protect the user’s credentials\nduring login but then revert to HTTP for the remainder of the user’s\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 193\nChapter 7 ■ Attacking Session Management 193\nsession. Many web mail applications behave in this way. In this situa-\ntion, an eavesdropper cannot intercept the user’s credentials but may\nstill capture the session token, as shown in Figure7-2.\nFigure7-2: Capturing a session token transmitted over HTTP\n■■ Some applications use HTTP for preauthenticated areas of the site,\nsuch as the site’s front page, but switch to HTTPS from the login page\nonwards. However, in many cases the user is issued a session token at\nthe first page visited, and this token is not modified when the user logs\nin. The user’s session, which is originally unauthenticated, is upgraded\nto an authenticated session after login. In this situation an eavesdropper\ncan intercept a user’s token before login, wait for the user’s communi-\ncations to switch to HTTPS, indicating that the user is logging in, and\nthen attempt to access a protected page (such as My Account) using\nthat token.\n■■ Even if the application issues a fresh token following successful login,\nand uses HTTPS from the login page onwards, the token for the user’s\nauthenticated session may still be disclosed if the user revisits a preau-\nthentication page (such as Help or About), either by following links\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 194\n194 Chapter 7 ■ Attacking Session Management\nwithin the authenticated area, by using the Back button, or by typing\nthe URL directly.\n■■ In a variation on the previous case, the application may attempt to\nswitch to HTTPS when the user clicks the Login link; however, it may\nstill accept a login over HTTP if the user modifies the URL accordingly.\nIn this situation, a suitably positioned attacker can modify the pages\nreturned in the preauthenticated areas of the site so that the Login link\npoints to an HTTP page. Even if the application issues a fresh session\ntoken after successful login, the attacker may still intercept this token if\nhe has successfully downgraded the user’s connection to HTTP.\n■■ Some applications use HTTP for all static content within the applica-\ntion, such as images, scripts, style sheets, and page templates. This\nbehavior is often indicated by a warning alert within the user’s\nbrowser, as shown in Figure7-3. As described previously, an attacker\ncan intercept the user’s session token when the user’s browser accesses\na resource over HTTP, and use this token to access protected, nonstatic\nareas of the site over HTTPS.\nFigure7-3: Browsers present a warning alert\nwhen a page accessed over HTTPS contains\nitems accessed over HTTP.\n■■ Even if an application uses HTTPS for every single page, including\nunauthenticated areas of the site and static content, there may still be\ncircumstances in which users’ tokens are transmitted over HTTP. If an\nattacker can somehow induce a user to make a request over HTTP\n(either to the HTTP service on the same server if one is running or to\nhttp://server:443/otherwise), then their token may be submitted.\nMeans by which the attacker may attempt this include sending the user\na URL in an email or instant message, placing auto-loading links into a\nweb site the attacker controls, or using clickable banner ads. (See Chap-\nter 12 for more details about techniques of this kind for delivering\nattacks against other users.)\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 195\nChapter 7 ■ Attacking Session Management 195\nHACK STEPS\n■ Walk through the application in the normal way from first access (the\n“start” URL), through the login process, and then through all of the appli-\ncation’s functionality. Keep a record of every URL visited, and note every\ninstance in which a new session token is received. Pay particular atten-\ntion to login functions and transitions between HTTTP and HTTPS com-\nmunications. This can be achieved manually using a network sniffer such\nas Wireshark or partially automated using the logging functions of your\nintercepting proxy:\n■ If HTTP cookies are being used as the transmission mechanism for ses-\nsion tokens, verify whether the secureflag is set, preventing them from\never being transmitted over unencrypted connections.\n■ Determine whether, in the normal use of the application, session tokens\nare ever transmitted over an unencrypted connection. If so, they should\nbe regarded as vulnerable to interception.\n■ Where the start page uses HTTP, and the application switches to HTTPS\nfor the login and authenticated areas of the site, verify whether a new\ntoken is issued following login, or whether a token transmitted during\nthe HTTP stage is still being used to track the user’s authenticated ses-\nsion. Also verify whether the application will accept login over HTTP if\nthe login URL is modified accordingly.\n■ Even if the application uses HTTPS for every single page, verify whether\nthe server is also listening on port 80, running any service or content\nwhatsoever. If so, visit any HTTP URL directly from with an authenticated\nsession and verify whether the session token is transmitted.\n■ In cases where a token for an authenticated session is transmitted to the\nserver over HTTP, verify whether that token continues to be valid or is\nimmediately terminated by the server.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 196\n196 Chapter 7 ■ Attacking Session Management\nDisclosure of Tokens in Logs\nAside from the clear-text transmission of session tokens in network communi-\ncations, the most common place where tokens are simply disclosed to unau-\nthorized view is in system logs of various kinds. Although it is a rarer\noccurrence, the consequences of this kind of disclosure are usually more seri-\nous because those logs may be viewed by a far wider range of potential attack-\ners, and not just by someone who is suitably positioned to eavesdrop on the\nnetwork.\nMany applications provide functionality for administrators and other sup-\nport personnel to monitor and control aspects of the application’s runtime\nstate, including user sessions. For example, a helpdesk worker assisting a user\nwho is having problems may ask for their username, locate their current ses-\nsion through a list or search function, and view relevant details about the ses-\nsion. Or an administrator may consult a log of recent sessions in the course of\ninvestigating a security breach. Often, this kind of monitoring and control\nfunctionality discloses the actual session token associated with each session.\nAnd often, the functionality is poorly protected, allowing unauthorized users\nto access the list of current session tokens, and thereby hijack the sessions of all\napplication users.\nThe other main cause of session tokens appearing in system logs is where an\napplication uses the URL query string as a mechanism for transmitting tokens,\nas opposed to using HTTP cookies or the body of POSTrequests. For example,\ngoogling for inurl:jsessionid identifies thousands of applications that\ntransmit the Java platform session token (called jsessionid) within the URL:\nhttp://www.webjunction.org/do/Navigation;jsessionid=\nF27ED2A6AAE4C6DA409A3044E79B8B48?category=327\nWhen applications transmit their session tokens in this way, it is likely that\ntheir session tokens will appear in various system logs to which unauthorized\nparties may have access, for example:\n■■ Users’ browser logs.\n■■ Web server logs.\n■■ Logs of corporate or ISP proxy servers.\n■■ Logs of any reverse proxies employed within the application’s hosting\nenvironment.\n■■ The Referer logs of any servers that application users visit by following\noff-site links, as in Figure7-4.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 197\nChapter 7 ■ Attacking Session Management 197\nSome of these vulnerabilities will arise even if HTTPS is used throughout\nthe application.\nThe final case just described presents an attacker with a highly effective\nmeans of capturing session tokens in some applications. For example, if a web\nmail application transmits session tokens within the URL, then an attacker can\nsend emails to users of the application containing a link to a web server that he\ncontrols. If any user accesses the link (e.g., because they click on it, or because\ntheir browser loads images contained within HTML-formatted email), then\nthe attacker will receive, in real time, the session token of the user. The attacker\ncan run a simple script on his server to hijack the session of every token\nreceived and perform some malicious action, such as send spam email, harvest\npersonal information, or change passwords.\nNOTE Current versions of Internet Explorer do not include a Referer header\nwhen following off-site links contained in a page that was accessed over\nHTTPS. In this situation, Firefox includes the Referer header provided that the\noff-site link is also being accessed over HTTPS, even if it belongs to a different\ndomain. Hence, sensitive data placed into URLs is vulnerable to leakage in\nReferer logs even where SSL is being used.\nFigure7-4: When session tokens appear in URLs, these will be transmitted\nin the Referer header when users follow an off-site link or their browser\nloads an off-site resource.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 198\n198 Chapter 7 ■ Attacking Session Management\nHACK STEPS\n■ Identify all of the functionality within the application and locate any log-\nging or monitoring functions where session tokens can be viewed. Verify\nwho is able to access this functionality–for example, administrators, any\nauthenticated user, or any anonymous user. See Chapter 4 for techniques\nfor discovering hidden content that is not directly linked from the main\napplication.\n■ Identify any instances within the application where session tokens are\ntransmitted within the URL. It may be that tokens are generally transmit-\nted in a more secure manner but that developers have used the URL in\nspecific cases to work around particular difficulties. For example, this\nbehavior is often observed where a web application interfaces to an\nexternal system.\n■ If session tokens are being transmitted in URLs, attempt to find any\napplication functionality that enables you to inject arbitrary off-site links\ninto pages viewed by other users—for example, functionality implement-\ning a message board, site feedback, question-and-answer, and so on. If\nso, submit links to a web server you control and wait to see whether any\nusers’ session tokens are received in your Referer logs.\n■ If any session tokens are captured, attempt to hijack user sessions by\nusing the application as normal but substituting a captured token for\nyour own. Some intercepting proxies can be configured with regex-based\ncontent replacement rules to automatically modify items such as HTTP\ncookies. If a large number of tokens are captured, and session hijacking\nallows you to access sensitive data such as personal details, payment\ninformation or user passwords, you can use the automated techniques\ndescribed in Chapter 13 to harvest all desired data belonging to other\napplication users.\nVulnerable Mapping of Tokens to Sessions\nVarious common vulnerabilities in session management mechanisms arise\nbecause of weaknesses in the way the application maps the creation and pro-\ncessing of session tokens to individual users’ sessions themselves.\nThe simplest weakness is to allow multiple valid tokens to be concurrently\nassigned to the same user account. In virtually every application, there is no\nlegitimate reason why any user should have more than one session active at\nany given time. Of course, it is fairly frequent for a user to abandon an active\nsession and start a new one—for example, because they have closed a\nbrowser window or have moved to a different computer. But if a user appears\nto be using two different sessions simultaneously, this usually indicates that a\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 199\nChapter 7 ■ Attacking Session Management 199\nsecurity compromise has occurred: either the user has disclosed their creden-\ntials to another party or an attacker has obtained their credentials through\nsome other means. In both cases, permitting concurrent sessions is undesirable\nbecause it allows users to persist in undesirable practices without inconve-\nnience and because it allows an attacker to use captured credentials without\nrisk of detection.\nA related but distinct weakness is for applications to use “static” tokens.\nThese look like session tokens and may initially appear to function like them,\nbut in fact they are no such thing. In these applications, each user is assigned a\ntoken, and this same token is reissued to the user every time he logs in. The\napplication always accepts the token as valid regardless of whether the user\nhas recently logged in and been issued with it. Applications like this really\ninvolve a misunderstanding of the whole concept of what a session is, and the\nbenefits that it provides for managing and controlling access to the applica-\ntion. Sometimes, applications operate like this as a means of implementing\npoorly designed “remember me” functionality, and the static token is accord-\ningly stored in a persistent cookie (see Chapter 6). Sometimes the tokens them-\nselves are vulnerable to prediction attacks, making the vulnerability far more\nserious because rather than compromising the sessions of currently logged-in\nusers, a successful attack will compromise, for all time, the accounts of all reg-\nistered users.\nOther kinds of strange application behavior are also occasionally observed\nthat demonstrate a fundamental defect in the relationship between tokens and\nsessions. One example is where a meaningful token is constructed based upon\na username and a random component. For example, consider the token:\ndXNlcj1kYWY7cjE9MTMwOTQxODEyMTM0NTkwMTI=\nwhich Base64-decodes to:\nuser=daf;r1=13094181213459012\nAfter extensive analysis of the r1 component, we may conclude that this\ncannot be predicted based on a sample of values. However, if the application’s\nsession processing logic is awry, it may be that an attacker simply needs to\nsubmit any valid value as r1 and any valid value as user, in order to access a\nsession under the security context of the specified user. This is essentially an\naccess control vulnerability, because decisions about access are being made on\nthe basis of user-supplied data outside of the session (see Chapter 8). It arises\nbecause the application effectively uses session tokens to signify that the\nrequester has established somekind of valid session with the application; how-\never, the user context in which that session is processed is not an integral prop-\nerty of the session itself but is determined per-request through some other\nmeans. In this case, that means can be directly controlled by the requester.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 200\n200 Chapter 7 ■ Attacking Session Management\nHACK STEPS\n■ Log in to the application twice using the same user account, either from\ndifferent browser processes or from different computers. Determine\nwhether both sessions remain active concurrently. If so, the application\nsupports concurrent sessions, enabling an attacker who has compro-\nmised another user’s credentials to make use of these without risk of\ndetection.\n■ Log in and log out several times using the same user account, either from\ndifferent browser processes or from different computers. Determine\nwhether a new session token is issued each time or whether the same\ntoken is issued each time you log in. If the latter occurs, then the applica-\ntion is not really employing proper sessions at all.\n■ If tokens appear to contain any structure and meaning, attempt to sepa-\nrate out components that may identify the user from those that appear to\nbe inscrutable. Try to modify any user-related components of the token\nso that they refer to other known users of the application, and verify\nwhether the resulting token (a) is accepted by the application, and (b)\nenables you to masquerade as that user.\nVulnerable Session Termination\nProper termination of sessions is important for two reasons. First, keeping the\nlifespan of a session as short as is necessary reduces the window of opportu-\nnity within which an attacker may capture, guess, or misuse a valid session\ntoken. Second, it provides users with a means of invalidating an existing ses-\nsion when they no longer require it, thereby enabling them to reduce this win-\ndow further and to take some responsibility for securing their session in a\nshared computing environment. The main weaknesses in session termination\nfunctions involve failures to meet these two key objectives.\nSome applications do not enforce effective session expiration. Once created, a\nsession may remain valid for many days after the last request is received, before\nit is eventually cleaned up by the server. If tokens are vulnerable to some kind of\nsequencing flaw that is particularly difficult to exploit (for example, 100,000\nguesses for each valid token identified), an attacker may still be able to capture\nthe tokens of every user who has accessed the application in the recent past.\nSome applications do not provide effective logout functionality:\n■■ In some cases, a logout function is simply not implemented. Users have\nno means of causing the application to invalidate their session.\n■■ In some cases, the logout function does not actually cause the server to\ninvalidate the session. The server removes the token from the user’s\nbrowser (for example, by issuing a Set-Cookieinstruction to blank the\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 201\nChapter 7 ■ Attacking Session Management 201\ntoken). However, if the user continues to submit the token, then it is still\naccepted by the server.\n■■ In the worst cases, when a user clicks Logout, this fact is not communi-\ncated to the server at all, and so the server performs no action whatso-\never. Rather, a client-side script is executed that blanks the user’s\ncookie, meaning that subsequent requests return the user to the login\npage. An attacker who gains access to this cookie could use the session\nas if the user had never logged out.\nHACK STEPS\n■ Do not fall into the trap of examining actions that the application per-\nforms on the client-side token (such as cookie invalidation via a new\nSet-Cookieinstruction, client-side script, or an expiration time\nattribute). In terms of session termination, nothing much depends upon\nwhat happens to the token within the client browser. Rather, investigate\nwhether session expiration is implemented on the server side:\n■ Log in to the application to obtain a valid session token.\n■ Wait for a period without using this token, and then submit a request\nfor a protected page (e.g., “my details”) using the token.\n■ If the page is displayed as normal, then the token is still active.\n■ Use trial and error to determine how long any session expiration time-\nout is, or whether a token can still be used days after the last request\nusing it. Burp Intruder can be configured to increment the time inter-\nval between successive requests, to automate this task.\n■ Determine whether a logout function exists and is prominently made\navailable to users. If not, users are more vulnerable because they have\nno means of causing the application to invalidate their session.\n■ Where a logout function is provided, test its effectiveness. After logging\nout, attempt to reuse the old token and determine whether it is still\nvalid. If so, users remain vulnerable to some session hijacking attacks\neven after they have “logged out.”\nClient Exposure to Token Hijacking\nThere are various ways in which an attacker can target other users of the appli-\ncation in an attempt to capture or misuse the victim’s session token:\n■■ An obvious payload for cross-site scripting attacks is to query the user’s\ncookies to obtain their session token, which can then be transmitted to\nan arbitrary server controlled by the attacker. All of the various permu-\ntations of this attack are described in detail in Chapter 12.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 202\n202 Chapter 7 ■ Attacking Session Management\n■■ Various other attacks against users can be used to hijack the user’s ses-\nsion in different ways. These include session fixation vulnerabilities,\nwhere an attacker feeds a known session token to a user, waits for them\nto log in, and then hijacks their session; as well as cross-site request\nforgery attacks, in which an attacker makes a crafted request to an\napplication from a web site that he controls, and exploits the fact that\nthe user’s browser automatically submits her current cookie with this\nrequest. These attacks are also described in Chapter 12.\nHACK STEPS\n■ Identify any cross-site scripting vulnerabilities within the application and\ndetermine whether these can be exploited to capture the session tokens\nof other users (see Chapter 12).\n■ If the application issues session tokens to unauthenticated users, obtain a\ntoken and perform a login. If the application does not issue a fresh token\nfollowinga successful login, then it is vulnerable to session fixation.\n■ Even if the application does not issue session tokens to unauthenticated\nusers, obtain a token by logging in, and then return to the login page. If\nthe application is willing to return this page even though you are already\nauthenticated, submit another login as a different user using the same\ntoken. If the application does not issue a fresh token after the second\nlogin, then it is vulnerable to session fixation.\n■ Identify the format of session tokens used by the application. Modify\nyour token to an invented value that is validly formed, and attempt to\nlogin. If the application allows you to create an authenticated session\nusing an invented token, then it is vulnerable to session fixation.\n■ If the application does not support login, but processes sensitive user\ninformation (such as personal and payment details), and allows this to\nbe displayed after submission (e.g., on a “verify my order” page), then\ncarry out the previous three tests in relation to the pages displaying sen-\nsitive data. If a token set during anonymous usage of the application can\nlater be used to retrieve sensitive user information, then the application\nis vulnerable to session fixation.\n■ If the application uses HTTP cookies to transmit session tokens, then it\nmay well be vulnerable to cross-site request forgery (XSRF). First, log in to\nthe application. Then confirm that a request made to the application but\noriginating from a page of a different application results in submission of\nthe user’s token. (This submission will need to be made from a window of\nthe same browser process as was used to log in to the target application.)\nAttempt to identify any sensitive application functions all of whose para-\nmeters can be determined in advance by an attacker, and exploit this to\ncarry out unauthorized actions within the security context of a target user.\nSee Chapter 12 for more details on how to execute XSRF attacks.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 203\nChapter 7 ■ Attacking Session Management 203\nLiberal Cookie Scope\nThe usual simple summary of how cookies work is that the server issues a\ncookie using the HTTP response header Set-cookie, and the browser then\nresubmits this cookie in subsequent requests to the same server using the\nCookieheader. In fact, matters are rather more subtle than this.\nThe cookie mechanism allows a server to specify both the domain and the\nURL path to which each cookie will be resubmitted. To do this, it uses the domain\nand pathattributes that may be included in the Set-cookieinstruction.\nCookie Domain Restrictions\nWhen the application residing at foo.wahh-app.comsets a cookie, the browser\nwill by default resubmit the cookie in all subsequent requests to foo.wahh-\napp.com, and also to any subdomains, such as admin.foo.wahh-app.com. It will\nnot submit the cookie to any other domains, including the parent domain wahh-\napp.comand any other subdomains of the parent, such as bar.wahh-app.com.\nA server can override this default behavior by including a domainattribute\nin the Set-cookie instruction. For example, suppose that the application at\nfoo.wahh-app.comreturns the following HTTP header:\nSet-cookie: sessionId=19284710; domain=wahh-app.com;\nThe browser will then resubmit this cookie to all subdomains of wahh-app.com,\nincluding bar.wahh-app.com.\nNOTE A server cannot specify just any domain using this attribute. First, the\ndomain specified must be either the same domain as the application is running\non or a domain that is its parent (either immediately or at some remove).\nSecond, the domain specified cannot be a top-level domain such as .comor\n.co.uk, because this would enable a malicious server to set arbitrary cookies\non any other domain. If the server violates one of these rules, the browser will\nsimply ignore the Set-cookieinstruction.\nIf an application sets a cookie’s domain scope as unduly liberal, this may\nexpose the application to various security vulnerabilities.\nFor example, consider a blogging application that allows users to register,\nlog in, write blog posts, and read other people’s blogs. The main application is\nlocated at the domain wahh-blogs.com, and when users log in to the applica-\ntion they receive a session token in a cookie that is scoped to this domain. Each\nuser is able to create blogs that are accessed via a new subdomain which is pre-\nfixed by their username, for example:\nherman.wahh-blogs.com\nsolero.wahh-blogs.com\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 204\n204 Chapter 7 ■ Attacking Session Management\nBecause cookies are automatically resubmitted to every subdomain within\ntheir scope, when a user who is logged in browses the blogs of other users,\ntheir session token will be submitted with their requests. If blog authors are\npermitted to place arbitrary JavaScript within their own blogs (as is usually\nthe case in real-world blog applications), then a malicious blogger will be able\nto steal the session tokens of other users in the same way as is done in a stored\ncross-site scripting attack (see Chapter 12).\nThe problem arises because user-authored blogs are created as subdomains\nof the main application that handles authentication and session management.\nThere is no facility within HTTP cookies for the application to prevent cookies\nissued by the main domain from being resubmitted to its subdomains.\nThe solution is to use a different domain name for the main application (for\nexample, www.wahh-blogs.com), and scope the domain of its session token\ncookies to this fully qualified name. The session cookie will not then be sub-\nmitted when a logged-in user browses the blogs of other users.\nA different version of this vulnerability arises when an application explicitly\nsets the domain scope of its cookies to a parent domain. For example, suppose\nthat a security-critical application is located at the domain sensitiveapp\n.wahh-organization.com. When it sets cookies, it explicitly liberalizes their\ndomain scope, as follows:\nSet-cookie: sessionId=12df098ad809a5219; domain=wahh-organization.com\nThe consequence of this is that the sensitive application’s session token cook-\nies will be submitted when a user visits everysubdomain used by wahh-orga-\nnization.com, including:\nwww.wahh-organization.com\ntestapp.wahh-organization.com\nAlthough these other applications may all belong to the same organization\nas the sensitive application, it is undesirable for the sensitive application’s\ncookies to be submitted to other applications, for several reasons:\n■■ The personnel responsible for the other applications may have a differ-\nent level of trust than those responsible for the sensitive application.\n■■ The other applications may contain functionality which enables third\nparties to obtain the value of cookies submitted to the application, as in\nthe previous blogging example.\n■■ The other applications may not have been subjected to the same secu-\nrity standards or testing as the sensitive application (e.g., because they\nare less important, do not handle sensitive data, or have been created\nonly for test purposes). Many kinds of vulnerability that may exist in\nthose applications (for example, cross-site scripting vulnerabilities) may\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 205\nChapter 7 ■ Attacking Session Management 205\nbe irrelevant to the security posture of those applications but could\nenable an external attacker to leverage an insecure application in order\nto capture session tokens created by the sensitive application.\nCookie Path Restrictions\nWhen the application residing at /apps/secure/foo-app/index.jsp sets a\ncookie, the browser will by default resubmit the cookie in all subsequent\nrequests to the path /apps/secure/foo-app/, and also to any subdirectories. It\nwill not submit the cookie to the parent directory or to any other directory\npaths that exist on the server.\nAs with domain-based restrictions on cookie scope, a server can override\nthis default behavior by including a pathattribute in the Set-cookieinstruc-\ntion. For example, if the application returns the following HTTP header:\nSet-cookie: sessionId=187ab023e09c00a881a; path=/apps/;\nthe browser will then resubmit this cookie to all subdirectories of the /apps/\npath.\nNOTE If the application specifies a path attribute that does not contain a\ntrailing slash, then the browser will not interpret this as representing an actual\ndirectory. Rather it will submit the cookie to any paths that match the pattern\nspecified. For example, if the application specifies a path scope of /apps, then\nthe browser will submit its cookies to the paths /apps-test/and /apps-\nold/and all of their subdirectories, in addition to the path /apps/. This\nbehavior is probably not what the developer intended.\nIt is surprisingly common to encounter applications that explicitly liberalize\nthe path scope of their cookies to the web server root (/). In this situation, the\napplication’s cookies will be submitted to every application accessible via the\nsame domain name. For example:\n/apps/secure/bar-app/\n/apps/test/\n/blogs/users/solero/\nLiberalizing a cookie’s path scope can leave an application vulnerable in the\nsame way as when an application sets the domain scope of a cookie to its par-\nent domain. If a security-critical application sets a cookie with its path scope\nset to the web server root, and a less secure application resides at some other\npath, then the cookies issued by the former application will be submitted to\nthe latter. This will enable an attacker to leverage any weakness in the less\nsecure application as a means of attacking sessions on the more secure target.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 206\n206 Chapter 7 ■ Attacking Session Management\nNOTE In certain circumstances it may be possible to circumvent cookie path\nrestrictions, enabling a malicious web site residing at one path to access the\ncookies belonging to an application at a different path. Hence, the path\nattribute should not be relied upon to be completely reliable. See the following\npaper by Amit Klein for more details:\nwww.webappsec.org/lists/websecurity/archive/2006-03/\nmsg00000.html\nHACK STEPS\nReview all of the cookies issued by the application, and check for any domain\nor pathattributes used to control of the scope of the cookies.\n■ If an application explicitly liberalizes its cookies’ scope to a parent\ndomain or parent directory, then it may be leaving itself vulnerable to\nattacks via other web applications.\n■ If an application sets its cookies’ domain scope to its own domain name\n(or does not specify a domain attribute), then it may still be exposed to\napplications or functionality accessible via subdomains.\n■ If an application specifies its cookies’ path scope without using a trailing\nslash, then it might be exposed to other applications residing at paths\ncontaining a prefix that matches the specified scope.\nIdentify all of the possible domain names and paths that will receive the\ncookies issued by the application. Establish whether any other web application\nor functionality is accessible via these domain names or paths that you may be\nable to leverage to obtain the cookies issued to users of the target application.\nSecuring Session Management\nThe defensive measures that web applications must take to prevent attacks on\ntheir session management mechanisms correspond to the two broad cate-\ngories of vulnerability that affect those mechanisms. In order to perform ses-\nsion management in a secure manner, an application must generate its tokens\nin a robust way and must protect these tokens throughout their lifecycle from\ncreation to disposal.\nGenerate Strong Tokens\nThe tokens used to re-identify a user between successive requests should be\ngenerated in a manner that does not provide any scope for an attacker who\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 207\nChapter 7 ■ Attacking Session Management 207\nobtains a large sample of tokens from the application in the usual way to pre-\ndict or extrapolate the tokens issued to other users.\nThe most effective token generation mechanisms are those that:\n(a) use an extremely large set of possible values, and\n(b) contain a strong source of pseudo-randomness, ensuring an even and\nunpredictable spread of tokens across the range of possible values.\nIn principle, any item of arbitrary length and complexity may be guessed\nusing brute force given sufficient time and resources. The objective of design-\ning a mechanism for generating strong tokens is that it should be extremely\nunlikely that a determined attacker with large amounts of bandwidth and pro-\ncessing resources should be successful in guessing a single valid token within\nthe lifespan of its validity.\nTokens should consist of nothing more than an identifier used by the server\nto locate the relevant session object to be used for processing the user’s\nrequest. The token should contain no meaning or structure, either overtly or\nwrapped in layers of encoding or obfuscation. All data about the session’s\nowner and status should be stored on the server in the session object to which\nthe session token corresponds.\nCare should be taken when selecting a source of randomness. Developers\nshould be aware that the various sources available to them are likely to differ\nin strength very significantly. Some, as with java.util.Random, are perfectly\nuseful for many purposes where a source of changing input is required, but\ncan be extrapolated in both forward and reverse directions with perfect cer-\ntainty on the basis of a single item of output. Developers should investigate\nthe mathematical properties of the actual algorithms used within different\navailable sources of randomness and should read relevant documentation\nabout the recommended uses of different APIs. In general, if an algorithm is\nnot explicitly described as being cryptographically secure, it should be\nassumed to be predictable.\nNOTE Some high-strength sources of randomness take some time to return\nthe next value in their output sequence because of the steps they take to\nobtain sufficient entropy (from system events, etc.) and so may not deliver\nvalues sufficiently fast to generate tokens for some high-volume applications.\nIn addition to selecting the most robust source of randomness that is feasi-\nble, a good practice is to introduce as a source of entropy some information\nabout the individual request for which the token is being generated. This\ninformation may not be unique to that request, but it can be very effective in\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 208\n208 Chapter 7 ■ Attacking Session Management\nmitigating any weaknesses in the core pseudo-random number generator\nbeing used. Examples of information that may be incorporated include:\n■■ The source IP address and port number from which the request was\nreceived.\n■■ The User-Agentheader in the request.\n■■ The time of the request in milliseconds.\nA highly effective formula for incorporating this entropy is to construct a\nstring that concatenates a pseudo-random number, a variety of request-\nspecific data as listed, and a secret string known only to the server and gener-\nated afresh on each reboot. A suitable hash is then taken of this string (using,\nfor example, SHA-256 at the time of this writing), to produce a manageable\nfixed-length string that can be used as a token. (Placing the most variable items\ntowards the start of the hash’s input serves to maximize the “avalanche” effect\nwithin the hashing algorithm.)\nTIP Having decided upon an algorithm for generating session tokens, a useful\n“thought experiment” is to imagine that your source of pseudo-randomness is\ntotally broken and always returns the same value. In this eventuality, would an\nattacker who obtains a large sample of tokens from the application be able to\nextrapolate tokens issued to other users? Using the formula described here,\nthis will in general be highly unlikely, even with full knowledge of the algorithm\nused. The source IP, port number, User-Agentheader, and time of request\ntogether generate a vast amount of entropy. And even with full knowledge of\nthese, the attacker will not be able to produce the corresponding token without\nknowing the secret string used by the server.\nProtect Tokens throughout Their Lifecycle\nHaving created a robust token whose value cannot be predicted, this token\nneeds to be protected throughout its lifecycle from creation to disposal, to\nensure that it is not disclosed to anyone other than the user to whom it is\nissued:\n■■ The token should only ever be transmitted over HTTPS. Any token\ntransmitted in clear text should be regarded as tainted—that is, as not\nproviding assurance of the user’s identity. If HTTP cookies are being\nused to transmit tokens, these should be flagged as secureto prevent\nthe user’s browser from ever transmitting them over HTTP. If feasible,\nHTTPS should be used for every page of the application, including sta-\ntic content such as help pages, images, and so on. If this is not desired\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 209\nChapter 7 ■ Attacking Session Management 209\nand an HTTP service is still implemented, the application should redi-\nrect any requests for sensitive content (including the login page) back to\nthe HTTPS service. Static resources such as help pages are not usually\nsensitive and may be accessed without any authenticated session;\nhence, the use of secure cookies can be backed up using cookie scope\ninstructions to prevent tokens being submitted in requests for these\nresources.\n■■ Session tokens should never be transmitted in the URL, as this provides\na trivial vehicle for session fixation attacks and results in tokens appear-\ning in numerous logging mechanisms. In some cases, developers use\nthis technique to implement sessions in browsers that have cookies dis-\nabled. However, a better means of achieving this is to use POSTrequests\nfor all navigation and store tokens in a hidden field of an HTML form.\n■■ Logout functionality should be implemented. This should dispose of all\nsession resources held on the server and invalidate the session token.\n■■ Session expiration should be implemented after a suitable period of\ninactivity (e.g., 10 minutes). This should result in the same behavior as\nif the user had explicitly logged out.\n■■ Concurrent logins should be prevented. Each time a user logs in, a dif-\nferent session token should be issued, and any existing session belong-\ning to the user should be disposed of as if she had logged out from it.\nWhen this occurs, the old token may be stored for a period and any\nsubsequent requests received using the token should return a security\nalert to the user stating that the session has been terminated because\nshe has logged in from a different location.\n■■ If the application contains any administrative or diagnostic functional-\nity that enables session tokens to be viewed, this functionality should\nbe robustly defended against unauthorized access. In most cases, there\nis no necessity for this functionality to display the actual session token\nat all—rather, it should contain sufficient details about the owner of\nthe session for any support and diagnostic tasks to be performed, with-\nout divulging the session token being submitted by the user to identify\nher session.\n■■ The domain and path scope of an application’s session cookies should\nbe set as restrictively as possible. Cookies with overly liberal scope are\noften generated by poorly configured web application platforms or web\nservers, rather than by the application developers themselves. There\nshould be no other web applications or untrusted functionality accessi-\nble via domain names or URL paths that are included within the scope\nof the application’s cookies. Particular attention should be paid to any\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 210\n210 Chapter 7 ■ Attacking Session Management\nexisting subdomains to the domain name that is used to access the\napplication. In some cases, to ensure that this vulnerability does not\narise, it may be necessary to modify the domain- and path-naming\nscheme employed by the various applications in use within the\norganization.\nSpecific measures should be taken to defend the session management mech-\nanism against the variety of attacks with which the application’s users may\nfind themselves targeted:\n■■ The application’s codebase should be rigorously audited to identify and\nremove any cross-site scripting vulnerabilities (see Chapter 12). Most\nsuch vulnerabilities can be exploited to attack session management\nmechanisms. In particular, stored (or second-order) XSS attacks can usu-\nally be exploited to defeat every conceivable defense against session\nmisuse and hijacking.\n■■ Arbitrary tokens submitted by users that the server does not recognize\nshould not be accepted. The token should be immediately canceled\nwithin the browser, and the user should be returned to the application’s\nstart page.\n■■ Cross-site request forgery and other session attacks can be made more\ndifficult by requiring two-step confirmation and/or reauthentication\nbefore critical actions such as funds transfers are carried out.\n■■ Cross-site request forgery attacks can be defended against by not rely-\ning solely upon HTTP cookies for transmitting session tokens. Using\nthe cookie mechanism introduces the vulnerability because cookies are\nautomatically submitted by the browser regardless of what caused the\nrequest to take place. If tokens are always transmitted in a hidden field\nof an HTML form, then an attacker cannot create a form whose submis-\nsion will cause an unauthorized action unless he already knows the\nvalue of the token, in which case he can simply perform a trivial hijack-\ning attack. Per-page tokens can also help prevent these attacks (see the\nfollowing section).\n■■ A fresh session should always be created after successful authentica-\ntion, to mitigate the effects of session fixation attacks. Where an applica-\ntion does not use authentication but does allow sensitive data to be\nsubmitted, the threat posed by fixation attacks is harder to address.\nOne possible approach is to keep the sequence of pages where sensitive\ndata is submitted as short as possible, and either (a) create a new ses-\nsion at the first page of this sequence (where necessary, copying from\nthe existing session any required data, such as the contents of a shop-\nping cart), or (b) use per-page tokens (described in the following sec-\ntion) to prevent an attacker who knows the token used in the first page\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 211\nChapter 7 ■ Attacking Session Management 211\nfrom accessing subsequent pages. Except where strictly necessary, per-\nsonal data should not be displayed back to the user at all. Even where\nthis is required (e.g., a “confirm order” page showing addresses), sensi-\ntive items such as credit card numbers and passwords should neverbe\ndisplayed back to the user and should always be masked within the\nsource of the application’s response.\nPer-Page Tokens\nFiner-grained control over sessions can be achieved, and many kinds of session\nattacks made more difficult or impossible, by using per-page tokens in addition to\nsession tokens. Here, a new page token is created every time a user requests an\napplication page (as opposed to an image, for example) and is passed to the client\nin a cookie or a hidden field of an HTML form. Each time the user makes a\nrequest, the page token is validated against the last value issued, in addition to the\nnormal validation of the main session token. In the case of a non-match, the entire\nsession is terminated. Many of the most security-critical web applications on the\nInternet, such as online banks, employ per-page tokens to provide increased pro-\ntection for their session management mechanism, as shown in Figure7-5.\nFigure7-5: Per-page tokens used in a banking application\nWhile the use of per-page tokens does impose some restrictions on navigation\n(for example, on use of the back and forward buttons and multi-window brows-\ning), it effectively prevents session fixation attacks and ensures that the simulta-\nneous use of a hijacked session by a legitimate user and an attacker will quickly\nbe blocked after both have made a single request. Per-page tokens can also be\nleveraged to track the user’s location and movement through the application,\nand used to detect attempts to access functions out of a defined sequence, help-\ning to protect against certain access control defects (see Chapter 8).\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 212\n212 Chapter 7 ■ Attacking Session Management\nLog, Monitor, and Alert\nThe application’s session management functionality should be closely inte-\ngrated with its mechanisms for logging, monitoring, and alerting, in order to\nprovide suitable records of anomalous activity and enable administrators to\ntake defensive actions where necessary:\n■■ The application should monitor requests that contain invalid tokens.\nExcept in the most trivially predictable cases, a successful attack\nattempting to guess the tokens issued to other users will typically\ninvolve issuing large numbers of requests containing invalid tokens,\nleaving a noticeable mark in the application’s logs.\n■■ Brute-force attacks against session tokens are difficult to block altogether,\nbecause there is no particular user account or session that can be disabled\nto stop the attack. One possible action is to block source IP addresses for\na period when a number of requests containing invalid tokens have been\nreceived. However, this may be ineffective when one user’s requests orig-\ninate from multiple IP addresses (e.g., AOL users) or when multiple\nusers’ requests originate from the same IP address (e.g., users behind a\nproxy or a firewall performing network address translation).\n■■ Even if brute-force attacks against sessions cannot be effectively pre-\nvented in real time, keeping detailed logs and alerting administrators\nenables them to investigate the attack and take appropriate action\nwhere they are able to.\n■■ Wherever possible, users should be alerted to anomalous events relat-\ning to their session—for example, concurrent logins or apparent\nhijacking (detected using per-page tokens). Even though a compromise\nmay already have occurred, this enables the user to check whether any\nunauthorized actions such as funds transfers have taken place.\nReactive Session Termination\nThe session management mechanism can be leveraged as a highly effective\ndefense against many kinds of other attacks against the application. Some\ns ecurity-critical applications such as online banking are extremely aggressive in\nterminating a user’s session every time the user submits some anomalous\nrequest—for example, any request containing a modified hidden HTML form\nfield or URL query string parameter, any request containing strings associated\nwith SQL injection or cross-site scripting attacks, and any user input that would\nnormally have been blocked by client-side checks such as length restrictions.\nOf course, any actual vulnerabilities that may be exploited using such\nrequests need to be addressed at source. But forcing users to reauthenticate\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 213\nChapter 7 ■ Attacking Session Management 213\nevery time they submit an invalid request can slow down the process of prob-\ning the application for vulnerabilities by many orders of magnitude, even\nwhere automated techniques are employed. If residual vulnerabilities do still\nexist, they are far less likely to be discovered by anyone in the field.\nWhere this kind of defense is implemented, it is also recommended that it\ncan be easily switched off for testing purposes. If a legitimate penetration test\nof the application is slowed down in the same way as a real-world attacker,\nthen its effectiveness is dramatically reduced, and it is very likely that the pres-\nence of the mechanism will result in more vulnerabilities remaining in pro-\nduction code than if the mechanism were absent.\nHACK STEPS\nIf the application you are attacking uses this kind of defensive measure, you\nmay find that probing the application for many kinds of common vulnerability\nis extremely time-consuming, and the mind-numbing need to log in after each\nfailed test and renavigate to the point of the application you were looking at\nquickly leads you to give up.\nIn this situation, you can often use automation to tackle the problem. When\nusing Burp Intruder to perform an attack, you can use the Obtain Cookie\nfeature to perform a fresh login before sending each test case, and use the new\nsession token (provided that the login is single-stage). When browsing and\nprobing the application manually, you can use the extensibility features of Burp\nProxy via the IBurpExtenderinterface. You can create an extension which\ndetects when the application has performed a forced logout, automatically logs\nback in to the application, and returns the new session and page to the\nbrowser, optionally with a pop-up message to inform you of what has occurred.\nWhile this by no means removes the problem altogether, in certain cases it can\nmitigate it substantially.\nChapter Summary\nThe session management mechanism provides a rich source of potential vul-\nnerabilities for you to target when formulating your attack against an applica-\ntion. Because of its fundamental role in enabling the application to identify the\nsame user across multiple requests, a broken session management function\nusually provides the keys to the kingdom. Jumping into other users’ sessions\nis good; hijacking an administrator’s session is even better, and will typically\nenable you to compromise the entire application.\nYou can expect to encounter a wide range of defects in real-world session\nmanagement functionality. When bespoke mechanisms are employed, the\npossible weaknesses and avenues of attack may appear to be endless. The\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 214\n214 Chapter 7 ■ Attacking Session Management\nmost important lesson to draw from this topic is to be patient and determined.\nVery many session management mechanisms that appear to be robust on first\ninspection can be found wanting when analyzed closely. Deciphering the\nmethod which an application uses to generate its sequence of seemingly ran-\ndom tokens may take time and ingenuity. But given the reward, this is usually\nan investment well worth making.\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. You log in to an application and the server sets the following cookie:\nSet-cookie: sessid=amltMjM6MTI0MToxMTk0ODcwODYz;\nAn hour later, you log in again and receive the following:\nSet-cookie: sessid=amltMjM6MTI0MToxMTk0ODc1MTMy;\nWhat can you deduce about these cookies?\n2. An application employs six-character alphanumeric session tokens and\nfive-character alphanumeric passwords. Both are randomly generated\naccording to an unpredictable algorithm. Which of these is likely to be\nthe most worthwhile target for a brute force guessing attack? List all of\nthe different factors that may be relevant to your decision.\n3. You log in to an application at the following URL:\nhttps://foo.wahh-app.com/login/home.php\nand the server sets the following cookie:\nSet-cookie: sessionId=1498172056438227; domain=foo.wahh-\napp.com; path=/login; HttpOnly;\nYou then visit a range of other URLs. Which of the following will your\nbrowser submit the sessionIdcookie to? (Select all that apply.)\n(a) https://foo.wahh-app.com/login/myaccount.php\n(b) https://bar.wahh-app.com/login\n(c) https://staging.foo.wahh-app.com/login/home.php\n(d) http://foo.wahh-app.com/login/myaccount.php\n(e) http://foo.wahh-app.com/logintest/login.php\n(f) https://foo.wahh-app.com/logout\n(g) https://wahh-app.com/login/\n(h) https://xfoo.wahh-app.com/login/myaccount.php\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 215\nChapter 7 ■ Attacking Session Management 215\n4. The application you are targeting uses per-page tokens, in addition to\nthe primary session token. If a per-page token is received out of\nsequence, then the entire session is invalidated. Suppose that you dis-\ncover some defect that enables you to predict or capture the tokens\nissued to other users who are currently accessing the application. Are\nyou able to hijack their sessions?\n5. You log in to an application and the server sets the following cookie:\nSet-cookie: sess=ab11298f7eg14;\nWhen you click the logout button, this causes the following client-side\nscript to execute:\ndocument.cookie=”sess=”;\ndocument.location=”/“;\nWhat conclusion would you draw from this behavior?\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 216"
  },
  {
    "input": "What are the common types of access control vulnerabilities and how can they be exploited?",
    "summary": "Access controls are essential for determining whether users can perform actions or access resources. When they are broken, attackers can gain unauthorized access to sensitive data and functions. Common vulnerabilities include vertical and horizontal privilege escalation, where users can access resources they shouldn't and perform actions beyond their permissions. To secure access controls, developers should implement them consistently, validate all user inputs, and use a multi-layered approach that includes the application server, database, and operating system.",
    "output": "70779c08v6.5.qxd 9/14/07 3:18 PM Page 217\nCHAPTER\n8\nAttacking Access Controls\nWithin the application’s core security mechanisms, access controls are logi-\ncally built upon authentication and session management. So far, you have seen\nhow an application can first verify a user’s identity and then confirm that a\nparticular sequence of requests that it receives originated from the same user.\nThe primary reason that the application needs to do these things, in terms of\nsecurity at least, is because it needs a way of deciding whether it should per-\nmit a given request to perform its attempted action or access the resources that\nit is requesting. Access controls are a critical defense mechanism within the\napplication because they are responsible for making these key decisions.\nWhen they are defective, an attacker can often compromise the entire applica-\ntion, taking control of administrative functionality and accessing sensitive\ndata belonging to every other user.\nAs we noted in Chapter 1, broken access controls are among the most com-\nmonly encountered categories of web application vulnerability, affecting a\nmassive 78% of the applications recently tested by the authors. Somewhat\nincredibly, it is extremely common to encounter applications that go to all the\ntrouble of implementing robust mechanisms for authentication and session\nmanagement, only to squander that investment by neglecting to build any\neffective access controls upon them.\nAccess control vulnerabilities are conceptually very simple: the application\nis letting you do something you shouldn’t be able to. The differences between\nseparate flaws really come down to the different ways in which this core defect\n217\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 218\n218 Chapter 8 ■ Attacking Access Controls\nis manifested, and the different techniques you need to employ to detect it. We\nwill describe all of these techniques, showing how you can exploit different\nkinds of behavior within an application to perform unauthorized actions and\naccess protected data.\nCommon Vulnerabilities\nAccess controls can be divided into two broad categories: vertical and horizontal.\nVertical access controls allow different types of users to access different\nparts of the application’s functionality. In the simplest case, this typically\ninvolves a division between ordinary users and administrators. In more com-\nplex cases, vertical access controls may involve fine-grained user roles grant-\ning access to specific functions, with each user being allocated to a single role,\nor a combination of different roles.\nHorizontal access controls allow users to access a certain subset of a wider\nrange of resources of the same type. For example, a web mail application may\nallow you to read your email but no one else’s; an online bank may let you\ntransfer money out of your account only; and a workflow application may\nallow you to update tasks assigned to you but only read tasks assigned to\nother people.\nIn many cases, vertical and horizontal access controls are intertwined. For\nexample, an enterprise resource planning application may allow each accounts\npayable clerk to pay invoices for a specific organizational unit and no other. The\naccounts payable manager, on the other hand, may be allowed to pay invoices\nfor any unit. Similarly, clerks may be able to pay invoices for small amounts,\nwhile larger invoices must be paid by the manager. The finance director may be\nable to view invoice payments and receipts for every organizational unit in the\ncompany but may not be permitted to pay any invoices at all.\nAccess controls are broken if any user is able to access functionality or\nresources for which he is not authorized. There are two main types of attack\nagainst access controls, corresponding to the two categories of control:\n■■ Vertical privilege escalationoccurs when a user can perform functions\nthat their assigned role does not permit them to. For example, if an\nordinary user can perform administrative functions or a clerk is able to\npay invoices of any size, then access controls are broken.\n■■ Horizontal privilege escalationoccurs when a user can view or modify\nresources to which he is not entitled. For example, if you can use a web\nmail application to read other people’s email, or if a payment clerk can\nprocess invoices for an organizational unit other than his own, then\naccess controls are broken.\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 219\nChapter 8 ■ Attacking Access Controls 219\nIt is common to find cases where a vulnerability in the application’s hori-\nzontal separation of privileges can lead immediately to a vertical escalation\nattack. For example, if a user finds a way to set a different user’s password,\nthen the user can attack an administrative account and take control of the\napplication.\nIn the cases described so far, broken access controls enable users who have\nauthenticated themselves to the application in a particular user context to per-\nform actions or access data for which that context does not authorize them.\nHowever, in the most serious cases of broken access control, it may be possible\nfor completely unauthorized users to gain access to functionality or data that\nis intended to be accessed only by privileged authenticated users.\nCompletely Unprotected Functionality\nIn many cases of broken access controls, sensitive functionality and resources\ncan be accessed by anyone who knows the relevant URL. For example, there\nare many applications in which anyone who visits a specific URL is able to\nmake full use of its administrative functions:\nhttps://wahh-app.com/admin/\nIn this situation, the application typically enforces access control only to the\nfollowing extent: users who have logged in as administrators see a link to this\nURLon their user interface, while other users do not. This cosmetic difference\nis the only mechanism in place to “protect” the sensitive functionality from\nunauthorized use.\nSometimes, the URL that grants access to powerful functions may be less\neasy to guess, and may even be quite cryptic, for example:\nhttps://wahh-app.com/menus/secure/ff457/DoAdminMenu2.jsp\nHere, access to administrative functions is protected by the assumption that\nan attacker will not know or discover this URL. The application is harder for a\ncomplete outsider to compromise, because they are less likely to guess the\nURLby which they can do so.\nCOMMON MYTH “No low-privileged users will know that URL. We don’t\nreference it anywhere within the application.”\nIn the example just described, the absence of any genuine access control still\nconstitutes a serious vulnerability, regardless of how easy it would be to guess\nthe URL. URLs do not have the status of secrets, either within the application\nitself or in the hands of its users. They are displayed on-screen, and appear in\nbrowser histories and the logs of web servers and proxy servers. Users may write\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 220\n220 Chapter 8 ■ Attacking Access Controls\nthem down, bookmark them, or email them around. They are not normally\nchanged periodically, as passwords should be. When users change job roles, and\ntheir access to administrative functionality needs to be withdrawn, there is no\nway to delete their knowledge of a particular URL.\nIn some applications where sensitive functionality is hidden behind URLs\nthat are not trivial to guess, an attacker may often be able to identify these via\nclose inspection of client-side code. Many applications use JavaScript to build\nthe user interface dynamically within the client. This typically works by set-\nting various flags regarding the user’s status, and then adding individual ele-\nments to the UI on the basis of these. For example:\nvar isAdmin = false;\n...\nif (isAdmin)\n{\nadminMenu.addItem(“/menus/secure/ff457/addNewPortalUser2.jsp”,\n“create a new user”);\n}\nHere, an attacker can simply review the JavaScript to identify URLs for\nadministrative functionality and attempt to access these. In other cases, HTML\ncomments may contain references to or clues about URLs that are not linked\nfrom on-screen content. See Chapter 4 for a discussion of the various tech-\nniques by which an attacker can gather information about hidden content\nwithin the application.\nIdentifier-Based Functions\nWhen a function of an application is used to gain access to a specific resource,\nit is very common to see an identifier for the requested resource being passed\nto the server in a request parameter, either within the URLquery string or the\nbody of a POST request. For example, an application may use the following\nURLto display a specific document belonging to a particular user:\nhttps://wahh-app.com/ViewDocument.php?docid=1280149120\nWhen the user who owns the document is logged in, a link to this URLis\ndisplayed on the user’s My Documents page. Other users do not see the link.\nHowever, if access controls are broken, then any user who requests the rele-\nvant URLmay be able to view the document in exactly the same way as the\nauthorized user.\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 221\nChapter 8 ■ Attacking Access Controls 221\nTIP This type of vulnerability often arises when the main application is\ninterfacing to an external system or back-end component. It can be difficult to\nshare a session-based security model between different systems that may be\nbased on diverse technologies. Faced with this problem, developers frequently\ntake a shortcut and move away from that model, using client-submitted\nparameters to make access control decisions.\nIn this example, an attacker seeking to gain unauthorized access needs to\nknow not only the name of the application page (ViewDocument.php) but also\nthe identifier of the document he wishes to view. Sometimes, resource identi-\nfiers are generated in a highly unpredictable manner—for example, they may\nbe randomly chosen GUIDs. In other cases, they may be easily guessed—for\nexample, they may be sequentially generated numbers. However, the applica-\ntion is vulnerable in both cases. As described previously, URLs do not have the\nstatus of secrets, and the same applies to resource identifiers. Often, an\nattacker wishing to discover the identifiers of other users’ resources will find\nsome location within the application that discloses these, such as access logs.\nEven where an application’s resource identifiers cannot be easily guessed, it is\nstill vulnerable if it fails to properly control access to those resources. In cases\nwhere the identifiers are easily predicted, the problem is even more serious\nand more easily exploited.\nTIP Application logs are often a gold mine of information, and may contain\nnumerous items of data that can be used as identifiers to probe functionality\nthat is accessed in this way. Identifiers commonly found within application logs\ninclude: usernames, user ID numbers, account numbers, document IDs, user\ngroups and roles, and email addresses.\nNOTE In addition to being used as references to data-based resources\nwithin the application, this kind of identifier is also often used to refer to\nfunctions of the application itself. As you saw in Chapter 4, an application may\ndeliver different functions via a single page, which accepts a function name or\nidentifier as a parameter. Again in this situation, access controls may run no\ndeeper than the presence or absence of specific URLs within the interfaces\nof different types of user. If an attacker can determine the identifier for a\nsensitive function, he may be able to access it in just the same way as a\nmore privileged user.\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 222\n222 Chapter 8 ■ Attacking Access Controls\nMultistage Functions\nMany kinds of functions within an application are implemented across several\nstages, involving multiple requests being sent from the client to the server. For\nexample, a function to add a new user may involve choosing this option from\na user maintenance menu, selecting the department and user role from drop-\ndown lists, and then entering the new username, initial password, and other\ninformation.\nIt is common to encounter applications in which efforts have been made to\nprotect this kind of sensitive functionality from unauthorized access but where\nthe access controls employed are broken because of flawed assumptions about\nthe ways in which the functionality will be used.\nIn the previous example, when a user attempts to load the user maintenance\nmenu, and chooses the option to add a new user, the application may verify\nthat the user has the required privileges, and block access if the user does not.\nHowever, if an attacker proceeds directly to the stage of specifying the user’s\ndepartment and other details, there may be no effective access control. The\ndevelopers unconsciously assumed that any user who reaches the later stages\nof the process must have the relevant privileges because this was verified at\nthe earlier stages. The result is that any user of the application can add a new\nadministrative user account, and thereby take full control of the application,\ngaining access to many other functions whose access control is intrinsically\nrobust.\nThe authors have encountered this type of vulnerability even in the most\nsecurity-critical web applications, those deployed by online banks. Making a\nfunds transfer in a banking application typically involves multiple stages,\npartly to prevent users from accidentally making mistakes when requesting a\ntransfer. This multistage process involves capturing different items of data\nfrom the user at each stage. This data is strictly checked when first submitted\nand then is usually passed to each subsequent stage, using hidden fields in an\nHTMLform. However, if the application does not revalidate all of this data at\nthe final stage, then an attacker can potentially bypass the server’s checks. For\nexample, the application might verify that the source account selected for the\ntransfer belongs to the current user and then ask for details about the destina-\ntion account and the amount of the transfer. If a user intercepts the final POST\nrequest of this process and modifies the source account number, she can exe-\ncute a horizontal privilege escalation and transfer funds out of an account\nbelonging to a different user.\nStatic Files\nIn the majority of cases, users gain access to protected functionality and\nresources by issuing requests to dynamic pages that execute on the server. It is\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 223\nChapter 8 ■ Attacking Access Controls 223\nthe responsibility of each such page to perform suitable access control checks,\nand confirm that the user has the relevant privileges to perform the action that\nthey are attempting.\nHowever, in some cases, requests for protected resources are made directly\nto the static resources themselves, which are located within the web root of the\nserver. For example, an online publisher may allow users to browse its book\ncatalog and purchase ebooks for download. Once payment has been made, the\nuser is directed to a download URLlike the following:\nhttps://wahh-books.com/download/0636628104.pdf\nBecause this is a completely static resource, it does not execute on the server,\nand its contents are simply returned directly by the web server. Hence, the\nresource itself cannot implement any logic to verify that the requesting user\nhas the required privileges. When static resources are accessed in this way, it is\nhighly likely that there are no effective access controls protecting them and\nthat anyone who knows the URLnaming scheme can exploit this to access any\nresources they desire. In the present case, the document name looks suspi-\nciously like an ISBN, which would enable an attacker to quickly download\nevery ebook produced by the publisher!\nCertain types of functionality are particularly prone to this kind of problem,\nincluding financial web sites providing access to static documents about com-\npanies such as annual reports, software vendors who provide downloadable\nbinaries, and administrative functionality that provides access to static log\nfiles and other sensitive data collected within the application.\nInsecure Access Control Methods\nSome applications employ a fundamentally insecure access control model in\nwhich access control decisions are made on the basis of request parameters\nsubmitted by the client. In some versions of this model, the application deter-\nmines a user’s role or access level at the time of login and from this point\nonwards transmits this information via the client in a hidden form field,\ncookie, or preset query string parameter (see Chapter 5). When each subse-\nquent request is processed, the application reads this request parameter and\ndecides what access to grant the user accordingly.\nFor example, an administrator using the application may see URLs like the\nfollowing:\nhttps://wahh-app.com/login/home.jsp?admin=true\nwhile the URLs seen by ordinary users contain a different parameter, or none\nat all. Any user who is aware of the parameter assigned to administrators can\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 224\n224 Chapter 8 ■ Attacking Access Controls\nsimply set it in his own requests and thereby gain access to administrative\nfunctions.\nThis type of access control may sometimes be difficult to detect without\nactually using the application as a high-privileged user and identifying what\nrequests are made. The techniques described in Chapter 4 for discovering hid-\nden request parameters may be successful in discovering the mechanism\nwhen working only as an ordinary user.\nIn other unsafe access control models, the application uses the HTTP\nRefererheader as the basis for making access control decisions. For example,\nan application may strictly control access to the main administrative menu,\nbased on a user’s privileges. But when a user makes a request for an individ-\nual administrative function, the application may simply check whether this\nrequest was referred from the administrative menu page and assume that, if\nso, then the user must have accessed that page and so have the required priv-\nileges. This model is fundamentally broken, of course, because the Referer\nheader is completely within the control of the user and can be set to any value\nat all.\nAttacking Access Controls\nBefore starting to probe the application to detect any actual access control vul-\nnerabilities, you should take a moment to review the results of your applica-\ntion mapping exercises (see Chapter 4), to understand what the application’s\nactual requirements are in terms of access control, and therefore where it will\nprobably be most fruitful to focus your attention.\nHACK STEPS\nQuestions to consider when examining an application’s access controls include:\n■ Do application functions give individual users access to a particular sub-\nset of data that belongs to them?\n■ Are there different levels of user, such as managers, supervisors, guests,\nand so on, who are granted access to different functions?\n■ Do administrators use functionality that is built into the same application\nin order to configure and monitor it?\n■ What functions or data resources within the application have you\nidentified that would most likely enable you to escalate your current\nprivileges?\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 225\nChapter 8 ■ Attacking Access Controls 225\nThe easiest and most effective way to test the effectiveness of an applica-\ntion’s access controls is to access the application using different accounts, and\ndetermine whether resources and functionality that can be accessed legiti-\nmately by one account can be accessed illegitimately by another.\nHACK STEPS\n■ If the application segregates user access to different levels of functional-\nity, first use a powerful account to locate all of the available functionality\nand then attempt to access this using a lower-privileged account.\n■ If the application segregates user access to different resources (such as\ndocuments), use two different user-level accounts to test whether access\ncontrols are effective or whether horizontal privilege escalation is possi-\nble. Find a document that can be legitimately accessed by one user but\nnot by another, and attempt to access it using the second user’s\naccount—either by requesting the relevant URL or by submitting the\nsame POSTparameters from within the second user’s session.\n■ It may be possible to automate some of this testing by running a spider-\ning tool twice or more against the application, using a different user con-\ntext each time, and also in an unauthenticated context. To do this, run\nthe spider first as an administrator, and then obtain a session token for a\nlower-privileged user and resubmit the same linksbut replace the privi-\nleged session token with the lower-privileged token.\n■ If a spidering session running as an ordinary user discovers privileged\nfunctions to which only administrators should have access, then this may\nrepresent a vulnerability. Note, however, that the effectiveness of this\nmethod depends upon the exact behavior of the application: some appli-\ncations provide all users with the same navigation links and return an\n“access denied” message (in an HTTP 200 response) when an unautho-\nrized function is requested.\nIf you have only one user-level account with which to access the application\n(or none at all), then additional work needs to be done to test the effectiveness\nof access controls. In fact, to perform a fully comprehensive test, further work\nneeds to be done in any case, because poorly protected functionality may exist\nthat is not explicitly linked from the interface of any application user—for\nexample, old functionality that has not yet been removed, or new functionality\nthat has been deployed but has not yet been published to users.\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 226\n226 Chapter 8 ■ Attacking Access Controls\nHACK STEPS\n■ Use the content discovery techniques described in Chapter 4 to identify\nas much of the application’s functionality as possible. Performing this\nexercise as a low-privileged user is often sufficient to both enumerate\nand gain direct access to sensitive functionality.\n■ Where application pages are identified that are likely to present different\nfunctionality or links to ordinary and administrative users (for example, a\nControl Panel or My Home Page), try adding parameters like admin=true\nto the URL query string and the body of POSTrequests, to determine\nwhether this uncovers or gives access to any additional functionality than\nyour user context has normal access to.\n■ Test whether the application uses the Refererheader as the basis for\nmaking access control decisions. For key application functions that you\nare authorized to access, try removing or modifying the Refererheader\nand determine whether your request is still successful. If not, the appli-\ncation may be trusting the Refererheader in an unsafe way.\n■ Review all client-side HTML and scripts to find references to hidden func-\ntionality or functionality that can be manipulated on the client side, such\nas script-based user interfaces.\nOnce all accessible functionality has been enumerated, it is necessary to test\nwhether per-user segregation of access to resources is being correctly enforced.\nIn every instance where the application grants users access to a subset of a\nwider range of resources of the same type (such as documents, orders, emails,\nand personal details), there may be opportunities for one user to gain unau-\nthorized access to other resources.\nHACK STEPS\n■ Where the application uses identifiers of any kind (document IDs,\naccount numbers, order references, etc.) to specify which resource a user\nis requesting, attempt to discover the identifiers for resources to which\nyou do not have authorized access.\n■ If it is possible to generate a series of such identifiers in quick succession\n(for example, by creating multiple new documents or orders), use the same\ntechniques as were described in Chapter 8 for session tokens, to try to dis-\ncover any predictable sequences in the identifiers the application produces.\n■ If it is not possible to generate any new identifiers, then you are\nrestricted to analyzingthe identifiers that you have already discovered,\nor even using plain guesswork. If the identifier has the form of a GUID, it\nis unlikely that any attempts based on guessing will be successful. How-\never, if it is a relatively small number, try other numbers in close range,\nor random numbers with the same number of digits.\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 227\nChapter 8 ■ Attacking Access Controls 227\nHACK STEPS (continued)\n■ If access controls are found to be broken, and resource identifiers are\nfound to be predictable, you can mount an automated attack to harvest\nsensitive resources and information from the application. Use the tech-\nniques described in Chapter 13 to design a bespoke automated attack to\nretrieve the data you require.\nA catastrophic vulnerability of this kind occurs where an Account\nInformation page displays a user’s personal details together with his\nusername and password. While the password is typically masked on-screen,\nit is nevertheless transmitted in full to the browser. Here, you can often\nquickly iterate through the full range of account identifiers to harvest the\nlogin credentials of all users, including administrators. The following example\nshows Burp Intruder being used to carry out a successful attack of this kind.\nTIP When you have detected an access control vulnerability, an immediate\nattack to follow up with is to attempt to escalate your privileges further by\ncompromising a user account with administrative privileges. There are various\ntricks you can use in trying to locate an administrative account. Using an\naccess control flaw like the one illustrated, you may harvest hundreds of user\ncredentials and not relish the task of logging in manually as every user until an\nadministrator is found. However, when accounts are identified by a sequential\nnumeric ID, it is very common to find that the lowest account numbers are\nassigned to administrators. Logging in as the first few users who were\nregistered with the application will often identify an administrator. If this\napproach fails, an effective method is to find a function within the application\nwhere access is properly segregated horizontally—for example, the main home\npage presented to each user. Write a script to log in using each set of captured\ncredentials, and then try to access your own home page. It is likely that\nadministrative users are able to view the home page of every user, so you will\nimmediately detect when an administrative account is being used.\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 228\n228 Chapter 8 ■ Attacking Access Controls\nIn every instance where an application superficially appears to be enforcing\naccess controls effectively, you should probe further to determine whether any\ndefective assumptions have been made by developers.\nHACK STEPS\n■ Where an action is carried out in a multistep way, involving several dif-\nferent requests from client to server, test each request individually to\ndetermine whether access controls have been applied to it.\n■ Try to find any locations where the application is effectively assuming that\nif you have reached a particular point, then you must have arrived via legiti-\nmate means. Try to reach that point in other ways using a lower-privileged\naccount, to detect if any privilege escalation attacks are possible.\nIn cases where static resources that the application is protecting are ulti-\nmately accessed directly via URLs to the resource files themselves, you should\ntest whether it is possible for unauthorized users to simply request these URLs\ndirectly.\nHACK STEPS\n■ Step through the normal process for gaining access to a protected static\nresource, to obtain an example of the URL by which it is ultimately\nretrieved.\n■ Using a different user context (for example, a less-privileged user or an\naccount that has not made a required purchase), attempt to access the\nresource directly using the URL you have identified.\n■ If this attack succeeds, try to understand the naming scheme being used\nfor protected static files. If possible, construct an automated attack to\ntrawl for content that may be useful or contain sensitive data (see\nChapter 13).\nSecuring Access Controls\nAccess controls are one of the easiest areas of web application security to\nunderstand, although a well-informed, thorough methodology must be care-\nfully applied when implementing them.\nFirst, there are several obvious pitfalls to avoid. These usually arise from\nignorance about the essential requirements of effective access control or\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 229\nChapter 8 ■ Attacking Access Controls 229\nflawed assumptions about the kinds of requests that users will make and\nagainst which the application needs to defend itself:\n■■ Do not rely on users’ ignorance of application URLs or the identifiers\nused to specify application resources, such as account numbers and\ndocument IDs. Explicitly assume that users know every application\nURLand identifier, and ensure that the application’s access controls\nalone are sufficient to prevent unauthorized access.\n■■ Do not trust any user-submitted parameters to signify access rights\n(such as admin=true).\n■■ Do not assume that users will access application pages in the intended\nsequence. Do not assume that because users cannot access the Edit\nUsers page, they will not be able to reach the Edit User X page that is\nlinked from it.\n■■ Do not trust the user not to tamper with any data that is transmitted via\nthe client. If some user-submitted data has been validated and is then\ntransmitted via the client, do not rely upon the retransmitted value\nwithout revalidation.\nThe following represents a best-practice approach to implementing effective\naccess controls within web applications:\n■■ Explicitly evaluate and document the access control requirements for\nevery unit of application functionality. This needs to include both who\ncan legitimately use the function and what resources individual users\nmay access via the function.\n■■ Drive all access control decisions from the user’s session.\n■■ Use a central application component to check access controls.\n■■ Process every single client request via this component, to validate that\nthe user making the request is permitted to access the functionality and\nresources being requested.\n■■ Use programmatic techniques to ensure that there are no exceptions to\nthe previous point. An effective approach is to mandate that every\napplication page must implement an interface that is queried by the\ncentral access control mechanism. By forcing developers to explicitly\ncode access control logic into every page, there can be no excuse for\nomissions.\n■■ For particularly sensitive functionality, such as administrative pages,\nyou can further restrict access by IPaddress, to ensure that only users\nfrom a specific network range are able to access the functionality,\nregardless of their login status.\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 230\n230 Chapter 8 ■ Attacking Access Controls\n■■ If static content needs to be protected, there are two methods of provid-\ning access control. First, static files can be accessed indirectly by passing\na file name to a dynamic server-side page which implements relevant\naccess control logic. Second, direct access to static files can be controlled\nusing HTTPauthentication or other features of the application server to\nwrap the incoming request and check the permissions for the resource\nbefore granting access.\n■■ Identifiers specifying which resource a user wishes to access are vulner-\nable to tampering whenever they are transmitted via the client. The\nserver should trust only the integrity of server-side data. Any time\nthese identifiers are transmitted via the client, they need to be revali-\ndated to ensure the user is authorized to access the requested resource.\n■■ For security-critical application functions such as the creation of a\nnew bill payee in a banking application, consider implementing per-\ntransaction reauthentication and dual authorization to provide addi-\ntional assurance that the function is not being used by an unauthorized\nparty. This will also mitigate the consequences of other possible attacks,\nsuch as session hijacking.\n■■ Log every event where sensitive data is accessed or a sensitive action is\nperformed. These logs will enable potential access control breaches to\nbe detected and investigated.\nWeb application developers often implement access control functions on a\npiecemeal basis, adding code to individual pages in cases where they register\nthat some access control is required, and often cutting and pasting the same\ncode between pages to implement similar requirements. This approach carries\nan inherent risk of defects in the resulting access control mechanism: many\ncases are overlooked where controls are required, controls designed for one\narea may not operate in the intended way in another area, and modifications\nmade elsewhere within the application may break existing controls by violat-\ning assumptions made by them.\nIn contrast to this approach, the previously described method of using a cen-\ntral application component to enforce access controls has many benefits:\n■■ It increases the clarity of access controls within the application,\nenabling different developers to quickly understand the controls imple-\nmented by others.\n■■ It makes maintainability more efficient and reliable. Most changes will\nonly need to be applied once, to a single shared component, and will\nnot need to be cut and pasted to multiple locations.\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 231\nChapter 8 ■ Attacking Access Controls 231\n■■ It improves adaptability. Where new access control requirements arise,\nthese can be easily reflected within an existing API implemented by\neach application page.\n■■ It results in fewer mistakes and omissions than if access control code is\nimplemented piecemeal throughout the application.\nA Multi-Layered Privilege Model\nIssues relating to access apply not only to the web application itself but also to\nthe other infrastructure tiers which lie beneath it—in particular, the applica-\ntion server, the database, and the operating system. Taking a defense-in-depth\napproach to security entails implementing access controls at each of these lay-\ners to create several layers of protection. This provides greater assurance\nagainst threats of unauthorized access, because if an attacker succeeds in com-\npromising defenses at one layer, the attack may yet be blocked by defenses at\nanother layer.\nIn addition to implementing effective access controls within the web appli-\ncation itself, as already described, a multi-layered approach can be applied in\nvarious ways to the components which underlie the application, for example:\n■■ The application server can be used to control access to entire URL\npaths, on the basis of user roles that are defined at the application\nserver tier.\n■■ The application can employ a different database account when carrying\nout the actions of different users. For users who should only be query-\ning (and not updating) data, an account with read-only privileges\nshould be used.\n■■ Fine-grained control over access to different database tables can be\nimplemented within the database itself, using a table of privileges.\n■■ The operating system accounts used to run each component in the\ninfrastructure can be restricted to the least powerful privileges that the\ncomponent actually requires.\nIn a complex security-critical application, layered defenses of this kind can\nbe devised with the help of a matrix defining the different user roles within the\napplication and the different privileges, at each tier, that should be assigned to\neach role. Figure 8-1 is a partial example of a privilege matrix for a complex\napplication.\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 232\n232 Chapter 8 ■ Attacking Access Controls\nFigure8-1: Example of a privilege matrix for a complex application\nWithin a security model of this kind, you can see how various useful access\ncontrol concepts can be applied:\n■■ Programmatic control—The matrix of individual database privileges\nis stored in a table within the database, and applied programmatically\nto enforce access control decisions. The classification of user roles pro-\nvides a shortcut for applying certain access control checks, and this is\nalso applied programmatically. Programmatic controls can be extremely\nfine-grained and can build in arbitrarily complex logic into the process\nof carrying out access control decisions within the application.\n■■ Discretionary access control (DAC) —Administrators are able to dele-\ngate their privileges to other users in relation to specific resources that\nthey own, employing discretionary access control. This is a closed DAC\nmodel, in which access is denied unless explicitly granted. Administra-\ntors are also able to lock or expire individual user accounts. This is an\nopen DACmodel, in which access is permitted unless explicitly with-\ndrawn. Various application users have privileges to create user\naccounts, again applying discretionary access control.\n■■ Role-based access control (RBAC)—There are named roles, which\ncontain different sets of specific privileges, and each user is assigned to\none of these roles. This serves as a shortcut for assigning and enforcing\ndifferent privileges and is necessary to help manage access control in\ncomplex applications. Using roles to perform upfront access checks on\nuser requests enables many unauthorized requests to be quickly\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 233\nChapter 8 ■ Attacking Access Controls 233\nrejected with a minimum amount of processing being performed. An\nexample of this approach is in protecting the URLpaths that specific\ntypes of user may access.\nWhen designing role-based access control mechanisms, it is necessary to\nbalance the number of roles so that they remain a useful tool to assist in\nthe management of privileges within the application. If too many fine-\ngrained roles are created, then the number of different roles becomes\nunwieldy, and they are difficult to manage accurately. If too few roles are\ncreated, the resulting roles will be a coarse instrument for managing\naccess, and it is likely that individual users will be assigned privileges\nthat are not strictly necessary for performance of their function.\n■■ Declarative control—The application uses restricted database\naccounts when accessing the database. It employs different accounts\nfor different groups of users, with each account having the least level of\nprivilege necessary for carrying out the actions which that group is per-\nmitted to perform. Declarative controls of this kind are declared from\noutside the application. This is a very useful application of defense-in-\ndepth principles, because privileges are being imposed on the applica-\ntion by a different component. Even if a user finds a means of breaching\nthe access controls implemented within the application tier, so as to\nperform a sensitive action such as adding a new user, they will be pre-\nvented from doing so because the database account that they are using\ndoes not have the required privileges within the database.\nAdifferent means of applying declarative access control exists at the\napplication server level, via deployment descriptor files, which are\napplied during application deployment. However, these can be rela-\ntively blunt instruments and do not always scale well to manage fine-\ngrained privileges in a large application.\nHACK STEPS\nIf you are attacking an application that employs a multi-layered privilege model\nof this kind, it is likely that many of the most obvious mistakes that are\ncommonly made in applying access controls will be defended against. You may\nfind that circumventing the controls implemented within the application does\nnot get you very far, because of protection in place at other layers. With this in\nmind, there are still several potential lines of attack available to you. Most\nimportantly, understanding the limitations of each type of control, in terms of\nthe protection that it does not offer, will help to you identify the vulnerabilities\nthat are most likely to affect it:\n■ Programmatic checks within the application layer may be susceptible to\ninjection-based attacks.\n(continued)\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 234\n234 Chapter 8 ■ Attacking Access Controls\nHACK STEPS (continued)\n■ Roles defined at the application server layer are often coarsely defined\nand may be incomplete.\n■ Where application components run using low-privileged operating sys-\ntem accounts, these are still typically able to read many kinds of poten-\ntially sensitive data within the host file system. Any vulnerabilities\ngranting arbitrary file access may still be usefully exploited.\n■ Vulnerabilities within the application server software itself will typically\nenable you to defeat all access controls implemented within the applica-\ntion layer, but you may still have limited access to the database and\noperating system.\n■ A single exploitable access control vulnerability in the right location may\nstill provide a starting point for serious privilege escalation. For example,\nif you discover a way to modify the role associated with your account,\nthen you may find that logging in again with that account gives you\nenhanced access at both the application and database layers.\nChapter Summary\nAccess control defects can manifest themselves in various ways. In some cases,\nthey may be uninteresting, allowing illegitimate access to a harmless function\nthat cannot be leveraged to escalate privileges any further. In other cases, find-\ning a weakness in access controls can quickly lead to a complete compromise\nof the application.\nFlaws in access control can arise from various sources: a poor application\ndesign may make it difficult or impossible to check for unauthorized access, a\nsimple oversight may leave only one or two functions unprotected, or defec-\ntive assumptions about the way users will behave can leave the application\nundefended when those assumptions are violated.\nIn many cases, finding a break in access controls is almost trivial—you sim-\nply request a common administrative URLand gain direct access to the func-\ntionality. In other cases, it may be very hard, and subtle defects may lurk deep\nwithin application logic, particularly in complex, high-security applications.\nThe most important lesson when attacking access controls is to look every-\nwhere. If you are struggling to make progress, be patient and test every single\nstep of every application function. A bug that allows you to own the entire\napplication may be just around the corner."
  },
  {
    "input": "What are some common weaknesses in access controls that web applications may have?",
    "summary": "The chapter discusses testing for weaknesses in access controls, such as the use of the HTTPReferer header, and how to verify if an application uses parameters like uid in a potentially unsafe manner. It also explores the limitations of using IP addresses for access control and highlights the importance of implementing proper security measures in applications that lack authentication or session handling. Finally, it notes that files with the .xls extension containing sensitive information should raise concerns due to their potential for unauthorized access.",
    "output": "70779c08v6.5.qxd 9/14/07 3:18 PM Page 235\nChapter 8 ■ Attacking Access Controls 235\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. An application may use the HTTPRefererheader to control access\nwithout any overt indication of this in its normal behavior. How can\nyou test for this weakness?\n2. You log in to an application and are redirected to the following URL:\nhttps://wahh-app.com/MyAccount.php?uid=1241126841\nThe application appears to be passing a user identifier to the\nMyAccount.phppage. The only identifier you are aware of is your\nown. How can you test whether the application is using this\nparameter to enforce access controls in an unsafe way?\n3. Aweb application on the Internet enforces access controls by examining\nusers’ source IPaddresses. Why is this behavior potentially flawed?\n4. An application’s sole purpose is to provide a searchable repository of\ninformation for use by members of the public. There are no authentica-\ntion or session-handling mechanisms. What access controls should be\nimplemented within the application?\n5. You are browsing an application and encounter several sensitive\nresources that ought to be protected from unauthorized access, and that\nhave the .xlsfile extension. Why should these immediately catch your\nattention?\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 236"
  }
]