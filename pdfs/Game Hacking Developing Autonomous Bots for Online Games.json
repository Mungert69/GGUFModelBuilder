[
  {
    "input": "Blank Page",
    "output": "Game HackinG\nG A M E\nH A C K I N G\nDeveloping Autonomous\nBots for Online Games\nby Nick Cano\nSan Francisco\nGame HackinG. Copyright © 2016 by Nick Cano.\nAll rights reserved. No part of this work may be reproduced or transmitted in any form or by any means,\nelectronic or mechanical, including photocopying, recording, or by any information storage or retrieval\nsystem, without the prior written permission of the copyright owner and the publisher.\nPrinted in USA\nFirst printing\n20 19 18 17 16 1 2 3 4 5 6 7 8 9\nISBN-10: 1-59327-669-9\nISBN-13: 978-1-59327-669-0\nPublisher: William Pollock\nProduction Editor: Laurel Chun\nCover Illustration: Ryan Milner\nInterior Design: Octopod Studios\nDevelopmental Editor: Jennifer Griffith-Delgado\nTechnical Reviewer: Stephen Lawler\nCopyeditor: Rachel Monaghan\nCompositor: Laurel Chun\nProofreader: Paula L. Fleming\nIndexer: BIM Creatives, LLC\nFor information on distribution, translations, or bulk sales, please contact No Starch Press, Inc. directly:\nNo Starch Press, Inc.\n245 8th Street, San Francisco, CA 94103\nphone: 415.863.9900; info@nostarch.com\nwww.nostarch.com\nLibrary of Congress Cataloging-in-Publication Data\nCano, Nick, author.\nGame hacking : developing autonomous bots for online games / by Nick Cano.\npages cm\nIncludes index.\nSummary: \"A hands-on guide to hacking computer games. Shows programmers how to dissect computer\ngames and create bots to alter their gaming environment. Covers the basics of game hacking,\nincluding reverse engineering, assembly code analysis, programmatic memory manipulation, persistent\nhacks, responsive hacks, and code injection.\"-- Provided by publisher.\nISBN 978-1-59327-669-0 -- ISBN 1-59327-669-9\n1. Intelligent agents (Computer software) 2. Internet programming. 3. Internet games--\nProgramming. 4. Hacking. I. Title.\nQA76.76.I58C36 2016\n005.8--dc23\n2015036294\nNo Starch Press and the No Starch Press logo are registered trademarks of No Starch Press, Inc. Other\nproduct and company names mentioned herein may be the trademarks of their respective owners. Rather\nthan use a trademark symbol with every occurrence of a trademarked name, we are using the names only\nin an editorial fashion and to the benefit of the trademark owner, with no intention of infringement of the\ntrademark.\nThe information in this book is distributed on an “As Is” basis, without warranty. While every precaution\nhas been taken in the preparation of this work, neither the author nor No Starch Press, Inc. shall have any\nliability to any person or entity with respect to any loss or damage caused or alleged to be caused directly or\nindirectly by the information contained in it.\nabout the author\nNick Cano wrote his first scripts for open source game servers when he\nwas 12 and started a business selling his bots when he was 16. He has\nbeen a part of the game-hacking community ever since and advises game\ndevelopers and designers on best practices to protect their games against\nbots. Nick also has years of experience in detecting and defending against\nmalware, and he has spoken at many conferences about his research and\ntools.\nabout the Technical Reviewer\nStephen Lawler is the founder and president of a small computer software\nand security consulting firm. He has been actively working in information\nsecurity for over 10 years, primarily in reverse engineering, malware analy-\nsis, and vulnerability research. He was a member of the Mandiant malware\nanalysis team and assisted with high-profile computer intrusions affecting\nseveral Fortune 100 companies. Stephen also developed and teaches the\nPractical ARM Exploitation class, which has been offered at BlackHat and\nseveral other security conferences for the past five years.\nBrIEf CONtENts\nForeword by Dr. Jared DeMott............................................ xv\nAcknowledgments ....................................................xvii\nIntroduction.........................................................xix\nPART 1: TOOLS OF THE TRADE\nChapter 1: Scanning Memory Using Cheat Engine...............................3\nChapter 2: Debugging Games with OllyDbg..................................23\nChapter 3: Reconnaissance with Process Monitor and Process Explorer ...............49\nPART 2: GAME DISSECTION\nChapter 4: From Code to Memory: A General Primer............................65\nChapter 5: Advanced Memory Forensics ....................................97\nChapter 6: Reading from and Writing to Game Memory ........................119\nPART 3: PROCESS PUPPETEERING\nChapter 7: Code Injection..............................................133\nChapter 8: Manipulating Control Flow in a Game.............................149\nPART 4: CREATING BOTS\nChapter 9: Using Extrasensory Perception to Ward Off Fog of War ................189\nChapter 10: Responsive Hacks ..........................................203\nChapter 11: Putting It All Together: Writing Autonomous Bots .....................221\nChapter 12: Staying Hidden............................................245\nIndex ............................................................265\nCONtENts IN D E tAIl\nFORewORd by dr. Jared demott xv\nacknOwLedGmenTS xvii\ninTROducTiOn xix\nPrerequisites for the Reader............................................xx\nA Brief Game Hacking History..........................................xx\nWhy Hack Games? ................................................ xxi\nHow This Book Is Organized..........................................xxii\nAbout the Online Resources...........................................xxiv\nHow to Use This Book...............................................xxiv\nPaRT 1\nTOOLS OF THe TRade\n1\nScanninG memORy uSinG cHeaT enGine 3\nWhy Memory Scanners Are Important .................................... 4\nBasic Memory Scanning.............................................. 4\nCheat Engine’s Memory Scanner........................................ 5\nScan Types................................................. 6\nRunning Your First Scan........................................ 6\nNext Scans................................................. 7\nWhen You Can’t Get a Single Result............................... 7\nCheat Tables ............................................... 7\nMemory Modification in Games......................................... 8\nManual Modification with Cheat Engine ............................ 8\nTrainer Generator............................................ 9\nPointer Scanning .................................................. 11\nPointer Chains ............................................. 11\nPointer Scanning Basics....................................... 12\nPointer Scanning with Cheat Engine .............................. 14\nPointer Rescanning .......................................... 17\nLua Scripting Environment............................................ 18\nSearching for Assembly Patterns................................. 19\nSearching for Strings......................................... 21\nClosing Thoughts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n2\ndebuGGinG GameS wiTH OLLydbG 23\nA Brief Look at OllyDbg’s User Interface.................................. 24\nOllyDbg’s CPU Window............................................. 26\nViewing and Navigating a Game’s Assembly Code ................... 27\nViewing and Editing Register Contents............................. 29\nViewing and Searching a Game’s Memory ......................... 29\nViewing a Game’s Call Stack................................... 30\nCreating Code Patches.............................................. 31\nTracing Through Assembly Code ....................................... 32\nOllyDbg’s Expression Engine.......................................... 33\nUsing Expressions in Breakpoints ................................ 34\nUsing Operators in the Expression Engine .......................... 34\nWorking with Basic Expression Elements ........................... 35\nAccessing Memory Contents with Expressions ....................... 36\nOllyDbg Expressions in Action......................................... 36\nPausing Execution When a Specific Player’s Name Is Printed............. 37\nPausing Execution When Your Character’s Health Drops ............... 39\nOllyDbg Plug-ins for Game Hackers..................................... 42\nCopying Assembly Code with Asm2Clipboard....................... 42\nAdding Cheat Engine to OllyDbg with Cheat Utility.................... 42\nControlling OllyDbg Through the Command Line...................... 43\nVisualizing Control Flow with OllyFlow ............................ 45\nClosing Thoughts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n3\nRecOnnaiSSance wiTH PROceSS mOniTOR\nand PROceSS exPLOReR 49\nProcess Monitor................................................... 50\nLogging In-Game Events....................................... 50\nInspecting Events in the Process Monitor Log......................... 52\nDebugging a Game to Collect More Data .......................... 53\nProcess Explorer................................................... 55\nProcess Explorer’s User Interface and Controls ....................... 56\nExamining Process Properties ................................... 57\nHandle Manipulation Options................................... 59\nClosing Thoughts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61\nPaRT 2\nGame diSSecTiOn\n4\nFROm cOde TO memORy: a GeneRaL PRimeR 65\nHow Variables and Other Data Manifest in Memory ......................... 66\nNumeric Data.............................................. 67\nString Data................................................ 69\nData Structures............................................. 71\nx Contents in Detail\nUnions................................................... 73\nClasses and VF Tables........................................ 74\nx86 Assembly Crash Course.......................................... 78\nCommand Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79\nProcessor Registers .......................................... 81\nThe Call Stack ............................................. 86\nImportant x86 Instructions for Game Hacking........................ 89\nClosing Thoughts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96\n5\nadvanced memORy FORenSicS 97\nAdvanced Memory Scanning ......................................... 98\nDeducing Purpose........................................... 98\nFinding the Player’s Health with OllyDbg........................... 99\nDetermining New Addresses After Game Updates ................... 101\nIdentifying Complex Structures in Game Data ............................. 105\nThe std::string Class......................................... 105\nThe std::vector Class ........................................ 108\nThe std::list Class .......................................... 110\nThe std::map Class ......................................... 114\nClosing Thoughts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118\n6\nReadinG FROm and wRiTinG TO Game memORy 119\nObtaining the Game’s Process Identifier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120\nObtaining Process Handles ................................... 121\nWorking with OpenProcess() .................................. 121\nAccessing Memory................................................ 122\nWorking with ReadProcessMemory() and WriteProcessMemory() ......... 122\nAccessing a Value in Memory with ReadProcessMemory()\nand WriteProcessMemory() ................................ 123\nWriting Templated Memory Access Functions....................... 123\nMemory Protection................................................ 124\nDifferentiating x86 Windows Memory Protection Attributes ............. 125\nChanging Memory Protection.................................. 126\nAddress Space Layout Randomization .................................. 128\nDisabling ASLR to Simplify Bot Development........................ 128\nBypassing ASLR in Production.................................. 128\nClosing Thoughts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130\nPaRT 3\nPROceSS PuPPeTeeRinG\n7\ncOde inJecTiOn 133\nInjecting Code Caves with Thread Injection............................... 134\nCreating an Assembly Code Cave .............................. 134\nTranslating the Assembly to Shellcode ............................ 135\nContents in Detail xi\nWriting the Code Cave to Memory.............................. 136\nUsing Thread Injection to Execute the Code Cave.................... 137\nHijacking a Game’s Main Thread to Execute Code Caves .................... 138\nBuilding the Assembly Code Cave............................... 138\nGenerating Skeleton Shellcode and Allocating Memory................ 140\nFinding and Freezing the Main Thread ........................... 141\nInjecting DLLs for Full Control......................................... 142\nTricking a Process into Loading Your DLL .......................... 143\nAccessing Memory in an Injected DLL ............................ 145\nBypassing ASLR in an Injected DLL............................... 146\nClosing Thoughts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147\n8\nmaniPuLaTinG cOnTROL FLOw in a Game 149\nNOPing to Remove Unwanted Code ................................... 150\nWhen to NOP ............................................ 150\nHow to NOP ............................................. 151\nHooking to Redirect Game Execution ................................... 153\nCall Hooking ............................................. 153\nVF Table Hooking.......................................... 156\nIAT Hooking.............................................. 160\nJump Hooking............................................. 165\nApplying Call Hooks to Adobe AIR .................................... 169\nAccessing the RTMP Goldmine ................................. 169\nHooking the RTMPS encode() Function............................ 171\nHooking the RTMPS decode() Function............................ 172\nPlacing the Hooks.......................................... 173\nApplying Jump Hooks and VF Hooks to Direct3D........................... 175\nThe Drawing Loop.......................................... 176\nFinding the Direct3D Device................................... 177\nWriting a Hook for EndScene()................................. 182\nWriting a Hook for Reset() .................................... 183\nWhat’s Next?............................................. 184\nClosing Thoughts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185\nPaRT 4\ncReaTinG bOTS\n9\nuSinG exTRaSenSORy PeRcePTiOn TO waRd OFF\nFOG OF waR 189\nBackground Knowledge ............................................ 190\nRevealing Hidden Details with Lighthacks ................................ 190\nAdding a Central Ambient Light Source........................... 190\nIncreasing the Absolute Ambient Light ............................ 191\nCreating Other Types of Lighthacks.............................. 192\nxii Contents in Detail\nRevealing Sneaky Enemies with Wallhacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192\nRendering with Z-Buffering.................................... 193\nCreating a Direct3D Wallhack ................................. 194\nFingerprinting the Model You Want to Reveal....................... 196\nGetting a Wider Field of Vision with Zoomhacks........................... 197\nUsing NOPing Zoomhacks ................................... 197\nScratching the Surface of Hooking Zoomhacks...................... 198\nDisplaying Hidden Data with HUDs .................................... 198\nCreating an Experience HUD .................................. 199\nUsing Hooks to Locate Data ................................... 200\nAn Overview of Other ESP Hacks ..................................... 201\nClosing Thoughts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202\n10\nReSPOnSive HackS 203\nObserving Game Events............................................ 204\nMonitoring Memory ........................................ 204\nDetecting Visual Cues ....................................... 205\nIntercepting Network Traffic................................... 206\nPerforming In-Game Actions ......................................... 211\nEmulating the Keyboard...................................... 211\nSending Packets ........................................... 215\nTying the Pieces Together ........................................... 218\nMaking the Perfect Healer .................................... 218\nResisting Enemy Crowd-Control Attacks ........................... 218\nAvoiding Wasted Mana ..................................... 219\nClosing Thoughts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219\n11\nPuTTinG iT aLL TOGeTHeR:\nwRiTinG auTOnOmOuS bOTS 221\nControl Theory and Game Hacking .................................... 222\nState Machines .................................................. 223\nCombining Control Theory and State Machines............................ 225\nA Basic Healer State Machine ................................. 225\nA Complex Hypothetical State Machine........................... 228\nError Correction ........................................... 230\nPathfinding with Search Algorithms .................................... 232\nTwo Common Search Techniques ............................... 233\nHow Obstacles Disrupt Searches................................ 233\nAn A* Search Algorithm ..................................... 234\nWhen A* Searches Are Particularly Useful......................... 240\nCommon and Cool Automated Hacks................................... 241\nLooting with Cavebots....................................... 241\nAutomating Combat with Warbots .............................. 243\nClosing Thoughts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244\nContents in Detail xiii\n12\nSTayinG Hidden 245\nProminent Anti-Cheat Software........................................ 246\nThe PunkBuster Toolkit.............................................. 246\nSignature-Based Detection .................................... 246\nScreenshots .............................................. 247\nHash Validation ........................................... 247\nThe ESEA Anti-Cheat Toolkit ......................................... 247\nThe VAC Toolkit ................................................. 247\nDNS Cache Scans ......................................... 248\nBinary Validation .......................................... 248\nFalse Positives............................................. 248\nThe GameGuard Toolkit ............................................ 248\nUser-Mode Rootkit.......................................... 248\nKernel-Mode Rootkit ........................................ 249\nThe Warden Toolkit ............................................... 249\nCarefully Managing a Bot’s Footprint................................... 250\nMinimizing a Bot’s Footprint................................... 250\nMasking Your Footprint ...................................... 251\nTeaching a Bot to Detect Debuggers ............................. 251\nAnti-Debugging Techniques ................................... 255\nDefeating Signature-Based Detection ................................... 256\nDefeating Screenshots.............................................. 258\nDefeating Binary Validation.......................................... 259\nDefeating an Anti-Cheat Rootkit....................................... 261\nDefeating Heuristics ............................................... 262\nClosing Thoughts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263\nindex 265\nxiv Contents in Detail"
  },
  {
    "input": "Untitled",
    "output": "fOr E wOr D\nNick is great. We first hit it off in all the right and wrong ways, as you can\nimagine. I’ve been in the security field a while; he’s a little younger. I’ve had\nthe schooling, whereas he’s not much for college. I’m a faith guy, and he’s\nnot. The interesting thing is that none of that matters; we’ve had a blast\nanyway. Age, race, gender, degrees—when it comes to gaming, hacking, and\ncoding, no one cares!\nNick gets it done. He’s fun. He’s brilliant. He’s hard working. And prob-\nably most pertinent: he’s one of the rare few who understand the intersec-\ntion of gaming, hacking, and coding. He’s worked in this niche and created\nprofitable bots.\nIn this first-of-its-kind book, Nick walks you through what it means to\npull apart games. He teaches you the software investigation tools and tricks\nof the trade. You’ll learn about game internals, how to pull them apart, and\nhow to modify play. For example, Nick teaches how to avoid anti-cheat so\nthat you can automate play. Wouldn’t it be cool to have your own bot that\ncollects experience, gold, items, and more—all while you’re away?\nEver wonder how the cheaters cheat? Ever wanted to patch or protect\nyour game? Grab a coffee, crack open your laptop, and enjoy.\nBlessings to you and yours,\nDr. Jared DeMott\nSecurity Expert & Software Builder"
  },
  {
    "input": "Acknowledgments",
    "output": "ACKNOwlEDGMENts\nWriting this book was an amazing journey, and I couldn’t have done it\nalone. No Starch Press has been extremely supportive and worked closely\nwith me to take this book from concept to reality. In particular, I’d like to\nthank my developmental editor, Jennifer Griffith-Delgado, and my produc-\ntion editor, Laurel Chun. Bill Pollock, Tyler Ortman, Alison Law, and the\nrest of the team at No Starch are wonderful people, and I’m pleased to have\nworked with them.\nThanks to copyeditor Rachel Monaghan, proofreader Paula L. Fleming,\nand technical reviewer Stephen Lawler. Thanks also to my friends Cavitt\n“synt4x” Glover and Vadim Kotov, who took the time to skim some chapters\nbefore submission, and to Jared DeMott for writing the book’s foreword.\nI’d like to thank all of the people on TPForums who took me in when I\nwas just a naive kid and helped me learn how to hack games. In particular,\nI owe my thanks to Joseph “jo3bingham” Bingham, Ian Obermiller, and\njeremic, who all had a significant influence on my progression as a hacker,\nand to TPForums founder Josh “Zyphrus” Hartzell, who helped me find my\nconfidence and skills when my future looked its bleakest.\nThanks also to my entire forum staff and every customer who has ever\nused my bots. And finally, thanks to my family, friends, and colleagues,\nwho have been fun and supportive and helped shape me into the man I am\ntoday."
  },
  {
    "input": "Introduction",
    "output": "INtr ODuCtION\nA common misconception in the world\nof online gaming is the idea that the only\ngame you can play is the one in the title.\nIn fact, game hackers enjoy playing the game\nthat hides behind the curtain: a cat-and-mouse game\nof wits between them and the game developers. While\ngame hackers work to reverse engineer game binaries, automate aspects\nof game play, and modify gaming environments, game developers combat\nthe hacker-designed tools (normally referred to as bots) using anti-reversing\ntechniques, bot detection algorithms, and heuristic data mining.\nAs the battle between game hackers and developers has progressed, the\ntechnical methods implemented by both parties—many of which resemble\ntechniques utilized by malware developers and antivirus vendors—have\nevolved, becoming more complex. This book highlights the fight put up by\ngame hackers, and the advanced methods they have engineered to manipu-\nlate games while simultaneously eluding game developers in the dark cor-\nners of their own software."
  },
  {
    "input": "A Brief Game Hacking History",
    "output": "Although the book focuses on teaching you to develop tools that would\nlikely be considered a nuisance or even malicious by gaming companies,\nyou’ll find that many of the techniques are useful for development of tools\nthat are perfectly benign and neutral. Furthermore, the knowledge of how\nthese techniques are implemented is key for the game developers working\nto prevent their use.\nPrerequisites for the Reader\nThis book does not aim to teach you software development, and therefore\nassumes that you have, at minimum, a solid software development back-\nground. This background should include familiarity with native Windows-\nbased development, as well as light experience with game development and\nmemory management. While these skills will be enough for you to follow\nthis book, experience with x86 assembly and Windows internals will ensure\nthat details of more advanced implementations are not lost on you.\nFurthermore, since all the advanced hacks discussed in this book rely\non code injection, an ability to write code in a native language like C or\nC++ is a must. All of the example code in this book is written in C++ and\ncan be compiled with Microsoft Visual C++ Express Edition. (You can\ndownload MSVC++ Express Edition from http://www.visualstudio.com/en-US/\nproducts/visual-studio-express-vs.)\nNO tE Other languages that compile to native code, such as Delphi, are also capable of injec-\ntion, but I will not discuss them in this book.\na brief Game Hacking History\nSince the dawn of online PC gaming in the early 1980s, an ongoing war of\nwits between game hackers and game developers has been taking place.\nThis seemingly endless struggle has prompted game developers to devote\ncountless hours toward preventing hackers from taking their games apart\nand greasing between the gears. These hackers, who fight back with their\nsophisticated stealth implementations, have many motivations: customized\ngraphics, better performance, ease of use, autonomous play, in-game asset\nacquisition, and, of course, real-life profit.\nThe late 1990s and early 2000s were the golden age of game hacking,\nwhen online PC games became advanced enough to draw large crowds\nbut were still simple enough to easily reverse engineer and manipulate.\nOnline games that came out during this time, such as Tibia (January 1997),\nRunescape (January 2001), and Ultima Online (September 1997), were heavily\ntargeted by bot developers. The developers of these games and others like\nthem still struggle today to control the massive communities of bot devel-\nopers and bot users. The game developers’ lack of action and the hackers’\nxx Introduction"
  },
  {
    "input": "There’s a Reason for Everything",
    "output": "tenacity have not only completely shattered the economies within the games,\nbut have also produced a thriving for-profit industry focused around bot\ndevelopment and bot defense.\nIn the years since the golden age, more mature game companies\nstarted taking bot defense very seriously. These companies now have dedi-\ncated teams focused on developing bot prevention systems, and many also\nview bots as a legal matter and will not hesitate to banish players who use\nbots and sue the bot developers who provided them. As a result, many game\nhackers have been forced to develop advanced stealth techniques to keep\ntheir users safe.\nThis war wages on, and the numbers on both sides of the fight will con-\ntinue to grow as online gaming becomes more prevalent over the coming\nyears. Major game developers are pursuing hackers with endless determina-\ntion, even slamming some game hacking giants with multimillion-dollar\nlawsuits. This means that game hackers who are serious about their business\nmust either target smaller gaming companies, or anonymously market their\nproducts from the shadows in order to escape prosecution. For the foresee-\nable future, game hacking and bot development will continue to grow into\na larger and more lucrative industry for those game hackers bold enough to\ntake the risks.\nwhy Hack Games?\nAside from its obvious allure and challenging nature, game hacking has\nsome practical and profitable purposes. Every day, thousands of novice pro-\ngrammers experiment with small-scale game hacking as a way to automate\nmonotonous tasks or perform menial actions. These script kiddies will use\nautomation tools like AutoIt for their small, relatively harmless hacks. On\nthe other hand, professional game hackers, backed by their large toolkits\nand years of programming experience, will devote hundreds of hours to the\ndevelopment of advanced game hacks. These types of game hacks, which\nare the focus of this book, are often created with the intent of making large\namounts of money.\nGaming is a huge industry that generated $22.4 billion in sales in\n2014, according to the Entertainment Software Association. Of the tens\nof millions of players who play games daily, 20 percent play massively multi-\nplayer online role-playing games (MMORPGs). These MMORPGs often\nhave thousands of players who trade virtual goods within thriving in-game\neconomies. Players often have a need for in-game assets and are willing to\nbuy these assets with real-world money. Consequently, MMORPG players\nend up developing large communities that provide gold-for-cash services.\nThese services often go as far as enforcing exchange rates from in-game\ngold to real-world currencies.\nTo take advantage of this, game hackers will create bots that are capable\nof automatically farming gold and leveling characters. Then, depending\non their goal, hackers will either set up massive gold farms and sell their\nIntroduction xxi"
  },
  {
    "input": "How This Book Is Organized",
    "output": "in-game profits, or perfect and sell their software to players who wish to\nseamlessly obtain levels and gold with minimal interference. Due to the\nmassive communities surrounding popular MMORPGs, these game hackers\ncan make between six and seven figures annually.\nWhile MMORPGs provide the largest attack surface for hackers, they\nhave a relatively small audience overall. About 38 percent of gamers favor\nreal-time strategy (RTS) and massive online battle arena (MOBA) games,\nand another 6 percent play primarily first-person shooter (FPS) games.\nThese competitive player versus player (PvP) games collectively represent\n44 percent of the gaming market and provide great rewards to determined\ngame hackers.\nPvP games are often episodic in nature; each match is an isolated game,\nand there’s typically not much profitable progression for botting away from\nkeyboard (AFK). This means that, instead of running gold farms or creat-\ning autonomous bots to level up characters, hackers will create reactive bots\nthat assist players in combat.\nThese highly competitive games are about skill and tactics, and most\nplayers participate to prove their ability to themselves and others. As a\nconsequence, the number of people seeking bots for PvP-type games is\nsubstantially lower than you’d find in the grind-heavy world of MMORPGs.\nNevertheless, hackers can still make a pretty penny selling their PvP bots,\nwhich are often much easier to develop than full-fledged autonomous bots.\nHow This book is Organized\nThis book is split into four parts, each of which focuses on a different core\naspect of game hacking. In Part 1: Tools of the Trade, you’ll get a box full\nof tools to help you hack games.\n• Chapter 1: Scanning Memory Using Cheat Engine will teach you how\nto scan a game’s memory for important values using Cheat Engine.\n• In Chapter 2: Debugging Games with OllyDbg, you’ll get a crash\ncourse in debugging and reverse engineering with OllyDbg. The\nskills you learn here will be extremely useful when you start making\nadvanced bots and injecting code.\n• To wrap up, Chapter 3: Reconnaissance with Process Monitor and\nProcess Explorer, will teach you how to use two reconnaissance tools to\ninspect how games interact with files, other processes, the network, and\nthe operating system.\nThe online resources for each chapter in Part 1 include custom binaries\nI created to give you a safe place to test and hone your newly discovered\nskills.\nOnce you’re comfortable with every wrench and hammer, Part 2: Game\nDissection, will teach you how to get under the hood and figure out how\ngames work.\nxxii Introduction\n• In Chapter 4: From Code to Memory: A General Primer, you’ll learn\nwhat a game’s source code and data look like once compiled into a\ngame binary.\n• Chapter 5: Advanced Memory Forensics builds on the knowledge\nyou’ll gain from Chapter 4. You’ll learn how to scan memory and use\ndebugging to seamlessly locate tricky memory values and dissect com-\nplex classes and structures.\n• Finally, Chapter 6: Reading from and Writing to Game Memory shows\nyou how to read and modify data within a running game.\nThese chapters provide lots of in-depth proof-of-concept example code\nthat you can use to verify everything you read.\nIn Part 3: Process Puppeteering, you’ll become a puppeteer as you\nlearn how to turn any game into a marionette.\n• Building on the skills from Parts 1 and 2, Chapter 7: Code Injection\ndescribes how to inject and execute your own code in the address space\nof a game.\n• Once you’ve mastered injection, Chapter 8: Manipulating Control Flow\nin a Game will teach you how to use injection to intercept, modify, or\ndisable any function call made by a game, and will wrap up with some\nuseful real-world examples for the common libraries Adobe AIR and\nDirect 3D.\nTo complement your puppeteering classes, these chapters are accompa-\nnied by thousands of lines of production-ready code that you can use as a\nboilerplate library for a future bot.\nIn Part 4: Creating Bots, you’ll see how to combine your toolbox, dis-\nsection abilities, puppeteering skills, and software engineering background\nto create powerful bots.\n• Chapter 9: Using Extrasensory Perception to Ward Off Fog of War\nexplores ways to make a game display useful information that isn’t\nexposed by default, such as the locations of hidden enemies and the\namount of experience you earn per hour.\n• Chapter 10: Responsive Hacks shows code patterns you can use to\ndetect in-game events, like decreases in health, and to make bots that\nreact to those events faster than human players.\n• Chapter 11: Putting It All Together: Writing Autonomous Bots reveals\nhow bots that play games without human interaction work. Automated\nbots combine control theory, state machines, search algorithms, and\nmathematical models, and this chapter is a crash course in those topics.\n• In Chapter 12: Staying Hidden, you’ll learn about some of the high-\nlevel techniques you can use to escape and evade any system that would\ninterfere with your bots.\nIntroduction xxiii"
  },
  {
    "input": "How to Use This Book",
    "output": "As you’ve probably come to expect, these chapters have lots of example\ncode. Some of the hacks shown in this part are built on example code from\nprevious chapters. Others explore succinct, straightforward design pat-\nterns you can use to create your own bots. Once you’ve finished all four\nparts of this book, you’ll be sent off into the virtual world with your new\nsuperpower.\nabout the Online Resources\nYou’ll find many additional resources for this book at https://www.nostarch\n.com/gamehacking/. These resources include compiled binaries to test your\nskills, a considerable amount of example code, and quite a few snippets of\nproduction-ready game hacking code. These resources go hand-in-hand\nwith the book, and it really isn’t complete without them, so make sure to\ndownload them before you continue.\nHow to use This book\nThis book should be used first and foremost as a guide to get you started\nin game hacking. The progression is such that the content of each chap-\nter introduces new skills and abilities that build on all previous chapters.\nAs you complete chapters, I encourage you to play with the example code\nand test your skills on a real game before continuing your reading. This is\nimportant, as some covered topics will have use cases that don’t become evi-\ndent until you’re 10 feet deep in the mud.\nOnce you’ve finished the book, I hope it can still be useful to you as a\nfield manual. If you come across some data structure you’re unsure of, maybe\nthe details in Chapter 5 can help. If you reverse engineer a game’s map for-\nmat and are ready to create a pathfinder, you can always flip to Chapter 11,\nstudy the content, and use some of the example code as a starting point.\nAlthough it’s impossible to anticipate all the problems you might face when\nyou’re hacking away, I’ve tried to ensure you’ll find some answers within\nthese pages.\nA NOtE frOM tHE PuBlIsHEr\nThis book does not condone piracy, violating the DMCA, infringing copyright,\nor breaking in-game Terms of Service. Game hackers have been banned from\ngames for life, sued for millions of dollars, and even jailed for their work.\nxxiv Introduction"
  },
  {
    "input": "Chapter 1: Scanning Memory \rUsing Cheat Engine",
    "output": "1\nsCANNING M EMOry\nusING CHE At ENGINE\nThe best game hackers in the world spend\nyears personalizing expansive arsenals with\ncustom-built tools. Such potent toolkits\nenable these hackers to seamlessly analyze\ngames, effortlessly prototype hacks, and effectively\ndevelop bots. At the core, however, each unique kit is\nbuilt from the same four-piece powerhouse: a memory\nscanner, an assembler-level debugger, a process moni-\ntor, and a hex editor.\nMemory scanning is the gateway to game hacking, and this chapter will\nteach you about Cheat Engine, a powerful memory scanner that searches a\ngame’s operating memory (which lives in RAM) for values like the player’s\nlevel, health, or in-game money. First, I’ll focus on basic memory scanning,\nmemory modification, and pointer scanning. Following that, we’ll dive into\nCheat Engine’s powerful embedded Lua scripting engine."
  },
  {
    "input": "Basic Memory Scanning",
    "output": "NO tE You can grab Cheat Engine from http://www.cheatengine.org/. Pay attention\nwhen running the installer because it will try to install some toolbars and other bloat-\nware. You can disable those options if you wish.\nwhy memory Scanners are important\nKnowing a game’s state is paramount to interacting with the game intel-\nligently, but unlike humans, software can’t determine the state of a game\nsimply by looking at what’s on the screen. Fortunately, underneath all of\nthe stimuli produced by a game, a computer’s memory contains a purely\nnumeric representation of that game’s state—and programs can under-\nstand numbers easily. Hackers use memory scanners to find those values in\nmemory, and then in their programs, they read the memory in these loca-\ntions to understand the game’s state.\nFor example, a program that heals players when they fall below 500\nhealth needs to know how to do two things: track a player’s current health\nand cast a healing spell. The former requires access to the game’s state,\nwhile the latter might only require a button to be pressed. Given the loca-\ntion where a player’s health is stored and the way to read a game’s memory,\nthe program would look something like this pseudocode:\n// do this in some loop\nhealth = readMemory(game, HEALTH_LOCATION)\nif (health < 500)\npressButton(HEAL_BUTTON)\nA memory scanner allows you to find HEALTH_LOCATION so that your soft-\nware can query it for you later.\nbasic memory Scanning\nThe memory scanner is the most basic, yet most important, tool for the\naspiring game hacker. As in any program, all data in the memory of a game\nresides at an absolute location called a memory address. If you think of the\nmemory as a very large byte array, a memory address is an index pointing\nto a value in that array. When a memory scanner is told to find some value\nx (called a scan value, because it’s the value you’re scanning for) in a game’s\nmemory, the scanner loops through the byte array looking for any value\nequal to x. Every time it finds a matching value, it adds the index of the\nmatch to a result list.\nDue to the sheer size of a game’s memory, however, the value of x can\nappear in hundreds of locations. Imagine that x is the player’s health, which\nis currently 500. Our x uniquely holds 500, but 500 is not uniquely held by\nx, so a scan for x returns all variables with a value of 500. Any addresses not\nrelated to x are ultimately clutter; they share a value of 500 with x only by\n4 Chapter 1"
  },
  {
    "input": "Cheat Engine’s Memory Scanner",
    "output": "chance. To filter out these unwanted values, the memory scanner allows you\nto rescan the result list, removing addresses that no longer hold the same\nvalue as x, whether x is still 500 or has changed.\nFor these rescans to be effective, the overall state of the game must\nhave significant entropy—a measure of disorder. You increase entropy by\nchanging the in-game environment, often by moving around, killing crea-\ntures, or switching characters. As entropy increases, unrelated addresses are\nless likely to continue to arbitrarily hold the same value, and given enough\nentropy, a few rescans should filter out all false positives and leave you with\nthe true address of x.\ncheat engine’s memory Scanner\nThis section gives you a tour of Cheat Engine’s memory-scanning options,\nwhich will help you track down the addresses of game state values in mem-\nory. I’ll give you a chance to try the scanner out in “Basic Memory Editing”\non page 11; for now, open Cheat Engine and have a look around. The\nmemory scanner is tightly encapsulated in its main window, as shown in\nFigure 1-1.\n(cid:31)\n(cid:30)\n(cid:27)\n(cid:29)\n(cid:28)\n(cid:26)\nFigure 1-1: Cheat Engine main screen\nTo begin scanning a game’s memory, click the Attach icon u to attach\nto a process and then enter the scan value (referred to as x in our concep-\ntual scanner) you want to locate w. By attaching to a process, we’re telling\nScanning Memory Using Cheat Engine 5"
  },
  {
    "input": "Running Your First Scan",
    "output": "Cheat Engine to prepare to operate on it; in this case, that operation is a\nscan. It helps to also tell Cheat Engine what kind of scan to run, as I’ll dis-\ncuss next.\nScan Types\nCheat Engine allows you to select two different scan directives, called Scan\nType and Value Type x. Scan Type tells the scanner how to compare your\nscan value with the memory being scanned using one of the following scan\ntypes:\nExact Value Returns addresses pointing to values equal to the\nscan value. Choose this option if the value you are looking for won’t\nchange during the scan; health, mana, and level typically fall into this\ncategory.\nBigger Than Returns addresses pointing to values greater than the\nscan value. This option is useful when the value you’re searching for is\nsteadily increasing, which often happens with timers.\nSmaller Than Returns addresses pointing to values smaller than the\nscan value. Like Bigger Than, this option is useful for finding timers\n(in this case, ones that count down rather than up).\nValue Between Returns addresses pointing to values within a scan\nvalue range. This option combines Bigger Than and Smaller Than,\ndisplaying a secondary scan value box that allows you to input a much\nsmaller range of values.\nUnknown Initial Value Returns all addresses in a program’s memory,\nallowing rescans to examine the entire address range relative to their\ninitial values. This option is useful for finding item or creature types,\nsince you won’t always know the internal values the game developers\nused to represent these objects.\nThe Value Type directive tells the Cheat Engine scanner what type of\nvariable it’s searching for.\nRunning Your First Scan\nOnce the two scan directives are set, click First Scan v to run an initial\nscan for values, and the scanner will populate the results list y. Any green\naddresses in this list are static, meaning that they should remain persistent\nacross program restarts. Addresses listed in black reside in dynamically allo-\ncated memory, memory that is allocated at runtime.\nWhen the results list is first populated, it shows the address and real-\ntime value of each result. Each rescan will also show the value of each result\nduring the previous scan. (Any real-time values displayed are updated at\nan interval that you can set in Edit4Settings4General Settings4Update\ninterval.)\n6 Chapter 1"
  },
  {
    "input": "Cheat Tables",
    "output": "Next Scans\nOnce the results list is populated, the scanner enables the Next Scan v but-\nton, which offers six new scan types. These additional scan types allow you\nto compare the addresses in the results list to their values in the previous\nscan, which will help you narrow down which address holds the game state\nvalue you’re scanning for. They are as follows:\nIncreased Value Returns addresses pointing to values that have\nincreased. This complements the Bigger Than scan type by keeping\nthe same minimum value and removing any address whose value has\ndecreased.\nIncreased Value By Returns addresses pointing to values that have\nincreased by a defined amount. This scan type usually returns far fewer\nfalse positives, but you can use it only when you know exactly how much\na value has increased.\nDecreased Value This option is the opposite of Increased Value.\nDecreased Value By This option is the opposite of Increased Value By.\nChanged Value Returns addresses pointing to values that have\nchanged. This type is useful when you know a value will mutate, but\nyou’re unsure how.\nUnchanged Value Returns addresses pointing to values that haven’t\nchanged. This can help you eliminate false positives, since you can eas-\nily create a large amount of entropy while ensuring the desired value\nstays the same.\nYou’ll usually need to use multiple scan types in order to narrow down\na large result list and find the correct address. Eliminating false positives is\noften a matter of properly creating entropy (as described in “Basic Memory\nScanning” on page 4), tactically changing your scan directives, bravely\npressing Next Scan, and then repeating the process until you have a single\nremaining address.\nWhen You Can’t Get a Single Result\nSometimes it is impossible to pinpoint a single result in Cheat Engine, in\nwhich case you must determine the correct address through experimenta-\ntion. For example, if you’re looking for your character’s health and can’t\nnarrow it down to fewer than five addresses, you could try modifying the\nvalue of each address (as discussed in “Manual Modification with Cheat\nEngine” on page 8) until you see the health display change or the other\nvalues automatically change to the one you set.\nCheat Tables\nOnce you’ve found the correct address, you can double-click it to add it to\nthe cheat table pane z; addresses in the cheat table pane can be modified,\nwatched, and saved to cheat table files for future use.\nScanning Memory Using Cheat Engine 7"
  },
  {
    "input": "Manual Modification with Cheat Engine",
    "output": "For each address in the cheat table pane, you can add a description by\ndouble-clicking the Description column, and you can add a color by right-\nclicking and selecting Change Color. You can also display the values of each\naddress in hexadecimal or decimal format by right-clicking and selecting\nShow as hexadecimal or Show as decimal, respectively. Lastly, you can\nchange the data type of each value by double-clicking the Type column,\nor you can change the value itself by double-clicking the Value column.\nSince the main purpose of the cheat table pane is to allow a game\nhacker to neatly track addresses, it can be dynamically saved and loaded.\nGo to File4Save or File4Save As to save the current cheat table pane to\na .ct document file containing each address with its value type, description,\ndisplay color, and display format. To load the saved .ct documents, go to\nFile4Load. (You’ll find many ready-made cheat tables for popular games\nat http://cheatengine.org/tables.php.)\nNow that I’ve described how to scan for a game state value, I’ll discuss\nhow you can change that value when you know where it lives in memory.\nmemory modification in Games\nBots cheat a game system by modifying memory values in the game’s state\nin order to give you lots of in-game money, modify your character’s health,\nchange your character’s position, and so on. In most online games, a char-\nacter’s vitals (such as health, mana, skills, and position) are held in memory\nbut are controlled by the game server and relayed to your local game client\nover the Internet, so modifying such values during online play is merely\ncosmetic and doesn’t affect the actual values. (Any useful memory modifica-\ntion to an online game requires a much more advanced hack that’s beyond\nCheat Engine’s capabilities.) In local games with no remote server, however,\nyou can manipulate all of these values at will.\nManual Modification with Cheat Engine\nWe’ll use Cheat Engine to understand how the memory modification magic\nworks.\nTo modify memory manually, do the following:\n1. Attach Cheat Engine to a game.\n2. Either scan for the address you wish to modify or load a cheat table that\ncontains it.\n3. Double-click on the Value column for the address to open an input\nprompt where you can enter a new value.\n4. If you want to make sure the new value can’t be overwritten, select the\nbox under the Active column to freeze the address, which will make\nCheat Engine keep writing the same value back to it every time it\nchanges.\n8 Chapter 1"
  },
  {
    "input": "Trainer Generator",
    "output": "This method works wonders for quick-and-dirty hacks, but constantly\nchanging values by hand is cumbersome; an automated solution would be\nmuch more appealing.\nTrainer Generator\nCheat Engine’s trainer generator allows you to automate the whole memory\nmodification process without writing any code.\nTo create a trainer (a simple bot that binds memory modification actions\nto keyboard hotkeys), go to File4Create generic trainer Lua script from\ntable. This opens a Trainer generator dialog similar to the one shown in\nFigure 1-2.\nFigure 1-2: Cheat Engine Trainer generator dialog\nThere are a number of fields to modify here:\nProcessname The name of the executable the trainer should attach\nto. This is the name shown in the process list when you attach with\nCheat Engine, and it should be autofilled with the name of the pro-\ncess Cheat Engine is attached to.\nPopup trainer on keypress Optionally enables a hotkey—which you\nset by entering a key combination in the box below the checkbox—to\ndisplay the trainer’s main window.\nTitle The name of your trainer, which will be displayed on its inter-\nface. This is optional.\nAbout text The description of your trainer, to be displayed on the\ninterface; this is also optional.\nFreeze interval (in milliseconds) The interval during which a freeze\noperation overwrites the value. You should generally leave this at 250, as\nlower intervals can sap resources and higher values may be too slow.\nScanning Memory Using Cheat Engine 9\nOnce these values are configured, click Add Hotkey to set up a key\nsequence to activate your trainer. You will be prompted to select a value\nfrom your cheat table. Enter a value, and you will be taken to a Set/Change\nhotkey screen similar to Figure 1-3.\n(cid:31)\n(cid:30)\n(cid:29)\n(cid:28)\nFigure 1-3: Cheat Engine Set/Change hotkey screen\nOn this screen, place your cursor in the box labeled Type the keys you\nwant to set the hotkey to u and enter the desired key combination. Next,\nchoose the desired action from the drop-down menu v; your options\nshould appear in the following order:\nToggle freeze Toggles the freeze state of the address.\nToggle freeze and allow increase Toggles the freeze state of the\naddress but allows the value to increase. Any time the value decreases,\nthe trainer overwrites it with its previous value. Increased values will\nnot be overwritten.\nToggle freeze and allow decrease Does the opposite of Toggle freeze\nand allow increase.\nFreeze Sets the address to frozen if it’s not frozen already.\nUnfreeze Unfreezes the address if it’s frozen.\nSet value to Sets the value to whatever you specify in the value box w.\nDecrease value with Decreases the value by the amount you specify in\nthe value box w.\nIncrease value with Does the opposite of Decrease value with.\nFinally, you can set a description for the action x. Click Apply, then\nOK, and your action will appear in the list on the Trainer generator\nscreen. At this point, Cheat Engine runs the trainer in the background,\nand you can simply press the hotkeys you configured to execute the mem-\nory actions.\n10 Chapter 1"
  },
  {
    "input": "Pointer Chains",
    "output": "To save your trainer to a portable executable, click Generate trainer.\nRunning this executable after the game is launched will attach your trainer\nto the game so you can use it without starting Cheat Engine.\nNow that you know your way around Cheat Engine’s memory scanner\nand trainer generator, try modifying some memory yourself.\nBAsIC MEMOry EDItING\nDownload the files for this book from https://www.nostarch.com/gamehacking/,\nand run the file BasicMemory.exe. Next, start up Cheat Engine and attach to\nthe binary. Then, using only Cheat Engine, find the addresses for the x- and\ny-coordinates of the gray ball. (Hint: Use the 4 Bytes value type.)\nOnce you’ve found the values, modify them to place the ball on top of the\nblack square. The game will let you know once you’ve succeeded by display-\ning the text “Good job!” (Hint: Each time the ball is moved, its position—stored\nas a 4-byte integer—in that plane is changed by 1. Also, try to look only for\nstatic [green] results.)\nPointer Scanning\nAs I’ve mentioned, online games often store values in dynamically allocated\nmemory. While addresses that reference dynamic memory are useless to us in\nand of themselves, some static address will always point to another address,\nwhich in turn points to another, and so on, until the tail of the chain points\nto the dynamic memory we’re interested in. Cheat Engine can locate these\nchains using a method called pointer scanning.\nIn this section, I’ll introduce you to pointer chains and then describe\nhow pointer scanning works in Cheat Engine. When you have a good grasp\nof the user interface, you can get some hands-on experience in “Pointer\nScanning” on page 18.\nPointer Chains\nThe chain of offsets I’ve just described is called a pointer chain and looks\nlike this:\nlist<int> chain = {start, offset1, offset2[, ...]}\nThe first value in this pointer chain (start) is called a memory pointer. It’s\nan address that starts the chain. The remaining values (offset1, offset2, and\nso on) make up the route to the desired value, called a pointer path.\nScanning Memory Using Cheat Engine 11"
  },
  {
    "input": "Pointer Scanning Basics",
    "output": "This pseudocode shows how a pointer chain might be read:\nint readPointerChain(chain) {\nu ret = read(chain[0])\nfor i = 1, chain.len - 1, 1 {\noffset = chain[i]\nret = read(ret + offset)\n}\nreturn ret\n}\nThis code creates the function readPointerPath(), which takes a pointer\nchain called chain as a parameter. The function readPointerPath() treats the\npointer path in chain as a list of memory offsets from the address ret, which\nis initially set to the memory pointer at u. It then loops through these off-\nsets, updating the value of ret to the result of read(ret + offset) on each\niteration and returning ret once it’s finished. This pseudocode shows what\nreadPointerPath() looks like when the loop is unrolled:\nlist<int> chain = {0xDEADBEEF, 0xAB, 0x10, 0xCC}\nvalue = readPointerPath(chain)\n// the function call unrolls to this\nret = read(0xDEADBEEF) //chain[0]\nret = read(ret + 0xAB)\nret = read(ret + 0x10)\nret = read(ret + 0xCC)\nint value = ret\nThe function ultimately calls read four times, on four different\naddresses—one for each element in chain.\nNO tE Many game hackers prefer to code their chain reads in place, instead of encapsulating\nthem in functions like readPointerPath().\nPointer Scanning Basics\nPointer chains exist because every chunk of dynamically allocated memory\nmust have a corresponding static address that the game’s code can use to\nreference it. Game hackers can access these chunks by locating the pointer\nchains that reference them. Because of their multitier structure, however,\npointer chains cannot be located through the linear approach that memory\nscanners use, so game hackers have devised new ways to find them.\nFrom a reverse engineering perspective, you could locate and analyze\nthe assembly code in order to deduce what pointer path it used to access the\nvalue, but doing so is very time-consuming and requires advanced tools.\nPointer scanners solve this problem by using brute-force to recursively iterate\nover every possible pointer chain until they find one that resolves to the tar-\nget memory address.\n12 Chapter 1\nThe Listing 1-1 pseudocode should give you a general idea of how a\npointer scanner works.\nlist<int> pointerScan(target, maxAdd, maxDepth) {\nu for address = BASE, 0x7FFFFFF, 4 {\nret = rScan(address, target, maxAdd, maxDepth, 1)\nif (ret.len > 0) {\nret.pushFront(address)\nreturn ret\n}\n}\nreturn {}\n}\nlist<int> rScan(address, target, maxAdd, maxDepth, curDepth) {\nv for offset = 0, maxAdd, 4 {\nvalue = read(address + offset)\nw if (value == target)\nreturn list<int>(offset)\n}\nx if (curDepth < maxDepth) {\ncurDepth++\ny for offset = 0, maxAdd, 4 {\nret = rScan(address + offset, target, maxAdd, maxDepth, curDepth)\nz if (ret.len > 0) {\nret.pushFront(offset)\n{ return ret\n}\n}\n}\nreturn {}\n}\nListing 1-1: Pseudocode for a pointer scanner\nThis code creates the functions pointerScan() and rScan().\npointerScan()\nThe pointerScan() function is the entry point to the scan. It takes the param-\neters target (the dynamic memory address to find), maxAdd (the maximum\nvalue of any offset), and maxDepth (the maximum length of the pointer path).\nIt then loops through every 4-byte aligned address u in the game, calling\nrScan() with the parameters address (the address in the current iteration),\ntarget, maxAdd, maxDepth, and curDepth (the depth of the path, which is always 1\nin this case).\nrScan()\nThe rScan() function reads memory from every 4-byte aligned offset between\n0 and maxAdd v, and returns if a result is equal to target w. If rScan() doesn’t\nreturn in the first loop and the recursion is not too deep x, it increments\ncurDepth and again loops over each offset y, calling itself for each iteration.\nScanning Memory Using Cheat Engine 13"
  },
  {
    "input": "Pointer Scanning with Cheat Engine",
    "output": "If a self call returns a partial pointer path z, rScan() will prepend the\ncurrent offset to the path and return up the recursion chain { until it\nreaches pointerScan(). When a call to rScan() from pointerScan() returns a\npointer path, pointerScan() pushes the current address to the front of the\npath and returns it as a complete chain.\nPointer Scanning with Cheat Engine\nThe previous example showed the basic process of pointer scanning, but\nthe implementation I’ve shown is primitive. Aside from being insanely\nslow to execute, it would generate countless false positives. Cheat Engine’s\npointer scanner uses a number of advanced interpolations to speed up the\nscan and make it more accurate, and in this section, I’ll introduce you to\nthe smorgasbord of available scanning options.\nTo initiate a pointer scan in Cheat Engine, right-click on a dynamic\nmemory address in your cheat table and click Pointer scan for this address.\nWhen you initiate a pointer scan, Cheat Engine will ask you where to store\nthe scan results as a .ptr file. Once you enter a location, a Pointerscanner\nscanoptions dialog similar to the one shown in Figure 1-4 will appear.\nFigure 1-4: Cheat Engine Pointerscanner scanoptions dialog\n14 Chapter 1\nThe Address to find input field at the top displays your dynamic mem-\nory address. Now carefully select from among Cheat Engine’s many scan\noptions.\nKey Options\nSeveral of Cheat Engine’s scan options typically retain their default values.\nThose options are as follows:\nAddresses must be 32-bits aligned Tells Cheat Engine to scan only\naddresses that are multiples of 4, which greatly increases the scan\nspeed. As you’ll learn in Chapter 4, compilers align data so that most\naddresses will be multiples of 4 anyway by default. You’ll rarely need to\ndisable this option.\nOnly find paths with a static address Speeds up the scan by prevent-\ning Cheat Engine from searching paths with a dynamic start pointer.\nThis option should always be enabled because scanning for a path start-\ning at another dynamic address can be counterproductive.\nDon’t include pointers with read-only nodes Should also always be\nenabled. Dynamically allocated memory that stores volatile data should\nnever be read-only.\nStop traversing a path when a static has been found Terminates the\nscan when it finds a pointer path with a static start address. This should\nbe enabled to reduce false positives and speed up the scan.\nPointer path may only be inside this region Can typically be left as is.\nThe other options available to you compensate for this large range by\nintelligently narrowing the scope of the scan.\nFirst element of pointerstruct must point to module Tells Cheat\nEngine not to search heap chunks in which virtual function tables are\nnot found, under the assumption that the game was coded using object\norientation. While this setting can immensely speed up scans, it’s highly\nunreliable and you should almost always leave it disabled.\nNo looping pointers Invalidates any paths that point to themselves,\nweeding out inefficient paths but slightly slowing down the scan. This\nshould usually be enabled.\nMax level Determines the maximum length of the pointer path.\n(Remember the maxDepth variable in the example code in Listing 1-1?)\nThis should be kept around 6 or 7.\nOf course, there will be times when you’ll need to change these options\nfrom the settings described. For example, failing to obtain reliable results\nwith the No looping pointers or Max level settings typically means that the\nvalue you’re looking for exists in a dynamic data structure, like a linked list,\nbinary tree, or vector. Another example is the Stop traversing a path when a\nstatic has been found option, which in rare cases can prevent you from get-\nting reliable results.\nScanning Memory Using Cheat Engine 15\nSituational Options\nUnlike the previous options, your settings for the remaining ones will depend\non your situation. Here’s how to determine the best configuration for each:\nImprove pointerscan with gathered heap data Allows Cheat Engine\nto use the heap allocation record to determine offset limits, effectively\nspeeding up the scan by weeding out many false positives. If you run\ninto a game using a custom memory allocator (which is becoming\nincreasingly common), this option can actually do the exact opposite\nof what it’s meant to do. You can leave this setting enabled in initial\nscans, but it should be the first to go when you’re unable to find reli-\nable paths.\nOnly allow static and heap addresses in the path Invalidates all paths\nthat can’t be optimized with heap data, making this approach even\nmore aggressive.\nMax different offsets per node Limits the number of same-value\npointers the scanner checks. That is, if n different addresses point to\n0x0BADF00D, this option tells Cheat Engine to consider only the first m\naddresses. This can be extremely helpful when you’re unable to narrow\ndown your result set. In other cases, you may want to disable it, as it will\nmiss many valid paths.\nAllow stack addresses of the first thread(s) to be handled as static\nScans the call stacks of oldest m threads in the game, considering the\nfirst n bytes in each one. This allows Cheat Engine to scan the param-\neters and local variables of functions in the game’s call chain (the goal\nbeing to find variables used by the game’s main loop). The paths found\nwith this option can be both highly volatile and extremely useful; I use\nit only when I fail to find heap addresses.\nStack addresses as only static address Takes the previous option even\nfurther by allowing only stack addresses in pointer paths.\nPointers must end with specific offsets Can be useful if you know the\noffset(s) at the end of a valid path. This option will allow you to specify\nthose offsets (starting with the last offset at the top), greatly reducing\nthe scope of the scan.\nNr of threads scanning Determines how many threads the scanner\nwill use. A number equal to the number of cores in your processor\noften works best. A drop-down menu with options allows you to specify\nthe priority for each thread. Idle is best if you want your scan to go very\nslowly, Normal is what you should use for most scans, and Time critical\nis useful for lengthy scans but will render your computer useless for the\nscan duration.\nMaximum offset value Determines the maximum value of each offset\nin the path. (Remember the maxAdd variable in Listing 1-1?) I typically\nstart with a low value, increasing it only if my scan fails; 128 is a good\nstarting value. Keep in mind that this value is mostly ignored if you’re\nusing the heap optimization options.\n16 Chapter 1"
  },
  {
    "input": "Pointer Rescanning",
    "output": "NO tE What if both Only allow static and heap addresses in the path and Stack addresses as\nonly static address are enabled? Will the scan come up empty? Seems like a fun, albeit\nuseless, experiment.\nOnce you have defined your scan options, click OK to start a pointer\nscan. When the scan completes, a results window will appear with the list of\npointer chains found. This list often has thousands of results, containing\nboth real chains and false positives.\nPointer Rescanning\nThe pointer scanner has a rescan feature that can help you eliminate false\npositives. To begin, press ctrl-R from the results window to open the\nRescan pointerlist dialog, as shown in Figure 1-5.\n(cid:31)\n(cid:30)\nFigure 1-5: Cheat Engine Rescan pointerlist\ndialog\nThere are two main options to consider when you tell Cheat Engine to\nrescan:\nOnly filter out invalid pointers If you check this box u, the rescan\nwill discard only pointer chains that point to invalid memory, which\nhelps if your initial result set is very large. Disable this to filter out paths\nthat don’t resolve to a specific address or value (as shown in the figure).\nRepeat rescan until stopped If you check this box v, the rescan will\nexecute in a continuous loop. Ideally, you should enable this setting and\nlet rescan run while you create a large amount of memory entropy.\nFor the initial rescan, enable both Only filter out invalid pointers and\nRepeat rescan until stopped, and then press OK to initiate the rescan. The\nrescan window will go away, and a Stop rescan loop button will appear in\nthe results window. The result list will be constantly rescanned until you click\nStop rescan loop, but spend a few minutes creating memory entropy before\ndoing so.\nScanning Memory Using Cheat Engine 17"
  },
  {
    "input": "Lua Scripting Environment",
    "output": "In rare cases, rescanning using a rescan loop may still leave you with\na large list of possible paths. When this happens, you may need to restart\nthe game, find the address that holds your value (it may have changed!),\nand use the rescan feature on this address to further narrow results. In this\nscan, leave Only filter out invalid pointers unchecked and enter the new\naddress in the Address to find field.\nNO tE If you had to close the results window, you can reopen it and load the result list by\ngoing to the main Cheat Engine window and pressing the Memory View button below\nthe results pane. This should bring up a memory dump window. When the window\nappears, press ctrl-P to open the pointer scan results list. Then press ctrl-O to open\nthe .ptr file where you saved the pointer scan.\nIf your results still aren’t narrow enough, try running the same scan\nacross system restarts or even on different systems. If this still yields a large\nresult set, each result can safely be considered static because more than one\npointer chain can resolve to the same address.\nOnce you’ve narrowed down your result set, double-click on a usable\npointer chain to add it to your cheat table. If you have a handful of seem-\ningly usable chains, grab the one with the fewest offsets. If you find multiple\nchains with identical offsets that start with the same pointer but diverge\nafter a certain point, your data may be stored in a dynamic data structure.\nThat’s all there is to pointer scanning in Cheat Engine. Try it yourself!\nPOINtEr sCANNING\nGo to https://www.nostarch.com/gamehacking/ and download MemoryPointers\n.exe. Unlike the last task, which required you to win only once, this one requires\nthat you win 50 times in 10 seconds. Upon each win, the memory addresses\nfor the x- and y-coordinates will change, meaning you will be able to freeze\nthe value only if you have found a proper pointer path. Start this exercise the\nsame way as the previous one, but once you’ve found the addresses, use the\nPointer scan feature to locate pointer paths to them. Then, place the ball on\ntop of the black square, freeze the value in place, and press tab to begin the\ntest. Just as before, the game will let you know once you’ve won. (Hint: Try set-\nting the maximum level to 5 and the maximum offset value to 512. Also, play\nwith the options to allow stack addresses, terminate the scan when a static is\nfound, and improve the pointer scan with heap data. See which combination\nof options gives the best results.)\nLua Scripting environment\nHistorically, bot developers rarely used Cheat Engine to update their\naddresses when a game released a patch because it was much easier to\ndo so in OllyDbg. This made Cheat Engine useless to game hackers other\n18 Chapter 1"
  },
  {
    "input": "Searching for Assembly Patterns",
    "output": "than for initial research and development—that is, until a powerful Lua-\nbased embedded scripting engine was implemented around Cheat Engine’s\nrobust scanning environment. While this engine was created to enable the\ndevelopment of simple bots within Cheat Engine, professional game hack-\ners found they could also use it to easily write complex scripts to automati-\ncally locate addresses across different versions of a game’s binary—a task\nthat might otherwise take hours.\nNO tE You’ll find more detail about the Cheat Engine Lua scripting engine on the wiki at\nhttp://wiki.cheatengine.org/.\nTo start using the Lua engine, press ctrl-alt-L from the main Cheat\nEngine window. Once the window opens, write your script in the text area\nand click Execute script to run it. Save a script with ctrl-S and open a\nsaved script with ctrl-O.\nThe scripting engine has hundreds of functions and infinite use cases,\nso I’ll give you just a glimpse of its abilities by breaking down two scripts.\nEvery game is different and every game hacker writes scripts to accomplish\nunique goals, so these scripts are only useful for demonstrating concepts.\nSearching for Assembly Patterns\nThis first script locates functions that compose outgoing packets and sends\nthem to the game server. It works by searching a game’s assembly code for\nfunctions that contain a certain code sequence.\nu BASEADDRESS = getAddress(\"Game.exe\")\nv function LocatePacketCreation(packetType)\nw for address = BASEADDRESS, (BASEADDRESS + 0x2ffffff) do\nlocal push = readBytes(address, 1, false)\nlocal type = readInteger(address + 1)\nlocal call = readInteger(address + 5)\nx if (push == 0x68 and type == packetType and call == 0xE8) then\nreturn address\nend\nend\nreturn 0\nend\nFUNCTIONHEADER = { 0xCC, 0x55, 0x8B, 0xEC, 0x6A }\ny function LocateFunctionHead(checkAddress)\nif (checkAddress == 0) then return 0 end\nz for address = checkAddress, (checkAddress - 0x1fff), -1 do\nlocal match = true\nlocal checkheader = readBytes(address, #FUNCTIONHEADER, true)\n{ for i, v in ipairs(FUNCTIONHEADER) do\nif (v ~= checkheader[i]) then\nmatch = false\nbreak\nend\nend\n| if (match) then return address + 1 end\nend\nScanning Memory Using Cheat Engine 19\nreturn 0\nend\n} local funcAddress = LocateFunctionHead(LocatePacketCreation(0x64))\nif (funcAddress ~= 0) then\nprint(string.format(\"0x%x\",funcAddress))\nelse\nprint(\"Not found!\")\nend\nThe code begins by getting the base address of the module that\nCheat Engine is attached to u. Once it has the base address, the function\nLocatePacketCreation() is defined v. This function loops through the first\n0x2FFFFFF bytes of memory in the game w, searching for a sequence that\nrepresents this x86 assembler code:\nPUSH type ; Data is: 0x68 [4byte type]\nCALL offset ; Data is: 0xE8 [4byte offset]\nThe function checks that the type is equal to packetType, but it doesn’t\ncare what the function offset is x. Once this sequence is found, the func-\ntion returns.\nNext, the LocateFunctionHead() function is defined y. The function back-\ntracks up to 0x1FFF bytes from a given address z, and at each address, it\nchecks for a stub of assembler code { that looks something like this:\nINT3 ; 0xCC\nPUSH EBP ; 0x55\nMOV EBP, ESP ; 0x8B 0xEC\nPUSH [-1] ; 0x6A 0xFF\nThis stub will be present at the beginning of every function, because it’s\npart of the function prologue that sets up the function’s stack frame. Once\nit finds the code, the function will return the address of the stub plus 1 |\n(the first byte, 0xCC, is padding).\nTo tie these steps together, the LocatePacketCreation() function is called\nwith the packetType that I’m looking for (arbitrarily 0x64) and the resulting\naddress is passed into the LocateFunctionHead() function }. This effectively\nlocates the first function that pushes packetType into a function call and\nstores its address in funcAddress. This stub shows the result:\nINT3 ; LocateFunctionHead back-tracked to here\nPUSH EBP ; and returned this address\nMOV EBP, ESP\nPUSH [-1]\n--snip--\nPUSH [0x64] ; LocatePacketCreation returned this address\nCALL [something]\n20 Chapter 1"
  },
  {
    "input": "Searching for Strings",
    "output": "This 35-line script can automatically locate 15 different functions in\nunder a minute.\nSearching for Strings\nThis next Lua script scans a game’s memory for text strings. It works much as\nthe Cheat Engine’s memory scanner does when you use the string value type.\nBASEADDRESS = getAddress(\"Game.exe\")\nu function findString(str)\nlocal len = string.len(str)\nv local chunkSize = 4096\nw local chunkStep = chunkSize - len\nprint(\"Found '\" .. str .. \"' at:\")\nx for address = BASEADDRESS, (BASEADDRESS + 0x2ffffff), chunkStep do\nlocal chunk = readBytes(address, chunkSize, true)\nif (not chunk) then break end\ny for c = 0, chunkSize-len do\nz checkForString(address , chunk, c, str, len)\nend\nend\nend\nfunction checkForString(address, chunk, start, str, len)\nfor i = 1, len do\nif (chunk[start+i] ~= string.byte(str, i)) then\nreturn false\nend\nend\n{ print(string.format(\"\\t0x%x\", address + start))\nend\n| findString(\"hello\")\n} findString(\"world\")\nAfter getting the base address, the findString() function is defined u,\nwhich takes a string, str, as a parameter. This function loops through the\ngame’s memory x in 4,096-byte-long chunks v. The chunks are scanned\nsequentially, each one starting len (the length of str) bytes before the end\nof the previous one w to prevent missing a string that begins on one chunk\nand ends on another.\nAs findString() reads each chunk, it iterates over every byte until the over-\nlap point in the chunk y, passing each subchunk into the checkForString()\nfunction z. If checkForString() matches the subchunk to str, it prints the\naddress of that subchunk to the console {.\nLastly, to find all addresses that reference the strings \"hello\" and\n\"world\", the functions findString(\"hello\") | and findString(\"world\") } are\ncalled. By using this code to search for embedded debug strings and pairing\nit with the previous code to locate function headers, I’m able to find a large\nnumber of internal functions within a game in mere seconds.\nScanning Memory Using Cheat Engine 21"
  },
  {
    "input": "Closing Thoughts",
    "output": "OPtIMIzING MEMOry CODE\nDue to the high overhead of memory reading, optimization is extremely impor-\ntant when you’re writing code that performs memory reads. In the previous code\nsnippet, notice that the function findString() does not use the Lua engine’s built-\nin readString() function. Instead, it reads big chunks of memory and searches\nthem for the desired string. Let’s break down the numbers.\nA scan using readString() would try to read a string of len bytes at every\npossible memory address. This means it would read, at most, (0x2FFFFFF * len\n+ len) bytes. However, findString() reads chunks of 4,096 bytes and scans\nthem locally for matching strings. This means it would read, at most, (0x2FFFFFF\n+ 4096 + (0x2FFFFFF / (4096 - 10)) * len) bytes. When searching for a\nstring with a length of 10, the number of bytes that each method would read is\n503,316,480 and 50,458,923, respectively.\nNot only does findString() read an order of magnitude less data, it also\ninvokes far fewer memory reads. Reading in chunks of 4,096 bytes would\nrequire a total of (0x2FFFFFF / (4096 - len)) reads. Compare that to a scan\nusing readString(), which would need 0x2FFFFFF reads. The scan that uses\nfindString() is a huge improvement because invoking a read is much more\nexpensive than increasing the size of data being read. (Note that I chose\n4,096 arbitrarily. I keep the chunk relatively small because reading memory\ncan be time-consuming, and it might be wasteful to read four pages at a time\njust to find the string in the first.)\nclosing Thoughts\nBy this point, you should have a basic understanding of Cheat Engine\nand how it works. Cheat Engine is a very important tool in your kit, and I\nencourage you to get some hands-on experience with it by following “Basic\nMemory Editing” on page 11 and “Pointer Scanning” on page 18 and\nplaying around with it on your own.\n22 Chapter 1"
  },
  {
    "input": "Chapter 2: Debugging Games \rwith OllyDbg",
    "output": "2\nDEBuGGING G AMEs\nwItH OllyD BG\nYou can scratch the surface of what hap-\npens as a game runs with Cheat Engine,\nbut with a good debugger, you can dig\ndeeper until you understand the game’s\nstructure and execution flow. That makes OllyDbg\nessential to your game-hacking arsenal. It’s packed\nwith a myriad of powerful tools like conditional breakpoints, referenced\nstring search, assembly pattern search, and execution tracing, making it a\nrobust assembler-level debugger for 32-bit Windows applications.\nI’ll cover low-level code structure in detail in Chapter 4, but for this\nchapter, I assume you’re at least familiar with modern code-level debug-\ngers, such as the one packaged with Microsoft Visual Studio. OllyDbg is\nfunctionally similar to those, with one major difference: it interfaces with"
  },
  {
    "input": "A Brief Look at OllyDbg’s User Interface",
    "output": "the assembly code of an application, working even in the absence of source\ncode and/or debug symbols, making it ideal when you need to dig into the\ninternals of a game. After all, game companies are rarely nice (or dumb)\nenough to ship their games with debug symbols!\nIn this chapter, I’ll go over OllyDbg’s user interface, show you how to\nuse its most common debugging features, break down its expression engine,\nand provide some real-world examples of how you can tie it in to your game\nhacking endeavors. As a wrap-up, I’ll teach you about some useful plug-ins\nand send you off with a test game designed to get you started in OllyDbg.\nNO tE This chapter focuses on OllyDbg 1.10 and may not be entirely accurate for later\nversions. I use this version because, at the time of writing, the plug-in interface for\nOllyDbg 2 is still far less robust than the one for OllyDbg 1.\nWhen you feel like you have a handle on OllyDbg’s interface and fea-\ntures, you can try it on a game yourself with “Patching an if() Statement”\non page 46.\na brief Look at Ollydbg’s user interface\nGo to the OllyDbg website (http://www.ollydbg.de/), download and install\nOllyDbg, and open the program. You should see the toolbar shown in\nFigure 2-1 above a multiple window interface area.\n(cid:29) (cid:27)\n(cid:31) (cid:30) (cid:28)\nFigure 2-1: OllyDbg main window\nThis toolbar contains the program controls u, the debug buttons v,\nthe Go to button w, the control window buttons x, and the Settings\nbutton y.\nThe three program controls allow you to open an executable and\nattach to the process it creates, restart the current process, or terminate\nexecution of the current process, respectively. You can also complete these\nfunctions with the hotkeys F3, ctrl-F2, and alt-F2, respectively. To attach\nto a process that is already running, click File4Attach.\nThe debug buttons control the debugger actions. Table 2-1 describes\nwhat these buttons do, along with their hotkeys and functions. This table\nalso lists three useful debugger actions that don’t have buttons on the\ndebug toolbar.\n24 Chapter 2\nTable 2-1: Debug Buttons and Other Debugger Functions\nButton Hotkey Function\nPlay F9 Resumes normal execution of the process.\nPause F12 Pauses execution of all threads within the\nprocess and brings up the CPU window at the\ninstruction currently being executed.\nStep into F7 Single-steps to the next operation to be executed\n(will dive down into function calls).\nStep over F8 Steps to the next operation to be executed\nwithin current scope (will skip over function\ncalls).\nTrace into ctrl-F11 Runs a deep trace, tracing every operation that\nis executed.\nTrace over ctrl-F12 Runs a passive trace that traces only operations\nwithin the current scope.\nExecute until return ctrl-F9 Executes until a return operation is hit within the\ncurrent scope.\nctrl-F7 Automatically single-steps on every operation,\nfollowing execution in the disassembly window.\nThis makes execution appear to be animated.\nctrl-F8 Also animates execution, but steps over\nfunctions instead of stepping into them.\nesc Stops animation, pausing execution on the\ncurrent operation.\nThe Go to button opens a dialog asking for a hexadecimal address. Once\nyou enter the address, OllyDbg opens the CPU window and shows the disas-\nsembly at the specified address. When the CPU window is in focus, you can\nalso show that information with the hotkey ctrl-G.\nThe control window buttons open different control windows, which display\nuseful information about the process you’re debugging and expose more\ndebugging functions, like the ability to set breakpoints. OllyDbg has a total of\n13 control windows, which can all be open simultaneously within the multiple\nwindow interface. Table 2-2 describes these windows, listed in the order in\nwhich they appear on the window buttons toolbar.\nTable 2-2: OllyDbg’s Control Windows\nWindow Hotkey Function\nLog alt-L Displays a list of log messages, including debug prints,\nthread events, debugger events, module loads, and\nmuch more.\nModules alt-E Displays a list of all executable modules loaded into\nthe process. Double-click a module to open it in the\nCPU window.\n(continued)\nDebugging Games with OllyDbg 25"
  },
  {
    "input": "OllyDbg’s CPU Window",
    "output": "Table 2-2 (continued)\nWindow Hotkey Function\nMemory map alt-M Displays a list of all blocks of memory allocated by the\nprocess. Double-click a block in the list to bring up a\ndump window of that memory block.\nThreads Displays a list of threads running in the process. For each\nthread in this list, the process has a structure called a\nThread Information Block (TIB). OllyDbg allows you to\nview each thread’s TIB; simply right-click a thread and\nselect Dump thread data block.\nWindows Displays a list of window handles held by the process.\nRight-click a window in this list to jump to or set a\nbreakpoint on its class procedure (the function that\ngets called when a message is sent to the window).\nHandles Displays a list of handles held by the process. (Note\nthat Process Explorer has a much better handle list than\nOllyDbg, as I will discuss in Chapter 3.)\nCPU alt-C Displays the main disassembler interface and controls\na majority of the debugger functionality.\nPatches ctrl-P Displays a list of any assembly code modifications you\nhave made to modules within the process.\nCall stack alt-K Displays the call stack for the active thread. The\nwindow updates when the process halts.\nBreakpoints alt-B Displays a list of active debugger breakpoints and\nallows you to toggle them on and off.\nReferences Displays the reference list, which typically holds the\nsearch results for many different types of searches. It\npops up on its own when you run a search.\nRun trace Displays a list of operations logged by a debugger\ntrace.\nSource Displays the source code of the disassembled module if\na program debug database is present.\nFinally, the Settings button opens the OllyDbg settings window. Keep\nthe default settings for now.\nNow that you’ve had a tour of the main OllyDbg window, let’s explore the\nCPU, Patches, and Run trace windows more closely. You’ll use those windows\nextensively as a game hacker, and knowing your way around them is key.\nOllydbg’s cPu window\nThe CPU window in Figure 2-2 is where game hackers spend most of their\ntime in OllyDbg because it is the main control window for the debugging\nfeatures.\n26 Chapter 2"
  },
  {
    "input": "Viewing and Navigating a Game’s Assembly Code",
    "output": "(cid:28) (cid:31)\n(cid:30) (cid:29)\nFigure 2-2: OllyDbg CPU window\nThis window houses four distinct control panes: the disassembler\npane u, the registers pane v, the dump pane w, and the stack pane x.\nThese four panes encapsulate OllyDbg’s main debugger functions, so it’s\nimportant to know them inside and out.\nViewing and Navigating a Game’s Assembly Code\nYou’ll navigate game code and control most aspects of debugging from\nOllyDbg’s disassembler pane. This pane displays the assembly code for the\ncurrent module, and its data is neatly displayed in a table composed of four\ndistinct columns: Address, Hex dump, Disassembly, and Comment.\nThe Address column displays the memory addresses of each operation\nin the game process you’re attached to. You can double-click an address in\nthis column to toggle whether it’s the display base. When an address is set as\nthe display base, the Address column displays all other addresses as offsets\nrelative to it.\nThe Hex dump column displays the byte code for each operation,\ngrouping operation codes and parameters accordingly. Black braces span-\nning multiple lines on the left side of this column mark known function\nboundaries. Operations that have jumps going to them are shown with a\nDebugging Games with OllyDbg 27\nright-facing arrow on the inside of these braces. Operations that perform\njumps are shown with either up-facing or down-facing arrows, depending\non the direction in which they jump, on the inside of these braces. For\nexample, in Figure 2-2, the instruction at address 0x779916B1 (highlighted\nin gray) has an up-facing arrow, indicating it’s an upward jump. You can\nthink of a jump as a goto operator.\nThe Disassembly column displays the assembly code of each operation\nthe game performs. So, for example, you can confirm that the instruction\nat 0x779916B1 in Figure 2-2 is a jump by looking at the assembly, which\nshows a JNZ (jump if nonzero) instruction. Black braces in this column\nmark the boundaries of loops. Right-facing arrows attached to these braces\npoint to the conditional statements that control whether the loops continue\nor exit. The three right-facing arrows in this column in Figure 2-2 point to\nCMP (compare) and TEST instructions, which are used by assembly code to\ncompare values.\nThe Comment column displays human-readable comments about each\noperation the game performs. If OllyDbg encounters known API function\nnames, it will automatically insert a comment with the name of the function.\nSimilarly, if it successfully detects arguments being passed to a function,\nit will label them (for example, Arg1, Arg2, . . . , ArgN). You can double-click\nin this column to add a customized comment. Black braces in this column\nmark the assumed boundaries of function call parameters.\nNO tE OllyDbg infers function boundaries, jump directions, loop structures, and function\nparameters during code analysis, so if these columns lack boundary lines or jump\narrows, just press ctrl-A to run a code analysis on the binary.\nWhen the disassembler pane is in focus, there are a few hotkeys you can\nuse to quickly navigate code and control the debugger. Use F2 for Toggle\nbreakpoint, shift-F12 for Place conditional breakpoint, - (hyphen) for Go\nback and + (plus) for Go forward (these two work as you’d expect in a web\nbrowser), * (asterisk) for Go to EIP (which is the execution pointer in the\nx86 architecture), ctrl-- (hyphen) for Go to previous function, and ctrl-+\nfor Go to next function.\nThe disassembler can also populate the References window with differ-\nent types of search results. When you want to change the References win-\ndow’s contents, right-click in the disassembler pane, mouse over the Search\nfor menu to expand it, and select one of the following options:\nAll intermodular calls Searches for all calls to functions in remote\nmodules. This can, for example, allow you to see everywhere that a\ngame calls Sleep(), PeekMessage(), or any other Windows API function,\nenabling you to inspect or set breakpoints on the calls.\nAll commands Searches for all occurrences of a given operation writ-\nten in assembly, where the added operators CONST and R32 will match\na constant value or a register value, respectively. One use for this\noption might be searching for commands like MOV [0xDEADBEEF], CONST;\n28 Chapter 2"
  },
  {
    "input": "Viewing and Searching a Game’s Memory",
    "output": "MOV [0xDEADBEEF], R32; and MOV [0xDEADBEEF], [R32+CONST] to list all opera-\ntions that modify memory at the address 0xDEADBEEF, which could be any-\nthing, including the address of your player’s health.\nAll sequences Searches for all occurrences of a given sequence of\noperations. This is similar to the previous options, but it allows you to\nspecify multiple commands.\nAll constants Searches for all instances of a given hexadecimal con-\nstant. For instance, if you enter the address of your character’s health,\nthis will list all of the commands that directly access it.\nAll switches Searches for all switch-case blocks.\nAll referenced text strings Searches for all strings referenced in code.\nYou can use this option to search through all referenced strings and see\nwhat code accesses them, which can be useful for correlating in-game\ntext displays with the code that displays them. This option is also very\nuseful for locating any debug assertion or logging strings, which can be\na tremendous help in determining the purpose of code parts.\nThe disassembler can also populate the Names window with all labels\nin the current module (ctrl-N) or all known labels in all modules (Search\nfor4Name in all modules). Known API functions will be automatically\nlabeled with their names, and you can add a label to a command by high-\nlighting it, pressing shift-; and entering the label when prompted. When\na labeled command is referenced in code, the label will be shown in place of\nthe address. One way to use this feature is to name functions that you’ve\nanalyzed (just set a label on the first command in a function) so you can\nsee their names when other functions call them.\nViewing and Editing Register Contents\nThe registers pane displays the contents of the eight processor registers, all\neight flag bits, the six segment registers, the last Windows error code, and\nEIP. Underneath these values, this pane can display either Floating-Point\nUnit (FPU) registers or debug registers; click on the pane’s header to change\nwhich registers are displayed. The values in this pane are populated only if\nyou freeze your process. Values that are displayed in red have been changed\nsince the previous pause. Double-click on values in this pane to edit them.\nViewing and Searching a Game’s Memory\nThe dump pane displays a dump of the memory at a specific address. To\njump to an address and display the memory contents, press ctrl-G and\nenter the address in the box that appears. You can also jump to the address\nof an entry in the other CPU window panes by right-clicking on the Address\ncolumn and selecting Follow in dump.\nWhile there are always three columns in the dump pane, the only one\nyou should always see is the Address column, which behaves much like its\ncousin within the disassembler pane. The data display type you choose\nDebugging Games with OllyDbg 29"
  },
  {
    "input": "Viewing a Game’s Call Stack",
    "output": "determines the other two columns shown. Right-click the dump pane to\nchange the display type; for the one shown in Figure 2-2, you’d right-click\nand select Hex4Hex/ASCII (8 bytes).\nYou can set a memory breakpoint on an address shown in the dump\npane by right-clicking that address and expanding the Breakpoint submenu.\nSelect Memory4On access from this menu to break on any code that uses\nthe address at all, or select Memory4On write to break only on code that\nwrites to that space in memory. To remove a memory breakpoint, select\nRemove memory breakpoint in the same menu; this option appears only\nwhen the address you right-click has a breakpoint.\nWith one or more values selected in the dump, you can press ctrl-R to\nsearch the current module’s code for references to addresses of the selected\nvalues; results of this search appear in the References window. You can also\nsearch for values in this pane using ctrl-B for binary strings and ctrl-N for\nlabels. After you initiate a search, press ctrl-L to jump to the next match.\nctrl-E allows you to edit any values you have selected.\nNO tE The dump windows that you can open from the Memory window work in the same\nway as the dump pane.\nViewing a Game’s Call Stack\nThe final CPU pane is the stack pane, and as the name suggests, it shows\nthe call stack. Like the dump and disassembler panes, the stack pane has an\nAddress column. The stack pane also has a Value column, which shows the\nstack as an array of 32-bit integers, and a Comment column, which shows\nreturn addresses, known function names, and other informative labels. The\nstack pane supports all the same hotkeys as the dump pane, with the excep-\ntion of ctrl-N.\nMultIClIENt PAtCHING\nOne type of hack, called a multiclient patch, overwrites the single-instance\nlimitation code within a game’s binary with no-operation code, allowing the\nuser to run multiple game clients, even when doing so is normally forbidden.\nBecause the code that performs instance limitation must be executed very early\nafter a game client is launched, it can be nearly impossible for a bot to inject\nits patch on time. The easiest workaround for this is to make multiclient patches\npersist by applying them within OllyDbg and saving them directly to the game\nbinary.\n30 Chapter 2"
  },
  {
    "input": "Creating Code Patches",
    "output": "creating code Patches\nOllyDbg’s code patches let you make assembly code modifications for a game\nyou want to hack, removing the need to engineer a tool tailored to that\nspecific game. This makes prototyping control flow hacks—which manipulate\ngame behavior through a mix of game design flaws, x86 assembly protocols,\nand common binary constructs—much easier.\nGame hackers typically include perfected patches as optional features\nin a bot’s tool suite, but in some cases, making those features persistent is\nactually more convenient for your end user. Luckily, OllyDbg patches pro-\nvide the complete functionality you need to design, test, and permanently\nsave code modifications to an executable binary using only OllyDbg.\nTo place a patch, navigate to the line of assembly code you want to patch\nin the CPU window, double-click the instruction you wish to modify, place\na new assembly instruction in the pop-up prompt, and click Assemble, as\nshown in Figure 2-3.\nFigure 2-3: Placing a patch with OllyDbg\nAlways pay attention to the size of your patch—you can’t just resize and\nmove around assembled code however you’d like. Patches larger than the\ncode you intend to replace will overflow into subsequent operations, poten-\ntially removing critical functionality. Patches smaller than the operations\nyou intend to replace are safe, as long as Fill with NOPs is checked. This\noption fills any abandoned bytes with no-operation (NOP) commands, which\nare single-byte operations that do nothing when executed.\nAll patches you place are listed, along with the address, size, state, old\ncode, new code, and comment, in the Patches window. Select a patch in this\nlist to access a small but powerful set of hotkeys, shown in Table 2-3.\nDebugging Games with OllyDbg 31"
  },
  {
    "input": "Tracing Through Assembly Code ",
    "output": "Table 2-3: Patches Window Hotkeys\nOperator Function\nenter Jumps to the patch in the disassembler.\nspacebar Toggles the patch on or off.\nF2 Places a breakpoint on the patch.\nshift-F2 Places a conditional breakpoint on the patch.\nshift-F4 Places a conditional log breakpoint on the patch.\ndel Removes the patch entry from the list only.\nIn OllyDbg, you can also save your patches directly to the binary. First,\nright-click in the disassembler and click Copy to executable4All modifica-\ntions. If you want to copy only certain patches, highlight them in the disas-\nsembly pane and press Copy to executable4Selection instead.\nDEtErMINING PAtCH sIzE\nThere are a few ways to determine whether your patch will be a different size\nthan the original code. For example, in Figure 2-3, you can see the command\nat 0x7790ED2E being changed from SHR AL, 6 to SHR AL, 7. If you look at the\nbytes to the left of the command, you see 3 bytes that represent the memory of\nthe command. This means our new command must either be 3 bytes or padded\nwith NOPs if it’s less than 3 bytes. Furthermore, these bytes are arranged in\ntwo columns. The first column contains 0xC0 and 0x08, which represent the com-\nmand SHR and the first operand, AL. The second column contains 0x06, which\nrepresents the original operand. Because the second column shows a single\nbyte, any replacement operand must also be 1 byte (between 0x00 and 0xFF).\nIf this column had shown 0x00000006 instead, a replacement operand could be\nup to 4 bytes in length.\nTypical code patches will either use all NOPs to completely remove a\ncommand (by leaving the box empty and letting it fill the entire command with\nNOPs) or just replace a single operand, so this method of checking patch size\nis almost always effective.\nTracing Through assembly code\nWhen you run a trace on any program, OllyDbg single-steps over every\nexecuted operation and stores data about each one. When the trace is\ncomplete, the logged data is displayed in the Run trace window, shown\nin Figure 2-4.\n32 Chapter 2"
  },
  {
    "input": "OllyDbg’s Expression Engine",
    "output": "Figure 2-4: The Run trace window\nThe Run trace window is organized into the following six columns:\nBack The number of operations logged between an operation and the\ncurrent execution state\nThread The thread that executed the operation\nModule The module where the operation resides\nAddress The address of the operation\nCommand The operation that was executed\nModified registers The registers changed by the operation and their\nnew values\nWhen hacking games, I find OllyDbg’s trace feature very effective at\nhelping me find pointer paths to dynamic memory when Cheat Engine\nscans prove inconclusive. This works because you can follow the log in the\nRun trace window backward from the point when the memory is used to\nthe point where it is resolved from a static address.\nThis potent feature’s usefulness is limited only by the creativity of the\nhacker using it. Though I typically use it only to find pointer paths, I’ve\ncome across a few other situations where it has proven invaluable. The anec-\ndotes in “OllyDbg Expressions in Action” on page 36 will help to illumi-\nnate the functionality and power of tracing.\nOllydbg’s expression engine\nOllyDbg is home to a custom expression engine that can compile and evalu-\nate advanced expressions with a simple syntax. The expression engine is\nsurprisingly powerful and, when utilized properly, can be the difference\nbetween an average OllyDbg user and an OllyDbg wizard. You can use this\nengine to specify expressions for many features, such as conditional break-\npoints, conditional traces, and the command line plug-in. This section\nintroduces the expression engine and the options it provides.\nDebugging Games with OllyDbg 33"
  },
  {
    "input": "Using Operators in the Expression Engine",
    "output": "NO tE Parts of this section are based on the official expressions documentation (http://\nwww.ollydbg.de/Help/i_Expressions.htm). I have found, however, that a few\nof the components defined in the documentation don’t seem to work, at least not in\nOllyDbg v1.10. Two examples are the INT and ASCII data types, which must be sub-\nstituted with the aliases LONG and STRING. For this reason, here I include only compo-\nnents that I’ve personally tested and fully understand.\nUsing Expressions in Breakpoints\nWhen a conditional breakpoint is toggled on, OllyDbg prompts you to enter an\nexpression for the condition; this is where most expressions are used. When\nthat breakpoint is executed, OllyDbg silently pauses execution and evalu-\nates the expression. If the result of the evaluation is nonzero, execution\nremains paused and you will see the breakpoint get triggered. But if the\nresult of the evaluation is 0, OllyDbg silently resumes execution as if noth-\ning happened.\nWith the huge number of executions that happen within a game every\nsecond, you’ll often find that a piece of code is executed in far too many\ncontexts for a breakpoint to be an effective way of getting the data you are\nlooking for. A conditional breakpoint paired with a good understanding of\nthe code surrounding it is a foolproof way to avoid these situations.\nUsing Operators in the Expression Engine\nFor numeric data types, OllyDbg expressions support general C-style opera-\ntors, as seen in Table 2-4. While there is no clear documentation on the\noperator precedence, OllyDbg seems to follow C-style precedence and can\nuse parenthesized scoping.\nTable 2-4: OllyDbg Numeric Operators\nOperator Function\na == b Returns 1 if a is equal to b, else returns 0.\na != b Returns 1 if a is not equal to b, else returns 0.\na > b Returns 1 if a is greater than b, else returns 0.\na < b Returns 1 if a is less than b, else returns 0.\na >= b Returns 1 if a is greater than or equal to b, else returns 0.\na <= b Returns 1 if a is less than or equal to b, else returns 0.\na && b Returns 1 if a and b are both nonzero, else returns 0.\na || b Returns 1 if either a or b are nonzero, else returns 0.\na ^ b Returns the result of XOR(a, b).\na % b Returns the result of MODULUS(a, b).\na & b Return the result of AND(a, b).\na | b Return the result of OR(a, b).\na << b Returns the result of a shifted b bits to the left.\na >> b Returns the result of a shifted b bits to the right.\n34 Chapter 2"
  },
  {
    "input": "Working with Basic Expression Elements",
    "output": "Operator Function\na + b Returns the sum of a plus b.\na - b Returns the difference of a minus b.\na / b Returns the quotient of a divided by b.\na * b Returns the product of a times b.\n+a Returns the signed representation of a.\n-a Returns a*-1.\n!a Returns 1 if a is 0, else returns 0.\nFor strings, on the other hand, the only available operators are == and\n!=, which both adhere to the following set of rules:\n• String comparisons are case insensitive.\n• If only one of the operands is a string literal, the comparison will termi-\nnate after it reaches the length of the literal. As a result, the expression\n[STRING EAX]==\"ABC123\", where EAX is a pointer to the string ABC123XYZ, will\nevaluate to 1 instead of 0.\n• If no type is specified for an operand in a string comparison and the\nother operand is a string literal (for example, \"MyString\"!=EAX), the com-\nparison will first assume the nonliteral operand is an ASCII string, and,\nif that compare would return 0, it will try a second compare assuming\nthe operand is a Unicode string.\nOf course, operators aren’t much use without operands. Let’s look at\nsome of the data you can evaluate in expressions.\nWorking with Basic Expression Elements\nExpressions are able to evaluate many different elements, including:\nCPU registers EAX, EBX, ECX, EDX, ESP, EBP, ESI, and EDI. You can also use\nthe 1-byte and 2-byte registers (for example, AL for the low byte and AX\nfor the low word of EAX). EIP can also be used.\nSegment registers CS, DS, ES, SS, FS, and GS.\nFPU registers ST0, ST1, ST2, ST3, ST4, ST5, ST6, and ST7.\nSimple labels Can be API function names, such as GetModuleHandle, or\nuser-defined labels.\nWindows constants Such as ERROR_SUCCESS.\nIntegers Are written in hexadecimal format or decimal format if fol-\nlowed by a trailing decimal point (for example, FFFF or 65535.).\nFloating-point numbers Allow exponents in decimal format (for\nexample, 654.123e-5).\nString literals Are wrapped in quotation marks (for example, \"my\nstring\").\nDebugging Games with OllyDbg 35"
  },
  {
    "input": "OllyDbg Expressions in Action",
    "output": "The expressions engine looks for these elements in the order they’re\nlisted here. For example, if you have a label that matches the name of a\nWindows constant, the engine uses the address of the label instead of the\nconstant’s value. But if you have a label named after a register, such as EAX,\nthe engine uses the register value, not the label value.\nAccessing Memory Contents with Expressions\nOllyDbg expressions are also powerful enough to incorporate memory read-\ning, which you can do by wrapping a memory address, or an expression that\nevaluates to one, in square brackets. For example, [EAX+C] and [401000] rep-\nresent the contents at the addresses EAX+C and 401000. To read the mem-\nory as a type other than DWORD, you can specify the desired type either before\nthe brackets, as in BYTE [EAX], or as the first token within them, as in [STRING\nESP+C]. Supported types are listed in Table 2-5.\nTable 2-5: OllyDbg Data Types\nData type Interpretation\nBYTE 8-bit integer (unsigned)\nCHAR 8-bit integer (signed)\nWORD 16-bit integer (unsigned)\nSHORT 16-bit integer (signed)\nDWORD 32-bit integer (unsigned)\nLONG 32-bit integer (signed)\nFLOAT 32-bit floating-point number\nDOUBLE 64-bit floating-point number\nSTRING Pointer to an ASCII string (null-terminated)\nUNICODE Pointer to a Unicode string (null-terminated)\nPlugging memory contents directly into your OllyDbg expressions is\nincredibly useful in game hacking, in part because you can tell the debug-\nger to check a character’s health, name, gold, and so on in memory before\nbreaking. You’ll see an example of this in “Pausing Execution When a\nSpecific Player’s Name Is Printed” on page 37.\nOllydbg expressions in action\nExpressions in OllyDbg use a syntax similar to that of most programming\nlanguages; you can even combine multiple expressions and nest one expres-\nsion within another. Game hackers (really, all hackers) commonly use them\nto create conditional breakpoints, as I described in “Using Expressions in\nBreakpoints” on page 34, but you can use them in many different places\nin OllyDbg. For instance, OllyDbg’s command line plug-in can evaluate\n36 Chapter 2"
  },
  {
    "input": "Pausing Execution When a Specific Player’s Name Is Printed",
    "output": "expressions in place and display their results, allowing you to easily read\narbitrary memory, inspect values that are being calculated by assembly code,\nor quickly get the results of mathematical equations. Furthermore, hackers\ncan even create intelligent, position-agnostic breakpoints by coupling expres-\nsions with the trace feature.\nIn this section, I’ll share some anecdotes where the expression engine\nhas come in handy during my work. I will explain my thought process, walk\nthrough my entire debugging session, and break each expression down into\nits component parts so you can see some ways to use OllyDbg expressions in\ngame hacking.\nNO tE These examples contain some assembly code, but if you don’t have much experience\nwith assembly, don’t worry. Just ignore the fine details and know that values like ECX,\nEAX, and ESP are process registers like the ones discussed in “Viewing and Editing\nRegister Contents” on page 29. From there, I’ll explain everything else.\nIf you get confused about an operator, element, or data type in an\nexpression as I walk through these anecdotes, just refer to “OllyDbg’s\nExpression Engine” on page 33.\nPausing Execution When a Specific Player’s Name Is Printed\nDuring one particular debugging session, I needed to figure out exactly\nwhat was happening when a game was drawing the names of players on\nscreen. Specifically, I needed to invoke a breakpoint before the game drew\nthe name “Player 1,” ignoring all other names that were drawn.\nFiguring Out Where to Pause\nAs a starting point, I used Cheat Engine to find the address of Player 1’s\nname in memory. Once I had the address, I used OllyDbg to set a memory\nbreakpoint on the first byte of the string. Every time this breakpoint got\nhit, I quickly inspected the assembly code to determine how it was using\nPlayer 1’s name. Eventually, I found the name being accessed directly above\na call to a function that I had previously given the name printText(). I had\nfound the code that was drawing the name.\nI removed my memory breakpoint and replaced it with a code breakpoint\non the call to printText(). There was a problem, however: because the call to\nprintText() was inside a loop that iterated over every player in the game, my\nnew breakpoint was getting hit every time a name was drawn—and that was\nmuch too often. I needed to fix it to hit only on a specific player.\nInspecting the assembly code at my previous memory breakpoint told\nme that each player’s name was accessed using the following assembly code:\nPUSH DWORD PTR DS:[EAX+ECX*90+50]\nThe EAX register contained the address of an array of player data; I’ll\ncall it playerStruct. The size of playerStruct was 0x90 bytes, the ECX register\ncontained the iteration index (the famous variable i), and each player’s\nDebugging Games with OllyDbg 37\nname was stored 0x50 bytes after the start of its respective playerStruct. This\nmeant that this PUSH instruction essentially put EAX[ECX].name (the name of the\nplayer at index i) on the stack to be passed as an argument to the printText()\nfunction call. The loop, then, broke down to something like the following\npsuedocode:\nplayerStruct EAX[MAX_PLAYERS]; // this is filled elsewhere\nfor (int uECX = 0; ECX < MAX_PLAYERS; ECX++) {\nchar* name = vEAX[ECX].name;\nbreakpoint(); // my code breakpoint was basically right here\nprintText(name);\n}\nPurely through analysis, I determined that the playerStruct() function\ncontained data for all players, and the loop iterated over the total number\nof players (counting up with ECX u), fetched the character name v for each\nindex, and printed the name.\nCrafting the Conditional Breakpoint\nKnowing that, to pause execution only when printing “Player 1” all I had to\ndo was check the current player name before executing my breakpoint. In\npseudocode, the new breakpoint would look like this:\nif (EAX[ECX].name == \"Player 1\") breakpoint();\nOnce I figured out the form of my new breakpoint, I needed to access\nEAX[ECX].name from within the loop. That’s where OllyDbg’s expression engine\ncame in: I could achieve my goal by making slight modifications to the\nexpression that the assembly code used, leaving me with this expression:\n[STRING EAX + ECX*0x90 + 0x50] == \"Player 1\"\nI removed the code breakpoint on printText() and replaced it with\na conditional breakpoint that used this expression, which told OllyDbg\nto break only if the string value stored at EAX + ECX*0x90 + 0x50 matched\nPlayer 1’s name. This breakpoint hit only when \"Player 1\" was being drawn,\nallowing me to continue my analysis.\nThe amount of work it took to engineer this breakpoint might seem\nextensive, but with practice, the entire process becomes as intuitive as writ-\ning code. Experienced hackers can do this in a matter of seconds.\nIn practice, this breakpoint enabled me to inspect certain values in\nthe playerStruct() function for \"Player 1\" as soon as he appeared on screen.\nDoing it this way was important, as the states of these values were relevant\nto my analysis only in the first few frames after the player entered the screen.\nCreatively using breakpoints like this can enable you to analyze all sorts of\ncomplex game behavior.\n38 Chapter 2"
  },
  {
    "input": "Pausing Execution When Your Character’s Health Drops ",
    "output": "Pausing Execution When Your Character’s Health Drops\nDuring another debugging session, I needed to find the first function called\nafter my character’s health dropped below the maximum. I knew two ways\nto approach this problem:\n• Find every piece of code that accesses the health value and place a con-\nditional breakpoint that checks the health on each one. Then, once one\nof these breakpoints is hit, single-step through the code until the next\nfunction call.\n• Use OllyDbg’s trace function to create a dynamic breakpoint that can\nstop exactly where I need.\nThe first method required more setup and was not easily repeatable,\nmostly due to the sheer number of breakpoints needed and the fact that\nI’d have to single-step by hand. In contrast, the latter method had a quick\nsetup, and since it did everything automatically, it was easily repeatable.\nThough using the trace function would slow the game down consider-\nably (every single operation was captured by the trace), I chose the latter\nmethod.\nWriting an Expression to Check Health\nOnce again, I started by using Cheat Engine to find the address that stored\nmy health. Using the method described in “Cheat Engine’s Memory Scanner”\non page 5, I determined the address to be 0x40A000.\nNext, I needed an expression that told OllyDbg to return 1 when my\nhealth was below maximum and return 0 otherwise. Knowing that my health\nwas stored at 0x40A000 and that the maximum value was 500, I initially\ndevised this expression:\n[0x40A000] < 500.\nThis expression would invoke a break when my health was below 500\n(remember, decimal numbers must be suffixed with a period in the expres-\nsion engine), but instead of waiting for a function to be called, the break\nwould happen immediately. To ensure that it waited until a function was\ncalled, I appended another expression with the && operator:\n[0x40A000] < 500. && [uBYTE EIP] == 0xE8\nOn x86 processors, the EIP register stores the address of the operation\nbeing executed, so I decided to check the first byte at EIP u to see if it was\nequal to 0xE8. This value tells the processor to execute a near function call,\nwhich is the type of call I was looking for.\nBefore starting my trace, I had to do one last thing. Because the trace\nfeature repeatedly single-steps (Trace into uses step into and Trace over\nDebugging Games with OllyDbg 39\nuses step over, as described in “A Brief Look at OllyDbg’s User Interface”\non page 24), I needed to start the trace at a location scoped at or above\nthe level of any code that could possibly update the health value.\nFiguring Out Where to Start the trace\nTo find a good location, I opened the game’s main module in OllyDbg’s\nCPU window, right-clicked in the disassembler pane, and selected Search\nfor4All intermodular calls. The References window popped up and dis-\nplayed a list of external API functions that were called by the game.\nNearly all gaming software polls for new messages using the Windows\nUSER32.PeekMessage() function, so I sorted the list using the Destination col-\numn and typed PEEK (you can search the list by simply typing a name with\nthe window in focus) to locate the first call to USER32.PeekMessage().\nThanks to the Destination sorting, every call to this function was listed\nin a contiguous chunk following the first, as shown in Figure 2-5. I set a\nbreakpoint on each by selecting it and pressing F2.\nFigure 2-5: OllyDbg’s Found intermodular calls window\nThough there were around a dozen calls to USER32.PeekMessage(), only\ntwo of them were setting off my breakpoints. Even better, the active calls\nwere beside one another in an unconditional loop. At the bottom of this\nloop were a number of internal function calls. This looked exactly like a\nmain game loop.\nactivating the trace\nTo finally set my trace, I removed all of my previous breakpoints and placed\none at the top of the suspected main loop. I removed the breakpoint as soon\nas it was hit. I then pressed ctrl-T from the CPU window, which brought up a\n40 Chapter 2\ndialog called Condition to pause run trace, shown in Figure 2-6. Within this\nnew dialog, I enabled the Condition is TRUE option, placed my expression in\nthe box beside it, and pressed OK. Then, I went back to the CPU window and\npressed ctrl-F11 to begin a Trace Into session.\nFigure 2-6: Condition to pause run trace dialog\nOnce the trace began, the game ran so slowly it was nearly unplayable.\nTo decrease my test character’s health, I opened a second instance of the\ngame, logged into a different character, and attacked my test character.\nWhen the execution of the trace caught up to real time, OllyDbg saw my\nhealth change and triggered the breakpoint on the following function\ncall—just as expected.\nIn this game, the main pieces of code that would modify the health\nvalue were directly invoked from the network code. Using this trace, I was\nable to find the function that the network module called directly after a\nnetwork packet told the game to change the player’s health. Here’s the\npsuedocode of what the game was doing:\nvoid network::check() {\nwhile (this->hasPacket()) {\npacket = this->getPacket();\nif (packet.type == UPDATE_HEALTH) {\noldHealth = player->health;\nplayer->health = packet.getInteger();\nu observe(HEALTH_CHANGE, oldHealth, player->health);\n}\n}\n}\nI knew the game had code that needed to execute only when the player’s\nhealth was changed, and I needed to add code that could also respond to\nsuch changes. Without knowing the overall code structure, I guessed that\nDebugging Games with OllyDbg 41"
  },
  {
    "input": "Adding Cheat Engine to OllyDbg with Cheat Utility",
    "output": "the health-dependent code would be executed from some function call\ndirectly after health was updated. My trace conditional breakpoint con-\nfirmed this hunch, as it broke directly on the observe() function u. From\nthere, I was able to place a hook on the function (hooking, a way to intercept\nfunction calls, is described in “Hooking to Redirect Game Execution” on\npage 153) and execute my own code when the player’s health changed.\nOllydbg Plug-ins for Game Hackers\nOllyDbg’s highly versatile plug-in system is perhaps one of its most power-\nful features. Experienced game hackers often configure their OllyDbg\nenvironments with dozens of useful plug-ins, both publicly available and\ncustom-made.\nYou can download popular plug-ins from the OpenRCE (http://www\n.openrce.org/downloads/browse/OllyDbg_Plugins) and tuts4you (http://www\n.tuts4you.com/download.php?list.9/) plug-in repositories. Installing them is\neasy: just unzip the plug-in files and place them inside OllyDbg’s installa-\ntion folder.\nOnce installed, some plug-ins can be accessed from the OllyDbg’s Plugin\nmenu item. Other plug-ins, however, might be found only in specific places\nthroughout the OllyDbg interface.\nYou can find hundreds of potent plug-ins using these online reposito-\nries, but you should be careful when constructing your arsenal. Working\nin an environment bloated by unused plug-ins can actually impede pro-\nductivity. In this section, I’ve carefully selected four plug-ins that I believe\nare not only integral to a game hacker’s toolkit but also noninvasive to the\nenvironment.\nCopying Assembly Code with Asm2Clipboard\nAsm2Clipboard is a minimalistic plug-in from the OpenRCE repository that\nallows you to copy chunks of assembly code from the disassembler pane to\nthe clipboard. This can be useful for updating address offsets and devising\ncode caves, two game-hacking essentials I cover deeply in Chapters 5 and 7.\nWith Asm2Clipboard installed, you can highlight a block of assem-\nbly code in the disassembler, right-click the highlighted code, expand\nthe Asm2Clipboard submenu, and select either Copy fixed Asm code to\nclipboard or Copy Asm code to clipboard. The latter prepends the code\naddress of each instruction as a comment, while the former copies only\nthe pure code.\nAdding Cheat Engine to OllyDbg with Cheat Utility\nThe Cheat Utility plug-in from tuts4you provides a highly slimmed-down\nversion of Cheat Engine within OllyDbg. While Cheat Utility only allows\nyou to do exact-value scans with a very limited number of data types, it can\n42 Chapter 2"
  },
  {
    "input": "Controlling OllyDbg Through the Command Line",
    "output": "make simple scans much easier when you don’t need the full functional-\nity of Cheat Engine to find what you’re looking for. After installing Cheat\nUtility, to open its interface (shown in Figure 2-7), select Plugins4Cheat\nutility4Start.\nFigure 2-7: Cheat Utility interface\nCheat Utility’s user interface and operation mimic Cheat Engine\nclosely, so review Chapter 1 if you need a refresher.\nNO tE Games Invader, an updated version of Cheat Utility also from tuts4you, was created\nto provide more functionality. I’ve found it buggy, however, and I prefer Cheat Utility\nsince I can always use Cheat Engine for advanced scans.\nControlling OllyDbg Through the Command Line\nThe command line plug-in enables you to control OllyDbg through a small\ncommand line interface. To access the plug-in, either press alt-F1 or select\nPlugins4Command line4Command line. You should then see a window,\nshown in Figure 2-8, which acts as the command line interface.\n(cid:31)\n(cid:30)\n(cid:29)\nFigure 2-8: Command line interface\nTo execute a command, type it into the input box u and press enter.\nYou will see a session-level command history in the center list v, and the\nbottom label displays the command’s return value w (if any).\nDebugging Games with OllyDbg 43\nThough there are many commands available, I find a majority of\nthem useless. I primarily use this tool as a way to test that expressions are\nparsing as expected and as a handy calculator, but there are a few addi-\ntional use cases that are also worth mentioning. I’ve described these in\nTable 2-6.\nTable 2-6: Command Line Plug-in Commands\nCommand Function\nBC identifier Removes any breakpoints present on identifier,\nwhich can be a code address or API function name.\nBP identifier [,condition] Places a debugger breakpoint on identifier,\nwhich can be a code address or API function\nname. When identifier is an API function name, the\nbreakpoint will be placed on the function entry point.\nThe condition parameter is an optional expression\nthat, if present, will be set as the breakpoint\ncondition.\nBPX label Places a debugger breakpoint on every instance\nof label within the module currently being\ndisassembled. This label will typically be an\nAPI function name.\nCALC expression Evaluates expression and displays the result.\n? expression\nHD address Removes any hardware breakpoints present on\naddress.\nHE address Places a hardware on-execute breakpoint on\naddress.\nHR address Places a hardware on-access breakpoint on\naddress. Only four hardware breakpoints can\nexist at a time.\nHW address Places a hardware on-write breakpoint on address.\nMD Removes any existing memory breakpoint, if\npresent.\nMR address1, address2 Places a memory on-access breakpoint starting at\naddress1 and spanning until address2. Will replace\nany existing memory breakpoint.\nMW address1, address2 Places a memory on-write breakpoint starting at\naddress1 and spanning until address2. Will replace\nany existing memory breakpoint.\nWATCH expression Opens the Watches window and adds expression\nW expression to the watch list. Expressions in this list will be\nreevaluated every time the process receives\na message and the evaluation results will be\ndisplayed beside them.\nThe command line plug-in was made by the OllyDbg developer and\nshould come preinstalled with OllyDbg.\n44 Chapter 2"
  },
  {
    "input": "Visualizing Control Flow with OllyFlow",
    "output": "Visualizing Control Flow with OllyFlow\nOllyFlow, which can be found in the OpenRCE plug-in directory, is a purely\nvisual plug-in that can generate code graphs like the one in Figure 2-9 and\ndisplay them using Wingraph32.\nFigure 2-9: An OllyFlow function flowchart\nNOtE Wingraph32 is not provided with OllyFlow, but it is available with the free version of\nIDA here: https://www.hex-rays.com/products/ida/. Download it and drop the\n.exe in your OllyDbg installation folder.\nThough not interactive, these graphs allow you to easily identify con-\nstructs such as loops and nested if() statements in game code, which can be\nparamount in control flow analysis. With OllyFlow installed, you can gener-\nate a graph by going to Plugins4OllyFlow (alternatively, right-click in the\ndisassembler pane and expand the OllyFlow graph submenu) and selecting\none of the following options:\nGenerate function flowchart Generates a graph of the function cur-\nrently in scope, breaking apart different code blocks and showing jump\npaths. Figure 2-9 shows a function flowchart. Without a doubt, this is\nOllyFlow’s most useful feature.\nGenerate xrefs from graph Generates a graph of all functions called\nby the function that is currently in scope.\nGenerate xrefs to graph Generates a graph of all functions that call\nthe function currently in scope.\nDebugging Games with OllyDbg 45\nGenerate call stack graph Generates a graph of the assumed call path\nfrom the process entry point to the function currently in scope.\nGenerate module graph Theoretically generates a complete graph of\nall function calls in the entire module, but rarely actually works.\nTo get an idea of the usefulness of OllyFlow, take a look at the graph\nin Figure 2-9 and compare it to the relatively simple assembly function that\ngenerated it:\n76f86878:\nu MOV EAX,DWORD PTR DS:[76FE7E54]\nTEST AL,1\nJE ntdll.76F8689B\n76f86881:\nv MOV EAX,DWORD PTR FS:[18]\nMOV EAX,DWORD PTR DS:[EAX+30]\nOR DWORD PTR DS:[EAX+68],2000000\nMOV EAX,DWORD PTR DS:[76FE66E0]\nOR DWORD PTR DS:[EAX],1\nJMP ntdll.76F868B2\n76f8689b:\nw TEST EAX,8000\nJE ntdll.76F868B2\n76f868a2:\nx MOV EAX,DWORD PTR FS:[18]\nMOV EAX,DWORD PTR DS:[EAX+30]\nOR DWORD PTR DS:[EAX+68],2000000\n76f868b2:\ny MOV AL,1\nRETN\nThere are five boxes in Figure 2-9, and they map to the five pieces of\nthis function. The function starts with u, and it falls through to v if the\nbranch fails or jumps to w if it succeeds. After v executes, it jumps directly\nto piece y, which then returns out of the function. After w executes, it\neither falls through to x or branches to y to return directly. After x\nexecutes, it unconditionally falls through to y. What this function does is\nirrelevant to understanding OllyFlow; for now, just focus on seeing how the\ncode maps to the graph.\nPAtCHING AN I f() stAtEMENt\nIf you think you’re ready to get your hands dirty with OllyDbg, keep read-\ning. Go to https://www.nostarch.com/gamehacking/, download the book’s\nresource files, grab BasicDebugging.exe, and execute it. At first glance, you’ll\nsee that it looks like the classic game Pong. In this version of Pong, the ball is\ninvisible to you when it is on your opponent’s screen. Your task is to disable\nthis feature so that you can always see the ball. To make it easier for you, I’ve\nmade the game autonomous. You don’t have to play, only hack.\n46 Chapter 2"
  },
  {
    "input": "Closing Thoughts",
    "output": "To start, attach OllyDbg to the game. Then focus the CPU window on the\nmain module (find the .exe in the module list and double-click it) and use the\nReferenced text strings feature to locate the string that is displayed when the\nball is hidden. Next, double-click the string to bring it up in the code and\nanalyze the surrounding code until you find the if() statement that determines\nwhether to hide the ball. Lastly, using the code-patching feature, patch the\nif() statement so the ball is always drawn. As an added bonus, you might try\nusing OllyFlow to graph this function so you can get a better understanding\nof what exactly it is doing. (Hint: The if() statement checks whether the ball’s\nx-coordinate is less than 0x140. If so, it jumps to code that draws the ball.\nIf not, it draws the scene without the ball. If you can change 0x140 to, say,\n0xFFFF, the ball will never get hidden.)\nclosing Thoughts\nOllyDbg is a much more complex beast than Cheat Engine, but you’ll learn\nbest by using it, so dive in and get your hands dirty! You can start by pairing\nthe controls taught in this chapter with your debugging skills and going to\nwork on some real games. If you are not yet ready to tamper with your vir-\ntual fate, however, try tackling the example in “Patching an if() Statement”\nfor a practice environment. When you’re done, read on to Chapter 3, where\nI’ll introduce you to Process Monitor and Process Explorer, two tools you’ll\nfind invaluable in game-hacking reconnaissance.\nDebugging Games with OllyDbg 47"
  },
  {
    "input": "Chapter 3: Reconnaissance \rwith Process Monitor \rand Process Explorer",
    "output": "3\nrECONNAIssANCE\nwItH Pr OCEss MONI tOr\nAND Pr OCEss E xPlOr Er\nCheat Engine and OllyDbg can help you\ntear apart a game’s memory and code, but\nyou also need to understand how the game\ninteracts with files, registry values, network\nconnections, and other processes. To learn how those\ninteractions work, you must use two tools that excel at\nmonitoring the external actions of processes: Process Monitor and Process\nExplorer. With these tools, you can track down the complete game map,\nlocate save files, identify registry keys used to store settings, and enumerate\nthe Internet Protocol (IP) addresses of remote game servers.\nIn this chapter, I’ll teach you how to use both Process Monitor and\nProcess Explorer to log system events and inspect them to see how a game\nwas involved. Useful mainly for initial reconnaissance, these tools are"
  },
  {
    "input": "Logging In-Game Events",
    "output": "amazing at giving a clear, verbose picture of exactly how a game interacts\nwith your system. You can download both programs from the Windows\nSysinternals website (https://technet.microsoft.com/en-us/sysinternals/).\nProcess monitor\nYou can learn a lot about a game simply by exploring how it interacts with\nthe registry, filesystem, and network. Process Monitor is a powerful system-\nmonitoring tool that logs such events in real time and lets you seamlessly\nintegrate the data into a debugging session. This tool provides extensive\namounts of useful data regarding a game’s interaction with the external\nenvironment. With calculated review (and sometimes, spontaneous intu-\nition) on your part, this data can reveal details about data files, network\nconnections, and registry events that are helpful to your ability to see and\nmanipulate how the game functions.\nIn this section, I’ll show you how to use Process Monitor to log data,\nnavigate it, and make educated guesses about the files a game interacts with.\nAfter this interface tour, you’ll have a chance to try out Process Monitor for\nyourself in “Finding a High Score File” on page 55.\nLogging In-Game Events\nProcess Monitor’s logs can hold all sorts of potentially useful informa-\ntion, but their most practical use is to help you figure out where data files,\nsuch as in-game item definitions, might be stored. When you start Process\nMonitor, the first dialog you see is the Process Monitor Filter, shown in\nFigure 3-1.\nFigure 3-1: Process Monitor Filter dialog\nThis dialog allows you to show or suppress events based on a number\nof dynamic properties they possess. To start monitoring processes, select\nProcess Name4Is4YourGameFilename.exe4Include and then press Add,\n50 Chapter 3\nApply, and OK. This tells Process Monitor to show events invoked by\nYourGameFilename.exe. With the proper filters set, you will be taken to the\nmain window shown in Figure 3-2.\nFigure 3-2: Process Monitor main window\nTo configure the columns displayed in Process Monitor’s log area, right-\nclick on the header and choose Select Columns. There’s an impressive\nnumber of options, but I recommend seven.\nTime of Day Lets you see when actions are happening.\nProcess Name Is useful if you’re monitoring multiple processes, but\nwith the single-process filter that is typically used for games; disabling\nthis option can save precious space.\nProcess ID Is like Process Name, but it shows the ID rather than\nthe name.\nOperation Shows what action was performed; thus, this option is\ncompulsory.\nPath Shows the path of the action’s target; also compulsory.\nDetail Is useful only in some cases, but enabling it won’t hurt.\nResult Shows when actions, such as loading files, fail.\nAs you show more columns, the log can get very crowded, but sticking\nwith these options should help keep the output succinct.\nOnce the monitor is running and you’ve defined the columns you wish\nto see, there are five event class filters, outlined in black in Figure 3-2, that\nyou can toggle to clean up your logs even further. Event class filters let you\nchoose which events to show in the log, based on type. From left to right,\nthese filters are as follows:\nRegistry Shows all registry activity. There will be a lot of white noise\nin the registry upon process creation, as games rarely use the registry\nand Windows libraries always use it. Leaving this filter disabled can save\na lot of space in the log.\nReconnaissance with Process Monitor and Process Explorer 51"
  },
  {
    "input": "Inspecting Events in the Process Monitor Log",
    "output": "Filesystem Shows all filesystem activity. This is the most important\nevent class filter, since knowing where data files are stored and how they\nare accessed is integral to writing an effective bot.\nNetwork Shows all network activity. The call stack on network events\ncan be useful in finding network-related code within a game.\nProcess and thread activity Shows all process and thread actions. The\ncall stack on these events can give you insight into how a game’s code\nhandles threads.\nProcess profiling Periodically shows information about the memory\nand CPU usage of each running process; a game hacker will rarely use it.\nIf class-level event filtering is still not precise enough to filter out\nunwanted pollution in your logs, right-click on specific events for event-\nlevel filtering options. Once you have your event filtering configured to log\nonly what you need, you can begin navigating the log. Table 3-1 lists some\nuseful hotkeys for controlling the log’s behavior.\nTable 3-1: Process Monitor Hotkeys\nHotkey Action\nctrl-E Toggles logging.\nctrl-A Toggles automatic scrolling of the log.\nctrl-X Clears the log.\nctrl-L Displays the Filter dialog.\nctrl-H Displays the Highlight dialog. This dialog looks very similar to\nthe Filter dialog, but it is used to indicate which events should\nbe highlighted.\nctrl-F Displays the Search dialog.\nctrl-P Displays the Event Properties dialog for the selected event.\nAs you navigate the log, you can examine the operations recorded to\nsee the fine-grained details of an event.\nInspecting Events in the Process Monitor Log\nProcess Monitor logs every data point it possibly can about an event,\nenabling you to learn more about these events than just the files they act\nupon. Carefully inspecting data-rich columns, such as Result and Detail,\ncan yield some very interesting information.\nFor example, I’ve found that games sometimes read data structures,\nelement by element, directly from files. This behavior is apparent when a\nlog contains a large number of reads to the same file, where each read has\nsequential offsets but differing lengths. Consider the hypothetical event log\nshown in Table 3-2.\n52 Chapter 3"
  },
  {
    "input": "Debugging a Game to Collect More Data",
    "output": "Table 3-2: Example Event Log\nOperation Path Detail\nCreate File C:\\file.dat Desired Access: Read\nRead File C:\\file.dat Offset: 0 Size: 4\nRead File C:\\file.dat Offset: 4 Size: 2\nRead File C:\\file.dat Offset: 6 Size: 2\nRead File C:\\file.dat Offset: 8 Size: 4\nRead File C:\\file.dat Offset: 12 Size: 4\n... ... ...Continues to read chunks of 4 bytes for a while\nThis log reveals that the game is reading a structure from the file piece\nby piece, disclosing some hints about what the structure looks like. For\nexample, let’s say that these reads reflect the following data file:\nstruct myDataFile\n{\nint header; // 4 bytes (offset 0)\nshort effectCount; // 2 bytes (offset 4)\nshort itemCount; // 2 bytes (offset 6)\nint* effects;\nint* items;\n};\nCompare the log in Table 3-2 with this structure. First, the game reads\nthe 4 header bytes. Then, it reads two 2-byte values: effectCount and itemCount.\nIt then creates two integer arrays, effects and items, of respective lengths\neffectCount and itemCount. The game then fills these arrays with data from\nthe file, reading 4 bytes effectCount + itemCount times.\nNO tE Developers definitely shouldn’t use a process like this to read data from a file, but\nyou’d be amazed at how often it happens. Fortunately for you, naïveté like this just\nmakes your analysis easier.\nIn this case, the event log can identify small pieces of information\nwithin a file. But keep in mind that, while correlating the reads with the\nknown structure is easy, it’s much harder to reverse engineer an unknown\nstructure from nothing but an event log. Typically, game hackers will use\na debugger to get more context about each interesting event, and the\ndata from Process Monitor can be seamlessly integrated into a debugging\nsession, effectively tying together the two powerful reverse engineering\nparadigms.\nDebugging a Game to Collect More Data\nLet’s step away from this hypothetical file read and look at how Process\nMonitor lets you transition from event logging to debugging. Process Monitor\nstores a complete stack trace for each event, showing the full execution\nReconnaissance with Process Monitor and Process Explorer 53\nchain that led to the event being triggered. You can view these stack traces\nin the Stack tab of the Event Properties window (double-click the event or\npress ctrl-P), as shown in Figure 3-3.\n(cid:31) (cid:30) (cid:29) (cid:28) (cid:27)\nFigure 3-3: Process Monitor event call stack\nThe stack trace is displayed in a table starting with a Frame column u,\nwhich shows the execution mode and stack frame index. A pink K in this\ncolumn means the call happened in kernel mode, while a blue U means it\nhappened in user mode. Since game hackers typically work in user mode,\nkernel mode operations are usually meaningless.\nThe Module column v shows the executable module where the calling\ncode was located. Each module is just the name of the binary that made\nthe call; this makes it easy to identify which calls were actually made from\nwithin a game binary.\nThe Location column w shows the name of the function that made\neach call, as well as the call offset. These function names are deduced from\nthe export table of the module and will generally not be present for the\nfunctions within a game binary. When no function names are present, the\nLocation column instead shows the module name and the call’s offset (how\nmany bytes past the origin address the call is in memory) from the mod-\nule’s base address.\n54 Chapter 3"
  },
  {
    "input": "Process Explorer",
    "output": "NO tE In the context of code, the offset is how many bytes of assembly code are between an\nitem and its origin.\nThe Address column x shows the code address of the call, which is very\nuseful because you can jump to the address in the OllyDbg disassembler.\nFinally, the Path column y shows the path to the module that made the call.\nIn my opinion, the stack trace is, by far, the most powerful feature in\nProcess Monitor. It reveals the entire context that led to an event, which can\nbe immensely useful when you are debugging a game. You can use it to find\nthe exact code that triggered an event, crawl up the call chain to see how it\ngot there, and even determine exactly what libraries were used to complete\neach action.\nProcess Monitor’s sister application, Process Explorer, doesn’t have\nmany capabilities beyond those in Process Monitor or OllyDbg. But it does\nexpose some of those capabilities much more effectively, making it an ideal\npick in certain situations.\nfINDING A HIGH sCOrE fIlE\nIf you’re ready to test your Process Monitor skills, you’ve come to the right\nplace. Open the GameHackingExamples/Chapter3_FindingFiles directory\nand execute FindingFiles .exe. You’ll see that it is a game of Pong, like the one\nin “Patching an if() Statement” on page 46. Unlike in Chapter 2, though,\nnow the game is actually playable. It also displays your current score and\nyour all-time-high score.\nNow restart the game, firing up Process Monitor before executing it for the\nsecond time. Filtering for filesystem activity and creating any other filters you\nsee fit, try to locate where the game stores the high-score file. For bonus points,\ntry to modify this file to make the game show the highest possible score.\nProcess explorer\nProcess Explorer is an advanced task manager (it even has a button you\ncan press to make it your default task manager), and it’s very handy when\nyou’re starting to understand how a game operates. It provides complex\ndata about running processes, such as parent and child processes, CPU\nusage, memory usage, loaded modules, open handles, and command line\narguments, and it can manipulate those processes. It exceeds at showing\nyou high-level information, such as process trees, memory consumption,\nfile access, and process IDs, all of which can be very useful.\nOf course, none of this data is specifically useful in isolation. But with\na keen eye, you can make correlations and draw some useful conclusions\nabout what global objects—including files, mutexes, and shared memory\nReconnaissance with Process Monitor and Process Explorer 55"
  },
  {
    "input": "Process Explorer’s User Interface and Controls",
    "output": "segments—a game has access to. Additionally, the data shown in Process\nExplorer can be even more valuable when cross-referenced with data gath-\nered in a debugging session.\nThis section introduces the Process Explorer interface, discusses the\nproperties it shows, and describes how you can use this tool to manipu-\nlate handles (references to system resources). After this introduction, use\n“Finding and Closing a Mutex” on page 60 to hone your skills.\nProcess Explorer’s User Interface and Controls\nWhen you open Process Explorer, you see a window that is split into three\ndistinct sections, as in Figure 3-4.\n(cid:31)\n(cid:30)\n(cid:29)\nFigure 3-4: Process Explorer main window\nThose three sections are the toolbar u, an upper pane v, and a lower\npane w. The upper pane shows a list of processes, utilizing a tree struc-\nture to display their parent/child relationships. Different processes are\nhighlighted with different colors; if you don’t like the current colors, click\nOptions4Configure Colors to display a dialog that allows you to view and\nchange them.\nJust as in Process Monitor, the display for this table is highly versatile,\nand you can customize it by right-clicking on the table header and choosing\nSelect Columns. There are probably more than 100 customization options,\nbut I find that the defaults with the addition of the ASLR Enabled column\nwork just fine.\n56 Chapter 3"
  },
  {
    "input": "Examining Process Properties",
    "output": "NO tE Address Space Layout Randomization (ASLR) is a Windows security feature\nthat allocates executable images at unpredictable locations, and knowing whether it’s\non is invaluable when you’re trying to alter game state values in memory.\nThe lower pane has three possible states: Hidden, DLLs, and Handles.\nThe Hidden option hides the pane from view, DLLs displays a list of\nDynamic Link Libraries loaded within the current process, and Handles\nshows a list of handles held by the process (visible in Figure 3-4). You can\nhide or unhide the entire lower pane by toggling View4Show Lower\nPane. When it is visible, you can change the information display by\nselecting either View4Lower Pane View4DLLs or View4Lower Pane\nView4Handles.\nYou can also use hotkeys to quickly change between lower pane modes\nwithout affecting processes in the upper pane. These hotkeys are listed in\nTable 3-3.\nTable 3-3: Process Explorer Hotkeys\nHotkey Action\nctrl-F Search through lower pane data sets for a value.\nctrl-L Toggle the lower pane between hidden and visible.\nctrl-D Toggle the lower pane to display DLLs.\nctrl-H Toggle the lower pane to display handles.\nspacebar Toggle process list autorefresh.\nenter Display the Properties dialog for the selected process.\ndel Kill the selected process.\nshift-del Kill the selected process and all child processes.\nUse the GUI or hotkeys to practice changing modes. When you’re\nacquainted with the main window, we’ll look at another important Process\nExplorer dialog, called Properties.\nExamining Process Properties\nMuch like Process Monitor, Process Explorer has a very kinetic approach to\ndata gathering; the end result is a broad and verbose spectrum of informa-\ntion. In fact, if you open the Properties dialog (shown in Figure 3-5) for a\nprocess, you’ll see a massive tab bar containing 10 tabs.\nThe Image tab, selected by default and shown in Figure 3-5, displays the\nexecutable name, version, build date, and complete path. It also displays the\ncurrent working directory and the Address Space Layout Randomization sta-\ntus of the executable. ASLR status is the most important piece of informa-\ntion here, because it has a direct effect on how a bot can read the memory\nfrom a game. I’ll talk about this more in Chapter 6.\nReconnaissance with Process Monitor and Process Explorer 57\nFigure 3-5: Process Explorer Properties dialog\nThe Performance, Performance Graph, Disk and Network, and GPU\nGraph tabs display a myriad of metrics about the CPU, memory, disk, net-\nwork, and GPU usage of the process. If you create a bot that injects into a\ngame, this information can be very useful to determine how much of a per-\nformance impact your bot has on the game.\nThe TCP/IP tab displays a list of active TCP connections, which you\ncan use to find any game server IP addresses that a game connects to. If\nyou’re trying to test connection speed, terminate connections, or research\na game’s network protocol, this information is critical.\nThe Strings tab displays a list of strings found in either the binary or\nthe memory of the process. Unlike the string list in OllyDbg, which shows\nonly strings referenced by assembly code, the list includes any occurrences\nof three or more consecutive readable characters, followed by a null termi-\nnator. When a game binary is updated, you can use a diffing tool on this\nlist from each game version to determine whether there are any new strings\nthat you want to investigate.\nThe Threads tab shows you a list of threads running within the pro-\ncess and allows you to pause, resume, or kill each thread; the Security tab\ndisplays the security privileges of the process; and the Environment tab dis-\nplays any environment variables known to or set by the process.\n58 Chapter 3"
  },
  {
    "input": "Handle Manipulation Options",
    "output": "NO tE If you open the Properties dialog for a .NET process, you’ll notice two additional\ntabs: .NET Assemblies and .NET Performance. The data in these tabs is pretty self-\nexplanatory. Please keep in mind that a majority of the techniques in this book won’t\nwork with games written in .NET.\nHandle Manipulation Options\nAs you’ve seen, Process Explorer can provide you with a wealth of informa-\ntion about a process. That’s not all it’s good for, though: it can also manipu-\nlate certain parts of a process. For example, you can view and manipulate\nopen handles from the comfort of Process Explorer’s lower pane (see\nFigure 3-4). This alone makes a strong argument for adding Process\nExplorer to your toolbox. Closing a handle is as simple as right-clicking on\nit and selecting Close Handle. This can come in handy when you want, for\ninstance, to close mutexes, which is essential to certain types of hacks.\nNO tE You can right-click on the lower pane header and click Select Columns to customize\nthe display. One column you might find particularly useful is Handle Value, which\ncan help when you see a handle being passed around in OllyDbg and want to know\nwhat it does.\nClosing Mutexes\nGames often allow only one client to run at a time; this is called single-\ninstance limitation. You can implement single-instance limitation in a\nnumber of ways, but using a system mutex is common because mutexes\nare sessionwide and can be accessed by a simple name. It’s trivial to limit\ninstances with mutexes, and thanks to Process Explorer, it’s just as trivial to\nremove that limit, allowing you to run multiple instances of a game at the\nsame time.\nFirst, here’s how a game might tackle single-instance limitation with a\nmutex:\nint main(int argc, char *argv[]) {\n// create the mutex\nHANDLE mutex = CreateMutex(NULL, FALSE, \"onlyoneplease\");\nif (GetLastError() == ERROR_ALREADY_EXISTS) {\n// the mutex already exists, so exit\nErrorBox(\"An instance is already running.\");\nreturn 0;\n}\n// the mutex didn't exist; it was just created, so\n// let the game run\nRunGame();\n// the game is over; close the mutex to free it up\n// for future instances\nif (mutex)\nCloseHandle(mutex);\nreturn 0;\n}\nReconnaissance with Process Monitor and Process Explorer 59\nThis example code creates a mutex named onlyoneplease. Next, the func-\ntion checks GetLastError() to see whether the mutex was already created, and\nif so, it closes the game. If the mutex doesn’t already exist, the game creates\nthe first instance, thereby blocking any future game clients from running. In\nthis example, the game runs normally, and once it finishes, CloseHandle() is\ncalled to close the mutex and allow future game instances to run.\nYou can use Process Explorer to close instance-limiting mutexes and\nrun many game instances simultaneously. To do so, choose the Handles\nview of the lower pane, look for all handles with a type of Mutant, determine\nwhich one is limiting instances of the game, and close that mutex.\nwArNING Mutexes are also used to synchronize data across threads and processes. Close one\nonly if you’re sure that its sole purpose is the one you’re trying to subvert!\nMulticlient hacks are generally in high demand, so being able to quickly\ndevelop them for emerging games is crucial to your overall success as a bot\ndeveloper within that market. Since mutexes are one of the most common\nways to achieve single-instance limitation, Process Explorer is an integral\ntool for prototyping these kinds of hacks.\nInspecting File accesses\nUnlike Process Monitor, Process Explorer can’t show a list of filesystem calls.\nOn the other hand, the Handles view of Process Explorer’s lower pane can\nshow all file handles that a game currently has open, revealing exactly what\nfiles are in continuous use without the need to set up advanced filtering cri-\nteria in Process Monitor. Just look for handles with a type of File to see all\nfiles the game is currently using.\nThis functionality can come in handy if you’re trying to locate logfiles\nor save files. Moreover, you can locate named pipes that are used for inter-\nprocess communication (IPC); these are files prefixed with \\Device\\\nNamedPipe\\. Seeing one of these pipes is often a hint that the game is talk-\ning to another process.\nfINDING AND ClOsING A MutEx\nTo put your Process Explorer skills to use, go to the GameHackingExamples/\nChapter3_CloseMutex directory and execute CloseMutex .exe. This game plays\nexactly like the one in “Finding a High Score File” on page 55, but it pre-\nvents you from simultaneously running multiple instances. As you might have\nguessed, it does this using a single-instance-limitation mutex. Using Process\nExplorer’s Handles view in the lower pane, find the mutex responsible for this\nlimitation and close it. If you succeed, you’ll be able to open a second instance\nof the game.\n60 Chapter 3"
  },
  {
    "input": "Closing Thoughts",
    "output": "closing Thoughts\nTo be effective when using Process Monitor and Process Explorer, you need,\nabove all else, a deep familiarity with the data that these applications dis-\nplay as well as the interfaces they use to display it. While this chapter’s over-\nview is a good baseline, the intricacies of these applications can be learned\nonly through experience, so I encourage you to play around with them on\nyour system.\nYou won’t use these tools on a regular basis, but at some point, they’ll\nsave the day: as you struggle to figure out how some code works, you’ll recall\nan obscure piece of information that caught your eye during a previous\nProcess Explorer or Process Monitor session. That’s why I consider them\nuseful reconnaissance tools.\nReconnaissance with Process Monitor and Process Explorer 61"
  },
  {
    "input": "Chapter 4: From Code to Memory: A General Primer",
    "output": "4\nfrOM C ODE t O M EMOry:\nA G ENEr Al PrIMEr\nAt the lowest level, a game’s code, data,\ninput, and output are complex abstrac-\ntions of erratically changing bytes. Many\nof these bytes represent variables or machine\ncode generated by a compiler that was fed the game’s\nsource code. Some represent images, models, and\nsounds. Others exist only for an instant, posted by the\ncomputer’s hardware as input and destroyed when the game finishes pro-\ncessing them. The bytes that remain inform the player of the game’s inter-\nnal state. But humans can’t think in bytes, so the computer must translate\nthem in a way we can understand.\nThere’s a huge disconnect in the opposite direction as well. A computer\ndoesn’t actually understand high-level code and visceral game content, so\nthese must be translated from the abstract into bytes. Some content—such\nas images, sounds, and text—is stored losslessly, ready to be presented to the"
  },
  {
    "input": "How Variables and Other Data Manifest in Memory",
    "output": "player at a microsecond’s notice. A game’s code, logic, and variables, on the\nother hand, are stripped of all human readability and compiled down to\nmachine data.\nBy manipulating a game’s data, game hackers obtain humanly improb-\nable advantages within the game. To do this, however, they must understand\nhow a developer’s code manifests once it has been compiled and executed.\nEssentially, they must think like computers.\nTo get you thinking like a computer, this chapter will begin by teach-\ning you how numbers, text, simple structures, and unions are represented\nin memory at the byte level. Then you’ll dive deeper to explore how class\ninstances are stored in memory and how abstract instances know which vir-\ntual functions to call at runtime. In the last half of the chapter, you’ll take\nan x86 assembly language crash course that covers syntax, registers, oper-\nands, the call stack, arithmetic operations, branching operations, function\ncalls, and calling conventions.\nThis chapter focuses very heavily on general technical details. There\nisn’t a lot of juicy information that immediately relates to hacking games,\nbut the knowledge you gain here will be central in the coming chapters,\nwhen we talk about topics like programmatically reading and writing mem-\nory, injecting code, and manipulating control flow.\nSince C++ is the de facto standard for both game and bot development,\nthis chapter explains the relationships between C++ code and the memory\nthat represents it. Most native languages have very similar (sometimes iden-\ntical) low-level structure and behavior, however, so you should be able to\napply what you learn here to just about any piece of software.\nAll of the example code in this chapter is in the GameHackingExamples/\nChapter4_CodeToMemory directory of this book’s source files. The included\nprojects can be compiled with Visual Studio 2010 but should also work\nwith any other C++ compiler. Download them at https://www.nostarch.com/\ngamehacking/ and compile them if you want to follow along.\nHow variables and Other data manifest in memory\nProperly manipulating a game’s state can be very hard, and finding the\ndata that controls it is not always as easy as clicking Next Scan and hoping\nCheat Engine won’t fail you. In fact, many hacks must manipulate dozens\nof related values at once. Finding these values and their relationships often\nrequires you to analytically identify structures and patterns. Moreover, devel-\noping game hacks typically means re-creating the original structures within\nyour bot’s code.\nTo do these things, you need an in-depth understanding of exactly how\nvariables and data are laid out in the game’s memory. Through example\ncode, OllyDbg memory dumps, and some tables to tie everything together,\nthis section will teach you everything there is to know about how different\ntypes of data manifest in memory.\n66 Chapter 4"
  },
  {
    "input": "Numeric Data",
    "output": "Numeric Data\nMost of the values game hackers need (like the player’s health, mana, loca-\ntion, and level) are represented by numeric data types. Because numeric\ndata types are also a building block for all other data types, understanding\nthem is extremely important. Luckily, they have relatively straightforward\nrepresentations in memory: they are predictably aligned and have a fixed\nbit width. Table 4-1 shows the five main numeric data types you’ll find in\nWindows games, along with their sizes and ranges.\nTable 4-1: Numeric Data Types\nType name(s) Size Signed range Unsigned range\nchar, BYTE 8 bits −128 to 127 0 to 255\nshort, WORD, 16 bits −32,768 to −32,767 0 to 65535\nwchar_t\nint, long, DWORD 32 bits −2,147,483,648 to 2,147,483,647 0 to 4,294,967,295\nlong long 64 bits −9,223,372,036,854,775,808 to 0 to 18,446,744,073,709,551,615\n9,223,372,036,854,775,807\nfloat 32 bits +/−1.17549*10−38 to N/A\n+/−3.40282*1038\nThe sizes of numeric data types can differ between architectures and\neven compilers. Since this book focuses on hacking x86 games on Windows,\nI’m using type names and sizes made standard by Microsoft. With the excep-\ntion of float, the data types in Table 4-1 are stored with little-endian ordering,\nmeaning the least significant bytes of an integer are stored in the lowest\naddresses occupied by that integer. For example, Figure 4-1 shows that DWORD\n0x0A0B0C0D is represented by the bytes 0x0D 0x0C 0x0B 0x0A.\nRegister\n0A0B0C0D Memory\n. . .\na: 0D\na+1: 0C\na+2: 0B\na+3: 0A\n. . .\nFigure 4-1: Little-endian ordering diagram\nThe float data type can hold mixed numbers, so its representation in\nmemory isn’t as simple as that of other data types. For example, if you see\nFrom Code to Memory: A General Primer 67\n0x0D 0x0C 0x0B 0x0A in memory and that value is a float, you can’t simply\nconvert it to 0x0A0B0C0D. Instead, float values have three components: the\nsign (bit 0), exponent (bits 1–8), and mantissa (bits 9–31).\nThe sign determines whether the number is negative or positive, the\nexponent determines how many places to move the decimal point (start-\ning before the mantissa), and the mantissa holds an approximation of\nthe value. You can retrieve the stored value by evaluating the expression\nmantissa × 10n (where n is the exponent) and multiplying the result by –1\nif the sign is set.\nNow let’s look at some numeric data types in memory. Listing 4-1 ini-\ntializes nine variables.\nunsigned char ubyteValue = 0xFF;\nchar byteValue = 0xFE;\nunsigned short uwordValue = 0x4142;\nshort wordValue = 0x4344;\nunsigned int udwordValue = 0xDEADBEEF;\nint dwordValue = 0xDEADBEEF;\nunsigned long long ulongLongValue = 0xEFCDAB8967452301;\nlong long longLongValue = 0xEFCDAB8967452301;\nfloat floatValue = 1337.7331;\nListing 4-1: Creating variables of numeric data types in C++\nStarting from the top, this example includes variables of types char, short,\nint, long long, and float. Four of these are unsigned, and five are signed. (In\nC++, a float can’t be unsigned.) Taking into account what you’ve learned so\nfar, carefully study the relationship between the code in Listing 4-1 and the\nmemory dump in Figure 4-2. Assume that the variables are declared in global\nscope.\nFigure 4-2: OllyDbg memory dump of our numeric data\nYou might notice that some values seem arbitrarily spaced out. Since\nit’s much faster for processors to access values residing at addresses that are\nmultiples of the address size (which is 32 bits in x86), compilers pad values\nwith zeros in order to align them on such addresses—hence, padding is also\ncalled alignment. Single-byte values are not padded, since operations that\naccess them perform the same regardless of alignment.\nKeeping this in mind, take a look at Table 4-2, which provides a sort of\nmemory-to-code crosswalk between the memory dump in Figure 4-2 and\nthe variables declared in Listing 4-1.\n68 Chapter 4"
  },
  {
    "input": "String Data",
    "output": "Table 4-2: Memory-to-Code Crosswalk for Listing 4-1 and Figure 4-2\nAddress Size Data Object\n0x00BB3018 1 byte 0xFF ubyteValue\n0x00BB3019 1 byte 0xFE byteValue\n0x00BB301A 2 bytes 0x00 0x00 Padding before uwordValue\n0x00BB301C 2 bytes 0x42 0x41 uwordValue\n0x00BB301E 2 bytes 0x00 0x00 Padding before wordValue\n0x00BB3020 2 bytes 0x44 0x43 wordValue\n0x00BB3022 2 bytes 0x00 0x00 Padding before udwordValue\n0x00BB3024 4 bytes 0xEF 0xBE 0xAD 0xDE udwordValue\n0x00BB3028 4 bytes 0xEF 0xBE 0xAD 0xDE dwordValue\n0x00BB302C 4 bytes 0x76 0x37 0xA7 0x44 floatValue\n0x00BB3030 8 bytes 0x01 0x23 0x45 0x67 ulongLongValue\n0x89 0xAB 0xCD 0xEF\n0x00BB3038 8 bytes 0x01 0x23 0x45 0x67 LongLongValue\n0x89 0xAB 0xCD 0xEF\nThe Address column lists locations in memory, and the Data column\ntells you exactly what’s stored there. The Object column tells you which\nvariable from Listing 4-1 each piece of data relates to. Notice that floatValue\nis placed before ulongLongValue in memory, even though it’s the last variable\ndeclared in Listing 4-1. Because these variables are declared in global scope,\nthe compiler can place them wherever it wants. This particular move is\nlikely a result of either alignment or optimization.\nString Data\nMost developers use the term string as if it’s synonymous with text, but text is\nonly the most common use for strings. At a low level, strings are just arrays\nof arbitrary numeric objects that appear linear and unaligned in memory.\nListing 4-2 shows four text string declarations.\n// char will be 1 byte per character\nchar* thinStringP = \"my_thin_terminated_value_pointer\";\nchar thinStringA[40] = \"my_thin_terminated_value_array\";\n// wchar_t will be 2 bytes per character\nwchar_t* wideStringP = L\"my_wide_terminated_value_pointer\";\nwchar_t wideStringA[40] = L\"my_wide_terminated_value_array\";\nListing 4-2: Declaring several strings in C++\nFrom Code to Memory: A General Primer 69\nIn the context of text, strings hold character objects (char for 8-bit encod-\ning or wchar_t for 16-bit encoding), and the end of each string is specified by a\nnull terminator, a character equal to 0x0. Let’s look at the memory where these\nvariables are stored, as shown in the two memory dumps in Figure 4-3.\n(cid:31)\n(cid:30)\nFigure 4-3: In this OllyDbg memory dump of string data, the\nhuman-readable text in the ASCII column is the text we stored\nin Listing 4-2.\nIf you’re not used to reading memory, the OllyDbg dump might be a bit\ndifficult to follow at this point. Table 4-3 shows a deeper look at the correla-\ntion between the code in Listing 4-2 and the memory in Figure 4-3.\nTable 4-3: Memory-to-Code Crosswalk for Listing 4-2 and Figure 4-3\nAddress Size Data Object\nPane 1\n0x012420F8 32 bytes 0x6D 0x79 0x5F {…} 0x74 0x65 0x72 thinStringP characters\n0x01242118 4 bytes 0x00 0x00 0x00 0x00 thinStringP terminator and\npadding\n0x0124211C 4 bytes 0x00 0x00 0x00 0x00 Unrelated data\n0x01242120 64 bytes 0x6D 0x00 0x79 {…} 0x00 0x72 0x00 wideStringP characters\n0x01242160 4 bytes 0x00 0x00 0x00 0x00 wideStringP terminator and\npadding\n{...} Unrelated data\nPane 2\n0x01243040 4 bytes 0xF8 0x20 0x24 0x01 Pointer to thinStringP at\n0x012420F8\n0x01243044 30 bytes 0x6D 0x79 0x5F {…} 0x72 0x61 0x79 thinStringA characters\n0x01243062 10 bytes 0x00 repeated 10 times thinStringA terminator and\narray fill\n0x0124306C 4 bytes 0x20 0x21 0x24 0x01 Pointer to wideStringP at\n0x01242120\n0x01243070 60 bytes 0x6D 0x00 0x79 {…} 0x00 0x79 0x00 wideStringA characters\n0x012430AC 20 bytes 0x00 repeated 10 times wideStringA terminator and\narray fill\n70 Chapter 4"
  },
  {
    "input": "Data Structures",
    "output": "In Figure 4-3, pane 1 shows that the values stored where thinStringP\n(address 0x01243040) and wideStringP (address 0x0124306C) belong in\nmemory are only 4 bytes long and contain no string data. That’s because\nthese variables are actually pointers to the first characters of their respec-\ntive arrays. For example, thinStringP contains 0x012420F8, and in pane 2 in\nFigure 4-3, you can see \"my_thin_terminated_value_pointer\" located at address\n0x012420F8.\nLook at the data between these pointers in pane 1, and you can see the\ntext being stored by thinStringA and wideStringA. Furthermore, notice that\nthinStringA and wideStringA are padded beyond their null terminators; this\nis because these variables were declared as arrays with length 40, so they are\nfilled up to 40 characters.\nData Structures\nUnlike the data types we have previously discussed, structures are containers\nthat hold multiple pieces of simple, related data. Game hackers who know\nhow to identify structures in memory can mimic those structures in their\nown code. This can greatly reduce the number of addresses they must find,\nas they need to find only the address to the start of the structure, not the\naddress of every individual item.\nNO tE This section talks about structures as simple containers that lack member functions\nand contain only simple data. Objects that exceed these limitations will be discussed\nin “Classes and VF Tables” on page 74.\nStructure Element Order and alignment\nSince structures simply represent an assortment of objects, they don’t visibly\nmanifest in memory dumps. Instead, a memory dump of a structure shows\nthe objects that are contained within that structure. The dump would look\nmuch like the others I’ve shown in this chapter, but with important differ-\nences in both order and alignment.\nTo see these differences, start by taking a look at Listing 4-3.\nstruct MyStruct {\nunsigned char ubyteValue;\nchar byteValue;\nunsigned short uwordValue;\nshort wordValue;\nunsigned int udwordValue;\nint dwordValue;\nunsigned long long ulongLongValue;\nlong long longLongValue;\nfloat floatValue;\n};\nMyStruct& m = 0;\nFrom Code to Memory: A General Primer 71\nprintf(\"Offsets: %d,%d,%d,%d,%d,%d,%d,%d,%d\\n\",\n&m->ubyteValue, &m->byteValue,\n&m->uwordValue, &m->wordValue,\n&m->udwordValue, &m->dwordValue,\n&m->ulongLongValue, &m->longLongValue,\n&m->floatValue);\nListing 4-3: A C++ structure and some code that uses it\nThis code declares a structure named MyStruct and creates a variable\nnamed m that supposedly points to an instance of the structure at address\n0. There’s not actually an instance of the structure at address 0, but this\ntrick lets me use the ampersand operator (&) in the printf() call to get the\naddress of each member of the structure. Since the structure is located\nat address 0, the address printed for each member is equivalent to its offset\nfrom the start of the structure.\nThe ultimate purpose of this example is to see exactly how each mem-\nber is laid out in memory, relative to the start of the structure. If you were\nto run the code, you’d see the following output:\nOffsets: 0,1,2,4,8,12,16,24,32\nAs you can see, the variables in MyStruct are ordered exactly as they\nwere defined in code. This sequential member layout is a mandatory prop-\nerty of structures. Compare this to the example from Listing 4-1, when we\ndeclared an identical set of variables; in the memory dump from Figure 4-2,\nthe compiler clearly placed some values out of order in memory.\nFurthermore, you may have noticed that the members are not aligned\nlike the globally scoped variables in Listing 4-1; if they were, for example,\nthere would be 2 padding bytes before uwordValue. This is because structure\nmembers are aligned on addresses divisible by either the struct member align-\nment (a compiler option that accepts 1, 2, 4, 8, or 16 bytes; in this example,\nit’s set to 4) or the size of the member—whichever is smaller. I arranged the\nmembers of MyStruct so that the compiler didn’t need to pad the values.\nIf, however, we put a char immediately after ulongLongValue, the printf()\ncall would give the following output:\nOffsets: 0,1,2,4,8,12,16,28,36\nNow, take a look at the original and the modified outputs together:\nOriginal: Offsets: 0,1,2,4,8,12,16,24,32\nModified: Offsets: 0,1,2,4,8,12,16,28,36\nIn the modified version, the last two values, which are the offsets for\nlongLongValue and floatValue from the start of the structure, have changed.\nThanks to the struct member alignment, the variable longLongValue moves\nby 4 bytes (1 for the char value and 3 following it) to ensure it gets placed on\nan address divisible by 4.\n72 Chapter 4"
  },
  {
    "input": "Unions",
    "output": "How Structures Work\nUnderstanding structures—how they are aligned and how to mimic them—\ncan be very useful. For instance, if you replicate a game’s structures in your\nown code, you can read or write those entire structures from memory in\na single operation. Consider a game that declares the player’s current and\nmax health like so:\nstruct {\nint current;\nint max;\n} vital;\nvital health;\nIf an inexperienced game hacker wants to read this information from\nmemory, they might write something like this to fetch the health values:\nint currentHealth = readIntegerFromMemory(currentHealthAddress);\nint maxHealth = readIntegerFromMemory(maxHealthAddress);\nThis game hacker doesn’t realize that seeing these values right next to\neach other in memory could be more than a lucky happenstance, so they’ve\nused two separate variables. But if you came along with your knowledge of\nstructures, you might conclude that, since these values are closely related and\nare adjacent in memory, our hacker could have used a structure instead:\nstruct {\nint current;\nint max;\n} _vital;\nu _vital health = readTypeFromMemory<_vital>(healthStructureAddress);\nSince this code assumes a structure is being used and correctly mimics it,\nit can fetch both health and max health in just one line u. We’ll dive deeper\ninto how to write your own code to read memory from in Chapter 6.\nUnions\nUnlike structures, which encapsulate multiple pieces of related data, unions\ncontain a single piece of data that is exposed through multiple variables.\nUnions follow three rules:\n• The size of a union in memory is equal to that of its largest member.\n• Members of a union all reference the same memory.\n• A union inherits the alignment of its largest member.\nThe printf() call in the following code helps illustrate the first two rules:\nunion {\nBYTE byteValue;\nstruct {\nFrom Code to Memory: A General Primer 73"
  },
  {
    "input": "Classes and VF Tables",
    "output": "WORD first;\nWORD second;\n} words;\nDWORD value;\n} dwValue;\ndwValue.value = 0xDEADBEEF;\nprintf(\"Size %d\\nAddresses 0x%x,0x%x\\nValues 0x%x,0x%x\\n\",\nsizeof(dwValue), &dwValue.value, &dwValue.words,\ndwValue.words.first, dwValue.words.second);\nThis call to printf() outputs the following:\nSize 4\nAddresses 0x2efda8,0x2efda8\nValues 0xbeef,0xdead\nThe first rule is illustrated by the Size value, which is printed first. Even\nthough dwValue has three members that occupy a total of 9 bytes, it has a\nsize of only 4 bytes. The size result validates the second rule as well, because\ndwValue.value and dwValue.words both point to address 0x2efda8, as shown by\nthe values printed after the word Addresses. The second rule is also vali-\ndated by the fact that dwValue.words.first and dwValue.words.second contain\n0xbeef and 0xdead, printed after Values, which makes sense considering that\ndwValue.value is 0xdeadbeef. The third rule isn’t demonstrated in this example\nbecause we don’t have enough memory context, but if you were to put this\nunion inside a structure and surround it with whatever types you like, it\nwould in fact always align like a DWORD.\nClasses and VF Tables\nMuch like structures, classes are containers that hold and isolate multiple\npieces of data, but classes can also contain function definitions.\na Simple Class\nClasses with normal functions, such as bar in Listing 4-4, conform to the\nsame memory layouts as structures.\nclass bar {\npublic:\nbar() : bar1(0x898989), bar2(0x10203040) {}\nvoid myfunction() { bar1++; }\nint bar1, bar2;\n};\nbar _bar = bar();\nprintf(\"Size %d; Address 0x%x : _bar\\n\", sizeof(_bar), &_bar);\nListing 4-4: A C++ class\n74 Chapter 4\nThe printf() call in Listing 4-4 would output the following:\nSize 8; Address 0x2efd80 : _bar\nEven though bar has two member functions, this output shows that it\nspans only the 8 bytes needed to hold bar1 and bar2. This is because the bar\nclass doesn’t include abstractions of those member functions, so the pro-\ngram can call them directly.\nNO tE Access levels such as public, private, and protected do not manifest in memory.\nRegardless of these modifiers, members of classes are still ordered as they are defined.\na Class with Virtual Functions\nIn classes that do include abstract functions (often called virtual functions),\nthe program must know which function to call. Consider the class defini-\ntions in Listing 4-5:\nclass foo {\npublic:\nfoo() : myValue1(0xDEADBEEF), myValue2(0xBABABABA) {}\nint myValue1;\nstatic int myStaticValue;\nvirtual void bar() { printf(\"call foo::bar()\\n\"); }\nvirtual void baz() { printf(\"call foo::baz()\\n\"); }\nvirtual void barbaz() {}\nint myValue2;\n};\nint foo::myStaticValue = 0x12121212;\nclass fooa : public foo {\npublic:\nfooa() : foo() {}\nvirtual void bar() { printf(\"call fooa::bar()\\n\"); }\nvirtual void baz() { printf(\"call fooa::baz()\\n\"); }\n};\nclass foob : public foo {\npublic:\nfoob() : foo() {}\nvirtual void bar() { printf(\"call foob::bar()\\n\"); }\nvirtual void baz() { printf(\"call foob::baz()\\n\"); }\n};\nListing 4-5: The foo, fooa, and foob classes\nThe class foo has three virtual functions: bar, baz, and barbaz. Classes\nfooa and foob inherit from class foo and overload both bar and baz. Since fooa\nFrom Code to Memory: A General Primer 75\nand foob have a public base class of foo, a foo pointer can point to them, but\nthe program must still call the correct versions of bar and baz. You can see\nthis by executing the following code:\nfoo* _testfoo = (foo*)new fooa();\n_testfoo->bar(); // calls fooa::bar()\nAnd here is the output:\ncall fooa::bar()\nThe output shows that _testfoo->bar() invoked fooa::bar() even though\n_testfoo is a foo pointer. The program knew which version of the function\nto call, because the compiler included a VF (virtual function) table in the\nmemory of _testfoo. VF tables are arrays of function addresses that abstract\nclass instances use to tell a program where their overloaded functions are\nlocated.\nClass Instances and Virtual Function tables\nTo understand the relationship between class instances and VF tables, let’s\ninspect a memory dump of the three objects declared in this listing:\nfoo _foo = foo();\nfooa _fooa = fooa();\nfoob _foob = foob();\nThese objects are of the types defined in Listing 4-5. You can see them\nin memory in Figure 4-4.\n(cid:31)\n(cid:30)\nFigure 4-4: OllyDbg memory dump of class data\nPane 1 shows that each class instance stores its members just like a\nstructure, but it precedes them with a DWORD value that points to the class\ninstance’s VF table. Pane 2 shows the VF tables for each of our three class\ninstances. The memory-to-code crosswalk in Table 4-4 shows how these\npanes and the code tie together.\n76 Chapter 4\nTable 4-4: Memory-to-Code Crosswalk for Listing 4-5 and Figure 4-4\nAddress Size Data Object\nPane 1\n0x0018FF20 4 bytes 0x004022B0 Start of _foo and pointer to foo VF\ntable\n0x0018FF24 8 bytes 0xDEADBEEF _foo.myValue1 and _foo.myValue2\n0xBABABABA\n0x0018FF2C 4 bytes 0x004022C0 Start of _fooa and pointer to fooa VF\ntable\n0x0018FF30 8 bytes 0xDEADBEEF _fooa.myValue1 and _fooa.myValue2\n0xBABABABA\n0x0018FF38 4 bytes 0x004022D0 Start of _foob and pointer to foob VF\ntable\n0x0018FF3C 8 bytes 0xDEADBEEF _foob.myValue1 and _foob.myValue2\n0xBABABABA\n{...} Unrelated data\nPane 2\n0x004022B0 4 bytes 0x00401060 Start of foo VF table; address of\nfoo::bar\n0x004022B4 4 bytes 0x00401080 Address of foo::baz\n0x004022B8 4 bytes 0x004010A0 Address of foo::barbaz\n0x004022BC 4 bytes 0x0040243C Unrelated data\n0x004022C0 4 bytes 0x004010D0 Start of fooa VF table; address of\nfooa::bar\n0x004022C4 4 bytes 0x004010F0 Address of fooa::baz\n0x004022C8 4 bytes 0x004010A0 Address of foo::barbaz\n0x004022CC 4 bytes 0x004023F0 Unrelated data\n0x004022D0 4 bytes 0x00401130 Start of foob VF table; address of\nfoob::bar\n0x004022D4 4 bytes 0x00401150 Address of foob::baz\n0x004022D8 4 bytes 0x004010A0 Address of foo::barbaz\nThis crosswalk shows how the VF tables for the code in Listing 4-5 are\nlaid out in memory. Each VF table is generated by the compiler when the\nbinary is made, and the tables remain constant. To save space, instances\nof the same class all point to the same VF table, which is why the VF tables\naren’t placed inline with the class.\nSince we have three VF tables, you might wonder how a class instance\nknows which VF table to use. The compiler places code similar to the fol-\nlowing bit of assembly in each virtual class constructor:\nMOV DWORD PTR DS:[EAX], VFADDR\nFrom Code to Memory: A General Primer 77"
  },
  {
    "input": "x86 Assembly Crash Course",
    "output": "This example takes the static address of a VF table (VFADDR) and places it\nin memory as the first member of the class.\nNow look at addresses 0x004022B0, 0x004022C0, and 0x004022D0 in\nTable 4-4. These addresses contain the beginning of the foo, fooa, and foob\nVF tables. Notice that foo::barbaz exists in all three VF tables; this is because\nthe function is not overloaded by either subclass, meaning instances of each\nsubclass will call the original implementation directly.\nNotice, too, that foo::myStaticValue does not appear in this crosswalk.\nSince the value is static, it doesn’t actually need to exist as a part of the foo\nclass; it’s placed inside this class only for better code organization. In real-\nity, it gets treated like a global variable and is placed elsewhere.\nVf tABlEs AND CHEAt ENGINE\nRemember Cheat Engine’s First element of pointerstruct must point to module\noption for pointer scans from Figure 1-4 on page 14? Now that you’ve read\na bit about VF tables, that knowledge should help you understand how this\noption works: it makes Cheat Engine ignore all heap chunks where the first\nmember is not a pointer to a valid VF table. It speeds up scans, but it works\nonly if every step in a pointer path is part of an abstract class instance.\nThe memory tour ends here, but if you have trouble identifying a chunk\nof data in the future, come back to this section for reference. Next, we’ll\nlook at how a computer can understand a game’s high-level source code in\nthe first place.\nx86 assembly crash course\nWhen a program’s source code is compiled into a binary, it is stripped of all\nunnecessary artifacts and translated into machine code. This machine code,\nmade up of only bytes (command bytes are called opcodes, but there are also\nbytes representing operands), gets fed directly to the processor and tells it\nexactly how to behave. Those 1s and 0s flip transistors to control computa-\ntion, and they can be extremely difficult to understand. To make computers\na little easier to talk to, engineers working with such code use assembly lan-\nguage, a shorthand that represents raw machine opcodes with abbreviated\nnames (called mnemonics) and a simplistic syntax.\nAssembly language is important for game hackers to know because\nmany powerful hacks can be achieved only through direct manipulation\nof a game’s assembly code, via methods such as NOPing or hooking. In this\nsection, you’ll learn the basics of x86 assembly language, a specific flavor of\n78 Chapter 4"
  },
  {
    "input": "Command Syntax",
    "output": "assembly made for speaking to 32-bit processors. Assembly language is very\nextensive, so for the sake of brevity this section talks only about the small\nsubset of assembly concepts that are most useful to game hackers.1\nNO tE Throughout this section, many small snippets of assembly code include comments set\noff by a semicolon ( ;) to describe each instruction in greater detail.\nCommand Syntax\nAssembly language is used to describe machine code, so its syntax is pretty\nsimplistic. While this syntax makes it very easy for someone to understand\nindividual commands (also called operations), it also makes understanding\ncomplex blocks of code very hard. Even algorithms that are easily readable\nin high-level code seem obfuscated when written in assembly. For example,\nthe following snippet of pseudocode:\nif (EBX > EAX)\nECX = EDX\nelse\nECX = 0\nwould look like Listing 4-6 in x86 assembly.\nCMP EBX, EAX\nJG label1\nMOV ECX, 0\nJMP label2\nlabel1:\nMOV ECX, EDX\nlabel2:\nListing 4-6: Some x86 assembly commands\nTherefore, it takes extensive practice to understand even the most triv-\nial functions in assembly. Understanding individual commands, however,\nis very simple, and by the end of this section, you’ll know how to parse the\ncommands I just showed you.\nInstructions\nThe first part of an assembly command is called an instruction. If you equate\nan assembly command to a terminal command, the instruction is the pro-\ngram to run. At the machine code level, instructions are typically the first\nbyte of a command;2 there are also some 2-byte instructions, where the\nfirst byte is 0x0F. Regardless, an instruction tells the processor exactly what\nto do. In Listing 4-6, CMP, JG, MOV, and JMP are all instructions.\n1. Randall Hyde’s The Art of Assembly Language, 2nd edition (No Starch Press, 2010) is a wonder-\nful book that can teach you everything there is to know about assembly.\n2. Each command must fit within 15 bytes. Most commands are 6 or fewer.\nFrom Code to Memory: A General Primer 79\nOperand Syntax\nWhile some instructions are complete commands, the vast majority are\nincomplete unless followed by operands, or parameters. Every command in\nListing 4-6 has at least one operand, like EBX, EAX, and label1.\nAssembly operands come in three forms:\nImmediate value An integer value that is declared inline (hexadeci-\nmal values have a trailing h).\nRegister A name that refers to a processor register.\nMemory offset An expression, placed in brackets, that represents the\nmemory location of a value. The expression can be an immediate value\nor a register. Alternatively, it can be either the sum or difference of a\nregister and immediate value (something like [REG+Ah] or [REG-10h]).\nEach instruction in x86 assembly can have between zero and three\noperands, and commas are used to separate multiple operands. In most\ncases, instructions that require two operands have a source operand and a\ndestination operand. The ordering of these operands is dependent on the\nassembly syntax. For example, Listing 4-7 shows a group of pseudocom-\nmands written in the Intel syntax, which is used by Windows (and, thus,\nby Windows game hackers):\nMOV R1, 1 ; set R1 (register) to 1 (immediate)\nu MOV R1, [BADF00Dh] ; set R1 to value at [BADFOODh] (memory offset)\nMOV R1, [R2+10h] ; set R1 to value at [R2+10h] (memory offset)\nMOV R1, [R2-20h] ; set R1 to value at [R2+20h] (memory offset)\nListing 4-7: Demonstrating Intel syntax\nIn the Intel syntax, the destination operand comes first, followed by the\nsource, so at u, R1 is the destination and [BADFOODh] is the source. On the other\nhand, compilers like GCC (which can be used to write bots on Windows) use\na syntax known as AT&T, or UNIX, syntax. This syntax does things a little\ndifferently, as you can see in the following example:\nMOV $1, %R1 ; set R1 (register) to 1 (immediate)\nMOV 0xBADF00D, %R1 ; set R1 to value at 0xBADFOOD (memory offset)\nMOV 0x10(%R2), %R1 ; set R1 to value at 0x10(%R2) (memory offset)\nMOV -0x20(%R2), %R1 ; set R1 to value at -0x20(%R2) (memory offset)\nThis code is the AT&T version of Listing 4-7. AT&T syntax not only\nreverses the operand order but also requires operand prefixing and has\na different format for memory offset operands.\nassembly Commands\nOnce you understand assembly instructions and how to format their oper-\nands, you can start writing commands. The following code shows an assem-\nbly function, consisting of some very basic commands, that essentially does\nnothing.\n80 Chapter 4"
  },
  {
    "input": "Processor Registers",
    "output": "PUSH EBP ; put EBP (register) on the stack\nMOV EBP, ESP ; set EBP to value of ESP (register, top of stack)\nPUSH -1 ; put -1 (immediate) on the stack\nADD ESP, 4 ; negate the 'PUSH -1' to put ESP back where it was (a PUSH\n; subtracts 4 from ESP, since it grows the stack)\nMOV ESP, EBP ; set ESP to the value of EBP (they will be the same anyway,\n; since we have kept ESP in the same place)\nPOP EBP ; set EBP to the value on top of the stack (it will be what\n; EBP started with, put on the stack by PUSH EBP)\nXOR EAX, EAX ; exclusive-or EAX (register) with itself (same effect as\n; 'MOV EAX, 0' but much faster)\nRETN ; return from the function with a value of 0 (EAX typically\n; holds the return value)\nThe first two lines, a PUSH command and a MOV command, set up a stack\nframe. The next line pushes –1 to the stack, which is undone when the stack\nis set back to its original position by the ADD ESP, 4 command. Following that,\nthe stack frame is removed, the return value (stored in EAX) is set to 0 with\nan XOR instruction, and the function returns.\nYou’ll learn more about stack frames and functions in “The Call Stack”\non page 86 and “Function Calls” on page 94. For now, turn your atten-\ntion to the constants in the code—namely EBP, ESP, and EAX, which are used\nfrequently in the code as operands. These values, among others, are called\nprocessor registers, and understanding them is essential to understanding the\nstack, function calls, and other low-level aspects of assembly code.\nProcessor Registers\nUnlike high-level programming languages, assembly language does not\nhave user-defined variable names. Instead, it accesses data by referenc-\ning its memory address. During intensive computation, however, it can be\nextremely costly for the processor to constantly deal with the overhead of\nreading and writing data to RAM. To mitigate this high cost, x86 proces-\nsors provide a small set of temporary variables, called processor registers,\nwhich are small storage spaces within the processor itself. Since accessing\nthese registers requires far less overhead than accessing RAM, assembly\nuses them to describe its internal state, pass volatile data around, and store\ncontext-sensitive variables.\nGeneral registers\nWhen assembly code needs to store or operate on arbitrary data, it uses a\nsubset of process registers called general registers. These registers are used\nexclusively to store process-specific data, such as a function’s local variables.\nEach general register is 32 bits and thus can be thought of as a DWORD vari-\nable. General registers are also optimized for specific purposes:\nEAX, the accumulator This register is optimized for mathematical\ncomputations. Some operations, such as multiplication and division,\ncan only occur in EAX.\nFrom Code to Memory: A General Primer 81\nEBX, the base register This register is used arbitrarily for extra\nstorage. Since its 16-bit predecessor, BX, was the only register that\noperations could use to reference memory addresses, EBX was used\nas a reference to RAM. In x86 assembly, however, all registers can be\naddress references, leaving EBX without a true purpose.\nECX, the counter This register is optimized to act as the counter vari-\nable (often called i in high-level code) in a loop.\nEDX, the data register This register is optimized to act as a helper to\nEAX. In 64-bit computations, for instance, EAX acts as bits 0–31 and\nEDX acts as bits 32–63.\nThese registers also have a set of 8- and 16-bit subregisters that you can\nuse to access partial data. Think of every general register as a union, where\na register name describes the 32-bit member and the subregisters are alter-\nnate members that allow access to smaller pieces of the register. The follow-\ning code shows what this union might look like for EAX:\nunion {\nDWORD EAX;\nWORD AX;\nstruct {\nBYTE L;\nBYTE H;\n} A;\n} EAX;\nIn this example, AX allows access to the lower WORD of EAX, while AL allows\naccess to the lower BYTE of AX and AH to its higher BYTE. Every general reg-\nister has this structure, and I outline the other registers’ subregisters in\nFigure 4-5.\n16 bits\n8 bits 8 bits\nEAX AX AH AL\nEBX BX BH BL\nECX CX CH CL\nEDX DX DH DL\n32 bits\nFigure 4-5: x86 registers and subregisters\nEAX, EBC, ECX, and EDX have higher words, too, but the compiler\nwill almost never access them on its own, as it can just use the lower word\nwhen it needs word-only storage.\n82 Chapter 4\nIndex registers\nx86 assembly also has four index registers, which are used to access data\nstreams, reference the call stack, and keep track of local information. Like\nthe general registers, index registers are 32 bits, but index registers have\nmore strictly defined purposes:\nEDI, the destination index This register is used to index memory tar-\ngeted by write operations. If there are no write operations in a piece of\ncode, the compiler can use EDI for arbitrary storage if needed.\nESI, the source index This register is used to index memory targeted\nby read operations. It can also be used arbitrarily.\nESP, the stack pointer This register is used to reference the top of the\ncall stack. All stack operations directly access this register. You must use\nESP only when working with the stack, and it must always point to the\ntop of the stack.\nEBP, the stack base pointer This register marks the bottom of the\nstack frame. Functions use it as a reference to their parameters and local\nvariables. Some code may be compiled with an option to omit this behav-\nior, in which case EBP can be used arbitrarily.\nLike the general registers, each index register has a 16-bit counterpart:\nDI, SI, SP, and BP, respectively. However, the index registers have no 8-bit\nsubregisters.\nwHy DO sOME x86 rEGI stErs HAVE suBrEGIstErs?\nThere is a historical reason why both general and index registers have\n16-bit counterparts. The x86 architecture was based on a 16-bit architec-\nture, from which it extended the registers AX, BX, CX, DX, DI, SI, SP, and BP.\nAppropriately, the extensions retain the same names but are prefixed with an\nE, for “extended.” The 16-bit versions remain for backward compatibility. This\nalso explains why index registers have no 8-bit abstractions: they are intended\nto be used as memory-address offsets, and there is no practical need to know\npartial bytes of such values.\nthe Execution Index register\nThe Execution Index register, referred to as EIP, has a very concrete pur-\npose: it points to the address of the code currently being executed by the\nprocessor. Because it controls the flow of execution, it is directly incre-\nmented by the processor and is off-limits to assembly code. To modify EIP,\nassembly code must indirectly access it using operations such as CALL, JMP,\nand RETN.\nFrom Code to Memory: A General Primer 83\nthe EFLaGS register\nUnlike high-level code, assembly language doesn’t have binary comparison\noperators like ==, >, and <. Instead, it uses the CMP command to compare two\nvalues, storing the resulting information in the EFLAGS register. Then, the\ncode changes its control flow using special operations that depend on the\nvalue stored in ELFAGS.\nWhile comparison commands are the only user-mode operations that\ncan access EFLAGS, they use only this register’s status bits: 0, 2, 4, 6, 7, and\n11. Bits 8–10 act as control flags, bits 12–14 and 16–21 act as system flags,\nand the remaining bits are reserved for the processor. Table 4-5 shows the\ntype, name, and description of each EFLAGS bit.\nTable 4-5: EFLAGS bits\nBit(s) Type Name Description\n0 Status Carry Set if a carry or borrow was generated from the most\nsignificant bit during the previous instruction.\n2 Status Parity Set if the least significant byte resulting from the previ-\nous instruction has an even number of bits set.\n4 Status Adjust Same as the carry flag, but considers the 4 least sig-\nnificant bits.\n6 Status Zero Set if the resulting value from the previous instruction\nis equal to 0.\n7 Status Sign Set if the resulting value from the previous instruction\nhas its sign bit (most significant bit) set.\n8 Control Trap When set, the processor sends an interrupt to the\noperating system kernel after executing the next\noperation.\n9 Control Interrupt When not set, the system ignores maskable interrupts.\n10 Control Direction When set, ESI and EDI are decremented by operations\nthat automatically modify them. When not set, they\nare incremented.\n11 Status Overflow Set when a value is overflowed by the previous instruc-\ntion, such as when ADD is performed on a positive\nvalue and the result is a negative value.\nThe EFLAGS register also contains a system bit and a reserved bit, but\nthose are irrelevant in user-mode assembly and game hacking, so I’ve omit-\nted them from this table. Keep EFLAGS in mind when you’re debugging\ngame code to figure out how it works. For example, if you set a breakpoint\non a JE (jump if equal) instruction, you can look at the EFLAGS 0 bit to see\nwhether the jump will be taken.\nSegment registers\nFinally, assembly language has a set of 16-bit registers called segment registers.\nUnlike other registers, segment registers are not used to store data; they\nare used to locate it. In theory, they point to isolated segments of memory,\n84 Chapter 4\nallowing different types of data to be stored in completely separate memory\nsegments. The implementation of such segmentation is left up to the operat-\ning system. These are the x86 segment registers and their intended purposes:\nCS, the code segment This register points to the memory that holds\nan application’s code.\nDS, the data segment This register points to the memory that holds\nan application’s data.\nES, FS, and GS, the extra segments These registers point to any pro-\nprietary memory segments used by the operating system.\nSS, the stack segment This register points to memory that acts as a\ndedicated call stack.\nIn assembly code, segment registers are used as prefixes to memory off-\nset operands. When a segment register isn’t specified, DS is used by default.\nThis means that the command PUSH [EBP] is effectively the same as PUSH\nDS:[EBP]. But the command PUSH FS:[EBP] is different: it reads memory from\nthe FS segment, not the DS segment.\nIf you look closely at the Windows x86 implementation of memory seg-\nmentation, you might notice that these segment registers were not exactly\nused as intended. To see this in action, you can run the following commands\nwith the OllyDbg command line plug-in while OllyDbg is attached to a\npaused process:\n? CALC (DS==SS && SS==GS && GS==ES)\n? 1\n? CALC DS-CS\n? 8\n? CALC FS-DS\n; returns nonzero (and changes between threads)\nThis output tells us three distinct things. First, it shows that there are\nonly three segments being used by Windows: FS, CS, and everything else.\nThis is demonstrated by DS, SS, GS, and ES being equal. For the same\nreason, this output shows that DS, SS, GS, and ES can all be used inter-\nchangeably, as they all point to the same memory segments. Lastly, since FS\nchanges depending on the thread, this output shows that it is thread depen-\ndent. FS is an interesting segment register, and it points to certain thread-\nspecific data. In “Bypassing ASLR in Production” on page 128, we’ll explore\nhow the data in FS can be used to bypass ASLR—something most bots will\nneed to do.\nIn fact, in assembly code generated for Windows by a compiler, you’d\nonly ever see three segments used: DS, FS, and SS. Interestingly enough,\neven though CS seems to show a constant offset from DS, it has no real\npurpose in user-mode code. Knowing all of these things, you can further\nconclude that there are only two segments being used by Windows: FS and\neverything else.\nThese two segments actually point to different locations in the same\nmemory (there’s no simple way to verify this, but it is true), which shows\nFrom Code to Memory: A General Primer 85"
  },
  {
    "input": "The Call Stack",
    "output": "that Windows actually doesn’t use memory segments at all. Instead, it uses\na flat memory model in which segment registers are nearly irrelevant. While\nall segment registers point to the same memory, only FS and CS point to\ndifferent locations, and CS is not used.\nIn conclusion, there are only three things you need to know about seg-\nment registers when working with x86 assembly in Windows. First, DS, SS,\nGS, and ES are interchangeable, but for clarity DS should be used to access\ndata and SS should be used to access the call stack. Second, CS can be safely\nforgotten. Third, FS is the only segment register with a special purpose; it\nshould be left alone for now.\nThe Call Stack\nRegisters are powerful, but unfortunately they come in very limited sup-\nply. In order for assembly code to effectively store all of its local data,\nit must also use the call stack. The stack is used to store many different\nvalues, including function parameters, return addresses, and some local\nvariables.\nUnderstanding the ins and outs of the call stack will come in handy\nwhen you’re reverse engineering a game. Moreover, you’ll rely on this\nknowledge heavily when we jump into control flow manipulation in\nChapter 8.\nStructure\nYou can think of the call stack as a FILO (first-in-last-out) list of DWORD values\nthat can be directly accessed and manipulated by assembly code. The\nterm stack is used because the structure resembles a stack of paper: objects\nare both added to and removed from the top. Data is added to the stack\nthrough the PUSH operand command, and it is removed (and placed in a reg-\nister) through the POP register command. Figure 4-6 shows how this process\nmight look.\nPUSH POP\nFigure 4-6: The structure of a stack\n86 Chapter 4\nIn Windows, the stack grows from higher memory addresses to lower\nones. It occupies a finite block of memory, piling up to address 0x00000000\n(the absolute top) from address n (the absolute bottom). This means that\nESP (the pointer to the top of the stack) decreases as items are added and\nincreases as items are removed.\nthe Stack Frame\nWhen an assembly function uses the stack\nto store data, it references the data by creat- 0x0000\ning a stack frame. It does so by storing ESP\nin EBP and then subtracting n bytes from . . .\nESP, effectively opening an n-byte gap that\nis framed between the registers EBP and ESP. 0xFF00 ESP\nTo better understand this, first imagine that\nthe stack in Figure 4-7 is passed to a func- . . .\ntion that requires 0x0C bytes of local storage\nspace.\nFigure 4-7: Initial example stack\nIn this example, address 0x0000 is the\n(read from bottom to top)\nabsolute top of the stack. We have unused\nmemory from addresses 0x0000 to 0xFF00\n– 4, and at the time of the function call, 0xFF00 is the top of the stack. ESP\npoints to this address. The stack memory after 0xFF00 is used by preceding\nfunctions in the call chain (from 0xFF04 to 0xFFFF). When the function is\ncalled, the first thing it does is execute the following assembly code, which\ncreates a stack frame of 0x0C (12 in decimal) bytes:\nPUSH EBP ; saves the bottom of the lower stack frame\nMOV EBP, ESP ; stores the bottom of the current stack frame, in EBP\n; (also 4 bytes above the lower stack frame)\nSUB ESP, 0x0C ; subtracts 0x0C bytes from ESP, moving it up the stack\n; to mark the top of the stack frame\nAfter this code executes, the stack looks more like the one shown in\nFigure 4-8. After creating this stack, the function can work with the 0x0C\nbytes it allocated on the stack.\n0x0000 is still the absolute top of the stack. We have unused stack\nmemory from addresses 0x0000 to 0xFF00 – 20, and the memory at\naddress 0xFF00 – 16 contains the final 4 bytes of local storage (referenced\nby [EBP-Ch]). This is also the top of the current stack frame, so ESP points\nhere. 0xFF00 – 12 contains the middle 4 bytes of local storage (referenced\nby [EBP-8h]), and 0xFF00 – 8 contains the first 4 bytes of local storage (ref-\nerenced by [EBP-4h]). EBP points to 0xFF00 – 4, which is the bottom of the\ncurrent stack frame; this address holds the original value of EBP. 0xFF00 is\nthe top of the lower stack frame, and the original ESP in Figure 4-7 pointed\nhere. Finally, you can still see the stack memory from preceding functions\nin the call chain from 0xFF04 to 0xFFFF.\nFrom Code to Memory: A General Primer 87\n0x0000\n. . .\n0xFF00 – 16 ESP\n0xFF00 – 12\n0xFF00 – 8\n0xFF00 – 4 EBP\n0xFF00\n. . .\nFigure 4-8: Example stack with stack\nframe set up (read from bottom to top)\nWith the stack in this state, the function is free to use its local data as\nit pleases. If this function called another function, the new function would\nbuild its own stack frame using the same technique (the stack frames really\nstack up). Once a function finishes using a stack frame, however, it must\nrestore the stack to its previous state. In our case, that means making the\nstack look like it did in Figure 4-7. When the second function finishes, our\nfirst function cleans the stack using the following two commands:\nMOV ESP, EBP ; demolishes the stack frame, bringing ESP to 4 bytes above\n; its original value (0xFF00-4)\nPOP EBP ; restores the bottom of the old stack frame that was saved by\n; 'PUSH EBP'. Also adds 4 bytes to ESP, putting it back at\n; its original value\nBut if you want to change the parameters passed to a function in a game,\ndon’t look for them in that function’s stack frame. A function’s parameters\nare stored in the stack frame of the function that called it, and they’re ref-\nerenced through [EBP+8h], [EBP+Ch], and so on. They start at [EBP+8h] because\n[EBP+4h] stores the function’s return address. (“Function Calls” on page 94\nexplains this topic further.)\nNO tE Code can be compiled with stack frames disabled. When this is the case, you’ll notice\nthat functions don’t open with PUSH EBP and instead reference everything relative to\nESP. More often than not, though, stack frames are enabled in compiled game code.\nNow that you have a grasp on the fundamentals of assembly code, let’s\nexplore some specifics that will come in handy when hacking games.\n88 Chapter 4"
  },
  {
    "input": "Important x86 Instructions for Game Hacking",
    "output": "Important x86 Instructions for Game Hacking\nWhile assembly language has hundreds of instructions, many well-equipped\ngame hackers understand only a small subset of them, which I cover in detail\nhere. This subset typically encapsulates all instructions that are used to mod-\nify data, call functions, compare values, or jump around within code.\nData Modification\nData modification often happens over several assembly operations, but\nthe end result has to be stored either in memory or in a register, typically\nwith the MOV instruction. The MOV operation takes two operands: a destina-\ntion and a source. Table 4-6 shows all possible sets of MOV operands and the\nresults you can expect from those calls.\nTable 4-6: Operands to the MOV Instruction\nInstruction syntax Result\nMOV R1, R2 Copies R2’s value to R1.\nMOV R1, [R2] Copies the value from the memory referenced\nby R2 to R1.\nMOV R1, [R2+Ah] Copies the value from the memory referenced\nby R2+0xA to R1.\nMOV R1, [DEADBEEFh] Copies the value from the memory at\n0xDEADBEEF to R1.\nMOV R1, BADF00Dh Copies the value 0xBADF00D to R1.\nMOV [R1], R2 Copies R2’s value to the memory referenced\nby R1.\nMOV [R1], BADF00Dh Copies the value 0xBADF00D to the memory\nreferenced by R1.\nMOV [R1+4h], R2 Copies R2’s value to the memory referenced\nby R1+0x4.\nMOV [R1+4h], BADF00Dh Copies the value 0xBADF00D to the memory\nreferenced by R1+0x4.\nMOV [DEADBEEFh], R1 Copies R1’s value to the memory at\n0xDEADBEEF.\nMOV [DEADBEEFh], BADF00Dh Copies the value 0xBADF00D to the memory\nat 0xDEADBEEF.\nThe MOV instruction can take a lot of operand combinations, but some\naren’t allowed. First, the destination operand can’t be an immediate value;\nit must be a register or memory address, because immediate values can’t be\nmodified. Second, values can’t be directly copied from one memory address\nto another. Copying a value requires two separate operations, like so:\nMOV EAX, [EBP+10h] ; copy memory from EBP+0x10 to EAX\nMOV [DEADBEEFh], EAX ; MOV the copied memory to memory at 0xDEADBEEF\nFrom Code to Memory: A General Primer 89\nThese instructions copy whatever is stored at EBP+0x10 to the memory at\n0xDEADBEEF.\narithmetic\nLike many high-level languages, assembly language has two types of arith-\nmetic: unary and binary. Unary instructions take a single operand that\nacts as both a destination and a source. This operand can be a register or\na memory address. Table 4-7 shows the common unary arithmetic instruc-\ntions in x86.\nTable 4-7: Unary Arithmetic Instructions\nInstruction syntax Result\nINC operand Adds 1 to the operand value.\nDEC operand Subtracts 1 from the operand value.\nNOT operand Logically negates the operand value (flips all bits).\nNEG operand Performs two’s-complement negation (flips all bits and adds 1;\nessentially multiplies by −1).\nBinary instructions (which make up the majority of x86 arithmetic), on\nthe other hand, are syntactically similar to the MOV instruction. They require\ntwo operands and have similar operand limitations. Unlike MOV, however,\ntheir destination operand serves a second purpose: it is also the left-hand\nvalue in the calculation. For example, the assembly operation ADD EAX,EBX\nequates to EAX = EAX + EBX or EAX += EBX in C++. Table 4-8 shows the common\nx86 binary arithmetic instructions.\nTable 4-8: Binary Arithmetic Instructions\nInstruction syntax Function Operand notes\nADD destination, source destination += source\nSUB destination, source destination -= source\nAND destination, source destination &= source\nOR destination, source destination |= source\nXOR destination, source destination ^= source\nSHL destination, source destination = destination << source source must be CL or an 8-bit\nimmediate value.\nSHR destination, source destination = destination >> source source must be CL or an 8-bit\nimmediate value.\nIMUL destination, source destination *= source destination must be a register;\nsource cannot be an immediate\nvalue.\nOf these arithmetic instructions, IMUL is special because you can pass it\na third operand, in the form of an immediate value. With this prototype,\nthe destination operand is no longer involved in the calculation, which\n90 Chapter 4\ninstead takes place between the remaining operands. For example, the\nassembly command IMUL EAX,EBX,4h equates to EAX = EBX * 0x4 in C++.\nYou can also pass a single operand to IMUL.3 In this case, the oper-\nand acts as the source and can be either a memory address or a register.\nDepending on the size of the source operand, the instruction will use\ndifferent parts of the EAX register for inputs and output, as shown in\nTable 4-9.\nTable 4-9: Possible IMUL Register Operands\nSource size Input Output\n8 bits AL 16 bit, stored in AH:AL (which is AX)\n16 bits AX 32 bit, stored in DX:AX (bits 0–15 in AX and bits\n16–31 in DX)\n32 bits EAX 64 bit, stored in EDX:EAX (bits 0–31 in EAX and\nbits 32–64 in EDX)\nNotice that even though the input is only one register, each output uses\ntwo registers. That’s because in multiplication, the result generally is larger\nthan the inputs.\nLet’s look at an example calculation using IMUL with a single 32-bit\noperand:\nIMUL [BADFOODh] ; 32-bit operand is at address 0xBADFOOD\nThis command behaves like the following pseudocode:\nEDX:EAX = EAX * [BADFOODh]\nSimilarly, here’s an operation that uses IMUL with a single 16-bit\noperand:\nIMUL CX ; 16-bit operand is stored in CX\nAnd its corresponding pseudocode:\nDX:AX = AX * CX\nFinally, this is an IMUL command with a single 8-bit operand:\nIMUL CL ; 8-bit operand is stored in CL\nAnd its corresponding pseudocode:\nAX = AL * CL\n3. There is also an unsigned multiplication instruction, MUL, which only works with a single\noperand.\nFrom Code to Memory: A General Primer 91\nx86 assembly language has division as well, through the IDIV instruction.4\nThe IDIV instruction accepts a single source operand and follows register\nrules similar to those for IMUL. As Table 4-10 shows, IDIV operations require\ntwo inputs and two outputs.\nTable 4-10: Possible IDIV Register Operands\nSource size Input Output\n8 bit 16 bit, stored in AH:AL (which is AX) Remainder in AH; quotient in AL\n16 bit 32 bit, stored in DX:AX Remainder in DX; quotient in AX\n32 bit 64 bit, stored in EDX:EAX Remainder in EDX; quotient in EAX\nIn division, the inputs are generally larger than the output, so here\nthe inputs take two registers. Moreover, division operations must store a\nremainder, which gets stored in the first input register. For example, here’s\nhow a 32-bit IDIV calculation would look:\nMOV EDX, 0 ; there's no high-order DWORD in the input, so EDX is 0\nMOV EAX, inputValue ; 32-bit input value\nIDIV ECX ; divide EDX:EAX by ECX\nAnd here’s some pseudocode that expresses what happens under\nthe hood:\nEAX = EDX:EAX / ECX ; quotient\nEDX = EDX:EAX % ECX ; remainder\nThese details of IDIV and IMUL are important to remember, as the behav-\nior can otherwise be quite obfuscated when you’re simply looking at the\ncommands.\nBranching\nAfter evaluating an expression, programs can decide what to execute next\nbased on the result, typically using constructs such as if() statements or\nswitch() statements. These control flow statements don’t exist at the assem-\nbly level, however. Instead, assembly code uses the EFLAGS register to make\ndecisions and jump operations to execute different blocks; this process is\ncalled branching.\nTo get the proper value in EFLAGS, assembly code uses one of two\ninstructions: TEST or CMP. Both compare two operands, set the status bits of\nEFLAGS, and then discard any results. TEST compares the operands using\na logical AND, while CMP uses signed subtraction to subtract the latter oper-\nand from the former.\n4. Just as MUL is to IMUL, DIV is the unsigned counterpart to IDIV.\n92 Chapter 4\nIn order to branch properly, the code has a jump command immedi-\nately following the comparison. Each type of jump instruction accepts a\nsingle operand that specifies the address of the code to jump to. How a\nparticular jump instruction behaves depends on the status bits of EFLAGS.\nTable 4-11 describes some x86 jump instructions.\nTable 4-11: Common x86 Jump Instructions\nInstruction Name Behavior\nJMP dest Unconditional jump Jumps to dest (sets EIP to dest).\nJE dest Jump if equal Jumps if ZF (zero flag) is 1.\nJNE dest Jump if not equal Jumps if ZF is 0.\nJG dest Jump if greater Jumps if ZF is 0 and SF (sign flag) is equal\nto OF (overflow flag).\nJGE dest Jump if greater or equal Jumps if SF is equal to OF.\nJA dest Unsigned JG Jumps if CF (carry flag) is 0 and ZF is 0.\nJAE dest Unsigned JGE Jumps if CF is 0.\nJL dest Jump if less Jumps if SF is not equal to OF.\nJLE dest Jump if less or equal Jumps if ZF is 1 or SF is not equal to OF.\nJB dest Unsigned JL Jumps if CF is 1.\nJBE dest Unsigned JLE Jumps if CF is 1 or ZF is 1.\nJO dest Jump if overflow Jumps if OF is 1.\nJNO dest Jump if not overflow Jumps if OF is 0.\nJZ dest Jump if zero Jumps if ZF is 1 (identical to JE).\nJNZ dest Jump if not zero Jumps if ZF is 0 (identical to JNE).\nRemembering which flags control which jump instructions can be a\npain, but their purpose is clearly expressed in their name. A good rule of\nthumb is that a jump preceded by a CMP is the same as its corresponding\noperator. For example, Table 4-11 lists JE as “jump if equal,” so when JE fol-\nlows a CMP operation, it’s the same as the == operator. Similarly, JGE would be\n>=, JLE would be >=, and so on.\nAs an example, consider the high-level code shown in Listing 4-8.\n--snip--\nif (EBX > EAX)\nECX = EDX;\nelse\nECX = 0;\n--snip--\nListing 4-8: A simple conditional statement\nFrom Code to Memory: A General Primer 93\nThis if() statement just checks whether EBX is greater than EAX and sets\nECX based on the result. In assembly, the same statement may look some-\nthing like this:\n--snip--\nCMP EBX, EAX ; if (EBX > EAX)\nJG label1 ; jump to label1 if EBX > EAX\nMOV ECX, 0 ; ECX = 0 (else block)\nJMP label2 ; jump over the if block\nlabel1:\nu MOV ECX, EDX ; ECX = EDX (if block)\nlabel2:\n--snip--\nThe assembly for the if() statement in Listing 4-8 begins with a CMP\ninstruction and branches if EBX is greater than EAX. If the branch is taken,\nEIP is set to the if block at u courtesy of the JG instruction. If the branch\nis not taken, the code continues executing linearly and hits the else block\nimmediately after the JG instruction. When the else block finishes execut-\ning, an unconditional JMP sets EIP to 0x7, skipping over the if block.\nFunction Calls\nIn assembly code, functions are isolated blocks of commands executed\nthrough the CALL instruction. The CALL instruction, which takes a function\naddress as the only operand, pushes a return address onto the stack and\nsets EIP to its operand value. The following pseudocode shows a CALL in\naction, with memory addresses on the left in hex:\n0x1: CALL EAX\n0x2: ...\nWhen CALL EAX is executed, the next address is pushed to the stack and\nEIP is set to EAX, showing that CALL is essentially a PUSH and JMP. The following\npseudocode underscores this point:\n0x1: PUSH 3h\n0x2: JMP EAX\n0x3: ...\nWhile there’s an extra address between the PUSH instruction and the\ncode to execute, the result is the same: before the block of code at EAX is\nexecuted, the address of the code that follows the branch is pushed to the\nstack. This happens so the callee (the function being called) knows where to\njump to in the caller (the function doing the call) when it returns.\nIf a function without parameters is called, a CALL command is all that’s\nnecessary. If the callee takes parameters, however, the parameters must first\n94 Chapter 4\nbe pushed onto the stack in reverse order. The following pseudocode shows\nhow a function call with three parameters might look:\nPUSH 300h ; arg3\nPUSH 200h ; arg2\nPUSH 100h ; arg1\nCALL ECX ; call\nWhen the callee is executed, the top of the stack contains a return\naddress that points to the code after the call. The first parameter, 0x100,\nis below the return address on the stack. The second parameter, 0x200, is\nbelow that, followed by the third parameter, 0x300. The callee sets up its\nstack frame, using memory offsets from EBP to reference each parameter.\nOnce the callee has finished executing, it restores the caller’s stack frame\nand executes the RET instruction, which pops the return address off the\nstack and jumps to it.\nSince the parameters are not a part of the callee’s stack frame, they\nremain on the stack after RET is executed. If the caller is responsible for\ncleaning the stack, it adds 12 (3 parameters, at 4 bytes each) to ESP imme-\ndiately after CALL ECX completes. If the callee is responsible, it cleans up by\nexecuting RET 12 instead of RET. This responsibility is determined by the cal-\nlee’s calling convention.\nA function’s calling convention tells the compiler how the assembly code\nshould pass parameters, store instance pointers, communicate the return\nvalue, and clean the stack. Different compilers have different calling con-\nventions, but the ones listed in Table 4-12 are the only four that a game\nhacker is likely to encounter.\nTable 4-12: Calling Conventions to Know for Game Hacking\nDirective Cleaner Notes\n__cdecl caller Default convention in Visual Studio.\n__stdcall callee Convention used by Win32 API functions.\n__fastcall callee First two DWORD (or smaller) parameters are\npassed in ECX and EDX.\n__thiscall callee Used for member functions. The pointer to\nthe class instance is passed in ECX.\nThe Directive column in Table 4-12 gives the name of the calling con-\nvention, and the Cleaner column tells you whether the caller or callee is\nresponsible for cleaning the stack given that directive. In the case of these\nfour calling conventions, parameters are always pushed right to left, and\nreturn values are always stored in EAX. This is a standard, but not a rule;\nit can differ across other calling conventions.\nFrom Code to Memory: A General Primer 95"
  },
  {
    "input": "Closing Thoughts",
    "output": "closing Thoughts\nMy goal in writing this chapter was to help you understand memory and\nassembly in a general sense, before we dig into game-hacking specifics.\nWith your newfound ability to think like a computer, you should be ade-\nquately armed to start tackling more advanced memory forensics tasks. If\nyou’re itching for a peek at how you’ll apply all of this to something real, flip\nto “Applying Call Hooks to Adobe AIR” on page 169 or “Applying Jump\nHooks and VF Hooks to Direct3D” on page 175.\nIf you want some hands-on time with memory, compile this chapter’s\nexample code and use Cheat Engine or OllyDbg to inspect, tweak, and poke\nat the memory until you’ve got the hang of it. This is important, as the next\nchapter will build on these skills by teaching you advanced memory forensic\ntechniques.\n96 Chapter 4"
  },
  {
    "input": "Chapter 5: Advanced Memory Forensics",
    "output": "5\nADVANCED M EMOry fOr ENsICs\nWhether you hack games as a hobby or\na business, you’ll eventually find yourself\nbetween a rock and . . . an unintelligible\nmemory dump. Be it a race with a rival bot\ndeveloper to release a highly requested feature, a\nbattle against a game company’s constant barrage of\nupdates, or a struggle to locate some complex data\nstructure in memory, you’ll need top-notch memory\nforensics skills to prevail.\nSuccessful bot development is precariously balanced atop speed and\nskill, and tenacious hackers must rise to the challenge by swiftly releasing\ningenious features, promptly responding to game updates, and readily\nsearching for even the most elusive pieces of data. Doing this, however,\nrequires a comprehensive understanding of common memory patterns,\nadvanced data structures, and the purpose of different pieces of data."
  },
  {
    "input": "Deducing Purpose",
    "output": "Those three aspects of memory forensics are perhaps the most effective\nweapons in your arsenal, and this chapter will teach you how to use them.\nFirst, I’ll discuss advanced memory-scanning techniques that focus on\nsearching for data by understanding its purpose and usage. Next, I’ll teach\nyou how to use memory patterns to tackle game updates and tweak your\nbots without having to relocate all of your addresses from scratch. To wrap\nup, I’ll dissect the four most common complex data structures in the C++\nstandard library (std::string, std::vector, std::list, and std::map) so you can\nrecognize them in memory and enumerate their contents. By the end of the\nchapter, my hope is that you’ll have a deep understanding of memory foren-\nsics and be able to take on any challenge related to memory scanning.\nadvanced memory Scanning\nWithin a game’s source code, each piece of data has a cold, calculated defi-\nnition. When the game is being played, however, all of that data comes\ntogether to create something new. Players only experience the beautiful\nscenery, visceral sounds, and intense adventures; the data that drives these\nexperiences is irrelevant.\nWith that in mind, imagine Hacker A has just started tearing into his\nfavorite game, wanting to automate some of the boring bits with a bot. He\ndoesn’t have a complete understanding of memory yet, and to him, the\ndata is nothing but assumptions. He thinks, “I have 500 health, so I can\nfind the health address by telling Cheat Engine to look for a 4-byte integer\nwith a value of 500.” Hacker A has an accurate understanding of data: it’s\njust information (values) stored at particular locations (addresses) using\ndefined structures (types).\nNow imagine Hacker B, who already understands the game both inside\nand out; she knows how playing the game alters its state in memory, and the\ndata no longer has any secrets. She knows that every defined property of\nthe data can be determined given its purpose. Unlike Hacker A, Hacker B\nhas an understanding of data that transcends the confines of a single vari-\nable declaration: she considers the data’s purpose and usage. In this section,\nwe’ll discuss both.\nEach piece of data in a game has a purpose, and the assembly code of\nthe game must, at some point, reference the data to fulfill that purpose.\nFinding the unique code that uses a piece of data means finding a version-\nagnostic marker that persists across game updates until the data is either\nremoved or its purpose is changed. Let me show you why this is important.\nDeducing Purpose\nSo far, I’ve only shown you how to blindly search memory for a given piece\nof data without considering how it’s being used. This method can be effec-\ntive, but it is not always efficient. In many cases, it’s much quicker to deduce\nthe purpose of data, determine what code might use that data, and then\nlocate that code to ultimately find the address of the data.\n98 Chapter 5"
  },
  {
    "input": "Finding the Player’s Health with OllyDbg",
    "output": "This might not sound easy, but neither does “scan the game’s memory\nfor a specific value of a specific data type, and then continuously filter the\nresult list based on changing criteria,” which is what you’ve learned to do\nthus far. So let’s look at how we might locate the address for health given its\npurpose. Consider the code in Listing 5-1.\nstruct PlayerVital {\nint current, maximum;\n};\nPlayerVital health;\n--snip--\nprintString(\"Health: %d of %d\\n\", health.current, health.maximum);\nListing 5-1: A structure containing the player’s vitals, and a function that displays them\nIf you pretend that printString() is a fancy function to draw text on an\nin-game interface, then this code is pretty close to what you might find in a\ngame. The PlayerVital structure has two properties: the current value and a\nmaximum value. The value health is a PlayerVital structure, so it has these prop-\nerties, too. Based on the name alone, you can deduce that health exists to\ndisplay information about the player’s health, and you can see this purpose\nfulfilled when printString() uses the data.\nEven without the code, you can intuitively draw similar conclusions by\njust looking at the health text displayed in the game’s interface; a computer\ncan’t do anything without code, after all. Aside from the actual health vari-\nable, there are a few code elements that need to exist to show a player this\ntext. First, there needs to be some function to display text. Second, the\nstrings Health and of must be nearby.\nNO tE Why do I assume the text is split into two separate strings instead of one? The game\ninterface shows that the current health value is between these two strings, but there are\nmany ways that could happen, including format strings, strcat(), or text aligned\nwith multiple display text calls. When you’re analyzing data, it’s best to keep your\nassumptions broad to account for all possibilities.\nTo find health without using a memory scanner, we could utilize these\ntwo distinct strings. We probably wouldn’t have a clue what the function\nto display text looks like, where it is, or how many times it’s called, though.\nRealistically, the strings are all we would know to look for, and that’s\nenough. Let’s walk through it.\nFinding the Player’s Health with OllyDbg\nI’ll walk you through how to track down the health structure in this sec-\ntion, but I’ve also included the binary I analyze in the book’s resource files.\nTo follow along and get some hands-on practice, use the file Chapter5_\nAdvancedMemoryForensics_Scanning.exe.\nFirst, open OllyDbg and attach it to the executable. Then, open\nOllyDbg’s Executable modules window and double-click the main module;\nin my example, the main module is the only .exe in the module’s window.\nAdvanced Memory Forensics 99\nThe CPU window should pop up. Now, right-click in the Disassembler pane\nand select Search for4All referenced text strings. This should open the\nReferences window, shown in Figure 5-1.\nFigure 5-1: OllyDbg’s References window, showing only\na list of strings. There would be a lot more than four in a\nreal game.\nFrom this window, right-click and select Search for text. A search dia-\nlog appears. Enter the string you’re looking for, as shown in Figure 5-2,\nand make the search as broad as possible by disabling Case sensitive and\nenabling Entire scope.\nFigure 5-2: Searching for strings in OllyDbg\nClick OK to execute the search. The References window comes back into\nfocus with the first match highlighted. Double-click the match to see the\nassembly code that uses the string inside the CPU window. The Disassembler\npane focuses on the line of code at 0x401030, which pushes the format string\nparameter to printString(). You can see this line in Figure 5-3, where I’ve\nhighlighted the entire function call block.\n(cid:31)\n(cid:30)\n(cid:29)\nFigure 5-3: Viewing the printString() call in the CPU window’s Disassembler pane\nBy reading the assembly code, you can get a very accurate understand-\ning of exactly what the game is doing. The black bracket on the left shows\nthat the string Health is inside a function call. Notice the arguments to that\n100 Chapter 5"
  },
  {
    "input": "Determining New Addresses After Game Updates",
    "output": "function. In order, these are EAX u, ECX v, and the format string at\n0x4020D0 w. EAX is the value at 0x40301C, ECX is the value at 0x403018,\nand the format string contains Health. Since the string contains two format\nplaceholders, you can assume that the remaining two parameters are the\narguments for those placeholders.\nKnowing what the arguments are and that they are pushed in reverse\norder, you can work backward and conclude that the original code looked\nsomething like Listing 5-2.\nint currentHealth; // value at 0x403018\nint maxHealth; // value at 0x40301C\n--snip--\nsomeFunction(\"Health: %d of %d\\n\",\ncurrentHealth, maxHealth);\nListing 5-2: How a game hacker might interpret the assembly that Figure 5-3 compiles to\nThe values stored in EAX and ECX are adjacent in memory, which\nmeans they may be part of a structure. To keep it simple, though, this\nexample just shows them as variable definitions. Either way, these are the\ntwo numbers used to display the player’s health. Because both of these impor-\ntant values were displayed in the game’s UI, it was easy to make assumptions\nabout the underlying code that displays them. When you know the purpose\nof a piece of data, you can quickly find the code responsible for fulfilling it;\nin this case, that knowledge helped us quickly find both addresses.\nIn many cases, finding addresses can be this easy, but some pieces of\ndata have such complex purposes that it’s harder to guess what to look for.\nFiguring out how to search for map data or character locations in OllyDbg,\nfor instance, can be pretty tricky.\nStrings are far from the only markers that you can use to find the\ndata you want to change in a game, but they are definitely the easiest to\nteach without giving contrived examples. Moreover, some games have log-\nging or error strings embedded in their code, and poking around in the\nReferenced text strings window of OllyDbg can be a quick way to determine\nwhether these strings are present. If you become familiar with a game’s log-\nging practices, you’ll be able to find values even more easily.\nDetermining New Addresses After Game Updates\nWhen application code is modified and recompiled, a brand-new binary\nthat reflects the changes is produced. This binary might be very similar to\nthe previous one, or the binaries might be nothing alike; the difference\nbetween the two versions has a direct correlation to the complexity of the\nhigh-level changes. Small changes, like modified strings or updated con-\nstants, can leave binaries nearly identical and often have no effect on the\naddresses of code or data. But more complex changes—like added features,\na new user interface, refactored internals, or new in-game content—often\ncause shifts in the location of crucial memory.\nAdvanced Memory Forensics 101\nAutOMAtICAlly fIND CurrENtHEAltH AND MAxHEAltH\nIn “Searching for Assembly Patterns” on page 19 and “Searching for Strings”\non page 21, I showed a few Cheat Engine Lua scripts and explained how\nthey worked. Using the findString() function in these examples, you can\nmake Cheat Engine automatically locate the address of the format string that\nwe just found manually in OllyDbg. Next, you can write a small function to\nscan for this address following byte 0x68 (the byte for the PUSH command,\nas you can see beside it at 0x401030 in Figure 5-3) to locate the address\nof the code that pushes it to the stack. Then, you can read 4 bytes from\npushAddress - 5 and pushAddress - 12 to locate currentHealth and maxHealth,\nrespectively.\nThis may not seem useful since we’ve already found the addresses, but\nif this were a real game, these addresses would change when an update is\nreleased. Using this knowledge to automate finding them can be very helpful.\nIf you’re up to the challenge, give it a whirl!\nDue to constant bug fixes, content improvements, and feature addi-\ntions, online games are among the most rapidly evolving types of software.\nSome games release updates as often as once a week, and game hackers often\nspend a majority of their time reverse engineering the new binaries in order\nto accordingly update their bots.\nIf you create advanced bots, they will become increasingly supported\nby a foundation of memory addresses. When an update comes, determin-\ning the new addresses for a large number of values and functions is the\nmost time-consuming inevitability you will face. Relying on the “Tips for\nWinning the Update Race” can be very beneficial, but the tips won’t help\nyou locate the updated addresses. You can automatically locate some\naddresses using Cheat Engine scripts, but that won’t always work either.\nSometimes you’ll have to do the dirty work by hand.\nIf you try to reinvent the wheel and find these addresses the same way\nyou did initially, you’ll be wasting your time. You actually have a big advan-\ntage, though: the old binary and the addresses themselves. Using these two\nthings, it is possible to find every single address you need to update in a\nfraction of the time.\nFigure 5-4 shows two different disassemblies: a new game binary on the\nleft and the previous version on the right. I have taken this image from an\nactual game (which will remain nameless) in order to give you a realistic\nexample.\n102 Chapter 5\nFigure 5-4: Side-by-side disassemblies of two versions of one game\nMy bot modified the code at 0x047B542 (right), and I needed to find\nthe corresponding code in the new version, which I discovered at 0x047B672\n(left). This function call invokes a packet-parsing function when a packet\nhas been received. In order to find this address originally (and by “origi-\nnally,” I mean about 100 updates previous), I figured out how the game’s\nnetwork protocol worked, set breakpoints on many network-related API\ncalls, stepped through execution, and inspected data on the stack until I\nfound something that looked similar to what I expected given my knowl-\nedge of the protocol.\ntIPs fOr wINNING tHE uPDAtE rACE\nIn saturated markets, being the first bot developer to release a stable update is\ncritical to success. The race starts the second the game updates, and hackers\ndetermined to be the fastest will spend hundreds of hours preparing. These are\nthe most common ways to stay on top:\nCreate update alarms By writing software that alerts you as soon as the game\npatches, you can begin working on your updates as soon as possible.\nAutomate bot installs Games often schedule expected updates at times when\nthe fewest players are online. Botters hate waking up and downloading new\nsoftware before they bot, but they love waking up to find it silently installed\nwhile the game is patching.\nUse fewer addresses The less there is to update, the better. Consolidating\nrelated data into structures and eliminating unnecessary memory address\nusage can save a bunch of time.\nHave great test cases Data changes, and hackers make mistakes. Having\nways to quickly test every feature can be the difference between a stable bot\nand one that randomly crashes, gets users killed, or even leads to their charac-\nters being banned from the game.\nAttacking updates with these practices will give you a sizable head start,\nbut they might not always be enough to lead you to victory. Above all else,\nstrive to understand reverse engineering as much as possible and use that\nunderstanding to your advantage.\nAdvanced Memory Forensics 103\nI could have followed the same steps for each of the 100+ updates since\nthen, but that would have been unnecessary. The code stayed relatively the\nsame throughout the years, which let me use patterns from the old code to\nfind that function call’s address in the new code.\nNow, consider this chunk of assembly code:\nPUSH EDI\nPUSH EAX\nLEA EAX,DWORD PTR SS:[EBP-C]\nMOV DWORD PTR FS:[0],EAX\nMOV DWORD PTR SS:[EBP-10],ESP\nMOV DWORD PTR SS:[EBP-220],-1\nMOV DWORD PTR SS:[EBP-4],0\nDoes it look familiar? Compare it to Figure 5-4, and you’ll see that this\nexact code exists right above the highlighted function call in both versions\nof the game. Regardless of what it does, the combination of operations looks\npretty distinctive; because of the number of different offsets the code is\nusing relative to EBP, it’s unlikely that an identical chunk of code exists in\nany other part of the binary.\nEvery time I have to update this address, I open the old binary\nin OllyDbg, highlight this chunk of operations, right-click, and select\nAsm2Clipboard4Copy fixed asm to clipboard. Then, I open the new binary\nin OllyDbg, navigate to the CPU Window, press ctrl-S, paste the assembly\ncode, and hit Find. In 9.5 cases out of 10, this places me directly above the\nfunction call I need to find in the new version.\nWhen an update comes, you can use the same method to find nearly all\nof your known addresses. It should work for every address you can find eas-\nily in assembly code. There are a few caveats, though:\n• OllyDbg limits search to eight operations, so you must find code mark-\ners of that size or smaller.\n• The operations you use cannot contain any other addresses, as those\naddresses have likely changed.\n• If parts of the game have changed that use the address you’re looking\nfor, the code might be different.\n• If the game changes compilers or switches optimization settings, almost\nall code will be entirely different.\nAs discussed in “Automatically Find currentHealth and maxHealth” on\npage 102, you can benefit from writing scripts that carry out these tasks for\nyou. Serious game hackers work very hard to automatically locate as many\naddresses as possible, and some of the best bots are engineered to automati-\ncally detect their addresses at runtime, every time. It can be a lot of work\ninitially, but the investment can definitely pay off.\n104 Chapter 5"
  },
  {
    "input": "The std::string Class",
    "output": "identifying complex Structures in Game data\nChapter 4 described how a game might store data in static structures. This\nknowledge will suffice when you’re trying to find simple data, but it falls\nshort for data that is stored through dynamic structures. This is because\ndynamic structures might be scattered across different memory locations,\nfollow long pointer chains, or require complex algorithms to actually extract\nthe data from them.\nThis section explores common dynamic structures you’ll find in video\ngame code, and how to read data from them once they’re found. To begin,\nI’ll talk about the underlying composition of each dynamic structure.\nNext, I’ll outline the algorithms needed to read the data from these struc-\ntures. (For simplicity, each algorithm discussion assumes you have a pointer\nto an instance of the structure as well as some way to read from memory.)\nLastly, I’ll cover tips and tricks that can help you determine when a value\nyou’re searching for in memory is actually encapsulated in one of these\nstructures, so you’ll know when to apply this knowledge. I’ll focus on C++,\nas its object-oriented nature and heavily used standard library are typically\nresponsible for such structures.\nNO tE Some of these structures might differ slightly from machine to machine based on com-\npilers, optimization settings, or standard library implementations, but the basic con-\ncepts will remain the same. Also, in the interest of brevity, I will be omitting irrelevant\nparts of these structures, such as custom allocators or comparison functions. Working\nexample code can be found at https://www.nostarch.com/gamehacking/ in the\nresource files for Chapter 5.\nThe std::string Class\nInstances of std::string are among the most common culprits of dynamic\nstorage. This class from the C++ Standard Template Library (STL) abstracts\nstring operations away from the developer while preserving efficiency,\nmaking it widely used in all types of software. A video game might use\nstd::string structure for any string data, such as creature names.\nExamining the Structure of a std::string\nWhen you strip away the member functions and other nondata components\nof the std::string class, this is the structure that remains:\nclass string {\nunion {\nchar* dataP;\nchar dataA[16];\n};\nint length;\n};\n// point to a string in memory\nstring* _str = (string*)stringAddress;\nAdvanced Memory Forensics 105\nThe class reserves 16 characters that are presumably used to store\nthe string in place. It also, however, declares that the first 4 bytes can be a\npointer to a character. This might seem odd, but it’s a result of optimiza-\ntion. At some point, the developers of this class decided that 15 charac-\nters (plus a null terminator) was a suitable length for many strings, and\nthey chose to save on memory allocations and de-allocations by reserving\n16 bytes of memory in advance. To accommodate longer strings, they allowed\nthe first 4 bytes of this reserved memory to be used as a pointer to the char-\nacters of these longer strings.\nNO tE If the code were compiled to 64 bits, then it would actually be the first 8 (not 4) bytes\nthat point to a character. Throughout this example, however, you can assume 32-bit\naddresses and that int is the size of an address.\nAccessing string data this way takes some overhead. The function to\nlocate the right buffer looks something like this:\nconst char* c_str() {\nif (_str->length <= 15)\nreturn (const char*)&_str->dataA[0];\nelse\nreturn (const char*)_str->dataP;\n}\nThe fact that a std::string can be either a complete string or a pointer\nto a longer string makes this particular structure quite tricky from a game-\nhacking perspective. Some games may use std::string to store strings that\nonly rarely exceed 15 characters. When this is the case, you might imple-\nment bots that rely on these strings, never knowing that the underlying\nstructure is in fact more complicated than a simple string.\nOverlooking a std::string Can ruin Your Fun\nNot knowing the true nature of the structure containing the data you need\ncan lead you to write a bot that works only some of the time and fails when\nit counts. Imagine, for example, that you’re trying to figure out how a game\nstores creature data. In your hypothetical search, you find that all the\ncreatures in the game are stored in an array of structures that look some-\nthing like Listing 5-3.\nstruct creatureInfo {\nint uniqueID;\nchar name[16];\nint nameLength;\nint healthPercent;\nint xPosition;\nint yPosition;\nint modelID;\n106 Chapter 5\nint creatureType;\n};\nListing 5-3: How you might interpret creature data found in memory\nAfter scanning the creature data in memory, say you notice that the\nfirst 4 bytes of each structure are unique for each creature, so you call those\nbytes the uniqueID and assume they form a single int property. Looking fur-\nther in the memory, you find that the creature’s name is stored right after\nuniqueID, and after some deduction, you figure out the name is 16 bytes\nlong. The next value you see in memory turns out to be the nameLength; it’s a\nbit strange that a null-terminated string has an associated length, but you\nignore that oddity and continue analyzing the data in memory. After fur-\nther analysis, you determine what the remaining values are for, define the\nstructure shown in Listing 5-3, and write a bot that automatically attacks\ncreatures with certain names.\nAfter weeks of testing your bot while hunting creatures with names like\nDragon, Cyclops, Giant, and Hound, you decide it’s time to give your bot to\nyour friends. For the inaugural use, you gather everyone together to kill a\nboss named Super Bossman Supreme. The entire team sets the bot to attack\nthe boss first and target lesser creatures like a Demon or Grim Reaper when the\nboss goes out of range.\nOnce your team arrives at the boss’s dungeon . . . you’re all slowly\nobliterated.\nWhat went wrong in this scenario? Your game must be storing creature\nnames with std::string, not just a simple character array. The name and\nnameLength fields in creatureInfo are, in fact, part of a std::string field, and\nthe name character array is a union of dataA and dataP members. Super Bossman\nSupreme is longer than 15 characters, and because the bot was not aware of\nthe std::string implementation, it didn’t recognize the boss. Instead, it con-\nstantly retargeted summoned Demon creatures, effectively keeping you from\ntargeting the boss while he slowly drained your health and supplies.\nDetermining Whether Data Is Stored in a std::string\nWithout knowing how the std::string class is structured, you’d have trouble\ntracking down bugs like the hypothetical one I just described. But pair what\nyou’ve learned here with experience, and you can avoid these kinds of bugs\nentirely. When you find a string like name in memory, don’t just assume it’s\nstored in a simple array. To figure out whether a string is in fact a std::string,\nask yourself these questions:\n• Why is the string length present for a null-terminated string? If you\ncan’t think of a good reason, then you may have a std::string on your\nhands.\n• Do some creatures (or other game elements, depending on what you’re\nlooking for) have names longer than 16 letters, but you find room for\nonly 16 characters in memory? If so, the data is almost definitely stored\nin a std::string.\nAdvanced Memory Forensics 107"
  },
  {
    "input": "The std::vector Class",
    "output": "• Is the name stored in place, requiring the developer to use strcpy()\nto modify it? It’s probably a std::string, because working with raw C\nstrings in this way is considered bad practice.\nFinally, keep in mind that there is also a class called std::wstring that is\nused to store wide strings. The implementation is very similar, but wchar_t\nis used in place of every char.\nThe std::vector Class\nGames must keep track of many dynamic arrays of data, but manag-\ning dynamically sized arrays can be very tricky. For speed and flexibility,\ngame developers often store such data using a templated STL class called\nstd::vector instead of a simple array.\nExamining the Structure of a std::vector\nA declaration of this class looks something like Listing 5-4.\ntemplate<typename T>\nclass vector {\nT* begin;\nT* end;\nT* reservationEnd;\n};\nListing 5-4: An abstracted std::vector object\nThis template adds an extra layer of abstraction, so I’ll continue this\ndescription using a std::vector declared with the DWORD type. Here’s how a\ngame might declare that vector:\nstd::vector<DWORD> _vec;\nNow, let’s dissect what a std::vector of DWORD objects would look like in\nmemory. If you had the address of _vec and shared the same memory space,\nyou could re-create the underlying structure of the class and access _vec as\nshown in Listing 5-5.\nclass vector {\nDWORD* begin;\nDWORD* end;\nDWORD* tail;\n};\n// point to a vector in memory\nvector* _vec = (vector*)vectorAddress;\nListing 5-5: A DWORD std::vector object\nYou can treat the member begin like a raw array, as it points to the first\nelement in the std::vector object. There is no array length member, though,\n108 Chapter 5\nso you must calculate the vector’s length based on begin and end, which is an\nempty object following the final object in the array. The length calculation\ncode looks like this:\nint length() {\nreturn ((DWORD)_vec->end - (DWORD)_vec->begin) / sizeof(DWORD);\n}\nThis function simply subtracts the address stored in begin from the\naddress stored in end to find the number of bytes between them. Then, to\ncalculate the number of objects, it divides the number of bytes by the num-\nber of bytes per object.\nUsing begin and this length() function, you can safely access elements in\n_vec. That code would look something like this:\nDWORD at(int index) {\nif (index >= _vec->length())\nthrow new std::out_of_range();\nreturn _vec->begin[index];\n}\nGiven an index, this code will fetch an item from the vector. But if\nthe index is greater than the vector’s length, a std::out_of_range exception\nwill be thrown. Adding values to a std::vector would be very expensive if\nthe class couldn’t reserve or reuse memory, though. To remedy this, the\nclass implements a function called reserve() that tells the vector how many\nobjects to leave room for.\nThe absolute size of a std::vector (its capacity) is determined through an\nadditional pointer, which is called tail in the vector class we’ve re-created.\nThe calculation for the capacity resembles the length calculation:\nint capacity() {\nreturn ((DWORD)_vec->tail - (DWORD)_vec->begin) / sizeof(DWORD);\n}\nTo find the capacity of a std::vector, instead of subtracting the begin\naddress from the end address, as you would to calculate length, this function\nsubtracts the begin address from tail. Additionally, you can use this calcula-\ntion a third time to determine the number of free elements in the vector by\nusing tail and end instead:\nint freeSpace() {\nreturn ((DWORD)_vec->tail - (DWORD)_vec->end) / sizeof(DWORD);\n}\nGiven proper memory reading and writing functions, you can use the\ndeclaration in Listing 5-4 and the calculations that follow to access and\nmanipulate vectors in the memory of a game. Chapter 6 discusses reading\nmemory in detail, but for now, let’s look at ways you can determine whether\ndata you’re interested in is stored in a std::vector.\nAdvanced Memory Forensics 109"
  },
  {
    "input": "The std::list Class",
    "output": "Determining Whether Data Is Stored in a std::vector\nOnce you’ve found an array of data in a game’s memory, there are a few\nsteps you can follow to determine whether it is stored in a std::vector. First,\nyou can be sure that the array is not stored in a std::vector if it has a static\naddress, because std::vector objects require pointer paths to access the\nunderlying array. If the array does require a pointer path, having a final off-\nset of 0 would indicate a std::vector. To confirm, you can change the final\noffset to 4 and check if it points to the final object in the array instead of\nthe first one. If so, you’re almost definitely looking at a vector, as you’ve just\nconfirmed the begin and end pointers.\nThe std::list Class\nSimilar to std::vector, std::list is a class that you can use to store a collec-\ntion of items in a linked list. The main differences are that std::list doesn’t\nrequire a contiguous storage space for elements, cannot directly access ele-\nments by their index, and can grow in size without affecting any previous\nelements. Due to the overhead required to access items, it is rare to see this\nclass used in games, but it shows up in some special cases, which I’ll discuss\nin this section.\nExamining the Structure of a std::list\nThe std::list class looks something like Listing 5-6.\ntemplate<typename T>\nclass listItem {\nlistItem<T>* next;\nlistItem<T>* prev;\nT value;\n};\ntemplate<typename T>\nclass list {\nlistItem<T>* root;\nint size;\n};\nListing 5-6: An abstracted std::list object\nThere are two classes here: listItem and list. To avoid extra abstraction\nwhile explaining how std::list works, I’ll describe this object as it would\nlook when the type is DWORD. Here’s how a game would declare a std::list of\nthe DWORD type:\nstd::list<DWORD> _lst;\nGiven that declaration, the std::list is structured like the code in\nListing 5-7.\n110 Chapter 5\nclass listItem {\nlistItem* next;\nlistItem* prev;\nDWORD value;\n};\nclass list {\nlistItem* root;\nint size;\n};\n// point to a list\nlist* _lst = (list*)listAddress;\nListing 5-7: A DWORD std::list object\nThe class list represents the list header, while listItem represents a\nvalue stored in the list. Instead of being stored contiguously, the items\nin the list are stored independently. Each item contains a pointer to the\nitem that comes after it (next) and the\none that comes before it (prev), and\nthese pointers are used to locate\nRoot\nitems in the list. The root item acts\nas a marker for the end of the list; the\nnext pointer of the last item points to\nroot, as does the prev pointer of the\nItem Item Item\nfirst item. The root item’s next and\nprev pointers also point to the first\nitem and the last item, respectively. Figure 5-5: A std::list flowchart\nFigure 5-5 shows what this looks like.\nGiven this structure, you can use the following code to iterate over a\nstd::list object:\n// iterate forward\nlistItem* it = _lst->root->next;\nfor (; it != _lst->root; it = it->next)\nprintf(\"Value is %d\\n\", it->value);\n// iterate backward\nlistItem* it = _lst->root->prev;\nfor (; it != _lst->root; it = it->prev)\nprintf(\"Value is %d\\n\", it->value);\nThe first loop starts at the first item (root->next) and iterates forward\n(it = it->next) until it hits the end marker (root). The second loop starts\nat the last item (root->pres) and iterates backward (it = it->prev) until it\nhits the end marker (root). This iteration relies on next and prev because\nunlike objects in an array, objects in a std::list are not contiguous. Since\nthe memory of each object in a std::list is not contiguous, there’s no\nquick-and-dirty way to calculate the size. Instead, the class just defines a\nAdvanced Memory Forensics 111\nsize member. Additionally, the concept of reserving space for new objects\nis irrelevant for lists, so there’s no variable or calculation to determine a\nlist’s capacity.\nDetermining Whether Game Data Is Stored in a std::list\nIdentifying objects stored in the std::list class can be tricky, but there are\na few hints you can watch for. First, items in a std::list cannot have static\naddresses, so if the data you seek has a static address, then you’re in the clear.\nItems that are obviously part of a collection may, however, be part of a\nstd::list if they’re not contiguous in memory.\nAlso consider that objects in a std::list can have infinitely long pointer\nchains (think it->prev->next->prev->next->prev . . .), and pointer scanning\nfor them in Cheat Engine will show many more results when No Looping\nPointers is turned off.\nYou can also use a script to detect when a value is stored in a linked list.\nListing 5-8 shows a Cheat Engine script that does just this.\nfunction _verifyLinkedList(address)\nlocal nextItem = readInteger(address) or 0\nlocal previousItem = readInteger(address + 4) or 0\nlocal nextItemBack = readInteger(nextItem + 4)\nlocal previousItemForward = readInteger(previousItem)\nreturn (address == nextItemBack\nand address == previousItemForward)\nend\nfunction isValueInLinkedList(valueAddress)\nfor address = valueAddress - 8, valueAddress - 48, -4 do\nif (_verifyLinkedList(address)) then\nreturn address\nend\nend\nreturn 0\nend\nlocal node = isValueInLinkedList(addressOfSomeValue)\nif (node > 0) then\nprint(string.format(\"Value in LL, top of node at 0x0%x\", node))\nend\nListing 5-8: Determining whether data is in a std::list using a Cheat Engine Lua script\nThere’s quite a bit of code here, but what it’s doing is actually pretty\nsimple. The isValueInLinkedList() function takes an address of some value\nand then looks backward for up to 40 bytes (10 integer objects, in case the\n112 Chapter 5\nvalue is in some larger structure), starting 8 bytes above the address (two\npointers must be present, and they are 4 bytes each). Because of memory\nalignment, this loop iterates in steps of 4 bytes.\nOn each iteration, the address is passed to the _verifyLinkedList() func-\ntion, which is where the magic happens. If we look at it in terms of linked\nlist structure as defined in this chapter, the function simply does this:\nreturn (node->next->prev == node && node->prev->next == node)\nThat is, the function basically assumes the memory address it’s given\npoints to a linked list, and it makes sure the supposed node has valid next\nand previous nodes. If the nodes are valid, the assumption was correct and\nthe address is that of a linked list node. If the nodes don’t exist or don’t\npoint to the right locations, the assumption was wrong and the address is\nnot part of a linked list.\nKeep in mind that this script won’t give you the address of the list’s root\nnode but simply the address of the node containing the value you’ve given\nit. To properly traverse a linked list, you’ll need to scan for a valid pointer\npath to the root node, so you’ll need its address.\nFinding that address can require some searching of memory dumps,\na lot of trial and error, and a ton of head scratching, but it’s definitely pos-\nsible. The best way to start is to follow the chain of prev and next nodes until\nyou find a node with data that is either blank, nonsensical, or filled with the\nvalue 0xBAADF00D (some, but not all, standard library implementations use\nthis value to mark root nodes).\nThis investigation can also be made easier if you know exactly how\nmany nodes are in the list. Even without the list header, you can determine\nthe amount of nodes by continuously following the next pointer until you\nend up back at your starting node, as in Listing 5-9.\nfunction countLinkedListNodes(nodeAddress)\nlocal counter = 0\nlocal next = readInteger(nodeAddress)\nwhile (next ~= nodeAddress) do\ncounter = counter + 1\nnext = readInteger(next)\nend\nreturn counter\nend\nListing 5-9: Determining the size of an arbitrary std::list using a Cheat Engine Lua script\nFirst, this function creates a counter to store the number of nodes and\na variable to store the next node’s address. The while loop then iterates over\nthe nodes until it ends up back at the initial node. Finally, it returns the\ncounter variable, which was incremented on every iteration of the loop.\nAdvanced Memory Forensics 113"
  },
  {
    "input": "The std::map Class",
    "output": "fIND tHE rOOt NODE wItH A sC rIPt\nIt’s actually possible to write a script that can find the root node, but I’ll leave\nit as an optional exercise for you. How does it work? Well, the root node must\nbe in the chain of nodes, the list header points to the root, and the size of the\nlist will immediately follow the root in memory. Given this information, you can\nwrite a script that will search for any memory containing a pointer to one of the\nlist’s nodes, followed by the size of the list. More often than not, this piece of\nmemory is the list header, and the node it points to is the root node.\nThe std::map Class\nLike a std::list, a std::map uses links between elements to form its structure.\nUnique to std::map, however, is the fact that each element stores two pieces\nof data (a key and a value), and sorting the elements is an inherent prop-\nerty of the underlying data structure: a red-black tree. The following code\nshows the structures that compose a std::map.\ntemplate<typename keyT, typename valT>\nstruct mapItem {\nmapItem<keyT, valT>* left;\nmapItem<keyT, valT>* parent;\nmapItem<keyT, valT>* right;\nkeyT key;\nvalT value;\n};\ntemplate<typename keyT, typename valT>\nstruct map {\nDWORD irrelevant;\nmapItem<keyT, valT>* rootNode;\nint size;\n}\nA red-black tree is a self-balancing binary search tree, so a std::map is,\ntoo. In the STL’s std::map implementation, each element (or node) in the\ntree has three pointers: left, parent, and right. In addition to the point-\ners, each node also has a key and a value. The nodes are arranged in the\ntree based on a comparison between their keys. The left pointer of a node\npoints to a node with a smaller key, and the right pointer points to a node\nwith a larger key. The parent points to the upper node. The first node in the\ntree is called the rootNode, and nodes that lack children point to it.\nVisualizing a std::map\nFigure 5-6 shows a std::map that has the keys 1, 6, 8, 11, 13, 15, 17, 22, 25,\nand 27.\n114 Chapter 5\nRoot\n13\n8 17\n1 11 15 25\nRoot Root Root Root Root\n6 22 27\nRoot Root Root Root Root Root\nFigure 5-6: A red-black tree\nThe top node (holding the value 13) is pointed to by the parent of\nrootNode. Everything to the left of it has a smaller key, and everything to the\nright has a greater key. This is true for any node in the tree, and this truth\nenables efficient key-based search. While not represented in the image, the\nleft pointer of the root node will point to the leftmost node (1), and the\nright pointer will point to the rightmost node (27).\naccessing Data in a std::map\nOnce again, I’ll use a static std::map definition when discussing how to extract\ndata from the structure. Since the template takes two types, I’ll also use\nsome pseudotypes to keep things obvious. Here’s the declaration for the\nstd::map object I’ll reference for the rest of the section:\ntypedef int keyInt;\ntypedef int valInt;\nstd::map<keyInt, valInt> myMap;\nWith this declaration, the structure of myMap becomes:\nstruct mapItem {\nmapItem* left;\nmapItem* parent;\nmapItem* right;\nkeyInt key;\nvalInt value;\n};\nstruct map {\nDWORD irrelevant;\nmapItem* rootNode;\nAdvanced Memory Forensics 115\nint size;\n}\nmap* _map = (map*)mapAddress;\nThere are some important algorithms that you might need to access the\ndata in a std::map structure in a game. First, blindly iterating over every item\nin the map can be useful if you just want to see all of the data. To do this\nsequentially, you could write an iteration function like this:\nvoid iterateMap(mapItem* node) {\nif (node == _map->rootNode) return;\niterateMap(node->left);\nprintNode(node);\niterateMap(node->right);\n}\nA function to iterate over an entire map would first read the current\nnode and check whether it’s the rootNode. If not, it would recurse left, print\nthe node, and recurse right.\nTo call this function, you’d have to pass a pointer to the rootNode as\nfollows:\niterateMap(_map->rootNode->parent);\nThe purpose of a std::map, however, is to store keyed data in a quickly\nsearchable way. When you need to locate a node given a specific key, mim-\nicking the internal search algorithm is preferable to scanning the entire\ntree. The code for searching a std::map looks something like this:\nmapItem* findItem(keyInt key, mapItem* node) {\nif (node != _map->rootNode) {\nif (key == node->key)\nreturn node;\nelse if (key < node->key)\nreturn findItem(key, node->left);\nelse\nreturn findItem(key, node->right);\n} else return NULL;\n}\nStarting at the top of the tree, you simply recurse left if the current key\nis greater than the search key and recurse right if it is smaller. If the keys are\nequal, you return the current node. If you reach the bottom of the tree and\ndon’t find the key, you return NULL because the key isn’t stored in the map.\nHere’s one way you might use this findItem() function:\nmapItem* ret = findItem(someKey, _map->rootNode->parent);\nif (ret)\nprintNode(ret);\n116 Chapter 5\nAs long as findItem() doesn’t return NULL, this code should print a node\nfrom _map.\nDetermining Whether Game Data Is Stored in a std::map\nTypically, I don’t even consider whether data could be in a std::map until I\nknow the collection is not an array, a std::vector, or a std::list. If you rule\nout all three options, then as with a std::list, you can look at the three inte-\nger values before the value and check if they point to memory that could\npossibly be other map nodes.\nOnce again, this can be done with a Lua script in Cheat Engine. The\nscript is similar to the one I showed for lists, looping backward over memory\nto see if a valid node structure is found before the value. Unlike the list code,\nthough, the function that verifies a node is much trickier. Take a look at the\ncode in Listing 5-10, and then I’ll dissect it.\nfunction _verifyMap(address)\nlocal parentItem = readInteger(address + 4) or 0\nlocal parentLeftItem = readInteger(parentItem + 0) or 0\nlocal parentRightItem = readInteger(parentItem + 8) or 0\nu local validParent =\nparentLeftItem == address\nor parentRightItem == address\nif (not validParent) then return false end\nlocal tries = 0\nlocal lastChecked = parentItem\nlocal parentsParent = readInteger(parentItem + 4) or 0\nv while (readInteger(parentsParent + 4) ~= lastChecked and tries < 200) do\ntries = tries + 1\nlastChecked = parentsParent\nparentsParent = readInteger(parentsParent + 4) or 0\nend\nreturn readInteger(parentsParent + 4) == lastChecked\nend\nListing 5-10: Determining whether data is in a std::map using a Cheat Engine Lua script\nGiven address, this function checks if address is in a map structure. It\nfirst checks if there’s a valid parent node and, if so, checks whether that\nparent node points to address on either side u. But this check isn’t enough.\nIf the check passes, the function will also climb up the line of parent nodes\nuntil it reaches a node that is the parent of its own parent v, trying 200\ntimes before calling it quits. If the climb succeeds in finding a node that\nis its own grandparent, then address definitely points to a map node. This\nworks because, as I outlined in “Visualizing a std::map” on page 114, at the\ntop of every map is a root node whose parent points to the first node in the\ntree, and that node’s parent points back to the root node.\nAdvanced Memory Forensics 117"
  },
  {
    "input": "Closing Thoughts",
    "output": "NO tE I bet you didn’t expect to run into the grandfather paradox from time travel when\nreading a game-hacking book!\nUsing this function and a slightly modified backtracking loop from\nListing 5-8, you can automatically detect when a value is inside a map:\nfunction isValueInMap(valueAddress)\nfor address = valueAddress - 12, valueAddress - 52, -4 do\nif (_verifyMap(address)) then\nreturn address\nend\nend\nreturn 0\nend\nlocal node = isValueInMap(addressOfSomeValue)\nif (node > 0) then\nprint(string.format(\"Value in map, top of node at 0x0%x\", node))\nend\nAside from function names, the only change in this code from\nListing 5-8 is that it starts looping 12 bytes before the value instead of 8,\nbecause a map has three pointers instead of the two in a list. One good\nconsequence of a map’s structure is that it’s easy to obtain the root node.\nWhen the _verifyMap function returns true, the parentsParent variable will\ncontain the address of the root node. With some simple modifications,\nyou could return this to the main call and have everything you need to\nread the data from a std::map in one place.\nclosing Thoughts\nMemory forensics is the most time-consuming part of hacking games, and\nits obstacles can appear in all shapes and sizes. Using purpose, patterns,\nand a deep understanding of complex data structures, however, you can\nquickly overcome these obstacles. If you’re still a bit confused about what’s\ngoing on, make sure to download and play with the example code provided,\nas it contains proofs of concept for all of the algorithms covered in this\nchapter.\nIn Chapter 6, we’ll start diving in to the code you need to read from\nand write to a game’s memory from your own programs so you can take\nthe first step in putting to work all of this information about memory struc-\ntures, addresses, and data.\n118 Chapter 5"
  },
  {
    "input": "Chapter 6: Reading from and Writing to Game Memory",
    "output": "6\nrE ADING fr OM AND\nwrItING t O G AME M EMOry\nEarlier chapters discussed how memory\nis structured as well as how to scan and\nmodify memory using Cheat Engine and\nOllyDbg. Working with memory will be essen-\ntial when you begin to write bots, and your code will\nneed to know how to do so.\nThis chapter digs into the code-level details of memory manipulation.\nFirst, you’ll learn how to use code to locate and obtain handles to game\nprocesses. Next, you’ll learn how to use those handles to read from and\nwrite to memory both from remote processes and from injected code. To\nwrap up, you’ll learn bypasses for a certain memory protection technique,\ncomplete with a small example of code injection. You’ll find the example\ncode for this chapter in the GameHackingExamples/Chapter6_AccessingMemory\ndirectory in this book’s source files.\nNO tE When I talk about API functions in this chapter (and in later ones), I’m referring to\nthe Windows API unless otherwise specified. If I don’t mention a header file for the\nlibrary, you can assume it is Windows.h."
  },
  {
    "input": "Obtaining the Game’s Process Identifier",
    "output": "Obtaining the Game’s Process identifier\nTo read from or write to a game’s memory, you need its process identifier (PID),\na number that uniquely identifies an active process. If the game has a visible\nwindow, you can obtain the PID of the process that created that window by\ncalling GetWindowThreadProcessId(). This function takes the window’s handle\nas the first parameter and outputs the PID to the second parameter. You\ncan find the window’s handle by passing its title (the text on the taskbar) as\nthe second parameter to FindWindow(), as shown in Listing 6-1.\nHWND myWindow =\nFindWindow(NULL, \"Title of the game window here\");\nDWORD PID;\nGetWindowThreadProcessId(myWindow, &PID);\nListing 6-1: Fetching a window’s handle to obtain a PID\nWith the window handle secured, all you have to do is create a place to\nstore the PID and call GetWindowThreadProcessId(), as shown in this example.\nIf a game isn’t windowed or the window name isn’t predictable, you\ncan find the game’s PID by enumerating all processes and looking for\nthe name of the game binary. Listing 6-2 does this using the API func-\ntions CreateToolhelp32Snapshot(), Process32First(), and Process32Next() from\ntlhelp32.h.\n#include <tlhelp32.h>\nPROCESSENTRY32 entry;\nentry.dwSize = sizeof(PROCESSENTRY32);\nHANDLE snapshot =\nCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);\nif (Process32First(snapshot, &entry) == TRUE) {\nwhile (Process32Next(snapshot, &entry) == TRUE) {\nwstring binPath = entry.szExeFile;\nif (binPath.find(L\"game.exe\") != wstring::npos) {\nprintf(\"game pid is %d\\n\", entry.th32ProcessID);\nbreak;\n}\n}\n}\nCloseHandle(snapshot);\nListing 6-2: Fetching a game’s PID without the window name\nListing 6-2 might look a bit more complex than Listing 6-1, but\nunderneath all that code, the function is actually like a canonical for\n(iterator; comparator; increment) loop. The CreateToolhelp32Snapshot() func-\ntion obtains a list of processes named snapshot, and entry is an iterator over\nthat list. The value returned by Process32First() initializes the iterator,\nwhile Process32Next() increments it. Finally, the Boolean return value of\n120 Chapter 6"
  },
  {
    "input": "Working with OpenProcess() ",
    "output": "Process32Next() is the comparator. This code just iterates over a snapshot of\nevery running process, looks for one whose binary path contains the text\ngame.exe, and prints its PID.\nObtaining Process Handles\nOnce you know a game’s PID, you can obtain a handle to the process itself\nusing an API function called OpenProcess(). This function allows you to fetch\nhandles with the access levels you need to read from and write to memory.\nThis is crucial to game hacking, as any function that operates on a process\nwill require a handle with proper access.\nLet’s take a look at the prototype of OpenProcess():\nHANDLE OpenProcess(DWORD DesiredAccess, BOOL InheritHandle, DWORD ProcessId);\nThe first parameter, DesiredAccess, expects one or a mixture of process\naccess flags to set on the handle that OpenProcess() returns. There are many\nflags you can use, but these are the most common in game hacking:\nPROCESS_VM_OPERATION The returned handle can be used with\nVirtualAllocEx(), VirtualFreeEx(), and VirtualProtectEx() to allocate,\nfree, and protect chunks of memory, respectively.\nPROCESS_VM_READ The returned handle can be used with\nReadProcessMemory().\nPROCESS_VM_WRITE The returned handle can be used with\nWriteProcessMemory(), but it must also have PROCESS_VM_OPERATION rights.\nYou can set both flags by passing PROCESS_VM_OPERATION | PROCESS_VM_WRITE\nas the DesiredAccess parameter.\nPROCESS_CREATE_THREAD The returned handle can be used with\nCreateRemoteThread().\nPROCESS_ALL_ACCESS The returned handle can be used to do anything.\nAvoid using this flag, as it can only be used by processes with debug\nprivileges enabled and has compatibility issues with older versions of\nWindows.\nWhen fetching a handle to a game, you can typically just set the\nOpenProcess() function’s second parameter, InheritHandle, to false. The\nthird parameter, ProcessId, expects the PID of the process to be opened.\nWorking with OpenProcess()\nNow let’s walk through an example call to OpenProcess() that uses a handle\nwith access permissions allowing it to read from and write to memory:\nDWORD PID = getGamePID();\nHANDLE process = OpenProcess(\nPROCESS_VM_OPERATION |\nPROCESS_VM_READ |\nPROCESS_VM_WRITE,\nReading from and Writing to Game Memory 121"
  },
  {
    "input": "Working with ReadProcessMemory() and WriteProcessMemory() ",
    "output": "FALSE,\nPID\n);\nu if (process == INVALID_HANDLE_VALUE) {\nprintf(\"Failed to open PID %d, error code %d\",\nPID, GetLastError());\n}\nFirst, the call to getGamePID() fetches the PID you’re looking for. (The\nfunction is something you’ll have to write yourself, though it could just be\none of the snippets I showed in Listings 6-1 and 6-2, fleshed out into a full-\nblown function.) Then, the code calls OpenProcess() with three flags: the\nPROCESS_VM_OPERATION flag gives this handle memory access permissions, and\nthe other two combined give it read and write permissions. This example\nalso contains an error-handling case u, but as long as you have the correct\nPID, you have valid access flags, and your code is running under the same\nor higher permissions as the game (for example, if you start your bot using\nRun As Admin), the call should never fail.\nOnce you’re done using a handle, clean it up using CloseHandle() as\nfollows:\nCloseHandle(process);\nYou can reuse handles as much as you want, so you can leave one open\nuntil you’re completely done using it or until your bot is exited.\nNow that you’ve seen how to open a process handle in preparation for\nmanipulating game memory, let’s dig into how to actually access the mem-\nory of that process.\naccessing memory\nThe Windows API exposes two functions that are crucial to memory access:\nReadProcessMemory() and WriteProcessMemory(). You can use these functions to\nexternally manipulate a game’s memory.\nWorking with ReadProcessMemory() and WriteProcessMemory()\nThe prototypes for these two functions (shown in Listing 6-3) resemble\neach other closely, and you’ll follow almost exactly the same steps to\nuse them.\nBOOL ReadProcessMemory(\nHANDLE Process, LPVOID Address,\nLPVOID Buffer, DWORD Size,\nDWORD *NumberOfBytesRead\n);\nBOOL WriteProcessMemory(\nHANDLE Process, LPVOID Address,\nLPCVOID Buffer, DWORD Size,\n122 Chapter 6"
  },
  {
    "input": "Writing Templated Memory Access Functions",
    "output": "DWORD *NumberOfBytesWritten\n);\nListing 6-3: ReadProcessMemory() and WriteProcessMemory() prototypes\nBoth functions expect Process to be a process handle and Address to be\nthe target memory address. When the function is reading from memory,\nBuffer is expected to point to an object that will hold the read data. When\nthe function is writing to memory, Buffer is expected to point to the data\nto write. In both cases, Size defines the size of Buffer, in bytes. The final\nparameter to both functions is used to optionally return the number of\nbytes that were accessed; you can safely set it to NULL. Unless the function\nfails, the value returned in the final parameter should be equal to Size.\nAccessing a Value in Memory with ReadProcessMemory() and\nWriteProcessMemory()\nThe code in Listing 6-4 shows how you might use these functions to access a\nvalue in memory.\nDWORD val;\nReadProcessMemory(proc, adr, &val, sizeof(DWORD), 0);\nprintf(\"Current mem value is %d\\n\", val);\nval++;\nWriteProcessMemory(proc, adr, &val, sizeof(DWORD), 0);\nReadProcessMemory(proc, adr, &val, sizeof(DWORD), 0);\nprintf(\"New mem value is confirmed as %d\\n\", val);\nListing 6-4: Reading from and writing to process memory using the Windows API\nBefore code like this appears in a program, you need to find the\nPID (proc) as described in “Obtaining the Game’s Process Identifier” on\npage 120, as well as the memory address (adr) you want to read from or\nwrite to. With those values in place, the ReadProcessMemory() function stores\na fetched value from memory in val. Then, the code increments val and\nreplaces the original value by calling WriteProcessMemory(). After the write\ntakes place, ReadProcessMemory() is called on the same address to confirm the\nnew memory value. Notice that val isn’t actually a buffer. Passing &val as the\nBuffer parameter works because it can be a pointer to any static memory\nstructure, as long as Size matches.\nWriting Templated Memory Access Functions\nOf course, the example in Listing 6-4 assumes you already know what type\nof memory you’re dealing with, and it hardcodes the type as DWORD. To be a\nversatile game hacker, it’s better to have some generic code in your toolbox\nto avoid duplicating code for different types. Generic memory reading and\nwriting functions that support different types might look like Listing 6-5.\nReading from and Writing to Game Memory 123"
  },
  {
    "input": "Memory Protection",
    "output": "template<typename T>\nT readMemory(HANDLE proc, LPVOID adr) {\nT val;\nReadProcessMemory(proc, adr, &val, sizeof(T), NULL);\nreturn val;\n}\ntemplate<typename T>\nvoid writeMemory(HANDLE proc, LPVOID adr, T val) {\nWriteProcessMemory(proc, adr, &val, sizeof(T), NULL);\n}\nListing 6-5: Generic memory functions\nThese functions use C++ templates to accept arbitrary types as argu-\nments. They allow you to access memory with whatever types you like in a\nvery clean way. For example, given these readMemory() and writeMemory() tem-\nplates I just showed, you could make the calls in Listing 6-6.\nDWORD value = readMemory<DWORD>(proc, adr); // read\nwriteMemory<DWORD>(proc, adr, value++); // increment and write\nListing 6-6: Calling templated memory access functions\nCompare this to the calls to WriteProcessMemory() and ReadProcessMemory()\nin Listing 6-4. This code still reads a value, increments it, and writes the\nnew value to memory. But since the templated functions let you specify the\ntype when you call them, you don’t need a new readMemory() and writeMemory()\nfunction for every data type you might need to work with. That’s much\ncleaner, since you’ll often want to work with all kinds of data.\nmemory Protection\nWhen memory is allocated by a game (or any program), it is placed in\na page. In x86 Windows, pages are chunks of 4,096 bytes that store data.\nBecause all memory must be within a page, the minimal allocation unit\nis 4,096 bytes. The operating system can place memory chunks smaller\nthan 4,096 bytes as a subset of an existing page that has enough uncommit-\nted space, in a newly allocated page, or across two contiguous pages that\nhave the same attributes.\nMemory chunks 4,096 bytes or larger span n pages, where n is\nmemory size\n.\n4,096\nThe operating system typically looks for room in existing pages when\nallocating memory, but it allocates new pages on demand if necessary.\nNO tE It’s also possible for large chunks to span n + 1 pages, as there’s no guarantee that a\nchunk begins at the start of a page.\n124 Chapter 6"
  },
  {
    "input": "Differentiating x86 Windows Memory Protection Attributes",
    "output": "The important thing to understand about memory pages is that each\npage has a set of specific attributes. Most of these attributes are transparent\nin user mode, but there’s one you should be extra conscious of when work-\ning with memory: protection.\nDifferentiating x86 Windows Memory Protection Attributes\nThe memory-reading techniques you’ve learned so far are very basic. They\nassume that the memory you’re accessing is protected with the PAGE_READWRITE\nattribute. While this assumption is correct for variable data, other types of\ndata exist on pages with different types of protection. Table 6-1 describes\nthe different types of memory protection in x86 Windows.\nTable 6-1: Memory Protection Types\nProtection type Value Read Write Execute Special\npermission? permission? permission? permissions?\nPAGE_NOACCESS 0x01 No No No\nPAGE_READONLY 0x02 Yes No No\nPAGE_READWRITE 0x04 Yes No No\nPAGE_WRITECOPY 0x08 Yes Yes No Yes, copy on write\nPAGE_EXECUTE 0x10 No No Yes\nPAGE_EXECUTE_READ 0x20 Yes No Yes\nPAGE_EXECUTE_READWRITE 0x40 Yes Yes Yes\nPAGE_EXECUTE_WRITECOPY 0x80 Yes Yes Yes Yes, copy on write\nPAGE_GUARD 0x100 No No No Yes, guard page\nIf a protection type in Table 6-1 has a Yes in any permission column, it\nmeans the action in question can be performed on that page of memory.\nFor example, if a page is PAGE_READONLY, then a program can read the mem-\nory on that page, but the program cannot write to that memory.\nConstant strings, for example, are usually stored with PAGE_READONLY pro-\ntection. Other constant data, such as virtual function tables and a module’s\nentire Portable Executable (PE) header (which contains information about a\nprogram, such as the kind of application it is, library functions it uses, its\nsize, and so on), are also stored on read-only pages. Assembly code, on the\nother hand, is stored on pages protected with PAGE_EXECUTE_READ.\nMost protection types involve only some combination of read, write,\nand execute protection. For now, you can safely ignore special protection\ntypes; I cover them in “Special Protection Types” on page 126 if you’re\ncurious, but only very advanced hacks will ever require knowledge of them.\nThe basic protection types, though, will be prevalent in your game-hacking\nadventures.\nReading from and Writing to Game Memory 125"
  },
  {
    "input": "Changing Memory Protection",
    "output": "sPECIAl PrOtECtION tyPEs\nTwo protection types in Table 6-1 include copy-on-write protection. When\nmultiple processes have pages of memory that are identical (such as pages\nwith mapped system DLLs), copy-on-write protection is used to conserve memory.\nThe actual data is stored in only one physical place, and the operating system\nvirtually maps all memory pages containing that data to the physical location. If\na process sharing the memory makes a change to it, a copy of the data will be\nmade in physical memory, the change will be applied, and the memory page(s)\nfor that process will be remapped to the new physical memory. When a copy\non write happens, the protection for all affected pages changes accordingly;\nPAGE_WRITECOPY will become PAGE_READWRITE, and PAGE_EXECUTE_WRITECOPY will\nbecome PAGE_EXECUTE_READWRITE. I’ve found no game hacking–specific uses for\ncopy-on-write pages, but it’s useful to understand them.\nPages can also be created with guard protection. Guarded pages must\nhave a secondary protection, defined like PAGE_GUARD | PAGE_READONLY. When\nthe program tries to access a guarded page, the operating system will throw\na STATUS_GUARD_PAGE_VIOLATION exception. Once the exception is handled, the\nguard protection is removed from the page, leaving only the secondary protec-\ntion. One way in which the operating system uses this type of protection is to\ndynamically expand the call stack by placing a guarded page at the top and\nallocating more memory when that guarded page is hit. Some memory analy-\nsis tools place guarded pages after heap memory to detect heap corruption\nbugs. In the context of game hacking, a guarded page can be used as a trip\nwire that tells you when a game might be attempting to detect your code within\nits memory.\nChanging Memory Protection\nWhen you want to hack a game, you’ll sometimes need to access memory in\na way that is forbidden by the memory page’s protection, making it impor-\ntant to be able to change memory protection at will. Luckily, the Windows\nAPI provides the VirtualProtectEx() function for this purpose. This is the\nfunction’s prototype:\nBOOL VirtualProtectEx(\nHANDLE Process, LPVOID Address,\nDWORD Size, DWORD NewProtect,\nPDWORD OldProtect\n);\nThe parameters Process, Address, and Size take the same input as they\ndo in the ReadProcessMemory() and WriteProcessMemory() functions. NewProtect\nshould specify the new protection flags for the memory, and OldProtect can\noptionally point to a DWORD where the old protection flags will be stored.\n126 Chapter 6\nThe most granular scale for memory protection is per page, which means\nVirtualProtectEx() will set the new protection to every page that is on or\nbetween Address and Address + Size - 1.\nNO tE The VirtualProtectEx() function has a sister called VirtualProtect(). They work\nthe same way, but VirtualProtect() operates only on the process calling it and, thus,\ndoes not have a process handle parameter.\nWhen you’re writing your own code to change memory protections, I\nsuggest making it flexible by creating a template. A generic wrapped func-\ntion for VirtualProtectEx() should look something like Listing 6-7.\ntemplate<typename T>\nDWORD protectMemory(HANDLE proc, LPVOID adr, DWORD prot) {\nDWORD oldProt;\nVirtualProtectEx(proc, adr, sizeof(T), prot, &oldProt);\nreturn oldProt;\n}\nListing 6-7: A generic function to change memory protection\nWith this template in place, if you wanted to, say, write a DWORD to a mem-\nory page without write permission, you might do something like this:\nprotectMemory<DWORD>(process, address, PAGE_READWRITE)\nwriteMemory<DWORD>(process, address, newValue)\nFirst, this sets the protection on the memory to change to PAGE_READWRITE.\nWith write permission granted, the door is open to call writeMemory() and\nchange the data at address.\nWhen you’re changing memory protection, it’s best practice to let the\nchange persist only as long as needed and restore the original protection\nas soon as possible. This is less efficient, but it ensures that a game doesn’t\ndetect your bot (for example, by noticing that some of its assembly code\npages have become writable).\nA typical write operation on read-only memory should look like this:\nDWORD oldProt =\nprotectMemory<DWORD>(process, address, PAGE_READWRITE);\nwriteMemory<DWORD>(process, address, newValue);\nprotectMemory<DWORD>(process, address, oldProt);\nThis code calls the protectMemory() function from Listing 6-7 to change\nthe protection to PAGE_READWRITE. It then writes newValue to the memory before\nchanging the protection back to oldProt, which was set to the page’s original\nprotection by the initial call to protectMemory(). The writeMemory() function\nused here is the same one defined in Listing 6-5.\nA final important point is that when you’re manipulating a game’s\nmemory, it’s entirely possible that the game will access the memory at\nthe same time as you. If the new protection that you set is not compatible\nReading from and Writing to Game Memory 127"
  },
  {
    "input": "Bypassing ASLR in Production",
    "output": "with the original protection, the game process will get an ACCESS_VIOLATION\nexception and crash. For instance, if you change memory protection from\nPAGE_EXECUTE to PAGE_READWRITE, the game might try to execute the code on\nthe page(s) when the memory is not marked as executable. In this case,\nyou’d want to instead set the memory protection to PAGE_EXECUTE_READWRITE to\nensure that you can operate on the memory while still allowing the game to\nexecute it.\naddress Space Layout Randomization\nSo far, I’ve described memory addresses as static integers that change only\nas the binary changes. This model is correct on Windows XP and earlier.\nOn later Windows systems, however, memory addresses are only static rela-\ntive to the base address of the game binary, because these systems enable\na feature called address space layout randomization (ASLR) for supported bina-\nries. When a binary is compiled with ASLR support (enabled by default on\nMSVC++ 2010 and many other compilers), its base address can be different\nevery time it is run. Conversely, non-ASLR binaries will always have a base\naddress of 0x400000.\nNO tE Since ASLR doesn’t work on XP, I’ll call 0x400000 the XP-base.\nDisabling ASLR to Simplify Bot Development\nTo keep development simple, you can disable ASLR and use addresses with\nthe transparent XP-base. To do so, enter a single command in the Visual\nStudio Command Prompt:\n> editbin /DYNAMICBASE:NO \"C:\\path\\to\\game.exe\"\nTo re-enable it, enter:\n> editbin /DYNAMICBASE \"C:\\path\\to\\game.exe\"\nBypassing ASLR in Production\nDisabling ASLR is suitable for bot development, but it is a no-no for produc-\ntion; end users cannot be expected to turn off ALSR. Instead, you can write\na function to dynamically rebase addresses at runtime. If you use addresses\nwith the XP-base, the code to do a rebase would look like this:\nDWORD rebase(DWORD address, DWORD newBase) {\nDWORD diff = address - 0x400000;\nreturn diff + newBase;\n}\n128 Chapter 6\nWhen you know the base address of the game (newBase), this function\nallows you to essentially ignore ASLR by rebasing address.\nTo find newBase, however, you need to use the GetModuleHandle() function.\nWhen the parameter to GetModuleHandle() is NULL, it always returns a handle\nto the main binary in a process. The function’s returned type is HMODULE, but\nthe value is actually just the address where the binary is mapped. This is the\nbase address, so you can directly cast it to a DWORD to get newBase. Since you’re\nlooking for the base address in another process, though, you need a way to\nexecute the function in the context of that process.\nTo do this, call GetModuleHandle() using the CreateRemoteThread() API func-\ntion, which can be used to spawn threads and execute code in a remote pro-\ncess. It has the prototype shown in Listing 6-8.\nHANDLE CreateRemoteThread(\nHANDLE Process,\nLPSECURITY_ATTRIBUTES ThreadAttributes,\nDWORD StackSize,\nLPTHREAD_START_ROUTINE StartAddress,\nLPVOID Param,\nDWORD CreationFlags,\nLPDWORD ThreadId\n);\nListing 6-8: A function that spawns a thread\nThe spawned thread will start execution on StartAddress, treating it\nas a single-parameter function with Param as input and setting the value\nreturned as the thread exit code. This is ideal, as the thread can be started\nwith StartAddress pointing to the address of GetModuleHandle() and Param set to\nNULL. You can then use the API function WaitForSingleObject() to wait until\nthe thread is done executing and get the returned base address using the\nAPI function GetExitCodeThread().\nOnce all of these things are tied together, the code to get newBase from\nan external bot should look like Listing 6-9.\nDWORD newBase;\n// get the address of kernel32.dll\nHMODULE k32 = GetModuleHandle(\"kernel32.dll\");\n// get the address of GetModuleHandle()\nLPVOID funcAdr = GetProcAddress(k32, \"GetModuleHandleA\");\nif (!funcAdr)\nfuncAdr = GetProcAddress(k32, \"GetModuleHandleW\");\n// create the thread\nHANDLE thread =\nCreateRemoteThread(process, NULL, NULL,\n(LPTHREAD_START_ROUTINE)funcAdr,\nNULL, NULL, NULL);\nReading from and Writing to Game Memory 129"
  },
  {
    "input": "Closing Thoughts",
    "output": "// let the thread finish\nWaitForSingleObject(thread, INFINITE);\n// get the exit code\nGetExitCodeThread(thread, &newBase);\n// clean up the thread handle\nCloseHandle(thread);\nListing 6-9: Finding the base address of a game with API functions\nThe GetModuleHandle() function is part of kernel32.dll, which has the\nsame base address in every process, so first this code gets the address for\nkernel32.dll. Since the base address of kernel32.dll is the same in every pro-\ncess, the address of GetModuleHandle() will be the same in the game as it is in\nthe external bot. Given the base address of kernel32.dll, this code finds the\naddress of GetModuleHandle() easily with the API function GetProcAddress().\nFrom there, it calls the CreateRemoteThread() function from Listing 6-8, lets\nthe thread do its job, and fetches the exit code to obtain newBase.\nclosing Thoughts\nNow that you’ve seen how to manipulate memory from your own code, I’ll\nshow you how to apply the skills from Parts I and II to games. These skills\nare paramount to the concepts you’ll explore in the coming chapters, so\nmake sure you have a firm grasp on what’s happening. If you’re having\ntrouble, play with the example code as you review concepts, as it provides a\nsafe sandbox for testing and tweaking how the methods in this and earlier\nchapters behave.\nThe way Listing 6-9 tricks the game into executing GetModuleHandle() is a\nform of code injection. But that’s just a glimpse into what injection can do.\nIf you’re excited to learn more about it, dive into Chapter 7, which explores\nthis topic in detail.\n130 Chapter 6"
  },
  {
    "input": "Chapter 7: Code Injection",
    "output": "7\nCODE I NjECtION\nImagine being able to walk into a game\ncompany’s office, sit down, and start add-\ning code to their game client. Imagine\nthat you can do this for any game you want,\nwhenever you want, and for any functionality you want.\nAlmost any gamer you talk to will have ideas on how\nto improve a game, but, as far as they know, it’s just a\npipe dream. But you know that dreams are meant to be fulfilled, and now\nthat you’ve learned a bit about how memory works, you’re ready to start\nthrowing the rules out the window. Using code injection, you can, for all\nintents and purposes, become as powerful as any game’s developers.\nCode injection is a means of forcing any process to execute foreign code\nwithin its own memory space and execution context. I touched on this\ntopic previously in “Bypassing ASLR in Production” on page 128, where\nI showed you how to remotely subvert ASLR using CreateRemoteThread(), but\nthat example only scratched the surface. In the first part of this chapter,\nyou’ll learn how to create code caves, inject new threads, and hijack thread"
  },
  {
    "input": "Creating an Assembly Code Cave",
    "output": "execution to force games to execute small snippets of assembly code. In the\nsecond part, you’ll learn how to inject foreign binaries directly into games,\nforcing those games to execute entire programs that you’ve created.\ninjecting code caves with Thread injection\nThe first step to injecting code into another process is writing position-\nagnostic assembly code, known as shellcode, in the form of a byte array. You\ncan write shellcode to remote processes to form code caves, which act as the\nentry point for a new thread that you want a game to execute. Once a code\ncave is created, you can execute it using either thread injection or thread hijack-\ning. I’ll show you an example of thread injection in this section, and I’ll\nillustrate thread hijacking in “Hijacking a Game’s Main Thread to Execute\nCode Caves” on page 138.\nYou’ll find example code for this chapter in this book’s resource\nfiles in the directory GameHackingExamples/Chapter7_CodeInjection. Open\nmain-codeInjection. cpp to follow along as I explain how to build a simplified\nversion of the function injectCodeUsingThreadInjection() from that file.\nCreating an Assembly Code Cave\nIn “Bypassing ASLR in Production” on page 128, I used thread injection\nto call the function GetModuleHandle() by way of CreateRemoteThread() and\nobtain a process handle. In that case, GetModuleHandle() acted as the code\ncave; it had the proper code structure to act as the entry point for a new\nthread. Thread injection isn’t always that easy, though.\nFor example, say you want your external bot to remotely call a function\nwithin a game, and the function has this prototype:\nDWORD __cdecl someFunction(int times, const char* string);\nA few things make remotely calling this function tricky. First, it has two\nparameters, meaning you need to create a code cave that will both set up\nthe stack and properly make the call. CreateRemoteThread() allows you to pass\none argument to the code cave, and you can access that argument relative\nto ESP, but the other one would still need to be hardcoded into the code\ncave. Hardcoding the first argument, times, is easiest. Additionally, you’d\nneed to make sure that the cave properly cleans the stack.\nNO tE Recall that when bypassing ASLR in Chapter 6, I used CreateRemoteThread() to start\nnew threads by executing any arbitrary code at a given address and passing that\ncode a single parameter. That’s why these examples can pass one parameter using the\nstack.\n134 Chapter 7"
  },
  {
    "input": "Translating the Assembly to Shellcode",
    "output": "Ultimately, the code cave to inject that call to someFunction into a run-\nning game process would look something like this pseudocode:\nPUSH DWORD PTR:[ESP+0x4] // get second arg from stack\nPUSH times\nCALL someFunction\nADD ESP, 0x8\nRETN\nThis code cave is almost perfect, but it could be less complex. The CALL\noperation expects one of two operands: either a register with an absolute\nfunction address or an immediate integer that holds an offset to a function,\nrelative to the return address. This means you’d have to do a bunch of off-\nset calculations, which can be tedious.\nTo keep the cave position agnostic, modify it to use a register instead,\nas in Listing 7-1.\nPUSH DWORD PTR:[ESP+0x4] // get second arg from stack\nPUSH times\nMOV EAX, someFunction\nCALL EAX\nADD ESP, 0x8\nRETN\nListing 7-1: A code cave to call someFunction\nSince a caller knows that a function it calls will overwrite EAX with its\nreturn value, the caller should ensure that EAX doesn’t hold any critical data.\nKnowing this, you can use EAX to hold the absolute address of someFunction.\nTranslating the Assembly to Shellcode\nBecause code caves need to be written to another process’s memory, they\ncannot be written directly in assembly. Instead, you’ll need to write them\nbyte by byte. There’s no standard way to determine which bytes represent\nwhich assembly code, but there are a few hacky approaches. My personal\nfavorite is to compile an empty C++ application with the assembly code in a\nfunction and use OllyDbg to inspect that function. Alternatively, you could\nopen OllyDbg on any arbitrary process and scan through the disassembly\nuntil you find the bytes for all of the operations you need. This method is\nactually really good, as your code caves should be written as simply as pos-\nsible, meaning all of the operations should be very common. You can also\nfind charts of assembly opcodes online, but I find that they’re all pretty\nhard to read; the methods I just described are easier overall.\nWhen you know what your bytes should be, you can use C++ to easily\ngenerate the proper shellcode. Listing 7-2 shows the finished shellcode skel-\neton for the assembly in Listing 7-1.\nCode Injection 135"
  },
  {
    "input": "Writing the Code Cave to Memory",
    "output": "BYTE codeCave[20] = {\n0xFF, 0x74, 0x24, 0x04, // PUSH DWORD PTR:[ESP+0x4]\n0x68, 0x00, 0x00, 0x00, 0x00, // PUSH 0\n0xB8, 0x00, 0x00, 0x00, 0x00, // MOV EAX, 0x0\n0xFF, 0xD0, // CALL EAX\n0x83, 0xC4, 0x08, // ADD ESP, 0x08\n0xC3 // RETN\n};\nListing 7-2: Shellcode skeleton\nThis example creates a BYTE array containing the needed bytes of shell-\ncode. But the times argument needs to be dynamic, and it’s impossible to\nknow the address of someFunction at compile time, which is why this shell-\ncode is written as a skeleton. The two groups of four sequential 0x00 bytes\nare placeholders for times and the address of someFunction, and you can\ninsert the real values into your code cave at runtime by calling memcpy(), as\nin the snippet in Listing 7-3.\nmemcpy(&codeCave[5], &times, 4);\nmemcpy(&codeCave[10], &addressOfSomeFunc, 4);\nListing 7-3: Inserting times and the location of someFunction into the code cave\nBoth times and the address of someFunction are 4 bytes each (recall\nthat times is an int and addresses are 32-bit values), and they belong at\ncodeCave[5-8] and codeCave[10-13], respectively. The two calls to memcpy() pass\nthis information as parameters to fill the blanks in the codeCave array.\nWriting the Code Cave to Memory\nWith the proper shellcode created, you can place it inside the target process\nusing VirtualAllocEx() and WriteProcessMemory(). Listing 7-4 shows one way to\ndo this.\nint stringlen = strlen(string) + 1; // +1 to include null terminator\nint cavelen = sizeof(codeCave);\nu int fulllen = stringlen + cavelen;\nauto remoteString = // allocate the memory with EXECUTE rights\nv VirtualAllocEx(process, 0, fulllen, MEM_COMMIT, PAGE_EXECUTE);\nauto remoteCave = // keep a note of where the code cave will go\nw (LPVOID)((DWORD)remoteString + stringlen);\n// write the string first\nx WriteProcessMemory(process, remoteString, string, stringlen, NULL);\n// write the code cave next\ny WriteProcessMemory(process, remoteCave, codeCave, cavelen, NULL);\nListing 7-4: Writing the final shellcode to a code cave memory\n136 Chapter 7"
  },
  {
    "input": "Using Thread Injection to Execute the Code Cave",
    "output": "First, this code determines exactly how many bytes of memory it will\nneed to write the string argument and the code cave into the game’s mem-\nory, and it stores that value in fulllen u. Then, it calls the API function\nVirtualAllocEx() to allocate fulllen bytes inside of process with PAGE_EXECUTE\nprotection (you can always use 0 and MEM_COMMIT, respectively, for the sec-\nond and fourth parameters), and it stores the address of the memory in\nremoteString v. It also increments remoteString by stringlen bytes and stores\nthe result in remoteCave w, as the shellcode should be written directly to the\nmemory following the string argument. Finally, it uses WriteProcessMemory()\nto fill the allocated buffer with string x and the assembly bytes y stored in\ncodeCave.\nTable 7-1 shows how a memory dump of the code cave might look,\nassuming that it is allocated at 0x030000, someFunction is at 0xDEADBEEF,\ntimes is set to 5, and string is pointing to the injected! text.\nTable 7-1: Code Cave Memory Dump\nAddress Code representation Raw data Data meaning\n0x030000 remoteString[0-4] 0x69 0x6E 0x6A injec\n0x65 0x63\n0x030005 remoteString[5-9] 0x74 0x65 0x64 ted!\\0\n0x0A 0x00\n0x03000A remoteCave[0-3] 0xFF 0x74 0x24 PUSH DWORD\n0x04 PTR[ESP+0x4]\n0x03000E remoteCave[4-8] 0x68 0x05 0x00 PUSH 0x05\n0x00 0x00\n0x030013 remoteCave[9-13] 0xB8 0xEF 0xBE MOV EAX, 0xDEADBEEF\n0xAD 0xDE\n0x030018 remoteCave[14-15] 0xFF 0xD0 CALL EAX\n0x03001A remoteCave[16-18] 0x83 0xC4 0x08 ADD ESP, 0x08\n0x03001D remoteCave[19] 0xC3 RETN\nThe Address column shows where each piece of the cave is located\nin memory; the Code representation column tells you which indexes of\nremoteString and remoteCave correspond to the bytes in the Raw data col-\numn; and the Data meaning column shows what the bytes represent, in\nhuman-readable format. You can see the injected! string at 0x030000, the\nvalue of times at 0x03000E, and the address of someFunction at 0x030014.\nUsing Thread Injection to Execute the Code Cave\nWith a complete code cave written to memory, the only thing left to\ndo is execute it. In this example, you could execute the cave using the\nfollowing code:\nHANDLE thread = CreateRemoteThread(process, NULL, NULL,\n(LPTHREAD_START_ROUTINE)remoteCave,\nremoteString, NULL, NULL);\nCode Injection 137"
  },
  {
    "input": "Building the Assembly Code Cave",
    "output": "WaitForSingleObject(thread, INFINITE);\nCloseHandle(thread);\nVirtualFreeEx(process, remoteString, fulllen, MEM_RELEASE)\nThe calls to CreateRemoteThread(), WaitForSingleObject(), and CloseHandle()\nwork to inject and execute the code cave, and VirtalFreeEx() covers the\nbot’s tracks by freeing the memory allocated in code like Listing 7-4. In\nthe simplest form, that’s all there is to executing a code cave injected into\na game. In practice, you should also check return values after calling\nVirtualAllocEx(), WriteProcessMemory(), and CreateRemoteThread() to make sure\nthat everything was successful.\nFor instance, if VirtualAllocEx() returns 0x00000000, it means that the\nmemory allocation failed. If you don’t handle the failure, WriteProcessMemory()\nwill also fail and CreateRemoteThread() will begin executing with an entry point\nof 0x00000000, ultimately crashing the game. The same is true for the return\nvalues of WriteProcessMemory() and CreateRemoteThread(). Typically, these func-\ntions will only fail when the process handle is opened without the required\naccess flags.\nHijacking a Game’s main Thread to execute code caves\nIn some cases, injected code caves need to be in sync with the main thread\nof the game process. Solving this problem can be very tricky because it\nmeans that you must control the existing threads in an external process.\nYou could simply suspend the main thread until the code cave finishes\nexecuting, which might work, but that would prove very slow. The overhead\nrequired to wait for a code cave and then resume a thread is pretty heavy.\nA faster alternative is to force the thread to execute the code for you, a pro-\ncess called thread hijacking.\nNO tE Open the main-codeInjection.cpp file in this book’s source code files to follow\nalong with building this thread-hijacking example, which is a simplified version of\ninjectCodeUsingThreadHijacking().\nBuilding the Assembly Code Cave\nAs with thread injection, the first step to thread hijacking is knowing what\nyou want to happen in your code cave. This time, however, you don’t know\nwhat the thread will be executing when you hijack it, so you’ll need to make\nsure to save the thread’s state when the code cave starts and restore the\nstate when you’re done hijacking it. This means your shellcode needs to be\nwrapped in some assembly, as in Listing 7-5.\nPUSHAD // push general registers to the stack\nPUSHFD // push EFLAGS to the stack\n138 Chapter 7\n// shellcode should be here\nPOPFD // pop EFLAGS from the stack\nPOPAD // pop general registers to the stack\n// resume the thread without using registers here\nListing 7-5: A framework for the thread-hijacking code cave\nIf you were to call the same someFunction that you did with thread injec-\ntion, you could use shellcode similar to that in Listing 7-2. The only dif-\nference is that you couldn’t pass the second parameter to your bot using\nthe stack because you wouldn’t be using CreateRemoteThread(). But that’s no\nproblem; you could just push it the same way you’d push the first parameter.\nThe part of the code cave that executes the function you want to call would\nneed to look like Listing 7-6.\nPUSH string\nPUSH times\nMOV EAX, someFunction\nCALL EAX\nADD ESP, 0x8\nListing 7-6: Assembly skeleton for calling someFunction\nAll that’s changed here from Listing 7-1 is that this example pushes\nstring explicitly and there’s no RETN. You don’t call RETN in this case because\nyou want the game thread to go back to whatever it was doing before you\nhijacked it.\nTo resume the execution of the thread normally, the cave needs to\njump back to the thread’s original EIP without using registers. Fortunately,\nyou can use the GetThreadContext() function to fetch EIP, filling the shellcode\nskeleton in C++. Then you can push it to the stack inside your code cave\nand do a return. Listing 7-7 shows how your code cave would need to end.\nPUSH originalEIP\nRETN\nListing 7-7: Jumping to EIP indirectly\nA return jumps to the value on the top of the stack, so doing this imme-\ndiately after pushing EIP will do the trick. You should use this method\ninstead of a jump, because jumps require offset calculation and make the\nshellcode a bit more complex to generate. If you tie Listings 7-5 through 7-7\ntogether, you come up with the following code cave:\n//save state\nPUSHAD // push general registers to the stack\nPUSHFD // push EFLAGS to the stack\nCode Injection 139"
  },
  {
    "input": "Generating Skeleton Shellcode and Allocating Memory",
    "output": "// do work with shellcode\nPUSH string\nPUSH times\nMOV EAX, someFunction\nCALL EAX\nADD ESP, 0x8\n// restore state\nPOPFD // pop EFLAGS from the stack\nPOPAD // pop general registers to the stack\n// un-hijack: resume the thread without using registers\nPUSH originalEIP\nRETN\nNext, follow the instructions in “Translating the Assembly to Shellcode”\non page 135 and plug those bytes into an array representing your code cave.\nGenerating Skeleton Shellcode and Allocating Memory\nUsing the same method shown in Listing 7-2, you could generate the shell-\ncode for this cave, as shown in Listing 7-8.\nBYTE codeCave[31] = {\n0x60, // PUSHAD\n0x9C, // PUSHFD\n0x68, 0x00, 0x00, 0x00, 0x00, // PUSH 0\n0x68, 0x00, 0x00, 0x00, 0x00, // PUSH 0\n0xB8, 0x00, 0x00, 0x00, 0x00, // MOV EAX, 0x0\n0xFF, 0xD0, // CALL EAX\n0x83, 0xC4, 0x08, // ADD ESP, 0x08\n0x9D, // POPFD\n0x61, // POPAD\n0x68, 0x00, 0x00, 0x00, 0x00, // PUSH 0\n0xC3 // RETN\n};\n// we'll need to add some code here to place\n// the thread's EIP into threadContext.Eip\nmemcpy(&codeCave[3], &remoteString, 4);\nmemcpy(&codeCave[8], &times, 4);\nmemcpy(&codeCave[13], &func, 4);\nmemcpy(&codeCave[25], &threadContext.Eip, 4);\nListing 7-8: Creating the thread-hijacking shellcode array\nAs in Listing 7-3, memcpy() is used to put the variables into the skeleton.\nUnlike in that listing, though, there are two variables that cannot be copied\nright away; times and func are known immediately, but remoteString is a result\nof allocation and threadContext.Eip will be known only once the thread is\nfrozen. It also makes sense to allocate memory before freezing the thread,\n140 Chapter 7"
  },
  {
    "input": "Finding and Freezing the Main Thread",
    "output": "because you don’t want the thread to be frozen any longer than it has to be.\nHere’s how this might look:\nint stringlen = strlen(string) + 1;\nint cavelen = sizeof(codeCave);\nint fulllen = stringlen + cavelen;\nauto remoteString =\nVirtualAllocEx(process, 0, fulllen, MEM_COMMIT, PAGE_EXECUTE);\nauto remoteCave =\n(LPVOID)((DWORD)remoteString + stringlen);\nThe allocation code is the same as it was for thread injection, so you\ncan reuse the same snippet.\nFinding and Freezing the Main Thread\nThe code to freeze the main thread is a bit trickier. First, you get the thread’s\nunique identifier. This works much like getting a PID, and you can do it\nusing CreateToolhelp32Snapshot(), Thread32First(), and Thread32Next() from\nTlHelp32.h. As discussed in “Obtaining the Game’s Process Identifier” on\npage 120, these functions are used to essentially iterate over a list. A pro-\ncess can have many threads, but the following example assumes that the\nfirst thread the game process created is the one that needs to be hijacked:\nDWORD GetProcessThreadID(HANDLE Process) {\nTHREADENTRY32 entry;\nentry.dwSize = sizeof(THREADENTRY32);\nHANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);\nif (Thread32First(snapshot, &entry) == TRUE) {\nDWORD PID = GetProcessId(Process);\nwhile (Thread32Next(snapshot, &entry) == TRUE) {\nif (entry.th32OwnerProcessID == PID) {\nCloseHandle(snapshot);\nreturn entry.th32ThreadID;\n}\n}\n}\nCloseHandle(snapshot);\nreturn NULL;\n}\nThis code simply iterates over the list of all threads on the system and\nfinds the first one that matches the game’s PID. Then it gets the thread\nidentifier from the snapshot entry. Once you know the thread identifier,\nfetch the thread’s current register state like this:\nHANDLE thread = OpenThread(\n(THREAD_GET_CONTEXT | THREAD_SUSPEND_RESUME | THREAD_SET_CONTEXT),\nfalse, threadID);\nSuspendThread(thread);\nCode Injection 141"
  },
  {
    "input": "Injecting DLLs for Full Control",
    "output": "CONTEXT threadContext;\nthreadContext.ContextFlags = CONTEXT_CONTROL;\nGetThreadContext(thread, &threadContext);\nThis code uses OpenThread() to get a thread handle. It then suspends\nthe thread using SuspendThread() and obtains the values of its registers using\nGetThreadContext(). After this, the memcpy() code in Listing 7-8 should have all\nof the variables it needs to finish generating the shellcode.\nWith the shellcode generated, the code cave can be written to the allo-\ncated memory in the same fashion as in Listing 7-4:\nWriteProcessMemory(process, remoteString, string, stringlen, NULL);\nWriteProcessMemory(process, remoteCave, codeCave, cavelen, NULL);\nOnce the cave is ready and waiting in memory, all you need to do is set\nthe thread’s EIP to the address of the code cave and let the thread resume\nexecution, as follows:\nthreadContext.Eip = (DWORD)remoteCave;\nthreadContext.ContextFlags = CONTEXT_CONTROL;\nSetThreadContext(thread, &threadContext);\nResumeThread(thread);\nThis code causes the thread to resume execution at the address of the\ncode cave. Because of the way the code cave is written, the thread has no\nclue that anything has changed. The cave stores the thread’s original state,\nexecutes the payload, restores the thread’s original state, and then returns\nto the original code with everything intact.\nWhen you’re using any form of code injection, it is also important to\nunderstand what data your code caves touch. For example, if you were to\ncreate a code cave that calls a game’s internal functions to create and send\na network packet, you’d need to make sure that any global variables that\nthe functions touch (like a packet buffer, packet position marker, and so\non) are safely restored once you’re done. You never know what the game is\ndoing when your code cave is executed—it could be calling the same func-\ntion as you!\ninjecting dLLs for Full control\nCode caves are very powerful (you can make a game do anything using\nassembly shellcode), but handcrafting shellcode isn’t practical. It would be\nmuch more convenient to inject C++ code, wouldn’t it? That’s possible, but\nthe process is far more complex: the code must be compiled to assembly,\npackaged in a position-agnostic format, made aware of any external depen-\ndencies, entirely mapped into memory, and then executed on some entry\npoint.\n142 Chapter 7"
  },
  {
    "input": "Tricking a Process into Loading Your DLL",
    "output": "Luckily, all of these things are already taken care of in Windows. By\nchanging a C++ project to compile as a dynamic library, you can create a self-\ncontained, position-agnostic binary called a dynamic link library (DLL). Then\nyou can use a mix of thread injection or hijacking and the LoadLibrary() API\nfunction to map your DLL file into a game’s memory.\nOpen main-codeInjection.cpp in the GameHackingExamples/Chapter7_\nCodeInjection directory and dllmain.cpp under GameHackingExamples/\nChapter7_CodeInjection_DLL to follow along with some example code as\nyou read this section. In main-codeInjection.cpp, look at the LoadDLL() function\nspecifically.\nTricking a Process into Loading Your DLL\nUsing a code cave, you can trick a remote process into invoking LoadLibrary()\non a DLL, effectively loading foreign code into its memory space. Because\nLoadLibrary() takes only a single parameter, you could create a code cave to\ncall it as follows:\n// write the dll name to memory\nwchar_t* dllName = \"c:\\\\something.dll\";\nint namelen = wcslen(dllName) + 1;\nLPVOID remoteString =\nVirtualAllocEx(process, NULL, namelen * 2, MEM_COMMIT, PAGE_EXECUTE);\nWriteProcessMemory(process, remoteString, dllName, namelen * 2, NULL);\n// get the address of LoadLibraryW()\nHMODULE k32 = GetModuleHandleA(\"kernel32.dll\");\nLPVOID funcAdr = GetProcAddress(k32, \"LoadLibraryW\");\n// create a thread to call LoadLibraryW(dllName)\nHANDLE thread =\nCreateRemoteThread(process, NULL, NULL,\n(LPTHREAD_START_ROUTINE)funcAdr,\nremoteString, NULL, NULL);\n// let the thread finish and clean up\nWaitForSingleObject(thread, INFINITE);\nCloseHandle(thread);\nThis code is somewhat a mix of the thread injection code from\n“Bypassing ASLR in Production” on page 128 and the code cave created\nto call someFunction in Listings 7-2 and 7-3. Like the former, this example\nuses the body of a single-parameter API function, namely LoadLibrary, as the\nbody of the code cave. Like the latter, though, it has to inject a string into\nmemory, since LoadLibrary expects a string pointer as its first argument. Once\nthe thread is injected, it forces LoadLibrary to load the DLL whose name was\ninjected into memory, effectively putting foreign code into a game.\nCode Injection 143\nNO tE Give any DLL you plan to inject a unique name, like MySuperBotV2Hook.dll.\nSimpler names, such as Hook.dll or Injected.dll, are dangerously generic. If the\nname conflicts with a DLL that is already loaded, LoadLibrary() will assume that it\nis the same DLL and not load it!\nOnce the LoadLibrary() code cave loads your DLL into a game, the DLL’s\nentry point—known as DllMain()—will be executed with DLL_PROCESS_ATTACH as\nthe reason. When the process is killed or FreeLibrary() is called on the DLL,\nits entry point will be called with the DLL_PROCESS_DETACH reason. Handling\nthese events from the entry point might look like this:\nBOOL APIENTRY DllMain(HMODULE hModule,\nDWORD ul_reason_for_call,\nLPVOID lpReserved) {\nswitch (ul_reason_for_call) {\ncase DLL_PROCESS_ATTACH:\nprintf(\"DLL attached!\\n\");\nbreak;\ncase DLL_PROCESS_DETACH:\nprintf(\"DLL detached!\\n\");\nbreak;\n}\nreturn TRUE;\n}\nThis example function starts by checking why DllMain() was called. It\nthen outputs text indicating whether it was called because the DLL was\nattached or detached, returning TRUE either way.\nKeep in mind that the entry point of a DLL is executed inside a loader\nlock, which is a global synchronization lock used by all functions that read\nor modify the list of modules loaded in a process. This loader lock gets used\nby functions like GetModuleHandle(), GetModuleFileName(), Module32First(), and\nModule32Next(), which means that running nontrivial code from a DLL entry\npoint can lead to deadlocks and should be avoided.\nIf you need to run code from a DLL entry point, do so from a new\nthread, as follows:\nDWORD WINAPI runBot(LPVOID lpParam) {\n// run your bot\nreturn 1;\n}\n// do this from DllMain() for case DLL_PROCESS_ATTACH\nauto thread = CreateThread(NULL, 0, &runBot, NULL, 0, NULL);\nCloseHandle(thread);\nFrom DllMain(), this code creates a new thread starting on the function\nrunBot(). It then immediately closes its handle to the thread, as doing any\nfurther operations from DllMain() can lead to serious problems. From inside\n144 Chapter 7"
  },
  {
    "input": "Accessing Memory in an Injected DLL",
    "output": "this runBot(), you can begin executing your bot’s code. The code runs inside\nthe game, meaning you can directly manipulate memory using the type-\ncasting methods. You can also do a lot more, as you’ll see in Chapter 8.\nWhen injecting DLLs, make sure you have no dependency issues. If\nyour DLL relies on some nonstandard DLLs, for example, you have to\neither inject those DLLs into the game first or put them in a folder that\nLoadLibrary() will search, such as any folder in the PATH environment vari-\nable. The former will work only if the DLLs have no dependencies of their\nown, whereas the latter is a bit tricky to implement and subject to name col-\nlisions. The best option is to link all external libraries statically so that they\nare compiled directly into your DLL.\nAccessing Memory in an Injected DLL\nWhen you’re trying to access a game’s memory from an injected DLL, pro-\ncess handles and API functions are a hindrance. Because a game shares\nthe same memory space as all code injected into it, you can access a game’s\nmemory directly from injected code. For example, to access a DWORD value\nfrom injected code, you could write the following:\nDWORD value = *((DWORD*)adr); // read a DWORD from adr\n*((DWORD*)adr) = 1234; // write 1234 to DWORD adr\nThis simply typecasts the memory address adr to a DWORD* and\nde references that pointer to a DWORD. Doing typecasts in place like that\nis fine, but your memory access code will look cleaner if the functions\nare abstracted and made generic, just like the Windows API wrappers.\nThe generic functions for accessing memory from inside injected code\nlook something like this:\ntemplate<typename T>\nT readMemory(LPVOID adr) {\nreturn *((T*)adr);\n}\ntemplate<typename T>\nvoid writeMemory(LPVOID adr, T val) {\n*((T*)adr) = val;\n}\nUsing these templates is just like using the functions under “Writing\nTemplated Memory Access Functions” on page 123. Here’s an example:\nDWORD value = readMemory<DWORD>(adr); // read\nwriteMemory<DWORD>(adr, value++); // increment and write\nThese calls are nearly identical to the calls in Listing 6-6 on page 124;\nthey just don’t need to take the process handle as an argument because\nCode Injection 145"
  },
  {
    "input": "Bypassing ASLR in an Injected DLL",
    "output": "they’re being called from inside the process itself. You can make this\nmethod even more flexible by creating a third templated function called\npointMemory(), as follows:\ntemplate<typename T>\nT* pointMemory(LPVOID adr) {\nreturn ((T*)adr);\n}\nThis function skips the dereferencing step of a memory read and simply\ngives you the pointer to the data. From there, you’re free to both read from\nand write to the memory by dereferencing that pointer yourself, like this:\nDWORD* pValue = pointMemory<DWORD>(adr); // point\nDWORD value = *pValue; // 'read'\n(*pValue)++; // increment and 'write'\nWith a function like pointMemory() in place, you could eliminate the calls\nto readMemory() and writeMemory(). You’d still need to find adr ahead of time,\nbut from there, the code to read a value, change it, and write it back would\nbe much simpler to follow.\nBypassing ASLR in an Injected DLL\nSimilarly, since the code is injected, there’s no need to inject a thread into\nthe game to get the base address. Instead, you can just call GetModuleHandle()\ndirectly, like so:\nDWORD newBase = (DWORD)GetModuleHandle(NULL);\nA faster way to get the base address is to utilize the game’s FS memory\nsegment, which is another superpower you get from injected code. This\nmemory segment points to a structure called the thread environment block\n(TEB), and 0x30 bytes into the TEB is a pointer to the process environment\nblock (PEB) structure. These structures are used by the operating system\nand contain a ton of data about the current thread and the current process,\nbut we’re interested only in the base address of the main module, which is\nstored 0x8 bytes into the PEB. Using inline assembly, you can traverse these\nstructures to get newBase, like this:\nDWORD newBase;\n__asm {\nMOV EAX, DWORD PTR FS:[0x30]\nMOV EAX, DWORD PTR DS:[EAX+0x8]\nMOV newBase, EAX\n}\nThe first command stores the PEB address in EAX, and the second com-\nmand reads the main module’s base address and stores it in EAX. The final\ncommand then copies EAX to newBase.\n146 Chapter 7"
  },
  {
    "input": "Closing Thoughts",
    "output": "closing Thoughts\nIn Chapter 6, I showed you how to read from memory remotely and how\nan injected DLL can directly access a game’s memory using pointers. This\nchapter demonstrated how to inject all types of code, from pure assembly\nbyte code to entire C++ binaries. In the next chapter, you’ll learn just\nhow much power being in a game’s memory space actually gives you. If you\nthought assembly code injection was cool, you’ll love what you can do when\nyou mix injected C++ with control flow manipulation.\nThe example code for this chapter contains proofs of concept for every-\nthing we’ve discussed. If you’re still unclear about any of the topics, you can\npoke at the code to learn exactly what’s going on and see all of the tricks in\naction.\nCode Injection 147"
  },
  {
    "input": "Chapter 8: \rManipulating Control Flow in a Game",
    "output": "8\nMANIPul AtING C ONtrOl f lOw\nIN A G AME\nForcing a game to execute foreign code is\ndefinitely powerful, but what if you could\nalter the way a game executes its own code?\nWhat if you could force the game to bypass\nthe code that draws the fog of war, trick it into mak-\ning enemies visible through walls, or manipulate the\narguments it passes to functions? Control flow manipu-\nlation lets you do exactly that, allowing you to change\nwhat a process does by intercepting code execution\nand monitoring, modifying, or preventing it.\nThere are many ways to manipulate the control flow of a process, but\nalmost all require you to modify the process’s assembly code. Depending on\nyour goals, you’ll need to either completely remove code from the process\n(called NOPing) or force the process to redirect execution to injected func-\ntions (called hooking). In the beginning of this chapter, you’ll learn about"
  },
  {
    "input": "When to NOP",
    "output": "NOPing, several types of hooking, and other control flow manipulation tech-\nniques. Once I’ve explained the basics, I’ll show you how I’ve applied these\nprinciples to common game libraries like Adobe AIR and Direct3D.\nOpen the directory GameHackingExamples/Chapter8_ControlFlow in this\nbook’s resource files to see the complete sample code for the next section\nand “Hooking to Redirect Game Execution” on page 153.\nnOPing to Remove unwanted code\nChapter 7 described how to inject new code into a game, but the opposite—\nremoving code from a game—can also be useful. Some hacks require you\nto stop some of a game’s original code from being executed, and to do that,\nyou’ll have to get rid of it. One way to eliminate code from a game process\nis NOPing, which involves overwriting the original x86 assembly code with\nNOP instructions.\nWhen to NOP\nConsider a game that won’t show the health bars of cloaked enemies. It’s\npretty hard to see cloaked enemies coming, and you’d have a huge advan-\ntage in combat if you could at least see their health bars. The code to draw\nhealth bars often looks like Listing 8-1.\nfor (int i = 0; i < creatures.size(); i++) {\nauto c = creatures[i];\nif (c.isEnemy && c.isCloaked) continue;\ndrawHealthBar(c.healthBar);\n}\nListing 8-1: The loop from the drawCreatureHealthBarExample() function\nWhen drawing health bars, a game with cloaked creatures might\nuse a for loop to check whether the creatures within the screen’s bounds\nare cloaked. If an enemy isn’t cloaked, the loop calls some function\n(drawHealthBar() in this example) to display the enemy’s health bar.\nGiven the source code, you could force the game to draw even cloaked\nenemies’ health bars by simply removing if (c.isEnemy && c.isCloaked)\ncontinue; from the code. But as a game hacker, you have only the assembly\ncode, not the source code. When simplified, the assembly that Listing 8-1\ntranslates into looks something like this pseudocode:\nstartOfLoop: ; for\nMOV i, 0 ; int i = 0\nJMP condition ; first loop, skip increment\nincrement:\nADD i, 1 ; i++\ncondition:\nCMP i, creatures.Size() ; i < creatures.size()\nJNB endOfLoop ; exit loop if i >= creatures.size()\n150 Chapter 8"
  },
  {
    "input": "How to NOP",
    "output": "body:\nMOV c, creatures[i] ; auto c = creatures[i]\nTEST c.isEnemy, c.isEnemy ; if c.isEnemy\nJZ drawHealthBar ; draw bar if c.isEnemy == false\nTEST c.isCloaked, c.isCloaked ; && c.isCloaked\nJZ drawHealthBar ; draw bar if c.isCloaked == false\nu JMP increment ; continue\ndrawHealthBar:\nCALL drawHealthBar(c.healthBar) ; drawHealthBar(c.healthBar)\nJMP increment ; continue\nendOfLoop:\nTo trick the game into drawing all enemy health bars, regardless of\ncloaking, you’d need to remove the JMP increment command u that executes\nwhen c.isEnemy && c.isCloaked evaluates to true. In assembly, though, replac-\ning unwanted code with instructions that do nothing is easier than deleting\ncode. That’s where the NOP command comes in. Since NOP is a single byte\n(0x90), you can overwrite the 2-byte JMP increment command with two NOP\ncommands. When the processor reaches those NOP commands, it rolls over\nthem and falls into drawHealthBar() even when c.isEnemy && c.isCloaked evalu-\nates to true.\nHow to NOP\nThe first step to NOPing a chunk of assembly code is making the memory\nchunk where the code lives writable. It’s possible for the code on the same\nmemory page to be executed while you’re writing the NOP commands,\nthough, so you also want to make sure the memory is still executable. You\ncan accomplish both of these tasks by setting the memory’s protection to\nPAGE_EXECUTE_READWRITE. Once the memory is properly protected, you can\nwrite the NOP commands and be done. It technically doesn’t hurt to leave\nthe memory writable, but it’s good practice to also restore the original pro-\ntection when you’re finished.\nProvided you have facilities in place for writing and protecting memory\n(as described in Chapter 6), you can write a function like the one shown\nin Listing 8-2 to write NOP commands to game memory. (Follow along by\nopening the project’s NOPExample.cpp file.)\ntemplate<int SIZE>\nvoid writeNop(DWORD address)\n{\nauto oldProtection =\nprotectMemory<BYTE[SIZE]>(address, PAGE_EXECUTE_READWRITE);\nfor (int i = 0; i < SIZE; i++)\nwriteMemory<BYTE>(address + i, 0x90);\nprotectMemory<BYTE[SIZE]>(address, oldProtection);\n}\nListing 8-2: Proper NOPing, complete with memory protection\nManipulating Control Flow in a Game 151\nIn this example, the writeNop() function sets the appropriate memory\nprotection, writes a number of NOP commands equal to SIZE, and reapplies\nthe original memory protection level.\nThe writeNop() function takes the number of NOP instructions to\nplace as a template parameter, since the memory functions require a\ncorrectly sized type at compile time. Passing an integer SIZE tells the\nmemory functions to operate on a type of BYTE[SIZE] at compile time.\nTo specify a dynamic size at runtime, simply drop the loop and instead\ncall protectMemory<BYTE> and pass address and address + SIZE as arguments.\nAs long as the size isn’t larger than a page (and really, you shouldn’t be\nNOPing a full page), this will ensure that the memory gets properly pro-\ntected even if it’s on a page boundary.\nCall this function with the address where you want to place your NOPs\nand the number of NOP commands to place:\nwriteNop<2>(0xDEADBEEF);\nKeep in mind that the number of NOP commands should match the\nsize in bytes of the command being removed. This call to writeNop() writes\ntwo NOP commands to the address 0xDEADBEEF.\nPrACtICE NOPING\nIf you haven’t already, open NOPExample.cpp in this chapter’s example code\nnow and play around with it for a bit. You’ll find a working implementation of\nthe writeNop() function and an interesting function called getAddressforNOP()\nthat scans the example program’s memory to find where the NOP command\nshould be placed.\nTo see the NOP command in action, run the compiled NOPapplication in\nVisual Studio’s debugger with breakpoints at the start and end of the writeNop()\nfunction. When the first breakpoint is hit, press alt-8 to open the disassembly\nwindow, enter address in the input box, and press enter. This brings you to the\nNOP’s target address, where you’ll see the assembly code fully intact. Press F5\nto continue execution, which triggers the second breakpoint after allowing the\napplication to place the NOPs. Finally, jump back to address in the disassembly\ntab to see that the code was replaced by NOPs.\nYou can rework this code to do other cool stuff. For example, you might try\nplacing NOPs on the comparisons instead of the jump or even modifying the\njump’s type or destination.\nThese and other alternative approaches may work, but note that they\nintroduce more room for error than overwriting the single JMP with NOP com-\nmands. When modifying foreign code, make as few changes as possible to\nminimize the potential for errors.\n152 Chapter 8"
  },
  {
    "input": "Call Hooking",
    "output": "Hooking to Redirect Game execution\nSo far, I’ve shown you how to manipulate games by adding code to them,\nhijacking their threads, creating new threads, and even removing existing\ncode from their execution flow. These methods are very powerful on their\nown, but when combined, they form an even more potent method of manip-\nulation called hooking. Hooking allows you to intercept precise branches of\nexecution and redirect them to injected code that you’ve written to dictate\nwhat the game should do next, and it comes in a variety of flavors. In this\nsection, I’ll teach you about four of the most powerful hooking methods for\ngame hacking: call hooking, virtual function table hooking, import address\ntable hooking, and jump hooking.\nCall Hooking\nA call hook directly modifies the target of a CALL operation to point to a new\npiece of code. There are a few variations of the CALL operation in x86 assem-\nbly, but call hooks are generally used on only one: the near call, which takes\nan immediate address as an operand.\nWorking with Near Calls in Memory\nIn an assembly program, a near call looks like this:\nCALL 0x0BADF00D\nThis near call is represented by the byte 0xE8, so you might assume it is\nstored in memory like this:\n0xE8 0x0BADF00D\nOr, when split into single bytes and swapped for endianness, like this:\n0xE8 0x0D 0xF0 0xAD 0x0B\nBut the anatomy of a near call in memory is not that simple. Instead\nof storing the callee’s absolute address, a near call stores an offset to the\ncallee relative to the address immediately after the call. Since a near call is\n5 bytes, the address immediately after the call is 5 bytes later in memory.\nGiven that, the address stored can be computed as follows:\ncalleeAddress – (callAddress + 5)\nIf CALL 0x0BADF00D lives at 0xDEADBEEF in memory, then the value after\n0xE8 is this:\n0x0BADF00D – (0xDEADBEEF + 5) = 0x2D003119\nManipulating Control Flow in a Game 153\nIn memory, then, that CALL instruction looks like this:\n0xE8 0x19 0x31 0x00 0x2D\nTo hook a near call, you first need to change the offset following 0xE8\n(that is, the little-endian 0x19 0x31 0x00 0x2D) to point to your new callee.\nHooking a Near Call\nFollowing the same memory protection rules shown in Listing 8-2, you hook\na near call like so (follow along by opening CallHookExample.cpp):\nDWORD callHook(DWORD hookAt, DWORD newFunc)\n{\nDWORD newOffset = newFunc - hookAt - 5;\nauto oldProtection =\nprotectMemory<DWORD>(hookAt + 1, PAGE_EXECUTE_READWRITE);\nDWORD originalOffset = readMemory<DWORD>(uhookAt + 1);\nwriteMemory<DWORD>(hookAt + 1, newOffset);\nprotectMemory<DWORD>(hookAt + 1, oldProtection);\nv return originalOffset + hookAt + 5;\n}\nThis function takes as arguments the address of the CALL to hook\n(hookAt) and the address to redirect execution to (newFunc), and it uses\nthem to calculate the offset required to call the code at the address newFunc\ncontains. After you apply the correct memory protections, the callHook()\nfunction writes the new offset to the memory at hookAt + 1 u, applies the\nold memory protections, calculates the address of the original call v, and\nreturns that value to the caller.\nHere’s how you might actually use a function like this in a game hack:\nDWORD origFunc = callHook(0xDEADBEEF, (DWORD)&someNewFunction);\nThis hooks the near call to 0x0BADF00D at 0xDEADBEEF and re directs\nit to the address of someNewFunction, which is the code your hack will execute.\nAfter this is called, the origFunc value will hold 0x0BADF00D.\nCleaning Up the Stack\nThe new callee must also properly handle the stack, preserve registers, and\npass proper return values. At the least, this means your replacement func-\ntion must match the game’s original function in both calling convention\nand argument count.\nLet’s say this is the original full function call, in assembly:\nPUSH 1\nPUSH 456\n154 Chapter 8\nPUSH 321\nCALL 0x0BADF00D\nADD ESP, 0x0C\nYou can tell the function has the C++ __cdecl convention because the\nstack is being reset by the caller. Additionally, the 0x0C bytes being cleaned\nfrom the stack show that there are three arguments, which you can calcu-\nlate as follows:\n0x0C\n= 3\nsizeof(DWORD)\nOf course, you can also obtain the number of arguments by checking\nhow many things are pushed to the stack: there are three PUSH commands,\none for each argument.\nWriting a Call Hook\nIn any case, the new callee, someNewFunction, must follow the __cdecl conven-\ntion and have three arguments. Here’s an example skeleton for the new\ncallee:\nDWORD __cdecl someNewFunction(DWORD arg1, DWORD arg2, DWORD arg3)\n{\n}\nIn Visual Studio, C++ programs use the __cdecl convention by default,\nso technically you could omit it from your function definition; however, I’ve\nfound it’s better to be verbose so you get into the habit of being specific.\nAlso keep in mind that if the caller expects a value to be returned, the\nreturn type of your function should match as well. This example assumes\nthe return type is always a DWORD or smaller. Since return types in this size\nrange will all be passed back on EAX, further examples will also use a\nreturn type of DWORD.\nIn most cases, a hook finishes by calling the original function and\npassing its return value back to the caller. Here’s how all of that might fit\ntogether:\ntypedef DWORD (__cdecl _origFunc)(DWORD arg1, DWORD arg2, DWORD arg3);\n_origFunc* originalFunction =\n(_origFunc*)hookCall(0xDEADBEEF, (DWORD)&someNewFunction);\nDWORD __cdecl someNewFunction(DWORD arg1, DWORD arg2, DWORD arg3)\n{\nreturn originalFunction(arg1, arg2, arg3);\n}\nThis example uses typedef to declare a type representing the original\nfunction’s prototype and creates a pointer with this type to the original\nManipulating Control Flow in a Game 155"
  },
  {
    "input": "VF Table Hooking",
    "output": "function. Then someNewFunction() uses this pointer to call the original func-\ntion with the original arguments and pass the returned value back to the\ncaller.\nRight now, all someNewFunction() does is return to the original function.\nBut you can do whatever you want from inside the someNewFunction() call\nfrom here. You can modify the parameters being passed to the original\nfunction or intercept and store interesting parameters for later use. If you\nknow the caller isn’t expecting a return value (or if you know how to spoof\nthe return value), you can even forget about the original function and com-\npletely replace, replicate, or improve its functionality inside the new callee.\nOnce you’ve perfected this skill, you can add your own native C or C++ code\nto any part of a game that you wish.\nVF Table Hooking\nUnlike call hooks, virtual function (VF) table hooks don’t modify assembly\ncode. Instead, they modify the function addresses stored in the VF tables\nof classes. (If you need a refresher on VF tables, see “A Class with Virtual\nFunctions” on page 75.) All instances of the same class type share a static\nVF table, so VF table hooks will intercept all calls made to a member func-\ntion, regardless of which class instance the game is calling the function\nfrom. This can be both powerful and tricky.\ntHE trutH ABOut Vf tABlEs\nTo simplify the explanation, I lied a little when I said that VF table hooks could\nintercept all calls made to a function. In reality, the VF table is traversed only\nwhen a virtual function is called in a way that leaves the compiler with some\nplausible type ambiguity. For example, a VF table will be traversed when a\nfunction is called through the inst->function() call format. A VF table won’t be\ntraversed when a virtual function is invoked in such a way that the compiler is\nsure about the type, as in inst.function() or similar calls, since the compiler\nwill know the function’s address. Conversely, calling inst.function() from a\nscope where inst is passed in as a reference would trigger a VF table tra-\nversal. Before you try to deploy VF table hooking, make sure the function calls\nyou want to hook have type ambiguity.\nWriting a VF table Hook\nBefore we go any deeper into how to place a VF table hook, we need to\ntalk about those pesky calling conventions again. VF tables are used by\nclass instances to call virtual member functions, and all member functions\nwill have the __thiscall convention. The name __thiscall is derived from\n156 Chapter 8\nthe this pointer that member functions use to reference the active class\ninstance. Thus, member functions are given this as a pseudoparameter\non ECX.\nIt’s possible to match the prototype of a __thiscall by declaring a class\nthat acts as a container for all __thiscall hook callbacks, but I don’t prefer\nthis method. Instead, I find it easier to control the data using inline assem-\nbly. Let’s explore how you control the data when placing a VF hook on a\nclass that looks like this:\nclass someBaseClass {\npublic:\nvirtual DWORD someFunction(DWORD arg1) {}\n};\nclass someClass : public someBaseClass {\npublic:\nvirtual DWORD someFunction(DWORD arg1) {}\n};\nThe someBaseClass class just has one member (a public virtual func-\ntion), and the someClass class inherits from someBaseClass and overrides the\nsomeBaseClass::someFunction member. To hook someClass::someFunction, you\nreplicate the prototype in your VF table hook, as shown in Listing 8-3 (fol-\nlow along in the VFHookExample.cpp file of the project).\nDWORD __stdcall someNewVFFunction(DWORD arg1)\n{\nu static DWORD _this;\n__asm MOV _this, ECX\n}\nListing 8-3: The start of a VF table hook\nThis function works as a hook because __thiscall only differs from\n__stdcall in that the former is given this on ECX. To reconcile this small\ndifference, the callback function uses inline assembly (denoted by __asm)\nto copy this from ECX to a static variable u. Since the static variable is actu-\nally initialized as a global, the only code that executes before MOV _this, ECX\nis the code that sets up the stack frame—and that code never touches\nECX. That ensures that the proper value is in ECX when the assembly is\nexecuted.\nNO tE If multiple threads start calling the same VF function, the someNewVFFunction()\nhook will break because _this might be modified by one call while still being used by\nanother call. I’ve never personally run into this problem, as games don’t typically\nthrow around multiple instances of critical classes between threads, but an efficient\nremedy would be to store _this in thread local storage, ensuring each thread would\nhave its own copy.\nManipulating Control Flow in a Game 157\nBefore returning, a VF table callback must also restore ECX, to keep\nwith the __thiscall convention. Here’s how that process looks:\nDWORD __stdcall someNewVFFunction(DWORD arg1)\n{\nstatic DWORD _this;\n__asm MOV _this, ECX\n// do game modifying stuff here\n__asm uMOV ECX, _this\n}\nAfter executing some game-hacking code, this version of the function\nsomeNewVFFunction() restores ECX u with a reversed version of the first MOV\ninstruction from Listing 8-3.\nUnlike with __cdecl functions, however, you shouldn’t call functions that\nuse the __thiscall convention from pure C++ using only a function pointer\nand typedef (as you would for a call hook). When calling the original func-\ntion from a VF table hook, you must use inline assembly—that’s the only\nway to be sure you’re passing data (specifically _this) around properly. For\nexample, this is how you continue to build the someNewVFFunction() hook:\nDWORD __stdcall someNewVFFunction(DWORD arg1)\n{\nstatic DWORD _this, _ret;\n__asm MOV _this, ECX\n// do pre-call stuff here\n__asm {\nPUSH arg1\nMOV ECX, _this\nu CALL [originalVFFunction]\nv MOV _ret, EAX\n}\n// do post-call stuff here\nw __asm MOV ECX, _this\nreturn _ret;\n}\nNow, someNewVFFunction() stores this in the _this variable, allows some\ncode to execute, calls the original game function u that’s being hooked,\nstores that function’s return value in _ret v, allows some more code to\nexecute, restores this to ECX w, and returns the value stored in _ret. The\ncallee cleans the stack for __thiscall calls, so unlike a call hook, the pushed\nargument doesn’t need to be removed.\n158 Chapter 8\nNO tE If you want to remove a single pushed argument at any point, use the assembly\ninstruction ADD ESP, 0x4 because a single argument is 4 bytes.\nUsing a VF table Hook\nWith the calling convention established and a skeleton callback in place, it’s\ntime to move on to the fun part: actually using a VF table hook. A pointer\nto a class’s VF table is the first member of every class instance, so placing a\nVF table hook requires only a class instance address and the index of the\nfunction to be hooked. Using these two pieces of information, you need\nonly a modest amount of code to place a hook. Here’s an example:\nDWORD hookVF(DWORD classInst, DWORD funcIndex, DWORD newFunc)\n{\nDWORD VFTable = ureadMemory<DWORD>(classInst);\nDWORD hookAt = VFTable + funcIndex * sizeof(DWORD);\nauto oldProtection =\nprotectMemory<DWORD>(hookAt, PAGE_READWRITE);\nDWORD originalFunc = readMemory<DWORD>(hookAt);\nwriteMemory<DWORD>(hookAt, newFunc);\nprotectMemory<DWORD>(hookAt, oldProtection);\nreturn originalFunc;\n}\nThe hookVF() function finds the VF table by reading the first member\nof the class instance u and storing it in VFTable. Since the VF table is just\nan array of DWORD-sized addresses, this code finds the function address by\nmultiplying the function’s index in the VF table (funcIndex in this example)\nby the size of a DWORD, which is 4, and adding the result to the VF table’s\naddress. From there, hookVF() acts similar to a call hook: it makes sure the\nmemory is properly accessible by setting appropriate protections, stores the\noriginal function address for later, writes the new function address, and\nfinally, restores the original memory protection.\nYou’ll typically hook the VF table of a class instantiated by the game,\nand calling a function like hookVF() for a VF table hook looks like this:\nDWORD origVFFunction =\nhookVF(classInstAddr, 0, (DWORD)&someNewVFFunction);\nAs usual, you need to find classInstAddr and the funcIndex argument\nahead of time.\nThere are some very niche cases in which VF table hooks are useful, and\nit can be really hard to find the right class pointers and functions. Given that,\ninstead of showing contrived use cases, I’ll come back to VF table hooks in\n“Applying Jump Hooks and VF Hooks to Direct3D” on page 175, once I’ve\ndiscussed other types of hooking.\nManipulating Control Flow in a Game 159"
  },
  {
    "input": "IAT Hooking",
    "output": "If you want to play with VF hooks before reading more, add new vir-\ntual functions to the example classes in this book’s resource files and prac-\ntice hooking them. You might even create a second class that derives from\nsomeBaseClass and place a hook on its virtual table to demonstrate how you\ncan have two completely separate VF hooks on two classes that inherit the\nsame base class.\nIAT Hooking\nIAT hooks actually replace function addresses in a specific type of VF table,\ncalled the import address table (IAT). Each loaded module in a process con-\ntains an IAT in its PE header. A module’s IAT holds a list of all the other\nmodules on which the module depends, as well as a list of functions that the\nmodule uses from each dependency. Think of an IAT as a lookup table for\nAPIs to call one another.\nWhen a module is loaded, its dependencies are also loaded. Dependency\nloading is a recursive process that continues until all dependencies for\nall modules are loaded. As each dependency is loaded, the operating sys-\ntem finds all functions used by the dependent module and fills any blank\nspaces in its IAT with the function addresses. Then, when a module calls a\nfunction from a dependency, it makes that call by resolving the function’s\naddress from the IAT.\nPaying for Portability\nFunction addresses are always resolved from the IAT in real time, so hook-\ning the IAT is similar to hooking VF tables. Since function pointers are\nstored in the IAT beside their actual names, there’s no need to do any\nreverse engineering or memory scanning; as long as you know the name\nof the API you want to hook, you can hook it! Moreover, IAT hooking lets\nyou easily hook Windows API calls on a module-specific basis, allowing your\nhooks to intercept only API calls from a game’s main module.\nThis portability has a cost, though; the code to place an IAT hook is\nmuch more complex than what you’ve seen so far. First, you need to locate\nthe PE header of the game’s main module. Since the PE header is the first\nstructure in any binary, you can find it at the base address of each module,\nas shown in Listing 8-4 (follow along in the IATHookExample.cpp file of the\nproject).\nDWORD baseAddr = (DWORD)GetModuleHandle(NULL);\nListing 8-4: Fetching the module’s base address\nOnce you’ve found the base address, you must verify that the PE header\nis valid. This validation can be very important, as some games try to prevent\nthese types of hooks by scrambling nonessential parts of their PE header after\nthey load. A valid PE header is prefixed by a DOS header, which indicates\n160 Chapter 8\nthe file is a DOS MZ executable; the DOS header is identified by the magic\nvalue 0x5A4D. A member of the DOS header called e_lfanew then points to\nthe optional header, which contains values like the size of the code, a version\nnumber, and so on and is identified by the magic value 0x10B.\nThe Windows API has PE structures called IMAGE_DOS_HEADER and\nIMAGE_OPTIONAL_HEADER that correspond to the DOS header and optional\nheader, respectively. You can use them to validate the PE header with\ncode like Listing 8-5.\nauto dosHeader = pointMemory<IMAGE_DOS_HEADER>(baseAddr);\nif (dosHeader->e_magic != 0x5A4D)\nreturn 0;\nauto optHeader =\npointMemory<IMAGE_OPTIONAL_HEADER>(baseAddr + dosHeader->e_lfanew + 24);\nif (optHeader->Magic != 0x10B)\nreturn 0;\nListing 8-5: Confirming the DOS and optional headers are valid\nThe calls to pointMemory() create pointers to the two headers that need\nto be checked. If either if() statement returns 0, then the corresponding\nheader has the wrong magic number, meaning the PE header isn’t valid.\nReferences to the IAT from assembly are hardcoded, meaning assem-\nbly references don’t traverse the PE header to locate the IAT. Instead, each\nfunction call has a static location indicating where to find the function\naddress. That means overwriting the PE header to say that there are no\nimports is a viable way to protect against IAT hooks, and some games have\nthis protection.\nTo account for that, you also need to make sure the game’s IAT still\nexists. Listing 8-6 shows how to add such a check to the code in Listing 8-5.\nauto IAT = optHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];\nif (IAT.Size == 0 || IAT.VirtualAddress == 0)\nreturn 0;\nListing 8-6: Checking that the IAT actually exists\nThe PE header contains many sections that store information about\nthe application’s code, embedded resources, relocations, and so on. The\npiece of code in Listing 8-6 is particularly interested in the data section,\nwhich—as you might guess—stores many different types of data. Each\ntype of data is stored in its own directory, and the DataDirectory member of\nIMAGE_OPTIONAL_HEADER is an array of directory headers that describes the size\nand virtual address of each directory in the data section. The Windows API\ndefines a constant called IMAGE_DIRECTORY_ENTRY_IMPORT, which happens to be\nthe index of the IAT header within the DataDirectory array.\nManipulating Control Flow in a Game 161\nThus, this code uses optHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]\nto resolve the header of the IAT and check that the header’s Size and\nVirtualAddress are nonzero, essentially confirming its existence.\ntraversing the Iat\nOnce you know the IAT is still intact, you can start traversing it, and this\nis where IAT hooking starts to get ugly. The IAT is an array of structures\ncalled import descriptors. There is one import descriptor for each depen-\ndency, each import descriptor points to an array of structures called thunks,\nand each thunk represents a function imported from the dependency.\nLuckily, the Windows API exposes both the import descriptors and\nthunks through the IMAGE_IMPORT_DESCRIPTOR and IMAGE_THUNK_DATA structures,\nrespectively. Having the structures predefined saves you from creating\nyour own, but it doesn’t make the code to traverse the IAT any prettier.\nTo see what I mean, look at Listing 8-7, which builds on Listings 8-4\nthrough 8-6.\nauto impDesc =\npointMemory<IMAGE_IMPORT_DESCRIPTOR>(ubaseAddr + IAT.VirtualAddress);\nv while (impDesc->FirstThunk) {\nw auto thunkData =\npointMemory<IMAGE_THUNK_DATA>(baseAddr + impDesc->OriginalFirstThunk);\nint n = 0;\nx while (thunkData->u1.Function) {\n// the hook happens in here\nn++;\nthunkData++;\n}\nimpDesc++;\n}\nListing 8-7: Iterating over the IAT to find a function\nKeeping in mind that the import descriptors are stored relative to the\nstart of the PE header, this code adds the module’s base address to the\nvirtual address found in the IAT’s directory header u, creating a pointer,\nimpDesc, that points to the module’s first import descriptor.\nImport descriptors are stored in a sequential array, and a descriptor\nwith a FirstThunk member set to NULL signifies the end of the array. Knowing\nthis, the code uses a while loop v that continues until impDesc->FirstThunk is\nNULL, incrementing the descriptor by executing impDesc++ each iteration.\nFor each import descriptor, the code creates a pointer called thunkData w\nthat points to the first thunk inside the descriptor. Using a familiar loop,\nthe code iterates over thunks x until one is found with a Function member\nset to NULL. The loop also uses an integer, n, to keep track of the current\nthunk index, as the index is important when placing the hook.\n162 Chapter 8\nPlacing the Iat Hook\nFrom here, placing the hook is just a matter of finding the proper function\nname and replacing the function address. You can find the name inside the\nnested while loop, as shown in Listing 8-8.\nchar* importFunctionName =\npointMemory<char>(baseAddr + (DWORD)thunkData->u1.AddressOfData + 2);\nListing 8-8: Finding the function name\nThe function name for each thunk is stored at thunkData->u1.AddressOfData\n+ 2 bytes into the module, so you can add that value to the module’s base\naddress to locate the function name in memory.\nAfter obtaining a pointer to the function name, use strcmp() to check\nwhether it’s the target function, like so:\nif (strcmp(importFuncName, funcName) == 0) {\n// the final step happens in here\n}\nOnce you’ve located the target function using its name, you simply need\nto overwrite the function address with the address of your own function.\nUnlike function names, function addresses are stored in an array at the\nstart of each import descriptor. Using n from the thunk loop, you can finally\nset the hook, as shown in Listing 8-9.\nauto vfTable = pointMemory<DWORD> (baseAddr + impDesc->FirstThunk);\nDWORD original = vfTable[n];\nu auto oldProtection = protectMemory<DWORD>((DWORD)&vfTable[n], PAGE_READWRITE);\nv vfTable[n] = newFunc;\nprotectMemory<DWORD>((DWORD)&vfTable[n], oldProtection);\nListing 8-9: Finding the function address\nThis code locates the VF table for the current descriptor by adding the\naddress of the first thunk to the module base address. The VF table is an\narray of function addresses, so the code uses the n variable as an index to\nlocate the target function address.\nOnce the address is found, the code in Listing 8-9 works just like a typi-\ncal VF hook: it stores the original function address, sets the protection of\nindex n in the VF table to PAGE_READWRITE u, inserts the new function address\ninto the VF table v, and finally restores the old protection.\nIf you stitch together the code from Listings 8-4 through 8-9, the final\nIAT hooking function looks like Listing 8-10.\nDWORD hookIAT(const char* funcName, DWORD newFunc)\n{\nDWORD baseAddr = (DWORD)GetModuleHandle(NULL);\nManipulating Control Flow in a Game 163\nauto dosHeader = pointMemory<IMAGE_DOS_HEADER>(baseAddr);\nif (dosHeader->e_magic != 0x5A4D)\nreturn 0;\nauto optHeader =\npointMemory<IMAGE_OPTIONAL_HEADER>(baseAddr + dosHeader->e_lfanew + 24);\nif (optHeader->Magic != 0x10B)\nreturn 0;\nauto IAT =\noptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];\nif (IAT.Size == 0 || IAT.VirtualAddress == 0)\nreturn 0;\nauto impDesc =\npointMemory<IMAGE_IMPORT_DESCRIPTOR>(baseAddr + IAT.VirtualAddress);\nwhile (impDesc->FirstThunk) {\nauto thunkData =\npointMemory<IMAGE_THUNK_DATA>(baseAddr + impDesc->OriginalFirstThunk);\nint n = 0;\nwhile (thunkData->u1.Function) {\nchar* importFuncName = pointMemory<char>\n(baseAddr + (DWORD)thunkData->u1.AddressOfData + 2);\nif (strcmp(importFuncName, funcName) == 0) {\nauto vfTable = pointMemory<DWORD>(baseAddr + impDesc->FirstThunk);\nDWORD original = vfTable[n];\nauto oldProtection =\nprotectMemory<DWORD>((DWORD)&vfTable[n], PAGE_READWRITE);\nvfTable[n] = newFunc;\nprotectMemory<DWORD>((DWORD)&vfTable[n], oldProtection);\nreturn original;\n}\nn++;\nthunkData++;\n}\nimpDesc++;\n}\n}\nListing 8-10: The complete IAT hooking function\nThis is the most complex code that we’ve put together so far, and\nit’s pretty hard to read when squished to fit on a page. If you haven’t yet\nwrapped your head around what it’s doing, you might want to study the\nexample code from this book’s resource files before continuing.\nUsing an Iat Hook to Sync with a Game thread\nWith the code in Listing 8-10, hooking any Windows API function is as simple\nas knowing the function name and the proper prototype. The Sleep() API is\na common API to hook when game hacking, as bots can use a Sleep() hook\nto thread-sync with a game’s main loop.\n164 Chapter 8"
  },
  {
    "input": "Jump Hooking",
    "output": "GEttING IN s yNC wItH tHrEAD syNC\nYour injected code will inevitably have to sync with a game’s main loop, or\nit won’t work. When you’re reading or writing data larger than 4 bytes, for\nexample, being out of sync allows the game to read or write that data at the\nsame time as you. You’ll be stepping on the game’s toes, and vice versa, lead-\ning to all sorts of race conditions and data corruption issues. Similarly, if you\ntry to call a game’s function from your own thread, you run the risk of crashing\nthe game if the function is not thread safe.\nSince IAT hooks are thread-safe modifications to the PE header, they can\nbe placed from any thread. By placing one on a function that’s called before\nor after the game’s main loop, you can effectively sync with the game’s main\nthread. All you need to do is place the hook and execute any thread-sensitive\ncode from your hook callback.\nHere’s one way to use hookIAT() to hook the Sleep() API:\nVOID WINAPI newSleepFunction(DWORD ms)\n{\n// do thread-sensitive things\noriginalSleep(ms);\n}\ntypedef VOID (WINAPI _origSleep)(DWORD ms);\n_origSleep* originalSleep =\n(_origSleep*)hookIAT(\"Sleep\", (DWORD)&newSleepFunction);\nHere’s why this works. At the end of a game’s main loop, it might call\nSleep() to rest until it’s ready to draw the next frame. Since it’s sleeping, it’s\nsafe for you to do anything you want without worrying about synchroniza-\ntion issues. Some games might not do this, or they might call Sleep() from\nmultiple threads, and those games will require a different method.\nA more portable alternative is to hook the PeekMessageA() API function,\nbecause games often call that function from the main loop while waiting\nfor input. Then, your bot can do thread-sensitive operations from within\nthe PeekMessageA() hook, ensuring that they’re done from the game’s main\nthread. You may also want your bot to use this method to hook the send()\nand recv() API functions, as intercepting these allows you to create a packet\nsniffer relatively simply.\nJump Hooking\nJump hooking allows you to hook code in places where there is no branch-\ning code to manipulate. A jump hook replaces the code being hooked\nwith an unconditional jump to a trampoline function. When the jump is hit,\nManipulating Control Flow in a Game 165\nthe trampoline function stores all current register and flag values, calls a\ncallback function of your choice, restores the registers, restores the flags,\nexecutes the code that was replaced by the hook, and finally jumps back to\nthe code just below the hook. This process is shown in Figure 8-1.\nOriginal Code Hooked Code Trampoline Callback\nSUB EAX, 1 SUB EAX, 1 PUSHFD // do stuff\nADD EBX, EAX ADD EBX, EAX PUSHAD RETN\nPUSH EBX PUSH EBX CALL callback\nMOV ECX ESI MOV ECX, ESI POPAD\nCALL function CALL function POPFD\nPOP EAX JMP trampoline POP EAX\nMOV AL, 1 RETN MOV AL, 1\nPOP EDI POP EDI\nPOP ESI POP ESI\nRETN JMP restore\nFigure 8-1: A jump hook\nThe original code shows an example of some unmodified assembly you\nmight find in a game, and the hooked code shows how that assembly might\nlook after being hooked by a jump hook. The trampoline box shows an\nexample trampoline function, in assembly, and the callback represents the\ncode you’re trying to execute through hooking. In the original code, the\nassembly executes from top to bottom. In the hooked code, to get from the\nSUB EAX,1 instruction to the RETN instruction, execution must follow the path\nshown by the dashed arrows.\nNO tE If your callback code is simple, it can be integrated into the trampoline instead. It’s\nalso not always necessary to store and restore the registers and flags, but doing so is\ngood practice.\nPlacing a Jump\nThe byte code of an unconditional jump resembles that of a near call, but\nthe first byte is 0xE9 instead of 0xE8. (See “Working with Near Calls in\nMemory” on page 153 for a refresher.) In Figure 8-1, the unconditional\njump JMP trampoline replaces the following four operations:\nPOP EAX\nMOV AL, 1\nPOP EDI\nPOP ESI\nIn this case, you need to replace multiple sequential operations to\naccommodate the 5-byte size of the unconditional jump. You may come\nacross cases where the size of the operation (or operations) being replaced\nis larger than 5 bytes. When this happens, replace the remaining bytes with\nNOP instructions.\n166 Chapter 8\nNow, let’s look at how to replace those operations. Listing 8-11 shows\nthe code to place a jump hook.\nDWORD hookWithJump(DWORD hookAt, DWORD newFunc, int size)\n{\nif (size > 12) // shouldn't ever have to replace 12+ bytes\nreturn 0;\nu DWORD newOffset = newFunc - hookAt - 5;\nauto oldProtection =\nprotectMemory<DWORD[3]>(hookAt + 1,PAGE_EXECUTE_READWRITE);\nv writeMemory<BYTE>(hookAt, 0xE9);\nw writeMemory<DWORD>(hookAt + 1, newOffset);\nfor (unsigned int i = 5; i < size; i++)\nwriteMemory<BYTE>(hookAt + i, 0x90);\nprotectMemory<DWORD[3]>(hookAt + 1, oldProtection);\nreturn hookAt + 5;\n}\nListing 8-11: How to place a jump hook\nThis function takes the address to hook at, the address of the callback\nfunction, and the size of the memory to overwrite (in bytes) as arguments.\nFirst, it calculates the offset between the hook site and the trampoline and\nstores the result in newOffset u. Next, PAGE_EXECUTE_READWRITE permissions are\napplied to the memory to be changed. The unconditional jump (0xE9) v\nand the address of the callback function w are then written to memory,\nand a for loop writes NOP instructions (0x90) to any abandoned bytes.\nAfter the old protections are reapplied, hookWithJump() returns to the origi-\nnal address.\nNotice that the hookWithJump() function ensures that size is not above 12\nbefore placing the jump. This check is important because a jump takes up 5\nbytes, meaning it can replace up to five commands if the first four are each\na single byte. If the first four commands are each a single byte, the fifth\ncommand would need to be more than 8 bytes to trigger the if (size > 12)\nclause. Because 9-byte operations are very, very rare, 12 is a safe but flexible\nlimit. Having this limit can stop all sorts of bugs from happening, especially\nif your bot is dynamically detecting the size parameter. If the bot messes up\nand passes a size of 500,000,000, for instance, the check will stop you from\nNOPing the whole universe.\nWriting the trampoline Function\nUsing the function in Listing 8-11, you can replicate the hook shown in\nFigure 8-1, but first you’ll have to create the trampoline function as follows:\nDWORD restoreJumpHook = 0;\nvoid __declspec(naked) myTrampoline()\n{\nManipulating Control Flow in a Game 167\n__asm {\nu PUSHFD\nv PUSHAD\nw CALL jumpHookCallback\nx POPAD\ny POPFD\nz POP EAX\nMOV AL, 1\nPOP EDI\n{ POP ESI\n| JMP [restoreJumpHook]\n}\n}\nJust like the trampoline described alongside Figure 8-1, this trampoline\nstores all current flag u and register values v, calls a callback function w,\nrestores the registers x, restores the flags y, executes the code that was\nreplaced by the hook at z and {, and finally jumps back to the original\ncode just below the jump and NOPs |.\nNO tE To ensure that the compiler doesn’t autogenerate any extra code within the trampoline,\nalways declare the trampoline using the __declspec(naked) convention.\nFinishing the Jump Hook\nOnce you create the trampoline, define the callback and set the hook\nlike so:\nvoid jumpHookCallback() {\n// do stuff\n}\nrestoreJumpHook = hookWithJump(0xDEADBEEF, &myTrampoline, 5);\nFinally, inside the jumpHookCallback() function, execute the code that\nrelies on the hook. If your code needs to read or write the values of the\nregisters as they were when the hook executed, you’re in luck. The PUSHAD\ncommand pushes them to the stack in the order EAX, ECX, EDX, EBX,\noriginal ESP, EBP, ESI, and EDI. The trampoline calls PUSHAD directly before\nthe jumpHookCallback() call, so you can reference the register values as argu-\nments, like this:\nvoid jumpHookCallback(DWORD EDI, DWORD ESI, DWORD EBP, DWORD ESP,\nDWORD EBX, DWORD EDX, DWORD ECX, DWORD EAX) {\n// do stuff\n}\nrestoreJumpHook = hookWithJump(0xDEADBEEF, &myTrampoline, 5);\nSince the trampoline uses POPAD to directly restore the registers from\nthese values on the stack, any modifications you make to the parameters\nwill be applied to the actual registers when they are restored from the\nstack.\n168 Chapter 8"
  },
  {
    "input": "Accessing the RTMP Goldmine",
    "output": "Like VF table hooks, jump hooks are rarely needed, and they can\nbe tricky to simulate with a simple example. To help you wrap your head\naround them, I’ll explore a real-world, practical use case in “Applying Jump\nHooks and VF Hooks to Direct3D” on page 175.\nPrOfEssIONAl API HOOKING lIBrArIEs\nThere are prewritten hooking libraries, like Microsoft’s Detours and MadCHook,\nthat use only jump hooks. These libraries can automatically detect and follow\nother hooks, they know how many instructions to replace, and they generate\ntrampoline functions for you. The libraries are able to do this because they\nunderstand how to disassemble and walk through assembly instructions to deter-\nmine lengths, jump destinations, and so on. If you need to use hooks with that\nmuch power, it is arguably better to use one of those libraries than to create\nyour own.\napplying call Hooks to adobe aiR\nAdobe AIR is a development framework that can be used to make cross-\nplatform games in an environment similar to Abode Flash. AIR is a\ncommon framework for online games, as it allows developers to write\ncross-platform code in a versatile, high-level language called ActionScript.\nActionScript is an interpreted language, and AIR runs the code inside a\nvirtual machine, which makes it infeasible to hook game-specific code with\nAIR. Instead, it is easier to hook AIR itself.\nThe example code for this section can be found in GameHackingExamples/\nChapter8_AdobeAirHook in this book’s source files. The code comes from an\nold project of mine, and it works on any game running Adobe AIR.dll version\n3.7.0.1530. I’ve gotten it working on other versions as well, but I can’t guar-\nantee it will work with much newer or much older versions, so treat this as a\ncase study.\nAccessing the RTMP Goldmine\nThe Real Time Messaging Protocol (RTMP) is a text-based network protocol\nthat ActionScript uses to serialize and send entire objects over the network.\nRTMP sits on top of the HyperText Transfer Protocol (HTTP), and a secure\nversion, RTMPS, sits on top of HTTP Secure (HTTPS). RTMPS allows game\ndevelopers to easily send and receive entire object instances over a secure\nconnection with little complication, making it the network protocol of\nchoice for any games running on AIR.\nNO tE Data sent over RTMP/RTMPS is serialized through Action Message Format\n(AMF), and parsing AMF packets is beyond the scope of this book. Search online for\n“AMF3 Parser,” and you’ll find a lot of code that does it.\nManipulating Control Flow in a Game 169\nData sent over RTMP and RTMPS is very rich. The packets contain\ninformation about object types, names, and values. This is a gold mine. If\nyou can intercept this data in real time, you can instantaneously respond\nto changes in game state, see a wealth of critical information without ever\nreading it from memory, and find useful pieces of data that you might not\neven know exist.\nA while back, I was working on a tool that required a ton of insight into\nthe state of a game. Obtaining such a large amount of data directly from\nmemory would have been extremely hard, if not impossible. After some\nresearch, I realized that the game was using RTMPS to communicate with\nthe server, and that prompted me to start digging into this gold mine.\nSince RTMPS is encrypted, I knew I had to somehow hook the cryp-\ntographic functions used by AIR before I could get any usable data. After\nsearching online, I found source code for a small tool called airlog, created\nby another game hacker who, like me, was trying to log packets sent over\nRTMPS. Although the tool hooked the exact functions I needed, the code\nwas outdated, messy, and, worst of all, didn’t work on the version of AIR\nI was trying to hook.\nBut that didn’t mean it was useless. Not only did airlog hook the two\nfunctions I needed, but it also located them by scanning for certain byte\npatterns within the Adobe AIR library. These byte patterns were three years\nold, though, so they weren’t working anymore. The newer versions of Adobe\nAIR had changed enough that the assembly bytes were no longer the same.\nThe difference in bytes was a problem for the code in airlog, but not for me.\nInside an inline assembly block, you can specify raw bytes with the fol-\nlowing function call:\n_emit BYTE\nIf you replace BYTE with, say, 0x03, the code will be compiled in a way\nthat treats 0x03 as a byte in the assembly code, regardless of whether that\nmakes sense. Using this trick, I compiled the byte arrays back to assembly\ncode. The code didn’t do anything, and it wasn’t meant to; using this trick\nsimply allowed me to attach to my dummy application with OllyDBG and\ninspect bytes, which were conveniently presented as a clean disassembly.\nSince these bytes represented the code surrounding the functions I\nneeded, so, too, did their disassembly. The code was pretty standard and\ndidn’t seem likely to change, so I turned my attention to the constants. The\ncode had a few immediate values passed as offsets in commands. Knowing\nhow commonly these can change, I rewired airlog’s pattern-matching algo-\nrithm to support wildcards, updated the patterns to treat any constants as\nwildcards, and then ran the match. After some tweaks to the patterns and\na bit of digging through duplicate search results, I tracked down the func-\ntions I wanted to hook. I appropriately named them encode() and decode()\nand began working on a tool similar to airlog—but better.\n170 Chapter 8"
  },
  {
    "input": "Hooking the RTMPS encode() Function",
    "output": "Hooking the RTMPS encode() Function\nI discovered that the encode() function, which is used to encrypt the data for\noutgoing packets, is a nonvirtual __thiscall, meaning it’s called by a near\ncall. Moreover, the call happens inside a loop. The entire loop looks like\nListing 8-12, taken directly from the OllyDBG disassembly pane.\nloop:\nMOV EAX, [ESI+3C58]\nSUB EAX,EDI\nPUSH EAX\nu LEA EAX, [ESI+EDI+1C58]\nPUSH EAX\nMOV ECX,ESI\nv CALL encode\nCMP EAX,-1\nw JE SHORT endLoop\nADD EDI,EAX\nx CMP EDI, [ESI+3C58]\nJL loop\nendLoop:\nListing 8-12: The encode() loop\nWith a bit of analysis and some guidance from airlog, I determined\nthat the encode() function called at u takes a byte array and buffer length\n(let’s call them buffer and size, respectively) as parameters. The function\nreturns -1 when it fails and returns size otherwise. The function operates\non chunks of 4,096 bytes, which is why this happens in a loop.\nTurned into more readable pseudocode, the loop calling encode()\nlooks like this (the numbers refer to the relevant assembly instructions\nin Listing 8-12):\nfor (EDI = 0; EDI < x[ESI+3C58]; ) {\nEAX = vencode(u&[ESI+EDI+1C58], [ESI+3C58] - EDI);\nif (EAX == -1) wbreak;\nEDI += EAX;\n}\nI wasn’t interested in what encode() did, but I needed the entire buffer\nit was looping over, and hooking encode() was my means of getting that buf-\nfer. Looking at the real loop in Listing 8-12, I knew that the calling object\ninstance’s full buffer was stored at ESI+0x1C58, that the full size was stored\nat ESI+0x3C58, and that EDI contained the loop counter. I devised the\nhook with these things in mind, ultimately creating a two-part hook.\nThe first part of my hook was a reportEncode() function that logs the\nentire buffer on the first loop iteration. Here’s the reportEncode() function\nin full:\nDWORD __stdcall reportEncode(\nconst unsigned char* buffer,\nunsigned int size,\nManipulating Control Flow in a Game 171"
  },
  {
    "input": "Hooking the RTMPS decode() Function",
    "output": "unsigned int loopCounter)\n{\nif (loopCounter == 0)\nprintBuffer(buffer, size);\nreturn origEncodeFunc;\n}\nThis function takes buffer, size, and loopCounter as parameters and\nreturns the address of the function I dubbed encode(). Before fetching that\naddress, however, the second part of my hook, a myEncode() function, does all\nof the dirty work to obtain buffer, size, and loopCounter, as follows:\nvoid __declspec(naked) myEncode()\n{\n__asm {\nMOV EAX, DWORD PTR SS:[ESP + 0x4] // get buffer\nMOV EDX, DWORD PTR DS:[ESI + 0x3C58] // get full size\nPUSH ECX // store ecx\nPUSH EDI // push current pos (loop counter)\nPUSH EDX // push size\nPUSH EAX // push buffer\nCALL reportEncode // report the encode call\nPOP ECX // restore ecx\nJMP EAX // jump to encode\n}\n}\nThe myEncode() function is a pure assembly function that replaces the\noriginal encode() function call using a near call hook. After storing ECX on\nthe stack, myEncode() obtains buffer, size, and loopCounter and passes them\nto the reportEncode() function. After calling the reportEncode() function, the\nmyEncode() function restores ECX and jumps directly into encode(), causing\nthe original function to execute and return gracefully to the loop.\nSince myEncode() cleans everything it uses from the stack, the stack still\ncontains the original parameters and return address in the correct spot\nafter myEncode() runs. That’s why myEncode() jumps directly into encode()\ninstead of using a function call: that stack is already set up with the proper\nreturn address and parameters, so the encode() function will think every-\nthing happened as normal.\nHooking the RTMPS decode() Function\nThe function I named decode(), which is used to decrypt incoming data,\nwas also a __thiscall that was called in a loop. It worked on chunks of\n4,096 bytes and took a buffer and size as parameters. The loop was quite\na bit more complex, containing multiple function calls, nested loops, and\nloop escapes, but hooking worked much the same as hooking the so-called\nencode() function. The reason for the added complexity is not relevant to\nhooking the function, but it makes the code difficult to summarize, so I won’t\nshow the original function here. The bottom line is this: once all the com-\nplexity was rubbed away, the decode() loop was the encode() loop in reverse.\n172 Chapter 8"
  },
  {
    "input": "Placing the Hooks",
    "output": "Once again, I devised a two-part near call hook. The first part,\nreportDecode(), is shown here:\nvoid __stdcall reportDecode(const unsigned char* buffer, unsigned int size)\n{\nprintBuffer(buffer, size);\n}\nThe function logs each packet that comes through. I didn’t have a loop\nindex at the time, so I decided that it was okay to log every single partial\npacket.\nThe second part of the hook, the myDecode() function, acts as the new\ncallee and does all of the dirty work, as follows:\nvoid __declspec(naked) myDecode()\n{\n__asm {\nMOV EAX, DWORD PTR SS:[ESP + 0x4] // get buffer\nMOV EDX, DWORD PTR SS:[ESP + 0x8] // get size\nPUSH EDX // push size\nPUSH EAX // push buffer\nu CALL [origDecodeFunc]\nMOV EDX, DWORD PTR SS:[ESP + 0x4] // get the buffer\nPUSH EAX // store eax (return value)\nPUSH ECX // store ecx\nPUSH EAX // push size\nPUSH EDX // push buffer\nCALL reportDecode // report the results now\nPOP ECX // restore ecx\nv POP EAX // restore eax (return value)\nw RETN 8 // return and clean stack\n}\n}\nI knew the buffer was decrypted in place, meaning the encrypted chunk\nwould be overwritten with the decrypted one once the call to decode() was\ncomplete. This meant that myDecode() had to call the original decode() func-\ntion u before calling the reportDecode() function, which would give the\nresults of the decoding. Ultimately, myDecode() also needed to return with\nthe same value that the original decode() function would and clean up the\nstack, and the final POP v and RETN w instructions took care of that.\nPlacing the Hooks\nThe next problem I ran into was that the hooks were for code inside the\nmodule Adobe AIR.dll, which was not the main module of the game. Because\nof the code’s location, I needed to find the base addresses for the hooks\na bit differently. Additionally, since I needed these hooks to work across a\nfew different versions of Adobe AIR, I also had to find the right addresses\nManipulating Control Flow in a Game 173\nfor each version. Instead of trying to get my hands on all of the different\nversions of Adobe AIR, I took another page out of airlog’s playbook and\ndecided to programmatically locate the addresses by writing a small mem-\nory scanner. Before I could write the memory scanner, I needed both the\nbase address and size of Adobe AIR.dll so I could limit my memory search to\nonly that area.\nI found these values using Module32First() and Module32Next() as follows:\nMODULEENTRY32 entry;\nentry.dwSize = sizeof(MODULEENTRY32);\nHANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, NULL);\nDWORD base, size;\nif (Module32First(snapshot, &entry) == TRUE) {\nu while (Module32Next(snapshot, &entry) == TRUE) {\nstd::wstring binaryPath = entry.szModule;\nv if (binaryPath.find(\"Adobe AIR.dll\") != std::wstring::npos) {\nsize = (DWORD)entry.modBaseSize;\nbase = (DWORD)entry.modBaseAddr;\nbreak;\n}\n}\n}\nCloseHandle(snapshot);\nThis code loops through all modules in the process until it finds\nAdobe AIR.dll u. When it finds the correct module entry v, it fetches the\nmodBaseSize and modBaseAddr properties from it and breaks out immediately.\nThe next step was finding a sequence of bytes I could use to identify the\nfunctions. I decided to use the byte code surrounding each call. I also had\nto make sure that each sequence was unique while avoiding the use of any\nconstants in the patterns to ensure the code’s portability. Listing 8-13 shows\nthe byte sequences I ended up with.\nconst char encodeSeq[16] = {\n0x8B, 0xCE, // MOV ECX, ESI\n0xE8, 0xA6, 0xFF, 0xFF, 0xFF, // CALL encode\n0x83, 0xF8, 0xFF, // CMP EAX, -1\n0x74, 0x16, // JE SHORT endLoop\n0x03, 0xF8, // ADD EDI, EAX\n0x3B, 0xBE}; // part of CMP EDI, [ESI+0x3C58]\nconst char decodeSeq[12] = {\n0x8B, 0xCE, // MOV ECX, ESI\n0xE8, 0x7F, 0xF7, 0xFF, 0xFF, // CALL decode\n0x83, 0xF8, 0xFF, // CMP EAX, -1\n0x89, 0x86}; // part of MOV [ESI+0x1C54], EAX\nListing 8-13: The encode() and decode() byte sequences\n174 Chapter 8"
  },
  {
    "input": "Applying Jump Hooks and VF Hooks to Direct3D",
    "output": "Notice the CALL instruction in each pattern; these are the calls to the\nAdobe AIR functions I named encode() and decode(). I scanned for these\nsequences with the following function:\nDWORD findSequence(\nDWORD base, DWORD size,\nconst char* sequence,\nunsigned int seqLen){\nfor (DWORD adr = base; adr <= base + size – seqLen; adr++) {\nif (memcmp((LPVOID)sequence, (LPVOID)adr, seqLen) == 0)\nreturn adr;\n}\nreturn 0;\n}\nTreating the memory of Adobe AIR.dll as a byte array, the findSequence()\nfunction looks for a sequence of bytes as a subset of that byte array and\nreturns the address of the first match it finds. With the findSequence() func-\ntion written, finding the addresses I needed to hook encode() and decode()\nwas simple. Here’s how those calls looked:\nDWORD encodeHookAt =\nfindSequence(base, size, encodeSeq, 16) + 2;\nDWORD decodeHookAt =\nfindSequence(base, size, decodeSeq, 12) + 2;\nSince each target call was 2 bytes into its receptive search sequence,\nall I had to do was locate each sequence and add 2. After that, the final\nstep was to place the hooks using the method described in “Call Hooking”\non page 153.\nWith my hook finished, I could see every single piece of data that went\nbetween the game’s client and server. Moreover, since the RTMPS protocol\nsends serialized ActionScript objects, the data was basically self-document-\ning. Every single piece of information was accompanied by a variable name.\nEvery variable existed as a member of a well-described object. Every object\nhad a consistent name. Like I said—it was a gold mine.\napplying Jump Hooks and vF Hooks to direct3d\nUnlike the Adobe AIR hook I just described, hooks for Direct3D (the 3D\ngraphics component of Microsoft’s DirectX API) are very common and\nhighly documented. Direct3D is ubiquitous in the world of gaming: a major-\nity of PC games use the library, which means that hooking it gives you a\nvery powerful method for intercepting data and manipulating the graphics\nlayers of many different games. You can use a Direct3D hook for a number\nManipulating Control Flow in a Game 175"
  },
  {
    "input": "The Drawing Loop",
    "output": "of tasks, such as detecting locations of hidden enemy players, increasing\nthe lighting of dark in-game environments, and seamlessly displaying\nadditional graphical information. Making effective use of a Direct3D hook\nrequires you to learn about the API, but there’s more than enough informa-\ntion in this book to get you started.\nIn this section, I’ll give you a high-level introduction to a game loop that\nuses Direct3D before diving right into the implementation of a Direct3D\nhook. Rather than detailing the internals and giving you the analytical\nbackstory as I did with the Adobe AIR hook, I’ll go over the most popular\nDirect3D hook method, as it is well documented and used by the majority\nof game hackers.\nThe online resources for this book include two pieces of example code\nfor this section; find those files now if you want to follow along. The first\npart, an example Direct3D 9 application for you to hack on, can be found\nunder GameHackingExamples/Chapter8_Direct3DApplication. The second part,\nthe actual hook, is under Chapter8_Direct3DHook.\nThere are multiple versions of Direct3D in use at any given time,\nand there are ways to hook each one. For this book, I’ll focus on hooking\nDirect3D 9, because it is the only commonly used version that is supported\nby Windows XP.\nNO tE Even though XP has reached end of life, many people in less developed countries still\nuse it as a primary gaming system. Direct3D 9 works on all versions of Windows and\nis nearly as powerful as its successors, so many game companies still prefer to use it\nover newer versions that don’t have as much backward compatibility.\nThe Drawing Loop\nLet’s jump right in with a crash course on how Direct3D works. Inside a\nDirect3D game’s source code, you’ll find an infinite loop that processes\ninput and renders graphics. Each iteration in this drawing loop is called a\nframe. If we cut out all the extraneous code and focus simply on a bare skele-\nton, we can visualize a game’s main loop with the following code:\nint WINAPI WinMain(args)\n{\n/* Some code here would be called\nto set up Direct3D and initialize\nthe game. Leaving it out for brevity. */\nMSG msg;\nwhile(TRUE) {\n/* Some code would be here to handle incoming\nmouse and keyboard messages. */\ndrawFrame(); // this is the function we care about\n}\n/* Some code here would be called to\nclean up everything before exiting. */\n}\n176 Chapter 8"
  },
  {
    "input": "Finding the Direct3D Device",
    "output": "This function is the entry point of the game. Simply put, it initial-\nizes the game and then enters the game’s main loop. Inside the main\nloop, it executes code responsible for processing user input before calling\ndrawFrame() to redraw the screen using Direct3D. (Check out the code in\nGameHackingExamples/Chapter8_Direct3DApplication to see a fully functional\ngame loop.)\nEach time it is called, the drawFrame() function redraws the entire\nscreen. The code looks something like this:\nvoid drawFrame()\n{\nu device->Clear(0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0, 0, 0), 1.0f, 0);\ndevice->BeginScene();\n// drawing will happen here\ndevice->EndScene();\ndevice->Present(NULL, NULL, NULL, NULL);\n}\nAfter clearing the screen with device->Clear u, the drawFrame() function\ncalls device->BeginScene() to unlock the scene for drawing. It then executes\nsome drawing code (what that drawing code actually does isn’t important\nright now) and locks the scene with a device->EndScene() call. To finish up, it\nrenders the scene to the screen by calling the device->Present() function.\nNotice that all of these functions are called as members of some\ninstance called device. This is simply an object instance representing the\nDirect3D device, which is used to invoke all sorts of drawing calls. Also,\nnotice that this function is devoid of any actual drawing code, but that’s\nokay. It’s really only important for you to understand the high-level con-\ncepts of drawing loops, frames, and the Direct3D device. To recap, games\nhave a main loop with two responsibilities:\n• Handling incoming messages\n• Drawing the game to the screen\nEach iteration in this loop is called a frame, and each frame is drawn by\na device. Taking control of the device gives you access to the most sensitive\nand descriptive details of the game’s state; that is, you’ll be able to peek into\nthe game’s state after the data has been parsed, processed, and rendered\nto the screen. Moreover, you’ll be able to modify the output of this state.\nThese two superpowers enable you to pull off all kinds of awesome hacks.\nFinding the Direct3D Device\nTo take control of a Direct3D device, you hook the member functions in the\ndevice’s VF table. Unfortunately, however, using the Direct3D API to instan-\ntiate your own instance of the same device class from injected code doesn’t\nmean you’ll share a VF table with the game’s instance. Direct3D devices use\nManipulating Control Flow in a Game 177\na customized runtime implementation of VF tables, and each device gets its\nown unique VF table. Additionally, devices sometimes rewrite their own VF\ntables, removing any hooks and restoring the original function addresses.\nBoth of these Direct3D quirks leave you with one inevitable option: you\nmust find the address of the game’s device and modify its VF table directly.\nHere’s how:\n1. Create a Direct3D device and traverse its VF table to locate the true\naddress of EndScene().\n2. Place a temporary jump hook on EndScene().\n3. When the jump hook callback is executed, store the address of the\ndevice that was used to call the function, remove the hook, and restore\nexecution normally.\n4. From there, use VF hooks to hook any member function of the\nDirect3D device.\nJump Hooking EndScene()\nSince every device will call EndScene() at the end of each frame, you can\nhook EndScene() using a jump hook and intercept the game’s device from\nyour hook callback. Unique devices may have their own unique VF tables,\nbut the different tables still point to the same functions, so you can find the\naddress of EndScene() in the VF table of any arbitrary device. Using standard\nDirect3D API calls, you can create your own device like this:\nLPDIRECT3D9 pD3D = Direct3DCreate9(D3D_SDK_VERSION);\nif (!pD3D) return 0;\nD3DPRESENT_PARAMETERS d3dpp;\nZeroMemory( &d3dpp, sizeof(d3dpp) );\nd3dpp.Windowed = TRUE;\nd3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;\nd3dpp.hDeviceWindow = hWnd;\nLPDIRECT3DDEVICE9 device;\nHRESULT res = pD3D->CreateDevice(\nD3DADAPTER_DEFAULT,\nD3DDEVTYPE_HAL,\nhWnd,\nD3DCREATE_SOFTWARE_VERTEXPROCESSING,\n&d3dpp, &device);\nif (FAILED(res)) return 0;\nExplaining how everything in Direct3D works is outside the scope of\nthis book, so just know that you can copy this code to create a Direct3D\ndevice that contains the EndScene() function as a member. The EndScene()\naddress is at index 42 in the VF table of device (see “The Meaning of Device,\n178 Chapter 8\nDirect3D, and VF Hooks” box to learn how to find that index), and you can\nread it using a subset of the VF table hooking code from “Using a VF Table\nHook” on page 159, as follows:\nDWORD getVF(DWORD classInst, DWORD funcIndex)\n{\nDWORD VFTable = readMemory<DWORD>(classInst);\nDWORD hookAddress = VFTable + funcIndex * sizeof(DWORD);\nreturn readMemory<DWORD>(hookAddress);\n}\nDWORD EndSceneAddress = getVF((DWORD)device, 42);\nOnce you’ve obtained the address, your discovery device has served its\npurpose, and it can be destroyed with a call to the Release() function:\npD3D->Release();\ndevice->Release();\nWith the address of EndScene() in hand, you’d be ready to start thinking\nabout how to place your hook in memory. But since you just have a function\naddress, your only option is to place a jump hook at the top of the function.\ntHE MEANING Of DEVICE, DIrECt3D, AND Vf HOOKs\nIf you’re wondering how I know that the index of the EndScene() function is 42,\nyou’ve come to the right box. Since Direct3D 9 is a freely available library, you\ncan actually see quite a bit of what goes on under the hood. The main header\nfile for the library is d3d9.h. If you open this file in your editor and search for\n“EndScene,” you’ll end up in the middle of a large class definition that speci-\nfies several functions using C macros. This is the base class for all Direct3D 9\ndevice implementations, and it defines the virtual functions used by the class.\nThe VF table is constructed in the same order as the functions are defined\nin code, so you can determine the index of any member function by simply\ncounting the lines. You can scroll to the top of the class definition (at line 426 in\nmy version of the library, and probably yours too), note the line where the first\nfunction is declared (line 429), and then scroll to the EndScene() definition and\nnote that line (line 473). Finally, count the number of blank or commented lines\n(two for me) and do some math: 473 – 429 – 2 = 42.\nPresto! The EndScene() function is the 43rd function declared, so it sits\nat the 42nd spot in the VF table. Another advantage to having this header is\nthat you can see the name, argument types, argument names, and return type\nof every single function in the device class. So when you’re writing your own\nhooks in the future, you’ll know exactly where to look.\nManipulating Control Flow in a Game 179\nPlacing and removing the Jump Hook\nSince you’re just using the hook to find the device, you need to call it only\nonce. After obtaining the device, you’ll remove the jump hook and restore\nexecution back to the start of EndScene() so that the drawing loop can carry\non its work. Believe it or not, this makes your life much easier. Since the\ncode will be restored immediately, there’s no need for your trampoline to\nexecute the commands that are replaced by the jump, and there’s no need\nto pad the jump with NOPs. All you need to do is store the original bytes\nand place the hook. To do so, you use a slightly tweaked version of the\njump-hooking code from Listing 8-11:\nunsigned char* hookWithJump(DWORD hookAt, DWORD newFunc)\n{\nDWORD newOffset = newFunc - hookAt - 5;\nu auto oldProtection = protectMemory<BYTE[5]>(hookAt, PAGE_EXECUTE_READWRITE);\nunsigned char* originals = new unsigned char[5];\nfor (int i = 0; i < 5; i++)\nv originals[i] = readMemory<unsigned char>(hookAt + i);\nw writeMemory<BYTE>(hookAt, 0xE9);\nwriteMemory<DWORD>(hookAt + 1, newOffset);\nprotectMemory<BYTE[5]>(hookAt, oldProtection);\nreturn originals;\n}\nLike the function in Listing 8-11, this function makes the memory writ-\nable u, places the hook w, and restores the memory protection. Before\nplacing the hook, it allocates a 5-byte buffer called originals v and fills it\nwith the original bytes. After the hook is placed, it returns originals to the\ncalling function.\nWhen it’s time to remove the hook, pass originals to the following\nfunction:\nvoid unhookWithJump(DWORD hookAt, unsigned char* originals)\n{\nauto oldProtection = protectMemory<BYTE[5]>(hookAt, PAGE_EXECUTE_READWRITE);\nfor (int i = 0; i < 5; i++)\nwriteMemory<BYTE>(hookAt + i, originals[i]);\nprotectMemory<BYTE[5]>(hookAt, oldProtection);\ndelete [] originals;\n}\nThis code simply iterates over originals and quietly places those 5 bytes\nback where they were found so that everything is as expected when execu-\ntion returns to the EndScene() function. When the time comes, you can place\nand remove your actual hook using two lines of code, like this:\nauto originals = hookWithJump(EndSceneAddress, (DWORD)&endSceneTrampoline);\nunhookWithJump(EndSceneAddress, originals);\n180 Chapter 8\nOnce you have the hookWithJump() and unhookWithJump() functions, it’s\ntime to prepare the callback and find the device.\nWriting the Callback and trampoline\nEven though you can obtain the EndScene() address from a VF table, the\nEndScene() function doesn’t actually follow the __thiscall convention. Direct3D\nclasses are simple wrappers around a C API, and all of the member function\ncalls are forwarded to __stdcall functions that take a class instance as a first\nparameter. This means that your trampoline only needs to grab the device\nfrom the stack, pass it to the callback, and then jump back to EndScene().\nThe callback only has to remove the jump hook before returning to the\ntrampoline.\nThe final code for the callback and trampoline to this jump hook looks\nsomething like this:\nLPDIRECT3DDEVICE9 discoveredDevice;\nDWORD __stdcall reportInitEndScene(LPDIRECT3DDEVICE9 device)\n{\ndiscoveredDevice = device;\nunhookWithJump(EndSceneAddress, originals);\nreturn EndSceneAddress;\n}\n__declspec(naked) void endSceneTrampoline()\n{\n__asm {\nMOV EAX, DWORD PTR SS:[ESP + 0x4]\nPUSH EAX // give the device to the callback\nu CALL reportInitEndScene\nJMP EAX // jump to the start of EndScene\n}\n}\nUsing the hookWithJump() function, you can place a jump hook on\nEndScene() that calls the endSceneTrampoline() function. When the game’s\ndevice calls the EndScene() function, the trampoline function calls the\nreportInitEndScene() function u. The reportInitEndScene() function stores the\ncaptured device pointer to a global variable called discoveredDevice, removes\nthe hook by calling unhookWithJump(), and returns the address of EndScene()\nto the trampoline. To finish up, the trampoline jumps directly to EAX, which\nwill be holding the address that was returned from the reporting function.\nNO tE You can use jump hooks to completely skip the VF table hooking that I’ll show you,\nbut it’s very unreliable to use “dumb” jump hooks on commonly hooked API func-\ntions. Consistently obtaining good results with only jump hooks requires professional\nhooking libraries, and I’d rather teach you how to do it completely on your own.\nAt this point, all that’s left to do is hook the VF table of discoveredDevice\nto hack the game. The next two sections will walk you through hooks on the\nEndScene() and Reset() functions, which are required if you want a stable hook.\nManipulating Control Flow in a Game 181"
  },
  {
    "input": "Writing a Hook for EndScene()",
    "output": "Writing a Hook for EndScene()\nA hook on EndScene() is useful because it allows you to intercept a com-\npleted frame just before it is rendered; you can effectively execute your own\nrendering code inside the game loop. As you saw when locating this func-\ntion’s address in “Jump Hooking EndScene()” on page 178, this function\nis at index 42 in the VF table. You can hook EndScene() using a VF hook as\nfollows:\ntypedef HRESULT (WINAPI* _endScene)(LPDIRECT3DDEVICE9 pDevice);\n_endScene origEndScene =\n(_endScene)hookVF((DWORD)discoveredDevice, 42,(DWORD)&myEndScene);\nHRESULT WINAPI myEndScene(LPDIRECT3DDEVICE9 pDevice)\n{\n// draw your own stuff here\nreturn origEndScene(pDevice);\n}\nThis code uses the hookVF() function from “Using a VF Table Hook” on\npage 159 to hook EndScene() at index 42 of discoveredDevice, using myEndScene()\nas the callback function. A direct Direct3D device will occasionally repatch\nits own VF table and restore the original function addresses. This typically\nhappens from within the EndScene() function, meaning you also have to\nrepatch the VF table after calling the original EndScene() function. There\nare a few changes you can make to this hook to handle that, as shown in\nListing 8-14.\n_endScene origEndScene = NULL;\nvoid placeHooks()\n{\nauto ret = hookVF((DWORD)discoveredDevice, 42, (DWORD)&myEndScene);\nif (ret != (DWORD)&myEndScene) // don't point to your hook\norigEndScene = (_endScene)ret;\n}\nplaceHooks();\nHRESULT WINAPI myEndScene(LPDIRECT3DDEVICE9 pDevice)\n{\n// draw your own stuff here\nauto ret = origEndScene(pDevice);\nplaceHooks(); // update hooks\nreturn ret;\n}\nListing 8-14: Final code to hook EndScene()\nThe code to place the hook has been moved into a function called\nplaceHooks() so it can be called multiple times with ease. The callback func-\ntion still forwards the call to the original function, but it makes sure to call\nplaceHooks() before returning. This ensures that the hook is always active,\neven if the original EndScene() function removes it.\n182 Chapter 8"
  },
  {
    "input": "Writing a Hook for Reset()",
    "output": "Another point to notice is that placeHooks() updates the address of\norigEndScene() every time the hook is replaced, as long as the address\nreturned from hookVF() isn’t the address of the myEndScene() function. This\ndoes two distinct things. First, it allows other applications to hook EndScene()\nwithout stepping on their toes, since it will update origEndScene() to whatever\nis seen in the VF table. Second, it makes sure that the value of origEndScene()\ncan never be the address of our callback, preventing a potential infinite\nloop. An infinite loop is possible otherwise, because origEndScene() doesn’t\nalways fix the device’s VF table, meaning placeHooks() can be called when\nthe VF table still contains the myEndScene() function.\nWriting a Hook for Reset()\nWhen you’re using a Direct3D hook in production, you’ll be doing all kinds\nof tasks like drawing custom text, displaying images related to your bot, and\ninteracting with function calls from the game. These tasks will require you\nto create your own Direct3D objects that are tied to the game’s device, and\nthat can be a problem. From time to time, the game may completely reset\nits device through a Reset() function. When a device is reset, you’ll need to\nupdate any objects (most commonly fonts and sprites) that you’ve created\nfor the device, using their OnLostDevice() member functions.\nSince Reset() is called from the VF table of the device, you can use\na hook on it to tell you when the device has been reset. Reset() takes two\nparameters and is at index 16 in the VF table. You can add this code to\nplaceHooks() in Listing 8-14 to hook the Reset() function:\nauto ret = hookVF((DWORD)discoveredDevice, 16, (DWORD)&myReset);\nif (ret != (DWORD)&myReset)\norigReset = (_reset)ret;\nAnd this is the declaration to use for origReset:\ntypedef HRESULT (WINAPI* _reset)(\nLPDIRECT3DDEVICE9 pDevice,\nD3DPRESENT_PARAMETERS* pPresentationParameters);\n_reset origReset = NULL;\nWhen a reset is successful, the original function returns D3D_OK. Your\nhook function recognizes this and calls OnLostDevice() accordingly:\nHRESULT WINAPI myReset(\nLPDIRECT3DDEVICE9 pDevice,\nD3DPRESENT_PARAMETERS* pPresentationParameters)\n{\nauto result = origReset(pDevice, pPresentationParameters);\nif (result == D3D_OK) {\n// call onLostDevice() for all of your objects\n}\nreturn result;\n}\nManipulating Control Flow in a Game 183"
  },
  {
    "input": "What’s Next?",
    "output": "Once you fill in the contents of the if() statement, all of your objects\nare ready to use again.\nWhat’s Next?\nNow that I’ve shown you how to take control of a game’s Direct3D device,\nyou’re probably wondering what you can do with it. Unlike the other\nexamples in the book, the code in this section and the example code don’t\nhave a one-to-one correlation, but the functionality is still the same. Here’s\na high-level view of the correlation between this chapter and the code in the\nChapter8_Direct3DHook example project.\nThe file DirectXHookCallbacks.h contains the callbacks for the EndScene()\nand Reset() functions, two callbacks for other common functions, and the\ntrampoline and reporter functions for the temporary jump hook. These func-\ntions are all pretty much as described in this chapter, except they call into a\nsingleton class defined in DirectXHook.h and DirectXHook.cpp. This single ton\nclass is responsible for forwarding the calls to the original functions.\nThe class is also responsible for all of the heavy lifting, and it contains\nthe code to create the discovery device, place the hooks, draw text, handle\ndevice resets, and display images. Furthermore, it allows external code to\nadd custom callbacks for each hook, as you can see in main.cpp. Here, you’ll\nsee a number of different callbacks that are drawing custom text, adding\nnew images to the screen, and changing the textures of models that are\ndrawn by the game. I recommend poking around in the code to get a better\nunderstanding of what’s going on, but don’t get too carried away. We’ll dive\ninto this code in Chapter 9 to talk about all the cool hacks it can do.\nOPtIONAl fIxEs fOr stABIlIty\nThe Reset() and EndScene() hooks described in this chapter should work well\nfor any game running Direct3D 9, but it is slightly unstable. If the game tries\nto execute EndScene() when the jump hook is placed, it will crash because the\nbytes are being modified. There are two ways to fix this. First, you can place\nthe jump hook from within an IAT hook on PeekMessage(). This will work\nbecause placing an IAT hook is a thread-safe operation, but it assumes that\nPeekMessage() is called only from the same thread that does the Direct3D\ndrawing.\nA safer, but more complex, alternative is to iterate over every thread in the\ngame (similar to how it worked for thread hijacking) and use SuspendThread()\nto pause all threads in the game (except for the one placing the hook, of\ncourse). Before pausing a thread, you must make sure its EIP is not execut-\ning the first 5 bytes of EndScene(). After the hook is placed, you must use\nResumeThread() to restore execution with your hook in place.\n184 Chapter 8"
  },
  {
    "input": "Closing Thoughts",
    "output": "closing Thoughts\nControl flow manipulation is a very important skill in game hacking, and\na lot of the hacks in this book rely on it. Throughout the next two chap-\nters you’ll learn how to create common hacks using the Direct3D hook,\nand you’ll get a better idea of the general use cases of hooking. Even if you\nfeel a little shaky, continue to Chapter 9. The code examples there center\non the Direct3D hook and will get you even more familiar with hooking\ntechniques.\nManipulating Control Flow in a Game 185"
  },
  {
    "input": "Chapter 9: Using Extrasensory Perception to Ward Off Fog of War ",
    "output": "9\nusING E x tr AsENsOry\nPErCEPtION t O wA rD Off\nfOG Of wA r\nFog of war (often shortened to just fog) is\na mechanism that game developers com-\nmonly use to limit a player’s situational\nawareness and hide information about the\ngame environment. Fog is often a literal lack of sight\nin massive online battle arena (MOBA) games, but\nthe concept also includes any lack or obscurity of\npertinent gameplay information. Cloaked figures,\ndark rooms, and enemies hiding behind walls are all\nforms of fog.\nGame hackers can reduce or even completely remove fog using an extra-\nsensory perception (ESP) hack. An ESP hack uses hooking, memory manipula-\ntion, or both to force a game to display hidden information. These hacks\ntake advantage of the fact that some types of fog are often implemented on\nthe client side, as opposed to the server side, meaning that the game clients\nstill contain information (partial or complete) about what is being hidden."
  },
  {
    "input": "Adding a Central Ambient Light Source",
    "output": "In this chapter, you will learn how to implement different types of ESP\nhacks. First, you’ll learn to light up dark environments. Next, you’ll use\nx-ray vision to see through walls. Finally, you’ll learn about zoom hacking,\ntweaking heads-up displays, and other simple ESP hacks that can reveal all\nsorts of useful (but otherwise hidden) information about the game you’re\nplaying.\nbackground knowledge\nThis chapter starts the transition from hacking, puppeteering, and reverse\nengineering to coding. From here on out, you’ll be learning how to actually\ncode your own hacks. To keep on topic, everything I’ve talked about thus\nfar will be treated as background knowledge. If you see a technique used\nthat you don’t quite remember, such as memory scanning, setting memory\nbreakpoints, hooking, or writing memory, flip back to the relevant chapters\nand study them a bit more before continuing. Throughout the text, you’ll\nfind notes to remind you where you can brush up on certain topics.\nSpecifically, this chapter will talk a lot about Direct3D. In “Applying\nJump Hooks and VF Hooks to Direct3D” on page 175, I explained\nhow to hook into a game’s Direct3D drawing loop. The example code\nfor that chapter includes a fully featured Direct3D hooking engine in\nGameHackingExamples/Chapter8_Direct3DHook. A lot of the hacks in this\nchapter build on that hook, and their example code can be found in the\nmain.cpp file of the Direct3D hook code. You can run the compiled appli-\ncation from GameHackingExamples/Chapter8_Direct3DApplication to see the\nhacks in action on a test application.\nRevealing Hidden details with Lighthacks\nLighthacks increase lighting in dark environments, allowing you to clearly\nsee enemies, treasure chests, pathways, and anything else that is normally\nobscured by darkness. Lighting is often a cosmetic change that’s added at a\ngame’s graphical layer, and it can usually be directly modified with a hook\non the graphics layer.\nOptimal lighting depends on camera orientation, environment layout,\nand even specific traits of a game’s engine, and you can manipulate any of\nthese factors to create lighthacks. But the easiest way is simply to add more\nlight to a room.\nAdding a Central Ambient Light Source\nThe online resources for this book include two small lighthack examples.\nThe first is the enableLightHackDirectional() function in main.cpp, which is\nshown in Listing 9-1.\nvoid enableLightHackDirectional(LPDIRECT3DDEVICE9 pDevice)\n{\nD3DLIGHT9 light;\n190 Chapter 9"
  },
  {
    "input": "Increasing the Absolute Ambient Light",
    "output": "ZeroMemory(&light, sizeof(light));\nlight.Type = D3DLIGHT_DIRECTIONAL;\nlight.Diffuse = D3DXCOLOR(0.5f, 0.5f, 0.5f, 1.0f);\nlight.Direction = D3DXVECTOR3(-1.0f, -0.5f, -1.0f);\npDevice->SetLight(0, &light);\npDevice->LightEnable(0, TRUE);\n}\nListing 9-1: A directional lighthack\nThis code is called from the EndScene() hook, and it adds light to the\nscene by creating a light source called light. The code sets light.Type to\ndirectional, which means the light source will act like a spotlight and proj-\nect light in a specific direction. The code then sets the red, green, and blue\nvalues of light.Diffuse to 0.5, 0.5, and 0.5, giving the light an off-white shine\nwhen reflected from a surface. Next, it sets light.Direction to an arbitrary\npoint in the three-dimensional space. Finally, the code uses the game’s\nDirect3D device to set up the light at index 0 and enable lighting effects.\nNOtE In the example application, the light shines up and to the right from the bottom left of\nthe scene. You may need to change this location depending on how your target game is\nrendered.\nNote that inserting the light at index 0 works for this proof of con-\ncept, but it won’t always work. Games typically have multiple light sources\ndefined, and setting your light at an index the game uses might override\ncritical lighting effects. In practice, you might try setting the index to an arbi-\ntrarily high number. There’s an issue with this type of lighthack, though:\ndirectional lights will be blocked by objects such as walls, creatures, and\nterrain, meaning shadows can still be cast. Directional lights work great\nfor wide-open spaces, but not so well for tightly wound corridors or under-\nground caves.\nIncreasing the Absolute Ambient Light\nThe other lighthack method, seen in the enableLightHackAmbient() function,\nis far more aggressive than the one in Listing 9-1. It affects the light level\nglobally, rather than adding an extra light source. Here’s what the code\nlooks like:\nvoid enableLightHackAmbient(LPDIRECT3DDEVICE9 pDevice)\n{\npDevice->SetRenderState(D3DRS_AMBIENT, D3DCOLOR_XRGB(100, 100, 100));\n}\nThis lighthack sets the absolute ambient light (which you indicate\nby passing D3DRS_AMBIENT to the SetRenderState() function) to a medium-\nstrength white. The D3DCOLOR_XRGB macro sets that strength, taking 100 as\nUsing Extrasensory Perception to Ward Off Fog of War 191"
  },
  {
    "input": "Revealing Sneaky Enemies with Wallhacks",
    "output": "its parameters for the red, green, and blue levels. This lights up objects\nusing an omnidirectional white light, effectively revealing everything at\nthe cost of shadows and other lighting-based details.\nCreating Other Types of Lighthacks\nThere are many other ways to create lighthacks, but they differ from game\nto game. One creative way to affect the light in a game is to NOP the code\nthat the game uses to call the device->SetRenderState() function. Since this\nfunction is used to set up the global ambient light strength, disabling calls\nto it leaves Direct3D at the default light settings and makes everything vis-\nible. This is perhaps the most powerful type of lighthack, but it requires\nyour bot to know the address of the lighting code to NOP.\nThere are also memory-based lighthacks. In some games, players and\ncreatures emit light of different colors and strengths, often depending on\nattributes like their equipment, mount, or active spells. If you understand\nthe structure of the game’s creature list, you can directly modify the values\nthat determine a creature’s light level.\nFor instance, imagine a game in which characters emit a bluish ball\nof light when under a healing or strengthening spell. Somewhere in the\ngame’s memory are values associated with each creature that tell the game\nthe color and intensity of light the creature should emit. If you can locate\nthese values in memory, you can change them so that the creatures effec-\ntively emit orbs of light. This type of lighthack is commonly used in games\nwith a 2D top-down style, since the orbs around individual creatures pro-\nduce a cool artistic effect while shedding light on important parts of the\nscreen. In 3D games, however, this sort of hack just turns creatures into\nblobs of light that run around.\nYou can also hook the SetLight() member function at index 51 in the\nVF table of the game’s Direct3D device. Then, whenever your hook callback\nis invoked, you can modify the properties of the intercepted D3DLIGHT9 light\nstructure before passing it to the original function. You might, for instance,\nchange all lights to the D3DLIGHT_POINT type, causing any existing light sources\nin the game to radiate light in every direction like a light bulb. This type of\nlighthack is very powerful and accurate, but it can produce some disturbing\nvisuals. It also tends to break in any environment that has no lighting, and\nopaque obstacles still block point light sources.\nLighthacks are very powerful, but they don’t reveal anything. If infor-\nmation is hidden behind an obstacle, rather than by darkness, you’ll need a\nwallhack to reveal it.\nRevealing Sneaky enemies with wallhacks\nYou can use wallhacks to show enemies that are hidden by walls, floors, and\nother obstacles. There are a few ways to create these hacks, but the most com-\nmon method takes advantage of a type of rendering known as z-buffering.\n192 Chapter 9"
  },
  {
    "input": "Rendering with Z-Buffering",
    "output": "Rendering with Z-Buffering\nMost graphics engines, including Direct3D, support z-buffering, which is a\nway to make sure that when there are overlapping objects in a scene, only\nthe top object is drawn. Z-buffering works by “drawing” the scene to a two-\ndimensional array that describes how close the object at each pixel on the\nscreen is to the viewer. Think of the array’s indices as axes: they correspond\nto the x-axis (right and left) and y-axis (up and down) for each pixel on the\nscreen. Each value stored in the array is the z-axis value for a pixel.\nWhen a new object appears, whether it is actually drawn on the\nscreen is decided by the z-buffer array. If the spot at the object’s x- and\ny-position is already filled in the array, that means there’s another object\nat that pixel on the screen. The new object will appear only if it has a lower\nz-axis value (that is, if it’s closer to the viewer) than the pixel already there.\nWhen the scene is finished being drawn to the array, it is flushed to the\nscreen.\nTo illustrate this, imagine a three-dimensional space that needs to be\ndrawn to a two-dimensional canvas by some game with 4×4-pixel viewport.\nThe z-buffer for this scenario would look like Figure 9-1.\n(0,0) (3,0)\nz = 0 z = 0 z = 0 z = 0\nNo color No color No color No color\nz = 0 z = 0 z = 0 z = 0\nNo color No color No color No color\nz = 0 z = 0 z = 0 z = 0\nNo color No color No color No color\nz = 0 z = 0 z = 0 z = 0\nNo color No color No color No color\n(0,3) (3,3)\nFigure 9-1: An empty z-buffer\nTo start, the game draws a blue background that completely fills the\nviewport and is located as far away on the z-axis as possible; let’s say the\nhighest z-value is 100. Next, the game draws a 2×2-pixel red rectangle at\nUsing Extrasensory Perception to Ward Off Fog of War 193"
  },
  {
    "input": "Creating a Direct3D Wallhack",
    "output": "position (0,0) with a z-position of 5. Finally, the game draws a 2×2-pixel\ngreen rectangle at position (1,1) with a z-position of 3. The z-buffer would\nnow look like Figure 9-2.\n(0,0) (3,0)\nz = 5 z = 5 z = 100 z = 100\nRed Red Blue Blue\nz = 5 z = 3 z = 3 z = 100\nRed Green Green Blue\nz = 100 z = 3 z = 3 z = 100\nBlue Green Green Blue\nz = 100 z = 100 z = 100 z = 100\nBlue Blue Blue Blue\n(0,3) (3,3)\nFigure 9-2: A filled z-buffer\nThe z-buffer neatly handled overlapping objects based on their z-posi-\ntions. The green square that’s closest on the z-axis overlaps the red square\nthat’s a bit farther away, and both squares overlap the blue background,\nwhich is very far away.\nThis behavior allows a game to draw its map, players, creatures, details,\nand particles without worrying about what is actually visible to the player.\nThis is a huge optimization for game developers, but it exposes a large area\nof attack. Since all game models are always given to the graphics engine,\nyou can use hooks to detect objects that the player can’t actually see.\nCreating a Direct3D Wallhack\nYou can create wallhacks that manipulate z-buffering in Direct3D using a\nhook on the DrawIndexedPrimitive() function, which is called when a game\ndraws a 3D model to the screen. When an enemy player model is drawn,\na wallhack of this type disables z-buffering, calls the original function to\ndraw the model, and then reenables z-buffering. This causes the enemy\nmodel to be drawn on top of everything else in the scene, regardless of\nwhat’s in front of it. Some wallhacks can also render specific models in a\nsolid color, such as red for enemies and green for allies.\n194 Chapter 9\ntoggling Z-Buffering\nThe Direct3D hook in main.cpp from GameHackingExamples/Chapter8_\nDirect3DHook has this example wallhack in the onDrawIndexedPrimitive()\nfunction:\nvoid onDrawIndexedPrimitive(\nDirectXHook* hook,\nLPDIRECT3DDEVICE9 device,\nD3DPRIMITIVETYPE primType,\nINT baseVertexIndex, UINT minVertexIndex,\nUINT numVertices, UINT startIndex, UINT primCount)\n{\nif (numVertices == 24 && primCount == 12) {\n// it's an enemy, do the wallhack\n}\n}\nThis function is used as a callback for a hook on DrawIndexedPrimitive()\nat VF index 82 of the game’s Direct3D device. Every model the game draws\npasses through this function, accompanied by some model-specific proper-\nties. By inspecting a subset of the properties, namely the numVertices and\nprimCount values, the hook detects when an enemy model is drawn and com-\nmences the wallhack. In this example, the values representing an enemy\nmodel are 24 and 12.\nThe magic happens inside the if() statement. Using just a few lines\nof code, the wallhack draws the model in a way that ignores z-buffering,\nlike so:\ndevice->SetRenderState(D3DRS_ZENABLE, false); // disable z-buffering\nDirectXHook::origDrawIndexedPrimitive( // draw model\ndevice, primType, baseVertexIndex,\nminVertexIndex, numVertices, startIndex, primCount);\ndevice->SetRenderState(D3DRS_ZENABLE, true); // enable z-buffering\nSimply put, this code disables z-buffering when drawing the enemy\nmodel and reenables it afterward. With z-buffering off, the enemy is drawn\nin front of everything.\nChanging an Enemy texture\nWhen a model is rendered onscreen, a texture is used to skin the model.\nTextures are 2D images that are stretched around 3D models to apply the\ncolors and patterns that make up the model’s 3D artwork. To change the\nway an enemy looks when it’s drawn in your wallhack, you can set it to be\ndrawn with a different texture, as in this example:\n// when hook initializes\nLPDIRECT3DTEXTURE9 red;\nD3DXCreateTextureFromFile(device, \"red.png\", &red);\nUsing Extrasensory Perception to Ward Off Fog of War 195"
  },
  {
    "input": "Fingerprinting the Model You Want to Reveal",
    "output": "// just before drawing the primitive\ndevice->SetTexture(0, red);\nThe first block of this code loads the texture from a file and is executed\nonly once—when the hook is initialized. The full example code does this in\nan initialize() function, which gets called the first time the EndScene() hook\ncallback is invoked. The second block of this code happens right before the\ncall to the original DrawIndexedPrimitive() function in the wallhack, and it\ncauses the model to be drawn with the custom texture.\nFingerprinting the Model You Want to Reveal\nThe trickiest part to creating a good wallhack is finding the right values for\nnumVertices and primCount. To do this, you can create a tool that logs every\nunique combination of the two variables and allows you to iterate over the\nlist using your keyboard. Working example code for this tool won’t be use-\nful in the example application provided with this chapter, but I’ll give you\nsome high-level implementation details.\nFirst, in the global scope, you’d declare a structure that has members to\nstore the following:\n• numVertices and primCount\n• A std::set of this structure (let’s call it seenParams)\n• An instance of that structure (let’s call it currentParams)\nThe std::set requires a comparator for this structure, so you’d also\ndeclare a comparison functor that calls memcmp() to compare two of the\nstructures using memcmp(). Each time the DrawIndexedPrimitive() callback is\ninvoked, your hack could create a structure instance with the intercepted\nvalues and pass it to a seenParams.insert() function, which should insert the\nparameter pair into the list only if the pair isn’t already there.\nUsing the GetAsyncKeyState() Windows API function, you could then\ndetect when the spacebar is pressed and execute something similar to this\npseudocode:\nauto current = seenParams.find(currentParam);\nif (current == seenParams.end())\ncurrent = seenParams.begin();\nelse\ncurrent++;\ncurrentParams = *current;\nThis would set currentParams to the next pair in seenParams when the space-\nbar is pressed. With this code in place, you could use code similar to a wall-\nhack to change the texture of models matching currentParams.numVertices\nand currentParams.primCount. The tool could also draw those values on the\nscreen so you could see them and write them down.\nWith a tool like this, finding the proper models is as easy as starting\nup a game in a mode where your character won’t die (against a friend, in\n196 Chapter 9"
  },
  {
    "input": "Using NOPing Zoomhacks ",
    "output": "a customization mode, and so on), running the bot, and pressing the space-\nbar until each model you need is highlighted. Once you have the values\nfor your target models, you’ll modify the numVertices and primCount check in\nyour wallhack so it knows which models to highlight.\nNO tE Character models are commonly made up of smaller models for individual body seg-\nments, and games often show different models of a character at different distances.\nThat means a game may have 20 or more models for one type of character. Even in\nthat case, selecting only one model (say, the enemy’s torso) to show in your wallhack\nmay be enough.\nGetting a wider Field of vision with Zoomhacks\nMany games in the MOBA and real-time strategy (RTS) genres use a 3D\ntop-down style that makes them immune to wallhacks. They also use dark-\nness on the map as a type of fog, but showing the dark areas using a light-\nhack doesn’t give any extra information; models hidden inside the fog are\nknown only to the game server, not to the client.\nThis style makes most types of ESP hacks useless: there’s little unknown\ninformation to reveal, so these hacks only augment your view of the infor-\nmation you can already see. One type of ESP hack, however, can still be\nhelpful. Zoomhacks let you zoom out much farther than a game normally\nallows, effectively revealing large portions of the map that you couldn’t see\notherwise—and thus getting around the game’s wallhack and lighthack\nimmunity.\nUsing NOPing Zoomhacks\nMOBA and RTS games typically allow players a variable but limited amount\nof zoom. The simplest type of zoomhack finds the value of the zoom factor\n(a multiplier that changes as the zoom level changes, typically a float or\ndouble) and overwrites it with a larger value.\nTo find the zoom factor, fire up Cheat Engine and search for a float\nwith an unknown initial value. (To brush up on Cheat Engine, head over\nto “Cheat Engine’s Memory Scanner” on page 5.) For rescans, repeat\nthe following process until there are only a few values left to find the zoom\nfactor:\n1. Go to the game window and zoom in.\n2. Search for an increased value in Cheat Engine.\n3. Go to the game window and zoom out.\n4. Search for a decreased value in Cheat Engine.\nTry to get the value list down to one option. To confirm that the\nremaining value is the zoom factor, freeze it in Cheat Engine and see how\nzoom behaves in-game; freezing the proper value will disable zooming. If\nyou fail to find the zoom factor using a float search, retry the search using\nUsing Extrasensory Perception to Ward Off Fog of War 197"
  },
  {
    "input": "Displaying Hidden Data with HUDs",
    "output": "a double. If both searches fail, try them again but correspond zooming in\nwith decreased values and zooming out with increased values instead. Once\nyou’ve found the zoom factor in memory, you can write a small bot to over-\nwrite it to the zoom factor that best suits you.\nMore advanced zoomhacks NOP the game code responsible for mak-\ning sure the zoom factor is within a set range. You should be able to find\nthis code with OllyDbg. Set a memory on-write breakpoint on the zoom\nfactor, zoom in-game to trigger the breakpoint, and inspect the code at\nthe breakpoint. (To hone your OllyDbg memory breakpoint skills, flip to\n“Controlling OllyDbg Through the Command Line” on page 43.) You\nshould see the code that modified the zoom factor. Zoom limitation code\nis typically easy to spot: constants that match the minimum and maximum\nzoom values are a dead giveaway.\nIf you can’t find the limitation code using this method, then the limita-\ntion may be applied when the graphics are redrawn at a new zoom level,\nrather than when the zoom factor changes. In this case, switch your break-\npoint to memory on-read and look for the same clues.\nScratching the Surface of Hooking Zoomhacks\nYou can also create zoomhacks by using a Direct3D hook on the function\ndevice->SetTransform(type, matrix), but this requires a deep understanding of\nhow a game sets up the player’s perspective. There are a few different ways\nto manage perspective, but you control zoom level using either view (trans-\nform type D3DTS_VIEW) or projection (transform type D3DTS_PROJECTION).\nProperly manipulating transform matrices that control view and projec-\ntion requires some pretty extensive knowledge of the mathematics behind\n3D graphics, though, so I stay away from this method at all costs—and I’ve\nnever had trouble simply manipulating the zoom factor. If you’re interested\nin this kind of hack, though, I recommend reading a 3D game program-\nming book to learn more about 3D mathematics first.\nBut sometimes, even a zoomhack isn’t enough. Some useful informa-\ntion may remain hidden as a part of a game’s internal state or may simply\nbe hard for a player to determine at a moment’s glance. For these situations,\na heads-up display is the tool for the job.\ndisplaying Hidden data with Huds\nA heads-up display (HUD) is a type of ESP hack that displays critical game\ninformation in an overlay. HUDs often resemble a game’s existing interface\nfor displaying information like your remaining ammunition, a mini-map,\nyour current health level, any active ability cooldowns, and so on. HUDs\ntypically display either historical or aggregated information, and they’re\nmostly used on MMORPGs. They are often text based, but some also con-\ntain sprites, shapes, and other small visual effects.\n198 Chapter 9"
  },
  {
    "input": "Creating an Experience HUD",
    "output": "The HUDs you can create depend on what data is available in the\ngame. Common data points are these:\n• Experience gain per hour (exp/h)\n• Creature kills per hour (KPH)\n• Damage per second (DPS)\n• Gold looted per hour (GPH)\n• Healing per minute\n• Estimated time until next level\n• Amount of gold spent on supplies\n• Overall gold value of items looted\nMore advanced custom HUDs may display large tables containing items\nlooted, supplies used, the number of kills for each type of creature, and the\nnames of players that have recently been seen.\nBeyond what you’ve already learned about reading memory, hooking\ngraphics engines, and displaying customized data, there’s not much else\nI can teach you about how to create a HUD. Most games have a simple\nenough architecture that you can easily obtain most of the information you\nneed from memory. Then, you can run some basic hourly, percentage, or\nsummation calculations to get the data into a usable format.\nCreating an Experience HUD\nImagine you want a HUD that displays your current level, hourly experi-\nence, and how long you’ll have to play before your character levels up. First,\nyou could use Cheat Engine to find the variables that contain your level and\nexperience. When you know those values, you can use either a game-specific\nalgorithm or a hardcoded experience table to calculate the experience\nrequired to reach the next level.\nWhen you know how much experience you need to level up, you can\ncalculate your hourly experience. Put into pseudocode, that process might\nlook like this:\n// this example assumes the time is stored in milliseconds\n// for seconds, remove the \"1000 * \"\ntimeUnitsPerHour = 1000 * 60 * 60\ntimePassed = (currentTime - startTime)\nu timePassedToHourRatio = timeUnitsPerHour / timePassed\nv expGained = (currentExp - startExp)\nhourlyExp = expGained * timePassedToHourRatio\nw remainingExp = nextExp - currentExp\nx hoursToGo = remainingExp / hourlyExp\nUsing Extrasensory Perception to Ward Off Fog of War 199"
  },
  {
    "input": "Using Hooks to Locate Data",
    "output": "To find your hourly experience, hourlyExp, you’d store your experience\nand the time when your HUD first starts; these are startExp and startTime,\nrespectively. This example also assumes currentLevel and currentExp are pre-\nviously defined, where currentLevel is the character’s level and currentExp is\nthe current amount of experience.\nWith these values, hourlyExp can be calculated by multiplying a ratio u\nof the time units in an hour to the time that has passed by the experience\ngained since startTime v. In this case, the time unit is a millisecond, so the\ntime units get multiplied by 1,000.\nNext, currentExp is subtracted from nextExp to determine the remaining\nexperience w to level up. To calculate how many hours are left to level up,\nyour remaining experience is divided by your hourly experience x.\nWhen you have all this information, you can finally display it onscreen.\nUsing the Direct3D hooking engine provided in this book’s example code,\nyou’d draw the text using this call inside the EndScene() hook callback:\nhook->drawText(\n10, 10,\nD3DCOLOR_ARGB(255, 255, 0, 0),\n\"Will reach level %d in %0.20f hours (%d exp per hour)\",\ncurrentLevel, hoursToGo, hourlyExp);\nThat’s all you need for a working, experience-tracking HUD. Variations\nof these same equations can be used to calculate KPH, DPS, GPH, and other\nuseful time-based measures. Furthermore, you can use the drawText() func-\ntion of the Direct3D hook to display any information you can locate and\nnormalize. The hook also contains addSpriteImage() and drawSpriteImage()\nfunctions that you can use to draw your own custom images, allowing you\nto make your HUDs as fancy as you want.\nUsing Hooks to Locate Data\nMemory reading isn’t the only way to get data for a custom HUD. You can\nalso gather information by counting the number of times a specific model\nis drawn by the DrawIndexedPrimitive() function, hooking the game’s internal\nfunctions responsible for drawing certain types of text, or even intercept-\ning function calls responsible for processing data packets from the game\nserver. The methods you use to do this will be drastically different for\nevery game, and finding those methods will require you to pair everything\nyou’ve learned from this book with your own ingenuity and programming\ninstincts.\nFor instance, to create a HUD that displays how many enemies are on\nthe map, you could use the model-fingerprinting methods used by wallhacks\nto count the number of enemies and output that number to the screen. This\nmethod is better than creating a way to read the list of enemies from mem-\nory, since it doesn’t require new memory addresses every time the game\npatches.\n200 Chapter 9"
  },
  {
    "input": "An Overview of Other ESP Hacks",
    "output": "Another example is displaying a list of enemy cooldowns, which would\nrequire you to intercept incoming packets that tell the client which spell\neffects to display. You could then correlate certain spells with certain\nenemies based on spell and enemy location, spell type, and so on, and use\nthat information to track spells each enemy has used. If you correlate the\ndata with a database of cooldown times, you can display exactly when each\nenemy spell can be used again. This is especially powerful because most\ngames don’t store enemy cooldowns in memory.\nan Overview of Other eSP Hacks\nIn addition to the hacks discussed in this chapter, there are a number of\nESP hacks that don’t have common names and are specific to certain genres\nor even certain games. I’ll quickly take you through the theory, background,\nand architecture of some of these hacks.\nRange Hacks\nRange hacks use a method similar to wallhacks to detect when the\nmodels for different types of champions or heroes are drawn. Then\nthey draw circles on the ground around each hero model. The radius\nof each circle corresponds to the maximum attack range of the cham-\npion or hero it surrounds, effectively showing you areas where you can\nbe damaged by each enemy.\nLoading-Screen HUDs\nLoading-screen HUDs are common in MOBA and RTS games that\nrequire all players to sit through a loading screen while everyone’s game\nis starting up. These hacks take advantage of the fact that such games\noften have websites where historical player statistics can be queried. You\ncan write a bot that automatically queries the statistics of each player in\nthe game and seamlessly displays the information as an overlay on your\nloading screen, allowing you to study your enemies before launching\ninto battle.\nPick-Phase HUDs\nPick-phase HUDs are similar to their loading-screen cousins, but they\nare displayed during the pregame phase when each player is picking\na champion or hero to play. Instead of showing enemy statistics, pick-\nphase HUDs show statistics about allies. This allows you to quickly assess\nthe strengths and weaknesses of your allies so you can make better deci-\nsions about which character to play.\nFloor Spy Hacks\nFloor spy hacks are common in older 2D top-down games that have dif-\nferent distinct floors or platforms. If you’re on the top floor, you might\nwant to know what’s going on downstairs before you go charging in.\nYou can write floor spy hacks that modify the current floor value (typi-\ncally an unsigned int) to a different floor above or below you, allowing\nyou to spy on other floors.\nUsing Extrasensory Perception to Ward Off Fog of War 201"
  },
  {
    "input": "Closing Thoughts",
    "output": "Games often recalculate the current floor value every frame based on\nplayer position, so NOPs are sometimes required to keep the value from\nbeing reset every time a frame is redrawn. Finding the current floor value\nand the code to NOP would be similar to finding the zoom factor, as dis-\ncussed in “Using NOPing Zoomhacks” on page 197.\nclosing Thoughts\nESP hacks are powerful ways to obtain extra information about a game.\nSome of them can be done pretty easily through Direct3D hooks or simple\nmemory editing. Others require you to learn about a game’s internal data\nstructures and hook proprietary functions, giving you a reason to employ\nyour reverse engineering skills.\nIf you want to experiment with ESP hacks, study and tweak the example\ncode for this chapter. For practice with more specific ESP hacks, I encour-\nage you to go out and find some games to play around with.\n202 Chapter 9"
  },
  {
    "input": "Chapter 10: Responsive Hacks",
    "output": "10\nrEsPON sIVE H ACKs\nThe average gamer has a reaction time of\n250 milliseconds, or a quarter of a second.\nProfessional gamers average a fifth of a\nsecond, but some can react in a sixth of a sec-\nond. These figures are based on online tests that mea-\nsure players’ reaction times to singular, predictable\nevents. In actual games, though, players must react to dozens of differ-\nent events, like health loss, incoming skill shots, abilities coming off of\ncooldown, enemy attacks, and many others. Only very skilled gamers can\nmaintain a fourth- or fifth-of-a-second reaction time in such dynamic envi-\nronments; the only way to be faster is to be a computer.\nIn this chapter, you’ll learn how to make bots that react faster than any\nplayer. First, I’ll show you some code patterns you can incorporate into a\nbot to detect when certain events happen within a game. Next, you’ll learn\nhow to make a bot that moves your character, heals, or casts spells all on its\nown. Once you’ve explored those fundamental techniques, I’ll help you tie\nthem together to implement some of the most common, and most powerful,\nresponsive hacks."
  },
  {
    "input": "Monitoring Memory",
    "output": "Observing Game events\nWithin just a few seconds of playing a game, most people can make essen-\ntial observations about the game environment. You can clearly see when\nmissiles are flying toward your character, when your health is too low, and\nwhen abilities come off of cooldown. For a bot, though, these seemingly\nintuitive observations are not as easy to make. The bot must detect each\nevent by looking for changes in memory, detecting visual cues, or intercept-\ning network traffic.\nMonitoring Memory\nTo detect simple events, such as your health bar dropping low, you can pro-\ngram a bot to periodically read your health from memory and compare it to\nsome minimum acceptable value, as in Listing 10-1.\n// do this every 10 milliseconds (100 times a second)\nauto health = readMemory<int>(HEALTH_ADDRESS);\nif (health <= 500) {\n// some code to tell the bot how to react\n}\nListing 10-1: An if statement that checks health\nGiven the address of your character’s health, you can check the value\nthere as often as you need; every 10 milliseconds is typically a good rate.\n(Flip back to Chapter 1 if you need a refresher on locating values in mem-\nory.) Once health drops below a certain value, you’ll want to run some reac-\ntion code to cast a healing spell or drink a potion. I’ll talk about how you\ncan do this later in the chapter.\nIf you want your bot to have more granular information and the chance\nfor a greater variety of responses, you can program it to react to any change\nin health, instead of only after a set threshold. To do so, change the code in\nListing 10-1 to compare your current health to the amount you had during\nthe previous execution, as follows:\n// still do this every 10 milliseconds\nstatic int previousHealth = 0;\nauto health = readMemory<int>(HEALTH_ADDRESS);\nif (health != previousHealth) {\nif (health > previousHealth) {\n// react to increase\n} else {\n// react to decrease\n}\npreviousHealth = health;\n}\nNow, this code uses a static variable called previousHealth to track the\nvalue of health on the previous iteration. If previousHealth and health differ,\nthe bot not only reacts to the change in health but also reacts differently\n204 Chapter 10"
  },
  {
    "input": "Detecting Visual Cues",
    "output": "to health increases and decreases. This technique is the simplest, and most\ncommon, way to react to changes in a game state. With the proper memory\naddresses, you can use this code pattern to observe changes in health,\nmana, ability cooldowns, and other critical information.\nDetecting Visual Cues\nHealth is relatively simple for a bot to check because it’s just a number, but\nsome game elements have to be relayed to the bot differently. For example,\nwhen status ailments or buffs are affecting a character, the easiest way for\nyou to tell is to simply look for an onscreen status indicator, and the same is\ntrue for bots.\nWhen reading memory isn’t enough, you can detect certain events by\nhooking a game’s graphics engine and waiting for the game to render a\nspecific model. (Refer back to “Applying Jump Hooks and VF Hooks to\nDirect3D” on page 175 and “Creating a Direct3D Wallhack” on page 194\nto get refreshed on Direct3D hooks. ) When the model is drawn, you can\nqueue up a reaction to be executed after the frame is drawn, like this:\n// below is the drawIndexedPrimitive hook\nvoid onDrawIndexedPrimitive(...) {\nif (numVertices == EVENT_VERT && primCount == EVENT_PRIM) {\n// react, preferably after drawing is done\n}\n}\nUsing the same model-fingerprinting trick as the wallhack code in\nChapter 9, this code detects when a specific model is drawn to the screen\nand reacts accordingly. This code reacts to the event every single frame,\nthough, and that can make your game unplayable. You’ll probably want\nsome internal cooldown to avoid spamming a reaction. In cases where the\nindicator model is persistently drawn (that is, not blinking), you can actu-\nally track it across frames to determine when it appears and disappears.\nHere’s a code snippet that also handles tracking:\nbool eventActive = false;\nbool eventActiveLastFrame = false;\n// below is the drawIndexedPrimitive hook\nvoid onDrawIndexedPrimitive(...) {\nif (numVertices == EVENT_VERT && primCount == EVENT_PRIM)\neventActive = true;\n}\n// below is the endScene hook\nvoid onDrawFrame(...) {\nif (eventActive) {\nif (!eventActiveLastFrame) {\n// react to event model appear\n}\neventActiveLastFrame = true;\nResponsive Hacks 205"
  },
  {
    "input": "Intercepting Network Traffic",
    "output": "} else {\nif (eventActiveLastFrame) {\n// react to event model disappear\n}\neventActiveLastFrame = false;\n}\neventActive = false;\n}\nThe onDrawIndexedPrimitive() function still checks whether a certain\nmodel was drawn, but now, two Booleans track whether the model was\ndrawn this frame or the previous frame. Then, when the frame is com-\npletely drawn, the bot can check these variables and react to the model\neither appearing or disappearing.\nThis method works great for detecting visual status indicators that\nappear only when your character is affected by stuns, movement slows,\nsnares, poisons, and so on. You can also use it to detect when enemies\nappear and disappear in MOBA and RTS games, as these games draw only\nenemies that are explicitly in the sight range of an allied unit or player.\nIntercepting Network Traffic\nOne of the most reliable ways to observe events is the same way the game\nclient does: by waiting for the game server to tell you that they occurred.\nIn this type of communication, the game server sends byte arrays called\npackets over the network to the client, using sockets. The packets are typi-\ncally encrypted and contain blobs of data serialized through a proprietary\nformat.\na typical Packet-Parsing Function\nTo receive and process packets, a game client does something like\nListing 10-2 before it draws a frame.\nvoid parseNextPacket() {\nif (!network->packetReady()) return;\nauto packet = network->getPacket();\nauto data = packet->decrypt();\nswitch (data->getType()) {\ncase PACKET_HEALTH_CHANGE:\nonHealthChange(data->getMessage());\nbreak;\ncase PACKET_MANA_CHANGE:\nonManaChange(data->getMessage());\nbreak;\n// more cases for more packet types\n}\n}\nListing 10-2: A simplified look at how a game parses packets\n206 Chapter 10\nThe exact code for any particular game might look different, but the\ncontrol flow is always the same: receive a packet, decrypt it, decide what\nkind of message it contains, and call a function that knows what to do with\nit. Some game hackers intercept raw network packets and replicate this\nfunctionality in their bots. This technique works, but it requires extensive\nknowledge of encryption, a complete understanding of how the game stores\ndata inside a packet, the ability to man-in-the-middle the network connec-\ntion, and a way to locate the decryption keys being used by the game client.\nHooking the functions responsible for handling the packets after they\nare decrypted and parsed is a much better approach; in Listing 10-2, those\nfunctions are the onHealthChange() and onManaChange() functions. This method\nleverages the game’s inherent ability to process packets, allowing a bot to\nremain ignorant of the various network facilities the game uses. It also gives\nyou discretion over which network data you intercept, as you need to hook\nonly the handlers that meet your needs.\nNO tE Intercepting entire packets can sometimes be advantageous—for example, in any\ngame that uses Adobe AIR and communicates using RTMPS. Since RTMPS is so\nheavily documented, there’s no need to reverse engineer the format or encryption.\nChapter 8 explains how to hook RTMPS in detail.\nThere are a few tricks you can use to easily find the parser function\nand, ultimately, the switch() statement that dispatches packets to their han-\ndlers. The most useful method I’ve found is to place a breakpoint on the\nfunction the game uses to receive data from the network, and then analyze\nthe flow of the application when the breakpoint is hit.\nLet’s walk through how you might do this with OllyDbg attached to\nyour target game. In Windows, recv() is the API function to receive data\nfrom a socket. From the OllyDbg command line, you can set a breakpoint\non recv() by entering the bp recv command. When the breakpoint is hit,\nyou can climb the call stack using ctrl-F9, the shortcut for execute until\nreturn, and F8, the shortcut for step over. This combination essentially lets\nthe program execute until the callee has returned to the caller, allowing\nyou to climb the call stack in tandem with the game. At each stack level, you\ncan inspect the code of each caller until you find one that has a big switch()\nstatement; this should be the packet parser.\na trickier Parser\nDepending on the game’s architecture, though, finding the parser function\nmay not be that simple. Consider a game with a parser function that looks\nlike this:\npacketHandlers[PACKET_HEALTH_CHANGE] = onHealthChange;\npacketHandlers[PACKET_MANA_CHANGE] = onManaChange;\nvoid parseNextPacket()\n{\nif (!network->packetReady()) return;\nResponsive Hacks 207\nauto packet = network->getPacket();\nauto data = packet->decrypt();\nauto handler = packetHandlers[data->getType()];\nhandler->invoke(data->getMessage());\n}\nSince the parseNextPacket() function doesn’t have a switch() statement,\nthere’s no obvious way to identify it in memory. Unless you pay very close\nattention, you’ll likely climb right past it on the call stack. When a game\nhas a parser function like this, trying to figure out what the parser func-\ntion looks like might be pointless. If you don’t see a switch() statement when\nclimbing the recv() call stack, you’ll have to note every callee on the call\nstack instead.\nInstead of climbing up the call stack from the breakpoint, you’d go\nto every address marked as a RETURN below ESP in the OllyDbg stack pane.\nThese are the return addresses into each caller for each callee. At each\nreturn address, you’d need to find the top of the caller in OllyDbg’s dis-\nassembly pane and note the address. As a result, you’d have a list of every\nfunction call leading up to the recv() call.\nNext, you’d repeat the same list-making process from breakpoints\nplaced on a few of the game’s handler functions. You can find a handler\nfunction by monitoring memory that it will inevitably use. The handler for\na health change packet, for instance, will update your health in memory.\nUsing OllyDbg, you can set a memory on write breakpoint to the health\naddress. When the breakpoint gets triggered, it means the game updated\nthe health value from a handler function. This should work the same way\nfor most values that are controlled by the server. The server will control any\ngame-critical values, such as health, mana, level, items, and so on.\nOnce you’ve recorded the call stack from recv() and a few handler func-\ntions, you can correlate them to locate the parser function. For example,\nconsider the three pseudo–call stacks in Table 10-1.\nTable 10-1: Pseudo–Call Stacks for Three Packet-Related Functions\nrecv() stack onHealthChange() stack onManaChange() stack\n0x0BADF00D 0x101E1337 0x14141414\n0x40404040 0x50505050 0x60606060\n0xDEADBEEF 0xDEADBEEF 0xDEADBEEF\n0x30303030 0x30303030 0x30303030\n0x20202020 0x20202020 0x20202020\n0x10101010 0x10101010 0x10101010\nThese stacks show what memory might look like during a call to recv()\nand to a game’s hypothetical onHealthChange() and onManaChange() functions.\nNotice that each function originates from a chain of four common function\n208 Chapter 10\ncalls (shown in boldface). The deepest common address, 0xDEADBEEF, is\nthe address of the parser. For a better understanding of this structure, look\nat the call stacks laid out in a tree view, as in Figure 10-1.\n0x0BADF00D (cid:31) recv() 0x14141414 (cid:31) onManaChange()\n0x40404040 (cid:31) network->getPacket() 0x60606060 (cid:31) handler->invoke()\n0x101E1337 (cid:31) onHealthChange()\n0x50505050 (cid:31) handler->invoke()\n0xDEADBEEF (cid:31) parseNextPacket()\n0x30303030 (cid:31) processInput()\n0x20202020 (cid:31) executeFrame()\n0x10101010 (cid:31) main()\nFigure 10-1: Tree view of our three call stacks\nEach function’s call stack branches out from the function at\n0xDEADBEEF, meaning that function is a common point of origin for\nall three calls. The example parseNextPacket() function is responsible for\ncalling these functions, so it must be the most recent common ancestor at\n0xDEADBEEF.\nNO tE These call stacks are hypothetical, and they’re simplified beyond what you’ll typically\nencounter. Real call stacks will probably have quite a few more function calls, and\ncomparing them won’t be as easy.\na Hybrid Parsing System\nA third variation of the parsing loop might be a hybrid of the previous two\nthat uses a switch() statement after a function call. Here’s another hypo-\nthetical function:\nvoid processNextPacket()\n{\nif (!network->packetReady()) return;\nauto packet = network->getPacket();\nauto data = packet->decrypt();\ndispatchPacket(data);\n}\nvoid dispatchPacket(data)\n{\nswitch (data->getType()) {\ncase PACKET_HEALTH_CHANGE:\nprocessHealthChangePacket(data->getMessage());\nbreak;\nResponsive Hacks 209\ncase PACKET_MANA_CHANGE:\nprocessManaChangePacket(data->getMessage());\nbreak;\n// more cases for more data types\n}\n}\nThe processNextPacket() function fetches a new packet and calls\ndispatchPacket() to handle the data. In this case, the dispatchPacket() func-\ntion exists in the call stack of each handler, but not in the one for the\nrecv() function. Look at the hypothetical stacks in Table 10-2, for\nexample.\nTable 10-2: Pseudo–Call Stacks for Three Packet-Related Functions\nrecv() stack onHealthChange() stack onManaChange() stack\n0x0BADF00D 0x101E1337 0x14141414\n0x40404040 0x00ABCDEF 0x00ABCDEF\n0xDEADBEEF 0xDEADBEEF 0xDEADBEEF\n0x30303030 0x30303030 0x30303030\n0x20202020 0x20202020 0x20202020\n0x10101010 0x10101010 0x10101010\nAlthough these three functions have the same first four addresses in\ntheir call stacks, only the two handlers have one more address in common\n(again shown in boldface). That’s 0x00ABCDEF, and it’s the address of the\ndispatchPacket() function. Once again, you can imagine these laid out in a\ntree view, as in Figure 10-2.\n0x101E1337 (cid:31) onHealthChange() 0x14141414 (cid:31) onManaChange()\n0x0BADF00D (cid:31) recv()\n0x40404040 (cid:31) network->getPacket() 0x0ABCDEF (cid:31) dispatchPacket()\n0xDEADBEEF (cid:31) parseNextPacket()\n0x30303030 (cid:31) processInput()\n0x20202020 (cid:31) executeFrame()\n0x10101010 (cid:31) main()\nFigure 10-2: Tree view of our three call stacks\na Parser Hack\nOnce you’ve located the function responsible for dispatching packets to\ntheir handlers, you’ll be able to spot every handler that can be called. You\n210 Chapter 10"
  },
  {
    "input": "Emulating the Keyboard",
    "output": "can deduce a handler’s purpose by placing a breakpoint on it and watching\nwhat values change in memory when it executes. Then, you can hook any\nhandlers that your bot needs to react to. (Flip back to Chapter 8 if you need\na refresher on how you might hook these functions. )\nOf course, there are endless ways to implement network behavior. I\ncan’t cover them all, but seeing these three common techniques should\nhelp you understand the methodology. No matter what game you’re deal-\ning with, a breakpoint on recv() should be a step in the right direction.\nPerforming in-Game actions\nBefore a bot can react to events, you have to teach it to play the game. It\nneeds to be able to cast spells, move around, and activate items. On this\nfront, bots aren’t much different from people: they can just be told which\nbuttons to press. Pressing buttons is simple and suffices in many cases, but\nin more intricate situations, a bot may have to communicate on the network\nand tell the server what it’s trying to do.\nTo follow along with the examples in this section and explore on your\nown afterward, open the files in the GameHackingExamples/Chapter10_\nResponsiveHacks/ folder in this book’s resource files.\nEmulating the Keyboard\nThe most common buttons you’ll press in a game are keyboard keys, and\nthere are a couple of ways you can teach your bot to type.\nthe SendInput() Function\nOne common way to emulate the keyboard is with the SendInput() Windows\nAPI function. This function, which sends keyboard and mouse input to the\ntopmost window, has the following prototype:\nUINT SendInput(UINT inputCount, LPINPUT inputs, int size);\nThe first parameter, inputCount, is the number of inputs being sent. For\nthe examples in this book, I’ll always use a value of 1. The second parame-\nter, inputs, is a pointer to a structure (or an array of structures whose length\nmatches the inputCount value) with the predefined type INPUT. The final\nparameter is the size of inputs in memory, as calculated with the formula\nsize = inputCount × sizeof(INPUT).\nThe INPUT structure tells the SendInput() function what type of input to\nsend, and the following code shows how you might initialize an instance of\nINPUT to press the F1 key:\nINPUT input = {0};\ninput.type = INPUT_KEYBOARD;\ninput.ki.wVk = VK_F1;\nResponsive Hacks 211\nTo have your bot actually press F1, you’d need to send this input twice,\nlike so:\nSendInput(1, &input, sizeof(input));\n// change input to key up\ninput.ki.dwFlags |= KEYEVENTF_KEYUP;\nSendInput(1, &input, sizeof(input));\nThe first call to SendInput() presses F1, and the second releases it. The\nrelease happens not because the input was sent twice, but because the sec-\nond call was made with the KEYEVENTF_KEYUP flag enabled in the input param-\neter’s keyboard flags field. Since setting up input for even a single key is a bit\nmessy, it’s best to wrap everything inside a function. The result looks some-\nthing like Listing 10-3.\nvoid sendKeyWithSendInput(WORD key, bool up)\n{\nINPUT input = {0};\ninput.type = INPUT_KEYBOARD;\ninput.ki.wVk = key;\ninput.ki.dwFlags = 0;\nif (up)\ninput.ki.dwFlags |= KEYEVENTF_KEYUP;\nSendInput(1, &input, sizeof(input));\n}\nsendKeyWithSendInput(VK_F1, false); // press\nsendKeyWithSendInput(VK_F1, true); // release\nListing 10-3: A wrapper for emulating keystrokes with SendInput()\nThis function initializes input with the given key, enables the flag\nKEYEVENTF_KEYUP if up is set, and calls the SendInput() function. This means\nsendKeyWithSendInput() must be called a second time to send the key release,\neven though the release is always required. The function is written this way\nbecause key combinations that involve modifiers like shift, alt, or ctrl\nmust be sent a bit differently; the modifier’s press must come before the\nkey’s press, but its release must come after the key’s release.\nThe following code shows how you’d use the sendKeyWithSendInput() func-\ntion to tell a bot to press shift-F1:\nsendKeyWithSendInput(VK_LSHIFT, false); // press shift\nsendKeyWithSendInput(VK_F1, false); // press F1\nsendKeyWithSendInput(VK_F1, true); // release F1\nsendKeyWithSendInput(VK_LSHIFT, true); // release shift\nYou’d have to call sendKeyWithSendInput() four times, but that’s still easier\nthan using the code without a wrapper function.\n212 Chapter 10\nthe SendMessage() Function\nAn alternative method for sending keystrokes relies on the SendMessage()\nWindows API function. This function allows you to send input to any win-\ndow, even if it’s minimized or hidden, by posting data directly to the target\nwindow’s message queue. This advantage makes it the method of choice\nfor game hackers, because it enables users to do other things while their\nbot plays the game in the background. SendMessage() has the following\nprototype:\nLRESULT SendMessage(\nHWND window,\nUINT message,\nWPARAM wparam,\nLPARAM lparam);\nThe first parameter, window, is a handle to the window that the input\nis being sent to. The second parameter, message, is the type of input being\nsent; for keyboard input, this parameter is WM_KEYUP, WM_KEYDOWN, or WM_CHAR.\nThe third parameter, wparam, should be the key code. The final parameter,\nlparam, should be 0 when the message is WM_KEYDOWN and 1 otherwise.\nBefore you can use the SendMessage() function, you must obtain a handle\nto the target process’s main window. Given the title of the window, you can\nobtain a handle using the FindWindow() Windows API function, as follows:\nauto window = FindWindowA(NULL, \"Title Of Game Window\");\nWith a valid window handle, making a call to SendMessage() looks some-\nthing like this:\nSendMessageA(window, WM_KEYDOWN, VK_F1, 0);\nSendMessageA(window, WM_KEYUP, VK_F1, 0);\nThe first call presses the F1 key, and the second call releases it. Keep in\nmind, however, that this series of calls works only for keys that don’t input\ntext, like F1, insert, or tab. To have your bot press keys that input text, you\nmust also send a WM_CHAR message between the down and up messages. To\ntype W, for instance, you’d do something like this:\nDWORD key = (DWORD)'W';\nSendMessageA(window, WM_KEYDOWN, key, 0);\nSendMessageA(window, WM_CHAR, key, 1);\nSendMessageA(window, WM_KEYUP, key, 1);\nThis creates a key variable so the letter key to press can be changed eas-\nily. Then it follows the same steps the F1 example used, just with a WM_CHAR\nmessage in between.\nResponsive Hacks 213\nNO tE You can actually send nothing but the WM_CHAR message and get the same result, but\nit’s best practice to send all three messages. Game developers can easily shut down bots\nby patching the game to ignore WM_CHAR messages that don’t follow WM_KEYDOWN, and\nthey can even use it as a way to detect your bot and ban you.\nAs I showed with the SendInput() technique, you can create a wrapper\naround this functionality to make your bot code easier to work with. The\nwrapper looks something like this:\nvoid sendKeyWithSendMessage(HWND window, WORD key, char letter)\n{\nSendMessageA(window, WM_KEYDOWN, key, 0);\nif (letter != 0)\nSendMessageA(window, WM_CHAR, letter, 1);\nSendMessageA(window, WM_KEYUP, key, 1);\n}\nUnlike Listing 10-3, this wrapper actually sends both the press and\nrelease. This is because SendMessage() can’t be used to send keystrokes with\nmodifiers, so there’s never any need to insert code between the two calls.\nNO tE There are multiple ways a game might check whether a modifier key is pressed,\nthough. You might be able to send modifier keys to certain games by calling the\nSendMessage() function, but it depends on how those games detect modifiers.\nYou can use this wrapper in a similar way as the one in Listing 10-3. For\nexample, this code sends F1 followed by W:\nsendKeyWithSendMessage(window, VK_F1, 0);\nsendKeyWithSendMessage(window, 'W', 'W');\nThis example, like all of the SendMessage() code I’ve shown so far, sim-\nply gets the job done. It can input text, but it doesn’t exactly send proper\nmessages.\nThere are a lot of small details you have to get right if you want to send\n100 percent valid messages with the SendMessage() function. For instance,\nthe first 16 bits of lparam should store the number of times the key has been\nautomatically repeated as a result of being held down. The next 8 bits\nshould store the scan code, a key identifier that is specific to each keyboard\nmanufacturer. The next bit, number 24, should be set only if the button is\non an extended part of the keyboard, such as the number pad. The follow-\ning 4 bits are undocumented, and the next bit should be set only if the alt\nkey was down when the message originated. The last 2 bits are the previous\nstate flag and the transition state flag. The previous state flag is set only if\nthe key was previously down, and the transition state is set only if the key\nwas previously in the state opposite its current position (that is, if the key is\nnow up and was previously down, or vice versa).\n214 Chapter 10"
  },
  {
    "input": "Sending Packets",
    "output": "Thankfully, the average game doesn’t consider most of these values. For\nthat matter, the average piece of software doesn’t care about them either.\nIf you have to fill all of these values with proper data to make your bot\nwork, you’re moving in the wrong direction. There are many other ways to\nperform actions, the majority of which are simpler than trying to emulate\nthe exact behavior of the operating system’s kernel-level keyboard input\nhandler/dispatcher. In fact, there’s already a function that does that, and\nI’ve already talked about it: the SendInput() function.\nYou can also control the mouse with the SendInput() and SendMessage()\nfunctions, but I highly recommend avoiding it. Any mouse commands\nyou send will affect, and be affected by, any legitimate mouse movements,\nmouse clicks, or keystrokes sent by the player. The same is true for keyboard\ninput, but the complications are much rarer.\nSending Packets\nBefore a game draws a frame, it checks for keyboard and mouse input.\nWhen it receives input that results in an action, such as moving around or\ncasting a spell, it checks to make sure the action is possible and, if so, tells\nthe game server that the action has been performed. The game code to\ncheck for events and alert the server often looks something like this:\nvoid processInput() {\ndo {\nauto input = getNextInput();\nif (input.isKeyboard())\nprocessKeyboardInput(input);\n// handle other input types (e.g., mouse)\n} while (!input.isEmpty());\n}\nvoid processKeyboardInput(input) {\nif (input.isKeyPress()) {\nif (input.getKey() == 'W')\nstep(FORWARD);\nelse if (input.getKey() == 'A')\nstep(BACKWARD);\n// handle other keystrokes (e.g., 'S' and 'D')\n}\n}\nvoid step(int direction) {\nif (!map->canWalkOn(player->position))\nreturn;\nplayerMovePacket packet(direction);\nnetwork->send(packet);\n}\nThe processInput() function is called every frame. The function iterates\nover all pending inputs and dispatches different types of inputs to their rel-\nevant handlers. In this case, when keyboard input is received, it’s dispatched\nResponsive Hacks 215\nto the processKeyboardInput() function. This handler then checks whether\nthe key is either W or S, and, if so, calls step() to move the player in the cor-\nresponding direction.\nSince step() is used to perform an action, it is called an actor function.\nThe invocation of an actor function is called actuation. You can directly call\na game’s actor functions from your bot to perform an action while com-\npletely bypassing the input layer.\nBefore you can call an actor, though, you must find its address. To do\nthis, you can attach OllyDbg to the game, open the command line, and\nenter bp send. This will place a breakpoint on the send() function, which is\nused to send data over the network. When you play the game, every time\nyou take a step, cast a spell, pick up loot, or do anything else, your break-\npoint should trigger, and you can note each function in the call stack.\nNO tE The game should call send() every time you do anything while playing. Pay attention\nto what you did before each send() breakpoint is hit, as that will give you a rough\nidea of what action each call is communicating to the server, and, ultimately, what\nthe actor you find is responsible for.\nOnce you have a few different call stacks, you can compare them to\nlocate the actor functions. To see how to spot the actor functions, let’s com-\npare the two annotated call stacks in Figure 10-3.\n0x70707070 (cid:31) send()\n0x60606060 (cid:31) connection->send()\n0x50505050 (cid:31) network->send()\n0xDEADBEEF (cid:31) step() 0x0BADF00D (cid:31) castSpell()\n0x40404040 (cid:31) processKeyboardInput()\n0x30303030 (cid:31) processInput()\n0x20202020 (cid:31) doFrame()\n0x10101010 (cid:31) main()\nFigure 10-3: Tree view of call stacks to two actor functions\nLike these two stacks, the call stacks you find should be identical at the\ntop, sharing a couple of common functions responsible for generic network\ntransmission. They should also be identical on the bottom, since each call\nto send() should have originated from the processInput() function. Each\nstack should have some unique functions between these identical regions,\n216 Chapter 10\nthough, and those are the actor functions you’re looking for. Typically, the\nfunction of interest is immediately beneath the common network calls. In\nthis case, the two actors are the step() and castSpell() functions.\nAfter hacking the same game for a while, you’ll learn how far up\nthe stack the actor functions are from the send() call. In Figure 10-3, for\nexample, the actors happen three calls before the send() call. Knowing this,\nyou could just climb the stack in OllyDbg (ctrl-F9 followed by F8) three\ntimes when your send() breakpoint is hit and be inside the actor function\nthat sent the data.\nOnce you’ve found an actor function, you can call it from an injected\nDLL. Here’s how you might call step() if you found it at 0xDEADBEEF:\ntypedef void _step(int direction);\nauto stepActor = (_step*)0xDEADBEEF;\nstepActor(FORWARD);\nSince the bot won’t know the actual name for this game function, the\ncode assigns the contents of memory at 0xDEADBEEF to a conveniently\nnamed variable: stepActor. Then, the code just calls stepActor() like any\nother function.\nIf you’ve got the right address, function prototype, and parameters, this\nshould work beautifully; you’ll be able to automate actions as if you have\naccess to the game’s source code. Just make sure to call the actor functions\nfrom inside the same thread as the game, or you can run into threading\nissues. The best way to do this is to call the actors from a hook on a major\nfunction like Direct3D’s EndScene() or the Windows API’s PeekMessage() func-\ntion, as these functions will usually be called only from the game’s main\nthread.\nusING tHIs tO CAll __tHIsCAll\nIf you try to call an actor function that’s a nonstatic member of a class, the\nfunction will have a _thiscall calling convention, which means you’ll need to\npass the instance of the class on the ECX register. (You can brush up on calling\nconventions in “Function Calls” on page 94.) Passing the instance is straight-\nforward, but you’ll have to locate a pointer chain to the class instance first.\nTo find the pointer chain, you can drop a breakpoint on the actor function,\ngrab the class instance value from ECX when the breakpoint kicks, and throw\nthat value into a Cheat Engine pointer scan. Then, to call the function, you’d\nwalk the pointer chain, obtain the current instance address, and use inline\nassembly to set up ECX and make the actual function call. This process works\nsimilarly to the way VF hook callbacks call their original counterparts, as shown\nin “Writing a VF Table Hook” on page 156.\nResponsive Hacks 217"
  },
  {
    "input": "Resisting Enemy Crowd-Control Attacks",
    "output": "Tying the Pieces Together\nAfter you’ve created frameworks for observing events and performing\nactions, you can tie them together to create responsive hacks. Responsive\nhacks come in many flavors, but there are a few common ones.\nMaking the Perfect Healer\nA favorite bot among gamers is autohealing, a hack that automatically uses a\nhealing spell when the player’s health decreases drastically or drops below\na certain threshold. Given a way to detect changes in health and an actor\nfunction to cast spells, an autohealer might look something like this:\nvoid onHealthDecrease(int health, int delta) {\nif (health <= 500) // health below 500\ncastHealing();\nelse if (delta >= 400) // large drop in health\ncastHealing();\n}\nThis autohealing function is pretty simple, but it works well. More\nadvanced autohealers might have many more levels of healing and be able\nto learn as they go. You’ll get working example code and an in-depth expla-\nnation of advanced autohealers in “Control Theory and Game Hacking” on\npage 222.\nResisting Enemy Crowd-Control Attacks\nAnti-crowd-control hacks detect incoming crowd-control attacks and automati-\ncally cast spells that reduce their effects or completely negate them. Crowd-\ncontrol attacks disable players in some way, so having enemies cast them on\nyou can be a pain.\nGiven a way to detect incoming or active crowd-control effects, such as\nby detecting a Direct3D model or by intercepting an incoming packet, and\nan actor function to cast spells, you could have a bot react instantly to such\nattacks like so:\nvoid onIncomingCrowdControl() {\n// cast a shield to block the crowd control\ncastSpellShield();\n}\nvoid onReceiveCrowdControl() {\n// cleanse crowd control that has already taken effect\ncastCleanse();\n}\nAn onIncomingCrowdControl() function might try to stop the crowd-\ncontrol spell from ever hitting you. Failing that, the bot could call an\nonReceiveCrowdControl() spell to remove the effects.\n218 Chapter 10"
  },
  {
    "input": "Closing Thoughts",
    "output": "Avoiding Wasted Mana\nSpell trainers are also quite common among botters. Spell trainers wait until\nthe player has full mana and then cast spells to increase the player’s magic\nlevel or stats. This allows players to quickly increase their magic skills, as\nthey will never waste mana regeneration just because they have full mana.\nGiven a way to detect changes in mana and an actor function to cast\nspells, a bot might include the following pseudocode for a spell trainer:\nvoid onManaIncrease(int mana, int delta) {\nif (delta >= 100) // player is using mana potions,\nreturn; // they must need the mana, abort\nif (mana >= MAX_MANA - 10) // mana is nearly full, waste some\ncastManaWasteSpell();\n}\nThis function takes the player’s mana and the increase in that player’s\nmana (delta) as parameters. If the increase in mana is above a certain\namount, it assumes the player is using potions or other items to replenish\nmana, and it won’t cast any extra spells. Otherwise, if the player has plenty\nof mana, the function fires off any old spell to get the player some experi-\nence points.\nOther common responsive hacks are autoreload to instantly reload\nammo, autododge to evade incoming projectiles, and autocombo to instantly\nattack the same target as a nearby ally. Really, the only limit to the number\nof responsive hacks you can add to a bot is the number of events your bot\ncan observe in the game, multiplied by the number of valid and helpful\nresponses it can send for each event.\nclosing Thoughts\nUsing hooks, memory manipulation, and keyboard simulation, you can\nbegin creating your first responsive hacks. These hacks are your entry\npoint into gaming autonomy, but they’re only a glimpse of what’s possible.\nChapter 11 will be the pinnacle of your game-hacking adventure. Using\neverything you’ve learned so far, and building on the principles of respon-\nsive hacks, you’ll learn how to automate advanced actions and create a truly\nautonomous bot.\nIf you’re not feeling quite ready to go deeper, I strongly recommend\nreviewing the earlier material and then getting some practice in an isolated\nenvironment on your own machine. Implementing bots like this is a lot eas-\nier than you might think, and it’s an amazingly satisfying experience. Once\nyou’re comfortable making autohealers and other basic responsive hacks,\nyou’ll be ready to start completely automating gameplay.\nResponsive Hacks 219"
  },
  {
    "input": "Chapter 11: Putting It All Together: Writing Autonomous Bots",
    "output": "11\nPut tING It All tOGE tHEr:\nwrItING Aut ONOMOus BOts\nThe end goal of game hacking is to make\na full-fledged automated bot capable of\nplaying a game for hours on end. Such\nbots can heal, drink potions, farm monsters,\nloot corpses, walk around, sell loot, buy supplies, and\nmore. Making bots this powerful requires you to com-\nbine your hooks and memory reads with concepts like\ncontrol theory, state machines, and search algorithms,\nwhich are all covered in this chapter.\nThroughout the lessons here, you’ll also learn about common auto-\nmated hacks and how they should behave at a high level. After covering\nthe theory and code behind automated hacks, I’ll give you a high-level\nlook at two types of bots that rely on such code: cavebots, which can explore"
  },
  {
    "input": "Control Theory and Game Hacking",
    "output": "caves and bring home the loot, and warbots, which can fight enemies for\nyou. By the end of the chapter, you should be ready to bust out your tools,\nfire up your development environment, and start making some really awe-\nsome bots.\ncontrol Theory and Game Hacking\nControl theory is a branch of engineering that provides a way to control the\nbehavior of dynamic systems. Control theory determines the state of a system\nusing sensors, after which a controller determines the set of actions needed to\nbring the system’s current state to some other desired state. After the con-\ntroller executes the first action in the set, the entire process—known as a\nfeedback loop—repeats (see Figure 11-1).\nAction System output\nController System\nSensors\nFigure 11-1: A control theory feedback loop\nLet’s apply this feedback loop to game hacking. To automate play\nwithin a game (the system), a bot implements some algorithms (the con-\ntroller) that understand how to play the game in any state observed by\nthe memory reads, network hooks, and so on (the sensors). The control-\nler typically has some human inputs, like the path to walk, creatures to\nattack, and loot to pick up. Thus, to reach the desired state, the controller\nmust perform some subset of these inputs that are possible given the cur-\nrent state.\nFor instance, if there are no creatures onscreen and no corpses to\nloot, the desired state may be for the player to reach the next location\n(called a waypoint) in the predefined path. In this case, the controller\nmoves the player one step closer to the waypoint on each iteration. If the\nplayer encounters a creature, the controller might decide to attack the\ncreature in the first frame and, in the following frames, switch between\nrunning from the creature (known as kiting) and shooting spells at it.\nOnce the creature dies, the controller executes a set of actions to loot\nthe body and continue to the next waypoint.\nGiven this example of how a feedback loop might operate, it might\nseem overwhelming to code such a system. Luckily, there are a few design\npatterns that make the task much easier than it sounds.\n222 Chapter 11"
  },
  {
    "input": "State Machines",
    "output": "State machines\nState machines are mathematical models\n1 1\nof computation that describe how a sys- 0\ntem behaves based on input. Figure 11-2\nshows a simple state machine that reads Input\nS S\na list of binary digits. The machine 1 2\nstarts with an initial state of S . As it\n1\niterates over the digits in the input, it\nchanges its state accordingly. In this 0\ncase, states S and S repeat themselves\n1 2 Figure 11-2: A simple state machine\nwhen the machine encounters a 1 and\nactivate one another when it encounters\na 0. For example, for the binary digits\n11000111, the state transitions would be\nS , S , S , S , S , S , S , and finally S .\n1 1 2 1 2 2 2 2\nWith a small spin on the classical state machine theory, a state machine\ncan be the controller in a control theory feedback loop. This tweaked ver-\nsion of a state machine comprises a list of states, the conditions signifying\neach state, and the actions that must happen to reach each state.\nstAtE MACHINEs AND GAME HACKING\nA game-hacking state machine not only must keep an internal state but also\nmust respond to (or actuate) the game environment based on that state. The\noverall game state can change based on your bot’s actuation, the behavior\nof other players, and other unpredictable occurrences in the game environ-\nment. For this reason, trying to persistently walk a state machine based on the\nobserved game environment is futile; it’s nearly impossible to create a set of\ntransitions for each state to account for every possible observation that can\nbe made between iterations. It makes more sense for the state machine to\nreevaluate the game environment as a fresh slate each time it considers the\ninput. To do this, the state machine must use the game environment itself as\nthe mechanism for transitioning between states—that is, the machine’s actua-\ntion on the environment should have enough of an effect on the next iterations\nthat it activates a new state. Classical state machines can be devised that are\ncapable of working like this, but we’re going to flatten them out and use them in\na much simpler, yet still very powerful, way.\nIf you’re familiar with classical state machines, this may not seem intuitive,\nbut in the coming sections you’ll see how state machines can be mutated and\npaired with control theory to achieve what we want.\nPutting It All Together: Writing Autonomous Bots 223\nThe major difference is that instead of one state merely activating\nanother, for each state in a game automation state machine, a bot will per-\nform in-game actions that change the overall state of the game and, thus,\nthe state that is detected on the next iteration of the feedback loop. In\ncode, an object to represent a state in this machine might look like this:\nclass StateDefinition {\npublic:\nStateDefinition(){}\n~StateDefinition(){}\nbool condition();\nvoid reach();\n};\nYou can assemble StateDefinition objects into a state machine with a\nsimple std::vector definition, like this:\nstd::vector<StateDefinition> stateMachine;\nAnd presto, you have the skeleton of a state machine, ready to receive\nany StateDefinition objects you create. In conjunction with a feedback loop,\nthis state machine can be used to define the flow of automation.\nFirst, you can create a list of definitions that model your bot’s desired\nbehavior, ordered in the vector by importance. Each StateDefinition object\ncan use information from your sensors as input, passing that data to the\ncondition() function to determine whether or not the state should be acti-\nvated. Then, you can create a controller that loops over the list of states,\ncalling the reach() function of the first state whose condition() function\nreturns false. Finally, you can wrap the controller in a feedback loop. If you\ndon’t see how this feedback loop would work yet, don’t worry; I’ll show you\nhow to code it now.\nNO tE You can think of the statement in your condition() function as a requirement for the\nmachine to transition to the next state. If the statement is true, it means no actuation\nmust happen before the next state in the list can be evaluated and the loop can con-\ntinue iterating. If the statement is false, it means some actuator must occur before the\ntransition can happen.\nYou’ll find all of the example code for the following section and\n“Error Correction” on page 230 in the GameHackingExamples/Chapter11_\nStateMachines directory of this book’s source files. The included projects\ncan be compiled with Visual Studio 2010, but they should also work with any\nother C++ compiler. Download them at https://www.nostarch.com/g amehacking/\nand compile them if you want to follow along.\n224 Chapter 11"
  },
  {
    "input": "A Basic Healer State Machine",
    "output": "combining control Theory and State machines\nTo tie states together with a feedback loop, first you have to provide each\nStateDefinition object with a generic way to access the sensors and actua-\ntors that you’ve implemented. The StateDefinition class then becomes the\nfollowing:\nclass StateDefinition {\npublic:\nStateDefinition(){}\n~StateDefinition(){}\nbool condition(GameSensors* sensors);\nvoid reach(GameSensors* sensors, GameActuators* actuators);\n};\nThis change simply modifies the condition() and reach() functions to\naccept instances of the classes GameSensors and GameActuators as arguments.\nGameSensors and GameActuators are classes you need to define; GameSensors will\ncontain the results of memory reads, network hooks, and other data sources\nyour bot intercepts from the game, while GameActuators will be a collection of\nactor functions capable of performing actions inside the game.\nNext, you need a generic way to define each individual state. You\ncould abstract the definition of each state to its own class that inherits\nStateDefinition and implements condition() and reach() as virtual functions.\nAlternatively, if the source code needs to fit in a small space (like a book,\nwink wink), you could keep a single class to represent each definition and\nuse std::function to implement the condition() and reach() functions outside\nthe class definition.\nFollowing that alternative method, the final version of StateDefinition\nwould look like this:\nclass StateDefinition {\npublic:\nStateDefinition(){}\n~StateDefinition(){}\nstd::function<bool(GameSensors*)> condition;\nstd::function<void(GameSensors*, GameActuators*)> reach;\n};\nWith this version of the StateDefinition class, you could define a new\nstate by creating an instance of the class and assigning condition() and\nreach() to functions that correspond with the intended behavior.\nA Basic Healer State Machine\nThe next step is defining the bot’s actual behavior. To keep the example\ncode simple, let’s say you’re implementing an automatic healer. This healer\nPutting It All Together: Writing Autonomous Bots 225\nhas two healing methods: it uses strong healing if the player is at or below\n50 percent health and weak healing if the player is between 51 and 70 per-\ncent health.\nA state machine representing this behavior needs two states, one for\nstrong healing and one for weak healing. To start, you need to define the\nstate machine as a vector with two StateDefinition objects:\nstd::vector<StateDefinition> stateMachine(2);\nThis code creates a state machine called stateMachine and initializes\nit with two empty StateDefinition objects. Next, you define the condition()\nand reach() functions for these state definitions. The strong healing state is\nthe most important because it keeps the character from dying, so it should\ncome first in the vector, as shown in Listing 11-1.\nauto curDef = stateMachine.begin();\ncurDef->condition = [](GameSensors* sensors) {\nu return sensors->getHealthPercent() > 50;\n};\ncurDef->reach = [](GameSensors* sensors, GameActuators* actuators) {\nv actuators->strongHeal();\n};\nListing 11-1: Code for a strong healing state\nThis code first creates an iterator called curDef that points to the first\nStateDefinition object in the stateMachine vector. The object’s condition()\nfunction is then defined u; in English, this definition says, “The state is met\nif the player’s health percent is greater than 50.” If the state isn’t met, then\nthe object’s reach() function calls the strongHeal() actor function v so that\nstrong healing can be performed.\nWith the strong healing state defined, next you define the weak healing\nstate, as shown in Listing 11-2.\ncurDef++;\ncurDef->condition = [](GameSensors* sensors) {\nu return sensors->getHealthPercent() > 70;\n};\ncurDef->reach = [](GameSensors* sensors, GameActuators* actuators) {\nv actuators->weakHeal();\n};\nListing 11-2: Code for weak healing\nAfter incrementing curDef so it points to the second StateDefinition\nobject in the stateMachine vector, this code defines the object’s condition()\n226 Chapter 11\nfunction u as, “The state is met if the player’s health percent is greater than\n70.” It also defines the object’s reach() function as an actuators->weakHeal()\ncall v.\nOnce you’ve finished defining the state machine, you must imple-\nment the controller. Since the actual behavior of the controller is con-\ntained in the state machine, you only need to add a simple loop to\ncomplete it:\nfor (auto state = stateMachine.begin(); state != stateMachine.end(); state++) {\nif (u!state->condition(&sensors)) {\nstate->reach(&sensors, &actuators);\nbreak;\n}\n}\nThis controller loop iterates over the state machine, executes the\nreach() function of the first state whose condition() function returns false u,\nand breaks out if any reach() function is called. The final step is to imple-\nment the feedback loop and plop the controller loop inside it, as shown in\nListing 11-3.\nwhile (true) {\nfor (auto state = stateMachine.begin();\nstate != stateMachine.end();\nstate++) {\nif (!state->condition(&sensors)) {\nstate->reach(&sensors, &actuators);\nbreak;\n}\nSleep(FEEDBACK_LOOP_TIMEOUT);\n}\nListing 11-3: Final healing state machine and feedback loop\nThis loop continuously executes the controller loop and sleeps for\nFEEDBACK_LOOP_TIMEOUT milliseconds between each execution. The Sleep()\ncall allows the game server to receive and process any actuation from the\nprevious iteration and allows the game client to receive any results of the\nactuation from the server before executing the next controller loop.\nIf you’re still a bit confused about what I just showed you, check out\nFigure 11-3, which shows how the infinitely looping code in Listing 11-3\nworks. First, it checks whether the strong healing condition is true, and if it\nis, the weak healing condition is checked. If the strong healing condition\nis false, then the player’s health must be at or below 50 percent, so a strong\nhealing method gets called. If the weak healing condition check is false,\nthen the player’s health must be between 51 and 70 percent, so the weak\nhealing method is executed.\nPutting It All Together: Writing Autonomous Bots 227"
  },
  {
    "input": "A Complex Hypothetical State Machine",
    "output": "Begin\nwhile (true)\nSleep()\nTrue\nFalse\nWeak healing condition: Weak healing\nPlayer has more than reach()\n70 percent health\nTrue\nFalse\nStrong healing condition: Strong healing\nPlayer has more than reach()\n50 percent health\nFigure 11-3: Flowchart of the healing state machine and feedback loop\nAfter either method, the machine sleeps. If both condition checks are\ntrue, then the player needs no healing. The machine does nothing to change\nthe state and sleeps before starting again at the top of the while loop.\nA Complex Hypothetical State Machine\nThe behavior implemented in the healing state machine is simple, so roll-\ning it into this kind of control structure may seem like overkill, but it’s\nuseful if you want to expand the controller. If, for example, you wanted to\ncombine the healing state machine with the “walk, attack, loot” behavior\nthat I discussed in “Control Theory and Game Hacking” on page 222, the\ncontrol structure would be much more complex. Let’s take a high-level look\nat the states you’d need:\nStrong healing Condition met if health is over 50 percent. Reach by\ncasting strong healing spell.\nWeak healing Condition met if health is over 70 percent. Reach by\ncasting weak healing spell.\nAttack spell Condition met if no target is available or if attack spell is\non cooldown. Reach by casting attack spell on target.\n228 Chapter 11\nKite monster Condition met if no target is available or if distance\nfrom target is adequate. (The definition of “adequate” depends on how\nfar away you want to be from enemies when kiting.) Reach by taking a\nstep away from target.\nTarget monster Condition met if there’s no creature to attack. Reach\nby attacking a creature.\nLoot item Condition met if there’s no corpse open or if open corpse\nhas nothing to loot. Reach by taking an item from open corpse.\nApproach corpse Condition met if there are no corpses to open or if\nadjacent to a corpse. Reach by taking a step toward a corpse that will be\nopened.\nOpen corpse Condition met if the character is not adjacent to a\ncorpse that can be opened. Reach by opening adjacent corpse.\nFollow path Condition met if the character is unable to move to cur-\nrent waypoint or if standing on current waypoint. Reach by taking a\nstep toward current waypoint.\nAdvance waypoint Condition met if there are no waypoints left to\nfollow. Reach by updating the current waypoint to the next waypoint\nin the list. If the character can’t reach the current waypoint for some\nreason (say, if the character is stuck), then the Advance Waypoint state\nkeeps it from being stuck. If the character has reached the current way-\npoint, Advance Waypoint selects the next waypoint to keep things mov-\ning along.\nThis state machine is quite a bit more complex than the healing-\nonly state machine. If I diagrammed this state machine, there would\nbe 23 objects in the diagram, with arrows going over 33 control paths.\nCompare that to Figure 11-3, which has only 7 objects and 9 control paths.\nYou could code the healer behavior without using a state machine or\nfeedback loop, but I can’t imagine how to easily do the same for this full-\nfledged bot. Each of these 10 states relies on not only its own condition\nbut also the condition of every state preceding it. Moreover, hardcoding\nthe logic would either require a ton of nested if() statements or a bunch\nof stacked if()/return() statements—and, either way, it would just behave\nexactly like the state machine but with no runtime flexibility.\nRuntime flexibility refers to a state machine’s ability to mutate. Unlike\nhardcoded condition checks, state definitions in a state machine can be\nmoved, removed, and added dynamically. The state machine method allows\nyou to plug and play different behaviors and features depending on user\ninput.\nTo take this concept a step further, you could expose your sensors and\nactuators to a Lua environment, create Lua functions capable of adding\nand removing states from the state machine, and modify the StateDefinition\nso that its condition() and reach() functions can call Lua functions exposed\nby the Lua environment. Writing a control system this way would allow you\nPutting It All Together: Writing Autonomous Bots 229"
  },
  {
    "input": "Error Correction",
    "output": "to code the core of your bot (hooks, memory reading, actuation) in C++\nwhile making Lua (a high-level, dynamic language) available to you for\nautomation.\nNO tE You can embed Lua in your own programs by including a few headers and link-\ning against the Lua library. This process is not difficult, but it’s outside the scope of\nthis book, so I encourage you to check out Chapter 24 of Programming in Lua by\nRoberto Ierusalimschy (http://www.lua.org/pil/24.html) for more information.\nError Correction\nAnother piece of control theory that’s useful for game hacking is error correc-\ntion. An error correction mechanism in a controller observes the outcome\nof actuation, compares the outcome to an expected result, and adjusts future\ncalculations to bring later outcomes closer to the expected one. Error correc-\ntion can come in handy when you’re working with stochastic systems, where\nthe output generated from a given input is not fully predictable.\nGames as a whole are stochastic, but, luckily for game hackers, the results\nof actions are mostly deterministic. Take the healing controller, for example.\nIn most games, you can calculate exactly how much health you can heal\nwith a given spell, and, thus, you know exactly when to heal. But imagine\nyou’re writing a healer for the small spectrum of situations where your heal-\ning is impossible to calculate; for instance, maybe the bot is supposed to\nwork on a variety of characters spanning many levels without user input.\nError correction could enable your bot to learn how to best heal the\nplayers. In this scenario, there are two ways you can implement error cor-\nrection, each of which depends on how the healing system works.\nadjusting for a Constant ratio\nIf you heal for a constant ratio of health, you’ll only need to adjust your con-\ntroller after the first heal. Assuming that your sensors can detect how much\nyou’ve healed, this adds only a few lines of code. You could easily modify the\nweak healing state in Listing 11-2 to something like this:\ncurDef->condition = [](GameSensors* sensors) -> bool {\nstatic float healAt = 70;\nstatic bool hasLearned = false;\nif (!hasLearned && sensors->detectedWeakHeal()) {\nhasLearned = true;\nhealAt = 100 - sensors->getWeakHealIncrease();\n}\nreturn sensors->getHealthPercent() > healAt;\n};\nInstead of hardcoding 70 as the threshold for weak healing, this code\nmoves the threshold to a static variable called healAt. It also adds another\nstatic variable called hasLearned so that the code knows when learning is\ncomplete.\n230 Chapter 11\nOn each invocation of this condition() function, the code checks two\nconditions: whether hasLearned is false and whether the sensors detected a\nweak healing event. When this check passes, the code sets hasLearned to true\nand updates healAt to heal at or below the perfect percentage; that is, if your\nweak healing mustered up a 20 percent increase in health, healAt would be\nset to 80 percent health instead of 70 percent, so each heal would bring the\nplayer back up to 100 percent health.\nImplementing adaptable Error Correction\nBut what if your healing power increases? If a character can gain levels,\napply skill points, or increase maximum health, the amount of health it can\nheal may change accordingly. For example, if you start a bot on a level-10\ncharacter and let it run until the character is level 40, your healing code\nwill need to adapt. A level-40 character healing like it did at level 10 would\neither immensely overheal or die quickly against on-level game enemies.\nTo handle this scenario, a bot needs to constantly update its healing\nthreshold to reflect the observed healing amount. Listing 11-4 shows how you\ncan modify the strong healing condition function in Listing 11-1 to do this.\ncurDef->condition = [](GameSensors* sensors) -> bool {\nstatic float healAt = 50;\nu if (sensors->detectedStrongHeal()) {\nauto newHealAt = 100 - sensors->getStrongHealIncrease();\nv healAt = (healAt + newHealAt) / 2.00f;\nw sensors->clearStrongHealInfo();\n}\nreturn sensors->getHealthPercent() > healAt;\n};\nListing 11-4: Tweaking the strong healing condition code\nAs in the modified weak healing function, the healing threshold has\nbeen moved to a static variable called healAt, but this time, the logic is a bit\ndifferent. Since learning must happen continually, there’s no variable to\ntrack whether the bot has already learned its true healing capacity. Instead,\nthe code just checks whether the sensors have seen a strong healing event\nsince its last invocation u. If so, the code replaces healAt with the average of\nhealAt and newHealAt and calls a function to clear the sensors of information\nrelated to strong healing w.\nClearing the sensors is actually very important, because it keeps the\ncode from constantly updating healAt against feedback from the same\nstrong healing cast. Notice, too, that this function doesn’t update healAt\nto a perfect value but instead slides it toward the observed optimal value.\nThis behavior makes the new function ideal for situations where there is\nsome amount of randomness in how much you can actually heal. If your bot\nneeds to slide toward the new value faster, you might change the line at v\nto something like this:\nhealAt = (healAt + newHealAt * 2) / 3.00f;\nPutting It All Together: Writing Autonomous Bots 231"
  },
  {
    "input": "Pathfinding with Search Algorithms",
    "output": "This code to update healAt uses an average weighted toward the newHealAt\nvalue. There are a few points to consider when using this approach, however.\nFirst, what happens when you overheal? In some games, when you heal to\nfull health, your sensors might be able to detect only how much you actu-\nally healed. In other games, your sensors may be able to detect the actual\namount healed. Put another way, if you cast a 30 percent strong heal from\n85 percent health, do your sensors see a heal of 30 percent or 15 percent?\nIf the answer is 30 percent, you’re set. If the answer is 15 percent, your code\nneeds a way to adjust downward.\nOne way to adjust accordingly is to decrement healAt when your sensors\nsee a heal that brings you to full health, like this:\ncurDef->condition = [](GameSensors* sensors) -> bool {\nstatic float healAt = 50;\nif (sensors->detectedStrongHeal()) {\nu if (sensors->getStrongHealMaxed()) {\nhealAt--;\n} else {\nauto newHealAt = 100 - sensors->getStrongHealIncrease();\nhealAt = (healAt + newHealAt) / 2.00f;\n}\nsensors->clearStrongHealInfo();\n}\nreturn sensors->getHealthPercent() > healAt;\n};\nThis code is almost the same as Listing 11-4, but it adds an if() clause\nto decrement healAt if a max heal is detected u. Otherwise, the function\nshould behave like Listing 11-4.\nHealing is a simple case, but this code shows a great example of how\nyou can use error correction to dynamically improve your bots’ behavior.\nOne more advanced use case is adjusting skillshots to account for enemy\nmovement patterns. Every player has patterns in how they avoid skillshots,\nso if your sensors are able to measure the direction and distance an enemy\nmoves when dodging a skillshot, your controller code can adjust the loca-\ntion where the bot initially shoots the skillshot. In this same scenario, learn-\ning would also help the bot account for differences in game server latency,\ncharacter movement speed, and so on.\nWhen using error correction, note that your code will be cleaner and\nmore portable if your state definitions have some form of internal book-\nkeeping other than static variables. Moreover, to avoid cluttering your state\ndefinitions, I suggest encapsulating the error correction logic in some\nexternal modules that are easily invoked when needed.\nPathfinding with Search algorithms\nOne common challenge you’ll face when writing an autonomous bot is cal-\nculating a path for a character to follow from one location to another. Aside\nfrom the sheer reverse engineering challenge of creating sensors to read\n232 Chapter 11"
  },
  {
    "input": "How Obstacles Disrupt Searches",
    "output": "which coordinates on the game map are blocking forward movement or\nnot, there’s also the algorithmic challenge of calculating a path within that\nmap. Calculating a path is called pathfinding, and game hackers often use a\nsearch algorithm to tackle it.\nTwo Common Search Techniques\nGiven a grid of tiles, a starting location a, and an ending location b, a\nsearch algorithm calculates a path from a to b. The algorithm does this\nby creating a node at a, adding nodes adjacent to a to a list of tiles to be\nexplored (called the frontier), updating the node to the best tile in the fron-\ntier, and repeating the process until the node reaches b. Different search\nalgorithms select the best node differently, using either a cost, a heuristic,\nor both.\nDijkstra’s algorithm, for example, calculates the cost of a tile based on its\ndistance from the a node and selects the tile with the lowest cost. Imagine\nan empty two-dimensional grid with a in the middle. In a search following\nDijkstra’s algorithm, the frontier will expand in a circular pattern around a\nuntil b lies on the edge of the circle, as seen in Figure 11-4.\nThe greedy best-first search algorithm, instead of prioritizing nodes by\ntheir distance from the starting point, uses a heuristic to estimate the dis-\ntance from a node in the frontier to b. The algorithm then selects the node\nwith the shortest estimated distance. Imagine this algorithm in the same\ngrid as before; the frontier would be a line going almost directly from a to\nb, as seen in Figure 11-5.\nb\na\nb\na\nFigure 11-4: The frontier of Dijkstra’s Figure 11-5: The frontier of the\nalgorithm. Lighter tiles are higher cost. greedy best-first search algorithm.\nLighter tiles are higher cost.\nHow Obstacles Disrupt Searches\nThe difference in how these algorithms behave becomes clearer once obsta-\ncles are added to the grid. If, for instance, a wall separates a and b, Dijkstra’s\nPutting It All Together: Writing Autonomous Bots 233"
  },
  {
    "input": "An A* Search Algorithm",
    "output": "algorithm will always find the quickest path, but with a huge consequence.\nThe radius of the circular frontier around a will be equal to the length of\nthe final path; let’s call that radius r. If no grid boundaries clip the frontier,\nyou can roughly calculate the number of nodes opened by taking the area\nof a circle with radius r. If the path around the wall is 50 tiles, the algorithm\nwill open roughly 7,854 tiles, as shown in this equation:\nπ × 502 = 7,854\nIn the same scenario, greedy best-first search will calculate a less-than-\noptimal path but open substantially fewer tiles. It’s not as easy to visualize\nhow the frontier will expand, and it’s not important right now, so I won’t go\ninto it here. At the end of the day, neither of these algorithms really fits the\npathfinding problem well. The optimal path is slow, and the fast path isn’t\noptimal.\nTo quickly calculate an optimal path, you need to fuse Dijkstra’s algo-\nrithm with greedy best-first search. Luckily, someone has already done this,\nand the resulting algorithm is a monster known as A-star search (often just\ncalled A*).\nA* uses the sum of a cost, called g, and a heuristic, called h, to select\nnodes. These resulting sum is called the score. Put simply, score = g + h. Like\nDijkstra’s algorithm, A* can calculate the most optimal path from a to b,\nand like greedy best-first search, it can do so relatively quickly.\nAn A* Search Algorithm\nNow that you know the fundamentals, let’s write code to implement the\nA* algorithm. This implementation will work in a two-dimensional grid. It\nwon’t allow diagonal movement at first, but I’ll discuss in a bit how you can\nmodify the code to work with diagonal movement, too.\nAll of the example code for this section is in the GameHackingExamples/\nChapter11_SearchAlgorithms directory of this book’s source files. The included\nprojects can be compiled with Visual Studio 2010, but they should also work\nwith any other C++ compiler. Download them at https://www.nostarch.com/\ngamehacking/ and compile them to follow along. If you execute Chapter11_\nSearchAlgorithms.exe, you’ll be able to define your own 20×20 grid and watch\nthe algorithm calculate a search path.\nCreating an a* Node\nTo start, define an empty AStarNode class as follows:\ntypedef std::shared_ptr<class AStarNode> AStarNodePtr;\nclass AStarNode\n{\npublic:\n};\nThis code defines the AStarNode class and a std::shared_ptr type defini-\ntion called AStarNodePtr to make it easier to create safe pointers to the class.\n234 Chapter 11\nNext, within the public scope of this class, declare member variables for the\nnode’s x-position, y-position, cost, and node’s score:\nint x, y;\nint g, score;\nAdditionally, you need a public member of type AStarNodePtr that refer-\nences the parent node:\nAStarNodePtr parent;\nAfter declaring all member variables, declare a public constructor that\ninitializes them upon instance creation, as follows:\nAStarNode(int x, int y, int cost, AStarNodePtr p, int score = 0)\n: x(x), y(y), g(cost), score(score), parent(p)\n{}\nNow, to make creating safe pointers easier, add a static helper function\nlike this:\nstatic AStarNodePtr makePtr(\nint x, int y, int cost,\nAStarNodePtr p,\nint score = 0)\n{\nreturn AStarNodePtr(new AStarNode(x, y, cost, p, score));\n}\nThis makePtr() function creates a new instance of AStarNode and returns\nthe instance wrapped inside of an AstarNodePtr.\nLet’s recap. The AStarNode class has member variables x, y, g, score, and\nparent. When the class is constructed, all of these members are initialized\nfrom values passed to the constructor, with the exception of score, which\nis optional (because you use it only when making copies of an AStarNode\ninstance) and set to 0 if not provided.\nNext, define a public member function to calculate the heuristic when\ngiven the destination coordinates:\nint heuristic(const int destx, int desty) const\n{\nint xd = destx - x;\nint yd = desty - y;\nu return abs(xd) + abs(yd);\n}\nThis function returns the Manhattan distance heuristic u, a distance cal-\nculation designed for grids where diagonal movement is not possible:\n∆x + ∆y\nPutting It All Together: Writing Autonomous Bots 235\nTo calculate a path that allows diagonal movement, you’d need to\nmodify this function to use the Euclidean distance heuristic, which looks\nlike this:\n(∆x × ∆x) + (∆y × ∆y)\nThe class also needs a function to update score. You add that function\nto the public scope as follows:\n#define TILE_COST 1\nvoid updateScore(int endx, int endy)\n{\nauto h = this->heuristic(endx, endy) * TILE_COST;\nthis->score = g + h;\n}\nNow, score should change to g + h when given destination coordinates\nto calculate h.\nTo wrap up, the node class also needs a function that can calculate all\nof its child nodes. The function could do this by creating new nodes for\neach tile adjacent to the current node. Each new node refers to the current\nnode as its parent, so the class needs to be able to create an AStarNodePtr to a\ncopy of the current node as well. Here’s how all that works:\nAStarNodePtr getCopy()\n{\nreturn AStarNode::makePtr(x, y, g, parent, score);\n}\nstd::vector<AStarNodePtr> getChildren(int width, int height)\n{\nstd::vector<AStarNodePtr> ret;\nauto copy = getCopy();\nif (x > 0)\nu ret.push_back(AStarNode::makePtr(x - 1, y, g + TILE_COST, copy));\nif (y > 0)\nv ret.push_back(AStarNode::makePtr(x, y - 1, g + TILE_COST, copy));\nif (x < width - 1)\nw ret.push_back(AStarNode::makePtr(x + 1, y, g + TILE_COST, copy));\nif (y < height - 1)\nx ret.push_back(AStarNode::makePtr(x, y + 1, g + TILE_COST, copy));\nreturn ret;\n}\nThis function creates child nodes at (x – 1, y) u, (x, y – 1) v, (x + 1,\ny) w, and (x, y + 1) x. Their parent is the node that called getChildren, and\ntheir g is the parent’s g plus TILE_COST.\nTo allow for diagonal movement, this function needs to add children\nat (x – 1, y – 1), (x + 1, y – 1), (x + 1, y + 1), and (x – 1, y + 1). Additionally, if\n236 Chapter 11\nmoving diagonally would cost more—that is, if the character requires more\ntime to do it—you’d also need to do the following:\n1. Change TILE_COST to 10.\n2. Define a constant DIAG_TILE_COST as TILE_COST multiplied by the time\nincrease. If a diagonal step takes 1.5 times as long, DIAG_TILE_COST would\nbe 15.\n3. Give diagonal children a g of the parent’s g plus DIAG_TILE_COST.\nTo finish off AStarNode, declare operators for comparing the priority and\nequality of two nodes. You could place these declarations outside the class\nin global scope like this:\nu bool operator<(const AStarNodePtr &a, const AStarNodePtr &b)\n{\nreturn a.score > b.score;\n}\nv bool operator==(const AStarNodePtr &a, const AStarNodePtr &b)\n{\nreturn a.x == b.x && a.y == b.y;\n}\nThese operators allow std::priority_queue to sort nodes by score u and\nstd::find to determine node equality by location v.\nWriting the a* Search Function\nNow that you’ve completed the AStarNode class, you can code the actual\nsearch function. Start by defining the function prototype:\ntemplate<int WIDTH, int HEIGHT, int BLOCKING>\nbool doAStarSearch(\nint map[WIDTH][HEIGHT],\nint startx, int starty,\nint endx, int endy,\nint path[WIDTH][HEIGHT])\n{ }\nThe prototype accepts the game map’s width and height, as well as the\nvalue that signifies a blocking tile on the map, as template parameters. The\ndoAStarSearch() function also takes the map itself (map), the starting coordi-\nnates (startx and starty), the destination coordinates (endx and endy), and a\nblank map (path) where it can fill the calculated path when it finishes.\nNO tE The first three parameters are template parameters, so you can pass them as compile-\ntime constants. I’ve done this for the example code to allow explicit array size declara-\ntions for the map and path parameters and to allow a definite value to signify blocking\ntiles on the map. In practice, the map you read from a game will have a dynamic size,\nand you’ll probably need a more robust way to pass this data.\nPutting It All Together: Writing Autonomous Bots 237\nNext, the doAStarSearch() function needs a sorted list to hold the fron-\ntier and a container to track all created notes so you can update the score\nand parent of an existing node if it’s opened as a child of a different parent.\nYou can create these as follows:\nstd::vector<AStarNodePtr> allNodes;\nstd::priority_queue<AStarNodePtr> frontier;\nThe frontier is defined with std::priority_queue since it can automati-\ncally sort the nodes based on their score. The node container, allNodes, is\ndefined as a std::vector.\nNow, let’s create the first node:\nauto node = AStarNode::makePtr(startx, starty, 0, nullptr);\nnode->updateScore(endx, endy);\nallNodes.push_back(node);\nThe first node is a no-cost orphan node at the position (startx, starty).\nThe node is given a score based on what the updateScore() function returns,\nand then it’s added to the allNodes container.\nWith a node in the container, it’s time to write the meat of the A* algo-\nrithm, starting with a simple loop:\nwhile (true) {\n}\nUntil otherwise specified, the rest of the code in this section will appear\ninside of this loop, in the order shown.\nFrom here, the first step is to check the goal state. In this case, the goal is\nto find a path for the player to follow to the next waypoint, which happens\nwhen the node object’s position is (endx, endy). Thus, to check the goal state,\nthe program needs to check whether node has reached those coordinates or\nnot. Here’s how that check should look:\nif (node->x == endx && node->y == endy) {\nmakeList<WIDTH, HEIGHT>(node, allNodes, path);\nreturn true;\n}\nWhen the goal state is met, the program reports true back to the caller\nand fills path with the final path. For now, assume a function called makeList()\ncan fill in path for you; I’ll show you this function shortly. If the goal state isn’t\nmet, you need to expand the children of node, which is actually a pretty com-\nplicated process:\nauto children = node->getChildren(WIDTH, HEIGHT);\nfor (auto c = children.begin(); c != children.end(); c++) {\nu if (map[(*c)->x][(*c)->y] == BLOCKING) continue;\n238 Chapter 11\nauto found = std::find(allNodes.rbegin(), allNodes.rend(), *c);\nv if (found != allNodes.rend()) {\nw if (*found > *c) {\n(*found)->g = (*c)->g;\n(*found)->parent = (*c)->parent;\n(*found)->updateScore(endx, endy);\n}\n} else {\n(*c)->updateScore(endx, endy);\nx frontier.push(*c);\ny allNodes.push_back(*c);\n}\n}\nAfter calling node->getChildren to generate a list of nodes that can be\nadded to the frontier, the code iterates over each child and ignores any that\nare on blocking tiles u. Next, for each child, the code checks whether a node\nhas already been opened at the same coordinates v. If so, and if the score\nof the existing node is greater than the score of the new child, the exist-\ning node is updated to the parent, cost, and score of the new child by the\nif() statement at w. If the new child doesn’t have a brother-from-another-\nmother, it will be added as is to the frontier x and the node list y.\nAlso notice that std::find uses the reverse begin and reverse end itera-\ntors of allNodes instead of the regular iterators u. The example does this\nbecause new nodes are appended to the end of the vector and duplicate\nnodes will be close together, so duplicates will usually be closer to the end\nof the vector. (This step could also be done directly against the frontier, but\nstd::priority_queue doesn’t allow iteration over nodes and writing the sort in\nplace would make the code too large for print.)\nEventually, the function will run out of new children to add to the fron-\ntier; the following if() statement handles that situation:\nif (frontier.size() == 0) return false;\nu node = frontier.top();\nv frontier.pop();\nThis code points node to the cheapest node from the frontier u, removes\nit from the frontier v, and lets the loop repeat. If the frontier ends up empty,\nthe function reports false back to the caller, since there’s nothing left to\nsearch.\nCreating the Path List\nFinally, it’s time to implement the makeList() function:\ntemplate<int WIDTH, int HEIGHT>\nvoid makeList(\nAStarNodePtr end,\nstd::vector<AStarNodePtr> nodes,\nint path[WIDTH][HEIGHT])\nPutting It All Together: Writing Autonomous Bots 239"
  },
  {
    "input": "When A* Searches Are Particularly Useful",
    "output": "{\nfor (auto n = nodes.begin(); n != nodes.end(); n++)\nu path[(*n)->x][(*n)->y] = 2;\nauto node = end;\nwhile (node.get() != nullptr) {\nv path[node->x][node->y] = 1;\nnode = node->parent;\n}\n}\nThis function updates path with both a list of closed nodes u and the\ncalculated path v. For this example, the value 2 represents the closed nodes\nand 1 represents the path nodes. The program calculates nodes in the path\nby following parent nodes from the goal node until it reaches the starting\nnode, which is an orphan with nullptr as a parent.\nWhen A* Searches Are Particularly Useful\nMake sure to play with the example code and executable for the previous\nsection, because that’s the only way you’ll really get acquainted with the\nbehavior of A* searches. In most newer games, you should be able to just\nsend a packet with the destination or even emulate a click on the map at the\ndesired spot, but when you come across a situation where you need to calcu-\nlate a path, you’ll be glad you learned A*.\nThere are actually many situations where calculating a path can be\nuseful:\nSelecting targets\nWhen your bot is selecting targets to attack, you may want to check\nwhether your character can actually reach them. Otherwise, if an\nenemy is isolated in an unreachable room, you might get stuck in\nplace trying to target them forever!\nSelecting corpses\nAs your looting state(s) determine which corpses to open, you can opti-\nmize by always trying to loot the closest corpse first.\nEmulating mouse movements\nVery rarely, some heavily protected games actually correlate in-game\nactions with mouse movements to ensure that there’s no bot running.\nIn this case, you might need to emulate the mouse. Using a modified\nversion of A* where the screen is the map, there are no blocking tiles,\nand node costs are slightly randomized, you can calculate human-like\npaths for your mouse to follow when you simulate movement.\nKiting monsters\nIf you ever need to write code to kite monsters, you can implement A*\nwith a goal state of being N units away from all creatures. Using the\nsame cost mechanism shown in this chapter, play with the heuristic\n240 Chapter 11"
  },
  {
    "input": "Looting with Cavebots",
    "output": "to give a higher cost to nodes that are closer to creatures. Kiting\nisn’t exactly a conventional use case, and the heuristic will require a\nbunch of tweaking, but it works amazingly once you’ve got it going.\nSome implementations can kite any number of monsters better than\na human!\nPredicting enemy movements\nIf you’re writing a bot that fights other players, you can use A* to pre-\ndict their movements and act accordingly. For instance, if your enemy\nstarts running away, your bot can assume they are running to their\nbase, calculate their route, and use a spell to block their path or even\nteleport to a location where it expects them to be.\nThese are just a few use cases for A* searches, and you’ll definitely\nfind many more as you improve your bots. For the rest of the chapter, I’ll\ndescribe some popular automated hacks that you can implement using the\ntechniques described in this book.\nOtHEr usEs fOr A* sEArCH\nA* isn’t just for calculating paths. With abstractions on top of the AStarNode\nclass, you can adapt the same algorithm to any search problem. Realistically,\nA* is just a weighted iteration over a multidimensional data set that iterates\nuntil some goal object is found, and, thus, it can solve any problem that can be\nrepresented as a multidimensional data set. More advanced applications for\nA* include playing chess and checkers, and—when it’s paired with a three-\ndimensional Manhattan distance heuristic and a depth-first search implementa-\ntion—even solving a Rubik’s cube. Sadly, I’m not going to go into these use\ncases; if you want to get really good with search algorithms, I encourage you\nto research more online.\ncommon and cool automated Hacks\nNow that you’ve seen the design patterns and algorithms needed to create\nefficient, self-teaching bots, it’s time to learn about some popular auto-\nmated hacks that go beyond simple healing and pathfinding. Let’s fly up to\n10,000 feet to explore two types of bots at a high level.\nLooting with Cavebots\nWhile discussing control theory, state machines, and search algorithms, I\ntouched on the idea of a cavebot that kills creatures, grabs loot, and walks\naround caves. The abilities of cavebots can vary greatly.\nPutting It All Together: Writing Autonomous Bots 241\nDepositing Gold and restocking Supplies\nIf you want to leave a character botting for days on end, you’ll need a deposi-\ntor and a refiller. A depositor can deposit loot in your bank or vault, while a\nrefiller refills your potions, runes, and other supplies. These features can be\ndescribed with six basic states:\nLeave spawn Condition met if the character is in the spawn area or\ncave, if it has nothing to deposit, and if it has enough supplies. Reach\nthis state by exiting the spawn area or cave.\nWalk to town Condition met if the character is in the spawn area or\ncave. Reach this state by walking from the spawn or cave to town.\nDeposit Condition met if the character is in the spawn area or cave,\nor if the character is in town and has nothing to deposit. Reach this\nstate by putting loot in the bank or vault.\nWithdraw cash Condition met if the character is in the spawn area\nor cave, is in town with no supplies to purchase, or has enough gold to\npurchase supplies. Reach this state by withdrawing gold from the bank\nor vault.\nPurchase supplies Condition met if the character is in the spawn area\nor cave or if the character has enough supplies to start hunting. Reach\nby buying supplies.\nEnter spawn Condition met if the character is in the spawn area or\ncave. Reach this state by walking to the spawn area or cave.\nThese states would come before the states related to following waypoints\n(I describe a couple of those states in “A Complex Hypothetical State\nMachine” on page 228) in the vector of StateDefinition objects. Placing\nthem first gives them priority over remaining in the cave, while still allow-\ning the character to target, kill, and loot monsters on the way back to town.\nDepending on where you’re hunting and how you want the bot to behave,\nyou may also tell your targeting states not to attack creatures if the charac-\nter isn’t in the spawn area or cave, and you might add an extra state before\nwalk to town that attacks only creatures that block the character’s path to\ntown. Specifying that extra state increases the bot’s efficiency, since trips to\nand from town will be much quicker if the monsters on the way aren’t worth\nkilling.\nUsing the Character as Bait\nTwo other cavebot features that can make your bot awesome are lure mode\nand dynamic lure. You wouldn’t implement these two features as actual states\nin a complex bot; rather, you’d have them inform the bot’s targeting and\nwalking states to help the bot make decisions.\nYou can control lure mode with special waypoints in your path, and its\ncode will tell your targeting states to attack creatures only if the bot is stuck,\nsimilar to the mechanism discussed for walking to or from town. The differ-\nence is that lure mode can be switched on and off at different areas in the\n242 Chapter 11"
  },
  {
    "input": "Automating Combat with Warbots",
    "output": "cave, allowing you to lure multiple mobs of monsters to certain locations\nbefore attacking them. This can make your bot much more efficient, as cer-\ntain types of characters may excel at killing many monsters at once.\nDynamic lure is similar, but instead of turning it on and off at definite\nlocations via waypoints, you can automatically turn lure mode on when\nthere aren’t enough monsters. For example, a bot with the dynamic lure\nfeature might tell the targeting states not to attack any creature until five\nmonsters are on screen. The targeting states would resume attacking and\nkiting until all five monsters are dead, and the bot would snap back into\nlure mode until a suitably sized mob appears again.\nIf your character is quick enough to outrun monsters, though, you’ll\nneed to modify your bot’s walking states to walk slowly when lure mode is\non and creatures are present. Otherwise, your character will leave mobs\nbehind without killing them. You can slow down a character by adding\na state before the follow path state in your state machine definition that\ndelays movement slightly when lure mode is on and any creatures are too\nfar away.\nallowing Players to Script Custom Behaviors\nNearly every cavebot includes a scripting interface that allows players to add\ntheir own behaviors. You could implement this interface as a way to specify\ncustom waypoints to follow, spells to use, or items to loot. In more advanced\nbots, you might make your targeting, looting, walking, and luring systems\nas dynamic as possible so players can add unique features. If you implement\nyour automation in Lua, third parties could easily improve and expand your\nbot’s abilities.\nMaking your bot easy to write scripts for takes a lot of work off your\nshoulders, since other programmers who play the game might release\nscripts to add support for new hunting spots and improve your automation.\nSuch scripting services are common in botting communities, and players\noften create and sell professional-grade scripts that integrate with bots.\nAutomating Combat with Warbots\nAnother class of automated bots is used for player versus player (PvP) combat.\nThese warbots, or PvP bots, have many features categorized as responsive\nor ESP hacks, since the bots focus on responding to incoming damage or\nspells, revealing hidden enemies, and giving the player an information\nadvantage.\nFully automated warbots are rare, but I’ve already lightly discussed how\nyou can use some automation techniques to make smarter healers, teach\nbots to land more accurate skillshots, and predict players’ paths to stop\nthem in their tracks. Let’s explore a few other cool hacks that fall on the\nfringe of responsive, ESP, and automated.\nNO tE In games that are completely PvP based, such as battlegrounds or real-time strategy\ngames, some players might also just call these bots, since war or PvP is the bot’s only\npurpose.\nPutting It All Together: Writing Autonomous Bots 243"
  },
  {
    "input": "Closing Thoughts",
    "output": "Autowall Bots\nIf your character has a spell to create a temporary wall, you can code\na bot that automatically blocks enemy players when they enter small\ncorridors. Using error correction, the bot could learn how far ahead of\nthe enemy to place the wall. With some really creative engineering, the\nbot could even learn which enemies can jump over walls by checking\nwhether each enemy manages to get past the wall before it disappears.\nAutosnipe Bots\nFor characters with a long-range skillshot or global execution spell, you\ncan use automation to detect when an enemy across the map has low\nhealth and cast your spell to kill them. You can also use error correc-\ntion to more accurately guess where to shoot a long-range skillshot. If\nyou’re unable to calculate exact damage amounts, error correction can\nalso help a bot determine how much damage a spell does and tweak the\ncasting threshold accordingly.\nAutokite Bots\nIf you’re playing a carry character that does most of its damage by\nattacking at a short distance, you might implement a bot to automati-\ncally kite enemies. Using a set of states similar to the ones a cavebot\nmight use to kite monsters, you can make a bot that automatically kites\nenemy characters when you attack them. When you stop targeting the\nenemy, the bot can stop kiting. Using A* search, you can improve the\nkiting mechanism to avoid multiple enemies, or, if you want to escape\nwhile attacking, guide the kiting mechanism back to a safe place, such\nas your team’s base or a neutral location.\nclosing Thoughts\nBy this point, you should be ready to go out and make some pretty awesome\nbots. Don’t worry if you’re still not completely comfortable with the tech-\nniques in this chapter; the best way to learn is to just dive in and start hack-\ning. Use the thousands of lines of example code provided for this book to\nget started without working from scratch, and most of all, have fun!\nIn the next chapter, I’ll discuss ways that bots can hide from anti-cheat\nmechanisms, which are pieces of software that games use to detect and stop\nbotters.\n244 Chapter 11"
  },
  {
    "input": "Chapter 12: \rStaying Hidden",
    "output": "12\nstAyING HIDDEN\nGame hacking is an ever-evolving prac-\ntice, a game of cat and mouse between\nhackers and game developers where each\nparty works to subvert the other. As long as\npeople make bots, game companies will find ways to\nhinder bot advances and ban players who use bots.\nRather than making their games inherently harder to\nhack, though, game companies focus on detection.\nThe largest game companies have very sophisticated detection suites\ncalled anti-cheat software. In the beginning of this chapter, I’ll discuss the\ncapabilities of the most common anti-cheat suites. After revealing how these\nsuites detect bots, I’ll teach you some powerful ways to evade them."
  },
  {
    "input": "Signature-Based Detection",
    "output": "Prominent anti-cheat Software\nThe best-known anti-cheat suites use the same methods as most antivirus soft-\nware to scan for bots and flag them as threats. Some anti-cheat suites are also\ndynamic, meaning their inner workings and capabilities can change based\non the game they’re protecting. Anti-cheat software developers also track\ndown and patch their suites against bypass software, so always do your own\nin-depth research of any anti-cheat software that you might face.\nWhen these suites detect a botter, they flag the botter’s account for ban-\nishment. Every few weeks, game company administrators ban the flagged\nplayers in a ban wave. Game companies use ban waves instead of instan-\ntaneous bans because banning in waves is more profitable. If botters are\nbanned after a few weeks of playing, their familiarity with the game will\nmake them more likely to buy a new account than if they were banned the\nmoment their bot started running.\nThere are dozens of anti-cheat suites, but I’ll focus on the five packages\nthat are the most common and thoroughly understood: PunkBuster, ESEA\nAnti-Cheat, Valve Anti-Cheat (VAC), GameGuard, and Warden.\nThe Punkbuster Toolkit\nPunkBuster, made by Even Balance Inc., is the original anti-cheat tool-\nkit. Many games use PunkBuster, but it’s most common in first-person\nshooter games like Medal of Honor, Far Cry 3, and several installments of\nthe Battlefield series.\nThe toolkit uses a myriad of detection methods, the most formidable of\nwhich are signature-based detection (SBD), screenshots, and hash valida-\ntion. PunkBuster is also known for imposing hardware bans that perma-\nnently ban a cheater’s computer, rather than just their game account, by\nsaving a fingerprint of the hardware’s serial numbers and blocking logins\nfrom a machine that matches it.\nSignature-Based Detection\nPunkBuster scans the memory of all processes on a system running a game\nthat employs it, searching for byte patterns unique to known cheat software,\ncalled signatures. If PunkBuster detects a signature, the player is flagged\nfor a ban. PunkBuster carries out memory scans from user mode using the\nNtQueryVirtualMemory() Windows API function, and it sometimes runs scans\nfrom multiple hidden processes.\nSignature-based detection is blind to context by design, and it ulti-\nmately suffers from a fatal flaw: false positives. On March 23, 2008, a team\nof hackers set out to prove the existence of this flaw by spamming public\nchatrooms with a text string that PunkBuster would identify as a bot signa-\nture. Since SBD blindly scans process memory for matching patterns, any\nand all legitimate players inside these public chatrooms were flagged as\nbotters.\n246 Chapter 12"
  },
  {
    "input": "The VAC Toolkit ",
    "output": "This caused thousands of fair players to be banned with no justification.\nA similar situation happened again in November 2013: PunkBuster falsely\nbanned thousands of players on Battlefield 4. That time, no one was trying to\nprove a point; the company had just added a bad signature to its software.\nPunkBuster resolved both of these issues by restoring the players’\naccounts, but these incidents show just how aggressive its flavor of SBD is.\nIn the time since these attacks, though, PunkBuster’s SBD has reduced\nthe number of false positives by checking only for signatures at predefined\nbinary offsets.\nScreenshots\nAs another method of bot detection, PunkBuster also periodically takes\nscreenshots of a player’s screen and sends them to the central game server.\nThis form of detection is a nuisance, and it’s weak compared to SDB. Game-\nhacking communities speculate that PunkBuster implemented this feature\nto give game admins proof against botters who dispute bans.\nHash Validation\nIn addition to employing SBD and screenshots, PunkBuster detects bots by\ncreating cryptographic hashes of a game’s executable binaries on a player’s\nsystem and comparing them to hashes stored on a central server. If the\nhashes do not match, the player is flagged for a ban. This check is carried\nout only on the binaries on the filesystem, not on in-memory binaries.\nThe eSea anti-cheat Toolkit\nThe ESEA Anti-Cheat toolkit is used by the E-Sports Entertainment Association\n(ESEA), primarily for its Counter-Strike: Global Offensive league. Unlike\nPunkBuster, this suite is known for generating very few false positives and\nbeing highly effective at catching cheaters.\nESEA Anti-Cheat’s detection capabilities resemble those of PunkBuster,\nwith one noteworthy difference. ESEA Anti-Cheat’s SBD algorithm is car-\nried out from a kernel-mode driver using three different Windows Kernel\nfunctions: the MmGetPhysicalMemoryRanges() function, the ZwOpenSection() func-\ntion, and the ZwMapViewOfSection() function. This implementation makes\nthe anti-cheat system nearly immune to memory spoofing (a common way\nto defeat SBD), as the functions used by the scan are much harder to hook\nwhen they’re called from a driver.\nThe vac Toolkit\nVAC is the toolkit Valve Corporation applies to its own games and many of\nthe third-party games available on its Steam gaming platform. VAC uses\nSDB and hash validation methods that resemble PunkBuster’s detection\ntechniques, and it also uses Domain Name System (DNS) cache scans and\nbinary validation.\nStaying Hidden 247"
  },
  {
    "input": "User-Mode Rootkit",
    "output": "DNS Cache Scans\nDNS is a protocol that converts between domain names and IP addresses\nsmoothly, and the DNS cache is where that information gets stored on a\ncomputer. When VAC’s SBD algorithm detects cheat software, VAC scans\nthe player’s DNS cache for any domain names associated with cheating\nwebsites. It’s not certain whether a positive DNS cache scan is required for\nVAC’s SBD algorithm to flag a player for banishment, or if the DNS cache\nscan simply acts as another nail in the coffin for players who are already\nflagged by SBD.\nNO tE To see your DNS cache, enter ipconfig /displaydns at a command prompt. Yes, VAC\nlooks at all of that.\nBinary Validation\nVAC also uses binary validation to prevent in-memory tampering of execut-\nable binaries. It scans for modifications like IAT, jump, and code hooking\nby comparing hashes of in-memory binary code to hashes of the same code\nin the binaries on the filesystem. If it finds a mismatch, VAC flags the player\nfor a ban.\nThis detection method is formidable, but Valve’s initial implementation\nof the algorithm was flawed. In July 2010, VAC’s binary validation falsely\nbanned 12,000 Call of Duty players. The binary validation module failed\nto account for a Steam update, and it banned the players when their in-\nmemory code did not match the updated binaries on the filesystem.\nFalse Positives\nVAC has had other issues with false positives. Its initial release routinely\nbanned fair players for “faulty memory.” This same early version banned\nplayers for using Cedega, a platform that ran Windows games on Linux. And\non April 1, 2004, Valve falsely banned a couple thousand players due to a\nserver-side glitch. On two separate occasions, one in June 2011 and one in\nFebruary 2014, VAC also falsely banned thousands of Team Fortress 2 and\nCounter-Strike players due to bugs that the company refuses to disclose. As\nwith PunkBuster, these incidents show that VAC is very aggressive.\nThe GameGuard Toolkit\nGameGuard is an anti-cheat toolkit made by INCA Internet Co. Ltd. and\nused by many MMORPGs, including Lineage II, Cabal Online, and Ragnarok\nOnline. In addition to some mildly aggressive SBD, GameGuard uses root-\nkits to proactively prevent cheat software from running.\nUser-Mode Rootkit\nGameGuard utilizes a user-mode rootkit to deny bots access to the Windows\nAPI functions they use to operate. The rootkit hooks the functions at their\n248 Chapter 12"
  },
  {
    "input": "The Warden Toolkit",
    "output": "lowest-level entry point, often inside undocumented functions in ntdll.dll,\nuser32.dll, and kernel32.dll. These are the most notable API functions\nGameGuard hooks, and here’s what GameGuard does from inside each\nhooked function:\nNtOpenProcess() Blocks any OpenProcess() attempts on the game being\nprotected.\nNtProtectVirtualMemory() Blocks any VirtualProtect() or VirtualProtectEx()\nattempts on the game.\nNtReadVirtualMemory() and NtWriteVirtualMemory() Block any\nReadProcessMemory() and WriteProcessMemory() attempts on the game.\nNtSuspendProcess() and NtSuspendThread() Block any attempts to suspend\nGameGuard.\nNtTerminateProcess() and NtTerminateThread() Block any attempts to ter-\nminate GameGuard.\nPostMessage(), SendMessage(), and SendInput() Block any attempts to send\nprogrammatic input to the game.\nSetWindowsHookEx() Prevents bots from globally intercepting mouse and\nkeyboard input.\nCreateProcessInternal() Automatically detects and hooks into new\nprocesses.\nGetProcAddress(), LoadLibraryEx(), and MapViewOfFileEx() Prevent any\nattempt to inject libraries into the game or GameGuard.\nKernel-Mode Rootkit\nGameGuard also uses a driver-based rootkit to prevent bots that work in\nthe kernel. This rootkit has the same abilities as its user-mode counterpart,\nand it works by hooking ZwProtectVirtualMemory(), ZwReadVirtualMemory(),\nZwWriteVirtualMemory(), SendInput(), and similar functions.\nThe warden Toolkit\nWarden, made exclusively for Blizzard’s games, is by far the most advanced\nanti-bot toolkit I’ve encountered. It’s hard to say what exactly Warden does,\nbecause it downloads dynamic code at runtime. This code, delivered as\ncompiled shellcode, typically has two responsibilities:\n• Detect bots.\n• Periodically send a heartbeat signal to the game server. The value sent\nis not predefined but instead is generated by some subset of the detec-\ntion code.\nIf Warden fails to complete the second task or sends the wrong value, the\ngame server will know that it’s been disabled or tampered with. Furthermore,\na bot can’t disable the detection code and leave the heartbeat code running.\nStaying Hidden 249"
  },
  {
    "input": "Minimizing a Bot’s Footprint",
    "output": "tHE HAltING PrOBlEM\nA bot that could disable Warden’s detection code and still send the heart-\nbeat signal would solve the halting problem, which Alan Turing proved to be\nimpossible in 1936. The halting problem is the problem of determining, with a\ngeneric algorithm, whether a program will finish running or continue forever.\nBecause Warden does two tasks using the same shellcode, writing a generic\nalgorithm that can disable just one task is a variation of the halting problem:\nthe algorithm can’t be sure which parts of the code will definitely execute,\nwhich parts won’t, and which parts are responsible for each task.\nWarden is formidable because you not only have no way to know what\nyou’re hiding from but also have no way to disable the toolkit. Even if you\nmanage to avoid detection today, a new detection method might be used\ntomorrow.\nIf you plan on publicly distributing bots, you will eventually meet one\nof the anti-cheat solutions described in the previous sections—and you’ll\nhave to beat it. Depending on your bot’s footprint, the type of detection in\nthe game you’re botting, and your implementation, the difficulty of evading\none of these toolkits can range from trivial to extremely hard.\ncarefully managing a bot’s Footprint\nA bot’s footprint is how many unique, detectable characteristics it has. For\nexample, a bot that hooks 100 functions will typically be easier to detect\nthan a bot that hooks only 10 functions because the former makes an order\nof magnitude more changes to a game’s code than the latter. Since a tar-\ngeted detection system needs to detect only one hook, the developer of the\nformer bot needs to spend much more time making sure all of the bot’s\nhooks are as stealthy as possible.\nAnother footprint characteristic is how detailed a bot’s user interface\nis. If a known bot has many dialog boxes that all have specific titles, a game\ncompany can just have its anti-cheat software detect the bot by searching for\nwindows that have those titles. This same basic reasoning can be used with\nprocess names and filenames.\nMinimizing a Bot’s Footprint\nDepending on how your bot works, there are many ways to minimize its\nfootprint. If your bot relies heavily on hooks, for instance, you can avoid\ndirectly hooking a game’s code and instead focus on hooking Windows API\nfunctions. Windows API hooking is surprisingly common, so developers\ncan’t assume a program that hooks the Windows API is a bot.\n250 Chapter 12"
  },
  {
    "input": "Teaching a Bot to Detect Debuggers",
    "output": "If your bot has a well-defined user interface, you can mask the interface\nby removing all strings from window bars, buttons, and so on. Instead, dis-\nplay images that show text. If you’re worried about specific process names\nor filenames being detected by the anti-cheat software, use generic file-\nnames and make your bot copy itself to a new, randomized directory every\ntime it launches.\nMasking Your Footprint\nMinimizing your footprint is a preferred way to avoid detection, but it’s not\nnecessary. You can also obfuscate your bot, making it harder for anyone to\nfigure out how it works. Obfuscation can prevent both anti-bot developers\nfrom trying to detect your bot and other bot developers from analyzing\nyour bot to steal proprietary functionality. If you sell your bot, obfuscation\nprevents people from cracking it to bypass your purchase verification, too.\nOne common type of obfuscation is called packing. Packing an execut-\nable encrypts it and hides it inside another executable. When the container\nexecutable is launched, the packed executable is decrypted and executed\nin-memory. When a bot is packed, analyzing the binary to learn what the\nbot does is impossible, and debugging the bot process is much harder.\nSome common packer programs are UPX, Armadillo, Themida, and ASPack.\nTeaching a Bot to Detect Debuggers\nWhen anti-bot developers (or other bot creators) can debug a bot, they can\nfigure out how it works and thus how to stop it. If someone is actively try-\ning to pick apart a bot, packing the executable may not be enough to evade\nthem. To protect against this, bots often employ anti-debugging techniques,\nwhich obfuscate control flow by changing the bot’s behavior when a debug-\nger is detected. In this section, I’ll quickly cover some well-known methods\nfor detecting when a debugger is attached to your bot, and in the next, I’ll\nshow you some tricks for obfuscation.\nCalling CheckremoteDebuggerPresent()\nCheckRemoteDebuggerPresent() is a Windows API function that can tell you if a\ndebugger is attached to the current process. Code to check for a debugger\nmight look like this:\nbool IsRemoteDebuggerPresent() {\nBOOL dbg = false;\nCheckRemoteDebuggerPresent(GetCurrentProcess(), &dbg);\nreturn dbg;\n}\nThis check is pretty straightforward—it calls CheckRemoteDebuggerPresent()\nwith the current process and a pointer to the dbg Boolean. Calling this\nfunction is the easiest way to detect a debugger, but it’s also very easy for a\ndebugger to evade.\nStaying Hidden 251\nChecking for Interrupt Handlers\nInterrupts are signals the processor sends to trigger a corresponding han-\ndler in the Windows kernel. Interrupts are typically generated by hardware\nevents, but they can also be generated in software using the INT assem-\nbly instruction. The kernel allows some interrupts—namely, interrupts\n0x2D and 0x03—to trigger user-mode interrupt handlers in the form of\nexception handlers. You can take advantage of these interrupts to detect\ndebuggers.\nWhen a debugger sets a breakpoint on an instruction, it replaces that\ninstruction with a breakpoint instruction, such as INT 0x03. When the\ninterrupt is executed, the debugger is notified via an exception handler,\nwhere it handles the breakpoint, replaces the original code, and allows the\napplication to resume execution seamlessly. When faced with an unrecog-\nnized interrupt, some debuggers even silently step over that interrupt and\nallow execution to continue normally, without triggering any other excep-\ntion handlers.\nYou can detect this behavior by purposely generating interrupts within\nexception handlers in your code, as shown in Listing 12-1.\ninline bool Has2DBreakpointHandler() {\n__try { __asm INT 0x2D }\n__except (EXCEPTION_EXECUTE_HANDLER){ return false; }\nreturn true;\n}\ninline bool Has03BreakpointHandler() {\n__try { __asm INT 0x03 }\n__except (EXCEPTION_EXECUTE_HANDLER){ return false; }\nreturn true;\n}\nListing 12-1: Detecting interrupt handlers\nDuring normal execution, these interrupts trigger the exception han-\ndlers surrounding them in the code. During a debugging session, some\ndebuggers might intercept the exceptions generated by these interrupts and\nsilently ignore them, preventing the surrounding exception handlers from\nexecuting. Thus, if the interrupts don’t trigger your exception handler, then\na debugger is present.\nChecking for Hardware Breakpoints\nDebuggers can also set breakpoints using the processor’s debug registers;\nthese are called hardware breakpoints. A debugger can set a hardware break-\npoint on an instruction by writing the address of the instruction to one of\nthe four debug registers.\n252 Chapter 12\nWhen an address present on a debug register is executed, the debug-\nger is notified. To detect hardware breakpoints (and thus, the presence of\na debugger), you can check for nonzero values on any of the four debug\nregisters like this:\nbool HasHardwareBreakpoints() {\nCONTEXT ctx = {0};\nctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;\nauto hThread = GetCurrentThread();\nif(GetThreadContext(hThread, &ctx) == 0)\nreturn false;\nreturn (ctx.Dr0 != 0 || ctx.Dr1 != 0 || ctx.Dr2 != 0 || ctx.Dr3 != 0);\n}\nPrinting Debug Strings\nOutputDebugString() is a Windows API function that can be used to print log\nmessages to a debugger console. If no debugger is present, the function will\nreturn with an error code. If a debugger is present, however, the function\nwill return with no error code. Here’s how you can use this function as a\ntrivial debugger check:\ninline bool CanCallOutputDebugString() {\nSetLastError(0);\nOutputDebugStringA(\"test\");\nreturn (GetLastError() == 0);\n}\nLike the CheckRemoteDebuggerPresent() method, this method is very\nstraightforward but also very easy for a debugger to evade.\nChecking for DBG_rIPEXCEPtION Handlers\nDebuggers typically have exception handlers that blindly catch exceptions\nwith Windows’ DBG_RIPEXCEPTION exception code, making that code a clear\nway to spot a debugger. You can detect these exception handlers in much\nthe same way Listing 12-1 detects interrupt handlers:\n#define DBG_RIPEXCEPTION 0x40010007\ninline bool hasRIPExceptionHandler() {\n__try { RaiseException(DBG_RIPEXCEPTION, 0, 0, 0); }\n__except(EXCEPTION_EXECUTE_HANDLER){ return false; }\nreturn true;\n}\nStaying Hidden 253\ntiming Control-Critical routines\nIf an anti-bot developer is debugging your bot, the developer will likely\nplace breakpoints on and single-step through parts of your code that are\ncritical to the bot’s behavior. You can detect this activity by measuring code\nexecution times; when someone steps through code, execution takes a lot\nlonger than usual.\nFor example, if a function only places some hooks, you can be sure that\nthe code shouldn’t take more than a tenth of a second to do the memory\nprotection. You could check the execution time for memory protection with\nhelp from the GetTickCount() Windows API function, as follows:\n--snip--\nauto startTime = GetTickCount();\nprotectMemory<>(...);\nif (GetTickCount() - startTime >= 100)\ndebuggerDetectedGoConfuseIt();\n--snip--\nChecking for Debug Drivers\nSome debuggers load kernel-mode drivers to assist their operation. You can\ndetect these debuggers by attempting to get a handle to their kernel-mode\ndrivers, like this:\nbool DebuggerDriversPresent() {\n// an array of common debugger driver device names\nconst char drivers[9][20] = {\n\"\\\\\\\\.\\\\EXTREM\", \"\\\\\\\\.\\\\ICEEXT\",\n\"\\\\\\\\.\\\\NDBGMSG.VXD\", \"\\\\\\\\.\\\\RING0\",\n\"\\\\\\\\.\\\\SIWVID\", \"\\\\\\\\.\\\\SYSER\",\n\"\\\\\\\\.\\\\TRW\", \"\\\\\\\\.\\\\SYSERBOOT\",\n\"\\0\"\n};\nfor (int i = 0; drivers[i][0] != '\\0'; i++) {\nauto h = CreateFileA(drivers[i], 0, 0, 0, OPEN_EXISTING, 0, 0);\nif (h != INVALID_HANDLE_VALUE) {\nCloseHandle(h);\nreturn true;\n}\n}\nreturn false;\n}\nThere are a few common kernel-mode driver device names to check for,\nlike \\\\\\\\.\\\\EXTREM and the others shown in the drivers array. If this handle-\nfetching code succeeds, then there’s a debugger running on the system.\nUnlike with the previous methods, though, obtaining a handle to one of\nthose drivers doesn’t always mean the debugger is attached to your bot.\n254 Chapter 12"
  },
  {
    "input": "Anti-Debugging Techniques",
    "output": "Anti-Debugging Techniques\nOnce you detect a debugger, there are multiple ways to obfuscate your con-\ntrol flow. For instance, you might try to crash the debugger. The following\ncode crashes OllyDbg v1.10:\nOutputDebugString(\"%s%s%s%s\");\nThe string \"%s%s%s%s\" contains format specifiers, and OllyDbg passes\nit to printf() without any extra parameters, which is why the debugger\ncrashes. You could place this code in a function that gets called in response\nto detecting a debugger, but this option works only against OllyDbg.\nCausing an Unavoidable Infinite Loop\nAnother obfuscation method to try is overloading the system until the per-\nson debugging your bot is forced to close the bot and debugger. This func-\ntion does the trick:\nvoid SelfDestruct() {\nstd::vector<char*> explosion;\nwhile (true)\nexplosion.push_back(new char[10000]);\n}\nThe infinite while loop just keeps adding elements to explosion until the\nprocess runs out of memory or someone pulls the plug.\nOverflowing the Stack\nIf you want to really confuse the analyst, you can make a chain of functions\nthat eventually cause a stack overflow, but in an indirect way:\n#include <random>\ntypedef void (* _recurse)();\nvoid recurse1(); void recurse2();\nvoid recurse3(); void recurse4();\nvoid recurse5();\n_recurse recfuncs[5] = {\n&recurse1, &recurse2, &recurse3,\n&recurse4, &recurse5\n};\nvoid recurse1() { recfuncs[rand() % 5](); }\nvoid recurse2() { recfuncs[(rand() % 3) + 2](); }\nvoid recurse3() {\nif (rand() % 100 < 50) recurse1();\nelse recfuncs[(rand() % 3) + 1]();\n}\nvoid recurse4() { recfuncs[rand() % 2](); }\nvoid recurse5() {\nfor (int i = 0; i < 100; i++)\nif (rand() % 50 == 1)\nStaying Hidden 255"
  },
  {
    "input": "Defeating Signature-Based Detection",
    "output": "recfuncs[i % 5]();\nrecurse5();\n}\n// call any of the above functions to trigger a stack overflow\nIn a nutshell, these functions randomly and infinitely recurse until\nthere’s no room left on the call stack. Causing the overflow indirectly makes\nit hard for the analyst to pause and examine previous calls before they real-\nize what’s happened.\nCausing a BSOD\nIf you’re serious about obfuscation, you can even trigger a Blue Screen of\nDeath (BSOD) when you detect a debugger. One way to do that is to set\nyour bot’s process as critical using the SetProcessIsCritical() Windows API\nfunction and then call exit(), since Windows will trigger a BSOD when a\ncritical process is killed. Here’s how you might do that:\nvoid BSODBaby() {\ntypedef long (WINAPI *RtlSetProcessIsCritical)\n(BOOLEAN New, BOOLEAN *Old, BOOLEAN NeedScb);\nauto ntdll = LoadLibraryA(\"ntdll.dll\");\nif (ntdll) {\nauto SetProcessIsCritical = (RtlSetProcessIsCritical)\nGetProcAddress(ntdll, \"RtlSetProcessIsCritical\");\nif (SetProcessIsCritical)\nSetProcessIsCritical(1, 0, 0);\n}\n}\nBSODBaby();\nexit(1);\nOr maybe you’re evil, in which case you can do this:\nBSODBaby();\nOutputDebugString(\"%s%s%s%s\");\nrecurse1();\nexit(1);\nAssuming you’ve implemented all of the techniques described in this\nsection, this code would cause a BSOD, crash the debugger (if it’s OllyDbg\nv1.10), overflow the stack, and exit the running program. If any one of the\nmethods fails or gets patched, the analyst still has to deal with the remain-\ning ones before they can continue debugging.\ndefeating Signature-based detection\nEven with amazing obfuscation, you won’t easily beat signature detection.\nEngineers who analyze bots and write signatures are very skilled, and obfus-\ncation is, at best, a nuisance that makes their job marginally harder.\n256 Chapter 12\nTo completely evade SBD, you need to subvert the detection code. This\nrequires knowing exactly how the SBD works. PunkBuster, for instance,\nuses NtQueryVirtualMemory() to scan the memory of all running processes\nfor any signatures. If you want to bypass this, you can inject code into all\nPunkBuster processes with a hook on the NtQueryVirtualMemory() function.\nWhen the function tries to query memory from your bot process, you\ncan give it whatever data you want, like this:\nNTSTATUS onNtQueryVirtualMemory(\nHANDLE process, PVOID baseAddress,\nMEMORY_INFORMATION_CLASS memoryInformationClass,\nPVOID buffer, ULONG numberOfBytes, PULONG numberOfBytesRead) {\n// if the scan is on this process, make sure it can't see the hook DLL\nif ((process == INVALID_HANDLE_VALUE ||\nprocess == GetCurrentProcess()) &&\nbaseAddress >= MY_HOOK_DLL_BASE &&\nbaseAddress <= MY_HOOK_DLL_BASE_PLUS_SIZE)\nu return STATUS_ACCESS_DENIED;\n// if the scan is on the bot, zero the returned memory\nauto ret = origNtQueryVirtualMemory(\nprocess, baseAddress,\nmemoryInformationClass,\nbuffer, numberOfBytes, numberOfBytesRead);\nif(GetProcessId(process) == MY_BOT_PROCESS)\nv ZeroMemory(buffer, numberOfBytesRead);\nreturn ret;\n}\nThis onNtQueryVirtualMemory() hook returns STATUS_ACCESS_DENIED u\nwhen NtQueryVirtualMemory() tries to query the hook DLL’s memory, but it\ngives zeroed memory v when NtQueryVirtualMemory() tries to query the bot’s\nmemory. The difference isn’t for any specific reason; I’m just showing two\nways you can hide from the NtQueryVirtualMemory() function call. If you’re\nreally paranoid, you can even replace the entire buffer with a random byte\nsequence.\nOf course, this method works only for SBD that happens from user\nmode, like the SBD in PunkBuster or VAC. SBD that happens from the\ndriver, like ESEA’s, or that isn’t predictable, like Warden’s, isn’t as easy to\nbypass.\nIn those cases, you can take precautions to eliminate unique signa-\ntures in your bot. If you’re distributing the bot to more than a dozen or so\npeople, however, removing all distinguishing properties is tricky. To throw\nanalysts off the scent, each time you give somebody a copy of the bot, you\ncould try some combination of the following:\n• Compiling the bot using a different compiler\n• Changing the compiler optimization settings\n• Toggling between using __fastcall and __cdecl\nStaying Hidden 257"
  },
  {
    "input": "Defeating Screenshots",
    "output": "• Packing the binaries using a different packer\n• Switching between static and dynamic linking of runtime libraries\nVarying these elements creates a different assembly for each user, but\nthere’s a limit on how many unique versions of the bot you can produce that\nway. Past some point, this method doesn’t scale to demand, and eventually,\ngame companies will have signatures for every incarnation of your bot.\nApart from obfuscation and code mutation, there aren’t many ways\nto defeat advanced SBD mechanisms. You could implement your bot in\na driver or create a kernel-mode rootkit to hide your bot, but even those\nmethods aren’t foolproof.\nNO tE This book doesn’t cover implementing a bot in a driver or creating a rootkit to hide\na bot, as both topics are pretty complex. Rootkit development alone is a subject that\ndozens of books have covered already. I’d recommend Bill Blunden’s The Rootkit\nArsenal: Escape and Evasion in The Dark Corners of The System (Jones &\nBartlett Learning, 2009).\nSome game hackers try to cover every single base, hooking every\nmemory-reading function and the entire filesystem API, but still get\ncaught by determined systems like Warden. In fact, I recommend stay-\ning away from Warden and Blizzard at all costs.\ndefeating Screenshots\nIf you encounter a detection mechanism that uses screenshots as additional\nproof to nail botters, you’re in luck. Bypassing screenshot mechanisms is\neasy: don’t let your bot be seen.\nYou can subvert this type of detection by keeping a minimal UI and\nmaking no visibly distinguishable changes to the game client. If your bot\nrequires a HUD or other distinctive UI displays, though, don’t fret—you\ncan have your cake and eat it, too. As long as you can intercept the screen-\nshot code, you can hide your fingerprints while a screenshot is taken.\nIn some versions of PunkBuster, for example, the Windows API func-\ntion GetSystemTimeAsFileTime() is called just before a screenshot is taken. You\ncan use a hook on this function to quickly hide your UI for a few seconds to\nensure it’s not seen:\nvoid onGetSystemTimeAsFileTime(LPFILETIME systemTimeAsFileTime) {\nmyBot->hideUI(2000); // hide UI for 2 seconds\norigGetSystemTimeAsFileTime(systemTimeAsFileTime);\n}\nJust hook GetSystemTimeAsFileTime() using the techniques described in\n“Hooking to Redirect Game Execution” on page 153, write a hideUI() func-\ntion, and call the hideUI() function before execution resumes.\n258 Chapter 12"
  },
  {
    "input": "Defeating Binary Validation",
    "output": "defeating binary validation\nDefeating binary validation is as simple as not placing hooks inside game-\nspecific binaries. Jump hooks and IAT hooks on Windows API functions are\nextremely common, so wherever you can, try to get away with using those\nmethods instead of using jump or near-call hooks in a game binary. In cases\nwhere you must directly hook a game’s code, you can trick the anti-cheat\nsoftware’s binary validation routines by intercepting the binary scan and\nspoofing the data to match what the software expects to see.\nLike SBD, binary validation often uses NtQueryVirtualMemory() to\nscan memory. To trick the validation code, start with a hook on that\nfunction. Then, write a function like this one to spoof the data when\nNtQueryVirtualMemory() is called:\nNTSTATUS onNtQueryVirtualMemory(\nHANDLE process, PVOID baseAddress,\nMEMORY_INFORMATION_CLASS memoryInformationClass,\nPVOID buffer, ULONG numberOfBytes, PULONG numberOfBytesRead) {\nauto ret = origNtQueryVirtualMemory(\nprocess, baseAddress,\nmemoryInformationClass,\nbuffer, numberOfBytes, numberOfBytesRead);\n// place tricky code somewhere in here\nreturn ret;\n}\nInside this hook, you’ll need to watch for any memory scans over mem-\nory that has been modified by one of your hooks.\nNO tE This example assumes the bot has only one hook and that variables prefixed with\nHOOK_ already exist and describe the code the hook replaces.\nListing 12-2 shows some scan-monitoring code.\n// is the scan on the current process?\nbool currentProcess =\nprocess == INVALID_HANDLE_VALUE ||\nprocess == GetCurrentProcess();\n// is the hook in the memory range being scanned?\nauto endAddress = baseAddress + numberOfBytesRead - 1;\nbool containsHook =\n(HOOK_START_ADDRESS >= baseAddress &&\nHOOK_START_ADDRESS <= endAddress) ||\n(HOOK_END_ADDRESS >= baseAddress &&\nHOOK_END_ADDRESS <= endAddress);\nu if (currentProcess && containsHook) {\n// hide the hook\n}\nListing 12-2: Checking whether hooked memory is being scanned\nStaying Hidden 259\nWhen a memory scan over the hooked code happens (which makes\ncurrentProcess and containsHook become true at the same time), code inside\nthe if() statement u updates the output buffer to reflect the original code.\nThis means you must know where the hooked code is within the scanned\nblock, taking into account the fact that the block may span only a subset of\nthe hooked code.\nSo if baseAddress marks the address where the scan starts, HOOK_START_\nADDRESS marks the spot where the modified code starts, endAddress marks the\naddress where the scan ends, and HOOK_END_ADDRESS marks the address where\nthe modified code ends, you can use some simple math to calculate which\nparts of the modified code are present in which parts of the buffer. You do\nso as follows, using writeStart to store the offset of the modified code in the\nscan buffer and readStart to store the offset of the scan buffer relative to\nthe modified code, in case the scan buffer starts in the middle of the modi-\nfied code:\nint readStart, writeStart;\nif (HOOK_START_ADDRESS >= baseAddress) {\nreadStart = 0;\nwriteStart = HOOK_START_ADDRESS - baseAddress;\n} else {\nreadStart = baseAddress - HOOK_START_ADDRESS;\nwriteStart = baseAddress;\n}\nint readEnd;\nif (HOOK_END_ADDRESS <= endAddress)\nreadEnd = HOOK_LENGTH - readStart - 1;\nelse\nreadEnd = endAddress – HOOK_START_ADDRESS;\nOnce you know how many bytes you need to replace, where to put them,\nand where to get them, you can do the spoof with three lines of code:\nchar* replaceBuffer = (char*)buffer;\nfor ( ; readStart <= readEnd; readStart++, writeStart++)\nreplaceBuffer[writeStart] = HOOK_ORIG_DATA[readStart];\nCompletely assembled, the code looks like this:\nNTSTATUS onNtQueryVirtualMemory(\nHANDLE process, PVOID baseAddress,\nMEMORY_INFORMATION_CLASS memoryInformationClass,\nPVOID buffer, ULONG numberOfBytes, PULONG numberOfBytesRead) {\nauto ret = origNtQueryVirtualMemory(\nprocess, baseAddress,\nmemoryInformationClass,\nbuffer, numberOfBytes, numberOfBytesRead);\nbool currentProcess =\nprocess == INVALID_HANDLE_VALUE ||\nprocess == GetCurrentProcess();\n260 Chapter 12"
  },
  {
    "input": "Defeating an Anti-Cheat Rootkit",
    "output": "auto endAddress = baseAddress + numberOfBytesRead - 1;\nbool containsHook =\n(HOOK_START_ADDRESS >= baseAddress &&\nHOOK_START_ADDRESS <= endAddress) ||\n(HOOK_END_ADDRESS >= baseAddress &&\nHOOK_END_ADDRESS <= endAddress);\nif (currentProcess && containsHook) {\nint readStart, writeStart;\nif (HOOK_START_ADDRESS >= baseAddress) {\nreadStart = 0;\nwriteStart = HOOK_START_ADDRESS - baseAddress;\n} else {\nreadStart = baseAddress - HOOK_START_ADDRESS;\nwriteStart = baseAddress;\n}\nint readEnd;\nif (HOOK_END_ADDRESS <= endAddress)\nreadEnd = HOOK_LENGTH - readStart - 1;\nelse\nreadEnd = endAddress – HOOK_START_ADDRESS;\nchar* replaceBuffer = (char*)buffer;\nfor ( ; readStart <= readEnd; readStart++, writeStart++)\nreplaceBuffer[writeStart] = HOOK_ORIG_DATA[readStart];\n}\nreturn ret;\n}\nOf course, if you had multiple hooks that you needed to hide from\nbinary validation scans, you would need to implement this functionality\nin a more robust way that would allow it to track multiple modified code\nregions accordingly.\ndefeating an anti-cheat Rootkit\nGameGuard and some other anti-cheat suites come with user-mode rootkits\nthat not only detect bots but also proactively prevent them from running.\nTo defeat this type of protection, rather than think outside the box, you can\ncompletely copy the box and work inside that copy.\nFor example, if you want to write memory to a game, you must call\nthe WriteProcessMemory() function, which is exported by kernel32.dll. When\nyou call this function, it directly calls NtWriteVirtualMemory() from ntdll.dll.\nGameGuard hooks ntdll.NtWriteVirtualMemory() to prevent you from writing\nmemory. But if NtWriteVirtualMemory() is exported from, say, ntdll_copy.dll,\nGameGuard won’t hook that function.\nThat means you can copy ntdll.dll and dynamically import all of the\nfunctions you need, as follows:\n// copy and load ntdll\ncopyFile(\"ntdll.dll\", \"ntdll_copy.dll\");\nStaying Hidden 261"
  },
  {
    "input": "Defeating Heuristics",
    "output": "auto module = LoadLibrary(\"ntdll_copy.dll\");\n// dynamically import NtWriteVirtualMemory\ntypedef NTSTATUS (WINAPI* _NtWriteVirtualMemory)\n(HANDLE, PVOID, PVOID, ULONG, PULONG);\nauto myWriteVirtualMemory = (_NtWriteVirtualMemory)\nGetProcAddress(module, \"NtWriteVirtualMemory\");\n// call NtWriteVirtualMemory\nmyWriteVirtualMemory(process, address, data, length, &writtenlength);\nAfter copying ntdll.dll, this code imports the NtWriteVirtualMemory() from\nthe copy with the name myWriteVirtualMemory(). From there, the bot can use\nthis function in place of the NtWriteVirtualMemory() function. They’re effec-\ntively the same code in the same library, just loaded under different names.\nCopying a function that anti-cheat software hooks works only if you\ncall that function at its lowest-level entry point, though. If this code copied\nkernel32.dll and dynamically imported the WriteProcessMemory() function, an\nanti-cheat rootkit would still stop the bot, because kernel32_copy.dll would\nstill rely on ntdll.NtWriteVirtualMemory() when calling the WriteProcessMemory()\nfunction.\ndefeating Heuristics\nIn addition to all of the advanced client-side detection mechanisms we’ve\njust discussed, game companies will employ server-side heuristics that can\ndetect bots simply by monitoring a player’s behavior. These systems learn\nto distinguish between human and autonomous player behavior through\nmachine-learning algorithms. Their decision-making process is often inter-\nnal and incomprehensible to humans, so it’s difficult to pinpoint exactly\nwhat features of gameplay lead to detection.\nYou don’t need to know how such algorithms work to trick them; your\nbot just needs to act human. Here are some common behaviors that are dis-\ntinguishably different between humans and bots:\nIntervals between actions\nMany bots perform actions unreasonably fast or at consistent intervals.\nBots will seem more human-like if they have a reasonable cooldown\nperiod between actions. They should also have some form of random-\nization to prevent them from repeating an action at a constant rate.\nPath repetition\nBots that farm enemies automatically visit a pre programmed list of\nlocations to kill creatures. These waypoint lists are often extremely accu-\nrate, indicating each location as an exact pixel. Humans, conversely,\nmove in less predictable ways and visit more unique locations along the\nway to a familiar area. To replicate this behavior, a bot might walk to a\n262 Chapter 12"
  },
  {
    "input": "Closing Thoughts",
    "output": "random location within a certain range of a target location, rather than\nto the target location itself. Also, if the bot randomizes the order in\nwhich it visits target locations, the variety of paths it takes will increase\nfurther.\nUnrealistic play\nSome botters run their bots in the same location for hundreds of con-\nsecutive hours, but humans can’t play a game that long. Encourage your\nusers to refrain from botting for more than eight hours at a time and\nwarn them that doing the same thing for seven straight days will defi-\nnitely trigger alarms in a heuristic system.\nPerfect accuracy\nBots can hit a thousand head shots in a row without firing a single extra\nbullet, and they can hit every skill shot with consistent precision. But it’s\nvirtually impossible for a human to do the same, so a smart bot should\nbe intentionally inaccurate at times.\nThese are just a few examples, but in general, you can sneak past\nheuristic checks if you just use common sense. Don’t try to have a bot do\nsomething a human can’t, and don’t have the bot do any single thing for\ntoo long.\nclosing Thoughts\nGame hackers and game developers are engaged in a constant battle of\nwits. Hackers will keep finding ways to subvert detection, and developers\nwill keep finding better ways to detect them. If you’re determined, however,\nthe knowledge in this chapter should help you defeat any anti-cheat soft-\nware you encounter.\nStaying Hidden 263"
  },
  {
    "input": "Index",
    "output": "INDEx\na anti-cheat software, 245–246\nanti-cheat rootkit, defeating,\nAbout text field, Trainer generator\n261–262\ndialog, 9\nbinary validation, defeating,\naccessing memory\n259–261\nin injected DLL, 145–146\nbot footprints, managing,\nfor writing and reading, 122–124\n250–256\nAction Message Format (AMF), 169\nESEA Anti-Cheat toolkit, 247\nactor functions, 216\nGameGuard toolkit, 248–249\nactuation, 216, 223\nheuristics, defeating, 262–263\nAddress column\nPunkBuster toolkit, 246–247\nEvent Properties dialog, 55\nscreenshots, defeating, 258\nOllyDbg disassembler pane, 27\nsignature-based detection,\naddresses, memory. See memory\nevading, 256–257\naddresses\nVAC toolkit, 247–248\nAddress Space Layout Randomization\nWarden toolkit, 249–250\n(ASLR), 128\nanti-crowd-control hacks, 218\nbypassing in injected DLL,\nanti-debugging techniques, 251,\n146–147\n255–256\nbypassing in production,\narithmetic instructions, 90–92\n128–130\nA* search algorithm, 234\ndisabling for bot\ncost, 233\ndevelopment, 128\ncreating node, 234–237\nin Process Explorer, 56, 57\ncreating path list, 239–240\nAdobe AIR hooking, 169\nscore, 234\ndecode() function, 172–173,\nuses for, 240–241\n174–175\nwriting search function, 237–239\nencode() function, 171–172,\nASLR. See Address Space Layout\n174–175\nRandomization (ASLR)\nplacing hooks, 173–175\nAsm2Clipboard plug-in, 42\nRTMP, assessing, 169–170\nassembly code\nAdobe AIR.dll, 173–175\ncopying, 42\nairlog tool, 170\ntracing, 32–33\nalignment\nviewing and navigating in\nin numeric data, 68\nOllyDbg, 27–29\nof variables, in data structures,\nassembly language, 78. See also\n70–71\nx86 assembly language\nambient light, adding, 190–192\nassembly patterns, searching for,\nAMF (Action Message Format), 169\n19–21\nAStarNode class, 234–236 intercepting network traffic,\nAT&T syntax, 80 206–211\nautocombo, 219 monitoring memory, 204–205\nautododge, 219 obfuscation, 251, 255–256\nautokite bots, 244 sending packets, 215–217\nautomatic healer, 218, 225–228, spell trainers, 219\n230–232 branching, 92–94\nautonomous bots, 221–222. See also breakpoints, 30, 34, 38\ncontrol theory; state Breakpoints window, OllyDbg, 26\nmachines BSOD (Blue Screen of Death), 256\ncavebots, 241–243 BYTE data type, 67\ncomplex hypothetical state bytes, machine code, 78\nmachine, 228–230\nerror correction, 230–232\nC\nhealer state machine, 225–228\nC++, 66\npathfinding with search\ncallee, 94–95\nalgorithms, 232–234\ncaller, 94–95\nwarbots, 243–244\nautoreload, 219 callHook() function, 154\ncall hooking, 153–156. See also Adobe\nautosnipe bots, 244\nAIR hooking\nautowall bots, 244\ncalling conventions, 95\nfor call hooks, 155\nB\n__cdecl, 95, 155\nban waves, 246 __fastcall, 95\nBigger Than scan type, Cheat __stdcall, 95\nEngine, 6 __thiscall, 95, 217\nbinary arithmetic instructions, 90 for trampoline functions, 168\nbinary validation, 248, 259–261 for VF table hooks, 156–158\nbits, EFLAGS register, 84 CALL instruction, 94–95\nBlue Screen of Death (BSOD), 256 call stack\nbots. See also autonomous bots; overflow, 255–256\nextrasensory perception viewing, 30\n(ESP) hacks x86 assembly language, 86–88\nanti-crowd-control hacks, 218 Call stack window, OllyDbg, 26\nanti-debugging techniques, 251, capacity of std::vector, 109\n255–256 casting spells. See spells\nautomatic healer, 218, 225–228, cavebots, 241–243\n230–232 __cdecl convention, 95, 155\ndetecting debuggers, 251–254 Changed Value scan type, Cheat\ndetecting visual cues, 205–206 Engine, 7\ndisabling ASLR for characters. See also enemies\ndevelopment, 128 health bars, monitoring with\nemulating keyboard, 211–215 bots, 204–205\nfootprints, managing, 250–256 pausing execution when health\ngame updates, dealing with, drops, 39–42\n101–104 player health, finding with\nOllyDbg, 99–101\n266 Index\nchar data type, 67 Comment column, OllyDbg\nCheat Engine, 3, 5–6 disassembler pane, 28\nautomatically locating string complex hypothetical state machine,\naddresses with, 102 228–230\ncheat tables, 7–8 conditional breakpoints, 34, 38\ncorrect address, determining, 7 conditional statements, 93\nfirst scan, running, 6 constant ratio of health, adjusting\ninstalling, 4 for, 230–231\nLua scripting environment, control-critical routines, timing, 254\n18–22 control flow hacks, 31\nmemory modification, 8–11 control flow manipulation, 149–150.\nnext scan, running, 7 See also Adobe AIR\npointer scanning with, 14–18 hooking; Direct3D\nscan types, 6 hooking\nstd::list, determining whether call hooking, 153–156\ndata is stored in, 112–113 IAT hooking, 160–165\nstd::map, determining whether jump hooking, 165–169\ndata is stored in, 117 NOPing, 150–152\ntrainer generator, 9–11 VF table hooking, 156–160\nVF tables, 78 control theory, 222\nzoom factor, finding, 197 combining with state\ncheat tables, Cheat Engine, 7–8 machines, 225\nCheat Utility plug-in, 42–43 complex hypothetical state\nCheckRemoteDebuggerPresent() machine, 228–230\nfunction, 251 error correction, 230–232\nclasses, 74–78 healer state machine, 225–228\nclass instances, 76 control windows, OllyDbg, 25–26\nCloseHandle() function, 122, 138 cooldowns, displaying enemy,\nclosing mutexes, 59–60 200–201\nCMP instruction, 92 copying assembly code, 42\ncode caves, 134 copy-on-write protection, 126\nloading DLLs, 143–146 corpses, bot behavior toward,\nthread hijacking, 138–142 229, 240\nthread injection, 134–138 correct address, determining in\ncode injection, 133–134 Cheat Engine, 7\nbypassing ASLR in production, CPU window, OllyDbg, 26–30, 40\n128–130 crashing debuggers, 255\nDLLs, 142–146 CreateRemoteThread() function, 129,\nwith thread hijacking, 138–142 130, 134, 138\nwith thread injection, 134–138 CreateToolhelp32Snapshot() function,\ncode patches, creating, 31–32 120, 141\ncolumn configurations, Process creature data, knowing structure\nMonitor, 51 behind, 106–107\ncombat, automating, 243–244 critical game information, displaying,\ncommand line plug-in, OllyDbg, 198–201\n43–44 crowd-control attacks, 218\ncommand syntax, x86 assembly cryptographic functions,\nlanguage, 79–81 hooking, 170\nIndex 267\nCS register, 85 finding devices, 177–181\nC-style operators, OllyDbg, 34–35 optional fixes for stability, 184\ncustom behaviors for cavebots, writing hook for EndScene(),\nscripting, 243 182–183\nwriting hook for Reset(), 183–184\nD directional lighthacks, 190–191\ndisabling ASLR, 128\ndark environments, lighting up,\ndisassembler pane, OllyDbg,\n190–192\n27–29, 42\ndata modification instructions, 89\nDisassembly column, OllyDbg\ndata structures, 71–73\ndisassembler pane, 28\ndata types, 66\ndispatchPacket() function, 210\nclasses and VF tables, 74–78\ndisplay base, 27\nnumeric data, 67–69\nDLL (dynamic link library),\nOllyDbg, 36\ninjecting, 142–146\nstring data, 69–71\nDllMain() entry point, 144–145\nunions, 73–74\nDLLs option, Process Explorer\nDBG_RIPEXCEPTION handlers,\npane, 57\nchecking for, 253\nDomain Name System (DNS) cache\ndebugging. See also OllyDbg\nscans, 248\nanti-debugging techniques,\nDOS header, 160–161\n255–256\nDrawIndexedPrimitive() function, 194,\ndebug drivers, checking for, 254\n195, 196, 200\ndebug strings, printing, 253\ndrawing loop, Direct3D, 176–177\ndetecting debuggers, 251–254\nDS register, 85\nProcess Monitor, 52–53\ndump pane, OllyDbg, 29–30\n__declspec(naked) convention, 168\nDWORD data type, 67, 145–146\ndecode() function, hooking, 172–173,\ndynamically allocated memory, 6,\n174–175\n11, 12\nDecreased Value By scan type, Cheat\ndynamic link library (DLL),\nEngine, 7\ninjecting, 142–146\nDecreased Value scan type, Cheat\ndynamic lure, 242–243\nEngine, 7\ndynamic structures, 105\ndependencies, DLL, 145\nstd::list class, 110–113\ndependency loading, 160\nstd::map class, 114–118\ndepositor, 242\nstd::string class, 105–108\ndestination operand, 80\nstd::vector class, 108–110\ndetection, avoiding. See anti-cheat\nsoftware\nE\ndevice->SetRenderState() function, 192\nDijkstra’s algorithm, 233–234 EAX register, 81\nDirect3D 9, 176 EBP register, 83\nDirect3D hooking, 175–176. See also EBX register, 82\nextrasensory perception ECX register, 82, 157\n(ESP) hacks EDI register, 83\ndetecting visual cues in games, EDX register, 82\n205–206 EFLAGS register, 84, 92\ndrawing loop, 176–177 EIP register, 83, 139\n268 Index\nemulating keyboard, 211–215 pausing execution when health\nenableLightHackDirectional() function, of character drops,\n190–191 39–42\nencode() function, hooking, 171–172, pausing execution when name of\n174–175 player is printed, 37–38\nEndScene() function supported data types, 36\njump hooking, 178–181 extrasensory perception (ESP) hacks,\nstability of, 184 189–190\nwriting hook for, 182–183 background knowledge, 190\nendSceneTrampoline() function, 181 floor spy hacks, 201–202\nenemies. See also extrasensory HUDs, 198–201\nperception (ESP) hacks lighthacks, 190–192\ncooldowns, displaying, 200–201 loading-screen HUDs, 201\ncritical game information, pick-phase HUDs, 201\ndisplaying, 198–201 range hacks, 201\npredicting movements of, 241 wallhacks, 192–197\ntexture, changing, 195–196 zoomhacks, 197–198\nentropy, 5, 7\nEnvironment tab, Process Explorer\nF\nProperties dialog, 58\nfalse positives, VAC toolkit, 248\nerror correction, 230–232\nESEA (E-Sports Entertainment __fastcall convention, 95\nfeedback loop, 222\nAssociation), 247\nfile accesses, inspecting in Process\nESEA Anti-Cheat toolkit, 247\nExplorer, 60\nESI register, 83\nFilesystem event class filter, 52\nESP hacks. See extrasensory\nFILO (first-in-last-out), 86\nperception (ESP) hacks\nfilters, event class, 51–52\nESP register, 83\nES register, 85 findItem() function, 116–117\nEuclidean distance heuristic, 236 findSequence() function, 175\nfirst-in-last-out (FILO), 86\nevent class filters, Process Monitor,\nfirst-person shooter (FPS), xxii, 246\n51–52\nfirst scan, running in Cheat\nevent log, Process Monitor, 52–53\nEngine, 6\nEvent Properties dialog, 54–55\nflags, process access, 121\nExact Value scan type, Cheat\nEngine, 6 float data type, 67–68\nfloor spy hacks, 201–202\nexception handlers, checking for, 253\nfog of war, 189. See also extrasensory\nexecute protection, 125–128\nperception (ESP) hacks\nExecute until return button,\nfootprints, managing, 250–256\nOllyDbg, 25\nFound intermodular calls window,\nexperience-tracking HUD, 200\nOllyDbg, 40\nexponent, float data type, 68\nFPS (first-person shooter), xxii, 246\nexpressions, OllyDbg, 36–37\nFPU registers, 29\naccessing memory\nFrame column, Event Properties\ncontents with, 36\nwindow, 54\nelements evaluated by, 35–36\nframes, in Direct3D drawing loop, 176\nexpression engine, 33–36\nIndex 269\nFreeze interval, Trainer generator Handles option, Process Explorer\ndialog, 9 pane, 57\nfreezing Handles window, OllyDbg, 26\naddresses, 8 hardware breakpoints, checking for,\nmain thread, 141 252–253\nfrontier, 233 hash validation, 247\nFS register, 85 heads-up display (HUD), 198–201\nfunction calls, x86 assembly healer state machine, 225–228,\nlanguage, 94–95 230–232\nfunction flowchart, OllyFlow, 45 health of characters\nfunction names, finding for IAT health bars, monitoring with\nhooking, 163 bots, 204–205\nhealth bars of enemies,\ndisplaying, 150–152\nG\npausing execution upon\nGameActuators class, 225 drop in, 39–42\ngame automation state machine,\nheap data, 16\n223–224\nheuristics, 233\nGameGuard toolkit, 248–249\ndefeating, 262–263\ngame updates, determining new\nEuclidean distance, 236\naddresses after, 101–104\nManhattan distance, 235\ngeneral registers, 81–82\nHex dump column, OllyDbg\ngeneric memory functions, 123–124\ndisassembler pane, 27–28\ngetAddressforNOP() function, 152\nhidden data, displaying, 198–201\nGetAsyncKeyState() function, 196\nHidden option, Process Explorer\nGetExitCodeThread() function, 129\npane, 57\nGetModuleFileName() function, 144\nhooking, 42, 149, 153. See also Adobe\nGetModuleHandle() function, 129–130,\nAIR hooking; Direct3D\n134, 144, 146–147\nhooking; extrasensory\nGetSystemTimeAsFileTime() function, 258\nperception (ESP) hacks\nGetThreadContext() function, 139, 142 call, 153–156\nGetTickCount() function, 254 detecting visual cues in games,\nGetWindowThreadProcessId() function, 120 205–206\ngoal state, 238\nIAT, 160–165\nGo To button, OllyDbg, 25\nintercepting network traffic,\ngreedy best-first search algorithm,\n206–211\n233–234\njump, 165–169\nGS register, 85\nprewritten libraries, 169\nguard protection, 126\nsignature-based detection,\nevading, 257\nH VF table, 156–160\nzoomhacks, 198\nhalting problem, 250\nhotkeys\nhandle manipulation options,\nPatches window, OllyDbg, 32\nProcess Explorer, 59–60\nProcess Explorer, 57\nhandler functions, 208\nProcess Monitor, 52\nhandles, 56, 121, 210–211, 252\nfor trainer, setting up, 10\n270 Index\nhourly experience, finding, 200 J\nHTTP (HyperText Transfer\njumpHookCallback() function, 168\nProtocol), 169\njump hooking, 165–169, 178–181\nHTTPS (HTTP Secure), 169\njump instructions, x86 assembly\nHUD (heads-up display), 198–201\nlanguage, 92–94\nI\nK\nIAT (import address table) hooking,\nkernel-mode rootkit, GameGuard\n160–165\ntoolkit, 249\nIDIV instruction, 92\nkeyboard, emulating, 211–215\nIMAGE_DOS_HEADER structure, 161\nKEYEVENTF_KEYUP flag, 212\nIMAGE_IMPORT_DESCRIPTOR structure, 162\nkiting, 222, 240–241\nIMAGE_OPTIONAL_HEADER structure, 161\nImage tab, Process Explorer\nL\nProperties dialog, 57–58\nIMAGE_THUNK_DATA structure, 162 libraries, hooking, 169\nimmediate value, 80 lighthacks, 190–192\nimport address table (IAT) hooking, list class, 110–111\n160–165 listItem class, 110–111\nimport descriptors, 162 little-endian ordering, 67\nIMUL arithmetic instruction, 90–91 loader lock, 144\nIncreased Value By scan type, Cheat loading-screen HUDs, 201\nEngine, 7 LoadLibrary() function, 143–144\nIncreased Value scan type, Cheat Location column, Event Properties\nEngine, 7 window, 54\nindex registers, 83 logging events, Process Monitor,\ninfinite loops, causing 50–52\nunavoidable, 255 Log window, OllyDbg, 25\nin-game actions, bots for long data type, 67\nanti-crowd-control hacks, 218 long long data type, 67\nautomatic healer, 218, 225–228, looting, 229, 241–243\n230–232 Lua scripting environment, Cheat\nemulating keyboard, 211–215 Engine, 18–22\nsending packets, 215–217 lure mode, 242\nspell trainers, 219\nin-game events, logging, 50–52\nM\ninstructions, 79\narithmetic, 90–92 machine code, 78\nbranching, 92–94 main loop\ndata modification, 89 Direct3D drawing loop,\nfunction calls, 94–95 176–177\njump, 92–94 syncing with, 164–165\nint data type, 67 mana, avoiding wasted, 219\nIntel syntax, 80 Manhattan distance heuristic, 235\ninterrupt handlers, checking for, 252 mantissa, float data type, 68\niterator, 120\nIndex 271\nmassively multiplayer online memory manipulation, 119\nrole-playing games accessing memory, 122–124\n(MMORPGs), xxi–xxii, address space layout\n198, 248 randomization, 128–130\nmassive online battle arena (MOBA), memory protection, 124–128\nxxii, 189, 197, 201, 206 process identifier, obtaining,\nmemcpy() function, 136 120–122\nmemory, 65–66 Memory map window, OllyDbg, 26\nclasses and VF tables, 74–78 memory modification, 8–11\ndata structures, 71–73 memory monitoring with bots,\nnumeric data, 67–69 204–205\nstring data, 69–71 memory offset, 80\nunions, 73–74 memory on write breakpoint, 208\nmemory access memory pointer, 11\nin injected DLL, 145–146 memory protection, 124–128, 151\nfor writing and reading, memory scanning, 3, 98. See also\n122–124 Cheat Engine; pointer\nmemory addresses, 4 scanning\naccessing with OllyDbg basic, 4–5\nexpressions, 36 importance of, 4\ncorrect, determining in Cheat memory modification, 8–11\nEngine, 7 new addresses, determining after\nfreezing, 8 game updates, 101–104\nnew, determining after game optimization of code, 22\nupdates, 101–104 player health, finding with\nrebasing at runtime, 128–129 OllyDbg, 99–101\nstatic, 6 purpose of data, deducing,\nmemory-based lighthacks, 192 98–99\nmemory dump MMORPGs (massively multiplayer\nof class data, 76 online role-playing\nof code cave, 137 games), xxi–xxii, 198, 248\nof data structures, inspecting, mnemonics, 78\n70–71 MOBA (massive online battle arena),\nof numeric data, inspecting, xxii, 189, 197, 201, 206\n68–69 modifying memory values, 8–11\nof string data, inspecting, 70 Module32First() function, 144, 174\nmemory forensics, 97–98 Module32Next() function, 144, 174\nnew addresses, determining Module column, Event Properties\nafter game updates, window, 54\n101–104 Modules window, OllyDbg, 25\nplayer health, finding with monitoring memory with bots,\nOllyDbg, 99–101 204–205\npurpose of data, deducing, monsters, kiting, 240–241\n98–99 mouse movements, emulating,\nstd::list class, 110–113 215, 240\nstd::map class, 114–118 MOV instruction, 89\nstd::string class, 105–108 multiclient patching, 30\nstd::vector class, 108–110 mutexes, closing, 59–60\n272 Index\nN dealing with game updates, 104\ndebugger buttons and\nnamed pipes, locating, 60\nfunctions, 25\nname of specific player, pausing\nexpression engine, 33–37\nexecution when printed,\nmemory, viewing and searching,\n37–38\n29–30\nNames window, OllyDbg, 29\nmemory dump of numeric data,\nnear calls, 153–154\n68–69\nnear function call, 39\nmemory dump of string data, 70\n.NET processes, 59\npacket parser, finding, 207–208\nNetwork event class filter, 52\nPatches window, 31–32\nnew addresses, determining after\npatching if() statements, 46–47\ngame updates, 101–104\npausing execution when health\nnext scan, running in Cheat\nof character drops,\nEngine, 7\n39–42\nnodes, 233, 234–238\npausing execution when name\nno-operation (NOP) commands,\nof player is printed,\n31, 32\n37–38\nNOPing, 150–152\nplug-ins, 42–46\nlighthacks, 192\nregister contents, viewing and\nzoomhacks, 197–198\nediting, 29\nNtQueryVirtualMemory() function, 246,\nRun trace window, 32–33\n257, 259\nsupported data types, 36\nNtWriteVirtualMemory() function,\ntranslating code cave assembly\n261–262\nto shellcode, 135–136\nnull terminator, 70\nuser interface, 24–26\nnumeric data types, 67–69\nzoom limitation code,\nnumeric operators, OllyDbg, 34–35\nfinding, 198\nOllyFlow plug-in, 45–46\nO\nopcodes, 78\nobfuscation, 251, 255–256 OpenProcess() function, 121–122\nobserving game events OpenThread() function, 142\ndetecting visual cues, 205–206 operands\nintercepting network traffic, binary arithmetic\n206–211 instructions, 90\nmonitoring memory, 204–205 IDIV instruction, 92\nobstacles, searches disrupted by, MOV instruction, 89\n233–234 syntax, 80–81\noffset, 54 unary arithmetic instructions, 90\nOllyDbg, 23–24 operations, 79\nassembly code, 27–29, 32–33 operators, using in OllyDbg\ncall stack, viewing, 30 expression engine, 34–35\ncode patches, creating, 31–32 optimizing memory code, 22\ncommand line for, 43–44 ordering, little-endian, 67\ncontrol windows, 25–26 order of variables, in data structures,\nCPU window, 26–30 70–71\ncrashing debuggers, 255 OutputDebugString() function, 253\nIndex 273\nP Popup trainer on keypress field,\nTrainer generator\npackets\ndialog, 9\nintercepting, 206–211\npredicting enemy movements, 241\nsending, 215–217\nprewritten hooking libraries, 169\npacking, 251\nprintf() call, 72, 73–74, 75\npadding, 68\nprinting debug strings, 253\npage protection, 125–126\nProcess32First() function, 120\npages, 124\nProcess32Next() function, 120–121\nparsing packets, 206–211\nprocess access flags, 121\nPatches window, OllyDbg, 26, 31–32\nPROCESS_ALL_ACCESS flag, 121\npatching, multiclient, 30\nProcess and thread activity event\npatching if() statements, 46–47\nclass filter, 52\nPath column, Event Properties\nPROCESS_CREATE_THREAD flag, 121\ndialog, 55\nprocess environment block (PEB)\npathfinding with search algorithms,\nstructure, 146\n232–234. See also A* search\nProcess Explorer, 49–50, 55–56\nalgorithm\nconfiguring colors, 56\npath list, A* search algorithm,\nhandle manipulation options,\n239–240\n59–60\nPause button, OllyDbg, 25\nhotkeys, 57\npausing execution, 37–38, 39–42\nProperties dialog, 57–59\npausing threads, 184\nuser interface and controls,\nPEB (process environment block)\n56–57\nstructure, 146\nprocess handles, obtaining, 121\nPeekMessage() function, 184\nprocess identifier (PID), 120–122\nPE header, 160–161\nprocessInput() function, 215–216\npick-phase HUDs, 201\nprocessKeyboardInput() function, 216\nPID (process identifier), 120–122\nProcess Monitor, 49–50\npipes, locating named, 60\nconfiguring columns in, 51\nPlay button, OllyDbg, 25\ndebugging, 53–55\nplayer health, finding with OllyDbg,\nevent class filters, 51–52\n99–101\nhigh-score file, finding, 55\nplayer versus player (PvP) combat,\nhotkeys, 52\n243–244\ninspecting events in event log,\nplug-ins, OllyDbg, 42–46\n52–53\npointer chains, 11–12\nlogging in-game events, 50–52\npointer path, 11\nProcess Monitor Filter dialog, 50\nPointerscanner Scanoptions dialog,\nProcessname field, Trainer generator\nCheat Engine, 14–16\ndialog, 9\npointer scanning, 11\nprocessNextPacket() function, 210\nbasics of, 12–14\nprocessor registers, 81–86\nwith Cheat Engine, 14–18\nProcess profiling event class\npointer chains, 11–12\nfilter, 52\nrescanning, 17–18\nPROCESS_VM_OPERATION flag, 121, 122\nPong, 46–47\nPROCESS_VM_READ flag, 121\nPROCESS_VM_WRITE flag, 121\n274 Index\nProperties dialog, Process Explorer, detecting visual cues, 205–206\n57–59 emulating keyboard, 211–215\nprotection, memory, 124–128, 151 intercepting network traffic,\nPunkBuster toolkit, 246–247, 257 206–211\npurpose of data, deducing, 98–99 monitoring memory, 204–205\nPvP (player versus player) combat, sending packets, 215–217\n243–244 spell trainers, 219\nrootkits\nr defeating anti-cheat, 261–262\nGameGuard toolkit, 248–249\nrange hacks, 201\nroot node, 113–114\nreading from game memory, 119\nRTMP. See Real Time Messaging\naccessing memory, 122–124\nProtocol\naddress space layout\nRTS (real-time strategy), xxii, 197,\nrandomization, 128–130\n201, 206, 243\nmemory protection, 124–128\nruntime flexibility, 229\nprocess identifier, obtaining,\nRun trace window, OllyDbg, 26, 32–33\n120–122\nReadProcessMemory() function, 122–124\nS\nread protection, 125–128\nReal Time Messaging Protocol SBD. See signature-based\n(RTMP) detection (SBD)\nassessing, 169–170 scan code, 214\ndecode() function, hooking, scan types, Cheat Engine, 6\n172–173, 174–175 scan value, 4\nencode() function, hooking, score, 234\n171–172, 174–175 screenshots, 247, 258\nintercepting packets, 207 scripting custom behaviors for\nreal-time strategy (RTS), xxii, 197, cavebots, 243\n201, 206, 243 scripting engine, Cheat Engine, 18–22\nrebasing addresses at runtime, 128–129 search algorithms, 232–234. See also\nreconnaissance, 49–50 A* search algorithm\nProcess Explorer, 55–60 Security tab, Process Explorer\nProcess Monitor, 50–55 Properties dialog, 58\nrecv() function, 207–208 segment registers, 84–86\nred-black tree, 114–115 send() function, 216–217\nReferences window, OllyDbg, 26, sending packets, 215–217\n28–29, 40, 100 SendInput() function, 211–212, 215\nrefiller, 242 SendMessage() function, 213–215\nregisters, processor, 81–86 sensors, of a system, 222\nregisters pane, OllyDbg, 29 Set/Change hotkey screen, Cheat\nRegistry event class filter, 51 Engine, 10\nRescan pointerlist window, Cheat SetLight() member function, 192\nEngine, 17–18 SetProcessIsCritical() function, 256\nresponsive hacks, 203 shellcode, 134, 135–136, 138–141\nanti-crowd-control hacks, 218 short data type, 67\nautomatic healer, 218, 225–228, sign, float data type, 68\n230–232\nIndex 275\nsignature-based detection (SBD) subregisters, 83\nESEA Anti-Cheat toolkit, 247 SuspendThread() function, 142, 184\nevading, 256–257 syncing with game threads, 164–165\nPunkBuster toolkit, 246–247 systems, controlling behavior of, 222\nsignatures, 246\nsingle-instance limitation, 59–60 t\nskillshots, 232\ntargets, selecting, 240\nSleep() function, 164–165, 227\nTCP/IP tab, Process Explorer\nSmaller Than scan type, Cheat\nProperties dialog, 58\nEngine, 6\nTEB (thread environment block), 146\nsource operand, 80\ntemplates\nSource window, OllyDbg, 26\nfor changing memory\nspawning threads, 129\nprotection, 127\nspells\nmemory access functions,\nanti-crowd-control hacks, 218\n123–124, 145–146\ncomplex hypothetical state\nmachine, 228–230 TEST instruction, 92\ntext strings, 21, 69–71, 100–101\nspell trainers, 219\ntexture of enemies, changing,\nSS register, 85\n195–196\nstack frame, 87–89\n__thiscall convention, 95,\nstack overflow, 255–256\n156–158, 217\nstack pane, OllyDbg, 30\nThread32First() function, 141\nstack trace, Process Monitor, 54–55\nstate machines, 223–224 Thread32Next() function, 141\nthread environment block\nautomated healer, 225–228\n(TEB), 146\ncombining with control\nthreads\ntheory, 225\nhijacking, 138–142\ncomplex hypothetical, 228–230\ninjection, 134–138\nerror correction, 230–232\nspawning, 129\nLua functions, adding, 229–230\nThreads tab, Process Explorer\nruntime flexibility, 229\nProperties dialog, 58\nstatic addresses, 6\nThreads window, OllyDbg, 26\n__stdcall convention, 95\nthunks, 162–163\nstd::list class, 110–113\ntiming control-critical routines, 254\nstd::map class, 114–118\nTitle field, Trainer generator\nstd::string class, 105–108\ndialog, 9\nstd::vector class, 108–110\ntoggling z-buffering, 195\nStep into button, OllyDbg, 25\nTrace into button, OllyDbg, 25\nStep over button, OllyDbg, 25\nTrace over button, OllyDbg, 25\nstochastic systems, 230\ntracing with OllyDbg, 32–33, 39–42\nstring data, 21, 69–71, 100–101\ntrainer generator, Cheat Engine,\nstring operators, OllyDbg, 35\n9–11\nStrings tab, Process Explorer\ntrampoline functions, 165–168, 181\nProperties dialog, 58\ntraversals\nstruct member alignment, 71\nIAT hooking, 162\nstructures, data, 71–73\nVF tables, 156\n276 Index\nU Windows window, OllyDbg, 26\nWM_CHAR messages, 213–214\nunary arithmetic instructions, 90\nWORD data type, 67\nunavoidable infinite loops,\nWriteProcessMemory() function,\ncausing, 255\n122–124, 136–137, 138\nUnchanged Value scan type, Cheat\nwrite protection, 125–128\nEngine, 7\nwriting to game memory, 119\nunions, 73–74\naccessing memory, 122–124\nUnix syntax, 80\naddress space layout\nUnknown Initial Value scan type,\nrandomization, 128–130\nCheat Engine, 6\ncode caves, 136–137\nupdates, determining new addresses\nmemory protection, 124–128\nafter, 101–104\nprocess identifier, obtaining,\nuser interface, Process Explorer,\n120–122\n56–57\nuser-mode rootkit, GameGuard\nX\ntoolkit, 248–249\nx86 assembly language, 78–79\nV arithmetic instructions, 90–92\nbranching instructions, 92–94\nVAC toolkit, 247–248\ncall stack, 86–88\nValue Between scan type, Cheat\ncommand syntax, 79–81\nEngine, 6\ndata modification\nValue Type directive, Cheat Engine, 6\ninstructions, 89\nVF (virtual function) tables\nfunction calls, 94–95\nclass instances and, 76–78\njump instructions, 92–94\nfinding Direct3D devices,\nNOPing, 150–152\n177–181\nprocessor registers, 81–86\nhooking, 156–160, 182–183\nx86 Windows memory protection\ntraversals, 156\nattributes, 125–126\nVirtualAllocEx() function,\n136–137, 138\nZ\nvirtual functions, classes with, 75–76\nVirtualProtectEx() function, 126–128 z-buffering, 192–195\nVirtualProtect() function, 127 zoom factor, 197\nzoomhacks, 197–198\nW\nWaitForSingleObject() function, 129, 138\nwallhacks, 192\ncreating for Direct3D, 194–197\nrendering with z-buffering,\n193–194\nwarbots, 243–244\nWarden toolkit, 249–250\nwaypoints, 222, 229\nwchar_t data type, 67\nwindow handle, fetching, 120\nIndex 277\nresources\nVisit https://www.nostarch.com/gamehacking/ for resources, errata, and other\ninformation.\nMore no-nonsense books from no starcH Press\nBlack Hat PytHon tHe car Hacker’s HandBook tHe ida Pro Book, 2nd edition\nPython Programming for A Guide for the Penetration Tester The Unofficial Guide to the\nHackers and Pentesters by craig smith World’s Most Popular Disassembler\nby justin seitz mar 2016, 304 pp., $49.95 by chris eagle\ndec 2014, 192 pp., $34.95 isbn 978-1-59327-703-1 jul 2011, 672 pp., $69.95\nisbn 978-1-59327-590-7 isbn 978-1-59327-289-0\nPractical Forensic imaging ios aPPlication security Practical malware analysis\nSecuring Digital Evidence with Linux Tools The Definitive Guide for Hackers The Hands-On Guide to\nby bruce nikkel and Developers Dissecting Malicious Software\nfall 2016, 256 pp., $49.95 by david thiel by michael sikorski and\nisbn 978-1-59327-793-2 feb 2016, 296 pp., $49.95 andrew honig\nisbn 978-1-59327-601-0 feb 2012, 800 pp., $59.95\nisbn 978-1-59327-290-6\n800.420.7240 or 415.863.9900 | sales@nostarch.com | www.nostarch.com\nGet Inside the Game\nGame Hacking\nYou don’t need to be a wizard to transform a You’ll even discover the secrets behind common\ngame you like into a game you love. Imagine game bots, including:\nif you could give your favorite PC game a more\ninformative heads-up display or i nstantly col- 💎\nExtrasensory perception hacks, such as\nwallhacks and heads-up displays Developing Autonomous Bots\nlect all that loot from your latest epic battle.\nBring your knowledge of Windows-based 💎\nResponsive hacks, such as autohealers and\ncombo bots\ndevelopment and memory management,\nand Game Hacking will teach you what you for Online Games\n💎\nBots with artificial intelligence, such as\nneed to become a true game hacker. Learn\ncave walkers and automatic looters\nthe basics, like reverse engineering, assembly\ncode analysis, programmatic memory manip- Game hacking might seem like black magic,\nulation, and code injection, and hone your but it doesn’t have to be. Once you understand\nnew skills with hands-on example code and how bots are made, you’ll be better positioned\npractice binaries. to defend against them in your own games.\nJourney through the inner workings of PC\nLevel up as you learn how to:\ngames with Game Hacking, and leave with a\ndeeper understanding of both game design\n💎\nScan and modify memory with Cheat\nand computer security.\nEngine\n💎\nExplore program structure and execution About the Author\nflow with OllyDbg\nNick Cano wrote his first scripts for open source\n💎\nLog processes and pinpoint useful data files\ngame servers when he was 12 and has been\nwith Process Monitor\na part of the game-hacking community ever\n💎\nManipulate control flow through NOPing, since. He has years of experience in detecting\nhooking, and more and defending against malware, and advises\ndevelopers and designers on best practices\n💎 Locate and dissect common game memory to protect their games against bots. Nick has\nstructures spoken about his research and tools at many\nconferences.\nTHE FINEST IN GEEK ENTERTAINMENT™\nwww.nostarch.com\nCano\n$44.95 ($51.95 CDN) Shelve In: ComputerS/SeCurIty\nDeveloping\nAutonomous\nBots\nfor\nOnline\nGames\nWARNING! This book does not condone piracy, violating the DMCA, infringing copyright, or breaking in-game Terms of\nService. Game hackers have been banned from games for life, sued for millions of dollars, and even jailed for their work.\nNick Cano\nForeword by Dr. Jared DeMott\nGame\nHacking"
  }
]