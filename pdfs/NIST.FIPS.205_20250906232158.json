[
  {
    "start": 1,
    "end": 4,
    "text": "FIPS 205\nFederal Information Processing Standards Publication\nStateless Hash-Based Digital Signature\nStandard\nCategory: Computer Security Subcategory: Cryptography\nInformation Technology Laboratory\nNational Institute of Standards and Technology\nGaithersburg, MD 20899-8900\nThis publication is available free of charge from:\nhttps://doi.org/10.6028/NIST.FIPS.205\nPublished: August 13, 2024\nU.S. Department of Commerce\nGina M. Raimondo, Secretary\nNational Institute of Standards and Technology\nLaurie E. Locascio, NIST Director and Under Secretary of Commerce for Standards and Technology\nForeword\nThe Federal Information Processing Standards Publication (FIPS) series of the National Institute of Standards\nand Technology (NIST) is the official series of publications relating to standards and guidelines developed\nunder 15 U.S.C. 278g-3, and issued by the Secretary of Commerce under 40 U.S.C. 11331.\nComments concerning this Federal Information Processing Standard publication are welcomed and should\nbe submitted using the contact information in the â€œInquiries and commentsâ€ clause of the announcement\nsection.\nKevin M. Stine, Director\nInformation Technology Laboratory\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nAbstract\nThis standard specifies the stateless hash-based digital signature algorithm (SLH-DSA). Digital\nsignatures are used to detect unauthorized modifications to data and to authenticate the identity\nof the signatory. In addition, the recipient of signed data can use a digital signature as evidence in\ndemonstrating to a third party that the signature was, in fact, generated by the claimed signatory.\nThis is known as non-repudiation since the signatory cannot easily repudiate the signature at a\nlater time. SLH-DSA is based on SPHINCS+ , which was selected for standardization as part of the\nNIST Post-Quantum Cryptography Standardization process.\nKeywords: computer security; cryptography; digital signatures; Federal Information Processing\nStandards; hash-based signatures; post-quantum; public-key cryptography.\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nFederal Information Processing Standards Publication 205\nPublished: August 13, 2024\nEffective: August 13, 2024\nAnnouncing the\nStateless Hash-Based Digital Signature Standard\nFederal Information Processing Standards (FIPS) publications are developed by the National\nInstitute of Standards and Technology (NIST) under 15 U.S.C. 278g-3 and issued by the Secretary\nof Commerce under 40 U.S.C. 11331.\n1. Name of Standard. Stateless Hash-Based Digital Signature Standard (FIPS 205).\n2. Category of Standard. Computer Security. Subcategory. Cryptography.\n3. Explanation. This standard specifies a stateless hash-based digital signature scheme (SLH-\nDSA) for applications that require a digital signature rather than a written signature. Additional\ndigital signature schemes are specified and approved in other NIST Special Publications and\nFIPS publications (e.g., FIPS 186-5 [1]). A digital signature is represented in a computer as a\nstring of bits and computed using a set of rules and parameters that allow the identity of the\nsignatory and the integrity of the data to be verified. Digital signatures may be generated on\nboth stored and transmitted data.\nSignature generation uses a private key to generate a digital signature. Signature verification\nuses a public key that corresponds to but is not the same as the private key. Each signatory\npossesses a private and public key pair. Public keys may be known by the public, but private\nkeys must be kept secret. Anyone can verify the signature by employing the signatoryâ€™s public\nkey. Only the user who possesses the private key can perform signature generation.\nThe digital signature is provided to the intended verifier along with the signed data. The\nverifying entity verifies the signature by using the claimed signatoryâ€™s public key. Similar\nprocedures may be used to generate and verify signatures for both stored and transmitted\ndata.\nThis standard specifies several parameter sets for SLH-DSA that are approved for use. Addi-\ntional parameter sets may be specified and approved in future NIST Special Publications.\n4. Approving Authority. Secretary of Commerce.\n5. Maintenance Agency. Department of Commerce, National Institute of Standards and Tech-\nnology, Information Technology Laboratory (ITL).\n6. Applicability. This standard is applicable to all federal departments and agencies for the\nprotection of sensitive unclassified information that is not subject to section 2315 of Title 10,\nUnited States Code, or section 3502 (2) of Title 44, United States Code. Either this standard,\nFIPS 204, FIPS 186-5, or NIST Special Publication 800-208 shall be used in designing and\nimplementing public-key-based signature systems that federal departments and agencies op-\nerate or that are operated for them under contract. In the future, additional digital signature\ni\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nschemes may be specified and approved in FIPS publications or NIST Special Publications.\nThe adoption and use of this standard are available to private and commercial organizations.\n7. Applications. A digital signature algorithm allows an entity to authenticate the integrity of\nsigned data and the identity of the signatory. The recipient of a signed message can use a\ndigital signature as evidence in demonstrating to a third party that the signature was, in fact,\ngenerated by the claimed signatory. This is known as non-repudiation since the signatory\ncannot easily repudiate the signature at a later time. A digital signature algorithm is intended\nfor use in electronic mail, electronic funds transfer, electronic data interchange, software\ndistribution, data storage, and other applications that require data integrity assurance and\ndata origin authentication.\n8. Implementations. A digital signature algorithm may be implemented in software, firmware,\nhardware, or any combination thereof. NIST will develop a validation program to test imple-\nmentations for conformance to the algorithms in this standard. For every computational\nprocedure that is specified in this standard, a conforming implementation may replace the\ngiven set of steps with any mathematically equivalent process. In other words, different\nprocedures that produce the correct output for every input are permitted. Information about\nvalidation programs is available at https://csrc.nist.gov/projects/cmvp. Examples for digital\nsignature algorithms are available at https://csrc.nist.gov/projects/cryptographic-standards-\nand-guidelines/example-values.\nAgencies are advised that digital signature key pairs shall not be used for other purposes.\n9. Other Approved Security Functions. Digital signature implementations that comply with this\nstandard shall employ cryptographic algorithms that have been approved for protecting Fed-\neral Government-sensitive information. Approved cryptographic algorithms and techniques\ninclude those that are either:\na. Specified in a Federal Information Processing Standard (FIPS) publication,\nb. Adopted in a FIPS or NIST recommendation, or\nc. Specified in the list of approved security functions in SP 800-140C.\n10. Export Control. Certain cryptographic devices and technical data regarding them are subject\nto federal export controls. Exports of cryptographic modules that implement this standard\nand technical data regarding them must comply with these federal regulations and be licensed\nby the Bureau of Industry and Security of the U.S. Department of Commerce. Information\nabout export regulations is available at https://www.bis.doc.gov.\n11. Patents. The algorithm in this standard may be covered by U.S. or foreign patents.\n12. Implementation Schedule. This standard becomes effective immediately upon final publica-\ntion.\n13. Specifications. Federal Information Processing Standard (FIPS) 205, Stateless Hash-Based\nDigital Signature Standard (affixed).\nii\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n14. Qualifications. The security of a digital signature system depends on the secrecy of the\nsignatoryâ€™s private keys. Signatories shall, therefore, guard against the disclosure of their\nprivate keys. While it is the intent of this standard to specify general security requirements for\ngenerating digital signatures, conformance to this standard does not ensure that a particular\nimplementation is secure. It is the responsibility of an implementer to ensure that any module\nthat implements a digital signature capability is designed and built in a secure manner.\nSimilarly, the use of a product containing an implementation that conforms to this standard\ndoes not guarantee the security of the overall system in which the product is used. The re-\nsponsible authority in each agency or department shall ensure that an overall implementation\nprovides an acceptable level of security.\nSince a standard of this nature must be flexible enough to adapt to advancements and\ninnovations in science and technology, this standard will be reviewed every five years in order\nto assess its adequacy.\n15. Waiver Procedure. The Federal Information Security Management Act (FISMA) does not\nallow for waivers to Federal Information Processing Standards (FIPS) that are made mandatory\nby the Secretary of Commerce.\n16. Where to Obtain Copies of the Standard. This publication is available by accessing https:\n//csrc.nist.gov/publications. Other computer security publications are available at the same\nwebsite.\n17. How to Cite This Publication. NIST has assigned NIST FIPS 205 as the publication identifier\nfor this FIPS, per the NIST Technical Series Publication Identifier Syntax. NIST recommends\nthat it be cited as follows:\nNational Institute of Standards and Technology (2024) Stateless Hash-Based Dig-\nital Signature Standard. (Department of Commerce, Washington, D.C.), Fed-\neral Information Processing Standards Publication (FIPS) NIST FIPS 205. https:\n//doi.org/10.6028/NIST.FIPS.205\n18. Inquiries and Comments. Inquiries and comments about this FIPS may be submitted to\nfips-205-comments@nist.gov.\niii\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nFederal Information Processing Standards Publication 205\nSpecification for the\nStateless Hash-Based Digital Signature Standard\nTable of Contents\n1 Introduction 1\n1.1 Purpose and Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1\n1.2 Context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1\n2 Glossary of Terms, Acronyms, and Symbols 2\n2.1 Terms and Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n2.2 Acronyms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n2.3 Mathematical Symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n3 Overview of the SLH-DSA Signature Scheme 7\n3.1 Additional Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n3.2 Implementation Considerations . . . . . . . . . . . . . . . . . . . . . . . . . 10\n4 Functions and Addressing 11\n4.1 Hash Functions and Pseudorandom Functions . . . . . . . . . . . . . . . . . 11\n4.2 Addresses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n4.3 Member Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n4.4 Arrays, Byte Strings, and Integers . . . . . . . . . . . . . . . . . . . . . . . . 15\n5 Winternitz One-Time Signature Plus Scheme 17\n5.1 WOTS+ Public-Key Generation . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n5.2 WOTS+ Signature Generation . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n5.3 Computing a WOTS+ Public Key From a Signature . . . . . . . . . . . . . . . 21\n6 eXtended Merkle Signature Scheme (XMSS) 22\n6.1 Generating a Merkle Hash Tree . . . . . . . . . . . . . . . . . . . . . . . . . 22\n6.2 Generating an XMSS Signature . . . . . . . . . . . . . . . . . . . . . . . . . . 23\n6.3 Computing an XMSS Public Key From a Signature . . . . . . . . . . . . . . . . 25\n7 The SLH-DSA Hypertree 26\niv\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n7.1 Hypertree Signature Generation . . . . . . . . . . . . . . . . . . . . . . . . . 26\n7.2 Hypertree Signature Verification . . . . . . . . . . . . . . . . . . . . . . . . . 28\n8 Forest of Random Subsets (FORS) 29\n8.1 Generating FORS Secret Values . . . . . . . . . . . . . . . . . . . . . . . . . . 29\n8.2 Generating a Merkle Hash Tree . . . . . . . . . . . . . . . . . . . . . . . . . 30\n8.3 Generating a FORS Signature . . . . . . . . . . . . . . . . . . . . . . . . . . . 30\n8.4 Computing a FORS Public Key From a Signature . . . . . . . . . . . . . . . . . 31\n9 SLH-DSA Internal Functions 33\n9.1 SLH-DSA Key Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\n9.2 SLH-DSA Signature Generation . . . . . . . . . . . . . . . . . . . . . . . . . . 34\n9.3 SLH-DSA Signature Verification . . . . . . . . . . . . . . . . . . . . . . . . . . 36\n10 SLH-DSA External Functions 37\n10.1 SLH-DSA Key Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n10.2 SLH-DSA Signature Generation . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n10.2.1 Pure SLH-DSASignature Generation . . . . . . . . . . . . . . . . . . . 38\n10.2.2 HashSLH-DSASignature Generation . . . . . . . . . . . . . . . . . . . 39\n10.3 SLH-DSA Signature Verification . . . . . . . . . . . . . . . . . . . . . . . . . . 41\n11 Parameter Sets 43\n11.1 SLH-DSA Using SHAKE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44\n11.2 SLH-DSA Using SHA2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44\n11.2.1 SLH-DSAUsingSHA2for SecurityCategory1 . . . . . . . . . . . . . . . 45\n11.2.2 SLH-DSA Using SHA2 for Security Categories 3 and 5 . . . . . . . . . . 46\nReferences 47\nAppendix A â€” Differences From the SPHINCS+ Submission 51\nA.1 Changes From FIPS 205 Initial Public Draft . . . . . . . . . . . . . . . . . . . . 51\nv",
    "question": "What is the purpose and key concept of the FIPS 205 standard?",
    "summary": "FIPS 205 is a U.S. federal standard for a stateless hash-based digital signature algorithm called SLH-DSA. It is designed to provide secure digital signatures that authenticate data integrity and identity, and are resistant to quantum computing threats. The standard is part of NIST's post-quantum cryptography efforts and is applicable to federal agencies for protecting sensitive unclassified information."
  },
  {
    "start": 5,
    "end": 6,
    "text": "FIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nList of Tables\nTable1 Memberfunctionsfor addresses . . . . . . . . . . . . . . . . . . . . . . 14\nTable2 SLH-DSAparameter sets . . . . . . . . . . . . . . . . . . . . . . . . . . 43\nTable 3 Member functions for compressed addresses . . . . . . . . . . . . . . . 45\nList of Figures\nFigure 1 AnSLH-DSAsignature . . . . . . . . . . . . . . . . . . . . . . . . . . . 8\nFigure 2 Address (ADRS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\nFigure 3 WOTS+ hashaddress . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\nFigure 4 WOTS+ public-key compressionaddress . . . . . . . . . . . . . . . . . 12\nFigure 5 Hashtree address . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\nFigure 6 FORStree address . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\nFigure 7 FORStree roots compressionaddress . . . . . . . . . . . . . . . . . . . 13\nFigure 8 WOTS+ keygenerationaddress . . . . . . . . . . . . . . . . . . . . . . 14\nFigure 9 FORSkeygenerationaddress . . . . . . . . . . . . . . . . . . . . . . . 14\nFigure 10 WOTS+ signature data format . . . . . . . . . . . . . . . . . . . . . . . 19\nFigure 11 XMSSsignature data format . . . . . . . . . . . . . . . . . . . . . . . . 22\nFigure 12 Merklehash tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\nFigure 13 HTsignature data format . . . . . . . . . . . . . . . . . . . . . . . . . 26\nFigure 14 FORSsignature data format . . . . . . . . . . . . . . . . . . . . . . . . 29\nFigure 15 SLH-DSAprivate key . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\nFigure 16 SLH-DSApublickey . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\nFigure 17 SLH-DSAsignature data format . . . . . . . . . . . . . . . . . . . . . . 34\nFigure 18 Compressed address (ADRS ğ‘ ) . . . . . . . . . . . . . . . . . . . . . . 45\nList of Algorithms\nAlgorithm 1 gen_len (ğ‘›, ğ‘™ğ‘” ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n2 ğ‘¤\nAlgorithm 2 toInt(ğ‘‹, ğ‘›) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\nAlgorithm 3 toByte(ğ‘¥, ğ‘›) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\nAlgorithm 4 base_2b(ğ‘‹, ğ‘, ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘›) . . . . . . . . . . . . . . . . . . . . . . . . 16\nAlgorithm 5 chain(ğ‘‹, ğ‘–, ğ‘ , PK.seed, ADRS) . . . . . . . . . . . . . . . . . . . 18\nAlgorithm 6 wots_pkGen(SK.seed, PK.seed, ADRS) . . . . . . . . . . . . . . 18\nAlgorithm 7 wots_sign(ğ‘€, SK.seed, PK.seed, ADRS) . . . . . . . . . . . . . 20\nAlgorithm 8 wots_pkFromSig(ğ‘ ğ‘–ğ‘”, ğ‘€, PK.seed, ADRS) . . . . . . . . . . . . . 21\nAlgorithm 9 xmss_node(SK.seed, ğ‘–, ğ‘§, PK.seed, ADRS) . . . . . . . . . . . . 23\nAlgorithm 10 xmss_sign(ğ‘€, SK.seed, ğ‘–ğ‘‘ğ‘¥, PK.seed, ADRS) . . . . . . . . . . . 24\nAlgorithm 11 xmss_pkFromSig(ğ‘–ğ‘‘ğ‘¥, SIG , ğ‘€, PK.seed, ADRS) . . . . . . . 25\nğ‘‹ğ‘€ğ‘†ğ‘†\nAlgorithm 12 ht_sign(ğ‘€, SK.seed, PK.seed, ğ‘–ğ‘‘ğ‘¥ , ğ‘–ğ‘‘ğ‘¥ ) . . . . . . . . . . 27\nğ‘¡ğ‘Ÿğ‘’ğ‘’ ğ‘™ğ‘’ğ‘ğ‘“\nAlgorithm 13 ht_verify(ğ‘€, SIG , PK.seed, ğ‘–ğ‘‘ğ‘¥ , ğ‘–ğ‘‘ğ‘¥ , PK.root) . . . . . . 28\nğ»ğ‘‡ ğ‘¡ğ‘Ÿğ‘’ğ‘’ ğ‘™ğ‘’ğ‘ğ‘“\nAlgorithm 14 fors_skGen(SK.seed, PK.seed, ADRS, ğ‘–ğ‘‘ğ‘¥) . . . . . . . . . . . . 29\nvi\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 15 fors_node(SK.seed, ğ‘–, ğ‘§, PK.seed, ADRS) . . . . . . . . . . . . . 30\nAlgorithm 16 fors_sign(ğ‘šğ‘‘, SK.seed, PK.seed, ADRS) . . . . . . . . . . . . . 31\nAlgorithm 17 fors_pkFromSig(SIG , ğ‘šğ‘‘, PK.seed, ADRS) . . . . . . . . . . 32\nğ¹ ğ‘‚ğ‘…ğ‘†\nAlgorithm 18 slh_keygen_internal(SK.seed, SK.prf, PK.seed) . . . . . . . . . . 34\nAlgorithm 19 slh_sign_internal(ğ‘€, SK, ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘›ğ‘‘) . . . . . . . . . . . . . . . . . . . 35\nAlgorithm 20 slh_verify_internal(ğ‘€,SIG,PK) . . . . . . . . . . . . . . . . . . . . 36\nAlgorithm 21 slh_keygen() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\nAlgorithm 22 slh_sign(ğ‘€, ğ‘ğ‘¡ğ‘¥,SK) . . . . . . . . . . . . . . . . . . . . . . . . . . 39\nAlgorithm 23 hash_slh_sign(ğ‘€, ğ‘ğ‘¡ğ‘¥,PH,SK) . . . . . . . . . . . . . . . . . . . . . 40\nAlgorithm 24 slh_verify(ğ‘€, SIG, ğ‘ğ‘¡ğ‘¥,PK) . . . . . . . . . . . . . . . . . . . . . . . 41\nAlgorithm 25 hash_slh_verify(ğ‘€, SIG, ğ‘ğ‘¡ğ‘¥,PH,PK) . . . . . . . . . . . . . . . . . 42\nvii\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n1. Introduction\n1.1 Purpose and Scope\nThis standard defines a method for digital signature generation that can be used for the protection\nof binary data (commonly called a message) and for the verification and validation of those digital\nsignatures.1 The security of the stateless hash-based digital signature algorithm (SLH-DSA) relies\non the presumed difficulty of finding preimages for hash functions as well as several related\nproperties of the same hash functions. Unlike the algorithms specified in FIPS 186-5 [1], SLH-DSA\nis designed to provide resistance against attacks from a large-scale quantum computer.\nThis standard specifies the mathematical steps that need to be performed for key generation,\nsignature generation, and signature verification. Additional assurances are required for digital\nsignatures to be valid (e.g., the assurance of identity and private key possession). SP 800-89,\nRecommendation for Obtaining Assurances for Digital Signature Applications [3], specifies the\nrequired assurances and the methods for obtaining these assurances.\n1.2 Context\nOver the past several years, there has been steady progress toward building quantum computers.\nThe security of many commonly used public-key cryptosystems will be at risk if large-scale\nquantum computers are ever realized. This would include key-establishment schemes and digital\nsignatures that are based on integer factorization and discrete logarithms (both over finite fields\nand elliptic curves). As a result, in 2016, NIST initiated a public Post-Quantum Cryptography\n(PQC) Standardization process to select quantum-resistant public-key cryptographic algorithms\nfor standardization. A total of 82 candidate algorithms were submitted to NIST for consideration.\nAfter three rounds of evaluation and analysis, NIST selected the first four algorithms for stan-\ndardization. These algorithms are intended to protect sensitive U.S. Government information\nwell into the foreseeable future, including after the advent of cryptographically relevant quan-\ntum computers. This standard includes the specification for one of the algorithms selected:\nSPHINCS+ , a stateless hash-based digital signature scheme. This standard contains several minor\nmodifications compared to Version 3 [4], which was submitted at the beginning of round three\nof the NIST PQC Standardization process. The changes are described in Appendix A. Throughout\nthis standard, SPHINCS+ will be referred to as SLH-DSA for stateless hash-based digital signature\nalgorithm.\n1NIST Special Publication (SP) 800-175B [2], Guideline for Using Cryptographic Standards in the Federal Government:\nCryptographic Mechanisms, includes a general discussion of digital signatures.\n1",
    "question": "What is the purpose of the FIPS 205 standard and how does it address the security concerns related to quantum computing?",
    "summary": "The FIPS 205 standard outlines a stateless hash-based digital signature method called SLH-DSA, which is designed to be quantum-resistant. It details the mathematical steps for key generation, signature creation, and verification. The standard specifies SPHINCS+ as the algorithm, which includes minor modifications from its previous version."
  },
  {
    "start": 7,
    "end": 12,
    "text": "FIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n2. Glossary of Terms, Acronyms, and Symbols\n2.1 Terms and Definitions\napproved FIPS-approved and/or NIST-recommended. An algorithm or tech-\nnique that is either 1) specified in a FIPS or NIST recommendation, 2)\nadopted in a FIPS or NIST recommendation, or 3) specified in a list of\nNIST-approved security functions. [1]\nbig-endian The property of a byte string having its bytes positioned in order of\ndecreasing significance. In particular, the leftmost (first) byte is the\nmost significant, and the rightmost (last) byte is the least significant.\nThe term â€œbig-endianâ€ may also be applied in the same manner to bit\nstrings. [5, adapted]\nbyte string An array of integers in which each integer is in the set {0, â€¦ , 255}.\nclaimed signatory From the verifierâ€™s perspective, the claimed signatory is the entity that\npurportedly generated a digital signature. [1]\ndestroy An action applied to a key or a piece of secret data. After a key or a\npiece of secret data is destroyed, no information about its value can\nbe recovered. [1]\ndigital signature The result of a cryptographic transformation of data that, when prop-\nerly implemented, provides a mechanism for verifying origin authenti-\ncation, data integrity, and signatory non-repudiation. [1]\nentity An individual (person), organization, device, or process. Used inter-\nchangeably with party. [1]\nequivalent process Two processes are equivalent if the same output is produced when\nthe same values are input to each process (either as input parameters,\nas values made available during the process, or both). [1]\nextendable-output A function on bit strings in which the output can be extended to any\nfunction desired length. Approved XOFs (such as those specified in FIPS 202 [6])\nare designed to satisfy the following properties as long as the specified\noutput length is sufficiently long to prevent trivial attacks:\n1. (One-way) It is computationally infeasible to find any input that\nmaps to any new pre-specified output.\n2. (Collision-resistant) It is computationally infeasible to find any\ntwo distinct inputs that map to the same output. [7, adapted]\nfresh random value A previously unused output of a random bit generator.\nhash function A function on bit strings in which the length of the output is fixed.\nApproved hash functions (such as those specified in FIPS 180 [8] and\nFIPS 202 [6]) are designed to satisfy the following properties:\n2\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n1. (One-way) It is computationally infeasible to find any input that\nmaps to any new pre-specified output\n2. (Collision-resistant) It is computationally infeasible to find any\ntwo distinct inputs that map to the same output. [1]\nhash value See message digest.\nkey A parameter used in conjunction with a cryptographic algorithm that\ndetermines its operation. Examples applicable to this standard include:\n1. The computation of a digital signature from data, and\n2. The verification of a digital signature. [1]\nkey pair A public key and its corresponding private key. [1]\nmessage The data that is signed. Also known as signed data during the signature\nverification and validation process. [1]\nmessage digest The result of applying a hash function to a message. Also known as a\nhash value. [1]\nnon-repudiation A service that is used to provide assurance of the integrity and origin\nof data in such a way that the integrity and origin can be verified and\nvalidated by a third party as having originated from a specific entity in\npossession of the private key (i.e., the signatory). [1]\nowner A key pair owner is the entity authorized to use the private key of a\nkey pair. [1]\nparty An individual (person), organization, device, or process. Used inter-\nchangeably with entity. [1]\nprivate key A cryptographic key that is used with an asymmetric (public-key) cryp-\ntographic algorithm. The private key is uniquely associated with the\nowner and is not made public. The private key is used to compute a\ndigital signature that may be verified using the corresponding public\nkey. [1]\npseudorandom A process or data produced by a process is said to be pseudorandom\nwhen the outcome is deterministic yet also effectively random as long\nas the internal action of the process is hidden from observation. For\ncryptographic purposes, â€œeffectively randomâ€ means â€œcomputation-\nally indistinguishable from random within the limits of the intended\nsecurity strength.â€ [1]\npublic key A cryptographic key that is used with an asymmetric (public-key) cryp-\ntographic algorithm and is associated with a private key. The public\nkey is associated with an owner and may be made public. In the case\nof digital signatures, the public key is used to verify a digital signature\nthat was generated using the corresponding private key. [1]\n3\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nsecurity category A number associated with the security strength of a post-quantum\ncryptographic algorithm, as specified by NIST (see [9, Sect. 5.6]).\nsecurity strength A number associated with the amount of work (i.e., the number of\noperations) that is required to break a cryptographic algorithm or\nsystem. [1]\nshall Used to indicate a requirement of this standard. [1]\nshould Used to indicate a strong recommendation but not a requirement of\nthis standard. Ignoring the recommendation could result in undesir-\nable results. [1]\nsignatory The entity that generates a digital signature on data using a private\nkey. [1]\nsignature generation The process of using a digital signature algorithm and a private key to\ngenerate a digital signature on data. [1]\nsignature validation The (mathematical) verification of the digital signature and obtain-\ning the appropriate assurances (e.g., public-key validity, private-key\npossession, etc.). [1]\nsignature verification The process of using a digital signature algorithm and a public key to\nverify a digital signature on data. [1]\nsigned data The data or message upon which a digital signature has been computed.\nAlso see message. [1]\nverifier The entity that verifies the authenticity of a digital signature using the\npublic key. [1]\n2.2 Acronyms\nADRS Address\nADRSc Compressed Address\nAES Advanced Encryption Standard\nDER Distinguished Encoding Rules\nFIPS Federal Information Processing Standard\nFORS Forest of Random Subsets\nITL Information Technology Laboratory\nMGF Mask Generation Function\nNIST National Institute of Standards and Technology\nOID Object Identifier\nPQC Post-Quantum Cryptography\nPRF Pseudorandom Function\n4\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nSHA Secure Hash Algorithm\nSHAKE Secure Hash Algorithm KECCAK\nSP Special Publication\nRFC Request for Comments\nWOTS+ Winternitz One-Time Signature Plus\nXMSS eXtended Merkle Signature Scheme\nXOF eXtendable-Output Function\n2.3 Mathematical Symbols\nğ‘‹ âˆ¥ ğ‘Œ The concatenation of two arrays ğ‘‹ and ğ‘Œ. If ğ‘‹ is an array of length â„“ ,\nğ‘¥\nand ğ‘Œ is an array of length â„“ , then ğ‘ = ğ‘‹ âˆ¥ ğ‘Œ is an array of length\nğ‘¦\nâ„“ + â„“ such that\nğ‘¥ ğ‘¦\nğ‘‹[ğ‘–] if 0 â‰¤ ğ‘– < â„“\nğ‘[ğ‘–] = { ğ‘¥\nğ‘Œ [ğ‘– âˆ’ â„“ ] if â„“ â‰¤ ğ‘– < â„“ +â„“ .\nğ‘¥ ğ‘¥ ğ‘¥ ğ‘¦\nğ‘‹[ğ‘– âˆ¶ ğ‘—] A subarray of ğ‘‹. If ğ‘‹ is an array of length â„“ , 0 â‰¤ ğ‘– < ğ‘— â‰¤ â„“ , and\nğ‘¥ ğ‘¥\nğ‘Œ = ğ‘‹[ğ‘– âˆ¶ ğ‘—], then ğ‘Œ is an array of length ğ‘— âˆ’ ğ‘– such that ğ‘Œ [ğ‘˜] =\nğ‘‹[ğ‘– + ğ‘˜] for 0 â‰¤ ğ‘˜ < ğ‘— âˆ’ğ‘–.\nTrunc (ğ‘‹) A truncation function that outputs the leftmost â„“ bytes of the input\nâ„“\nbyte string ğ‘‹. If ğ‘Œ = Trunc (ğ‘‹), then ğ‘Œ is a byte string (array) of\nâ„“\nlength â„“ such that ğ‘Œ [ğ‘–] = ğ‘‹[ğ‘–] for 0 â‰¤ ğ‘– < â„“ (i.e., ğ‘Œ = ğ‘‹[0 âˆ¶ â„“]).\n|ğ‘‹| The length (in bytes) of byte string ğ‘‹.\nâŒˆğ‘âŒ‰ The ceiling of ğ‘; the smallest integer that is greater than or equal to ğ‘.\nFor example, âŒˆ5âŒ‰ = 5, âŒˆ5.3âŒ‰ = 6, and âŒˆâˆ’2.1âŒ‰ = âˆ’2. [1]\nâŒŠğ‘âŒ‹ The floor of ğ‘; the largest integer that is less than or equal to ğ‘. For\nexample, âŒŠ5âŒ‹ = 5, âŒŠ5.3âŒ‹ = 5, and âŒŠâˆ’2.1âŒ‹ = âˆ’3. [1]\nğ‘ mod ğ‘› The unique remainder ğ‘Ÿ, 0 â‰¤ ğ‘Ÿ â‰¤ (ğ‘›âˆ’1), when integer ğ‘ is divided\nby the positive integer ğ‘›. For example, 23 mod 7 = 2. [1]\nğ‘ â‹… ğ‘ The product of ğ‘ and ğ‘. For example, 3â‹…5 = 15.\nğ‘ğ‘ ğ‘ raised to the power ğ‘. For example, 25 = 32.\nlog ğ‘¥ The base 2 logarithm of ğ‘¥. For example, log (16) = 4.\n2 2\n0b The prefix to a number that is represented in binary.\n0x The prefix to a number that is represented in hexadecimal. [1, adapted]\nğ‘ â‰« ğ‘ The logical right shift of ğ‘ by ğ‘ positions (i.e., ğ‘ â‰« ğ‘ = âŒŠğ‘/2ğ‘âŒ‹). For\nexample, 0x73 â‰« 4 = 7. [10, adapted]\n5\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nğ‘ â‰ª ğ‘ The logical left shift of ğ‘ by ğ‘ positions (i.e., ğ‘ â‰ª ğ‘ = ğ‘ â‹… 2ğ‘). For\nexample, 0x73 â‰ª 4 = 0x730. [10, adapted]\nğ‘ âŠ• ğ‘ The bitwise exclusive-or of ğ‘ and ğ‘. For example, 115 âŠ• 1 = 114\n(115 âŠ• 1 = 0b01110011 âŠ• 0b00000001 = 0b01110010 = 114).\nğ‘  â† ğ‘¥ In pseudocode, this notation means that the variable ğ‘  is set to the\nvalue of the expression ğ‘¥.\nğ‘  â† $ âˆ’ ğ”¹ğ‘› In pseudocode, this notation means that the variable ğ‘  is set to a\nbyte string of length ğ‘› chosen at random. A fresh random value is\ngenerated for each time this step is performed.\nâŠ¥ A symbol indicating failure or the lack of output from an algorithm.\n6\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n3. Overview of the SLH-DSA Signature Scheme\nSLH-DSA is a stateless hash-based signature scheme that is constructed using other hash-based\nsignature schemes as components: (1) a few-time signature scheme, forest of random subsets\n(FORS), and (2) a multi-time signature scheme, the eXtended Merkle Signature Scheme (XMSS).\nXMSS is constructed using the hash-based one-time signature scheme Winternitz One-Time\nSignature Plus (WOTS+) as a component.2\nConceptually, an SLH-DSA key pair consists of a very large set of FORS key pairs.3 The few-time\nsignature scheme FORS allows each key pair to safely sign a small number of messages. An\nSLH-DSA signature is created by computing a randomized hash of the message, using part of the\nresulting message digest to pseudorandomly select a FORS key, and signing the remaining part of\nthe message digest with that key. An SLH-DSA signature consists of the FORS signature and the\ninformation that authenticates the FORS public key. The authentication information is created\nusing XMSS signatures.\nXMSS is a multi-time signature scheme that is created using a combination of WOTS+ one-time\nsignatures and Merkle hash trees [13]. An XMSS key consists of 2â„â€² WOTS+ keys and can sign\n2â„â€² messages. The WOTS+ public keys are formed into a Merkle hash tree, and the root of the\ntree is the XMSS public key. (The Merkle hash tree formed from the WOTS+ keys is also referred\nto as an XMSS tree.) An XMSS signature consists of a WOTS+ signature and an authentication\npath within the Merkle hash tree for the WOTS+ public key. In Figure 1, triangles represent\nXMSS trees, squares represent the WOTS+ public keys, and circles represent the interior nodes\nof the hash tree. Within an XMSS tree, the square and circles that are filled in represent the\nauthentication path for the WOTS+ public key needed to verify the signature.\nThe authentication information for a FORS public key is a hypertree signature. A hypertree is a\ntree of XMSS trees, as depicted in Figure 1. The tree consists of ğ‘‘ layers4 in which the top layer\n(layer ğ‘‘ âˆ’ 1) consists of a single XMSS tree, the next layer down (layer ğ‘‘ âˆ’ 2) consists of 2â„â€²\nXMSS trees, and the lowest layer (layer 0) consists of 2(ğ‘‘âˆ’1)â„â€² XMSS trees. The public key of each\nXMSS key at layers 0 through ğ‘‘ âˆ’ 2 is signed by an XMSS key at the next higher layer. The XMSS\nkeys at layer 0 collectively have 2ğ‘‘â„â€² = 2â„ WOTS+ keys, which are used to sign the 2â„ FORS\npublic keys in the SLH-DSA key pair. The sequence of ğ‘‘ XMSS signatures needed to authenticate\na FORS public key when starting with the public key of the XMSS key at layer ğ‘‘ âˆ’1 is a hypertree\nsignature. An SLH-DSA signature consists of a FORS signature along with a hypertree signature.\nAn SLH-DSA public key (Figure 16) contains two ğ‘›-byte components: (1) PK.root, which is the\npublic key of the XMSS key at layer ğ‘‘ âˆ’1, and (2) PK.seed, which is used to provide domain\nseparation between different SLH-DSA key pairs. An SLH-DSA private key (Figure 15) consists of\nan ğ‘›-byte seed SK.seed that is used to pseudorandomly generate all of the secret values for the\nWOTS+ and FORS keys and an ğ‘›-byte key SK.prf that is used in the generation of the randomized\nhash of the message. An SLH-DSA private key also includes copies of PK.root and PK.seed, as\nthese values are needed during both signature generation and signature verification.\n2The WOTS+ and XMSS schemes that are used as components of SLH-DSA are not the same as the WOTS+ and\nXMSS schemes in RFC 8391 [11] and SP 800-208 [12].\n3For the parameter sets in this standard, an SLH-DSA key pair contains 263 , 264 , 266, or 268 FORS keys, which are\npseudorandomly generated from a single seed.\n4For the parameter sets in this standard, ğ‘‘ is 7, 8, 17, or 22.\n7\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nPK.root\nlayer ğ‘‘ âˆ’ 1 = 2\nWOTS+ signature\nlayer 1\nMerkle tree node\nWOTS+ signature\nWOTS+ public key\nFORS public key\nlayer 0\nWOTS+ signature\nFORS signature\nMessage\nFigure 1. An SLH-DSA signature\nThe WOTS+ one-time signature scheme is specified in Section 5, and the XMSS multi-time sig-\nnature scheme is specified in Section 6. Section 7 specifies the generation and verification of\nhypertree signatures. The FORS few-time signature scheme is specified in Section 8. Finally,\nSection 9 specifies the SLH-DSA key generation, signature, and verification functions. As the\nWOTS+ , XMSS, hypertree, and FORS schemes described in this standard are not intended for\nuse as stand-alone signature schemes, only the components of the schemes necessary to imple-\nment SLH-DSA are described. In particular, these sections do not include functions for key pair\ngeneration, and a signature verification function is only specified for hypertree signatures.\nWhen used in this standard, WOTS+ , XMSS, and FORS signatures are implicitly verified using\nfunctions to generate public keys from messages and signatures (see Sections 5.3, 6.3, and\n8.4). When verifying an SLH-DSA signature, the randomized hash of the message and the FORS\nsignature are used to compute a candidate FORS public key. The candidate FORS public key and\nthe WOTS+ signature from the layer 0 XMSS key are used to compute a candidate WOTS+ public\nkey, which is then used in conjunction with the corresponding authentication path to compute a\ncandidate XMSS public key. The candidate layer 0 XMSS public key is used along with the layer 1\n8\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nXMSS signature to compute a candidate layer 1 XMSS public key. This process is repeated until a\ncandidate layer ğ‘‘ âˆ’ 1 public key has been computed. SLH-DSA signature verification succeeds if\nthe computed candidate layer ğ‘‘ âˆ’1 XMSS public key is the same as the SLH-DSA public key root\nPK.root.\n3.1 Additional Requirements\nThis section specifies requirements for cryptographic modules that implement SLH-DSA. Sec-\ntion 3.2 discusses issues that implementers of cryptographic modules should take into considera-\ntion but that are not requirements. SP 800-89, Recommendation for Obtaining Assurances for\nDigital Signature Applications [3], specifies requirements that apply to the use of digital signature\nschemes.\nRandomness generation. SLH-DSA key generation (Algorithm 21) requires the generation of three\nrandom ğ‘›-byte values: PK.seed, SK.seed, and SK.prf, where ğ‘› is 16, 24, or 32, depending on\nthe parameter set. For each invocation of key generation, each of these values shall be a fresh\n(i.e., not previously used) random value generated using an approved random bit generator\n(RBG), as prescribed in SP 800-90A, SP 800-90B, and SP 800-90C [14, 15, 16]. Moreover, the RBG\nused shall have a security strength of at least 8ğ‘› bits. See Table 2 for the value of ğ‘› for each\nparameter set.\nDestruction of sensitive data. Data used internally by key generation and signing algorithms in\nintermediate computation steps could be used by an adversary to gain information about the\nprivate key and thereby compromise security. The data used internally by verification algorithms\nis similarly sensitive for some applications, including the verification of signatures that are used as\nbearer tokens (i.e., authentication secrets) or signatures on plaintext messages that are intended\nto be confidential. Intermediate values of the verification algorithm may reveal information\nabout its inputs (i.e., the message, signature, and public key), and in some applications, security\nor privacy requires one or more of these inputs to be confidential. Therefore, implementations of\nSLH-DSA shall ensure that any local copies of the inputs and any potentially sensitive intermediate\ndata are destroyed as soon as they are no longer needed.\nKey checks. SP 800-89 imposes requirements for the assurance of public-key validity and private-\nkey possession. In the case of SLH-DSA, where public-key validation is required, implementations\nshall verify that the public key is 2ğ‘› bytes in length. When the assurance of private key possession\nis obtained via regeneration, the owner of the private key shall check that the private key is 4ğ‘›\nbytes in length and shall use SK.seed and PK.seed to recompute PK.root and compare the\nnewly generated value with the value in the private key currently held.\nFloating-point arithmetic. Implementations of SLH-DSA shall not use floating-point arithmetic,\nas rounding errors in floating point operations may lead to incorrect results in some cases. In all\npseudocode in this standard in which division is performed (e.g., ğ‘¥/ğ‘¦) and ğ‘¦ may not divide ğ‘¥,\neither âŒŠğ‘¥/ğ‘¦âŒ‹ or âŒˆğ‘¥/ğ‘¦âŒ‰ is used. Both of these can be computed without floating-point arithmetic,\nas ordinary integer division ğ‘¥/ğ‘¦ computes âŒŠğ‘¥/ğ‘¦âŒ‹, and âŒˆğ‘¥/ğ‘¦âŒ‰ = âŒŠ(ğ‘¥+ğ‘¦âˆ’1)/ğ‘¦âŒ‹ for non-negative\nintegers ğ‘¥ and positive integers ğ‘¦.\n9\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nWhile the value of ğ‘™ğ‘’ğ‘› (see Equation 5.3) may be computed without using floating-point arith-\n2\nmetic (see Algorithm 1), it is recommended that this value be precomputed. For all parameter\nsets in this standard, ğ‘™ğ‘’ğ‘› is 3.\n2\nAlgorithm 1 gen_len (ğ‘›, ğ‘™ğ‘” )\n2 ğ‘¤\nComputes ğ‘™ğ‘’ğ‘› (Equation 5.3).\n2\nInput: Security parameter ğ‘›, bits per hash chain ğ‘™ğ‘” .\nğ‘¤\nOutput: ğ‘™ğ‘’ğ‘› .\n2\n1: ğ‘¤ â† 2ğ‘™ğ‘” ğ‘¤ â–· Equation 5.1\n2: ğ‘™ğ‘’ğ‘› â† âŒŠ8â‹…ğ‘›+ğ‘™ğ‘” ğ‘¤ âˆ’1 âŒ‹ â–· Equation 5.2\n1 ğ‘™ğ‘”\nğ‘¤\n3: ğ‘šğ‘ğ‘¥_ğ‘â„ğ‘’ğ‘ğ‘˜ğ‘ ğ‘¢ğ‘š = ğ‘™ğ‘’ğ‘› â‹… (ğ‘¤ âˆ’ 1) â–· maximum possible checksum value\n1\n4: ğ‘™ğ‘’ğ‘› â† 1 â–· maximum value that may be signed using\n2\n5: ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘–ğ‘¡ğ‘¦ â† ğ‘¤ â–· ğ‘™ğ‘’ğ‘› hash chains is ğ‘¤ğ‘™ğ‘’ğ‘› 2 âˆ’ 1 = ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘–ğ‘¡ğ‘¦ âˆ’ 1\n2\n6: while ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘–ğ‘¡ğ‘¦ â‰¤ ğ‘šğ‘ğ‘¥_ğ‘â„ğ‘’ğ‘ğ‘˜ğ‘ ğ‘¢ğ‘š do\n7: ğ‘™ğ‘’ğ‘› â† ğ‘™ğ‘’ğ‘› + 1\n2 2\n8: ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘–ğ‘¡ğ‘¦ â† ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘–ğ‘¡ğ‘¦ â‹… ğ‘¤\n9: end while\n10: return ğ‘™ğ‘’ğ‘›\n2\n3.2 Implementation Considerations\nThis section discusses some implementation considerations for SLH-DSA.\nDo not support component use. As WOTS+ , XMSS, FORS, and hypertree signature schemes are\nnot approved for use as stand-alone signature schemes, cryptographic modules should not make\ninterfaces to these components available to applications. SP 800-208 [12] specifies approved\nstateful hash-based signature schemes.\nSide-channel and fault attacks. For signature schemes, the secrecy of the private key is critical.\nCare must be taken to protect implementations against attacks, such as side-channel attacks\nor fault attacks [17, 18, 19, 20, 21]. A cryptographic device may leak critical information with\nside-channel analysis or attacks that allow internal data or keying material to be extracted without\nbreaking the cryptographic primitives.\n10",
    "question": "What is the structure and process of generating and verifying digital signatures in the SLH-DSA scheme?",
    "summary": "The FIPS 205 standard defines a stateless hash-based digital signature scheme called SLH-DSA, which uses components like FORS and XMSS. It outlines terms, acronyms, and mathematical symbols relevant to hash-based cryptography. The standard emphasizes the importance of randomness, security, and protection against side-channel and fault attacks to ensure the integrity and confidentiality of digital signatures."
  },
  {
    "start": 13,
    "end": 15,
    "text": "FIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n4. Functions and Addressing\n4.1 Hash Functions and Pseudorandom Functions\nThe specification of SLH-DSA makes use of six functions â€” PRF , H , PRF, T , H, and\nğ‘šğ‘ ğ‘” ğ‘šğ‘ ğ‘” â„“\nF â€” that are all implemented using hash functions or XOFs with fixed output lengths. The inputs\nand output of each function are byte strings. In the following definitions, ğ”¹ = {0,â€¦,255}\ndenotes the set of all bytes, ğ”¹ğ‘› denotes the set of byte strings of length ğ‘› bytes, and ğ”¹âˆ— denotes\nthe set of all byte strings. The ADRS input is described in Section 4.2.\nâ€¢ PRF (SK.prf, ğ‘œğ‘ğ‘¡_ğ‘Ÿğ‘ğ‘›ğ‘‘, ğ‘€) (ğ”¹ğ‘› Ã— ğ”¹ğ‘› Ã— ğ”¹âˆ— â†’ ğ”¹ğ‘›) is a pseudorandom function\nğ‘šğ‘ ğ‘”\n(PRF) that generates the randomizer (ğ‘…) for the randomized hashing of the message to be\nsigned.\nâ€¢ H (ğ‘…, PK.seed, PK.root, ğ‘€) (ğ”¹ğ‘› Ã— ğ”¹ğ‘› Ã— ğ”¹ğ‘› Ã— ğ”¹âˆ— â†’ ğ”¹ğ‘š) is used to generate the\nğ‘šğ‘ ğ‘”\ndigest of the message to be signed.\nâ€¢ PRF(PK.seed, SK.seed, ADRS) (ğ”¹ğ‘› Ã— ğ”¹ğ‘› Ã— ğ”¹32 â†’ ğ”¹ğ‘›) is a PRF that is used to\ngenerate the secret values in WOTS+ and FORS private keys.\nâ€¢ T (PK.seed, ADRS, ğ‘€ ) (ğ”¹ğ‘› Ã— ğ”¹32 Ã— ğ”¹â„“ğ‘› â†’ ğ”¹ğ‘›) is a hash function that maps an\nâ„“ â„“\nâ„“ğ‘›-byte message to an ğ‘›-byte message.\nâ€¢ H(PK.seed, ADRS, ğ‘€ ) (ğ”¹ğ‘› Ã— ğ”¹32 Ã— ğ”¹2ğ‘› â†’ ğ”¹ğ‘›) is a special case of T that takes a\n2 â„“\n2ğ‘›-byte message as input.\nâ€¢ F(PK.seed, ADRS, ğ‘€ ) (ğ”¹ğ‘› Ã— ğ”¹32 Ã— ğ”¹ğ‘› â†’ ğ”¹ğ‘›) is a hash function that takes an ğ‘›-byte\n1\nmessage as input and produces an ğ‘›-byte output.\nThe specific instantiations for these functions differ for different parameter sets and are specified\nin Section 11.\n4.2 Addresses\nFour of the functions described in Section 4.1 take a 32-byte address (i.e., ADRS) as input. An\nADRS consists of public values that indicate the position of the value being computed by the\nfunction. A different ADRS value is used for each call to each function. In the case of PRF,\nthis is used to generate a large number of different secret values from a single seed. In the case\nof T , H, and F, it is used to mitigate multi-target attacks. In the pseudocode, where addresses\nâ„“\nare passed as parameters, they may be passed either by reference or by value.\nThe structure of an ADRS conforms to word boundaries, with each word being 4 bytes long\nand values encoded as unsigned integers in big-endian byte order (see Figure 2). The first word\nof ADRS specifies the layer address, which is the height of an XMSS tree within the hypertree.\nTrees on the bottom layer have a height of zero, and the single XMSS tree at the top has a height\nof ğ‘‘ âˆ’1 (see Figure 1). The next three words of ADRS specify the tree address, which is the\nposition of an XMSS tree within a layer of the hypertree. The leftmost XMSS tree in a layer has a\ntree address of zero, and the rightmost XMSS tree in layer ğ¿ has a tree address of 2(ğ‘‘âˆ’1âˆ’ğ¿)â„â€² âˆ’ 1.\nThe next word is used to specify the type of the address, which differs depending on the use case.\n11\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nThere are seven different types of address used in SLH-DSA, as described below.5 The address\ntype determines how the final 12 bytes of the address are to be interpreted. The algorithms\nin this standard are written based on the assumption that whenever the type in an ADRS is\nchanged, the final 12 bytes of the address are initialized to zero.\nlayer address 4 bytes\ntree address 12 bytes\nğ‘¡ğ‘¦ğ‘ğ‘’ 4 bytes\n12 bytes\nFigure 2. Address (ADRS)\nThe type is set to WOTS_HASH (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 0) for a WOTS+ hash address (see Figure 3), which is\nused when computing hash chains in WOTS+ . When type is WOTS_HASH, the next word encodes\nthe key pair address, which is the index of the WOTS+ key pair within the XMSS tree specified\nby the layer and tree addresses, with the leftmost WOTS+ key having an index of zero and the\nrightmost WOTS+ key having an index of 2â„â€² âˆ’1. Next is the chain address, which encodes the\nindex of the chain within WOTS+ , followed by the hash address, which encodes the address of\nthe hash function within the chain.\nlayer address layer address\ntree address tree address\nğ‘¡ğ‘¦ğ‘ğ‘’ = 0 (WOTS_HASH) ğ‘¡ğ‘¦ğ‘ğ‘’ = 1 (WOTS_PK)\nkey pair address 4 bytes key pair address 4 bytes\nchain address 4 bytes\nğ‘ğ‘ğ‘‘ğ‘‘ğ‘–ğ‘›ğ‘” = 0 8 bytes\nhash address 4 bytes\nFigure 3. WOTS+ hash address Figure 4. WOTS+ public-key compression address\nThe type is set to WOTS_PK (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 1) when compressing WOTS+ public keys (see Figure 4).\nAs when the type is WOTS_HASH, the next word encodes the index of the WOTS+ key pair within\nthe XMSS tree specified by the layer and tree addresses. The remaining two words of ADRS\nare not needed and are set to zero.\nThe type is set to TREE (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 2) when computing the hashes within the XMSS tree (see\nFigure 5). For this type of address, the next word is always set to zero. The following word\n5The type word will have a value of 0, 1, 2, 3, 4, 5, or 6. In order to improve readability, these values will be\nreferred to in this standard by the constants WOTS_HASH, WOTS_PK, TREE, FORS_TREE, FORS_ROOTS, WOTS_PRF,\nand FORS_PRF, respectively.\n12\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nencodes the height of the node within the tree that is being computed, and the final word\nencodes the index of the node at that height.\nlayer address\ntree address\nğ‘¡ğ‘¦ğ‘ğ‘’ = 2 (TREE)\nğ‘ğ‘ğ‘‘ğ‘‘ğ‘–ğ‘›ğ‘” = 0 4 bytes\ntree height 4 bytes\ntree index 4 bytes\nFigure 5. Hash tree address\nThe type is set to FORS_TREE (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 3) when computing hashes within the FORS tree (see\nFigure 6). The next word is the key pair address, which encodes the FORS key that is used. The\nvalue is the same as the key pair address for the WOTS+ key used to sign the FORS key (see\nFigure 3 and Figure 4). The next two words â€” the tree height and tree index â€” encode the node\nwithin the FORS tree that is being computed. The tree height starts with zero for the leaf nodes.\nThe tree index is counted continuously across the ğ‘˜ different FORS trees. The leftmost node in\nthe leftmost tree has an index of zero, and the rightmost node in the rightmost tree at level ğ‘—\nhas an index of ğ‘˜ â‹… 2(ğ‘âˆ’ğ‘—) âˆ’ 1, where ğ‘ is the height of the tree.\nlayer address = 0 layer address = 0\ntree address tree address\nğ‘¡ğ‘¦ğ‘ğ‘’ = 3 (FORS_TREE) ğ‘¡ğ‘¦ğ‘ğ‘’ = 4 (FORS_ROOTS)\nkey pair address 4 bytes key pair address 4 bytes\ntree height 4 bytes\nğ‘ğ‘ğ‘‘ğ‘‘ğ‘–ğ‘›ğ‘” = 0 8 bytes\ntree index 4 bytes\nFigure 6. FORS tree address Figure 7. FORS tree roots compression address\nThe type is set to FORS_ROOTS (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 4) when compressing the ğ‘˜ FORS tree roots (see\nFigure 7). The next word is the key pair address, which has the same meaning as it does in the\nFORS_TREE address. The remaining two words of ADRS are not needed and are set to zero.\nThe type is set to WOTS_PRF (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 5) when generating secret values for WOTS+ keys (see\nFigure 8). The values for the other words in the address are set to the same values as for the\nWOTS_HASH address (Figure 3) used for the chain. The hash address is always set to zero.\n13\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nlayer address layer address = 0\ntree address tree address\nğ‘¡ğ‘¦ğ‘ğ‘’ = 5 (WOTS_PRF) ğ‘¡ğ‘¦ğ‘ğ‘’ = 6 (FORS_PRF)\nkey pair address 4 bytes key pair address 4 bytes\nchain address 4 bytes tree height = 0 4 bytes\nhash address = 0 4 bytes tree index 4 bytes\nFigure 8. WOTS+ key generation address Figure 9. FORS key generation address\nThe type is set to FORS_PRF (i.e., ğ‘¡ğ‘¦ğ‘ğ‘’ = 6) when generating secret values for FORS keys (see\nFigure 9). The values for the other words in the address are set to the same values as for the\nFORS_TREE address (Figure 6) used for the same leaf node.\n4.3 Member Functions\nThe algorithms in this standard make use of member functions. If a complex data structure\n(e.g., an ADRS) contains a component ğ‘‹, then ADRS.getX() returns the value of ğ‘‹, and\nADRS.setX(ğ‘Œ) sets the component ğ‘‹ in ADRS to the value held by ğ‘Œ. If a data structure ğ‘ \ncontains multiple instances of ğ‘‹, then ğ‘ .getX(ğ‘–) returns the value of the ğ‘–th instance of ğ‘‹ in ğ‘ .\nFor example, if ğ‘  is a FORS signature (Figure 14), then ğ‘ .getAUTH(ğ‘–) returns the authentication\npath for the ğ‘–th tree.\nWhenever the type in an address changes, the final 12 bytes of the address are initialized to zero.\nThe member function ADRS.setTypeAndClear(ğ‘Œ) for addresses sets the ğ‘¡ğ‘¦ğ‘ğ‘’ of the ADRS to\nğ‘Œ and sets the final 12 bytes of the ADRS to zero. 6\nTable 1 shows alternative notation for each of the member functions that operates on addresses.\nTable 1. Member functions for addresses\nMember function Expanded notation\nADRS.setLayerAddress(ğ‘™) ADRS â† toByte(ğ‘™, 4) âˆ¥ ADRS[4 âˆ¶ 32]\nADRS.setTreeAddress(ğ‘¡) ADRS â† ADRS[0 âˆ¶ 4] âˆ¥ toByte(ğ‘¡, 12) âˆ¥ ADRS[16 âˆ¶ 32]\nADRS.setTypeAndClear(ğ‘Œ) ADRS â† ADRS[0 âˆ¶ 16] âˆ¥ toByte(ğ‘Œ , 4) âˆ¥ toByte(0, 12)\nADRS.setKeyPairAddress(ğ‘–) ADRS â† ADRS[0 âˆ¶ 20] âˆ¥ toByte(ğ‘–, 4) âˆ¥ ADRS[24 âˆ¶ 32]\nADRS.setChainAddress(ğ‘–)\nADRS â† ADRS[0 âˆ¶ 24] âˆ¥ toByte(ğ‘–, 4) âˆ¥ ADRS[28 âˆ¶ 32]\nADRS.setTreeHeight(ğ‘–)\nADRS.setHashAddress(ğ‘–)\nADRS â† ADRS[0 âˆ¶ 28] âˆ¥ toByte(ğ‘–, 4)\nADRS.setTreeIndex(ğ‘–)\nğ‘– â† ADRS.getKeyPairAddress() ğ‘– â† toInt(ADRS[20 âˆ¶ 24], 4)\nğ‘– â† ADRS.getTreeIndex() ğ‘– â† toInt(ADRS[28 âˆ¶ 32], 4)\n6As noted in Section 4.2, the type (ğ‘Œ) is an integer. However, in the pseudocode, the constants WOTS_HASH, WOTS_PK,\nTREE, FORS_TREE, FORS_ROOTS, WOTS_PRF, and FORS_PRF are used in order to improve readability.\n14\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n4.4 Arrays, Byte Strings, and Integers\nIf ğ‘‹ is a byte string of length ğ‘›, then ğ‘‹[ğ‘–] for ğ‘– âˆˆ {0,â€¦,ğ‘›âˆ’1} will refer to the ğ‘–th element in\nthe string ğ‘‹. If ğ‘‹ is an array of ğ‘š ğ‘›-byte strings, then ğ‘‹[ğ‘–] for ğ‘– âˆˆ {0,â€¦,ğ‘šâˆ’1} will refer to\nthe ğ‘–th ğ‘›-byte string in ğ‘‹, and ğ‘‹ will refer to the ğ‘š â‹… ğ‘›-byte string ğ‘‹[0] âˆ¥ ğ‘‹[1] âˆ¥ â€¦ ğ‘‹[ğ‘š âˆ’ 1].\nA byte string may be interpreted as the big-endian representation of an integer. In such cases, a\nbyte string ğ‘‹ of length ğ‘› is converted to the integer\nğ‘‹[0] â‹… 256ğ‘›âˆ’1 + ğ‘‹[1] â‹… 256ğ‘›âˆ’2 + â€¦ ğ‘‹[ğ‘› âˆ’ 2] â‹… 256 + ğ‘‹[ğ‘› âˆ’ 1].\nSimilarly, an integer ğ‘¥ may be converted to a byte string of length ğ‘› by finding coefficients\nğ‘¥ , ğ‘¥ , â€¦ ğ‘¥ , ğ‘¥ âˆˆ {0, â€¦ , 255} such that\n0 1 ğ‘›âˆ’2 ğ‘›âˆ’1\nğ‘¥ = ğ‘¥ â‹… 256ğ‘›âˆ’1 + ğ‘¥ â‹… 256ğ‘›âˆ’2 + â€¦ ğ‘¥ â‹… 256 + ğ‘¥\n0 1 ğ‘›âˆ’2 ğ‘›âˆ’1\nand then setting the byte string to be ğ‘¥ ğ‘¥ â€¦ ğ‘¥ ğ‘¥ .\n0 1 ğ‘›âˆ’2 ğ‘›âˆ’1\nAlgorithm 2 is a function that converts a byte string ğ‘‹ of length ğ‘› to an integer, and Algorithm 3\nis a function that converts an integer ğ‘¥ to a byte string of length ğ‘›.\nAlgorithm 2 toInt(ğ‘‹, ğ‘›)\nConverts a byte string to an integer.\nInput: ğ‘›-byte string ğ‘‹.\nOutput: Integer value of ğ‘‹.\n1: ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† 0\n2: for ğ‘– from 0 to ğ‘› âˆ’ 1 do\n3: ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† 256 â‹… ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ + ğ‘‹[ğ‘–]\n4: end for\n5: return ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™\nAlgorithm 3 toByte(ğ‘¥, ğ‘›)\nConverts an integer to a byte string.\nInput: Integer ğ‘¥, string length ğ‘›.\nOutput: Byte string of length ğ‘› containing binary representation of ğ‘¥ in big-endian byte-order.\n1: ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† ğ‘¥\n2: for ğ‘– from 0 to ğ‘› âˆ’ 1 do\n3: ğ‘†[ğ‘› âˆ’ 1 âˆ’ ğ‘–] â† ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ mod 256 â–· least significant 8 bits of ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™\n4: ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â‰« 8\n5: end for\n6: return ğ‘†\n15\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nFor the WOTS+ and FORS schemes, the messages to be signed need to be split into a sequence\nof ğ‘-bit strings, where each ğ‘-bit string is interpreted as an integer between 0 and 2ğ‘ âˆ’1.7 This\nis the equivalent of creating the base-2ğ‘ representation of the message. The base_2b function\n(Algorithm 4) takes a byte string ğ‘‹, a bit string length ğ‘, and an output length ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘› as input\nand returns an array of base-2ğ‘ integers that represent the first ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘› â‹… ğ‘ bits of ğ‘‹ if the\nindividual bytes in ğ‘‹ are encoded as 8-bit strings in big-endian bit order. ğ‘‹ must be at least\nâŒˆğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘› â‹… ğ‘/8âŒ‰ bytes in length. As the value of ğ‘ğ‘–ğ‘¡ğ‘  will never exceed ğ‘ +7,a ğ‘ +7-bit unsigned\ninteger is sufficient to store ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ (i.e., ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ may be stored as a 32-bit unsigned integer).\nAlgorithm 4 base_2b(ğ‘‹, ğ‘, ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘›)\nComputes the base 2ğ‘ representation of ğ‘‹.\nInput: Byte string ğ‘‹ of length at least âŒˆğ‘œğ‘¢ğ‘¡_ ğ‘™ğ‘’ğ‘›â‹…ğ‘âŒ‰, integer ğ‘, output length ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘›.\n8\nOutput: Array of ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘› integers in the range [0,â€¦,2ğ‘ âˆ’1].\n1: ğ‘–ğ‘› â† 0\n2: ğ‘ğ‘–ğ‘¡ğ‘  â† 0\n3: ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† 0\n4: for ğ‘œğ‘¢ğ‘¡ from 0 to ğ‘œğ‘¢ğ‘¡_ğ‘™ğ‘’ğ‘› âˆ’ 1 do\n5: while ğ‘ğ‘–ğ‘¡ğ‘  < ğ‘ do\n6: ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â† (ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â‰ª 8) + ğ‘‹[ğ‘–ğ‘›]\n7: ğ‘–ğ‘› â† ğ‘–ğ‘›+1\n8: ğ‘ğ‘–ğ‘¡ğ‘  â† ğ‘ğ‘–ğ‘¡ğ‘  + 8\n9: end while\n10: ğ‘ğ‘–ğ‘¡ğ‘  â† ğ‘ğ‘–ğ‘¡ğ‘  âˆ’ ğ‘\n11: ğ‘ğ‘ğ‘ ğ‘’ğ‘[ğ‘œğ‘¢ğ‘¡] â† (ğ‘¡ğ‘œğ‘¡ğ‘ğ‘™ â‰« ğ‘ğ‘–ğ‘¡ğ‘ ) mod 2ğ‘\n12: end for\n13: return ğ‘ğ‘ğ‘ ğ‘’ğ‘\n7ğ‘ will be the value of ğ‘™ğ‘” when the base_2b function is used in WOTS +, and ğ‘ will be the value of ğ‘ when the\nğ‘¤\nbase_2b function is used in FORS. For the parameter sets in this standard, ğ‘™ğ‘” is 4, and ğ‘ is 6, 8, 9, 12, or 14.\nğ‘¤\n16",
    "question": "What are the different types of addresses used in the SLH-DSA standard and how do they determine the interpretation of the final 12 bytes of the address?",
    "summary": "The FIPS 205 standard defines six hash-based functions used in digital signatures, including PRF, H, T, and F, which are implemented with hash functions or XOFs. These functions use addresses (ADRS) to specify positions and prevent multi-target attacks. The ADRS is structured with layers, trees, and types, each determining how the final 12 bytes are interpreted for different cryptographic operations."
  },
  {
    "start": 16,
    "end": 18,
    "text": "FIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n5. Winternitz One-Time Signature Plus Scheme\nThis section describes the WOTS+ one-time signature scheme that is a component of SLH-DSA.\nWOTS+ uses two parameters. The security parameter ğ‘› is the length in bytes of the messages\nthat may be signed as well as the length of the private key elements, public key elements, and\nsignature elements. For the parameter sets specified in this standard, ğ‘› may be 16, 24, or 32\n(see Table 2). The second parameter ğ‘™ğ‘” indicates the number of bits that are encoded by each\nğ‘¤\nhash chain that is used.8 ğ‘™ğ‘” is 4 for all parameter sets in this standard. These parameters are\nğ‘¤\nused to compute four additional values:\nğ‘¤ = 2ğ‘™ğ‘” ğ‘¤ (5.1)\n8ğ‘›\nğ‘™ğ‘’ğ‘› = âŒˆ âŒ‰ (5.2)\n1 ğ‘™ğ‘”\nğ‘¤\nlog (ğ‘™ğ‘’ğ‘› â‹… (ğ‘¤ âˆ’ 1))\nğ‘™ğ‘’ğ‘› = âŒŠ 2 1 âŒ‹ + 1 (5.3)\n2 ğ‘™ğ‘”\nğ‘¤\nğ‘™ğ‘’ğ‘› = ğ‘™ğ‘’ğ‘› + ğ‘™ğ‘’ğ‘› (5.4)\n1 2\nWhen ğ‘™ğ‘” = 4, ğ‘¤ = 16, ğ‘™ğ‘’ğ‘› = 2ğ‘›, ğ‘™ğ‘’ğ‘› = 3, and ğ‘™ğ‘’ğ‘› = 2ğ‘› + 3.\nğ‘¤ 1 2\nA WOTS+ private key consists of ğ‘™ğ‘’ğ‘› secret values of length ğ‘›. In SLH-DSA, these are all generated\nfrom an ğ‘›-byte seed SK.seed using a PRF. Chains of length ğ‘¤ are then created from the secret\nvalues using a chaining function, and the end values from each of the chains are public values. The\nWOTS+ public key is computed as the hash of these public values. In order to create a signature,\nthe 8ğ‘›-bit message is first converted into an array of ğ‘™ğ‘’ğ‘› base-ğ‘¤ integers. A checksum is then\n1\ncomputed for this string, and the checksum is converted into an array of ğ‘™ğ‘’ğ‘› base-ğ‘¤ integers.\n2\nThe signature consists of the appropriate entries from the chains for each of the integers in the\nmessage and checksum arrays.\nThe WOTS+ functions make use of two helper functions: base_2b and chain. The base_2b function\n(Section 4.4) is used to break the message to be signed and the checksum value into arrays of\nbase-ğ‘¤ integers. The chain function (Algorithm 5) is used to compute the hash chains.\nThe chain function takes an ğ‘›-byte string ğ‘‹ and integers ğ‘  and ğ‘– (where ğ‘–+ğ‘  < ğ‘¤) as input and\nreturns the result of iterating a hash function F on the input ğ‘  times, starting from an index of\nğ‘–. 9 The chain function also requires as input PK.seed, which is part of the SLH-DSA public key,\nand an address ADRS. The type in ADRS must be set to WOTS_HASH, and the layer address,\ntree address, key pair address, and chain address must be set to the address of the chain being\ncomputed. The chain function updates the hash address in ADRS with each iteration to specify\nthe current position in the chain prior to ADRSâ€™s use in F.\n8In [10], the Winternitz parameter ğ‘¤ is used as the second WOTS+ parameter, where ğ‘¤ indicates the length of the\nhash chains that are used. This standard uses the parameter ğ‘™ğ‘” = log (ğ‘¤) to simplify notation.\nğ‘¤ 2\n9A start index of 0 indicates the beginning of the chain.\n17\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 5 chain(ğ‘‹, ğ‘–, ğ‘ , PK.seed, ADRS)\nChaining function used in WOTS+ .\nInput: Input string ğ‘‹, start index ğ‘–, number of steps ğ‘ , public seed PK.seed, address ADRS.\nOutput: Value of F iterated ğ‘  times on ğ‘‹.\n1: ğ‘¡ğ‘šğ‘ â† ğ‘‹\n2: for ğ‘— from ğ‘– to ğ‘– + ğ‘  âˆ’ 1 do\n3: ADRS.setHashAddress(ğ‘—)\n4: ğ‘¡ğ‘šğ‘ â† F(PK.seed, ADRS, ğ‘¡ğ‘šğ‘)\n5: end for\n6: return ğ‘¡ğ‘šğ‘\n5.1 WOTS\n+\nPublic-Key Generation\nThe wots_pkGen function (Algorithm 6) generates WOTS+ public keys. It takes SK.seed and\nPK.seed from the SLH-DSA private key and an address as input. The type in the address ADRS\nmust be set to WOTS_HASH, and the layer address, tree address, and key pair address must encode\nthe address of the WOTS+ public key to be generated.\nLines 4 through 9 in Algorithm 6 generate the public values, as described in Section 5. For each\nof the ğ‘™ğ‘’ğ‘› public values, the corresponding secret value is generated in lines 5 and 6, and the\nchain function is called to compute the end value of the chain of length ğ‘¤. Once the ğ‘™ğ‘’ğ‘› public\nvalues are computed, they are compressed into a single ğ‘›-byte value in lines 10 through 13.\nAlgorithm 6 wots_pkGen(SK.seed, PK.seed, ADRS)\nGenerates a WOTS+ public key.\nInput: Secret seed SK.seed, public seed PK.seed, address ADRS.\nOutput: WOTS+ public key ğ‘ğ‘˜.\n1: skADRS â† ADRS â–· copy address to create key generation key address\n2: skADRS.setTypeAndClear(WOTS_PRF)\n3: skADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n4: for ğ‘– from 0 to ğ‘™ğ‘’ğ‘› âˆ’ 1 do\n5: skADRS.setChainAddress(ğ‘–)\n6: ğ‘ ğ‘˜ â† PRF(PK.seed, SK.seed, skADRS) â–· compute secret value for chain ğ‘–\n7: ADRS.setChainAddress(ğ‘–)\n8: ğ‘¡ğ‘šğ‘[ğ‘–] â† chain(ğ‘ ğ‘˜, 0, ğ‘¤ âˆ’ 1, PK.seed, ADRS) â–· compute public value for chain ğ‘–\n9: end for\n10: wotspkADRS â† ADRS â–· copy address to create WOTS+public key address\n11: wotspkADRS.setTypeAndClear(WOTS_PK)\n12: wotspkADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n13: ğ‘ğ‘˜ â† T (PK.seed, wotspkADRS, ğ‘¡ğ‘šğ‘) â–· compress public key\nğ‘™ğ‘’ğ‘›\n14: return ğ‘ğ‘˜\n18\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n5.2 WOTS\n+\nSignature Generation\nA WOTS+ signature is an array of ğ‘™ğ‘’ğ‘› byte strings of length ğ‘›, as shown in Figure 10. The wots_sign\nfunction (Algorithm 7) generates the signature by converting the ğ‘›-byte message ğ‘€10 into an\narray of ğ‘™ğ‘’ğ‘› base-ğ‘¤ integers (line 2). A checksum is computed over ğ‘€ (lines 3 through 5). The\n1\nchecksum is converted to a byte string, which is then converted into an array of ğ‘™ğ‘’ğ‘› base-ğ‘¤\n2\nintegers (lines 6 and 7). The ğ‘™ğ‘’ğ‘› integers that represent the checksum are appended to the ğ‘™ğ‘’ğ‘›\n2 1\nintegers that represent the message (line 7).11 For each of the ğ‘™ğ‘’ğ‘› base-ğ‘¤ integers, the signature\nconsists of the corresponding node in one of the hash chains. For each of these integers, lines\n12 and 13 compute the secret value for the hash chain, and lines 14 and 15 compute the node in\nthe hash chain that corresponds to the integer. The selected nodes are concatenated to form\nthe WOTS+ signature.\nsig [0] ğ‘› bytes\nots\nâ‹¯\nsig [ğ‘™ğ‘’ğ‘› âˆ’ 1] ğ‘› bytes\nots\nFigure 10. WOTS+ signature data format\nIn addition to the ğ‘›-byte message to be signed, wots_sign takes SK.seed and PK.seed from\nthe SLH-DSA private key and an address as input. The type in the address ADRS must be set to\nWOTS_HASH, and the layer address, tree address, and key pair address must encode the address\nof the WOTS+ key that is used to sign the message.\n10In SLH-DSA, the message ğ‘€ that is signed using WOTS+ is either an XMSS public key or a FORS public key.\n11In the case that ğ‘™ğ‘” = 4, the ğ‘›-byte message is converted into an array of 2ğ‘› base-16 integers (i.e., hexadecimal\nğ‘¤\ndigits). The checksum is encoded as two bytes with the least significant four bits being zeros, and the most\nsignificant 12 bits are appended to the message as an array of three base-16 integers.\n19\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 7 wots_sign(ğ‘€, SK.seed, PK.seed, ADRS)\nGenerates a WOTS+ signature on an ğ‘›-byte message.\nInput: Message ğ‘€, secret seed SK.seed, public seed PK.seed, address ADRS.\nOutput: WOTS+ signature ğ‘ ğ‘–ğ‘”.\n1: ğ‘ğ‘ ğ‘¢ğ‘š â† 0\n2: ğ‘šğ‘ ğ‘” â† base_2b(ğ‘€,ğ‘™ğ‘” ,ğ‘™ğ‘’ğ‘› ) â–· convert message to base ğ‘¤\nğ‘¤ 1\n3: for ğ‘– from 0 to ğ‘™ğ‘’ğ‘› âˆ’ 1 do â–· compute checksum\n1\n4: ğ‘ğ‘ ğ‘¢ğ‘š â† ğ‘ğ‘ ğ‘¢ğ‘š + ğ‘¤ âˆ’ 1 âˆ’ ğ‘šğ‘ ğ‘”[ğ‘–]\n5: end for\n6: ğ‘ğ‘ ğ‘¢ğ‘š â† ğ‘ğ‘ ğ‘¢ğ‘š â‰ª ((8 âˆ’ ((ğ‘™ğ‘’ğ‘› â‹… ğ‘™ğ‘” ) mod 8)) mod 8) â–· for ğ‘™ğ‘” = 4, left shift by 4\n2 ğ‘¤ ğ‘¤\n7: ğ‘šğ‘ ğ‘” â† ğ‘šğ‘ ğ‘” âˆ¥ base_2b (toByte (ğ‘ğ‘ ğ‘¢ğ‘š, âŒˆğ‘™ğ‘’ğ‘› 2 â‹…ğ‘™ğ‘” ğ‘¤ âŒ‰) , ğ‘™ğ‘” , ğ‘™ğ‘’ğ‘› ) â–· convert to base ğ‘¤\n8 ğ‘¤ 2\n8: skADRS â† ADRS â–· copy address to create key generation key address\n9: skADRS.setTypeAndClear(WOTS_PRF)\n10: skADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n11: for ğ‘– from 0 to ğ‘™ğ‘’ğ‘› âˆ’ 1 do\n12: skADRS.setChainAddress(ğ‘–)\n13: ğ‘ ğ‘˜ â† PRF(PK.seed, SK.seed, skADRS) â–· compute chain ğ‘– secret value\n14: ADRS.setChainAddress(ğ‘–)\n15: ğ‘ ğ‘–ğ‘”[ğ‘–] â† chain(ğ‘ ğ‘˜, 0, ğ‘šğ‘ ğ‘”[ğ‘–], PK.seed, ADRS) â–· compute chain ğ‘– signature value\n16: end for\n17: return ğ‘ ğ‘–ğ‘”\n20",
    "question": "What are the parameters used in the WOTS+ one-time signature scheme and how are they utilized in generating the public key and signature?",
    "summary": "The WOTS+ one-time signature scheme is part of SLH-DSA and uses parameters ğ‘› and ğ‘™ğ‘” to generate keys and signatures. It creates hash chains from secret values and computes public keys by hashing the end values of these chains. To sign a message, it converts the message and checksum into base-ğ‘¤ integers and selects corresponding nodes from the hash chains to form the signature."
  }
]