[
  {
    "start": 1,
    "end": 4,
    "text": "FIPS 205\nFederal Information Processing Standards Publication\nStateless Hash-Based Digital Signature\nStandard\nCategory: Computer Security Subcategory: Cryptography\nInformation Technology Laboratory\nNational Institute of Standards and Technology\nGaithersburg, MD 20899-8900\nThis publication is available free of charge from:\nhttps://doi.org/10.6028/NIST.FIPS.205\nPublished: August 13, 2024\nU.S. Department of Commerce\nGina M. Raimondo, Secretary\nNational Institute of Standards and Technology\nLaurie E. Locascio, NIST Director and Under Secretary of Commerce for Standards and Technology\nForeword\nThe Federal Information Processing Standards Publication (FIPS) series of the National Institute of Standards\nand Technology (NIST) is the official series of publications relating to standards and guidelines developed\nunder 15 U.S.C. 278g-3, and issued by the Secretary of Commerce under 40 U.S.C. 11331.\nComments concerning this Federal Information Processing Standard publication are welcomed and should\nbe submitted using the contact information in the “Inquiries and comments” clause of the announcement\nsection.\nKevin M. Stine, Director\nInformation Technology Laboratory\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nAbstract\nThis standard specifies the stateless hash-based digital signature algorithm (SLH-DSA). Digital\nsignatures are used to detect unauthorized modifications to data and to authenticate the identity\nof the signatory. In addition, the recipient of signed data can use a digital signature as evidence in\ndemonstrating to a third party that the signature was, in fact, generated by the claimed signatory.\nThis is known as non-repudiation since the signatory cannot easily repudiate the signature at a\nlater time. SLH-DSA is based on SPHINCS+ , which was selected for standardization as part of the\nNIST Post-Quantum Cryptography Standardization process.\nKeywords: computer security; cryptography; digital signatures; Federal Information Processing\nStandards; hash-based signatures; post-quantum; public-key cryptography.\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nFederal Information Processing Standards Publication 205\nPublished: August 13, 2024\nEffective: August 13, 2024\nAnnouncing the\nStateless Hash-Based Digital Signature Standard\nFederal Information Processing Standards (FIPS) publications are developed by the National\nInstitute of Standards and Technology (NIST) under 15 U.S.C. 278g-3 and issued by the Secretary\nof Commerce under 40 U.S.C. 11331.\n1. Name of Standard. Stateless Hash-Based Digital Signature Standard (FIPS 205).\n2. Category of Standard. Computer Security. Subcategory. Cryptography.\n3. Explanation. This standard specifies a stateless hash-based digital signature scheme (SLH-\nDSA) for applications that require a digital signature rather than a written signature. Additional\ndigital signature schemes are specified and approved in other NIST Special Publications and\nFIPS publications (e.g., FIPS 186-5 [1]). A digital signature is represented in a computer as a\nstring of bits and computed using a set of rules and parameters that allow the identity of the\nsignatory and the integrity of the data to be verified. Digital signatures may be generated on\nboth stored and transmitted data.\nSignature generation uses a private key to generate a digital signature. Signature verification\nuses a public key that corresponds to but is not the same as the private key. Each signatory\npossesses a private and public key pair. Public keys may be known by the public, but private\nkeys must be kept secret. Anyone can verify the signature by employing the signatory’s public\nkey. Only the user who possesses the private key can perform signature generation.\nThe digital signature is provided to the intended verifier along with the signed data. The\nverifying entity verifies the signature by using the claimed signatory’s public key. Similar\nprocedures may be used to generate and verify signatures for both stored and transmitted\ndata.\nThis standard specifies several parameter sets for SLH-DSA that are approved for use. Addi-\ntional parameter sets may be specified and approved in future NIST Special Publications.\n4. Approving Authority. Secretary of Commerce.\n5. Maintenance Agency. Department of Commerce, National Institute of Standards and Tech-\nnology, Information Technology Laboratory (ITL).\n6. Applicability. This standard is applicable to all federal departments and agencies for the\nprotection of sensitive unclassified information that is not subject to section 2315 of Title 10,\nUnited States Code, or section 3502 (2) of Title 44, United States Code. Either this standard,\nFIPS 204, FIPS 186-5, or NIST Special Publication 800-208 shall be used in designing and\nimplementing public-key-based signature systems that federal departments and agencies op-\nerate or that are operated for them under contract. In the future, additional digital signature\ni\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nschemes may be specified and approved in FIPS publications or NIST Special Publications.\nThe adoption and use of this standard are available to private and commercial organizations.\n7. Applications. A digital signature algorithm allows an entity to authenticate the integrity of\nsigned data and the identity of the signatory. The recipient of a signed message can use a\ndigital signature as evidence in demonstrating to a third party that the signature was, in fact,\ngenerated by the claimed signatory. This is known as non-repudiation since the signatory\ncannot easily repudiate the signature at a later time. A digital signature algorithm is intended\nfor use in electronic mail, electronic funds transfer, electronic data interchange, software\ndistribution, data storage, and other applications that require data integrity assurance and\ndata origin authentication.\n8. Implementations. A digital signature algorithm may be implemented in software, firmware,\nhardware, or any combination thereof. NIST will develop a validation program to test imple-\nmentations for conformance to the algorithms in this standard. For every computational\nprocedure that is specified in this standard, a conforming implementation may replace the\ngiven set of steps with any mathematically equivalent process. In other words, different\nprocedures that produce the correct output for every input are permitted. Information about\nvalidation programs is available at https://csrc.nist.gov/projects/cmvp. Examples for digital\nsignature algorithms are available at https://csrc.nist.gov/projects/cryptographic-standards-\nand-guidelines/example-values.\nAgencies are advised that digital signature key pairs shall not be used for other purposes.\n9. Other Approved Security Functions. Digital signature implementations that comply with this\nstandard shall employ cryptographic algorithms that have been approved for protecting Fed-\neral Government-sensitive information. Approved cryptographic algorithms and techniques\ninclude those that are either:\na. Specified in a Federal Information Processing Standard (FIPS) publication,\nb. Adopted in a FIPS or NIST recommendation, or\nc. Specified in the list of approved security functions in SP 800-140C.\n10. Export Control. Certain cryptographic devices and technical data regarding them are subject\nto federal export controls. Exports of cryptographic modules that implement this standard\nand technical data regarding them must comply with these federal regulations and be licensed\nby the Bureau of Industry and Security of the U.S. Department of Commerce. Information\nabout export regulations is available at https://www.bis.doc.gov.\n11. Patents. The algorithm in this standard may be covered by U.S. or foreign patents.\n12. Implementation Schedule. This standard becomes effective immediately upon final publica-\ntion.\n13. Specifications. Federal Information Processing Standard (FIPS) 205, Stateless Hash-Based\nDigital Signature Standard (affixed).\nii\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n14. Qualifications. The security of a digital signature system depends on the secrecy of the\nsignatory’s private keys. Signatories shall, therefore, guard against the disclosure of their\nprivate keys. While it is the intent of this standard to specify general security requirements for\ngenerating digital signatures, conformance to this standard does not ensure that a particular\nimplementation is secure. It is the responsibility of an implementer to ensure that any module\nthat implements a digital signature capability is designed and built in a secure manner.\nSimilarly, the use of a product containing an implementation that conforms to this standard\ndoes not guarantee the security of the overall system in which the product is used. The re-\nsponsible authority in each agency or department shall ensure that an overall implementation\nprovides an acceptable level of security.\nSince a standard of this nature must be flexible enough to adapt to advancements and\ninnovations in science and technology, this standard will be reviewed every five years in order\nto assess its adequacy.\n15. Waiver Procedure. The Federal Information Security Management Act (FISMA) does not\nallow for waivers to Federal Information Processing Standards (FIPS) that are made mandatory\nby the Secretary of Commerce.\n16. Where to Obtain Copies of the Standard. This publication is available by accessing https:\n//csrc.nist.gov/publications. Other computer security publications are available at the same\nwebsite.\n17. How to Cite This Publication. NIST has assigned NIST FIPS 205 as the publication identifier\nfor this FIPS, per the NIST Technical Series Publication Identifier Syntax. NIST recommends\nthat it be cited as follows:\nNational Institute of Standards and Technology (2024) Stateless Hash-Based Dig-\nital Signature Standard. (Department of Commerce, Washington, D.C.), Fed-\neral Information Processing Standards Publication (FIPS) NIST FIPS 205. https:\n//doi.org/10.6028/NIST.FIPS.205\n18. Inquiries and Comments. Inquiries and comments about this FIPS may be submitted to\nfips-205-comments@nist.gov.\niii\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nFederal Information Processing Standards Publication 205\nSpecification for the\nStateless Hash-Based Digital Signature Standard\nTable of Contents\n1 Introduction 1\n1.1 Purpose and Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1\n1.2 Context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1\n2 Glossary of Terms, Acronyms, and Symbols 2\n2.1 Terms and Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n2.2 Acronyms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n2.3 Mathematical Symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n3 Overview of the SLH-DSA Signature Scheme 7\n3.1 Additional Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n3.2 Implementation Considerations . . . . . . . . . . . . . . . . . . . . . . . . . 10\n4 Functions and Addressing 11\n4.1 Hash Functions and Pseudorandom Functions . . . . . . . . . . . . . . . . . 11\n4.2 Addresses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n4.3 Member Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n4.4 Arrays, Byte Strings, and Integers . . . . . . . . . . . . . . . . . . . . . . . . 15\n5 Winternitz One-Time Signature Plus Scheme 17\n5.1 WOTS+ Public-Key Generation . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n5.2 WOTS+ Signature Generation . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n5.3 Computing a WOTS+ Public Key From a Signature . . . . . . . . . . . . . . . 21\n6 eXtended Merkle Signature Scheme (XMSS) 22\n6.1 Generating a Merkle Hash Tree . . . . . . . . . . . . . . . . . . . . . . . . . 22\n6.2 Generating an XMSS Signature . . . . . . . . . . . . . . . . . . . . . . . . . . 23\n6.3 Computing an XMSS Public Key From a Signature . . . . . . . . . . . . . . . . 25\n7 The SLH-DSA Hypertree 26\niv\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n7.1 Hypertree Signature Generation . . . . . . . . . . . . . . . . . . . . . . . . . 26\n7.2 Hypertree Signature Verification . . . . . . . . . . . . . . . . . . . . . . . . . 28\n8 Forest of Random Subsets (FORS) 29\n8.1 Generating FORS Secret Values . . . . . . . . . . . . . . . . . . . . . . . . . . 29\n8.2 Generating a Merkle Hash Tree . . . . . . . . . . . . . . . . . . . . . . . . . 30\n8.3 Generating a FORS Signature . . . . . . . . . . . . . . . . . . . . . . . . . . . 30\n8.4 Computing a FORS Public Key From a Signature . . . . . . . . . . . . . . . . . 31\n9 SLH-DSA Internal Functions 33\n9.1 SLH-DSA Key Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\n9.2 SLH-DSA Signature Generation . . . . . . . . . . . . . . . . . . . . . . . . . . 34\n9.3 SLH-DSA Signature Verification . . . . . . . . . . . . . . . . . . . . . . . . . . 36\n10 SLH-DSA External Functions 37\n10.1 SLH-DSA Key Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n10.2 SLH-DSA Signature Generation . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n10.2.1 Pure SLH-DSASignature Generation . . . . . . . . . . . . . . . . . . . 38\n10.2.2 HashSLH-DSASignature Generation . . . . . . . . . . . . . . . . . . . 39\n10.3 SLH-DSA Signature Verification . . . . . . . . . . . . . . . . . . . . . . . . . . 41\n11 Parameter Sets 43\n11.1 SLH-DSA Using SHAKE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44\n11.2 SLH-DSA Using SHA2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44\n11.2.1 SLH-DSAUsingSHA2for SecurityCategory1 . . . . . . . . . . . . . . . 45\n11.2.2 SLH-DSA Using SHA2 for Security Categories 3 and 5 . . . . . . . . . . 46\nReferences 47\nAppendix A — Differences From the SPHINCS+ Submission 51\nA.1 Changes From FIPS 205 Initial Public Draft . . . . . . . . . . . . . . . . . . . . 51\nv",
    "question": "What is the purpose and key concept of the FIPS 205 standard?",
    "summary": "FIPS 205 is a U.S. federal standard for a stateless hash-based digital signature algorithm called SLH-DSA. It is designed to provide secure digital signatures that authenticate data integrity and identity, and are resistant to quantum computing threats. The standard is part of NIST's post-quantum cryptography efforts and is applicable to federal agencies for protecting sensitive unclassified information."
  },
  {
    "start": 5,
    "end": 6,
    "text": "FIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nList of Tables\nTable1 Memberfunctionsfor addresses . . . . . . . . . . . . . . . . . . . . . . 14\nTable2 SLH-DSAparameter sets . . . . . . . . . . . . . . . . . . . . . . . . . . 43\nTable 3 Member functions for compressed addresses . . . . . . . . . . . . . . . 45\nList of Figures\nFigure 1 AnSLH-DSAsignature . . . . . . . . . . . . . . . . . . . . . . . . . . . 8\nFigure 2 Address (ADRS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\nFigure 3 WOTS+ hashaddress . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\nFigure 4 WOTS+ public-key compressionaddress . . . . . . . . . . . . . . . . . 12\nFigure 5 Hashtree address . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\nFigure 6 FORStree address . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\nFigure 7 FORStree roots compressionaddress . . . . . . . . . . . . . . . . . . . 13\nFigure 8 WOTS+ keygenerationaddress . . . . . . . . . . . . . . . . . . . . . . 14\nFigure 9 FORSkeygenerationaddress . . . . . . . . . . . . . . . . . . . . . . . 14\nFigure 10 WOTS+ signature data format . . . . . . . . . . . . . . . . . . . . . . . 19\nFigure 11 XMSSsignature data format . . . . . . . . . . . . . . . . . . . . . . . . 22\nFigure 12 Merklehash tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\nFigure 13 HTsignature data format . . . . . . . . . . . . . . . . . . . . . . . . . 26\nFigure 14 FORSsignature data format . . . . . . . . . . . . . . . . . . . . . . . . 29\nFigure 15 SLH-DSAprivate key . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\nFigure 16 SLH-DSApublickey . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\nFigure 17 SLH-DSAsignature data format . . . . . . . . . . . . . . . . . . . . . . 34\nFigure 18 Compressed address (ADRS 𝑐 ) . . . . . . . . . . . . . . . . . . . . . . 45\nList of Algorithms\nAlgorithm 1 gen_len (𝑛, 𝑙𝑔 ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n2 𝑤\nAlgorithm 2 toInt(𝑋, 𝑛) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\nAlgorithm 3 toByte(𝑥, 𝑛) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\nAlgorithm 4 base_2b(𝑋, 𝑏, 𝑜𝑢𝑡_𝑙𝑒𝑛) . . . . . . . . . . . . . . . . . . . . . . . . 16\nAlgorithm 5 chain(𝑋, 𝑖, 𝑠, PK.seed, ADRS) . . . . . . . . . . . . . . . . . . . 18\nAlgorithm 6 wots_pkGen(SK.seed, PK.seed, ADRS) . . . . . . . . . . . . . . 18\nAlgorithm 7 wots_sign(𝑀, SK.seed, PK.seed, ADRS) . . . . . . . . . . . . . 20\nAlgorithm 8 wots_pkFromSig(𝑠𝑖𝑔, 𝑀, PK.seed, ADRS) . . . . . . . . . . . . . 21\nAlgorithm 9 xmss_node(SK.seed, 𝑖, 𝑧, PK.seed, ADRS) . . . . . . . . . . . . 23\nAlgorithm 10 xmss_sign(𝑀, SK.seed, 𝑖𝑑𝑥, PK.seed, ADRS) . . . . . . . . . . . 24\nAlgorithm 11 xmss_pkFromSig(𝑖𝑑𝑥, SIG , 𝑀, PK.seed, ADRS) . . . . . . . 25\n𝑋𝑀𝑆𝑆\nAlgorithm 12 ht_sign(𝑀, SK.seed, PK.seed, 𝑖𝑑𝑥 , 𝑖𝑑𝑥 ) . . . . . . . . . . 27\n𝑡𝑟𝑒𝑒 𝑙𝑒𝑎𝑓\nAlgorithm 13 ht_verify(𝑀, SIG , PK.seed, 𝑖𝑑𝑥 , 𝑖𝑑𝑥 , PK.root) . . . . . . 28\n𝐻𝑇 𝑡𝑟𝑒𝑒 𝑙𝑒𝑎𝑓\nAlgorithm 14 fors_skGen(SK.seed, PK.seed, ADRS, 𝑖𝑑𝑥) . . . . . . . . . . . . 29\nvi\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 15 fors_node(SK.seed, 𝑖, 𝑧, PK.seed, ADRS) . . . . . . . . . . . . . 30\nAlgorithm 16 fors_sign(𝑚𝑑, SK.seed, PK.seed, ADRS) . . . . . . . . . . . . . 31\nAlgorithm 17 fors_pkFromSig(SIG , 𝑚𝑑, PK.seed, ADRS) . . . . . . . . . . 32\n𝐹 𝑂𝑅𝑆\nAlgorithm 18 slh_keygen_internal(SK.seed, SK.prf, PK.seed) . . . . . . . . . . 34\nAlgorithm 19 slh_sign_internal(𝑀, SK, 𝑎𝑑𝑑𝑟𝑛𝑑) . . . . . . . . . . . . . . . . . . . 35\nAlgorithm 20 slh_verify_internal(𝑀,SIG,PK) . . . . . . . . . . . . . . . . . . . . 36\nAlgorithm 21 slh_keygen() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\nAlgorithm 22 slh_sign(𝑀, 𝑐𝑡𝑥,SK) . . . . . . . . . . . . . . . . . . . . . . . . . . 39\nAlgorithm 23 hash_slh_sign(𝑀, 𝑐𝑡𝑥,PH,SK) . . . . . . . . . . . . . . . . . . . . . 40\nAlgorithm 24 slh_verify(𝑀, SIG, 𝑐𝑡𝑥,PK) . . . . . . . . . . . . . . . . . . . . . . . 41\nAlgorithm 25 hash_slh_verify(𝑀, SIG, 𝑐𝑡𝑥,PH,PK) . . . . . . . . . . . . . . . . . 42\nvii\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n1. Introduction\n1.1 Purpose and Scope\nThis standard defines a method for digital signature generation that can be used for the protection\nof binary data (commonly called a message) and for the verification and validation of those digital\nsignatures.1 The security of the stateless hash-based digital signature algorithm (SLH-DSA) relies\non the presumed difficulty of finding preimages for hash functions as well as several related\nproperties of the same hash functions. Unlike the algorithms specified in FIPS 186-5 [1], SLH-DSA\nis designed to provide resistance against attacks from a large-scale quantum computer.\nThis standard specifies the mathematical steps that need to be performed for key generation,\nsignature generation, and signature verification. Additional assurances are required for digital\nsignatures to be valid (e.g., the assurance of identity and private key possession). SP 800-89,\nRecommendation for Obtaining Assurances for Digital Signature Applications [3], specifies the\nrequired assurances and the methods for obtaining these assurances.\n1.2 Context\nOver the past several years, there has been steady progress toward building quantum computers.\nThe security of many commonly used public-key cryptosystems will be at risk if large-scale\nquantum computers are ever realized. This would include key-establishment schemes and digital\nsignatures that are based on integer factorization and discrete logarithms (both over finite fields\nand elliptic curves). As a result, in 2016, NIST initiated a public Post-Quantum Cryptography\n(PQC) Standardization process to select quantum-resistant public-key cryptographic algorithms\nfor standardization. A total of 82 candidate algorithms were submitted to NIST for consideration.\nAfter three rounds of evaluation and analysis, NIST selected the first four algorithms for stan-\ndardization. These algorithms are intended to protect sensitive U.S. Government information\nwell into the foreseeable future, including after the advent of cryptographically relevant quan-\ntum computers. This standard includes the specification for one of the algorithms selected:\nSPHINCS+ , a stateless hash-based digital signature scheme. This standard contains several minor\nmodifications compared to Version 3 [4], which was submitted at the beginning of round three\nof the NIST PQC Standardization process. The changes are described in Appendix A. Throughout\nthis standard, SPHINCS+ will be referred to as SLH-DSA for stateless hash-based digital signature\nalgorithm.\n1NIST Special Publication (SP) 800-175B [2], Guideline for Using Cryptographic Standards in the Federal Government:\nCryptographic Mechanisms, includes a general discussion of digital signatures.\n1",
    "question": "What is the purpose of the FIPS 205 standard and how does it address the security concerns related to quantum computing?",
    "summary": "The FIPS 205 standard outlines a stateless hash-based digital signature method called SLH-DSA, which is designed to be quantum-resistant. It details the mathematical steps for key generation, signature creation, and verification. The standard specifies SPHINCS+ as the algorithm, which includes minor modifications from its previous version."
  },
  {
    "start": 7,
    "end": 12,
    "text": "FIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n2. Glossary of Terms, Acronyms, and Symbols\n2.1 Terms and Definitions\napproved FIPS-approved and/or NIST-recommended. An algorithm or tech-\nnique that is either 1) specified in a FIPS or NIST recommendation, 2)\nadopted in a FIPS or NIST recommendation, or 3) specified in a list of\nNIST-approved security functions. [1]\nbig-endian The property of a byte string having its bytes positioned in order of\ndecreasing significance. In particular, the leftmost (first) byte is the\nmost significant, and the rightmost (last) byte is the least significant.\nThe term “big-endian” may also be applied in the same manner to bit\nstrings. [5, adapted]\nbyte string An array of integers in which each integer is in the set {0, … , 255}.\nclaimed signatory From the verifier’s perspective, the claimed signatory is the entity that\npurportedly generated a digital signature. [1]\ndestroy An action applied to a key or a piece of secret data. After a key or a\npiece of secret data is destroyed, no information about its value can\nbe recovered. [1]\ndigital signature The result of a cryptographic transformation of data that, when prop-\nerly implemented, provides a mechanism for verifying origin authenti-\ncation, data integrity, and signatory non-repudiation. [1]\nentity An individual (person), organization, device, or process. Used inter-\nchangeably with party. [1]\nequivalent process Two processes are equivalent if the same output is produced when\nthe same values are input to each process (either as input parameters,\nas values made available during the process, or both). [1]\nextendable-output A function on bit strings in which the output can be extended to any\nfunction desired length. Approved XOFs (such as those specified in FIPS 202 [6])\nare designed to satisfy the following properties as long as the specified\noutput length is sufficiently long to prevent trivial attacks:\n1. (One-way) It is computationally infeasible to find any input that\nmaps to any new pre-specified output.\n2. (Collision-resistant) It is computationally infeasible to find any\ntwo distinct inputs that map to the same output. [7, adapted]\nfresh random value A previously unused output of a random bit generator.\nhash function A function on bit strings in which the length of the output is fixed.\nApproved hash functions (such as those specified in FIPS 180 [8] and\nFIPS 202 [6]) are designed to satisfy the following properties:\n2\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n1. (One-way) It is computationally infeasible to find any input that\nmaps to any new pre-specified output\n2. (Collision-resistant) It is computationally infeasible to find any\ntwo distinct inputs that map to the same output. [1]\nhash value See message digest.\nkey A parameter used in conjunction with a cryptographic algorithm that\ndetermines its operation. Examples applicable to this standard include:\n1. The computation of a digital signature from data, and\n2. The verification of a digital signature. [1]\nkey pair A public key and its corresponding private key. [1]\nmessage The data that is signed. Also known as signed data during the signature\nverification and validation process. [1]\nmessage digest The result of applying a hash function to a message. Also known as a\nhash value. [1]\nnon-repudiation A service that is used to provide assurance of the integrity and origin\nof data in such a way that the integrity and origin can be verified and\nvalidated by a third party as having originated from a specific entity in\npossession of the private key (i.e., the signatory). [1]\nowner A key pair owner is the entity authorized to use the private key of a\nkey pair. [1]\nparty An individual (person), organization, device, or process. Used inter-\nchangeably with entity. [1]\nprivate key A cryptographic key that is used with an asymmetric (public-key) cryp-\ntographic algorithm. The private key is uniquely associated with the\nowner and is not made public. The private key is used to compute a\ndigital signature that may be verified using the corresponding public\nkey. [1]\npseudorandom A process or data produced by a process is said to be pseudorandom\nwhen the outcome is deterministic yet also effectively random as long\nas the internal action of the process is hidden from observation. For\ncryptographic purposes, “effectively random” means “computation-\nally indistinguishable from random within the limits of the intended\nsecurity strength.” [1]\npublic key A cryptographic key that is used with an asymmetric (public-key) cryp-\ntographic algorithm and is associated with a private key. The public\nkey is associated with an owner and may be made public. In the case\nof digital signatures, the public key is used to verify a digital signature\nthat was generated using the corresponding private key. [1]\n3\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nsecurity category A number associated with the security strength of a post-quantum\ncryptographic algorithm, as specified by NIST (see [9, Sect. 5.6]).\nsecurity strength A number associated with the amount of work (i.e., the number of\noperations) that is required to break a cryptographic algorithm or\nsystem. [1]\nshall Used to indicate a requirement of this standard. [1]\nshould Used to indicate a strong recommendation but not a requirement of\nthis standard. Ignoring the recommendation could result in undesir-\nable results. [1]\nsignatory The entity that generates a digital signature on data using a private\nkey. [1]\nsignature generation The process of using a digital signature algorithm and a private key to\ngenerate a digital signature on data. [1]\nsignature validation The (mathematical) verification of the digital signature and obtain-\ning the appropriate assurances (e.g., public-key validity, private-key\npossession, etc.). [1]\nsignature verification The process of using a digital signature algorithm and a public key to\nverify a digital signature on data. [1]\nsigned data The data or message upon which a digital signature has been computed.\nAlso see message. [1]\nverifier The entity that verifies the authenticity of a digital signature using the\npublic key. [1]\n2.2 Acronyms\nADRS Address\nADRSc Compressed Address\nAES Advanced Encryption Standard\nDER Distinguished Encoding Rules\nFIPS Federal Information Processing Standard\nFORS Forest of Random Subsets\nITL Information Technology Laboratory\nMGF Mask Generation Function\nNIST National Institute of Standards and Technology\nOID Object Identifier\nPQC Post-Quantum Cryptography\nPRF Pseudorandom Function\n4\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nSHA Secure Hash Algorithm\nSHAKE Secure Hash Algorithm KECCAK\nSP Special Publication\nRFC Request for Comments\nWOTS+ Winternitz One-Time Signature Plus\nXMSS eXtended Merkle Signature Scheme\nXOF eXtendable-Output Function\n2.3 Mathematical Symbols\n𝑋 ∥ 𝑌 The concatenation of two arrays 𝑋 and 𝑌. If 𝑋 is an array of length ℓ ,\n𝑥\nand 𝑌 is an array of length ℓ , then 𝑍 = 𝑋 ∥ 𝑌 is an array of length\n𝑦\nℓ + ℓ such that\n𝑥 𝑦\n𝑋[𝑖] if 0 ≤ 𝑖 < ℓ\n𝑍[𝑖] = { 𝑥\n𝑌 [𝑖 − ℓ ] if ℓ ≤ 𝑖 < ℓ +ℓ .\n𝑥 𝑥 𝑥 𝑦\n𝑋[𝑖 ∶ 𝑗] A subarray of 𝑋. If 𝑋 is an array of length ℓ , 0 ≤ 𝑖 < 𝑗 ≤ ℓ , and\n𝑥 𝑥\n𝑌 = 𝑋[𝑖 ∶ 𝑗], then 𝑌 is an array of length 𝑗 − 𝑖 such that 𝑌 [𝑘] =\n𝑋[𝑖 + 𝑘] for 0 ≤ 𝑘 < 𝑗 −𝑖.\nTrunc (𝑋) A truncation function that outputs the leftmost ℓ bytes of the input\nℓ\nbyte string 𝑋. If 𝑌 = Trunc (𝑋), then 𝑌 is a byte string (array) of\nℓ\nlength ℓ such that 𝑌 [𝑖] = 𝑋[𝑖] for 0 ≤ 𝑖 < ℓ (i.e., 𝑌 = 𝑋[0 ∶ ℓ]).\n|𝑋| The length (in bytes) of byte string 𝑋.\n⌈𝑎⌉ The ceiling of 𝑎; the smallest integer that is greater than or equal to 𝑎.\nFor example, ⌈5⌉ = 5, ⌈5.3⌉ = 6, and ⌈−2.1⌉ = −2. [1]\n⌊𝑎⌋ The floor of 𝑎; the largest integer that is less than or equal to 𝑎. For\nexample, ⌊5⌋ = 5, ⌊5.3⌋ = 5, and ⌊−2.1⌋ = −3. [1]\n𝑎 mod 𝑛 The unique remainder 𝑟, 0 ≤ 𝑟 ≤ (𝑛−1), when integer 𝑎 is divided\nby the positive integer 𝑛. For example, 23 mod 7 = 2. [1]\n𝑎 ⋅ 𝑏 The product of 𝑎 and 𝑏. For example, 3⋅5 = 15.\n𝑎𝑏 𝑎 raised to the power 𝑏. For example, 25 = 32.\nlog 𝑥 The base 2 logarithm of 𝑥. For example, log (16) = 4.\n2 2\n0b The prefix to a number that is represented in binary.\n0x The prefix to a number that is represented in hexadecimal. [1, adapted]\n𝑎 ≫ 𝑏 The logical right shift of 𝑎 by 𝑏 positions (i.e., 𝑎 ≫ 𝑏 = ⌊𝑎/2𝑏⌋). For\nexample, 0x73 ≫ 4 = 7. [10, adapted]\n5\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n𝑎 ≪ 𝑏 The logical left shift of 𝑎 by 𝑏 positions (i.e., 𝑎 ≪ 𝑏 = 𝑎 ⋅ 2𝑏). For\nexample, 0x73 ≪ 4 = 0x730. [10, adapted]\n𝑎 ⊕ 𝑏 The bitwise exclusive-or of 𝑎 and 𝑏. For example, 115 ⊕ 1 = 114\n(115 ⊕ 1 = 0b01110011 ⊕ 0b00000001 = 0b01110010 = 114).\n𝑠 ← 𝑥 In pseudocode, this notation means that the variable 𝑠 is set to the\nvalue of the expression 𝑥.\n𝑠 ← $ − 𝔹𝑛 In pseudocode, this notation means that the variable 𝑠 is set to a\nbyte string of length 𝑛 chosen at random. A fresh random value is\ngenerated for each time this step is performed.\n⊥ A symbol indicating failure or the lack of output from an algorithm.\n6\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n3. Overview of the SLH-DSA Signature Scheme\nSLH-DSA is a stateless hash-based signature scheme that is constructed using other hash-based\nsignature schemes as components: (1) a few-time signature scheme, forest of random subsets\n(FORS), and (2) a multi-time signature scheme, the eXtended Merkle Signature Scheme (XMSS).\nXMSS is constructed using the hash-based one-time signature scheme Winternitz One-Time\nSignature Plus (WOTS+) as a component.2\nConceptually, an SLH-DSA key pair consists of a very large set of FORS key pairs.3 The few-time\nsignature scheme FORS allows each key pair to safely sign a small number of messages. An\nSLH-DSA signature is created by computing a randomized hash of the message, using part of the\nresulting message digest to pseudorandomly select a FORS key, and signing the remaining part of\nthe message digest with that key. An SLH-DSA signature consists of the FORS signature and the\ninformation that authenticates the FORS public key. The authentication information is created\nusing XMSS signatures.\nXMSS is a multi-time signature scheme that is created using a combination of WOTS+ one-time\nsignatures and Merkle hash trees [13]. An XMSS key consists of 2ℎ′ WOTS+ keys and can sign\n2ℎ′ messages. The WOTS+ public keys are formed into a Merkle hash tree, and the root of the\ntree is the XMSS public key. (The Merkle hash tree formed from the WOTS+ keys is also referred\nto as an XMSS tree.) An XMSS signature consists of a WOTS+ signature and an authentication\npath within the Merkle hash tree for the WOTS+ public key. In Figure 1, triangles represent\nXMSS trees, squares represent the WOTS+ public keys, and circles represent the interior nodes\nof the hash tree. Within an XMSS tree, the square and circles that are filled in represent the\nauthentication path for the WOTS+ public key needed to verify the signature.\nThe authentication information for a FORS public key is a hypertree signature. A hypertree is a\ntree of XMSS trees, as depicted in Figure 1. The tree consists of 𝑑 layers4 in which the top layer\n(layer 𝑑 − 1) consists of a single XMSS tree, the next layer down (layer 𝑑 − 2) consists of 2ℎ′\nXMSS trees, and the lowest layer (layer 0) consists of 2(𝑑−1)ℎ′ XMSS trees. The public key of each\nXMSS key at layers 0 through 𝑑 − 2 is signed by an XMSS key at the next higher layer. The XMSS\nkeys at layer 0 collectively have 2𝑑ℎ′ = 2ℎ WOTS+ keys, which are used to sign the 2ℎ FORS\npublic keys in the SLH-DSA key pair. The sequence of 𝑑 XMSS signatures needed to authenticate\na FORS public key when starting with the public key of the XMSS key at layer 𝑑 −1 is a hypertree\nsignature. An SLH-DSA signature consists of a FORS signature along with a hypertree signature.\nAn SLH-DSA public key (Figure 16) contains two 𝑛-byte components: (1) PK.root, which is the\npublic key of the XMSS key at layer 𝑑 −1, and (2) PK.seed, which is used to provide domain\nseparation between different SLH-DSA key pairs. An SLH-DSA private key (Figure 15) consists of\nan 𝑛-byte seed SK.seed that is used to pseudorandomly generate all of the secret values for the\nWOTS+ and FORS keys and an 𝑛-byte key SK.prf that is used in the generation of the randomized\nhash of the message. An SLH-DSA private key also includes copies of PK.root and PK.seed, as\nthese values are needed during both signature generation and signature verification.\n2The WOTS+ and XMSS schemes that are used as components of SLH-DSA are not the same as the WOTS+ and\nXMSS schemes in RFC 8391 [11] and SP 800-208 [12].\n3For the parameter sets in this standard, an SLH-DSA key pair contains 263 , 264 , 266, or 268 FORS keys, which are\npseudorandomly generated from a single seed.\n4For the parameter sets in this standard, 𝑑 is 7, 8, 17, or 22.\n7\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nPK.root\nlayer 𝑑 − 1 = 2\nWOTS+ signature\nlayer 1\nMerkle tree node\nWOTS+ signature\nWOTS+ public key\nFORS public key\nlayer 0\nWOTS+ signature\nFORS signature\nMessage\nFigure 1. An SLH-DSA signature\nThe WOTS+ one-time signature scheme is specified in Section 5, and the XMSS multi-time sig-\nnature scheme is specified in Section 6. Section 7 specifies the generation and verification of\nhypertree signatures. The FORS few-time signature scheme is specified in Section 8. Finally,\nSection 9 specifies the SLH-DSA key generation, signature, and verification functions. As the\nWOTS+ , XMSS, hypertree, and FORS schemes described in this standard are not intended for\nuse as stand-alone signature schemes, only the components of the schemes necessary to imple-\nment SLH-DSA are described. In particular, these sections do not include functions for key pair\ngeneration, and a signature verification function is only specified for hypertree signatures.\nWhen used in this standard, WOTS+ , XMSS, and FORS signatures are implicitly verified using\nfunctions to generate public keys from messages and signatures (see Sections 5.3, 6.3, and\n8.4). When verifying an SLH-DSA signature, the randomized hash of the message and the FORS\nsignature are used to compute a candidate FORS public key. The candidate FORS public key and\nthe WOTS+ signature from the layer 0 XMSS key are used to compute a candidate WOTS+ public\nkey, which is then used in conjunction with the corresponding authentication path to compute a\ncandidate XMSS public key. The candidate layer 0 XMSS public key is used along with the layer 1\n8\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nXMSS signature to compute a candidate layer 1 XMSS public key. This process is repeated until a\ncandidate layer 𝑑 − 1 public key has been computed. SLH-DSA signature verification succeeds if\nthe computed candidate layer 𝑑 −1 XMSS public key is the same as the SLH-DSA public key root\nPK.root.\n3.1 Additional Requirements\nThis section specifies requirements for cryptographic modules that implement SLH-DSA. Sec-\ntion 3.2 discusses issues that implementers of cryptographic modules should take into considera-\ntion but that are not requirements. SP 800-89, Recommendation for Obtaining Assurances for\nDigital Signature Applications [3], specifies requirements that apply to the use of digital signature\nschemes.\nRandomness generation. SLH-DSA key generation (Algorithm 21) requires the generation of three\nrandom 𝑛-byte values: PK.seed, SK.seed, and SK.prf, where 𝑛 is 16, 24, or 32, depending on\nthe parameter set. For each invocation of key generation, each of these values shall be a fresh\n(i.e., not previously used) random value generated using an approved random bit generator\n(RBG), as prescribed in SP 800-90A, SP 800-90B, and SP 800-90C [14, 15, 16]. Moreover, the RBG\nused shall have a security strength of at least 8𝑛 bits. See Table 2 for the value of 𝑛 for each\nparameter set.\nDestruction of sensitive data. Data used internally by key generation and signing algorithms in\nintermediate computation steps could be used by an adversary to gain information about the\nprivate key and thereby compromise security. The data used internally by verification algorithms\nis similarly sensitive for some applications, including the verification of signatures that are used as\nbearer tokens (i.e., authentication secrets) or signatures on plaintext messages that are intended\nto be confidential. Intermediate values of the verification algorithm may reveal information\nabout its inputs (i.e., the message, signature, and public key), and in some applications, security\nor privacy requires one or more of these inputs to be confidential. Therefore, implementations of\nSLH-DSA shall ensure that any local copies of the inputs and any potentially sensitive intermediate\ndata are destroyed as soon as they are no longer needed.\nKey checks. SP 800-89 imposes requirements for the assurance of public-key validity and private-\nkey possession. In the case of SLH-DSA, where public-key validation is required, implementations\nshall verify that the public key is 2𝑛 bytes in length. When the assurance of private key possession\nis obtained via regeneration, the owner of the private key shall check that the private key is 4𝑛\nbytes in length and shall use SK.seed and PK.seed to recompute PK.root and compare the\nnewly generated value with the value in the private key currently held.\nFloating-point arithmetic. Implementations of SLH-DSA shall not use floating-point arithmetic,\nas rounding errors in floating point operations may lead to incorrect results in some cases. In all\npseudocode in this standard in which division is performed (e.g., 𝑥/𝑦) and 𝑦 may not divide 𝑥,\neither ⌊𝑥/𝑦⌋ or ⌈𝑥/𝑦⌉ is used. Both of these can be computed without floating-point arithmetic,\nas ordinary integer division 𝑥/𝑦 computes ⌊𝑥/𝑦⌋, and ⌈𝑥/𝑦⌉ = ⌊(𝑥+𝑦−1)/𝑦⌋ for non-negative\nintegers 𝑥 and positive integers 𝑦.\n9\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nWhile the value of 𝑙𝑒𝑛 (see Equation 5.3) may be computed without using floating-point arith-\n2\nmetic (see Algorithm 1), it is recommended that this value be precomputed. For all parameter\nsets in this standard, 𝑙𝑒𝑛 is 3.\n2\nAlgorithm 1 gen_len (𝑛, 𝑙𝑔 )\n2 𝑤\nComputes 𝑙𝑒𝑛 (Equation 5.3).\n2\nInput: Security parameter 𝑛, bits per hash chain 𝑙𝑔 .\n𝑤\nOutput: 𝑙𝑒𝑛 .\n2\n1: 𝑤 ← 2𝑙𝑔 𝑤 ▷ Equation 5.1\n2: 𝑙𝑒𝑛 ← ⌊8⋅𝑛+𝑙𝑔 𝑤 −1 ⌋ ▷ Equation 5.2\n1 𝑙𝑔\n𝑤\n3: 𝑚𝑎𝑥_𝑐ℎ𝑒𝑐𝑘𝑠𝑢𝑚 = 𝑙𝑒𝑛 ⋅ (𝑤 − 1) ▷ maximum possible checksum value\n1\n4: 𝑙𝑒𝑛 ← 1 ▷ maximum value that may be signed using\n2\n5: 𝑐𝑎𝑝𝑎𝑐𝑖𝑡𝑦 ← 𝑤 ▷ 𝑙𝑒𝑛 hash chains is 𝑤𝑙𝑒𝑛 2 − 1 = 𝑐𝑎𝑝𝑎𝑐𝑖𝑡𝑦 − 1\n2\n6: while 𝑐𝑎𝑝𝑎𝑐𝑖𝑡𝑦 ≤ 𝑚𝑎𝑥_𝑐ℎ𝑒𝑐𝑘𝑠𝑢𝑚 do\n7: 𝑙𝑒𝑛 ← 𝑙𝑒𝑛 + 1\n2 2\n8: 𝑐𝑎𝑝𝑎𝑐𝑖𝑡𝑦 ← 𝑐𝑎𝑝𝑎𝑐𝑖𝑡𝑦 ⋅ 𝑤\n9: end while\n10: return 𝑙𝑒𝑛\n2\n3.2 Implementation Considerations\nThis section discusses some implementation considerations for SLH-DSA.\nDo not support component use. As WOTS+ , XMSS, FORS, and hypertree signature schemes are\nnot approved for use as stand-alone signature schemes, cryptographic modules should not make\ninterfaces to these components available to applications. SP 800-208 [12] specifies approved\nstateful hash-based signature schemes.\nSide-channel and fault attacks. For signature schemes, the secrecy of the private key is critical.\nCare must be taken to protect implementations against attacks, such as side-channel attacks\nor fault attacks [17, 18, 19, 20, 21]. A cryptographic device may leak critical information with\nside-channel analysis or attacks that allow internal data or keying material to be extracted without\nbreaking the cryptographic primitives.\n10",
    "question": "What is the structure and process of generating and verifying digital signatures in the SLH-DSA scheme?",
    "summary": "The FIPS 205 standard defines a stateless hash-based digital signature scheme called SLH-DSA, which uses components like FORS and XMSS. It outlines terms, acronyms, and mathematical symbols relevant to hash-based cryptography. The standard emphasizes the importance of randomness, security, and protection against side-channel and fault attacks to ensure the integrity and confidentiality of digital signatures."
  },
  {
    "start": 13,
    "end": 15,
    "text": "FIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n4. Functions and Addressing\n4.1 Hash Functions and Pseudorandom Functions\nThe specification of SLH-DSA makes use of six functions — PRF , H , PRF, T , H, and\n𝑚𝑠𝑔 𝑚𝑠𝑔 ℓ\nF — that are all implemented using hash functions or XOFs with fixed output lengths. The inputs\nand output of each function are byte strings. In the following definitions, 𝔹 = {0,…,255}\ndenotes the set of all bytes, 𝔹𝑛 denotes the set of byte strings of length 𝑛 bytes, and 𝔹∗ denotes\nthe set of all byte strings. The ADRS input is described in Section 4.2.\n• PRF (SK.prf, 𝑜𝑝𝑡_𝑟𝑎𝑛𝑑, 𝑀) (𝔹𝑛 × 𝔹𝑛 × 𝔹∗ → 𝔹𝑛) is a pseudorandom function\n𝑚𝑠𝑔\n(PRF) that generates the randomizer (𝑅) for the randomized hashing of the message to be\nsigned.\n• H (𝑅, PK.seed, PK.root, 𝑀) (𝔹𝑛 × 𝔹𝑛 × 𝔹𝑛 × 𝔹∗ → 𝔹𝑚) is used to generate the\n𝑚𝑠𝑔\ndigest of the message to be signed.\n• PRF(PK.seed, SK.seed, ADRS) (𝔹𝑛 × 𝔹𝑛 × 𝔹32 → 𝔹𝑛) is a PRF that is used to\ngenerate the secret values in WOTS+ and FORS private keys.\n• T (PK.seed, ADRS, 𝑀 ) (𝔹𝑛 × 𝔹32 × 𝔹ℓ𝑛 → 𝔹𝑛) is a hash function that maps an\nℓ ℓ\nℓ𝑛-byte message to an 𝑛-byte message.\n• H(PK.seed, ADRS, 𝑀 ) (𝔹𝑛 × 𝔹32 × 𝔹2𝑛 → 𝔹𝑛) is a special case of T that takes a\n2 ℓ\n2𝑛-byte message as input.\n• F(PK.seed, ADRS, 𝑀 ) (𝔹𝑛 × 𝔹32 × 𝔹𝑛 → 𝔹𝑛) is a hash function that takes an 𝑛-byte\n1\nmessage as input and produces an 𝑛-byte output.\nThe specific instantiations for these functions differ for different parameter sets and are specified\nin Section 11.\n4.2 Addresses\nFour of the functions described in Section 4.1 take a 32-byte address (i.e., ADRS) as input. An\nADRS consists of public values that indicate the position of the value being computed by the\nfunction. A different ADRS value is used for each call to each function. In the case of PRF,\nthis is used to generate a large number of different secret values from a single seed. In the case\nof T , H, and F, it is used to mitigate multi-target attacks. In the pseudocode, where addresses\nℓ\nare passed as parameters, they may be passed either by reference or by value.\nThe structure of an ADRS conforms to word boundaries, with each word being 4 bytes long\nand values encoded as unsigned integers in big-endian byte order (see Figure 2). The first word\nof ADRS specifies the layer address, which is the height of an XMSS tree within the hypertree.\nTrees on the bottom layer have a height of zero, and the single XMSS tree at the top has a height\nof 𝑑 −1 (see Figure 1). The next three words of ADRS specify the tree address, which is the\nposition of an XMSS tree within a layer of the hypertree. The leftmost XMSS tree in a layer has a\ntree address of zero, and the rightmost XMSS tree in layer 𝐿 has a tree address of 2(𝑑−1−𝐿)ℎ′ − 1.\nThe next word is used to specify the type of the address, which differs depending on the use case.\n11\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nThere are seven different types of address used in SLH-DSA, as described below.5 The address\ntype determines how the final 12 bytes of the address are to be interpreted. The algorithms\nin this standard are written based on the assumption that whenever the type in an ADRS is\nchanged, the final 12 bytes of the address are initialized to zero.\nlayer address 4 bytes\ntree address 12 bytes\n𝑡𝑦𝑝𝑒 4 bytes\n12 bytes\nFigure 2. Address (ADRS)\nThe type is set to WOTS_HASH (i.e., 𝑡𝑦𝑝𝑒 = 0) for a WOTS+ hash address (see Figure 3), which is\nused when computing hash chains in WOTS+ . When type is WOTS_HASH, the next word encodes\nthe key pair address, which is the index of the WOTS+ key pair within the XMSS tree specified\nby the layer and tree addresses, with the leftmost WOTS+ key having an index of zero and the\nrightmost WOTS+ key having an index of 2ℎ′ −1. Next is the chain address, which encodes the\nindex of the chain within WOTS+ , followed by the hash address, which encodes the address of\nthe hash function within the chain.\nlayer address layer address\ntree address tree address\n𝑡𝑦𝑝𝑒 = 0 (WOTS_HASH) 𝑡𝑦𝑝𝑒 = 1 (WOTS_PK)\nkey pair address 4 bytes key pair address 4 bytes\nchain address 4 bytes\n𝑝𝑎𝑑𝑑𝑖𝑛𝑔 = 0 8 bytes\nhash address 4 bytes\nFigure 3. WOTS+ hash address Figure 4. WOTS+ public-key compression address\nThe type is set to WOTS_PK (i.e., 𝑡𝑦𝑝𝑒 = 1) when compressing WOTS+ public keys (see Figure 4).\nAs when the type is WOTS_HASH, the next word encodes the index of the WOTS+ key pair within\nthe XMSS tree specified by the layer and tree addresses. The remaining two words of ADRS\nare not needed and are set to zero.\nThe type is set to TREE (i.e., 𝑡𝑦𝑝𝑒 = 2) when computing the hashes within the XMSS tree (see\nFigure 5). For this type of address, the next word is always set to zero. The following word\n5The type word will have a value of 0, 1, 2, 3, 4, 5, or 6. In order to improve readability, these values will be\nreferred to in this standard by the constants WOTS_HASH, WOTS_PK, TREE, FORS_TREE, FORS_ROOTS, WOTS_PRF,\nand FORS_PRF, respectively.\n12\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nencodes the height of the node within the tree that is being computed, and the final word\nencodes the index of the node at that height.\nlayer address\ntree address\n𝑡𝑦𝑝𝑒 = 2 (TREE)\n𝑝𝑎𝑑𝑑𝑖𝑛𝑔 = 0 4 bytes\ntree height 4 bytes\ntree index 4 bytes\nFigure 5. Hash tree address\nThe type is set to FORS_TREE (i.e., 𝑡𝑦𝑝𝑒 = 3) when computing hashes within the FORS tree (see\nFigure 6). The next word is the key pair address, which encodes the FORS key that is used. The\nvalue is the same as the key pair address for the WOTS+ key used to sign the FORS key (see\nFigure 3 and Figure 4). The next two words — the tree height and tree index — encode the node\nwithin the FORS tree that is being computed. The tree height starts with zero for the leaf nodes.\nThe tree index is counted continuously across the 𝑘 different FORS trees. The leftmost node in\nthe leftmost tree has an index of zero, and the rightmost node in the rightmost tree at level 𝑗\nhas an index of 𝑘 ⋅ 2(𝑎−𝑗) − 1, where 𝑎 is the height of the tree.\nlayer address = 0 layer address = 0\ntree address tree address\n𝑡𝑦𝑝𝑒 = 3 (FORS_TREE) 𝑡𝑦𝑝𝑒 = 4 (FORS_ROOTS)\nkey pair address 4 bytes key pair address 4 bytes\ntree height 4 bytes\n𝑝𝑎𝑑𝑑𝑖𝑛𝑔 = 0 8 bytes\ntree index 4 bytes\nFigure 6. FORS tree address Figure 7. FORS tree roots compression address\nThe type is set to FORS_ROOTS (i.e., 𝑡𝑦𝑝𝑒 = 4) when compressing the 𝑘 FORS tree roots (see\nFigure 7). The next word is the key pair address, which has the same meaning as it does in the\nFORS_TREE address. The remaining two words of ADRS are not needed and are set to zero.\nThe type is set to WOTS_PRF (i.e., 𝑡𝑦𝑝𝑒 = 5) when generating secret values for WOTS+ keys (see\nFigure 8). The values for the other words in the address are set to the same values as for the\nWOTS_HASH address (Figure 3) used for the chain. The hash address is always set to zero.\n13\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nlayer address layer address = 0\ntree address tree address\n𝑡𝑦𝑝𝑒 = 5 (WOTS_PRF) 𝑡𝑦𝑝𝑒 = 6 (FORS_PRF)\nkey pair address 4 bytes key pair address 4 bytes\nchain address 4 bytes tree height = 0 4 bytes\nhash address = 0 4 bytes tree index 4 bytes\nFigure 8. WOTS+ key generation address Figure 9. FORS key generation address\nThe type is set to FORS_PRF (i.e., 𝑡𝑦𝑝𝑒 = 6) when generating secret values for FORS keys (see\nFigure 9). The values for the other words in the address are set to the same values as for the\nFORS_TREE address (Figure 6) used for the same leaf node.\n4.3 Member Functions\nThe algorithms in this standard make use of member functions. If a complex data structure\n(e.g., an ADRS) contains a component 𝑋, then ADRS.getX() returns the value of 𝑋, and\nADRS.setX(𝑌) sets the component 𝑋 in ADRS to the value held by 𝑌. If a data structure 𝑠\ncontains multiple instances of 𝑋, then 𝑠.getX(𝑖) returns the value of the 𝑖th instance of 𝑋 in 𝑠.\nFor example, if 𝑠 is a FORS signature (Figure 14), then 𝑠.getAUTH(𝑖) returns the authentication\npath for the 𝑖th tree.\nWhenever the type in an address changes, the final 12 bytes of the address are initialized to zero.\nThe member function ADRS.setTypeAndClear(𝑌) for addresses sets the 𝑡𝑦𝑝𝑒 of the ADRS to\n𝑌 and sets the final 12 bytes of the ADRS to zero. 6\nTable 1 shows alternative notation for each of the member functions that operates on addresses.\nTable 1. Member functions for addresses\nMember function Expanded notation\nADRS.setLayerAddress(𝑙) ADRS ← toByte(𝑙, 4) ∥ ADRS[4 ∶ 32]\nADRS.setTreeAddress(𝑡) ADRS ← ADRS[0 ∶ 4] ∥ toByte(𝑡, 12) ∥ ADRS[16 ∶ 32]\nADRS.setTypeAndClear(𝑌) ADRS ← ADRS[0 ∶ 16] ∥ toByte(𝑌 , 4) ∥ toByte(0, 12)\nADRS.setKeyPairAddress(𝑖) ADRS ← ADRS[0 ∶ 20] ∥ toByte(𝑖, 4) ∥ ADRS[24 ∶ 32]\nADRS.setChainAddress(𝑖)\nADRS ← ADRS[0 ∶ 24] ∥ toByte(𝑖, 4) ∥ ADRS[28 ∶ 32]\nADRS.setTreeHeight(𝑖)\nADRS.setHashAddress(𝑖)\nADRS ← ADRS[0 ∶ 28] ∥ toByte(𝑖, 4)\nADRS.setTreeIndex(𝑖)\n𝑖 ← ADRS.getKeyPairAddress() 𝑖 ← toInt(ADRS[20 ∶ 24], 4)\n𝑖 ← ADRS.getTreeIndex() 𝑖 ← toInt(ADRS[28 ∶ 32], 4)\n6As noted in Section 4.2, the type (𝑌) is an integer. However, in the pseudocode, the constants WOTS_HASH, WOTS_PK,\nTREE, FORS_TREE, FORS_ROOTS, WOTS_PRF, and FORS_PRF are used in order to improve readability.\n14\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n4.4 Arrays, Byte Strings, and Integers\nIf 𝑋 is a byte string of length 𝑛, then 𝑋[𝑖] for 𝑖 ∈ {0,…,𝑛−1} will refer to the 𝑖th element in\nthe string 𝑋. If 𝑋 is an array of 𝑚 𝑛-byte strings, then 𝑋[𝑖] for 𝑖 ∈ {0,…,𝑚−1} will refer to\nthe 𝑖th 𝑛-byte string in 𝑋, and 𝑋 will refer to the 𝑚 ⋅ 𝑛-byte string 𝑋[0] ∥ 𝑋[1] ∥ … 𝑋[𝑚 − 1].\nA byte string may be interpreted as the big-endian representation of an integer. In such cases, a\nbyte string 𝑋 of length 𝑛 is converted to the integer\n𝑋[0] ⋅ 256𝑛−1 + 𝑋[1] ⋅ 256𝑛−2 + … 𝑋[𝑛 − 2] ⋅ 256 + 𝑋[𝑛 − 1].\nSimilarly, an integer 𝑥 may be converted to a byte string of length 𝑛 by finding coefficients\n𝑥 , 𝑥 , … 𝑥 , 𝑥 ∈ {0, … , 255} such that\n0 1 𝑛−2 𝑛−1\n𝑥 = 𝑥 ⋅ 256𝑛−1 + 𝑥 ⋅ 256𝑛−2 + … 𝑥 ⋅ 256 + 𝑥\n0 1 𝑛−2 𝑛−1\nand then setting the byte string to be 𝑥 𝑥 … 𝑥 𝑥 .\n0 1 𝑛−2 𝑛−1\nAlgorithm 2 is a function that converts a byte string 𝑋 of length 𝑛 to an integer, and Algorithm 3\nis a function that converts an integer 𝑥 to a byte string of length 𝑛.\nAlgorithm 2 toInt(𝑋, 𝑛)\nConverts a byte string to an integer.\nInput: 𝑛-byte string 𝑋.\nOutput: Integer value of 𝑋.\n1: 𝑡𝑜𝑡𝑎𝑙 ← 0\n2: for 𝑖 from 0 to 𝑛 − 1 do\n3: 𝑡𝑜𝑡𝑎𝑙 ← 256 ⋅ 𝑡𝑜𝑡𝑎𝑙 + 𝑋[𝑖]\n4: end for\n5: return 𝑡𝑜𝑡𝑎𝑙\nAlgorithm 3 toByte(𝑥, 𝑛)\nConverts an integer to a byte string.\nInput: Integer 𝑥, string length 𝑛.\nOutput: Byte string of length 𝑛 containing binary representation of 𝑥 in big-endian byte-order.\n1: 𝑡𝑜𝑡𝑎𝑙 ← 𝑥\n2: for 𝑖 from 0 to 𝑛 − 1 do\n3: 𝑆[𝑛 − 1 − 𝑖] ← 𝑡𝑜𝑡𝑎𝑙 mod 256 ▷ least significant 8 bits of 𝑡𝑜𝑡𝑎𝑙\n4: 𝑡𝑜𝑡𝑎𝑙 ← 𝑡𝑜𝑡𝑎𝑙 ≫ 8\n5: end for\n6: return 𝑆\n15\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nFor the WOTS+ and FORS schemes, the messages to be signed need to be split into a sequence\nof 𝑏-bit strings, where each 𝑏-bit string is interpreted as an integer between 0 and 2𝑏 −1.7 This\nis the equivalent of creating the base-2𝑏 representation of the message. The base_2b function\n(Algorithm 4) takes a byte string 𝑋, a bit string length 𝑏, and an output length 𝑜𝑢𝑡_𝑙𝑒𝑛 as input\nand returns an array of base-2𝑏 integers that represent the first 𝑜𝑢𝑡_𝑙𝑒𝑛 ⋅ 𝑏 bits of 𝑋 if the\nindividual bytes in 𝑋 are encoded as 8-bit strings in big-endian bit order. 𝑋 must be at least\n⌈𝑜𝑢𝑡_𝑙𝑒𝑛 ⋅ 𝑏/8⌉ bytes in length. As the value of 𝑏𝑖𝑡𝑠 will never exceed 𝑏 +7,a 𝑏 +7-bit unsigned\ninteger is sufficient to store 𝑡𝑜𝑡𝑎𝑙 (i.e., 𝑡𝑜𝑡𝑎𝑙 may be stored as a 32-bit unsigned integer).\nAlgorithm 4 base_2b(𝑋, 𝑏, 𝑜𝑢𝑡_𝑙𝑒𝑛)\nComputes the base 2𝑏 representation of 𝑋.\nInput: Byte string 𝑋 of length at least ⌈𝑜𝑢𝑡_ 𝑙𝑒𝑛⋅𝑏⌉, integer 𝑏, output length 𝑜𝑢𝑡_𝑙𝑒𝑛.\n8\nOutput: Array of 𝑜𝑢𝑡_𝑙𝑒𝑛 integers in the range [0,…,2𝑏 −1].\n1: 𝑖𝑛 ← 0\n2: 𝑏𝑖𝑡𝑠 ← 0\n3: 𝑡𝑜𝑡𝑎𝑙 ← 0\n4: for 𝑜𝑢𝑡 from 0 to 𝑜𝑢𝑡_𝑙𝑒𝑛 − 1 do\n5: while 𝑏𝑖𝑡𝑠 < 𝑏 do\n6: 𝑡𝑜𝑡𝑎𝑙 ← (𝑡𝑜𝑡𝑎𝑙 ≪ 8) + 𝑋[𝑖𝑛]\n7: 𝑖𝑛 ← 𝑖𝑛+1\n8: 𝑏𝑖𝑡𝑠 ← 𝑏𝑖𝑡𝑠 + 8\n9: end while\n10: 𝑏𝑖𝑡𝑠 ← 𝑏𝑖𝑡𝑠 − 𝑏\n11: 𝑏𝑎𝑠𝑒𝑏[𝑜𝑢𝑡] ← (𝑡𝑜𝑡𝑎𝑙 ≫ 𝑏𝑖𝑡𝑠) mod 2𝑏\n12: end for\n13: return 𝑏𝑎𝑠𝑒𝑏\n7𝑏 will be the value of 𝑙𝑔 when the base_2b function is used in WOTS +, and 𝑏 will be the value of 𝑎 when the\n𝑤\nbase_2b function is used in FORS. For the parameter sets in this standard, 𝑙𝑔 is 4, and 𝑎 is 6, 8, 9, 12, or 14.\n𝑤\n16",
    "question": "What are the different types of addresses used in the SLH-DSA standard and how do they determine the interpretation of the final 12 bytes of the address?",
    "summary": "The FIPS 205 standard defines six hash-based functions used in digital signatures, including PRF, H, T, and F, which are implemented with hash functions or XOFs. These functions use addresses (ADRS) to specify positions and prevent multi-target attacks. The ADRS is structured with layers, trees, and types, each determining how the final 12 bytes are interpreted for different cryptographic operations."
  },
  {
    "start": 16,
    "end": 18,
    "text": "FIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n5. Winternitz One-Time Signature Plus Scheme\nThis section describes the WOTS+ one-time signature scheme that is a component of SLH-DSA.\nWOTS+ uses two parameters. The security parameter 𝑛 is the length in bytes of the messages\nthat may be signed as well as the length of the private key elements, public key elements, and\nsignature elements. For the parameter sets specified in this standard, 𝑛 may be 16, 24, or 32\n(see Table 2). The second parameter 𝑙𝑔 indicates the number of bits that are encoded by each\n𝑤\nhash chain that is used.8 𝑙𝑔 is 4 for all parameter sets in this standard. These parameters are\n𝑤\nused to compute four additional values:\n𝑤 = 2𝑙𝑔 𝑤 (5.1)\n8𝑛\n𝑙𝑒𝑛 = ⌈ ⌉ (5.2)\n1 𝑙𝑔\n𝑤\nlog (𝑙𝑒𝑛 ⋅ (𝑤 − 1))\n𝑙𝑒𝑛 = ⌊ 2 1 ⌋ + 1 (5.3)\n2 𝑙𝑔\n𝑤\n𝑙𝑒𝑛 = 𝑙𝑒𝑛 + 𝑙𝑒𝑛 (5.4)\n1 2\nWhen 𝑙𝑔 = 4, 𝑤 = 16, 𝑙𝑒𝑛 = 2𝑛, 𝑙𝑒𝑛 = 3, and 𝑙𝑒𝑛 = 2𝑛 + 3.\n𝑤 1 2\nA WOTS+ private key consists of 𝑙𝑒𝑛 secret values of length 𝑛. In SLH-DSA, these are all generated\nfrom an 𝑛-byte seed SK.seed using a PRF. Chains of length 𝑤 are then created from the secret\nvalues using a chaining function, and the end values from each of the chains are public values. The\nWOTS+ public key is computed as the hash of these public values. In order to create a signature,\nthe 8𝑛-bit message is first converted into an array of 𝑙𝑒𝑛 base-𝑤 integers. A checksum is then\n1\ncomputed for this string, and the checksum is converted into an array of 𝑙𝑒𝑛 base-𝑤 integers.\n2\nThe signature consists of the appropriate entries from the chains for each of the integers in the\nmessage and checksum arrays.\nThe WOTS+ functions make use of two helper functions: base_2b and chain. The base_2b function\n(Section 4.4) is used to break the message to be signed and the checksum value into arrays of\nbase-𝑤 integers. The chain function (Algorithm 5) is used to compute the hash chains.\nThe chain function takes an 𝑛-byte string 𝑋 and integers 𝑠 and 𝑖 (where 𝑖+𝑠 < 𝑤) as input and\nreturns the result of iterating a hash function F on the input 𝑠 times, starting from an index of\n𝑖. 9 The chain function also requires as input PK.seed, which is part of the SLH-DSA public key,\nand an address ADRS. The type in ADRS must be set to WOTS_HASH, and the layer address,\ntree address, key pair address, and chain address must be set to the address of the chain being\ncomputed. The chain function updates the hash address in ADRS with each iteration to specify\nthe current position in the chain prior to ADRS’s use in F.\n8In [10], the Winternitz parameter 𝑤 is used as the second WOTS+ parameter, where 𝑤 indicates the length of the\nhash chains that are used. This standard uses the parameter 𝑙𝑔 = log (𝑤) to simplify notation.\n𝑤 2\n9A start index of 0 indicates the beginning of the chain.\n17\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 5 chain(𝑋, 𝑖, 𝑠, PK.seed, ADRS)\nChaining function used in WOTS+ .\nInput: Input string 𝑋, start index 𝑖, number of steps 𝑠, public seed PK.seed, address ADRS.\nOutput: Value of F iterated 𝑠 times on 𝑋.\n1: 𝑡𝑚𝑝 ← 𝑋\n2: for 𝑗 from 𝑖 to 𝑖 + 𝑠 − 1 do\n3: ADRS.setHashAddress(𝑗)\n4: 𝑡𝑚𝑝 ← F(PK.seed, ADRS, 𝑡𝑚𝑝)\n5: end for\n6: return 𝑡𝑚𝑝\n5.1 WOTS\n+\nPublic-Key Generation\nThe wots_pkGen function (Algorithm 6) generates WOTS+ public keys. It takes SK.seed and\nPK.seed from the SLH-DSA private key and an address as input. The type in the address ADRS\nmust be set to WOTS_HASH, and the layer address, tree address, and key pair address must encode\nthe address of the WOTS+ public key to be generated.\nLines 4 through 9 in Algorithm 6 generate the public values, as described in Section 5. For each\nof the 𝑙𝑒𝑛 public values, the corresponding secret value is generated in lines 5 and 6, and the\nchain function is called to compute the end value of the chain of length 𝑤. Once the 𝑙𝑒𝑛 public\nvalues are computed, they are compressed into a single 𝑛-byte value in lines 10 through 13.\nAlgorithm 6 wots_pkGen(SK.seed, PK.seed, ADRS)\nGenerates a WOTS+ public key.\nInput: Secret seed SK.seed, public seed PK.seed, address ADRS.\nOutput: WOTS+ public key 𝑝𝑘.\n1: skADRS ← ADRS ▷ copy address to create key generation key address\n2: skADRS.setTypeAndClear(WOTS_PRF)\n3: skADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n4: for 𝑖 from 0 to 𝑙𝑒𝑛 − 1 do\n5: skADRS.setChainAddress(𝑖)\n6: 𝑠𝑘 ← PRF(PK.seed, SK.seed, skADRS) ▷ compute secret value for chain 𝑖\n7: ADRS.setChainAddress(𝑖)\n8: 𝑡𝑚𝑝[𝑖] ← chain(𝑠𝑘, 0, 𝑤 − 1, PK.seed, ADRS) ▷ compute public value for chain 𝑖\n9: end for\n10: wotspkADRS ← ADRS ▷ copy address to create WOTS+public key address\n11: wotspkADRS.setTypeAndClear(WOTS_PK)\n12: wotspkADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n13: 𝑝𝑘 ← T (PK.seed, wotspkADRS, 𝑡𝑚𝑝) ▷ compress public key\n𝑙𝑒𝑛\n14: return 𝑝𝑘\n18\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n5.2 WOTS\n+\nSignature Generation\nA WOTS+ signature is an array of 𝑙𝑒𝑛 byte strings of length 𝑛, as shown in Figure 10. The wots_sign\nfunction (Algorithm 7) generates the signature by converting the 𝑛-byte message 𝑀10 into an\narray of 𝑙𝑒𝑛 base-𝑤 integers (line 2). A checksum is computed over 𝑀 (lines 3 through 5). The\n1\nchecksum is converted to a byte string, which is then converted into an array of 𝑙𝑒𝑛 base-𝑤\n2\nintegers (lines 6 and 7). The 𝑙𝑒𝑛 integers that represent the checksum are appended to the 𝑙𝑒𝑛\n2 1\nintegers that represent the message (line 7).11 For each of the 𝑙𝑒𝑛 base-𝑤 integers, the signature\nconsists of the corresponding node in one of the hash chains. For each of these integers, lines\n12 and 13 compute the secret value for the hash chain, and lines 14 and 15 compute the node in\nthe hash chain that corresponds to the integer. The selected nodes are concatenated to form\nthe WOTS+ signature.\nsig [0] 𝑛 bytes\nots\n⋯\nsig [𝑙𝑒𝑛 − 1] 𝑛 bytes\nots\nFigure 10. WOTS+ signature data format\nIn addition to the 𝑛-byte message to be signed, wots_sign takes SK.seed and PK.seed from\nthe SLH-DSA private key and an address as input. The type in the address ADRS must be set to\nWOTS_HASH, and the layer address, tree address, and key pair address must encode the address\nof the WOTS+ key that is used to sign the message.\n10In SLH-DSA, the message 𝑀 that is signed using WOTS+ is either an XMSS public key or a FORS public key.\n11In the case that 𝑙𝑔 = 4, the 𝑛-byte message is converted into an array of 2𝑛 base-16 integers (i.e., hexadecimal\n𝑤\ndigits). The checksum is encoded as two bytes with the least significant four bits being zeros, and the most\nsignificant 12 bits are appended to the message as an array of three base-16 integers.\n19\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 7 wots_sign(𝑀, SK.seed, PK.seed, ADRS)\nGenerates a WOTS+ signature on an 𝑛-byte message.\nInput: Message 𝑀, secret seed SK.seed, public seed PK.seed, address ADRS.\nOutput: WOTS+ signature 𝑠𝑖𝑔.\n1: 𝑐𝑠𝑢𝑚 ← 0\n2: 𝑚𝑠𝑔 ← base_2b(𝑀,𝑙𝑔 ,𝑙𝑒𝑛 ) ▷ convert message to base 𝑤\n𝑤 1\n3: for 𝑖 from 0 to 𝑙𝑒𝑛 − 1 do ▷ compute checksum\n1\n4: 𝑐𝑠𝑢𝑚 ← 𝑐𝑠𝑢𝑚 + 𝑤 − 1 − 𝑚𝑠𝑔[𝑖]\n5: end for\n6: 𝑐𝑠𝑢𝑚 ← 𝑐𝑠𝑢𝑚 ≪ ((8 − ((𝑙𝑒𝑛 ⋅ 𝑙𝑔 ) mod 8)) mod 8) ▷ for 𝑙𝑔 = 4, left shift by 4\n2 𝑤 𝑤\n7: 𝑚𝑠𝑔 ← 𝑚𝑠𝑔 ∥ base_2b (toByte (𝑐𝑠𝑢𝑚, ⌈𝑙𝑒𝑛 2 ⋅𝑙𝑔 𝑤 ⌉) , 𝑙𝑔 , 𝑙𝑒𝑛 ) ▷ convert to base 𝑤\n8 𝑤 2\n8: skADRS ← ADRS ▷ copy address to create key generation key address\n9: skADRS.setTypeAndClear(WOTS_PRF)\n10: skADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n11: for 𝑖 from 0 to 𝑙𝑒𝑛 − 1 do\n12: skADRS.setChainAddress(𝑖)\n13: 𝑠𝑘 ← PRF(PK.seed, SK.seed, skADRS) ▷ compute chain 𝑖 secret value\n14: ADRS.setChainAddress(𝑖)\n15: 𝑠𝑖𝑔[𝑖] ← chain(𝑠𝑘, 0, 𝑚𝑠𝑔[𝑖], PK.seed, ADRS) ▷ compute chain 𝑖 signature value\n16: end for\n17: return 𝑠𝑖𝑔\n20",
    "question": "What are the parameters used in the WOTS+ one-time signature scheme and how are they utilized in generating the public key and signature?",
    "summary": "The WOTS+ one-time signature scheme is part of SLH-DSA and uses parameters 𝑛 and 𝑙𝑔 to generate keys and signatures. It creates hash chains from secret values and computes public keys by hashing the end values of these chains. To sign a message, it converts the message and checksum into base-𝑤 integers and selects corresponding nodes from the hash chains to form the signature."
  },
  {
    "start": 19,
    "end": 19,
    "text": "FIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n5.3 Computing a WOTS\n+\nPublic Key From a Signature\nVerifying a WOTS+ signature involves computing a public-key value from a message and signature\nvalue. Verification succeeds if the correct public-key value is computed, which is determined\nby using the computed public-key value along with other information to compute a candidate\nPK.root value and then comparing that value to the known value of PK.root from the SLH-DSA\npublic key. This section describes wots_pkFromSig (Algorithm 8), a function that computes a\ncandidate WOTS+ public key from a WOTS+ signature and corresponding message.\nIn addition to an 𝑛-byte message 𝑀 and a 𝑙𝑒𝑛 ⋅ 𝑛-byte signature 𝑠𝑖𝑔, which is interpreted as\nan array of 𝑙𝑒𝑛 𝑛-byte strings, the wots_pkFromSig function takes PK.seed from the SLH-DSA\npublic key and an address as input. The type of the address ADRS must be set to WOTS_HASH,\nand the layer address, tree address, and key pair address must encode the address of the WOTS+\nkey that was used to sign the message.\nLines 1 through 7 of wots_pkFromSig are the same as lines 1 through 7 of wots_sign (Algorithm 7).\nLines 8 through 11 of wots_pkFromSig compute the end nodes for each of the chains using\nthe signature value as the starting point and the message value to determine the number of\niterations that need to be performed to get to the end node. Finally, as with lines 10 through 13\nof Algorithm 6, the computed public-key values are compressed in lines 12 through 15.\nAlgorithm 8 wots_pkFromSig(𝑠𝑖𝑔, 𝑀, PK.seed, ADRS)\nComputes a WOTS+ public key from a message and its signature.\nInput: WOTS+ signature 𝑠𝑖𝑔, message 𝑀, public seed PK.seed, address ADRS.\nOutput: WOTS+ public key 𝑝𝑘 derived from 𝑠𝑖𝑔.\n𝑠𝑖𝑔\n1: 𝑐𝑠𝑢𝑚 ← 0\n2: 𝑚𝑠𝑔 ← base_2b(𝑀,𝑙𝑔 ,𝑙𝑒𝑛 ) ▷ convert message to base 𝑤\n𝑤 1\n3: for 𝑖 from 0 to 𝑙𝑒𝑛 − 1 do ▷ compute checksum\n1\n4: 𝑐𝑠𝑢𝑚 ← 𝑐𝑠𝑢𝑚 + 𝑤 − 1 − 𝑚𝑠𝑔[𝑖]\n5: end for\n6: 𝑐𝑠𝑢𝑚 ← 𝑐𝑠𝑢𝑚 ≪ ((8 − ((𝑙𝑒𝑛 ⋅ 𝑙𝑔 ) mod 8)) mod 8) ▷ for 𝑙𝑔 = 4, left shift by 4\n2 𝑤 𝑤\n7: 𝑚𝑠𝑔 ← 𝑚𝑠𝑔 ∥ base_2b (toByte (𝑐𝑠𝑢𝑚, ⌈𝑙𝑒𝑛 2 ⋅𝑙𝑔 𝑤 ⌉) , 𝑙𝑔 , 𝑙𝑒𝑛 ) ▷ convert to base 𝑤\n8 𝑤 2\n8: for 𝑖 from 0 to 𝑙𝑒𝑛 − 1 do\n9: ADRS.setChainAddress(𝑖)\n10: 𝑡𝑚𝑝[𝑖] ← chain(𝑠𝑖𝑔[𝑖], 𝑚𝑠𝑔[𝑖], 𝑤 − 1 − 𝑚𝑠𝑔[𝑖], PK.seed, ADRS)\n11: end for\n12: wotspkADRS ← ADRS ▷ copy address to create WOTS+ public key address\n13: wotspkADRS.setTypeAndClear(WOTS_PK)\n14: wotspkADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n15: 𝑝𝑘 ← T (PK.seed, wotspkADRS, 𝑡𝑚𝑝)\n𝑠𝑖𝑔 𝑙𝑒𝑛\n16: return 𝑝𝑘\n𝑠𝑖𝑔\n21",
    "question": "How is a WOTS+ public key computed from a WOTS+ signature and message using the wots_pkFromSig algorithm?",
    "summary": "The WOTS+ public key is computed from a signature and message using a specific algorithm. It involves generating end nodes for each chain based on the signature and message, then combining these with the address information to derive the public key. The process uses the SLH-DSA public key's seed and address parameters to ensure the correct public-key value is obtained for verification."
  },
  {
    "start": 20,
    "end": 22,
    "text": "FIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n6. eXtended Merkle Signature Scheme (XMSS)\nXMSS extends the WOTS+ signature scheme into one that can sign multiple messages. A Merkle\ntree [13] of height ℎ′ is used to allow 2ℎ′ WOTS+ public keys to be authenticated using a single\n𝑛-byte XMSS public key, which is the root of the Merkle tree.12 As each WOTS+ key may be used\nto sign one message, the XMSS key may be used to sign 2ℎ′ messages.\nAn XMSS signature is (ℎ′ + 𝑙𝑒𝑛) ⋅ 𝑛 bytes in length and consists of a WOTS+ signature and an\nauthentication path (see Figure 11). The authentication path is an array of nodes from the Merkle\ntree — one from each level of the tree, except for the root — that allows the verifier to compute\nthe root of the tree when used in conjunction with the WOTS+ public key that can be computed\nfrom the WOTS+ signature.\n𝑙𝑒𝑛 ⋅ 𝑛\nSIG\nWOTS+ bytes\nAUTH[0] 𝑛 bytes\n⋯\nAUTH[ℎ′ − 1] 𝑛 bytes\nFigure 11. XMSS signature data format\n6.1 Generating a Merkle Hash Tree\nThe xmss_node function (Algorithm 9) computes the nodes of an XMSS tree. The xmss_node\nfunction takes as input SK.seed and PK.seed from the SLH-DSA private key; a target node index\n𝑖, which is the index of the node being computed; a target node height 𝑧, which is the height\nwithin the Merkle tree of the node being computed; and an address. The address ADRS must\nhave the layer address and tree address set to the XMSS tree within which the node is being\ncomputed. The target node height and index must satisfy 𝑧 ≤ ℎ′ and 𝑖 < 2(ℎ′−𝑧).\nEach node in an XMSS tree is the root of a subtree, and Algorithm 9 computes the root of the\nsubtree recursively. If the subtree consists of a single leaf node, then the function simply returns\nthe value of the node’s WOTS+ public key (lines 2 through 4). Otherwise, the function computes\nthe roots of the left subtree (line 6) and right subtree (line 7) and hashes them together (lines 8\nthrough 11).\n12The Merkle tree formed from the 2ℎ′ WOTS+ keys of an XMSS key is referred to in this standard as an XMSS tree.\n22\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 9 xmss_node(SK.seed, 𝑖, 𝑧, PK.seed, ADRS)\nComputes the root of a Merkle subtree of WOTS+ public keys.\nInput: Secret seed SK.seed, target node index 𝑖, target node height 𝑧, public seed PK.seed,\naddress ADRS.\nOutput: 𝑛-byte root 𝑛𝑜𝑑𝑒.\n1: if 𝑧 = 0 then\n2: ADRS.setTypeAndClear(WOTS_HASH)\n3: ADRS.setKeyPairAddress(𝑖)\n4: 𝑛𝑜𝑑𝑒 ← wots_pkGen(SK.seed, PK.seed, ADRS)\n5: else\n6: 𝑙𝑛𝑜𝑑𝑒 ← xmss_node(SK.seed, 2𝑖, 𝑧 − 1, PK.seed, ADRS)\n7: 𝑟𝑛𝑜𝑑𝑒 ← xmss_node(SK.seed,2𝑖+1,𝑧 −1, PK.seed, ADRS)\n8: ADRS.setTypeAndClear(TREE)\n9: ADRS.setTreeHeight(𝑧)\n10: ADRS.setTreeIndex(𝑖)\n11: 𝑛𝑜𝑑𝑒 ← H(PK.seed, ADRS, 𝑙𝑛𝑜𝑑𝑒 ∥ 𝑟𝑛𝑜𝑑𝑒)\n12: end if\n13: return 𝑛𝑜𝑑𝑒\n6.2 Generating an XMSS Signature\nThe xmss_sign function (Algorithm 10) creates an XMSS signature on an 𝑛-byte message 𝑀13 by\ncreating an authentication path (lines 1 through 4) and signing 𝑀 with the appropriate WOTS+\nkey (lines 5 through 7). In addition to 𝑀, xmss_sign takes SK.seed and PK.seed from the\nSLH-DSA private key, an address, and an index as input. The address ADRS must have the layer\naddress and tree address set to the XMSS key that is being used to sign the message, and the\nindex 𝑖𝑑𝑥 must be the index of the WOTS+ key within the XMSS tree that will be used to sign the\nmessage.\nThe authentication path consists of the sibling nodes of each node that is on the path from\nthe WOTS+ key used to the root. For example, in Figure 12, if the message is signed with 𝐾 ,\n2\nthen 𝐾 , 𝑛 , and 𝑛 are the on path nodes, and the authentication path consists of 𝐾 ,\n2 1,1 2,0 3\n𝑛 , and 𝑛 . In line 2 of Algorithm 10, ⌊𝑖𝑑𝑥/2𝑗⌋ is the on path node, and ⌊𝑖𝑑𝑥/2𝑗⌋ ⊕ 1 is the\n1,0 2,1\nauthentication path node. Line 3 computes the value of the authentication path node.\n13In SLH-DSA, the message 𝑀 that is signed using XMSS is either an XMSS public key or a FORS public key.\n23\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 10 xmss_sign(𝑀, SK.seed, 𝑖𝑑𝑥, PK.seed, ADRS)\nGenerates an XMSS signature.\nInput: 𝑛-byte message 𝑀, secret seed SK.seed, index 𝑖𝑑𝑥, public seed PK.seed,\naddress ADRS.\nOutput: XMSS signature SIG = (𝑠𝑖𝑔 ∥ AUTH).\n𝑋𝑀𝑆𝑆\n1: for 𝑗 from 0 to ℎ′ −1 do ▷ build authentication path\n2: 𝑘 ← ⌊𝑖𝑑𝑥/2𝑗⌋ ⊕ 1\n3: AUTH[𝑗] ← xmss_node(SK.seed, 𝑘, 𝑗, PK.seed, ADRS)\n4: end for\n5: ADRS.setTypeAndClear(WOTS_HASH)\n6: ADRS.setKeyPairAddress(𝑖𝑑𝑥)\n7: 𝑠𝑖𝑔 ← wots_sign(𝑀, SK.seed, PK.seed, ADRS)\n8: SIG ← 𝑠𝑖𝑔 ∥ AUTH\n𝑋𝑀𝑆𝑆\n9: return SIG\n𝑋𝑀𝑆𝑆\n𝑛 = H(𝑛 ∥ 𝑛 )\n3\n\u0010\n,0 \u0010 2,0 P\nP\n2,1\n\u0010 P\n\u0010 P\n\u0010\u0010 PP\n𝑛 = H(𝑛 ∥ 𝑛 ) 𝑛 = H(𝑛 ∥ 𝑛 )\n2,0 1,0 1,1 2,1 1,2 1,3\n� @ � @\n� @ � @\n𝑛 = H(𝐾 ∥ 𝐾 ) 𝑛 = H(𝐾 ∥ 𝐾 ) 𝑛 = H(𝐾 ∥ 𝐾 ) 𝑛 = H(𝐾 ∥ 𝐾 )\n1,0 0 1 1,1 2 3 1,2 4 5 1,3 6 7\n� @ � @ � @ � @\n� @ � @ � @ � @\n𝐾 𝐾 𝐾 𝐾 𝐾 𝐾 𝐾 𝐾\n0 1 2 3 4 5 6 7\nFigure 12. Merkle hash tree\n24\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n6.3 Computing an XMSS Public Key From a Signature\nVerifying an XMSS signature involves computing a public-key value from a message and a signature\nvalue. Verification succeeds if the correct public-key value is computed, which is determined\nby using the computed public-key value along with other information to compute a candidate\nPK.root value and then comparing that value to the known value of PK.root from the SLH-DSA\npublic key. This section describes xmss_pkFromSig (Algorithm 11), a function that computes a\ncandidate XMSS public key from an XMSS signature and corresponding message.\nIn addition to an 𝑛-byte message 𝑀 and an (𝑙𝑒𝑛+ℎ′)⋅𝑛-byte signature SIG , xmss_pkFromSig\n𝑋𝑀𝑆𝑆\ntakes PK.seed from the SLH-DSA public key, an address, and an index as input. The address\nADRS must be set to the layer address and tree address of the XMSS key that was used to sign\nthe message, and the index 𝑖𝑑𝑥 must be the index of the WOTS+ key within the XMSS tree that\nwas used to sign the message.\nAlgorithm 11 begins by computing the WOTS+ public key in lines 1 through 5. The root is then\ncomputed in lines 6 through 18. Starting with the leaf node (i.e., the WOTS+ public key), a\nnode at each level of the tree is computed by hashing together the node computed in the\nprevious iteration with the corresponding authentication path node. In lines 12 and 15, AUTH is\ninterpreted as an array of ℎ′ 𝑛-byte strings.\nAlgorithm 11 xmss_pkFromSig(𝑖𝑑𝑥, SIG , 𝑀, PK.seed, ADRS)\n𝑋𝑀𝑆𝑆\nComputes an XMSS public key from an XMSS signature.\nInput: Index 𝑖𝑑𝑥, XMSS signature SIG = (𝑠𝑖𝑔 ∥ AUTH), 𝑛-byte message 𝑀,\n𝑋𝑀𝑆𝑆\npublic seed PK.seed, address ADRS.\nOutput: 𝑛-byte root value 𝑛𝑜𝑑𝑒[0].\n1: ADRS.setTypeAndClear(WOTS_HASH) ▷ compute WOTS+ pk from WOTS+ 𝑠𝑖𝑔\n2: ADRS.setKeyPairAddress(𝑖𝑑𝑥)\n3: 𝑠𝑖𝑔 ← SIG .getWOTSSig() ▷ SIG [0 ∶ 𝑙𝑒𝑛 ⋅ 𝑛]\n𝑋𝑀𝑆𝑆 𝑋𝑀𝑆𝑆\n4: AUTH ← SIG .getXMSSAUTH() ▷ SIG [𝑙𝑒𝑛 ⋅ 𝑛 ∶ (𝑙𝑒𝑛 + ℎ′) ⋅ 𝑛]\n𝑋𝑀𝑆𝑆 𝑋𝑀𝑆𝑆\n5: 𝑛𝑜𝑑𝑒[0] ← wots_pkFromSig(𝑠𝑖𝑔, 𝑀, PK.seed, ADRS)\n6: ADRS.setTypeAndClear(TREE) ▷ compute root from WOTS+ pk and AUTH\n7: ADRS.setTreeIndex(𝑖𝑑𝑥)\n8: for 𝑘 from 0 to ℎ′ −1 do\n9: ADRS.setTreeHeight(𝑘 + 1)\n10: if ⌊𝑖𝑑𝑥/2𝑘⌋ is even then\n11: ADRS.setTreeIndex(ADRS.getTreeIndex()/2)\n12: 𝑛𝑜𝑑𝑒[1] ← H(PK.seed, ADRS, 𝑛𝑜𝑑𝑒[0] ∥ AUTH[𝑘])\n13: else\n14: ADRS.setTreeIndex((ADRS.getTreeIndex() − 1)/2)\n15: 𝑛𝑜𝑑𝑒[1] ← H(PK.seed, ADRS, AUTH[𝑘] ∥ 𝑛𝑜𝑑𝑒[0])\n16: end if\n17: 𝑛𝑜𝑑𝑒[0] ← 𝑛𝑜𝑑𝑒[1]\n18: end for\n19: return 𝑛𝑜𝑑𝑒[0]\n25",
    "question": "How does the XMSS signature scheme allow a single public key to sign multiple messages using a Merkle tree?",
    "summary": "XMSS is an extended version of the WOTS+ signature scheme that allows signing multiple messages using a single public key. It uses a Merkle tree to authenticate multiple WOTS+ public keys, with the tree's root serving as the XMSS public key. An XMSS signature includes a WOTS+ signature and an authentication path that enables verification by reconstructing the Merkle tree root."
  },
  {
    "start": 23,
    "end": 34,
    "text": "FIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n7. The SLH-DSA Hypertree\nSLH-DSA requires a very large number of WOTS+ keys to sign FORS public keys. As it would\nnot be feasible for the parameter sets in this standard to have a single XMSS key with so many\nWOTS+ keys, SLH-DSA uses a hypertree to sign the FORS keys. As depicted in Figure 1, a hypertree\nis a tree of XMSS trees. The XMSS keys at the lowest layer are used to sign FORS public keys\n(Section 8), and the XMSS keys at every other layer are used to sign the XMSS public keys at the\nlayer below.\nThe hypertree has 𝑑 layers of XMSS trees with each XMSS tree being a Merkle tree of height ℎ′ ,\nso the total height of the hypertree is ℎ = 𝑑 ⋅ℎ′ (see Table 2). The top layer (layer 𝑑 −1) is a\nsingle XMSS tree, and the public key of this XMSS key pair (i.e., the root of the Merkle tree) is the\npublic key of the hypertree (PK.root). The next layer down has 2ℎ′ XMSS trees, and the public\nkey of each of these XMSS keys is signed by one of the 2ℎ′ WOTS+ keys that is part of the top\nlayer’s XMSS key. The lowest layer has 2ℎ−ℎ′ XMSS trees, providing 2ℎ WOTS+ keys to sign FORS\nkeys.\n7.1 Hypertree Signature Generation\nA hypertree signature is (ℎ + 𝑑 ⋅ 𝑙𝑒𝑛) ⋅ 𝑛 bytes in length and consists of a sequence of 𝑑 XMSS\nsignatures, starting with a signature generated using an XMSS key at the lowest layer and ending\nwith a signature generated using the XMSS key at the top layer (see Figure 13).\nXMSS signature SIG (layer 0) (ℎ′ + 𝑙𝑒𝑛) ⋅ 𝑛 bytes\nXMSS\nXMSS signature SIG (layer 1) (ℎ′ + 𝑙𝑒𝑛) ⋅ 𝑛 bytes\nXMSS\n⋯\nXMSS signature SIG (layer 𝑑 − 1) (ℎ′ + 𝑙𝑒𝑛) ⋅ 𝑛 bytes\nXMSS\nFigure 13. HT signature data format\nIn addition to the 𝑛-byte message 𝑀, 14 the ht_sign function (Algorithm 12) takes as input\nSK.seed and PK.seed from the SLH-DSA private key, the index of the XMSS tree at the lowest\nlayer that will sign the message 𝑖𝑑𝑥 , and the index of the WOTS+ key within the XMSS tree\n𝑡𝑟𝑒𝑒\nthat will sign the message 𝑖𝑑𝑥 .\n𝑙𝑒𝑎𝑓\nAlgorithm 12 begins in lines 1 through 3 by signing 𝑀 with the specified XMSS key using the\nWOTS+ key within that XMSS key specified by 𝑖𝑑𝑥 . The XMSS public key is obtained (line 5 or\n𝑙𝑒𝑎𝑓\n14) for each successive layer and signed by the appropriate key at the next higher level (lines 7\nthrough 11).\n14In SLH-DSA, the message 𝑀 that is provided to ht_sign is a FORS public key.\n26\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 12 ht_sign(𝑀, SK.seed, PK.seed, 𝑖𝑑𝑥 , 𝑖𝑑𝑥 )\n𝑡𝑟𝑒𝑒 𝑙𝑒𝑎𝑓\nGenerates a hypertree signature.\nInput: Message 𝑀, private seed SK.seed, public seed PK.seed, tree index 𝑖𝑑𝑥 ,\n𝑡𝑟𝑒𝑒\nleaf index 𝑖𝑑𝑥 .\n𝑙𝑒𝑎𝑓\nOutput: HT signature SIG .\n𝐻𝑇\n1: ADRS ← toByte(0, 32)\n2: ADRS.setTreeAddress(𝑖𝑑𝑥 )\n𝑡𝑟𝑒𝑒\n3: SIG ← xmss_sign(𝑀, SK.seed, 𝑖𝑑𝑥 , PK.seed, ADRS)\n𝑡𝑚𝑝 𝑙𝑒𝑎𝑓\n4: SIG ← SIG\n𝐻𝑇 𝑡𝑚𝑝\n5: 𝑟𝑜𝑜𝑡 ← xmss_pkFromSig(𝑖𝑑𝑥 , SIG , 𝑀, PK.seed, ADRS)\n𝑙𝑒𝑎𝑓 𝑡𝑚𝑝\n6: for 𝑗 from 1 to 𝑑 − 1 do\n7: 𝑖𝑑𝑥 ← 𝑖𝑑𝑥 mod 2ℎ′ ▷ℎ′ least significant bits of 𝑖𝑑𝑥\n𝑙𝑒𝑎𝑓 𝑡𝑟𝑒𝑒 𝑡𝑟𝑒𝑒\n8: 𝑖𝑑𝑥 ← 𝑖𝑑𝑥 ≫ ℎ′ ▷ remove least significant ℎ′ bits from 𝑖𝑑𝑥\n𝑡𝑟𝑒𝑒 𝑡𝑟𝑒𝑒 𝑡𝑟𝑒𝑒\n9: ADRS.setLayerAddress(𝑗)\n10: ADRS.setTreeAddress(𝑖𝑑𝑥 )\n𝑡𝑟𝑒𝑒\n11: SIG ← xmss_sign(𝑟𝑜𝑜𝑡, SK.seed, 𝑖𝑑𝑥 , PK.seed, ADRS)\n𝑡𝑚𝑝 𝑙𝑒𝑎𝑓\n12: SIG ← SIG ∥ SIG\n𝐻𝑇 𝐻𝑇 𝑡𝑚𝑝\n13: if 𝑗 < 𝑑 −1 then\n14: 𝑟𝑜𝑜𝑡 ← xmss_pkFromSig(𝑖𝑑𝑥 , SIG , 𝑟𝑜𝑜𝑡, PK.seed, ADRS)\n𝑙𝑒𝑎𝑓 𝑡𝑚𝑝\n15: end if\n16: end for\n17: return SIG\n𝐻𝑇\n27\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n7.2 Hypertree Signature Verification\nHypertree signature verification works by making 𝑑 calls to xmss_pkFromSig (Algorithm 11) and\ncomparing the result to the public key of the hypertree.\nIn addition to the 𝑛-byte message 𝑀 and the (ℎ+𝑑 ⋅𝑙𝑒𝑛)⋅𝑛-byte signature SIG , ht_verify\n𝐻𝑇\n(Algorithm 13) takes as input PK.seed and PK.root from the SLH-DSA public key, the index of\nthe XMSS tree at the lowest layer that signed the message 𝑖𝑑𝑥 , and the index of the WOTS+\n𝑡𝑟𝑒𝑒\nkey within the XMSS tree that signed the message 𝑖𝑑𝑥 .\n𝑙𝑒𝑎𝑓\nAt each layer, either the message 𝑀 or the computed public key of the XMSS key at the lower\nlayer is provided along with the appropriate XMSS signature to xmss_pkFromSig in order to\nobtain the layer’s computed XMSS public key. If the computed XMSS public key of the top layer\ntree is the same as the known hypertree public key, PK.root, then verification succeeds.\nAlgorithm 13 ht_verify(𝑀, SIG , PK.seed, 𝑖𝑑𝑥 , 𝑖𝑑𝑥 , PK.root)\n𝐻𝑇 𝑡𝑟𝑒𝑒 𝑙𝑒𝑎𝑓\nVerifies a hypertree signature.\nInput: Message 𝑀, signature SIG , public seed PK.seed, tree index 𝑖𝑑𝑥 , leaf index 𝑖𝑑𝑥 ,\n𝐻𝑇 𝑡𝑟𝑒𝑒 𝑙𝑒𝑎𝑓\nHT public key PK.root.\nOutput: Boolean.\n1: ADRS ← toByte(0, 32)\n2: ADRS.setTreeAddress(𝑖𝑑𝑥 )\n𝑡𝑟𝑒𝑒\n3: SIG ← SIG .getXMSSSignature(0) ▷ SIG [0 ∶ (ℎ′ + 𝑙𝑒𝑛) ⋅ 𝑛]\n𝑡𝑚𝑝 𝐻𝑇 𝐻𝑇\n4: 𝑛𝑜𝑑𝑒 ← xmss_pkFromSig(𝑖𝑑𝑥 , SIG , 𝑀, PK.seed, ADRS)\n𝑙𝑒𝑎𝑓 𝑡𝑚𝑝\n5: for 𝑗 from 1 to 𝑑 − 1 do\n6: 𝑖𝑑𝑥 ← 𝑖𝑑𝑥 mod 2ℎ′ ▷ℎ′ least significant bits of 𝑖𝑑𝑥\n𝑙𝑒𝑎𝑓 𝑡𝑟𝑒𝑒 𝑡𝑟𝑒𝑒\n7: 𝑖𝑑𝑥 ← 𝑖𝑑𝑥 ≫ ℎ′ ▷ remove least significant ℎ′ bits from 𝑖𝑑𝑥\n𝑡𝑟𝑒𝑒 𝑡𝑟𝑒𝑒 𝑡𝑟𝑒𝑒\n8: ADRS.setLayerAddress(𝑗)\n9: ADRS.setTreeAddress(𝑖𝑑𝑥 )\n𝑡𝑟𝑒𝑒\n10: SIG ← SIG .getXMSSSignature(𝑗) ▷ SIG [𝑗 ⋅ (ℎ′ + 𝑙𝑒𝑛) ⋅ 𝑛 ∶ (𝑗 + 1)(ℎ′ + 𝑙𝑒𝑛) ⋅ 𝑛]\n𝑡𝑚𝑝 𝐻𝑇 𝐻𝑇\n11: 𝑛𝑜𝑑𝑒 ← xmss_pkFromSig(𝑖𝑑𝑥 , SIG , 𝑛𝑜𝑑𝑒, PK.seed, ADRS)\n𝑙𝑒𝑎𝑓 𝑡𝑚𝑝\n12: end for\n13: if 𝑛𝑜𝑑𝑒 = PK.root then\n14: return true\n15: else\n16: return false\n17: end if\n28\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n8. Forest of Random Subsets (FORS)\nFORS is a few-time signature scheme that is used to sign the digests of the actual messages.\nUnlike WOTS+ , for which forgeries become feasible if a key is used twice [22], the security of a\nFORS key degrades gradually as the number of signatures increases.\nFORS uses two parameters: 𝑘 and 𝑡 = 2𝑎 (see Table 2). A FORS private key consists of 𝑘 sets of 𝑡\n𝑛-byte strings, all of which are pseudorandomly generated from the seed SK.seed. Each of the\n𝑘 sets is formed into a Merkle tree, and the roots of the trees are hashed together to form the\nFORS public key. A signature on a 𝑘 ⋅𝑎-bit message digest consists of 𝑘 elements from the private\nkey, one from each set selected using 𝑎 bits of the message digest, along with the authentication\npaths for each of these elements (see Figure 14).\nprivate key value (tree 0) 𝑛 bytes\nAUTH (tree 0) 𝑎 ⋅ 𝑛 bytes\n⋯\nprivate key value (tree 𝑘 − 1) 𝑛 bytes\nAUTH (tree 𝑘 − 1) 𝑎 ⋅ 𝑛 bytes\nFigure 14. FORS signature data format\n8.1 Generating FORS Secret Values\nThe fors_skGen function (Algorithm 14) generates the 𝑛-byte strings of the FORS private key. The\nfunction takes SK.seed and PK.seed from the SLH-DSA private key, an address, and an index\nas input. The 𝑡𝑦𝑝𝑒 in the address ADRS must be set to FORS_TREE, and the tree address and\nkey pair address must be set to the index of the WOTS+ key within the XMSS tree that signs the\nFORS key. The layer address must be set to zero. The index 𝑖𝑑𝑥 is the index of the FORS secret\nvalue within the sets of FORS trees.\nAlgorithm 14 fors_skGen(SK.seed, PK.seed, ADRS, 𝑖𝑑𝑥)\nGenerates a FORS private-key value.\nInput: Secret seed SK.seed, public seed PK.seed, address ADRS, secret key index 𝑖𝑑𝑥.\nOutput: 𝑛-byte FORS private-key value.\n1: skADRS ← ADRS ▷ copy address to create key generation address\n2: skADRS.setTypeAndClear(FORS_PRF)\n3: skADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n4: skADRS.setTreeIndex(𝑖𝑑𝑥)\n5: return PRF(PK.seed, SK.seed, skADRS)\n29\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n8.2 Generating a Merkle Hash Tree\nThe fors_node function (Algorithm 15) computes the nodes of a Merkle tree. It is the same as\nxmss_node, except that the leaf nodes are the hashes of the FORS secret values instead of WOTS+\npublic keys.\nThe fors_node function takes as input SK.seed and PK.seed from the SLH-DSA private key; a\ntarget node index 𝑖, which is the index of the node being computed; a target node height 𝑧, which\nis the height within the Merkle tree of the node being computed; and an address. The address\nADRS must have the layer address set to zero (since the XMSS tree that signs a FORS key is\nalways at layer 0), the tree address set to the XMSS tree that signs the FORS key, the 𝑡𝑦𝑝𝑒 set to\nFORS_TREE, and the key pair address set to the index of the WOTS+ key within the XMSS tree\nthat signs the FORS key. The target node height and index must satisfy 𝑧 ≤ 𝑎 and 𝑖 < 𝑘 ⋅ 2(𝑎−𝑧).\nEach node in the Merkle tree is the root of a subtree, and Algorithm 15 computes the root of a\nsubtree recursively. If the subtree consists of a single leaf node, then the function simply returns\na hash of the node’s private 𝑛-byte string (lines 2 through 5). Otherwise, the function computes\nthe roots of the left subtree (line 7) and right subtree (line 8) and hashes them together (lines 9\nthrough 11).\nAlgorithm 15 fors_node(SK.seed, 𝑖, 𝑧, PK.seed, ADRS)\nComputes the root of a Merkle subtree of FORS public values.\nInput: Secret seed SK.seed, target node index 𝑖, target node height 𝑧, public seed PK.seed,\naddress ADRS.\nOutput: 𝑛-byte root 𝑛𝑜𝑑𝑒.\n1: if 𝑧 = 0 then\n2: 𝑠𝑘 ← fors_skGen(SK.seed, PK.seed, ADRS, 𝑖)\n3: ADRS.setTreeHeight(0)\n4: ADRS.setTreeIndex(𝑖)\n5: 𝑛𝑜𝑑𝑒 ← F(PK.seed, ADRS, 𝑠𝑘)\n6: else\n7: 𝑙𝑛𝑜𝑑𝑒 ← fors_node(SK.seed, 2𝑖, 𝑧 − 1, PK.seed, ADRS)\n8: 𝑟𝑛𝑜𝑑𝑒 ← fors_node(SK.seed,2𝑖+1,𝑧 −1, PK.seed, ADRS)\n9: ADRS.setTreeHeight(𝑧)\n10: ADRS.setTreeIndex(𝑖)\n11: 𝑛𝑜𝑑𝑒 ← H(PK.seed, ADRS, 𝑙𝑛𝑜𝑑𝑒 ∥ 𝑟𝑛𝑜𝑑𝑒)\n12: end if\n13: return 𝑛𝑜𝑑𝑒\n8.3 Generating a FORS Signature\nThe fors_sign function (Algorithm 16) signs a 𝑘 ⋅ 𝑎-bit message digest 𝑚𝑑. 15 In addition to the\nmessage digest, fors_sign takes SK.seed and PK.seed from the SLH-DSA private key and an\naddress as input. The address ADRS must have the layer address set to zero (since the XMSS\n15For convenience, fors_sign takes a ⌈ 𝑘⋅𝑎 ⌉ byte message digest as input and extracts 𝑘 ⋅ 𝑎 bits to sign.\n8\n30\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\ntree that signs a FORS key is always at layer 0), the tree address set to the XMSS tree that signs\nthe FORS key, the 𝑡𝑦𝑝𝑒 set to FORS_TREE, and the key pair address set to the index of the WOTS+\nkey within the XMSS tree that signs the FORS key.\nThe fors_sign function splits 𝑘⋅𝑎 bits of 𝑚𝑑 into 𝑘 𝑎-bit strings (line 2), each of which is interpreted\nas an integer between 0 and 𝑡 − 1. Each of these integers is used to select a secret value from\none of the 𝑘 sets (line 4). For each secret value selected, an authentication path is computed\nand added to the signature (lines 5 through 9).\nAlgorithm 16 fors_sign(𝑚𝑑, SK.seed, PK.seed, ADRS)\nGenerates a FORS signature.\nInput: Message digest 𝑚𝑑, secret seed SK.seed, address ADRS, public seed PK.seed.\nOutput: FORS signature SIG .\n𝐹 𝑂𝑅𝑆\n1: SIG = NULL ▷ initialize SIG as a zero-length byte string\n𝐹 𝑂𝑅𝑆 𝐹 𝑂𝑅𝑆\n2: 𝑖𝑛𝑑𝑖𝑐𝑒𝑠 ← base_2b(𝑚𝑑, 𝑎, 𝑘)\n3: for 𝑖 from 0 to 𝑘 − 1 do ▷ compute signature elements\n4: SIG ← SIG ∥ fors_skGen(SK.seed, PK.seed, ADRS, 𝑖 ⋅ 2𝑎 + 𝑖𝑛𝑑𝑖𝑐𝑒𝑠[𝑖])\n𝐹 𝑂𝑅𝑆 𝐹 𝑂𝑅𝑆\n5: for 𝑗 from 0 to 𝑎 − 1 do ▷ compute auth path\n6: 𝑠 ← ⌊𝑖𝑛𝑑𝑖𝑐𝑒𝑠[𝑖]/2𝑗⌋ ⊕ 1\n7: AUTH[𝑗] ← fors_node(SK.seed, 𝑖 ⋅ 2𝑎−𝑗 + 𝑠, 𝑗, PK.seed, ADRS)\n8: end for\n9: SIG ← SIG ∥ AUTH\n𝐹 𝑂𝑅𝑆 𝐹 𝑂𝑅𝑆\n10: end for\n11: return SIG\n𝐹 𝑂𝑅𝑆\n8.4 Computing a FORS Public Key From a Signature\nVerifying a FORS signature involves computing a public-key value from a message digest and\na signature value. Verification succeeds if the correct public-key value is computed, which is\ndetermined by verifying the hypertree signature on the computed public-key value using the SLH-\nDSA public key. This section describes fors_pkFromSig (Algorithm 17), a function that computes\na candidate FORS public key from a FORS signature and corresponding message digest.\nIn addition to a message digest 𝑚𝑑 and a 𝑘 ⋅ (𝑎 + 1) ⋅ 𝑛-byte signature SIG , fors_pkFromSig\n𝐹 𝑂𝑅𝑆\ntakes PK.seed from the SLH-DSA public key and an address as input.16 The address ADRS\nmust have the layer address set to zero (since the XMSS tree that signs a FORS key is always at\nlayer 0), the tree address set to the XMSS tree that signs the FORS key, the 𝑡𝑦𝑝𝑒 set to FORS_TREE,\nand the key pair address set to the index of the WOTS+ key within the XMSS tree that signs the\nFORS key.\nThe fors_pkFromSig function begins by computing the roots of each of the 𝑘 Merkle trees (lines\n2 through 20). As in fors_sign, 𝑘 ⋅ 𝑎 bits of the message digest are split into 𝑘 𝑎-bit strings (line\n1), each of which is interpreted as an integer between 0 and 𝑡 − 1. The integers are used to\ndetermine the locations in the Merkle trees of the secret values from the signature (lines 3\n16As with fors_sign, fors_pkFromSig takes a ⌈ 𝑘⋅𝑎 ⌉ byte message digest as input and extracts 𝑘 ⋅ 𝑎 bits.\n8\n31\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nthrough 5). The hashes of the secret values are computed (line 6), and the hash values are used\nalong with the corresponding authentication paths from the signature to compute the Merkle\ntree roots (lines 7 through 19). Once all of the Merkle tree roots have been computed, they are\nhashed together to compute the FORS public key (lines 21 through 24).\nAlgorithm 17 fors_pkFromSig(SIG , 𝑚𝑑, PK.seed, ADRS)\n𝐹 𝑂𝑅𝑆\nComputes a FORS public key from a FORS signature.\nInput: FORS signature SIG , message digest 𝑚𝑑, public seed PK.seed, address ADRS.\n𝐹 𝑂𝑅𝑆\nOutput: FORS public key.\n1: 𝑖𝑛𝑑𝑖𝑐𝑒𝑠 ← base_2b(𝑚𝑑, 𝑎, 𝑘)\n2: for 𝑖 from 0 to 𝑘 − 1 do\n3: 𝑠𝑘 ← SIG .getSK(𝑖) ▷ SIG [𝑖⋅(𝑎+1)⋅𝑛 ∶ (𝑖⋅(𝑎+1)+1)⋅𝑛]\n𝐹 𝑂𝑅𝑆 𝐹𝑂𝑅𝑆\n4: ADRS.setTreeHeight(0) ▷ compute leaf\n5: ADRS.setTreeIndex(𝑖 ⋅ 2𝑎 + 𝑖𝑛𝑑𝑖𝑐𝑒𝑠[𝑖])\n6: 𝑛𝑜𝑑𝑒[0] ← F(PK.seed, ADRS, 𝑠𝑘)\n7: 𝑎𝑢𝑡ℎ ← SIG .getAUTH(𝑖) ▷ SIG [(𝑖⋅(𝑎+1)+1)⋅𝑛 ∶ (𝑖+1)⋅(𝑎+1)⋅𝑛]\n𝐹 𝑂𝑅𝑆 𝐹𝑂𝑅𝑆\n8: for 𝑗 from 0 to 𝑎 − 1 do ▷ compute root from leaf and AUTH\n9: ADRS.setTreeHeight(𝑗 + 1)\n10: if ⌊𝑖𝑛𝑑𝑖𝑐𝑒𝑠[𝑖]/2𝑗⌋ is even then\n11: ADRS.setTreeIndex(ADRS.getTreeIndex()/2)\n12: 𝑛𝑜𝑑𝑒[1] ← H(PK.seed, ADRS, 𝑛𝑜𝑑𝑒[0] ∥ 𝑎𝑢𝑡ℎ[𝑗])\n13: else\n14: ADRS.setTreeIndex((ADRS.getTreeIndex() − 1)/2)\n15: 𝑛𝑜𝑑𝑒[1] ← H(PK.seed, ADRS, 𝑎𝑢𝑡ℎ[𝑗] ∥ 𝑛𝑜𝑑𝑒[0])\n16: end if\n17: 𝑛𝑜𝑑𝑒[0] ← 𝑛𝑜𝑑𝑒[1]\n18: end for\n19: 𝑟𝑜𝑜𝑡[𝑖] ← 𝑛𝑜𝑑𝑒[0]\n20: end for\n21: forspkADRS ← ADRS ▷ copy address to create a FORS public-key address\n22: forspkADRS.setTypeAndClear(FORS_ROOTS)\n23: forspkADRS.setKeyPairAddress(ADRS.getKeyPairAddress())\n24: 𝑝𝑘 ← T (PK.seed, forspkADRS, 𝑟𝑜𝑜𝑡) ▷ compute the FORS public key\n𝑘\n25: return 𝑝𝑘\n32\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n9. SLH-DSA Internal Functions\nSLH-DSA uses the hypertree and the FORS keys to create a stateless hash-based signature scheme.\nThe SLH-DSA private key contains a secret seed value and a secret PRF key. The public key consists\nof a key identifier PK.seed and the root of the hypertree. A signature is created by hashing\nthe message, using part of the message digest to select a FORS key, signing other bits from the\nmessage digest with the FORS key, and generating a hypertree signature for the FORS key. The\nparameters for SLH-DSA are those specified previously for WOTS+ , XMSS, the SLH-DSA hypertree,\nand FORS (see Table 2).\nSLH-DSA uses one additional parameter 𝑚, which is the length in bytes of the message digest. It\nis computed as:\nℎ−ℎ′ ℎ′ 𝑘⋅𝑎\n𝑚 = ⌈ ⌉ + ⌈ ⌉+⌈ ⌉\n8 8 8\nSLH-DSA uses ℎ bits of the message digest to select a FORS key: ℎ − ℎ′ bits to select an XMSS\ntree at the lowest layer and ℎ′ bits to select a WOTS+ key and corresponding FORS key from that\ntree. 𝑘 ⋅ 𝑎 bits of the digest are signed by the selected FORS key. While only ℎ + 𝑘 ⋅ 𝑎 bits of the\nmessage digest are used, implementation is simplified by extracting the necessary bits from a\nslightly larger digest.\nThis section describes the functions for SLH-DSA key generation, signature generation, and\nsignature verification. In the functions in this section, where randomness is required, the random\nvalues are provided as inputs to the functions. The interfaces specified in this section will be used\nwhen testing of SLH-DSA implementations is performed through the Cryptographic Algorithm\nValidation Program (CAVP). The key generation function in this section may also be used to obtain\nthe assurance of private key possession via regeneration, as described in Section 3.1.\nOther than for testing purposes, the interfaces for key generation and signature generation\nspecified in this section should not be made available to applications, as any random values\nrequired for key generation and signature generation shall be generated by the cryptographic\nmodule. Section 10 provides guidance on the interfaces to be made available to applications.\n9.1 SLH-DSA Key Generation\nSLH-DSA public keys contain two elements (see Figure 16). The first is an 𝑛-byte public seed\nPK.seed, which is used in many hash function calls to provide domain separation between\ndifferent SLH-DSA key pairs. The second value is the hypertree public key (i.e., the root of the\ntop layer XMSS tree). PK.seed shall be generated using an approved random bit generator (see\nSK.seed 𝑛 bytes\nSK.prf 𝑛 bytes PK.seed 𝑛 bytes\nPK.seed 𝑛 bytes PK.root 𝑛 bytes\nPK.root 𝑛 bytes\nFigure 15. SLH-DSA private key Figure 16. SLH-DSA public key\n33\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n[14, 15, 16]), where the instantiation of the random bit generator supports at least 8𝑛 bits of\nsecurity strength.\nThe SLH-DSA private key contains two random, secret 𝑛-byte values (see Figure 15). SK.seed is\nused to generate all of the WOTS+ and FORS private key elements. SK.prf is used to generate a\nrandomization value for the randomized hashing of the message in SLH-DSA. The private key\nalso includes a copy of the public key. Both SK.seed and SK.prf shall be generated using an\napproved random bit generator, where the instantiation of the random bit generator supports\nat least 8𝑛 bits of security strength.\nAlgorithm 18 generates an SLH-DSA key pair. Lines 1 through 3 compute the root of the top layer\nXMSS tree. Line 4 bundles the three inputs and the computed PK.seed into the private and\npublic keys.\nSLH-DSA signing has two variants — “hedged” and deterministic (see Section 9.2) — whose keys\nshould only be used for the generation and verification of hedged and deterministic SLH-DSA\ndigital signatures, respectively.\nAlgorithm 18 slh_keygen_internal(SK.seed, SK.prf, PK.seed)\nGenerates an SLH-DSA key pair.\nInput: Secret seed SK.seed, PRF key SK.prf, public seed PK.seed\nOutput: SLH-DSA key pair (SK, PK).\n1: ADRS ← toByte(0, 32) ▷ generate the public key for the top-level XMSS tree\n2: ADRS.setLayerAddress(𝑑 −1)\n3: PK.root ← xmss_node(SK.seed, 0, ℎ′, PK.seed, ADRS)\n4: return ((SK.seed, SK.prf, PK.seed, PK.root), (PK.seed, PK.root) )\n9.2 SLH-DSA Signature Generation\nAn SLH-DSA signature consists of a randomization string, a FORS signature, and a hypertree\nsignature, as shown in Figure 17.\nGenerating an SLH-DSA signature (Algorithm 19) begins by creating an 𝑚-byte message digest\n(lines 2 through 5). A PRF is used to create a message randomizer (line 3), and it is hashed along\nwith the message to create the digest (line 5). Bits are then extracted from the message digest to\nbe signed by the FORS key (line 6), to select an XMSS tree (lines 7 and 9), and to select a WOTS+\nkey and corresponding FORS key within that XMSS tree (lines 8 and 10). Next, the FORS signature\nis computed (lines 11 through 14), and the corresponding FORS public key is obtained (line 16).\nFinally, the FORS public key is signed (line 17).\nRandomness R 𝑛 bytes\nFORS signature SIG 𝑘(1 + 𝑎) ⋅ 𝑛 bytes\nFORS\nHT signature SIG (ℎ + 𝑑 ⋅ 𝑙𝑒𝑛) ⋅ 𝑛 bytes\nHT\nFigure 17. SLH-DSA signature data format\n34\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 19 slh_sign_internal(𝑀, SK, 𝑎𝑑𝑑𝑟𝑛𝑑)\nGenerates an SLH-DSA signature.\nInput: Message 𝑀, private key SK = (SK.seed, SK.prf, PK.seed, PK.root),\n(optional) additional randomness 𝑎𝑑𝑑𝑟𝑛𝑑.\nOutput: SLH-DSA signature SIG.\n1: ADRS ← toByte(0, 32)\n2: 𝑜𝑝𝑡_𝑟𝑎𝑛𝑑 ← 𝑎𝑑𝑑𝑟𝑛𝑑 ▷ substitute 𝑜𝑝𝑡_𝑟𝑎𝑛𝑑 ← PK.seed for the deterministic variant\n3: 𝑅 ← PRF (SK.prf, 𝑜𝑝𝑡_𝑟𝑎𝑛𝑑,𝑀) ▷ generate randomizer\n𝑚𝑠𝑔\n4: SIG ← 𝑅\n5: 𝑑𝑖𝑔𝑒𝑠𝑡 ← H (𝑅, PK.seed, PK.root,𝑀) ▷ compute message digest\n𝑚𝑠𝑔\n6: 𝑚𝑑 ← 𝑑𝑖𝑔𝑒𝑠𝑡 [0 ∶ ⌈𝑘⋅𝑎 ⌉] ▷ first ⌈𝑘⋅𝑎 ⌉ bytes\n8 8\n7: 𝑡𝑚𝑝_𝑖𝑑𝑥 ← 𝑑𝑖𝑔𝑒𝑠𝑡 [⌈𝑘⋅𝑎 ⌉ ∶ ⌈𝑘⋅𝑎 ⌉+⌈ℎ−ℎ/𝑑 ⌉] ▷ next ⌈ℎ−ℎ/𝑑 ⌉ bytes\n𝑡𝑟𝑒𝑒 8 8 8 8\n8: 𝑡𝑚𝑝_𝑖𝑑𝑥 ← 𝑑𝑖𝑔𝑒𝑠𝑡 [⌈𝑘⋅𝑎 ⌉+⌈ℎ−ℎ/𝑑 ⌉ ∶ ⌈𝑘⋅𝑎 ⌉+⌈ℎ−ℎ/𝑑 ⌉ + ⌈ ℎ ⌉] ▷ next ⌈ ℎ ⌉ bytes\n𝑙𝑒𝑎𝑓 8 8 8 8 8𝑑 8𝑑\n9: 𝑖𝑑𝑥 ← toInt (𝑡𝑚𝑝_𝑖𝑑𝑥 , ⌈ℎ−ℎ/𝑑 ⌉) mod 2ℎ−ℎ/𝑑\n𝑡𝑟𝑒𝑒 𝑡𝑟𝑒𝑒 8\n10: 𝑖𝑑𝑥 ← toInt (𝑡𝑚𝑝_𝑖𝑑𝑥 , ⌈ ℎ ⌉) mod 2ℎ/𝑑\n𝑙𝑒𝑎𝑓 𝑙𝑒𝑎𝑓 8𝑑\n11: ADRS.setTreeAddress(𝑖𝑑𝑥 )\n𝑡𝑟𝑒𝑒\n12: ADRS.setTypeAndClear(FORS_TREE)\n13: ADRS.setKeyPairAddress(𝑖𝑑𝑥 )\n𝑙𝑒𝑎𝑓\n14: SIG ← fors_sign(𝑚𝑑, SK.seed, PK.seed, ADRS)\n𝐹 𝑂𝑅𝑆\n15: SIG ← SIG ∥ SIG\n𝐹 𝑂𝑅𝑆\n16: PK ← fors_pkFromSig(SIG , 𝑚𝑑, PK.seed, ADRS) ▷ get FORS key\n𝐹 𝑂𝑅𝑆 𝐹 𝑂𝑅𝑆\n17: SIG ← ht_sign(PK , SK.seed, PK.seed, 𝑖𝑑𝑥 , 𝑖𝑑𝑥 )\n𝐻𝑇 𝐹 𝑂𝑅𝑆 𝑡𝑟𝑒𝑒 𝑙𝑒𝑎𝑓\n18: SIG ← SIG ∥ SIG\n𝐻𝑇\n19: return SIG\n35\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nThe message randomizer may be set in either a non-deterministic or deterministic way, depending\non whether 𝑎𝑑𝑑𝑟𝑛𝑑 is provided as an input. For the “hedged” variant, 𝑎𝑑𝑑𝑟𝑛𝑑 is provided as an\ninput, and 𝑜𝑝𝑡_𝑟𝑎𝑛𝑑 is set to 𝑎𝑑𝑑𝑟𝑛𝑑. The hedged variant is the default and should be used on\nplatforms where side-channel attacks are a concern. When using the hedged version, 𝑎𝑑𝑑𝑟𝑛𝑑\nshall be an 𝑛-byte random value. While 𝑎𝑑𝑑𝑟𝑛𝑑 should ideally be generated by an approved\nrandom bit generator, other methods for generating fresh random values may be used. For\nthe deterministic variant, 𝑎𝑑𝑑𝑟𝑛𝑑 is not provided as an input, and 𝑜𝑝𝑡_𝑟𝑎𝑛𝑑 is set to PK.seed,\nwhich results in signing being deterministic (i.e., signing the same message twice will result in\nthe same signature). The deterministic variant is available for platforms where a random bit\ngenerator is not available.\n9.3 SLH-DSA Signature Verification\nAs with signature generation, SLH-DSA signature verification (Algorithm 20) begins by computing\na message digest (line 8) and then extracting 𝑚𝑑 (line 9), 𝑖𝑑𝑥 (lines 10 and 12), and 𝑖𝑑𝑥\n𝑡𝑟𝑒𝑒 𝑙𝑒𝑎𝑓\n(lines 11 and 13) from the digest. A candidate FORS public key is then computed (line 17), and\nthe signature on the FORS key is verified (line 18). If this signature verification succeeds, then\nthe correct FORS public key was computed, and the signature SIG on message 𝑀 is valid.\nAlgorithm 20 slh_verify_internal(𝑀, SIG, PK)\nVerifies an SLH-DSA signature.\nInput: Message 𝑀, signature SIG, public key PK = (PK.seed, PK.root).\nOutput: Boolean.\n1: if |SIG| ≠ (1+𝑘(1+𝑎)+ℎ+𝑑 ⋅𝑙𝑒𝑛)⋅𝑛 then\n2: return false\n3: end if\n4: ADRS ← toByte(0, 32)\n5: 𝑅 ← SIG.getR() ▷ SIG[0 ∶ 𝑛]\n6: SIG ← SIG.getSIG_FORS() ▷ SIG[𝑛 ∶ (1+𝑘(1+𝑎))⋅𝑛]\n𝐹 𝑂𝑅𝑆\n7: SIG ← SIG.getSIG_HT() ▷ SIG[(1+𝑘(1+𝑎))⋅𝑛 ∶ (1+𝑘(1+𝑎)+ℎ+𝑑 ⋅𝑙𝑒𝑛)⋅𝑛]\n𝐻𝑇\n8: 𝑑𝑖𝑔𝑒𝑠𝑡 ← H (𝑅, PK.seed, PK.root,𝑀) ▷ compute message digest\n𝑚𝑠𝑔\n9: 𝑚𝑑 ← 𝑑𝑖𝑔𝑒𝑠𝑡 [0 ∶ ⌈𝑘⋅𝑎 ⌉] ▷ first ⌈𝑘⋅𝑎 ⌉ bytes\n8 8\n10: 𝑡𝑚𝑝_𝑖𝑑𝑥 ← 𝑑𝑖𝑔𝑒𝑠𝑡 [⌈𝑘⋅𝑎 ⌉ ∶ ⌈𝑘⋅𝑎 ⌉+⌈ℎ−ℎ/𝑑 ⌉] ▷ next ⌈ℎ−ℎ/𝑑 ⌉ bytes\n𝑡𝑟𝑒𝑒 8 8 8 8\n11: 𝑡𝑚𝑝_𝑖𝑑𝑥 ← 𝑑𝑖𝑔𝑒𝑠𝑡 [⌈𝑘⋅𝑎 ⌉+⌈ℎ−ℎ/𝑑 ⌉ ∶ ⌈𝑘⋅𝑎 ⌉+⌈ℎ−ℎ/𝑑 ⌉ + ⌈ ℎ ⌉] ▷ next ⌈ ℎ ⌉ bytes\n𝑙𝑒𝑎𝑓 8 8 8 8 8𝑑 8𝑑\n12: 𝑖𝑑𝑥 ← toInt (𝑡𝑚𝑝_𝑖𝑑𝑥 , ⌈ℎ−ℎ/𝑑 ⌉) mod 2ℎ−ℎ/𝑑\n𝑡𝑟𝑒𝑒 𝑡𝑟𝑒𝑒 8\n13: 𝑖𝑑𝑥 ← toInt (𝑡𝑚𝑝_𝑖𝑑𝑥 , ⌈ ℎ ⌉) mod 2ℎ/𝑑\n𝑙𝑒𝑎𝑓 𝑙𝑒𝑎𝑓 8𝑑\n14: ADRS.setTreeAddress(𝑖𝑑𝑥 ) ▷ compute FORS public key\n𝑡𝑟𝑒𝑒\n15: ADRS.setTypeAndClear(FORS_TREE)\n16: ADRS.setKeyPairAddress(𝑖𝑑𝑥 )\n𝑙𝑒𝑎𝑓\n17: PK ← fors_pkFromSig(SIG , 𝑚𝑑, PK.seed, ADRS)\n𝐹 𝑂𝑅𝑆 𝐹 𝑂𝑅𝑆\n18: return ht_verify(PK , SIG , PK.seed, 𝑖𝑑𝑥 , 𝑖𝑑𝑥 , PK.root)\n𝐹 𝑂𝑅𝑆 𝐻𝑇 𝑡𝑟𝑒𝑒 𝑙𝑒𝑎𝑓\n36\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n10. SLH-DSA External Functions\nThis section provides guidance on the key generation, signature generation, and signature\nverification functions that should be provided for use by applications. The functions in this\nsection use the functions in Section 9 to implement the underlying SLH-DSA scheme.\n10.1 SLH-DSA Key Generation\nAlgorithm 21 generates an SLH-DSA key pair. Lines 1 through 3 generate the random values\nfor the private and public keys, and line 7 calls slh_keygen_internal to compute PK.root and\nreturn the private and public key. PK.seed, SK.seed, and SK.prf shall be generated using an\napproved random bit generator (see [14, 15, 16]), where the instantiation of the random bit\ngenerator supports at least 8𝑛 bits of security strength.\nAlgorithm 21 slh_keygen()\nGenerates an SLH-DSA key pair.\nInput: (none)\nOutput: SLH-DSA key pair (SK, PK).\n1: SK.seed ← $ − 𝔹𝑛 ▷ set SK.seed, SK.prf, and PK.seed to random 𝑛-byte\n2: SK.prf ← $ − 𝔹𝑛 ▷ strings using an approved random bit generator\n3: PK.seed ← $ − 𝔹𝑛\n4: if SK.seed = NULL or SK.prf = NULL or PK.seed = NULL then\n5: return ⊥ ▷ return an error indication if random bit generation failed\n6: end if\n7: return slh_keygen_internal(SK.seed, SK.prf, PK.seed)\n10.2 SLH-DSA Signature Generation\nThis section presents two versions of SLH-DSA signature generation: a “pure” version (slh_sign)\nand a “pre-hash” version (hash_slh_sign). Both versions use slh_sign_internal, but they differ\nin how the message input to slh_sign_internal is created from the content to be signed. In the\npure version, the content is signed by slh_sign_internal along with some domain separation\ninformation. In the pre-hash version, a hash of the content is signed by slh_sign_internal along\nwith some domain separation information.\nBoth versions take the content to be signed, the private key, and a context as input. The pre-hash\nversion also takes as input a hash function or XOF that is to be used to pre-hash the content to\nbe signed. The context string has a maximum length of 255 bytes. By default, the context is the\nempty string. However, applications may specify the use of a non-empty context string.\nThe identifier for a signature (e.g., the object identifier [OID]) should indicate whether the\nsignature is a pure signature or a pre-hash signature. In the case of pre-hash signatures, the\nidentifier should also indicate the hash function or XOF used to compute the pre-hash.17 While\n17In the case of a XOF, this would also include the length of the output from the XOF.\n37\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\na single key pair may be used for both pure and pre-hash signatures, it is recommended that\neach key pair only be used for one version or the other. If a non-empty context string is to be\nused, this should either be indicated by the signature’s identifier or the application with which\nthe signature is being used.\nIf the default hedged variant of slh_sign_internal is used, the 𝑛-byte random value 𝑎𝑑𝑑𝑟𝑛𝑑\nshall be generated by the cryptographic module that runs slh_sign_internal. However, 𝑀′ in\nAlgorithms 22 and 23 may be constructed outside of the crytographic module. In the case of\nhash_slh_sign, the hash or XOF of the content to be signed must be computed within a FIPS\n140-validated cryptographic module, but it may be a different cryptographic module than the\none that runs slh_sign_internal.\nIn general, the pure version is preferred. However, for some cryptographic modules that generate\nSLH-DSA signatures, performing lines 3 and 5 of Algorithm 19 may be infeasible if the message 𝑀\nis large. This may, for example, be the result of the module having limited memory to store the\nmessage to be signed. Similarly, for some cryptographic modules that verify SLH-DSA signatures,\nperforming line 8 of Algorithm 20 may be infeasible if the message 𝑀 is large. For some use\ncases, these issues may be addressed by signing a digest of the content rather than signing the\ncontent directly.\nIn many cases where the content to be signed is large, hashing of the content is performed at\nthe application level. For example, in the Cryptographic Message Syntax [23], a digest of the\ncontent may be computed, and that digest is signed along with other attributes. In cases in\nwhich the content is not hashed at the application level, the pre-hash version of SLH-DSA signing\n(Section 10.2.2) may be used.\nTo maintain the same level of security strength when the content is hashed at the application\nlevel or when using the pre-hash version of SLH-DSA, the digest that is signed needs to be\ngenerated using an approved hash function or XOF (e.g., from FIPS 180-4 [8] or FIPS 202 [6]) that\nprovides at least 8𝑛 bits of classical security strength against both collision and second preimage\nattacks [6, Table 4].18 Verification of a signature created in this way will require the verify function\nto generate a digest from the message in the same way for input to the verification function.\nEven if it is feasible to compute collisions on the hash functions or XOF used to instantiate H ,\n𝑚𝑠𝑔\nPRF, PRF , F, H, and T , there is believed to be no adverse effect on the security of\n𝑚𝑠𝑔 𝑙\nSLH-DSA.19 However, if the input to the signing function is a digest of the content, then collisions\non the function used to compute the digest can result in forged messages.\n10.2.1 Pure SLH-DSA Signature Generation\nIn the pure version, the content to be signed is prepended with a one-byte domain separator,\none byte that indicates the length of the context string, and the context string. The domain\nseparator, which has a value of zero for pure signing, is included to prevent pre-hash signatures\nfrom verifying as pure signatures and vice versa. In the default case in which the context string\n18Obtaining at least 8𝑛 bits of classical security strength against collision attacks requires that the digest to be\nsigned is at least 2𝑛 bytes in length.\n19As noted in Section 11, applications that require message-bound signatures may be adversely affected if it is\nfeasible to compute collisions on H .\n𝑚𝑠𝑔\n38\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nis empty, pure signing simply involves prepending two zero bytes to the content to be signed\nand passing the result to slh_sign_internal along with the private key and, in the case of hedged\nsigning, an 𝑛-byte random value.\nAlgorithm 22 slh_sign(𝑀, 𝑐𝑡𝑥, SK)\nGenerates a pure SLH-DSA signature.\nInput: Message 𝑀, context string 𝑐𝑡𝑥, private key SK.\nOutput: SLH-DSA signature SIG.\n1: if |𝑐𝑡𝑥| > 255 then\n2: return ⊥ ▷ return an error indication if the context string is too long\n3: end if\n4: 𝑎𝑑𝑑𝑟𝑛𝑑 ← $ − 𝔹𝑛 ▷ skip lines 4 through 7 for the deterministic variant\n5: if 𝑎𝑑𝑑𝑟𝑛𝑑 = NULL then\n6: return ⊥ ▷ return an error indication if random bit generation failed\n7: end if\n8: 𝑀′ ← toByte(0, 1) ∥ toByte(|𝑐𝑡𝑥|, 1) ∥ 𝑐𝑡𝑥 ∥ 𝑀\n9: SIG ← slh_sign_internal(𝑀′ , SK, 𝑎𝑑𝑑𝑟𝑛𝑑) ▷ omit 𝑎𝑑𝑑𝑟𝑛𝑑 for the deterministic variant\n10: return SIG\n10.2.2 HashSLH-DSA Signature Generation\nIn the pre-hash version, the message input to slh_sign_internal is the result of applying either a\nhash function or a XOF to the content to be signed. The output of the hash function or XOF is\nprepended by a one-byte domain separator, one byte that indicates the length of the context\nstring, the context string, and the distinguished encoding rules (DER) encoding of the hash\nfunction or XOF’s OID. The domain separator has a value of one for pre-hash signing. The DER\nencoding of the OID includes the tag and length.\nAlgorithm 23 shows the DER encodings of the OIDs for SHA-256, SHA-512, SHAKE128, and\nSHAKE256. However, hash_slh_sign may be used with other hash functions or XOFs. SHA-256\nand SHAKE128 are only appropriate for use with SLH-DSA parameter sets that are claimed to be\nin security category 1 (see Section 11).\n39\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 23 hash_slh_sign(𝑀, 𝑐𝑡𝑥, PH, SK)\nGenerates a pre-hash SLH-DSA signature.\nInput: Message 𝑀, context string 𝑐𝑡𝑥, pre-hash function PH, private key SK.\nOutput: SLH-DSA signature SIG.\n1: if |𝑐𝑡𝑥| > 255 then\n2: return ⊥ ▷ return an error indication if the context string is too long\n3: end if\n4: 𝑎𝑑𝑑𝑟𝑛𝑑 ← $ − 𝔹𝑛 ▷ skip lines 4 through 7 for the deterministic variant\n5: if 𝑎𝑑𝑑𝑟𝑛𝑑 = NULL then\n6: return ⊥ ▷ return an error indication if random bit generation failed\n7: end if\n8: switch PH do\n9: case SHA-256:\n10: OID ← toByte(0x0609608648016503040201, 11) ▷ 2.16.840.1.101.3.4.2.1\n11: PH ← SHA-256(𝑀)\n𝑀\n12: case SHA-512:\n13: OID ← toByte(0x0609608648016503040203, 11) ▷ 2.16.840.1.101.3.4.2.3\n14: PH ← SHA-512(𝑀)\n𝑀\n15: case SHAKE128:\n16: OID ← toByte(0x060960864801650304020B, 11) ▷ 2.16.840.1.101.3.4.2.11\n17: PH ← SHAKE128(𝑀, 256)\n𝑀\n18: case SHAKE256:\n19: OID ← toByte(0x060960864801650304020C, 11) ▷ 2.16.840.1.101.3.4.2.12\n20: PH ← SHAKE256(𝑀, 512)\n𝑀\n21: case … ▷ other approved hash functions or XOFs\n22: …\n23: end switch\n24: 𝑀′ ← toByte(1,1) ∥ toByte(|𝑐𝑡𝑥|, 1) ∥ 𝑐𝑡𝑥 ∥ OID ∥ PH\n𝑀\n25: SIG ← slh_sign_internal(𝑀′, SK, 𝑎𝑑𝑑𝑟𝑛𝑑) ▷ omit 𝑎𝑑𝑑𝑟𝑛𝑑 for the deterministic variant\n26: return SIG\n40\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n10.3 SLH-DSA Signature Verification\nAlgorithms 24 and 25 present the pure and pre-hash versions of SLH-DSA signature verification\nthat correspond to the pure and pre-hash versions of SLH-DSA signature generation in Sec-\ntion 10.2. These functions construct 𝑀′ in the same way as Algorithms 22 and 23, respectively,\nand pass the resulting 𝑀′ to slh_verify_internal for verification. As with signature generation,\n𝑀′ may be constructed outside of the cryptographic module that performs slh_verify_internal.\nHowever, in the case of hash_slh_verify, the hash or XOF of the content must be computed within\na FIPS 140-validated cryptographic module, which may be a different cryptographic module than\nthe one that performs slh_verify_internal.\nThe identifier associated with the signature should indicate whether the pure or pre-hash version\nof signature verification should be used, and in the pre-hash case, the hash function or XOF to\nuse to compute the pre-hash. A non-empty context string should be used in verification if one is\nspecified in the signature’s identifier or by the application with which the signature is being used.\nAlgorithm 24 slh_verify(𝑀, SIG, 𝑐𝑡𝑥, PK)\nVerifies a pure SLH-DSA signature.\nInput: Message 𝑀, signature SIG, context string 𝑐𝑡𝑥, public key PK.\nOutput: Boolean.\n1: if |𝑐𝑡𝑥| > 255 then\n2: return false\n3: end if\n4: 𝑀′ ← toByte(0,1) ∥ toByte(|𝑐𝑡𝑥|, 1) ∥ 𝑐𝑡𝑥 ∥ 𝑀\n5: return slh_verify_internal(𝑀′, SIG, PK)\n41\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 25 hash_slh_verify(𝑀, SIG, 𝑐𝑡𝑥, PH, PK)\nVerifies a pre-hash SLH-DSA signature.\nInput: Message 𝑀, signature SIG, context string 𝑐𝑡𝑥, pre-hash function PH, public key PK.\nOutput: Boolean.\n1: if |𝑐𝑡𝑥| > 255 then\n2: return false\n3: end if\n4: switch PH do\n5: case SHA-256:\n6: OID ← toByte(0x0609608648016503040201, 11) ▷ 2.16.840.1.101.3.4.2.1\n7: PH ← SHA-256(𝑀)\n𝑀\n8: case SHA-512:\n9: OID ← toByte(0x0609608648016503040203, 11) ▷ 2.16.840.1.101.3.4.2.3\n10: PH ← SHA-512(𝑀)\n𝑀\n11: case SHAKE128:\n12: OID ← toByte(0x060960864801650304020B, 11) ▷ 2.16.840.1.101.3.4.2.11\n13: PH ← SHAKE128(𝑀, 256)\n𝑀\n14: case SHAKE256:\n15: OID ← toByte(0x060960864801650304020C, 11) ▷ 2.16.840.1.101.3.4.2.12\n16: PH ← SHAKE256(𝑀, 512)\n𝑀\n17: case … ▷ other approved hash functions or XOFs\n18: …\n19: end switch\n20: 𝑀′ ← toByte(1,1) ∥ toByte(|𝑐𝑡𝑥|, 1) ∥ 𝑐𝑡𝑥 ∥ OID ∥ PH\n𝑀\n21: return slh_verify_internal(𝑀′, SIG, PK)\n42",
    "question": "What is the role of the hypertree in the SLH-DSA digital signature standard and how does it contribute to the signing and verification of FORS public keys?",
    "summary": "SLH-DSA is a stateless hash-based digital signature scheme that uses a hypertree structure and FORS keys. The hypertree allows for signing multiple FORS public keys by using multiple XMSS trees, while FORS is a few-time signature scheme that signs message digests securely even with multiple signatures. SLH-DSA combines these components to generate signatures that are both secure and efficient, with specific functions for key generation, signing, and verification."
  },
  {
    "start": 35,
    "end": 38,
    "text": "FIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n11. Parameter Sets\nThis standard approves 12 parameter sets for use with SLH-DSA. A parameter set consists of\nparameters for WOTS+ (𝑛 and 𝑙𝑔 ), XMSS and the SLH-DSA hypertree (ℎ and 𝑑), and FORS (𝑘\n𝑤\nand 𝑎), as well as instantiations for the functions H , PRF, PRF , F, H, and T .\n𝑚𝑠𝑔 𝑚𝑠𝑔 ℓ\nTable 2 lists the parameter sets that are approved for use.20 Each parameter set name indicates\nthe hash function family (SHA2 or SHAKE) that is used to instantiate the hash functions, the\nlength in bits of the security parameter 𝑛, and whether the parameter set was designed to create\nrelatively small signatures (‘s’) or to have relatively fast signature generation (‘f’). There are six\nsets of values for 𝑛, 𝑙𝑔 , ℎ, 𝑑, 𝑘, and 𝑎 that are approved for use. 21 For each of the six sets of\n𝑤\nvalues, the functions H , PRF, PRF , F, H, and T may be instantiated using either\n𝑚𝑠𝑔 𝑚𝑠𝑔 ℓ\nSHAKE [6] or SHA-2 [8]. For the SHAKE parameter sets, the functions shall be instantiated as\nspecified in Section 11.1. For the SHA2 parameter sets, the functions shall be instantiated as\nspecified in Section 11.2.1 if 𝑛 = 16 and shall be instantiated as specified in Section 11.2.2 if\n𝑛 = 24 or 𝑛 = 32.\nTable 2. SLH-DSA parameter sets\nsecurity pk sig\n𝑛 ℎ 𝑑 ℎ′ 𝑎 𝑘 𝑙𝑔 𝑚 category bytes bytes\n𝑤\nSLH-DSA-SHA2-128s\n16 63 7 9 12 14 4 30 1 32 7 856\nSLH-DSA-SHAKE-128s\nSLH-DSA-SHA2-128f\n16 66 22 3 6 33 4 34 1 32 17 088\nSLH-DSA-SHAKE-128f\nSLH-DSA-SHA2-192s\n24 63 7 9 14 17 4 39 3 48 16 224\nSLH-DSA-SHAKE-192s\nSLH-DSA-SHA2-192f\n24 66 22 3 8 33 4 42 3 48 35 664\nSLH-DSA-SHAKE-192f\nSLH-DSA-SHA2-256s\n32 64 8 8 14 22 4 47 5 64 29 792\nSLH-DSA-SHAKE-256s\nSLH-DSA-SHA2-256f\n32 68 17 4 9 35 4 49 5 64 49 856\nSLH-DSA-SHAKE-256f\nThe 12 parameter sets included in Table 2 were designed to meet certain security strength\ncategories defined by NIST in its original Call for Proposals [25] with respect to existential un-\nforgeability under chosen message attack (EUF-CMA) when each key pair is used to sign at most\n264 messages.2 2 These security strength categories are explained further in SP 800-57, Part 1 [9].\n20SP 800-230 [24] specifies additional parameter sets that are approved for use. While key pairs generated for the\nparameter sets specified in this standard may be used to sign up to 264 messages, key pairs generated for the\nparameter sets in SP 800-230 are more limited in the number of signatures that may be generated.\n21In addition to 𝑛, 𝑙𝑔 , ℎ, 𝑑, 𝑘, and 𝑎, Table 2 also lists values for parameters that may be computed from these\n𝑤\nvalues (ℎ′ , 𝑚, public-key size(pk bytes), and signature size(sig bytes)). The security category is the security\ncategory in which the parameter set is claimed to be [10].\n22If a key pair were used to sign 10 billion (1010) messages per second, it would take over 58 years to sign 264\nmessages.\n43\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nUsing this approach, security strength is not described by a single number, such as “128 bits of\nsecurity.” Instead, each parameter set is claimed to be at least as secure as a generic block cipher\nwith a prescribed key size. More precisely, it is claimed that the computational resources needed\nto break SLH-DSA are greater than or equal to the computational resources needed to break the\nblock cipher when these computational resources are estimated using any realistic model of\ncomputation. Different models of computation can be more or less realistic and, accordingly,\nlead to more or less accurate estimates of security strength. Some commonly studied models\nare discussed in [26].\nConcretely, the parameter sets with 𝑛 = 16 are claimed to be in security category 1, the\nparameter sets with 𝑛 = 24 are claimed to be in security category 3, and the parameter sets with\n𝑛 = 32 are claimed to be in security category 5 [10]. For additional discussion of the security\nstrength of SLH-DSA, see [10, 27].\nSome applications require a property known as message-bound signatures [28, 29], which\nintuitively requires that it be infeasible for anyone to create a public key and a signature that\nare valid for two different messages. Signature schemes are not required to have this property\nunder the EUF-CMA security definition used in assigning security categories. In the case of\nSLH-DSA, the key pair owner could create two messages with the same signature by finding\na collision on H . Due to the length of the output of H , finding such a collision would\n𝑚𝑠𝑔 𝑚𝑠𝑔\nbe expected to require fewer computational resources than specified for the parameter sets’\nclaimed security categories in all cases except SLH-DSA-SHA2-128f and SLH-DSA-SHAKE-128f.23\nTherefore, applications that require message-bound signatures should either take the expected\ncost of finding collisions on H into account when choosing an appropriate parameter set or\n𝑚𝑠𝑔\napply a technique (e.g., the BUFF transformation [29]) to obtain the message-bound signatures\nproperty.\n11.1 SLH-DSA Using SHAKE\nH , PRF, PRF , F, H, and T shall be instantiated as follows for the SLH-DSA-SHAKE-\n𝑚𝑠𝑔 𝑚𝑠𝑔 ℓ\n128s, SLH-DSA-SHAKE-128f, SLH-DSA-SHAKE-192s, SLH-DSA-SHAKE-192f, SLH-DSA-SHAKE-256s,\nand SLH-DSA-SHAKE-256f parameter sets:\nH (𝑅, PK.seed, PK.root,𝑀) = SHAKE256(𝑅 ∥ PK.seed ∥ PK.root ∥ 𝑀,8𝑚)\n𝑚𝑠𝑔\nPRF(PK.seed, SK.seed, ADRS) = SHAKE256(PK.seed ∥ ADRS ∥ SK.seed, 8𝑛)\nPRF (SK.prf, 𝑜𝑝𝑡_𝑟𝑎𝑛𝑑,𝑀) = SHAKE256(SK.prf ∥ 𝑜𝑝𝑡_𝑟𝑎𝑛𝑑 ∥ 𝑀,8𝑛)\n𝑚𝑠𝑔\nF(PK.seed, ADRS, 𝑀 ) = SHAKE256(PK.seed ∥ ADRS ∥ 𝑀 , 8𝑛)\n1 1\nH(PK.seed, ADRS, 𝑀 ) = SHAKE256(PK.seed ∥ ADRS ∥ 𝑀 , 8𝑛)\n2 2\nT (PK.seed, ADRS, 𝑀 ) = SHAKE256(PK.seed ∥ ADRS ∥ 𝑀 , 8𝑛)\nℓ ℓ ℓ\n11.2 SLH-DSA Using SHA2\nIn Sections 11.2.1 and 11.2.2, the functions MGF1-SHA-256 and MGF1-SHA-512 are MGF1 from\nAppendix B.2.1 of RFC 8017 [30], where Hash is SHA-256 or SHA-512, respectively. The functions\n23Finding a collision would be expected to require computing H for approximately 2(ℎ+𝑘⋅𝑎)/2 different mes-\n𝑚𝑠𝑔\nsages.\n44\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nHMAC-SHA-256 and HMAC-SHA-512 are the HMAC function from FIPS 198-1 [31, 32], where 𝐻\nis SHA-256 or SHA-512, respectively.\nThe functions in Sections 11.2.1 and 11.2.2 make use of a compressed version of ADRS (see\nFigure 18). A compressed address (ADRS 𝑐 ) is a 22-byte string that is the same as an ADRS\nwith the exceptions that the encodings of the layer address and type are reduced to one byte\neach and the encoding of the tree address is reduced to eight bytes (i.e., ADRS𝑐 = ADRS[3] ∥\nADRS[8 ∶ 16] ∥ ADRS[19] ∥ ADRS[20 ∶ 32]). For implementations of the SHA2 parameter\nsets that store addresses in compressed form (i.e., 22 bytes), the member functions (Section 4.3)\nare as shown in Table 3 rather than Table 1.\nlayer address 1 byte\ntree address 8 bytes\n𝑡𝑦𝑝𝑒 1 byte\n12 bytes\nFigure 18. Compressed address (ADRS𝑐 )\nTable 3. Member functions for compressed addresses\nMember function Expanded notation\nADRS.setLayerAddress(𝑙) ADRS ← toByte(𝑙, 1) ∥ ADRS[1 ∶ 22]\nADRS.setTreeAddress(𝑡) ADRS ← ADRS[0 ∶ 1] ∥ toByte(𝑡, 8) ∥ ADRS[9 ∶ 22]\nADRS.setTypeAndClear(𝑌) ADRS ← ADRS[0 ∶ 9] ∥ toByte(𝑌 , 1) ∥ toByte(0, 12)\nADRS.setKeyPairAddress(𝑖) ADRS ← ADRS[0 ∶ 10] ∥ toByte(𝑖, 4) ∥ ADRS[14 ∶ 22]\nADRS.setChainAddress(𝑖)\nADRS ← ADRS[0 ∶ 14] ∥ toByte(𝑖, 4) ∥ ADRS[18 ∶ 22]\nADRS.setTreeHeight(𝑖)\nADRS.setHashAddress(𝑖)\nADRS ← ADRS[0 ∶ 18] ∥ toByte(𝑖, 4)\nADRS.setTreeIndex(𝑖)\n𝑖 ← ADRS.getKeyPairAddress() 𝑖 ← toInt(ADRS[10 ∶ 14], 4)\n𝑖 ← ADRS.getTreeIndex() 𝑖 ← toInt(ADRS[18 ∶ 22], 4)\n11.2.1 SLH-DSA Using SHA2 for Security Category 1\nH , PRF, PRF , F, H, and T shall be instantiated as follows for the SLH-DSA-SHA2-128s\n𝑚𝑠𝑔 𝑚𝑠𝑔 ℓ\nand SLH-DSA-SHA2-128f parameter sets:\nH (𝑅, PK.seed, PK.root,𝑀) =\n𝑚𝑠𝑔\nMGF1-SHA-256(𝑅 ∥ PK.seed ∥ SHA-256(𝑅 ∥ PK.seed ∥ PK.root ∥ 𝑀),𝑚)\n45\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nPRF(PK.seed, SK.seed, ADRS) =\nTrunc (SHA-256(PK.seed ∥ toByte(0,64−𝑛) ∥ ADRS𝑐 ∥ SK.seed))\n𝑛\nPRF (SK.prf, 𝑜𝑝𝑡_𝑟𝑎𝑛𝑑,𝑀) =\n𝑚𝑠𝑔\nTrunc (HMAC-SHA-256(SK.prf, 𝑜𝑝𝑡_𝑟𝑎𝑛𝑑 ∥ 𝑀))\n𝑛\nF(PK.seed, ADRS, 𝑀 ) =\n1\nTrunc (SHA-256(PK.seed ∥ toByte(0,64−𝑛) ∥ ADRS𝑐 ∥ 𝑀 ))\n𝑛 1\nH(PK.seed, ADRS, 𝑀 ) =\n2\nTrunc (SHA-256(PK.seed ∥ toByte(0,64−𝑛) ∥ ADRS𝑐 ∥ 𝑀 ))\n𝑛 2\nT (PK.seed, ADRS, 𝑀 ) =\nℓ ℓ\nTrunc (SHA-256(PK.seed ∥ toByte(0,64−𝑛) ∥ ADRS𝑐 ∥ 𝑀 ))\n𝑛 ℓ\n11.2.2 SLH-DSA Using SHA2 for Security Categories 3 and 5\nH , PRF, PRF , F, H, and T shall be instantiated as follows for the SLH-DSA-SHA2-192s,\n𝑚𝑠𝑔 𝑚𝑠𝑔 ℓ\nSLH-DSA-SHA2-192f, SLH-DSA-SHA2-256s, and SLH-DSA-SHA2-256f parameter sets:\nH (𝑅, PK.seed, PK.root,𝑀) =\n𝑚𝑠𝑔\nMGF1-SHA-512(𝑅 ∥ PK.seed ∥ SHA-512(𝑅 ∥ PK.seed ∥ PK.root ∥ 𝑀),𝑚)\nPRF(PK.seed, SK.seed, ADRS) =\nTrunc (SHA-256(PK.seed ∥ toByte(0,64−𝑛) ∥ ADRS𝑐 ∥ SK.seed))\n𝑛\nPRF (SK.prf, 𝑜𝑝𝑡_𝑟𝑎𝑛𝑑,𝑀) =\n𝑚𝑠𝑔\nTrunc (HMAC-SHA-512(SK.prf, 𝑜𝑝𝑡_𝑟𝑎𝑛𝑑 ∥ 𝑀))\n𝑛\nF(PK.seed, ADRS, 𝑀 ) =\n1\nTrunc (SHA-256(PK.seed ∥ toByte(0,64−𝑛) ∥ ADRS𝑐 ∥ 𝑀 ))\n𝑛 1\nH(PK.seed, ADRS, 𝑀 ) =\n2\nTrunc (SHA-512(PK.seed ∥ toByte(0,128−𝑛) ∥ ADRS𝑐 ∥ 𝑀 ))\n𝑛 2\nT (PK.seed, ADRS, 𝑀 ) =\nℓ ℓ\nTrunc (SHA-512(PK.seed ∥ toByte(0,128−𝑛) ∥ ADRS𝑐 ∥ 𝑀 ))\n𝑛 ℓ\n46",
    "question": "What are the 12 parameter sets approved for use in the FIPS 205 stateless hash-based digital signature standard and what do they indicate about their security strength and signature generation characteristics?",
    "summary": "The FIPS 205 standard includes 12 approved parameter sets for use with SLH-DSA, each specifying different hash functions and security categories. These sets are designed to meet security requirements for digital signatures, with some focusing on smaller signatures and others on faster generation. The parameter sets use either SHA2 or SHAKE hash families and are structured to ensure security based on computational resource estimates."
  },
  {
    "start": 39,
    "end": 39,
    "text": "FIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nReferences\n[1] National Institute of Standards and Technology (2023) Digital Signature Standard (DSS).\n(Department of Commerce, Washington, D.C.), Federal Information Processing Standards\nPublications (FIPS) NIST FIPS 186-5. https://doi.org/10.6028/NIST.FIPS.186-5.\n[2] National Institute of Standards and Technology (2024) Guideline for Using Cryptographic\nStandards in the Federal Government: Cryptographic Mechanisms. (National Institute of\nStandards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-175B, Rev.\n2. [Forthcoming: will be available at https://csrc.nist.gov/publications].\n[3] National Institute of Standards and Technology (2024) Recommendation for Obtaining\nAssurances for Digital Signature Applications. (National Institute of Standards and Technol-\nogy, Gaithersburg, MD), NIST Special Publication (SP) 800-89, Rev. 1. [Forthcoming: will be\navailable at https://csrc.nist.gov/publications].\n[4] Aumasson JP, Bernstein DJ, Beullens W, Dobraunig C, Eichlseder M, Fluhrer S, Gazdag\nSL, Hülsing A, Kampanakis P, Kölbl S, Lange T, Lauridsen MM, Mendel F, Niederhagen R,\nRechberger C, Rijneveld J, Schwabe P, Westerbaan B (2020) SPHINCS+ – Submission to the\nNIST post-quantum project, v.3.\n[5] Barker EB, Chen L, Roginsky AL, Vassilev A, Davis R, Simon S (2019) Recommendation for\nPair-Wise Key-Establishment Using Integer Factorization Cryptography. (National Institute\nof Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-56B,\nRev. 2. https://doi.org/10.6028/NIST.SP.800-56Br2.\n[6] National Institute of Standards and Technology (2015) SHA-3 Standard: Permutation-Based\nHash and Extendable-Output Functions. (Department of Commerce, Washington, DC),\nFederal Information Processing Standards Publication (FIPS) NIST FIPS 202. https://doi.org/\n10.6028/NIST.FIPS.202.\n[7] Kelsey JM, Chang SjH, Perlner RA (2016) SHA-3 Derived Functions: cSHAKE, KMAC, Tuple-\nHash and ParallelHash. (National Institute of Standards and Technology, Gaithersburg, MD),\nNIST Special Publication (SP) 800-185. https://doi.org/10.6028/NIST.SP.800-185.\n[8] National Institute of Standards and Technology (2015) Secure Hash Standard (SHS). (De-\npartment of Commerce, Washington, D.C.), Federal Information Processing Standards\nPublication (FIPS) NIST FIPS 180-4. https://doi.org/10.6028/NIST.FIPS.180-4.\n[9] National Institute of Standards and Technology (2024) Recommendation for Key Manage-\nment: Part 1 – General. (National Institute of Standards and Technology, Gaithersburg,\nMD), NIST Special Publication (SP) 800-57 Part 1, Rev 6. [Forthcoming: will be available at\nhttps://csrc.nist.gov/publications].\n[10] Aumasson JP, Bernstein DJ, Beullens W, Dobraunig C, Eichlseder M, Fluhrer S, Gazdag\nSL, Hülsing A, Kampanakis P, Kölbl S, Lange T, Lauridsen MM, Mendel F, Niederhagen R,\nRechberger C, Rijneveld J, Schwabe P, Westerbaan B (2022) SPHINCS+ – Submission to\nthe NIST post-quantum project, v.3.1. Available at https://sphincs.org/data/sphincs+-r3.1-\nspecification.pdf.\n47\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n[11] Hülsing A, Butin D, Gazdag SL, Rijneveld J, Mohaisen A (2018) XMSS: eXtended Merkle\nSignature Scheme. (Internet Research Task Force (IRTF)), IRTF Request for Comments (RFC)\n8391. https://doi.org/10.17487/RFC8391.\n[12] Cooper DA, Apon D, Dang QH, Davidson MS, Dworkin MJ, Miller CA (2020) Recommendation\nfor Stateful Hash-Based Signature Schemes. (National Institute of Standards and Technology,\nGaithersburg, MD), NIST Special Publication (SP) 800-208. https://doi.org/10.6028/NIST.SP.\n800-208.\n[13] Merkle RC (1979) Secrecy, Authentication, and Public Key Systems. Ph.D. thesis. Stanford\nuniversity, .\n[14] Barker EB, Kelsey JM (2015) Recommendation for Random Number Generation Using\nDeterministic Random Bit Generators. (National Institute of Standards and Technology,\nGaithersburg, MD), NIST Special Publication (SP) 800-90A, Rev. 1. https://doi.org/10.6028/\nNIST.SP.800-90Ar1.\n[15] Sönmez Turan M, Barker EB, Kelsey JM, McKay KA, Baish ML, Boyle M (2018) Recom-\nmendation for the Entropy Sources Used for Random Bit Generation. (National Institute\nof Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-90B.\nhttps://doi.org/10.6028/NIST.SP.800-90B.\n[16] Barker EB, Kelsey JM, McKay KA, Roginsky AL, Sönmez Turan M (2022) Recommendation for\nRandom Bit Generator (RBG) Constructions. (National Institute of Standards and Technology,\nGaithersburg, MD), NIST Special Publication (SP) 800-90C 4pd. https://doi.org/10.6028/\nNIST.SP.800-90C.4pd.\n[17] Kannwischer MJ, Genêt A, Butin D, Krämer J, Buchmann J (2018) Differential Power Analysis\nof XMSS and SPHINCS. Constructive Side-Channel Analysis and Secure Design, eds Fan J,\nGierlichs B (Springer International Publishing, Cham), pp 168–188. https://doi.org/10.1007/\n978-3-319-89641-0_10.\n[18] Castelnovi L, Martinelli A, Prest T (2018) Grafting Trees: A Fault Attack Against the SPHINCS\nFramework. Post-Quantum Cryptography, eds Lange T, Steinwandt R (Springer International\nPublishing, Cham), pp 165–184. https://doi.org/10.1007/978-3-319-79063-3_8.\n[19] Genêt A, Kannwischer MJ, Pelletier H, McLauchlan A (2018) Practical Fault Injection Attacks\non SPHINCS, Cryptology ePrint Archive preprint. https://ia.cr/2018/674.\n[20] Amiet D, Leuenberger L, Curiger A, Zbinden P (2020) FPGA-based SPHINCS+ Implementa-\ntions: Mind the Glitch. 2020 23rd Euromicro Conference on Digital System Design (DSD), pp\n229–237. https://doi.org/10.1109/DSD51259.2020.00046.\n[21] Genêt A (2023) On Protecting SPHINCS+ Against Fault Attacks. IACR Transactions on Cryp-\ntographic Hardware and Embedded Systems 2023(2):80–114. https://doi.org/10.46586/\ntches.v2023.i2.80-114.\n[22] Groot Bruinderink L, Hülsing A (2018) “Oops, I Did It Again” – Security of One-Time Signatures\nUnder Two-Message Attacks. Selected Areas in Cryptography – SAC 2017, eds Adams C,\nCamenisch J (Springer International Publishing, Cham), pp 299–322. https://doi.org/10.\n1007/978-3-319-72565-9_15.\n48\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n[23] Housley R (2009) Cryptographic Message Syntax (CMS). (Internet Engineering Task Force\n(IETF)), IETF Request for Comments (RFC) 5652. https://doi.org/10.17487/RFC5652.\n[24] National Institute of Standards and Technology (2024) Recommendation for Additional\nStateless Hash-Based Digital Signature Parameter Sets. (National Institute of Standards and\nTechnology, Gaithersburg, MD), NIST Special Publication (SP) 800-230. [Forthcoming: will\nbe available at https://csrc.nist.gov/publications].\n[25] National Institute of Standards and Technology (2016) Submission Requirements and Eval-\nuation Criteria for the Post-Quantum Cryptography Standardization Process. Available\nat https://csrc.nist.gov/CSRC/media/Projects/Post-Quantum-Cryptography/documents/\ncall-for-proposals-final-dec-2016.pdf.\n[26] Alagic G, Apon D, Cooper DA, Dang QH, Dang T, Kelsey JM, Lichtinger J, Liu YK, Miller CA,\nMoody D, Peralta R, Perlner RA, Robinson A, Smith-Tone D (2022) Status Report on the\nThird Round of the NIST Post-Quantum Cryptography Standardization Process. (National\nInstitute of Standards and Technology, Gaithersburg, MD), NIST Interagency or Internal\nReport (IR) NIST IR 8413-upd1, includes updates as of September 26, 2022. https://doi.org/\n10.6028/NIST.IR.8413-upd1.\n[27] Hülsing A, Kudinov M (2022) Recovering the Tight Security Proof of SPHINCS+ . Advances in\nCryptology – ASIACRYPT 2022, eds Agrawal S, Lin D (Springer Nature Switzerland, Cham),\npp 3–33. https://doi.org/10.1007/978-3-031-22972-5_1.\n[28] Stern J, Pointcheval D, Malone-Lee J, Smart NP (2002) Flaws in Applying Proof Methodologies\nto Signature Schemes. Advances in Cryptology — CRYPTO 2002, ed Yung M (Springer Berlin\nHeidelberg, Berlin, Heidelberg), pp 93–110. https://doi.org/10.1007/3-540-45708-9_7.\n[29] Cremers C, Düzlü S, Fiedler R, Janson C, Fischlin M (2021) BUFFing Signature Schemes\nBeyond Unforgeability and the Case of Post-Quantum Signatures. 2021 IEEE Symposium on\nSecurity and Privacy (SP) (IEEE Computer Society, Los Alamitos, CA, USA), pp 1696–1714.\nhttps://doi.org/10.1109/SP40001.2021.00093.\n[30] Moriarty K, Kaliski B, Jonsson J, Rusch A (2016) PKCS #1: RSA Cryptography Specifications\nVersion 2.2. (Internet Engineering Task Force (IETF)), IETF request for comments (RFC) 8017.\nhttps://doi.org/10.17487/RFC8017.\n[31] National Institute of Standards and Technology (2008) The Keyed-Hash Message Authentica-\ntion Code (HMAC). (Department of Commerce, Washington, DC), Federal Information Pro-\ncessing Standards Publication (FIPS) NIST FIPS 198-1. https://doi.org/10.6028/NIST.FIPS.198-\n1.\n[32] Krawczyk H, Bellare M, Canetti R (1997) HMAC: Keyed-Hashing for Message Authentication.\n(Internet Engineering Task Force (IETF)), IETF request for comments (RFC) 2104. https:\n//doi.org/10.17487/RFC2104.\n[33] Stern M (2021) Re: Diversity of signature schemes. Available at https://groups.google.com/\na/list.nist.gov/g/pqc-forum/c/2LEoSpskELs/m/LkUdQ5mKAwAJ.\n[34] Antonov S (2022) ROUND 3 OFFICIAL COMMENT: SPHINCS+. Available at https://groups.\ngoogle.com/a/list.nist.gov/g/pqc-forum/c/FVItvyRea28/m/mGaRi5iZBwAJ.\n49\nFIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\n[35] Perlner R, Kelsey J, Cooper D (2022) Breaking Category Five SPHINCS+ with SHA-256. Post-\nQuantum Cryptography, eds Cheon JH, Johansson T (Springer International Publishing,\nCham), pp 501–522. https://doi.org/10.1007/978-3-031-17234-2_23.\n50",
    "question": "What is the purpose and significance of the FIPS 205 Stateless Hash-Based Digital Signature Standard?",
    "summary": "FIPS 205 is a stateless hash-based digital signature standard developed by NIST to provide secure digital signatures against quantum computing threats. It builds on cryptographic hash functions like SHA-3 and is designed to be efficient and secure for post-quantum environments. The standard is part of NIST's efforts to standardize quantum-resistant cryptographic algorithms."
  },
  {
    "start": 40,
    "end": 40,
    "text": "FIPS 205 STATELESS HASH-BASED DIGITAL SIGNATURE STANDARD\nAppendix A — Differences From the SPHINCS\n+\nSubmission\nThis standard is based on Version 3.1 of the SPHINCS+ specification [10] and contains several\nminor modifications compared to Version 3 [4], which was submitted at the beginning of round\nthree of the NIST PQC Standardization process:\n• Two new address types — WOTS_PRF and FORS_PRF — were defined for WOTS+ and FORS\nsecret key value generation.\n• PK.seed was added as an input to PRF in order to mitigate multi-key attacks.\n• For the category 3 and 5 SHA2 parameter sets, SHA-256 was replaced by SHA-512 in H ,\n𝑚𝑠𝑔\nPRF , H, and T based on weaknesses that were discovered when using SHA-256 to\n𝑚𝑠𝑔 ℓ\nobtain category 5 security [33, 34, 35].\n• 𝑅 and PK.seed were added as inputs to MGF1 when computing H for the SHA2\n𝑚𝑠𝑔\nparameter sets in order to mitigate multi-target long-message second preimage attacks.\nThis standard also differs from the Version 3 specification in its method for extracting bits from\nthe message digest to select a FORS key. This change was made in order to align with the\nreference implementation that was submitted along with the round three specification. The\ndescription of the method for extracting indices for FORS signature generation and verification\nfrom the message digest was also changed due to ambiguity in the submitted specification. The\nmethod described in this standard is not compatible with the method used in the reference\nimplementation that was submitted along with the round three specification. Additionally, line 6\nin both wots_sign and wots_pkFromSig were changed to match the reference implementation,\nas the pseudocode in [10, 4] will sometimes shift 𝑐𝑠𝑢𝑚 by the incorrect amount when 𝑙𝑔 is not\n𝑤\n4.\nThis standard approves the use of only 12 of the 36 parameter sets defined in [10, 4]. As specified\nin Section 11, only the ‘simple’ instances of the SHA2 and SHAKE parameter sets are approved.\nA.1 Changes From FIPS 205 Initial Public Draft\nThe differences from Version 3 of the SPHINCS+ specification described in Appendix A were\nincluded in the draft version of this standard (FIPS 205 ipd) that was posted on August 24, 2023.\nBased on comments that were submitted on FIPS 205 ipd, the SLH-DSA signature generation and\nverification functions were modified to include domain separation cases in which the message\nis signed directly and in which a digest of the message is signed. The changes were made by\nmodifying the inputs to the signing and verification functions (see Algorithms 22, 23, 24, and\n25).\n51",
    "question": "What are the key differences between the FIPS 205 standard and the SPHINCS+ Version 3 specification?",
    "summary": "The FIPS 205 standard is based on Version 3.1 of the SPHINCS+ specification and includes minor changes such as new address types, added inputs to PRF and MGF1, and adjustments to bit extraction methods. It also approves only 12 of the 36 parameter sets from the original submission, specifically the 'simple' instances of SHA2 and SHAKE. These changes were made to align with the reference implementation and address security concerns."
  }
]