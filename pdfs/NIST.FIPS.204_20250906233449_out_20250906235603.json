[
  {
    "input": "What is the purpose of domain separation in the FIPS 204 module-lattice-based digital signature standard?",
    "summary": "The FIPS 204 standard defines ML-DSA, a lattice-based digital signature algorithm that provides secure signing and verification functions. It includes domain separation to prevent key misuse and ensure security. The standard is applicable to federal agencies for protecting sensitive information and is intended for use in various electronic applications requiring data integrity and authentication.",
    "output": "FIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nthat call an internal function corresponding to the signing or verification functions from the draft FIPS.\nDomain separation is included in the input to the internal function (see Algorithms 2, 3, 4, 5, 7, and 8).\nTo simplify APIs and for testing purposes, this document also introduced a similar external/internal split\nfor key generation (see Algorithms 1 and 6), but this is a purely editorial change, as the external key\ngeneration algorithm is functionally equivalent to the key-generation algorithm from the draft FIPS.\nFinally, to offer misuse resistance against the possibility that keys for different parameter sets might be\nexpanded from the same seed [35], domain separation was added to line 1 of Algorithm 6.\n55\nFIPS 204\nFederal Information Processing Standards Publication\nModule-Lattice-Based Digital\nSignature Standard\nCategory: Computer Security Subcategory: Cryptography\nInformation Technology Laboratory\nNational Institute of Standards and Technology\nGaithersburg, MD 20899-8900\nThis publication is available free of charge from:\nhttps://doi.org/10.6028/NIST.FIPS.204\nPublished August 13, 2024\nU.S. Department of Commerce\nGina M. Raimondo, Secretary\nNational Institute of Standards and Technology\nLaurie E. Locascio, NIST Director and Under Secretary of Commerce for Standards and Technology\nForeword\nThe Federal Information Processing Standards Publication Series of the National Institute of Standards\nand Technology is the official series of publications relating to standards and guidelines developed under\n15 U.S.C. 278g-3, and issued by the Secretary of Commerce under 40 U.S.C. 11331.\nComments concerning this Federal Information Processing Standard publication are welcomed and should\nbe submitted using the contact information in the “Inquiries and comments” clause of the announcement\nsection.\nKevin M. Stine, Director\nInformation Technology Laboratory\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAbstract\nDigital signatures are used to detect unauthorized modifications to data and to authenticate the identity\nof the signatory. In addition, the recipient of signed data can use a digital signature as evidence in\ndemonstrating to a third party that the signature was, in fact, generated by the claimed signatory. This is\nknown as non-repudiation since the signatory cannot easily repudiate the signature at a later time. This\nstandard specifies ML-DSA, a set of algorithms that can be used to generate and verify digital signatures.\nML-DSA is believed to be secure, even against adversaries in possession of a large-scale quantum computer.\nKeywords: cryptography; digital signatures; Federal Information Processing Standards; lattice; post-\nquantum; public-key cryptography.\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nFederal Information Processing Standards Publication 204\nPublished: August 13, 2024\nEffective: August 13, 2024\nAnnouncing the\nModule-Lattice-Based Digital Signature Standard\nFederal Information Processing Standards (FIPS) publications are developed by the National Institute of\nStandards and Technology (NIST) under 15 U.S.C. 278g-3 and issued by the Secretary of Commerce under\n40 U.S.C. 11331.\n1. Name of Standard. Module-Lattice-Based Digital Signature Standard (FIPS 204).\n2. Category of Standard. Computer Security. Subcategory. Cryptography.\n3. Explanation. This standard specifies ML-DSA, a lattice-based digital signature algorithm for applications\nthat require a digital signature rather than a written signature. Additional digital signature schemes are\nspecified and approved in other NIST Special Publications and FIPS publications (e.g., FIPS 186-5 [1]).\nA digital signature is represented in a computer as a string of bits and computed using a set of rules\nand parameters that allow the identity of the signatory and the integrity of the data to be verified.\nDigital signatures may be generated on both stored and transmitted data.\nSignature generation uses a private key to generate a digital signature. Signature verification uses\na public key that corresponds to but is not the same as the private key. Each signatory possesses a\nkey-pair composed of a private key and a corresponding public key. Public keys may be known by\nthe public, but private keys must be kept secret. Anyone can verify the signature by employing the\nsignatory’s public key. Only the user who possesses the private key can generate a signature that can\nbe verified by the corresponding public key.\nThe digital signature is provided to the intended verifier along with the signed data. The verifying\nentity verifies the signature by using the claimed signatory’s public key. Similar procedures may be\nused to generate and verify signatures for both stored and transmitted data.\nThis standard specifies several parameter sets for ML-DSA that are approved for use. Additional\nparameter sets may be specified and approved in future NIST Special Publications.\n4. Approving Authority. Secretary of Commerce.\n5. Maintenance Agency. Department of Commerce, National Institute of Standards and Technology,\nInformation Technology Laboratory (ITL).\n6. Applicability. This standard is applicable to all federal departments and agencies for the protection of\nsensitive unclassified information that is not subject to section 2315 of Title 10, United States Code,\nor section 3502 (2) of Title 44, United States Code. Either this standard, FIPS 205, FIPS 186-5, or NIST\nSpecial Publication 800-208 shall be used in designing and implementing public-key-based signature\nsystems that federal departments and agencies operate or that are operated for them under contract.\nIn the future, additional digital signature schemes may be specified and approved in FIPS or NIST\nSpecial Publications.\nThe adoption and use of this standard are available to private and commercial organizations.\ni\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n7. Applications. A digital signature algorithm allows an entity to authenticate the integrity of signed\ndata and the identity of the signatory. The recipient of a signed message can use a digital signature as\nevidence in demonstrating to a third party that the signature was, in fact, generated by the claimed\nsignatory. This is known as non-repudiation since the signatory cannot easily repudiate the signature\nat a later time. A digital signature algorithm is intended for use in electronic mail, electronic funds\ntransfer, electronic data interchange, software distribution, data storage, and other applications that\nrequire data integrity assurance and data origin authentication.\n8. Implementations. A digital signature algorithm may be implemented in software, firmware, hardware,\nor any combination thereof. NIST will develop a validation program to test implementations for\nconformance to the algorithm in this standard. For every computational procedure that is specified in\nthis standard, a conforming implementation may replace the given set of steps with any mathematically\nequivalent set of steps. In other words, different procedures that produce the correct output for every\ninput are permitted.\nInformation about validation programs is available at https://csrc.nist.gov/projects/cmvp. Examples\nfor digital signature algorithms are available at https://csrc.nist.gov/projects/cryptographic-standards\n-and-guidelines/example-values.\nAgencies are advised that digital signature key pairs shall not be used for other purposes.\n9. Other Approved Security Functions. Digital signature implementations that comply with this standard\nshall employ cryptographic algorithms that have been approved for protecting Federal Government-\nsensitive information. Approved cryptographic algorithms and techniques include those that are\neither:\na. Specified in a Federal Information Processing Standards (FIPS) publication,\nb. Adopted in a FIPS or NIST recommendation, or\nc. Specified in the list of approved security functions in SP 800-140C.\n10. Export Control. Certain cryptographic devices and technical data regarding them are subject to federal\nexport controls. Exports of cryptographic modules that implement this standard and technical data\nregarding them must comply with these federal regulations and be licensed by the Bureau of Industry\nand Security of the U.S. Department of Commerce. Information about export regulations is available\nat https://www.bis.doc.gov.\n11. Patents. The algorithm in this standard may be covered by U.S. or foreign patents.\n12. Implementation Schedule. This standard becomes effective immediately upon final publication.\n13. Specifications. Federal Information Processing Standards (FIPS) 204, Module-Lattice-Based Digital\nSignature Standard (affixed).\n14. Qualifications. The security of a digital signature system depends on maintaining the secrecy of the\nsignatory’s private keys. Signatories shall, therefore, guard against the disclosure of their private\nkeys. While it is the intent of this standard to specify general security requirements for generating\ndigital signatures, conformance to this standard does not ensure that a particular implementation is\nsecure. It is the responsibility of an implementer to ensure that any module that implements a digital\nsignature capability is designed and built in a secure manner.\nSimilarly, the use of a product containing an implementation that conforms to this standard does not\nguarantee the security of the overall system in which the product is used. The responsible authority in\neach agency or department shall ensure that an overall implementation provides an acceptable level\nof security.\nii\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nSince a standard of this nature must be flexible enough to adapt to advancements and innovations in\nscience and technology, this standard will be reviewed every five years in order to assess its adequacy.\n15. Waiver Procedure. The Federal Information Security Management Act (FISMA) does not allow for\nwaivers to Federal Information Processing Standards (FIPS) that are made mandatory by the Secretary\nof Commerce.\n16. Where to Obtain Copies of the Standard. This publication is available by accessing https://csrc.nist.\ngov/publications. Other computer security publications are available at the same website.\n17. How to Cite This Publication. NIST has assigned NIST FIPS 204 as the publication identifier for this\nFIPS, per the NIST Technical Series Publication Identifier Syntax. NIST recommends that it be cited as\nfollows:\nNational Institute of Standards and Technology (2024) Module-Lattice-Based Digital Signa-\nture Standard. (Department of Commerce, Washington, D.C.), Federal Information Pro-\ncessing Standards Publication (FIPS) NIST FIPS 204. https://doi.org/10.6028/NIST.FIPS.204\n18. Inquiries and Comments. Inquiries and comments about this FIPS may be submitted to fips-204-\ncomments@nist.gov.\niii"
  },
  {
    "input": "What is the purpose and security basis of the Module-Lattice-Based Digital Signature Standard (ML-DSA) as defined in FIPS 204?",
    "summary": "The FIPS 204 standard outlines a module-lattice-based digital signature scheme called ML-DSA, which is secure against quantum computing threats. It includes algorithms for key generation, signing, and verification, along with mathematical details and parameter sets. ML-DSA is designed to protect sensitive U.S. government information and can replace other digital signature standards like DSS.",
    "output": "FIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nFederal Information Processing Standards Publication 204\nSpecification for the\nModule-Lattice-Based Digital Signature Standard\nTable of Contents\n1 Introduction 1\n1.1 Purpose and Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1\n1.2 Context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1\n2 Glossary of Terms, Acronyms, and Symbols 2\n2.1 Terms and Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n2.2 Acronyms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n2.3 Mathematical Symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n2.4 Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n2.4.1 Rings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n2.4.2 Vectors andMatrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n2.5 NTT Representation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8\n3 Overview of the ML-DSA Signature Scheme 9\n3.1 Security Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n3.2 Computational Assumptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n3.3 ML-DSA Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n3.4 Hedged and Deterministic Signing . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n3.5 Use of Digital Signatures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n3.6 Additional Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n3.6.1 RandomnessGeneration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n3.6.2 Public-KeyandSignature LengthChecks . . . . . . . . . . . . . . . . . . . . . 12\n3.6.3 Intermediate Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n3.6.4 NoFloating-Point Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n3.7 Use of Symmetric Cryptography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n4 Parameter Sets 15\n5 External Functions 17\n5.1 ML-DSA Key Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n5.2 ML-DSA Signing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n5.3 ML-DSA Verifying . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\niv\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n5.4 Pre-Hash ML-DSA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n5.4.1 HashML-DSASigningandVerifying . . . . . . . . . . . . . . . . . . . . . . . . 19\n6 Internal Functions 22\n6.1 ML-DSA Key Generation (Internal) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n6.2 ML-DSA Signing (Internal) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\n6.3 ML-DSA Verifying (Internal) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n7 Auxiliary Functions 28\n7.1 Conversion Between Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n7.2 Encodings of ML-DSA Keys and Signatures . . . . . . . . . . . . . . . . . . . . . . . . 33\n7.3 Pseudorandom Sampling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36\n7.4 High-Order and Low-Order Bits and Hints . . . . . . . . . . . . . . . . . . . . . . . . 39\n7.5 NTT and NTT− 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\n7.6 Arithmetic Under NTT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45\nReferences 47\nAppendix A — Montgomery Multiplication 50\nAppendix B — Zetas Array 51\nAppendix C — Loop Bounds 52\nAppendix D — Differences from the CRYSTALS-DILITHIUM Submission 54\nD.1 Differences Between Version 3.1 and the Round 3 Version of CRYSTALS-DILITHIUM . . 54\nD.2 Differences Between Version 3.1 of CRYSTALS-DILITHIUM and FIPS 204 Initial Public Draft 54\nD.3 Changes From FIPS 204 Initial Public Draft . . . . . . . . . . . . . . . . . . . . . . . . 54\nv\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nList of Tables\nTable1 ML-DSAparameter sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\nTable2 Sizes (inbytes)ofkeys andsignatures ofML-DSA . . . . . . . . . . . . . . . . . . 16\nTable 3 While loop and XOF output limits for a 2−256 or less probability of failure . . . . . 52\nList of Algorithms\nAlgorithm 1 ML-DSA.KeyGen() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\nAlgorithm 2 ML-DSA.Sign(𝑠𝑘, 𝑀, 𝑐𝑡𝑥) . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\nAlgorithm 3 ML-DSA.Verify(𝑝𝑘, 𝑀, 𝜎, 𝑐𝑡𝑥) . . . . . . . . . . . . . . . . . . . . . . . . . 18\nAlgorithm 4 HashML-DSA.Sign(𝑠𝑘, 𝑀, 𝑐𝑡𝑥, PH) . . . . . . . . . . . . . . . . . . . . . . 20\nAlgorithm 5 HashML-DSA.Verify(𝑝𝑘, 𝑀, 𝜎, 𝑐𝑡𝑥, PH) . . . . . . . . . . . . . . . . . . . . 21\nAlgorithm 6 ML-DSA.KeyGen_internal(𝜉) . . . . . . . . . . . . . . . . . . . . . . . . . . 23\nAlgorithm 7 ML-DSA.Sign_internal(𝑠𝑘, 𝑀′, 𝑟𝑛𝑑) . . . . . . . . . . . . . . . . . . . . . . 25\nAlgorithm 8 ML-DSA.Verify_internal(𝑝𝑘, 𝑀′, 𝜎) . . . . . . . . . . . . . . . . . . . . . . 27\nAlgorithm 9 IntegerToBits(𝑥, 𝛼) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\nAlgorithm 10 BitsToInteger(𝑦, 𝛼) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\nAlgorithm 11 IntegerToBytes(𝑥, 𝛼) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\nAlgorithm 12 BitsToBytes(𝑦) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29\nAlgorithm 13 BytesToBits(𝑧) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29\nAlgorithm 14 CoeffFromThreeBytes(𝑏 , 𝑏 , 𝑏 ) . . . . . . . . . . . . . . . . . . . . . . . . 29\n0 1 2\nAlgorithm 15 CoeffFromHalfByte(𝑏) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30\nAlgorithm 16 SimpleBitPack(𝑤, 𝑏) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30\nAlgorithm 17 BitPack(𝑤, 𝑎, 𝑏) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30\nAlgorithm 18 SimpleBitUnpack(𝑣, 𝑏) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\nAlgorithm 19 BitUnpack(𝑣, 𝑎, 𝑏) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\nAlgorithm 20 HintBitPack(𝐡) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\nAlgorithm 21 HintBitUnpack(𝑦) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\nAlgorithm 22 pkEncode(𝜌, 𝐭 ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\n1\nAlgorithm 23 pkDecode(𝑝𝑘) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\nAlgorithm 24 skEncode(𝜌, 𝐾, 𝑡𝑟, 𝐬 , 𝐬 , 𝐭 ) . . . . . . . . . . . . . . . . . . . . . . . . . . 34\n1 2 0\nAlgorithm 25 skDecode(𝑠𝑘) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34\nAlgorithm 26 sigEncode(𝑐,̃ 𝐳, 𝐡) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\nAlgorithm 27 sigDecode(𝜎) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\nAlgorithm 28 w1Encode(𝐰 ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n1\nAlgorithm 29 SampleInBall(𝜌) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36\nAlgorithm 30 RejNTTPoly(𝜌) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\nAlgorithm 31 RejBoundedPoly(𝜌) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\nAlgorithm 32 ExpandA(𝜌) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38\nAlgorithm 33 ExpandS(𝜌) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38\nAlgorithm 34 ExpandMask(𝜌, 𝜇) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38\nAlgorithm 35 Power2Round(𝑟) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40\nAlgorithm 36 Decompose(𝑟) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40\nAlgorithm 37 HighBits(𝑟) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40\nAlgorithm 38 LowBits(𝑟) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41\nvi\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 39 MakeHint(𝑧, 𝑟) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41\nAlgorithm 40 UseHint(ℎ, 𝑟) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41\nAlgorithm 41 NTT(𝑤) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\nAlgorithm 42 NTT−1(𝑤̂ ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44\nAlgorithm 43 BitRev (𝑚) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44\n8\nAlgorithm 44 AddNTT(𝑎,̂ 𝑏̂ ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45\nAlgorithm 45 MultiplyNTT(𝑎,̂ 𝑏̂ ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45\nAlgorithm 46 AddVectorNTT(𝐯̂ ,𝐰̂ ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45\nAlgorithm 47 ScalarVectorNTT(𝑐,̂ 𝐯̂ ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46\nAlgorithm 48 MatrixVectorNTT(𝐌̂ ,𝐯̂ ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46\nAlgorithm 49 MontgomeryReduce(𝑎) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\nvii\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n1. Introduction\n1.1 Purpose and Scope\nThis standard defines a digital signature scheme, which includes a method for digital signature generation\nthat can be used for the protection of binary data (commonly called a “message”) and a method for the\nverification and validation of those digital signatures. NIST Special Publication (SP) 800-175B [2], Guideline\nfor Using Cryptographic Standards in the Federal Government: Cryptographic Mechanisms, includes a\ngeneral discussion of digital signatures.\nThis standard specifies the mathematical steps that need to be performed for key generation, signature\ngeneration, and signature verification. In order for digital signatures to be valid, additional assurances\nare required, such as assurance of identity and of private key possession. SP 800-89, Recommendation\nfor Obtaining Assurances for Digital Signature Applications [3], specifies the required assurances and the\nmethods for obtaining them.\nThe digital signature scheme approved in this standard is the Module-Lattice-Based Digital Signature\nAlgorithm (ML-DSA), which is based on the Module Learning With Errors problem [4]. ML-DSA is believed\nto be secure, even against adversaries in possession of a large-scale fault-tolerant quantum computer. In\nparticular, ML-DSA is believed to be strongly unforgeable, which implies that the scheme can be used to\ndetect unauthorized modifications to data and to authenticate the identity of the signatory (one bound\nto the possession of the private-key). In addition, a signature generated by this scheme can be used\nas evidence in demonstrating to a third party that the signature was, in fact, generated by the claimed\nsignatory. The latter property is known as non-repudiation since the signatory cannot easily repudiate the\nsignature at a later time.\nThis standard gives algorithms for ML-DSA key generation, signature generation, and signature verification\n(Section 5), and for supporting algorithms used by them (Section 7). ML-DSA is standardized with three\npossible parameter sets, each of which corresponds to a different security strength. Section 4 describes\nthe global parameters used by these algorithms and enumerates the parameter sets for ML-DSA that are\napproved by this standard. ML-DSA can be used in place of other digital signature schemes specified in\nNIST FIPS and Special Publications (e.g., FIPS 186-5, Digital Signature Standard (DSS) [1]).\n1.2 Context\nOver the past several years, there has been steady progress toward building quantum computers. The\nsecurity of many commonly used public-key cryptosystems will be at risk if large-scale quantum computers\nare ever realized. This would include key-establishment schemes and digital signatures that are based on\ninteger factorization and discrete logarithms (both over finite fields and elliptic curves). As a result, in 2016,\nNIST initiated a public Post-Quantum Cryptography (PQC) Standardization process to select quantum-\nresistant public-key cryptographic algorithms for standardization. A total of 82 candidate algorithms were\nsubmitted to NIST for consideration.\nAfter three rounds of evaluation and analysis, NIST selected the first four algorithms for standardization.\nML-DSA is derived from one of the selected schemes, CRYSTALS-DILITHIUM [5, 6], and is intended to protect\nsensitive U.S. Government information well into the foreseeable future, including after the advent of\ncryptographically relevant quantum computers. For the differences between ML-DSA and CRYSTALS-\nDILITHIUM, see Appendix D.\n1"
  },
  {
    "input": "What is the definition of a digital signature in the context of the FIPS 204 Module-Lattice-Based Digital Signature Standard?",
    "summary": "The FIPS 204 standard defines terms and acronyms related to lattice-based digital signatures, including concepts like asymmetric cryptography, key pairs, and security strength. It also outlines mathematical symbols and notations used in the standard, such as rings, vectors, and the Number Theoretic Transform. The standard emphasizes the use of post-quantum cryptographic algorithms to ensure security against quantum computing threats.",
    "output": "FIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n2. Glossary of Terms, Acronyms, and Symbols\n2.1 Terms and Definitions\napproved FIPS-approved and/or NIST-recommended. An algorithm or technique that\nis either 1) specified in a FIPS or NIST recommendation, 2) adopted in a FIPS\nor NIST recommendation, or 3) specified in a list of NIST-approved security\nfunctions.\nassurance of Confidence that an entity possesses a private key and any associated keying\npossession material.\nasymmetric Cryptography that uses two separate keys to exchange data — one to encrypt\ncryptography or digitally sign the data and one to decrypt the data or verify the digital\nsignature. Also known as public-key cryptography.\nbit string An ordered sequence of zeros and ones.\nbyte An integer from the set {0, 1, 2, …, 255}.\nbyte string An ordered sequence of bytes.\ncertificate A set of data that uniquely identifies a public key that has a corresponding\nprivate key and an owner that is authorized to use the key pair. The certificate\ncontains the owner’s public key and possibly other information and is digitally\nsigned by a certification authority (i.e., a trusted party), thereby binding the\npublic key to the owner.\ncertification authority The entity in a public-key infrastructure (PKI) that is responsible for issuing\n(CA) certificates and exacting compliance with a PKI policy.\nclaimed signatory From the verifier’s perspective, the claimed signatory is the entity that pur-\nportedly generated a digital signature.\ndestroy An action applied to a key or a piece of secret data. After a key or a piece of\nsecret data is destroyed, no information about its value can be recovered.\ndigital signature The result of a cryptographic transformation of data that, when properly\nimplemented, provides a mechanism to verify origin authenticity and data\nintegrity and to enforce signatory non-repudiation.\nentity An individual person, organization, device, or process. Used interchangeably\nwith party.\nequivalent process Two processes are equivalent if the same output is produced when the same\nvalues are input to each process (either as input parameters, as values made\navailable during the process, or both).\neXtendable-Output A function on bit strings in which the output can be extended to any desired\nFunction (XOF) length. Approved XOFs (e.g., those specified in FIPS 202 [7]) are designed\nto satisfy the following properties as long as the specified output length is\nsufficiently long to prevent trivial attacks:\n2\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n1. (One-way) It is computationally infeasible to find any input that maps to\nany new pre-specified output.\n2. (Collision-resistant) It is computationally infeasible to find any two dis-\ntinct inputs that map to the same output.\nfresh random value A previously unused output of a random bit generator.\nhash function A function on bit strings in which the length of the output is fixed. Approved\nhash functions (such as those specified in FIPS 180 [8] and FIPS 202 [7]) are\ndesigned to satisfy the following properties:\n1. (One-way) It is computationally infeasible to find any input that maps to\nany new pre-specified output.\n2. (Collision-resistant) It is computationally infeasible to find any two dis-\ntinct inputs that map to the same output.\nhash value See message digest.\nkey A parameter used in conjunction with a cryptographic algorithm that deter-\nmines its operation. Examples of cryptographic algorithms applicable to this\nstandard include:\n1. The computation of a digital signature from data\n2. The verification of a digital signature\nkey pair A public key and its corresponding private key.\nlittle-endian The property of a byte string having its bytes positioned in order of increasing\nsignificance. In particular, the leftmost (first) byte is the least significant,\nand the rightmost (last) byte is the most significant. The term “little-endian”\nmay also be applied in the same manner to bit strings (e.g., the 8-bit string\n11010001 corresponds to the byte 20 + 21 + 23 + 27 = 139).\nmessage The data that is signed. Also known as signed data during the signature\nverification and validation process.\nmessage digest The result of applying a hash function to a message. Also known as a hash\nvalue.\nnon-repudiation A service that is used to provide assurance of the integrity and origin of data\nin such a way that the integrity and origin can be verified and validated by\na third party as having originated from a specific entity in possession of the\nprivate key (i.e., the signatory).\nowner A key pair owner is the entity authorized to use the private key of a key pair.\nparty An individual person, organization, device, or process. Used interchangeably\nwith entity.\npublic-key A framework that is established to issue, maintain, and revoke public key\ninfrastructure (PKI) certificates.\n3\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nprivate key A cryptographic key that is used with an asymmetric (public-key) cryptographic\nalgorithm. The private key is uniquely associated with the owner and is not\nmade public. The private key is used to compute a digital signature that may\nbe verified using the corresponding public key.\npseudorandom A process or data produced by a process is said to be pseudorandom when the\noutcome is deterministic yet also effectively random as long as the internal\naction of the process is hidden from observation. For cryptographic purposes,\n“effectively random” means “computationally indistinguishable from random\nwithin the limits of the intended security strength.”\npublic key A cryptographic key that is used with an asymmetric (public-key) cryptographic\nalgorithm and is associated with a private key. The public key is associated\nwith an owner and may be made public. In the case of digital signatures, the\npublic key is used to verify a digital signature that was generated using the\ncorresponding private key.\nsecurity category A number associated with the security strength of a post-quantum crypto-\ngraphic algorithm, as specified by NIST (see [9, Sect. 5.6]).\nsecurity strength A number associated with the amount of work (i.e., the number of operations)\nthat is required to break a cryptographic algorithm or system.\nseed A bit string used as input to a pseudorandom process.\nshall Used to indicate a requirement of this standard.\nshould Used to indicate a strong recommendation but not a requirement of this\nstandard. Ignoring the recommendation could lead to undesirable results.\nsignatory The entity that generates a digital signature on data using a private key.\nsignature generation The process of using a digital signature algorithm and a private key to generate\na digital signature on data.\nsignature validation The mathematical verification of the digital signature along with obtaining the\nappropriate assurances (e.g., public-key validity, private-key possession, etc.).\nsignature verification The process of using a digital signature algorithm and a public key to verify a\ndigital signature on data.\nsigned data The data or message upon which a digital signature has been computed. Also\nsee message.\ntrusted third party An entity other than the key pair owner and the verifier that is trusted by the\n(TTP) owner, the verifier, or both. Sometimes shortened to “trusted party.”\nverifier The entity that verifies the authenticity of a digital signature using the public\nkey of the signatory.\n4\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n2.2 Acronyms\nAES Advanced Encryption Standard\nAPI Application Programming Interface\nDER Distinguished Encoding Rules\nFIPS Federal Information Processing Standard\nML-DSA Module-Lattice-Based Digital Signature Algorithm\nMLWE Module Learning With Errors\nNIST National Institute of Standards and Technology\nNIST IR NIST Interagency or Internal Report\nNTT Number Theoretic Transform\nOID Object Identifier\nPQC Post-Quantum Cryptography\nRBG Random Bit Generator\nSHA Secure Hash Algorithm\nSHAKE Secure Hash Algorithm KECCAK\nSP Special Publication\nSUF-CMA Strongly existentially UnForgeable under Chosen Message Attack\nXOF eXtendable-Output Function\n2.3 Mathematical Symbols\nThe following symbols and mathematical expressions are used in this standard.\n𝑞 The prime number 𝑞 = 223 −213 +1 = 8380417.\n𝔹 The set {0, 1, … , 255} of integers represented by a byte.\nℕ The set of natural numbers {1, 2, 3, …}.\nℤ The ring of integers.\nℤ The ring of integers modulo 𝑚 whose set of elements is {0,1,…,𝑚 − 1}.\n𝑚\nℤ𝑛 The set of 𝑛-tuples over ℤ equipped with the ℤ-module structure.\n𝑚 𝑚\n𝑅 The ring of single-variable polynomials over ℤ modulo 𝑋256 + 1, also denoted by\nℤ[𝑋]/(𝑋256 + 1).\n𝑅 The ring of single-variable polynomials over ℤ modulo 𝑋256 + 1, also denoted by\n𝑚 𝑚\nℤ [𝑋]/(𝑋256 + 1).\n𝑚\n5\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n𝐵 The set of all polynomials 𝑝 = ∑ 255 𝑝 𝑋𝑖 in 𝑅 that are such that exactly 𝜏 of the\n𝜏 𝑖=0 𝑖 𝑞\ncoefficients of 𝑝 are from the set {−1,1}, and all other coefficients are zero. (See\n𝑖\nSection 7.3.)\nΠ Used to denote a direct product of two or more rings, where addition and multipli-\ncation are performed componentwise.\n𝑇 The ring Π255 ℤ .\n𝑞 𝑗=0 𝑞\n𝐴 × 𝐵 Cartesian product of two sets 𝐴, 𝐵.\n[𝑎, 𝑏] For two integers 𝑎 ≤ 𝑏, [𝑎, 𝑏] denotes the set of integers {𝑎, 𝑎 + 1, … , 𝑏}.\nbitlen 𝑎 The bit length of a positive integer 𝑎. The bit length of 𝑎 is the number of digits that\nwould appear in a base-2 representation of 𝑎, where the most significant digit in\nthe representation is assumed to be a 1 (e.g., bitlen 32 = 6 and bitlen 31 = 5). 1\nBitRev (𝑟) Bit reversal of an 8-bit integer 𝑟. If 𝑟 = 𝑟 +2𝑟 +4𝑟 +…+128𝑟 with 𝑟 ∈ {0, 1},\n8 0 1 2 7 𝑖\nthen BitRev (𝑟) = 𝑟 + 2𝑟 + 4𝑟 + … + 128𝑟 .\n8 7 6 5 0\n0x Prefix to an integer written in hexadecimal representation.\nlog 𝑥 The base 2 logarithm of 𝑥. For example, log (16) = 4.\n2 2\nmod If 𝛼 is a positive integer and 𝑚 ∈ ℤ or 𝑚 ∈ ℤ , then 𝑚 mod 𝛼 denotes the unique\n𝛼\nelement 𝑚′ ∈ ℤ in the range 0 ≤ 𝑚 ′ < 𝛼 such that 𝑚 and 𝑚′ are congruent\nmodulo 𝛼.\nmod± If 𝛼 is a positive integer and 𝑚 ∈ ℤ or 𝑚 ∈ ℤ , then 𝑚 mod±𝛼 denotes the unique\n𝛼\nelement 𝑚′ ∈ ℤ in the range −⌈𝛼/2⌉ < 𝑚 ′ ≤ ⌊𝛼/2⌋ such that 𝑚 and 𝑚′ are\ncongruent modulo 𝛼.\n⌊𝑥⌋ The largest integer less than or equal to the real number 𝑥, called the floor of 𝑥. For\nexample, ⌊2.1⌋ = 2, and ⌊4⌋ = 4.\n⌈𝑥⌉ The least integer greater than or equal to the real number 𝑥, called the ceiling of 𝑥.\nFor example, ⌈5⌉ = 5 and ⌈5.3⌉ = 6.\n‖⋅‖ The infinity norm. For an element 𝑤 ∈ ℤ, ‖𝑤‖ = |𝑤|, the absolute value of\n∞ ∞\n𝑤. For an element 𝑤 ∈ ℤ ,‖𝑤‖ = ∣𝑤 mod±𝑞∣ . For an element 𝑤 of 𝑅 or 𝑅 ,\n𝑞 ∞ 𝑞\n‖𝑤‖ = max ‖𝑤 ‖ . For a length-𝑚 vector 𝐰 with entries from 𝑅 or 𝑅 ,\n∞ 0≤𝑖<256 𝑖 ∞ 𝑞\n‖𝐰‖ = max ‖𝑤[𝑖]‖ .\n∞ 0≤𝑖<𝑚 ∞\n𝑎! The factorial quantity 1 ⋅ 2 ⋅ 3 ⋅ … ⋅ 𝑎. The value 0! is defined as 1.\n(𝑎) For 𝑎 ≥ 𝑏, the quantity 𝑎!/(𝑏!(𝑎 − 𝑏)!).\n𝑏\n𝑠 ← 𝑥 In pseudocode, this notation means that the variable 𝑠 is assigned the value of the\nexpression 𝑥.\n𝑠 ← 𝔹ℓ In pseudocode, this notation means that the variable 𝑠 is assigned the value of an\narray of ℓ random bytes. The bytes must be generated using randomness from an\napproved RBG. See Section 3.6.1.\n1 In this specification, bitlen 𝑎 is only ever called with a small finite number of values for 𝑎, so it may be helpful to\nprecompute bitlen 𝑎 for these values and hard code the results, rather than computing them on the fly.\n6\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n𝑥 ∈ 𝑆 ← 𝑦 Type casting. The variable 𝑥 is assigned a value in a set 𝑆 that is constructed from\nthe value of an expression 𝑦 in a possibly different set 𝑇. The set 𝑇 and the mapping\nfrom 𝑇 to 𝑆 are not explicitly specified, but they should be obvious from the context\nin which this statement appears.\n[[𝑎 < 𝑏]] A Boolean predicate. A comparison operator inside double square brackets [[𝑎 < 𝑏]]\ndenotes that the expression should be evaluated as a Boolean. Booleans can also\nbe interpreted as elements of ℤ with 1 denoting true and 0 denoting false.\n2\n⟨⟨𝑓(𝑥)⟩⟩ A temporary variable that stores the output of a computation 𝑓(𝑥) so that it can be\nused many times without needing to be recomputed. This is equivalent to defining a\ntemporary variable 𝑦 ← 𝑓(𝑥). Naming the variable ⟨⟨𝑓(𝑥)⟩⟩ makes the pseudocode\nless cluttered.\n𝑎||𝑏 Concatenation of two bit or byte strings 𝑎 and 𝑏.\n𝑎 ∘ 𝑏 Multiplication of 𝑎 and 𝑏 in the ring 𝑇 .\n𝑞\n𝑎 ⋅ 𝑏 or 𝑎𝑏 Multiplication in any of the rings ℤ, ℤ , 𝑅, or 𝑅 .\n𝑚 𝑚\n𝑎 + 𝑏 Addition of 𝑎 and 𝑏.\n𝑎/𝑏 Division of integers. When this notation is used, 𝑎 and 𝑏 are always integers. If 𝑏\ncannot be assumed to divide 𝑎, then either ⌊𝑎/𝑏⌋ or ⌈𝑎/𝑏⌉ is used.\n⊥ Blank symbol that indicates failure or the lack of an output from an algorithm.\n2.4 Notation\n2.4.1 Rings\nElements of the rings ℤ, ℤ , ℤ , 𝑅, and 𝑅 are denoted by italicized lowercase letters (e.g., 𝑤). Elements\n𝑞 2 𝑞\nof the ring 𝑇 are length-256 arrays of elements of ℤ , and they are denoted by italicized letters with a\n𝑞 𝑞\nhat symbol (e.g., 𝑤̂). The addition and multiplication of elements of 𝑇 are performed entry-wise. Thus,\n𝑞\nthe 𝑖th entry of the product of two elements 𝑢̂ and 𝑣̂ of 𝑇 is 𝑢̂[𝑖] ⋅ 𝑣[̂ 𝑖] ∈ ℤ . The multiplication operation\n𝑞 𝑞\nin 𝑇 is denoted by the symbol ∘ (see Section 2.3).\n𝑞\nWhen a product 𝑎 ⋅ 𝑏 or a sum 𝑎 + 𝑏 is written and either 𝑎 or 𝑏 is a congruence class modulo 𝑚 (i.e., if\neither 𝑎 or 𝑏 is an element of ℤ or 𝑅 ), then the product or sum is also understood to be a congruence\n𝑚 𝑚\nclass modulo 𝑚 (i.e., an element of ℤ or 𝑅 ). Likewise, an element of 𝑅 or ℤ may be “typecast” to an\n𝑚 𝑚\nelement of 𝑅 or ℤ , respectively, and may be used as the input of a function specified to act on an\n𝑚 𝑚\nelement of 𝑅 or ℤ , respectively. In both cases, the element itself or its coefficients are mapped from\n𝑚 𝑚\nℤ to ℤ by taking the unique congruence class modulo 𝑚 that contains the integer.\n𝑚\nThe coefficients of an element 𝑤 of 𝑅 or 𝑅 are denoted by 𝑤 so that 𝑤 = 𝑤 +𝑤 𝑋+…+𝑤 𝑋255 .\n𝑚 𝑖 0 1 255\nIf 𝑤 is in 𝑅 (respectively, 𝑅 ) and 𝑡 is in ℤ (respectively, ℤ ), then 𝑤(𝑡) denotes the polynomial 𝑤 =\n𝑚 𝑑\n𝑤 + 𝑤 𝑋 + … + 𝑤 𝑋255 evaluated at 𝑋 = 𝑡.\n0 1 255\n2.4.2 Vectors and Matrices\nVectors with elements in 𝑅 or 𝑅 are denoted by bold lowercase letters (e.g., 𝐯). Matrices with elements\n𝑚\nin 𝑅 or 𝑅 are denoted by bold uppercase letters (e.g., 𝐀).\n𝑚\n7\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nIf 𝑆 is a ring and 𝐯 is a length-𝐿 vector over 𝑆, then the entries in the vector 𝐯 are expressed as\n𝑣[0], 𝑣[1], … , 𝑣[𝐿 − 1].\nThe entries of a 𝐾 ×𝐿 matrix 𝐀 over 𝑆 are denoted as 𝐀[𝑖, 𝑗], where 0 ≤ 𝑖 < 𝐾 and 0 ≤ 𝑗 < 𝐿.\nThe set of all length-𝐿 vectors over 𝑆 is denoted by 𝑆𝐿 . The set of all 𝐾 ×𝐿 matrices over 𝑆 is denoted\nby 𝑆𝐾×𝐿 . A length-𝐿 vector can also be treated as an 𝐿 × 1 matrix.\n2.5 NTT Representation\nThe Number Theoretic Transform (NTT) is a specific isomorphism between the rings 𝑅 and 𝑇 . Let\n𝑞 𝑞\n𝜁 = 1753 ∈ ℤ , which is a 512th root of unity. If 𝑤 ∈ 𝑅 , then\n𝑞 𝑞\nNTT(𝑤) = (𝑤(𝜁 ),𝑤(𝜁 ),…,𝑤(𝜁 )) ∈ 𝑇 , (2.1)\n0 1 255 𝑞\nwhere 𝜁 𝑖 = 𝑤(𝜁2BitRev 8 (𝑖)+1) mod 𝑞. See Section 7.5 for an implementation discussion for NTT and NTT−1 .\nThe motivation for using NTT is that multiplication is considerably faster in the ring 𝑇 . Since NTT is an\n𝑞\nisomorphism, for any 𝑎, 𝑏 ∈ 𝑅 ,\n𝑞\nNTT(𝑎𝑏) = NTT(𝑎) ∘ NTT(𝑏). (2.2)\nIf 𝐀 is a matrix with entries from 𝑅 , then NTT(𝐀) denotes the matrix computed via the entry-wise\n𝑞\napplication of NTT to 𝐀. The symbol ∘ is also used to denote the matrix multiplication of matrices with\nentries in 𝑇 . Thus, NTT(𝐀𝐁) = NTT(𝐀) ∘ NTT(𝐁). Explicit algorithms for linear algebra over 𝑇 are\n𝑞 𝑞\ngiven in Section 7.6.\n8"
  },
  {
    "input": "What is ML-DSA and how does it differ from the standard Schnorr signature scheme in terms of its construction, security properties, and use of lattice-based cryptographic assumptions?",
    "summary": "ML-DSA is a lattice-based digital signature scheme based on CRYSTALS-DILITHIUM, using a Schnorr-like protocol with optimizations. It includes a variant called HashML-DSA that adds a pre-hashing step before signing. The scheme relies on the MLWE and SelfTargetMSIS problems for security and incorporates rejection sampling to correct biases in the signing process. Additionally, it requires secure randomness generation and avoids floating-point arithmetic to ensure correctness and prevent errors.",
    "output": "FIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n3. Overview of the ML-DSA Signature Scheme\nML-DSA is a digital signature scheme based on CRYSTALS-DILITHIUM [6]. It consists of three main algorithms:\nML-DSA.KeyGen (Algorithm 1), ML-DSA.Sign (Algorithm 2), and ML-DSA.Verify (Algorithm 3). The\nML-DSA scheme uses the Fiat-Shamir With Aborts construction [10, 11] and bears the most resemblance\nto the schemes proposed in [12, 13].\nThis document also defines a closely related but domain-separated signature scheme, HashML-DSA, which\ndiffers from ML-DSA in that it includes an additional pre-hashing step before signing. It consists of three\nmain algorithms: ML-DSA.KeyGen (Algorithm 1), which is the same key generation algorithm used for\nML-DSA; HashML-DSA.Sign (Algorithm 4); and HashML-DSA.Verify (Algorithm 5).\n3.1 Security Properties\nML-DSA is designed to be strongly existentially unforgeable under chosen message attack (SUF-CMA).\nThat is, it is expected that even if an adversary can get the honest party to sign arbitrary messages, the\nadversary cannot create any additional valid signatures based on the signer’s public key, including on\nmessages for which the signer has already provided a signature.\nBeyond unforgeability, ML-DSA is designed to satisfy additional security properties described in [14].\n3.2 Computational Assumptions\nSecurity for lattice-based digital signature schemes is typically related to the Learning With Errors (LWE)\nproblem and the short integer solution (SIS) problem. The LWE problem [15] is to recover a vector 𝐬 ∈ ℤ𝑛\n𝑞\ngiven a set of random “noisy” linear equations2 satisfied by 𝐬. The SIS problem is to find a non-zero solution\n𝐭 ∈ ℤ𝑛 for a given linear system over ℤ of the form 𝐀𝐭 = 𝟎 such that ‖𝐭‖ is small. For appropriate\n𝑞 𝑞 ∞\nchoices of parameters, these problems are intractable for the best known techniques, including Gaussian\nelimination.\nWhen the module ℤ𝑛 in LWE and SIS is replaced by a module over a ring larger than ℤ (e.g., 𝑅 ), the\n𝑞 𝑞 𝑞\nresulting problems are called Module Learning With Errors (MLWE) [4] and Module Short Integer Solution\n(MSIS). The security of ML-DSA is based on the MLWE problem over 𝑅 and a nonstandard variant of\n𝑞\nMSIS called SelfTargetMSIS [16].\n3.3 ML-DSA Construction\nML-DSA is a Schnorr-like signature with several optimizations. The Schnorr signature scheme applies the\nFiat-Shamir heuristic to an interactive protocol between a verifier who knows 𝑔 (the generator of a group in\nwhich discrete logs are believed to be difficult) and the value 𝑦 = 𝑔𝑥 and a prover who knows 𝑔 and 𝑥. The\ninteractive protocol, where the prover demonstrates knowledge of 𝑥 to the verifier, consists of three steps:\n1. Commitment: The prover generates a random positive integer 𝑟 that is less than the order of 𝑔 and\ncommits to its value by sending 𝑔𝑟 to the verifier.\n2. Challenge: The verifier sends a random positive integer 𝑐 that is less than the order of 𝑔 to the\nprover.\n2Specifically, the LWE problem is to solve a system of equations of the form 𝐀𝐬+𝐞 = 𝑏, where 𝐀 and 𝑏 are given\nand 𝐞 is not given but known to be small.\n9\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n3. Response: The prover returns 𝑠 = 𝑟 −𝑐𝑥 reduced modulo the order of 𝑔, and the verifier checks\nwhether 𝑔𝑠 ⋅ 𝑦𝑐 = 𝑔𝑟 .\nThis protocol is made noninteractive and turned into a signature scheme by replacing the verifier’s random\nchoice of 𝑐 in step 2 with a deterministic process that pseudorandomly derives 𝑐 from a hash of the\ncommitment 𝑔𝑟 concatenated with the message to be signed. For this signature scheme, 𝑦 is the public\nkey, and 𝑥 is the private key.\nThe basic idea of ML-DSA and similar lattice signature schemes is to build a signature scheme from\nan analogous interactive protocol, where a prover who knows matrices 𝐀 ∈ ℤ𝐾×𝐿, 𝐒 ∈ ℤ𝐿×𝑛 , and\n𝑞 1 𝑞\n𝐒 ∈ ℤ𝐾×𝑛with small coefficients (for 𝐒 and 𝐒 ) demonstrates knowledge of these matrices to a verifier\n2 𝑞 1 2\nwho knows 𝐀 and 𝐓 ∈ ℤ𝐾×𝑛 = 𝐀𝐒 + 𝐒 . Such an interactive protocol would proceed as follows:\n𝑞 1 2\n1. Commitment: The prover generates 𝐲 ∈ ℤ𝐿 with small coefficients and commits to its value by\n𝑞\nsending 𝐰 = 𝐀𝐲 + 𝐲 to the verifier, where 𝐲 ∈ ℤ𝐾 is a vector with small coefficients.\nApprox 2 2 𝑞\n2. Challenge: The verifier sends a vector 𝐜 ∈ ℤ𝑛 with small coefficients to the prover.\n𝑞\n3. Response: The prover returns 𝐳 = 𝐲+𝐒 𝐜, and the verifier checks that 𝐳 has small coefficients\n1\nand that 𝐀𝐳 − 𝐓𝐜 ≈ 𝐰 .\nApprox\nAs written, the above protocol has a security flaw: the response 𝐳 will be biased in a direction related\nto the private value 𝐒 . Likewise 𝐫 = 𝐰 − 𝐀𝐳 + 𝐓𝐜 = 𝐲 + 𝐒 𝐜 is biased in a direction related\n1 Approx 2 2\nto the private value 𝐒 . However, this flaw can be corrected when converting the interactive protocol\n2\ninto a signature scheme. As with Schnorr signatures, the signer derives the challenge by a pseudorandom\nprocess from a hash of the commitment concatenated with the message. To correct the bias, the signer\napplies rejection sampling to 𝐳; if coefficients of 𝐳 fall outside of a specified range, the signing process is\naborted, and the signer starts over from a new value of 𝐲. Likewise, similar rejection sampling must also\nbe applied to 𝐫. These checks are analogous to those done at Line 23 of Algorithm 7. In the simplified\nFiat-Shamir With Aborts signature, the public key is (𝐀, 𝐓), and the private key is (𝐒 , 𝐒 ).\n1 2\nIn the ML-DSA standard, a number of tweaks and modifications are added to this basic framework for\nsecurity or efficiency reasons:\n• To reduce key and signature size and to use fast NTT-based polynomial multiplication, ML-DSA\nuses module-structured matrices. Relative to the basic scheme described above, it replaces\ndimension-𝑛 × 𝑛 blocks of matrices and dimension-𝑛 blocks of vectors with polynomials in the ring\n𝑅 . Thus, instead of 𝐀 ∈ ℤ𝐾×𝐿 , 𝐓 ∈ ℤ𝐾×𝑛 , 𝐒 ∈ ℤ𝐿×𝑛 , 𝐒 ∈ ℤ𝐾×𝑛 , 𝐲 ∈ ℤ𝐿, 𝐜 ∈ ℤ𝑛 , ML-DSA\n𝑞 𝑞 𝑞 1 𝑞 𝟐 𝑞 𝑞 𝑞\nhas 𝐀 ∈ 𝑅𝑘×ℓ , 𝐭 ∈ 𝑅𝑘 , 𝐬 ∈ 𝑅ℓ , 𝐬 ∈ 𝑅𝑘 , 𝐲 ∈ 𝑅ℓ , 𝑐 ∈ 𝑅 , where ℓ = 𝐿/𝑛 and 𝑘 = 𝐾/𝑛.\n𝑞 𝑞 1 𝑞 2 𝑞 𝑞 𝑞\n• To further reduce the size of the public key, the matrix 𝐀 is pseudorandomly derived from a 256-bit\npublic seed 𝜌, which is included in the ML-DSA public key in place of 𝐀.\n• For a still further reduction in public key size, the ML-DSA public key substitutes a compressed\nvalue 𝐭 for 𝐭, which drops the 𝑑 low-order bits of each coefficient.\n1\n• To obtain beyond unforgeability (BUFF) properties noted in [14], ML-DSA does not directly sign\nthe message 𝑀 but rather signs a message representative 𝜇 that is obtained by hashing the\nconcatenation of a hash of the public key and 𝑀.\n10\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n• To reduce signature size, rather than including the commitment 𝐰 = 𝐀𝐲+𝐲 in the signature,\nApprox 2\nthe ML-DSA signature uses a rounded version of 𝐰 = 𝐀𝐲 as a commitment 𝐰 and includes only\n1\nthe hash 𝑐 ̃of 𝐰 ||𝜇.\n1\n• To ensure that 𝐰 can be reconstructed by the verifier from 𝐳 and the compressed value 𝐭 , the\n1 1\nsignature must also include a hint 𝐡 ∈ 𝑅𝑘 computed by the signer using the signer’s private key.\n2\n• Additionally, to ensure correctness, a second stage of rejection sampling must be included (Line 28\nof Algorithm 7)\nIn this document, the abbreviations ML-DSA-44, ML-DSA-65, and ML-DSA-87 are used to refer to ML-DSA\nwith the parameter choices given in Table 1. In these abbreviations, the numerical suffix refers to the\ndimension of the matrix 𝐀. For example, in ML-DSA-65, the matrix 𝐀 is a 6×5 matrix over 𝑅 .\n𝑞\n3.4 Hedged and Deterministic Signing\nFor ML-DSA to be secure, the signer’s commitment value 𝐲 must not be used to sign more than one\nmessage, and it must not be easily guessed by an attacker. This requires randomness. In principle, the\nrandomness leading to 𝐲 can be produced either with the use of fresh randomness at signing time or\npseudorandomly from the message being signed and a precomputed random value included in the signer’s\nprivate key.\nBy default, this standard specifies the signing algorithm to use both types of randomness. This is referred\nto as the “hedged” variant of the signing procedure. The use of fresh randomness during signing helps\nmitigate side-channel attacks, while the use of precomputed randomness protects against the possibility\nthat there may be flaws in the random number generator used by the signer at signing time.\nThis document also permits a fully deterministic variant of the signing procedure in case the signer has\nno access to a fresh source of randomness at signing time. However, the lack of randomness in the\ndeterministic variant makes the risk of side-channel attacks (particularly fault attacks) more difficult to\nmitigate. Therefore, this variant should not be used on platforms where side-channel attacks are a concern\nand where they cannot be otherwise mitigated.\nOnly implementing the hedged variant (i.e., without the deterministic variant) is sufficient to guarantee\ninteroperability. The same verification algorithm will work to verify signatures produced by either variant,\nso implementing the deterministic variant in addition to the hedged variant does not enhance interoper-\nability. The hedged and deterministic signing procedure differ only at line 5 of Algorithm 2 and line 5 of\nAlgorithm 4.\n3.5 Use of Digital Signatures\nSecure key management is an essential requirement for the use of digital signatures. This is context-\ndependent and involves more than the key generation, signing, and signature verification algorithms in\nthis document. Guidance for key management is provided in the SP 800-57 series [9, 17, 18].\nDigital signatures are most useful when bound to an identity. Binding a public key to an identity requires\nproof of possession of the private key. In the PKI context, issuing certificates involves assurances of identity\nand proof of possession. When a public-key certificate is not available, users of digital signatures should\ndetermine whether a public key needs to be bound to an identity. Methods for obtaining assurances of\nidentity and proof of possession are provided in [3].\n11\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n3.6 Additional Requirements\nThis section describes several required assurances when implementing ML-DSA. These are in addition to\nthe considerations in Section 3.5.\n3.6.1 Randomness Generation\nAlgorithm 1, implementing key generation for ML-DSA, uses an RBG to generate the 256-bit random seed\n𝜉. The seed 𝜉 shall be a fresh (i.e., not previously used) random value generated using an approved RBG,\nas prescribed in SP 800-90A, SP 800-90B, and SP 800-90C [19, 20, 21]. Moreover, the RBG used shall have\na security strength of at least 192 bits for ML-DSA-65 and 256 bits for ML-DSA-87. For ML-DSA-44, the\nRBG should have a security strength of at least 192 bits and shall have a security strength of at least 128\nbits. If an approved RBG with at least 128 bits of security but less than 192 bits of security is used, then\nthe claimed security strength of ML-DSA-44 is reduced from category 2 to category 1.\nAdditionally, the value 𝑟𝑛𝑑 is generated using an RBG in the default “hedged” variants of Algorithms 2\nand 4 for ML-DSA and HashML-DSA signing, respectively. While this value should ideally be generated by\nan approved RBG, other methods for generating fresh random values may be used. The primary purpose\nof 𝑟𝑛𝑑 is to facilitate countermeasures to side-channel attacks and fault attacks on deterministic signatures,\nsuch as [22, 23, 24].3 For this purpose, even a weak RBG may be preferable to the fully deterministic\nvariants of Algorithms 2 and 4.\n3.6.2 Public-Key and Signature Length Checks\nAlgorithm 3, implementing verification for ML-DSA, and Algorithm 5, implementing verification for HashML-\nDSA, specify the length of the signature 𝜎 and the public key 𝑝𝑘 in terms of the parameters described in\nTable 1. If an implementation of ML-DSA can accept inputs for 𝜎 or 𝑝𝑘 of any other length, it shall return\nfalse whenever the lengths of either of these inputs differ from their lengths specified in this standard.\nFailing to check the length of 𝑝𝑘 or 𝜎 may interfere with the security properties that ML-DSA is designed\nto have, like strong unforgeability.\n3.6.3 Intermediate Values\nThe data used internally by the key generation and signing algorithms in intermediate computation steps\ncould be used by an adversary to gain information about the private key and thereby compromise security.\nThe data used internally by verification algorithms is similarly sensitive for some applications, including\nthe verification of signatures that are used as bearer tokens (i.e., authentication secrets) or the verification\nof signatures on plaintext messages that are intended to be confidential. Intermediate values of the\nverification algorithm may reveal information about its inputs (i.e., the message, signature, and public\nkey), and in some applications, security or privacy requires one or more of these inputs to be confidential.\nTherefore, implementations of ML-DSA shall ensure that any potentially sensitive intermediate data is\ndestroyed as soon as it is no longer needed.\nTwo particular cases in which implementations may refrain from destroying intermediate data are:\n1. The seed 𝜉 generated in step 1 of ML-DSA.KeyGen can be stored for the purpose of later expansion\n3In addition, when signing is deterministic, there is leakage through timing side channels of information about\nthe message but not the private key). If the signer does not want to reveal the message being signed, hedged\nsignatures should be used (see Section 3.2 in [6]).\n12\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nusing ML-DSA.KeyGen_internal. As the seed can be used to compute the private key, it is sensitive\ndata and shall be treated with the same safeguards as a private key.\n2. The matrix 𝐀̂ generated in step 3 of ML-DSA.KeyGen_internal can be stored so that it need not\nbe recomputed in later operations. Likewise, the matrix 𝐀̂ generated in step 5 of the verification\nalgorithm ML-DSA.Verify_internal can also be stored. In either case, the matrix 𝐀̂ is data that is\neasily computed from the public key and does not require any special protections.\nIn certain situations (e.g., deterministic signing and the verification of confidential messages and signa-\ntures), additional care must be taken to protect implementations against side-channel attacks or fault\nattacks. A cryptographic device may leak critical information through side channels, which allows internal\ndata or keying material to be extracted without breaking the cryptographic primitives.\n3.6.4 No Floating-Point Arithmetic\nImplementations of ML-DSA shall not use floating-point arithmetic, as rounding errors in floating point\noperations may lead to incorrect results in some cases. Either ⌊𝑥/𝑦⌋ or ⌈𝑥/𝑦⌉ is used in all pseudocode\nin this standard in which division is performed (e.g., 𝑥/𝑦), and 𝑦 may not divide 𝑥. Both of these can\nbe computed without floating-point arithmetic, as ordinary integer division 𝑥/𝑦 computes ⌊𝑥/𝑦⌋, and\n⌈𝑥/𝑦⌉ = ⌊(𝑥 + 𝑦 − 1)/𝑦⌋ for non-negative integers 𝑥 and positive integers 𝑦. If 𝑦 is a power of two, it\nmay be more efficient to use bit shift operations than integer division.\n3.7 Use of Symmetric Cryptography\nThis standard makes use of the functions SHAKE256 and SHAKE128, as defined in FIPS 202 [7]. While FIPS\n202 specifies these functions as inputting and outputting bit strings, most implementations treat inputs\nand outputs as byte strings.\nThis standard will always call these functions with an output length of a multiple of eight bits and treat the\noutput of these functions as a byte string, which will be the same byte string that would result from taking\nthe bit string expected from a literal reading of FIPS 202 and processing it with BitsToBytes. However,\nto allow the signing of messages that are not a whole number of bytes, this document will overload\nSHAKE256 so that its input may be a bit string but will usually be a byte string. The following equivalence\nwill hold for any byte string str and integer ℓ ≥ 1:\nSHAKE256(str, 8ℓ) = SHAKE256(BytesToBits(str), 8ℓ).\nIn addition to using a mostly byte-oriented variant of the API defined in FIPS 202 for SHAKE256 and\nSHAKE128, this standard sometimes makes use of the incremental API defined in SP 800-185 [25]. This API\nconsists of three functions for each variant of SHAKE. These functions can be used to absorb a sequence\nof arbitrary-length strings and squeeze a sequence of arbitrary-length strings. These functions perform\nbuffering to handle any incomplete data blocks while absorbing or squeezing. For example, for SHAKE256:\n• ctx ← SHAKE256.Init()\nInitializes a hash function context.\n• ctx ← SHAKE256.Absorb(ctx, str)\nInjects data to be used in the absorbing phase of SHAKE256 and updates context ctx.\n13\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n• (ctx, out) ← SHAKE256.Squeeze(ctx, 8ℓ)\nExtracts ℓ output bytes produced during the squeezing phase of SHAKE256 and updates context\nctx.\nWhile the above functions are specified in terms of the Keccak-𝑓 permutation rather than the eXtendable-\nOutput Function (XOF), SHAKE256, they are defined so that any series of commands of the following\nform:\n1. ctx ← SHAKE256.Init()\n2. For 𝑖 = 1 to 𝑚: ctx ← SHAKE256.Absorb(ctx, str )\n𝑖\n3. For 𝑗 = 1 to 𝑘: (ctx, out ) ← SHAKE256.Squeeze(ctx, 8𝑏 )\n𝑗 𝑗\n4. output ← out || … ||out\n1 𝑘\nwill yield the same output as a single SHAKE256 call:\noutput ← SHAKE256(str || … ||str ,8𝑏 +…+8𝑏 ).\n1 𝑚 1 𝑘\nThis equivalence holds whether or not |str | and 𝑏 are multiples of the SHAKE256 block length.\n𝑖 𝑗\nSince all outputs of SHAKE128 and SHAKE256 in this document give a whole number of bytes, the wrapper\nfunctions H and G are defined as follows:\n1. H(str,ℓ) = SHAKE256(str, 8ℓ)\n2. G(str,ℓ) = SHAKE128(str, 8ℓ)\n3. H.Init() = SHAKE256.Init()\n4. G.Init() = SHAKE128.Init()\n5. H.Absorb(ctx, str) = SHAKE256.Absorb(ctx, str)\n6. G.Absorb(ctx, str) = SHAKE128.Absorb(ctx, str)\n7. H.Squeeze(ctx,ℓ) = SHAKE256.Squeeze(ctx, 8ℓ)\n8. G.Squeeze(ctx,ℓ) = SHAKE128.Squeeze(ctx, 8ℓ)\nIn addition to SHAKE128 and SHAKE256, HashML-DSA.Sign and HashML-DSA.Verify may call other\napproved hash functions for pre-hashing. The pseudocode in this standard also treats these functions\nas returning a byte string as output while supporting either a bit string or a byte string as input. Here, it\nshould be noted that the hash functions defined in [8] use different rules (i.e., big-endian ordering) to\nrelate bits, bytes, and words.\n14"
  },
  {
    "input": "What are the security strength categories and corresponding key and signature sizes for the three ML-DSA parameter sets listed in Table 1?",
    "summary": "The FIPS 204 standard includes three ML-DSA parameter sets: ML-DSA-44, ML-DSA-65, and ML-DSA-87, each assigned specific values for cryptographic parameters. These parameter sets are designed to meet different security strength categories as defined by NIST. The security strength is determined by the computational resources required to break the system, compared to those needed for generic block ciphers or hash functions.",
    "output": "FIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n4. Parameter Sets\nTable 1. ML-DSA parameter sets\nParameters Values assigned by each parameter set\n(see Sections 6.1 and 6.2 of this document) ML-DSA-44 ML-DSA-65 ML-DSA-87\n𝑞 -modulus [see §6.1] 8380417 8380417 8380417\n𝜁 -a 512th root of unity in ℤ [see §7.5] 1753 1753 1753\n𝑞\n𝑑 -# of dropped bits from 𝐭 [see §6.1] 13 13 13\n𝜏 -# of ±1’s in polynomial 𝑐 [see §6.2] 39 49 60\n𝜆 -collision strength of 𝑐 ̃[see §6.2] 128 192 256\n𝛾 -coefficient range of 𝐲 [see §6.2] 217 219 219\n1\n𝛾 -low-order rounding range [see §6.2] (𝑞 − 1)/88 (𝑞 − 1)/32 (𝑞 − 1)/32\n2\n(𝑘, ℓ) -dimensions of 𝐀 [see §6.1] (4,4) (6,5) (8,7)\n𝜂 -private key range [see §6.1] 2 4 2\n𝛽 = 𝜏 ⋅𝜂 [see §6.2] 78 196 120\n𝜔 -max # of 1’s in the hint 𝐡 [see §6.2] 80 55 75\nChallenge entropy log (256) +𝜏 [see §6.2] 192 225 257\n2 𝜏\nRepetitions (see explanation below) 4.25 5.1 3.85\nClaimed security strength Category 2 Category 3 Category 5\nThree ML-DSA parameter sets are included in Table 1. Each parameter set assigns values for all of the\nparameters used in the ML-DSA algorithms for key generation, signing, and verification. For informational\npurposes, some parameters used in the analysis of these algorithms are also included in the table. In\nparticular, “repetitions” refers to the expected number of repetitions of the main loop in the signing\nalgorithm from eq. 5 in [5]. The names of the parameter sets are of the form “ML-DSA-𝑘ℓ,” where (𝑘, ℓ)\nare the dimensions of the matrix 𝐀.\nThese parameter sets were designed to meet certain security strength categories defined by NIST in its\noriginal Call for Proposals [26]. These security strength categories are explained further in SP 800-57, Part\n1 [9].\nUsing this approach, security strength is not described by a single number, such as “128 bits of security.”\nInstead, each ML-DSA parameter set is claimed to be at least as secure as a generic block cipher with a\nprescribed key size or a generic hash function with a prescribed output length. More precisely, it is claimed\nthat the computational resources needed to break ML-DSA are greater than or equal to the computational\nresources needed to break the block cipher or hash function when these computational resources are\nestimated using any realistic model of computation. Different models of computation can be more or less\nrealistic and, accordingly, lead to more or less accurate estimates of security strength. Some commonly\nstudied models are discussed in [27].\nConcretely, the parameter set ML-DSA-44 is claimed to be in security strength category 2, ML-DSA-65 is\nclaimed to be in category 3, and ML-DSA-87 is claimed to be in category 5 [6]. For additional discussion of\nthe security strength of MLWE-based cryptosystems, see [28].\nThe sizes of keys and signatures that correspond to each parameter set are given in Table 2. Certain\noptimizations are possible when storing ML-DSA public and private keys. If additional space is available,\none can precompute and store 𝐀̂ to speed up signing and verifying. Alternatively, if one wants to reduce\n15\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nthe space needed for the private key, one can store only the 32-byte seed 𝜉, which is sufficient to generate\nthe other parts of the private key. For additional details, see Section 3.1 in [6].\nTable 2. Sizes (in bytes) of keys and signatures of ML-DSA\nPrivate Key Public Key Signature Size\nML-DSA-44 2560 1312 2420\nML-DSA-65 4032 1952 3309\nML-DSA-87 4896 2592 4627\n16"
  },
  {
    "input": "What is the difference between the \"pure\" ML-DSA signing and the \"pre-hash\" HashML-DSA signing in terms of how the message is processed and the security considerations involved?",
    "summary": "The FIPS 204 standard defines lattice-based digital signature algorithms, separating signing, verification, and key generation into external and internal components. External functions handle randomness and checks before passing data to deterministic internal functions. The \"pre-hash\" version of ML-DSA allows signing a message's digest instead of the message itself, which can improve performance, but requires the digest to be generated using an approved hash function or XOF to maintain security.",
    "output": "FIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n5. External Functions\nThe signing, verifying, and key generation functions can be split into “external” and “internal” components\nto simplify APIs and Cryptographic Algorithm Validation Program (CAVP) testing. The external components\ngenerate randomness and perform various checks before calling their internal counterparts. The internal\ncomponents are deterministic and can assume that the external components did not encounter error\nconditions.\nThe distinction between external and internal functions also simplifies the presentation of algorithms\nfor signing and verification by grouping the operations that are shared between ML-DSA.Sign and\nHashML-DSA.Sign in ML-DSA.Sign_internal and grouping the operations that are shared between\nML-DSA.Verify and HashML-DSA.Verify in ML-DSA.Verify_internal.\n5.1 ML-DSA Key Generation\nThe key generation algorithm ML-DSA.KeyGen takes no input and outputs a public key and a private key,\nwhich are both encoded as byte strings.\nThe algorithm uses an approved RBG to generate a 256-bit (32-byte) random seed 𝜉 that is given as input\nto ML-DSA.KeyGen_internal (Algorithm 6), which produces the public and private keys.\nAlgorithm 1 ML-DSA.KeyGen()\nGenerates a public-private key pair.\nOutput: Public key 𝑝𝑘 ∈ 𝔹32+32𝑘(bitlen (𝑞−1)−𝑑)\nand private key 𝑠𝑘 ∈ 𝔹32+32+64+32⋅((ℓ+𝑘)⋅bitlen (2𝜂)+𝑑𝑘).\n1: 𝜉 ← 𝔹32 ▷ choose random seed\n2: if 𝜉 = NULL then\n3: return ⊥ ▷ return an error indication if random bit generation failed\n4: end if\n5: return ML-DSA.KeyGen_internal (𝜉)\n5.2 ML-DSA Signing\nThe signing algorithm ML-DSA.Sign (Algorithm 2) takes a private key, a message, and a context string as\ninput4. It outputs a signature that is encoded as a byte string.\nFor the default “hedged” version of ML-DSA signing, the algorithm (at line 5) uses an approved RBG to\ngenerate a 256-bit (32-byte) random seed 𝑟𝑛𝑑. If the deterministic variant is desired, then 𝑟𝑛𝑑 is set\nto the fixed zero string {0}32 . The value 𝑟𝑛𝑑, the private key, and the encoded message are input to\nML-DSA.Sign_internal (Algorithm 7), which produces the signature.\n4By default, the context is the empty string, though applications may specify the use of a non-empty context string.\n17\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 2 ML-DSA.Sign(𝑠𝑘, 𝑀, 𝑐𝑡𝑥)\nGenerates an ML-DSA signature.\nInput: Private key 𝑠𝑘 ∈ 𝔹32+32+64+32⋅((ℓ+𝑘)⋅bitlen (2𝜂)+𝑑𝑘), message 𝑀 ∈ {0,1}∗ ,\ncontext string 𝑐𝑡𝑥 (a byte string of 255 or fewer bytes).\nOutput: Signature 𝜎 ∈ 𝔹𝜆/4+ℓ⋅32⋅(1+bitlen (𝛾 1 −1))+𝜔+𝑘.\n1: if |𝑐𝑡𝑥| > 255 then\n2: return ⊥ ▷ return an error indication if the context string is too long\n3: end if\n4:\n5: 𝑟𝑛𝑑 ← 𝔹32 ▷ for the optional deterministic variant, substitute 𝑟𝑛𝑑 ← {0}32\n6: if 𝑟𝑛𝑑 = NULL then\n7: return ⊥ ▷ return an error indication if random bit generation failed\n8: end if\n9:\n10: 𝑀′ ← BytesToBits(IntegerToBytes(0,1) ∥ IntegerToBytes(|𝑐𝑡𝑥|, 1) ∥ 𝑐𝑡𝑥) ∥ 𝑀\n11: 𝜎 ← ML-DSA.Sign_internal(𝑠𝑘, 𝑀′, 𝑟𝑛𝑑)\n12: return 𝜎\n5.3 ML-DSA Verifying\nThe verification algorithm ML-DSA.Verify (Algorithm 3) takes a public key, a message, a signature, and a\ncontext string as input. The public key, signature, and context string are all encoded as byte strings, while\nthe message is a bit string. ML-DSA.Verify outputs a Boolean value that is true if the signature is valid\nwith respect to the message and the public key and false if the signature is invalid. The verification is\naccomplished by calling ML-DSA.Verify_internal (Algorithm 8) with the public key, the encoded message,\nand the signature.\nAlgorithm 3 ML-DSA.Verify(𝑝𝑘, 𝑀, 𝜎, 𝑐𝑡𝑥)\nVerifies a signature 𝜎 for a message 𝑀.\nInput: Public key 𝑝𝑘 ∈ 𝔹32+32𝑘(bitlen (𝑞−1)−𝑑), message 𝑀 ∈ {0,1}∗ ,\nsignature 𝜎 ∈ 𝔹𝜆/4+ℓ⋅32⋅(1+bitlen (𝛾 1 −1))+𝜔+𝑘,\ncontext string 𝑐𝑡𝑥 (a byte string of 255 or fewer bytes).\nOutput: Boolean.\n1: if |𝑐𝑡𝑥| > 255 then\n2: return ⊥ ▷ return an error indication if the context string is too long\n3: end if\n4:\n5: 𝑀′ ← BytesToBits(IntegerToBytes(0,1) ∥ IntegerToBytes(|𝑐𝑡𝑥|, 1) ∥ 𝑐𝑡𝑥) ∥ 𝑀\n6: return ML-DSA.Verify_internal(𝑝𝑘, 𝑀′, 𝜎)\n5.4 Pre-Hash ML-DSA\nFor some cryptographic modules that generate ML-DSA signatures, hashing the message in step 6 of\nML-DSA.Sign_internal may result in unacceptable performance if the message 𝑀 is large. For example,\n18\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nthe platform may require hardware support for hashing to achieve acceptable performance but lack\nhardware support for SHAKE256 specifically. For some use cases, this may be addressed by signing a\ndigest of the message along with some domain separation information rather than signing the message\ndirectly. This version of ML-DSA is known as “pre-hash” ML-DSA or HashML-DSA . In general, the “pure”\nML-DSA version is preferred.\nWhile key generation for HashML-DSA is the same as for ML-DSA, it is not the same for the signing algorithm\nHashML-DSA.Sign or the verification algorithm HashML-DSA.Verify. Like ML-DSA, the signing algorithm\nof HashML-DSA takes the content to be signed, the private key, and a context as input, as well as a hash\nfunction or XOF that is to be used to pre-hash the content to be signed. The context string has a maximum\nlength of 255 bytes. By default, the context is the empty string, though applications may specify the use\nof a non-empty context string.\nThe identifier for a signature (e.g., the object identifier [OID]) should indicate whether the signature is a\nML-DSA signature or a pre-hash HashML-DSA signature. In the case of pre-hash signatures, the identifier\nshould also indicate the hash function or XOF used to compute the pre-hash. 5 While a single key pair\nmay be used for both ML-DSA and HashML-DSA signatures, it is recommended that each key pair only\nbe used for one version or the other. If a non-empty context string is to be used, this should either be\nindicated by the signature’s identifier or by the application with which the signature is being used.\nIf the default “hedged” variant of is used, the 32-byte random value 𝑟𝑛𝑑 shall be generated by the\ncryptographic module that generates the signature (i.e., that runs ML-DSA.Sign_internal). However, all\nother steps of signing may be performed outside of the cryptographic module that generates the signature.\nIn the case of pre-hashing, the hash or XOF of the content to be signed must be computed within a FIPS\n140-validated cryptographic module, but it may be a different cryptographic module than the one that\ngenerates the signature.\nIf the content to be signed is large, hashing of the content is often performed at the application level.\nFor example, in the Cryptographic Message Syntax [29], a digest of the content may be computed, and\nthat digest is signed along with other attributes. If the content is not hashed at the application level, the\npre-hash version of ML-DSA signing may be used.\nIn order to maintain the same level of security strength when the content is hashed at the application level\nor using HashML-DSA , the digest that is signed needs to be generated using an approved hash function\nor XOF (e.g., from FIPS 180 [8] or FIPS 202 [7]) that provides at least 𝜆 bits of classical security strength\nagainst both collision and second preimage attacks [7, Table 4].6 The verification of a signature that is\ncreated in this way will require the verify function to generate a digest from the message in the same way\nto be used as input for the verification function.\n5.4.1 HashML-DSA Signing and Verifying\nIn the HashML-DSA version, the message input to ML-DSA.Sign_internal is the result of applying either a\nhash function or a XOF to the content to be signed. The output of the hash function or XOF is prepended\nby a one-byte domain separator, one byte that indicates the length of the context string, the context\nstring, and the distinguished encoding rules (DER) encoding of the hash function or XOF’s OID. The domain\nseparator has a value of one for “pre-hash” signing. The DER encoding of the OID includes the tag and\nlength.\n5In the case of a XOF this would also include the length of the output from the XOF.\n6 Obtaining at least 𝜆 bits of classical security strength against collision attacks requires that the digest to be signed\nbe at least 2𝜆 bits in length.\n19\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 4 shows the DER encodings of the OIDs for SHA-256, SHA-512, and SHAKE128. However, it may\nbe used with other hash functions or XOFs.\nAlgorithm 4 HashML-DSA.Sign(𝑠𝑘, 𝑀, 𝑐𝑡𝑥, PH)\nGenerate a “pre-hash” ML-DSA signature.\nInput: Private key 𝑠𝑘 ∈ 𝔹32+32+64+32⋅((ℓ+𝑘)⋅bitlen (2𝜂)+𝑑𝑘) , message 𝑀 ∈ {0,1}∗ ,\ncontext string 𝑐𝑡𝑥 (a byte string of 255 or fewer bytes), pre-hash function PH.\nOutput: ML-DSA signature 𝜎 ∈ 𝔹𝜆/4+ℓ⋅32⋅(1+bitlen (𝛾 1 −1))+𝜔+𝑘 .\n1: if |𝑐𝑡𝑥| > 255 then\n2: return ⊥ ▷ return an error indication if the context string is too long\n3: end if\n4:\n5: 𝑟𝑛𝑑 ← 𝔹32 ▷ for the optional deterministic variant, substitute 𝑟𝑛𝑑 ← {0}32\n6: if 𝑟𝑛𝑑 = NULL then\n7: return ⊥ ▷ return an error indication if random bit generation failed\n8: end if\n9:\n10: switch PH do\n11: case SHA-256:\n12: OID ← 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01\n▷ 2.16.840.1.101.3.4.2.1\n13: PH ← SHA256(𝑀)\n𝑀\n14: case SHA-512:\n15: OID ← 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03\n▷ 2.16.840.1.101.3.4.2.3\n16: PH ← SHA512(𝑀)\n𝑀\n17: case SHAKE128:\n18: OID ← 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x0B\n▷ 2.16.840.1.101.3.4.2.11\n19: PH ← SHAKE128(𝑀,256)\n𝑀\n20: case …\n21: …\n22: end switch\n23: 𝑀 ′ ← BytesToBits(IntegerToBytes(1, 1) ∥ IntegerToBytes(|𝑐𝑡𝑥|, 1) ∥ 𝑐𝑡𝑥 ∥ OID ∥ PH )\n𝑀\n24: 𝜎 ← ML-DSA.Sign_internal(𝑠𝑘, 𝑀 ′ , 𝑟𝑛𝑑)\n25: return 𝜎\nAlgorithm 5 presents the signature verification for HashML-DSA . This function constructs 𝑀 ′ in the same\nway as Algorithm 4 and passes the resulting 𝑀 ′ to Algorithm ML-DSA.Verify_internal for verification. As\nwith the pre-hash signature generation, 𝑀 ′ may be constructed outside of the cryptographic module\nthat performs ML-DSA.Verify_internal. However, in the case of HashML-DSA , the hash or XOF of the\ncontent must be computed within a FIPS 140-validated cryptographic module, which may be a different\ncryptographic module than the one that performs ML-DSA.Verify_internal.\nAs noted in Section 5.4, the identifier associated with the signature should indicate whether ML-DSA or\n20\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nthe pre-hash version HashML-DSA of signature verification should be used, as well as the hash function or\nXOF to be used to compute the pre-hash. A non-empty context string should be used in verification if one\nis specified either in the signature’s identifier or by the application with which the signature is being used.\nAlgorithm 5 HashML-DSA.Verify(𝑝𝑘, 𝑀, 𝜎, 𝑐𝑡𝑥, PH)\nVerifies a pre-hash HashML-DSA signature.\nInput: Public key 𝑝𝑘 ∈ 𝔹32+32𝑘(bitlen (𝑞−1)−𝑑) , message 𝑀 ∈ {0, 1}∗ ,\nsignature 𝜎 ∈ 𝔹𝜆/4+ℓ⋅32⋅(1+bitlen (𝛾 1 −1))+𝜔+𝑘 ,\ncontext string 𝑐𝑡𝑥 (a byte string of 255 or fewer bytes), pre-hash function PH.\nOutput: Boolean.\n1: if |𝑐𝑡𝑥| > 255 then\n2: return false\n3: end if\n4:\n5: switch PH do\n6: case SHA-256:\n7: OID ← 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01\n▷ 2.16.840.1.101.3.4.2.1\n8: PH ← SHA256(𝑀)\n𝑀\n9: case SHA-512:\n10: OID ← 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03\n▷ 2.16.840.1.101.3.4.2.3\n11: PH ← SHA512(𝑀)\n𝑀\n12: case SHAKE128:\n13: OID ← 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x0B\n▷ 2.16.840.1.101.3.4.2.11\n14: PH ← SHAKE128(𝑀, 256)\n𝑀\n15: case …\n16: …\n17: end switch\n18: 𝑀 ′ ← BytesToBits(IntegerToBytes(1, 1) ∥ IntegerToBytes(|𝑐𝑡𝑥|, 1) ∥ 𝑐𝑡𝑥 ∥ OID ∥ PH )\n𝑀\n19: return ML-DSA.Verify_internal(𝑝𝑘, 𝑀 ′ , 𝜎)\n21"
  },
  {
    "input": "What is the process for generating a public-private key pair in the ML-DSA algorithm?",
    "summary": "The FIPS 204 standard outlines internal functions for generating, signing, and verifying lattice-based digital signatures (ML-DSA). Key generation uses a random seed to create public and private keys, with the public key being compressed for efficiency. Signing involves a rejection sampling loop to ensure validity, using randomness and message hashing to produce a signature. Verification checks the signature's components against the public key and message to confirm its authenticity.",
    "output": "FIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n6. Internal Functions\nThis section describes the functions for ML-DSA key generation, signature generation, and signature\nverification. Where randomness is required, the random values are provided as inputs to the functions.\nThe interfaces specified in this section will be used when testing of ML-DSA implementations is performed\nthrough the CAVP.\nOther than for testing purposes, the interfaces for key generation and signature generation specified\nin this section should not be made available to applications, as any random values required for key\ngeneration and signature generation shall be generated by the cryptographic module. Section 5 provides\nguidance on the interfaces to be made available to applications.7\n6.1 ML-DSA Key Generation (Internal)\nThe internal key generation algorithm ML-DSA.KeyGen_internal takes a 32-byte random seed as input\nand outputs a public key and a private key that are both encoded as byte strings.\nThe seed 𝜉 is expanded as needed using an XOF (i.e., a byte-variant of SHAKE256) denoted by H to produce\nother random values.8 In particular:\n• A 32-byte public random seed 𝜌. Using this seed, a polynomial matrix 𝐀 ∈ 𝑅𝑘×ℓ is pseudorandomly\n𝑞\nsampled9 from 𝑅𝑘×ℓ .\n𝑞\n• A 64-byte private random seed 𝜌′ . Using this seed, the polynomial vectors 𝐬 ∈ 𝑅ℓ and 𝐬 ∈ 𝑅𝑘\n1 𝑞 2 𝑞\nare pseudorandomly sampled from the subset of polynomial vectors whose coordinate polynomials\nhave short coefficients (i.e., in the range [−𝜂, 𝜂]).\n• A 32-byte private random seed 𝐾 for use during signing.\nThe core cryptographic operation computes the public value\n𝐭 = 𝐀𝐬 + 𝐬 .\n1 2\nThe vector 𝐭 together with the matrix 𝐀 may be considered an expanded form of the public key. The vector\n𝐭 is compressed in the actual public key by dropping the 𝑑 least significant bits from each coefficient, thus\nproducing the polynomial vector 𝐭 . This compression is an optimization for performance, not security.\n1\nThe low-order bits of 𝐭 can be reconstructed from a small number of signatures and, therefore, need not\nbe regarded as secret.\nThe ML-DSA public key 𝑝𝑘 is a byte encoding of the public random seed 𝜌 and the compressed polynomial\nvector 𝐭 .\n1\nThe ML-DSA private key 𝑠𝑘 is a byte encoding of the public random seed 𝜌, a private random seed 𝐾\nfor use during signing, a 64-byte hash 𝑡𝑟 of the public key for use during signing, the secret polynomial\n7In some cases, it is permissible to modify the format of the private key in these interfaces (see Sections 4 and 3.6.3.)\n8Single-byte encodings of the parameters 𝑘 and ℓ are included in the XOF input for domain separation. For\nimplementations that use the seed in place of the private key, this ensures that the expansion will produce an\nunrelated key if the seed is mistakenly expanded using a parameter set other than the one originally intended.\n9More precisely, since only the NTT form of 𝐀, 𝐀̂ ∈ 𝑇𝑘×ℓ = NTT(𝐀) is needed in subsequent calculations, the\n𝑞\ncode actually computes 𝐀̂ as a pseudorandom sample over 𝑇𝑘×ℓ , and the sampling of 𝐀 = NTT−1(𝐀̂ )is only\n𝑞\nimplicit (i.e., it could be computed but is not).\n22\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nvectors 𝐬 and 𝐬 , and a polynomial vector 𝐭 encoding the 𝑑 least significant bits of each coefficient of\n1 2 0\nthe uncompressed public-key polynomial 𝐭.\nAlgorithm 6 ML-DSA.KeyGen_internal(𝜉)\nGenerates a public-private key pair from a seed.\nInput: Seed 𝜉 ∈ 𝔹32\nOutput: Public key 𝑝𝑘 ∈ 𝔹32+32𝑘(bitlen (𝑞−1)−𝑑)\nand private key 𝑠𝑘 ∈ 𝔹32+32+64+32⋅((ℓ+𝑘)⋅bitlen (2𝜂)+𝑑𝑘).\n1: (𝜌,𝜌′,𝐾) ∈ 𝔹32 ×𝔹64 ×𝔹32 ← H(𝜉||IntegerToBytes(𝑘, 1)||IntegerToBytes(ℓ, 1), 128)\n2: ▷ expand seed\n3: 𝐀̂ ← ExpandA(𝜌) ▷ 𝐀 is generated and stored in NTT representation as 𝐀̂\n4: (𝐬 , 𝐬 ) ← ExpandS(𝜌′)\n1 2\n5: 𝐭 ← NTT−1(𝐀̂ ∘NTT(𝐬 )) + 𝐬 ▷ compute 𝐭 = 𝐀𝐬 + 𝐬\n1 2 1 2\n6: (𝐭 , 𝐭 ) ← Power2Round(𝐭) ▷ compress 𝐭\n1 0\n7: ▷ PowerTwoRound is applied componentwise (see explanatory text in Section 7.4)\n8: 𝑝𝑘 ← pkEncode(𝜌, 𝐭 )\n1\n9: 𝑡𝑟 ← H(𝑝𝑘, 64)\n10: 𝑠𝑘 ← skEncode(𝜌,𝐾,𝑡𝑟,𝐬 ,𝐬 ,𝐭 ) ▷𝐾 and 𝑡𝑟 are for use in signing\n1 2 0\n11: return (𝑝𝑘, 𝑠𝑘)\n6.2 ML-DSA Signing (Internal)\nML-DSA.Sign_internal (Algorithm 7) outputs a signature encoded as a byte string. It takes a private\nkey 𝑠𝑘 encoded as a byte string, a formatted message 𝑀′ encoded as a bit string, and a 32-byte string\n𝑟𝑛𝑑 as input. There are two ways that a signing algorithm can use ML-DSA.Sign_internal: “hedged”\nand “deterministic.” The default “hedged” variants of ML-DSA.Sign and HashML-DSA.Sign use a fresh\nrandom value for 𝑟𝑛𝑑, while the optional deterministic variants use the constant byte string {0}32 (see\nSection 3).\nIn both variants, the signer first extracts the following from the private key: the public random seed 𝜌,\nthe 32-byte private random seed 𝐾, the 64-byte hash of the public key 𝑡𝑟, the secret polynomial vectors\n𝐬 and 𝐬 , and the polynomial vector 𝐭 encoding the 𝑑 least significant bits of each coefficient of the\n1 2 0\nuncompressed public-key polynomial 𝐭. 𝜌 is then expanded to the same matrix 𝐀 as in key generation.\nBefore the message 𝑀 is signed, it is concatenated with the public-key hash 𝑡𝑟 and hashed down to a\n64-byte message representative 𝜇 using H.\nThe signer produces an additional 64-byte seed 𝜌″ for private randomness during each signing operation.\n𝜌″ is computed as 𝜌″ ← H(𝐾||𝑟𝑛𝑑||𝜇, 64). In the default hedged variant, 𝑟𝑛𝑑 is the output of an RBG,\nwhile in the deterministic variant, 𝑟𝑛𝑑 is a 32-byte string that consists entirely of zeros. This is the only\ndifference between the deterministic and hedged variant of ML-DSA.Sign.\nThe main part of the signing algorithm consists of a rejection sampling loop in which each iteration of the\nloop either produces a valid signature or an invalid signature whose release would leak information about\nthe private key. The loop is repeated until a valid signature is produced, which can then be encoded as a\nbyte string and output.10 The rejection sampling loop follows the Fiat-Shamir With Aborts paradigm [10]\n10Implementations may limit the number of iterations in this loop to not exceed a finite maximum value. If this\n23\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nand (aside from the rejection step) is similar in structure to Schnorr signatures [30] (e.g., EdDSA [31]). The\nsigner first produces a “commitment” 𝐰 and then pseudorandomly derives a “challenge” 𝑐 from 𝐰 and\n1 1\nthe message representative 𝜇. Finally, the signer computes a response 𝐳.\nIn more detail, the main computations involved in the rejection sampling loop are as follows:\n• Using the ExpandMask function (Algorithm 34), the seed 𝜌″ , and a counter 𝜅, a polynomial vector\n𝐲 ∈ 𝑅ℓ is pseudorandomly sampled from the subset of polynomial vectors whose coefficients are\n𝑞\nmoderately short (i.e., in the range [−𝛾 + 1, 𝛾 ]).\n1 1\n• From 𝐲, the signer computes the commitment 𝐰 by computing 𝐰 = 𝐀𝐲 and then rounding to a\n1\nnearby multiple of 2𝛾 using HighBits (Algorithm 37).\n2\n• 𝐰 and 𝜇 are concatenated and hashed to produce the commitment hash 𝑐.̃ This uses the function\n1\nw1Encode (Algorithm 28). The byte string 𝑐 ̃is used to pseudorandomly sample a polynomial 𝑐 ∈ 𝑅\n𝑞\nthat has coefficients in {−1, 0, 1} and Hamming weight 𝜏. The sampling is done with the function\nSampleInBall (Algorithm 29).11\n• The signer computes the response 𝐳 = 𝐲+𝑐𝐬 and performs various validity checks. If any of the\n1\nchecks fails, the signer will continue the rejection sampling loop.\n• If the checks pass, the signer can compute a hint polynomial 𝐡, which will allow the verifier to\nreconstruct 𝐰 using the compressed public key along with the other components of the signature.\n1\nThis uses the function MakeHint (Algorithm 39). The signer will then output the final signature,\nwhich is a byte encoding of the commitment hash 𝑐,̃ the response 𝐳, and the hint 𝐡.\nIn addition, there is an alternative way of implementing the validity checks on 𝐳 and the computation of\n𝐡, which is described in Section 5.1 of [6]. This method may also be used in implementations of ML-DSA.\nIn Algorithm 7, variables are sometimes used to store products to avoid recomputing them later in the\nsigning algorithm. These precomputed products are denoted in the pseudocode by a pair of double angle\nbrackets enclosing the variables being multiplied (e.g., ⟨⟨𝑐𝐬 ⟩⟩).\n1\noption is used and the maximum number of iterations is exceeded without producing a valid signature, the signing\nalgorithm shall return a constant that represents an error and no other output, destroying the results of the\nunsuccessful signing attempts. See Appendix C.\n11The length of 𝑐 ̃is determined by the desired security with respect to the “message-bound signatures” property\ndescribed in [14]. Here, a length of 𝜆/4 bytes or equivalently 2𝜆 bits is required for 𝜆 bits of classical security.\n24\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 7 ML-DSA.Sign_internal(𝑠𝑘, 𝑀′, 𝑟𝑛𝑑)\nDeterministic algorithm to generate a signature for a formatted message 𝑀′ .\nInput: Private key 𝑠𝑘 ∈ 𝔹32+32+64+32⋅((ℓ+𝑘)⋅bitlen (2𝜂)+𝑑𝑘), formatted message 𝑀′ ∈ {0,1}∗ , and\nper message randomness or dummy variable 𝑟𝑛𝑑 ∈ 𝔹32 .\nOutput: Signature 𝜎 ∈ 𝔹𝜆/4+ℓ⋅32⋅(1+bitlen (𝛾 1 −1))+𝜔+𝑘.\n1: (𝜌,𝐾,𝑡𝑟,𝐬 ,𝐬 ,𝐭 ) ← skDecode(𝑠𝑘)\n1 2 0\n2: 𝐬̂ ← NTT(𝐬 )\n1 1\n3: 𝐬̂ ← NTT(𝐬 )\n2 2\n4: 𝐭̂ ← NTT(𝐭 )\n0 0\n5: 𝐀̂ ← ExpandA(𝜌) ▷ 𝐀 is generated and stored in NTT representation as 𝐀̂\n6: 𝜇 ← H(BytesToBits(𝑡𝑟)||𝑀′, 64) ▷ message representative that may optionally be\ncomputed in a different cryptographic module\n7: 𝜌″ ← H(𝐾||𝑟𝑛𝑑||𝜇,64) ▷ compute private random seed\n8: 𝜅 ← 0 ▷ initialize counter 𝜅\n9: (𝐳,𝐡) ← ⊥\n10: while (𝐳,𝐡) = ⊥ do ▷ rejection sampling loop\n11: 𝐲 ∈ 𝑅ℓ ← ExpandMask(𝜌″, 𝜅)\n𝑞\n12: 𝐰 ← NTT−1(𝐀̂ ∘NTT(𝐲))\n13: 𝐰 ← HighBits(𝐰) ▷ signer’s commitment\n1\n14: ▷ HighBits is applied componentwise (see explanatory text in Section 7.4)\n15: 𝑐 ̃← H(𝜇||w1Encode(𝐰 ), 𝜆/4) ▷ commitment hash\n1\n16: 𝑐 ∈ 𝑅 ← SampleInBall(𝑐)̃ ▷ verifier’s challenge\n𝑞\n17: 𝑐 ̂← NTT(𝑐)\n18: ⟨⟨𝑐𝐬 ⟩⟩ ← NTT−1(𝑐 ̂ ∘𝐬̂ )\n1 1\n19: ⟨⟨𝑐𝐬 ⟩⟩ ← NTT−1(𝑐 ̂ ∘𝐬̂ )\n2 2\n20: 𝐳 ← 𝐲 + ⟨⟨𝑐𝐬 ⟩⟩ ▷ signer’s response\n1\n21: 𝐫 ← LowBits(𝐰 − ⟨⟨𝑐𝐬 ⟩⟩)\n0 2\n22: ▷ LowBits is applied componentwise (see explanatory text in Section 7.4)\n23: if ||𝐳|| ≥ 𝛾 − 𝛽 or ||𝐫 || ≥ 𝛾 − 𝛽 then (z, h) ← ⊥ ▷ validity checks\n∞ 1 0 ∞ 2\n24: else\n25: ⟨⟨𝑐𝐭 ⟩⟩ ← NTT−1(𝑐 ̂ ∘𝐭̂ )\n0 0\n26: 𝐡 ← MakeHint(−⟨⟨𝑐𝐭 ⟩⟩, 𝐰 − ⟨⟨𝑐𝐬 ⟩⟩ + ⟨⟨𝑐𝐭 ⟩⟩) ▷ Signer’s hint\n0 2 0\n27: ▷ MakeHint is applied componentwise (see explanatory text in Section 7.4)\n28: if ||⟨⟨𝑐𝐭 ⟩⟩|| ≥ 𝛾 or the number of 1’s in 𝐡 is greater than 𝜔, then (z, h) ← ⊥\n0 ∞ 2\n29: end if\n30: end if\n31: 𝜅 ← 𝜅+ℓ ▷ increment counter\n32: end while\n33: 𝜎 ← sigEncode(𝑐,̃ 𝐳mod±𝑞, 𝐡)\n34: return 𝜎\n6.3 ML-DSA Verifying (Internal)\nThe algorithm ML-DSA.Verify_internal (Algorithm 8) takes a public key 𝑝𝑘 encoded as a byte string, a\nmessage 𝑀 encoded as a bit string, and a signature 𝜎 encoded as a byte string as input. No randomness is\n25\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nrequired for ML-DSA.Verify_internal. It produces a Boolean value (i.e., a value that is true if the signature\nis valid with respect to the message and public key and false if the signature is invalid) as output. Algorithm 8\nspecifies the lengths of the signature 𝜎 and the public key 𝑝𝑘 in terms of the parameters described in\nTable 1. If an implementation of ML-DSA.Verify_internal can accept inputs for 𝜎 or 𝑝𝑘 of any other\nlength, it shall return false whenever the length of either of these inputs differs from its specified length.\nThe verifier first extracts the public random seed 𝜌 and the compressed polynomial vector 𝐭 from the\n1\npublic key 𝑝𝑘 and then extracts the signer’s commitment hash 𝑐,̃ response 𝐳, and hint 𝐡 from the signature\n𝜎. The verifier may find that the hint was not properly byte-encoded, denoted by the symbol “⊥,” in\nwhich case the verification algorithm will immediately return false to indicate that the signature is invalid.\nAssuming that the signature is successfully extracted from its byte encoding, the verifier pseudorandomly\nderives 𝐀 from 𝜌, as is done in key generation and signing, and creates a message representative 𝜇 by\nhashing the concatenation of 𝑡𝑟 (i.e., the hash of the public key 𝑝𝑘) and the message 𝑀. The verifier\nthen attempts to reconstruct the signer’s commitment (i.e., the polynomial vector 𝐰 ) from the public\n1\nkey 𝑝𝑘 and the signature 𝜎. In ML-DSA.Sign_internal, 𝐰 is computed by rounding 𝐰 = 𝐀𝐲. In\n1\nML-DSA.Verify_internal, the reconstructed value of 𝐰 is called 𝐰′ since it may have been computed in\n1 1\na different way if the signature is invalid. This 𝐰′ is computed through the following process:\n1\n• Derive the challenge polynomial 𝑐 from the signer’s commitment hash 𝑐,̃ just as similarly is done in\nML-DSA.Sign_internal.\n• Use the signer’s response 𝐳 to compute\n𝐰′ = 𝐀𝐳 − 𝑐𝐭 ⋅ 2𝑑.\nApprox 1\nAssuming the signature was computed correctly, as in ML-DSA.Sign_internal, it follows that\n𝐰 = 𝐀𝐲 = 𝐀𝐳 − 𝑐𝐭 + 𝑐𝐬 ≈ 𝐰′ = 𝐀𝐳 − 𝑐𝐭 ⋅ 2𝑑\n2 Approx 1\nbecause 𝑐 and 𝐬 have small coefficients, and 𝐭 ⋅2𝑑 ≈ 𝐭 .\n2 1\n• Use the signer’s hint 𝐡 to obtain 𝐰′ from 𝐰′ .\n1 Approx\nFinally, the verifier checks that the signer’s response 𝐳 and the signer’s hint 𝐡 are valid and that the\nreconstructed 𝐰′ is consistent with the signer’s commitment hash 𝑐.̃ More precisely, the verifier checks\n1\nthat all of the coefficients of 𝐳 are sufficiently small (i.e., in the range (−(𝛾 − 𝛽), 𝛾 − 𝛽)), 𝐡 contains no\n1 1\nmore than 𝜔 nonzero coefficients, and 𝑐 ̃matches the hash 𝑐′̃ of the message representative 𝜇 concatenated\nwith 𝐰′ (represented as a byte string). If all of these checks succeed, then ML-DSA.Verify_internal returns\n1\ntrue. Otherwise, it returns false.\n26\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 8 ML-DSA.Verify_internal(𝑝𝑘, 𝑀′, 𝜎)\nInternal function to verify a signature 𝜎 for a formatted message 𝑀′ .\nInput: Public key 𝑝𝑘 ∈ 𝔹32+32𝑘(bitlen (𝑞−1)−𝑑) and message 𝑀′ ∈ {0,1}∗ .\nInput: Signature 𝜎 ∈ 𝔹𝜆/4+ℓ⋅32⋅(1+bitlen (𝛾 1 −1))+𝜔+𝑘.\nOutput: Boolean\n1: (𝜌, 𝐭 ) ← pkDecode(𝑝𝑘)\n1\n2: (𝑐,̃ 𝐳, 𝐡) ← sigDecode(𝜎) ▷ signer’s commitment hash 𝑐,̃ response 𝐳, and hint 𝐡\n3: if 𝐡 = ⊥ then return false ▷ hint was not properly encoded\n4: end if\n5: 𝐀̂ ← ExpandA(𝜌) ▷ 𝐀 is generated and stored in NTT representation as 𝐀̂\n6: 𝑡𝑟 ← H(𝑝𝑘, 64)\n7: 𝜇 ← (H(BytesToBits(𝑡𝑟)||𝑀′, 64)) ▷ message representative that may optionally be\ncomputed in a different cryptographic module\n8: 𝑐 ∈ 𝑅 ← SampleInBall(𝑐)̃ ▷ compute verifier’s challenge from 𝑐 ̃\n𝑞\n9: 𝐰′ ← NTT−1(𝐀̂ ∘NTT(𝐳) − NTT(𝑐) ∘ NTT(𝐭 ⋅ 2𝑑)) ▷ 𝐰′ = 𝐀𝐳 − 𝑐𝐭 ⋅ 2𝑑\nApprox 1 Approx 1\n10: 𝐰′ ← UseHint(𝐡,𝐰′ ) ▷ reconstruction of signer’s commitment\n1 Approx\n11: ▷ UseHint is applied componentwise (see explanatory text in Section 7.4)\n12: 𝑐′̃ ← H(𝜇||w1Encode(𝐰′), 𝜆/4) ▷ hash it; this should match 𝑐 ̃\n1\n13: return [[ ||𝐳|| < 𝛾 − 𝛽]] and [[𝑐 ̃ = 𝑐′̃ ]]\n∞ 1\n27"
  },
  {
    "input": "What are the key auxiliary functions described in the FIPS 204 module for lattice-based digital signature standard and how do they facilitate the conversion between different data types and polynomial coefficients?",
    "summary": "The FIPS 204 standard includes algorithms for converting between different data types, such as bit strings, byte strings, and integers, using little-endian order. These conversion functions are essential for handling polynomial coefficients in the lattice-based digital signature scheme. Additionally, the standard provides methods for efficiently translating polynomials into byte strings and back, which are used in the signing and verification processes. Specialized algorithms like HintBitPack and HintBitUnpack are designed to handle polynomials with sparse binary coefficients, improving efficiency through structured encoding and decoding.",
    "output": "FIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n7. Auxiliary Functions\nThis section provides pseudocode for subroutines utilized by ML-DSA, including functions for data-type\nconversions, arithmetic, and sampling.\n7.1 Conversion Between Data Types\nWhile the primary data type in ML-DSA is a byte string, other data types are used as well. The goal in\nthis section is to construct procedures for translating between the various algebraic objects defined in\nSection 2.3. Algorithms 9–13 are intermediate procedures for converting between bit strings, byte strings,\nand integers.\nAlgorithm 9 IntegerToBits(𝑥, 𝛼)\nComputes a base-2 representation of 𝑥 mod 2𝛼 using little-endian order.\nInput: A nonnegative integer 𝑥 and a positive integer 𝛼.\nOutput: A bit string 𝑦 of length 𝛼.\n1: 𝑥′ ← 𝑥\n2: for 𝑖 from 0 to 𝛼 − 1 do\n3: 𝑦[𝑖] ← 𝑥 ′ mod 2\n4: 𝑥 ′ ← ⌊𝑥 ′ /2⌋\n5: end for\n6: return 𝑦\nAlgorithm 10 BitsToInteger(𝑦, 𝛼)\nComputes the integer value expressed by a bit string using little-endian order.\nInput: A positive integer 𝛼 and a bit string 𝑦 of length 𝛼.\nOutput: A nonnegative integer 𝑥.\n1: 𝑥 ← 0\n2: for 𝑖 from 1 to 𝛼 do\n3: 𝑥 ← 2𝑥 + 𝑦[𝛼 − 𝑖]\n4: end for\n5: return 𝑥\nAlgorithm 11 IntegerToBytes(𝑥, 𝛼)\nComputes a base-256 representation of 𝑥 mod 256𝛼 using little-endian order.\nInput: A nonnegative integer 𝑥 and a positive integer 𝛼.\nOutput: A byte string 𝑦 of length 𝛼.\n1: 𝑥′ ← 𝑥\n2: for 𝑖 from 0 to 𝛼 − 1 do\n3: 𝑦[𝑖] ← 𝑥 ′ mod 256\n4: 𝑥 ′ ← ⌊𝑥 ′ /256⌋\n5: end for\n6: return 𝑦\n28\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 12 BitsToBytes(𝑦)\nConverts a bit string into a byte string using little-endian order.\nInput: A bit string 𝑦 of length 𝛼.\nOutput: A byte string 𝑧 of length ⌈𝛼/8⌉.\n1: 𝑧 ∈ 𝔹⌈𝛼/8⌉ ← 0⌈𝛼/8⌉\n2: for 𝑖 from 0 to 𝛼 − 1 do\n3: 𝑧 [⌊𝑖/8⌋] ← 𝑧 [⌊𝑖/8⌋] + 𝑦[𝑖] ⋅ 2𝑖 mod 8\n4: end for\n5: return 𝑧\nAlgorithm 13 BytesToBits(𝑧)\nConverts a byte string into a bit string using little-endian order.\nInput: A byte string 𝑧 of length 𝛼.\nOutput: A bit string 𝑦 of length 8𝛼.\n1: 𝑧 ′ ← 𝑧\n2: for 𝑖 from 0 to 𝛼 − 1 do\n3: for 𝑗 from 0 to 7 do ▷ convert the byte 𝑧[𝑖] into 8 bits\n4: 𝑦[8𝑖 + 𝑗] ← 𝑧 ′ [𝑖] mod 2\n5: 𝑧 ′ [𝑖] ← ⌊𝑧 ′ [𝑖]/2⌋\n6: end for\n7: end for\n8: return 𝑦\nAlgorithms 14 and 15 translate byte strings into coefficients of polynomials in 𝑅. CoeffFromThreeBytes\nuses a 3-byte string to either generate an element of {0, 1, … , 𝑞 − 1} or return the blank symbol ⊥.\nCoeffFromHalfByte uses an element of {0, 1, … , 15} to either generate an element of {−𝜂, −𝜂+1, … , 𝜂}\nor return ⊥. These two procedures will be used in the uniform sampling algorithms RejNTTPoly and\nRejBoundedPoly, which are discussed in Section 7.3.\nAlgorithm 14 CoeffFromThreeBytes(𝑏 , 𝑏 , 𝑏 )\n0 1 2\nGenerates an element of {0, 1, 2, … , 𝑞 − 1} ∪ {⊥}.\nInput: Bytes 𝑏 , 𝑏 , 𝑏 .\n0 1 2\nOutput: An integer modulo 𝑞 or ⊥.\n1: 𝑏′ ← 𝑏\n2 2\n2: if 𝑏 ′ > 127 then\n2\n3: 𝑏′ ← 𝑏′ − 128 ▷ set the top bit of 𝑏′ to zero\n2 2 2\n4: end if\n5: 𝑧 ← 216 ⋅ 𝑏 ′ + 28 ⋅ 𝑏 + 𝑏 ▷ 0 ≤ 𝑧 ≤ 223 − 1\n2 1 0\n6: if 𝑧 < 𝑞 then return 𝑧 ▷ rejection sampling\n7: else return ⊥\n8: end if\n29\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 15 CoeffFromHalfByte(𝑏)\nLet 𝜂 ∈ {2,4}. Generates an element of {−𝜂,−𝜂 + 1,…,𝜂} ∪ {⊥}.\nInput: Integer 𝑏 ∈ {0,1,…,15}.\nOutput: An integer between −𝜂 and 𝜂, or ⊥.\n1: if 𝜂 = 2 and 𝑏 < 15 then return 2 − (𝑏 mod 5) ▷ rejection sampling from {−2, … , 2}\n2: else\n3: if 𝜂 = 4 and 𝑏 < 9 then return 4 − 𝑏 ▷ rejection sampling from {−4, … , 4}\n4: else return ⊥\n5: end if\n6: end if\nAlgorithms 16–19 efficiently translate an element 𝑤 ∈ 𝑅 into a byte string and vice versa under the\nassumption that the coefficients of 𝑤 are in a restricted range. SimpleBitPack assumes that 𝑤 ∈ [0, 𝑏]\n𝑖\nfor some positive integer 𝑏 and packs 𝑤 into a byte string of length 32 ⋅ bitlen 𝑏. BitPack allows for the\nmore general restriction 𝑤 ∈ [−𝑎, 𝑏]. The BitPack algorithm works by merely subtracting 𝑤 from the\n𝑖\npolynomial ∑ 255 𝑏𝑋𝑖 .\n𝑖=0\nAlgorithm 16 SimpleBitPack(𝑤, 𝑏)\nEncodes a polynomial 𝑤 into a byte string.\nInput: 𝑏 ∈ ℕ and 𝑤 ∈ 𝑅 such that the coefficients of 𝑤 are all in [0, 𝑏].\nOutput: A byte string of length 32 ⋅ bitlen 𝑏.\n1: 𝑧 ← () ▷ set 𝑧 to the empty bit string\n2: for 𝑖 from 0 to 255 do\n3: 𝑧 ← 𝑧||IntegerToBits(𝑤 , bitlen 𝑏)\n𝑖\n4: end for\n5: return BitsToBytes(𝑧)\nAlgorithm 17 BitPack(𝑤, 𝑎, 𝑏)\nEncodes a polynomial 𝑤 into a byte string.\nInput: 𝑎,𝑏 ∈ ℕ and 𝑤 ∈ 𝑅 such that the coefficients of 𝑤 are all in [−𝑎, 𝑏].\nOutput: A byte string of length 32 ⋅ bitlen (𝑎 + 𝑏).\n1: 𝑧 ← () ▷ set 𝑧 to the empty bit string\n2: for 𝑖 from 0 to 255 do\n3: 𝑧 ← 𝑧||IntegerToBits(𝑏 − 𝑤 , bitlen (𝑎 + 𝑏))\n𝑖\n4: end for\n5: return BitsToBytes(𝑧)\nSimpleBitUnpack and BitUnpack are used to decode the byte strings produced by the above functions.\nFor some choices of 𝑎 and 𝑏, there exist malformed byte strings that will cause SimpleBitUnpack and\nBitUnpack to output polynomials whose coefficients are not in the ranges [0, 𝑏] and [−𝑎, 𝑏], respectively.\nThis can be a concern when running SimpleBitUnpack and BitUnpack on inputs that may come from an\nuntrusted source.\n30\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 18 SimpleBitUnpack(𝑣, 𝑏)\nReverses the procedure SimpleBitPack.\nInput: 𝑏 ∈ ℕ and a byte string 𝑣 of length 32 ⋅ bitlen 𝑏.\nOutput: A polynomial 𝑤 ∈ 𝑅 with coefficients in [0,2𝑐 −1], where 𝑐 = bitlen 𝑏.\nWhen 𝑏 + 1 is a power of 2, the coefficients are in [0, 𝑏].\n1: 𝑐 ← bitlen 𝑏\n2: 𝑧 ← BytesToBits(𝑣)\n3: for 𝑖 from 0 to 255 do\n4: 𝑤 ← BitsToInteger((𝑧[𝑖𝑐], 𝑧[𝑖𝑐 + 1], … 𝑧[𝑖𝑐 + 𝑐 − 1]), 𝑐)\n𝑖\n5: end for\n6: return 𝑤\nAlgorithm 19 BitUnpack(𝑣, 𝑎, 𝑏)\nReverses the procedure BitPack.\nInput: 𝑎,𝑏 ∈ ℕ and a byte string 𝑣 of length 32 ⋅ bitlen (𝑎 + 𝑏).\nOutput: A polynomial 𝑤 ∈ 𝑅 with coefficients in [𝑏−2𝑐 +1,𝑏], where 𝑐 = bitlen (𝑎 + 𝑏).\nWhen 𝑎+𝑏 +1 is a power of 2, the coefficients are in [−𝑎, 𝑏].\n1: 𝑐 ← bitlen (𝑎 + 𝑏)\n2: 𝑧 ← BytesToBits(𝑣)\n3: for 𝑖 from 0 to 255 do\n4: 𝑤 ← 𝑏− BitsToInteger((𝑧[𝑖𝑐], 𝑧[𝑖𝑐 + 1], … 𝑧[𝑖𝑐 + 𝑐 − 1]), 𝑐)\n𝑖\n5: end for\n6: return 𝑤\nAlgorithms 20 and 21 carry out byte-string-to-polynomial conversions for polynomials with sparse binary\ncoefficients. In particular, the signing and verification algorithms (Sections 6.2 and 6.3) make use of a “hint,”\nwhich is a vector of polynomials 𝐡 ∈ 𝑅𝑘 such that the total number of coefficients in 𝐡[0], 𝐡[1], … , 𝐡[𝑘−1]\n2\nthat are equal to 1 is no more than 𝜔. This constraint enables encoding and decoding procedures that are\nmore efficient (although more complex) than BitPack and BitUnpack.\nHintBitPack (𝐡) outputs a byte string 𝑦 of length 𝜔 + 𝑘. The last 𝑘 bytes of 𝑦 contain information about\nhow many nonzero coefficients are present in each of the polynomials 𝐡[0], 𝐡[1], … , 𝐡[𝑘 − 1], and the\nfirst 𝜔 bytes of 𝑦 contain information about exactly where those nonzero terms occur. HintBitUnpack\nreverses the procedure performed by HintBitPack and recovers the vector 𝐡.\n31\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 20 HintBitPack(𝐡)\nEncodes a polynomial vector 𝐡 with binary coefficients into a byte string.\nInput: A polynomial vector 𝐡 ∈ 𝑅𝑘 such that the polynomials 𝐡[0], 𝐡[1],...,𝐡[𝑘 − 1] have\n2\ncollectively at most 𝜔 nonzero coefficients.\nOutput: A byte string 𝑦 of length 𝜔 + 𝑘 that encodes 𝐡 as described above.\n1: 𝑦 ∈ 𝔹𝜔+𝑘 ← 0𝜔+𝑘\n2: Index ← 0 ▷ Index for writing the first 𝜔 bytes of 𝑦\n3: for 𝑖 from 0 to 𝑘 − 1 do ▷ look at 𝐡[𝑖]\n4: for 𝑗 from 0 to 255 do\n5: if 𝐡[𝑖] ≠ 0 then\n𝑗\n6: 𝑦[Index] ← 𝑗 ▷ store the locations of the nonzero coefficients in 𝐡[𝑖]\n7: Index ← Index +1\n8: end if\n9: end for\n10: 𝑦[𝜔 + 𝑖] ← Index ▷ after processing 𝐡[𝑖], store the value of Index\n11: end for\n12: return 𝑦\nAlgorithm 21 HintBitUnpack(𝑦)\nReverses the procedure HintBitPack.\nInput: A byte string 𝑦 of length 𝜔 + 𝑘 that encodes 𝐡 as described above.\nOutput: A polynomial vector 𝐡 ∈ 𝑅𝑘 or ⊥.\n2\n1: 𝐡 ∈ 𝑅𝑘 ← 0𝑘\n2\n2: Index ← 0 ▷ Index for reading the first 𝜔 bytes of 𝑦\n3: for 𝑖 from 0 to 𝑘 − 1 do ▷ reconstruct 𝐡[𝑖]\n4: if 𝑦[𝜔 + 𝑖] < Index or 𝑦[𝜔 + 𝑖] > 𝜔 then return ⊥ ▷ malformed input\n5: end if\n6: First ← Index\n7: while Index < 𝑦[𝜔 + 𝑖] do ▷ 𝑦[𝜔 + 𝑖] says how far one can advance Index\n8: if Index > First then\n9: if 𝑦[Index − 1] ≥ 𝑦[Index] then return ⊥ ▷ malformed input\n10: end if\n11: end if\n12: 𝐡[𝑖] ← 1 ▷𝑦[Index] says which coefficient in 𝐡[𝑖] should be 1\n𝑦[Index]\n13: Index ← Index +1\n14: end while\n15: end for\n16: for 𝑖 from Index to 𝜔 − 1 do ▷ read any leftover bytes in the first 𝜔 bytes of 𝑦\n17: if 𝑦[𝑖] ≠ 0 then return ⊥ ▷ malformed input\n18: end if\n19: end for\n20: return 𝐡\n32"
  },
  {
    "input": "What is the purpose of the Power2Round and Decompose functions in the context of ML-DSA key compression and signature verification?",
    "summary": "The FIPS 204 standard defines encoding and decoding algorithms for ML-DSA keys and signatures, with careful handling of pseudorandom sampling and hint-based operations to ensure security and efficiency. It also specifies the NTT and its inverse for efficient arithmetic operations in the lattice-based digital signature scheme.",
    "output": "FIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n7.2 Encodings of ML-DSA Keys and Signatures\nAlgorithms 22–27 translate keys and signatures for ML-DSA into byte strings. These procedures take\ncertain sequences of algebraic objects, encode them consecutively into byte strings, and perform the\nrespective decoding procedures.\nFirst, pkEncode and pkDecode translate ML-DSA public keys into byte strings and vice versa. When\nverifying a signature, pkDecode might be run on an input that comes from an untrusted source. Thus,\ncare is required when using SimpleBitUnpack. As used here, SimpleBitUnpack always returns values in\nthe correct range.\nAlgorithm 22 pkEncode(𝜌, 𝐭 )\n1\nEncodes a public key for ML-DSA into a byte string.\nInput:𝜌 ∈ 𝔹32, 𝐭 ∈ 𝑅𝑘 with coefficients in [0, 2bitlen (𝑞−1)−𝑑 − 1].\n1\nOutput: Public key 𝑝𝑘 ∈ 𝔹32+32𝑘(bitlen (𝑞−1)−𝑑).\n1: 𝑝𝑘 ← 𝜌\n2: for 𝑖 from 0 to 𝑘 − 1 do\n3: 𝑝𝑘 ← 𝑝𝑘 || SimpleBitPack (𝐭 [𝑖], 2bitlen (𝑞−1)−𝑑 − 1)\n1\n4: end for\n5: return 𝑝𝑘\nAlgorithm 23 pkDecode(𝑝𝑘)\nReverses the procedure pkEncode.\nInput: Public key 𝑝𝑘 ∈ 𝔹32+32𝑘(bitlen (𝑞−1)−𝑑).\nOutput: 𝜌 ∈ 𝔹32, 𝐭 ∈ 𝑅𝑘 with coefficients in [0, 2bitlen (𝑞−1)−𝑑 − 1].\n1\n1: (𝜌, 𝑧 , … , 𝑧 ) ∈ 𝔹32 × (𝔹32(bitlen (𝑞−1)−𝑑))\n𝑘\n← 𝑝𝑘\n0 𝑘−1\n2: for 𝑖 from 0 to 𝑘 − 1 do\n3: 𝐭 [𝑖] ← SimpleBitUnpack(𝑧 , 2bitlen (𝑞−1)−𝑑 − 1) ▷ This is always in the correct range\n1 𝑖\n4: end for\n5: return (𝜌, 𝐭 )\n1\nNext, skEncode and skDecode translate ML-DSA secret keys into byte strings and vice versa. Note that\nthere exist malformed inputs that can cause skDecode to return values that are not in the correct range.\nHence, skDecode should only be run on inputs that come from trusted sources.\n33\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 24 skEncode(𝜌, 𝐾, 𝑡𝑟, 𝐬 , 𝐬 , 𝐭 )\n1 2 0\nEncodes a secret key for ML-DSA into a byte string.\nInput: 𝜌 ∈ 𝔹32, 𝐾 ∈ 𝔹32, 𝑡𝑟 ∈ 𝔹64 , 𝐬 ∈ 𝑅ℓ with coefficients in [−𝜂, 𝜂], 𝐬 ∈ 𝑅𝑘 with\n1 2\ncoefficients in [−𝜂, 𝜂], 𝐭 ∈ 𝑅𝑘 with coefficients in [−2𝑑−1 + 1, 2𝑑−1].\n0\nOutput: Private key 𝑠𝑘 ∈ 𝔹32+32+64+32⋅((𝑘+ℓ)⋅bitlen (2𝜂)+𝑑𝑘).\n1: 𝑠𝑘 ← 𝜌||𝐾||𝑡𝑟\n2: for 𝑖 from 0 to ℓ−1 do\n3: 𝑠𝑘 ← 𝑠𝑘 || BitPack (𝐬 [𝑖], 𝜂, 𝜂)\n1\n4: end for\n5: for 𝑖 from 0 to 𝑘 − 1 do\n6: 𝑠𝑘 ← 𝑠𝑘 || BitPack (𝐬 [𝑖], 𝜂, 𝜂)\n2\n7: end for\n8: for 𝑖 from 0 to 𝑘 − 1 do\n9: 𝑠𝑘 ← 𝑠𝑘 || BitPack (𝐭 [𝑖], 2𝑑−1 − 1, 2𝑑−1)\n0\n10: end for\n11: return 𝑠𝑘\nAlgorithm 25 skDecode(𝑠𝑘)\nReverses the procedure skEncode.\nInput: Private key 𝑠𝑘 ∈ 𝔹32+32+64+32⋅((ℓ+𝑘)⋅bitlen (2𝜂)+𝑑𝑘).\nOutput: 𝜌 ∈ 𝔹32, 𝐾 ∈ 𝔹32, 𝑡𝑟 ∈ 𝔹64 ,\n𝐬 ∈ 𝑅ℓ , 𝐬 ∈ 𝑅𝑘 , 𝐭 ∈ 𝑅𝑘 with coefficients in [−2𝑑−1 + 1, 2𝑑−1].\n1 2 0\n1: (𝜌,𝐾,𝑡𝑟,𝑦 ,…,𝑦 ,𝑧 ,…,𝑧 ,𝑤 ,…,𝑤 )∈ 𝔹32 ×𝔹32 ×𝔹64 ×(𝔹32⋅bitlen (2𝜂))\nℓ\n×\n0 ℓ−1 0 𝑘−1 0 𝑘−1\n(𝔹32⋅bitlen (2𝜂)) 𝑘 × (𝔹32𝑑) 𝑘 ← 𝑠𝑘\n2: for 𝑖 from 0 to ℓ−1 do\n3: 𝐬 [𝑖] ← BitUnpack(𝑦 , 𝜂, 𝜂) ▷ this may lie outside [−𝜂, 𝜂] if input is malformed\n1 𝑖\n4: end for\n5: for 𝑖 from 0 to 𝑘 − 1 do\n6: 𝐬 [𝑖] ← BitUnpack(𝑧 , 𝜂, 𝜂) ▷ this may lie outside [−𝜂, 𝜂] if input is malformed\n2 𝑖\n7: end for\n8: for 𝑖 from 0 to 𝑘 − 1 do\n9: 𝐭 [𝑖] ← BitUnpack(𝑤 , 2𝑑−1 − 1, 2𝑑−1) ▷ this is always in the correct range\n0 𝑖\n10: end for\n11: return (𝜌, 𝐾, 𝑡𝑟, 𝐬 , 𝐬 , 𝐭 )\n1 2 0\nNext, sigEncode and sigDecode translate ML-DSA signatures into byte strings and vice versa. When\nverifying a signature, sigDecode might take input that comes from an untrusted source. Thus, care is\nrequired when using BitUnpack. As used here, BitUnpack always returns values in the correct range.\n34\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 26 sigEncode(𝑐,̃ 𝐳, 𝐡)\nEncodes a signature into a byte string.\nInput: 𝑐 ̃∈ 𝔹𝜆/4, 𝐳 ∈ 𝑅ℓ with coefficients in [−𝛾 + 1, 𝛾 ], 𝐡 ∈ 𝑅𝑘 .\n1 1 2\nOutput: Signature 𝜎 ∈ 𝔹𝜆/4+ℓ⋅32⋅(1+bitlen (𝛾 1 −1))+𝜔+𝑘.\n1: 𝜎 ← 𝑐̃\n2: for 𝑖 from 0 to ℓ−1 do\n3: 𝜎 ← 𝜎|| BitPack (𝐳[𝑖], 𝛾 − 1, 𝛾 )\n1 1\n4: end for\n5: 𝜎 ← 𝜎|| HintBitPack (𝐡)\n6: return 𝜎\nAlgorithm 27 sigDecode(𝜎)\nReverses the procedure sigEncode.\nInput: Signature 𝜎 ∈ 𝔹𝜆/4+ℓ⋅32⋅(1+bitlen (𝛾 1 −1))+𝜔+𝑘.\nOutput: 𝑐 ̃∈ 𝔹𝜆/4, 𝐳 ∈ 𝑅ℓ with coefficients in [−𝛾 + 1, 𝛾 ], 𝐡 ∈ 𝑅𝑘 , or ⊥.\n1 1 2\n1: (𝑐,̃ 𝑥 , … , 𝑥 , 𝑦) ∈ 𝔹𝜆/4 × (𝔹32⋅(1+bitlen (𝛾 1 −1)))\nℓ\n× 𝔹𝜔+𝑘 ← 𝜎\n0 ℓ−1\n2: for 𝑖 from 0 to ℓ−1 do\n3: 𝐳[𝑖] ← BitUnpack(𝑥 , 𝛾 − 1, 𝛾 ) ▷ this is in the correct range, as 𝛾 is a power of 2\n𝑖 1 1 1\n4: end for\n5: 𝐡 ← HintBitUnpack(𝑦)\n6: return (𝑐,̃ 𝐳, 𝐡)\nw1Encode is a specific subroutine used in ML-DSA.Sign. The procedure w1Encode encodes a polynomial\nvector 𝐰 into a string of bytes so that it can be processed by the function H.\n1\nAlgorithm 28 w1Encode(𝐰 )\n1\nEncodes a polynomial vector 𝐰 into a byte string.\n1\nInput: 𝐰 ∈ 𝑅𝑘 whose polynomial coordinates have coefficients in [0, (𝑞 − 1)/(2𝛾 ) − 1].\n1 2\nOutput: A byte string representation 𝐰̃ ∈ 𝔹32𝑘⋅bitlen ((𝑞−1)/(2𝛾 2 )−1).\n1\n1: 𝐰̃ ← ()\n1\n2: for 𝑖 from 0 to 𝑘 − 1 do\n3: 𝐰̃ ← 𝐰̃ || SimpleBitPack (𝐰 [𝑖], (𝑞 − 1)/(2𝛾 ) − 1)\n1 1 1 2\n4: end for\n5: return 𝐰̃\n1\n35\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n7.3 Pseudorandom Sampling\nThis section specifies various algorithms for generating algebraic objects pseudorandomly from a seed\n𝜌, where 𝜌 is a byte string whose length varies depending on the algorithm. The first procedure to be\ndefined is SampleInBall. As in Section 2.3, 𝐵 denotes the set of all polynomials 𝑐 ∈ 𝑅 such that\n𝜏\n• Each coefficient of 𝑐 is either −1, 0, or 1, and\n• Exactly 𝜏 of the coefficients of 𝑐 are nonzero.\nSampleInBall pseudorandomly generates an element of 𝐵 using the XOF of a seed 𝜌. The procedure\n𝜏\nis based on the Fisher-Yates shuffle. H is applied to 𝜌, and the first 8 bytes of the output are used to\nchoose the signs of the nonzero entries of 𝑐. 12 Subsequent bytes are used to choose the positions of\nthose nonzero entries.\nAlgorithm 29 SampleInBall(𝜌)\nSamples a polynomial 𝑐 ∈ 𝑅 with coefficients from {−1, 0, 1} and Hamming weight 𝜏 ≤ 64.\nInput: A seed 𝜌 ∈ 𝔹𝜆/4\nOutput: A polynomial 𝑐 in 𝑅.\n1: 𝑐 ← 0\n2: ctx ← H.Init()\n3: ctx ← H.Absorb(ctx, 𝜌)\n4: (ctx, 𝑠) ← H.Squeeze(ctx, 8)\n5: ℎ ← BytesToBits(𝑠) ▷ℎ is a bit string of length 64\n6: for 𝑖 from 256 − 𝜏 to 255 do\n7: (ctx, 𝑗) ← H.Squeeze(ctx, 1)\n8: while 𝑗 > 𝑖 do ▷ rejection sampling in {0, … , 𝑖}\n9: (ctx, 𝑗) ← H.Squeeze(ctx, 1)\n10: end while ▷ 𝑗 is a pseudorandom byte that is ≤ 𝑖\n11: 𝑐 ← 𝑐\n𝑖 𝑗\n12: 𝑐 ← (−1)ℎ[𝑖+𝜏−256]\n𝑗\n13: end for\n14: return 𝑐\nAlgorithms 30–34 are the pseudorandom procedures RejNTTPoly, RejBoundedPoly, ExpandA, ExpandS,\nand ExpandMask. Each generates elements of 𝑅 or 𝑇 under different input and output conditions.\n𝑞\nRejNTTPoly and ExpandA make use of the more efficient XOF G, whereas the other three procedures\nuse the XOF H.\nThe procedure ExpandMask (Algorithm 34) generates a polynomial vector 𝐲 in 𝑅𝑘 that disguises the\nsecret key in the ML-DSA.Sign_internal procedure (Algorithm 7). In addition to the seed 𝜌, ExpandMask\nalso accepts an integer input 𝜇 that is incorporated into the pseudorandom procedure that generates 𝐬.\n12The parameter 𝜏 is always less than or equal to 64, and thus 8 bytes are sufficient to choose the signs for all 𝜏\nnonzero entries of 𝐜.\n36\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 30 RejNTTPoly(𝜌)\nSamples a polynomial ∈ 𝑇 .\n𝑞\nInput: A seed 𝜌 ∈ 𝔹34 .\nOutput: An element 𝑎 ̂ ∈ 𝑇 .\n𝑞\n1: 𝑗 ← 0\n2: ctx ← G.Init()\n3: ctx ← G.Absorb(ctx, 𝜌)\n4: while 𝑗 < 256 do\n5: (ctx, 𝑠) ← G.Squeeze(ctx, 3)\n6: 𝑎[̂ 𝑗] ← CoeffFromThreeBytes(𝑠[0], 𝑠[1], 𝑠[2])\n7: if 𝑎[̂ 𝑗] ≠ ⊥ then\n8: 𝑗 ← 𝑗+1\n9: end if\n10: end while\n11: return 𝑎̂\nAlgorithm 31 RejBoundedPoly(𝜌)\nSamples an element 𝑎 ∈ 𝑅 with coefficients in [−𝜂, 𝜂] computed via rejection sampling from 𝜌.\nInput: A seed 𝜌 ∈ 𝔹66 .\nOutput: A polynomial 𝑎 ∈ 𝑅.\n1: 𝑗 ← 0\n2: ctx ← H.Init()\n3: ctx ← H.Absorb(ctx, 𝜌)\n4: while 𝑗 < 256 do\n5: 𝑧 ← H.Squeeze(ctx, 1)\n6: 𝑧 ← CoeffFromHalfByte(𝑧 mod 16)\n0\n7: 𝑧 ← CoeffFromHalfByte(⌊𝑧/16⌋)\n1\n8: if 𝑧 ≠ ⊥ then\n0\n9: 𝑎 ← 𝑧\n𝑗 0\n10: 𝑗 ← 𝑗+1\n11: end if\n12: if 𝑧 ≠ ⊥ and 𝑗 < 256 then\n1\n13: 𝑎 ← 𝑧\n𝑗 1\n14: 𝑗 ← 𝑗+1\n15: end if\n16: end while\n17: return 𝑎\n37\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 32 ExpandA(𝜌)\nSamples a 𝑘 × ℓ matrix 𝐀̂ of elements of 𝑇 .\n𝑞\nInput: A seed 𝜌 ∈ 𝔹32 .\nOutput: Matrix 𝐀̂ ∈ (𝑇 )𝑘×ℓ .\n𝑞\n1: for 𝑟 from 0 to 𝑘 − 1 do\n2: for 𝑠 from 0 to ℓ−1 do\n3: 𝜌′ ← 𝜌||IntegerToBytes(𝑠, 1)||IntegerToBytes(𝑟, 1)\n4: 𝐀̂[𝑟, 𝑠] ← RejNTTPoly(𝜌′) ▷ seed 𝜌′ depends on 𝑠 and 𝑟\n5: end for\n6: end for\n7: return 𝐀̂\nAlgorithm 33 ExpandS(𝜌)\nSamples vectors 𝐬 ∈ 𝑅ℓ and 𝐬 ∈ 𝑅𝑘 , each with polynomial coordinates whose coefficients are\n1 2\nin the interval [−𝜂, 𝜂].\nInput: A seed 𝜌 ∈ 𝔹64 .\nOutput: Vectors 𝐬 , 𝐬 of polynomials in 𝑅.\n1 2\n1: for 𝑟 from 0 to ℓ−1 do\n2: 𝐬 [𝑟] ← RejBoundedPoly(𝜌||IntegerToBytes(𝑟, 2)) ▷ seed depends on 𝑟\n𝟏\n3: end for\n4: for 𝑟 from 0 to 𝑘 − 1 do\n5: 𝐬 [𝑟] ← RejBoundedPoly(𝜌||IntegerToBytes(𝑟+ℓ,2)) ▷ seed depends on 𝑟 +ℓ\n𝟐\n6: end for\n7: return (𝐬 , 𝐬 )\n𝟏 𝟐\nAlgorithm 34 ExpandMask(𝜌, 𝜇)\nSamples a vector 𝐲 ∈ 𝑅ℓ such that each polynomial 𝐲[𝑟] has coefficients between −𝛾 +1 and\n1\n𝛾 .\n1\nInput: A seed 𝜌 ∈ 𝔹64 and a nonnegative integer 𝜇.\nOutput: Vector 𝐲 ∈ 𝑅ℓ .\n1: 𝑐 ← 1+ bitlen (𝛾 −1) ▷𝛾 is always a power of 2\n1 1\n2: for 𝑟 from 0 to ℓ−1 do\n3: 𝜌′ ← 𝜌||IntegerToBytes(𝜇 + 𝑟,2)\n4: 𝑣 ← H(𝜌′, 32𝑐) ▷ seed depends on 𝜇 + 𝑟\n5: 𝐲[𝑟] ← BitUnpack(𝑣, 𝛾 − 1, 𝛾 )\n1 1\n6: end for\n7: return 𝐲\n38\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n7.4 High-Order and Low-Order Bits and Hints\nThis specification uses the auxiliary functions Power2Round, Decompose, HighBits, LowBits, MakeHint,\nand UseHint and explicitly defines these functions, where 𝑟 ∈ ℤ , 𝑟 ,𝑟 ∈ ℤ, and ℎ is a Boolean (or\n𝑞 1 0\nequivalently an element of ℤ ). However, this specification also uses these functions where 𝐫, 𝐳 ∈ 𝑅𝑘 ,\n2 𝑞\n𝐫 , 𝐫 ∈ 𝑅𝑘 , and 𝐡 ∈ 𝑅𝑘 . In this case, the functions are applied coefficientwise to the polynomials in the\n1 0 2\nvectors. In particular:\n• For 𝐫 ∈ 𝑅𝑘 , define (𝐫 ,𝐫 ) ∈ (𝑅𝑘)2 = Power2Round(𝐫) so that:\n𝑞 1 0\n((𝐫 [𝑖]) ,(𝐫 [𝑖]) ) = Power2Round((𝐫[𝑖]) ).\n1 𝑗 0 𝑗 𝑗\n• For 𝐫 ∈ 𝑅𝑘 , define (𝐫 ,𝐫 ) ∈ (𝑅𝑘)2 = Decompose(𝐫) so that:\n𝑞 1 0\n((𝐫 [𝑖]) ,(𝐫 [𝑖]) ) = Decompose((𝐫[𝑖]) ).\n1 𝑗 0 𝑗 𝑗\n• For 𝐫 ∈ 𝑅𝑘 , define 𝐫 = HighBits (𝐫) so that:\n𝑞 1\n(𝐫 [𝑖]) = HighBits((𝐫[𝑖]) ).\n1 𝑗 𝑗\n• For 𝐫 ∈ 𝑅𝑘 , define 𝐫 = LowBits(𝐫) so that:\n𝑞 0\n(𝐫 [𝑖]) = LowBits((𝐫[𝑖]) ).\n0 𝑗 𝑗\n• For 𝐳, 𝐫 ∈ 𝑅𝑘 , define 𝐡 ∈ 𝑅𝑘 = MakeHint(𝐳, 𝐫) so that:\n𝑞 2\n(𝐡[𝑖]) = MakeHint((𝐳[𝑖]) , (𝐫[𝑖]) ).\n𝑗 𝑗 𝑗\n• For 𝐡 ∈ 𝑅𝑘 and 𝐫 ∈ 𝑅𝑘 , define 𝐫 ∈ 𝑅𝑘 = UseHint(𝐡, 𝐫) so that:\n2 𝑞 1\n𝐫 [𝑖] = UseHint((𝐡[𝑖]) , (𝐫[𝑖]) ).\n1 𝑗 𝑗 𝑗\nThese algorithms are used to support the key compression optimization of ML-DSA. They involve dropping\nthe 𝑑 low-order bits of each coefficient of the polynomial vector 𝐭 from the public key using the function\nPower2Round. However, in order to make this optimization work, additional information called a “hint”\nneeds to be provided in the signature to allow the verifier to reconstruct enough of the information in\nthe dropped public-key bits to verify the signature. Hints are created during signing and used during\nverification by the functions MakeHint and UseHint, respectively. In the verification of a valid signature,\nthe hint allows the verifier to recover 𝐰 ∈ 𝑅𝑘 , which represents 𝐰 ∈ 𝑅𝑘 rounded to a nearby multiple\n1 𝑞\nof 𝛼 = 2𝛾 . The signer directly obtains 𝐰 using the function HighBits, and the part rounded off (i.e., 𝐫 )\n2 1 0\nis obtained by LowBits. 𝐫 is used by the signer in the rejection sampling procedure.\n0\nPower2Round decomposes an input 𝑟 ∈ ℤ into integers that represent the high-and low-order bits of\n𝑞\n𝑟 mod 𝑞 in the straightforward bitwise way, 𝑟 mod 𝑞 = 𝑟 ⋅2𝑑 +𝑟 , where 𝑟 = (𝑟 mod 𝑞) mod±2𝑑 and\n1 0 0\n𝑟 = (𝑟 mod 𝑞 − 𝑟 )/2𝑑 .\n1 0\nHowever, for the purpose of computations related to hints, this method of decomposing 𝑟 has the\nundesirable property that when 𝑟 is close to 𝑞 − 1 or 0, a small rounding error in 𝑟 can cause 𝑟 to change\n1\nby more than 1, even accounting for wrap-around. In contrast to other unequal pairs of values of 𝑟 ⋅ 2𝑑\n1\nand 𝑟′ ⋅ 2𝑑 , the distance (mod𝑞) between ⌊𝑞/2𝑑⌋ ⋅ 2𝑑 and 0 may be very small.\n1\n39\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nTo avoid this problem, this specification defines Decompose, which is similar to Power2Round except:\n• 𝑟 is generally decomposed as 𝑟 mod 𝑞 = 𝑟 ⋅𝛼+𝑟 , where 𝛼 = 2𝛾 is a divisor of 𝑞 −1.\n1 0 2\n• If the straightforward rounding procedure would return (𝑟 = (𝑞 − 1)/𝛼, 𝑟 ∈ [−(𝛼/2) + 1, 𝛼/2]),\n1 0\nDecompose instead returns (𝑟 = 0,𝑟 −1).\n1 0\nThe functions HighBits and LowBits — which only return 𝑟 and 𝑟 , respectively — and MakeHint and\n1 0\nUseHint use Decompose. For additional discussion of the mathematical properties of these functions\nthat are relevant to the correctness and security of ML-DSA, see Section 2.4 in [6].\nAlgorithm 35 Power2Round(𝑟)\nDecomposes 𝑟 into (𝑟 , 𝑟 ) such that 𝑟 ≡ 𝑟 2𝑑 + 𝑟 mod 𝑞.\n1 0 1 0\nInput: 𝑟 ∈ ℤ .\n𝑞\nOutput: Integers (𝑟 , 𝑟 ).\n1 0\n1: 𝑟+ ← 𝑟 mod 𝑞\n2: 𝑟 ← 𝑟+ mod± 2𝑑\n0\n3: return ((𝑟+ − 𝑟 )/2𝑑, 𝑟 )\n0 0\nAlgorithm 36 Decompose(𝑟)\nDecomposes 𝑟 into (𝑟 , 𝑟 ) such that 𝑟 ≡ 𝑟 (2𝛾 ) + 𝑟 mod 𝑞.\n1 0 1 2 0\nInput: 𝑟 ∈ ℤ .\n𝑞\nOutput: Integers (𝑟 , 𝑟 ).\n1 0\n1: 𝑟+ ← 𝑟 mod 𝑞\n2: 𝑟 ← 𝑟+ mod±(2𝛾 )\n0 2\n3: if 𝑟+ −𝑟 = 𝑞 −1 then\n0\n4: 𝑟 ← 0\n1\n5: 𝑟 ← 𝑟 −1\n0 0\n6: else 𝑟 ← (𝑟+ − 𝑟 )/(2𝛾 )\n1 0 2\n7: end if\n8: return (𝑟 , 𝑟 )\n1 0\nAlgorithm 37 HighBits(𝑟)\nReturns 𝑟 from the output of Decompose (𝑟).\n1\nInput: 𝑟 ∈ ℤ .\n𝑞\nOutput: Integer 𝑟 .\n1\n1: (𝑟 , 𝑟 ) ← Decompose(𝑟)\n1 0\n2: return 𝑟\n1\n40\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 38 LowBits(𝑟)\nReturns 𝑟 from the output of Decompose (𝑟).\n0\nInput: 𝑟 ∈ ℤ .\n𝑞\nOutput: Integer 𝑟 .\n0\n1: (𝑟 , 𝑟 ) ← Decompose(𝑟)\n1 0\n2: return 𝑟\n0\nAlgorithm 39 MakeHint(𝑧, 𝑟)\nComputes hint bit indicating whether adding 𝑧 to 𝑟 alters the high bits of 𝑟.\nInput: 𝑧,𝑟 ∈ ℤ .\n𝑞\nOutput: Boolean.\n1: 𝑟 ← HighBits(𝑟)\n1\n2: 𝑣 ← HighBits(𝑟 + 𝑧)\n1\n3: return [[𝑟 ≠ 𝑣 ]]\n1 1\nAlgorithm 40 UseHint(ℎ, 𝑟)\nReturns the high bits of 𝑟 adjusted according to hint ℎ.\nInput: Boolean ℎ, 𝑟 ∈ ℤ .\n𝑞\nOutput: 𝑟 ∈ ℤ with 0 ≤ 𝑟 ≤ 𝑞−1 .\n1 1 2𝛾\n2\n1: 𝑚 ← (𝑞 − 1)/(2𝛾 )\n2\n2: (𝑟 , 𝑟 ) ← Decompose(𝑟)\n1 0\n3: if ℎ = 1 and 𝑟 > 0 return (𝑟 + 1) mod 𝑚\n0 1\n4: if ℎ = 1 and 𝑟 ≤ 0 return (𝑟 − 1) mod 𝑚\n0 1\n5: return 𝑟\n1\n41\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n7.5 NTT and NTT− 1\nThe following algorithms implement the NTT and its inverse (NTT−1), which is important for efficiency.\nThere are other optimizations that are not included in this standard. In particular, mod 𝑞 and mod±𝑞 are\nexpensive operations whose use can be minimized by using Montgomery Multiplication (see Appendix A).\nAn element of 𝑅 is a polynomial in ℤ [𝑋]/(𝑋256 + 1), and an element of 𝑇 is a tuple in Π255ℤ . The\n𝑞 𝑞 𝑞 𝑗=0 𝑞\nNTT algorithm takes a polynomial 𝑤 ∈ 𝑅 as input and returns 𝑤̂ ∈ 𝑇 . NTT−1 takes 𝑤̂ ∈ 𝑇 as input\n𝑞 𝑞 𝑞\nand returns 𝑤 such that 𝑤̂ = NTT(𝑤).\nThis document always distinguishes between elements of 𝑅 and elements of 𝑇 . However, the natural\n𝑞 𝑞\ndata structure for both of these sets is as an integer array of size 256. This would allow the NTT and\nNTT−1 algorithms to perform computation in place on an integer array passed by reference. That\noptimization is not included in this document.\nIn Section 2.5, 𝜁 = 1753 ∈ ℤ , which is a 512th root of unity modulo 𝑞. On input 𝑤 ∈ 𝑅 , the algorithm\n𝑞 𝑞\noutputs\nNTT(𝑤) = (𝑤(𝜁 ),𝑤(𝜁 ),…,𝑤(𝜁 )) ∈ 𝑇 , (7.1)\n0 1 255 𝑞\nwhere 𝜁 𝑖 = 𝑤(𝜁2BitRev 8 (𝑖)+1) mod 𝑞.\nThe values 𝜁BitRev 8 (𝑘) mod 𝑞 for 𝑘 = 1,…,255 used in line 10 of Algorithms 41 and 42 are pre-computed\ninto an array zetas[1..255]. The table of zetas is given in Appendix B. If Montgomery Multiplication is used\n(see Appendix A), then the zetas array would typically be stored in Montgomery form.\nNTT and NTT−1 use BitRev , which reverses the order of bits in an 8-bit integer.\n8\n42\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 41 NTT(𝑤)\nComputes the NTT.\nInput: Polynomial 𝑤(𝑋) = ∑ 255 𝑤 𝑋𝑗 ∈ 𝑅 .\n𝑗=0 𝑗 𝑞\nOutput: 𝑤̂ = (𝑤̂ [0], … , 𝑤̂[255]) ∈ 𝑇 .\n𝑞\n1: for 𝑗 from 0 to 255 do\n2: 𝑤̂[𝑗] ← 𝑤\n𝑗\n3: end for\n4: 𝑚 ← 0\n5: 𝑙𝑒𝑛 ← 128\n6: while 𝑙𝑒𝑛 ≥ 1 do\n7: 𝑠𝑡𝑎𝑟𝑡 ← 0\n8: while 𝑠𝑡𝑎𝑟𝑡 < 256 do\n9: 𝑚 ← 𝑚+1\n10: 𝑧 ← zetas[𝑚] ▷𝑧 ← 𝜁BitRev 8 (𝑚) mod 𝑞\n11: for 𝑗 from 𝑠𝑡𝑎𝑟𝑡 to 𝑠𝑡𝑎𝑟𝑡 + 𝑙𝑒𝑛 − 1 do\n12: 𝑡 ← (𝑧 ⋅ 𝑤̂ [𝑗 + 𝑙𝑒𝑛]) mod 𝑞\n13: 𝑤̂[𝑗 + 𝑙𝑒𝑛] ← (𝑤̂[𝑗] − 𝑡) mod 𝑞\n14: 𝑤̂[𝑗] ← (𝑤̂[𝑗] + 𝑡) mod 𝑞\n15: end for\n16: 𝑠𝑡𝑎𝑟𝑡 ← 𝑠𝑡𝑎𝑟𝑡 + 2 ⋅ 𝑙𝑒𝑛\n17: end while\n18: 𝑙𝑒𝑛 ← ⌊𝑙𝑒𝑛/2⌋\n19: end while\n20: return 𝑤̂\n43\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 42 NTT−1(𝑤̂ )\nComputes the inverse of the NTT.\nInput: 𝑤̂ = (𝑤̂ [0], … , 𝑤̂[255]) ∈ 𝑇 .\n𝑞\nOutput: Polynomial 𝑤(𝑋) = ∑ 255 𝑤 𝑋𝑗 ∈ 𝑅 .\n𝑗=0 𝑗 𝑞\n1: for 𝑗 from 0 to 255 do\n2: 𝑤 ← 𝑤̂[𝑗]\n𝑗\n3: end for\n4: 𝑚 ← 256\n5: 𝑙𝑒𝑛 ← 1\n6: while 𝑙𝑒𝑛 < 256 do\n7: 𝑠𝑡𝑎𝑟𝑡 ← 0\n8: while 𝑠𝑡𝑎𝑟𝑡 < 256 do\n9: 𝑚 ← 𝑚−1\n10: 𝑧 ← −𝑧𝑒𝑡𝑎𝑠[𝑚] ▷ 𝑧 ← −𝜁BitRev 8 (𝑚) mod 𝑞\n11: for 𝑗 from 𝑠𝑡𝑎𝑟𝑡 to 𝑠𝑡𝑎𝑟𝑡 + 𝑙𝑒𝑛 − 1 do\n12: 𝑡 ← 𝑤\n𝑗\n13: 𝑤 ← (𝑡 + 𝑤 ) mod 𝑞\n𝑗 𝑗+𝑙𝑒𝑛\n14: 𝑤 ← (𝑡 − 𝑤 ) mod 𝑞\n𝑗+𝑙𝑒𝑛 𝑗+𝑙𝑒𝑛\n15: 𝑤 ← (𝑧 ⋅ 𝑤 ) mod 𝑞\n𝑗+𝑙𝑒𝑛 𝑗+𝑙𝑒𝑛\n16: end for\n17: 𝑠𝑡𝑎𝑟𝑡 ← 𝑠𝑡𝑎𝑟𝑡 + 2 ⋅ 𝑙𝑒𝑛\n18: end while\n19: 𝑙𝑒𝑛 ← 2 ⋅ 𝑙𝑒𝑛\n20: end while\n21: 𝑓 ← 8347681 ▷ 𝑓 = 256−1 mod 𝑞\n22: for 𝑗 from 0 to 255 do\n23: 𝑤 ← (𝑓 ⋅ 𝑤 ) mod 𝑞\n𝑗 𝑗\n24: end for\n25: return 𝑤\nAlgorithm 43 BitRev (𝑚)\n8\nTransforms a byte by reversing the order of bits in its 8-bit binary expansion.\nInput: A byte 𝑚 ∈ [0, 255].\nOutput: A byte 𝑟 ∈ [0, 255].\n1: 𝑏 ← IntegerToBits(𝑚, 8)\n2: 𝑏 ∈ {0,1}8 ← (0,…,0)\nrev\n3: for 𝑖 from 0 to 7 do\n4: 𝑏 [𝑖] ← 𝑏[7−𝑖]\nrev\n5: end for\n6: 𝑟 ← BitsToInteger(𝑏 ,8)\nrev\n7: return r\n44\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n7.6 Arithmetic Under NTT\nThe NTT converts elements of the ring 𝑅 (where addition and multiplication are denoted by + and ⋅,\n𝑞\nrespectively) into elements of the ring 𝑇 (where addition and multiplication are denoted by + and ∘,\n𝑞\nrespectively). This section gives explicit algorithms for linear algebra over the ring 𝑇 .\n𝑞\nThe ring 𝑇 is defined to be the direct product ring Π255ℤ . Thus, an element 𝑎 ̂∈ 𝑇 is an array of length\n𝑞 𝑖=0 𝑞 𝑞\n256, and its elements are denoted by 𝑎[̂0], 𝑎[̂ 1], … , 𝑎[̂255] ∈ ℤ .\n𝑞\nAlgorithm 44 AddNTT(𝑎,̂ 𝑏̂ )\nComputes the sum 𝑎̂ + 𝑏̂ of two elements 𝑎,̂ 𝑏̂ ∈ 𝑇 .\n𝑞\nInput: 𝑎,̂ 𝑏̂ ∈ 𝑇 .\n𝑞\nOutput: 𝑐 ̂∈ 𝑇 .\n𝑞\n1: for 𝑖 from 0 to 255 do\n2: 𝑐[̂ 𝑖] ← 𝑎[̂ 𝑖] + 𝑏̂[𝑖]\n3: end for\n4: return 𝑐 ̂\nAlgorithm 45 MultiplyNTT(𝑎,̂ 𝑏̂ )\nComputes the product 𝑎̂ ∘𝑏 ̂of two elements 𝑎,̂ 𝑏 ̂ ∈ 𝑇 .\n𝑞\nInput: 𝑎,̂ 𝑏̂ ∈ 𝑇 .\n𝑞\nOutput: 𝑐 ̂∈ 𝑇 .\n𝑞\n1: for 𝑖 from 0 to 255 do\n2: 𝑐[̂ 𝑖] ← 𝑎[̂ 𝑖] ⋅ 𝑏̂[𝑖]\n3: end for\n4: return 𝑐 ̂\nAlgorithm 46 AddVectorNTT(𝐯̂ ,𝐰̂ )\nComputes the sum 𝐯̂ + 𝐰̂ of two vectors 𝐯̂, 𝐰̂ over 𝑇 .\n𝑞\nInput: ℓ ∈ ℕ, 𝐯̂ ∈ 𝑇 ℓ , 𝐰̂ ∈ 𝑇 ℓ .\n𝑞 𝑞\nOutput: 𝐮̂ ∈ 𝑇 ℓ .\n𝑞\n1: for 𝑖 from 0 to ℓ−1 do\n2: 𝐮̂ [𝑖] ← AddNTT(𝐯̂[𝑖], 𝐰̂[𝑖])\n3: end for\n4: return 𝐮̂\n45\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAlgorithm 47 ScalarVectorNTT(𝑐,̂ 𝐯̂ )\nComputes the product 𝑐 ̂ ∘𝐯̂ of a scalar 𝑐 ̂and a vector 𝐯̂ over 𝑇 .\n𝑞\nInput: 𝑐 ̂ ∈ 𝑇 , ℓ ∈ ℕ, 𝐯̂ ∈ 𝑇 ℓ .\n𝑞 𝑞\nOutput: 𝐰̂ ∈ 𝑇 ℓ .\n𝑞\n1: for 𝑖 from 0 to ℓ−1 do\n2: 𝐰̂ [𝑖] ← MultiplyNTT(𝑐,̂ 𝐯̂[𝑖])\n3: end for\n4: return 𝐰̂\nAlgorithm 48 MatrixVectorNTT(𝐌̂ ,𝐯̂ )\nComputes the product 𝐌̂ ∘𝐯̂ of a matrix 𝐌̂ and a vector 𝐯̂ over 𝑇 .\n𝑞\nInput: 𝑘,ℓ ∈ ℕ, 𝐌̂ ∈ 𝑇𝑘×ℓ , 𝐯̂ ∈ 𝑇 ℓ .\n𝑞 𝑞\nOutput: 𝐰̂ ∈ 𝑇 𝑘 .\n𝑞\n1: 𝐰̂ ← 0𝑘\n2: for 𝑖 from 0 to 𝑘 − 1 do\n3: for 𝑗 from 0 to ℓ−1 do\n4: 𝐰̂ [𝑖] ← AddNTT(𝐰̂ [𝑖], MultiplyNTT(𝐌̂ [𝑖, 𝑗], 𝐯̂ [𝑗]))\n5: end for\n6: end for\n7: return 𝐰̂\n46"
  },
  {
    "input": "",
    "summary": "The FIPS 204 module-lattice-based digital signature standard is a cryptographic standard developed by the National Institute of Standards and Technology (NIST) for secure digital signatures. It builds upon lattice-based cryptography, which is considered quantum-resistant. The standard includes guidelines for cryptographic mechanisms, key management, and random number generation, ensuring robustness and security in digital signature applications.",
    "output": "FIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nReferences\n[1] National Institute of Standards and Technology (2023) Digital signature standard (DSS), (U.S. Depart-\nment of Commerce, Washington, DC), Federal Information Processing Standards Publication (FIPS)\n186-5. https://doi.org/10.6028/NIST.FIPS.186-5.\n[2] Barker E (2020) Guideline for using cryptographic standards in the federal government: Cryptographic\nmechanisms, (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special\nPublication (SP) 800-175B, Rev. 1 [or as amended]. https://doi.org/10.6028/NIST.SP.800-175Br1.\n[3] Barker E (2006) Recommendation for obtaining assurances for digital signature applications, National\nInstitute of Standards and Technology, Gaithersburg, MD. NIST Special Publication (SP) 800-89 [or as\namended]. https://doi.org/10.6028/NIST.SP.800-89.\n[4] Langlois A, Stehlé D (2015) Worst-case to average-case reductions for module lattices. Designs, Codes\nand Cryptography 75(3):565–599. https://doi.org/10.1007/s10623-014-9938-4.\n[5] Bai S, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schwabe P, Seiler G, Stehlé D (2020) CRYSTALS-\nDilithium: Algorithm specifications and supporting documentation, Submission to the NIST’s post-\nquantum cryptography standardization process. Available at https://csrc.nist.gov/Projects/post-qua\nntum-cryptography/post-quantum-cryptography-standardization/round-3-submissions.\n[6] Bai S, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schwabe P, Seiler G, Stehlé D (2021) CRYSTALS-\nDilithium: Algorithm specifications and supporting documentation (Version 3.1). Available at https:\n//pq-crystals.org/dilithium/data/dilithium-specification-round3-20210208.pdf.\n[7] National Institute of Standards and Technology (2015) SHA-3 standard: Permutation-based hash and\nextendable-output functions, (U.S. Department of Commerce, Washington, DC), Federal Information\nProcessing Standards Publication (FIPS) 202. https://doi.org/10.6028/NIST.FIPS.202.\n[8] National Institute of Standards and Technology (2015) Secure hash standard (SHS), (U.S. Department\nof Commerce, Washington, DC), Federal Information Processing Standards Publication (FIPS) 180-4.\nhttps://doi.org/10.6028/NIST.FIPS.180-4.\n[9] Barker E (2020) Recommendation for key management: Part 1 - general, (National Institute of\nStandards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-57 Part 1, Rev. 5 [or\nas amended]. https://doi.org/10.6028/NIST.SP.800-57pt1r5.\n[10] Lyubashevsky V (2009) Fiat-Shamir with aborts: Applications to lattice and factoring-based signa-\ntures. Advances in Cryptology – ASIACRYPT 2009, ed Matsui M (Springer Berlin Heidelberg, Berlin,\nHeidelberg), pp 598–616. https://doi.org/10.1007/978-3-642-10366-7_35.\n[11] Lyubashevsky V (2012) Lattice signatures without trapdoors. EUROCRYPT (Springer), Lecture Notes\nin Computer Science, Vol. 7237, pp 738–755. https://doi.org/10.1007/978-3-642-29011-4_43.\n[12] Güneysu T, Lyubashevsky V, Pöppelmann T (2012) Practical lattice-based cryptography: A signature\nscheme for embedded systems. CHES (Springer), Vol. 7428, pp 530–547. https://doi.org/10.1007/97\n8-3-642-33027-8_31.\n[13] Bai S, Galbraith SD (2014) An improved compression technique for signatures based on learning with\nerrors. Topics in Cryptology – CT-RSA 2014, ed Benaloh J (Springer International Publishing, Cham),\npp 28–47. https://doi.org/10.1007/978-3-319-04852-9_2.\n47\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\n[14] Cremers C, Düzlü S, Fiedler R, Janson C, Fischlin M (2021) BUFFing signature schemes beyond\nunforgeability and the case of post-quantum signatures. 2021 IEEE Symposium on Security and\nPrivacy (SP) (IEEE Computer Society, Los Alamitos, CA, USA), pp 1696–1714. https://doi.org/10.110\n9/SP40001.2021.00093.\n[15] Regev O (2005) On lattices, learning with errors, random linear codes, and cryptography. Proceedings\nof the Thirty-Seventh Annual ACM Symposium on Theory of Computing STOC ’05 (Association for\nComputing Machinery, New York, NY, USA), p 84–93. https://doi.org/10.1145/1060590.1060603.\n[16] Kiltz E, Lyubashevsky V, Schaffner C (2018) A concrete treatment of Fiat-Shamir signatures in the\nquantum random-oracle model. Advances in Cryptology – EUROCRYPT 2018, eds Nielsen JB, Rijmen\nV (Springer International Publishing, Cham), pp 552–586. https://doi.org/10.1007/978-3-319-78372\n-7_18.\n[17] Barker E, Barker W (2019) Recommendation for key management: Part 2 -best practices for key\nmanagement organizations, National Institute of Standards and Technology, Gaithersburg, MD. NIST\nSpecial Publication (SP) 800-57 Part 2, Rev. 1. https://doi.org/10.6028/NIST.SP.800-57pt2r1.\n[18] Barker E, Dang Q (2019) Recommendation for key management: Part 3 -application-specific key\nmanagement guidance, National Institute of Standards and Technology, Gaithersburg, MD. NIST\nSpecial Publication (SP) 800-57 Part 3, Rev. 1. http://doi.org/10.6028/NIST.SP.800-57pt3r1.\n[19] Barker E, Kelsey J (2015) Recommendation for random number generation using deterministic\nrandom bit generators, (National Institute of Standards and Technology, Gaithersburg, MD), NIST\nSpecial Publication (SP) 800-90A, Rev. 1. https://doi.org/10.6028/NIST.SP.800-90Ar1.\n[20] Sönmez Turan M, Barker E, Kelsey J, McKay K, Baish M, Boyle M (2018) Recommendation for the\nentropy sources used for random bit generation, (National Institute of Standards and Technology,\nGaithersburg, MD), NIST Special Publication (SP) 800-90B. https://doi.org/10.6028/NIST.SP.800-90B.\n[21] Barker E, Kelsey J, McKay K, Roginsky A, Turan MS (2024) Recommendation for random bit generator\n(RBG) constructions, (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special\nPublication (SP) 800-90C 4pd. https://doi.org/10.6028/NIST.SP.800-90C.4pd.\n[22] Bruinderink LG, Pessl P (2018) Differential fault attacks on deterministic lattice signatures. IACR\nTransactions on Cryptographic Hardware and Embedded Systems (3):21–43. https://doi.org/10.131\n54/tches.v2018.i3.21-43.\n[23] Poddebniak D, Somorovsky J, Schinzel S, Lochter M, Rösler P (2018) Attacking deterministic signature\nschemes using fault attacks. 2018 IEEE European Symposium on Security and Privacy (EuroS&P)\n(IEEE), pp 338–352. https://doi.org/10.1109/EuroSP.2018.00031.\n[24] Samwel N, Batina L, Bertoni G, Daemen J, Susella R (2018) Breaking ed25519 in wolfssl. Topics in\nCryptology–CT-RSA 2018: The Cryptographers’ Track at the RSA Conference 2018, San Francisco, CA,\nUSA, April 16-20, 2018, Proceedings (Springer), pp 1–20. https://doi.org/10.1007/978-3-319-76953\n-0_1.\n[25] Kelsey J, Chang S, Perlner R (2016) SHA-3 Derived Functions: cSHAKE, KMAC, TupleHash and Parallel-\nHash, (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special Publication\n(SP) 800-185 [or as amended]. https://doi.org/10.6028/NIST.SP.800-185.\n[26] National Institute of Standards and Technology (2016) Submission requirements and evaluation\ncriteria for the post-quantum cryptography standardization process. Available at https://csrc.nist.go\n48\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nv/CSRC/media/Projects/Post-Quantum-Cryptography/documents/call-for-proposals-final-dec-201\n6.pdf.\n[27] Alagic G, Apon D, Cooper D, Dang Q, Dang T, Kelsey J, Lichtinger J, Liu YK, Miller C, Moody D, Peralta R,\nPerlner R, Robinson A, Smith-Tone D (2022) Status report on the third round of the NIST post-quantum\ncryptography standardization process (National Institute of Standards and Technology, Gaithersburg,\nMD), NIST Interagency or Internal Report (IR) 8413. https://doi.org/10.6028/NIST.IR.8413-upd1.\n[28] Avanzi R, Bos J, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schanck JM, Schwabe P, Seiler G,\nStehlé D (2020) CRYSTALS-Kyber algorithm specifications and supporting documentation, 3rd\nRound submission to the NIST’s post-quantum cryptography standardization process. Available\nat https://csrc.nist.gov/Projects/post-quantum-cryptography/post-quantum-cryptography-standar\ndization/round-3-submissions.\n[29] Housley R (2009) Cryptographic Message Syntax (CMS), Internet Engineering Task Force (IETF) request\nfor comments (RFC) 5652, https://doi.org/10.17487/RFC5652.\n[30] Schnorr C (1990) Efficient identification and signatures for smart cards. Advances in Cryptology —\nCRYPTO’ 89 Proceedings, ed Brassard G (Springer New York, New York, NY), pp 239–252. https:\n//doi.org/10.1007/0-387-34805-0_22.\n[31] Josefsson S, Liusvaara I (2017) Edwards-Curve Digital Signature Algorithm (EdDSA), RFC 8032. https:\n//doi.org/10.17487/RFC8032.\n[32] Lyubashevsky V (2021) Round 3 Official Comment: CRYSTALS-DILITHIUM. Available at https://groups\n.google.com/a/list.nist.gov/g/pqc-forum/c/BjfjRMIdnhM/m/W7kkVOFDBAAJ.\n[33] Hamburg M (2024) Dilithium hint unpacking. Available at https://groups.google.com/a/list.nist.gov/\ng/pqc-forum/c/TQo-qFbBO1A/m/YcYKjMblAAAJ.\n[34] Mattsson (on behalf of Sönke Jendral) JP (2024) Dilithium hint unpacking. Available at https://grou\nps.google.com/a/list.nist.gov/g/pqc-forum/c/TQo-qFbBO1A/m/sLjseYlSAwAJ.\n[35] Lee S (2024) Updates for FIPS 203. Available at https://groups.google.com/a/list.nist.gov/g/pqc-for\num/c/Rb0nFvfFTEQ/m/lw-k7tVdBQAJ.\n49\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAppendix A — Montgomery Multiplication\nThis document uses modular multiplications of the form 𝑎 ⋅ 𝑏 modulo 𝑞. This is an expensive operation\nthat is often sped up in practice through the use of Montgomery Multiplication.\nIf 𝑎 is an integer modulo 𝑞, then its Montgomery form with multiplier 232 is 𝑟 ≡ 𝑎 ⋅ 232 mod 𝑞. 13\nSuppose that two integers 𝑢 and 𝑣 modulo 𝑞 are in Montgomery form. Their product modulo 𝑞 is\n𝑐 = 𝑢 ⋅ 𝑣 ⋅ 2−32 , which is also in Montgomery form. If the integer product of 𝑢 and 𝑣 does not overflow a\n64-bit signed integer, then one can compute 𝑐 by first performing the integer multiplication 𝑢 ⋅ 𝑣 and then\n“reducing” the product by multiplying by 2−32 modulo 𝑞. This last operation can be done efficiently as\nfollows.\nThe MontgomeryReduce function takes an integer 𝑎 with absolute value at most 231𝑞 as input. It returns\nan integer 𝑟 such that 𝑟 = 𝑎 ⋅ 2−32 mod 𝑞. The output is in Montgomery form with multiplier 232 mod 𝑞.\nAn implementation would typically input a 64-bit input and return a 32-bit output. The “modulo 232”\noperation simply extracts the 32 least significant bits of a 64-bit value. The value (𝑎 − 𝑡 ⋅ 𝑞) on line 3 is an\ninteger divisible by 232 . Therefore, the division consists of simply taking the most significant 32 bits of a\n64-bit value. Extracting the four low-or high-order bytes is often done using typecasting.\nAlgorithm 49 MontgomeryReduce(𝑎)\nComputes 𝑎 ⋅ 2−32 mod 𝑞.\nInput: Integer 𝑎 with −231𝑞 ≤ 𝑎 ≤ 231𝑞.\nOutput: 𝑟 ≡ 𝑎 ⋅ 2−32 mod 𝑞.\n1: QINV ← 58728449 ▷ the inverse of 𝑞 modulo 232\n2: 𝑡 ← ((𝑎 mod 232) ⋅ QINV) mod 232\n3: 𝑟 ← (𝑎 − 𝑡 ⋅ 𝑞)/232\n4: return 𝑟\nWith this algorithm, the modular product of 𝑎 and 𝑏 is 𝑐 = MontgomeryReduce(𝑎 ⋅ 𝑏), where 𝑎, 𝑏, and 𝑐\nare in Montgomery form. The return value of the algorithm is not necessarily less than 𝑞 in absolute value,\nbut it is less than 2𝑞 in absolute value. This is not a concern in practice since the objective of Montgomery\nMultiplication is to efficiently work with modular values that fit in a 32-bit register. If necessary, the result\ncan be normalized to an integer in (−𝑞, 𝑞) using a comparison and an integer addition.\nConverting an integer modulo 𝑞 to Montgomery form by multiplying by 232 modulo 𝑞 is an expensive\noperation. When a sequence of modular operations is to be performed, the operands are converted once\nto Montgomery form. The operations are then performed, and the factor 232 is extracted from the final\nresult.\n13This section does not distinguish between different versions of the “mod” operator. There are three such versions\nof “𝑥 = 𝑎 modulo 𝑞”: i) 𝑥 ∈ [0, 𝑞 − 1]; ii) 𝑥 ∈ [−⌈𝑞/2⌉, ⌊𝑞/2⌋] ; iii) 𝑥 ∈ [−𝑞 + 1, 𝑞 − 1]. The last version\ncorresponds to the ‶ %″ operator in most programming languages.\n50"
  },
  {
    "input": "What are the pre-computed values of 𝜁BitRev 8 (𝑘) mod 𝑞 for 𝑘 = 1 to 255 used in the NTT Algorithms 41 and 42?",
    "summary": "The FIPS 204 module-lattice-based digital signature standard includes a pre-computed array of values called zetas, used in NTT algorithms. This array, named zetas[1..255], contains specific modular values for bit reversal operations. The values are provided in the appendix for use in cryptographic implementations.",
    "output": "FIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAppendix B — Zetas Array\nThe values 𝜁BitRev 8 (𝑘) mod 𝑞 for 𝑘 = 1,…,255 used in the NTT Algorithms 41 and 42 may be pre-computed\nand stored in an array zetas[1..255]. This table of zetas is given below.\nzetas[0..255] = {\n0, 4808194, 3765607, 3761513, 5178923, 5496691, 5234739, 5178987,\n7778734, 3542485, 2682288, 2129892, 3764867, 7375178, 557458, 7159240,\n5010068, 4317364, 2663378, 6705802, 4855975, 7946292, 676590, 7044481,\n5152541, 1714295, 2453983, 1460718, 7737789, 4795319, 2815639, 2283733,\n3602218, 3182878, 2740543, 4793971, 5269599, 2101410, 3704823, 1159875,\n394148, 928749, 1095468, 4874037, 2071829, 4361428, 3241972, 2156050,\n3415069, 1759347, 7562881, 4805951, 3756790, 6444618, 6663429, 4430364,\n5483103, 3192354, 556856, 3870317, 2917338, 1853806, 3345963, 1858416,\n3073009, 1277625, 5744944, 3852015, 4183372, 5157610, 5258977, 8106357,\n2508980, 2028118, 1937570, 4564692, 2811291, 5396636, 7270901, 4158088,\n1528066, 482649, 1148858, 5418153, 7814814, 169688, 2462444, 5046034,\n4213992, 4892034, 1987814, 5183169, 1736313, 235407, 5130263, 3258457,\n5801164, 1787943, 5989328, 6125690, 3482206, 4197502, 7080401, 6018354,\n7062739, 2461387, 3035980, 621164, 3901472, 7153756, 2925816, 3374250,\n1356448, 5604662, 2683270, 5601629, 4912752, 2312838, 7727142, 7921254,\n348812, 8052569, 1011223, 6026202, 4561790, 6458164, 6143691, 1744507,\n1753, 6444997, 5720892, 6924527, 2660408, 6600190, 8321269, 2772600,\n1182243, 87208, 636927, 4415111, 4423672, 6084020, 5095502, 4663471,\n8352605, 822541, 1009365, 5926272, 6400920, 1596822, 4423473, 4620952,\n6695264, 4969849, 2678278, 4611469, 4829411, 635956, 8129971, 5925040,\n4234153, 6607829, 2192938, 6653329, 2387513, 4768667, 8111961, 5199961,\n3747250, 2296099, 1239911, 4541938, 3195676, 2642980, 1254190, 8368000,\n2998219, 141835, 8291116, 2513018, 7025525, 613238, 7070156, 6161950,\n7921677, 6458423, 4040196, 4908348, 2039144, 6500539, 7561656, 6201452,\n6757063, 2105286, 6006015, 6346610, 586241, 7200804, 527981, 5637006,\n6903432, 1994046, 2491325, 6987258, 507927, 7192532, 7655613, 6545891,\n5346675, 8041997, 2647994, 3009748, 5767564, 4148469, 749577, 4357667,\n3980599, 2569011, 6764887, 1723229, 1665318, 2028038, 1163598, 5011144,\n3994671, 8368538, 7009900, 3020393, 3363542, 214880, 545376, 7609976,\n3105558, 7277073, 508145, 7826699, 860144, 3430436, 140244, 6866265,\n6195333, 3123762, 2358373, 6187330, 5365997, 6663603, 2926054, 7987710,\n8077412, 3531229, 4405932, 4606686, 1900052, 7598542, 1054478, 7648983 }\n51"
  },
  {
    "input": "What are the minimum allowable loop iteration and XOF output byte limits for each algorithm in the FIPS 204 module-lattice-based digital signature standard to ensure a probability of approximately 2−256 or less of failure?",
    "summary": "The FIPS 204 standard includes four algorithms with loops that have an indeterminate number of iterations, but the expected number is a small constant. Three of these algorithms use XOFs, where the output size is proportional to the number of iterations. Implementations should not set lower bounds on iterations or XOF output unless specified in Table 3, which ensures a probability of failure of 2^-256 or less. The table provides minimum limits for each algorithm to achieve this security level, and exceeding these limits requires destroying intermediate results.",
    "output": "FIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAppendix C — Loop Bounds\nThere are four algorithms in this standard with loops that iterate an indeterminate number of times,\nthough the expected number of iterations is a small constant in each case. Three of the four algorithms\ninvolve sampling from the output of an XOF, where the amount of output required from the XOF is\nproportional to the number of iterations that are performed.\nImplementations should not bound the number of iterations in these loops or the amount of output that\nis extracted from the XOFs when executing these functions.14 If an implementation bounds the number of\niterations or the number of bytes that may be extracted from the XOF, it shall not use a limit lower than\nthose presented in Table 3. The limits yield a probability of approximately 2−256 (or less) of being reached\nin a correct implementation of this standard. The probability is calculated under standard assumptions\nabout the output distributions of XOFs and hash functions.\nTable 3. While loop and XOF output limits for a 2−256 or less probability of failure\nAlgorithm Minimum allowable limit Minimum allowable limit\n(Loop iterations) (XOF output bytes)\nML-DSA.Sign_internal 814 N/A\nRejBoundedPoly 481 481\nRejNTTPoly 298 894\nSampleInBall 121 221\nImplementations may limit the number of iterations of a while loop or the number of bytes drawn from\nthe XOF to not exceed the maximum values in Table 3. If this option is used and the maximum number of\niterations or XOF output bytes is exceeded, the algorithm shall destroy all intermediate results. If a return\nvalue or exception is produced, it shall be the same for any execution in which the maximum number of\niterations or output bytes is exceeded.\nThere is essentially no performance penalty for using a larger than necessary limit, as the limit will only\nbe reached on a faulty execution of the loop. Because of this, limits were chosen that lower-bound the\nprobability of reaching them to 2−256 .\nML-DSA.Sign_internal\nTable 1 contains the expected repetitions in the rejection sampling loop of ML-DSA.Sign_internal. These\nare 4.25, 5.1, and 3.85 for Categories 2, 3, and 5, respectively. Therefore, the probability that the number\nof repetitions exceeds 𝑛 is less than or equal to (5.1−1 ) 𝑛 for all categories. Solving (5.1−1) 𝑛 ≤ 2−256\n5.1 5.1\nyields 𝑛 = 814.\nRejBoundedPoly\nLet 𝑋 be the number of coefficients generated in 𝑛 iterations of the while loop of RejBoundedPoly15.\nThen 𝑋 is 𝐵𝑖𝑛𝑜𝑚𝑖𝑎𝑙(2𝑛, 𝜃), where 𝜃 is either 9 or 15, depending on the parameter 𝜂. For 𝜃 = 9 ,\n16 16 16\nthe probability that fewer than 256 coefficients are generated in 481 iterations of the main loop in\nRejBoundedPoly is less than 2−256 . Each iteration consumes one byte of output from H.\n14RejBoundedPoly, RejNTTPoly, and SampleInBall use the incremental APIs described in Section 3.7 in order to\nextract the amount of output needed from the XOFs, given that the amount needed is not known in advance.\n15Note that 0, 1, or 2 coefficients are generated in each iteration.\n52\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nRejNTTPoly\nThe number of valid coefficients generated in 𝑛 calls to G.Squeeze in RejNTTPoly is 𝐵𝑖𝑛𝑜𝑚𝑖𝑎𝑙(𝑛, 2−23𝑞).\nIt follows that after 298 calls, the probability of failure is less than 2−256 . Each iteration consumes three\nbytes of output from G.\nSampleInBall\nStep 9 in SampleInBall is executed every time a pseudorandom byte is greater than a value 𝑖 in the range\n[256 − 𝜏,255]. The parameter 𝜏 is 39, 49, and 60 for categories 2, 3, and 5, respectively. Therefore, the\nprobability that this step is executed more than 𝑛 times in a single iteration of the for loop is less than or\nequal to ( 59 )𝑛 ≤ ( 𝜏 )𝑛 . Solving ( 59 )𝑛 ≤ 2−256 yields a bound of 𝑛 = 121 for the while loop on step\n256 256 256\n8 of SampleInBall. Each iteration consumes one byte of output from H.\nEach call to SampleInBall extracts eight bytes from H and then performs 𝜏 iterations of the for loop, each\nof which extracts an indeterminate amount of data from H. The probability that more than 𝑛 bytes of\noutput will be required from H during an execution of SampleInBall for a given value of 𝜏 is\n⎧ 1 if 𝑛 ≤ 8\n{\n𝑃(𝑛,𝜏) = 0 if 𝜏 = 1 and 𝑛 > 8 .\n⎨\n⎩ { (257−𝜏 )𝑃(𝑛−1,𝜏 −1)+(𝜏−1 )𝑃(𝑛−1,𝜏) if 𝜏 > 1 and 𝑛 > 8\n256 256\n𝑃 (𝑛, 60) is less than 2−256 when 𝑛 is 221 or greater. Implementations may limit the number of bytes\nextracted from H to 𝑛 ≥ 221. Such implementations must stop the execution of SampleInBall, return a\nconstant that represents an error and no other output, and destroy all intermediate results after 𝑛 bytes\nof output have been consumed.\n53"
  },
  {
    "input": "What are the key differences between Version 3.1 of CRYSTALS-DILITHIUM and the final ML-DSA standard as described in the FIPS 204 document?",
    "summary": "ML-DSA is based on Version 3.1 of CRYSTALS-DILITHIUM, which has minor changes from the NIST version. The signing algorithm increases the bit lengths of certain variables to address security issues and allows for both deterministic and pseudorandom generation of the private random seed. The final ML-DSA standard includes a restored input check for the hint unpacking algorithm and modifies the ExpandMask function to use bits from the beginning of H's output.",
    "output": "FIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nAppendix D — Differences from the CRYSTALS-DILITHIUM Submission\nML-DSA is derived from Version 3.1 of CRYSTALS-DILITHIUM [6]. Version 3.1 differs slightly from the most\nrecent version that appears on the NIST website (i.e., Version 3 CRYSTALS-DILITHIUM [5]). Appendices D.1,\nD.2, and D.3 document the differences between Versions 3 and 3.1, the differences between Version 3.1\nand the initial public draft of the ML-DSA, and the differences between the initial public draft and the\nML-DSA standard as published in this document, respectively.\nD.1 Differences Between Version 3.1 and the Round 3 Version of CRYSTALS-\nDILITHIUM\nThe lengths of the variables 𝜌′ (private random seed) and 𝜇 (message representative) in the signing\nalgorithm were increased from 384 to 512 bits. The increase in the length of 𝜇 corrects a security flaw\nthat appeared in the third-round submission, where a collision attack against SHAKE256 with a 384-bit\noutput would make it so that parameters targeting NIST security strength category 5 could only meet\ncategory 4 [32].\nAdditionally, the length of the variable 𝑡𝑟 (the hash of the public key) was reduced from 384 to 256 bits.\nIn key generation, the variable 𝜍 was relabeled as 𝜌′ and increased in size from 256 bits to 512 bits.\nD.2 Differences Between Version 3.1 of CRYSTALS-DILITHIUM and FIPS 204\nInitial Public Draft\nIn order to ensure the properties noted in [14], ML-DSA increases the length of 𝑡𝑟 to 512 bits and increases\nthe length of 𝑐 ̃to 384 and 512 bits for the parameter sets ML-DSA-65 and ML-DSA-87, respectively. In\ndraft ML-DSA, only the first 256 bits of 𝑐 ̃are used in the generation of 𝑐.\nIn Version 3.1 of the CRYSTALS-DILITHIUM submission, the default version of the signing algorithm is\ndeterministic with 𝜌′ being generated pseudorandomly from the signer’s private key and the message,\nand an optional version of the signing algorithm has 𝜌′ sampled instead as a 512-bit random string. In\nML-DSA, 𝜌′ is generated by a “hedged” procedure in which 𝜌′ is pseudorandomly derived from the signer’s\nprivate key, the message, and a 256-bit string 𝑟𝑛𝑑, which should be generated by an Approved RBG by\ndefault. The ML-DSA standard also allows for an optional deterministic version in which 𝑟𝑛𝑑 is a 256-bit\nconstant string.\nThe draft ML-DSA standard also included pseudocode that unintentionally omitted a check for malformed\ninput while unpacking the hint [33]. Failure to perform this check results in a signature scheme that is not\nstrongly existentially unforgeable [34].\nD.3 Changes From FIPS 204 Initial Public Draft\nIn the final version of the ML-DSA standard, the omitted malformed input check was restored to the hint\nunpacking algorithm (Algorithm 21). Additionally, in the final version of ML-DSA, all of the bits of 𝑐 ̃are\nused in the generation of 𝑐 (Algorithm 29), and ExpandMask (Algorithm 34) is modified to take output\nbits from the beginning of the output of H.\nBased on comments that were submitted on the draft version, more details were provided for the pre-hash\nversion HashML-DSA in Section 5.4. These modifications include domain separation for the cases in which\nthe message is signed directly and cases in which a digest of the message is signed. The changes were\nmade by explicitly defining external functions for both versions of the signing and verification functions\n54\nFIPS 204 MODULE-LATTICE-BASED DIGITAL SIGNATURE STANDARD\nthat call an internal function corresponding to the signing or verification functions from the draft FIPS.\nDomain separation is included in the input to the internal function (see Algorithms 2, 3, 4, 5, 7, and 8).\nTo simplify APIs and for testing purposes, this document also introduced a similar external/internal split\nfor key generation (see Algorithms 1 and 6), but this is a purely editorial change, as the external key\ngeneration algorithm is functionally equivalent to the key-generation algorithm from the draft FIPS.\nFinally, to offer misuse resistance against the possibility that keys for different parameter sets might be\nexpanded from the same seed [35], domain separation was added to line 1 of Algorithm 6.\n55"
  }
]