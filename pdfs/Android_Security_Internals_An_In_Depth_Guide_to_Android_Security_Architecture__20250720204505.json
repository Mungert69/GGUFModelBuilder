[
  {
    "start": 1,
    "end": 11,
    "text": "Android Security\nA Deep Dive into Android Security\nInternals\nThere are more than one billion Android About the online account management\ndevices in use today, each one a potential framework and how Google accounts\ntarget. Unfortunately, many fundamental integrate with Android\nAndroid security features have been little\nAbout the implementation of verified boot,\nmore than a black box to all but the most\ndisk encryption, lockscreen, and other\nelite security professionals—until now.\ndevice security features\nIn Android Security Internals, top Android\nHow Android’s bootloader and recovery OS\nsecurity expert Nikolay Elenkov takes us\nare used to perform full system updates,\nunder the hood of the Android security sys­\nand how to obtain root access\ntem. Elenkov describes Android security archi­\ntecture from the bottom up, delving into the\nWith its unprecedented level of depth and\nimple mentation of major security­related\ndetail, Android Security Internals is a must­\ncomponents and subsystems, like Binder IPC,\nhave for any security­minded Android\npermissions, cryptographic providers, and\ndeveloper.\ndevice administration.\nYou’ll learn: About the Author\nHow Android permissions are declared,\nused, and enforced Nikolay Elenkov has been working on\nenter prise security–related projects for\nHow Android manages application more than 10 years. He became interested\npackages and employs code signing to in Android shortly after the initial public\nverify their authenticity release and has been developing Android\napplications since version 1.5. His work\nHow Android implements the Java Cryp ­\nhas led to the discovery and correction\ntog raphy Architecture (JCA) and Java Secure\nof significant Android security flaws. He\nSocket Extension (JSSE) frameworks\nwrites about Android security on his highly\nAbout Android’s credential storage system regarded blog, http://nelenkov.blogspot.com/.\nand APIs, which let applications store\ncryptographic keys securely\nElenkov\nTHE FINEST IN GEEK ENTERTAINMENT™\nwww.nostarch.com\n$49.95 ($51.95 CDN) Shelve In: ComputerS/SeCurIty Nikolay Elenkov\nForeword by Jon Sawyer\nAndroid\nSecurity\nInternals\nCovers Android 4.4\nAn In-Depth Guide to\nAndroid’s Security Architecture\n“I LIE FLAT.” This book uses a durable binding that won’t snap shut.\nSFI-00000\nAndroid Security\nA Deep Dive into Android Security\nInternals\nThere are more than one billion Android About the online account management\ndevices in use today, each one a potential framework and how Google accounts\ntarget. Unfortunately, many fundamental integrate with Android\nAndroid security features have been little\nAbout the implementation of verified boot,\nmore than a black box to all but the most\ndisk encryption, lockscreen, and other\nelite security professionals—until now.\ndevice security features\nIn Android Security Internals, top Android\nHow Android’s bootloader and recovery OS\nsecurity expert Nikolay Elenkov takes us\nare used to perform full system updates,\nunder the hood of the Android security sys­\nand how to obtain root access\ntem. Elenkov describes Android security archi­\ntecture from the bottom up, delving into the\nWith its unprecedented level of depth and\nimple mentation of major security­related\ndetail, Android Security Internals is a must­\ncomponents and subsystems, like Binder IPC,\nhave for any security­minded Android\npermissions, cryptographic providers, and\ndeveloper.\ndevice administration.\nYou’ll learn: About the Author\nHow Android permissions are declared,\nused, and enforced Nikolay Elenkov has been working on\nenter prise security–related projects for\nHow Android manages application more than 10 years. He became interested\npackages and employs code signing to in Android shortly after the initial public\nverify their authenticity release and has been developing Android\napplications since version 1.5. His work\nHow Android implements the Java Cryp ­\nhas led to the discovery and correction\ntog raphy Architecture (JCA) and Java Secure\nof significant Android security flaws. He\nSocket Extension (JSSE) frameworks\nwrites about Android security on his highly\nAbout Android’s credential storage system regarded blog, http://nelenkov.blogspot.com/.\nand APIs, which let applications store\ncryptographic keys securely\nElenkov\nTHE FINEST IN GEEK ENTERTAINMENT™\nwww.nostarch.com\n$49.95 ($51.95 CDN) Shelve In: ComputerS/SeCurIty Nikolay Elenkov\nForeword by Jon Sawyer\nAndroid\nSecurity\nInternals\nCovers Android 4.4\nAn In-Depth Guide to\nAndroid’s Security Architecture\n“I LIE FLAT.” This book uses a durable binding that won’t snap shut.\nSFI-00000\naNDROID sECURITY INTERNaLs\na N D R O I D\ns E C U R I T Y\nIN T E R NaLs\nan In -Dep th Guide t o\nan droid ’s security\narc hitecture\nby Nikolay Elenkov\nSan Francisco\naNDROID sECURITY INTERNaLs. Copyright © 2015 by Nikolay Elenkov.\nAll rights reserved. No part of this work may be reproduced or transmitted in any form or by any means,\nelectronic or mechanical, including photocopying, recording, or by any information storage or retrieval\nsystem, without the prior written permission of the copyright owner and the publisher.\nPrinted in USA\nFirst printing\n18 17 16 15 14 1 2 3 4 5 6 7 8 9\nISBN-10: 1-59327-581-1\nISBN-13: 978-1-59327-581-5 SFI-00000\nPublisher: William Pollock\nProduction Editor: Alison Law\nCover Illustration: Garry Booth\nInterior Design: Octopod Studios\nDevelopmental Editor: William Pollock\nTechnical Reviewer: Kenny Root\nCopyeditor: Gillian McGarvey\nCompositor: Susan Glinert Stevens\nProofreader: James Fraleigh\nIndexer: BIM Proofreading & Indexing Services\nFor information on distribution, translations, or bulk sales, please contact No Starch Press, Inc. directly:\nNo Starch Press, Inc.\n245 8th Street, San Francisco, CA 94103\nphone: 415.863.9900; info@nostarch.com\nwww.nostarch.com\nLibrary of Congress Control Number: 2014952666\nNo Starch Press and the No Starch Press logo are registered trademarks of No Starch Press, Inc. Other\nproduct and company names mentioned herein may be the trademarks of their respective owners. Rather\nthan use a trademark symbol with every occurrence of a trademarked name, we are using the names only\nin an editorial fashion and to the benefit of the trademark owner, with no intention of infringement of the\ntrademark.\nThe Android robot is reproduced or modified from work created and shared by Google and used according\nto terms described in the Creative Commons 3.0 Attribution License.\nThe information in this book is distributed on an “As Is” basis, without warranty. While every precaution\nhas been taken in the preparation of this work, neither the author nor No Starch Press, Inc. shall have any\nliability to any person or entity with respect to any loss or damage caused or alleged to be caused directly or\nindirectly by the information contained in it.\nabout the author\nNikolay Elenkov has been working on enterprise security projects for\nthe past 10 years. He has developed security software on various plat-\nforms, ranging from smart cards and HSMs to Windows and Linux\nservers. He became interested in Android shortly after the initial public\nrelease and has been developing applications for it since version 1.5.\nNikolay’s interest in Android internals intensified after the release of\nAndroid 4.0 (Ice Cream Sandwich), and for the past three years he’s\nbeen documenting his findings and writing about Android security on\nhis blog, http://nelenkov.blogspot.com/.\nabout the Technical Reviewer\nKenny Root has been a core contributor to the Android platform at\nGoogle since 2009, where his focus has been primarily on security and\ncryptography. He is the author of ConnectBot, the first SSH app for\nAndroid, and is an avid open source contributor. When he’s not hack-\ning on software, he’s spending time with his wife and two boys. He is an\nalumnus of Stanford University, Columbia University, Chinese University\nof Hong Kong, and Baker College, but he’s originally from Kansas City,\nwhich has the best barbecue.\nBRIEf CONTENTs\nForeword by Jon Sawyer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xvii\nAcknowledgments  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xix\nIntroduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .xxi\nChapter 1: Android’s Security Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1\nChapter 2: Permissions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .21\nChapter 3: Package Management  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\nChapter 4: User Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .87\nChapter 5: Cryptographic Providers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .115\nChapter 6: Network Security and PKI  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145\nChapter 7: Credential Storage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .171\nChapter 8: Online Account Management  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191\nChapter 9: Enterprise Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .215\nChapter 10: Device Security  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 251\nChapter 11: NFC and Secure Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .289\nChapter 12: SELinux . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .319\nChapter 13: System Updates and Root Access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .349\nIndex  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 377\nCONTENTs IN D E TaIL\nFOREwORD by Jon sawyer xvii\naCkNOwLEDgmENTs xix\nINTRODUCTION xxi\nWho This Book Is For  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .xxii\nPrerequisites  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxiii\nAndroid Versions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxiii\nHow Is This Book Organized? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxiv\nConventions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxv\n1\naNDROID’s sECURITY mODEL 1\nAndroid’s Architecture  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1\nLinux Kernel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\nNative Userspace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\nDalvik VM  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\nJava Runtime Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\nSystem Services  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\nInter-Process Communication  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\nBinder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\nAndroid Framework Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\nApplications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\nAndroid’s Security Model  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\nApplication Sandboxing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\nPermissions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\nIPC  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\nCode Signing and Platform Keys . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\nMulti-User Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\nSELinux  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\nSystem Updates  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\nVerified Boot  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\nSummary  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n2\nPERmIssIONs 21\nThe Nature of Permissions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\nRequesting Permissions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\nPermission Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\nPermission Protection Levels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\nPermission Assignment  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\nPermission Enforcement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30\nKernel-Level Enforcement  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30\nNative Daemon-Level Enforcement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\nFramework-Level Enforcement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\nSystem Permissions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\nSignature Permissions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39\nDevelopment Permissions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39\nShared User ID  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40\nCustom Permissions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\nPublic and Private Components  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\nActivity and Service Permissions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44\nBroadcast Permissions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45\nContent Provider Permissions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46\nStatic Provider Permissions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46\nDynamic Provider Permissions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\nPending Intents  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49\nSummary  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\n3\nPaCkagE maNagEmENT 51\nAndroid Application Package Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\nCode Signing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53\nJava Code Signing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53\nAndroid Code Signing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\nAPK Install Process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61\nLocation of Application Packages and Data . . . . . . . . . . . . . . . . . . . . . . . . 62\nActive Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\nInstalling a Local Package  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66\nUpdating a Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72\nInstalling Encrypted APKs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76\nForward Locking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79\nAndroid 4 .1 Forward Locking Implementation  . . . . . . . . . . . . . . . . . . . . . . 80\nEncrypted Apps and Google Play . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82\nPackage Verification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83\nAndroid Support for Package Verification  . . . . . . . . . . . . . . . . . . . . . . . . . 84\nGoogle Play Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85\nSummary  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86\n4\nUsER maNagEmENT 87\nMulti-User Support Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87\nTypes of Users . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90\nThe Primary User (Owner)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90\nSecondary Users . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91\nRestricted Profiles  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92\nGuest User . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94\nx Contents in Detail\nUser Management  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95\nCommand-Line Tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95\nUser States and Related Broadcasts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95\nUser Metadata . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96\nThe User List File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96\nUser Metadata Files  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97\nUser System Directory  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99\nPer-User Application Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99\nApplication Data Directories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100\nApplication Sharing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\nExternal Storage  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104\nExternal Storage Implementations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104\nMulti-User External Storage  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105\nExternal Storage Permissions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111\nOther Multi-User Features  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112\nSummary  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113\n5\nCRYPTOgRaPhIC PROvIDERs 115\nJCA Provider Architecture  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116\nCryptographic Service Providers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116\nJCA Engine Classes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119\nObtaining an Engine Class Instance  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119\nAlgorithm Names  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120\nSecureRandom . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120\nMessageDigest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121\nSignature . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122\nCipher . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123\nMac  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127\nKey . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128\nSecretKey and PBEKey . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128\nPublicKey, PrivateKey, and KeyPair . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\nKeySpec  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\nKeyFactory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\nSecretKeyFactory  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130\nKeyPairGenerator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131\nKeyGenerator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131\nKeyAgreement  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132\nKeyStore  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133\nCertificateFactory and CertPath  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135\nCertPathValidator and CertPathBuilder  . . . . . . . . . . . . . . . . . . . . . . . . . . 136\nAndroid JCA Providers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137\nHarmony’s Crypto Provider  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137\nAndroid’s Bouncy Castle Provider . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137\nAndroidOpenSSL Provider . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140\nOpenSSL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142\nUsing a Custom Provider . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142\nSpongy Castle  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143\nSummary  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\nContents in Detail xi\n6\nNETwORk sECURITY aND PkI 145\nPKI and SSL Overview  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146\nPublic Key Certificates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146\nDirect Trust and Private CAs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148\nPublic Key Infrastructure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148\nCertificate Revocation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150\nJSSE Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151\nSecure Sockets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152\nPeer Authentication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152\nHostname Verification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154\nAndroid JSSE Implementation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155\nCertificate Management and Validation . . . . . . . . . . . . . . . . . . . . . . . . . . 156\nCertificate Blacklisting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162\nReexamining the PKI Trust Model  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166\nSummary  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170\n7\nCREDENTIaL sTORagE 171\nVPN and Wi-Fi EAP Credentials . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172\nAuthentication Keys and Certificates  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172\nThe System Credential Store . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173\nCredential Storage Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174\nThe keystore Service  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174\nKey Blob Versions and Types  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176\nAccess Restrictions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176\nkeymaster Module and keystore Service Implementation  . . . . . . . . . . . . . . 176\nNexus 4 Hardware-Backed Implementation  . . . . . . . . . . . . . . . . . . . . . . . 178\nFramework Integration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180\nPublic APIs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181\nThe KeyChain API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181\nKeyChain API Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185\nControlling Access to the Keystore . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186\nAndroid Keystore Provider . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188\nSummary  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189\n8\nONLINE aCCOUNT maNagEmENT 191\nAndroid Account Management Overview  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 192\nAccount Management Implementation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192\nAccountManagerService and AccountManager  . . . . . . . . . . . . . . . . . . . . 193\nAuthenticator Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194\nThe Authenticator Module Cache  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194\nAccountManagerService Operations and Permissions  . . . . . . . . . . . . . . . . 195\nThe Accounts Database . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198\nMulti-User Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201\nAdding an Authenticator Module  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203\nxii Contents in Detail\nGoogle Accounts Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206\nThe Google Login Service  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206\nGoogle Services Authentication and Authorization  . . . . . . . . . . . . . . . . . . 209\nGoogle Play Services  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211\nSummary  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213\n9\nENTERPRIsE sECURITY 215\nDevice Administration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216\nImplementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217\nAdding a Device Administrator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223\nEnterprise Account Integration  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226\nVPN Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229\nPPTP  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229\nL2TP/IPSec . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229\nIPSec Xauth  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230\nSSL-Based VPNs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230\nLegacy VPN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231\nApplication-Based VPNs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236\nMulti-User Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239\nWi-Fi EAP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242\nEAP Authentication Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243\nAndroid Wi-Fi Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244\nEAP Credentials Management  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245\nAdding an EAP Network with WifiManager . . . . . . . . . . . . . . . . . . . . . . . 248\nSummary  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250\n10\nDEvICE sECURITY 251\nControlling OS Boot-Up and Installation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252\nBootloader . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252\nRecovery  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253\nVerified Boot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254\ndm-verity Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254\nAndroid Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255\nEnabling Verified Boot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256\nDisk Encryption  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258\nCipher Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259\nKey Derivation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260\nDisk Encryption Password  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261\nChanging the Disk Encryption Password  . . . . . . . . . . . . . . . . . . . . . . . . . 262\nEnabling Encryption  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263\nBooting an Encrypted Device  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265\nScreen Security  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268\nLockscreen Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268\nKeyguard Unlock Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269\nBrute-Force Attack Protection  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276\nContents in Detail xiii\nSecure USB Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277\nADB Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277\nThe Need for Secure ADB  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279\nSecuring ADB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\nSecure ADB Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281\nADB Authentication Keys . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282\nVerifying the Host Key Fingerprint . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282\nAndroid Backup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283\nAndroid Backup Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283\nBackup File Format  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284\nBackup Encryption  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286\nControlling Backup Scope  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287\nSummary  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288\n11\nNFC aND sECURE ELEmENTs 289\nNFC Overview  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289\nAndroid NFC Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\nReader/Writer Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\nPeer-to-Peer Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 294\nCard Emulation Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 295\nSecure Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 295\nSE Form Factors in Mobile Devices  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296\nAccessing the Embedded SE  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299\nAndroid SE Execution Environment  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302\nUICC as a Secure Element . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 305\nSoftware Card Emulation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310\nAndroid 4 .4 HCE Architecture  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310\nAPDU Routing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311\nWriting an HCE Service . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315\nSecurity of HCE Applications  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 317\nSummary  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 318\n12\nsELINUx 319\nSELinux Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320\nSELinux Architecture  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320\nMandatory Access Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321\nSELinux Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 322\nSecurity Contexts  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 322\nSecurity Context Assignment and Persistence  . . . . . . . . . . . . . . . . . . . . . . 324\nSecurity Policy  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324\nPolicy Statements  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324\nType Transition Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\nDomain Transition Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 328\nAccess Vector Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 329\nAndroid Implementation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330\nKernel Changes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331\nUserspace Changes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332\nDevice Policy Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339\nPolicy Event Logging  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 340\nxiv Contents in Detail\nAndroid 4 .4 SELinux Policy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 340\nPolicy Overview  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 341\nEnforcing Domains  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 342\nUnconfined Domains . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 344\nApp Domains . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 345\nSummary  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 347\n13\nsYsTEm UPDaTEs aND ROOT aCCEss 349\nBootloader  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350\nUnlocking the Bootloader . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350\nFastboot Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 352\nRecovery . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 354\nStock Recovery . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 354\nCustom Recoveries  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 363\nRoot Access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 364\nRoot Access on Engineering Builds  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 365\nRoot Access on Production Builds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 368\nRooting by Changing the boot or system Image  . . . . . . . . . . . . . . . . . . . . 369\nRooting by Flashing an OTA Package . . . . . . . . . . . . . . . . . . . . . . . . . . . 370\nRooting via Exploits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375\nSummary  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 376\nINDEx 377\nContents in Detail xv\nfORE wORD\nI first became aware of the quality of Nikolay’s work\nin Android security with the release of Android 4.0,\nIce Cream Sandwich. I needed a better explanation of\nthe new Android backup format; I was struggling to\nexploit a vulnerability I had found, because I didn’t\nhave a full grasp of the new feature and format. His clear, in-depth expla-\nnation helped me understand the issue, exploit the vulnerability, and get a\npatch into production devices quickly. I have since been a frequent visitor to\nhis blog, often referring to it when I need a refresher.\nWhile I was honored to be asked to write this foreword, I honestly didn’t\nbelieve I’d learn much from the book because I’ve been working on Android\nsecurity for many years. This belief could not have been more wrong. As\nI read and digested new information regarding subjects I thought I knew\nthoroughly, my mind whirled with thoughts of what I had missed and what\nI could have done better. Why wasn’t a reference like this available when I\nfirst engrossed myself in Android?\nThis book exposes the reader to a wide range of security topics, from\nAndroid permissions and sandboxing to the Android SELinux implementa-\ntion, SEAndroid. It provides excellent explanations of minute details and\nrarely seen features such as dm-verify. Like me, you’ll walk away from this\nbook with a better understanding of Android security features.\nAndroid Security Internals has earned a permanent spot on my office\nbookshelf.\nJon “jcase” Sawyer\nCTO, Applied Cybersecurity LLC\nPort Angeles, WA\nxviii Foreword\naCkNOwLEDGmENTs\nI would like to thank everyone at No Starch Press who worked on this book.\nSpecial thanks to Bill Pollock for making my ramblings readable and to\nAlison Law for her patience in turning them into an actual book.\nA big thanks to Kenny Root for reviewing all chapters and sharing the\nbackstories behind some of Android’s security features.\nThanks to Jorrit “Chainfire” Jongma for maintaining SuperSU, which\nhas been an invaluable tool for poking at Android’s internals, and for\nreviewing my coverage of it in Chapter 13.\nThanks to Jon “jcase” Sawyer for continuing to challenge our assump-\ntions about Android security and for contributing a foreword to my book.\nINTRODUCTION\nIn a relatively short period of time, Android has\nbecome the world’s most popular mobile platform.\nAlthough originally designed for smartphones, it\nnow powers tablets, TVs, and wearable devices, and\nwill soon even be found in cars. Android is being\ndeveloped at a breathtaking pace, with an average of two major releases\nper year. Each new release brings a better UI, performance improvements,\nand a host of new user-facing features which are typically blogged about\nand dissected in excruciating detail by Android enthusiasts.\nOne aspect of the Android platform that has seen major improvements\nover the last few years, but which has received little public attention, is secu-\nrity. Over the years, Android has become more resistant to common exploit\ntechniques (such as buffer overflows), its application isolation (sandboxing)\nhas been reinforced, and its attack surface has been considerably reduced\nby aggressively decreasing the number of system processes that run as root.\nIn addition to these exploit mitigations, recent versions of Android have\nintroduced major new security features such as restricted user support,\nfull-disk encryption, hardware-backed credential storage, and support for\ncentralized device management and provisioning. Even more enterprise-\noriented features and security improvements such as managed profile\nsupport, improved full-disk encryption, and support for biometric authen-\ntication have been announced for the next Android release (referred to as\nAndroid L as I write this).\nAs with any new platform feature, discussing cutting-edge security\nimprovements is exciting, but it’s arguably more important to understand\nAndroid’s security architecture from the bottom up because each new secu-\nrity feature builds upon and integrates with the platform’s core security\nmodel. Android’s sandboxing model (in which each application runs as a\nseparate Linux user and has a dedicated data directory) and permission sys-\ntem (which requires each application to explicitly declare the platform fea-\ntures it requires) are fairly well understood and documented. However, the\ninternals of other fundamental platform features that have an impact on\ndevice security, such as package management and code signing, are largely\ntreated as a black box beyond the security research community.\nOne of the reasons for Android’s popularity is the relative ease with\nwhich a device can be “flashed” with a custom build of Android, “rooted” by\napplying a third-party update package, or otherwise customized. Android\nenthusiast forums and blogs feature many practical “How to” guides that\ntake users through the steps necessary to unlock a device and apply various\ncustomization packages, but they offer very little structured information\nabout how such system updates operate under the hood and what risks they\ncarry.\nThis books aims to fill these gaps by providing an exploration of how\nAndroid works by describing its security architecture from the bottom up\nand delving deep into the implementation of major Android subsystems and\ncomponents that relate to device and data security. The coverage includes\nbroad topics that affect all applications, such as package and user manage-\nment, permissions and device policy, as well as more specific ones such as\ncryptographic providers, credential storage, and support for secure elements.\nIt’s not uncommon for entire Android subsystems to be replaced or\nrewritten between releases, but security-related development is conserva-\ntive by nature, and while the described behavior might be changed or aug-\nmented across releases, Android’s core security architecture should remain\nfairly stable in future releases.\nwho This Book Is For\nThis book should be useful to anyone interested in learning more about\nAndroid’s security architecture. Both security researchers looking to evalu-\nate the security level of Android as a whole or of a specific subsystem and\nplatform developers working on customizing and extending Android will\nfind the high-level description of each security feature and the provided\nimplementation details to be a useful starting point for understanding\nthe underlying platform source code. Application developers can gain a\nxxii Introduction\ndeeper understanding of how the platform works, which will enable them\nto write more secure applications and take better advantage of the security-\nrelated APIs that the platform provides. While some parts of the book are\naccessible to a non-technical audience, the bulk of the discussion is closely\ntied to Android source code or system files, so familiarity with the core con-\ncepts of software development in a Unix environment is useful.\nPrerequisites\nThe book assumes basic familiarity with Unix-style operating systems, pref-\nerably Linux, and does not explain common concepts such as processes,\nuser groups, file permissions, and so on. Linux-specific or recently added\nOS features (such as capability and mount namespaces) are generally intro-\nduced briefly before discussing Android subsystems that use them. Most\nof the presented platform code comes from core Android daemons (usu-\nally implemented in C or C++) and system services (usually implemented\nin Java), so basic familiarity with at least one of these languages is also\nrequired. Some code examples feature sequences of Linux system calls, so\nfamiliarity with Linux system programming can be helpful in understand-\ning the code, but is not absolutely required. Finally, while the basic struc-\nture and core components (such as activities and services) of Android apps\nare briefly described in the initial chapters, basic understanding of Android\ndevelopment is assumed.\nandroid versions\nThe description of Android’s architecture and implementation in this book\n(except for several proprietary Google features) is based on source code\npublicly released as part of the Android Open Source Project (AOSP). Most\nof the discussion and code excerpts reference Android 4.4, which is the lat-\nest publicly available version released with source code at the time of this\nwriting. The master branch of AOSP is also referenced a few times, because\ncommits to master are generally a good indicator of the direction future\nAndroid releases will take. However, not all changes to the master branch\nare incorporated in public releases as is, so it’s quite possible that future\nreleases will change and even remove some of the presented functionality.\nA developer preview version of the next Android release (Android L,\nmentioned earlier) was announced shortly after the draft of this book was\ncompleted. However, as of this writing, the full source code of Android L is\nnot available and its exact public release date is unknown. While the pre-\nview release does include some new security features, such as improvements\nto device encryption, managed profiles, and device management, none of\nthese features are final and so are subject to change. That is why this book\ndoes not discuss any of these new features. Although we could introduce\nsome of Android L’s security improvements based on their observed behav-\nior, without the underlying source code, any discussion about their imple-\nmentation would be incomplete and speculative.\nIntroduction xxiii\nhow Is This Book Organized?\nThis book consists of 13 chapters that are designed to be read in sequence.\nEach chapter discusses a different aspect or feature of Android security,\nand subsequent chapters build on the concepts introduced by their pre-\ndecessors. Even if you’re already familiar with Android’s architecture and\nsecurity model and are looking for details about a specific topic, you should\nat least skim Chapters 1 through 3 because the topics they cover form the\nfoundation for the rest of the book.\n• Chapter 1: Android’s Security Model gives a high-level overview of\nAndroid’s architecture and security model.\n• Chapter 2: Permissions describes how Android permissions are\ndeclared, used, and enforced by the system.\n• Chapter 3: Package Management discusses code signing and details\nhow Android’s application installation and management process works.\n• Chapter 4: User Management explores Android’s multi-user support\nand describes how data isolation is implemented on multi-user devices.\n• Chapter 5: Cryptographic Providers gives an overview of the Java\nCryptography Architecture ( JCA) framework and describes Android’s\nJCA cryptographic providers.\n• Chapter 6: Network Security and PKI introduces the architecture of\nthe Java Secure Socket Extension ( JSSE) framework and delves into its\nAndroid implementation.\n• Chapter 7: Credential Storage explores Android’s credential store and\nintroduces the APIs it provides to applications that need to store crypto-\ngraphic keys securely.\n• Chapter 8: Online Account Management discusses Android’s online\naccount management framework and shows how support for Google\naccounts is integrated into Android.\n• Chapter 9: Enterprise Security presents Android’s device management\nframework, details how VPN support is implemented, and delves into\nAndroid’s support for the Extensible Authentication Protocol (EAP).\n• Chapter 10: Device Security introduces verified boot, disk encryption,\nand Android’s lockscreen implementation, and shows how secure USB\ndebugging and encrypted device backups are implemented.\n• Chapter 11: NFC and Secure Elements gives an overview of Android’s\nNFC stack, delves into secure element (SE) integration and APIs, and\nintroduces host-based card emulation (HCE).\n• Chapter 12: SELinux starts with a brief introduction to SELinux’s archi-\ntecture and policy language, details the changes made to SELinux in\norder to integrate it in Android, and gives an overview of Android’s base\nSELinux policy.\nxxiv Introduction\n• Chapter 13: System Updates and Root Access discusses how Android’s\nbootloader and recovery OS are used to perform full system updates,\nand details how root access can be obtained on both engineering and\nproduction Android builds.\nConventions\nBecause the main topic of this book is Android’s architecture and implemen-\ntation, it contains multiple code excerpts and file listings, which are exten-\nsively referenced in the sections that follow each listing or code example. A\nfew format conventions are used to set those references (which typically\ninclude multiple OS or programming language constructs) apart from the\nrest of the text.\nCommands; function and variable names; XML attributes; and SQL\nobject names are set in monospace (for example: “the id command,” “the\ngetCallingUid() method,” “the name attribute,” and so on). The names of files\nand directories, Linux users and groups, processes, and other OS objects\nare set in italic (for example: “the packages.xml file,” “the system user,” “the\nvold daemon,” and so on). String literals are also set in italic (for example:\n“the AndroidOpenSSL provider”). If you use such string literals in a program,\nyou typically need to enclose them in double or single quotes (for example:\nSignature.getInstance(\"SHA1withRSA\", \"AndroidOpenSSL\")).\nJava class names are typically in their unqualified format without the\npackage name (for example: “the Binder class”); fully qualified names are\nonly used when multiple classes with the same name exist in the discussed\nAPI or package, or when specifying the containing package is otherwise\nimportant (for example: “the javax.net.ssl.SSLSocketFactory class”). When\nreferenced in the text, function and method names are shown with paren-\ntheses, but their parameters are typically omitted for brevity (for example:\n“the getInstance() factory method”). See the relevant reference documenta-\ntion for the full function or method signature.\nMost chapters include diagrams that illustrate the architecture or struc-\nture of the discussed security subsystem or component. All diagrams follow\nan informal “boxes and arrows” style and do not conform strictly to a par-\nticular format. That said, most diagrams borrow ideas from UML class and\ndeployment diagrams, and boxes typically represent classes or objects, while\narrows represent dependency or communication paths.\nIntroduction xxv",
    "question": "What is the main focus of the book \"Android Security Internals\"?",
    "summary": "The book \"Android Security Internals\" provides an in-depth look at Android's security architecture, covering topics like permissions, cryptographic providers, and device security features. It explains how Android's security mechanisms work from the ground up, including verified boot, disk encryption, and lockscreen functionality. Written by Nikolay Elenkov, a long-time Android security expert, the book is a valuable resource for developers and researchers seeking to understand Android's security internals and how to implement secure applications."
  },
  {
    "start": 12,
    "end": 24,
    "text": "1\naNDROID’s sECURIT Y mODEL\nThis chapter will first briefly introduce Android’s\narchitecture, inter-process communication (IPC)\nmechanism, and main components. We then describe\nAndroid’s security model and how it relates to the\nunderlying Linux security infrastructure and code\nsigning. We conclude with a brief overview of some\nnewer additions to Android’s security model, namely multi-user support,\nmandatory access control (MAC) based on SELinux, and verified boot.\nAndroid’s architecture and security model are built on top of the tra-\nditional Unix process, user, and file paradigm, but this paradigm is not\ndescribed from scratch here. We assume a basic familiarity with Unix-like\nsystems, particularly Linux.\nandroid’s architecture\nLet’s briefly examine Android’s architecture from the bottom up. Figure 1-1\nshows a simplified representation of the Android stack.\nSystem Apps\nUser-Installed Apps\nSettings/Phone/Launcher/...\nAndroid Framework Libraries Java\nandroid.* Runtime\nLibraries\nSystem Services\njava.*\nActivity Mgr./Package Mgr./Window Mgr./... javax.*\nDalvik Runtime\nNative Native\nInit HAL\nDaemons Libraries\nLinux Kernel\nFigure 1-1: The Android architecture\nLinux Kernel\nAs you can see in Figure 1-1, Android is built on top of the Linux kernel. As\nin any Unix system, the kernel provides drivers for hardware, networking, file-\nsystem access, and process management. Thanks to the Android Mainlining\nProject,1 you can now run Android with a recent vanilla kernel (with some\neffort), but an Android kernel is slightly different from a “regular” Linux\nkernel that you might find on a desktop machine or a non-Android embed-\nded device. The differences are due to a set of new features (sometimes\ncalled Androidisms2) that were originally added to support Android. Some\nof the main Androidisms are the low memory killer, wakelocks (integrated\nas part of wakeup sources support in the mainline Linux kernel), anony-\nmous shared memory (ashmem), alarms, paranoid networking, and Binder.\nThe most important Androidisms for our discussion are Binder and\nparanoid networking. Binder implements IPC and an associated security\nmechanism, which we discuss in more detail on page 5. Paranoid net-\nworking restricts access to network sockets to applications that hold spe-\ncific permissions. We delve deeper into this topic in Chapter 2.\nNative Userspace\nOn top of the kernel is the native userspace layer, consisting of the init\nbinary (the first process started, which starts all other processes), several\nnative daemons, and a few hundred native libraries that are used throughout\nthe system. While the presence of an init binary and daemons is reminiscent\n1. Android Mainlining Project, http://elinux.org/Android_Mainlining_Project\n2. For a more detailed discussion of Androidisms, see Karim Yaghmour’s Embedded Android,\nO’Reilly, 2013, pp. 29–38.\n2 Chapter 1\nof a traditional Linux system, note that both init and the associated startup\nscripts have been developed from scratch and are quite different from their\nmainline Linux counterparts.\nDalvik VM\nThe bulk of Android is implemented in Java and as such is executed by a\nJava Virtual Machine (JVM). Android’s current Java VM implementation is\ncalled Dalvik and it is the next layer in our stack. Dalvik was designed with\nmobile devices in mind and cannot run Java bytecode (.class files) directly:\nits native input format is called Dalvik Executable (DEX) and is packaged in\n.dex files. In turn, .dex files are packaged either inside system Java libraries\n(JAR files), or inside Android applications (APK files, discussed in Chapter 3).\nDalvik and Oracle’s JVM have different architectures—register-based\nin Dalvik versus stack-based in the JVM—and different instruction sets.\nLet’s look at a simple example to illustrate the differences between the two\nVMs (see Listing 1-1).\npublic static int add(int i, int j) {\nreturn i + j;\n}\nListing 1-1: Static Java method that adds two integers\nWhen compiled for each VM, the add() static method, which simply\nadds two integers and returns the result, would generate the bytecode\nshown in Figure 1-2.\nJVM Bytecode Dalvik Bytecode\npublic static int add(int, int); .method public static add(II)I\nCode:\n0: iload_0(cid:31) add-int v0, p0, p1(cid:27)\n1: iload_1(cid:30)\n2: iadd(cid:29)\n3: ireturn(cid:28) return v0(cid:26)\n.end method\nFigure 1-2: JVM and Dalvik bytecode\nHere, the JVM uses two instructions to load the parameters onto the\nstack (u and v), then executes the addition w, and finally returns the\nresult x. In contrast, Dalvik uses a single instruction to add parameters\n(in registers p0 and p1) and puts the result in the v0 register y. Finally, it\nreturns the contents of the v0 register z. As you can see, Dalvik uses fewer\ninstructions to achieve the same result. Generally speaking, register-based\nVMs use fewer instructions, but the resulting code is larger than the cor-\nresponding code in a stack-based VM. However, on most architectures,\nAndroid’s Security Model 3\nloading code is less expensive than instruction dispatch, so register-based\nVMs can be interpreted more efficiently.3\nIn most production devices, system libraries and preinstalled applica-\ntions do not contain device-independent DEX code directly. As a perfor-\nmance optimization, DEX code is converted to a device-dependent format\nand stored in an Optimized DEX (.odex) file, which typically resides in the\nsame directory as its parent JAR or APK file. A similar optimization process\nis performed for user-installed applications at install time.\nJava Runtime Libraries\nA Java language implementation requires a set of runtime libraries, defined\nmostly in the java.* and javax.* packages. Android’s core Java libraries are\noriginally derived from the Apache Harmony project4 and are the next\nlayer on our stack. As Android has evolved, the original Harmony code\nhas changed significantly. In the process, some features have been replaced\nentirely (such as internationalization support, the cryptographic provider,\nand some related classes), while others have been extended and improved.\nThe core libraries are developed mostly in Java, but they have some native\ncode dependencies as well. Native code is linked into Android’s Java librar-\nies using the standard Java Native Interface (JNI),5 which allows Java code to\ncall native code and vice versa. The Java runtime libraries layer is directly\naccessed both from system services and applications.\nSystem Services\nThe layers introduced up until now make up the plumbing necessary to\nimplement the core of Android —system services. System services (79 as of\nversion 4.4) implement most of the fundamental Android features, includ-\ning display and touch screen support, telephony, and network connectivity.\nMost system services are implemented in Java; some fundamental ones are\nwritten in native code.\nWith a few exceptions, each system service defines a remote interface\nthat can be called from other services and applications. Coupled with the\nservice discovery, mediation, and IPC provided by Binder, system services\neffectively implement an object-oriented OS on top of Linux.\nLet’s look at how Binder enables IPC on Android in detail, as this is one\nof the cornerstones of Android’s security model.\nInter-Process Communication\nAs mentioned previously, Binder is an inter-process communication (IPC)\nmechanism. Before getting into detail about how Binder works, let’s briefly\nreview IPC.\n3. Yunhe Shi et al., Virtual Machine Showdown: Stack Versus Registers, https://www.usenix.org/\nlegacy/events/vee05/full_papers/p153-yunhe.pdf\n4. The Apache Software Foundation, Apache Harmony, http://harmony.apache.org/\n5. Oracle, Java™ Native Interface, http://docs.oracle.com/javase/7/docs/technotes/guides/jni/\n4 Chapter 1\nAs in any Unix-like system, processes in Android have separate address\nspaces and a process cannot directly access another process’s memory (this\nis called process isolation). This is usually a good thing, both for stability\nand security reasons: multiple processes modifying the same memory can\nbe catastrophic, and you don’t want a potentially rogue process that was\nstarted by another user to dump your email by accessing your mail client’s\nmemory. However, if a process wants to offer some useful service(s) to other\nprocesses, it needs to provide some mechanism that allows other processes\nto discover and interact with those services. That mechanism is referred to\nas IPC.\nThe need for a standard IPC mechanism is not new, so several options\npredate Android. These include files, signals, sockets, pipes, semaphores,\nshared memory, message queues, and so on. While Android uses some of\nthese (such as local sockets), it does not support others (namely System V\nIPCs like semaphores, shared memory segments, and message queues).\nBinder\nBecause the standard IPC mechanisms weren’t flexible or reliable enough,\na new IPC mechanism called Binder was developed for Android. While\nAndroid’s Binder is a new implementation, it’s based on the architecture\nand ideas of OpenBinder.6\nBinder implements a distributed component architecture based on\nabstract interfaces. It is similar to Windows Common Object Model (COM)\nand Common Object Broker Request Architectures (CORBA) on Unix, but\nunlike those frameworks, it runs on a single device and does not support\nremote procedure calls (RPC) across the network (although RPC support\ncould be implemented on top of Binder). A full description of the Binder\nframework is outside the scope of this book, but we introduce its main com-\nponents briefly in the following sections.\nBinder Implementation\nAs mentioned earlier, on a Unix-like system, a process cannot access another\nprocess’s memory. However, the kernel has control over all processes and\ntherefore can expose an interface that enables IPC. In Binder, this interface\nis the /dev/binder device, which is implemented by the Binder kernel driver.\nThe Binder driver is the central object of the framework, and all IPC calls\ngo through it. Inter-process communication is implemented with a single\nioctl() call that both sends and receives data through the binder_write_read\nstructure, which consists of a write_buffer containing commands for the\ndriver, and a read_buffer containing commands that the userspace needs\nto perform.\nBut how is data actually passed between processes? The Binder driver\nmanages part of the address space of each process. The Binder driver-\nmanaged chunk of memory is read-only to the process, and all writing\n6. PalmSource, Inc., OpenBinder, http://www.angryredplanet.com/~hackbod/openbinder/docs/html/\nAndroid’s Security Model 5\nis performed by the kernel module. When a process sends a message to\nanother process, the kernel allocates some space in the destination pro-\ncess’s memory, and copies the message data directly from the sending\nprocess. It then queues a short message to the receiving process telling it\nwhere the received message is. The recipient can then access that message\ndirectly (because it is in its own memory space). When a process is finished\nwith the message, it notifies the Binder driver to mark the memory as free.\nFigure 1-3 shows a simplified illustration of the Binder IPC architecture.\nProcess A Process B\nBinder Client Binder Server\nBinder : IBinder\nIPC onTransact(){\nIBinder case CMD1:\n...\ntransact() case CMD2:\n...\n}\nLinux Kernel\nBinder Driver (/dev/binder)\nFigure 1-3: Binder IPC\nHigher-level IPC abstractions in Android such as Intents (commands with\nassociated data that are delivered to components across processes), Messengers\n(objects that enable message-based communication across processes), and\nContentProviders (components that expose a cross-process data management\ninterface) are built on top of Binder. Additionally, service interfaces that\nneed to be exposed to other processes can be defined using the Android\nInterface Definition Language (AIDL), which enables clients to call remote ser-\nvices as if they were local Java objects. The associated aidl tool automatically\ngenerates stubs (client-side representations of the remote object) and proxies\nthat map interface methods to the lower-level transact() Binder method and\ntake care of converting parameters to a format that Binder can transmit (this\nis called parameter marshalling/unmarshalling). Because Binder is inherently\ntypeless, AIDL-generated stubs and proxies also provide type safety by includ-\ning the target interface name in each Binder transaction (in the proxy) and\nvalidating it in the stub.\nBinder Security\nOn a higher level, each object that can be accessed through the Binder\nframework implements the IBinder interface and is called a Binder object.\nCalls to a Binder object are performed inside a Binder transaction, which\ncontains a reference to the target object, the ID of the method to execute,\nand a data buffer. The Binder driver automatically adds the process ID\n(PID) and effective user ID (EUID) of the calling process to the transaction\n6 Chapter 1\ndata. The called process (callee) can inspect the PID and EUID and decide\nwhether it should execute the requested method based on its internal logic\nor system-wide metadata about the calling application.\nSince the PID and EUID are filled in by the kernel, caller processes\ncannot fake their identity to get more privileges than allowed by the sys-\ntem (that is, Binder prevents privilege escalation). This is one of the central\npieces of Android’s security model, and all higher-level abstractions, such as\npermissions, build upon it. The EUID and PID of the caller are accessible\nvia the getCallingPid() and getCallingUid() methods of the android.os.Binder\nclass, which is part of Android’s public API.\nNOTE The calling process’s EUID may not map to a single application if more than one\napplication is executing under the same UID (see Chapter 2 for details). However,\nthis does not affect security decisions, as processes running under the same UID are\ntypically granted the same set of permissions and privileges (unless process-specific\nSELinux rules have been defined).\nBinder Identity\nOne of the most important properties of Binder objects is that they main-\ntain a unique identity across processes. Thus if process A creates a Binder\nobject and passes it to process B, which in turn passes it to process C, calls\nfrom all three processes will be processed by the same Binder object. In\npractice, process A will reference the Binder object directly by its memory\naddress (because it is in process A’s memory space), while process B and C\nwill receive only a handle to the Binder object.\nThe kernel maintains the mapping between “live” Binder objects\nand their handles in other processes. Because a Binder object’s identity\nis unique and maintained by the kernel, it is impossible for userspace\nprocesses to create a copy of a Binder object or obtain a reference to one\nunless they have been handed one through IPC. Thus a Binder object is a\nunique, unforgeable, and communicable object that can act as a security\ntoken. This enables the use of capability-based security in Android.\nCapability-Based Security\nIn a capability-based security model, programs are granted access to a particular\nresource by giving them an unforgeable capability that both references the\ntarget object and encapsulates a set of access rights to it. Because capabili-\nties are unforgeable, the mere fact that a program possesses a capability is\nsufficient to give it access to the target resource; there is no need to main-\ntain access control lists (ACLs) or similar structures associated with actual\nresources.\nBinder Tokens\nIn Android, Binder objects can act as capabilities and are called Binder\ntokens when used in this fashion. A Binder token can be both a capability\nand a target resource. The possession of a Binder token grants the owning\nAndroid’s Security Model 7\nprocess full access to a Binder object, enabling it to perform Binder\ntrans actions on the target object. If the Binder object implements multiple\nactions (by selecting the action to perform based on the code parameter of\nthe Binder transaction), the caller can perform any action when it has a\nreference to that Binder object. If more granular access control is required,\nthe implementation of each action needs to implement the necessary permis-\nsion checks, typically by utilizing the PID and EUID of the caller process.\nA common pattern in Android is to allow all actions to callers running\nas system (UID 1000) or root (UID 0), but perform additional permission\nchecks for all other processes. Thus access to important Binder objects\nsuch as system services is controlled in two ways: by limiting who can get a\nreference to that Binder object and by checking the caller identity before\nperforming an action on the Binder object. (This check is optional and\nimplemented by the Binder object itself, if required.)\nAlternatively, a Binder object can be used only as a capability without\nimplementing any other functionality. In this usage pattern, the same\nBinder object is held by two (or more) cooperating processes, and the one\nacting as a server (processing some kind of client requests) uses the Binder\ntoken to authenticate its clients, much like web servers use session cookies.\nThis usage pattern is used internally by the Android framework and is\nmostly invisible to applications. One notable use case of Binder tokens that\nis visible in the public API is window tokens. The top-level window of each\nactivity is associated with a Binder token (called a window token), which\nAndroid’s window manager (the system service responsible for managing\napplication windows) keeps track of. Applications can obtain their own win-\ndow token but cannot get access to the window tokens of other applications.\nTypically you don’t want other applications adding or removing windows\non top of your own; each request to do so must provide the window token\nassociated with the application, thus guaranteeing that window requests are\ncoming from your own application or from the system.\nAccessing Binder Objects\nAlthough Android controls access to Binder objects for security purposes,\nand the only way to communicate with a Binder object is to be given a refer-\nence to it, some Binder objects (most notably system services) need to be\nuniversally accessible. It is, however, impractical to hand out references to\nall system services to each and every process, so we need some mechanism\nthat allows processes to discover and obtain references to system services\nas needed.\nIn order to enable service discovery, the Binder framework has a single\ncontext manager, which maintains references to Binder objects. Android’s\ncontext manager implementation is the servicemanager native daemon. It\nis started very early in the boot process so that system services can register\nwith it as they start up. Services are registered by passing a service name\nand a Binder reference to the service manager. Once a service is registered,\n8 Chapter 1\nany client can obtain its Binder reference by using its name. However, most\nsystem services implement additional permission checks, so obtaining a\nreference does not automatically guarantee access to all of its functional-\nity. Because anyone can access a Binder reference when it is registered with\nthe service manager, only a small set of whitelisted system processes can\nregister system services. For example, only a process executing as UID 1002\n(AID_BLUETOOTH) can register the bluetooth system service.\nYou can view a list of registered services by using the service list com-\nmand, which returns the name of each registered service and the imple-\nmented IBinder interface. Sample output from running the command on\nan Android 4.4 device is shown in Listing 1-2.\n$ service list\nservice list\nFound 79 services:\n0 sip: [android.net.sip.ISipService]\n1 phone: [com.android.internal.telephony.ITelephony]\n2 iphonesubinfo: [com.android.internal.telephony.IPhoneSubInfo]\n3 simphonebook: [com.android.internal.telephony.IIccPhoneBook]\n4 isms: [com.android.internal.telephony.ISms]\n5 nfc: [android.nfc.INfcAdapter]\n6 media_router: [android.media.IMediaRouterService]\n7 print: [android.print.IPrintManager]\n8 assetatlas: [android.view.IAssetAtlas]\n9 dreams: [android.service.dreams.IdreamManager]\n--snip--\nListing 1-2: Obtaining a list of registered system services with the service list command\nOther Binder Features\nWhile not directly related to Android’s security model, two other notable\nBinder features are reference counting and death notification (also known\nas link to death). Reference counting guarantees that Binder objects are auto-\nmatically freed when no one references them and is implemented in the\nkernel driver with the BC_INCREFS, BC_ACQUIRE, BC_RELEASE, and BC_DECREFS com-\nmands. Reference counting is integrated at various levels of the Android\nframework but is not directly visible to applications.\nDeath notification allows applications that use Binder objects that are\nhosted by other processes to be notified when those processes are killed by\nthe kernel and to perform any necessary cleanup. Death notification is imple-\nmented with the BC_REQUEST_DEATH_NOTIFICATION and BC_CLEAR_DEATH_NOTIFICATION\ncommands in the kernel driver and the linkToDeath() and unlinkToDeath()\nmethods of the IBinder interface7 in the framework. (Death notifications\nfor local binders are not sent, because local binders cannot die without the\nhosting process dying as well.)\n7. Google, Android APIs Reference, “IBinder,” http://developer.android.com/reference/android/os/\nIBinder.html\nAndroid’s Security Model 9\nAndroid Framework Libraries\nNext on the stack are the Android framework libraries, sometimes called\njust “the framework.” The framework includes all Java libraries that are\nnot part of the standard Java runtime (java.*, javax.*, and so on) and is for\nthe most part hosted under the android top-level package. The framework\nincludes the basic blocks for building Android applications, such as the\nbase classes for activities, services, and content providers (in the android.app.*\npackages); GUI widgets (in the android.view.* and android.widget packages);\nand classes for file and database access (mostly in the android.database.* and\nandroid.content.* packages). It also includes classes that let you interact with\ndevice hardware, as well as classes that take advantage of higher-level ser-\nvices offered by the system.\nEven though almost all Android OS functionality above the kernel\nlevel is implemented as system services, it is not exposed directly in the\nframework but is accessed via facade classes called managers. Typically,\neach manager is backed by a corresponding system service; for example,\nthe BluetoothManager is a facade for the BluetoothManagerService.\nApplications\nOn the highest level of the stack are applications (or apps), which are the\nprograms that users directly interact with. While all apps have the same\nstructure and are built on top of the Android framework, we distinguish\nbetween system apps and user-installed apps.\nSystem Apps\nSystem apps are included in the OS image, which is read-only on produc-\ntion devices (typically mounted as /system), and cannot be uninstalled or\nchanged by users. Therefore, these apps are considered secure and are\ngiven many more privileges than user-installed apps. System apps can be\npart of the core Android OS or can simply be preinstalled user applications,\nsuch as email clients or browsers. While all apps installed under /system\nwere treated equally in earlier versions of Android (except by OS features\nthat check the app signing certificate), Android 4.4 and higher treat apps\ninstalled in /system/priv-app/ as privileged applications and will only grant\npermissions with protection level signatureOrSystem to privileged apps, not\nto all apps installed under /system. Apps that are signed with the platform\nsigning key can be granted system permissions with the signature protection\nlevel, and thus can get OS-level privileges even if they are not preinstalled\nunder /system. (See Chapter 2 for details on permissions and code signing.)\nWhile system apps cannot be uninstalled or changed, they can be updated\nby users as long as the updates are signed with the same private key, and\nsome can be overridden by user-installed apps. For example, a user can\nchoose to replace the preinstalled application launcher or input method\nwith a third-party application.\n10 Chapter 1\nUser-Installed Apps\nUser-installed apps are installed on a dedicated read-write partition (typi-\ncally mounted as /data) that hosts user data and can be uninstalled at will.\nEach application lives in a dedicated security sandbox and typically cannot\naffect other applications or access their data. Additionally, apps can only\naccess resources that they have explicitly been granted a permission to use.\nPrivilege separation and the principle of least privilege are central to\nAndroid’s security model, and we will explore how they are implemented\nin the next section.\nAndroid App Components\nAndroid applications are a combination of loosely coupled components and,\nunlike traditional applications, can have more than one entry point. Each\ncomponent can offer multiple entry points that can be reached based on\nuser actions in the same or another application, or triggered by a system\nevent that the application has registered to be notified about.\nComponents and their entry points, as well as additional metadata, are\ndefined in the application’s manifest file, called AndroidManifest.xml. Like\nmost Android resource files, this file is compiled into a binary XML format\n(similar to ASN.1) before bundling it in the application package (APK)\nfile in order to decrease size and speed up parsing. The most important\napplication property defined in the manifest file is the application package\nname, which uniquely identifies each application in the system. The pack-\nage name is in the same format as Java package names (reverse domain\nname notation; for example, com.google.email).\nThe AndroidManifest.xml file is parsed at application install time, and\nthe package and components it defines are registered with the system.\nAndroid requires each application to be signed using a key controlled\nby its developer. This guarantees that an installed application cannot be\nreplaced by another application that claims to have the same package name\n(unless it is signed with the same key, in which case the existing application is\nupdated). We’ll discuss code signing and application packages in Chapter 3.\nThe main components of Android apps are listed below.\nActivities\nAn activity is a single screen with a user interface. Activities are the\nmain building blocks of Android GUI applications. An application can\nhave multiple activities and while they are usually designed to be dis-\nplayed in a particular order, each activity can be started independently,\npotentially by a different app (if allowed).\nServices\nA service is a component that runs in the background and has no user\ninterface. Services are typically used to perform some long-running\noperation, such as downloading a file or playing music, without block-\ning the user interface. Services can also define a remote interface using\nAndroid’s Security Model 11\nAIDL and provide some functionality to other apps. However, unlike\nsystem services, which are part of the OS and are always running, appli-\ncation services are started and stopped on demand.\nContent providers\nContent providers provide an interface to app data, which is typically\nstored in a database or files. Content providers can be accessed via IPC\nand are mainly used to share an app’s data with other apps. Content\nproviders offer fine-grained control over what parts of data are acces-\nsible, allowing an application to share only a subset of its data.\nBroadcast receivers\nA broadcast receiver is a component that responds to systemwide events,\ncalled broadcasts. Broadcasts can originate from the system (for example,\nannouncing changes in network connectivity), or from a user appli-\ncation (for example, announcing that background data update has\ncompleted).\nandroid’s security model\nLike the rest of the system, Android’s security model also takes advantage\nof the security features offered by the Linux kernel. Linux is a multi-\nuser operating system and the kernel can isolate user resources from one\nanother, just as it isolates processes. In a Linux system, one user cannot\naccess another user’s files (unless explicitly granted permission) and each\nprocess runs with the identity (user and group ID, usually referred to as UID\nand GID) of the user that started it, unless the set-user-ID or set-group-ID\n(SUID and SGID) bits are set on the corresponding executable file.\nAndroid takes advantage of this user isolation, but treats users differently\nthan a traditional Linux system (desktop or server) does. In a traditional\nsystem, a UID is given either to a physical user that can log into the system\nand execute commands via the shell, or to a system service (daemon) that\nexecutes in the background (because system daemons are often accessible\nover the network, running each daemon with a dedicated UID can limit\nthe damage if one is compromised). Android was originally designed for\nsmartphones, and because mobile phones are personal devices, there was\nno need to register different physical users with the system. The physical\nuser is implicit, and UIDs are used to distinguish applications instead. This\nforms the basis of Android’s application sandboxing.\nApplication Sandboxing\nAndroid automatically assigns a unique UID, often called an app ID, to\neach application at installation and executes that application in a dedi-\ncated process running as that UID. Additionally, each application is given\na dedicated data directory which only it has permission to read and write\n12 Chapter 1\nto. Thus, applications are isolated, or sandboxed, both at the process level\n(by having each run in a dedicated process) and at the file level (by having\na private data directory). This creates a kernel-level application sandbox,\nwhich applies to all applications, regardless of whether they are executed in\na native or virtual machine process.\nSystem daemons and applications run under well-defined and constant\nUIDs, and very few daemons run as the root user (UID 0). Android does\nnot have the traditional /etc/password file and its system UIDs are statically\ndefined in the android_filesystem_config.h header file. UIDs for system ser-\nvices start from 1000, with 1000 being the system (AID_SYSTEM) user, which\nhas special (but still limited) privileges. Automatically generated UIDs for\napplications start at 10000 (AID_APP), and the corresponding usernames\nare in the form app_XXX or uY_aXXX (on Android versions that support\nmultiple physical users), where XXX is the offset from AID_APP and Y is the\nAndroid user ID (not the same as UID). For example, the 10037 UID cor-\nresponds to the u0_a37 username and may be assigned to the Google email\nclient application (com.google.android.email package). Listing 1-3 shows that\nthe email application process executes as the u0_a37 user u, while other\napplication processes execute as different users.\n$ ps\n--snip--\nu0_a37 16973 182 941052 60800 ffffffff 400d073c S com.google.android.emailu\nu0_a8 18788 182 925864 50236 ffffffff 400d073c S com.google.android.dialer\nu0_a29 23128 182 875972 35120 ffffffff 400d073c S com.google.android.calendar\nu0_a34 23264 182 868424 31980 ffffffff 400d073c S com.google.android.deskclock\n--snip--\nListing 1-3: Each application process executes as a dedicated user on Android\nThe data directory of the email application is named after its package\nname and is created under /data/data/ on single-user devices. (Multi-user\ndevices use a different naming scheme as discussed in Chapter 4.) All files\ninside the data directory are owned by the dedicated Linux user, u0_a37, as\nshown in Listing 1-4 (with timestamps omitted). Applications can option-\nally create files using the MODE_WORLD_READABLE and MODE_WORLD_WRITEABLE flags\nto allow direct access to files by other applications, which effectively sets the\nS_IROTH and S_IWOTH access bits on the file, respectively. However, the direct\nsharing of files is discouraged, and those flags are deprecated in Android\nversions 4.2 and higher.\n# ls -l /data/data/com.google.android.email\ndrwxrwx--x u0_a37 u0_a37 app_webview\ndrwxrwx--x u0_a37 u0_a37 cache\ndrwxrwx--x u0_a37 u0_a37 databases\ndrwxrwx--x u0_a37 u0_a37 files\n--snip--\nListing 1-4: Application directories are owned by the dedicated Linux user\nAndroid’s Security Model 13\nApplication UIDs are managed alongside other package metadata\nin the /data/system/packages.xml file (the canonical source) and also writ-\nten to the /data/system/packages.list file. (We discuss package management\nand the packages.xml file in Chapter 3.) Listing 1-5 shows the UID assigned\nto the com.google.android.email package as it appears in packages.list.\n# grep 'com.google.android.email' /data/system/packages.list\ncom.google.android.email 10037 0 /data/data/com.google.android.email default 3003,1028,1015\nListing 1-5: The UID corresponding to each application is stored in /data/system/packages .list\nHere, the first field is the package name, the second is the UID assigned\nto the application, the third is the debuggable flag (1 if debuggable), the\nfourth is the application’s data directory path, and the fifth is the seinfo label\n(used by SELinux). The last field is a list of the supplementary GIDs that the\napp launches with. Each GID is typically associated with an Android permis-\nsion (discussed next) and the GID list is generated based on the permissions\ngranted to the application.\nApplications can be installed using the same UID, called a shared user\nID, in which case they can share files and even run in the same process.\nShared user IDs are used extensively by system applications, which often\nneed to use the same resources across different packages for modularity.\nFor example, in Android 4.4 the system UI and keyguard (lockscreen imple-\nmentation) share UID 10012 (see Listing 1-6).\n# grep ' 10012 ' /data/system/packages.list\ncom.android.keyguard 10012 0 /data/data/com.android.keyguard platform 1028,1015,1035,3002,3001\ncom.android.systemui 10012 0 /data/data/com.android.systemui platform 1028,1015,1035,3002,3001\nListing 1-6: System packages sharing the same UID\nWhile the shared user ID facility is not recommended for non-system\napps, it’s available to third-party applications as well. In order to share\nthe same UID, applications need to be signed by the same code signing\nkey. Additionally, because adding a shared user ID to a new version of an\ninstalled app causes it to change its UID, the system disallows this (see\nChapter 2). Therefore, a shared user ID cannot be added retroactively,\nand apps need to be designed to work with a shared ID from the start.\nPermissions\nBecause Android applications are sandboxed, they can access only their\nown files and any world-accessible resources on the device. Such a limited\napplication wouldn’t be very interesting though, and Android can grant\nadditional, fine-grained access rights to applications in order to allow for\nricher functionality. Those access rights are called permissions, and they\ncan control access to hardware devices, Internet connectivity, data, or OS\nservices.\nApplications can request permissions by defining them in the\nAndroidManifest.xml file. At application install time, Android inspects\n14 Chapter 1\nthe list of requested permissions and decides whether to grant them or\nnot. Once granted, permissions cannot be revoked and they are available\nto the application without any additional confirmation. Additionally, for\nfeatures such as private key or user account access, explicit user confirma-\ntion is required for each accessed object, even if the requesting application\nhas been granted the corresponding permission (see Chapters 7 and 8).\nSome permission can only be granted to applications that are part of the\nAndroid OS, either because they’re preinstalled or signed with the same key as\nthe OS. Third-party applications can define custom permissions and define\nsimilar restrictions known as permission protection levels, thus restricting\naccess to an app’s services and resources to apps created by the same author.\nPermission can be enforced at different levels. Requests to lower-level\nsystem resources, such as device files, are enforced by the Linux kernel\nby checking the UID or GID of the calling process against the resource’s\nowner and access bits. When accessing higher-level Android components,\nenforcement is performed either by the Android OS or by each component\n(or both). We discuss permissions in Chapter 2.\nIPC\nAndroid uses a combination of a kernel driver and userspace libraries\nto implement IPC. As discussed in “Binder” on page 5, the Binder ker-\nnel driver guarantees that the UID and PID of callers cannot be forged,\nand many system services rely on the UID and PID provided by Binder to\ndynamically control access to sensitive APIs exposed via IPC. For example,\nthe system Bluetooth manager service only allows system applications to\nenable Bluetooth silently if the caller is running with the system UID (1000)\nby using the code shown in Listing 1-7. Similar code is found in other sys-\ntem services.\npublic boolean enable() {\nif ((Binder.getCallingUid() != Process.SYSTEM_UID) &&\n(!checkIfCallerIsForegroundUser())) {\nLog.w(TAG,\"enable(): not allowed for non-active and non-system user\");\nreturn false;\n}\n--snip--\n}\nListing 1-7: Checking that the caller is running with the system UID\nMore coarse-grained permissions that affect all methods of a service\nexposed via IPC can be automatically enforced by the system by specify-\ning a permission in the service declaration. As with requested permissions,\nrequired permissions are declared in the AndroidManifest.xml file. Like the\ndynamic permission check in the example above, per-component permis-\nsions are also implemented by consulting the caller UID obtained from\nBinder under the hood. The system uses the package database to deter-\nmine the permission required by the callee component, and then maps the\nAndroid’s Security Model 15\ncaller UID to a package name and retrieves the set of permissions granted\nto the caller. If the required permission is in that set, the call succeeds. If\nnot, it fails and the system throws a SecurityException.\nCode Signing and Platform Keys\nAll Android applications must be signed by their developer, including sys-\ntem applications. Because Android APK files are an extension of the Java\nJAR package format,8 the code signing method used is also based on JAR\nsigning. Android uses the APK signature to make sure updates for an app\nare coming from the same author (this is called the same origin policy) and\nto establish trust relationships between applications. Both of these secu-\nrity features are implemented by comparing the signing certificate of the\ncurrently installed target app with the certificate of the update or related\napplication.\nSystem applications are signed by a number of platform keys. Different\nsystem components can share resources and run inside the same process\nwhen they are signed with the same platform key. Platform keys are gener-\nated and controlled by whoever maintains the Android version installed\non a particular device: device manufacturers, carriers, Google for Nexus\ndevices, or users for self-built open source Android versions. (We’ll discuss\ncode signing and the APK format in Chapter 3.)\nMulti-User Support\nBecause Android was originally designed for handset (smartphone) devices\nthat have a single physical user, it assigns a distinct Linux UID to each\ninstalled application and traditionally does not have a notion of a physi-\ncal user. Android gained support for multiple physical users in version 4.2,\nbut multi-user support is only enabled on tablets, which are more likely to\nbe shared. Multi-user support on handset devices is disabled by setting the\nmaximum number of users to 1.\nEach user is assigned a unique user ID, starting with 0, and users are\ngiven their own dedicated data directory under /data/system/users/<user ID>/,\nwhich is called the user’s system directory. This directory hosts user-specific set-\ntings such as homescreen parameters, account data, and a list of currently\ninstalled applications. While application binaries are shared between users,\neach user gets a copy of an application’s data directory.\nTo distinguish applications installed for each user, Android assigns a\nnew effective UID to each application when it is installed for a particular\nuser. This effective UID is based on the target physical user’s user ID and\nthe app’s UID in a single-user system (the app ID). This composite structure\nof the granted UID guarantees that even if the same application is installed\nby two different users, both application instances get their own sandbox.\nAdditionally, Android guarantees dedicated shared storage (hosted on an\nSD card for older devices), which is world-readable, to each physical user.\n8. Oracle, JAR File Specification, http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html\n16 Chapter 1\nThe user to first initialize the device is called the device owner, and only they\ncan manage other users or perform administrative tasks that influence\nthe whole device (such as factory reset). (We discuss multi-user support in\ngreater detail in Chapter 4.)\nSELinux\nThe traditional Android security model relies heavily on the UIDs and\nGIDs granted to applications. While those are guaranteed by the kernel,\nand by default each application’s files are private, nothing prevents an appli-\ncation from granting world access to its files (whether intentionally or due\nto a programming error).\nSimilarly, nothing prevents malicious applications from taking advan-\ntage of the overly permissive access bits of system files or local sockets. In\nfact, inappropriate permissions assigned to application or system files have\nbeen the source of a number of Android vulnerabilities. Those vulner-\nabilities are unavoidable in the default access control model employed by\nLinux, known as discretionary access control (DAC). Discretionary here means\nthat once a user gets access to a particular resource, they can pass it on to\nanother user at their discretion, such as by setting the access mode of one\nof their files to world-readable. In contrast, mandatory access control (MAC)\nensures that access to resources conforms to a system-wide set of authoriza-\ntion rules called a policy. The policy can only be changed by an administra-\ntor, and users cannot override or bypass it in order to, for example, grant\neveryone access to their own files.\nSecurity Enhanced Linux (SELinux) is a MAC implementation for the\nLinux kernel and has been integrated in the mainline kernel for more than\n10 years. As of version 4.3, Android integrates a modified SELinux version\nfrom the Security Enhancements for Android (SEAndroid) project9 that\nhas been augmented to support Android-specific features such as Binder. In\nAndroid, SELinux is used to isolate core system daemons and user applica-\ntions in different security domains and to define different access policies for\neach domain. As of version 4.4, SELinux is deployed in enforcing mode (viola-\ntions to the system policy generate runtime errors), but policy enforcement\nis only applied to core system daemons. Applications still run in permissive\nmode and violations are logged but do not cause runtime errors. (We give\nmore details about Android’s SELinux implementation in Chapter 12.)\nSystem Updates\nAndroid devices can be updated over-the-air (OTA) or by connecting the\ndevice to a PC and pushing the update image using the standard Android\ndebug bridge (ADB) client or some vendor-provided application with sim-\nilar functionality. Because in addition to system files, an Android update\nmight need to modify the baseband (modem) firmware, bootloader, and\n9. SELinux Project, SE for Android, http://selinuxproject.org/page/SEAndroid\nAndroid’s Security Model 17\nother parts of the device that are not directly accessible from Android, the\nupdate process typically uses a special-purpose, minimal OS with exclusive\naccess to all device hardware. This is called a recovery OS or simply recovery.\nOTA updates are performed by downloading an OTA package file (typi-\ncally a ZIP file with an added code signature), which contains a small script\nfile to be interpreted by the recovery, and rebooting the device in recovery\nmode. Alternatively, the user can enter recovery mode by using a device-\nspecific key combination when booting the device, and apply the update\nmanually by using the menu interface of the recovery, which is usually navi-\ngated using the hardware buttons (Volume up/down, Power, and so on) of the\ndevice.\nOn production devices, the recovery accepts only updates signed by the\ndevice manufacturer. Update files are signed by extending the ZIP file for-\nmat to include a signature over the whole file in the comment section (see\nChapter 3), which the recovery extracts and verifies before installing the\nupdate. On some devices (including all Nexus devices, dedicated developer\ndevices, and some vendor devices), device owners can replace the recov-\nery OS and disable system update signature verification, allowing them to\ninstall updates by third parties. Switching the device bootloader to a mode\nthat allows replacing the recovery and system images is called bootloader\nunlocking (not to be confused with SIM-unlocking, which allows a device to\nbe used on any mobile network) and typically requires wiping all user data\n(factory reset) in order to make sure that a potentially malicious third-party\nsystem image does not get access to existing user data. On most consumer\ndevices, unlocking the bootloader has the side effect of voiding the device’s\nwarranty. (We discuss system updates and recovery images in Chapter 13.)\nVerified Boot\nAs of version 4.4, Android supports verified boot using the verity target10 of\nLinux’s Device-Mapper. Verity provides transparent integrity checking of\nblock devices using a cryptographic hash tree. Each node in the tree is a\ncryptographic hash, with leaf nodes containing the hash value of a physical\ndata block and intermediary nodes containing hash values of their child\nnodes. Because the hash in the root node is based on the values of all other\nnodes, only the root hash needs to be trusted in order to verify the rest of\nthe tree.\nVerification is performed with an RSA public key included in the boot\npartition. Device blocks are checked at runtime by calculating the hash\nvalue of the block as it is read and comparing it to the recorded value in\nthe hash tree. If the values do not match, the read operation results in an\nI/O error indicating that the filesystem is corrupted. Because all checks are\nperformed by the kernel, the boot process needs to verify the integrity of the\nkernel in order for verified boot to work. This process is device-specific and is\ntypically implemented by using an unchangeable, hardware-specific key that\n10. Linux kernel source tree, dm-verity, http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux\n.git/tree/Documentation/device-mapper/verity.txt\n18 Chapter 1\nis “burned” (written to write-only memory) into the device. That key is used\nto verify the integrity of each bootloader level and eventually the kernel. (We\ndiscuss verified boot in Chapter 10.)\nsummary\nAndroid is a privilege-separated operating system based on the Linux\nkernel. Higher-level system functions are implemented as a set of cooper-\nating system services that communicate using an IPC mechanism called\nBinder. Android isolates applications from each other by running each with\na distinct system identity (Linux UID). By default, applications are given\nvery few privileges and have to request fine-grained permission in order\nto interact with system services, hardware devices, or other applications.\nPermissions are defined in each application’s manifest file and are granted\nat install time. The system uses the UID of each application to find out what\npermissions it has been granted and to enforce them at runtime. In recent\nversions, system processes isolation takes advantage of SELinux to further\nconstrain the privileges given to each process.\nAndroid’s Security Model 19",
    "question": "What are the key components and mechanisms of Android's security model, and how do they interact with the underlying Linux security infrastructure and code signing?",
    "summary": "Android's security model is built on top of the Linux kernel, utilizing a combination of process isolation, user IDs (UIDs), and inter-process communication (IPC) mechanisms like Binder. It ensures application sandboxing by assigning unique UIDs and restricting access to system resources through permissions defined in the AndroidManifest.xml file. Recent versions also incorporate SELinux for mandatory access control and verified boot for ensuring the integrity of the system."
  },
  {
    "start": 25,
    "end": 41,
    "text": "2\nPERmIssION s\nIn the previous chapter, we gave an overview of\nAndroid’s security model and briefly introduced\npermissions. In this chapter we’ll provide more\ndetails about permissions, focusing on their imple-\nmentation and enforcement. We will then discuss\nhow to define custom permissions and apply them to each of Android’s\ncomponents. Finally, we’ll say a few words about pending intents, which are\ntokens that allow an application to start an intent with the identity and\nprivileges of another application.\nThe Nature of Permissions\nAs we learned in Chapter 1, Android applications are sandboxed and by\ndefault can access only their own files and a very limited set of system ser-\nvices. In order to interact with the system and other applications, Android\napplications can request a set of additional permissions that are granted at\ninstall time and cannot be changed (with some exceptions, as we’ll discuss\nlater in this chapter).\nIn Android, a permission is simply a string denoting the ability to per-\nform a particular operation. The target operation can be anything from\naccessing a physical resource (such as the device’s SD card) or shared data\n(such as the list of registered contacts) to the ability to start or access a\ncomponent in a third-party application. Android comes with a built-in set\nof predefined permissions. New permissions that correspond to new fea-\ntures are added in each version.\nNOTE New built-in permissions, which lock down functionality that previously didn’t require\na permission, are applied conditionally, depending on the targetSdkVersion speci-\nfied in an app’s manifest: applications targeting Android versions that were released\nbefore the new permission was introduced cannot be expected to know about it, and\ntherefore the permission is usually granted implicitly (without being requested).\nHowever, implicitly granted permissions are still shown in the list of permissions on\nthe app installer screen so that users can be aware of them. Apps targeting later ver-\nsions need to explicitly request the new permission.\nBuilt-in permissions are documented in the platform API reference.1\nAdditional permissions, called custom permissions, can be defined by both\nsystem and user-installed applications.\nTo view a list of the permissions currently known to the system, use the\npm list permissions command (see Listing 2-1). To display additional infor-\nmation about permissions, including the defining package, label, description,\nand protection level, add the -f parameter to the command.\n$ pm list permissions\nAll Permissions:\npermission:android.permission.REBOOTu\npermission:android.permission.BIND_VPN_SERVICEv\npermission:com.google.android.gallery3d.permission.GALLERY_PROVIDERw\npermission:com.android.launcher3.permission.RECEIVE_LAUNCH_BROADCASTSx\n--snip--\nListing 2-1: Getting a list of all permissions\nPermission names are typically prefixed with their defining package\nconcatenated with the string .permission. Because built-in permissions are\ndefined in the android package, their names start with android.permission.\nFor example, in Listing 2-1, the REBOOT u and BIND_VPN_SERVICE v are built-in\npermissions, while GALLERY_PROVIDER w is defined by the Gallery application\n(package com.google.android.gallery3d) and RECEIVE_LAUNCH_BROADCASTS x is\ndefined by the default launcher application (package com.android.launcher3).\n1. Google, Android API Reference, “Manifest.permission class,” http://developer.android.com/\nreference/android/Manifest.permission.html\n22 Chapter 2\nRequesting Permissions\nApplications request permissions by adding one or more <uses-permission>\ntags to their AndroidManifest.xml file and can define new permissions with the\n<permission> tag. Listing 2-2 shows an example manifest file that requests the\nINTERNET and WRITE_EXTERNAL_STORAGE permissions. (We show how to define\ncustom permission in “Custom Permissions” on page 42.)\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\nxmlns:tools=\"http://schemas.android.com/tools\"\npackage=\"com.example.app\"\nandroid:versionCode=\"1\"\nandroid:versionName=\"1.0\" >\n<uses-permission android:name=\"android.permission.INTERNET\" />\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n--snip--\n<application android:name=\"SampleApp\" ...>\n--snip--\n</application>\n</manifest>\nListing 2-2: Requesting permissions using the application manifest file\nPermission management\nPermissions are assigned to each application (as identified by a unique\npackage name) at install time by the system package manager service. The\npackage manager maintains a central database of installed packages, both\npre installed and user-installed, with information about the install path,\nversion, signing certificate, and assigned permissions of each package, as\nwell as a list of all permissions defined on a device. (The pm list permissions\ncommand introduced in the previous section obtains this list by query-\ning the package manager.) This package database is stored in the XML\nfile /data/system/packages.xml, which is updated each time an application is\ninstalled, updated, or uninstalled. Listing 2-3 shows a typical application\nentry from packages.xml.\n<package name=\"com.google.android.apps.translate\"\ncodePath=\"/data/app/com.google.android.apps.translate-2.apk\"\nnativeLibraryPath=\"/data/app-lib/com.google.android.apps.translate-2\"\nflags=\"4767300\" ft=\"1430dfab9e0\" it=\"142cdf04d67\" ut=\"1430dfabd8d\"\nversion=\"30000028\"\nuserId=\"10204\"u\ninstaller=\"com.android.vending\">\n<sigs count=\"1\">\n<cert index=\"7\" />v\n</sigs>\nPermissions 23\n<perms>w\n<item name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n<item name=\"android.permission.USE_CREDENTIALS\" />\n<item name=\"android.permission.READ_SMS\" />\n<item name=\"android.permission.CAMERA\" />\n<item name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n<item name=\"android.permission.INTERNET\" />\n<item name=\"android.permission.MANAGE_ACCOUNTS\" />\n<item name=\"android.permission.GET_ACCOUNTS\" />\n<item name=\"android.permission.ACCESS_NETWORK_STATE\" />\n<item name=\"android.permission.RECORD_AUDIO\" />\n</perms>\n<signing-keyset identifier=\"17\" />\n<signing-keyset identifier=\"6\" />\n</package>\nListing 2-3: Application entry in packages .xml\nWe discuss the meaning of most tags and attributes in Chapter 3, but\nfor now let’s focus on the ones that are related to permissions. Each pack-\nage is represented by a <package> element, which contains information about\nthe assigned UID (in the userId attribute u), signing certificate (in the\n<cert> tag v), and assigned permissions (listed as children of the <perms>\ntag w). To get information about an installed package programmatically,\nuse the getPackageInfo() method of the android.content.pm.PackageManager\nclass, which returns a PackageInfo instance that encapsulates the informa-\ntion contained in the <package> tag.\nIf all permissions are assigned at install time and cannot be changed or\nrevoked without uninstalling the application, how does the package manager\ndecide whether it should grant the requested permissions? To understand\nthis, we need to discuss permission protection levels.\nPermission Protection Levels\nAccording to the official documentation,2 a permission’s protection level\n“characterizes the potential risk implied in the permission and indicates\nthe procedure that the system should follow when determining whether\nor not to grant the permission.” In practice, this means that whether a\npermission is granted or not depends on its protection level. The following\nsections discuss the four protection levels defined in Android and how the\nsystem handles each.\nnormal\nThis is the default value. It defines a permission with low risk to the sys-\ntem or other applications. Permissions with protection level normal are\n2. Google, Android API Guides, “App Manifest: <permission> tag,” http://developer.android.com/\nguide/topics/manifest/permission-element.html#plevel\n24 Chapter 2\nautomatically granted without requiring user confirmation. Examples\nare ACCESS_NETWORK_STATE (allows applications to access information about\nnetworks) and GET_ACCOUNTS (allows access to the list of accounts in the\nAccounts Service).\ndangerous\nPermissions with the dangerous protection level give access to user data or\nsome form of control over the device. Examples are READ_SMS (allows an appli-\ncation to read SMS messages) and CAMERA (gives applications access to the\ncamera device). Before granting dangerous permissions, Android shows a\nconfirmation dialog that displays information about the requested permis-\nsions. Because Android requires that all requested permission be granted\nat install time, the user can either agree to install the app, thus granting\nthe requested dangerous permission(s), or cancel the application install. For\nexample, for the application shown in Listing 2-3 (Google Translate), the\nsystem confirmation dialog will look like the one shown in Figure 2-1.\nGoogle Play and other application market clients display their own\ndialog, which is typically styled differently. For the same application, the\nGoogle Play Store client displays the dialog shown in Figure 2-2. Here, all\ndangerous permissions are organized by permission group (see “System\nPermissions” on page 37) and normal permissions are not displayed.\nFigure 2-1: Default Android applica- Figure 2-2: Google Play Store client\ntion install confirmation dialog application install confirmation dialog\nPermissions 25\nsignature\nA signature permission is only granted to applications that are signed with\nthe same key as the application that declared the permission. This is the\n“strongest” permission level because it requires the possession of a crypto-\ngraphic key, which only the app (or platform) owner controls. Thus, applica-\ntions using signature permissions are typically controlled by the same author.\nBuilt-in signature permissions are typically used by system applications that\nperform device management tasks. Examples are NET_ADMIN (configure net-\nwork interfaces, IPSec, and so on) and ACCESS_ALL_EXTERNAL_STORAGE (access\nall multi-user external storage). We’ll discuss signature permissions in more\ndetail in “Signature Permissions” on page 39.\nsignatureOrSystem\nPermissions with this protection level are somewhat of a compromise:\nthey are granted to applications that are either part of the system image,\nor that are signed with the same key as the app that declared the permis-\nsion. This allows vendors that have their applications preinstalled on an\nAndroid device to share specific features that require a permission without\nhaving to share signing keys. Until Android 4.3, any application installed on\nthe system partition was granted signatureOrSystem permissions automatically.\nSince Android 4.4, applications need to be installed in the /system/priv-app/\ndirectory in order to be granted permissions with this protection level.\nPermission assignment\nPermissions are enforced at various layers in Android. Higher-level compo-\nnents such as applications and system services query the package manager\nto determine which permissions have been assigned to an application and\ndecide whether to grant access. Lower-level components like native daemons\ntypically do not have access to the package manager and rely on the UID,\nGID, and supplementary GIDs assigned to a process in order to determine\nwhich privileges to grant it. Access to system resources like device files, Unix\ndomain sockets (local sockets), and network sockets is regulated by the\nkernel based on the owner and access mode of the target resource and the\nUID and GIDs of the accessing process.\nWe’ll look into framework-level permission enforcement in “Permission\nEnforcement” on page 30. Let’s first discuss how permissions are mapped\nto OS-level constructs such as UID and GIDs and how these process IDs are\nused for permission enforcement.\nPermissions and Process Attributes\nAs in any Linux system, Android processes have a number of associated pro-\ncess attributes, most importantly real and effective UID and GID, and a set\nof supplementary GIDs.\nAs discussed in Chapter 1, each Android application is assigned a\nunique UID at install time and executes in a dedicated process. When the\n26 Chapter 2\napplication is started, the process’s UID and GID are set to the application\nUID assigned by the installer (the package manager service). If additional\npermissions have been assigned to the application, they are mapped to\nGIDs and assigned as supplementary GIDs to the process. Permission to\nGID mappings for built-in permissions are defined in the /etc/permission/\nplatform.xml file. Listing 2-4 shows an excerpt from the platform.xml file\nfound on an Android 4.4 device.\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<permissions>\n--snip--\n<permission name=\"android.permission.INTERNET\" >u\n<group gid=\"inet\" />\n</permission>\n<permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" >v\n<group gid=\"sdcard_r\" />\n<group gid=\"sdcard_rw\" />\n</permission>\n<assign-permission name=\"android.permission.MODIFY_AUDIO_SETTINGS\"\nuid=\"media\" />w\n<assign-permission name=\"android.permission.ACCESS_SURFACE_FLINGER\"\nuid=\"media\" />x\n--snip--\n</permissions>\nListing 2-4: Permission to GID mapping in platform .xml\nHere, the INTERNET permission is associated with the inet GID u, and\nthe WRITE_EXTERNAL_STORAGE permission is associated with the sdcard_r and\nsdcard_rw GIDs v. Thus any process for an app that has been granted the\nINTERNET permission is associated with the supplementary GID correspond-\ning to the inet group, and processes with the WRITE_EXTERNAL_STORAGE permis-\nsion have the GIDs of sdcard_r and sdcard_rw added to the list of associated\nsupplementary GIDs.\nThe <assign-permission> tag serves the opposite purpose: it is used to\nassign higher-level permissions to system processes running under a spe-\ncific UID that do not have a corresponding package. Listing 2-4 shows that\nprocesses running with the media UID (in practice, this is the mediaserver\ndaemon) are assigned the MODIFY_AUDIO_SETTINGS w and ACCESS_SURFACE_FLINGER x\npermissions.\nAndroid does not have an /etc/group file, so the mapping from group\nnames to GIDs is static and defined in the android_filesystem_config.h header\nfile. Listing 2-5 shows an excerpt containing the sdcard_rw u, sdcard_r v,\nand inet w groups.\n--snip--\n#define AID_ROOT 0 /* traditional unix root user */\n#define AID_SYSTEM 1000 /* system server */\n--snip--\nPermissions 27\n#define AID_SDCARD_RW 1015 /* external storage write access */\n#define AID_SDCARD_R 1028 /* external storage read access */\n#define AID_SDCARD_ALL 1035 /* access all users external storage */\n--snip--\n#define AID_INET 3003 /* can create AF_INET and AF_INET6 sockets */\n--snip--\nstruct android_id_info {\nconst char *name;\nunsigned aid;\n};\nstatic const struct android_id_info android_ids[] = {\n{ \"root\", AID_ROOT, },\n{ \"system\", AID_SYSTEM, },\n--snip--\n{ \"sdcard_rw\", AID_SDCARD_RW, },u\n{ \"sdcard_r\", AID_SDCARD_R, },v\n{ \"sdcard_all\", AID_SDCARD_ALL, },\n--snip--\n{ \"inet\", AID_INET, },w\n};\nListing 2-5: Static user and group name to UID/GID mapping in android_filesystem_config .h\nThe android_filesystem_config.h file also defines the owner, access mode,\nand associated capabilities (for executables) of core Android system direc-\ntories and files.\nThe package manager reads platform.xml at startup and maintains a list of\npermissions and associated GIDs. When it grants permissions to a package\nduring installation, the package manager checks whether each permission\nhas an associated GID(s). If so, the GID(s) is added to the list of supple-\nmentary GIDs associated with the application. The supplementary GID list\nis written as the last field of the packages.list file (see Listing 1-5 on page 14).\nProcess Attribute Assignment\nBefore we see how the kernel and lower-level system services check and\nenforce permissions, we need to examine how Android application pro-\ncesses are started and assigned process attributes.\nAs discussed in Chapter 1, Android applications are implemented\nin Java and are executed by the Dalvik VM. Thus each application pro-\ncess is in fact a Dalvik VM process executing the application’s bytecode.\nIn order to reduce the application memory footprint and improve startup\ntime, Android does not start a new Dalvik VM process for each application.\nInstead, it uses a partially initialized process called zygote and forks it (using\nthe fork() system call3) when it needs to start a new application. However,\n3. For detailed information about process management functions like fork(), setuid(), and\nso on, see the respective man pages or a Unix programming text, such as W. Richard Stevens\nand Stephen A. Rago’s Advanced Programming in the UNIX Environment (3rd edition), Addison-\nWesley Professional, 2013.\n28 Chapter 2\ninstead of calling one of the exec() functions like it does when starting a\nnative process, it merely executes the main() function of the specified Java\nclass. This process is called specialization, because the generic zygote process is\nturned into a specific application process, much like cells originating from\nthe zygote cell specialize into cells that perform different functions. Thus\nthe forked process inherits the memory image of the zygote process, which has\npre loaded most core and application framework Java classes. Because those\nclasses never change and Linux uses a copy-on-write mechanism when fork-\ning processes, all child processes of zygote (that is, all Android applications)\nshare the same copy of framework Java classes.\nThe zygote process is started by the init.rc initialization script and\nreceives commands on a Unix-domain socket, also named zygote. When\nzygote receives a request to start a new application process, it forks itself,\nand the child process executes roughly the following code (abbreviated\nfrom forkAndSpecializeCommon() in dalvik_system_Zygote.cpp) in order to spe-\ncialize itself as shown in Listing 2-6.\npid = fork();\nif (pid == 0) {\nint err;\n/* The child process */\nerr = setgroupsIntarray(gids);u\nerr = setrlimitsFromArray(rlimits);v\nerr = setresgid(gid, gid, gid);w\nerr = setresuid(uid, uid, uid);x\nerr = setCapabilities(permittedCapabilities, effectiveCapabilities);y\nerr = set_sched_policy(0, SP_DEFAULT);z\nerr = setSELinuxContext(uid, isSystemServer, seInfo, niceName);{\nenableDebugFeatures(debugFlags);|\n}\nListing 2-6: Application process specialization in zygote\nAs shown here, the child process first sets its supplementary GIDs (corre-\nsponding to permissions) using setgroups(), called by setgroupsIntarray() at u.\nNext, it sets resource limits using setrlimit(), called by setrlimitsFromArray()\nat v, then sets the real, effective, and saved user and group IDs using\nsetresgid() w and setresuid() x.\nThe child process is able to change its resource limits and all process\nattributes because it initially executes as root, just like its parent process,\nzygote. After the new process attributes are set, the child process executes\nwith the assigned UIDs and GIDs and cannot go back to executing as root\nbecause the saved user ID is not 0.\nAfter setting the UIDs and GIDs, the process sets its capabilities4 using\ncapset(), called from setCapabilities() y. Then, it sets its scheduling policy\n4. For a discussion of Linux capabilities, see Chapter 39 of Michael Kerrisk’s The Linux\nProgramming Interface: A Linux and UNIX System Programming Handbook, No Starch Press, 2010.\nPermissions 29\nby adding itself to one of the predefined control groups z.5 At {, the pro-\ncess sets its nice name (displayed in the process list, typically the applica-\ntion’s package name) and seinfo tag (used by SELinux, which we discuss in\nChapter 12). Finally, it enables debugging if requested |.\nNOTE Android 4.4 introduces a new, experimental runtime called Android RunTime (ART),\nwhich is expected to replace Dalvik in a future version. While ART brings many\nchanges to the current execution environment, most importantly ahead-of-time (AOT)\ncompilation, it uses the same zygote-based app process execution model as Dalvik.\nThe process relationship between zygote and application process is evident\nin the process list obtained with the ps command, as shown in Listing 2-7.\n$ ps\nUSER PID PPID VSIZE RSS WCHAN PC NAME\nroot 1 0 680 540 ffffffff 00000000 S /initu\n--snip--\nroot 181 1 858808 38280 ffffffff 00000000 S zygotev\n--snip--\nradio 1139 181 926888 46512 ffffffff 00000000 S com.android.phone\nnfc 1154 181 888516 36976 ffffffff 00000000 S com.android.nfc\nu0_a7 1219 181 956836 48012 ffffffff 00000000 S com.google.android.gms\nListing 2-7: zygote and application process relationship\nHere, the PID column denotes the process ID, the PPID column denotes\nthe parent process ID, and the NAME column denotes the process name.\nAs you can see, zygote (PID 181 v) is started by the init process (PID 1 u)\nand all application processes have zygote as their parent (PPID 181). Each\nprocess executes under a dedicated user, either built-in (radio, nfc), or auto-\nmatically assigned (u0_a7) at install time. The process names are set to the\npackage name of each application (com.android.phone, com.android.nfc, and\ncom.google.android.gms).\nPermission Enforcement\nAs discussed in the previous section, each application process is assigned a\nUID, GID, and supplementary GIDs when it is forked from zygote. The ker-\nnel and system daemons use these process identifiers to decide whether to\ngrant access to a particular system resource or function.\nKernel-Level Enforcement\nAccess to regular files, device nodes, and local sockets is regulated just as it\nis in any Linux system. One Android-specific addition is requiring processes\nthat want to create network sockets to belong to the group inet. This Android\nkernel addition is known as “paranoid network security” and is implemented\nas an additional check in the Android kernel, as shown in Listing 2-8.\n5. Linux Kernel Archives, CGROUPS, https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt\n30 Chapter 2\n#ifdef CONFIG_ANDROID_PARANOID_NETWORK\n#include <linux/android_aid.h>\nstatic inline int current_has_network(void)\n{ return in_egroup_p(AID_INET) || capable(CAP_NET_RAW);u}\n#else\nstatic inline int current_has_network(void)\n{ return 1;v\n}\n#endif\n--snip--\nstatic int inet_create(struct net *net, struct socket *sock, int protocol,\nint kern)\n{\n--snip--\nif (!current_has_network())\nreturn -EACCES;w\n--snip--\n}\nListing 2-8: Paranoid network security implementation in the Android kernel\nCaller processes that do not belong to the AID_INET (GID 3003, name\ninet) group and do not have the CAP_NET_RAW capability (allowing the use of\nRAW and PACKET sockets) receive an access denied error (u and w). Non-\nAndroid kernels do not define CONFIG_ANDROID_PARANOID_NETWORK and thus no\nspecial group membership is required to create a socket v. In order for the\ninet group to be assigned to an application process, it needs to be granted\nthe INTERNET permission. As a result, only applications with the INTERNET per-\nmission can create network sockets. In addition to checking process creden-\ntials when creating sockets, Android kernels also grant certain capabilities\nto processes executing with specific GIDs: processes that execute with the\nAID_NET_RAW (GID 3004) are given the CAP_NET_RAW capability, and those exe-\ncuting with AID_NET_ADMIN (GID 3005) are given the CAP_NET_ADMIN capability.\nParanoid network security is also used to control access to Bluetooth\nsockets and the kernel tunneling driver (used for VPN). A full list of\nAndroid GIDs that the kernel treats in a special way can be found in the\ninclude/linux/android_aid.h file in the kernel source tree.\nNative Daemon-Level Enforcement\nWhile Binder is the preferred IPC mechanism in Android, lower-level native\ndaemons often use Unix domain sockets (local sockets) for IPC. Because\nUnix domain sockets are represented as nodes on the filesystem, standard\nfilesystem permission can be used to control access.\nAs most sockets are created with an access mode that only allows access\nto their owner and group, clients running under a different UID and GID\ncannot connect to the socket. Local sockets for system daemons are defined\nPermissions 31\nin init.rc and created by init on startup with the specified access mode. For\nexample, Listing 2-9 shows how the volume management daemon (vold) is\ndefined in init.rc:\nservice vold /system/bin/vold\nclass core\nsocket vold stream 0660 root mountu\nioprio be 2\nListing 2-9: vold daemon entry in init .rc\nvold declares a socket called vold with the 0660 access mode, owned by\nroot and with group set to mount u. The vold daemon needs to run as root\nin order to mount or unmount volumes, but members of the mount group\n(AID_MOUNT, GID 1009) can send it commands via the local socket without\nneeding to run as the superuser. Local sockets for Android daemons are\ncreated in the /dev/socket/ directory. Listing 2-10 shows that the vold socket\nu has the owner and permission specified in init.rc.\n$ ls -l /dev/socket\nsrw-rw---- system system 1970-01-18 14:26 adbd\nsrw------- system system 1970-01-18 14:26 installd\nsrw-rw---- root system 1970-01-18 14:26 netd\n--snip--\nsrw-rw-rw- root root 1970-01-18 14:26 property_service\nsrw-rw---- root radio 1970-01-18 14:26 rild\nsrw-rw---- root mount 1970-01-18 14:26 voldu\nsrw-rw---- root system 1970-01-18 14:26 zygote\nListing 2-10: Local sockets for core system daemons in /dev/socket/\nUnix domain sockets allow the passing and querying of client creden-\ntials using the SCM_CREDENTIALS control message and the SO_PEERCRED socket\noption. Like the effective UID and effective GUID that are part of a Binder\ntransaction, the peer credentials associated with a local socket are checked\nby the kernel and cannot be forged by user-level processes. This allows\nnative daemons to implement additional, fine-grained control over the\noperations that they allow for a particular client, as shown in Listing 2-11\nusing the vold daemon as an example.\nint CommandListener::CryptfsCmd::runCommand(SocketClient *cli,\nint argc, char **argv) {\nif ((cli->getUid() != 0) && (cli->getUid() != AID_SYSTEM)) {u\ncli->sendMsg(ResponseCode::CommandNoPermission,\n\"No permission to run cryptfs commands\", false);\nreturn 0;\n}\n--snip--\n}\nListing 2-11: Fine-grained access control based on socket client credentials in vold\n32 Chapter 2\nThe vold daemon only allows encrypted container management com-\nmands to clients running as the root (UID 0) or system (AID_SYSTEM, UID 1000)\nusers. Here, the UID returned by SocketClient->getUid() u is initialized with\nthe client UID obtained using getsockopt(SO_PEERCRED) as shown in Listing 2-12\nat u.\nvoid SocketClient::init(int socket, bool owned, bool useCmdNum) {\n--snip--\nstruct ucred creds;\nsocklen_t szCreds = sizeof(creds);\nmemset(&creds, 0, szCreds);\nint err = getsockopt(socket, SOL_SOCKET, SO_PEERCRED, &creds, &szCreds);u\nif (err == 0) {\nmPid = creds.pid;\nmUid = creds.uid;\nmGid = creds.gid;\n}\n}\nListing 2-12: Obtaining local socket client credentials using getsockopt()\nLocal socket connection functionality is encapsulated in the\nandroid.net.LocalSocket class and is available to Java applications as well,\nallowing higher-level system services to communicate with native daemons\nwithout using JNI code. For example, the MountService framework class uses\nLocalSocket to send commands to the vold daemon.\nFramework-Level Enforcement\nAs discussed in the introduction to Android permissions, access to Android\ncomponents can be controlled using permissions by declaring the required\npermissions in the manifest of the enclosing application. The system keeps\ntrack of the permissions associated with each component and checks to\nsee whether callers have been granted the required permissions before\nallowing access. Because components cannot change the permissions they\nrequire at runtime, enforcement by the system is static. Static permissions\nare an example of declarative security. When using declarative security,\nsecurity attributes such as roles and permissions are placed in the metadata\nof a component (the AndroidManifest.xml file in Android), rather than in the\ncomponent itself, and are enforced by the container or runtime environ-\nment. This has the advantage of isolating security decisions from business\nlogic but can be less flexible than implementing securing checks within the\ncomponent.\nAndroid components can also check to see whether a calling process\nhas been granted a certain permission without declaring the permissions\nin the manifest. This dynamic permission enforcement requires more work but\nallows for more fine-grained access control. Dynamic permission enforce-\nment is an example of imperative security, because security decisions are\nmade by each component rather than being enforced by the runtime\nenvironment.\nPermissions 33\nLet’s look at how dynamic and static permission enforcement are imple-\nmented in more detail.\nDynamic Enforcement\nAs discussed in Chapter 1, the core of Android is implemented as a set of\ncooperating system services that can be called from other processes using\nthe Binder IPC mechanism. Core services register with the service manager\nand any application that knows their registration name can obtain a Binder\nreference. Because Binder does not have a built-in access control mechanism,\nwhen clients have a reference they can call any method of the underlying\nsystem service by passing the appropriate parameters to Binder.transact().\nTherefore, access control needs to be implemented by each system service.\nIn Chapter 1, we showed that system services can regulate access to\nexported operations by directly checking the UID of the caller obtained\nfrom Binder.getCallingUid() (see Listing 1-7 on page 15). However, this\nmethod requires that the service knows the list of allowed UIDs in advance,\nwhich only works for well-known fixed UIDs such as those of root (UID 0)\nand system (UID 1000). Also, most services do not care about the actual\nUID of the caller; they simply want to check if it has been granted a certain\npermission.\nBecause each application UID in Android is associated with a unique\npackage (unless it is part of a shared user ID), and the package manager\nkeeps track of the permissions granted to each package, this is made possible\nby querying the package manager service. Checking to see whether the caller\nhas a certain permission is a very common operation, and Android provides\na number of helper methods in the android.content.Context class that can per-\nform this check.\nLet’s first examine how the int Context.checkPermission(String permission,\nint pid, int uid) method works. This method returns PERMISSION_GRANTED if\nthe passed UID has the permission, and returns PERMISSION_DENIED otherwise.\nIf the caller is root or system, the permission is automatically granted. As a\nperformance optimization, if the requested permission has been declared\nby the calling app, it is granted without examining the actual permission.\nIf that is not the case, the method checks to see whether the target com-\nponent is public (exported) or private, and denies access to all private\ncomponents. (We’ll discuss component export in “Public and Private\nComponents” on page 43.) Finally, the code queries the package man-\nager service to see if the caller has been granted the requested permission.\nThe relevant code from the PackageManagerService class is shown in Listing 2-13.\npublic int checkUidPermission(String permName, int uid) {\nsynchronized (mPackages) {\nObject obj = mSettings.getUserIdLPr(uUserHandle.getAppId(uid));\nif (obj != null) {\nGrantedPermissions gp = (GrantedPermissions)obj;v\nif (gp.grantedPermissions.contains(permName)) {\nreturn PackageManager.PERMISSION_GRANTED;\n}\n34 Chapter 2\n} else {\nHashSet<String> perms = mSystemPermissions.get(uid);w\nif (perms != null && perms.contains(permName)) {\nreturn PackageManager.PERMISSION_GRANTED;\n}\n}\n}\nreturn PackageManager.PERMISSION_DENIED;\n}\nListing 2-13: UID-based permission check in PackageManagerService\nHere the PackageManagerService first determines the app ID of the appli-\ncation based on the passed UID u (the same application can be assigned\nmultiple UIDs when installed for different users, which we discuss in detail\nin Chapter 4) and then obtains the set of granted permissions. If the\nGrantedPermission class (which holds the actual java.util.Set<String> of\npermission names) contains the target permission, the method returns\nPERMISSION_GRANTED v. If not, it checks whether the target permission\nshould be automatically assigned to the passed-in UID w (based on the\n<assign-permission> tags in platform.xml, as shown in Listing 2-4). If this\ncheck fails as well, it finally returns PERMISSION_DENIED.\nThe other permission-check helper methods in the Context class follow\nthe same procedure. The int checkCallingOrSelfPermission(String permission)\nmethod calls Binder.getCallingUid() and Binder.getCallingPid() for us, and\nthen calls checkPermission(String permission, int pid, int uid) using the\nobtained values. The enforcePermission(String permission, int pid, int uid,\nString message) method does not return a result but instead throws a\nSecurityException with the specified message if the permission is not\ngranted. For example, the BatterStatsService class guarantees that only\napps that have the BATTERY_STATS permission can obtain battery statistics by\ncalling enforceCallingPermission() before executing any other code, as shown\nin Listing 2-14. Callers that have not been granted the permission receive a\nSecurityException.\npublic byte[] getStatistics() {\nmContext.enforceCallingPermission(\nandroid.Manifest.permission.BATTERY_STATS, null);\nParcel out = Parcel.obtain();\nmStats.writeToParcel(out, 0);\nbyte[] data = out.marshall();\nout.recycle();\nreturn data;\n}\nListing 2-14: Dynamic permission check in BatteryStatsService\nStatic Enforcement\nStatic permission enforcement comes into play when an application\ntries to interact with a component declared by another application. The\nPermissions 35\nenforcement process takes into account the permissions declared for each\ntarget component (if any) and allows the interaction if the caller process\nhas been granted the required permission.\nAndroid uses intents to describe an operation it needs to perform, and\nintents that fully specify the target component (by package and class name)\nare called explicit. On the other hand, implicit intents contain some data\n(often only an abstract action such as ACTION_SEND) that allows the system to\nfind a matching component, but they do not fully specify a target component.\nWhen the system receives an implicit intent, it first resolves it by search-\ning for matching components. If more than one matching component is\nfound, the user is presented with a selection dialog. When a target compo-\nnent has been selected, Android checks to see whether it has any associated\npermissions, and if it does, checks whether they have been granted to the\ncaller.\nThe general process is similar to dynamic enforcement: the UID\nand PID of the caller are obtained using Binder.getCallingUid() and\nBinder.getCallingPid(), the caller UID is mapped to a package name, and\nthe associated permissions are retrieved. If the set of caller permissions con-\ntains the ones required by the target component, the component is started;\notherwise, a SecurityException is thrown.\nPermission checks are performed by the ActivityManagerService, which\nresolves the specified intent and checks to see whether the target compo-\nnent has an associated permission attribute. If so, it delegates the permission\ncheck to the package manager. The timing and concrete sequence of per-\nmission checks is slightly different depending on the target component.\n(Next, we’ll examine how checks are performed for each component.)\nActivity and Service Permission Enforcement\nPermission checks for activities are performed if the intent passed to\nContext.startActivity() or startActivityForResult() resolves to an activ-\nity that declares a permission. A SecurityException is thrown if the caller\ndoes not have the required permission. Because Android services can be\nstarted, stopped, and bound to, calls to Context.startService(), stopService(),\nand bindService() are all subject to permission checks if the target service\ndeclares a permission.\nContent Provider Permission Enforcement\nContent provider permissions can either protect the whole component or\na particular exported URI, and different permissions can be specified for\nreading and writing. (You’ll learn more about permission declaration in\n“Content Provider Permissions” on page 46.) If different permissions\nfor reading and writing have been specified, the read permission con-\ntrols who can call ContentResolver.query() on the target provider or URI,\nand the write permission controls who can call ContentResolver.insert(),\nContentResolver.update(), and ContentResolver.delete() on the provider or one\nof its exported URIs. The checks are performed synchronously when one of\nthese methods is called.\n36 Chapter 2\nBroadcast Permission Enforcement\nWhen sending a broadcast, applications can require that receivers hold\na particular permission by using the Context.sendBroadcast (Intent intent,\nString receiverPermission) method. Because broadcasts are asynchronous,\nno permission check is performed when calling this method. The check\nis performed when delivering the intent to registered receivers. If a tar-\nget receiver does not hold the required permission, it is skipped and does\nnot receive the broadcast, but no exception is thrown. In turn, broadcast\nreceivers can require that broadcasters hold a specific permission in order\nto be able to target them.\nThe required permission is specified in the manifest or when regis-\ntering a broadcast dynamically. This permission check is also performed\nwhen delivering the broadcast and does not result in a SecurityException.\nThus delivering a broadcast might require two permission checks: one for\nthe broadcast sender (if the receiver specified a permission) and one for the\nbroadcast receiver (if the sender specified a permission).\nProtected and Sticky Broadcasts\nSome system broadcasts are declared as protected (for example, BOOT_COMPLETED\nand PACKAGE_INSTALLED) and can only be sent by a system process running as\none of SYSTEM_UID, PHONE_UID, SHELL_UID, BLUETOOTH_UID, or root. If a process run-\nning under a different UID tries to send a protected broadcast, it receives a\nSecurityException when calling one of the sendBroadcast() methods. Sending\n“sticky” broadcasts (if marked as sticky, the system preserves the sent Intent\nobject after the broadcast is complete) requires that the sender holds\nBROADCAST_STICKY permission; otherwise, a SecurityException is thrown and\nthe broadcast is not sent.\nsystem Permissions\nAndroid’s built-in permissions are defined in the android package, some-\ntimes also referred to as “the framework” or “the platform.” As we learned\nin Chapter 1, the core Android framework is the set of classes shared by\nsystem services, with some exposed via the public SDK as well. Framework\nclasses are packaged in JAR files found in /system/framework/ (about 40 in\nlatest releases).\nBesides JAR libraries, the framework contains a single APK file,\nframework-res.apk. As the name implies, it packages framework resources\n(animation, drawables, layouts, and so on), but no actual code. Most\nimportantly, it defines the android package and system permissions. As\nframework-res.apk is an APK file, it contains an AndroidManifest.xml file\nwhere permission groups and permissions are declared (see Listing 2-15).\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\npackage=\"android\" coreApp=\"true\" android:sharedUserId=\"android.uid.system\"\nandroid:sharedUserLabel=\"@string/android_system_label\">\nPermissions 37\n--snip--\n<protected-broadcast android:name=\"android.intent.action.BOOT_COMPLETED\" />u\n<protected-broadcast android:name=\"android.intent.action.PACKAGE_INSTALL\" />\n--snip--\n<permission-group android:name=\"android.permission-group.MESSAGES\"\nandroid:label=\"@string/permgrouplab_messages\"\nandroid:icon=\"@drawable/perm_group_messages\"\nandroid:description=\"@string/permgroupdesc_messages\"\nandroid:permissionGroupFlags=\"personalInfo\"\nandroid:priority=\"360\"/>v\n<permission android:name=\"android.permission.SEND_SMS\"\nandroid:permissionGroup=\"android.permission-group.MESSAGES\"w\nandroid:protectionLevel=\"dangerous\"\nandroid:permissionFlags=\"costsMoney\"\nandroid:label=\"@string/permlab_sendSms\"\nandroid:description=\"@string/permdesc_sendSms\" />\n--snip--\n<permission android:name=\"android.permission.NET_ADMIN\"\nandroid:permissionGroup=\"android.permission-group.SYSTEM_TOOLS\"\nandroid:protectionLevel=\"signature\" />x\n--snip--\n<permission android:name=\"android.permission.MANAGE_USB\"\nandroid:permissionGroup=\"android.permission-group.HARDWARE_CONTROLS\"\nandroid:protectionLevel=\"signature|system\"y\nandroid:label=\"@string/permlab_manageUsb\"\nandroid:description=\"@string/permdesc_manageUsb\" />\n--snip--\n<permission android:name=\"android.permission.WRITE_SECURE_SETTINGS\"\nandroid:permissionGroup=\"android.permission-group.DEVELOPMENT_TOOLS\"\nandroid:protectionLevel=\"signature|system|development\"z\nandroid:label=\"@string/permlab_writeSecureSettings\"\nandroid:description=\"@string/permdesc_writeSecureSettings\" />\n--snip--\n</manifest>\nListing 2-15: System permission definitions in the manifest of framework-res .apk\nAs shown in this listing, the AndroidManifest.xml file also declares the\nsystem’s protected broadcasts u. A permission group v specifies a name for a\nset of related permissions. Individual permission can be added to a group\nby specifying the group name in their permissionGroup attribute w.\nPermission groups are used to display related permissions in the system\nUI, but each permission still needs to be requested individually. That is, appli-\ncations cannot request that they be granted all the permissions in a group.\nRecall that each permission has an associated protection level declared\nusing the protectionLevel attribute, as shown at x.\nProtection levels can be combined with protection flags to further con-\nstrain how permissions are granted. The currently defined flags are system\n(0x10) and development (0x20). The system flag requires that applications be\npart of the system image (that is, installed on the read-only system partition)\nin order to be granted a permission. For example, the MANAGE_USB permis-\nsion, which allows applications to manage preferences and permissions for\n38 Chapter 2\nUSB devices, is only granted to applications that are both signed with the\nplatform signing key and installed on the system partition y. The development\nflag marks development permissions z, which we’ll discuss after presenting\nsignature permissions.\nSignature Permissions\nAs discussed in Chapter 1, all Android applications are required to be code\nsigned with a signature key controlled by the developer. This applies to sys-\ntem applications and the framework resource package as well. We discuss\npackage signing in detail in Chapter 3, but for now let’s say a few words\nabout how system applications are signed.\nSystem applications are signed by a platform key. By default, there are four\ndifferent keys in the current Android source tree: platform, shared, media, and\ntestkey (releasekey for release builds). All packages considered part of the core\nplatform (System UI, Settings, Phone, Bluetooth, and so on) are signed with\nthe platform key; the search- and contacts-related packages with the shared\nkey; the gallery app and media related providers with the media key; and\neverything else (including packages that don’t explicitly specify the signing\nkey in their makefile) with the testkey (or releasekey). The framework-res.apk\nAPK that defines system permissions is signed with the platform key. Thus\nany app trying to request a system permission with signature protection level\nneeds to be signed with the same key as the framework resource package.\nFor example, the NET_ADMIN permission shown in Listing 2-15 (which\nallows a granted application to control network interfaces), is declared with\nthe signature protection level x and can only be granted to applications\nsigned with the platform key.\nNOTE The Android open source repository (AOSP) includes pregenerated test keys that\nare used by default when signing compiled packages. They should never be used\nfor production builds because they are public and available to anyone who down-\nloads Android source code. Release builds should be signed with newly generated\nprivate keys that belong only to the build owner. Keys can be generated using the\nmake_key script, which is included in the development/tools/ AOSP directory.\nSee the build/target/product/security/README file for details on platform key\ngeneration.\nDevelopment Permissions\nTraditionally, the Android permission model does not allow for dynamically\ngranting and revoking permissions, and the set of granted permission for\nan application is fixed at install time. However, since Android 4.2, this rule\nhas been relaxed a little by adding a number of development permissions (such\nas READ_LOGS and WRITE_SECURE_SETTINGS). Development permission can be\ngranted or revoked on demand using the pm grant and pm revoke commands\non the Android shell.\nPermissions 39\nNOTE Of course, this operation is not available to everyone and is protected by the\nGRANT_REVOKE_PERMISSIONS signature permission. It is granted to the android\n.uid.shell shared user ID (UID 2000), and to all processes started from the\nAndroid shell (which also runs as UID 2000).\nshared User ID\nAndroid applications signed with the same key can request the ability to\nrun as the same UID, and optionally in the same process. This feature\nis referred to as shared user ID and is extensively used by core framework\nservices and system applications. Because it can have subtle effects on\nprocess accounting and application management, the Android team does\nnot recommend that third-party applications use it, but it is available to\nuser-installed applications as well. Additionally, switching an existing appli-\ncations that does not use a shared user ID to a shared user ID is not sup-\nported, so cooperating applications that need to use shared user ID should\nbe designed and released as such from the start.\nShared user ID is enabled by adding the sharedUserId attribute to\nAndroidManifest.xml’s root element. The user ID specified in the mani-\nfest needs to be in Java package format (containing at least one dot [.])\nand is used as an identifier, much like package names for applications. If\nthe specified shared UID does not exist, it is created. If another package\nwith the same shared UID is already installed, the signing certificate is\ncompared to that of the existing package, and if they do not match, an\nINSTALL_FAILED_SHARED_USER_INCOMPATIBLE error is returned and installation fails.\nAdding the sharedUserId attribute to a new version of an installed app\nwill cause it to change its UID, which would result in losing access to its\nown files (that was the case in some early Android versions). Therefore,\nthis is disallowed by the system, which will reject the update with the\nINSTALL_FAILED_UID_CHANGED error. In short, if you plan to use shared UID\nfor your apps, you have to design for it from the start, and must have used\nit since the very first release.\nThe shared UID itself is a first class object in the system’s package\ndatabase and is treated much like applications: it has an associated signing\ncertificate(s) and permissions. Android has five built-in shared UIDs, which\nare automatically added when the system is bootstrapped:\n• android.uid.system (SYSTEM_UID, 1000)\n• android.uid.phone (PHONE_UID, 1001)\n• android.uid.bluetooth (BLUETOOH_UID, 1002)\n• android.uid.log (LOG_UID, 1007)\n• android.uid.nfc (NFC_UID, 1027)\nListing 2-16 shows how the android.uid.system shared user is defined:\n<shared-user name=\"android.uid.system\" userId=\"1000\">\n<sigs count=\"1\">\n40 Chapter 2\n<cert index=\"4\" />\n</sigs>\n<perms>\n<item name=\"android.permission.MASTER_CLEAR\" />\n<item name=\"android.permission.CLEAR_APP_USER_DATA\" />\n<item name=\"android.permission.MODIFY_NETWORK_ACCOUNTING\" />\n--snip--\n<shared-user/>\nListing 2-16: Definition of the android .uid .system shared user\nAs you can see, apart from having a bunch of scary permissions (about\n66 on a 4.4 device), the definition is very similar to the package declara-\ntions shown earlier. Conversely, packages that are part of a shared user\ndo not have an associated granted permission list. Instead, they inherit\nthe permissions of the shared user, which are a union of the permissions\nrequested by all currently installed packages with the same shared user ID.\nOne side effect of this is that if a package is part of a shared user, it can\naccess APIs that it hasn’t explicitly requested permissions for, as long as\nsome package with the same shared user ID has already requested them.\nPermissions are dynamically removed from the <shared-user> definition as\npackages are installed or uninstalled though, so the set of available permis-\nsions is neither guaranteed nor constant.\nListing 2-17 shows how the declaration of the KeyChain system app that\nruns under a shared user ID looks like. As you can see, it references the\nshared user with the sharedUserId attribute and lacks explicit permission\ndeclarations:\n<package name=\"com.android.keychain\"\ncodePath=\"/system/app/KeyChain.apk\"\nnativeLibraryPath=\"/data/app-lib/KeyChain\"\nflags=\"540229\" ft=\"13cd65721a0\"\nit=\"13c2d4721f0\" ut=\"13cd65721a0\"\nversion=\"19\"\nsharedUserId=\"1000\">\n<sigs count=\"1\">\n<cert index=\"4\" />\n</sigs>\n<signing-keyset identifier=\"1\" />\n</package>\nListing 2-17: Package declaration of an application that runs under a shared user ID\nThe shared UID is not just a package management construct; it actu-\nally maps to a shared Linux UID at runtime as well. Listing 2-18 shows an\nexample of two system apps running as the system user (UID 1000):\nsystem 5901 9852 845708 40972 ffffffff 00000000 S com.android.settings\nsystem 6201 9852 824756 22256 ffffffff 00000000 S com.android.keychain\nListing 2-18: Applications running under a shared UID (system)\nPermissions 41\nApplications that are part of a shared user can run in the same pro-\ncess, and because they already have the same Linux UID and can access\nthe same system resources, this typically does not require any additional\nmodifications. A common process can be requested by specifying the same\nprocess name in the process attribute of the <application> tag in the mani-\nfests of all apps that need to run in one process. While the obvious result of\nthis is that the apps can share memory and communicate directly instead of\nusing IPC, some system services allow special access to components running\nin the same process (for example, direct access to cached passwords or get-\nting authentication tokens without showing UI prompts). Google applica-\ntions (such as Play Services and the Google location service) take advantage\nof this by requesting to run in the same process as the Google login service\nin order to be able to sync data in the background without user interaction.\nNaturally, they are signed with the same certificate and are part of the\ncom.google.uid.shared shared user.\nCustom Permissions\nCustom permissions are simply permissions declared by third-party applica-\ntions. When declared, they can be added to application components for static\nenforcement by the system, or the application can dynamically check to see\nif callers have been granted the permission using the checkPermission() or\nenforcePermission() methods of the Context class. As with built-in permissions,\napplications can define permission groups that their custom permissions are\nadded to. For example, Listing 2-19 shows the declaration of a permission\ngroup v and the permission belonging to that group w.\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\npackage=\"com.example.app\"\nandroid:versionCode=\"1\"\nandroid:versionName=\"1.0\" >\n--snip--\n<permission-tree\nandroid:name=\"com.example.app.permission\"\nandroid:label=\"@string/example_permission_tree_label\" />u\n<permission-group\nandroid:name=\"com.example.app.permission-group.TEST_GROUP\"\nandroid:label=\"@string/test_permission_group_label\"\nandroid:description=\"@string/test_permission_group_desc\"/>v\n<permission\nandroid:name=\"jcom.example.app.permission.PERMISSION1\"\nandroid:label=\"@string/permission1_label\"\nandroid:description=\"@string/permission1_desc\"\nandroid:permissionGroup=\"com.example.app.permission-group.TEST_GROUP\"\nandroid:protectionLevel=\"signature\" />w\n42 Chapter 2\n--snip--\n</manifest>\nListing 2-19: Custom permission tree, permission group, and permission declaration\nAs with system permissions, if the protection level is normal or danger-\nous, custom permission will be granted automatically when the user okays\nthe confirmation dialog. In order to be able to control which applications\nare granted a custom permission, you need to declare it with the signature\nprotection level to guarantee that it will only be granted to applications\nsigned with the same key.\nNOTE The system can only grant a permission that it knows about, which means that appli-\ncations that define custom permissions need to be installed before the applications that\nmake use of those permissions are installed. If an application requests a permission\nunknown to the system, it is ignored and not granted.\nApplications can also add new permissions dynamically using the\nandroid.content.pm.PackageManager.addPermission() API and remove them with\nthe matching removePermision() API. Such dynamically added permissions\nmust belong to a permission tree defined by the application. Applications can\nonly add or remove permissions from a permission tree in their own pack-\nage or another package running as the same shared user ID.\nPermission tree names are in reverse domain notation and a per-\nmission is considered to be in a permission tree if its name is pre-\nfixed with the permission tree name plus a dot (.). For example, the\ncom.example.app.permission.PERMISSION2 permission is a member of the\ncom.example.app.permission tree defined in Listing 2-19 at u. Listing 2-20\nshows how to add a dynamic permission programmatically.\nPackageManager pm = getPackageManager();\nPermissionInfo permission = new PermissionInfo();\npermission.name = \"com.example.app.permission.PERMISSION2\";\npermission.labelRes = R.string.permission_label;\npermission.protectionLevel = PermissionInfo.PROTECTION_SIGNATURE;\nboolean added = pm.addPermission(permission);\nLog.d(TAG, \"permission added: \" + added);\nListing 2-20: Adding a dynamic permission programmatically\nDynamically added permissions are added to the package database\n(/data/system/packages.xml ). They persist across reboots, just like permis-\nsions defined in the manifest, but they have an additional type attribute set\nto dynamic.\nPublic and Private Components\nComponents defined in the AndroidManifest.xml file can be public or pri-\nvate. Private components can be called only by the declaring application,\nwhile public ones are available to other applications as well.\nPermissions 43\nWith the exception of content providers, all components are private\nby default. Because the purpose of content providers is to share data with\nother applications, content providers were initially public by default, but\nthis behavior changed in Android 4.2 (API Level 17). Applications that tar-\nget API Level 17 or later now get private content providers by default, but\nthey are kept public for backward compatibility when targeting a lower\nAPI level.\nComponents can be made public by explicitly setting the exported attri-\nbute to true, or implicitly by declaring an intent filter. Components that have\nan intent filter but that do not need to be public can be made private by set-\nting the exported attribute to false. If a component is not exported, calls from\nexternal applications are blocked by the activity manager, regardless of the\npermissions the calling process has been granted (unless it is running as root\nor system). Listing 2-21 shows how to keep a component private by setting the\nexported attribute to false.\n<service android:name=\".MyService\" android:exported=\"false\" >\n<intent-filter>\n<action android:name=\"com.example.FETCH_DATA\" />\n</intent-filter>\n</service>\nListing 2-21: Keeping a component private by setting exported=\"false\"\nUnless explicitly intended for public consumption, all public compo-\nnents should be protected by a custom permission.\nactivity and service Permissions\nActivities and services can each be protected by a single permission set\nwith the permission attribute of the target component. The activity permis-\nsion is checked when other applications call Context.startActivity() or Con\ntext.startActivityForResult() with an intent that resolves to that activity.\nFor services, the permission is checked when other applications call one\nof Context.startService(), stopService(), or bindService() with an intent that\nresolves to the service.\nFor example, Listing 2-22 shows two custom permissions, START_MY_ACTIVITY\nand USE_MY_SERVICE, set to an activity u and service v, respectively. Applications\nthat want to use these components need to request the respective permissions\nusing the <uses-permission> tag in their manifest.\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\npackage=\"com.example.myapp\"\n... >\n<permission android:name=\"com.example.permission.START_MY_ACTIVITY\"\nandroid:protectionLevel=\"signature\"\nandroid:label=\"@string/start_my_activity_perm_label\"\nandroid:description=\"@string/start_my_activity_perm_desc\" />\n<permission android:name=\"com.example.permission.USE_MY_SERVICE\"\n44 Chapter 2\nandroid:protectionLevel=\"signature\"\nandroid:label=\"@string/use_my_service_perm_label\"\nandroid:description=\"@string/use_my_service_perm_desc\" />\n--snip--\n<activity android:name=\".MyActivity\"\nandroid:label=\"@string/my_activity\"\nandroid:permission=\"com.example.permission.START_MY_ACTIVITY\">u\n<intent-filter>\n--snip--\n</intent-filter>\n</activity>\n<service android:name=\".MyService\"\nandroid:permission=\"com.example.permission.USE_MY_SERVICE\">v\n<intent-filter>\n--snip--\n</intent-filter>\n</service>\n--snip--\n</manifest>\nListing 2-22: Protecting activities and services with custom permissions\nBroadcast Permissions\nUnlike activities and services, permissions for broadcast receivers can be\nspecified both by the receiver itself and by the application sending the\nbroadcast. When sending a broadcast, applications can either use the\nContext.sendBroadcast(Intent intent) method to send a broadcast to be\ndelivered to all registered receives, or limit the scope of components that\nreceive the broadcast by using the Context.sendBroadcast(Intent intent,\nString receiverPermission). The receiverPermission parameter specifies the\npermission that interested receivers need to hold in order to receive the\nbroadcast. Alternatively, starting with Android 4.0, senders can use the\nIntent.setPackage(String packageName) to limit the scope of receivers to those\ndefined in the specified package. On multi-user devices, system applications\nthat hold the INTERACT_ACROSS_USERS permission can send a broadcast that is\ndelivered only to a specific user by the using the sendBroadcastAsUser(Intent\nintent, UserHandle user) and sendBroadcastAsUser(Intent intent, UserHandle\nuser, String receiverPermission) methods.\nReceivers can limit who can send them broadcasts by specifying a per-\nmission using the permission attribute of the <receiver> tag in the manifest\nfor statically registered receivers, or by passing the required permission to\nthe Context.registerReceiver(BroadcastReceiver receiver, IntentFilter filter,\nString broadcastPermission, Handler scheduler) method for dynamically regis-\ntered receivers.\nOnly broadcasters that have been granted the required permission\nwill be able to send a broadcast to that receiver. For example, device\nadministration applications that enforce systemwide security policies (we\ndiscuss device administration in Chapter 9) require the BIND_DEVICE_ADMIN\nPermissions 45\npermission in order to receive the DEVICE_ADMIN_ENABLED broadcast. Because\nthis is a system permission with protection level signature, requiring the per-\nmission guarantees that only the system can activate device administration\napplications. For example, Listing 2-23 shows how the default Android\nEmail application specifies the BIND_DEVICE_ADMIN u permission for its\nPolicyAdmin receiver.\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\npackage=\"com.android.email\"\nandroid:versionCode=\"500060\" >\n--snip--\n<receiver\nandroid:name=\".SecurityPolicy$PolicyAdmin\"\nandroid:label=\"@string/device_admin_label\"\nandroid:description=\"@string/device_admin_description\"\nandroid:permission=\"android.permission.BIND_DEVICE_ADMIN\" >u\n<meta-data\nandroid:name=\"android.app.device_admin\"\nandroid:resource=\"@xml/device_admin\" />\n<intent-filter>\n<action\nandroid:name=\"android.app.action.DEVICE_ADMIN_ENABLED\" />\n</intent-filter>\n</receiver>\n--snip--\n</manifest>\nListing 2-23: Specifying a permission for a statically registered broadcast receiver\nAs with other components, private broadcast receivers can only receive\nbroadcasts originating from the same application.\nContent Provider Permissions\nAs mentioned in “The Nature of Permissions” on page 21, content pro-\nviders have a more complex permission model than other components, as\nwe’ll describe in detail in this section.\nStatic Provider Permissions\nWhile a single permissions that controls access to the whole provider can be\nspecified using the permission attribute, most providers employ different per-\nmission for reading and writing, and can also specify per-URI permissions.\nOne example of a provider that uses different permissions for reading and\nwriting is the built-in ContactsProvider. Listing 2-24 shows the declaration of\nits ContactsProvider2 class.\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\npackage=\"com.android.providers.contacts\"\nandroid:sharedUserId=\"android.uid.shared\"\nandroid:sharedUserLabel=\"@string/sharedUserLabel\">\n46 Chapter 2\n--snip--\n<provider android:name=\"ContactsProvider2\"\nandroid:authorities=\"contacts;com.android.contacts\"\nandroid:label=\"@string/provider_label\"\nandroid:multiprocess=\"false\"\nandroid:exported=\"true\"\nandroid:readPermission=\"android.permission.READ_CONTACTS\"u\nandroid:writePermission=\"android.permission.WRITE_CONTACTS\">v\n--snip--\n<path-permission\nandroid:pathPattern=\"/contacts/.*/photo\"\nandroid:readPermission=\"android.permission.GLOBAL_SEARCH\" />w\n<grant-uri-permission android:pathPattern=\".*\" />\n</provider>\n--snip--\n</manifest>\nListing 2-24: ContactsProvider permission declarations\nThe provider uses the readPermission attribute to specify one permission\nfor reading data (READ_CONTACTS u), and a separate permission for writing\ndata using the writePermission attribute (WRITE_CONTACTS v). Thus, applica-\ntions that only hold the READ_CONTACTS permission can only call the query()\nmethod of the provider, and calls to insert(), update(), or delete() require\nthe caller to hold the WRITE_CONTACTS permission. Applications that need to\nboth read and write to the contacts provider need to hold both permissions.\nWhen the global read and write permission are not sufficiently flexible,\nproviders can specify per-URI permissions to protect a certain subset of their\ndata. Per-URI permissions have higher priority than the component-level\npermission (or read and write permissions, if specified separately). Thus if\nan application wants to access a content provider URI that has an associated\npermission, it needs to hold only the target URI’s permission, and not the\ncomponent-level permission. In Listing 2-24, the ContactsProvider2 uses the\n<path-permission> tag to require that applications trying to read photos of con-\ntacts hold the GLOBAL_SEARCH permission w. As per-URI permissions override\nthe global read permission, interested applications do not need to hold the\nREAD_CONTACTS permission. In practice, the GLOBAL_SEARCH permission is used\nto grant read-only access to some of the system providers’ data to Android’s\nsearch system, which cannot be expected to hold read permissions to all\nproviders.\nDynamic Provider Permissions\nWhile statically defined per-URI permissions can be quite powerful, appli-\ncations sometimes need to grant temporary access to a particular piece\nof data (referred to by its URI) to other apps, without requiring that they\nhold a particular permission. For example, an email or messaging applica-\ntion may need to cooperate with an image viewer app in order to display\nan attachment. Because the app cannot know the URIs of attachments in\nadvance, if it used static per-URI permissions, it would need to grant read\naccess to all attachments to the image viewer app, which is undesirable.\nPermissions 47\nTo avoid this situation and potential security concern, applications\ncan dynamically grant temporary per-URI access using the Context\n.grantUriPermission(String toPackage, Uri uri, int modeFlags) method and\nrevoke access using the matching revokeUriPermission(Uri uri, int modeFlags)\nmethod. Temporary per-URI access is enabled by setting the global\ngrantUriPermissions attribute to true or by adding a <grant-uri-permission> tag\nin order to enable it for a specific URI. For example, Listing 2-25 shows how\nthe Email application uses the grantUriPermissions attribute u to allow tempo-\nrary access to attachments without requiring the READ_ATTACHMENT permission.\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\npackage=\"com.android.email\"\nandroid:versionCode=\"500060\" >\n<provider\nandroid:name=\".provider.AttachmentProvider\"\nandroid:authorities=\"com.android.email.attachmentprovider\"\nandroid:grantUriPermissions=\"true\"u\nandroid:exported=\"true\"\nandroid:readPermission=\"com.android.email.permission.READ_ATTACHMENT\"/>\n--snip--\n</manifest>\nListing 2-25: AttachmentProvider declaration from the Email app\nIn practice, applications rarely use the Context.grantPermission() and\nrevokePermission() methods directly to allow per-URI access. Instead, they\nset the FLAG_GRANT_READ_URI_PERMISSION or FLAG_GRANT_WRITE_URI_PERMISSION flags\nto the intent used to start the cooperating application (image viewer in our\nexample). When those flags are set, the recipient of the intent is granted per-\nmission to perform read or write operations on the URI in the intent’s data.\nBeginning with Android 4.4 (API Level 19), per-URI access\ngrants can be persisted across device reboots with the ContentResolver\n.takePersistableUriPermission() method, if the received intent has the\nFLAG_GRANT_PERSISTABLE_URI_PERMISSION flag set. Grants are persisted to\nthe /data/system/urigrants.xml file and can be revoked by calling the\nreleasePersistableUriPermission() method. Both transient and persistent\nper-URI access grants are managed by the system ActivityManagerService,\nwhich APIs related to per-URI access call internally.\nBeginning with Android 4.1 (API level 16), applications can use the\nClipData facility6 of intents to add more than one content URI to temporar-\nily be granted access to.\nPer-URI access is granted using one of the FLAG_GRANT_* intent flags, and\nautomatically revoked when the task of the called application finishes, so\nthere is no need to call revokePermission(). Listing 2-26 shows how the Email\napplication creates an intent that launches an attachment viewer application.\n6. Google, Android API Reference, “ClipData,” http://developer.android.com/reference/android/\ncontent/ClipData.html\n48 Chapter 2\npublic Intent getAttachmentIntent(Context context, long accountId) {\nUri contentUri = getUriForIntent(context, accountId);\nIntent intent = new Intent(Intent.ACTION_VIEW);\nintent.setDataAndType(contentUri, mContentType);\nintent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION |\nIntent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);\nreturn intent;\n}\nListing 2-26: Using the FLAG_GRANT_READ_URI_PERMISSION flag to start a viewer application\nPending Intents\nPending intents are neither an Android component nor a permission, but\nbecause they allow an application to grant its own permissions to another\napplication, we discuss them here.\nPending intents encapsulate an intent and a target action to perform\nwith it (start an activity, send a broadcast, and so on). The main difference\nfrom “regular” intents is that pending intents also include the identity of the\napplications that created them. This allows pending intents to be handed to\nother applications, which can use them to perform the specified action using\nthe identity and permissions of the original application. The identity stored\nin pending intents is guaranteed by the system ActivityManagerService, which\nkeeps track of the currently active pending intents.\nPending intents are used to implement alarms and notifications in\nAndroid. Alarms and notifications allow any application to specify an action\nthat needs to be performed on its behalf, either at a specified time for alarms,\nor when the user interacts with a system notification. Alarms and notifications\ncan be triggered when the application that created them is no longer running,\nand the system uses the information in the pending intent to start it and per-\nform the intent action on its behalf. Listing 2-27 shows how the Email applica-\ntion uses a pending intent created with the PendingIntent.getBroadcast() u to\nschedule broadcasts that trigger email synchronization.\nprivate void setAlarm(long id, long millis) {\n--snip--\nIntent i = new Intent(this, MailboxAlarmReceiver.class);\ni.putExtra(\"mailbox\", id);\ni.setData(Uri.parse(\"Box\" + id));\npi = PendingIntent.getBroadcast(this, 0, i, 0);u\nmPendingIntents.put(id, pi);\nAlarmManager am =\n(AlarmManager)getSystemService(Context.ALARM_SERVICE);\nm.set(AlarmManager.RTC_WAKEUP,\nSystem.currentTimeMillis() + millis, pi);\n--snip--\n}\nListing 2-27: Using a pending intent to schedule an alarm\nPermissions 49",
    "question": "What are the different types of permissions in Android and how are they enforced at various levels of the system?",
    "summary": "This chapter explains Android's permission system, detailing how permissions are defined, enforced, and managed. It covers the different protection levels (normal, dangerous, signature, and signatureOrSystem) and how they affect access to system resources. The chapter also discusses how permissions are mapped to UID and GID, and how the Android kernel enforces permissions through group memberships and capabilities. Additionally, it explains how Android applications can define custom permissions and how they are used to control access to components. Finally, it covers pending intents, which allow an application to start an intent with the identity and privileges of another application."
  },
  {
    "start": 42,
    "end": 44,
    "text": "Pending intents can be handed to non-system applications as well.\nThe same rules apply: applications that receive a PendingIntent instance\ncan perform the specified operation with the same permissions and iden-\ntity as creator applications. Therefore, care should be taken when building\nthe base intent, and base intents should generally be as specific as possible\n(with component name explicitly specified) to ensure that the intent is\nreceived by the intended components.\nThe implementation of pending intents is rather complex, but it is\nbased on the same IPC and sandboxing principles that other Android\ncomponents are built upon. When an application creates a pending\nintent, the system retrieves its UID and PID using Binder.getCallingUid()\nand Binder.getCallingPid(). Based on those, the system retrieves the package\nname and user ID (on multi-user devices) of the creator and stores them\nin a PendingIntentRecord along with the base intent and any additional meta-\ndata. The activity manager keeps a list of active pending intents by storing\nthe corresponding PendingIntentRecords, and when triggered, retrieves the\nnecessary record. It then uses the information in the record to assume the\nidentity of the pending intent creator and execute the specified action.\nFrom there, the process is the same as when starting any Android compo-\nnent and the same permission checks are performed.\nsummary\nAndroid runs each application in a restricted sandbox and requires that\napplications request specific permissions in order to interact with other\napps or the system. Permissions are strings that denote the ability to per-\nform a particular action. They are granted at application install time and\n(with the exception of development permissions) remain fixed during an\napplication’s lifetime. Permissions can be mapped to Linux supplemen-\ntary group IDs, which the kernel checks before granting access to system\nresources.\nHigher-level system services enforce permissions by obtaining the UID\nof the calling application using Binder and looking up the permissions it\nholds in the package manager database. Permissions associated with a com-\nponent declared in an application’s manifest file are automatically enforced\nby the system, but applications can also choose to perform additional per-\nmission checks dynamically. In addition to using built-in permissions, appli-\ncations can also define custom permissions and associate them with their\ncomponents in order to control access.\nEach Android component can require a permission, and content pro-\nviders can additionally specify read and write permissions on a per-URI\nbasis. Pending intents encapsulate the identity of the application that\ncreated them as well as an intent and an action to perform, which allows\nthe system or third-party applications to perform actions on behalf of the\noriginal applications with the same identity and permissions.\n50 Chapter 2\n3\nPaC k aGE m aNaGE mENT\nIn this chapter, we take an in-depth look at Android\npackage management. We begin with a description\nof Android’s package format and code signing imple-\nmentation, and then detail the APK install process.\nNext, we explore Android’s support for encrypted\nAPKs and secure application containers, which are used to implement a\nform of DRM for paid applications. Finally, we describe Android’s pack-\nage verification mechanism and its most widely used implementation: the\nGoogle Play application verification service.\nandroid application Package Format\nAndroid applications are distributed and installed in the form of application\npackage (APK) files, which are usually referred to as APK files. APK files are\ncontainer files that include both application code and resources, as well as\nthe application manifest file. They can also include a code signature. The\nAPK format is an extension of the Java JAR format,1 which in turn is an exten-\nsion of the popular ZIP file format. APK files typically have the .apk extension\nand are associated with the application/vnd.android.package-archive MIME type.\nBecause APK files are simply ZIP files, you can easily examine their con-\ntents by extracting them with any compression utility that supports the ZIP\nformat. Listing 3-1 shows the contents of a typical APK file after it has been\nextracted.\napk/\n|-- AndroidManifest.xmlu\n|-- classes.dexv\n|-- resources.arscw\n|-- assets/x\n|-- lib/y\n| |-- armeabi/\n| | `-- libapp.so\n| `-- armeabi-v7a/\n| `-- libapp.so\n|-- META-INF/z\n| |-- CERT.RSA\n| |-- CERT.SF\n| `-- MANIFEST.MF\n`-- res/{\n|-- anim/\n|-- color/\n|-- drawable/\n|-- layout/\n|-- menu/\n|-- raw/\n`-- xml/\nListing 3-1: Contents of a typical APK file\nEvery APK file includes an AndroidManifest.xml file u which declares the\napplication’s package name, version, components, and other metadata. The\nclasses.dex file v contains the executable code of the application and is in\nthe native DEX format of the Dalvik VM. The resources.arsc w packages all\nof the application’s compiled resources such as strings and styles. The assets\ndirectory x is used to bundle raw asset files with the application, such as\nfonts or music files.\nApplications that take advantage of native libraries via JNI contain a lib\ndirectory y, with subdirectories for each supported platform architecture.\nResources that are directly referenced from Android code, either directly\nusing the android.content.res.Resources class or indirectly via higher-level\nAPIs, are stored in the res directory {, with separate directories for each\nresource type (animations, images, menu definitions, and so on). Like JAR\nfiles, APK files also contain a META-INF directory z, which hosts the pack-\nage manifest file and code signatures. We’ll describe the contents of this\ndirectory in the next section.\n1. Oracle, JAR File Specification, http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html\n52 Chapter 3\nCode signing\nAs we learned in Chapter 2, Android uses APK code signing, in particular\nthe APK signing certificate, in order to control which applications can be\ngranted permission with the signature protection level. The APK signing\ncertificate is also used for various checks during the application installa-\ntion process, so before we get into details about APK installation, we should\nbecome more familiar with code signing in Android. This section provides\nsome details about Java code signing in general and highlights the differ-\nences with Android’s implementation.\nLet’s start with a few words about code signing in general. Why would\nanyone want to sign code? For the usual reasons: integrity and authenticity.\nBefore executing any third-party program, you want to make sure that it\nhasn’t been tampered with (integrity) and that it was actually created by the\nentity that it claims to come from (authenticity). These features are usually\nimplemented by a digital signature scheme, which guarantees that only the\nentity owning the signing key can produce a valid code signature.\nThe signature verification process verifies both that the code has not\nbeen tampered with and that the signature was produced with the expected\nkey. But one problem that code signing doesn’t solve directly is whether the\ncode signer (software publisher) can be trusted. The usual way to estab-\nlish trust is to require that the code signer holds a digital certificate and\nattaches it to the signed code. Verifiers decide whether to trust the certifi-\ncate based on a trust model (such as PKI or web of trust) or on a case-by-\ncase basis.\nAnother problem that code signing does not even attempt to solve is\nwhether the signed code is safe to run. As Flame2 and other code-signed\nmalware have demonstrated, even code that appears to have been signed\nby a trusted third party might not be safe.\nJava Code Signing\nJava code signing is performed at the JAR file level. It reuses and extends\nJAR manifest files in order to add a code signature to the JAR archive. The\nmain JAR manifest file (MANIFEST.MF) has entries with the filename and\ndigest value of each file in the archive. For example, Listing 3-2 shows the\nstart of the JAR manifest file of a typical APK file. (We’ll use APKs instead\nof regular JARs for all examples in this section.)\nManifest-Version: 1.0\nCreated-By: 1.0 (Android)\nName: res/drawable-xhdpi/ic_launcher.png\nSHA1-Digest: K/0Rd/lt0qSlgDD/9DY7aCNlBvU=\n2. Microsoft Corporation, Flame malware collision attack explained, http://blogs.technet.com/b/srd/\narchive/2012/06/06/more-information-about-the-digital-certificates-used-to-sign-the-flame-malware.aspx\nPackage Management 53\nName: res/menu/main.xml\nSHA1-Digest: kG8WDil9ur0f+F2AxgcSSKDhjn0=\nName: ...\nListing 3-2: JAR manifest file excerpt\nImplementation\nJava code signing is implemented by adding another manifest file called a\nsignature file (with extension .SF), which contains the data to be signed, and\na digital signature over it. The digital signature is called a signature block file\nand is stored in the archive as a binary file with one of the .RSA, .DSA, or\n.EC extensions, depending on the signature algorithm used. As shown in\nListing 3-3, the signature file is very similar to the manifest.\nSignature-Version: 1.0\nSHA1-Digest-Manifest-Main-Attributes: ZKXxNW/3Rg7JA1r0+RlbJIP6IMA=\nCreated-By: 1.7.0_51 (Sun Microsystems Inc.)\nSHA1-Digest-Manifest: zb0XjEhVBxE0z2ZC+B4OW25WBxo=u\nName: res/drawable-xhdpi/ic_launcher.png\nSHA1-Digest: jTeE2Y5L3uBdQ2g40PB2n72L3dE=v\nName: res/menu/main.xml\nSHA1-Digest: kSQDLtTE07cLhTH/cY54UjbbNBo=w\nName: ...\nListing 3-3: JAR signature file excerpt\nThe signature file contains the digest of the whole manifest file (SHA1-\nDigest-Manifest u), as well as digests for each entry in MANIFEST.MF (v\nand w). SHA-1 was the default digest algorithm until Java 6, but Java 7 and\nlater can generate file and manifest digests using the SHA-256 and SHA-512\nhash algorithms, in which case the digest attributes become SHA-256-Digest\nand SHA-512-Digest, respectively. Since version 4.3, Android supports SHA-256\nand SHA-512 digests.\nThe digests in the signature file can easily be verified by using the fol-\nlowing OpenSSL commands, as shown in Listing 3-4.\n$ openssl sha1 -binary MANIFEST.MF |openssl base64u\nzb0XjEhVBxE0z2ZC+B4OW25WBxo=\n$ echo -en \"Name: res/drawable-xhdpi/ic_launcher.png\\r\\nSHA1-Digest: \\\nK/0Rd/lt0qSlgDD/9DY7aCNlBvU=\\r\\n\\r\\n\"|openssl sha1 -binary |openssl base64v\njTeE2Y5L3uBdQ2g40PB2n72L3dE=\nListing 3-4: Verifying JAR signature file digests using OpenSSL\nThe first command u takes the SHA-1 digest of the entire manifest file\nand encodes it to Base64 to produce the SHA1-Digest-Manifest value. The\n54 Chapter 3\nsecond command v simulates the way the digest of a single manifest entry\nis calculated. It also demonstrates the attribute canonicalization format\nrequired by the JAR specification.\nThe actual digital signature is in binary PKCS#73 (or more generally,\nCMS4) format and includes the signature value and signing certificate.\nSignature block files produced using the RSA algorithm are saved with the\nextension .RSA, and those generated with DSA or EC keys are saved with\n.DSA or .EC extensions. Multiple signatures can also be performed, resulting\nin multiple .SF and .RSA/DSA/EC files in the JAR file’s META-INF directory.\nThe CMS format is rather involved, allowing for signing and encryp-\ntion, both with different algorithms and parameters. It’s also extensible via\ncustom signed or unsigned attributes. A thorough discussion is beyond the\nscope of this chapter (see RFC 5652 for details about CMS), but as used\nfor JAR signing, a CMS structure basically contains the digest algorithm,\nsigning certificate, and signature value. The CMS specifications allows for\nincluding signed data in the SignedData CMS structure (a format variation\ncalled attached signature), but JAR signatures don’t include it. When the\nsigned data is not included in the CMS structure, the signature is called a\ndetached signature and verifiers need to have a copy of the original signed\ndata in order to verify it. Listing 3-5 shows an RSA signature block file\nparsed into ASN.1,5 with the certificate details trimmed:\n$ openssl asn1parse -i -inform DER -in CERT.RSA\n0:d=0 hl=4 l= 888 cons: SEQUENCE\n4:d=1 hl=2 l= 9 prim: OBJECT :pkcs7-signedDatau\n15:d=1 hl=4 l= 873 cons: cont [ 0 ]\n19:d=2 hl=4 l= 869 cons: SEQUENCE\n23:d=3 hl=2 l= 1 prim: INTEGER :01v\n26:d=3 hl=2 l= 11 cons: SET\n28:d=4 hl=2 l= 9 cons: SEQUENCE\n30:d=5 hl=2 l= 5 prim: OBJECT :sha1w\n37:d=5 hl=2 l= 0 prim: NULL\n39:d=3 hl=2 l= 11 cons: SEQUENCE\n41:d=4 hl=2 l= 9 prim: OBJECT :pkcs7-datax\n52:d=3 hl=4 l= 607 cons: cont [ 0 ]y\n56:d=4 hl=4 l= 603 cons: SEQUENCE\n60:d=5 hl=4 l= 452 cons: SEQUENCE\n64:d=6 hl=2 l= 3 cons: cont [ 0 ]\n66:d=7 hl=2 l= 1 prim: INTEGER :02\n69:d=6 hl=2 l= 1 prim: INTEGER :04\n72:d=6 hl=2 l= 13 cons: SEQUENCE\n74:d=7 hl=2 l= 9 prim: OBJECT :sha1WithRSAEncryption\n85:d=7 hl=2 l= 0 prim: NULL\n87:d=6 hl=2 l= 56 cons: SEQUENCE\n3. EMC RSA Laboratories, PKCS #7: Cryptographic Message Syntax Standard, http://www.emc.com/\nemc-plus/rsa-labs/standards-initiatives/pkcs-7-cryptographic-message-syntax-standar.htm\n4. Housley, RFC 5652 – Cryptographic Message Syntax (CMS), http://tools.ietf.org/html/rfc5652\n5. Abstract Syntax Notation One (ASN.1) is a standard notation that describes rules and\nstructures for encoding data in telecommunications and computer networking. It’s used\nextensively in cryptography standards to define the structure of cryptographic objects.\nPackage Management 55\n89:d=7 hl=2 l= 11 cons: SET\n91:d=8 hl=2 l= 9 cons: SEQUENCE\n93:d=9 hl=2 l= 3 prim: OBJECT :countryName\n98:d=9 hl=2 l= 2 prim: PRINTABLESTRING :JP\n--snip--\n735:d=5 hl=2 l= 9 cons: SEQUENCE\n737:d=6 hl=2 l= 5 prim: OBJECT :sha1z\n744:d=6 hl=2 l= 0 prim: NULL\n746:d=5 hl=2 l= 13 cons: SEQUENCE\n748:d=6 hl=2 l= 9 prim: OBJECT :rsaEncryption{\n759:d=6 hl=2 l= 0 prim: NULL\n761:d=5 hl=3 l= 128 prim: OCTET STRING [HEX DUMP]:892744D30DCEDF74933007...|\nListing 3-5: Contents of a JAR file signature block\nThe signature block contains an object identifier u that describes the\ntype of data (ASN.1 object) that follows: SignedData, and the data itself. The\nincluded SignedData object contains a version v (1); a set of hash algorithm\nidentifiers used w (only one for a single signer, SHA-1 in this example); the\ntype of data that was signed x (pkcs7-data, which simply means “arbitrary\nbinary data”); the set of signing certificates y; and one or more (one for\neach signer) SignerInfo structures that encapsulates the signature value (not\nshown in full in Listing 3-5). SignerInfo contains a version; a SignerIdentifier\nobject, which typically contains the DN of the certificate issuer and the\ncertificate serial number (not shown); the digest algorithm used z (SHA-1,\nincluded in w); the digest encryption algorithm used to generate the signa-\nture value {; and the encrypted digest (signature value) itself |.\nThe most important elements of the SignedData structure, with regard to\nJAR and APK signatures, are the set of signing certificates y and the signa-\nture value | (or values, when signed by multiple signers).\nIf we extract the contents of a JAR file, we can use the OpenSSL smime\ncommand to verify its signature by specifying the signature file as the con-\ntent or signed data. The smime command prints the signed data and the veri-\nfication result as shown in Listing 3-6:\n$ openssl smime -verify -in CERT.RSA -inform DER -content CERT.SF signing-cert.pem\nSignature-Version: 1.0\nSHA1-Digest-Manifest-Main-Attributes: ZKXxNW/3Rg7JA1r0+RlbJIP6IMA=\nCreated-By: 1.7.0_51 (Sun Microsystems Inc.)\nSHA1-Digest-Manifest: zb0XjEhVBxE0z2ZC+B4OW25WBxo=\nName: res/drawable-xhdpi/ic_launcher.png\nSHA1-Digest: jTeE2Y5L3uBdQ2g40PB2n72L3dE=\n--snip--\nVerification successful\nListing 3-6: Verifying a JAR file signature block\n56 Chapter 3\nJAR File Signing\nThe official JDK tools for JAR signing and verification are the jarsigner and\nkeytool commands. Since Java 5.0 jarsigner also supports timestamping the\nsignature by a Timestamping Authority (TSA), which can be quite useful\nwhen you need to ascertain whether a signature was produced before or\nafter the signing certificate expired. However, this feature is not widely\nused and is not supported on Android.\nA JAR file is signed using the jarsigner command by specifying a key-\nstore file (see Chapter 5) together with the alias of the key to use for sign-\ning (the first eight characters of the alias become the base name for the\nsignature block file, unless the -sigfile option is specified) and optionally\na signature algorithm. See u in Listing 3-7 for an example invocation of\njarsigner.\nNOTE Since Java 7, the default algorithm has changed to SHA256withRSA, so you need\nto specify it explicitly if you want to use SHA-1 for backward compatibility. SHA-256-\nand SHA-512-based signatures have been supported since Android 4.3.\n$ jarsigner -keystore debug.keystore -sigalg SHA1withRSA test.apk androiddebugkeyu\n$ jarsigner -keystore debug.keystore -verify -verbose -certs test.apkv\n--snip--\nsmk 965 Sat Mar 08 23:55:34 JST 2014 res/drawable-xxhdpi/ic_launcher.png\nX.509, CN=Android Debug, O=Android, C=US (androiddebugkey)w\n[certificate is valid from 6/18/11 7:31 PM to 6/10/41 7:31 PM]\nsmk 458072 Sun Mar 09 01:16:18 JST 2013 classes.dex\nX.509, CN=Android Debug, O=Android, C=US (androiddebugkey)x\n[certificate is valid from 6/18/11 7:31 PM to 6/10/41 7:31 PM]\n903 Sun Mar 09 01:16:18 JST 2014 META-INF/MANIFEST.MF\n956 Sun Mar 09 01:16:18 JST 2014 META-INF/CERT.SF\n776 Sun Mar 09 01:16:18 JST 2014 META-INF/CERT.RSA\ns = signature was verified\nm = entry is listed in manifest\nk = at least one certificate was found in keystore\ni = at least one certificate was found in identity scope\njar verified.\nListing 3-7: Signing an APK file and verifying the signature using the jarsigner command\nThe jarsigner tool can use all keystore types supported by the platform,\nas well as keystores that are not natively supported and that require a dedi-\ncated JCA provider, such as those backed by a smart card, HSM, or another\nhardware device. The type of store to be used for signing is specified with\nPackage Management 57\nthe -storetype option, and the provider name and class with the -providerName\nand -providerClass options. Newer versions of the Android-specific signapk\ntool (discussed in “Android Code Signing Tools” on page 60), also sup-\nport the -providerClass option.\nJAR File Verification\nJAR file verification is performed using the jarsigner command by specify-\ning the -verify option. The second jarsigner command at v in Listing 3-7\nfirst verifies the signature block and signing certificate, ensuring that the\nsignature file has not been tampered with. Next it verifies that each digest\nin the signature file (CERT.SF ) matches its corresponding section in the\nmanifest file (MANIFEST.MF ). (The number of entries in the signature file\ndoes not have to match those in the manifest file. Files can be added to a\nsigned JAR without invalidating its signature: as long as none of the origi-\nnal files have been changed, verification succeeds.)\nFinally, jarsigner reads each manifest entry and checks that the file\ndigest matches the actual file contents. If a keystore has been specified\nwith the -keystore option (as in our example), jarsigner also checks to see\nwhether the signing certificate is present in the specified keystore. As of\nJava 7, there is a new -strict option that enables additional certificate vali-\ndations, including a time validity check and certificate chain verification.\nValidation errors are treated as warnings and are reflected in the exit code\nof the jarsigner command.\nViewing or Extracting Signer Information\nAs you can see in Listing 3-7, by default, jarsigner prints certificate details\nfor each entry (w and x) even though they are the same for all entries.\nA slightly better way to view signer info when using Java 7 is to specify the\n-verbose:summary or -verbose:grouped options, or alternatively use the keytool\ncommand, as shown in Listing 3-8.\n$ keytool -list -printcert -jarfile test.apk\nSigner #1:\nSignature:\nOwner: CN=Android Debug, O=Android, C=US\nIssuer: CN=Android Debug, O=Android, C=US\nSerial number: 4dfc7e9a\nValid from: Sat Jun 18 19:31:54 JST 2011 until: Mon Jun 10 19:31:54 JST 2041\nCertificate fingerprints:\nMD5: E8:93:6E:43:99:61:C8:37:E1:30:36:14:CF:71:C2:32\nSHA1: 08:53:74:41:50:26:07:E7:8F:A5:5F:56:4B:11:62:52:06:54:83:BE\nSignature algorithm name: SHA1withRSA\nVersion: 3\nListing 3-8: Viewing APK signer information using the keytool command\nOnce you have found the signature block filename (by listing the archive\ncontents for example), you can use OpenSSL with the unzip command to eas-\nily extract the signing certificate to a file, as shown in Listing 3-9. (If the\n58 Chapter 3",
    "question": "What is the role of pending intents in Android and how do they ensure the correct application identity and permissions when performing actions?",
    "summary": "Android uses APK files to distribute and install applications, which include the app's code, resources, and manifest. These APKs are signed with a certificate to ensure integrity and authenticity, and the signing process involves creating a digital signature that includes the certificate and the digest of the file contents. The system verifies these signatures to ensure that the app has not been tampered with and that it was created by a trusted entity."
  },
  {
    "start": 45,
    "end": 58,
    "text": "SignedData structure includes more than one certificate, all certificates will\nbe extracted. In that case, you will need to parse the SignedInfo structure to\nfind the identifier of the actual signing certificate.)\n$ unzip -q -c test.apk META-INF/CERT.RSA|openssl pkcs7 -inform DER -print_certs -out cert.pem\nListing 3-9: Extracting the APK signing certificate using the unzip and OpenSSL pkcs7 commands\nAndroid Code Signing\nBecause Android code signing is based on Java JAR signing, it uses public\nkey cryptography and X.509 certificates like many code signing schemes,\nbut that’s where the similarities end.\nIn practically all other platforms that use code signing (such as Java\nME and Windows Phone), code signing certificates must be issued by a CA\nthat the platform trusts. While there are many CAs that issue code signing\ncertificates, it can prove quite difficult to obtain a certificate that is trusted\nby all targeted devices. Android solves this problem quite simply: it doesn’t\ncare about the contents or signer of the signing certificate. Thus you do not\nneed to have it issued by a CA, and virtually all code signing certificates used\nin Android are self-signed. Additionally, you don’t need to assert your iden-\ntity in any way: you can use pretty much anything as the subject name. (The\nGoogle Play Store does have a few checks to weed out some common names,\nbut not the Android OS itself.) Android treats signing certificates as binary\nblobs, and the fact that they are in X.509 format is merely a consequence of\nusing the JAR format.\nAndroid doesn’t validate certificates in the PKI sense (see Chapter 6).\nIn fact, if a certificate is not self-signed, the signing CA’s certificate does not\nhave to be present or trusted; Android will even happily install apps with an\nexpired signing certificate. If you are coming from a traditional PKI back-\nground, this may sound like heresy, but keep in mind that Android does\nnot use PKI for code signing, it only uses the same certificate and signature\nformats.\nAnother difference between Android and “standard” JAR signing is\nthat all APK entries must be signed by the same set of certificates. The JAR\nfile format allows each file to be signed by a different signer and permits\nunsigned entries. This makes sense in the Java sandboxing and access con-\ntrol mechanism, which was originally designed for applets, because that\nmodel defines a code source as a combination of a signer certificate and code\norigin URL. However, Android assigns signers per-APK (usually only one,\nbut multiple signers are supported) and does not allow different signers for\ndifferent APK file entries.\nAndroid’s code signing model, coupled with the poor interface of the\njava.util.jar.JarFile class, which is not a good abstraction for the complexi-\nties of the underlying CMS signature format, makes it rather difficult to\nproperly verify the signature of APK files. While Android manages to both\nverify APK integrity and ensure that all APK file entries have been signed by\nPackage Management 59\nthe same set of certificates by adding additional signing certificate checks\nto its package parsing routines, it is evident that the JAR file format was not\nthe best choice for Android code signing.\nAndroid Code Signing Tools\nAs the examples in the “Java Code Signing” section showed, you can use the\nregular JDK code signing tools to sign or verify APKs. In addition to these\ntools, the AOSP build/ directory contains an Android-specific tool called\nsignapk. This tool performs pretty much the same task as jarsigner in signing\nmode, with a few notable differences. For one, while jarsigner requires that\nkeys be stored in a compatible keystore file, signapk takes a separate signing\nkey (in DER-encoded PKCS#8 format6) and certificate file (in DER-encoded\nX.509 format) as input. The advantage of the PKCS#8 format, which is the\nstandard key encoding format in Java, is that it includes an explicit algorithm\nidentifier that describes the type of the encoded private key. The encoded\nprivate key might include key material, possibly encrypted, or it might con-\ntain only a reference, such as a key ID, to a key stored in a hardware device.\nAs of Android 4.4, the signapk can only produce signatures with the\nSHA1withRSA or SHA256withRSA (added to the platform in Android 4.3)\nmechanisms. As of this writing, the version of signapk found in AOSP’s mas-\nter branch has been extended to support ECDSA signatures.\nWhile raw private keys in PKCS#8 format are somewhat hard to come\nby, you can easily generate a test key pair and a self-signed certificate using\nthe make_key script found in development/tools/. If you have existing OpenSSL\nkeys, you’ll have to convert them to PKCS#8 format first, using something\nlike OpenSSL’s pkcs8 command as shown in Listing 3-10:\n$ echo \"keypwd\"|openssl pkcs8 -in mykey.pem -topk8 -outform DER -out mykey.pk8 -passout stdin\nListing 3-10: Converting an OpenSSL key to PKCS#8 format\nOnce you have the needed keys, you can sign an APK using signapk as\nshown in Listing 3-11.\n$ java -jar signapk.jar cert.cer key.pk8 test.apk test-signed.apk\nListing 3-11: Signing an APK using the signapk tool\nOTA File Code Signing\nBesides its default APK signing mode, the signapk tool also has a “sign whole\nfile” mode that can be enabled with the -w option. When in this mode, in\naddition to signing each individual JAR entry, the tool generates a signature\nover the whole archive as well. This mode is not supported by jarsigner and\nis specific to Android.\n6. EMC RSA Laboratories, PKCS #8: Private-Key Information Syntax Standard, http://www.emc.com/\nemc-plus/rsa-labs/standards-initiatives/pkcs-8-private-key-information-syntax-stand.htm\n60 Chapter 3\nWhy sign the whole archive when each file is already signed? In order\nto support over-the-air (OTA) updates. OTA packages are ZIP files in a for-\nmat similar to JAR files that contain updated files and the scripts to apply\nthem. The packages include a META-INF/ directory, manifests, a signature\nblock, and a few extra files, including META-INF/com/android/otacert, which\ncontains the update signing certificate (in PEM format). Before booting\ninto recovery to apply updates, Android verifies the package signature\nand then checks to see if the signing certificate is trusted to sign updates.\nOTA-trusted certificates are separate from the “regular” system trust store\n(see Chapter 6), and reside in a ZIP file that is usually stored as /system/\netc/security/otacerts.zip. On a production device, this file typically contains\na single file usually named releasekey.x509.pem. After the device reboots, the\nrecovery OS verifies the OTA package signature once again before apply-\ning it in order to make sure that the OTA file has not been tampered with\nin the meantime.\nIf OTA files are like JAR files, and JAR files don’t support whole-file\nsignatures, where does the signature go? The Android signapk tool slightly\nabuses the ZIP format by adding a null-terminated string comment in the\nZIP comment section, followed by the binary signature block and a 6-byte\nfinal record containing the signature offset and the size of the entire com-\nment section. Adding the offset record to the end of the file makes it easy to\nverify the package by first reading and verifying the signature block from the\nend of the file, and only reading the rest of the file (which could be in the\nhundreds of megabytes) if the signature checks out.\naPk Install Process\nThere are a few ways to install Android applications:\n• Via an application store client (such as the Google Play Store). This is\nhow most users install applications.\n• Directly on the device by opening downloaded app files (if the “Unknown\nsources” option in system settings is enabled). This method is commonly\nreferred to as sideloading an app.\n• From a USB-connected computer with the adb install Android SDK com-\nmand which, in turn invokes the pm command line utility with the install\nparameter. This method is used mostly by application developers.\n• By directly copying an APK file to one of the system application direc-\ntories using the Android shell. Because application directories are not\naccessible on production builds, this method can only be used on\ndevices running an engineering (development) build.\nWhen an APK file is copied directly to one of the application direc-\ntories it is automatically detected and installed by the package manager,\nwhich watches these directories for changes. In the case of all other install\nmethods, the installer application (whether Google Play Store client, default\nsystem package install activity, pm command, or other) invokes one of the\nPackage Management 61\ninstallPackage() methods of the system package manager, which then copies\nthe APK to one of the application directories and installs it. In the following\nsections, we’ll explore the main steps of the Android package install process,\nand discuss some of the more complex installation steps like encrypted con-\ntainer creation and package verification.\nAndroid’s package management functionality is distributed across\nseveral system components that interact with each other during package\ninstallation, as shown in Figure 3-1. Solid arrows in the figure represent\ndependencies between components, as well as function calls. Dashed\narrows point to files or directories that are monitored for changes by a\ncomponent, but which are not directly modified by that component.\nPackageInstaller pm\nsystem app command\n/dev/socket/installd installd\nInstaller\ndaemon\nPackageManager\n/dev/socket/vold vold\nMountService\ndaemon\nMediaContainerService\nuserdata partition\npackages.xml\nsystem partition packages.list\nframework/ app-private/\napp/ AppDirObserver app/\npriv-app/ app-asec/\napp-lib/\nvendor/app/\ndalvik-cache/\ndata/\nmedia/\nuser/\nFigure 3-1: Package management components\nLocation of Application Packages and Data\nRecall from Chapter 1 that Android distinguishes between system- and user-\ninstalled applications. System applications are found on the read-only system\npartition (bottom left in Figure 3-1) and cannot be changed or uninstalled\non production devices. System applications are therefore considered trusted\nand are given more privileges, and have some signature checks relaxed. Most\nsystem applications are found in the /system/app/ directory, while /system/\npriv-app/ holds privileged apps that can be granted permission with the\n62 Chapter 3\nsignatureOrSystem protection level (as discussed in Chapter 2). The /system/\nvendor/app/ directory hosts vendor-specific applications. User-installed\napplications live on the read-write userdata partition (shown at the bottom\nright in Figure 3-1) and can be uninstalled or replaced at any time. Most\nuser-installed applications are installed in the /data/app/ directory.\nData directories for both system and user-installed applications are cre-\nated on the userdata partition under the /data/data/ directory. The userdata\npartition also hosts the optimized DEX files for user-installed applications\n(in /data/dalvik-cache/), the system package database (in /data/system/packages\n.xml), and other system databases and settings files. (We’ll discuss the rest\nof the userdata partition directories shown in Figure 3-1 when we cover the\nAPK install process.)\nActive Components\nHaving established the roles of the userdata and system partitions, let’s intro-\nduce the active components that play a role during package installation.\nPackageInstaller System Application\nThis is the default APK file handler. It\nprovides a basic GUI for package man-\nagement and when passed an APK file\nURI with the VIEW or INSTALL_ACTION\nintent action, it parses the package\nand displays an install confirmation\nscreen showing the permissions the\napplication requires (see Figure 2-1\non page 25). Installation using the\nPackageInstaller application is only\npossible if the user has enabled the\nUnknown Sources option in the\ndevice’s security settings (see Fig-\nure 3-2). If Unknown Sources is not\nenabled, PackageInstaller will show a\ndialog informing the user that installa-\ntion of apps obtained from unknown\nsources is blocked.\nWhat is considered an “unknown\nsource”? While the on-screen hint\ndefines it as “apps from sources other\nthan the Play Store,” the actual defini-\ntion is a bit more broad. When started,\nFigure 3-2: Application install security\nPackageInstaller retrieves the UID and\nsettings\npackage of the app that requested\nAPK installation and checks to see\nif it is a privileged app (installed in\nPackage Management 63\n/system/priv-app/). If the requesting app is unprivileged, it is considered\nan unknown source. If the Unknown Sources option is selected and the\nuser okays the install dialog, PackageInstaller calls the PackageManagerService,\nwhich performs the actual installation. The PackageInstaller GUI is also\nshown when upgrading side-loaded packages or uninstalling apps from the\nApps screen of System Settings.\npm command\nThe pm command (introduced in Chapter 2) provides a command-line\ninterface to some of the functions of the system package manager. It can\nbe used to install or uninstall packages when invoked as pm install or pm\nuninstall from the Android shell, respectively. Additionally, the Android\nDebug Bridge (ADB) client provides the adb install/uninstall shortcuts.\nUnlike the PackageInstaller, pm install does not depend on the Unknown\nSources system option and does not display a GUI, and it provides various\nuseful options for testing package installation that cannot be specified\nvia the PackageInstaller GUI. To start the install process, it calls the same\nPackageManager API as the GUI installer.\nPackageManagerService\nThe PackageManagerService (PackageManager in Figure 3-1) is the central object\nin Android’s package management infrastructure. It is responsible for pars-\ning APK files, starting the application install, upgrading and uninstalling\npackages, maintaining the package database, and managing permissions.\nThe PackageManagerService also provides a number of installPackage()\nmethods that can perform package installation with various options. The\nmost general of these is the installPackageWithVerificationAndEncryption(),\nwhich allows for the installation of an encrypted APK file, and package\nverification by a verification agent. (We’ll discuss app encryption and veri-\nfication later in “Installing Encrypted APKs” on page 76 and “Package\nVerification” on page 83.)\nNOTE The android.content.pm.PackageManager Android SDK facade class exposes a subset\nof the functionality of the PackageManagerService to third-party applications.\nInstaller class\nWhile the PackageManagerService is one of the most privileged Android system\nservices, it still runs inside the system server process (with the system UID)\nand lacks root privileges. However, because creating, deleting, and chang-\ning the ownership of application directories requires superuser capabilities,\nthe PackageManagerService delegates those operations to the installd daemon\n(discussed next). The Installer class connects to the installd daemon through\nthe /dev/socket/installd Unix domain socket and encapsulates the installd\ncommand-oriented protocol.\n64 Chapter 3\ninstalld Daemon\nThe installd daemon is a native daemon with elevated privileges that provides\napplication and user directory management functionality (for multi-user\ndevices) to the system package manager. It is also used to start the dexopt\ncommand, which generates optimized DEX files for newly installed packages.\nThe installd daemon is accessed via the installd local socket, which is only\naccessible to processes running as the system UID. The installd daemon does\nnot execute as root (although it used to do so in earlier Android versions),\nbut instead takes advantage of the CAP_DAC_OVERRIDE and CAP_CHOWN Linux capa-\nbilities7 in order to be able to set the owner and group UID of the application\ndirectories and files it creates to those of the owning application.\nMountService\nThe MountService is responsible for mounting detachable external storage\nsuch as SD cards, as well as opaque binary blob (OBB) files, which are used as\nexpansion files for applications. It is also used to kick off device encryption\n(see Chapter 10) and to change the encryption password.\nMountService also manages secure containers, which hold applications files\nthat should not be accessible to non-system applications. Secure containers\nare encrypted and used to implement a form of DRM called forward locking\n(discussed in “Forward Locking” on page 79 and “Android 4.1 Forward\nLocking Implementation” on page 80). Forward locking is used primar-\nily when installing paid applications in order to ensure that their APK files\ncannot be easily copied off the device and redistributed.\nvold daemon\nvold is Android’s volume management daemon. While the MountService\ncontains most system APIs that deal with volume management, because it\nruns as the system user it lacks the privileges required to actually mount and\nunmount disk volumes. Those privileged operations are implemented in\nthe vold daemon, which runs as root.\nvold has a local socket interface which is exposed via the /dev/socket/\nvold Unix domain socket that is only accessible to root and members of the\nmount group. Because the list of supplementary GIDs of the system_server\nprocess (which hosts MountService) includes mount (GID 1009), MountService\nis allowed to access vold’s command socket. Besides mounting and unmount-\ning volumes, vold can also create and format filesystems and manage secure\ncontainers.\nMediaContainerService\nThe MediaContainerService copies APK files to their final install location or to\nan encrypted container, and allows the PackageManagerService to access files\non removable storage. APK files obtained from a remote location (either\n7. For a discussion of Linux capabilities, see Chapter 39 of Michael Kerrisk’s The Linux\nProgramming Interface: A Linux and UNIX System Programming Handbook, No Starch Press, 2010.\nPackage Management 65\ndirectly or through an application market) are downloaded using Android’s\nDownloadManager service and the downloaded files are accessed through\nDownloadManager’s content provider interface. The PackageManager grants tem-\nporary access to each downloaded APK to the MediaContainerService process.\nIf the APK file is encrypted, MediaContainerService decrypts the file first\n(as discussed in “Installing an Encrypted APK with Integrity Check” on\npage 79). If an encrypted container was requested, MediaContainerService\ndelegates encrypted container creation to the MountService and copies the\nprotected part of the APK (both code and assets) into the newly created\ncontainer. Files that do not need to be protected by a container are copied\ndirectly to the filesystem.\nAppDirObserver\nAn AppDirObserver is a component that monitors an application direc-\ntory for APK file changes8 and calls the appropriate PackageManagerService\nmethod based on the event type. When an APK file is added to the system,\nAppDirObserver kicks off a package scan which either installs or updates the\napplication. When an APK file is removed, AppDirObserver starts the uninstall\nprocess, which removes app directories and the app entry in the system\npackage database.\nFigure 3-1 shows a single AppDirObserver instance due to space con-\nstraints, but there is a dedicated instance for each watched directory.\nThe directories monitored on the system partition are /system/framework/\n(which holds the framework resource package framework-res.apk); /system/\napp/ and /system/priv-app/ (system packages); and the vendor package\ndirectory /system/vendor/app/. The directories monitored on the userdata\npartition are /data/app/ and /data/app-private/ which hosts “old style” (pre-\nAndroid 4.1) forward locked APKs and temporary files produced during\nAPK decryption.\nInstalling a Local Package\nNow that we know what Android components are involved in package installa-\ntion, we’ll cover the install process, beginning with the simplest case: installing\nan unencrypted local package without verification and forward locking.\nParsing and Verifying the Package\nOpening a local APK file starts the application/vnd.android.package-archive\nhandler, typically the PackageInstallerActivity from the PackageInstaller system\napplication. PackageInstallerActivity first checks to see if the application that\nrequested the install is trusted (that is, not considered from an “unknown\nsource”). If it is not, and the Settings.Global.INSTALL_NON_MARKET_APPS is false (it\n8. File monitoring is implemented using Linux’s inotify facility. For more details about inotify,\nsee Chapter 19 of Michael Kerrisk’s The Linux Programming Interface: A Linux and UNIX System\nProgramming Handbook, No Starch Press, 2010.\n66 Chapter 3\nis set to true when the Unknown sources checkbox in Figure 3-2 is checked),\nPackageInstaller shows a warning dialog and ends the install process.\nIf the installation is allowed, the PackageInstallerActivity parses the APK\nfile and collects information from the AndroidManifest.xml file and pack-\nage signature. The integrity of the APK file is verified automatically while\nextracting the signing certificates for each of its entries using the java.util\n.jar.JarFile and related classes. This implementation is necessary because\nthe API of the JarFile class lacks any explicit methods to verify the signature\nof the whole file or of a particular entry. (System applications are implicitly\ntrusted and only the integrity of the AndroidManifest.xml file is verified when\nparsing their APK files. However, all APK entries are verified for packages\nthat are not part of the system image, such as user-installed applications or\nupdates for system applications.) The hash value of the AndroidManifest.xml\nfile is also calculated as part of APK parsing and passed to subsequent install\nsteps, which use it to verify that the APK file was not replaced between the\ntime when the user pressed OK in the install dialog and the APK copy pro-\ncess was started.\nNOTE Another noteworthy detail is that while at install time, APK file integrity is verified\nusing standard Java library classes, at runtime, the Dalvik virtual machine loads\nAPK files using its own native implementation of a ZIP/JAR file parser. Subtle dif-\nferences in their implementations have been the source of several Android bugs, most\nnotably bug #8219321 (commonly known as the Android Master Key) which allows\na signed APK file to be modified and still considered valid without resigning. A\nStrictJarFile class, which uses the same ZIP file parsing implementation as Dalvik,\nhas been added in AOSP’s master branch in order to address this. StrictJarFile\nis used by the system package manager when parsing APK files, ensuring that both\nDalvik and the package manager parse APK files in the same way. This new unified\nimplementation should be incorporated in future Android versions.\nAccepting Permissions and Starting the Install Process\nOnce the APK has been parsed, PackageInstallerActivity displays infor-\nmation about the application and the permissions it requires in a dialog\nsimilar to the one shown in Figure 2-1 (see page 25). If the user OK’s the\ninstall, PackageInstallerActivity forwards the APK file and its manifest digest,\nalong with install metadata such as the referrer URL, the installer package\nname, and originating UID to the InstallAppProgress activity, which starts\nthe actual package install process. InstallAppProgress then passes the APK\nURI and install metadata to the installPackageWithVerificationAndEncryption()\nmethod of the PackageManagerService, starting the install process. It then waits\nfor the process to complete and handles any errors.\nThe install method first verifies that the caller has the INSTALL_PACKAGES\npermission, which has a protection-level signature and is reserved for system\napplications. On multi-user devices, the method also verifies whether the\ncalling user is allowed to install applications. Next, it determines the pre-\nferred install location, which is either internal or external storage.\nPackage Management 67\nCopying to the Application Directory\nIf the APK file is not encrypted and no verification is required, the next\nstep is to copy it to the application directory (/data/app/). To copy the file,\nthe PackageManagerService first creates a temporary file in the application\ndirectory (with the vmdl prefix and .tmp extension) and then delegates\ncopying to the MediaContainerService. The file is not copied directly because\nit might need to be decrypted, or an encrypted container created for it if it\nwill be forward locked. Because the MediaContainerServices encapsulates\nthese tasks, the PackageManagerService does not need to be concerned with\nthe underlying implementation.\nWhen the APK file is successfully copied, any native libraries it contains\nare extracted to a dedicated app directory under the system’s native library\ndirectory (/data/app-lib/). Next, the temporary APK file and the library direc-\ntory are renamed to their final names, which are based on the package name,\nsuch as com.example.app-1.apk for the APK and /data/app-lib/com.example.app-1\nfor the library directory. Finally, the APK file permissions are set to 0644 and\nits SELinux context is set (see Chapter 12).\nNOTE By default, APK files are world-readable and any other application can access them.\nThis facilitates sharing public app resources and allows the development of third-\nparty launchers and other applications that need to show a list of all installed packages.\nHowever, those default permissions also allow anyone to extract APK files from a\ndevice, which is problematic for paid applications distributed via an application\nmarket. APK file forward locking provides a way for APK resources to remain public,\nwhile limiting access to code and assets.\nThe Package Scan\nThe next step in the install process is to trigger a package scan by calling\nthe scanPackageLI() method of PackageManagerService. (If the install process\nstops before scanning the new APK file, it will eventually be picked up by\nthe AppDirObserver instance which monitors the /data/app/ directory and\nalso triggers a package scan.)\nIn the case of a new install, the package manager first creates a new\nPackageSettings structure that contains the package name, code path, a\nseparate resource path if the package is forward-locked, and a native library\npath. It then assigns a UID to the new package and stores it in the settings\nstructure. Once the new app has a UID, its data directory can be created.\nCreating Data Directories\nBecause the PackageManagerService does not have enough privileges to cre-\nate and set ownership of app directories, it delegates directory creation\nto the installd daemon by sending it the install command which takes the\npackage name, UID, GID, and seinfo tag (used by SELinux) as parameters.\nThe installd daemon creates the package data directory (for example,\n68 Chapter 3\n/data/data/com.example.app/ when installing the com.example.app package),\nshared native library directory (/data/app-lib/com.example.app/), and local\nlibrary directory (/data/data/com.example.app/lib/). It then sets the package\ndirectory permissions to 0751 and creates symbolic links for the app’s native\nlibraries (if any) in the local library directory. Finally, it sets the SELinux\ncontext of the package directory and changes its owner to the UID and GID\nassigned to the app.\nIf the system has more than one user, the next step is to create data\ndirectories for each user by sending the mkuserdata command to installd\n(see Chapter 4). When all the necessary directories are created, control\nreturns to the PackageManagerService, which extracts any native libraries\nto the application’s native library directory and creates symbolic links in\n/data/data/com.example.app/lib/.\nGenerating Optimized DEX\nThe next step is to generate optimized DEX for the application’s code.\nThis operation is also delegated to installd by sending it the dexopt com-\nmand. The installd daemon forks a dexopt process, which creates the opti-\nmized DEX file in the /data/dalivk-cache/ directory. (The optimization\nprocess is also referred to as “sharpening.”)\nNOTE If the device is using the experimental Android Runtime (ART) introduced in ver-\nsion 4.4 instead of generating optimized DEX, installd generates native code using\nthe dex2oat command.\nFile and Directory Structure\nWhen all of the above processes have completed, the application’s files and\ndirectories might look something like Listing 3-12. (Timestamps and file\nsizes have been omitted.)\n-rw-r--r-- system system ... /data/app/com.example.app-1.apku\n-rwxr-xr-x system system ... /data/app-lib/com.example.app-1/libapp.sov\n-rw-r--r-- system all_a215 ... /data/dalvik-cache/data@app@com.example.app-1.apk@classes.dexw\ndrwxr-x--x u0_a215 u0_a215 ... /data/data/com.example.appx\ndrwxrwx--x u0_a215 u0_a215 ... /data/data/com.example.app/databasesy\ndrwxrwx--x u0_a215 u0_a215 ... /data/data/com.example.app/files\nlrwxrwxrwx install install ... /data/data/com.example.app/lib -> /data/app-lib/com.example.app-1z\ndrwxrwx--x u0_a215 u0_a215 ... /data/data/com.example.app/shared_prefs\nListing 3-12: Files and directories created after installing an application\nHere, u is the APK file and v is the extracted native library file. Both\nfiles are owned by system and are world readable. The file at w is the opti-\nmized DEX file for the application’s code. Its owner is set to system and its\ngroup is set to the special all_a215 group, which includes all device users\nPackage Management 69\nthat have installed the app. This allows all users to share the same optimized\nDEX file, thus avoiding the need to create a copy for each user, which could\ntake up too much disk space on a multi-user device. The application’s data\ndirectory x and its subdirectories (such as databases/ y) are owned by the\ndedicated Linux user created by combining the ID of the device user that\ninstalled the application (u0, the sole user on single-user devices) and the\napp ID (a215) to produce u0_a215. (App data directories are not read-\nable or writable by other users in accordance with Android’s sandboxing\nsecurity model. The lib/ directory z is merely a symbolic link to the app’s\nshared library directory in /data/app-lib/.)\nAdding the New Package to packages.xml\nThe next step is to add the package to the system package database. A\nnew package entry that looks like Listing 3-13 is generated and added to\npackages.xml.\n<package name=\"com.google.android.apps.chrometophone\"\ncodePath=\"/data/app/com.google.android.apps.chrometophone-2.apk\"\nnativeLibraryPath=\"/data/app-lib/com.google.android.apps.chrometophone-2\"\nflags=\"572996\"\nft=\"142dfa0e588\"\nit=\"142cbeac305\"\nut=\"142dfa0e8d7\"\nversion=\"16\"\nuserId=\"10088\"\ninstaller=\"com.android.vending\">u\n<sigs count=\"1\">\n<cert index=\"7\" key=\"30820252...\" />\n</sigs>v\n<perms>\n<item name=\"android.permission.USE_CREDENTIALS\" />\n<item name=\"com.google.android.apps.chrometophone.permission.C2D_MESSAGE\" />\n<item name=\"android.permission.GET_ACCOUNTS\" />\n<item name=\"android.permission.INTERNET\" />\n<item name=\"android.permission.WAKE_LOCK\" />\n<item name=\"com.google.android.c2dm.permission.RECEIVE\" />\n</perms>w\n<signing-keyset identifier=\"2\" />x\n</package>\nListing 3-13: Package database entry for a newly installed application\nHere, the <sigs> v element holds the DER-encoded values of the pack-\nage signing certificates (typically only one) in hexadecimal string format, or\na reference to the first occurrence of the certificate in the case of multiple\napps signed by the same key and certificate. The <perms> w elements holds\nthe permissions granted to the application, as described in Chapter 2.\nThe <signing-keyset> x element is new in Android 4.4 and holds a\nreference to the signing key set of the application, which contains all pub-\nlic keys (but not certificates) that have signed files inside the APK. The\n70 Chapter 3\nPackageManagerService collects and stores signing keys for all applications in a\nglobal <keyset-settings> element, but key sets are not checked or otherwise\nused as of Android 4.4.\nPackage Attributes\nThe root element <package> u (shown in Listing 3-13) holds the core attri-\nbutes of each package, such as install location and version. The main pack-\nage attributes are listed in Table 3-1. The information in each package\nentry can be obtained via the getPackageInfo(String packageName, int flags)\nmethod of the android.content.pm.PackageManager SDK class, which should\nreturn a PackageInfo instance that encapsulates the attributes available in\neach packages.xml entry, as well as information about components, permis-\nsions, and features defined in the application’s manifest.\nTable 3-1: Package Attributes\nAttribute Name Description\nname The package name .\ncodePath Full path to the location of the package .\nresourcePath Full path to the location of the publicly available parts of the\npackage (primary resource package and manifest) . Only set\non forward-locked apps .\nnativeLibraryPath Full path to the directory where native libraries are stored .\nflags Flags associated with the application .\nft APK file timestamp (Unix time in milliseconds, as per\nSystem.currentTimeMillis()) .\nit The time at which the app was first installed (Unix time in\nmilliseconds) .\nut The time the app was last updated (Unix time in milliseconds) .\nversion The version number of the package, as specified by the\nversionCode attribute in the app manifest .\nuserId The kernel UID assigned to the application .\ninstaller The package name of the application that installed the app .\nsharedUserId The shared user ID name of the package, as specified by the\nsharedUserId attribute in the manifest .\nUpdating Components and Permissions\nAfter creating the packages.xml entry, the PackageManagerService scans all\nAndroid components defined in the new application’s manifests and adds\nthem to its internal on-memory component registry. Next, any permission\ngroups and permissions the app declares are scanned and added to the per-\nmission registry.\nPackage Management 71\nNOTE Custom permissions defined by applications are registered using a “first one wins”\nstrategy: if both app A and B define permission P, and A is installed first, A’s permis-\nsion definition is registered and B’s permission definition is ignored (because P is\nalready registered). This is possible because permission names are not bound to the\ndefining app package in any way, and thus any app can define any permission. This\n“first one wins” strategy can result in permission protection level downgrade: if A’s\npermission definition has a lower protection level (for example, normal) than B’s\ndefinition (for example, signature), and A is installed first, access to B’s components\nprotected by P will not require callers to be signed with the same key as B. Therefore,\nwhen using custom permissions to protect components, be sure to check whether the\ncurrently registered permission has the protection level your app expects.9\nFinally, changes to the package database (the package entry and any\nnew permissions) are saved to disk and the PackageManagerService sends the\nACTION_PACKAGE_ADDED to notify other components about the newly added\napplication.\nUpdating a Package\nThe process of updating a package follows most of the same steps as install-\ning a package, so we’ll highlight only the differences here.\nSignature Verification\nThe first step is to check whether the new package has been signed by the\nsame set of signers as the existing one. This rule is referred to as same origin\npolicy, or Trust On First Use (TOFU). This signature check guarantees that the\nupdate is produced by the same entity as the original application (assuming\nthat the signing key has not been compromised) and establishes a trust rela-\ntionship between the update and the existing application. As we shall see in\n“Updating Non-System Apps” on page 75, the update inherits the data of\nthe original application.\nNOTE When signing certificates are compared for equality, the certificates are not validated\nin the PKI sense of the word (time validity, trusted issuer, revocation, and so on are\nnot checked).\nThe certificate equality check is performed by the PackageManagerService\n.compareSignatrues() method as shown in Listing 3-14.\nstatic int compareSignatures(Signature[] s1, Signature[] s2) {\nif (s1 == null) {\nreturn s2 == null\n? PackageManager.SIGNATURE_NEITHER_SIGNED\n: PackageManager.SIGNATURE_FIRST_NOT_SIGNED;\n}\n9. See CommonsWare, CWAC-Security, https://github.com/commonsguy/cwac-security, for further\ndiscussion and a sample project that shows how to perform the check.\n72 Chapter 3\nif (s2 == null) {\nreturn PackageManager.SIGNATURE_SECOND_NOT_SIGNED;\n}\nHashSet<Signature> set1 = new HashSet<Signature>();\nfor (Signature sig : s1) {\nset1.add(sig);\n}\nHashSet<Signature> set2 = new HashSet<Signature>();\nfor (Signature sig : s2) {\nset2.add(sig);\n}\n// Make sure s2 contains all signatures in s1.\nif (set1.equals(set2)) {u\nreturn PackageManager.SIGNATURE_MATCH;\n}\nreturn PackageManager.SIGNATURE_NO_MATCH;\n}\nListing 3-14: Package signature comparison method\nHere, the Signature class serves as an “opaque, immutable representa-\ntion of a signature associated with an application package.” 10 In practice, it\nis a wrapper for the DER-encoded signing certificate associated with an APK\nfile. Listing 3-15 shows an excerpt, focusing on its equals() and hashCode()\nmethods.\npublic class Signature implements Parcelable {\nprivate final byte[] mSignature;\nprivate int mHashCode;\nprivate boolean mHaveHashCode;\n--snip--\npublic Signature(byte[] signature) {\nmSignature = signature.clone();\n}\npublic PublicKey getPublicKey() throws CertificateException {\nfinal CertificateFactory certFactory =\nCertificateFactory.getInstance(\"X.509\");\nfinal ByteArrayInputStream bais = new ByteArrayInputStream(mSignature);\nfinal Certificate cert = certFactory.generateCertificate(bais);\nreturn cert.getPublicKey();\n}\n@Override\npublic boolean equals(Object obj) {\ntry {\nif (obj != null) {\nSignature other = (Signature)obj;\nreturn this == other\n|| Arrays.equals(mSignature, other.mSignature);u\n}\n10. Google, Android API Reference, “Signature,” https://developer.android.com/reference/android/\ncontent/pm/Signature.html\nPackage Management 73\n} catch (ClassCastException e) {\n}\nreturn false;\n}\n@Override\npublic int hashCode() {\nif (mHaveHashCode) {\nreturn mHashCode;\n}\nmHashCode = Arrays.hashCode(mSignature);v\nmHaveHashCode = true;\nreturn mHashCode;\n}\n--snip--\n}\nListing 3-15: Package signature representation\nAs you can see at u, two signature classes are considered equal if the\nDER-encoding of the underlying X.509 certificates match exactly, and the\nSignature class hash code is calculated solely based on the encoded certificate\nv. If the signing certificates do not match, the compareSignatures() methods\nreturns the INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES error code.\nThis binary certificate comparison naturally knows nothing about CAs\nor expiration dates. One consequence of this is that after an app (identified\nby a unique package name) is installed, updates need to use the same sign-\ning certificates (with the exception of system app updates, as discussed in\n“Updating System Apps” on page 75).\nWhile multiple signatures on Android apps are rare, they do occur. If\nthe original application was signed by more than one signer, any updates\nneed to be signed by the same signers, each using its original signing cer-\ntificate (enforced by u in Listing 3-14). This means that if a developer’s\nsigning certificate(s) expires or he loses access to his signing key, he cannot\nupdate the app and must release a new one instead. This would result in not\nonly losing any existing user base or ratings, but more importantly losing\naccess to the legacy app’s data and settings.\nThe solution to this problem is straightforward, if not ideal: back up\nyour signing key and don’t let your certificate expire. The currently rec-\nommended validity period is at least 25 years, and the Google Play Store\nrequires validity until at least October 2033. While technically this only\namounts to putting off the problem, proper certificate migration support\nmight eventually be added to the platform.\nWhen the package manager establishes that the update has been signed\nwith the same certificate, it proceeds with updating the package. The process\nis different for system and user-installed apps, as described next.\n74 Chapter 3\nUpdating Non-System Apps\nNon-system apps are updated by essentially reinstalling the app while retain-\ning its data directory. The first step is to kill any process of the package being\nupdated. Next, the package is removed from internal structures and the\npackage database, which removes all components that the app has registered\nas well. Next, the PackageManagerService triggers a package scan by calling\nthe scanPackageLI() method. The scan proceeds as it would with new installs,\nexcept that it updates the package’s code, resource path, version, and time-\nstamp. The package manifest is scanned and any defined components are\nregistered with the system. Next, permissions for all packages are re-granted\nto ensure that they match any definitions in the updated package. Finally, the\nupdated packaged database is written to disk and a PACKAGE_REPLACED system\nbroadcast is sent.\nUpdating System Apps\nAs with user-installed apps, preinstalled apps (usually found in /system/app/)\ncan be updated without a full-blown system update, usually via the Google\nPlay Store or a similar app distribution service. Though because the system\npartition is mounted read-only, updates are installed in /data/app/, while\nthe original app is left intact. In addition to a <package> entry, the updated\napp will also have an <updated-package> entry that might look like the example\nin Listing 3-16.\n<package name=\"com.google.android.keep\"\ncodePath=\"/data/app/com.google.android.keep-1.apk\"u\nnativeLibraryPath=\"/data/app-lib/com.google.android.keep-1\"\nflags=\"4767461\"v\nft=\"142ee64d980\"\nit=\"14206f3e320\"\nut=\"142ee64dfcb\"\nversion=\"2101\"\nuserId=\"10053\"w\ninstaller=\"com.android.vending\">\n<sigs count=\"1\">\n<cert index=\"2\" />\n</sigs>\n<signing-keyset identifier=\"3\" />\n<signing-keyset identifier=\"34\" />\n</package>\n--snip--\n<updated-package name=\"com.google.android.keep\"\ncodePath=\"/system/app/Keep.apk\"\nnativeLibraryPath=\"/data/app-lib/Keep\"\nft=\"ddc8dee8\"\nit=\"14206f3e320\"\nut=\"ddc8dee8\"\nversion=\"2051\"\nuserId=\"10053\">x\nPackage Management 75\n<perms>\n<item name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n<item name=\"android.permission.USE_CREDENTIALS\" />\n<item name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n--snip--\n</perms>\n</updated-package>\nListing 3-16: Package database entries for an updated system package\nThe update’s codePath attribute is set to the path of the new APK\nin /data/app/ u. It inherits the original app’s permissions and UID (w\nand x) and is marked as an update to a system app by adding the\nFLAG_UPDATED_SYSTEM_APP (0x80) to its flags attribute v.\nSystem apps can be updated directly in the system partition as well, usu-\nally as the result of an OTA system update, and in such case the updated\nsystem APK is allowed to be signed with a different certificate. The rationale\nbehind this is that if the installer has enough privileges to write to the system\npartition, it can be trusted to change the signing certificate as well. The\nUID, and any files and permissions, are retained. The exception is that\nif the package is part of a shared user (discussed in Chapter 2), the sig-\nnature cannot be updated, because doing so would affect other apps. In\nthe reverse case, when a new system app is signed by a different certificate\nthan that of the currently installed non-system app (with the same package\nname), the non-system app will be deleted first.\nInstalling Encrypted APKs\nSupport for installing encrypted APKs was added in Android 4.1 along\nwith support for forward locking using ASEC containers. Both features\nwere announced as app encryption, but we’ll discuss them separately, begin-\nning with support for encrypted APK files. But first let’s see how to install\nencrypted APKs.\nEncrypted APKs can be installed using the Google Play Store client, or\nwith the pm command from the Android shell, but the system PackageInstaller\ndoes not support encrypted APKs. Because we can’t control the Google\nPlay Store installation flow, in order to install an encrypted APK we need\nto either use the pm command or write our own installer app. We’ll take the\neasy route and use the pm command.\nCreating and Installing an Encrypted APK\nThe adb install command both copies the APK file to a temporary file on\nthe device and starts the install process. The command provides a conve-\nnient wrapper to the adb push and pm install commands. adb install gained\nthree new parameters in Android 4.1 in order to support encrypted APKs\n(see Listing 3-17).\n76 Chapter 3\nadb install [-l] [-r] [-s] [--algo <algorithm name> --key <hex-encoded key>\n--iv <hex-encoded iv>] <file>\nListing 3-17: adb install command options\nThe --algo, --key, and --iv parameters let you specify the encryption\nalgorithm, key, and initialization vector (IV), respectively. But in order to\nuse those new parameters, we need to create an encrypted APK first.\nAn APK file can be encrypted using the enc OpenSSL commands\nas shown in Listing 3-18. Here we use AES in CBC mode with a 128-bit\nkey, and specify an IV that is the same as the key in order to make things\nsimpler.\n$ openssl enc -aes-128-cbc -K 000102030405060708090A0B0C0D0E0F\n-iv 000102030405060708090A0B0C0D0E0F -in my-app.apk -out my-app-enc.apk\nListing 3-18: Encrypting an APK file using OpenSSL\nNext, we install our encrypted APK by passing the encryption algo-\nrithm key (in javax.crypto.Cipher transformation string format, which is\ndiscussed in Chapter 5) and IV bytes to the adb install command as shown\nin Listing 3-19.\n$ adb install --algo 'AES/CBC/PKCS5Padding' \\\n--key 000102030405060708090A0B0C0D0E0F \\\n--iv 000102030405060708090A0B0C0D0E0F my-app-enc.apk\npkg: /data/local/tmp/my-app-enc.apk\nSuccess\nListing 3-19: Installing an encrypted APK using adb install\nAs the Success output indicates, the APK installs without errors. The\nactual APK file is copied into /data/app/, and comparing its hash with our\nencrypted APK reveals that it is in fact a different file. The hash value is\nexactly the same as that of the original (unencrypted) APK, so we conclude\nthat the APK is decrypted at install time using the provided encryption\nparameters (algorithm, key, and IV).\nImplementation and Encryption Parameters\nLet’s see how this is implemented. After it has transferred the APK\nto the device, adb install calls the pm Android command-line utility with\nthe install parameter and the path to the copied APK file. The compo-\nnent responsible for installing apps on Android is PackageManagerService\nand the pm command is just a convenient frontend for some of its func-\ntionality. When started with the install parameter, pm calls the method\ninstallPackageWithVerificationAndEncryption(), converting its options to the\nrelevant parameters as necessary. Listing 3-20 shows the method’s full\nsignature.\nPackage Management 77\npublic void installPackageWithVerificationAndEncryption(Uri packageURI,\nIPackageInstallObserver observer, int flags,\nString installerPackageName,\nVerificationParams verificationParams,\nContainerEncryptionParams encryptionParams) {\n--snip--\n}\nListing 3-20: PackageManagerService.installPackageWithVerificationAndEncryption()\nmethod signature\nWe discussed most of the method’s parameters in “APK Install\nProcess” earlier, but we have yet to encounter the VerificationParams and\nContainerEncryptionParams classes. As the name implies, the VerificationParams\nclass encapsulates a parameter used during package verification, which we will\ndiscuss in “Package Verification” on page 83. The ContainerEncryptionParams\nclass holds encryption parameters, including the values passed via the --algo,\n--key, and --iv options of adb install. Listing 3-21 shows its data members.\npublic class ContainerEncryptionParams implements Parcelable {\nprivate final String mEncryptionAlgorithm;\nprivate final IvParameterSpec mEncryptionSpec;\nprivate final SecretKey mEncryptionKey;\nprivate final String mMacAlgorithm;\nprivate final AlgorithmParameterSpec mMacSpec;\nprivate final SecretKey mMacKey;\nprivate final byte[] mMacTag;\nprivate final long mAuthenticatedDataStart;\nprivate final long mEncryptedDataStart;\nprivate final long mDataEnd;\n--snip--\n}\nListing 3-21: ContainerEncryptionParams data members\nThe adb install parameters above correspond to the first three fields\nof the class. While not available through the adb install wrapper, the\npm install command also takes the --macalgo, --mackey, and --tag param-\neters, which correspond to the mMacAlgorithm, mMacKey, and mMacTag fields of\nthe ContainerEncryptionParams class. In order to use those parameters, we\nneed to calculate the MAC value of the encrypted APK first, which we\naccomplish with the OpenSSL dgst command as shown in Listing 3-22.\n$ openssl dgst -hmac 'hmac_key_1' -sha1 -hex my-app-enc.apk\nHMAC-SHA1(my-app-enc.apk)= 962ecdb4e99551f6c2cf72f641362d657164f55a\nListing 3-22: Calculating the MAC of an encrypted APK\n78 Chapter 3\nNOTE The dgst command doesn’t allow you to specify the HMAC key using hexadecimal or\nBase64, so we’re limited to ASCII characters. This may not be a good idea for produc-\ntion use, so consider using a real key and calculating the MAC in some other way (for\nexample, using a JCE program).\nInstalling an Encrypted APK with Integrity Check\nWe can now install an encrypted APK and verify its integrity by opening\nthe Android shell using adb shell and executing the command shown in\nListing 3-23.\n$ pm install -r --algo 'AES/CBC/PKCS5Padding' \\\n--key 000102030405060708090A0B0C0D0E0F \\\n--iv 000102030405060708090A0B0C0D0E0F \\\n--macalgo HmacSHA1 --mackey 686d61635f6b65795f31 \\\n--tag 962ecdb4e99551f6c2cf72f641362d657164f55a /sdcard/my-app-enc.apk\npkg: /sdcard/kr-enc.apk\nSuccess\nListing 3-23: Installing an encrypted APK with integrity verification using pm install\nThe app’s integrity is checked by comparing the specified MAC tag\nwith the value calculated based on the actual file contents, the contents are\ndecrypted, and the decrypted APK is copied to /data/app/. (To test that MAC\nverification is indeed performed, change the tag value slightly. Doing so\nshould result in an install error with error code INSTALL_FAILED_INVALID_APK.)\nAs we saw in Listings 3-19 and 3-23, the APK files that are ultimately\ncopied to /data/app/ are not encrypted and thus the installation process\nis the same as for unencrypted APKs, except for file decryption and the\noptional integrity verification. Decryption and integrity verification are\nperformed transparently by the MediaContainerService while copying the\nAPK to the application directory. If a ContainerEncryptionParams instance\nis passed to its copyResource() method, it uses the provided encryption\nparameters to instantiate the JCA classes Cipher and Mac (see Chapter 5)\nthat can perform decryption and integrity checking.\nNOTE The MAC tag and encrypted APK can be bundled in a single file, in which case the\nMediaContainerService uses the mAuthenticatedDataStart, mEncryptedDataStart, and\nmDataEnd members to extract the MAC and APK data from the file.\nForward Locking\nForward locking appeared around the time ringtones, wallpapers, and\nother digital “goods” started selling on feature phones. Because installed\nAPK files are world readable on Android, it’s relatively easy to extract apps\nfrom even a production device. In an attempt to lock down paid apps (and\nprevent a user from forwarding them to another user) without losing any of\nthe OS’s flexibility, early Android versions introduced forward locking (also\ncalled copy protection).\nPackage Management 79\nThe idea behind forward locking was to split app packages into two\nparts: a world-readable part that contains resources and the manifest\n(in /data/app/), and a package that is readable only by the system user and\nwhich contains executable code (in /data/app-private/). The code package\nwas protected by filesystem permissions, which made it inaccessible to users\non most consumer devices, but it could be extracted from devices with root\naccess, and this early forward locking mechanism was quickly deprecated\nand replaced with an online application licensing service called Google\nPlay Licensing.\nThe problem with Google Play Licensing was that it shifted app pro-\ntection implementation from the OS to app developers, and it had mixed\nresults. The forward locking implementation was redesigned in Android 4.1,\nand now offers the ability to store APKs in an encrypted container that\nrequires a device-specific key to be mounted at runtime. Let’s look at it in a\nbit more detail.\nAndroid 4.1 Forward Locking Implementation\nWhile the use of encrypted app containers as a forward locking mechanism\nwas introduced in Android version 4.1, encrypted containers were originally\nintroduced in Android 2.2. At that time (mid-2010), most Android devices\ncame with limited internal storage and relatively large (a few gigabytes)\nexternal storage, usually in the form of a microSD card. To make file shar-\ning easier, external storage was formatted using the FAT filesystem, which\nlacks file permissions. As a result, files on the SD card could be read and\nwritten by any application.\nTo prevent users from simply copying paid apps from the SD card,\nAndroid 2.2 created an encrypted filesystem image file and stored the\nAPK in it when a user opted to move an app to external storage. The sys-\ntem would then create a mount point for the encrypted image, and mount\nit using Linux’s device-mapper. Android loaded each app’s files from its\nmount point at runtime.\nAndroid 4.1 built on this idea by making the container use the ext4\nfilesystem, which allows for file permissions. A typical forward-locked app’s\nmount point now looks like Listing 3-24 (timestamps omitted).\n# ls -l /mnt/asec/com.example.app-1\ndrwxr-xr-x system system lib\ndrwx------ root root lost+found\n-rw-r----- system u0_a96 1319057 pkg.apk\n-rw-r--r-- system system 526091 res.zip\nListing 3-24: Contents of a forward-locked app’s mount point\nHere, the res.zip holds app resources and the manifest file and is world\nreadable, while the pkg.apk file that holds the full APK is only readable by\nthe system and the app’s dedicated user (u0_a96). The actual app contain-\ners are stored in /data/app-asec/ in files with the .asec extension.\n80 Chapter 3\nEncrypted App Containers\nEncrypted app containers are referred to as Android Secure External Caches, or\nASEC containers. ASEC container management (creating, deleting, mount-\ning, and unmounting) is implemented in the system volume daemon (vold),\nand the MountService provides an interface to its functionality to framework\nservices. We can also use the vdc command-line utility to interact with vold in\norder to manage forward-locked apps from Android’s shell (see Listing 3-25).\n# vdc asec listu\nvdc asec list\n111 0 com.example.app-1\n111 0 org.foo.app-1\n200 0 asec operation succeeded\n# vdc asec path com.example.app-1v\nvdc asec path com.example.app-1\n211 0 /mnt/asec/com.example.app-1\n# vdc asec unmount org.example.app-1w\n200 0 asec operation succeeded\n# vdc asec mount com.example.app-1 000102030405060708090a0b0c0d0e0f 1000x\ncom.example.app-1 000102030405060708090a0b0c0d0e0f 1000\n200 0 asec operation succeeded\nListing 3-25: Issuing ASEC management commands with vdc\nHere, the asec list command u lists the namespace IDs of mounted\nASEC containers. Namespace IDs are based on the package name and have\nthe same format as APK filenames for non-forward-locked applications. All\nother commands take a namespace ID as a parameter.\nThe asec path command v shows the mount point of the specified ASEC\ncontainer, while the asec unmount command unmounts it w. In addition to a\nnamespace ID, asec mount x requires that you specify the encryption key and\nthe mount point’s owner UID (1000 is system).\nThe ASEC container encryption algorithm and the key length are\nunchanged from the original Android 2.2 apps-to-SD implementation: Twofish\nwith a 128-bit key stored in /data/misc/systemkeys/, as shown in Listing 3-26.\n# ls -l /data/misc/systemkeys\n-rw------- system system 16 AppsOnSD.sks\n# od -t x1 /data/misc/systemkeys/AppsOnSD.sks\n0000000 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\n0000020\nListing 3-26: ASEC container encryption key location and contents\nForward locking an application is triggered by specifying the -l option\nof pm install or by specifying the INSTALL_FORWARD_LOCK flag when calling one of\nPackageManager’s installPackage() methods.\nPackage Management 81\nInstalling Forward-Locked APKs\nThe install process of forward-locked APKs involves two additional steps: cre-\nating and mounting the secure container, and extracting the public resource\nfiles from the APK file. As with encrypted APKs, those steps are encapsulated\nby the MediaContainerService and are performed while copying the APK to\nthe application directory. As the MediaContainerService does not have enough\nprivileges to create and mount secure containers, it delegates container man-\nagement to the vold daemon by calling the appropriate MountService methods\n(createSecureContainer(), mountSecureContainer(), and so on).\nEncrypted Apps and Google Play\nBecause installing apps without user interaction, encrypted or otherwise,\nrequires system permissions, only system applications can install applica-\ntions. Google’s own Play Store Android client takes advantage of both\nencrypted apps and forward locking. While describing exactly how the\nGoogle Play client works would require detailed knowledge of the under-\nlying protocol (which is not open and is constantly evolving), a casual look\ninto the implementation of a recent Google Play Store client reveals a few\nuseful pieces of information.\nGoogle Play servers send quite a bit of metadata about the app you are\nabout to download and install, such as download URL, APK file size, ver-\nsion code, and refund window. Among these, the EncryptionParams shown\nin Listing 3-27 looks very similar to the ContainerEncryptionParams shown in\nListing 3-21.\nclass AndroidAppDelivery$EncryptionParams {\n--snip--\nprivate String encryptionKey;\nprivate String hmacKey;\nprivate int version;\n}\nListing 3-27: EncryptionParams used in the Google Play Store protocol\nThe encryption algorithm and the HMAC algorithm of paid applications\ndownloaded from Google Play are always set to AES/CBC/PKCS5Padding and\nHMACSHA1, respectively. The IV and the MAC tag are bundled with the\nencrypted APK in a single blob. After all parameters are read and verified,\nthey are essentially converted to a ContainerEncryptionParams instance, and\nthe app is installed using the PackageManager.installPackageWithVerification()\nmethod.\nThe INSTALL_FORWARD_LOCK flag is set when installing a paid app in order\nto enable forward locking. The OS takes it from here, and the process is\nas described in the previous two sections: free apps are decrypted and the\nAPKs end up in /data/app/, while an encrypted container in /data/app-asec/\nis created and mounted under /mnt/asec/<package-name> for paid apps.\n82 Chapter 3\nHow secure is this in practice? Google Play can now claim that paid\napps are always transferred and stored in encrypted form, and so can your\nown app distribution channel if you decide to implement it using the app\nencryption facilities that Android provides. The APK file contents have\nto be made available to the OS at some point though, so if you have root\naccess to a running Android device, it’s still possible to extract a forward-\nlocked APK or the container encryption key.\nPackage verification\nPackage verification was introduced\nas an official Android feature in ver-\nsion 4.2 as application verification and\nwas later backported to all versions\nrunning Android 2.3 and later and the\nGoogle Play Store. The infrastructure\nthat makes package verification pos-\nsible is built into the OS, but Android\ndoesn’t ship with any built-in verifiers.\nThe most widely used package veri-\nfication implementation is the one\nbuilt into the Google Play Store client\nand backed by Google’s app analysis\ninfrastructure. It’s designed to protect\nAndroid devices from what Google calls\n“potentially harmful applications”11\n(backdoors, phishing applications, spy-\nware, and so on), commonly known\nsimply as malware.\nWhen package verification is\nturned on, APKs are scanned by a veri-\nfier prior to installation, and the sys-\ntem shows a warning (see Figure 3-3)\nFigure 3-3: Application verification\nor blocks installation if the verifier\nwarning dialog\ndeems the APK potentially harmful.\nVerification is on by default on sup-\nported devices but requires one-time\nuser approval on first use, as it sends application data to Google. Appli-\ncation verification can be toggled via the Verify Apps option on the system\nsettings Security screen (see Figure 3-2 on page 25).\nThe following sections discuss the Android package verification infra-\nstructure and then take a brief look at Google Play’s implementation.\n11. Google, Android Practical Security from the Ground Up, presented at VirusBulletin 2013.\nRetrieved from https://docs.google.com/presentation/d/1YDYUrD22Xq12nKkhBfwoJBfw2Q\n-OReMr0BrDfHyfyPw\nPackage Management 83\nAndroid Support for Package Verification\nAs with most things that deal with application management, package veri-\nfication is implemented in the PackageManagerService, and has been available\nsince Android 4.0 (API level 14). Package verification is performed by one\nor more verification agents, and has a required verifier and zero or more suf-\nficient verifiers. Verification is considered complete when the required veri-\nfier and at least one of the sufficient verifiers return a positive result. An\napplication can register itself as a required verifier by declaring a broadcast\nreceiver with an intent filter that matches the PACKAGE_NEEDS_VERIFICATION\naction and the APK file MIME type (application/vnd.android.package-archive),\nas shown in Listing 3-28.\n<receiver android:name=\".MyPackageVerificationReceiver\"\nandroid:permission=\"android.permission.BIND_PACKAGE_VERIFIER\">\n<intent-filter>\n<action\nandroid:name=\"android.intent.action.PACKAGE_NEEDS_VERIFICATION\" />\n<action android:name=\"android.intent.action.PACKAGE_VERIFIED\" />\n<data android:mimeType=\"application/vnd.android.package-archive\" />\n</intent-filter>\n</receiver>\nListing 3-28: Required verification declaration in AndroidManifest .xml\nIn addition, the declaring application needs to be granted the\nPACKAGE_VERIFICATION_AGENT permission. As this is a signature permission\nreserved for system applications (signature|system), only system applica -\ntions can become the required verification agent.\nApplications can register sufficient verifiers by adding a <package-verifier>\ntag to their manifest and listing the sufficient verifier’s package name and\npublic key in the tag’s attributes, as shown in Listing 3-29.\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\npackage=\"com.example.app\">\n<package-verifier android:name=\"com.example.verifier\"\nandroid:publicKey=\"MIIB...\" />\n<application ...>\n--snip--\n</application>\n</manifest>\nListing 3-29: Sufficient verifier declaration in AndroidManifest .xml\nWhen installing a package, the PackageManagerService performs verifica-\ntion when a required verifier is installed and the Settings.Global.PACKAGE_\nVERIFIER_ENABLE system setting is set to true. Verification is enabled by adding\nthe APK to a queue of pending installs and sending the ACTION_PACKAGE_NEEDS_\nVERIFICATION broadcast to registered verifiers.\n84 Chapter 3\nThe broadcasts contains a unique verification ID, and various metadata\nabout the package being verified. Verification agents respond by calling the\nverifyPendingInstall() method and passing the verification ID and a veri-\nfication status. Calling the method requires the PACKAGE_VERIFICATION_AGENT\npermission, which guarantees that non-system apps cannot participate\nin package verification. Each time the verifyPendingInstall() is called, the\nPackageManagerService checks to see whether sufficient verification for the\npending install has been received. If so, it removes the pending install from\nthe queue, sends the PACKAGE_VERIFIED broadcast, and starts the package instal-\nlation process. If the package is rejected by verification agents, or sufficient\nverification is not received within the allotted time, installation fails with\nthe INSTALL_FAILED_VERIFICATION_FAILURE error.\nGoogle Play Implementation\nGoogle’s application verification implementation is built into the Google\nPlay Store client. The Google Play Store app registers itself as a required\nverification agent and if the Verify apps option is turned on, it receives\na broadcast each time an application is about to be installed, whether\nthrough the Google Play Store client itself, the PackgeInstaller application,\nor via adb install.\nThe implementation is not open source, and few details are publicly\navailable, but Google’s “Protect against harmful apps” Android help page\nstates, “When you verify applications, Google receives log information, URLs\nrelated to the app, and general information about the device, such as the\nDevice ID, version of the operating system, and IP address.”12 We can observe\nthat, as of this writing, in addition to this information, the Play Store client\nsends the APK file’s SHA-256 hash value, file size, the app package name, the\nnames of its resources along with their SHA-256 hashes, the SHA-256 hashes\nof the app’s manifest and classes files, its version code and signing certificates,\nas well as some metadata about the installing application and referrer URLs,\nif available. Based on that information, Google’s APK analysis algorithms\ndetermine whether the APK is potentially harmful and return a result to the\nPlay Store client that includes a status code and an error message to display\nin case the APK is deemed potentially harmful. In turn, the Play Store client\ncalls the verifyPendingInstall() method of the PackageManagerService with the\nappropriate status code. Application install is accepted or rejected based on\nthe algorithm described in the previous section.\nIn practice (at least on “Google experience” devices), the Google Play\nStore verifier is usually the sole verification agent, so whether the package is\ninstalled or rejected depends only on the response of Google’s online verifi-\ncation service.\n12. Google, Protect against harmful apps, https://support.google.com/accounts/answer/2812853\nPackage Management 85\nsummary\nAndroid application packages (APK files) are an extension of the JAR\nfile format and contain resources, code, and a manifest file. APK files are\nsigned using the JAR file code signing format, but require that all files\nare signed with the same set of certificates. Android uses the code signer\ncertificate to establish the same origin of apps and their updates and to\nestablish trust relationships between apps. APK files are installed by copy-\ning them to the /data/app/ directory and creating a dedicated data direc-\ntory for each application under /data/data/.\nAndroid supports encrypted APK files and secure app containers for\nforward locked apps. Encrypted apps are automatically decrypted before\nbeing copied to the application directory. Forward locked apps are split into\na resource and manifest part, which is publicly accessible, and a private code\nand asset part, which is stored in a dedicated encrypted container, directly\naccessible only by the OS.\nAndroid can optionally verify apps before installing them by consulting\none or more verification agents. Currently, the most widely used verifica-\ntion agent is built into the Google Play Store client applications and uses\nGoogle’s online app verification service in order to detect potentially harm-\nful applications.\n86 Chapter 3",
    "question": "What is the difference between Android's code signing model and traditional PKI-based code signing schemes?",
    "summary": "Android uses APK files, which are similar to JAR files but include resources, code, and a manifest. APKs are signed with a set of certificates, and all entries must be signed by the same set. Android does not require certificates to be issued by a trusted CA, allowing self-signed certificates. It also does not validate certificates in the PKI sense, making it easier to install apps with expired certificates. Additionally, Android allows for encrypted APKs and secure containers for forward-locked apps, which are decrypted and stored in a protected location. The system can also verify APKs using verification agents, with Google Play Store being the primary one that checks for potentially harmful apps."
  },
  {
    "start": 59,
    "end": 74,
    "text": "4\nUsER m aNaGEmENT\nAndroid originally targeted personal devices such as\nsmartphones and assumed that each device had only\none user. With the increase in popularity of tablets\nand other shared devices, multi-user support was\nadded in version 4.2 and extended in later versions.\nIn this chapter, we’ll discuss how Android manages users who share\ndevices and data. We begin with a look at the types of users Android sup-\nports and how it stores user metadata. We then discuss how Android shares\ninstalled applications between users while isolating application data and\nkeeping it private to each user. Finally, we cover how Android implements\nisolated external storage.\nmulti-User support Overview\nAndroid’s multi-user support allows multiple users to share a single device\nby providing each user with an isolated, personal environment. Each user\ncan have their own home screen, widgets, apps, online accounts, and files\nthat are not accessible to other users.\nUsers are identified by a unique user ID (not to be confused with\nLinux UIDs) and only the system can switch between users. User switch-\ning is normally triggered by selecting a user from the Android lockscreen\nand (optionally) authenticating using a pattern, PIN, password, and so on\n(see Chapter 10). Applications can get information about the current user\nvia the UserManager API, but typically code modification is not required in\norder to support a multi-user environment. Applications that need to mod-\nify their behavior when used by a restricted profile are an exception: these\napplications require additional code that checks what restrictions (if any)\nare imposed on the current user (see “Restricted Profiles” on page 92 for\ndetails).\nMulti-user support is built into the core Android platform and is thus\navailable on all devices that run Android 4.2 or later. However, the default\nplatform configuration only allows for a single user, which effectively dis-\nables multi-user support. In order to enable support for multiple users, the\nconfig_multiuserMaximumUsers system resource must be set to a value greater\nthan one, typically by adding a device-specific overlay configuration file.\nFor example, on the Nexus 7 (2013), the overlay is placed in the device/\nasus/flo/overlay/frameworks/base/core/res/res/values/config.xml file and the\nconfig_multiuserMaximumUsers setting is defined as shown in Listing 4-1,\nto allow a maximum of eight users.\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources xmlns:xliff=\"urn:oasis:names:tc:xliff:document:1.2\">\n--snip--\n<!-- Maximum number of supported users -->\n<integer name=\"config_multiuserMaximumUsers\">8</integer>\n--snip--\n</resources>\nListing 4-1: Enabling multi-user support with a resource overlay file\nNOTE The Android Compatibility Definition requires that devices that support telephony\n(such as mobile phones) must not enable multi-user support because “the behav-\nior of the telephony APIs on devices with multiple users is currently undefined.” 1\nTherefore, in current production builds, all handsets are configured as single-user\ndevices.\n1. Google, Android 4.4 Compatibility Definition, “9.5. Multi-User Support,” http://static\n.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf\n88 Chapter 4\nWhen multi-user support is enabled, the system Settings application\ndisplays a Users entry that allows the device owner (the first user created,\nas discussed in the next section) to create and manage users. The user man-\nagement screen is shown in Figure 4-1.\nFigure 4-1: User management screen\nAs soon as more than one user has been created, the lockscreen shows\na user widget that displays the current users and allows switching to a differ-\nent user. Figure 4-2 shows how the lockscreen might look on a device with\neight users.\nUser Management 89\nFigure 4-2: Lockscreen with user switcher widget\nTypes of Users\nEven though Android lacks the full user management features of most\nmulti-user operating systems, which typically allow users to add multiple\nadministrators and define user groups, it does support configuring user\ntypes with different privileges. Each user type and its privileges will be\ndescribed in the following sections.\nThe Primary User (Owner)\nThe primary user, also known as the device owner, is the first user created\non a multi-user device, or the sole user on single-user devices. The owner\nis created by default and is always present. The primary user is assigned\nuser ID 0. On single-user devices where the primary user is the only user,\nAndroid behaves much like previous versions that lacked multi-user sup-\nport: directories and UIDs assigned to installed applications maintain\n90 Chapter 4\nthe same format and permissions as in previous versions (see “User\nManagement” on page 95 and “Application Sharing” on page 101 for\ndetails).\nThe primary user is assigned all privileges and can create and delete\nother users, as well as change system settings that affect all users, including\nsettings related to device security, network connectivity, and application\nmanagement. Device and user management privileges are granted to the\nprimary user by showing the respective settings screens in system settings\nand hiding them from other users. Additionally, the underlying system ser-\nvices check the identity of the calling user before performing operations\nthat can affect all users, and only allow execution when called by the device\nowner.\nAs of Android version 4.4, the following screens in the Wireless and\nNetworks section of system settings are displayed to only the primary user:\n• Cell broadcasts\n• Manage mobile plan\n• Mobile network\n• Tethering and portable hotspot\n• VPN\n• WiMAX (shown if supported by the device)\nThe following screens in the Security section are also reserved for the\nprimary user:\n• Device encryption\n• SIM card lock\n• Unknown sources (controls app sideloading; see Chapter 3)\n• Verify apps (controls package verification; see Chapter 3)\nSecondary Users\nWith the exception of restricted profiles (discussed in the next section), all\nadded users are secondary users. Each gets a dedicated user directory (see\n“User Management” on page 95), their own list of installed apps, and pri-\nvate data directories for each installed app.\nSecondary users cannot add or manage users; they can only set their\nown username via the Users screen (see Figure 4-1). Additionally, they can-\nnot perform any privileged operation reserved for the primary user as listed\nin the previous sections. Otherwise, secondary users can perform all the\noperations that a primary user can, including installing and using applica-\ntions, and changing the system appearance and settings.\nAlthough secondary users are restricted, their actions can still affect\ndevice behavior and other users. For example, they can add and connect to a\nnew Wi-Fi network. Because Wi-Fi connectivity state is shared across the sys-\ntem, switching to a different user does not reset the wireless connection, and\nthat user will be connected to the wireless network selected by the previous\nUser Management 91\nuser. Secondary users can also toggle airplane mode and NFC, and change\nthe global sound and display settings. Most importantly, as application pack-\nages are shared across all users (as discussed in “Application Sharing” on\npage 101), if a secondary user updates an application that adds new permis-\nsions, permissions are granted to the application without requiring the con-\nsent of other users, and other users are not notified of permission changes.\nRestricted Profiles\nUnlike secondary users, restricted profiles (added in Android 4.3) are\nbased on the primary user and share its applications, data, and accounts,\nwith certain restrictions. As such, the primary user must set up a lockscreen\npassword in order to protect their data. If no lockscreen password is in\nplace when the primary user creates a restricted profile, Android prompts\nthem to set up one.\nUser Restrictions\nAndroid defines the following default restrictions in order to control what\nusers are allowed to do. All restrictions are false by default. The list below\nshows their value for restricted users in parentheses.\nDISALLOW_CONFIG_BLUETOOTH Specifies whether a user is prevented from\nconfiguring Bluetooth. (default: false)\nDISALLOW_CONFIG_CREDENTIALS Specifies whether a user is prevented\nfrom configuring user credentials. When this restriction is set to true,\nrestricted profiles cannot add trusted CA certificates or import private\nkeys into the system credential store; see Chapters 6 and 7 for details.\n(default: false)\nDISALLOW_CONFIG_WIFI Specifies whether a user is prevented from chang-\ning Wi-Fi access points. (default: false)\nDISALLOW_INSTALL_APPS Specifies whether a user is prevented from\ninstalling applications. (default: false)\nDISALLOW_INSTALL_UNKNOWN_SOURCES Specifies whether a user is prevented\nfrom enabling the Unknown sources setting (see Chapter 3). (default:\nfalse)\nDISALLOW_MODIFY_ACCOUNTS Specifies whether a user is prevented from\nadding and removing accounts. (default: true)\nDISALLOW_REMOVE_USER Specifies whether a user is prevented from remov-\ning users. (default: false)\nDISALLOW_SHARE_LOCATION Specifies whether a user is prevented from\ntoggling location sharing. (default: true)\nDISALLOW_UNINSTALL_APPS Specifies whether a user is prevented from\nuninstalling applications. (default: false)\nDISALLOW_USB_FILE_TRANSFER Specifies whether a user is prevented from\ntransferring files over USB. (default: false)\n92 Chapter 4\nApplying Restrictions\nAt runtime, applications can use the UserManager.getUserRestrictions()\nmethod to get a Bundle (a universal container class that maps string keys\nto various value types) containing the restrictions imposed on a user.\nRestrictions are defined as key-value pairs, where the key is the restriction\nname and the Boolean value specifies whether it is in effect. Applications\ncan use that value in order to disable certain functionality when running\nwithin a restricted profile. For example, the system Settings app checks the\nvalue of the DISALLOW_SHARE_LOCATION restriction when displaying location pref-\nerences. If the value is true, it disables the location mode setting. Another\nexample is the PackageManagerService: it checks the DISALLOW_INSTALL_APPS and\nDISALLOW_UNINSTALL_APPS restrictions before installing or uninstalling apps\nand returns the INSTALL_FAILED_USER_RESTRICTED error code if any of those\nrestrictions are set to true for the calling user.\nThe primary user can select which applications will be available to a\nrestricted profile. When a restricted profile is created, all installed applica-\ntions are initially disabled, and the owner must explicitly enable the ones\nthat they want to make available to the restricted profile (see Figure 4-3).\nFigure 4-3: Restricted profile management screen\nUser Management 93\nIn addition to the built-in restrictions defined by the OS, applications\ncan define custom restrictions by creating a BroadcastReceiver that receives\nthe ACTION_GET_RESTRICTION_ENTRIES intent. Android invokes this intent to\nquery all apps for available restrictions and automatically builds a UI that\nallows device owners to toggle the app’s custom restrictions.\nAt runtime, applications can use the UserManager.getApplicationRestrictions()\nmethod to obtain a Bundle that contains saved restrictions as key-value pairs.\nThe application can then disable or modify certain features based on the\napplied restrictions. The device owner can toggle system and custom restric-\ntions on the same settings screen used to manage applications available to a\nrestricted profile. For example, in Figure 4-3, the single application restric-\ntion supported by the Settings app (whether to let apps use location informa-\ntion) is shown below the main application toggle.\nAccess to Online Accounts\nRestricted profiles can also access the online accounts of the primary user\nvia the AccountManager API (see Chapter 8), but this access is disabled by\ndefault. Applications that need access to accounts when running within\na restricted profile must explicitly declare the account types they require\nusing the restrictedAccountType attribute of the <application> tag, as shown in\nListing 4-2.\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\npackage=\"com.example.app\" ...>\n<application android:restrictedAccountType=\"com.google\" ... >\n--snip--\n</application>\n</manifest>\nListing 4-2: Allowing access to the owner’s accounts from a restricted profile\nOn the other hand, applications that do not want to expose account\ninformation to restricted profiles can declare this by specifying the account\ntype (an asterisk can be used to match all account types) as the value of the\nrequiredAccountType attribute of the <application> tag. If the requiredAccountType\nattribute is specified, Android will automatically disable such applications\nfor restricted profiles. For example, because the Android Calendar appli-\ncation declares android:requiredAccountType=\"*\" in its manifest, it cannot be\nmade available to restricted profiles and is disabled in the restrictions set-\ntings screen (see Figure 4-3).\nGuest User\nAndroid supports a single guest user, but this functionality is disabled\nby default. While the guest user can be enabled by calling the UserManager\n.setGuestEnabled() method, the guest user does not appear to be referenced\nanywhere other than by the UserManager and related classes in current\n94 Chapter 4\nAndroid versions. Code comments indicate that the guest user might be\ntransient, but as of this writing its exact purpose is not clear. It appears\nto be a remnant of a proposed feature that was rejected or never fully\nimplemented.\nUser management\nAndroid users are managed by the UserManagerService, which is responsible\nfor reading and persisting user information and maintaining the list of active\nusers. Because user management is closely related to package management,\nthe PackageManagerService calls the UserManagerService to query or modify users\nwhen packages are installed or removed. The android.os.UserManager class pro-\nvides a facade to the UserManagerService and exposes a subset of its function-\nality to third-party applications. Applications can get the number of users\non a system, a user’s serial number, the name and list of restrictions for the\ncurrent user, as well as the list of restrictions for a package without the need\nfor any special permissions. All other user operations, including querying,\nadding, removing, or modifying users, require the MANAGE_USERS system signa-\nture permission.\nCommand-Line Tools\nUser management operations can also be performed on the Android shell\nwith the pm command. These commands can be run via the shell without root\npermissions, because the shell user (UID 2000) is granted the MANAGE_USERS\npermission. You can use the pm create-user command to create a new user,\nand the pm remove-user to remove it. The command pm get-max-users returns\nthe maximum number of users supported by the OS, and pm list users lists\nall users. The output of the pm list users command might look like Listing 4-3\non a device with five users. The numbers in curly braces are the user ID,\nname, and flags, in that order.\n$ pm list users\nUsers:\nUserInfo{0:Owner:13}\nUserInfo{10:User1:10}\nUserInfo{11:User2:10}\nUserInfo{12:User3:10}\nUserInfo{13:Profile1:18}\nListing 4-3: Listing users using the pm list command\nUser States and Related Broadcasts\nThe UserManagerService sends several broadcasts to notify other compo-\nnents of user-related events. When a user is added, it sends the USER_ADDED\nbroadcast, and when a user is removed, it sends USER_REMOVED. If the user-\nname or their profile icon is changed, the UserManagerService sends the\nUser Management 95\nUSER_INFO_CHANGED broadcast. Switching users triggers the USER_BACKGROUND,\nUSER_FOREGROUND, and USER_SWITCHED broadcasts, all of which contain the rel-\nevant user ID as an extra.\nWhile Android supports a maximum of eight users, only three users\ncan be running at a time. A user is started when it is first switched to via\nthe lockscreen user switcher. Android stops inactive users based on a least\nrecently used (LRU) cache algorithm to ensure that no more than three\nusers are active.\nWhen a user is stopped, its processes are killed and it no longer receives\nany broadcasts. When users are started or stopped, the system sends the\nUSER_STARTING, USER_STARTED, USER_STOPPING, and USER_STOPPED broadcasts. The\nprimary user is started automatically when the system boots and is never\nstopped.\nStarting, stopping, and switching users, as well as targeting a specific\nuser with a broadcast, requires the INTERACT_ACROSS_USERS permission.\nThis is a system permission with signature protection, but it also has the\ndevelopment flag set (see Chapter 2) so it can be dynamically granted to\nnon-system applications that declare it (using the pm grant command). The\nINTERACT_ACROSS_USERS_FULL signature permission allows sending broadcasts\nto all users, changing the device administrator, as well as other privileged\noperations that affect all users.\nUser metadata\nAndroid stores user data in the /data/system/users/ directory that hosts\nmetadata about users in XML format, as well as user directories. On a\ndevice with five users, its contents may look like Listing 4-4 (timestamps\nhave been omitted).\n# ls -lF /data/system/users\ndrwx------ system system 0u\n-rw------- system system 230 0.xmlv\ndrwx------ system system 10\n-rw------- system system 245 10.xml\ndrwx------ system system 11\n-rw------- system system 245 11.xml\ndrwx------ system system 12\n-rw------- system system 245 12.xml\ndrwx------ system system 13\n-rw------- system system 299 13.xml\n-rw------- system system 212 userlist.xmlw\nListing 4-4: Contents of /data/system/users/\nThe User List File\nAs shown in Listing 4-4, each user has a dedicated directory called the\nuser system directory with a name that matches the assigned user ID (u for\n96 Chapter 4\nthe primary user) and an XML file that stores metadata about the user,\nagain with a filename based on the user ID (v for the primary user). The\nuserlists.xml file w holds data about all users created on a system and may\nlook like Listing 4-5 on a system with five users.\n<users nextSerialNumber=\"19\" version=\"4\">\n<user id=\"0\" />\n<user id=\"10\" />\n<user id=\"11\" />\n<user id=\"12\" />\n<user id=\"13\" />\n</users>\nListing 4-5: Contents of userlist .xml\nThe file format is basically a list of <user> tags holding the ID assigned to\neach user. The root <users> element has a version attribute specifying the cur-\nrent file version and a nextSerialNumber attribute holding the serial number to\nbe assigned to the next user. The primary user is always assigned user ID 0.\nThe fact that UIDs assigned to applications are based on the user ID of\nthe owning user ensures that on single-user devices, UIDs assigned to appli-\ncations are the same as they were before multi-user support was introduced.\n(For more on application UIDs, see “Application Data Directories” on\npage 100.) Secondary users and restricted profiles are assigned IDs begin-\nning with the number 10.\nUser Metadata Files\nThe attributes of each user are stored in a dedicated XML file. Listing 4-6\nshows an example for a restricted profile.\n<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n<user id=\"13\"\nserialNumber=\"18\"\nflags=\"24\"\ncreated=\"1394551856450\"\nlastLoggedIn=\"1394551882324\"\nicon=\"/data/system/users/13/photo.png\">u\n<name>Profile1</name>v\n<restrictions no_modify_accounts=\"true\" no_share_location=\"true\" />w\n</user>\nListing 4-6: User metadata file contents\nHere, the <name> tag v holds the user’s name and the <restrictions>\ntag w has attributes for each enabled restriction. (See “Restricted Profiles”\non page 92 for a list of built-in restrictions.) Table 4-1 summarizes the\nattributes of the root <user> element shown at u in Listing 4-6.\nUser Management 97\nTable 4-1: <user> Element Attributes\nName Format Description\nid integer User ID\nserialNumber integer User serial number\nflags integer Flags that indicate the type of user\ncreated milliseconds since the User creation time\nUnix epoch, as per\nSystem.currentTimeMillis()\nlastLoggedIn milliseconds since the Last login time\nUnix epoch, as per\nSystem.currentTimeMillis()\nicon string Full path to the user icon file\npartial Boolean Indicates that the user is partially\ninitialized . Partial users may\nnot have all of their files and\ndirectories created yet .\npinHash hexadecimal string The salted SHA1+MD5 PIN hash\nfor PIN-protected restrictions\nsalt long integer The PIN salt for PIN-protected\nrestrictions\nfailedAttempts integer The number of failed PIN entry\nattempts for PIN-protected\nrestrictions\nlastAttemptMs milliseconds since the The time of the last PIN entry\nUnix epoch, as per attempt for PIN-protected\nSystem.currentTimeMillis() restrictions (in milliseconds\nsince the Unix epoch, per\nSystem.currentTimeMillis())\nThe flags attribute is one of the most important as it determines the user\ntype. As of this writing, six bits of the flag value are used for the user type\nand the rest are reserved with the following flags currently defined:\nFLAG_PRIMARY (0x00000001) Marks the primary user.\nFLAG_ADMIN (0x00000002) Marks administrator users. Administrator\ncan create and delete users.\nFLAG_GUEST (0x00000004) Marks the guest user.\nFLAG_RESTRICTED (0x00000008) Marks restricted users.\nFLAG_INITIALIZED (0x00000010) Marks a user as fully initialized.\nWhile different flag combinations are possible, most combinations don’t\nrepresent a valid user type or state, and in practice the attributes for the pri-\nmary owner are set to 19 (0x13 or FLAG_INITIALIZED|FLAG_ADMIN|FLAG_PRIMARY),\nsecondary users have flags 16 (0x10 or FLAG_INITIALIZED), and restricted pro-\nfiles have flags 24 (0x18 or FLAG_INITIALIZED|FLAG_RESTRICTED).\n98 Chapter 4\nUser System Directory\nEach user system directory contains user-specific system settings and data\nbut no application data. As we’ll see in the next section, each application\nthat a user installs gets a dedicated data directory under /data, much like\non single-user devices. (See Chapter 3 for more on application data directo-\nries.) For example, in the case of a secondary user with user ID 12, the user\nsystem directory would be named /data/system/users/12/ and might contain\nthe files and directories listed in Listing 4-7.\n- accounts.dbu\n- accounts.db-journal\n- appwidgets.xmlv\n- device_policies.xmlw\n- gesture.keyx\nd inputmethody\n- package-restrictions.xmlz\n- password.key{\n- photo.png|\n- settings.db}\n- settings.db-journal\n- wallpaper~\n- wallpaper_info.xml\nListing 4-7: Contents of a user directory\nThe file accounts.db u is an SQLite database that holds online account\ndetails. (We discuss online account management in Chapter 8.) The file\nappwidgets.xml v holds information about widgets that the user has added\nto their home screen. The device_policies.xml w file describes the current\ndevice policy (see Chapter 9 for details), and gesture.key x and password.key {\ncontain the hash of the currently selected lockscreen pattern or PIN/pass-\nword, respectively (see Chapter 10 for format details).\nThe inputmethod directory y contains information about input meth-\nods. The photo.png file | stores the user’s profile image or picture. The file\nsettings.db } holds system settings specific to that user, and wallpaper ~ is the\ncurrently selected wallpaper image. The package-restrictions.xml file z defines\nwhat applications the user has installed and stores their state. (We discuss\napplication sharing and per-user application data in the next section.)\nPer-User application management\nAs mentioned in “Multi-User Support Overview” on page 87, besides\ndedicated accounts and settings, each user gets their own copy of applica-\ntion data that cannot be accessed by other users. Android achieves this by\nassigning a new, per-user effective UID for each application and creating a\ndedicated application data directory owned by that UID. We’ll discuss the\ndetails of this implementation in the following sections.\nUser Management 99\nApplication Data Directories\nAs we covered in Chapter 3, Android installs APK packages by copying them\nto the /data/app/ directory, and creates a dedicated data directory for each\napplication under /data/data/. When multi-user support is enabled, this lay-\nout is not changed but extended to support additional users. Application data\nfor the primary user is still stored in /data/data/ for backward compatibility.\nIf other users exist on the system when a new application is being\ninstalled, the PackageManagerService creates application data directories for\neach user. As with the data directory for the primary user, those directories\nare created with the help of the installd daemon (using the mkuserdata com-\nmand) because the system user does not have enough privileges to change\ndirectory ownership.\nUser data directories are stored in /data/user/ and named after the\nuser’s ID. The device owner directory (0/) is a symbolic link to /data/data/,\nas shown in Listing 4-8.\n# ls -l /data/user/\nlrwxrwxrwx root root 0 -> /data/data/\ndrwxrwx--x system system 10\ndrwxrwx--x system system 11\ndrwxrwx--x system system 12\ndrwxrwx--x system system 13\nListing 4-8: Contents of /data/user/ on a multi-user device\nThe contents of each application data directory are the same as /data/\ndata/, but application directories for each user’s instance of the same appli-\ncation are owned by a different Linux user, as shown in Listing 4-9.\n# ls -l /data/data/u\ndrwxr-x--x u0_a12 u0_a12 com.android.apps.tag\ndrwxr-x--x u0_a0 u0_a0 com.android.backupconfirm\ndrwxr-x--x bluetooth bluetooth com.android.bluetooth\ndrwxr-x--x u0_a16 u0_a16 com.android.browserv\ndrwxr-x--x u0_a17 u0_a17 com.android.calculator2\ndrwxr-x--x u0_a18 u0_a18 com.android.calendar\n--snip--\n# ls -l /data/user/13/w\nls -l /data/user/13\ndrwxr-x--x u13_system u13_system android\ndrwxr-x--x u13_a12 u13_a12 com.android.apps.tag\ndrwxr-x--x u13_a0 u13_a0 com.android.backupconfirm\ndrwxr-x--x u13_bluetooth u13_bluetooth com.android.bluetooth\ndrwxr-x--x u13_a16 u13_a16 com.android.browserx\ndrwxr-x--x u13_a17 u13_a17 com.android.calculator2\ndrwxr-x--x u13_a18 u13_a18 com.android.calendar\n--snip--\nListing 4-9: Contents of application data directories for the primary user and one\nsecondary user\n100 Chapter 4\nThis listing shows the contents of the app data directories for the pri-\nmary user u and the secondary user with user ID 13 w. As you can see,\neven though both users have data directories for the same apps, such as\nthe browser app (v for the owner and x for the secondary user), those\ndirectories are owned by different Linux users: u0_a16 in the case of the\nowner and u13_a16 in the case of the secondary user. If we check the UID\nfor those users using the su and id commands, we find that u0_a16 has\nUID=10016, and u13_a16 has UID=1310016.\nThe fact that both UIDs contain the number 10016 is no coinci-\ndence. The repeating part is called the app ID and is the same as the UID\nassigned to the app when first installed on a single-user device. On multi-\nuser devices, the app UID is derived from the user ID and the app ID\nusing the following code:\nuid = userId * 100000 + (appId % 100000)\nBecause the owner’s user ID is always 0, the UIDs for the device owner’s\napps are always the same as their app IDs. When the same application is\nexecuted in the context of different users, it executes under the respec-\ntive UIDs assigned to each user’s application instance. For example, if the\nbrowser application is executed simultaneously by the device owner and\na secondary user with user ID 13, two separate processes running as the\nu0_a16 and u13_a16 Linux users will be created (UID 10016, for the owner u\nand UID 1310016, for the secondary user v) as shown in Listing 4-10.\nUSER PID PPID VSIZE RSS WCHAN PC NAME\n--snip--\nu13_a16 1149 180 1020680 72928 ffffffff 4006a58c R com.android.browseru\n--snip--\nu0_a16 30500 180 1022796 73384 ffffffff 4006b73c S com.android.browserv\n--snip--\nListing 4-10: Process information for the browser application when executed by different\ndevice users\nApplication Sharing\nWhile installed applications have a dedicated data directory for each\nuser, the APK files are shared among all users. The APK files are copied\nto /data/app/ and are readable by all users; shared libraries used by apps\nare copied to /data/app-lib/<package name>/ and are symlinked to /data/\nuser/<user ID>/<package name>/lib/; and the optimized DEX files for each\napp are stored in /data/dalvik-cache/ and are also shared by all users. Thus\nonce an application is installed, it is accessible to all device users, and an\napp data directory is automatically created for each user.\nAndroid makes it possible for users to have different applications by\ncreating a package-restrictions.xml file (z in Listing 4-7) in the system direc-\ntory of each user, which it uses to track whether an app is enabled for a user\nUser Management 101\nor not. Besides the install state of packages, this file contains information\nabout the disabled components of each application, as well as a list of pre-\nferred applications to start when processing intents that can be handled by\nmore than one application (such as opening a text file, for example). The\ncontents of package-restrictions.xml might look like Listing 4-11 for a second-\nary user.\n<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n<package-restrictions>\n<pkg name=\"com.example.app\" inst=\"false\" stopped=\"true\" nl=\"true\" />u\n<pkg name=\"com.example.app2\" stopped=\"true\" nl=\"true\" />v\n--snip--\n<pkg name=\"com.android.settings\">\n<disabled-components>\n<item name=\"com.android.settings.CryptKeeper\" />\n</disabled-components>\n</pkg>\n<preferred-activities />\n</package-restrictions>\nListing 4-11: Contents of the package-restrictions.xml file\nHere, the com.example.app package is available on the system but is not\ninstalled for that secondary user, as expressed by adding a <pkg> for the\napp and setting the inst attribute to false u. Based on this information,\nthe PackageManagerService marks the com.example.app package as not installed\nfor that user and the package doesn’t show up in the launcher or the list of\napps in Settings.\nApplications can be installed but still marked as stopped, as shown at v.\nHere, the com.example.app2 package is installed but marked as stopped by set-\nting the stopped attribute to true. Android has a special state for applications\nthat have never been launched; a state that is persisted with the nl attribute\nof the <pkg> tag. The device owner can block a package for a certain user,\nin which case the blocked attribute is set to true, though this is not shown in\nFigure 4-4.\nWhen a device user installs an application, a <pkg> tag with inst=\"false\"\nis added to the package-restrictions.xml files for all users. When another user\ninstalls the same application, the inst attribute is removed and the applica-\ntion is considered installed for that user. (Depending on how the second\nuser started the install process, the APK file in /data/app/ may be replaced,\nas it is in an application update.)\nRestricted users cannot install applications, but the same proce -\ndure is applied when the device owner enables an app for a restricted\nuser: the application is installed by calling the PackageManagerService\n.installExistingPackageAsUser() method, which sets the installed flag\nfor the package and updates package-restrictions.xml accordingly.\n102 Chapter 4\nFigure 4-4: Warning shown when the device owner tries to\nuninstall an app for all users\nWhen a user uninstalls a package, their app data is deleted and the\ninternal per-user package installed flag is set to false. This state is then\npersisted by setting inst=\"false\" to the removed package’s tag in the user’s\npackage-restrictions.xml file. The APK file and native library directory are\nonly removed when the last user that has the app installed uninstalls it.\nHowever, the owner can see all apps installed on the system in the All tab\nof the Apps Settings screen, including ones they haven’t installed, and they\ncan un install those apps for all users. The Uninstall for all users action\nis hidden in the overflow menu so that it isn’t selected accidentally. It pro-\nduces the warning shown in Figure 4-4. If the owner selects OK in this\nwarning dialog, app directories for all users are removed and the APK file\nis deleted from the device.\nUser Management 103\nThe app-sharing scheme implemented on multi-user Android devices\nis backward-compatible with previous versions and saves device space by\nnot copying APK files for all users. However, it has one major disadvantage:\nany user can update an application, even if it was originally installed by\nanother user.\nThis scheme is usually not a problem, because every user’s app instance\nhas a separate data directory, except when the update adds new permis-\nsions. Because Android grants permissions at install time, if a user updates\nan app and accepts a new permission that affects user privacy (for example,\nREAD_CONTACTS), that permission will apply to all users who use the app. Other\nusers are not notified that the app has been granted a new permission and\nmay never notice the change, unless they manually inspect the app’s details\nin system Settings. Android does show a warning that notifies users about\nthis fact when they first enable multi-user support, but does not send subse-\nquent notifications about specific apps.\nExternal storage\nAndroid has included support for external storage since the first public\nversions. Because the first few generations of Android devices imple-\nmented external storage by simply mounting a FAT-formatted removable\nSD card, external storage is often referred to as “the SD card.” However, the\ndefinition of external storage is broader and simply requires that external\nstorage be a “case-insensitive filesystem with immutable POSIX permission\nclasses and modes.”2 The underlying implementation may be anything that\nsatisfies this definition.\nExternal Storage Implementations\nNewer devices tend to implement external storage by emulation, and some\ndon’t have an SD card slot at all. For example, the last Google Nexus device\nthat had an SD card slot was the Nexus One, released in January 2010, and\nall Nexus devices released after the Nexus S (which uses a dedicated parti-\ntion for external storage) implement external storage by emulation. On\ndevices that lack an SD card, external storage is implemented either by\ndirectly mounting a FAT-formatted partition, which resides on the same\nblock device as primary storage, or by using a helper daemon to emulate it.\nBeginning with Android version 4.4, apps have been able to manage\ntheir package-specific directories (Android/data/com.example.app/ for an app\nwith the com.example.app package) on external storage without requiring the\nWRITE_EXTERNAL_STORAGE permission, which grants access to all data on external\n2. Google, “External Storage Technical Information,” http://source.android.com/devices/tech/\nstorage/index.html\n104 Chapter 4\nstorage, including camera pictures, videos, and other media. This feature\nis called synthesized permissions and its AOSP implementation is based on a\nFUSE daemon that wraps the raw device storage and manages file access\nand permission based on a specified permission emulation mode.\nNOTE Filesystem in Userspace, or FUSE,3 is a Linux feature that allows the implementa-\ntion of a fully functional filesystem in a userspace program. This is achieved by using\na generic FUSE kernel module that routes all Virtual Filesystem (VFS) system calls for\nthe target filesystem to its userspace implementation. The kernel module and the user-\nspace implementation communicate via a special file descriptor obtained by opening\n/dev/fuse.\nAs of Android version 4.4, multiple external storage devices can be\naccessed by applications, but the applications are only allowed to write arbi-\ntrary files on primary external storage (if they hold the WRITE_EXTERNAL_STORAGE\npermission), and they have only limited access to other external storage\ndevices, referred to as secondary external storage. Our discussion will focus on\nprimary external storage as it’s most closely related to multi-user support.\nMulti-User External Storage\nIn order to uphold the Android security model in a multi-user environ-\nment, the Android Compatibility Definition Document (CDD) places\nnumerous requirements on external storage. The most important of these\nis that “Each user instance on an Android device MUST have separate and\nisolated external storage directories.” 4\nUnfortunately, implementing this requirement poses a problem because\nexternal storage has traditionally been world-readable and implemented\nusing the FAT filesystem, which does not support permissions. Google’s\nimplementation of multi-user external storage leverages three Linux kernel\nfeatures in order to provide backward-compatible, per-user external storage:\nmount namespaces, bind mounts, and shared subtrees.\nAdvanced Linux Mount Features\nAs in other Unix systems, Linux manages all files from all storage devices as\npart of a single directory tree. Each filesystem is linked to a specific subtree\nby mounting it at a specified directory, called the mount point. Traditionally,\nthe directory tree has been shared by all processes, and each process sees the\nsame directory hierarchy.\n3. “Filesystem in Userspace,” http://fuse.sourceforge.net/\n4. Google, Android 4.4 Compatibility Definition, “9.5. Multi-User Support,” http://static\n.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf\nUser Management 105\nLinux 2.4.19 and later versions added support for per-process mount\nnamespaces, which allows each process to have its own set of mount points\nand thus use a directory hierarchy different from that of other processes.5\nThe current list of mounts for each process can be read from the /proc/PID/\nmounts virtual file, where PID is the process ID. A forked Linux process can\nrequest a separate mount namespace by specifying the CLONE_NEWNS flag\nto the Linux-specific clone() 6 and unshare() 7 system calls. In this case, the\nnamespace of the parent process is referred to as the parent namespace.\nA bind mount allows a directory or file to be mounted at another path in\nthe directory tree, making the same file or directory visible at multiple loca-\ntions. A bind mount is created by specifying the MS_BIND flag to the mount()\nsystem call, or by passing the --bind parameter to the mount command.\nFinally, shared subtrees,8 which were first introduced in Linux 2.6.15, pro-\nvide a way to control how filesystem mounts are propagated across mount\nnamespaces. Shared subtrees make it possible for a process to have its\nown namespace but still access filesystems that are mounted after it starts.\nShared subtrees provide four different mount types, of which Android uses\nthe shared and slave mount. A shared mount created in a parent namespace\npropagates to all child namespaces and is thus visible to all processes that\nhave cloned off a namespace. A slave mount has a master mount that is a\nshared mount, and also propagates new mounts. However, the propagation\nis one-way only: mounts at the master propagate to the slave, but mounts at\nthe slave do not propagate to the master. This scheme allows a process to\nkeep its mounts invisible to any other process, while still being able to see\nshared system mounts. Shared mounts are created by passing the MS_SHARED\nflag to the mount() system call, while creating slave mounts requires passing\nthe MS_SLAVE flag.\nAndroid Implementation\nSince Android 4.4, mounting external storage directly is no longer sup-\nported but is emulated using the FUSE sdcard daemon, even when the\nunderlying device is a physical SD card. We’ll base our discussion on a con-\nfiguration that is backed by a directory on internal storage, which is typical\nfor devices without a physical SD card. (The official documentation9 con-\ntains more details on other possible configurations.)\nOn a device where primary external storage is backed by internal stor-\nage, the sdcard FUSE daemon uses the /data/media/ directory as a source and\n5. Michael Kerrisk, The Linux Programming Interface: A Linux and UNIX System Programming\nHandbook, No Starch Press, 2010, pp. 261\n6. Ibid., 598\n7. Ibid., 603\n8. Linux Kernel, Shared Subtrees, https://www.kernel.org/doc/Documentation/filesystems/\nsharedsubtree.txt\n9. Google, “External Storage: Typical Configuration Examples,” http://source.android.com/\ndevices/tech/storage/config-example.html\n106 Chapter 4\ncreates an emulated filesystem at /mnt/shell/emulated. Listing 4-12 shows how\nthe sdcard service is declared in the device-specific init.rc file in this case {.\n--snip--\non init\nmkdir /mnt/shell/emulated 0700 shell shellu\nmkdir /storage/emulated 0555 root rootv\nexport EXTERNAL_STORAGE /storage/emulated/legacyw\nexport EMULATED_STORAGE_SOURCE /mnt/shell/emulatedx\nexport EMULATED_STORAGE_TARGET /storage/emulatedy\n# Support legacy paths\nsymlink /storage/emulated/legacy /sdcardz\nsymlink /storage/emulated/legacy /mnt/sdcard\nsymlink /storage/emulated/legacy /storage/sdcard0\nsymlink /mnt/shell/emulated/0 /storage/emulated/legacy\n# virtual sdcard daemon running as media_rw (1023)\nservice sdcard /system/bin/sdcard -u 1023 -g 1023 -l /data/media /mnt/shell/emulated{\nclass late_start\n--snip--\nListing 4-12: sdcard service declaration for emulated external storage\nHere, the -u and -g options specify the user and group the daemon\nshould run as, and -l specifies the layout used for emulated storage (dis-\ncussed later in this section). As you can see at u, the /mnt/shell/emulated/\ndirectory (available via the EMULATED_STORAGE_SOURCE environment variable x)\nis owned and only accessible by the shell user. Its contents might look like\nListing 4-13 on a device with five users.\n# ls -l /mnt/shell/emulated/\ndrwxrwx--x root sdcard_r 0\ndrwxrwx--x root sdcard_r 10\ndrwxrwx--x root sdcard_r 11\ndrwxrwx--x root sdcard_r 12\ndrwxrwx--x root sdcard_r 13\ndrwxrwx--x root sdcard_r legacy\ndrwxrwx--x root sdcard_r obb\nListing 4-13: Contents of /mnt/shell/emulated/\nAs with app data directories, each user gets a dedicated external stor-\nage data directory named after their user ID. Android uses a combina-\ntion of mount namespaces and bind mounts in order to make each user’s\nexternal storage data directory available only to the applications that the\nuser starts, without showing them other users’ data directories. Because all\napplications are forked off the zygote process (discussed in Chapter 2), exter-\nnal storage setup is implemented in two steps: the first one is common to all\nprocesses, and the second is specific to each process. First, mount points\nUser Management 107\nthat are shared by all forked app processes are set up in the unique zygote\nprocess. Then dedicated mount points, which are visible only to that pro-\ncess, are set up as part of each app’s process specialization.\nLet’s first look at the shared part in the zygote process. Listing 4-14 shows\nan excerpt of the initZygote() function (found in dalvik/vm/Init.cpp) that\nhighlights mount point setup.\nstatic bool initZygote()\n{\nsetpgid(0,0);\nif (unshare(CLONE_NEWNS) == -1) {u\nreturn -1;\n}\n// Mark rootfs as being a slave so that changes from default\n// namespace only flow into our children.\nif (mount(\"rootfs\", \"/\", NULL, (MS_SLAVE | MS_REC), NULL) == -1) {v\nreturn -1;\n}\nconst char* target_base = getenv(\"EMULATED_STORAGE_TARGET\");\nif (target_base != NULL) {\nif (mount(\"tmpfs\", target_base, \"tmpfs\", MS_NOSUID | MS_NODEV,w\n\"uid=0,gid=1028,mode=0751\") == -1) {\nreturn -1;\n}\n}\n--snip--\nreturn true;\n}\nListing 4-14: Mount point setup in zygote\nHere, zygote passes the CLONE_NEWNS flag to the unshare() system call u in\norder to create a new, private mount namespace that will be shared by all\nits children (app processes). It then marks the root filesystem (mounted\nat /) as a slave by passing the MS_SLAVE flag to the mount() system call v. This\nensures that changes from the default mount namespace, such as mounting\nencrypted containers or removable storage, only propagate to its children,\nwhile at the same time making sure that any mounts created by children do\nnot propagate into the default namespace. Finally, zygote creates the memory-\nbacked EMULATED_STORAGE_TARGET (usually /storage/emulated/) mount point by\ncreating a tmpfs filesystem w, which children use to bind mount external\nstorage into their private namespaces.\nListing 4-15 shows the process-specific mount point setup found in\ndalvik/vm/native/dalvik_system_Zygote.cpp that is executed when forking each\napp process off zygote. (Error handling, logging, and some variable declara-\ntions have been omitted.)\n108 Chapter 4\nstatic int mountEmulatedStorage(uid_t uid, u4 mountMode) {\nuserid_t userid = multiuser_get_user_id(uid);u\n// Create a second private mount namespace for our process\nif (unshare(CLONE_NEWNS) == -1) {v\nreturn -1;\n}\n// Create bind mounts to expose external storage\nif (mountMode == MOUNT_EXTERNAL_MULTIUSER\n|| mountMode == MOUNT_EXTERNAL_MULTIUSER_ALL) {\n// These paths must already be created by init.rc\nconst char* source = getenv(\"EMULATED_STORAGE_SOURCE\");w\nconst char* target = getenv(\"EMULATED_STORAGE_TARGET\");x\nconst char* legacy = getenv(\"EXTERNAL_STORAGE\");y\nif (source == NULL || target == NULL || legacy == NULL) {\nreturn -1;\n}\n--snip--\n// /mnt/shell/emulated/0\nsnprintf(source_user, PATH_MAX, \"%s/%d\", source, userid);z\n// /storage/emulated/0\nsnprintf(target_user, PATH_MAX, \"%s/%d\", target, userid);{\n--snip--\nif (mountMode == MOUNT_EXTERNAL_MULTIUSER_ALL) {\n// Mount entire external storage tree for all users\nif (mount(source, target, NULL, MS_BIND, NULL) == -1) {\nreturn -1;\n}\n} else {\n// Only mount user-specific external storage\nif (mount(source_user, target_user, NULL, MS_BIND, NULL) == -1) {|\nreturn -1;\n}\n}\n--snip--\n// Finally, mount user-specific path into place for legacy users\nif (mount(target_user, legacy, NULL, MS_BIND | MS_REC, NULL) == -1) {}\nreturn -1;\n}\n} else {\nreturn -1;\n}\nreturn 0;\n}\nListing 4-15: External storage setup for app processes\nUser Management 109\nHere, the mountEmulatedStorage() function first obtains the current user\nID from the process UID u, then uses the unshare() system call to create a\nnew mount namespace for the process by passing the CLONE_NEWNS flag v.\nThe function then obtains the values of the EMULATED_STORAGE_SOURCE w,\nEMULATED_STORAGE_TARGET x, and EXTERNAL_STORAGE y environment variables,\nwhich are all initialized in the device-specific init.rc file (see w, x, and y in\nListing 4-12). It then prepares the mount source z and target { directory\npaths based on the values of EMULATED_STORAGE_SOURCE, EMULATED_STORAGE_TARGET,\nand the current user ID.\nThe directories are created if they don’t exist, and then the method\nbind mounts the source directory (such as /mnt/shell/emulated/0 for the\nowner user) at the target path (for example, /storage/emulated/0 for the\nowner user) |. This ensures that external storage is accessible from the\nAndroid shell (started with the adb shell command), which is used exten-\nsively for application development and debugging.\nThe final step is to recursively bind mount the target directory at the\nfixed legacy directory (/storage/emulated/legacy/) }. The legacy directory is\nsymlinked to /sdcard/ in the device-specific init.rc file (z in Listing 4-12)\nfor backward compatibility with apps that hardcode this path (normally\nobtained using the android.os.Environment.getExternalStorageDirectory() API).\nAfter all steps have been executed, the newly created app process is\nguaranteed to see only the external storage allotted to the user that started\nit. We can verify this by looking at the list of mounts for two app process\nexecuted by different users as shown in Listing 4-16.\n# cat /proc/7382/mounts\n--snip--\n/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,\ngroup_id=1023,default_permissions,allow_other 0 0u\n/dev/fuse /storage/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,\ngroup_id=1023,default_permissions,allow_other 0 0v\n/dev/fuse /storage/emulated/legacy fuse rw,nosuid,nodev,relatime,user_id=1023,\ngroup_id=1023,default_permissions,allow_other 0 0w\n# cat /proc/7538/mounts\n--snip--\n/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,\ngroup_id=1023,default_permissions,allow_other 0 0x\n/dev/fuse /storage/emulated/10 fuse rw,nosuid,nodev,relatime,user_id=1023,\ngroup_id=1023,default_permissions,allow_other 0 0y\n/dev/fuse /storage/emulated/legacy fuse rw,nosuid,nodev,relatime,user_id=1023,\ngroup_id=1023,default_permissions,allow_other 0 0z\nListing 4-16: List of mount points for process started by different users\nHere, the process started by the owner user with PID 7382 has a /storage/\nemulated/0 mount point v, which is a bind mount of /mnt/shell/emulated/0/,\nand process 7538 (started by a secondary user) has a /storage/emulated/10\nmount point y, which is a bind mount of /mnt/shell/emulated/10/.\nBecause neither process has a mount point for the other process’s exter-\nnal storage directory, each process can only see and modify its own files.\n110 Chapter 4\nBoth processes have a /storage/emulated/legacy mount point (w and z), but\nbecause it is bound to different directories (/storage/emulated/0/ and /mnt/\nshell/emulated/10/, respectively), each process sees different contents. Both\nprocess can see /mnt/shell/emulated/ (u and x), but because this directory\nis only accessible to the shell user (permissions 0700), app processes cannot\nsee its contents.\nExternal Storage Permissions\nIn order to emulate the FAT filesystem that was originally used for external\nstorage, the sdcard FUSE daemon assigns fixed owner, group, and access per-\nmissions to each file or directory on external storage. Additionally, permis-\nsions are not changeable, and symlinks and hardlinks are not supported. The\nassigned owner and permission are determined by the permission derivation\nmode that the sdcard daemon uses.\nIn legacy mode (specified with the -l option), which is backward-\ncompatible with previous Android versions and which is still the default in\nAndroid 4.4, most files and directories are owned by the root user and their\ngroup is set to sdcard_r. Applications that are granted the READ_EXTERNAL_STORAGE\npermission have sdcard_r as one of their supplementary groups, and thus\ncan read most files on external storage even if they were originally created\nby a different application. Listing 4-17 shows the owner and permission of\nfiles and directories in the root of external storage.\n# ls -l /sdcard/\ndrwxrwx--- root sdcard_r Alarms\ndrwxrwx--x root sdcard_r Android\ndrwxrwx--- root sdcard_r DCIM\n--snip--\n-rw-rw---- root sdcard_r 5 text.txt\nListing 4-17: Owner and permissions of files on external storage\nIn previous versions of Android, all files and directories on external stor-\nage were assigned the same owner and permissions, but Android 4.4 treats the\napplication-specific external files directory (Android/data/<package-name>/, the\nexact path is returned by the Context.getExternalFilesDir() method) differ-\nently. Applications don’t have to hold the WRITE_EXTERNAL_STORAGE permission\nin order to read and write files in this directory because it is owned by the\ncreating application.\nThat said, even in Android 4.4, the application’s external files direc-\ntory is accessible by any application that holds the READ_EXTERNAL_STORAGE or\nWRITE_EXTERNAL_STORAGE permissions because the group of the directory is set\nto sdcard_r, as shown in Listing 4-18.\n$ ls -l Android/data/\ndrwxrwx--- u10_a16 sdcard_r com.android.browser\nListing 4-18: Owner and permissions of an app’s external files directory\nUser Management 111\nAndroid 4.4 supports a more flexible permission derivation mode\nthat is based on directory structure, and which is specified by passing\nthe -d option to the sdcard daemon. This derivation mode sets dedi-\ncated groups to the directories Pictures/ and Music/ (sdcard_pics u and\nsdcard_av v, as shown in Listing 4-19), which allows for fine-grained con-\ntrol over which files applications can access. As of this writing, Android\ndoesn’t support such fine-grained access control, but it can easily be imple-\nmented by defining additional permissions that map to the sdcard_pics and\nsdcard_av groups. In the directory-structure-based permission mode, user\ndirectories are hosted under Android/user/ w.\nNOTE While this new permission derivation mode is supported in Android 4.4, as of this\nwriting, Nexus devices still use the legacy permission mode.\nrwxrwx--x root:sdcard_rw /\nrwxrwx--- root:sdcard_pics /Picturesu\nrwxrwx--- root:sdcard_av /Musicv\nrwxrwx--x root:sdcard_rw /Android\nrwxrwx--x root:sdcard_rw /Android/data\nrwxrwx--- u0_a12:sdcard_rw /Android/data/com.example.app\nrwxrwx--x root:sdcard_rw /Android/obb/\nrwxrwx--- u0_a12:sdcard_rw /Android/obb/com.example.app\nrwxrwx--- root:sdcard_all /Android/userw\nrwxrwx--x root:sdcard_rw /Android/user/10\nrwxrwx--- u10_a12:sdcard_rw /Android/user/10/Android/data/com.example.app\nListing 4-19: Directory owners and permission in the new permission derivation mode\nOther multi-User Features\nBesides dedicated app directories, external storage and settings, other\nAndroid features also support a multi-user device configuration. For\nexample, as of version 4.4, Android’s credential storage (which allows\nfor secure management of cryptographic keys) lets each user have their own\nkey storage. (We discuss credential storage in more detail in Chapter 7.)\nIn addition, Android’s online account database, accessible via the\nAccountManager API, has been extended to allow secondary users to have their\nown accounts, as well as to allow restricted profiles to share some of the pri-\nmary user’s accounts (if the app that needs account access supports it). We\ndiscuss online account support and the AccountManager API in Chapter 8.\nAnd finally, Android allows setting different device administration\npolicies for each user. As of version 4.4, it also supports setting up per-user\nVPNs that only route a single user’s traffic and which are not accessible by\nother users. (We discuss device administration, VPNs, and other enterprise\nfeatures in Chapter 9.)\n112 Chapter 4\nsummary\nAndroid allows multiple users to share a device by providing dedicated\ninternal and external storage to each user. Multi-user support follows the\nestablished security model and each user’s applications are assigned a\nunique UID and run in dedicated processes that cannot access other user’s\ndata. User isolation is achieved by combining a UID assignment scheme\nthat takes into account the user ID and storage mounting rules that allow\neach user to only see their own storage.\nAs of this writing, multi-user support is only available on devices with-\nout telephony support (usually tablets), as the behavior of telephony in a\nmulti-user environment is currently undefined. Most Android features,\nincluding account database management, credential storage, device poli-\ncies, and VPN support are multi-user-aware and allow each user to have\ntheir own configuration.\nUser Management 113",
    "question": "How does Android manage users who share devices and data, including the types of users, user isolation, and the handling of application data and external storage?",
    "summary": "Android allows multiple users to share a device by providing isolated environments for each user, including dedicated storage and application data. The system manages users through a unique user ID and isolates application data to ensure privacy. Multi-user support is available on non-telephony devices like tablets, with each user having their own settings and data. The system uses a combination of UID assignments and storage mounting rules to maintain user isolation and ensure that each user can only access their own data."
  },
  {
    "start": 75,
    "end": 95,
    "text": "5\nCRYPTOGR aPhIC PROvIDERs\nThis chapter introduces Android’s cryptographic\nprovider architecture and discusses the built-in pro-\nviders and the algorithms they support. Because\nAndroid builds on the Java Cryptography Architecture\n( JCA), we introduce its design in brief, starting with\nthe cryptographic service provider (CSP) framework. We then discuss the main\nJCA classes and interfaces, and the cryptographic primitives they imple-\nment. (We will briefly introduce each cryptographic primitive, but a thor-\nough discussion is beyond the scope of this book and some familiarity with\nbasic cryptography is assumed.) Next, we present Android’s JCA providers\nand cryptographic libraries as well as the algorithms each provider sup-\nports. Finally, we show how to use additional cryptography algorithms by\ninstalling a custom JCA provider.\nJCa Provider architecture\nJCA provides an extensible cryptographic provider framework and a set\nof APIs covering the major cryptographic primitives in use today (block\nciphers, message digests, digital signatures, and so on). This architecture\naims to be implementation-independent and extensible. Applications that\nuse the standard JCA APIs only need to specify the cryptographic algo-\nrithm they want to use and (in most cases) do not depend on a particular\nprovider implementation. Support for new cryptographic algorithms can\nbe added by simply registering an additional provider that implements the\nrequired algorithms. Additionally, cryptographic services offered by differ-\nent providers are generally interoperable (with certain restrictions when\nkeys are hardware-protected or key material is otherwise not directly avail-\nable) and applications are free to mix and match services from different\nproviders as needed. Let’s look at JCA’s architecture in more detail.\nCryptographic Service Providers\nJCA splits cryptographic functionality into a number of abstract crypto-\ngraphic services called engines and defines APIs for each service in the\nform of an engine class. For example, digital signatures are represented by\nthe Signature engine class, and encryption is modeled with the Cipher class.\n(You’ll find a comprehensive list of engine classes in the next section.)\nIn the context of JCA, a cryptographic service provider (CSP, or simply\nprovider) is a package (or set of packages) that provides a concrete imple-\nmentation of certain cryptographic services. Each provider advertises\nthe services and algorithms it implements, allowing the JCA framework\nto maintain a registry of supported algorithms and their implementing\nproviders. This registry maintains a preference order for providers, so if a\ncertain algorithm is offered by more than one provider, the one with higher\npreference order is returned to the requesting application. An exception\nto this rule is made for engine classes that support delayed provider selection\n(Cipher, KeyAgreement, Mac, and Signature). With delayed provider selection,\nthe provider is selected not when an instance of the engine class is created,\nbut when the engine class is initialized for a particular cryptographic oper-\nation. Initialization requires a Key instance, which the system uses to find a\nprovider that can accept the specified Key object. Delayed provider selection\nis helpful when using keys that are stored in hardware because the system\ncannot find the hardware-backed provider based on the algorithm name\nalone. However, concrete Key instances passed to initialization methods usu-\nally have enough information to determine the underlying provider.\nNOTE Current Android versions don’t support delayed provider selection, but some related\nwork is being done in the master branch, and delayed provider selection will likely be\nsupported in a future version.\nLet’s look at an example using the provider configuration illustrated in\nFigure 5-1.\n116 Chapter 5\n1 ProviderA\nMessageDigest.\ngetInstance(\"SHA-256\") NG SHA-1\nSHA-384\nProvider\nApplication\nFramework 2 ProviderB\nProvider B\nOK SHA-256\nSHA-256 implementation\nSHA-512\n3 ProviderC\nSHA-1\nSHA-256\nFigure 5-1: JCA algorithm implementation selection when provider is not specified\nIf an application requests an implementation of the SHA-256 digest\nalgorithm without specifying a provider (as shown in Listing 5-1), the pro-\nvider framework returns the implementation found in ProviderB (number 2\nin the list in Figure 5-1), not the one in ProviderC, which also supports SHA-\n256, but which is number 3 in the list in Figure 5-1.\nMessageDigest md = MessageDigest.getInstance(\"SHA-256\");\nListing 5-1: Requesting a SHA-256 implementation without specifying a provider\nOn the other hand, if the application specifically requests ProviderC\n(as shown in Listing 5-2), its implementation will be returned even though\nProviderB has a higher preference order.\nMessageDigest md = MessageDigest.getInstance(\"SHA-256\", \"ProviderC\");\nListing 5-2: Requesting a SHA-256 implementation from a specific provider\nGenerally, applications should not explicitly request a provider unless\nthey include the requested provider as part of the application or can handle\nfallback if the preferred provider is not available.\nProvider Implementation\nThe JCA framework guarantees implementation independence by requir-\ning all implementations of a particular cryptographic service or algorithm\nto conform to a common interface. For each engine class that represents a\nparticular cryptographic service, the framework defines a corresponding\nabstract Service Provider Interface (SPI) class. Providers that offer a particular\ncryptographic service implement and advertise the corresponding SPI class.\nFor example, a provider that implements a given encryption algorithm\nwould have an implementation of the CipherSpi class that corresponds to\nthe Cipher engine class. When an application calls the Cipher.getInstance()\nfactory method, the JCA framework finds the appropriate provider by using\nthe process outlined in “Cryptographic Service Providers” on page 116 and\nreturns a Cipher instance that routes all of its method calls to the CipherSpi\nsubclass implemented in the selected provider.\nCryptographic Providers 117\nIn addition to SPI implementation classes, each provider has a subclass of\nthe abstract java.security.Provider class that defines the name and version\nof the provider and, more importantly, a list of the supported algorithms\nand matching SPI implementation classes. The JCA provider framework\nuses this Provider class to build the provider registry, and queries it when\nsearching for algorithm implementations to return to its clients.\nStatic Provider Registration\nIn order for a provider to be visible to the JCA framework, it must be regis-\ntered first. There are two ways to register a provider: statically and dynami-\ncally. Static registration requires editing the system security properties file\nand adding an entry for the provider. (On Android, this properties file is\ncalled security.properties and is only present inside the core.jar system library.\nTherefore, it cannot be edited and static provider registration is not sup-\nported. We describe it here only for completeness.)\nA provider entry in the security properties file is formatted as shown in\nListing 5-3.\nsecurity.provider.n=ProviderClassName\nListing 5-3: Static registration of a JCA provider\nHere, n is the provider’s preference order that is used when search-\ning for requested algorithms (when no provider name is specified). The\norder is 1-based; that is, 1 is the most preferred, followed by 2, and so on.\nProviderClassName is the name of the java.security.Provider class implementa-\ntion described in “Provider Implementation” on page 117.\nDynamic Provider Registration\nProviders are registered dynamically (at runtime) with the addProvider()\nand insertProviderAt() methods of the java.security.Security class. These\nmethods return the actual position in which the provider was added, or −1\nif the provider was not added because it was already installed. Providers can\nalso be removed dynamically by calling the removeProvider() method.\nThe Security class manages the list of security Providers and effectively\nacts as the provider registry described in the previous sections. In Java SE,\nprograms require special permissions in order to register providers and\nmodify the provider registry because by inserting a new provider at the top\nof the provider list, they can effectively replace the system security imple-\nmentation. In Android, modifications to the provider registry are limited to\nthe current app process and cannot affect the system or other applications.\nTherefore, no special permissions are required in order to register a JCA\nprovider.\nDynamic modifications to the provider registry are typically placed in\na static block to ensure that they are executed before any application code.\nListing 5-4 shows an example of replacing the default (top priority) pro-\nvider with a custom one.\n118 Chapter 5\nstatic {\nSecurity.insertProviderAt(new MyProvider(), 1);\n}\nListing 5-4: Dynamically inserting a custom JCA provider\nNOTE If the class is loaded more than once (for example, by different class loaders), the static\nblock may be executed multiple times. You can work around this by checking whether\nthe provider is already available or by using a holder class that is loaded only once.\nJCa Engine Classes\nAn engine class provides the interface to a specific type of cryptographic\nservice. JCA engines provide one of the following services:\n• Cryptographic operations (encrypt/decrypt, sign/verify, hash, and so on)\n• Generation or conversion of cryptographic material (keys and algo-\nrithm parameters)\n• Management and storage of cryptographic objects, such as keys and\ndigital certificates\nObtaining an Engine Class Instance\nIn addition to providing a unified interface to cryptographic operations,\nengine classes decouple client code from the underlying implementation,\nwhich is why they cannot be instantiated directly; instead, they provide a\nstatic factory method called getInstance() that lets you request an implemen-\ntation indirectly. The getInstance() method typically has one of the signa-\ntures shown in Listing 5-5.\nstatic EngineClassName getInstance(String algorithm)u\nthrows NoSuchAlgorithmException\nstatic EngineClassName getInstance(String algorithm, String provider)v\nthrows NoSuchAlgorithmException, NoSuchProviderException\nstatic EngineClassName getInstance(String algorithm, Provider provider)w\nthrows NoSuchAlgorithmException\nListing 5-5: JCA engine class factory method signatures\nUsually, you would use the signature at u and specify only the algorithm\nname. The signatures at v and w allow you to request an implementa-\ntion from a specific provider. All variants throw a NoSuchAlgorithmException\nif an implementation for the requested algorithm is not available and v\nthrows NoSuchProviderException if a provider with the specified name is not\nregistered.\nCryptographic Providers 119\nAlgorithm Names\nThe string algorithm parameter that all factory methods take maps to a\nparticular cryptographic algorithm or transformation, or specifies an\nimplementation strategy for higher-level objects that manage collections\nof certificates or keys. Usually, the mapping is straightforward. For example,\nSHA-256 maps to an implementation of the SHA-256 hashing algorithm\nand AES requests an implementation of the AES encryption algorithm.\nHowever, some algorithm names have structure and specify more than one\nparameter of the requested implementation. For example, SHA256withRSA\nspecifies a signature implementation that uses SHA-256 for hashing the\nsigned message and RSA to perform the signature operation. Algorithms\ncan also have aliases, and more than one algorithm name can map to the\nsame implementation.\nAlgorithm names are case-insensitive. The standard algorithm names\nsupported by each JCA engine class are defined in the JCA Standard Algorithm\nName Documentation (sometimes referred to as just Standard Names).1 In addi-\ntion to those, providers can define their own algorithm names and aliases.\n(See each provider’s documentation for details.) You can use the code in\nListing 5-6 to list all providers, the algorithm names of cryptographic ser-\nvices offered by each provider, and the implementation classes they map to.\nProvider[] providers = Security.getProviders();\nfor (Provider p : providers) {\nSystem.out.printf(\"%s/%s/%f\\n\", p.getName(), p.getInfo(), p.getVersion());\nSet<Service> services = p.getServices();\nfor (Service s : services) {\nSystem.out.printf(\"\\t%s/%s/%s\\n\", s.getType(),\ns.getAlgorithm(), s.getClassName());\n}\n}\nListing 5-6: Listing all JCA providers and the algorithms they support\nWe will show the format for the algorithm name of major engine classes\nas we introduce them in the following sections.\nSecureRandom\nThe SecureRandom class represents a cryptographic Random Number Generator\n(RNG). While you may not directly use it too often, it is used internally by\nmost cryptographic operations to generate keys and other cryptographic\nmaterial. The typical software implementation is usually a Cryptographically\nSecure Pseudo Random Number Generator (CSPRNG), which produces a sequence\nof numbers that approximate the properties of true random numbers based\non an initial value called a seed. As the quality of random numbers produced\n1. Oracle, Java™ Cryptography Architecture Standard Algorithm Name Documentation, http://docs\n.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html\n120 Chapter 5\nby a CSPRNG largely depends on its seed, it is chosen carefully, usually based\non the output of a true RNG.\nOn Android, CSPRNG implementations are seeded by reading seed\nbytes from the standard Linux /dev/urandom device file, which is an inter-\nface to the kernel CSPRNG. As the kernel CSPRNG itself may be in a\nfairly predictable state right after starting, Android periodically saves the\nstate (which is 4096 bytes as of Android 4.4) of the kernel CSPRNG to\nthe /data/system/entropy.dat file. The contents of that file are written back\nto /dev/urandom on boot in order to carry over the previous CSPRNG\nstate. This is performed by the EntropyMixer system service.\nUnlike most engine classes, SecureRandom has public constructors that\nyou can use to create an instance. The recommended way to get a properly\nseeded instance on Android is to use the default (no argument) constructor\n(u in Listing 5-7). If you use the getInstance() factory method, you need to\npass SHA1PRNG as the algorithm name, which is the only universally sup-\nported algorithm name for SecureRandom. Because SHA1PRNG is not exactly\na cryptographic standard, implementations from different providers might\nbehave differently. To have SecureRandom generate random bytes, you pass\na byte array to its nextBytes() method (v in Listing 5-7). It will generate as\nmany bytes as the array length (16 in Listing 5-7) and store them in it.\nSecureRandom sr = new SecureRandom();u\nbyte[] output = new byte[16];\nsr.nextBytes(output);v\nListing 5-7: Using SecureRandom to generate random bytes\nSeeding SecureRandom manually is not recommended because seeding\nthe system CSPRNG improperly may result in it producing a predictable\nsequence of bytes, which could compromise any higher-level operations that\nrequire random input. However, if you need to manually seed SecureRandom\nfor some reason (for example, if the default system seeding implementation\nis known to be flawed), you can do so by using the SecureRandom(byte[] seed)\nconstructor or by calling the setSeed() method. When seeding manually,\nmake sure that the seed you are using is sufficiently random; for example,\nby reading it from /dev/urandom.\nAdditionally, depending on the underlying implementation, calling\nsetSeed() may not replace, but instead only add to the internal CSPRNG\nstate; so two SecureRandom instances seeded with the same seed value may not\nproduce the same number sequence. Therefore, SecureRandom should not be\nused when deterministic values are required. Instead, use a cryptographic\nprimitive that is designed to produce deterministic output from a given\ninput, such as a hash algorithm or a key derivation function.\nMessageDigest\nThe MessageDigest class represents the functionality of a cryptographic mes-\nsage digest, also referred to as a hash function. A cryptographic message\ndigest takes an arbitrarily long sequence of bytes and generates a fixed-size\nCryptographic Providers 121\nbyte sequence called a digest or hash. A good hash function guarantees that\neven a small change in its input results in completely different output and\nthat it is very difficult to find two inputs that are different but produce the\nsame hash value (collision resistance), or generate an input that has a given\nhash (pre-image resistance). Another important property of hash functions\nis second pre-image resistance. In order to withstand second pre-image\nattacks, a hash function should make it difficult to find a second input m\n2\nthat hashes to the same value as a given input m .\n1\nListing 5-8 shows how to use the MessageDigest class.\nMessageDigest md = MessageDigest.getInstance(\"SHA-256\");u\nbyte[] data = getMessage();\nbyte[] digest = md.digest(data);v\nListing 5-8: Using MessageDigest to hash data\nA MessageDigest instance is created by passing the hash algorithm name\nto the getInstance() factory method u. Input may be provided in chunks\nby using one of the update() methods, and then calling one of the digest()\nmethods to get the calculated hash value. Alternatively, if the input data\nsize is fixed and relatively short, it can be hashed in one step by using the\ndigest(byte[] input) method v, as shown in Listing 5-8.\nSignature\nThe Signature class provides a common interface for digital signature algo-\nrithms based on asymmetric encryption. A digital signature algorithm takes\nan arbitrary message and a private key and produces a fixed-sized byte string\ncalled a signature. Digital signatures typically apply a digest algorithm to the\ninput message, encode the calculated hash value, and then use a private\nkey operation to produce the signature. The signature can then be verified\nusing the corresponding public key by applying the reverse operation, cal-\nculating the hash value of the signed message, and comparing it to the one\nencoded in the signature. Successful verification guarantees the integrity of\nthe signed message and, on the condition that the signing private key has\nremained indeed private, its authenticity.\nSignature instances are created with the standard getInstance() factory\nmethod. The algorithm name used is generally in the form <digest>with\n<encryption>, where <digest> is a hash algorithm name as used by MessageDigest\n(such as SHA256), and <encryption> is an asymmetric encryption algorithm\n(such as RSA or DSA). For example, a SHA512withRSA Signature would first\nuse the SHA-512 hash algorithm to produce a digest value and then encrypt\nthe encoded digest with an RSA private key to produce the signature. For\nsignature algorithms that use a mask generation function such as RSA-PSS,\nthe algorithm name takes the form <digest>with<encryption>and<mgf> (for\nexample, SHA256withRSAandMGF1).\nListing 5-9 shows how to use the Signature class to generate and verify a\ncryptographic signature.\n122 Chapter 5\nPrivateKey privKey = getPrivateKey();\nPublicKey pubKey = getPublicKey();\nbyte[] data = \"sign me\".getBytes(\"ASCII\");\nSignature sig = Signature.getInstance(\"SHA256withRSA\");\nsig.initSign(privKey);u\nsig.update(data);v\nbyte[] signature = sig.sign();w\nsig.initVerify(pubKey);x\nsig.update(data);\nboolean valid = sig.verify(signature);y\nListing 5-9: Generating and verifying a signature with the Signature class\nAfter obtaining an instance, the Signature object is initialized for either\nsigning, by passing a private key to the initSign() method (u in Listing 5-9),\nor verification, by passing a public key or certificate to the initVerify()\nmethod x for verification.\nSigning is similar to calculating a hash with MessageDigest: the data to be\nsigned is fed in chunks to one of the update() methods v or in bulk to the\nsign() method w, which returns the signature value. To verify a signature,\nthe signed data is passed to one of the update() methods. Finally, the signa-\nture is passed to the verify() method y, which returns true if the signature\nis valid.\nCipher\nThe Cipher class provides a common interface to encryption and decryption\noperations. Encryption is the process of using some algorithm (called a\ncipher) and a key to transform data (called plaintext, or plaintext message) into\na randomly looking form (called ciphertext). The inverse operation, called\ndecryption, transforms the ciphertext back into the original plaintext.\nThe two major types of encryption widely used today are symmetric\nencryption and asymmetric encryption. Symmetric, or secret key, encryption uses\nthe same key to encrypt and decrypt data. Asymmetric encryption uses a\npair of keys: a public key and a private key. Data encrypted with one of the\nkeys can only be decrypted with the other key of the pair. The Cipher class\nsupports both symmetric and asymmetric encryption.\nDepending on how they process input, ciphers can be block or stream.\nBlock ciphers work on fixed-sized chunks of data called blocks. If the input\ncannot be divided into an integral number of blocks, the last block is pad-\nded by adding the necessary number of bytes to match the block size. Both\nthe operation and the added bytes are called padding. Padding is removed\nin the decryption process and is not included in the decrypted plaintext. If\na padding algorithm is specified, the Cipher class can add and remove pad-\nding automatically. On the other hand, stream ciphers process input data\none byte (or even bit) at a time and do not require padding.\nCryptographic Providers 123\nBlock Cipher Modes of Operation\nBlock ciphers employ different strategies when processing input blocks in\norder to produce the final ciphertext (or plaintext when decrypting). Those\nstrategies are called modes of operation, cipher modes, or simply modes. The sim-\nplest processing strategy is to split the plaintext into blocks (padding as nec-\nessary), apply the cipher to each block, and then concatenate the encrypted\nblocks to produce the ciphertext. This mode is called Electronic Code Book\n(ECB) mode, and while it’s straightforward and easy to use, it has the major\ndisadvantage that identical plaintext blocks produce identical ciphertext\nblocks. Thus, plaintext structure is reflected in the ciphertext, which com-\npromises message confidentiality and facilitates cryptanalysis. This has often\nbeen illustrated with the infamous “ECB Penguin” from the Wikipedia entry\non block cipher modes.2 We present our Android version in Figure 5-2.3 Here,\nu is the original image, v is the image encrypted in ECB mode, and w is the\nsame image encrypted in CBC mode. As you can see, the pattern of the origi-\nnal image is distinguishable in v, while w looks like random noise.\nu v w\nFigure 5-2: Ciphertext patterns produced by different cipher modes\nFeedback modes add randomness to the ciphertext by combining the pre-\nvious encrypted block with the current plaintext block before encrypting.\nIn order to produce the first cipher block, they combine the first plaintext\nblock with a block-sized string of bytes not found in the original plain text,\ncalled an initialization vector (IV). When configured to use a feedback mode,\nthe Cipher class can use a client-specified IV or generate one automatically.\nCommonly used feedback modes are Cipher-block chaining (CBC), Cipher feed-\nback (CFB), and Output feedback (OFB).\nAnother way to add randomness to the ciphertext, employed by\nthe Counter (CTR) mode, is to encrypt the successive values of a counter\nsequence in order to produce a new key for each plaintext block that needs\nto be encrypted. This effectively turns the underlying block cipher into a\nstream cipher and no padding is required.\n2. Wikipedia, “Block cipher mode of operation,” https://en.wikipedia.org/wiki/\nBlock_cipher_mode_of_operation\n3. The Android robot is reproduced or modified from work created and shared by Google\nand used according to terms described in the Creative Commons 3.0 Attribution License.\n124 Chapter 5\nNewer cipher modes, such as Galois/Counter Mode (GCM), not only dif-\nfuse patterns in the original plaintext but also authenticate the ciphertext,\nmaking sure it has not been tampered with. They provide authenticated\nencryption (AE) or Authenticated Encryption with Associated Data (AEAD).4 The\nCipher APIs have been extended to support authenticated encryption in Java\nSE 7, and those extensions have been available since Android 4.4, which\nhas a Java 7–compatible runtime library API. AE ciphers concatenate the\nauthentication tag output by the encryption operation to the ciphertext\nthat operation produces in order to form their final output. In the Java\nCipher API, the tag is included (or verified, when decrypting) implicitly\nafter calling doFinal(), so you should not use the output of update() until\nyou’re sure the implicit tag at the end validates.\nObtaining a Cipher Instance\nHaving reviewed the major parameters of a cipher, we can finally discuss\nhow to create Cipher instances. Like the other engine classes, Cipher objects\nare created with the getInstance() factory method, which requires not just a\nsimple algorithm name, but that you fully specify the cryptographic transfor-\nmation that the requested cipher will perform.\nListing 5-10 shows how to create a Cipher instance by passing a transfor-\nmation string to getInstance().\nCipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nListing 5-10: Creating a Cipher instance\nA transformation needs to specify the encryption algorithm, cipher\nmode, and padding. The transformation string passed to getInstance() is in\nthe algorithm/mode/padding format. For example, the transformation string\nused in Listing 5-10 would create a Cipher instance that uses AES as the\nencryption algorithm, CBC as the cipher mode, and PKCS#5 padding.\nNOTE The term PKCS will appear quite a few times in our discussion of JCA providers and\nengine classes. The acronym stands for Public Key Cryptography Standard\nand refers to a group of cryptography standards that were originally developed and\npublished by RSA Security, Inc. in the early 1990s. Most have evolved into public\nInternet standard and are now published and maintained as RFCs (Requests for\nComments, formal documents describing Internet standards), but they are still referred\nto by their original name. Notable standards include PKCS#1, which defines the basic\nalgorithms for RSA encryption and signatures; PKCS#5, which defines password-\nbased encryption; PKCS#7, which defines message encryption and signing under a\nPKI and became the basis of S/MIME; and PKCS#12, which defines a container for\nkeys and certificates. A full list can be found on EMC’s website.5\n4. D. McGrew, RFC 5116 – An Interface and Algorithms for Authenticated Encryption, http://www.ietf\n.org/rfc/rfc5116.txt\n5. RSA Laboratories, Public-Key Cryptography Standards (PKCS), http://www.emc.com/emc-plus/\nrsa-labs/standards-initiatives/public-key-cryptography-standards.htm\nCryptographic Providers 125\nA Cipher instance can be created by passing only the algorithm name,\nbut in that case the returned implementation would use provider-specific\ndefaults for the cipher mode and padding. This is not only not portable\nacross providers, but could severely impact the security of the system if, for\nexample, a less-secure-than-intended cipher mode (such as ECB) is used at\nruntime. This “shortcut” is a major design flaw of the JCA provider frame-\nwork and should never be used.\nUsing a Cipher\nOnce a Cipher instance has been obtained, it needs to be initialized before\nencrypting or decrypting data. A Cipher is initialized by passing an inte-\nger constant that denotes the operation mode (ENCRYPT_MODE, DECRYPT_MODE,\nWRAP_MODE, or UNWRAP_MODE), a key or certificate, and, optionally, algorithm\nparameters, to one of the corresponding init() methods. ENCRYPT_MODE and\nDECRYPT_MODE are used to encrypt and decrypt arbitrary data, while WRAP_MODE\nand UNWRAP_MODE are specialized modes used when encrypting (wrapping) and\ndecrypting (unwrapping) the key material of a Key object with another key.\nListing 5-11 shows how to use the Cipher class to encrypt and decrypt data.\nSecureRandom sr = new SecureRandom();\nSecretKey key = getSecretKey();\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");u\nbyte[] iv = new byte[cipher.getBlockSize()];\nsr.nextBytes(iv);\nIvParameterSpec ivParams = new IvParameterSpec(iv);v\ncipher.init(Cipher.ENCRYPT_MODE, key, ivParams);w\nbyte[] plaintext = \"encrypt me\".getBytes(\"UTF-8\");\nByteArrayOutputStream baos = new ByteArrayOutputStream();\nbyte[] output = cipher.update(plaintext);x\nif (output != null) {\nbaos.write(output);\n}\noutput = cipher.doFinal();y\nbaos.write(output);\nbyte[] ciphertext = baos.toByteArray();\ncipher.init(Cipher.DECRYPT_MODE, key, ivParams);z\nbaos = new ByteArrayOutputStream();\noutput = cipher.update(ciphertext);{\nif (output != null) {\nbaos.write(output);\n}\noutput = cipher.doFinal();|\nbaos.write(output);\nbyte[] decryptedPlaintext = baos.toByteArray();}\nListing 5-11: Using the Cipher class to encrypt and decrypt data\n126 Chapter 5\nIn this example, we create a Cipher instance that uses AES in CBC\nmode and PKCS#5 padding u; generate a random IV and wrap it into an\nIvParameterSpec object v; and then initialize the Cipher for encryption by\npassing ENCRYPT_MODE, the encryption key, and the IV to the init() method w.\nWe can then encrypt data by passing data chunks to the update() method x,\nwhich returns intermediate results (or null if the input data is too short\nto result in a new block), and obtain the last block by calling the doFinal()\nmethod y. The final ciphertext is obtained by concatenating the intermedi-\nate result(s) with the final block.\nTo decrypt, we initialize the cipher in DECRYPT_MODE z, passing the same\nkey and the IV used for encryption. We then call update() {, this time using\nthe ciphertext as input, and finally call doFinal() | to obtain the last chunk\nof plaintext. The final plaintext is obtained by concatenating the intermedi-\nate result(s) with the final chunk }.\nMac\nThe Mac class provides a common interface to Message Authentication Code\n(MAC) algorithms. A MAC is used to check the integrity of messages trans-\nmitted over an unreliable channel. MAC algorithms use a secret key to\ncalculate a value, the MAC (also called a tag), which can be used to authen-\nticate the message and check its integrity. The same key is used to perform\nverification, so it needs to be shared between the communicating parties.\n(A MAC is often combined with a cipher to provide both confidentiality and\nintegrity.)\nKeyGenerator keygen = KeyGenerator.getInstance(\"HmacSha256\");\nSecretKey key = keygen.generateKey();\nMac mac = Mac.getInstance(\"HmacSha256\");u\nmac.init(key);v\nbyte[] message = \"MAC me\".getBytes(\"UTF-8\");\nbyte[] tag = mac.doFinal(message);w\nListing 5-12: Using the Mac class to generate a message authentication code\nA Mac instance is obtained with the getInstance() factory method u\n(as shown in Listing 5-12) by requesting an implementation of the HMAC6\nMAC algorithm that uses SHA-256 as the hash function. It is then initial-\nized v with a SecretKey instance, which may be generated with a KeyGenerator\n(see “KeyGenerator” on page 131), derived from a password or directly\ninstantiated from raw key bytes. For MAC implementations based on hash\nfunctions (such as HMAC SHA-256 in this example), the type of key does\nnot matter, but implementations that use a symmetric cipher may require\na matching key type to be passed. We can then pass the message in chunks\nusing one of the update() methods and call doFinal() to obtain the final\nMAC value, or perform the operation in one step by passing the message\nbytes directly to doFinal() w.\n6. H. Krawczyk, M. Bellare, and R. Canetti, HMAC: Keyed-Hashing for Message Authentication,\nhttp://tools.ietf.org/html/rfc2104\nCryptographic Providers 127\nKey\nThe Key interface represents opaque keys in the JCA framework. Opaque\nkeys can be used in cryptographic operations, but usually do not provide\naccess to the underlying key material (raw key bytes). This allows us to use\nthe same JCA classes and interfaces both with software implementations\nof cryptographic algorithms that store key material on memory, and with\nhardware-backed ones, where the key material may reside in a hardware\ntoken (smart card, HSM,7 and so on) and is not directly accessible.\nThe Key interface defines only three methods:\nString getAlgorithm() Returns the name of the encryption algorithm\n(symmetric or asymmetric) that this key can be used with. Examples\nare AES or RSA.\nbyte[] getEncoded() Returns a standard encoded form of the key that\ncan be used when transmitting the key to other systems. This can be\nencrypted for private keys. For hardware-backed implementations that\ndo not allow exporting key material, this method typically returns null.\nString getFormat() Returns the format of the encoded key. This is usu-\nally RAW for keys that are not encoded in any particular format. Other\nformats defined in JCA are X.509 and PKCS#8.\nYou can obtain a Key instance in the following ways:\n• Generate keys using a KeyGenerator or a KeyPairGenerator.\n• Convert from some encoded representation using a KeyFactory.\n• Retrieve a stored key from a KeyStore.\nWe discuss different Key types and how they are created and accessed in\nthe next sections.\nSecretKey and PBEKey\nThe SecretKey interface represents keys used in symmetric algorithms. It is\na marker interface and does not add any methods to those of the parent Key\ninterface. It has only one implementation that can be directly instantiated,\nnamely SecretKeySpec. It is both a key implementation and a key specifica-\ntion (as discussed in the “KeySpec” section that follows) and allows you to\ninstantiate SecretKey instances based on the raw key material.\nThe PBEKey subinterface represents keys derived using Password Based\nEncryption (PBE).8 PBE defines algorithms that derive strong cryptographic\nkeys from passwords and passphrases, which typically have low entropy and\nthus cannot be used directly as keys. PBE is based on two main ideas: using a\nsalt to protect from table-assisted (pre-computed) dictionary attacks (salting),\nand using a large iteration count to make the key derivation computationally\n7. Hardware Security Module\n8. B. Kaliski, PKCS #5: Password-Based Cryptography Specification, Version 2.0, http://www.ietf.org/rfc/\nrfc2898.txt\n128 Chapter 5\nexpensive (key stretching). The salt and iteration count are used as param-\neters to PBE algorithms and thus need to be retained in order to generate\nthe same key from a particular password. Thus PBEKey implementations\nare required to implement getSalt() and getIterationCount() along with\ngetPassword().\nPublicKey, PrivateKey, and KeyPair\nPublic and private keys for asymmetric encryption algorithms are modeled\nwith the PublicKey and PrivateKey interfaces. They are marker interfaces and\ndo not add any new methods. JCA defines specialized classes for concrete\nasymmetric algorithms that hold the parameters of the corresponding keys,\nsuch as RSAPublicKey and RSAPrivateCrtKey. The KeyPair interface is simply a\ncontainer for a public key and a private key.\nKeySpec\nAs discussed in “Key” on page 128, the JCA Key interface represents opaque\nkeys. On the other hand, KeySpec models a key specification, which is a transpar-\nent key representation that allows you to access individual key parameters.\nIn practice, most Key and KeySpec interfaces for concrete algorithms over-\nlap considerably because the key parameters need to be accessible in order\nto implement the encryption algorithms. For example, both RSAPrivateKey\nand RSAPrivateKeySpec define getModulus() and getPrivateExponent() methods.\nThe difference is only important when an algorithm is implemented in\nhardware, in which case the KeySpec will only contain a reference to the\nhardware-managed key and not the actual key parameters. The correspond-\ning Key will hold a handle to the hardware-managed key and can be used to\nperform cryptographic operations, but it will not hold any key material. For\nexample, an RSAPrivateKey that is stored in hardware will return null when\nits getPrivateExponent() method is called.\nKeySpec implementations can hold an encoded key representation, in which\ncase they are algorithm independent. For example, the PKCS8EncodedKeySpec can\nhold either an RSA key or a DSA key in DER-encoded PKCS#8 format.9 On the\nother hand, an algorithm-specific KeySpec holds all key parameters as fields. For\nexample, RSAPrivateKeySpec contains the modulus and private exponent for an\nRSA key, which can be obtained using the getModulus() and getPrivateExponent()\nmethods, respectively. Regardless of their type, KeySpecs are converted to Key\nobjects using a KeyFactory.\nKeyFactory\nA KeyFactory encapsulates a conversion routine needed to turn a transparent\npublic or private key representation (some KeySpec subclass) into an opaque10\n9. RSA Laboratories, PKCS #8: Private-Key Information Syntax Standard, http://www.emc.com/\nemc-plus/rsa-labs/standards-initiatives/pkcs-8-private-key-information-syntax-stand.htm\n10. Some Key subclasses, such as RSAPrivateKey, expose all key material and thus are not\ntechnically opaque.\nCryptographic Providers 129\nkey object (some Key subclass) that can be used to perform a cryptographic\noperation, or vice versa. A KeyFactory that converts an encoded key typically\nparses the encoded key data and stores each key parameter in the cor-\nresponding field of the concrete Key class. For example, to parse an X.509-\nencoded RSA public key, you can use the following code (see Listing 5-13).\nKeyFactory kf = KeyFactory.getInstance(\"RSA\");u\nbyte[] encodedKey = readRsaPublicKey();\nX509EncodedKeySpec keySpec = new X509EncodedKeySpec(encodedKey);v\nRSAPublicKey pubKey = (RSAPublicKey) kf.generatePublic(keySpec);w\nListing 5-13: Using a KeyFactory to convert an X.509 encoded key to an RSAPublicKey\nobject\nHere we create an RSA KeyFactory by passing RSA to KeyFactory\n.getInstance() u. We then read the encoded RSA key, use the encoded\nkey bytes to instantiate an X509EncodedKeySpec v, and finally pass the KeySpec\nto the factory’s generatePublic() method w in order to obtain an RSAPublicKey\ninstance.\nA KeyFactory can also convert an algorithm-specific KeySpec, such\nas RSAPrivateKeySpec, to a matching Key (RSAPrivateKey, in this example)\ninstance, but in that case it merely copies the key parameters (or key\nhandle) from one class to the other. Calling the KeyFactory.getKeySpec()\nmethod converts a Key object to a KeySpec, but this usage is not very common\nbecause an encoded key representation can be obtained simply by calling\ngetEncoded() directly on the key object, and algorithm-specific KeySpecs gen-\nerally do not provide any more information than a concrete Key class does.\nAnother feature of KeyFactory is converting a Key instance from a differ-\nent provider into a corresponding key object compatible with the current\nprovider. The operation is called key translation and is performed using the\ntranslateKey(Key key) method.\nSecretKeyFactory\nSecretKeyFactory is very similar to KeyFactory except that it only operates on\nsecret (symmetric) keys. You can use it to convert a symmetric key specifica-\ntion into a Key object and vice versa. In practice though, if you have access to\nthe key material of a symmetric key, it is much easier to use it to instantiate\ndirectly a SecretKeySpec that is also a Key, so it is not used very often in this\nfashion.\nA much more common use case is generating a symmetric key from a\nuser-supplied password using PBE (see Listing 5-14).\nbyte[] salt = generateSalt();\nint iterationCount = 1000;\nint keyLength = 256;\nKeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt,\niterationCount, keyLength);u\n130 Chapter 5\nSecretKeyFactory skf = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");v\nSecretKey key = skf.generateSecret(keySpec);w\nListing 5-14: Generating a secret key from a password using SecretKeyFactory\nIn this case, a PBEKeySpec is initialized with the password, a randomly\ngenerated salt, iteration count, and the desired key length u. A SecretKey fac-\ntory that implements a PBE key derivation algorithm (in this case, PBKDF2)\nis then obtained with a call to getInstance() v. Passing the PBEKeySpec to\ngenerateSecret() executes the key derivation algorithm and returns a SecretKey\ninstance w that can be used for encryption or decryption.\nKeyPairGenerator\nThe KeyPairGenerator class generates pairs of public and private keys. A\nKeyPairGenerator is instantiated by passing an asymmetric algorithm name\nto the getInstance() factory method (u in Listing 5-15).\nKeyPairGenerator kpg = KeyPairGenerator.getInstance(\"ECDH\");u\nECGenParameterSpec ecParamSpec = new ECGenParameterSpec(\"secp256r1\");v\nkpg.initialize(ecParamSpec);w\nKeyPair keyPair = kpg.generateKeyPair();x\nListing 5-15: Initializing KeyPairGenerator with algorithm-specific parameters\nThere are two ways to initialize a KeyPairGenerator: by specifying the\ndesired key size and by specifying algorithm-specific parameters. In both\ncases, you can optionally pass a SecureRandom instance to be used for key gen-\neration. If only a key size is specified, key generation will use default param-\neters (if any). To specify additional parameters, you must instantiate and\nconfigure an AlgorithmParameterSpec instance appropriate for the asymmetric\nalgorithm you are using and pass it to the initialize() method, as shown\nin Listing 5-15. In this example, the ECGenParameterSpec initialized in v is an\nAlgorithmParameterSpec that allows you to specify the curve name used when\ngenerating Elliptic Curve (EC) cryptography keys. After it is passed to the\ninitialize() method in w, the subsequent generateKeyPair() call in x will\nuse the specified curve (secp256r1) to generate the key pair.\nNOTE While named curves have been defined by various standards, the Oracle JCA specifi-\ncation does not explicitly define any elliptic curve names. As there is no official JCA\nstandard, curve names supported by Android may vary based on platform version.\nKeyGenerator\nThe KeyGenerator is very similar to the KeyPairGenerator class, except that it\ngenerates symmetric keys. While you can generate most symmetric keys\nby requesting a sequence of random bytes from SecureRandom, KeyGenerator\nimplementations perform additional checks for weak keys and set key\nCryptographic Providers 131\nparity bytes where appropriate (for DES and derived algorithms) and\ncan take advantage of available cryptography hardware, so it’s best to use\nKeyGenerator instead of generating keys manually.\nListing 5-16 shows how to generate an AES key using KeyGenerator.\nKeyGenerator keygen = KeyGenerator.getInstance(\"AES\");u\nkg.init(256);v\nSecretKey key = keygen.generateKey();w\nListing 5-16: Generating an AES key with KeyGenerator\nTo generate a key using KeyGenerator, create an instance u, specify the\ndesired key size with init() v, and then call generateKey() w to generate\nthe key.\nKeyAgreement\nThe KeyAgreement class represents a key agreement protocol that allows two or\nmore parties to generate a shared key without needing to exchange secret\ninformation. While there are different key agreement protocols, the ones\nmost widely used today are based on the Diffie-Hellman (DH) key exchange—\neither the original one based on discrete logarithm cryptography11 (simply\nknown as DH), or the newer variant based on elliptic key cryptography\n(ECDH 12).\nBoth variants of the protocol are modeled in JCA using the KeyAgreement\nclass and can be performed in the same way, with the only difference being\nthe keys. For both variants, each communicating party needs to have a key\npair, with both key pairs generated with the same key parameters (prime\nmodulus and base generator for DH, and typically the same well-defined\nnamed curve for ECDH). Then the parties only need to exchange public\nkeys and execute the key agreement algorithm to arrive at a common secret.\nListing 5-17 illustrates using the KeyAgreement class to generate a shared\nsecret using ECDH.\nPrivateKey myPrivKey = getPrivateKey();\nPublicKey remotePubKey = getRemotePubKey();\nKeyAgreement keyAgreement = KeyAgreement.getInstance(\"ECDH\");u\nkeyAgreement.init(myPrivKey);v\nkeyAgreement.doPhase(remotePubKey, true);w\nbyte[] secret = keyAgreement.generateSecret();x\nListing 5-17: Using KeyAgreement to generate a shared secret\nA KeyAgreement instance is first created by passing the algorithm name,\nECDH, to the getInstance() factory method u. Then the agreement\n11. RSA Laboratories, PKCS #3: Diffie-Hellman Key-Agreement Standard, ftp://ftp.rsasecurity.com/\npub/pkcs/ascii/pkcs-3.asc\n12. NIST, Recommendation for Pair-Wise Key Establishment Schemes Using Discrete Logarithm\nCryptography, http://csrc.nist.gov/publications/nistpubs/800-56A/SP800-56A_Revision1_Mar08\n-2007.pdf\n132 Chapter 5\nis initialized by passing the local private key to the init() method v.\nNext, the doPhase() method is called N – 1 times, where N is the number\nof communicating parties, passing each party’s public key as the first\nparameter, and setting the second parameter to true when executing the\nlast phase of the agreement w. (For two communicating parties, as in\nthis example, the doPhase() method needs to be called only once.) Finally,\ncalling the generateSecret() method x produces the shared secret.\nListing 5-17 shows the call flow for only one of the parties (A), but the\nother party (B) needs to execute the same sequence using its own private\nkey to initialize the agreement, and passing A’s public key to doPhase().\nNote that while the value (or part of it) returned by generateSecret() can\nbe used directly as a symmetric key, the preferred method is to use it as the\ninput for a key-derivation function (KDF) and use the output of the KDF as\nkey(s). Directly using the generated shared secret may lead to some loss of\nentropy, and doing so limits the number of keys that can be produced using\na single DH key agreement operation. On the other hand, using a KDF dif-\nfuses any structure that the secret may have (such as padding) and allows\nfor generating multiple derived keys by mixing in a salt.\nKeyAgreement has another generateSecret() method which takes an algo-\nrithm name as a parameter and returns a SecretKey instance that can be used\nto initialize a Cipher directly. If the KeyAgreement instance has been created\nwith an algorithm string that includes a KDF specification (for example,\nECDHwithSHA1KDF ), this method will apply the KDF to the shared secret\nbefore returning a SecretKey. If a KDF has not been specified, most implemen-\ntations simply truncate the shared secret in order to obtain key material for\nthe returned SecretKey.\nKeyStore\nJCA uses the term keystore to refer to a database of keys and certificates.\nA keystore manages multiple cryptographic objects, referred to as entries\nthat are each associated with a string alias. The KeyStore class offers a well-\ndefined interface to a keystore that defines three types of entries:\nPrivateKeyEntry A private key with an associated certificate chain. For a\nsoftware implementation, the private key material is usually encrypted\nand protected by a user-supplied passphrase.\nSecretKeyEntry A secret (symmetric) key. Not all KeyStore implementa-\ntions support storing secret keys.\nTrustedCertificateEntry A public key certificate of another party.\nTrustedCertificateEntrys often contain CA certificates that can be\nused to establish trust relationships. A keystore that contains only\nTrustedCertificateEntrys is called a truststore.\nKeyStore Types\nA KeyStore implementation does not need to be persistent, but most imple-\nmentations are. Different implementations are identified by a keystore type\nCryptographic Providers 133\nthat defines the storage and data format of the keystore, as well as the meth-\nods used to protect stored keys. The default KeyStore type is set with the\nkeystore.type system property.\nThe default KeyStore implementation of most JCA providers is usually\na keystore type that stores its data in a file. The file format may be proprie-\ntary or based on a public standard. Proprietary formats include the original\nJava SE JKS format and its security enhanced version JCEKS, as well as the\nBouncy Castle KeyStore (BKS) format, which is the default in Android.\nPKCS#12 File-Backed KeyStores\nThe most widely used public standard that allows for bundling private keys\nand associated certificates in a file is the Personal Information Exchange Syntax\nStandard, commonly referred to as PKCS#12. It is a successor of the Personal\nInformation Exchange Syntax (PFX) standard, so the terms PKCS#12 and PFX\nare used somewhat interchangeably, and PKCS#12 files are often called\nPFX files.\nPKCS#12 is a container format that can contain multiple embedded\nobjects, such as private keys, certificates, and even CRLs. Like the previ-\nous PKCS standards, which PKCS#12 builds upon, the container contents\nare defined in ASN.113 and are essentially a sequence of nested structures.\nThe internal container structures are called SafeBags, with different bags\ndefined for certificates (CertBag), private keys (KeyBag), and encrypted pri-\nvate keys (PKCS8ShroudedKeyBag).\nThe integrity of the whole file PFX\nis protected by a MAC that uses MacData\na key derived from an integrity mac: SHA1/97365F305DF3F3ECA79C...\nmacSalt: F C 18D34D9D322AD0\npassword, and each individual iterations: 2048\nprivate key entry is encrypted\nAuthenticatedSafe\nwith a key derived from a pri-\nPKCS8ShroudedKeyBag\nvacy password. In practice, the\nencAlgorithm: p beWithSHA1And3DES−CBC\ntwo passwords are usually the\nsame. PKCS#12 can also use\nEncrypted RSA private key\npublic keys to protect the pri-\nvacy and integrity of the archive\ncontents, but this usage is not CertBag\nvery common.\nA typical PKCS#12 file that\ncontains a user’s encrypted X.509 Certificate\npassword key and an associated\ncertificate might have structure\nlike that illustrated in Fig ure 5-3\n(note that some of the wrapper Figure 5-3: Structure of a PKCS#12 file holding\nstructures have been removed a private key and an associated certificate\nfor clarity).\n13. Abstract Syntax Notation One (ASN.1): A standard notation that describes rules and struc-\ntures for encoding data in telecommunications and computer networking. Extensively used\nin cryptography standards to define the structure of cryptographic objects.\n134 Chapter 5\nListing 5-18 shows how to obtain a private key and certificate from a\nPKCS#12 file.\nKeyStore keyStore = KeyStore.getInstance(\"PKCS12\");u\nInputStream in = new FileInputStream(\"mykey.pfx\");\nkeyStore.load(in, \"password\".toCharArray());v\nKeyStore.PrivateKeyEntry keyEntry =\n(KeyStore.PrivateKeyEntry)keyStore.getEntry(\"mykey\", null);w\nX509Certificate cert = (X509Certificate) keyEntry.getCertificate();x\nRSAPrivateKey privKey = (RSAPrivateKey) keyEntry.getPrivateKey();y\nListing 5-18: Using the KeyStore class to extract a private key and certificate from a\nPKCS#12 file\nThe KeyStore class can be used to access the contents of a PKCS#12 file\nby specifying PKCS12 as the keystore type when creating an instance (u\nin Listing 5-18). To load and parse the PKCS#12 file, we call the load()\nmethod v, passing an InputStream from which to read the file, and the file\nintegrity password. Once the file is loaded, we can obtain a private key entry\nby calling the getEntry() method and passing the key alias w and, option-\nally, a KeyStore.PasswordProtection instance initialized with the password for\nthe requested entry, if it’s different from the file integrity password. If the\nalias is unknown, all aliases can be listed with the aliases() method. Once\nwe have a PrivateKeyEntry, we can access the public key certificate x or the\nprivate key y. New entries can be added with the setEntry() method and\ndeleted with the deleteEntry() method. Changes to the KeyStore contents\ncan be persisted to disk by calling the store() method, which accepts an\nOutputStream (to which the keystore bytes are written) and an integrity pass-\nword (which is used to derive MAC and encryption keys) as parameters.\nA KeyStore implementation does not have to use a single file for storing\nkey and certificate objects. It can use multiple files, a database, or any other\nstorage mechanism. In fact, keys may not be stored on the host system at all,\nbut on a separate hardware device such as a smart card or a hardware security\nmodule (HSM). (Android-specific KeyStore implementations that provide an\ninterface to the system’s trust store and credential storage are introduced in\nChapters 6 and 7.)\nCertificateFactory and CertPath\nCertificateFactory acts as a certificate and CRL parser and can build cer-\ntificate chains from a list of certificates. It can read a stream that contains\nencoded certificates or CRLs and output a collection (or a single instance) of\njava.security.cert.Certificate and java.security.cert.CRL objects. Usually, only\nan X.509 implementation that parses X.509 certificates and CRLs is available.\nListing 5-19 shows how to parse a certificate file using CertificateFactory.\nCryptographic Providers 135\nCertificateFactory cf = CertificateFactory.getInstance(\"X.509\");u\nInputStream in = new FileInputStream(\"certificate.cer\");\nX509Certificate cert = (X509Certificate) cf.generateCertificate(in);v\nListing 5-19: Parsing an X.509 certificate file with CertificateFactory\nTo create a CertificateFactory, we pass X.509 as the factory type to\ngetInstance() u, and then call generateCertificate(), passing an InputStream\nfrom which to read v. Because this is an X.509 factory, the obtained object\ncan be safely cast to java.security.cert.X509Certificate. If the read file includes\nmultiple certificates that form a certificate chain, a CertPath object can be\nobtained by calling the generateCertPath() method.\nCertPathValidator and CertPathBuilder\nThe CertPathValidator class encapsulates a certificate chain validation algo-\nrithm as defined by the Public-Key Infrastructure (X.509) or PKIX standard.14\nWe discuss PKIX and certificate chain validation in more detail in Chapter 6,\nbut Listing 5-20 shows how to use CertificateFactory and CertPathValidator to\nbuild and validate a certificate chain.\nCertPathValidator certPathValidator = CertPathValidator.getInstance(\"PKIX\");u\nCertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\nX509Certificate[] chain = getCertChain();\nCertPath certPath = cf.generateCertPath(Arrays.asList(chain));v\nSet<TrustAnchor> trustAnchors = getTrustAnchors();\nPKIXParameters result = new PKIXParameters(trustAnchors);w\nPKIXCertPathValidatorResult result = (PKIXCertPathValidatorResult)\ncertPathValidator.validate(certPath, pkixParams);x\nListing 5-20: Building and validating a certificate chain with CertPathValidator\nAs you can see, we first obtain a CertPathValidator instance by pass-\ning PKIX to the getInstance() method u. We then build a certificate chain\nusing CertificateFactory’s generateCertPath() method v. Note that if the\npassed list of certificates does not form a valid chain, this method throws a\nCertificateException. If we do not already have all the certificates needed to\nform a chain, we can use a CertPathBuilder initialized with a CertStore to find\nthe needed certificates and build a CertPath (not shown).\nOnce we have a CertPath, we initialize the PKIXParameters class with a set\nof trust anchors (typically, these are trusted CA certificates; see Chapter 6 for\ndetails) w, and then call CertPathValidator.validate() x, passing the CertPath\nthat we built in v and the PKIXParameters instance. If validation succeeds,\nvalidate() returns a PKIXCertPathValidatorResult instance; if not, it throws a\nCertPathValidatorException that contains detailed information about why it\nfailed.\n14. D. Cooper et al., Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation\nList (CRL) Profile, May 2008, http://tools.ietf.org/html/rfc5280\n136 Chapter 5\nandroid JCa Providers\nAndroid’s cryptography providers are based on JCA and follow its architec-\nture with some relatively minor exceptions. While low-level Android compo-\nnents directly use native cryptography libraries (such as OpenSSL), JCA is\nthe main cryptographic API and is used by system components and third-\nparty applications alike.\nAndroid has three core JCA providers that include implementations\nof the engine classes outlined in the previous section and two Java Secure\nSocket Extension ( JSSE) providers that implement SSL functionality. ( JSSE is\ndiscussed in detail in Chapter 6.)\nLet’s examine Android’s core JCA providers.\nHarmony’s Crypto Provider\nAndroid’s Java runtime library implementation is derived from the retired\nApache Harmony project,15 which also includes a limited JCA provider simply\nnamed Crypto that provides implementations for basic cryptographic services\nlike random number generation, hashing, and digital signatures. Crypto is\nstill included in Android for backward compatibility but has the lowest pri-\nority of all JCA providers, so engine class implementations from Crypto are\nnot returned unless explicitly requested. Table 5-1 shows the engine classes\nand algorithms that Crypto supports.\nTable 5-1: Algorithms Supported by the Crypto Provider as of Android 4 .4 .4\nEngine Class Name Supported Algorithms\nKeyFactory DSA\nMessageDigest SHA-1\nSecureRandom SHA1PRNG\nSignature SHA1withDSA\nNOTE While the algorithms listed in Table 5-1 are still available in Android 4.4, all except\nSHA1PRNG have been removed in the Android master branch and may not be\navailable in future versions.\nAndroid’s Bouncy Castle Provider\nBefore Android version 4.0, the only full-featured JCA provider in Android\nwas the Bouncy Castle provider. The Bouncy Castle provider is part of the\nBouncy Castle Crypto APIs,16 a set of open source Java implementations of\ncryptographic algorithms and protocols.\n15. The Apache Software Foundation, “Apache Harmony,” http://harmony.apache.org/\n16. Legion of the Bouncy Castle Inc., “Bouncy Castle Crypto APIs,” https://www.bouncycastle\n.org/java.html\nCryptographic Providers 137\nAndroid includes a modified version of the Bouncy Castle provider,\nwhich is derived from the mainstream version by applying a set of Android-\nspecific patches. Those patches are maintained in the Android source tree\nand updated for each new release of the mainstream Bouncy Castle provider.\nThe main differences from the mainstream version are summarized below.\n• Algorithms, modes, and algorithm parameters not supported by Java’s\nreference implementation (RI) have been removed (RIPEMD, SHA-224,\nGOST3411, Twofish, CMAC, El Gamal, RSA-PSS, ECMQV, and so on).\n• Insecure algorithms such as MD2 and RC2 have been removed.\n• Java-based implementations of MD5 and the SHA family of digest algo-\nrithms have been replaced with a native implementation.\n• Some PBE algorithms have been removed (for example,\nPBEwithHmacSHA256).\n• Support for accessing certificates stored in LDAP has been removed.\n• Support for certificate blacklists has been added (blacklists are dis-\ncussed in Chapter 6).\n• Various performance optimizations have been made.\n• The package name has been changed to com.android.org.bouncycastle to\navoid conflict with apps that bundle in Bouncy Castle (since Android 3.0).\nThe engine classes and algorithms supported by Android’s Bouncy\nCastle provider as of version 4.4.4 (based on Bouncy Castle 1.49) are listed\nin Table 5-2.\nTable 5-2: Algorithms Supported by Android’s Bouncy Castle Provider as of\nAndroid 4 .4 .4\nEngine Class Name Supported Algorithms\nCertPathBuilder PKIX\nCertPathValidator PKIX\nCertStore Collection\nCertificateFactory X.509\nCipher AES\nAESWRAP\nARC4\nBLOWFISH\nDES\nDESEDE\nDESEDEWRAP\nPBEWITHMD5AND128BITAES-CBC-OPENSSL\nPBEWITHMD5AND192BITAES-CBC-OPENSSL\nPBEWITHMD5AND256BITAES-CBC-OPENSSL\nPBEWITHMD5ANDDES\nPBEWITHMD5ANDRC2\nPBEWITHSHA1ANDDES\nPBEWITHSHA1ANDRC2\n138 Chapter 5\nEngine Class Name Supported Algorithms\nCipher (continued) PBEWITHSHA256AND128BITAES-CBC-BC\nPBEWITHSHA256AND192BITAES-CBC-BC\nPBEWITHSHA256AND256BITAES-CBC-BC\nPBEWITHSHAAND128BITAES-CBC-BC\nPBEWITHSHAAND128BITRC2-CBC\nPBEWITHSHAAND128BITRC4\nPBEWITHSHAAND192BITAES-CBC-BC\nPBEWITHSHAAND2-KEYTRIPLEDES-CBC\nPBEWITHSHAAND256BITAES-CBC-BC\nPBEWITHSHAAND3-KEYTRIPLEDES-CBC\nPBEWITHSHAAND40BITRC2-CBC\nPBEWITHSHAAND40BITRC4\nPBEWITHSHAANDTWOFISH-CBC\nRSA\nKeyAgreement DH\nECDH\nKeyFactory DH\nDSA\nEC\nRSA\nKeyGenerator AES\nARC4\nBLOWFISH\nDES\nDESEDE\nHMACMD5\nHMACSHA1\nHMACSHA256\nHMACSHA384\nHMACSHA512\nKeyPairGenerator DH\nDSA\nEC\nRSA\nKeyStore BKS (default)\nBouncyCastle\nPKCS12\nMac HMACMD5\nHMACSHA1\nHMACSHA256\nHMACSHA384\nHMACSHA512\nPBEWITHHMACSHA\nPBEWITHHMACSHA1\nMessageDigest MD5\nSHA-1\nSHA-256\nSHA-384\nSHA-512\n(continued)\nCryptographic Providers 139\nTable 5-2 (continued)\nEngine Class Name Supported Algorithms\nSecretKeyFactory DES\nDESEDE\nPBEWITHHMACSHA1\nPBEWITHMD5AND128BITAES-CBC-OPENSSL\nPBEWITHMD5AND192BITAES-CBC-OPENSSL\nPBEWITHMD5AND256BITAES-CBC-OPENSSL\nPBEWITHMD5ANDDES\nPBEWITHMD5ANDRC2\nPBEWITHSHA1ANDDES\nPBEWITHSHA1ANDRC2\nPBEWITHSHA256AND128BITAES-CBC-BC\nPBEWITHSHA256AND192BITAES-CBC-BC\nPBEWITHSHA256AND256BITAES-CBC-BC\nPBEWITHSHAAND128BITAES-CBC-BC\nPBEWITHSHAAND128BITRC2-CBC\nPBEWITHSHAAND128BITRC4\nPBEWITHSHAAND192BITAES-CBC-BC\nPBEWITHSHAAND2-KEYTRIPLEDES-CBC\nPBEWITHSHAAND256BITAES-CBC-BC\nPBEWITHSHAAND3-KEYTRIPLEDES-CBC\nPBEWITHSHAAND40BITRC2-CBC\nPBEWITHSHAAND40BITRC4\nPBEWITHSHAANDTWOFISH-CBC\nPBKDF2WithHmacSHA1\nPBKDF2WithHmacSHA1And8BIT\nSignature ECDSA\nMD5WITHRSA\nNONEWITHDSA\nNONEwithECDSA\nSHA1WITHRSA\nSHA1withDSA\nSHA256WITHECDSA\nSHA256WITHRSA\nSHA384WITHECDSA\nSHA384WITHRSA\nSHA512WITHECDSA\nSHA512WITHRSA\nAndroidOpenSSL Provider\nAs mentioned in “Android’s Bouncy Castle Provider” on page 137, hash\nalgorithms in Android’s Bouncy Castle provider have been replaced with\nnative code for performance reasons. In order to further improve crypto-\ngraphic performance, the number of supported engine classes and algo-\nrithms in the native AndroidOpenSSL provider has been steadily growing\nwith each release since 4.0.\nOriginally, AndroidOpenSSL was only used to implement SSL sockets,\nbut as of Android 4.4, it covers most of the functionality offered by Bouncy\nCastle. Because it is the preferred provider (with the highest priority, 1),\nengine classes that don’t explicitly request Bouncy Castle get an implemen-\ntation from the AndroidOpenSSL provider. As the name implies, its cryp-\ntographic functionality is provided by the OpenSSL library. The provider\n140 Chapter 5\nimplementation uses JNI to link OpenSSL’s native code to the Java SPI\nclasses required to implement a JCA provider. The bulk of the implementa-\ntion is in the NativeCrypto Java class, which is called by most SPI classes.\nAndroidOpenSSL is part of Android’s libcore library, which implements\nthe core part of Android’s Java runtime library. Starting with Android 4.4,\nAndroidOpenSSL has been decoupled from libcore so that it can be com-\npiled as a standalone library and included in applications that want a\nstable cryptographic implementation that does not depend on the plat-\nform version. The standalone provider is called Conscrypt and lives in the\norg.conscrypt package, renamed to com.android.org.conscrypt when built as\npart of the Android platform.\nThe engine classes and algorithms supported by the AndroidOpenSSL\nprovider as of version 4.4.4 are listed in Table 5-3.\nTable 5-3: Algorithms Supported by the AndroidOpenSSL Provider as of\nAndroid 4 .4 .4\nEngine Class Name Supported Algorithms\nCertificateFactory X509\nCipher AES/CBC/NoPadding\nAES/CBC/PKCS5Padding\nAES/CFB/NoPadding\nAES/CTR/NoPadding\nAES/ECB/NoPadding\nAES/ECB/PKCS5Padding\nAES/OFB/NoPadding\nARC4\nDESEDE/CBC/NoPadding\nDESEDE/CBC/PKCS5Padding\nDESEDE/CFB/NoPadding\nDESEDE/ECB/NoPadding\nDESEDE/ECB/PKCS5Padding\nDESEDE/OFB/NoPadding\nRSA/ECB/NoPadding\nRSA/ECB/PKCS1Padding\nKeyAgreement ECDH\nKeyFactory DSA\nEC\nRSA\nKeyPairGenerator DSA\nEC\nRSA\nMac HmacMD5\nHmacSHA1\nHmacSHA256\nHmacSHA384\nHmacSHA512\nMessageDigest MD5\nSHA-1\nSHA-256\nSHA-384\nSHA-512\n(continued)\nCryptographic Providers 141\nTable 5-3 (continued)\nEngine Class Name Supported Algorithms\nSecureRandom SHA1PRNG\nSignature ECDSA\nMD5WithRSA\nNONEwithRSA\nSHA1WithRSA\nSHA1withDSA\nSHA256WithRSA\nSHA256withECDSA\nSHA384WithRSA\nSHA384withECDSA\nSHA512WithRSA\nSHA512withECDSA\nOpenSSL\nOpenSSL is an open source cryptographic toolkit that implements the\nSSL and TLS protocols and is widely used as a general purpose cryptogra-\nphy library.17 It is included in Android as a system library and used to\nimplement the AndroidOpenSSL JCA provider that was introduced in\n“AndroidOpenSSL Provider” on page 140, as well as by some other system\ncomponents.\nDifferent Android releases use different OpenSSL versions (generally\nthe latest stable version, which is 1.0.1e in Android 4.4), with an evolving\nset of patches applied. Therefore, Android does not offer a stable public\nOpenSSL API, so applications that need to use OpenSSL should include\nthe library and not link to the system version. The only public cryptographic\nAPI is the JCA one, which offers a stable interface decoupled from the under-\nlying implementation.\nUsing a Custom Provider\nWhile Android’s built-in providers cover most widely used cryptographic\nprimitives, they do not support some more exotic algorithms and even some\nnewer standards. As mentioned in our discussion of the JCA architecture,\nAndroid applications can register custom providers for their own use, but\ncannot affect system-wide providers.\n17. The OpenSSL Project, “OpenSSL: The Open Source toolkit for SSL/TLS,” http://www\n.openssl.org/\n142 Chapter 5\nOne of the most widely used and full-featured JCA providers is Bouncy\nCastle, also the base of one of Android’s built-in providers. However, as\ndiscussed in “Android’s Bouncy Castle Provider” on page 137, the version\nshipped with Android has had a number of algorithms removed. If you\nneed to use any of those algorithms, you can try simply bundling the full\nBouncy Castle library with your application—but that may cause class load-\ning conflicts, especially on versions of Android earlier than 3.0, which do\nnot change the system’s Bouncy Castle’s package name. To avoid this, you\ncan change the library’s root package with a tool such as jarjar,18 or use\nSpongy Castle.19\nSpongy Castle\nSpongy Castle is a repackaged version of Bouncy Castle. It moves all pack-\nage names from org.bouncycastle.* to org.spongycastle.* in order to avoid\nclass loader conflicts, and changes the provider name from BC to SC.\nNo class names are changed, so the API is the same as Bouncy Castle.\nTo use Spongy Castle, you simply need to register it with the JCA frame-\nwork using Security.addProvider() or Security.insertProviderAt(). You can\nthen request algorithms not implemented by Android’s built-in provid-\ners simply by passing the algorithm name to the respective getInstance()\nmethod.\nTo explicitly request an implementation from Spongy Castle, pass the\nSC string as the provider name. If you bundle the Spongy Castle library\nwith your app, you can also directly use Bouncy Castle’s lightweight cryp-\ntographic API (which is often more flexible) without going through the\nJCA engine classes. Additionally, some cryptographic operations, such\nas signing an X.509 certificate or creating an S/MIME message, have\nno matching JCA APIs and can only be performed using the lower-level\nBouncy Castle APIs.\nListing 5-21 shows how to register the Spongy Castle provider and\nrequest an RSA-PSS (originally defined in PKCS#120) Signature implemen-\ntation, which is not supported by any of Android’s built-in JCA providers.\nstatic {\nSecurity.insertProviderAt(\nnew org.spongycastle.jce.provider.BouncyCastleProvider(), 1);\n}\nSignature sig = Signature.getInstance(\"SHA1withRSA/PSS\", \"SC\");\nListing 5-21: Registering and using the Spongy Castle provider\n18. Chris Nokleberg, “Jar Jar Links,” https://code.google.com/p/jarjar/\n19. Roberto Tyley, “Spongy Castle,” http://rtyley.github.io/spongycastle/\n20. J. Jonsson and B. Kaliski, Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography\nSpecifications Version 2.1, http://tools.ietf.org/html/rfc3447\nCryptographic Providers 143\nsummary\nAndroid implements the Java Cryptography Architecture (JCA) and comes\nbundled with a number of cryptographic providers. JCA defines inter-\nfaces to common cryptographic algorithms in the form of engine classes.\nCryptographic providers offer implementations of those engine classes\nand allow clients to request an algorithm implementation by name, with-\nout having to know about the actual underlying implementation. The two\nmain JCA providers in Android are the Bouncy Castle provider and the\nAndroidOpenSSL provider. Bouncy Castle is implemented in pure Java,\nwhile AndroidOpenSSL is backed by native code and offers better perfor-\nmance. As of Android 4.4, AndroidOpenSSL is the preferred JCA provider.\n144 Chapter 5",
    "question": "What are the main cryptographic providers in Android and how do they differ in terms of their implementation and performance?",
    "summary": "Android implements the Java Cryptography Architecture (JCA) with built-in cryptographic providers. The JCA provides a framework for cryptographic operations, allowing applications to request specific algorithms without needing to know the underlying implementation. Android's main JCA providers are Bouncy Castle and AndroidOpenSSL, with AndroidOpenSSL being the preferred choice in Android 4.4 and later due to its better performance. Bouncy Castle is a Java-based provider, while AndroidOpenSSL uses native code for improved efficiency."
  },
  {
    "start": 96,
    "end": 107,
    "text": "6\nNE T wORk sECURIT Y a ND P kI\nAs discussed in the previous chapter, Android includes\nvarious cryptographic providers that implement most\nmodern cryptographic primitives: hashing, symmetric\nand asymmetric encryption, and message authentica-\ntion codes. Those primitives can be combined to\nimplement secure communication, but even a subtle mistake can result\nin serious vulnerabilities, so the preferred way to implement secure com-\nmunication is to use standard protocols that are designed to protect the\nprivacy and integrity of data transferred across a network.\nThe most widely used secure protocols are Secure Sockets Layer (SSL)\nand Transport Layer Security (TLS). Android supports these protocols by\nproviding an implementation of the standard Java Secure Socket Extension\n(JSSE). In this chapter, we’ll briefly discuss the JSSE architecture and then\nprovide some details about Android’s JSSE implementation. Our description\nof Android’s SSL stack is focused on certificate validation and trust anchor\nmanagement, which are tightly integrated into the platform and are one of\nthe biggest differences that set it apart from other JSSE implementations.\nNOTE While TLS and SSL are technically different protocols, we will usually use the more com-\nmon term SSL to refer to both, and will only distinguish between SSL and TLS when\ndiscussing protocol differences.\nPkI and ssL Overview\nTLS1 and SSL2 (its predecessor) are secure point-to-point communication\nprotocols designed to provide (optional) authentication, message confi-\ndentiality, and message integrity between two parties communicating over\nTCP/IP. They use a combination of symmetric and asymmetric encryption\nto implement message confidentiality and integrity, and rely heavily on pub-\nlic key certificates to implement authentication.\nTo start a secure SSL channel, a client contacts a server and sends the\nSSL protocol version it supports, as well as a list of suggested cipher suites.\nA cipher suite is a set of algorithms and key sizes used for authentication, key\nagreement, encryption, and integrity. In order to establish a secure channel,\nthe server and client negotiate a commonly supported cipher suite, and then\nverify each other’s identity based on their certificates. Finally, the commu-\nnicating parties agree on a symmetric encryption algorithm and compute\na shared symmetric key that is used to encrypt all subsequent communica-\ntion. Typically, only the server’s identity is verified (server authentication) and\nnot the client’s. The SSL protocol supports verifying client identity as well\n(client authentication), but it is used much more rarely.\nNOTE While anonymous (unauthenticated) cipher suites such as TLS_DH_anon_WITH_\nAES_128_CBC_SHA are defined in SSL specifications, they are vulnerable to man-\nin-the-middle (MITM) attacks and are typically only employed when SSL is used as\npart of a more complex protocol that has other means to ensure authentication.\nPublic Key Certificates\nAs mentioned in the previous section, SSL relies on public key certificates\nto implement authentication. A public key certificate is a construct that\nbinds an identity to a public key. For X.509 certificates, which are used in\nSSL communication, the “identity” is a set of attributes typically including a\ncommon name (CN), organization, and location that form the entity’s dis-\ntinguished name (DN). Other major attributes of X.509 certificates are the\nissuer DN, validity period, and a set of extensions, which may be additional\nentity attributes or pertain to the certificate itself (for example, intended\nkey usage).\nThe binding is formed by applying a digital signature over the entity’s\npublic key and all additional attributes to produce a digital certificate. The\n1. T. Dierks and E. Rescorla, The Transport Layer Security (TLS) Protocol Version 1.2, August 2008,\nhttp://tools.ietf.org/html/rfc5246\n2. A. Freier, P. Karlton, and P. Kocher, The Secure Sockets Layer (SSL) Protocol Version 3.0,\nAugust 2011, http://tools.ietf.org/html/rfc6101\n146 Chapter 6\nsigning key used may be the certified entity’s own private key, in which case\nthe certificate is referred to as self-signed, or it may belong to a trusted third\nparty called a certificate authority (CA).\nThe contents of a typical X.509 server certificate as parsed by the\nOpenSSL x509 command are shown in Listing 6-1. This particular cer-\ntificate binds the C=US, ST=California, L=Mountain View, O=Google Inc,\nCN=*.googlecode.com DN v and a set of alternative DNS names x to the\nserver’s 2048-bit RSA key w and is signed with the private key of the Google\nInternet Authority G2 CA u.\nCertificate:\nData:\nVersion: 3 (0x2)\nSerial Number:\n09:49:24:fd:15:cf:1f:2e\nSignature Algorithm: sha1WithRSAEncryption\nIssuer: C=US, O=Google Inc, CN=Google Internet Authority G2u\nValidity\nNot Before: Oct 9 10:33:36 2013 GMT\nNot After : Oct 9 10:33:36 2014 GMT\nSubject: C=US, ST=California, L=Mountain View, O=Google Inc, CN=*.googlecode.comv\nSubject Public Key Info:\nPublic Key Algorithm: rsaEncryption\nPublic-Key: (2048 bit)w\nModulus:\n00:9b:58:02:90:d6:50:03:0a:7c:79:06:99:5b:7a:\n--snip--\nExponent: 65537 (0x10001)\nX509v3 extensions:\nX509v3 Extended Key Usage:\nTLS Web Server Authentication, TLS Web Client Authentication\nX509v3 Subject Alternative Name:\nDNS:*.googlecode.com, DNS:*.cloud.google.com, DNS:*.code.google.com,x\n--snip--\nAuthority Information Access:\nCA Issuers - URI:http://pki.google.com/GIAG2.crt\nOCSP - URI:http://clients1.google.com/ocsp\nX509v3 Subject Key Identifier:\n65:10:15:1B:C4:26:13:DA:50:3F:84:4E:44:1A:C5:13:B0:98:4F:7B\nX509v3 Basic Constraints: critical\nCA:FALSE\nX509v3 Authority Key Identifier:\nkeyid:4A:DD:06:16:1B:BC:F6:68:B5:76:F5:81:B6:BB:62:1A:BA:5A:81:2F\nX509v3 Certificate Policies:\nPolicy: 1.3.6.1.4.1.11129.2.5.1\nX509v3 CRL Distribution Points:\nFull Name:\nURI:http://pki.google.com/GIAG2.crl\nSignature Algorithm: sha1WithRSAEncryption\n3f:38:94:1b:f5:0a:49:e7:6f:9b:7b:90:de:b8:05:f8:41:32:\n--snip--\nListing 6-1: X.509 certificate contents, as parsed by OpenSSL\nNetwork Security and PKI 147\nDirect Trust and Private CAs\nIf an SSL client communicates with a limited number of servers, it can\nbe preconfigured with a set of server certificates that it trusts (called trust\nanchors), and deciding whether to trust a remote party becomes simply a\nmatter of checking whether its certificate is in that set. This model allows\nfor fine-grained control over whom clients trust, but makes it harder to\nrotate or upgrade server keys, which requires issuing a new self-signed\ncertificate.\nThis problem can be solved by using a private CA and configuring both\nclients and servers to use it as the single trust anchor. In this model, SSL\nparties do not check for a particular entity certificate, but trust any certifi-\ncate issued by the private CA. This allows for transparent key and certificate\nupgrades, without the need to upgrade SSL clients and servers as long as\nthe CA certificate is still valid. The downside is that at the same time, this\nsingle-CA model creates a single point of failure; if the CA key is compro-\nmised, whoever has obtained access to it can issue fraudulent certificates\nthat all clients will trust (as we will see later, this is not limited to private\nCAs). Recovering from this situation requires updating all clients and\nreplacing the CA certificate.\nAnother problem with this model is that it cannot be used for clients\nthat do not know in advance what servers they will need to connect to—\nusually generic Internet clients such as web browsers, email applications,\nand messaging or VoIP clients. Such generic clients are typically config-\nured with a set of trust anchors that includes well-known issuers, which\nwe call public CAs. While certain guidelines and requirements exist, the\nprocess of selecting public CAs to include as default trust anchors varies\nwidely between browsers and OSes. For example, in order to include a CA\ncertificate as a trust anchor in its products, Mozilla requires that the CA has\na public Certificate Policy and Certification Practice Statement (CP/CPS) docu-\nment, enforces multi-factor authentication for operator accounts, and that\nthe CA certificate does not issue end-entity certificates directly.3 Other ven-\ndors can have less stringent requirements. Current versions of most OSes\nand browsers ship with more than 100 CA certificates included as trust\nanchors.\nPublic Key Infrastructure\nWhen certificates are issued by public CAs, some sort of identity verification\nis performed before issuing the certificate. The verification process varies\nvastly between CAs and types of certificates issued, ranging from accept-\ning automatic email address confirmation (for cheap server certificates) to\nrequiring multiple forms of government-issued ID and company registra-\ntion documents (for Extended Validation, or EV, certificates).\nPublic CAs depend on multiple people, systems, procedures, and policies\nin order to perform entity verification and to create, manage, and distribute\n3. Mozilla, Mozilla CA Certificate Inclusion Policy (Version 2.2), https://www.mozilla.org/en-US/\nabout/governance/policies/security-group/certs/policy/inclusion/\n148 Chapter 6\ncertificates. The set of those parties and systems is referred to as a Public\nKey Infrastructure (PKI). PKIs can be infinitely complex, but in the context\nof secure communication, and SSL in particular, the most important pieces\nare the CA certificates, which act as trust anchors and are used when vali-\ndating the identity of communication parties. Therefore, managing trust\nanchors will be one of the key points in our discussion of Android’s SSL\nand PKI implementation. Figure 6-1 shows a simplified representation of\na typical PKI.\nRoot CA\nSign Publish\ncertificate certificate/CRL\nPublish\ncertificate/CRL\nCertificate/CRL\nIssuing CA\nRepository\nRequest\ncertificate\nSign Registration Fetch\ncertificate certificate/CRL\nAuthority\nVerify EE ID\nRequest\nEnd Entity 1 certificate End Entity 2\n(Alice) and submit (Bob)\nproof of ID\nSecure\ncommunication\nFigure 6-1: PKI entities\nHere, a person or server that holds a certificate is referred to as an end\nentity (EE). To obtain a certificate, an end entity sends a certificate request\nto a registration authority (RA). The RA obtains some proof of identity\nfrom the EE and verifies its identity according to the CA’s policy require-\nments. After the RA has established the identity of the EE, it checks that\nit matches the contents of the certificate request, and if so, forwards the\nrequest to the issuing CA. An issuing CA signs the EE certificate request\nin order to generate EE certificates and maintains revocation informa-\ntion (discussed in the next section) about the issued certificates. On the\nother hand, a root CA does not sign EE certificates directly but only signs\nNetwork Security and PKI 149\ncertificates for issuing CAs and revocation information concerning issuing\nCAs. A root CA is used very rarely and is usually kept offline in order to\nincrease the security of its keys.\nFor the PKI sketched in Figure 6-1, an EE certificate is associated with\ntwo CA certificates: the issuing CA’s certificate, which signed it, and the\nroot CA’s certificate, which signed the issuing CA’s certificate. The three\ncertificates form a certificate chain (also called a certification path). The\nchain begins with the EE certificate and terminates with the root CA cer-\ntificate. In order for an EE certificate to be trusted, its certification path\nneeds to lead to a certificate the system trusts implicitly (trust anchor).\nWhile intermediate certificates can be used as trust anchors, this role is\nusually performed by root CA certificates.\nCertificate Revocation\nIn addition to issuing certificates, CAs can mark a certificate as invalid\nby revoking it. Revoking involves adding the certificate serial number\nand a revocation reason to a certificate revocation list (CRL) that the\nCA signs and periodically publishes. Entities validating a certificate can\nthen check to see if it has been revoked by searching for its serial num-\nber (which is unique within a given CA) in the issuing CA’s current CRL.\nListing 6-2 shows the contents of a sample CRL file, issued by the Google\nInternet Authority G2. In this example, certificates with the serial numbers\n40BF8571DD53E3BB u and 0A9F21196A442E45 v have been revoked.\nCertificate Revocation List (CRL):\nVersion 2 (0x1)\nSignature Algorithm: sha1WithRSAEncryption\nIssuer: /C=US/O=Google Inc/CN=Google Internet Authority G2\nLast Update: Jan 13 01:00:02 2014 GMT\nNext Update: Jan 23 01:00:02 2014 GMT\nCRL extensions:\nX509v3 Authority Key Identifier:\nkeyid:4A:DD:06:16:1B:BC:F6:68:B5:76:F5:81:B6:BB:62:1A:BA:5A:81:2F\nX509v3 CRL Number:\n219\nRevoked Certificates:\nSerial Number: 40BF8571DD53E3BBu\nRevocation Date: Sep 10 15:19:22 2013 GMT\nCRL entry extensions:\nX509v3 CRL Reason Code:\nAffiliation Changed\n--snip--\nSerial Number: 0A9F21196A442E45v\nRevocation Date: Jun 12 17:42:06 2013 GMT\nCRL entry extensions:\nX509v3 CRL Reason Code:\nSuperseded\nSignature Algorithm: sha1WithRSAEncryption\n40:f6:05:7d:...\nListing 6-2: CRL file contents\n150 Chapter 6\nRevocation status can also be checked without fetching the full list\nof all revoked certificates by using the Online Certificate Status Protocol\n(OCSP).4 CRL and OCSP URIs are often included as extensions in cer-\ntificates so that verifying parties do not need to know their location in\nadvance. All public CAs maintain revocation information, but in practice a\nlot of SSL clients either do not check revocation at all or allow connections\n(possibly with a warning) even if the remote party’s certificate is revoked.\nThe main reasons for this lenient behavior of SSL clients are the overhead\nassociated with fetching current revocation information, and ensuring con-\nnectivity. While delta CRLs (CRLs that only contain the difference, or delta,\nfrom the previous CRL version) and local caching alleviate the problem to\nsome extent, CRLs for major CAs are typically huge and need to be down-\nloaded before an SSL connection is established, which adds user-visible\nlatency. OCSP improves this situation but still requires a connection to a\ndifferent server, which again adds latency.\nIn either case, revocation information may simply be unavailable, due\nto a network or configuration problem in a CA’s infrastructure. For a major\nCA, a revocation database outage could disable a large number of secure\nsites, which translates directly to financial loss for their operators. Lastly,\nnobody likes connection errors and when faced with a revocation error,\nmost users will simply find another, less strict SSL client that simply “works.”\nJssE Introduction\nWe’ll briefly introduce the architecture and main components of JSSE here.\n(For complete coverage, see the official JSSE Reference Guide.5)\nThe JSSE API lives in the javax.net and javax.net.ssl packages and pro-\nvides classes that represent the following features:\n• SSL client and server sockets\n• An engine for producing and consuming SSL streams (SSLEngine)\n• Factories for creating sockets\n• A secure socket context class (SSLContext) that creates secure socket\nfactories and engines\n• PKI-based key and trust managers and factories to create them\n• A class for HTTPS (HTTP over TLS, specified in RFC 2818 6) URL con-\nnections (HttpsURLConnection)\nJust as with JCA cryptographic service providers, a JSSE provider sup-\nplies implementations for the engine classes defined in the API. Those\nimplementation classes are responsible for creating the underlying sockets,\n4. S. Santesson et al., X.509 Internet Public Key Infrastructure Online Certificate Status Protocol -\nOCSP, June 2013, http://tools.ietf.org/html/rfc6960\n5. Oracle, Java™ Secure Socket Extension (JSSE) Reference Guide, http://docs.oracle.com/javase/7/\ndocs/technotes/guides/security/jsse/JSSERefGuide.html\n6. E. Rescorla, HTTP Over TLS, May 2000, http://tools.ietf.org/html/rfc2818\nNetwork Security and PKI 151\nand key and trust managers required to establish a connection, but JSSE\nAPI users never directly interact with them, only with the respective engine\nclasses. Let’s briefly review the key classes and interfaces in the JSSE API, as\nwell as how they relate to each other.\nSecure Sockets\nJSSE supports both stream-based, blocking I/O using sockets and NIO\n(New I/O) channel-based, nonblocking I/O. The central class for stream-\nbased communication is javax.net.ssl.SSLSocket, which is created either by\nan SSLSocketFactory or by calling the accept() method of the SSLServerSocket\nclass. In turn, SSLSocketFactory and SSLServerSocketFactory instances are created\nby calling the appropriate factory methods of the SSLContext class. SSL socket\nfactories encapsulate the details of creating and configuring SSL sockets,\nincluding authentication keys, peer certificate validation strategies, and\nenabled cipher suites. Those details are typically common for all SSL sockets\nthat an application uses and are configured when initializing the applica-\ntion’s SSLContext. They are then passed to all SSL socket factories created by\nthe shared SSLContext instance. If an SSLContext is not explicitly configured,\nit uses the system defaults for all SSL parameters.\nNonblocking SSL I/O is implemented in the javax.net.ssl.SSLEngine\nclass. This class encapsulates an SSL state machine and operates on byte\nbuffers supplied by its clients. While SSLSocket hides much of the complexity\nof SSL, in order to offer greater flexibility, SSLEngine leaves I/O and threading\nto the calling application. Therefore, SSLEngine clients are expected to have\nsome understanding of the SSL protocol. SSLEngine instances are created\ndirectly from an SSLContext and inherit its SSL configuration, just like SSL\nsocket factories.\nPeer Authentication\nPeer authentication is an integral part of the SSL protocol and relies on\nthe availability of a set of trust anchors and authentication keys. In JSSE,\npeer authentication configuration is provided with the help of the KeyStore,\nKeyManagerFactory, and TrustManagerFactory engine classes. A KeyStore repre-\nsents a storage facility for cryptographic keys and certificates and can be\nused to store both trust anchors certificates, and end entity keys along with\ntheir associated certificates. KeyManagerFactory and TrustManagerFactory create\nKeyManagers or TrustManagers, respectively, based on a specified authentication\nalgorithm. While implementations based on different authentication strate-\ngies are possible, in practice SSL uses only a X.509-based PKI (PKIX)7 for\nauthentication, and the only algorithm supported by those factory classes\nis PKIX (aliased to X.509). An SSLContext can be initialized with a set of\n7. D. Cooper et al., Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation\nList (CRL) Profile, May 2008, http://tools.ietf.org/html/rfc5280\n152 Chapter 6\nKeyManager and TrustManager instances by calling the following method. All\nparameters are optional, and if null is specified, the system default is used\n(see Listing 6-3).\nvoid init(KeyManager[] km, TrustManager[] tm, SecureRandom random);\nListing 6-3: SSLContext initialization method\nA TrustManager determines whether the presented peer authentication\ncredentials should be trusted. If they are, the connection is established; if\nnot, the connection is terminated. In the context of PKIX, this translates to\nvalidating the certificate chain of the presented peer certificate based on\nthe configured trust anchors. This is also reflected in the X509TrustManager\ninterface JSSE uses (see Listing 6-4):\nvoid checkClientTrusted(X509Certificate[] chain, String authType);\nvoid checkServerTrusted(X509Certificate[] chain, String authType);\nX509Certificate[] getAcceptedIssuers();\nListing 6-4: X509TrustManager interface methods\nCertificate chain validation is performed using the system Java\nCertification Path API (or CertPath API) implementation,8 which is\nresponsible for building and validating certificate chains. While the API\nhas a somewhat algorithm-independent interface, in practice it’s closely\nrelated to PKIX and implements the chain building and validation algo-\nrithms defined in PKIX standards. The default PKIX TrustManagerFactory\nimplementation can create an X509TrustManager instance that preconfigures\nthe underlying CertPath API classes with the trust anchors stored in a\nKeyStore object.\nThe KeyStore object is typically initialized from a system keystore\nfile referred to as a trust store. When more fine-grained configuration is\nrequired, a CertPathTrustManagerParameters instance that contains detailed\nCertPath API parameters can be used to initialize the TrustManagerFactory\nas well. When the system X509TrustManager implementation cannot be con-\nfigured as required using the provided APIs, a custom instance can be\ncreated by implementing the interface directly, possibly delegating base\ncases to the default implementation.\nA KeyManager determines which authentication credentials to send to the\nremote host. In the context of PKIX, this means selecting the client authenti-\ncation certificate to send to an SSL server. The default KeyManagerFactory can\ncreate a KeyManager instance that uses a KeyStore to search for client authen-\ntication keys and related certificates. Just as with TrustManagers, the concrete\ninterfaces, X509KeyManager (shown in Listing 6-5) and X509ExtendedKeyManager\n8. Oracle, Java™ PKI Programmer’s Guide, http://docs.oracle.com/javase/7/docs/technotes/guides/\nsecurity/certpath/CertPathProgGuide.html\nNetwork Security and PKI 153\n(which allows for connection-specific key selection), are PKIX-specific and\nselect a client certificate based on the list of trusted issuers that the server\nhas provided. If the default KeyStore -backed implementation is not suffi-\nciently flexible, a custom implementation can be provided by extending the\nabstract X509ExtendedKeyManager class.\nString chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket);\nString chooseServerAlias(String keyType, Principal[] issuers, Socket socket);\nX509Certificate[] getCertificateChain(String alias);\nString[] getClientAliases(String keyType, Principal[] issuers);\nPrivateKey getPrivateKey(String alias);\nString[] getServerAliases(String keyType, Principal[] issuers);\nListing 6-5: X509KeyManager interface\nIn addition to support for “raw” SSL sockets, JSSE also provides\nsupport for HTTPS with the HttpsURLConnection class. HttpsURLConnection\nuses the default SSLSocketFactory to create secure sockets when opening\na connection to a web server. If additional SSL configuration such as\nspecifying app-private trust anchors or authentication keys is required,\nthe default SSLSocketFactory can be replaced for all HttpsURLConnection\ninstances by calling the static setDefaultSSLSocketFactory() method.\nAlternatively, you can configure the socket factory for a particular\ninstance by calling its setSSLSocketFactory() method.\nHostname Verification\nWhile SSL verifies server identity by checking its certificate, the protocol\ndoes not mandate any hostname verification, and when using raw SSL\nsockets, the certificate subject is not matched against the server host-\nname. The HTTPS standard does mandate such a check however, and\nHttpsURLConnection performs one internally. The default hostname verifica-\ntion algorithm can be overridden by assigning a HostnameVerifier instance\nto the class or on a per-instance basis. The verify() callback it needs to\nimplement is shown in Listing 6-6. The SSLSession class used in the call-\nback encapsulates details about the current SSL connection, including\nselected protocol and cipher suite, local and peer certificate chains, and\npeer hostname and connection port number.\nboolean verify(String hostname, SSLSession session);\nListing 6-6: HostnameVerifier hostname verification callback\nWe have discussed the major classes and interfaces that form the JSSE\nAPI and introduced how they related to each other. Their relationships can\nbe visualized as shown in Figure 6-2.\n154 Chapter 6\nKey Material Trust Anchors\nCustom Custom\nKeyManagerFactory TrustManagerFactory\nKMF TMF\nKeyManager TrustManager\nSSLContext SecureRandom\nSSLServerSocketFactory SSLSocketFactory\nSSLServerSocket\nSSLSocket I/O SSLSocket I/O SSLEngine\nSSLSession\nFigure 6-2: JSSE classes and their relationships\nandroid JssE Implementation\nAndroid comes with two JSSE providers: the Java-based HarmonyJSSE and\nthe AndroidOpenSSL provider, which is implemented largely in native code\nbridged to the public Java API using JNI. HarmonyJSSE builds on Java sockets\nand JCA classes in order to implement SSL, while AndroidOpenSSL imple-\nments most of its functionality by using OpenSSL library calls. As discussed\nin Chapter 5, AndroidOpenSSL is the preferred JCA provider in Android,\nand it also provides the default SSLSocketFactory and SSLServerSocketFactory\nimplementations that are returned by SSLSocketFactory.getDefault() and\nSSLServerSocketFactory.getDefault(), respectively.\nNetwork Security and PKI 155\nBoth JSSE providers are part of the core Java library (found in core.jar\nand libjavacore.so), and the native part of the AndroidOpenSSL provider\nis compiled into libjavacrypto.so. HarmonyJSSE provides only SSLv3.0 and\nTLSv1.0 support, while AndroidOpenSSL supports TLSv1.1 and TLSv1.2\nas well. While the SSL socket implementation is different, both providers\nshare the same TrustManager and KeyManager code.\nNOTE The HarmonyJSSE provider is still available in Android 4.4, but it is considered\ndeprecated and is not actively maintained. It may be removed in future Android\nversions.\nIn addition to current TLS protocol versions, the OpenSSL-based\nprovider supports the Server Name Indication (SNI) TLS extension (defined\nin RFC 3546 9), which allows SSL clients to specify the intended hostname\nwhen connecting to servers hosting multiple virtual hosts. SNI is used by\ndefault when establishing a connection using the HttpsURLConnection class\nin Android 3.0 and later versions (version 2.3 has partial SNI support).\nHowever, SNI is not supported when using the Apache HTTP client library\nbundled with Android (in the org.apache.http package).\nBefore Android 4.2, the HTTP stack in Android’s core Java library,\nincluding HttpsURLConnection, was based on Apache Harmony code. In\nAndroid 4.2 and later, the original implementation is replaced with\nSquare’s HTTP & SPDY client library, OkHttp.10\nCertificate Management and Validation\nAndroid’s JSSE implementations mostly conform to the JSSE API specifica-\ntion, but there are some notable differences as well. The biggest one is how\nAndroid handles the system trust store. In Java SE JSSE implementations,\nthe system trust store is a single keystore file (typically called cacerts) whose\nlocation can be set with the javax.net.ssl.trustStore system property, but\nAndroid follows a different strategy. Recent versions of Android also pro-\nvide modern certificate validation features such as blacklisting and pinning\nthat are not specified in the original JSSE architecture document. We will\ndiscuss Android’s trust store implementation and advanced certificate vali-\ndation features in the next sections.\nSystem Trust Stores\nAs discussed in “Peer Authentication” on page 152, JSSE implementa-\ntions use a trust store to authenticate connection peers. While SSL does\nsupport encryption-only, non-authenticated connections, in practice raw\nSSL clients usually perform server authentication and it is mandatory for\nHTTPS. When a per-application trust store is not explicitly provided, JSSE\n9. S. Blake-Wilson et al., Transport Layer Security (TLS) Extensions, June 2003, http://tools.ietf.org/\nhtml/rfc3546\n10. Square, Inc., OkHttp: An HTTP & SPDY client for Android and Java applications,\nhttp://square.github.io/okhttp/\n156 Chapter 6\nuses the system trust store to perform SSL peer authentication. The system\ntrust store is especially important for generic Internet clients such as brows-\ners, because they typically do not manage their own trust store on mobile\ndevices (desktop versions of Mozilla clients do maintain private credential\nand certificate stores, but not on Android). Because system trust stores are\ncentral to the security of all applications that use JSSE, we will look into\ntheir implementation in detail.\nUntil Android 4.0, the OS trust store was hardwired into the system and\nusers had no control over it whatsoever. Certificates bundled in the store\nwere chosen solely by the device manufacturer or carrier. The only way to\nmake changes was to root your device, repackage the trusted certificates\nfile, and replace the original one—a procedure that’s obviously not too\npractical, and a major obstacle to using Android in enterprise PKIs. In the\nwake of the compromise of multiple major CAs, third-party tools that could\nchange the system-trusted certificates were developed, but using them still\nrequired a rooted phone. Fortunately, Android 4.0 made managing the\ntrust store much more flexible, and gave the much-needed control over who\nto trust to the user.\nAndroid 4.x System Trust Store\nPrior to Android 4.0, the system trust store was a single file: /system/etc/\nsecurity/cacerts.bks, a Bouncy Castle (one of the cryptographic providers\nused in Android; see Chapter 5 for details) native keystore file. It contained\nall the CA certificates that Android trusts and was used both by system apps\nsuch as the email client and browser, and third-party apps. Because it resided\non the read-only system partition, it could not be changed even by system\napplications.\nAndroid 4.0 introduced a new, more flexible TrustedCertificateStore\nclass that allows for maintaining built-in trust anchors and adding new\nones. It still reads system-trusted certificates from /system/etc/security/, but\nadds two new, mutable locations to store CA certificates in /data/misc/\nkeychain/: the cacerts-added/ and cacerts-removed/ directories. Listing 6-7\nshows what their contents looks like:\n# ls -l /data/misc/keychain\ndrwxr-xr-x system system cacerts-added\ndrwxr-xr-x system system cacerts-removed\n-rw-r--r-- system system 81 pubkey_blacklist.txt\n-rw-r--r-- system system 7 serial_blacklist.txt\n# ls -l /data/misc/keychain/cacerts-added\n-rw-r--r-- system system 653 30ef493b.0u\n# ls -l /data/misc/keychain/cacerts-removed\n-rw-r--r-- system system 1060 00673b5b.0v\nListing 6-7: Contents of the cacerts-added/ and cacerts-removed/ directories\nEach file in these directories contains one CA certificate. The file\nnames may look familiar: they are based on the MD5 hashes of the CA\nsubject names (computed using OpenSSL’s X509_NAME_hash_old() function),\nNetwork Security and PKI 157\nas used in mod_ssl and other cryptographic software implemented using\nOpenSSL. This makes it easy to quickly find certificates without scanning\nthe entire store by directly converting the DN to a filename.\nAlso note the permissions of the\ndirectories: 0775 system system guaran-\ntees that only the system user is able to\nadd or remove certificates, but anyone\ncan read them. As expected, adding\ntrusted CA certificates is implemented\nby storing the certificate in the cacerts-\nadded/ directory under the appropriate\nfile name. The certificate stored in the\n30ef493b.0 file (u in Listing 6-7) will\nalso be displayed in the User tab of\nthe Trusted credentials system applica-\ntion (Settings4Security4Trusted\ncredentials).\nBut how are OS-trusted certificates\ndisabled? Because preinstalled CA cer-\ntificates are still stored in /system/etc/\nsecurity/ (which is mounted read-only), a\nCA is marked as not trusted by placing\na copy of its certificate in the cacerts-\nremoved/ directory. Re-enabling is per-\nformed by simply removing the file. In\nthis particular case, 00673b5b.0 (v in Figure 6-3: Preinstalled CA certifi-\nListing 6-7) is the thawte Primary Root cate marked as untrusted\nCA, shown as disabled in the System tab\n(see Figure 6-3).\nUsing the System Trust Store\nTrustedCertificateStore is not part of the Android SDK, but it has a wrapper\n(TrustedCertificateKeyStoreSpi) accessible via the standard JCA KeyStore API\nthat applications can use (see Listing 6-8).\nKeyStore ks = KeyStore.getInstance(\"AndroidCAStore\");u\nks.load(null, null);v\nEnumeration<String> aliases = ks.aliases();w\nwhile (aliases.hasMoreElements()) {\nString alias = aliases.nextElement();\nLog.d(TAG, \"Certificate alias: \" + alias);\nX09Certificate cert = (X509Certificate) ks.getCertificate(alias);x\nLog.d(TAG, \"Subject DN: \" + cert.getSubjectDN().getName());\nLog.d(TAG, \"Issuer DN: \" + cert.getIssuerDN().getName());\n}\nListing 6-8: Listing trusted certificates using AndroidCAStore\n158 Chapter 6\nTo get a list of the current trusted certificates, we:\n1. Create a KeyStore instance by specifying AndroidCAStore as the type\nparameter u.\n2. Call its load() method and pass null for both parameters v.\n3. Get a list of certificate aliases with the aliases() method w.\n4. Pass each alias to the getCertificate() method to get the actual certifi-\ncate object x.\nWhen you examine the output of this code, you’ll notice that certificate\naliases start with either the user: (for user-installed certificates) or system:\n(for preinstalled ones) prefix, followed by the subject’s hash value.\nThe AndroidCAStore KeyStore implementation lets us easily access the\nOS’s trusted certificates, but a real-world application would be more inter-\nested in whether it should trust a particular server certificate, not what the\ncurrent trust anchors are. Android makes this very easy by integrating the\nTrustedCertificateKeyStoreSpi with its JSSE implementation. The default\nTrustManagerFactory uses it to get a list of trust anchors, and thus automati-\ncally validates server certificates against the system’s currently trusted cer-\ntificates. Higher-level code that uses HttpsURLConnection or HttpClient (both\nbuilt on top of JSSE) should thus work without needing to worry about\ncreating and initializing a custom SSLSocketFactory.\nIn order to install our own CA certificate (such as one from a pri-\nvate enterprise CA) into the system trust store, we need to convert it\nto DER (binary) format and copy it to the device. On versions prior to\nAndroid 4.4.1, the certificate file needs to be copied to the root of exter-\nnal storage with a .crt or .cer extension. Android 4.4.1 and later uses the\nstorage access framework introduced in Android 4.4 and allow you to\nselect a certificate file from any storage backend that the device can\naccess, including integrated cloud providers like Google Drive. We can\nthen import the certificate using the system Settings app by selecting\nSettings4Personal4Security4Credential storage4Install from storage.\nA list of available certificate files is displayed and tapping on a filename\nbrings up the import dialog, as shown in Figure 6-4.\nThe imported certificate will be displayed in the User tab of the Trusted\ncredentials screen (see Figure 6-5). You can view certificate details by tap-\nping the list entry, and remove it by scrolling down to the bottom of the\ndetails screen and tapping the Remove button.\nNOTE If the certificate is successfully imported, the certificate file in external storage file will\nbe deleted on versions prior to Android 4.4.1.\nNetwork Security and PKI 159\nFigure 6-4: CA certificate import dialog Figure 6-5: User-imported CA\ncertificates\nBeginning with Android 4.4, the system displays a notification that\nwarns the user that network activity could be monitored if there are any\nuser-installed trusted certificates. SSL connection monitoring can be\naccomplished by using an intercepting proxy server that returns automati-\ncally generated certificates for the sites that the user is trying to access.\nAs long as those certificates are issued by a CA that Android trusts (such\nas the one manually installed in the trust store), most applications would\nnot know the difference between a connection to the original host and\nthe intercepting proxy (unless they are have pinned the target host; see\n“Certificate Pinning” on page 168 for details). A warning icon is shown\nin Quick Settings and next to the Security preference entry in the system\nSettings. When tapped, the notification displays the warning message\nshown in Figure 6-6.\n160 Chapter 6\nFigure 6-6: Network monitoring warning\nin Android 4.4\nSystem Trust Store APIs\nThird-party applications can prompt the user to import a needed cer-\ntificate into the system trust store by using the KeyChain API, introduced\nin Android 4.0 as well. (We’ll discuss the KeyChain API in Chapter 7.)\nBeginning with Android 4.4, device administrator applications can\nsilently install CA certificates in the system trust store if they hold the\nMANAGE_CA_CERTIFICATES system permission. (We’ll introduce device\nadministration and related APIs in Chapter 9.)\nOnce a CA certificate is imported into the system trust store, we can\nuse it to validate certificates using the JSSE TrustManager API as shown in\nListing 6-9.\n// Certificate chain including the end entity (server) certificate\n// and any intermediate issuers.\nX509Certificate[] chain = { endEntityCert };\nTrustManagerFactory tmf = TrustManagerFactory.getInstance(\"X509\");u\ntmf.init((KeyStore) null);v\nNetwork Security and PKI 161\nTrustManager[] tms = tmf.getTrustManagers();\nX509TrustManager xtm = (X509TrustManager) tms[0];w\nLog.d(TAG, \"checking chain with \" + xtm.getClass().getName());\nxtm.checkServerTrusted(chain, \"RSA\");x\nLog.d(TAG, \"chain is valid\");\nListing 6-9: Initializing a TrustManager with system trust anchors and validating a certificate\nTo do so, we first get the system PKIX (aliased to X509) TrustManagerFactory\n(u in Listing 6-9); initialize it using the system trust store by passing null to\nits init(KeyStore ks) method v; then get the first TrustManager implementation\nfor the specified algorithm (there is usually only one, but do check in produc-\ntion code) and cast it to the validation algorithm-specific X509TrustManager\ninterface w. Finally, we pass the certificate chain and the key exchange algo-\nrithm used (RSA, DHE_DSS, and so on) to the checkServerTrusted() method x.\nIf a chain leading to a trusted CA certifi cate can be built, validation passes\nand the method returns. If any of the certificates in the chain is expired or\ninvalid, or if the chain does not lead to a system trust anchor, the method\nwill throw a java.security.cert.CertificateException (or one of its subclasses).\nConnections established with SSLSocket and HttpsURLConnection perform similar\nvalidation automatically.\nThis works pretty well, but there is one major problem with this code: it\ndoes not check revocation. Android’s default TrustManager explicitly turns off\nrevocation when validating the certificate chain. So even if the certificate\nhad a CRL Distribution Point (CDP) extension, pointing to a valid CRL, or\nthe OCSP responder URI was included in the Authority Information Access\n(AIA) extension, and the certificate was actually revoked, it would still vali-\ndate in Android. What’s missing here is online revocation checking: the ability\nto dynamically fetch, cache, and update revocation information as needed,\nbased on information available in certificate extensions.\nCertificate Blacklisting\nInstead of using online revocation checks, Android relies on CA and end\nentity certificate blacklisting, which we will discuss in this section. Certificate\nblacklisting refers to the explicit blocking of certain certificates by verifiers,\nregardless of their state in the PKI’s repository. Blacklisting is not part of\nthe original PKI philosophy and is not defined in any of the related stan-\ndards. So why is it necessary in practice?\nIn a perfect world, a working PKI takes care of issuing, distributing,\nand revoking certificates as necessary. All that a system needs to verify the\nidentities of previously unknown machines and users are a few trust anchor\ncertificates: any end entity certificates encountered will be issued by one\nof the trusted CAs, or one of their subordinate issuing CAs (sub-CA). In\npractice, though, there are a number of issues, mostly related to handling\ncompromised keys. End entity certificates have a relatively short validity\nperiod (usually one year), which limits the time a compromised key can be\nexploited. However, CA certificates have very long validity (20 or more years\n162 Chapter 6\nis typical) and because CAs are implicitly trusted, a key compromise may\ngo undetected for quite some time. Recent breaches in top-level CAs have\nshown that CA key compromise is not a theoretical problem, and the conse-\nquences of a CA breach can be quite far-reaching.\nHandling CA Key Compromises\nProbably the biggest PKI issue is that revocation of root certificates is not\nreally supported. Most OSes and browsers come with a preconfigured set of\ntrusted CA certificates (dozens of them!) and when a CA certificate is com-\npromised, there are two main ways to handle it: tell users to remove it from\nthe trust store, or issue an emergency update that removes the affected cer-\ntificate. Expecting users to handle this is obviously unrealistic, so that leaves\nthe second option.\nWindows modifies OS trust anchors by distributing patches via Windows\nUpdate, and browser vendors simply release a new patch version. However,\neven if an update removes a CA certificate from the system trust store, a\nuser can still install it again, especially when presented with a “do this, or\nyou can’t access this site” ultimatum.\nTo make sure removed trust anchors are not brought back, the hashes\nof their public keys are added to a blacklist and the OS or browser rejects\nthem even if they are in the user trust store. This approach effectively\nrevokes CA certificates (within the scope of the OS or browser, of course)\nand addresses PKI’s inability to handle compromised trust anchors. However,\nit is not exactly ideal because even an emergency update takes some time to\nprepare, and after it’s released, some users won’t update right away no mat-\nter how often they’re nagged about it. (Fortunately, CA compromises are\nrelatively rare and widely publicized, so it seems to work well in practice—\nfor now, at least.) Other approaches have been proposed as well, but most\nare not widely used. We discuss some of the proposed solutions in “Radical\nSolutions” on page 167.\nHandling End Entity Key Compromises\nWhile CA breaches are fairly uncommon, end entity (EE) key compromise\noccurs much more often. Whether due to a server breach, stolen laptop,\nor a lost smart card, these compromises occur daily. Fortunately, modern\nPKI systems are designed with this in mind and CAs can revoke certificates\nand publish revocation information in the form of CRLs, or provide online\nrevocation status using OCSP.\nUnfortunately, this doesn’t work too well in the real world. Revocation\nchecking generally requires network access to a machine different from the\none we are trying to connect to, and as such has a fairly high failure rate.\nTo mitigate this, most browsers try to fetch fresh revocation information,\nbut if that effort fails for some reason, they simply ignore the error (soft-\nfail), or at best show some visual indication that revocation information is\nnot available.\nNetwork Security and PKI 163\nNOTE To address this problem, Google Chrome disables online revocation checks11 altogether,\nand now uses its update mechanism to proactively push revocation information to\nbrowsers, without requiring an application update or restart.12 Thus Chrome can\nhave an up-to-date local cache of revocation information, which makes certificate val-\nidation both faster and more reliable. This is can be considered yet another blacklist\n(Chrome calls it a CRL set), this time based on information published by each CA.\nThe browser vendor effectively managing revocation data on the user’s behalf is quite\nnovel; not everyone thinks it’s a good idea, but it has worked well so far.\nAn alternative to directly pushing revocation information as part of\nbrowser updates is OCSP stapling, formerly known as the TLS Certificate Status\nRequest extension.13 Instead of requiring clients to issue an OCSP request\nfor the server certificate, the relevant response is included (“stapled”) with\nthe SSL handshake via the Certificate Status Request extension response.\nBecause the response is signed by the CA, the client can trust it just as if\nit had fetched it directly from the CA’s OCSP server. If the server did not\ninclude an OCSP response in the SSL handshake, the client is expected to\nfetch one itself. OCSP stapling is supported by all major HTTP servers, but\nbrowser support is still patchy, especially on mobile versions where latency is\nan issue.\nAndroid Certificate Blacklisting\nAs we learned in “Android 4.x System Trust Store” on page 157, Android 4.0\nadded a management UI, as well as an SDK API, that allows for adding and\nremoving trust anchors to the system trust store. This didn’t quite solve PKI’s\nnumber one problem, though: aside from the user manually disabling a com-\npromised trust anchor, an OS update was still required to remove a compro-\nmised CA certificate. Additionally, because Android does not perform online\nrevocation checks when validating certificate chains, there was no way to\ndetect compromised end entity certificates, even if they have been revoked.\nTo solve this problem, Android 4.1 introduced certificate blacklists that\ncan be modified without requiring an OS update. There are now two sys-\ntem blacklists:\n• A public key hash blacklist (to handle compromised CAs)\n• A serial number blacklist (to handle compromised EE certificates)\nThe certificate chain validator component takes those two lists into\nconsideration when verifying websites or user certificates. Let’s look at how\nthis is implemented in a bit more detail.\n11. Adam Langley, Revocation checking and Chrome’s CRL, Feb 2012, https://www.imperialviolet\n.org/2012/02/05/crlsets.html\n12. Online revocation checks can still be enabled by setting the EnableOnlineRevocationChecks\noption to true (default is false).\n13. D. Eastlake 3rd, Transport Layer Security (TLS) Extensions: Extension Definitions, Section 8,\nJanuary 2011, http://tools.ietf.org/html/rfc6066#section-8\n164 Chapter 6\nAndroid uses a content provider to store OS settings in a system data-\nbase. Some of those settings can be modified by third-party apps holding\nthe necessary permissions, while some are reserved for the system and can\nonly be changed in the system Settings, or by another system application.\nThe settings reserved for the system are known as secure settings. Android 4.1\nadds two new secure settings under the following URIs:\n• content://settings/secure/pubkey_blacklist\n• content://settings/secure/serial_blacklist\nAs the names imply, the first one stores public key hashes of com-\npromised CAs and the second one a list of EE certificate serial numbers.\nAdditionally, the system server now starts a CertBlacklister component that\nregisters itself as a ContentObserver for the two blacklist URIs. Whenever a new\nvalue is written to any of the blacklist secure settings, the CertBlacklister is\nnotified and writes the value to a file on disk. The files are comprised of a\ncomma-delimited list of hex-encoded public key hashes or certificate serial\nnumbers. The files are:\n• Certificate blacklist: /data/misc/keychain/pubkey_blacklist.txt\n• Serial number blacklist: /data/misc/keychain/serial_blacklist.txt\nWhy write the files to disk when they are already available in the set-\ntings database? Because the component that actually uses the blacklists\nis a standard Java CertPath API class that doesn’t know anything about\nAndroid and its system databases. The certificate path validator class,\nPKIXCertPathValidatorSpi, is part of the Bouncy Castle JCA provider modi-\nfied to handle certificate blacklists, which are an Android-specific feature\nand not defined in the standard CertPath API. The PKIX certificate vali-\ndation algorithm that the class implements is rather complex, but what\nAndroid 4.1 adds is fairly straightforward:\n• When verifying an EE (leaf) certificate, check to see if its serial number\nis in the serial number blacklist. If so, return the same error (exception)\nas if the certificate has been revoked.\n• When verifying a CA certificate, check to see if the hash of its public\nkey is in the public key blacklist. If so, return the same error as if the\ncertificate has been revoked.\nNOTE Using the unqualified serial number to index blacklisted EE certificates could be a\nproblem if two or more certificates from different CAs happen to have the same serial\nnumber. In this case, blacklisting just one of the certificates will effectively blacklist\nall others with the same serial number. In practice, though, most public CAs use long\nand randomly generated serial numbers so the probability of collision is quite low.\nThe certificate path validator component is used throughout the whole\nsystem, so blacklists affect applications that use HTTP client classes, as well\nas the native Android browser and WebView. As mentioned above, modifying\nNetwork Security and PKI 165\nthe blacklists requires system permissions, so only core system apps can\nchange it. There are no apps in the AOSP source that actually call those\nAPIs, but a good candidate to manage blacklists are the Google services\ncomponents, available on “Google Experience” devices (that is, devices\nwith the Play Store client preinstalled). These manage Google accounts\nand access to Google services, and provide push-style notifications via\nGoogle Client Messaging (GCM). Because GCM allows for real-time\nserver-initiated push notifications, it’s a safe bet that those will be used\nto trigger certificate blacklist updates.\nReexamining the PKI Trust Model\nAndroid has taken steps to make its trust store more flexible by allowing\non-demand modification of both trust anchors and certificate blacklists\nwithout requiring a system update. While certificate blacklisting does make\nAndroid more resilient to some PKI-related attacks and vulnerabilities, it\ndoesn’t quite solve all problems related to using certificates issued by public\nCAs. We present some of those problems and the proposed solutions next.\nWe then conclude our discussion of PKI and SSL with a description of\nAndroid’s implementation of one of those solutions: certificate pinning.\nTrust Problems in Today’s PKI\nIn the highly unlikely case that you haven’t heard about it, the trustworthi-\nness of the existing public CA model has been severely compromised in\nrecent years. It has been suspect for a while, but recent high profile CA secu-\nrity breaches have brought this problem into the spotlight. Attackers have\nmanaged to issue certificates for a wide range of sites, including Windows\nUpdate servers and Gmail. Although not all were used (or at least they were\nnot detected) in real attacks, the incidents have shown just how much of cur-\nrent Internet technology depends on certificates.\nFraudulent certificates can be used for anything from installing malware\nto spying on Internet communication, all while fooling users into think-\ning that they are using a secure channel or installing a trusted executable.\nUnfortunately, better security for CAs is not a solution because major CAs\nhave willingly issued hundreds of certificates for unqualified names such\nas localhost, webmail, and exchange.14 Certificates issued for unqualified host\nnames can be used to launch a MITM attack against clients that accesses\ninternal servers using their unqualified name, thus making it easy to eaves-\ndrop on internal corporate traffic. And, of course, there is also the matter of\ncompelled certificate creation, where a government agency could compel a\nCA to issue a false certificate to be used for intercepting secure traffic.\nClearly the current PKI system, which is largely based on a preselected\nset of trusted CAs (whose certificates are preinstalled as trust anchors),\nis problematic, but what are some of the actual problems? There are dif-\nferent takes on this, but for starters, there are too many public CAs. The\n14. Electronic Frontier Foundation, Unqualified Names in the SSL Observatory, April 2011,\nhttps://www.eff.org/deeplinks/2011/04/unqualified-names-ssl-observatory\n166 Chapter 6\nElectronic Frontier Foundation’s SSL Observatory project15 has shown that\nmore than 650 public CAs are trusted by major browsers. Recent Android\nversions ship with more than 100 trusted CA certificates and until version 4.0,\nthe only way to remove a trusted certificate was through a vendor-initiated\nOS update.\nAdditionally, there is generally no technical restriction on which cer-\ntificates CAs can issue. As the Comodo and DigiNotar attacks, as well as\nthe recent ANNSI16 intermediate CA incident, have shown, anyone can\nissue a certificate for *.google.com (name constraints don’t apply to root\nCAs and don’t really work for a public CA). Furthermore, because CAs\ndon’t publicize the certificates they have issued, there is no way for site\noperators (in this case, Google) to know when someone issues a new, pos-\nsibly fraudulent certificate for one of their sites and take appropriate action\n(certificate transparency standards17 aim to address this). In short, with\nthe current system, if any of the built-in trust anchors are compromised, an\nattacker could issue a certificate for any site, and neither users accessing it\nnor the site’s owner would notice.\nRadical Solutions\nProposed solutions range from radical—scrap the whole PKI idea alto-\ngether and replace it with something new and better (DNSSEC is a usual\nfavorite); to moderate—use the current infrastructure but do not implicitly\ntrust CAs; to evolutionary—maintain compatibility with the current system\nbut extend it in ways that limit the damage of CA compromise.\nUnfortunately, DNSSEC is still not universally deployed, although the\nkey TLD domains have already been signed. Additionally, it is inherently\nhierarchical—with country top-level domains controlled by the respective\ncountries—and actually more rigid than PKI, so it doesn’t really fit the bill\ntoo well. Improving the current PKI situation is an area of active research,\nand other viable radical solutions have yet to emerge.\nMoving toward the moderate side, the SSH model has also been\nsuggested (sometimes called Trust on First Use, or TOFU). In this model,\nno sites or CAs are initially trusted, and users decide which site to trust\non first access. Unlike SSH however, the number of sites that you access\ndirectly or indirectly (via CDNs, embedded content, and so on) is virtually\nunlimited, and user-managed trust is quite unrealistic.\nConvergence and Trust Agility\nIn a similar vein but much more practical is Convergence.18 Convergence is\na system based on the idea of trust agility, defined as “the ability to easily\n15. Electronic Frontier Foundation, The EFF SSL Observatory, https://www.eff.org/observatory\n16. Agence nationale de la sécurité des systèmes d’information, French Network and Information\nSecurity Agency\n17. B. Laurie, A. Langley, and E. Kasper, Certificate Transparency, June 2013, http://tools.ietf.org/\nhtml/rfc6962\n18. Thoughtcrime Labs, Convergence, http://convergence.io/\nNetwork Security and PKI 167\nchoose who you trust and to revise that decision at any time.” It both abol-\nishes the browser (or OS) preselected trust anchor set, and recognizes that\nusers cannot be relied on to independently make trust decisions about all\nthe sites they visit. Trust decisions are delegated to a set of notaries that can\nvouch for a site by confirming that the certificate you receive from a site is\none they have seen before. If multiple notaries point out that the same cer-\ntificate as correct, users can be reasonably sure that it is genuine and there-\nfore trustworthy.\nConvergence is not a formal standard, but a working implementation\nhas been released, including a Firefox plugin (client) and server-side notary\nsoftware. While this system is promising, the number of available notaries\nis currently limited, and Google has publicly stated that it won’t add it to\nChrome. Additionally, it cannot currently be implemented as a browser\nextension, because Chrome does not allow third-party extensions to over-\nride the default certificate validation module.\nCertificate Pinning\nThat leads us to the current evolutionary solutions, which have been deployed\nto a fairly large user base, mostly courtesy of the Chrome browser. One is\ncertificate blacklisting, which we already discussed, and the other is certifi-\ncate pinning.\nCertificate pinning (or more accurately, public key pinning) takes a con-\nverse to the blacklisting approach: it whitelists the keys that are trusted to\nsign certificates for a particular site. Pinning was introduced in Google\nChrome version 13 in order to limit the CAs that can issue certificates for\nGoogle properties. It is implemented by maintaining a list of public keys\nthat are trusted to issue certificates for a particular DNS name. The list is\nconsulted when validating the certificate chain for a host, and if the chain\ndoesn’t include at least one of the whitelisted keys, validation fails. In prac-\ntice, the browser keeps a list of SHA-1 hashes of the SubjectPublicKeyInfo\n(SPKI) field of trusted certificates. Pinning the public keys instead of the\nactual certificates allows for updating host certificates without breaking\nvalidation and requiring pinning information updates.\nHowever, a hardcoded pin list doesn’t really scale and a couple of\nnew Internet standards have been proposed to help solve this scalability\nproblem: Public Key Pinning Extension for HTTP (PKPE)19 by Google\nand Trust Assertions for Certificate Keys (TACK)20 by Moxie Marlinspike.\nThe first one is simpler and proposes a new HTTP header (Public-Key-Pin,\nor PKP) that holds pinning information about a host’s certificate. The\nheader value can include public key hashes, pin lifetime, and a flag that\nspecifies whether pinning should be applied to subdomains of the current\nhost. Pinning information (or simply pins) is cached by the browser and\nused when making trust decisions until it expires. Pins are required to be\n19. C. Evans, C. Palmer, and R. Sleevi, Public Key Pinning Extension for HTTP, August 7, 2014,\nhttp://tools.ietf.org/html/draft-ietf-websec-key-pinning-20\n20. M. Marlinspike, Trust Assertions for Certificate Keys, January 7, 2013, http://tack.io/draft.html\n168 Chapter 6\ndelivered over a secure (SSL) connection, and the first connection that\nincludes a PKP header is implicitly trusted (or optionally validated against\npins built into the client). The protocol also supports an endpoint to\nreport failed validations via the report-uri directive and allows for a non-\nenforcing mode (specified with the Public-Key-Pins-Report-Only header),\nwhere validation failures are reported but connections are still allowed.\nThis makes it possible to notify host administrators about possible MITM\nattacks against their sites, so that they can take appropriate action.\nThe TACK proposal, on the other hand, is somewhat more complex\nand defines a new TLS extension (also called TACK) that carries pinning\ninformation signed with a dedicated TACK key. TLS connections to a pinned\nhostname require the server to present a “tack” containing the pinned key\nand a corresponding signature over the TLS server’s public key. Thus, both\npinning information exchange and validation are carried out at the TLS\nlayer. In contrast, PKPE uses the HTTP layer (over TLS) to send pinning\ninformation to clients, but also requires validation to be performed at the\nTLS layer, dropping the connection if validation against the pins fails.\nNow that we have an idea how pinning works, let’s see how it’s imple-\nmented on Android.\nCertificate Pinning in Android\nPinning is one of the many security enhancements introduced in Android 4.2.\nThe OS doesn’t come with any built-in pins, but instead reads them from a\nfile in the /data/misc/keychain/ directory (where user-added certificates and\nblacklists are stored). The file is simply called pins and is in the following\nformat (see Listing 6-10):\nhostname=enforcing|SPKI SHA512 hash, SPKI SHA512 hash,...\nListing 6-10: System pins file format\nHere, enforcing is either true or false and is followed by a list of SPKI\nSHA-512 hashes separated by commas. Note that there is no validity period,\nso pins are valid until deleted. The file is used not only by the browser, but\nsystem-wide by virtue of pinning being integrated in libcore. In practice, this\nmeans that the default (and only) system X509TrustManager implementation\n(TrustManagerImpl) consults the pin list when validating certificate chains.\nBut there’s a twist: the standard checkServerTrusted() method doesn’t\nconsult the pin list. Thus, any legacy libraries that do not know about cer-\ntificate pinning would continue to function exactly as before, regardless of\nthe contents of the pin list. This has probably been done for compatibility\nreasons and is something to be aware of: running on Android 4.2 or above\ndoesn’t necessarily mean that you get the benefit of system-level certificate\npins. The pinning functionality is exposed to third-party libraries and apps\nvia the new X509TrustManagerExtensions SDK class. It has a single method,\ncheckServerTrusted() (full signature shown in Listing 6-11) that returns a\nvalidated chain on success or throws a CertificateException if validation fails.\nNetwork Security and PKI 169\nList<X509Certificate> checkServerTrusted(X509Certificate[] chain, String authType, String host)\nListing 6-11: X509TrustManagerExtensions certificate validation method\nThe last parameter, host, is what the underlying implementation\n(TrustManagerImpl) uses to search the pin list for matching pins. If one is\nfound, the public keys in the chain being validated will be checked against\nthe hashes in the pin entry for that host. If none matches, validation will\nfail and you will get a CertificateException.\nWhat part of the system uses the new pinning functionality then?\nThe default SSL engine (JSSE provider), namely the client handshake\n(ClientHandshakeImpl), and SSL socket (OpenSSLSocketImpl) implementations\ncheck their underlying X509TrustManager and if it supports pinning, they per-\nform additional validation against the pin list. If validation fails, the con-\nnection won’t be established, thus implementing pin validation on the TLS\nlayer as required by the standards discussed in the previous section.\nThe pins file is not written directly by the OS. Its updates are triggered\nby a broadcast (android.intent.action.UPDATE_PINS) that contains the new pins\nin its extras. The extras contain the path to the new pins file, its new ver-\nsion (stored in /data/misc/keychain/metadata/version/), a hash of the current\npins, and a SHA512withRSA signature over all the above. The receiver of the\nbroadcast (CertPinInstallReceiver) then verifies the version, hash, and signa-\nture, and if valid, atomically replaces the current pins file with new content\n(the same procedure is used for updating the premium SMS numbers list).\nSigning the new pins ensures that they can only by updated by whoever con-\ntrols the private signing key. The corresponding public key used for valida-\ntion is stored as a system secure setting under the config_update_certificate key\n(usually in the secure table of the /data/data/com.android.providers.settings/\ndatabases/settings.db). (As of this writing, the pins file on Nexus devices con-\ntains more than 40 pin entries, which cover most Google properties, includ-\ning Gmail, YouTube, and Play Store servers.)\nsummary\nAndroid builds on standard Java APIs such as JSSE and CertPath to imple-\nment SSL connections and the required authentication mechanisms. Most of\nthe secure sockets functionality is provided by the largely native, OpenSSL-\nbased JSSE implementation, while certificate validation and trust store man-\nagement are implemented in Java. Android provides a shared system trust\nstore that can be managed via the Settings UI or the KeyStore API. All appli-\ncations that use SSL or certificate validation APIs inherit the system trust\nanchors, unless an app-specific trust store is explicitly specified. Certificate\nvalidation in Android does not use online revocation checking but relies\non the system certificate blacklist to detect compromised CA or end entity\ncertificates. Finally, recent versions of Android support system-level certifi-\ncate pinning in order to be able to constrain the set of certificates that are\nallowed to issue a server certificate for a particular host.\n170 Chapter 6",
    "question": "What is the role of certificate blacklisting and pinning in Android's implementation of secure communication and trust management?",
    "summary": "Android uses the Java Secure Socket Extension (JSSE) and CertPath APIs to implement SSL and secure communication. It provides a native OpenSSL-based JSSE implementation for most secure sockets functionality, while certificate validation and trust store management are handled in Java. Android has a shared system trust store that can be managed through the Settings app or KeyStore API, and it relies on certificate blacklists rather than online revocation checks to detect compromised certificates. Recent Android versions also support certificate pinning to restrict which certificates can be used for a specific host."
  },
  {
    "start": 108,
    "end": 119,
    "text": "7\nCREDENTI aL sTOR aGE\nThe previous chapter introduced PKI and the chal-\nlenges involved in managing trust. While the most\nprevalent use of PKI is for authenticating the entity\nyou connect to (server authentication), it’s also used\nto authenticate you to those entities (client authen-\ntic ation). Client authentication is mostly found in\nenterprise environments, where it is used for everything from desktop\nlogon to remotely accessing company servers. PKI-based client authenti-\ncation requires the client to prove that it possesses an authentication key\n(typically an RSA private key) by performing certain cryptographic opera-\ntions that the server can verify independently. Therefore, the security of\nclient authentication relies heavily on protecting authentication keys from\nunauthorized use.\nMost operating systems provide a system service that applications can\nuse to securely store and access authentication keys without having to imple-\nment key protection themselves. Android has had such a service since ver-\nsion 1.6, and it has improved significantly since Android 4.0.\nAndroid’s credential store can be used to store credentials for built-in\nfeatures such as Wi-Fi and VPN connectivity, as well as for third-party apps.\nApps can access the credential store via standard SDK APIs and use it to\nmanage their keys securely. Recent Android versions feature hardware-\nbacked key storage, which provides enhanced key protection. This chapter\ndiscusses the architecture and implementation of Android’s credential\nstore and introduces the public APIs that it provides.\nvPN and wi-Fi EaP Credentials\nVirtual Private Networks (VPNs) are the preferred way to offer remote access\nto private enterprise services. We’ll discuss VPNs and related technologies\nin more detail in Chapter 9, but simply put, a VPN allows a remote client\nto join a private network by creating an encrypted tunnel between it and\na public tunnel endpoint. VPN implementations differ in their use of\ntunneling technology, but all need to authenticate the client before they\nestablish a secure connection. While some VPNs use a shared key or pass-\nword for authentication, enterprise solutions often rely on PKI-based client\nauthentication.\nExtensible Authentication Protocol (EAP) is an authentication framework\nfrequently used in wireless networks and point-to-point (P2P) connections.\n(EAP is discussed in more detail in Chapter 9.) Like VPN, EAP can use\nmany different authentication methods, but EAP-Transport Layer Security\n(EAP-TLS) is preferred in enterprise environments, especially when a com-\npany PKI has already been deployed.\nAuthentication Keys and Certificates\nIn the case of both EAP-TLS and PKI-based VPNs, clients have an authen-\ntication key and are issued a matching certificate, often by the company\ncertificate authority (CA). Keys are sometimes stored in a portable, tamper-\nresistant device such as a smart card or USB token. This greatly increases\nsecurity because keys cannot be exported or extracted from the device and\nthus authentication requires both physical possession of the token and the\nknowledge of the associated PIN or passphrase.\nWhen the security policy allows using authentication keys that are\nnot protected by a hardware device, keys and associated certificates are\ntypically stored in the standard PKCS#12 file format. Private keys stored\nin PKCS#12 files are encrypted with a symmetric key derived from a user-\nsupplied password, and thus extracting the keys requires knowledge of the\npassword. Some applications use PKCS#12 files as secure containers and\nonly extract keys and certificates into memory when required, but typically\nthey’re imported into a system- or application-specific credential storage\nbefore use. This is how Android works as well.\n172 Chapter 7\nThe user-facing implementation\nof importing credentials on Android\nis rather simple: to import an authen-\ntication key and related certificates,\nusers copy their PKCS#12 files (and, if\nnecessary, any related CA certificates)\nto the device’s external storage (often\nan SD card) and select Install from\nstorage from the Security system set-\ntings screen. Android searches the\nroot of the external storage for match-\ning files (with the .pfx or .p12 exten-\nsions) and presents an import dialog\n(see Figure 7-1). If the correct pass-\nword is supplied, keys are extracted\nfrom the PKCS#12 file and imported\ninto the system credential store.\nThe System Credential Store\nThe system credential store is a system\nservice that encrypts imported cre-\ndentials before storing them on disk.\nThe encryption key is derived from Figure 7-1: PKCS#12 file password\na user-supplied password: a dedicated dialog\ncredential store protection password\nin pre-4.0 versions, or the device\nunlock swipe pattern, PIN, or password in post-4.0 versions of Android.\nAdditionally, the credential store system service regulates access to stored\ncredentials and guarantees that only apps explicitly granted access can\naccess keys.\nThe original credential store was introduced in Android 1.6 and was\nlimited to storing VPN and Wi-Fi EAP credentials. Only the system—not\nthird-party apps—could access stored keys and certificates. Additionally,\nthe only supported way to import credentials was to go through the system\nsettings UI outlined in the previous section, and no public APIs for creden-\ntial store management were available.\nAPIs for accessing the system credential store were first introduced\nin Android 4.0. The system credential store was later extended to support\nhardware-backed credential storage and to offer not only shared system\nkeys, but app-private keys as well. Table 7-1 shows a summary of the major\ncredential store enhancements added in each Android version. We’ll intro-\nduce these enhancements and the related APIs in the following sections.\nCredential Storage 173\nTable 7-1: Credential Store Feature Progression\nAndroid version API level Credential store changes\n1 .6 4 Added credential store for VPN and Wi-Fi .\n4 .0 14 Added public API for credential store (KeyChain API) .\n4 .1 16 Added the ability to generate and use keys without\nexporting them . Introduced keymaster HAL module and\ninitial support for hardware-backed RSA key storage .\n4 .3 18 Added support for generating and accessing app-\nprivate keys using the AndroidKeyStore JCA provider,\nand APIs to check whether the device supports\nhardware-backed key storage for RSA keys .\n4 .4 19 Added ECDSA and DSA support to the\nAndroidKeyStore JCA provider .\nCredential storage Implementation\nWe now know that Android can encrypt imported credentials and manage\naccess to them. Let’s see how this is implemented under the hood.\nThe keystore Service\nCredential storage management in Android was originally implemented by\na single native daemon called keystore. Its functionality was initially limited\nto storing arbitrary blobs in encrypted form and verifying the credential\nstore password, but it was extended with new features as Android evolved.\nIt offered a local socket-based interface to its clients, and each client was\nresponsible for managing their own state and socket connections. The key-\nstore daemon was replaced with a centralized Binder service in Android 4.3\nin order to better integrate it with other framework services and facilitate\nextension. Let’s see how this keystore service works.\nThe keystore service is defined in init.rc, as shown in Listing 7-1.\nservice keystore /system/bin/keystore /data/misc/keystore\nclass main\nuser keystore\ngroup keystore drmrpc\nListing 7-1: keystore service definition in init .rc\nAs you can see, the keystore service runs as a dedicated keystore user and\nstores its files in /data/misc/keystore/. Let’s peek into /data/misc/keystore/ first.\nIf you’re using a single-user device, such as a phone, you will only find a\nsingle user_0/ directory inside the keystore/ directory (see Listing 7-2, time-\nstamps removed), but on multi-user enabled devices you should find one\ndirectory for each Android user.\n174 Chapter 7\n# ls -la /data/misc/keystore/user_0\n-rw------- keystore keystore 84 .masterkey\n-rw------- keystore keystore 980 1000_CACERT_cacert\n-rw------- keystore keystore 756 1000_USRCERT_test\n-rw------- keystore keystore 884 1000_USRPKEY_test\n-rw------- keystore keystore 724 10019_USRCERT_myKey\n-rw------- keystore keystore 724 10019_USRCERT_myKey1\nListing 7-2: Sample contents of the keystore directory on a single-user device\nIn this example, each file name consists of the UID of the app that\ncreated it (1000 is system), the entry type (CA certificate, user certificate,\nor private key), and the key name (alias), all connected with underscores.\nSince Android 4.3, system and app-private keys are supported as well, and\nthe UID reflects the Android user ID as well as the app ID. On multi-user\ndevices the user ID is UID / 100000, as discussed in Chapter 4.\nIn addition to system or app-owned key blobs, there is also a single\n.masterkey file, which we’ll discuss shortly. When an app that owns store-\nmanaged keys is uninstalled for a user, only keys created by that user are\ndeleted. If an app is completely removed from the system, its keys are\ndeleted for all users. Because key access is tied to the app ID, this feature\nprevents a different app that happens to get the same UID from accessing\nan uninstalled app’s keys. (Keystore reset, which deletes both key files and\nthe master key, also affects only the current user.)\nIn the default software-based implementation, these files have the fol-\nlowing contents (contents may be different for hardware-backed implemen-\ntations; instead of encrypted key material, they often store only a reference\nto hardware-managed key objects):\n• The master key (stored in .masterkey) is encrypted with a 128-bit AES key\nderived from the screen unlock password by applying the PBKDF2 key\nderivation function with 8192 iterations and a randomly generated 128-\nbit salt. The salt is stored in the .masterkey file’s info header.\n• All other files store key blobs. A key blob (binary large object) con-\ntains a serialized, optionally encrypted key along with some data\nthat describes the key (metadata). Each keystore key blob contains a\nmetadata header, the initial vector (IV) used for encryption, and a\nconcatenation of an MD5 hash value of the data with the data itself,\nencrypted with the 128-bit AES master key in CBC mode. Or more\nconcisely: metadata || Enc(MD5(data) || data).\nIn practice, this architecture means that the Android keystore is pretty\nsecure for a software solution. Even if you had access to a rooted device\nand managed to extract the key blobs, you would still need the keystore\npassword to derive the master key. Trying different passwords in an attempt\nto decrypt the master key would require at least 8192 iterations to derive a\nkey, which is prohibitively expensive. In addition, because the derivation\nfunction is seeded with a 128-bit random number, pre-calculated password\ntables cannot be used. However, the MD5-based integrity mechanism used\nCredential Storage 175\ndoes not employ a standard Message Authentication Code (MAC) algo-\nrithm such as HMAC and is a remnant of the original implementation. It’s\nkept for backward compatibility, but may be replaced in a future version.\nKey Blob Versions and Types\nBeginning with Android 4.1, two fields were added to key blobs: version and\ntype. The current version (as of Android 4.4) is 2 and keys blobs are auto-\nmatically upgraded to the latest version when an application first accesses\nthem. As of this writing, the following key types are defined:\n• TYPE_ANY\n• TYPE_GENERIC\n• TYPE_MASTER_KEY\n• TYPE_KEY_PAIR\nTYPE_ANY is a meta key type that matches any key type. TYPE_GENERIC is\nused for key blobs that are saved using the original get/put interface, which\nstores arbitrary binary data, and TYPE_MASTER_KEY is, of course, only used for\nthe keystore master key. The TYPE_KEY_PAIR type is used for key blobs created\nusing the generate_keypair and import_keypair operations, newly introduced\nin Android 4.1. We’ll discuss these in the “keymaster Module and keystore\nService Implementation” section.\nAndroid 4.3 is the first version to use the flags field of key blobs. It uses\nthis field to distinguish encrypted (the default) from non-encrypted key\nblobs. Key blobs that are protected by a hardware-based implementation\n(available on some devices) are stored without additional encryption.\nAccess Restrictions\nKey blobs are owned by the keystore user, so on a regular (not rooted)\ndevice, you need to go through the keystore service in order to access them.\nThe keystore service applies the following access restrictions:\n• The root user cannot lock or unlock the keystore, but can access\nsystem keys.\n• The system user can perform most keystore management operations\n(like initialization, reset, and so on) in addition to storing keys.\nHowever, the system user cannot use or retrieve other users’ keys.\n• Non-system users can insert, delete, and access keys, but can only see\ntheir own keys.\nNow that we know what the keystore service does, let’s look at the actual\nimplementation.\nkeymaster Module and keystore Service Implementation\nWhile the original daemon-based implementation included both key blob\nmanagement and encryption in a single binary, Android 4.1 introduced a\n176 Chapter 7\nnew keymaster Hardware Abstraction Layer (HAL) system module responsible\nfor generating asymmetric keys and signing/verifying data without the\nneed to export the keys first.\nThe keymaster module is meant to decouple the keystore service from the\nunderlying asymmetric key operations implementation and to allow for eas-\nier integration of device-specific, hardware-backed implementations. A typi-\ncal implementation would use a vendor-provided library to communicate\nwith the crypto-enabled hardware and provide a “glue” HAL library, which\nthe keystore daemon links with.\nAndroid also comes with a default softkeymaster module that performs\nall key operations in software only (using the system OpenSSL library).\nThis module is used on the emulator and included in devices that lack\ndedicated cryptographic hardware. The key size of generated keys was\ninitially fixed at 2048 bits and only RSA keys were supported. Android 4.4\nadded support for specifying key size, as well as the Digital Signature\nAlgorithm (DSA) and Elliptic Curve DSA (ECDSA) algorithms and their\nrespective keys.\nAs of this writing, the default softkeymaster module supports RSA and\nDSA keys with sizes between 512 and 8192 bits. If the key size is not explic-\nitly specified, DSA keys default to 1024 bits, and RSA ones to 2048 bits. For\nEC keys, the key size is mapped to a standard curve with the respective field\nsize. For example, when 384 is specified as the key size, the secp384r1 curve\nis used to generate keys. Currently the following standard curves are sup-\nported: prime192v1, secp224r1, prime256v1, secp384r1, and secp521r1. Keys for\neach of the supported algorithms can be imported as well if they are con-\nverted to the standard PKCS#8 format.\nThe HAL module interface is defined in hardware/keymaster.h and\ndefines the operations listed below.\n• generate_keypair\n• import_keypair\n• sign_data\n• verify_data\n• get_keypair_public\n• delete_keypair\n• delete_all\nAll asymmetric key operations exposed by the keystore service are imple-\nmented by calling the system keymaster module. Thus if the keymaster HAL\nmodule is backed by a hardware cryptographic device, all upper-level com-\nmands and APIs that use the keystore service interface automatically get to\nuse hardware crypto. Aside from asymmetric key operations, all other cre-\ndential store operations are implemented by the keystore system service and\ndo not depend on HAL modules. The service registers itself to Android’s\nServiceManager with the android.security.keystore name and is started at boot.\nUnlike most Android services, it is implemented in C++ and the implemen-\ntation resides in system/security/keystore/.\nCredential Storage 177\nNexus 4 Hardware-Backed Implementation\nTo give some perspective to the whole “hardware-backed” idea, let’s briefly\ndiscuss how it’s implemented on the Nexus 4. The Nexus 4 is based on\nQualcomm’s Snapdragon S4 Pro APQ8064 system on a chip (SoC). Like\nmost recent ARM SoCs, it is TrustZone-enabled, with Qualcomm’s Secure\nExecution Environment (QSEE) implemented on top of that.\nARM’s TrustZone technology provides two virtual processors backed by\nhardware-based access control, which allows a SoC system to be partitioned\ninto two virtual “worlds”: the Secure world for the security subsystem, and the\nNormal world for everything else. Applications running in the Secure world\nare referred to as trusted applications and can only be accessed by Normal\nworld applications (which the Android OS and apps run in) through a lim-\nited interface that they explicitly expose. Figure 7-2 shows a typical software\nconfiguration for a TrustZone-enabled system.\nNormal World Secure World\nARM CPU with TrustZone\n178 Chapter 7\napp\nTrusted\napp\nTrusted\napp\nTrusted\nApps w/\nSecure OS\nSupport\nNormal\n(e.g., keystore)\napps\nTZ API/\ndriver Secure OS\nRich OS\nMonitor\n(Android)\nFigure 7-2: TrustZone software architecture\nAs usual, implementation details are quite scarce, but on the Nexus 4\nthe only way to interact with trusted applications is through the controlled\ninterface that the /dev/qseecom device provides. Android applications that\nwish to interact with the QSEE load the proprietary libQSEEComAPI.so\nlibrary and use its functions to send commands to the QSEE.\nAs with most other SEEs, the QSEECom communication API is quite\nlow level and basically only allows for exchanging opaque blobs (typically\ncommands and replies), the contents of which depend entirely on the\nsecure app you’re communicating with. In the case of the Nexus 4 keymaster,\nthe commands used are: GENERATE_KEYPAIR, IMPORT_KEYPAIR, SIGN_DATA, and\nVERIFY_DATA. The keymaster implementation merely creates command struc-\ntures, sends them via the QSEECom API, and parses the replies. It does not\ncontain any cryptographic code.\nOne interesting detail is that the QSEE keystore trusted app (which\nmay not be a dedicated app, but part of a more general-purpose trusted\napplication) doesn’t return simple references to protected keys; it uses pro-\nprietary encrypted key blobs. In this model, the only thing that is actually\nprotected by hardware is some form of master key-encryption key (KEK);\nuser-generated keys are only indirectly protected by being encrypted with\nthe KEK.\nThis method allows for a practically unlimited number of protected keys,\nbut it has the disadvantage that if the KEK is compromised, all externally\nstored key blobs are compromised as well. (Of course, the actual implemen-\ntation might generate a dedicated KEK for each key blob created, or the\nkey can be fused in hardware; either way no details are available about the\ninternal implementation.) That said, Qualcomm keymaster key blobs are\ndefined in AOSP code (shown in Listing 7-3) and the definition suggests\nthat private exponents are encrypted using AES u, most probably in CBC\nmode, with an added HMAC-SHA256 v to check encrypted data integrity.\n#define KM_MAGIC_NUM (0x4B4D4B42) /* \"KMKB\" Key Master Key Blob in hex */\n#define KM_KEY_SIZE_MAX (512) /* 4096 bits */\n#define KM_IV_LENGTH (16) u/* AES128 CBC IV */\n#define KM_HMAC_LENGTH (32) v/* SHA2 will be used for HMAC */\nstruct qcom_km_key_blob {\nuint32_t magic_num;\nuint32_t version_num;\nuint8_t modulus[KM_KEY_SIZE_MAX];w\nuint32_t modulus_size;\nuint8_t public_exponent[KM_KEY_SIZE_MAX];x\nuint32_t public_exponent_size;\nuint8_t iv[KM_IV_LENGTH];y\nuint8_t encrypted_private_exponent[KM_KEY_SIZE_MAX];z\nuint32_t encrypted_private_exponent_size;\nuint8_t hmac[KM_HMAC_LENGTH];{\n};\nListing 7-3: QSEE keymaster blob definition (for Nexus 4)\nAs you can see in Listing 7-3, the QSEE key blob contains the key mod-\nulus w, public exponent x, the IV y used for private exponent encryption,\nthe private exponent itself z, and the HMAC value {.\nSince the QSEE used in the Nexus 4 is implemented using the TrustZone\nfunctions of the processor, in this case the “hardware” of the hardware-\nbacked credential store is simply the ARM SoC. Are other implementations\npossible? Theoretically, a hardware-backed keymaster implementation does\nnot need to be based on TrustZone. Any dedicated device that can gener-\nate and store keys securely can be used, with the usual candidates being\nembedded Secure Elements (SE) and Trusted Platform Modules (TPMs).\nCredential Storage 179\nWe’ll discuss SEs and other tamper-resistant devices in Chapter 11, but\nas of this writing no mainstream Android devices have dedicated TPMs\nand recent flagship devices have begun shipping without embedded SEs.\nTherefore, implementations using dedicated hardware are unlikely to show\nup in mainstream devices.\nNOTE Of course, all mobile devices have some form of Universal Integrated Circuit Card\n(UICC), colloquially known as a SIM card, which typically can generate and store\nkeys, but Android still doesn’t have a standard API to access the UICC even though\nvendor firmware often includes one. So while one could theoretically implement a\nUICC-based keymaster module, it would only work on custom Android builds and\nwould depend on network operators to include support in their UICCs.\nFramework Integration\nWhile managing credentials securely is the key feature of Android’s creden-\ntial storage, its main purpose is to provide this service seamlessly to the rest\nof the system. Let’s briefly discuss how it integrates with the rest of Android\nbefore presenting the public APIs that are available for third-party apps.\nBecause the keystore service is a standard Binder service, in order to use\nit potential clients only need to get a reference to it from the ServiceManager.\nThe Android framework provides the singleton android.security.KeyStore\nhidden class, which is responsible for obtaining a reference to the keystore\nservice and serves as a proxy to the IKeystoreService interface it exposes. Most\nsystem applications, such as the PKCS#12 file importer (see Figure 7-1), and\nthe implementations of some of the public APIs use the KeyStore proxy class\nto communicate with the keystore service.\nIn the case of lower-level libraries that are not part of the Android\nframework, such as native libraries and JCA classes in the core Java library,\nintegration with the system credential store is provided indirectly through\nan OpenSSL engine called the Android keystore engine.\nAn OpenSSL engine is a pluggable cryptographic module implemented\nas a dynamic shared library. The keystore engine is one such module that\nimplements all of its operations by calling the system keymaster HAL mod-\nule. It supports only loading and signing with RSA, DSA, or EC private\nkeys, but that’s enough to implement key-based authentication (such as\nSSL client authentication). The keystore engine makes it possible for native\ncode that uses OpenSSL APIs to use private keys saved in the system creden-\ntial store without the need for code modifications. It also has a Java wrapper\n(OpenSSLEngine), which is used to implement access to keystore-managed pri-\nvate keys in the JCA framework.\n180 Chapter 7\nPublic aPIs\nWhile system applications can access the keystore daemon AIDL interface\ndirectly or through the android.security.KeyStore proxy class, those interfaces\nare too closely coupled with the implementation to be part of the public\nAPI. Android provides higher-level abstractions for third-party apps with\nthe KeyChain API and the AndroidKeyStoreProvider JCA provider. We’ll show\nhow these APIs are used and provide some implementation details in the\nfollowing sections.\nThe KeyChain API\nAndroid has offered a system-wide credential store since version 1.6, but\nit was only usable by built-in VPN and Wi-Fi EAP clients. It was possible to\ninstall a private key/certificate pair using the Settings app, but the installed\nkeys were not accessible by third-party applications.\nAndroid 4.0 introduced SDK APIs for both trusted certificate manage-\nment and secure credential storage via the KeyChain class. This feature was\nextended in Android 4.3 to support the newly introduced hardware-backed\nfeatures. We’ll discuss how it’s used and review its implementation in the\nfollowing sections.\nThe KeyChain Class\nThe KeyChain class is quite simple: it offers six public static methods, which\nare sufficient for most certificate- and key-related tasks. We’ll look at how\nto install a private key/certificate pair and then use that pair to access the\ncredential-store-managed private key.\nThe KeyChain API lets you install a private key/certificate pair bundled\nin a PKCS#12 file. The KeyChain.createInstallIntent() factory method is the\ngateway to this functionality. It takes no parameters and returns a system\nintent that can parse and install keys and certificates. (This is actually the\nsame intent that is used internally by the Settings system app.)\nInstalling a PKCS#12 File\nTo install a PKCS#12 file, you have to read it to a byte array, store it under\nthe EXTRA_PKCS12 key in the intent’s extras, and start the associated activity\n(see Listing 7-4):\nIntent intent = KeyChain.createInstallIntent();\nbyte[] p12 = readFile(\"keystore-test.pfx\");\nintent.putExtra(KeyChain.EXTRA_PKCS12, p12);\nstartActivity(intent);\nListing 7-4: Installing a PKCS#12 file using the KeyChain API\nCredential Storage 181\nThis should prompt you for\nthe PKCS#12 password in order\nto extract and parse the key and\ncertificate. If the password is cor-\nrect, you should be prompted for\na certificate name, as shown in\nFigure 7-3. If the PKCS#12 has a\nfriendly name attribute, it will be\nshown as the default; if not, you’ll\njust get a long hexadecimal hash\nstring. The string you enter here is\nthe key or certificate alias you can\nuse later to look up and access keys\nvia the KeyChain API. You should be\nprompted to set a lock screen PIN\nor password to protect the creden-\ntial storage if you haven’t already\nset one.\nUsing a Private Key\nTo use a private key stored in the\nsystem credential store, you need\nto obtain a reference to the key Figure 7-3: Private key and certificate\nusing its alias and request key access import dialog\npermission from the user. If you’ve\nnever accessed a key before and don’t\nknow its alias, you need to first call KeyChain.choosePrivateKeyAlias() and pro-\nvide a callback implementation that receives the selected alias as shown in\nListing 7-5.\npublic class KeystoreTest extends Activity implements OnClickListener,\nKeyChainAliasCallback {\n@Override\npublic void onClick(View v) {\nKeyChain.choosePrivateKeyAlias(uthis, v(KeyChainAliasCallback)this,\nwnew String[] { \"RSA\" }, xnull, ynull, z-1, {null);\n}\n@Override\npublic void alias(final String alias) {|\nLog.d(TAG, \"Thread: \" + Thread.currentThread().getName());\nLog.d(TAG, \"selected alias: \" + alias);\n}\n}\nListing 7-5: Using a private key stored in the system credential store\nThe first parameter u is the current context; the second v is the call-\nback to invoke; and the third and fourth specify the acceptable keys w (RSA,\nDSA, or null for any) and acceptable certificate issuers x for the certificate\n182 Chapter 7\nmatching the private key. The next\ntwo parameters are the host y and\nport number z of the server request-\ning a certificate, and the last one {\nis the alias to preselect in the key\nselection dialog. We leave all but\nthe key type as unspecified (null or\n-1) here in order to be able to select\nfrom all available certificates. Note\nthat the alias() | callback will not\nbe called on the main thread, so\ndon’t try to directly manipulate the\nUI from it. (It’s called on a binder\nthread.)\nUsing the key requires user\nauthorization, so Android should\ndisplay a key selection dialog (see\nFigure 7-4) which also serves to\ngrant access to the selected key.\nOnce the user has granted key\naccess to an app, it can look up\nthat key directly without going\nthrough the key selection dialog.\nListing 7-6 shows how to use the Figure 7-4: Key selection dialog\nKeyChain API to obtain a reference to\na private key managed by the system\nkeystore.\nPrivateKey pk = KeyChain.getPrivateKey(context, alias);u\nX509Certificate[] chain = KeyChain.getCertificateChain(context, alias);v\nListing 7-6: Getting a key instance and its certificate chain\nTo get a reference to a private key, you need to call the KeyChain\n.getPrivateKey() u method, passing it the key alias name received in the\nprevious step. If you try to call this method on the main thread, you’ll get\nan exception, so make sure to call it from a background thread like the one\ncreated by the AsyncTask utility class. The getCertificateChain() v method\nreturns the certificate chain associated with the private key (see Listing 7-6). If\na key or certificate with the specified alias doesn’t exist, the getPrivateKey()\nand getCertificateChain() methods will return null.\nInstalling a CA Certificate\nInstalling a CA certificate is not very different from installing a PKCS#12\nfile. To do so, load the certificate in a byte array and pass it as an extra to\nthe install intent under the EXTRA_CERTIFICATE key, as shown in Listing 7-7.\nCredential Storage 183\nIntent intent = KeyChain.createInstallIntent();\nintent.putExtra(KeyChain.EXTRA_CERTIFICATE, cert);\nstartActivity(intent);\nListing 7-7: Installing a CA certificate using the KeyChain API\nAndroid parses the certificate, and if its Basic Constraints extension is\nset to CA:TRUE, considers it a CA certificate and imports it into the user trust\nstore. You need to authenticate in order to import the certificate.\nUnfortunately, the import dialog (see Figure 7-5) shows neither the cer-\ntificate DN nor its hash value. The user has no way of knowing what they’re\nimporting until it’s done. Very few people bother to check a certificate’s\nvalidity, so this could be a potential security threat because malicious appli-\ncations could trick people into installing rogue certificates.\nAfter the certificate is imported, it should show up in the Trusted creden-\ntials screen’s User tab (Settings4Security4Trusted credentials). Tap the\ncertificate entry to display a details dialog where you can check the subject,\nissuer, validity period, serial number, and SHA-1/SHA-256 fingerprints. To\nremove a certificate, press the Remove button (see Figure 7-6).\nFigure 7-5: CA certificate import dialog Figure 7-6: Certificate details dialog\n184 Chapter 7\nDeleting Keys and User Certificates\nWhile you can delete individual CA certificates, there is no way to delete\nindividual keys and user certificates, although the Clear credentials option\nin the Credential Storage section of the security settings will delete all keys\nand user certificates.\nNOTE As long as you have keys in the credential store, you can’t remove the screen lock\nbecause it is used to protect access to the keystore.\nGetting Information about Supported Algorithms\nAndroid 4.3 added two methods to the KeyChain class related to the newly\nintroduced hardware support. According to the API documentation,\nisBoundKeyAlgorithm(String algorithm) “returns true if the current device’s\nKeyChain imple mentation binds any PrivateKey of the given algorithm to the\ndevice once imported or generated.” In other words, if you pass the string\nRSA to this method, it should return true if generated or imported RSA keys\nhave hardware protection and cannot simply be copied off the device. The\nisKeyAlgorithmSupported(String algorithm) method should return true if the\ncurrent KeyChain implementation supports keys of the specified type (RSA,\nDSA, EC, and so on).\nWe’ve introduced the main features of the KeyChain API. Now let’s look\nat the underlying Android implementation.\nKeyChain API Implementation\nThe public KeyChain class and supporting interfaces reside in the android\n.security Java package. The package also contains two hidden AIDL files:\nIKeyChainService.aidl and IKeyChainAliasCallback. This is a hint that the\nactual keystore functionality, like most Android OS services, is imple-\nmented as a remote service to which the public APIs bind. The inter-\nface IKeyChainAliasCallback is called when you select a key via KeyStore\n.choosePrivateKeyAlias(), so it’s of little interest. IKeyChainService.aidl\ndefines the actual system interface that services use, so we’ll describe it\nin more detail.\nThe IKeyChainService interface has one implementation, the KeyChainService\nclass in the KeyChain system application. In addition to KeyChainService,\nthe application includes an activity, KeyChain, and a broadcast receiver,\nKeyChainBroadcastReceiver. The KeyChain application has its sharedUserId is set\nto android.uid.system and therefore inherits all privileges of the system user.\nThis allows its components to send management commands to the native\nkeystore service. Let’s examine the service first.\nThe KeyChainService is a wrapper for the android.security.KeyStore proxy\nclass that directly communicates with the native keystore service. It provides\nfour main services:\n• Keystore management: methods for getting private keys and certificates.\n• Trust store management: methods for installing and deleting CA certifi-\ncates in the user trust store.\nCredential Storage 185\n• Key and trust store initialization: a reset() method that deletes all key-\nstore entries, including the master key, thus returning the keystore\nto an uninitialized state; it also removes all user-installed trusted\ncertificates.\n• Methods for querying and adding entries to the key access grant database.\nControlling Access to the Keystore\nSince the KeyChain application runs as the system user, any process that binds\nto its remote interface would technically be able to perform all key and\ntrust store operations. To prevent this, the KeyChainService imposes addi-\ntional access control on its users by controlling access to credential store\noperations based on the caller’s UID and using a key access grant database\nto regulate access to individual keys. Only the system user can delete a CA\ncertificate and reset the key and trust stores (operations typically called via\nthe Settings app’s UI, which runs as system). By the same token, only the\nsystem user or the certificate installer application (com.android.certinstaller\npackage) can install a trusted CA certificate.\nControlling access to individual keys in the credential store is a little bit\nmore interesting than operation restrictions. The KeyChainService maintains\na grants database (in /data/data/com.android.keychain/databases/grants.db)\nthat maps UIDs to the key aliases they are allowed to use. Let’s have a look\ninside in Listing 7-8.\n# sqlite3 grants.db\nsqlite> .schema\n.schema\nCREATE TABLE android_metadata (locale TEXT);\nCREATE TABLE grants (alias STRING NOT NULL, uid INTEGER NOT NULL, UNIQUE (alias,uid));\nsqlite> select * from grants;\nselect * from grants;\nutest|10044v\nwkey1|10044\nListing 7-8: Schema and contents of the grants database\nIn this example, the application with UID 10044 v is granted access to\nthe keys with the test u and key1 w aliases.\nEach call to getPrivateKey() or getCertificate() is subject to a check\nagainst the grants database, and results in an exception if a grant for the\nrequired alias is not found. As stated before, KeyChainService has APIs for\nadding and querying grants, and only the system user can call them. But\nwho is responsible for actually granting and revoking access?\nRemember the private key selection dialog (Figure 7-4)? When you call\nKeyChain.choosePrivateKeyAlias(), it starts the KeyChainActivity (introduced\nabove), which checks to see if the keystore is unlocked; if so, KeyChainActivity\nshows the key selection dialog. Clicking the Allow button returns to the\nKeyChainActivity, which then calls KeyChainService.setGrant() with the selected\n186 Chapter 7\nalias, adding it to the grants database. Thus, even if the activity requesting\naccess to a private key has the needed permissions, the user must unlock\nthe keystore and explicitly authorize access to each individual key.\nBesides controlling private key storage, the KeyChainService also offers\ntrust store management by using the newly added TrustedCertificateStore\nclass (part of libcore). This class provides both the ability to add user-installed\ntrusted CA certificates and remove (mark as not trusted) system (preinstalled)\nCAs. Chapter 6 discusses the details of its implementation.\nKeyChainBroadcastReceiver\nThe last component of the KeyChain app is the KeyChainBroadcastReceiver.\nIt listens for the android.intent.action.PACKAGE_REMOVED system broadcast\nand simply forwards control to the KeyChainService. On receiving the\nPACKAGE_REMOVED action, the service does some grant database maintenance:\nit goes through all entries and deletes any referencing packages that are\nno longer available (that is, ones that have been uninstalled).\nCredential and Trust Store Summary\nAndroid 4.0 introduces a new service that grants access to both the sys-\ntem keystore (managed by the keystore system service) and the trust store\n(managed by the TrustedCertificateStore class) that backs the KeyChain API\nexposed in the public SDK. This feature makes it possible to control access\nto keys based on both the calling process’s UID and the key access grant\ndatabase, thus allowing for fine-grained, user-driven control over which\nkeys each application can access. The components of Android’s credential\nand trust store and their relationship are presented in Figure 7-7.\n/etc/security/cacerts/\nCertInstaller TrustedCertificateStore\n/data/misc/keychain/\nkeystore\nKeyChain KeyChainService\nsystem service\nKeyChainActivity grant.db /data/misc/keystore/\nFigure 7-7: System credential store components\nCredential Storage 187\nAndroid Keystore Provider\nWhile the KeyChain API introduced in Android 4.0 allows applications to\nimport keys into the system credential store, those keys are owned by the\nsystem user and any application can request access to them. Android 4.3\nadds support for app-private keys, which allows any app to generate and save\nprivate keys that can only be accessed and used by itself and are not visible\nto other apps.\nInstead of introducing yet another Android-specific API, keystore access\nis exposed via standard JCA APIs, namely java.security.KeyPairGenerator and\njava.security.KeyStore. Both are backed by a new Android JCA provider,\nAndroidKeyStoreProvider, and are accessed by passing AndroidKeyStore as the\ntype parameter of the respective factory methods. Listing 7-9 shows how to\ngenerate and access RSA keys using the AndroidKeyStoreProvider.\n// generate a key pair\nCalendar notBefore = Calendar.getInstance()\nCalendar notAfter = Calendar.getInstance();\nnotAfter.add(1, Calendar.YEAR);\nKeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(ctx)\n.setAlias(\"key1\")\n.setKeyType(\"RSA\")\n.setKeySize(2048)\n.setSubject(new X500Principal(\"CN=test\"))\n.setSerialNumber(BigInteger.ONE).setStartDate(notBefore.getTime())\n.setEndDate(notAfter.getTime()).build();u\nKeyPairGenerator kpGenerator = KeyPairGenerator.getInstance(\"RSA\",\n\"AndroidKeyStore\");\nkpGenerator.initialize(spec);v\nKeyPair kp = kpGenerator.generateKeyPair();w\n// in another part of the app, access the keys\nKeyStore ks = KeyStore.getInstance(\"AndroidKeyStore\");\nks.load(null);\nKeyStore.PrivateKeyEntry keyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(\"key1\", null);x\nRSAPublic pubKey = (RSAPublicKey)keyEntry.getCertificate().getPublicKey();\nRSAPrivateKey privKey = (RSAPrivateKey) keyEntry.getPrivateKey();\nListing 7-9: Generating and accessing RSA keys using the AndroidKeyStoreProvider\nFirst u you create a KeyPairGeneratorSpec describing the keys you want\nto generate and the automatically created self-signed certificate each key is\nassociated with. You can specify the key type (RSA, DSA, or EC) using the\nsetKeyType() method, and key size with the setKeySize() method.\nNOTE Each PrivateKeyEntry managed by a KeyStore object needs to be associated with a\ncertificate chain. Android automatically creates a self-signed certificate when you gen-\nerate a key, but you can replace the default certificate with one signed by a CA later.\n188 Chapter 7\nNext, you initialize a KeyPairGenerator v with the KeyPairGeneratorSpec\ninstance and then generate the keys by calling generateKeyPair() w.\nThe most important parameter is the alias. You pass the alias to\nKeyStore.getEntry() x in order to get a reference to the generated keys later.\nThe returned key object does not contain the actual key material; it is only\na pointer to a hardware-managed key object. Therefore, it is not usable with\ncryptographic providers that rely on key material being directly accessible.\nIf the device has a hardware-backed keystore implementation, keys will\nbe generated outside the Android OS and won’t be directly accessible even\nto the system (or root) user. If the implementation is software only, keys will\nbe encrypted with a per-user key-encryption master key derived from the\nunlock PIN or password.\nsummary\nAs you’ve learned in this chapter, Android has a system credential store\nthat can be used to store credentials for built-in features such as Wi-Fi and\nVPN connectivity, as well as for use by third-party apps. Android 4.3 and\nlater versions provide standard JCA APIs for generating and accessing\napp-private keys, which makes it easier for non-system apps to store their\nkeys securely without needing to implement key protection themselves.\nHardware-backed key storage, which is available on supported devices,\nguarantees that even apps with system or root privileges cannot extract\nthe keys. Most current hardware-backed credential storage implementa-\ntions are based on ARM’s TrustZone technology and do not use dedicated\ntamper-resistant hardware.\nCredential Storage 189",
    "question": "What is the role and functionality of Android's system credential store in managing authentication keys and certificates for both built-in features and third-party applications?",
    "summary": "Android has a system credential store that securely manages authentication keys and certificates for built-in features like Wi-Fi and VPN, as well as third-party apps. Starting with Android 4.3, it provides standard JCA APIs for app-private key storage, allowing non-system apps to securely store keys without implementing key protection. Hardware-backed key storage, often using ARM's TrustZone technology, ensures that even apps with system or root privileges cannot access the keys, enhancing security."
  },
  {
    "start": 120,
    "end": 127,
    "text": "8\nONLINE aCCOUNT m aNaGEmENT\nWhile enterprise services usually employ PKI for user\nauthentication, most publicly available online services\nrely on passwords to authenticate their users. How-\never, typing complex passwords on a touch screen\nmobile device multiple times a day for different sites\nis not a very pleasant exercise.\nIn an effort to improve the user experience when accessing online\nservices, Android provides a centralized registry of user accounts that can\ncache and reuse credentials. This account registry can be accessed by third-\nparty applications, allowing them to access web services on behalf of the\ndevice user without the need for apps to handle passwords directly. In this\nchapter, we discuss how Android manages a user’s online account creden-\ntials and the APIs that applications can use to take advantage of cached\ncredentials and to register custom accounts. We then show how Google\nexperience devices (devices on which the Google Play Store is preinstalled)\nstore Google account information and allow access to Google APIs and\nother online services by using the stored credentials.\nandroid account management Overview\nWhile early Android devices had built-in support for Google accounts and\nautomatic background data synchronization with Google services such as\nGmail, no APIs for this functionality were originally provided. Android 2.0\n(API Level 5) introduced the concept of centralized account manage-\nment with a public API. The central piece in the API is the AccountManager\nclass, which “provides access to a centralized registry of the user’s online\naccounts. The user enters credentials (username and password) once per\naccount, granting applications access to online resources with ‘one-click’\napproval.”1 Another major feature of the class is that it lets you get an\nauthentication token for supported accounts, allowing third-party applica-\ntions to authenticate to online services without needing to actually handle\nthe user password. On some older Android versions, the AccountManager\nwould also monitor your SIM card and wipe cached credentials if you\nswapped cards, but this feature was removed in Android 2.3.4 and later\nversions.\naccount management Implementation\nAs with most Android system APIs, the AccountManager is just a facade for the\nAccountManagerService, which does the actual work. The service doesn’t pro-\nvide an implementation for any particular form of authentication, though.\nIt merely coordinates a number of pluggable authenticator modules for\ndifferent account types (Google, Twitter, Microsoft Exchange, and so on).\nAny application can register an authenticator module by implementing an\naccount authenticator and related classes, if needed. We show how to write\nand register a custom authenticator module in “Adding an Authenticator\nModule” on page 203.\nRegistering a new account type with the system lets you take advantage\nof a number of Android infrastructure services, including the ability to:\n• Use a centralized credential storage in a system database\n• Issue tokens to third-party apps\n• Take advantage of Android’s automatic background synchronization\n(via a sync adapter)\nFigure 8-1 shows the main components of Android’s account manage-\nment subsystems and their relationships. Each component and its role will\nbe described in the following sections.\n1. Google, Android API Reference, “AccountManager,” http://developer.android.com/reference/\nandroid/accounts/AccountManager.html\n192 Chapter 8\ncom.example.app org.foo.app\nExAuthenticator : FooAuthenticator :\nIAccountAuthenticator IAccountAuthenticator\ntype: com.example.account type: org.foo.account\nAccountManager AccountManagerService AccountAuthenticatorCache\nAccounts Database\n/data/system/users/<user ID>/accounts.db\nextras accounts authtokens\n* 1 1 *\nkey name type\nvalue type authtoken\npassword\n1 1\ngrants * 0..1 shared_accounts\nauth_token_type name\nuid type\nFigure 8-1: Account management components\nAccountManagerService and AccountManager\nThe central piece here is the AccountManagerService, which coordinates all\nother components and persists account data in the accounts database.\nThe AccountManager class is the facade that exposes a subset of its func-\ntionality to third-party applications. It starts worker threads for asynchro-\nnous methods and posts the results (or error details) back to the caller.\nAdditionally, AccountManager shows an account chooser when the requested\ntoken or feature can be provided by more than one account. However, it\ndoesn’t enforce any permissions; all caller permissions are checked by the\nAccountManagerService and we’ll discuss the concrete permissions shortly.\nOnline Account Management 193\nAuthenticator Modules\nAs mentioned above, the functionality of each registered account is\nprovided by a pluggable authenticator module, but what exactly is an\nauthenticator module? Authenticator modules are defined and hosted by\napplications, and each is simply a bound service that implements the\nandroid.accounts.IAccountAuthenticator AIDL interface. This interface has\nmethods for adding an account, prompting the user for their credentials,\ngetting an authentication token, and for updating account metadata. In\npractice, applications don’t implement this interface directly, but instead\nextend the android.accounts.AbstractAccountAuthenticator class which links\nimplementation methods to an internal AIDL stub.\nThe AbstractAccountAuthenticator also ensures that all callers of the AIDL\nstub hold the ACCOUNT_MANAGER permission; a system signature permission that\nonly allows system components to call authenticator modules directly. All\nother clients need to go through the AccountManagerService.\nEach authenticator module implements an account identified uniquely\nby a string called the account type. Account types are typically in reverse\ndomain notation (like Java packages) and are usually named using the base\npackage name of the defining application concatenated with the account\ntype, or the account or auth strings (Android does not enforce this rule, how-\never, and there are no explicit guidelines). For example, in Figure 8-1, the\ncom.example.app application defines an account with type com.example.account,\nand the org.foo.app application defines an account with type org.foo.account.\nAuthenticator modules are implemented by adding a service that can\nbe bound to by using the android.accounts.AccountAuthenticator intent action\nto the host application. The account type, as well as other metadata, is\nlinked to the service by adding a <meta-data> tag to the service declara-\ntion. The resource attribute of the tag points to an XML file that contains\naccount metadata (see Listing 8-8 for an example).\nNOTE A <meta-data> tag allows a name-value pair containing arbitrary data to be associ-\nated with its parent component. The data can be a literal value, such as a string or an\ninteger, or a reference to an Android resource file. Multiple <meta-data> tags per compo-\nnent are also supported. The values from all <meta-data> tags are collected in a single\nBundle object and made available as the metaData field of the PackageItemInfo class\n(the base class of concrete classes that encapsulate component attribute values, such as\nServiceInfo). The interpretation of the associated metadata is component-specific.\nThe Authenticator Module Cache\n“Pluggability” is provided by the AccountAuthenticatorCache class, which\nscans for packages that define authenticator modules and makes them\navailable to the AccountManagerService. The AccountAuthenticatorCache is one\nimplementation of the more general registered service cache facility that\nAndroid provides. The cache is built on demand (lazily) by interrogating\nthe PackageManagerService about installed packages that register a particular\nintent action and metadata file. The cache is kept up-to-date by a broadcast\n194 Chapter 8\nreceiver that triggers an update when packages are added, updated, or\nremoved. The cache is persistent and written to disk each time a change\nis detected, with cache files written to the /data/system/registered_services/\ndirectory and named after the intent action they scan for. The authentica-\ntor module cache is saved to the android.accounts.AccountAuthenticator.xml file\nand might look like Listing 8-1.\n<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n<services>\n<service uid=\"10023\" type=\"com.android.exchange\" />u\n<service uid=\"10023\" type=\"com.android.email\" />v\n<service uid=\"10069\" type=\"com.example.account\" />w\n<service uid=\"10074\" type=\"org.foo.account\" />x\n--snip--\n<service uid=\"1010023\" type=\"com.android.email\" />y\n<service uid=\"1010023\" type=\"com.android.exchange\" />z\n<service uid=\"1010069\" type=\"com.example.account\" />{\n--snip--\n</services>\nListing 8-1: Contents of the AccountAuthenticator .xml registered services cache file\nHere, the com.android.exchange and com.android.email account types (u\nand v) are registered by the stock Email application, and com.example.\naccount and org.foo.account (w and x) are registered by third-party appli-\ncations. On a multi-user device, the cache file will have entries for the\naccounts available to each user.\nIn this example, the first secondary user (user ID 10) can use com\n.android.exchange, com.android.email, and com.example.account (y, z, and {),\nbut not the org.foo.account account (because there is no entry for it in the file).\nWhen the AccountManagerService needs to perform an action with a particular\naccount, it queries the AccountAuthenticatorCache for the implementing service\nby passing the account type. If an account implementation for that type is\nregistered for the current user, AccountAuthenticatorCache returns details about\nthe implementing service that contain the name of the implementing com-\nponent and the UID of the host package. The AccountManagerService uses this\ninformation to bind to the service in order to be able to call methods of the\nIAccountAuthenticator interface that the service implements.\nAccountManagerService Operations and Permissions\nAs shown in Figure 8-1, AccountManagerService implements its functionality\nby either calling into authenticator modules or by using cached data from\nthe accounts database. Third-party components can only use the API that\nAccountManagerService exposes; they can’t access authenticator modules or\nthe accounts database. This centralized interface guarantees operation\nworkflow and enforces access rules for each operation.\nAccountManagerService implements access control using a combination of\npermissions and caller UID and signature checks. Let’s look at the opera-\ntions it provides and the respective permission checks.\nOnline Account Management 195\nListing and Authenticating Accounts\nClients can get a list of accounts that match certain criteria (including type,\ndeclaring package, and other features) by calling one of the getAccounts()\nmethods, and they can check to see if a particular account has the required\nfeatures by calling the hasFeatures() method. These operations require the\nGET_ACCOUNTS permission, which has the normal protection level. A new account\nof a particular type can be added by calling the addAccount() method (which\nstarts an implementation-specific authenticator activity that collects credentials\nfrom the user) or silently by calling the addAccountExplicitly() method, which\ntakes the account, password, and any associated user data as parameters. The\nfirst method requires callers to hold the MANAGE_ACCOUNTS permission, and the\nsecond requires that they both hold the AUTHENTICATE_ACCOUNTS permission and\nhave the same UID as the account’s authenticator. Both permissions have\nprotection level dangerous and therefore require user confirmation when\nthe app is installed. Requiring callers of addAccountExplicitly() to have the\nsame UID as the authenticator ensures that only the same app, or apps\nthat belong to the same shared user ID (see Chapter 2 for details), can add\naccounts without user interaction.\nOther operations that require the caller to both hold the AUTHENTICATE_\nACCOUNTS permission and have the same UID as the account’s authenticator\nare listed below. (We’ve omitted AccountManager method parameters here and\nin the following sections for clarity. See the reference documentation of the\nAccountManager class2 for full method signatures and additional information.)\ngetPassword() Returns the raw cached password.\ngetUserData() Returns authenticator-specific account metadata that\nmatches a specified key.\npeekAuthToken() Returns a cached token of the specified type (if available).\nsetAuthToken() Adds or replaces an authentication token for an account.\nsetPassword() Sets or clears the cached password for an account.\nsetUserData() Sets or clears the metadata entry with the specified key.\nManaging Accounts\nJust as when adding a new account, removing an existing account requires\nthe MANAGE_ACCOUNTS permission. However, if the calling device user has the\nDISALLOW_MODIFY_ACCOUNTS restriction set (see Chapter 4 for more details on\nuser restrictions), they cannot add or remove accounts, even if the call-\ning application holds the MANAGE_ACCOUNTS permission. Other methods that\nrequire this permission are those that modify account properties or creden-\ntials as listed next.\n2.Google, Android API Reference, “AccountManager,” http://developer.android.com/reference/\nandroid/accounts/AccountManager.html.\n196 Chapter 8\nclearPassword() Clears a cached password.\nconfirmCredentials() Explicitly confirms that the user knows the pass-\nword (even if it is already cached) by showing a password entry UI.\neditProperties() Shows a UI that allows the user to change global\nauthenticator settings.\ninvalidateAuthToken() Removes an authentication token from the\ncache. (This can also be called if the caller holds the USE_CREDENTIALS\npermission.)\nremoveAccount() Removes an existing account.\nupdateCredentials() Asks the user the enter the current password and\nupdates the saved credentials accordingly.\nUsing Account Credentials\nThe final permission the AccountManagerService might require its clients to\nhold is USE_CREDENTIALS. This permission protects methods that return or\nmodify authentication tokens, a service-dependent credential string that cli-\nents can use to authenticate requests to the server without sending their\npassword with each request.\nTypically, servers return an authentication token after the client success-\nfully authenticates with their username and password (or other permanent\ncredentials). The token is identified by a string called the token type, which\ndescribes what type of access the token grants (for example, read-only\nor read-write). The token is reusable and can be used for sending mul-\ntiple requests, but might have a limited validity period. Additionally, if a\nuser account is believed to have been compromised, or if a user changes\ntheir password, all existing authentication tokens for that user are usu-\nally invalidated on the server. In this case, requests that use cached\nauthentication tokens will fail with an authentication error. Because the\nAccountManagerService is protocol- and application-agnostic, it doesn’t auto-\nmatically invalidate cached tokens, even if they have expired or been invali-\ndated on the server. Applications are responsible for cleaning up such\ninvalid cached tokens by calling the invalidateAuthToken() method.\nThese are the methods that require USE_CREDENTIALS:\ngetAuthToken() Gets an authentication token of the specified type for a\nparticular account.\ninvalidateAuthToken() Removes an authentication token from the\ncache. (This can also be called if the caller holds the MANAGE_ACCOUNTS\npermission.)\nOnline Account Management 197\nRequesting Authentication Token Access\nBesides holding the USE_CREDENTIALS permission, in order to obtain an\nauthentication token of a particular type, callers of the getAuthToken() (or\nany of its wrapper methods as provided by the AccountManager facade class)\nmust explicitly be granted access to the requested token type. This is accom-\nplished by showing a confirmation dia-\nlog like the one shown in Figure 8-2.\nThe dialog shows both the name of\nthe requesting application (in the first\nbullet, “Account Requestor,” in this\nexample), the account type and name\n(in the second bullet, “Example” and\n“example_user”, respectively), and a\nshort description (below the bullets,\n“Full access to example data”) of the\ntype of data access that will be permit-\nted if the access request is granted.\nIf the user grants access, this decision\nis cached and the dialog won’t be\nshown if a token of the same type is\nrequested again. Applications run-\nning under the same UID as the\nauthenticator module are allowed\naccess to its tokens without showing\na confirmation dialog. Additionally,\nprivileged system applications are\nimplicitly allowed access to all token\ntypes without user confirmation, so\nthe dialog is not shown if the token Figure 8-2: Account access request\nrequest comes from a privileged dialog\napplication.\nThe Accounts Database\nWe’ve introduced authenticator modules, the authenticator cache, and the\nmain features of the AccountManagerService. Now let’s see how this service uses\nthe accounts database, an SQLite database stored in each user’s system direc-\ntory with the accounts.db filename, to register accounts and cache credentials.\nThe accounts database is found at /data/system/users/0/accounts.db on\nsingle-user devices. On multi-user devices, this file stores account informa-\ntion for the primary user, and secondary users each have their own instance\nat /data/system/users/<user ID>/accounts.db. The database consists of six tables:\naccounts, extras, authtokens, grants, shared_users, and meta. As of this writing,\nthe meta table appears to be unused; all other tables and their relationships\nare shown in Figure 8-1.\n198 Chapter 8\nTable Schema\nThe accounts table stores the name, type, and password of registered accounts,\nand all other tables directly or indirectly link to it. It might contain data\nsimilar to Listing 8-2.\nsqlite> select * from accounts;\n_id|name |type |password\n1 |user1@gmail.com |com.google |1/......u\n2 |user1@example.com|com.google.android.pop3|passwordv\n3 |example_user |com.example.account |pass1234w\nListing 8-2: Contents of the accounts table\nHere, u is a Google account (type com.google) which allows access to\nGmail, the Google Play Store, and other Google services. Google accounts\ndepend on proprietary system components and are only available on Google\nexperience devices. (You’ll find more details on Google accounts in “The\nGoogle Login Service” on page 206.) The account at v is a POP3 mail\naccount (type com.google.android.pop3) registered by the stock email applica-\ntion, and w is a custom account (type com.example.account) registered by a\nthird-party application. Each account can be associated with zero or more\nmetadata key-value pairs that are stored in the extras table and link to the\naccount by using its primary key (in the _id column). For example, if our\ncustom application (w in Listing 8-2, _id=3) does background data synchro-\nnization, it might have entries similar to those in Listing 8-3.\nsqlite> select * from extras where accounts_id=3;\n_id|accounts_id|key |value\n11 |3 |device_id|0123456789\n12 |3 |last_sync|1395297374\n13 |3 |user_id |abcdefghij\n14 |3 |option1 |1\nListing 8-3: Contents of the extras table\nThe authtokens table stores tokens that have been issued for an account.\nFor our custom application, it might look like Listing 8-4.\nsqlite> select * from authtokens where accounts_id=3;\n_id|accounts_id|type |authtoken\n16 |3 |com.example.auth|abcdefghij0123456789\nListing 8-4: Contents of the authtokens table\nThe grants table associates application UIDs with the types of tokens\nthey’re allowed to use. Grants are added when the user OK’s the access con-\nfirmation dialog for a particular account type and token (see Figure 8-2). For\nexample, if an application with UID 10291 has requested and been granted\naccess to tokens of type com.example.auth as in our sample application (see\nOnline Account Management 199\nListing 8-4), the grant will be represented by the following row in the grants\ntable (see Listing 8-5). A new row is added for each combination of account\nID, token type, and granted application UID.\nsqlite> select * from grants;\naccounts_id|auth_token_type |uid\n3 |com.example.auth|10291\nListing 8-5: Contents of the grants table\nThe shared_accounts table is used when sharing the device owner’s\naccounts with one of the restricted users on the device. (You’ll find more\ndetails on its contents and usage in “Multi-User Support” on page 201.)\nTable Access\nNow we’ll examine the relationship between tables and data in the accounts\ndatabase and the key methods of the AccountManagerService. At a high level the\nrelationship is fairly straightforward (if we ignore caching and synchroniza-\ntion): methods that retrieve or manipulate account details access the accounts\ntable, and methods that handle user data associated with an account access\nthe extras table. APIs that handle authentication tokens access the authtokens\ntable, and save per-application token access grants in the grants table. We\ndescribe each method and the data it accesses next.\nWhen you add an account of a particular type by calling one of\nthe addAccount() methods, the AccountManagerService inserts a row in the\naccounts table containing its type, username, and password. Calling one\nof the getPassword(), setPassword(), or clearPassword() methods results in\nthe AccountManagerService accessing or updating the password column of\nthe accounts table. If you get or set user data for the account using the\ngetUserdata() or setUserdata() methods, the AccountManagerService fetches\nthe matching entry from or saves it to the extras table.\nWhen you request a token for a particular account, things become a\nbit more complex. If a token with the specified type has never been issued\nbefore, AccountManagerService shows a confirmation dialog (see Figure 8-2)\nasking the user to approve access for the requesting application. If they\naccept, the UID of the requesting app and the token type are saved to the\ngrants table. (Authenticators can declare that they use custom tokens by\nsetting the customTokens account metadata attribute to true. In this case,\nthey’re responsible for managing tokens, and Android neither shows the\ntoken access dialog nor automatically saves tokens to the authtokens table).\nIf a grant already exits, AccountManagerService checks the authtokens table for\ntokens matching the request. If a valid one exists, it’s returned. If a match-\ning token is not found, the AccountManagerService finds the authenticator for\nthe specified account type in the cache and calls its getAuthToken() method\nto request a token. This usually involves the authenticator fetching the user-\nname and password from the accounts table (via the getPassword() method)\nand calling its respective online service to get a fresh token. When a token\nis returned, it gets cached in the authtokens table and then is returned to the\n200 Chapter 8\nrequesting app (usually asynchronously via a callback). Invalidating a token\nresults in deleting the row that stores it from the authtokens table. Finally,\nwhen an account is removed by calling the removeAccount() method, its row is\ndeleted from the accounts table and a database trigger cleans up all linked\nrows from the authtokens, extras, and grants tables.\nPassword Security\nOne thing to note is that while credentials (usually usernames and pass-\nwords) are stored in a central database under /data/system/ that is only\naccessible to system applications, credentials are not encrypted; encrypt-\ning or otherwise protecting credentials is left to the authenticator module\nto implement as necessary. In fact, if you have a rooted device, you’ll likely\nfind that a listing of the contents of the accounts table will show certain\npasswords in cleartext, especially for the stock email application (the\ncom.android.email or com.google.android.email package). For example, in\nListing 8-2, the strings password v and pass1234 w are the cleartext pass-\nwords for a POP account used by the stock application and a custom\ncom.example.account account, respectively.\nNOTE Email applications may need to store the password instead of a password hash or an\nauthentication token in order to support several challenge-response authentication\nmethods that take the password as input, such as DIGEST-MD5 and CRAM-MD5.\nBecause the AccountManger.getPassword() method can be called only\nby apps with the same UID as the account’s authenticator, cleartext pass-\nwords are not accessible to other applications at runtime, but they may\nbe included in backups or device dumps. In order to avoid this potential\nsecurity risk, applications can encrypt passwords with a device-specific key\nor choose to replace a password with a revokable master token after ini-\ntial authentication succeeds. For example, the official Twitter client does\nnot store the user password in the accounts table, but only saves obtained\nauthentication tokens (in the authtokens table). Google accounts are another\nexample (account type com.google): as shown in “The Google Login Service”\non page 206, instead of the user password, Google accounts store a master\ntoken that is exchanged for service-specific authentication tokens.\nMulti-User Support\nRecall from Chapter 4 that on multi-user devices, Android allows each\nuser to have their own set of applications, application data, and system set-\ntings. This user isolation extends to online accounts as well and users can\nhave their own accounts registered with the system’s account manager ser-\nvice. Android 4.3 added support for restricted profiles, which are not fully\nindependent users but share installed applications with the primary user.\nAdditionally, restricted profiles can have a number of restrictions applied.\nApps that use the AccountManager APIs can add explicit support for restricted\nOnline Account Management 201\nprofiles, thus allowing restricted profiles to see and use a subset of the\nprimary user’s accounts within supported apps. We explain this feature in\ndetail in “Shared Accounts” below.\nThe following sections discuss how Android implements account isola-\ntion and sharing on multi-user devices.\nPer-User Account Databases\nAs mentioned in “The Accounts Database” on page 198, the accounts\ndatabases that AccountManagerServices uses to store account information\nand cache authentication tokens are stored in each user’s system directory\nin /data/system/users/<user ID>/accounts.db. This allows each user to have\ndedicated account storage, and different users might even have separate\ninstances of the same type of online account. Aside from the database\nlocation, everything else works in exactly the same way as it does for the\nowner user, including permissions, access grants, and so on. When a user is\nremoved, the system deletes all of its data, including the accounts database.\nShared Accounts\nPrimary user accounts are shared with a restricted profile by simply clon-\ning the account data into the restricted profile’s accounts database. Thus,\nrestricted profiles do not access the primary user’s account data directly,\nbut have their own copy. When a new restricted profile is added, the name\nand type of all current accounts of the primary user are copied into the\nshared_accounts table of the restricted profile’s accounts database. However,\nbecause the new user is not started yet, the accounts table is empty at this\npoint and the shared accounts are not yet usable.\nThe shared_accounts table has the same structure as the accounts table,\nwithout the password column. It might look like Listing 8-6 for a restricted\nprofile.\nsqlite> select * from shared_accounts;\n_id|name |type\n1 |user1@gmail.com |com.google\n2 |user1@example.com|com.google.android.pop3\n3 |example_user |com.example.account\nListing 8-6: Contents of the shared_accounts table\nShared accounts are not cloned directly by copying data from the own-\ner’s accounts table; instead, cloning is performed via the authenticator that\ndeclared the account. By default, the AbstractAccountAuthenticator, which all\nauthenticator classes derive from, does not support account cloning.\nImplementations that want to support shared accounts for restricted\nprofiles need to do so explicitly, by overriding a couple of methods that\nwere introduced in Android 4.3, along with restricted profile support:\ngetAccountCredentialsForCloning(), which returns a Bundle containing all data\nneeded to clone the account, and addAccountFromCredentials(), which receives\nthis Bundle as a parameter and is responsible for creating the account based\n202 Chapter 8\non credentials in the Bundle. The AccountManagerService delays the cloning of\na shared account until a restricted user is actually started. If the owner user\nadds any new accounts, they are added to the shared_accounts table and simi-\nlarly cloned.\nEven when accounts are successfully cloned, they may not be available\nto an application started by a restricted profile. Recall from Chapter 4 that\nif an application wants to support shared accounts, it must explicitly declare\nthe account type it requires with the restrictedAccountType attribute of the\n<application> manifest tag. The AccountManagerServices uses the value of the\nrestrictedAccountType attribute to filter accounts before passing them to\napplications running within a restricted profile. As of this writing, an appli-\ncation can declare only one type of account with this attribute.\nNOTE Secondary users do not share accounts with the owner, and therefore their\nshared_accounts tables are always empty and owner accounts are never cloned.\nAdding an Authenticator Module\nIn “Authenticator Modules” on page 194, we showed that an authent-\ncator module is a bound service that implements the android.accounts\n.IAccountAuthenticator AIDL interface and which can be bound to by using\nthe android.accounts.AccountAuthenticator intent action. In this section, we’ll\nshow how an application can implement and declare an authenticator\nmodule.\nMost of the authenticator logic, including adding accounts, checking\nuser-supplied credentials, and fetching authentication tokens, is imple-\nmented in an authenticator class derived from the base class that Android\nprovides—namely, AbstractAccountAuthenticator.3 The authenticator class\nneeds to provide implementation of all abstract methods, but if not all\nfunctionality is needed, implemented methods can return null or throw\nUnsupportedOperationException. In order to store the account password, an\nimplementation should implement at least the addAccount() method and dis-\nplay a UI that collects the password from the user. The password can then be\nadded to the accounts database by calling the addAccountExplicitly() method\nof AccountManager. Activities that implement credential collection and login\ncan extend from the AccountAuthenticatorActivity,4 which provides a conve-\nnience method to pass back collected credentials to the AccountManager.\nNOTE Remember that the addAccountExplicitly() method does not encrypt or otherwise pro-\ntect the password that is stored in cleartext by default. If required, encryption should\nbe implemented separately, and the encrypted password or token should be passed to\naddAccountExplicitly() instead of the cleartext version.\n3. Google, Android API Reference, “AbstractAccountAuthenticator,” http://developer.android\n.com/reference/android/accounts/AbstractAccountAuthenticator.html\n4. Google, Android API Reference, “AccountAuthenticatorActivity,” http://developer.android\n.com/reference/android/accounts/AccountAuthenticatorActivity.html\nOnline Account Management 203\nOnce you have an account authenticator implementation, you simply\ncreate a service that returns its Binder interface when invoked with the\nandroid.accounts.AccountAuthenticator intent action, as shown in Listing 8-7\n(AbstractAccountAuthenticator method implementations have been omitted).\npublic class ExampleAuthenticatorService extends Service {\npublic static class ExampleAuthenticator extends\nAbstractAccountAuthenticator{\n// ...\n}\nprivate ExampleAuthenticator authenticator;\n@Override\npublic void onCreate() {\nsuper.onCreate();\nauthenticator = new ExampleAuthenticator(this);\n}\n@Override\npublic IBinder onBind(Intent intent) {\nif (AccountManager.ACTION_AUTHENTICATOR_INTENT.equals(intent.\ngetAction())) {\nreturn authenticator.getIBinder();\n}\nreturn null;\n}\n}\nListing 8-7: Account authenticator service implementation\nIn order to be picked up by the AccountAuthenticatorCache and made\navailable via the AccountManagerService, the service needs to declare the\nandroid.accounts.AccountAuthenticator intent action and matching metadata\nas shown in Listing 8-8. Permissions needed to access accounts and tokens\nneed to be added to the manifest as well. In this example, we only add the\nAUTHENTICATE_ACCOUNTS permission, which is the minimum required in order\nto be able to add an account with addAccountExplicitly().\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\npackage=\"com.example.app\"\nandroid:versionCode=\"1\" android:versionName=\"1.0\" >\n<uses-permission android:name=\"android.permission.AUTHENTICATE_ACCOUNTS\" />\n<application ...>\n--snip--\n<service android:name=\".ExampleAuthenticatorService\" >\n<intent-filter>\n<action android:name=\"android.accounts.AccountAuthenticator\" />\n</intent-filter>\n204 Chapter 8\n<meta-data\nandroid:name=\"android.accounts.AccountAuthenticator\"\nandroid:resource=\"@xml/authenticator\" />\n</service>\n</application>\n</manifest>\nListing 8-8: Declaring an account authenticator service in AndroidManifest .xml\nFinally, the account type, label, and icons must be declared in the refer-\nenced XML resource file as shown in Listing 8-9. Here, the account type is\ncom.example.account and we’re simply using the app icon as the account icon.\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<account-authenticator\nxmlns:android=\"http://schemas.android.com/apk/res/android\"\nandroid:accountType=\"com.example.account\"\nandroid:label=\"@string/account_label\"\nandroid:icon=\"@drawable/ic_launcher\"\nandroid:smallIcon=\"@drawable/ic_launcher\"/>\nListing 8-9: Declaring account metadata in an XML resource file\nAfter the application that de-\nclares our new account is installed,\ncom.example.account accounts can\nbe added via the AccountManager\nAPI or the system Settings UI by\nselecting Add an account. The new\naccount should show up in the list\nof supported accounts, as shown in\nFigure 8-3.\nCustom accounts can be used for\nconvenience only by the declaring\napplication, or when creating a sync\nadapter, which requires a dedicated\naccount. In order to allow third-party\napplications to authenticate using your\ncustom account, you must implement\nauthentication tokens, because as we\nsaw in “Listing and Authenticating\nAccounts” on page 196, third-party\napplications cannot access an account\npassword via the AccountManager\n.getPassword() API, unless they are\nsigned with the same key and certifi-\ncate as the application hosting the tar- Figure 8-3: Adding a custom account\nget account’s authenticator module. via the system Settings UI\nOnline Account Management 205",
    "question": "What is the role of the AccountManagerService in Android's account management system and how does it interact with authenticator modules and the accounts database?",
    "summary": "Android manages online account credentials through a centralized AccountManager service, which allows applications to access and reuse cached credentials without handling passwords directly. The service uses an AccountManager class that provides APIs for managing accounts, authenticating users, and handling authentication tokens. Google accounts are a special case, as they require specific system components and are only available on Google experience devices."
  },
  {
    "start": 128,
    "end": 131,
    "text": "google accounts support\nThe main goal of Android’s account management facility is to make it easier\nto integrate online services into the OS, and to allow for seamless access to\nuser data via background synchronization. The first versions of the system\naccount management service were built to support Android integration with\nGoogle online services, and the service was later decoupled and made part\nof the OS. In Android versions 2.0 and later, Google account and online ser-\nvice support is bundled as a set of components that provide account authen-\nticators (for the com.google account type) and sync adapters (for Gmail,\nCalendar, contacts, and so on), using standard OS APIs. However, there are\na few notable differences from other third-party authenticator modules and\nsync adapters:\n• The Google accounts components are bundled with the system and\nthus are granted extra permissions.\n• A lot of the actual functionality is implemented on the server side.\n• The account authenticator does not store passwords in plain text on\nthe device.\nThe Google Login Service\nThe two main components that implement Google account and service\nsupport are the Google Services Framework (GSF) and the Google Login\nService (GLS, displayed as Google Account Manager in recent versions). The\nformer provides common services to all Google apps, such as centralized\nsettings and feature toggle management, while the latter implements the\nauthentication provider for Google accounts and will be the main topic of\nthis section.\nGoogle provides numerous online services, and supports a handful of\ndifferent methods to authenticate to those services, both via a user-facing\nweb UI and several dedicated authentication APIs. Android’s Google\nLogin Service, however, doesn’t call those public authentication APIs\ndirectly, but rather via a dedicated online service, which lives at https://\nandroid.clients.google.com. It has endpoints both for authentication, authori-\nzation token issuing, and different data feeds (mail, calendar, and so on)\nthat are used for data synchronization.\nWhile a lot of the authentication and authorization logic is imple-\nmented on the server side, some sort of locally stored credentials are also\nrequired, especially for background syncing. On-device credential manage-\nment is one of the services GLS provides, and while as of this writing there\nis no source code or reference documentation publicly available, we can\nobserve what data GLS stores on the device and infer how authentication is\nimplemented.\nAs mentioned earlier, GLS plugs into the system account framework,\nso cached credentials, tokens, and associated extra data are stored in the\nsystem’s accounts database of the current user, just as it is for other account\n206 Chapter 8\ntypes. Unlike most other applications, however, GLS doesn’t store Google\naccount passwords directly. Instead, in place of a password, GLS stores an\nopaque master token (probably some form of an OAuth refresh token) in\nthe password column of the accounts table and exchanges it for authentica-\ntion tokens for different Google services by calling an associated web service\nendpoint. The token is obtained when a Google account is first added to\nthe device by sending the username and password entered in the sign-in\nactivity shown in Figure 8-4.\nIf the target Google account is using the default password-only authenti-\ncation method and the correct password is entered, the GLS online service\nreturns the master token and the account is added to the user’s accounts\ndatabase. All subsequent authentication requests use the master token to\nobtain service- or scope-specific tokens that are used for synchronization or\nautomatic web login. If the Google account is set to use two-factor authenti-\ncation (2FA), the user is prompted to enter their one-time password (OTP,\ncalled verification code in the web UI) in an embedded web view like the one\nshown in Figure 8-5.\nFigure 8-4: Google account sign-in Figure 8-5: One-time password entry\nactivity as part of adding a Google account\nIf the OTP is successfully verified, the master token is added to the\naccounts database and a list of services that support background synchroni-\nzation is shown (see Figure 8-6).\nOnline Account Management 207\nNote that only the initial login\nprocess differs for Google accounts\nthat have 2FA enabled: all subse-\nquent authentication requests use\nthe cached master token and do not\nrequire entering an OTP. Thus, once\ncached, the master token grants full\naccess to a Google account and can\nbe used not only for data synchroniza-\ntion, but for other types of account\naccess as well, including web login.\nWhile it’s very handy to have an\nall-powerful authentication token\ncached, this trade-off in favor of con-\nvenience has enabled several attacks\non Google accounts, and as a result\nmany Google services now require\nadditional authentication when sensi-\ntive data is displayed or account set-\ntings are changed. The master token\ncan be invalidated by changing the\nGoogle account password, by en -\nabling two-factor authentication, or\nFigure 8-6: List of Google services that\nby removing the Android device from\nsupport background synchronization\nthe Account Permissions page of the\nassociated Google account (see Fig-\nure 8-7). Any of these actions will\nrequire the user to reauthenticate with their new credentials on the\ndevice the next time it tries to get a Google authentication token via the\nAccountManager API.\nFigure 8-7: Android device entry in the Account Permissions page of a Google account\n208 Chapter 8\nGoogle Services Authentication and Authorization\nBesides user-facing online services with a web UI such as Gmail, Google\nCalendar and, of course, search, Google provides programmatic access to\nmany of its services via different web APIs. Most of these require authentica-\ntion, either in order to be able to access a subset of a particular user’s data,\nor for quota and billing purposes. Several standard or Google-proprietary\nauthentication and authorization methods have been used over the years,\nwith the current trend being to migrate everything to OAuth 2.05 and\nOpenID Connect.6 However, many services still use older, proprietary pro-\ntocols, so we’ll briefly look into those as well.\nMost authentication protocols have two variations: one for web applica-\ntions and one for the so-called installed applications. Web applications run\nin a browser and are expected to be able to take advantage of all standard\nbrowser features including rich UI, free-form user interaction, cookie store,\nand the ability to follow redirects. Installed applications, on the other hand,\ndon’t have a native way to preserve session information, and may not have\nthe full web capabilities of a browser. Android native applications (mostly)\nfall into the “installed applications” category, so let’s see what protocols are\navailable for them.\nClientLogin\nThe oldest and, as of this writing, still widely used authorization protocol\nfor installed applications is ClientLogin.7 This protocol assumes that the\napplication has access to the user’s account name and password and lets you\nget an authorization token for a particular service that can be saved and\nused for accessing that service on behalf of the user. Services are identified\nby proprietary service names, such as cl for Google Calendar and ah for\nGoogle App engine. You’ll find a list of many supported service names in\nthe Google Data API reference,8 but here are a few Android-specific ones\nnot listed in the reference: ac2dm, android, androidsecure, androiddeveloper,\nand androidmarket.\nThe authorization tokens for these services can be fairly long-lived (up\nto two weeks), but cannot be refreshed and the application must obtain a\nnew token when the current token expires. Unfortunately, there is no way\nto validate a token short of accessing the associated service: if you get an\nOK HTTP status (200) the token is valid, but if 403 is returned you need to\nconsult the additional error code and retry or get a new token.\nAnother limitation of ClientLogin authorization tokens is that they don’t\noffer fine-grained access to a service’s resources: access is all or nothing, and\nyou cannot specify read-only access or access to a particular resource only.\n5. D. Hardt, The OAuth 2.0 Authorization Framework, http://tools.ietf.org/html/rfc6749\n6. N. Sakimura et al., OpenID Connect Core 1.0, http://openid.net/specs/openid-connect-core-1_0.html\n7. Google, Google Accounts Authentication and Authorization, “ClientLogin for Installed\nApplications,” https://developers.google.com/accounts/docs/AuthForInstalledApps\n8. Google, Google Data APIs, “Frequently Asked Questions,” https://developers.google.com/gdata/\nfaq#clientlogin\nOnline Account Management 209\nThe biggest drawback for mobile apps though is that ClientLogin requires\naccess to the actual user password. Therefore, unless you want to force users\nto enter their password each time a new token is required, the password must\nbe saved on the device, which poses various problems and potential security\nissues. Android avoids storing the raw password by storing a master token on\nthe device and uses GLS and the associated online service to exchange the\nmaster token for ClientLogin tokens. Getting a token is as simple as calling\nthe appropriate AccountManger method, which either returns a cached token\nor issues an API request to fetch a fresh one.\nDespite its many limitations, the ClientLogin protocol is easy to under-\nstand and straightforward to implement, so it has been widely used. It was\nofficially deprecated in April 2012 though, and apps using it are encour-\naged to migrate to OAuth 2.0.\nOAuth 2.0\nThe OAuth 2.0 authorization framework became an official Internet stan-\ndard in late 2012. It defines different authorization flows for different use\ncases, but we won’t try to present all of them here. We’ll only discuss how\nOAuth 2.0 relates to native mobile applications. (For more detail on the\nactual protocol, see RFC 6749.)\nThe OAuth 2.0 specification defines four basic flows for getting an\nauthorization token for a resource. It also defines two that don’t require the\nclient (in our scenario, an Android app) to directly handle user credentials\n(such as the Google account username and password), namely the autho-\nrization code grant flow and the implicit grant flow. Both of these require the\nauthorization server (Google’s) to authenticate the resource owner (the\nAndroid app user) in order to establish whether to grant or deny the access\nrequest (say, read-only access to profile information). In a typical browser-\nbased web application, this is straightforward: the user is redirected to\nan authentication page, then to an access grant page that basically says\n“Do you allow app X to access data Y and Z?” If the user agrees, another\nredirect, which includes an authorization token, takes the user back to the\noriginal application. The browser simply needs to pass the token in the next\nrequest in order to gain access to the target resource.\nThings are not so simple with a native app. A native app can either use\nthe system browser to handle the grant permission step, or embed a WebView\nor a similar control in the app’s UI. Using the system browser requires\nlaunching a third-party application (the browser), detecting success or fail-\nure, and finally figuring out a way to return the token back to the calling\napplication. Embedding a WebView is a bit more user-friendly, as it doesn’t\ninvolve switching back and forth between applications, but still results in\nshowing a non-native web UI, and requires complex code to detect success\nand extract the access token. Neither option is ideal, and both are confus-\ning to the user.\n210 Chapter 8\nThis integration complexity and UI impedance mismatch are the prob-\nlems that OAuth 2.0 support via native Android APIs aims to solve. Android\noffers two APIs that can be used to obtain OAuth 2.0 tokens: the platform\nAccountManager via the special oauth2:scope token type syntax, and Google Play\nServices (discussed in the next section). When using either of those APIs to\nobtain a token, user authentication is implemented transparently by passing\nthe saved master token to the server-side component of GLS, which pro-\nduces the native AccountManager access grant dialog (see Figure 8-8) instead\nof a WebView with a permission grant page. If you grant token access to the\nrequesting application, a second request is sent to convey this to the server,\nwhich returns the requested token. The access token is then directly deliv-\nered to the app, without passing through an intermediary component such\nas a WebView. This is essentially the same flow as for web applications, except\nthat it doesn’t require context switching from native to browser and back,\nand it’s much more user-friendly. Of course, this native authorization flow\nonly works for Google accounts, and writing a client for some other online\nservice that uses OAuth 2.0 still requires integrating its web interface into\nyour app. For example, Twitter clients often use WebView to process the per-\nmission grant callback URL returned by the Twitter API.\nGoogle Play Services\nGoogle Play Services (GPS)9 was an -\nnounced at Google I/O 2012 as an\neasy-to-use platform that offers third-\nparty Android apps a way to integrate\nwith Google products. Since then, it\nhas grown into a giant all-in-one pack-\nage (with over 14,000 Java methods!)\nthat provides access to Google APIs\nand proprietary OS extensions.\nAs mentioned in the previous sec-\ntion, getting OAuth 2.0 tokens via the\nstandard AccountManager interface has\nbeen supported since Android 2.2\nand higher, but it didn’t work reliably\nacross different Android builds\nbecause their different bundled GLS\nversions resulted in slightly different\nbehavior between devices. Addi-\ntionally, the permission grant dialog\nshown when requesting a token was\nnot particularly user friendly because\nit showed the raw OAuth 2.0 scope Figure 8-8: OAuth token access request\nin some cases, which meant little to dialog\nmost users (see Figure 8-8). While\n9. Google, “Google Play Services,” http://developer.android.com/google/play-services/index.html\nOnline Account Management 211\nhuman-readable aliases for certain scopes were partially supported (for\nexample, the Manage your tasks string was displayed instead of the raw\nOAuth scope oauth2:https://www.googleapis.com/auth/tasks in some versions),\nthat solution was neither ideal nor universally available, as it too depended\non the pre-installed GLS version.\nGenerally, while Android’s account management framework is well-\nintegrated into the OS and extensible via third-party authenticator mod-\nules, its API is not particularly flexible, and adding support for multi-step\nauthentication or authorization flows such as those used in OAuth 2.0 is\nfar from straightforward. GPS manages to achieve this with the help of an\nonline service, which does its best to hide the complexity of OAuth 2.0 and\nprovides web APIs compatible with Android’s account management frame-\nwork. We discuss the details of this integration next.\nGPS adds universal supports for displaying a user-friendly OAuth scope\ndescription by making token issuance a two-step process:\n1. Much like before, the first request\nincludes the account name, mas-\nter token, and requested service,\nin the oauth2:scope format. GPS\nadds two new parameters to the\nrequest: the app’s package name\nand the SHA-1 hash of its signing\ncertificate. The response includes\nsome human-readable details\nabout the requested scope and\nrequesting application, which GPS\nshows in a permission grant dialog\nlike the one shown in Figure 8-9.\n2. If the user grants permission, that\ndecision is recorded in the extras\ntable in a proprietary format that\nincludes the requesting app’s\npackage name, signing certificate\nhash, and granted OAuth 2.0\nscope. (Note that the grants table\nis not used.) GPS then resends the\nauthorization request, setting the\nhas_permission parameter to 1. On\nFigure 8-9: Google Play Services\nsuccess, this results in an OAuth\naccount access permission dialog\n2.0 token and its expiration date\nin the response. The expiration\ndate is saved in the extras table,\nand the token is cached in the\nauthtokens table in a similar\nformat.\n212 Chapter 8\nThe GPS app has the same shared user ID as the GSF and GLS pack-\nages (com.google.uid.shared), so it can directly interact with those services.\nThis allows it, among other things, to directly get and write Google account\ncredentials and tokens to the accounts database. As can be expected, GPS\nruns in a remote service that’s accessed by a client library which is linked into\napps that use GPS. The major selling point against the legacy AccountManager\nAPI is that while its underlying authenticator modules (GLS and GSF) are\npart of the system (and as such cannot be updated without an OTA), GPS\nis a user-installable app that can be easily updated via Google Play. In fact,\nit is auto-updating, so app developers presumably won’t have to rely on\nusers to update it if they want to use newer features (unless GPS is disabled\naltogether). This update mechanism is designed to provide “agility in roll-\ning out new platform capabilities,” but as GPS has come to integrate very\ndiverse APIs and functionalities that require extensive testing, updates have\nbeen infrequent. That said, if your app uses OAuth 2.0 tokens to authenti-\ncate to Google APIs (the preferred method as of this writing), you should\ndefinitely consider using GPS over “raw” AccountManager access.\nNOTE In order to be able to actually use a Google API, you must register your app’s package\nname and signing key in Google’s API console. The registration lets services validat-\ning the token query Google about what app the token was issued for, thus identifying\nthe calling app. This validation process has one subtle but important side effect: you\ndon’t have to embed an API key in your app and send it with every request. Of course,\nfor a third-party published app, you can easily discover both the package name and\nthe signing certificate so it’s not particularly hard to get a token issued in the name of\nsome other app (though not via the official API, of course).\nsummary\nAndroid provides a centralized registry of user online accounts via the\nAccountManager class, which lets you get tokens for existing accounts without\nhaving to handle the raw user credentials and register your own custom\naccount types. Registering a custom account type gives you access to pow-\nerful system features, such as authentication token caching and automatic\nbackground synchronization. Google experience devices include built-in\nsupport for Google accounts, which lets third-party apps access Google\nonline services without having to directly request authentication informa-\ntion from the user. The Google Play Services app and companion client\nlibrary further improve support for Google accounts by making it easy to\nuse OAuth 2.0 tokens from third-party applications.\nOnline Account Management 213",
    "question": "How does Android's Google Login Service (GLS) handle authentication for Google accounts, especially in relation to the use of master tokens and two-factor authentication (2FA)?",
    "summary": "Android uses the AccountManager to provide a centralized system for managing user online accounts, allowing apps to access tokens without handling raw credentials. Google accounts are supported through the Google Login Service (GLS) and Google Play Services (GPS), which handle authentication and authorization, including two-factor authentication. GPS simplifies OAuth 2.0 integration by abstracting the complexity and providing a more user-friendly experience."
  },
  {
    "start": 132,
    "end": 147,
    "text": "9\nENTERPRIsE sECURIT Y\nInitial Android versions were mostly consumer-\noriented, with limited enterprise features. However,\nas the platform has grown in popularity, Android\ndevices have entered the workplace and are increas-\ningly used to access corporate email, customer infor-\nmation, and other company data. As a result of this\ntrend, the need for increased platform security and tools that allow effec-\ntive management of employee devices has steadily grown. While Android’s\nprimary focus remains general-purpose consumer devices, recent versions\nhave introduced numerous enterprise features and Android will likely\nbecome even more enterprise-friendly as it develops.\nIn this chapter, we discuss Android’s major enterprise-oriented fea-\ntures and demonstrate how they can be used to both increase device security\nand provide centralized device policy management. We’ll begin with device\nadministration, and show how it can be integrated into third-party applica-\ntions. We then look into Android’s VPN support and describe the APIs that\nallow new VPN solutions to be developed as third-party, user-installed appli-\ncations. Next we show how Android implements different authentication\nmethods supported by the EAP authentication framework and describe how\nit manages credentials. Finally, we demonstrate how to add an EAP profile\nprogrammatically using the extended Wi-Fi management APIs added in\nAndroid 4.3.\nDevice administration\nAndroid 2.2 introduced support for a Device Administration API, which\nmakes it possible to develop applications that can both enforce a system-\nwide security policy and dynamically adapt their features based on the\ndevice’s current security level. Such applications are called device administra-\ntors. Device administrators must be explicitly enabled in the device’s secu-\nrity settings and cannot be uninstalled if they are active. When enabled,\nthey’re granted special privileges that allow them to lock the device, change\nthe lockscreen password, and even wipe the device (delete all user data).\nDevice administrators are often coupled with a specific type of enterprise\naccount (such as a Microsoft Exchange or Google Apps account), which\nallows enterprise administrators to control access to corporate data by\nallowing access only to devices that conform to the required security policy.\nSecurity policies can be static and built into the device administrator appli-\ncation, or they can be configured on the server side and sent to the device\nas part of a provisioning or synchronization protocol.\nAs of version 4.4, Android supports the policy types listed in Table 9-1.\nThe policy constants are defined in the DeviceAdminInfo class.1\nTable 9-1: Supported Device Administration Policies\nPolicy Constant/XML Tag Value Description API\n(bit to set) Level\nUSES_POLICY_LIMIT_PASSWORD 0 Limit the passwords that 8\n<limit-password> the user can select by\nsetting a minimum length\nor complexity .\nUSES_POLICY_WATCH_LOGIN 1 Watch login attempts by 8\n<watch-login> a user .\nUSES_POLICY_RESET_PASSWORD 2 Reset a user’s password . 8\n<reset-password>\nUSES_POLICY_FORCE_LOCK 3 Force the device to lock, 8\n<force-lock> or limit the maximum lock\ntimeout .\nUSES_POLICY_WIPE_DATA 4 Factory reset the device, 8\n<wipe-data> erasing all user data .\nUSES_POLICY_SETS_GLOBAL_PROXY 5 Specify the device global 9\n<set-global-proxy> proxy . (This is hidden from\nSDK applications .)\n1. Google, Android APIs Reference, “DeviceAdminInfo,” https://developer.android.com/reference/\nandroid/app/admin/DeviceAdminInfo.html\n216 Chapter 9\nPolicy Constant/XML Tag Value Description API\n(bit to set) Level\nUSES_POLICY_EXPIRE_PASSWORD 6 Force the user to change 11\n<expire-password> their password after an\nadministrator-defined time\nlimit .\nUSES_ENCRYPTED_STORAGE 7 Require stored data to be 11\n<encrypted-storage> encrypted .\nUSES_POLICY_DISABLE_CAMERA 8 Disable the use of all 14\n<disable-camera> device cameras .\nUSES_POLICY_DISABLE_KEYGUARD_FEATURES 9 Disable the use of 17\n<disable-keyguard-features> keyguard features such\nas lockscreen widgets or\ncamera support .\nEach device administration applica-\ntion must list the policies it intends to\nuse in a metadata file (see “Privilege\nManagement” on page 218 for details).\nThe list of supported policies is dis-\nplayed to the user when they activate\nthe administrator app, as shown in\nFigure 9-1.\nImplementation\nNow that we know which policies\ncan be enforced with the Device\nAdministration API, let’s look at\nthe internal implementation. Like\nmost public Android APIs, a man-\nager class called DevicePolicyManager 2\nexposes part of the functionality\nof the underlying system service,\nDevicePolicyManagerService. However,\nbecause the DevicePolicyManager facade\nclass defines constants and translates\nservice exceptions to return codes but\nFigure 9-1: Device administrator acti-\notherwise adds little functionality, we’ll\nvation screen\nfocus on the DevicePolicyManagerService\nclass.\nLike most system services, DevicePolicyManagerService is started by and\nruns within the system_server process as the system user, and thus can exe-\ncute almost all Android privileged actions. Unlike most system services,\n2. Google, Android APIs Reference, “DevicePolicyManager,” https://developer.android.com/\nreference/android/app/admin/DevicePolicyManager.html\nEnterprise Security 217\nit can grant access to certain privileged actions (such as changing the\nlockscreen password) to third-party applications, which do not need to\nhold any special system permissions. This makes it possible for users to\nenable and disable device administrators on demand, and guarantees that\ndevice administrators can only enforce policies that they have explicitly\ndeclared. However, this level of flexibility cannot be easily implemented\nwith standard Android permissions that are only granted at install time\nand cannot be revoked (with some exceptions, as discussed in Chapter 2).\nTherefore, DevicePolicyManagerService employs a different method for privi-\nlege management.\nAnother interesting aspect of Android’s device administration imple-\nmentation relates to how policies are managed and enforced. We describe\ndevice administrator privilege management and policy enforcement in\ndetail next.\nPrivilege Management\nAt runtime, the DevicePolicyManagerService keeps an internal, on-memory list\nof policy structures for each device user. (Policies are also persisted on disk\nin an XML file, as described in the next section.)\nEach policy structure contains the currently effective policy for a certain\nuser and a list of metadata about each active device administrator. Because\neach user can enable more than one application with device administra-\ntor functionality, the currently active policy is calculated by selecting the\nstrictest defined policy among all administrators. The metadata about each\nactive device administrator contains information about the declaring appli-\ncation, and a list of declared policies (represented by a bitmask).\nThe DevicePolicyManagerService decides whether to grant access to privi-\nleged operations to a calling application based on its internal list of active\npolicies: if the calling application is currently an active device administra-\ntor, and it has requested the policy that corresponds to the current request\n(API call), only then is the request granted and the operation executed. In\norder to confirm that an active administrator component really belongs to\nthe calling application, DevicePolicyManagerService compares the UID of the\ncalling process (returned by Binder.getCallingUid()) with the UID associated\nwith the target administrator component. For example, an application that\ncalls the resetPassword() needs to be an active device administrator, have the\nsame UID as the registered administrator component, and have requested\nthe USES_POLICY_RESET_PASSWORD policy in order for the call to succeed.\nPolicies are requested by adding an XML resource file that lists all poli-\ncies that a device administrator application wants to use as children of the\n<uses-policies> tag. Before a device administrator is activated, the system\nparses the XML file and displays a dialog similar to the one in Figure 9-1,\nallowing the user to review the requested policies before enabling the\nadministrator. Much like Android permissions, administrator policies are\ngranted on an all-or-nothing basis, and there is no way to selectively enable\n218 Chapter 9\nonly certain policies. A resource file that requests all policies might look\nlike Listing 9-1 (for the policy corresponding to each tag, see the first col-\numn of Table 9-1). You can find more details about adding this file to a\ndevice administrator application in “Adding a Device Administrator” on\npage 223.\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<device-admin xmlns:android=\"http://schemas.android.com/apk/res/android\">\n<uses-policies>\n<limit-password />\n<watch-login />\n<reset-password />\n<force-lock />\n<wipe-data />\n<expire-password />\n<encrypted-storage />\n<disable-camera />\n<disable-keyguard-features />\n<set-global-proxy />\n</uses-policies>\n</device-admin>\nListing 9-1: Declaring policies in a device administrator application\nIn order to be notified about policy-related system events and to be\nallowed access to the Device Administration API, device administrators\nmust be activated first. This is achieved by calling the setActiveAdmin()\nmethod of the DevicePolicyManagerService. Because this method requires\nthe MANAGE_DEVICE_ADMINS permission, which is a system signature permis-\nsion, only system applications can add a device administrator without user\ninteraction.\nUser-installed device administrator applications can only request to be\nactivated by starting the ACTION_ADD_DEVICE_ADMIN implicit intent with code\nsimilar to Listing 9-2. The only handler for this intent is the system Settings\napplication, which holds the MANAGE_DEVICE_ADMINS permission. Upon receiv-\ning the intent, the Settings applications checks whether the requesting\napplication is a valid device administrator, extracts the requested policies,\nand builds the confirmation dialog shown in Figure 9-1. The user pressing\nthe Activate button calls the setActiveAdmin() method, which adds the appli-\ncation to the list of active administrators for the current device user.\nIntent intent = new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN);\nComponentName admin = new ComponentName(this, MyDeviceAdminReceiver.class);\nintent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN, admin);\nintent.putExtra(DevicePolicyManager.EXTRA_ADD_EXPLANATION,\n\"Required for corporate email access.\");\nstartActivityForResult(intent, REQUEST_CODE_ENABLE_ADMIN);\nListing 9-2: Requesting device administrator activation\nEnterprise Security 219\nPolicy Persistence\nWhen a device administrator is activated, deactivated, or its policies are\nupdated, changes are written to the device_policies.xml file for the target user.\nFor the owner user, that file is stored under /data/system/, and for all other\nusers it’s written to the user’s system directory (/data/users/<user-ID>/). The\nfile is owned by and only modifiable by the system user (file permissions 0600).\nThe device_policies.xml file contains information about each active\nadministrator and its policies, as well some global information about the\ncurrent lockscreen password. The file might look like Listing 9-3.\n<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n<policies>\n<admin name=\"com.google.android.gms/com.google.android.gms.mdm.receivers.MdmDeviceAdminReceiver\">u\n<policies flags=\"28\" />\n</admin>\n<admin name=\"com.example.android.apis/com.example.android.apis.app.DeviceAdminSampleReceiver\">v\n<policies flags=\"1023\" />w\n<password-quality value=\"327680\" />x\n<min-password-length value=\"6\" />\n<min-password-letters value=\"2\" />\n<min-password-numeric value=\"2\" />\n<max-time-to-unlock value=\"300000\" />\n<max-failed-password-wipe value=\"100\" />\n<encryption-requested value=\"true\" />\n<disable-camera value=\"true\" />\n<disable-keyguard-features value=\"1\" />\n</admin>\n<admin name=\"com.android.email/com.android.email.SecurityPolicy$PolicyAdmin\">y\n<policies flags=\"475\" />\n</admin>\n<password-owner value=\"10076\" />z\n<active-password quality=\"327680\" length=\"6\"\nuppercase=\"0\" lowercase=\"3\"\nletters=\"3\" numeric=\"3\" symbols=\"0\" nonletter=\"3\" />{\n</policies>\nListing 9-3: Contents of the devices_policies .xml file\nThis example has three active device administrators, each represented\nby an <admin> element (u, v, and y). The policies of each administrator\napp are stored in the flags attribute of the <policies> tag w.\nA policy is considered enabled if its corresponding bit is set (see the\nValue column of Table 9-1). For example, because the DeviceAdminSample\napplication has requested all currently available policies, its flags attribute\nhas the value 1023 (0x3FF, or 1111111111 in binary).\nIf the administrator defines password quality restrictions (for example,\nalphanumeric or complex), they are persisted as the value attribute of the\n<password-quality> tag x. In this example, the value 327680 (0x50000) cor-\nresponds to PASSWORD_QUALITY_ALPHANUMERIC. (Password quality constants are\ndefined in the DevicePolicyManager class.)\n220 Chapter 9\nThe values of other policy requirements, such as password length and\ndevice encryption, are also stored as children of each <admin> element. If\nthe password has been set programmatically by using the resetPassword()\nmethod, device_policies.xml contains a <password-owner> tag that stores the\nUID of the application that sets the password in its value attribute z.\nFinally, the <active-password> tag contains details about the complexity of\nthe current password {.\nPolicy Enforcement\nDevice administrator policies have different granularity and can be enforced\neither for the current user or for all users on a device. Some policies are not\nenforced by the system at all—the system only notifies the declaring admin-\nistration application, which is then responsible for taking an appropriate\naction. In this section, we describe how each type of policy is implemented\nand enforced.\nUSES_POLICY_LIMIT_PASSWORD\nAfter one or more password restric-\ntions have been set, users cannot\nenter a password that does not fulfill\nthe current policy. However, the sys-\ntem does not require passwords to\nbe changed immediately, so the cur-\nrent password remains in effect until\nchanged. Administrator applications\ncan prompt the user for a new pass-\nword by starting an implicit intent\nwith the DevicePolicyManager.ACTION_\nSET_NEW_PASSWORD action.\nBecause each device user has\na separate unlock password, pass-\nword quality policies are applied\nper-user. When password quality\nis set, unlock methods that do not\nallow for a password of the desired\nquality are disabled. For example,\nsetting password quality to PASSWORD_\nQUALITY_ALPHANUMERIC disables the\nFigure 9-2: Setting a password qual-\nPattern and PIN unlock methods,\nity policy disables incompatible\nas shown in Figure 9-2. unlock methods\nUSES_POLICY_WATCH_LOGIN\nThis policy enables device administrators to receive notifications\nabout the outcome of login attempts. Notifications are sent with\nthe ACTION_PASSWORD_FAILED and ACTION_PASSWORD_SUCCEEDED broadcasts.\nBroadcast receivers that derive from DeviceAdminReceiver are automatically\nnotified via the onPasswordFailed() and onPasswordSucceeded() methods.\nEnterprise Security 221\nUSES_POLICY_RESET_PASSWORD\nThis policy enables administrator applications to set the current user’s\npassword via the resetPassword() API. The specified password must satisfy\nthe current password quality requirements and takes effect immediately.\nNote that if the device is encrypted, setting the lockscreen password for\nthe owner user also changes the device encryption password. (Chapter 10\nprovides more detail on device encryption.)\nUSES_POLICY_FORCE_LOCK\nThis policy allows administrators to lock the device immediately by\ncalling the lockNow() method, or to specify the maximum time for user\ninactivity until the device locks automatically via setMaximumTimeToLock().\nSetting the maximum time to lock takes effect immediately and lim-\nits the inactivity sleep time that users can set via the system Display\nsettings.\nUSES_POLICY_WIPE_DATA\nThis policy allows device administrators to wipe user data by calling the\nwipeData() API. Applications that also request the USES_POLICY_WATCH_LOGIN\npolicy can set the number of failed login attempts before the device\nis wiped automatically via the setMaximumFailedPasswordsForWipe() API.\nWhen the number of failed passwords is set to a value greater than zero,\nthe lockscreen implementation notifies the DevicePolicyManagerService\nand displays a warning dialog after each failed attempt, and triggers\na data wipe once the threshold is reached. If the wipe is triggered by\nan unsuccessful login attempt by the owner user, a full device wipe is\nperformed. If, on the other hand, the wipe is triggered by a secondary\nuser, only that user (and any associated data) is deleted and the device\nswitches to the owner user.\nNOTE Full device wipe is not immediate, but is implemented by writing a wipe_data com-\nmand in the cache partition and rebooting into recovery mode. The recovery OS is\nresponsible for executing the actual device wipe. Therefore, if the device has a custom\nrecovery image that ignores the wipe command, or if the user manages to boot into a\ncustom recovery and delete or modify the command file, the device wipe might not be\nexecuted. (Chapters 10 and 13 discuss recovery images in more detail.)\nUSES_POLICY_SETS_GLOBAL_PROXY\nAs of Android 4.4, this policy is not available to third-party applica-\ntions. It allows device administrators to set the global proxy server host\n(Settings.Global.GLOBAL_HTTP_PROXY_HOST), port (GLOBAL_HTTP_PROXY_PORT),\nand the list of excluded hosts (GLOBAL_HTTP_PROXY_EXCLUSION_LIST) by writ-\ning to the global system settings provider. Only the device owner is\nallowed to set global proxy settings.\n222 Chapter 9\nUSES_POLICY_EXPIRE_PASSWORD\nThis policy allows administrators to set the password expiration time-\nout via the setPasswordExpirationTimeout() API. If an expiration timeout\nis set, the system registers a daily alarm that checks for password expi-\nration. If the password has already expired, DevicePolicyManagerService\nposts daily password change notifications until it is changed. Device\nadministrators are notified about password expiration status via the Dev\niceAdminReceiver.onPasswordExpiring() method.\nUSES_ENCRYPTED_STORAGE\nThis policy allows administrators to request that device storage be\nencrypted via the setStorageEncryption() API. Only the owner user can\nrequest storage encryption. Requesting storage encryption does not auto-\nmatically start the device encryption process if the device is not encrypted;\ndevice administrators must check the current storage status by using\nthe getStorageEncryptionStatus() API (which checks the ro.crypto.state\nread-only system property), and start the encryption process. Device\nencryption can be kicked off by starting the associated system activity\nwith the ACTION_START_ENCRYPTION implicit intent.\nUSES_POLICY_DISABLE_CAMERA\nThis policy allows device administrators to disable all cameras on the\ndevice via the setCameraDisabled() API. Camera is disabled by setting\nthe sys.secpolicy.camera.disabled system property to 1. The native system\nCameraService checks this property and disallows all connections if it is\nset to 1, effectively disabling the camera for all users of the device.\nUSES_POLICY_DISABLE_KEYGUARD_FEATURES\nThis policy allows administrators to disable keyguard customizations\nsuch as lockscreen widgets by calling the setKeyguardDisabledFeatures()\nmethod. The system keyguard implementation checks if this policy is\nin effect and disables the corresponding features for the target user.\nAdding a Device Administrator\nAs with other applications, device administrators can either be included in\nthe system image or they can be installed by users. If an administrator is\npart of the system image, it can be set as the device owner app in Android 4.4\nand later, which is a special kind of device admin that cannot be disabled by\nthe user and cannot be uninstalled. In this section, we’ll show how to imple-\nment a device admin app and then demonstrate how a system app can be\nset as the device owner.\nEnterprise Security 223\nImplementing a Device Administrator\nA device administrator application needs to declare a broadcast receiver\nthat requires the BIND_DEVICE_ADMIN permission (u in Listing 9-4), declares\nan XML resource file that lists the policies it uses v, and responds to the\nACTION_DEVICE_ADMIN_ENABLED intent w. Listing 9-1 shows a sample policy\ndeclaration.\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\npackage=\"com.example.deviceadmin\">\n--snip--\n<receiver android:name=\".MyDeviceAdminReceiver\"\nandroid:label=\"@string/device_admin\"\nandroid:description=\"@string/device_admin_description\"\nandroid:permission=\"android.permission.BIND_DEVICE_ADMIN\">u\n<meta-data android:name=\"android.app.device_admin\"\nandroid:resource=\"@xml/device_admin_policy\" />v\n<intent-filter>\n<action android:name=\"android.app.action.DEVICE_ADMIN_ENABLED\" />w\n</intent-filter>\n</receiver>\n--snip--\n</manifest>\nListing 9-4: Device administrator broadcast receiver declaration\nThe Android SDK provides a base class that you can derive your receiver\nfrom, namely android.app.admin.DeviceAdminReceiver. This class defines a\nnumber of callback methods that you can override in order to handle the\ndevice policy-related broadcasts sent by the system. The default implemen-\ntations are empty, but at a minimum you should override the onEnabled()\nand onDisabled() methods in order to be notified when the administrator is\nenabled or disabled. Device administrators cannot use any privileged APIs\nbefore onEnabled() is called or after onDisabled() is called.\nYou can use the isAdminActive() API at any time to see if an applica-\ntion is currently an active device administrator. As mentioned in “Privilege\nManagement” on page 218, an administrator cannot activate itself auto-\nmatically, but must start a system activity to prompt for user confirmation\nwith code similar to Listing 9-2. However, when already active, an adminis-\ntrator can deactivate itself by calling the removeActiveAdmin() method.\nNOTE See the official Device Administration API guide3 for more details and a full working\nexample application.\nSetting the Device Owner\nA device administrator application that’s part of the system image (that is, its\nAPK file is installed on the system partition) can be set as the device owner by\n3. Google, API Guides, “Device Administration,” https://developer.android.com/guide/topics/\nadmin/device-admin.html\n224 Chapter 9\ncalling the setDeviceOwner(String packageName, String ownerName) method (not\nvisible in the public SDK API). The first parameter in this method specifies\nthe package name of the target application, and the second specifies the\nname of the owner to be displayed in the UI. While this method requires no\nspecial permissions, it can only be called before a device is provisioned (that\nis, if the global setting Settings.Global.DEVICE_PROVISIONED is set to 0), which\nmeans that it can only be called by system applications that execute as part\nof device initialization.\nA successful call to this method writes a device_owner.xml file (like the one\nin Listing 9-5) to /data/system/. Information about the current device owner\ncan be obtained using the getDeviceOwner(), isDeviceOwner() (which is exposed\nas isDeviceOwnerApp() in the Android SDK API) and getDeviceOwnerName()\nmethods.\n<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n<device-owner package=\"com.example.deviceadmin\" name=\"Device Owner\" />\nListing 9-5: Contents of the device_owner .xml file\nWhen a device owner is activated, either as part of the provisioning\nprocess or by the user, it cannot be disabled and uninstalled, as shown in\nFigure 9-3.\nFigure 9-3: A device owner adminis-\ntrator cannot be disabled.\nEnterprise Security 225\nManaged Devices\nA device with an owner administrator installed is called a managed device,\nand it reacts differently to configuration changes that affect device security\nthan unmanaged devices. As discussed in Chapters 6 and 7, Android allows\nusers to install certificates in the system trust store either via the system\nSettings application, or by using third-\nparty applications that call the KeyChain\nAPI. If there are user-installed certifi-\ncates in the system trust store, as of ver-\nsion 4.4 Android shows a warning (see\nFigure 6-6 on page 161) notifying\nusers that their communications can\nbe monitored.\nEnterprise networks often require\ntrusted certificates (for example, the\nroot certificate of a corporate PKI) to\nbe installed in order to access enter-\nprise services. Such certificates can be\nsilently installed or removed by device\nadministrators that hold the MANAGE_CA_\nCERTIFICATES system permissions via the\ninstallCaCert() and uninstallCaCert()\nmethods of the DevicePolicyManager class\n(these methods are reserved for system\napplications and aren’t visible in the\npublic SDK API). If an additional\ntrusted certificate is installed on a\nmanaged device, the network monitor-\ning warning changes to a less scary Figure 9-4: Network monitoring infor-\nmation message shown on managed\ninformation message, as shown in\ndevices\nFigure 9-4.\nEnterprise Account Integration\nAs mentioned in “Device Administration” on page 216, device adminis-\ntrator applications are often coupled with enterprise accounts, in order to\nallow some control over devices that access company data. In this section,\nwe’ll discuss two such implementations: one in the stock Email application,\nwhich works with Microsoft Exchange ActiveSync accounts, and the other\nin the dedicated Google Apps Device Policy application, which works with\ncorporate Google accounts.\nMicrosoft Exchange ActiveSync\nMicrosoft Exchange ActiveSync (usually abbreviated as EAS) is a protocol\nthat supports email, contacts, calendar, and task synchronization from a\n226 Chapter 9\ngroupware server to a mobile device.\nIt’s supported both by Microsoft’s own\nExchange Server, and by most compet-\ning products, including Google Apps.\nThe Email application included in\nAndroid supports ActiveSync accounts\nand data synchronization via dedicated\naccount authenticators (see Chapter 8)\nand sync adapters. In order to allow\nenterprise administrators to enforce a\nsecurity policy on devices that access\nemail and other corporate data, the\nEmail application doesn’t allow syn-\nchronization until the built-in device\nadministrator is enabled by the user.\nThe administrator can set lockscreen\npassword rules, erase all data, require\nstorage encryption, and disable device\ncameras, as shown in Figure 9-5.\nHowever, the policies are not built\ninto the app but fetched from the ser-\nvice using the EAS Provision protocol.\nFigure 9-5: Device administrator\nGoogle Apps policies required for using an EAS\naccount\nThe corporate version of Google’s\nGmail service, Google Apps, also sup-\nports setting mobile device security pol-\nicies. If the feature is enabled by the domain administrator, Google Apps\naccount holders can also remotely locate, ring, lock, or wipe their Android\ndevices. Domain administrators can also selectively delete a Google Apps\naccount and all of its associated content from a managed device, without\nperforming a full wipe. Both security policy enforcement and remote device\nmanagement are implemented in the dedicated Google Apps Device Policy\napplication (see y in Listing 9-3 on page 220).\nWhen first started, the application requests that the user enable the\nbuilt-in device administrator and displays the current domain policy set-\ntings as shown in Figure 9-6.\nDomain administrators define policies in the Google Apps admin\nconsole (see Figure 9-7), and policy settings are pushed to devices using\nGoogle’s proprietary sync protocol.\nWhile free Google accounts do not support setting a device policy,\nGoogle experience devices can use the basic device administrator built\ninto Google Play Services (see u in Listing 9-3 on page 220). This admin-\nistrator allows Google account holders to remotely locate or wipe their\ndevices using the Android Device Manager website or the associated\nAndroid application.\nEnterprise Security 227\nFigure 9-6: Policy enforcement con-\nfirmation in the Google Apps Device\nPolicy application\nFigure 9-7: Google Apps device policy management UI\n228 Chapter 9\nvPN support\nA Virtual Private Network (VPN) allows a private network to be extended\nacross a public network without requiring a dedicated physical connection,\nthus enabling all connected devices to send and receive data as if colocated\nand physically connected to the same private network. When a VPN is\nused to allow individual devices to connect to a target private network, it’s\nreferred to as a remote access VPN, and when used to connect two remote net-\nworks, as a site-to-site VPN.\nRemote-access VPNs can connect fixed devices with a static IP address,\nsuch as a computer in a remote office, but configurations where mobile\nclients use variable network connections and dynamic addresses are much\nmore common. Such a configuration is often called a road warrior configura-\ntion and is the configuration most commonly used with Android VPN clients.\nIn order to ensure that data transmitted over a VPN remains private,\nVPNs typically authenticate remote clients and provide data confidentiality\nand integrity by using a secure tunneling protocol. VPN protocols are com-\nplex because they work at multiple network layers simultaneously and often\ninvolve multiple levels of encapsulation in order to be compatible with vari-\nous network configurations. A thorough discussion of them is beyond the\nscope of his book, but in the following sections you’ll find a brief overview\nof the major types of VPN protocols, with a focus on the ones available on\nAndroid.\nPPTP\nThe Point-to-Point Tunneling Protocol (PPTP) uses a TCP control channel\nto establish connections and the Generic Routing Encapsulation (GRE)\ntunneling protocol to encapsulate Point-to-Point Protocol (PPP) packets.\nSeveral authentication methods such as Password Authentication Protocol\n(PAP), Challenge-Handshake Authentication Protocol (CHAP), and its\nMicrosoft extension MS-CHAP v1/v2, as well as EAP-TLS, are supported,\nbut only EAP-TLS is currently considered secure.\nThe PPP payload can be encrypted using the Microsoft Point-to-Point\nEncryption (MPPE) protocol, which uses the RC4 stream cipher. Because\nMPPE does not employ any form of ciphertext authentication, it is vulner-\nable to bit-flipping attacks. In addition, multiple problems with the RC4\ncipher have been uncovered in recent years, which further reduces the secu-\nrity of MMPE and PPTP.\nL2TP/IPSec\nThe Layer 2 Tunneling Protocol (L2TP) is similar to PPTP and exists at the\ndata link layer (Layer 2 in the OSI model). Because L2TP provides no\nencryption or confidentiality of its own (it relies on the tunneled protocol\nto implement these features), an L2TP VPN is typically implemented using\na combination of L2TP and the Internet Protocol Security (IPSec) protocol\nsuite, which adds authentication, confidentiality, and integrity.\nEnterprise Security 229\nIn an L2TP/IPSec configuration, a secure channel is first established\nusing IPSec, and an L2TP tunnel is then established over the secure chan-\nnel. L2TP packets are always wrapped inside IPSec packets and are there-\nfore secure. An IPSec connection requires establishing a Security Association\n(SA), which is a combination of cryptographic algorithm and mode, encryp-\ntion key, and other parameters required to establish a secure channel.\nSAs are established using the Internet Security Association and Key\nManagement Protocol (ISAKMP). ISAKMP does not define a particular key\nexchange method and is typically implemented either by manual configura-\ntion of pre-shared secrets, or by using the Internet Key Exchange (IKE and\nIKEv2) protocol. IKE uses X.509 certificates for peer authentication (much\nlike SSL), and a Diffie-Hellman key exchange in order to establish a shared\nsecret, which is used to derive the actual session encryption keys.\nIPSec Xauth\nIPSec Extended Authentication (Xauth) extends IKE to include additional\nuser authentication exchanges. This allows an existing user database or a\nRADIUS infrastructure to be used to authenticate remote access clients,\nand makes it possible to integrate two-factor authentication.\nMode-configuration (Modecfg) is another IPSec extension that is often\nused in a remote access scenario. Modecfg allows VPN servers to push net-\nwork configuration information such as the private IP address and DNS\nserver addresses to clients. When used in combination, Xauth and Modecfg\nmake it possible to create a pure-IPSec VPN solution, which doesn’t rely on\nadditional protocols for authentication and tunneling.\nSSL-Based VPNs\nSSL-based VPNs use SSL or TLS (see Chapter 6) to establish a secure con-\nnection and tunnel network traffic. No single standard defines SSL-based\nVPNs, and different implementations use different strategies in order to\nestablish a secure channel and encapsulate packets.\nOpenVPN is a popular open source application that uses SSL for\nauthentication and key exchange (preconfigured shared static keys are\nalso supported), and a custom encryption protocol4 to encrypt and authen-\nticate packets. OpenVPN multiplexes the SSL session used for authentica-\ntion and key exchange, and the encrypted packets stream over a single UDP\n(or TCP) port. The multiplexing protocol provides a reliable transport layer\nfor SSL on top of UDP, but it tunnels encrypted IP packets over UDP with-\nout adding reliability. Reliability is provided by the tunneled protocol itself,\nwhich is usually TCP.\nThe main advantages of OpenVPN over IPSec are that it is much simpler\nand can be implemented entirely in userspace. IPSec, on the other hand,\nrequires kernel-level support and implementation of multiple interoperating\n4. OpenVPN Technologies, Inc, “OpenVPN Security Overview,” http://openvpn.net/index.php/\nopen-source/documentation/security-overview.html\n230 Chapter 9\nprotocols. Additionally, it’s easier to get OpenVPN traffic through firewalls,\nNAT, and proxies because it uses the common network protocols TCP and\nUDP and can multiplex tunneled traffic over a single port.\nThe following sections examine Android’s built-in VPN support and\nthe APIs it provides for applications that want to implement additional VPN\nsolutions. We’ll also review the components that make up Android’s VPN\ninfrastructure and show how it protects VPN credentials.\nLegacy VPN\nPrior to Android 4.0, VPN support\nwas entirely built into the platform\nand wasn’t extensible. Support for new\nVPN types could only be added as part\nof platform updates. To distinguish it\nfrom application-based implementa-\ntions, built-in VPN support is referred\nto as legacy VPN.\nEarly Android versions supported\ndifferent VPN configurations based\non PPTP and L2TP/IPsec, with sup-\nport for “pure-IPSec” VPNs using\nIPSec Xauth added in version 4.0. In\naddition to new built-in VPN configu-\nrations, Android 4.0 also introduced\napplication-based VPNs by supplying\nthe base platform class VpnService,\nwhich applications could extend in\norder to implement a new VPN\nsolution.\nLegacy VPN is controlled via the\nsystem Settings application and is only\navailable to the owner (also called the\nprimary user) on multi-user devices. Figure 9-8: Legacy VPN profile defini-\nFigure 9-8 shows the dialog for adding tion dialog\na new IPSec legacy VPN profile.\nImplementation\nLegacy VPNs are implemented using a combination of kernel drivers as\nwell as native daemons, commands, and system services. The lower-level\nimplementation of PPTP and L2TP tunneling uses an Android-specific\nPPP daemon called mtpd and the PPPoPNS and PPPoLAC (only available in\nAndroid kernels) kernel drivers.\nBecause legacy VPNs support only a single VPN connection per device,\nmtpd can create only a single session. IPSec VPNs leverage the built-in ker-\nnel support for IPSec and a modified racoon IKE key management daemon\nEnterprise Security 231\n(part of the IPSec-Tools5 utilities package that complements the Linux ker-\nnel IPSec implementation; racoon supports only IKEv1). Listing 9-6 shows\nhow these two daemons are defined in init.rc.\nservice racoon /system/bin/racoonu\nclass main\nsocket racoon stream 600 system systemv\n# IKE uses UDP port 500. Racoon will setuid to vpn after binding the port.\ngroup vpn net_admin inetw\ndisabled\noneshot\nservice mtpd /system/bin/mtpdx\nclass main\nsocket mtpd stream 600 system systemy\nuser vpn\ngroup vpn net_admin inet net_rawz\ndisabled\noneshot\nListing 9-6: racoon and mtpd definition in init .rc\nBoth racoon u and mtpd x create control sockets (v and y), which are\nonly accessible by the system user and are not started by default. Both dae-\nmons have vpn, net_admin (mapped by the kernel to the CAP_NET_ADMIN Linux\ncapability), and inet added to their supplementary groups (w and z), which\nallow them to create sockets and control network interface devices. The\nmtpd daemon also receives the net_raw group (mapped to the CAP_NET_RAW\nLinux capability), which allows it to create GRE sockets (used by PPTP).\nWhen a VPN is started via the system Settings app, Android starts the\nracoon and mtpd daemons and sends them control commands via their local\nsockets in order to establish the configured connection. The daemons create\nthe requested VPN tunnel, and then create and configure a tunnel network\ninterface with the received IP address and network mask. While mtpd per-\nforms interface configuration internally, racoon uses the helper command\nip-up-vpn to bring up the tunnel interface, which is usually tun0.\nIn order to communicate connection parameters back to the framework,\nVPN daemons write a state file in /data/misc/vpn/ as shown in Listing 9-7.\n# cat /data/misc/vpn/state\ntun0u\n10.8.0.1/24v\n192.168.1.0/24w\n192.168.1.1x\nexample.comy\nListing 9-7: Contents of the VPN state file\n5. IPSec-Tools, http://ipsec-tools.sourceforge.net/\n232 Chapter 9\nThe file contains the tunnel interface name u, its IP address and mask v,\nconfigured routes w, DNS servers x, and search domains y, with each on a\nnew line.\nAfter the VPN daemons start running, the framework parses the state\nfile and calls the system ConnectivityService in order to configure routing,\nDNS servers, and search domains for the newly established VPN connec-\ntion. In turn, ConnectivityService sends control commands via the local\ncontrol socket of the netd daemon, which can modify the kernel’s packet\nfiltering and routing tables because it runs as root. Traffic from all applica-\ntions started by the owner user and restricted profiles is routed through the\nVPN interface by adding a firewall rule that matches the application UID\nand corresponding routing rules. (We discuss per-application traffic rout-\ning and multi-user support in detail in “Multi-User Support” on page 239).\nProfile and Credential Storage\nEach VPN configuration created via the Settings app is called a VPN profile\nand is saved on disk in encrypted form. Encryption is performed by the\nAndroid credential storage daemon keystore, with a device-specific key. (See\nChapter 7 for more on credential storage implementation.)\nVPN profiles are serialized by concatenating all configured properties,\nwhich are delimited by a NUL character (\\0) in a single profile string that\nis saved to the system keystore as a binary blob. VPN profile filenames are\ngenerated by appending the current time in milliseconds (in hexadecimal\nformat) to the VPN_ prefix. For example, Listing 9-8 shows the keystore direc-\ntory of a user with three configured VPN profiles (file timestamps omitted):\n# ls -l /data/misc/keystore/user_0\n-rw------- keystore keystore 980 1000_CACERT_cacertu\n-rw------- keystore keystore 52 1000_LOCKDOWN_VPNv\n-rw------- keystore keystore 932 1000_USRCERT_vpnclientw\n-rw------- keystore keystore 1652 1000_USRPKEY_vpnclientx\n-rw------- keystore keystore 116 1000_VPN_144965b85a6y\n-rw------- keystore keystore 84 1000_VPN_145635c88c8z\n-rw------- keystore keystore 116 1000_VPN_14569512c80{\nListing 9-8: Contents of the keystore directory when VPN profiles are configured\nThe three VPN profiles are stored in the 1000_VPN_144965b85a6 y,\n1000_VPN_145635c88c8 z, and 1000_VPN_14569512c80 { files. The 1000_\nprefix represents the owner user, which is system (UID 1000). Because VPN\nprofiles are owned by the system user, only system applications can retrieve\nand decrypt profile contents.\nListing 9-9 shows the decrypted contents of the three VPN profile files.\n(The NUL character has been replaced with vertical bar [|] for readability.)\nEnterprise Security 233\npsk-vpn|1|vpn1.example.com|test1|pass1234||||true|l2tpsecret|l2tpid|PSK|||u\npptpvpn|0|vpn2.example.com|user1|password||||true||||||v\ncertvpn|4|vpn3.example.com|user3|password||||true||||vpnclient|cacert|w\nListing 9-9: Contents of VPN profile files\nThe profile files contain all fields shown in the VPN profile edit dialog\n(see Figure 9-8), with missing properties represented by an empty string.\nThe first five fields represent the name of the VPN, the type of VPN, the VPN\ngateway host, the username, and the password, respectively. In Listing 9-9,\nthe first VPN profile u is for an L2TP/IPsec VPN with pre-shared key\n(type 1); the second profile v is for a PPTP VPN (type 0), and the last one w\nis for a IPSec VPN that uses certificates and Xauth authentication (type 4).\nIn addition to the username and password, VPN profile files also contain\nall other credentials required to connect to the VPN. In the case of the first\nVPN profile u in Listing 9-9, the additional credential is the pre-shared key\nrequired to establish an IPSec secure connection (represented by the PSK\nstring in this example). In the case of the third profile w, the additional cre-\ndentials are the user’s private key and certificate. However, as you can see in\nthe listing, the full key and certificate are not included; instead, the profile\ncontains only the alias (vpnclient) of the key and certificate (both share a\ncommon alias). The private key and certificate are stored in the system cre-\ndential store, and the alias included in the VPN profile serves only as an iden-\ntifier, which is used to access or retrieve the key and certificate.\nAccessing Credentials\nThe racoon daemon, which originally used keys and certificates stored in\nPEM files, was modified to use Android’s keystore OpenSSL engine. As dis-\ncussed in Chapter 7, the keystore engine is a gateway to the system credential\nstore, which can take advantage of hardware-backed credential store imple-\nmentations when available. When passed a key alias, it uses the correspond-\ning private key to sign authentication packets, without extracting the key\nfrom the keystore.\nThe VPN profile w in Listing 9-9 also contains the alias of the CA cer-\ntificate (cacert), which is used as a trust anchor when validating the server’s\ncertificate. At runtime, the framework retrieves the client certificate (w in\nListing 9-8) and the CA certificate (u in Listing 9-8) from the system key-\nstore and passes them to racoon via the control socket, along with other con-\nnection parameters. The private key blob (x in Listing 9-8) is never directly\npassed to the racoon daemon, only its alias (vpnclient).\nNOTE While private keys are protected by hardware on devices with a hardware-backed\nkeystore, pre-shared keys or passwords stored in a VPN profile content are not. The\nreason for this is that as of this writing, Android doesn’t support importing symmetric\nkeys in the hardware-backed keystore; it only supports asymmetric keys (RSA, DSA,\nand EC). As a result, credentials for VPNs that use pre-shared keys are stored in the\nVPN profile in plaintext form and can be extracted from devices that allow root access\nafter the profile is decrypted on memory.\n234 Chapter 9\nAlways-On VPN\nAndroid 4.2 and later supports an\nalways-on VPN configuration, which\nblocks all network connections from\napplications until a connection to the\nspecified VPN profile is established.\nThis prevents applications from send-\ning data across insecure channels, such\nas public Wi-Fi networks.\nSetting up an always-on VPN\nrequires setting up a VPN profile that\nspecifies the VPN gateway as an IP\naddress, and specifies an explicit DNS\nserver IP address. This explicit configu-\nration is required in order to make sure\nthat DNS traffic isn’t sent to the locally\nconfigured DNS server, which is blocked\nwhen an always-on VPN is in effect. The\nVPN profile selection dialog is shown in\nFigure 9-9.\nThe profile selection is saved with\nother VPN profiles in the encrypted file\nLOCKDOWN_VPN (v in Listing 9-8)\nwhich contains only the name of Figure 9-9: Always-on VPN profile\nselection dialog\nthe selected profile; in our example,\n144965b85a6. If the LOCKDOWN_VPN\nfile is present, the system automatically\nconnects to the specified VPN when the device boots. If the underlying net-\nwork connection reconnects or changes (for example, when switching Wi-Fi\nhotspots), the VPN is automatically restarted.\nAn always-on VPN guarantees that all traffic goes through the VPN\nby installing firewall rules that block all packets except those which go\nthrough the VPN interface. The rules are installed by the LockdownVpnTracker\nclass (always-on VPN is referred to as lockdown VPN in Android source\ncode), which monitors VPN state and adjusts the current firewall state by\nsending commands to the netd daemon, which in turn executes the iptables\nutility in order to modify the kernels packet filtering tables. For example,\nwhen an always-on L2TP/IPSec VPN has connected to a VPN server with IP\naddress 11.22.33.44 and has created a tunnel interface tun0 with IP address\n10.1.1.1, the installed firewall rules (as reported by iptables; some columns\nhave been omitted for brevity) might look like Listing 9-10.\n# iptables -v -L n\n--snip--\nChain fw_INPUT (1 references)\ntarget prot opt in out source destination\nRETURN all -- * * 0.0.0.0/0 10.1.1.0/24u\nRETURN all -- tun0 * 0.0.0.0/0 0.0.0.0/0v\nEnterprise Security 235\nRETURN udp -- * * 11.22.33.44 0.0.0.0/0 udp spt:1701w\nRETURN tcp -- * * 11.22.33.44 0.0.0.0/0 tcp spt:1701\nRETURN udp -- * * 11.22.33.44 0.0.0.0/0 udp spt:4500\nRETURN tcp -- * * 11.22.33.44 0.0.0.0/0 tcp spt:4500\nRETURN udp -- * * 11.22.33.44 0.0.0.0/0 udp spt:500\nRETURN tcp -- * * 11.22.33.44 0.0.0.0/0 tcp spt:500\nRETURN all -- lo * 0.0.0.0/0 0.0.0.0/0\nDROP all -- * * 0.0.0.0/0 0.0.0.0/0x\nChain fw_OUTPUT (1 references)\ntarget prot opt in out source destination\nRETURN all -- * * 10.1.1.0/24 0.0.0.0/0y\nRETURN all -- * tun0 0.0.0.0/0 0.0.0.0/0z\nRETURN udp -- * * 0.0.0.0/0 11.22.33.44 udp dpt:1701{\nRETURN tcp -- * * 0.0.0.0/0 11.22.33.44 tcp dpt:1701\nRETURN udp -- * * 0.0.0.0/0 11.22.33.44 udp dpt:4500\nRETURN tcp -- * * 0.0.0.0/0 11.22.33.44 tcp dpt:4500\nRETURN udp -- * * 0.0.0.0/0 11.22.33.44 udp dpt:500\nRETURN tcp -- * * 0.0.0.0/0 11.22.33.44 tcp dpt:500\nRETURN all -- * lo 0.0.0.0/0 0.0.0.0/0\nREJECT all -- * * 0.0.0.0/0 0.0.0.0/0 reject-with icmp-port-unreachable|\n--snip--\nListing 9-10: Always-on VPN firewall rules\nAs you can see in the listing, all traffic to and from the VPN network\nis allowed (u and y), as is all traffic on the tunnel interface (v and z).\nTraffic to and from the VPN server (w and {) is allowed only on the ports\nused by IPSec (500 and 4500) and L2TP (1701). All other incoming traffic\nis dropped x, and all other outgoing traffic is rejected |.\nApplication-Based VPNs\nAndroid 4.0 added a VpnService public API6 that third-party applications can\nuse to build VPN solutions that are neither built into the OS nor require\nsystem-level permissions. The VpnService and associated Builder class let\napplications specify network parameters such as interface IP address and\nroutes, which the system uses to create and configure a virtual network\ninterface. Applications receive a file descriptor associated with that network\ninterface and can tunnel network traffic by reading from or writing to the\nfile descriptor of the interface.\nEach read retrieves an outgoing IP packet, and each write injects an\nincoming IP packet. Because raw access to network packets effectively\nlets applications intercept and modify network traffic, application-based\nVPNs cannot be started automatically and always require user interaction.\nAdditionally, an ongoing notification is shown while a VPN is connected.\nThe connection warning dialog for an application-based VPN might look\nlike Figure 9-10.\n6. Google, Android APIs Reference, “VpnService,” https://developer.android.com/reference/android/\nnet/VpnService.html\n236 Chapter 9\nFigure 9-10: Application-based VPN\nconnection warning dialog\nDeclaring a VPN\nAn application-based VPN is implemented by creating a service component\nthat extends the VpnService base class and registering it in the application\nmanifest, as shown in Listing 9-11.\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\npackage=\"com.example.vpn\">\n--snip--\n<application android:label=\"@string/app\">\n--snip--\n<service android:name=\".MyVpnService\"\nandroid:permission=\"android.permission.BIND_VPN_SERVICE\">u\n<intent-filter>\n<action android:name=\"android.net.VpnService\"/>v\n</intent-filter>\n</service>\n</application>\n</manifest>:\nListing 9-11: Registering a VPN service in the application manifest\nThe service must have an intent filter that matches the android.net\n.VpnService intent action v so that the system can bind to the service and\nEnterprise Security 237\ncontrol it. In addition, the service must require the BIND_VPN_SERVICE system\nsignature permission u, which guarantees that only system applications can\nbind to it.\nPreparing the VPN\nTo register a new VPN connection with the system, the application first calls\nVpnService.prepare() in order to be granted permission to run, and then calls\nthe establish() method in order to create a network tunnel (discussed in the\nnext section). The prepare() method returns an intent that’s used to start the\nwarning dialog shown in Figure 9-10. The dialog serves to obtain the user’s\npermission and ensure that only one VPN connection per user is running\nat any time. If prepare() is called while a VPN connection created by another\napplication is running, that connection is terminated. The prepare() method\nsaves the package name of the calling application, and only that application\nis allowed to start a VPN connection until the method is called again, or\nthe system tears down the VPN connection (for example, if the VPN app’s\nprocess crashes). When a VPN connection is deactivated for any reason,\nthe system calls the onRevoke() method of the current VPN application’s\nVpnService implementation.\nEstablishing a VPN Connection\nAfter a VPN application has been prepared and granted permission to run,\nit can start its VpnService component, which would then typically create a\ntunnel to the VPN gateway and negotiate the network parameters for the\nVPN connection. Next, it sets up the VpnService.Builder class using those\nparameters and calls VpnService.establish() in order to receive a file descrip-\ntor to read and write packets. The establish() method first ensures that it’s\nbeing called by the application currently granted permission to establish a\nVPN connection by comparing the UID of the caller to the granted appli-\ncation’s UID. establish() then checks whether the current Android user is\nallowed to create VPN connections, and verifies that the service requires\nthe BIND_VPN_SERVICE permission; if the service doesn’t require that permis-\nsion, it’s considered insecure and a SecurityException is thrown. Next, the\nestablish() method creates and configures a tunnel interface using native\ncode, and sets up routing and DNS servers.\nNotifying the User About the VPN Connection\nThe last step in establishing a VPN connection is to show an ongoing noti-\nfication that tells the user that network traffic is been tunneled through\na VPN, which allows them to monitor and control the connection via the\nassociated control dialog. The dialog for the OpenVPN for Android applica-\ntion is shown in Figure 9-11.\n238 Chapter 9\nThis dialog is part of the dedicated\npackage com.android.vpndialogs, which\nis the only package explicitly allowed\nto manage application-based VPN con-\nnections, other than the system user.\nThis ensures that a VPN connection\ncan only be started and managed via\nthe system-mandated UI.\nUsing the application-based VPN\nframework, applications are free to\nimplement network tunneling, with any\nrequired authentication and encryp-\ntion methods. Because all packets the\ndevice sends or receives pass through\nthe VPN application, it can be used not\nonly for tunneling but also for traffic\nlogging, filtering, or modification\n(such as removing advertisements).\nNOTE For a full-featured implementation of an\napplication-based VPN that takes advan-\ntage of Android’s credential store to manage\nauthentication keys and certificates, see the Figure 9-11: Application-based VPN\nsource code for OpenVPN for Android.7 This management dialog\napplication implements an SSL VPN client\nthat is fully compatible with the OpenVPN\nserver.\nMulti-User Support\nAs mentioned earlier, on multi-user devices, legacy VPNs can be controlled\nonly by the owner user. However, with its introduction of multi-user support,\nAndroid 4.2 and higher allows all secondary users (with the exception of\nrestricted profiles, which must share the primary user’s VPN connection)\nto start application-based VPNs. While this change technically allowed\neach user to start their own VPN, because only one application-based VPN\ncould be activated at a time, traffic for all device users was routed through\nthe currently active VPN regardless of who started it. Android 4.4 finally\nbrought full multi-user VPN support by introducing per-user VPN, which\nallows traffic from any user to be routed through their VPN, thus isolating\nit from other users’ traffic.\nLinux Advanced Routing\nAndroid uses several advanced packet filtering and routing features of\nthe Linux kernel in order to implement per-user VPNs. These features\n(implemented by the netfilter kernel framework) include the owner module\n7. Arne Schwabe, “Openvpn for Android 4.0+,” https://code.google.com/p/ics-openvpn/\nEnterprise Security 239\nof the Linux iptables tool, which allows matching of locally generated pack-\nets based on the UID, GID, or PID of the process that created them. For\nexample, the command shown at u in Listing 9-12 creates a packet-filtering\nrule that drops all outgoing packets generated by the user with UID 1234.\n# iptables -A OUTPUT -m owner --uid-owner 1234 -j DROPu\n# iptables -A PREROUTING -t mangle -p tcp --dport 80 -j MARK --set-mark 0x1v\n# ip rule add fwmark 0x1 table webw\n# ip route add default via 1.2.3.4 dev em3 table webx\nListing 9-12: Using owner matching and packet marking with iptables\nAnother important netfilter feature is the ability to mark packets\nthat match a certain selector with a specified number (called a mark).\nFor example, the rule at v marks all packets destined for port 80 (which\nis typically used by a web server) with the mark 0x1. This mark can then\nbe matched in later filtering or routing rules in order to, for example, send\nmarked packets through a particular interface by adding a routing rule that\nsends marked packets to a predefined routing table, which is web in our\nexample w. Finally, a route that sends packets matching the web table to\nthe em3 interface can be added with the command shown at x.\nMulti-User VPN Implementation\nAndroid uses these packet filtering and routing features to mark pack-\nets originating from all apps of a particular Android user and send them\nthrough the tunneling interface created by the VPN app started by that user.\nWhen the owner user starts a VPN, that VPN is shared with any restricted\nprofiles on the device that cannot start their own VPNs by matching all\npackets originating from restricted profiles and routing them through the\nowner’s VPN tunnel.\nThis split-routing is implemented at the framework level by the\nNetworkManagementService, which provides APIs to manage package match-\ning and routing by UID or UID range. NetworkManagementService implements\nthose APIs by sending commands to the native netd daemon which runs as\nroot, and thus can modify the kernel’s packet filtering and routing tables.\nnetd manipulates the kernel’s filtering and routing configuration by calling\nthe iptables and ip userland utilities.\nLet’s illustrate Android’s per-user VPN routing with an example as\nshown in Listing 9-13. The primary user (user ID 0) and the first secondary\nuser (user ID 10) have each started an application-based VPN. The owner\nuser’s VPN is assigned the tun0 tunneling interface, and the secondary user’s\nVPN is assigned the tun1 interface. The device also has a restricted profile\nwith user ID 13. Listing 9-13 shows the state of the kernel’s packet filtering\ntables when both VPNs are connected (with some details omitted).\n# iptables -t mangle -L –n\n--snip--\nChain st_mangle_OUTPUT (1 references)\ntarget prot opt source destination\n240 Chapter 9\nRETURN all -- 0.0.0.0/0 0.0.0.0/0 mark match 0x1u\nRETURN all -- 0.0.0.0/0 0.0.0.0/0 owner UID match 1016v\n--snip--\nst_mangle_tun0_OUTPUT all -- 0.0.0.0/0 0.0.0.0/0 [goto] owner UID match\n0-99999w\nst_mangle_tun0_OUTPUT all -- 0.0.0.0/0 0.0.0.0/0 [goto] owner UID match\n1300000-1399999x\nst_mangle_tun1_OUTPUT all -- 0.0.0.0/0 0.0.0.0/0 [goto] owner UID match\n1000000-1099999y\nChain st_mangle_tun0_OUTPUT (3 references)\ntarget prot opt source destination\nMARK all -- 0.0.0.0/0 0.0.0.0/0 MARK and 0x0\nMARK all -- 0.0.0.0/0 0.0.0.0/0 MARK set 0x3cz\nChain st_mangle_tun1_OUTPUT (2 references)\ntarget prot opt source destination\nMARK all -- 0.0.0.0/0 0.0.0.0/0 MARK and 0x0\nMARK all -- 0.0.0.0/0 0.0.0.0/0 MARK set 0x3d{\nListing 9-13: Packet matching rules for VPNs started by two different device users\nOutgoing packets are first sent to the st_mangle_OUTPUT chain, which\nis responsible for matching and marking packets. Packets exempt from per-\nuser routing (those already marked with 0x1 u), and packets originating\nfrom legacy VPNs (UID 1016 v, assigned to the built-in vpn user, which\nboth mtd and racoon run as) pass without modification.\nNext, packets created by processes running with UIDs between 0 and\n99999 (the range of UIDs assigned to apps started by the primary user,\nas discussed in Chapter 4) are matched and sent to the st_mangle_tun0_\nOUTPUT chain w. Packets originating from UIDs 1300000–1399999, the\nrange assigned to our restricted profile (user ID 13), are sent to the same\nchain x. Thus, traffic originating from the owner user and the restricted\nprofile is treated the same way. Packets originating from the first second-\nary user (user ID 10, UID range 1000000-1099999) are, however, sent to a\ndifferent chain, st_mangle_tun1_OUTPUT y. The target chains themselves\nare simple: st_mangle_tun0_OUTPUT first clears the packet mark and then\nmarks them with 0x3c z; st_mangle_tun1_OUTPUT does the same but uses\nthe mark 0x3d {. After packets have been marked, the marks are used to\nimplement and match different routing rules, as shown in Listing 9-14.\n# ip rule ls\n0: from all lookup local\n100: from all fwmark 0x3c lookup 60u\n100: from all fwmark 0x3d lookup 61v\n--snip--\n# ip route list table 60\ndefault dev tun0 scope linkw\n# ip route list table 61\ndefault dev tun1 scope linkx\nListing 9-14: Routing rules for VPNs started by two different device users\nEnterprise Security 241\nNotice that two rules that match each mark have been created, and that\nthey’re associated with different routing tables. Packets marked with 0x3c\ngo to routing table 60 (0x3c in hexadecimal u), while those marked with\n0x3d go to table 61 (0x3d in hexadecimal v). Table 60 routes everything\nthrough the tun0 tunneling interface w, which was created by the owner user,\nand table 61 routes everything through the tun1 interface x, created by the\nsecondary user.\nNOTE While the VPN traffic routing method introduced in Android 4.4 offers greater flex-\nibility and allows user VPN traffic to be isolated, as of this writing the implementa-\ntion appears to have some problems, especially related to switching between different\nphysical networks (for example, mobile to Wi-Fi or vice versa). Those problems should\nbe addressed in future versions, possibly by modifying how packet filtering chains are\nassociated with interfaces, but the basic implementation strategy is likely to remain\nthe same.\nwi-Fi EaP\nAndroid supports different wireless network protocols, including Wi-Fi\nProtected Access (WPA) and Wi-Fi Protected Access II (WPA2), which\nare currently deployed on most wireless devices. Both protocols support a\nsimple pre-shared key (PSK) mode, also referred to as Personal mode, in which\nall devices that access the network must be configured with the same 256-\nbit authentication key.\nDevices can be configured either with the raw key bytes or with an\nASCII passphrase that’s used to derive the authentication key using the\nPBKDF2 key derivation algorithm. While the PSK mode is simple, it doesn’t\nscale as the number of network users increases. If access for a certain user\nneeds to be revoked, for example, the only way to cancel their network\ncredentials is to change the shared passphrase, which would force all other\nusers to reconfigure their devices. Additionally, as there is no practical way\nto distinguish users and devices, it is difficult to implement flexible access\nrules or accounting.\nTo address this problem, both WPA and WPA2 support the IEEE 802.1X\nnetwork access control standard, which offers an encapsulation of the\nExtensible Authentication Protocol (EAP). Authentication in a wireless net-\nwork that uses 802.1X and involves a supplicant, an authenticator, and an\nauthentication server is shown in Figure 9-12.\nEAPOL RADIUS\nSupplicant Authenticator Authentication\nserver\nEAP EAP\n(Android device) (Wi-Fi AP) (RADIUS server)\nFigure 9-12: 802.1X authentication participants\n242 Chapter 9\nThe supplicant is a wireless device such as an Android phone that wants\nto connect to the network, and the authenticator is the gateway to the net-\nwork that validates the supplicant’s identity and provides authorization. In\na typical Wi-Fi configuration, the authenticator is the wireless access point\n(AP). The authentication server, typically a RADIUS server, verifies client\ncredentials and decides whether they should be granted access based on a\npreconfigured access policy.\nAuthentication is implemented by exchanging EAP messages between\nthe three nodes. These are encapsulated in a format suitable for the medium\nconnecting each two nodes: EAP over LAN (EAPOL) between the suppli-\ncant and the authenticator, and RADIUS between the authenticator and\nthe authentication server.\nBecause EAP is an authentication framework that supports different\nconcrete authentication types and not a concrete authentication mechanism,\nthe supplicant and authentication server (with the help of the authenti-\ncator) need to negotiate a commonly supported authentication method\nbefore authentication can be performed. There are various standard and\nproprietary EAP authentication methods, and current Android versions\nsupport most of the methods used in wireless networks.\nThe sections below offer a brief overview of the EAP authentication\nmethods that Android supports, and show how it protects credentials for\neach method. We’ll also demonstrate how to configure access to a Wi-Fi\nnetwork that uses EAP for authentication using Android’s wireless network\nmanagement APIs.\nEAP Authentication Methods\nAs of version 4.4, Android supports the PEAP, EAP-TLS, EAP-TTLS, and\nEAP-PWD authentication methods. Before exploring how Android stores\ncredentials for each authentication method, let’s briefly discuss how each\none works.\nPEAP\nThe Protected Extensible Authentication Protocol (PEAP) transmits\nEAP messages through an SSL connection in order to provide confi-\ndentiality and integrity. It uses PKI and a server certificate to authenti-\ncate the server and establish an SSL connection (Phase 1), but does not\nmandate how clients are authenticated. Clients are authenticated using\na second, inner (Phase 2) authentication method, which is transmitted\ninside the SSL tunnel. Android supports the MSCHAPv2 (specified in\nPEAPv08) and Generic Token Card (GTC, specified in PEAPv29) meth-\nods for Phase 2 authentication.\n8. Vivek Kamath, Ashwin Palekar, and Mark Woodrich, Microsoft’s PEAP version 0\n(Implementation in Windows XP SP1), https://tools.ietf.org/html/draft-kamath-pppext-peapv0-00/\n9. Ashwin Palekar et al., Protected EAP Protocol (PEAP) Version 2, https://tools.ietf.org/html/\ndraft-josefsson-pppext-eap-tls-eap-10/\nEnterprise Security 243\nEAP-TLS\nThe EAP-Transport Layer Security (EAP-TLS) method10 uses TLS for\nmutual authentication and was formerly the only EAP method certified\nfor use with WPA Enterprise. EAP-TLS uses both a server certificate to\nauthenticate the server to supplicants, and a client certificate that the\nauthentication server verifies in order to establish supplicant identity.\nGranting network access requires issuing and distributing X.509 client\ncertificates, and thus maintaining a public key infrastructure. Existing\nclients can be blocked from accessing the network by revoking their\nsupplicant certificates. Android supports EAP-TLS and manages client\nkeys and certificates using the system credential store.\nEAP-TTLS\nLike EAP-TLS, the EAP-Tunneled Transport Layer Security (EAP-TTLS)\nprotocol11 is based on TLS. However, EAP-TTLS does not require client\nauthentication using X.509 certificates. Clients can be authenticated\neither using a certificate during the handshake phase (Phase 1), or\nwith another protocol during the tunnel phase (Phase 2). Android\ndoes not support authentication during Phase 1, but supports the PAP,\nMSCHAP, MSCHAPv2, and GTC protocols for Phase 2.\nEAP-PWD\nThe EAP-PWD authentication method12 uses a shared password for\nauthentication. Unlike legacy schemes that rely on a simple challenge-\nresponse mechanism, EAP-PWD is designed to be resistant to passive\nattacks, active attacks, and dictionary attacks. The protocol also provides\nforward secrecy and guarantees that even if a password is compromised,\nearlier sessions cannot be decrypted. EAP-PWD is based on discrete\nlogarithm cryptography and can be implemented using either finite\nfields or elliptic curves.\nAndroid Wi-Fi Architecture\nLike most hardware support in Android, Android’s Wi-Fi architecture\nconsists of a kernel layer (WLAN adapter driver modules), native daemon\n(wpa_supplicant), a Hardware Abstraction Layer (HAL), system services, and\na system UI. Wi-Fi adapter kernel drivers are usually specific to the system\non a chip (SoC) that an Android device is built upon, and are typically closed\nsource and loaded as kernel modules. The wpa_supplicant13 is a WPA suppli-\ncant daemon that implements key negotiation with a WPA authenticator and\n10. D. Simon, B. Aboba, and R. Hurst, The EAP-TLS Authentication Protocol, http://tools.ietf.org/\nhtml/rfc5216/\n11. P. Funk and S. Blake-Wilson, Extensible Authentication Protocol Tunneled Transport Layer\nSecurity Authenticated Protocol Version 0 (EAP-TTLSv0), https://tools.ietf.org/html/rfc5281/\n12. D. Harkins and G. Zorn, Extensible Authentication Protocol (EAP) Authentication Using Only a\nPassword, https://tools.ietf.org/html/rfc5931/\n13. Jouni Malinen, Linux WPA/WPA2/IEEE 802.1X Supplicant, http://hostap.epitest.fi/wpa_supplicant/\n244 Chapter 9\ncontrols 802.1X association of the WLAN driver. However, Android devices\nrarely include the original wpa_supplicant code; the included implementa-\ntion is often modified for better compatibility with the underlying SoC.\nThe HAL is implemented in the libharware_legacy native library and is\nresponsible for relaying commands from the framework to wpa_supplicant\nvia its control socket. The system service that controls Wi-Fi connectivity is\nWifiService, which offers a public interface via the WifiManager facade class.\nThe WifiService delegates Wi-Fi state management to a rather complex\nWifiStateMachine class, which can go through more than a dozen states while\nconnecting to a wireless network.\nWLAN connectivity is controlled via the Wi-Fi screen of the system\nSettings app, and connectivity status is displayed in the status bar and\nQuick Settings, both of which are part of the SystemUI package.\nAndroid stores Wi-Fi-related configuration files in the /data/misc/wifi/\ndirectory because wireless connectivity daemons persist configuration\nchanges directly to disk and thus need a writable directory. The direc-\ntory is owned by the wifi user (UID 1010), which is also the user that the\nwpa_supplicant runs as. Configurations files, including wpa_supplicant.conf,\nhave permissions set to 0660 and are owned by the system user, and their\ngroup is set to wifi. This ensures that both system applications and the sup-\nplicant daemon can read and modify configurations files, but they are not\naccessible to other applications. The wpa_supplicant.conf file contains config-\nuration parameters formatted as key-value pairs, both global and specific to\na particular network. Network-specific parameters are enclosed in network\nblocks, which may look like Listing 9-15 for a PSK configuration.\nnetwork={\nssid=\"psk-ap\"u\nkey_mgmt=WPA-PSKv\npsk=\"password\"w\npriority=805x\n}\nListing 9-15: PSK network configuration block in wpa_supplicant .conf\nAs you can see, the network block specifies the network SSID u, authen-\ntication key management protocol v, the pre-shared key itself w, and a pri-\nority value x. The PSK is saved in plaintext, and while the wpa_supplicant\n.conf access bits disallow non-system applications from accessing it, it can be\neasily extracted from devices that allow root access.\nEAP Credentials Management\nIn this section, we’ll examine how Android manages Wi-Fi credentials\nfor each of the supported EAP authentication methods and discuss the\nAndroid-specific wpa_supplicant changes that allow the supplicant daemon\nto take advantage of Android’s system credential store.\nListing 9-16 shows the network block in wpa_supplicant.conf for a net-\nwork configured to use PEAP.\nEnterprise Security 245\nnetwork={\nssid=\"eap-ap\"\nkey_mgmt=WPA-EAP IEEE8021Xu\neap=PEAPv\nidentity=\"android1\"w\nanonymous_identity=\"anon\"\npassword=\"password\"x\nca_cert=\"keystore://CACERT_eapclient\"y\nphase2=\"auth=MSCHAPV2\"z\nproactive_key_caching=1\n}\nListing 9-16: PEAP network configuration block in wpa_supplicant .conf\nHere, the key management mode is set to WPA-EAP IEEE8021X u, the\nEAP method to PEAP v, and Phase 2 authentication to MSCHAPv2 z.\nCredentials, namely the identity w and password x, are stored in plaintext\nin the configuration file, as they are in PSK mode.\nOne notable difference from a general-purpose wpa_supplicant.conf is\nthe format of the CA certificate path y. The CA certificate path (ca_cert)\nis used when validating the server certificate, and in Android ca_cert is in a\nURI-like format with the keystore scheme. This Android-specific extension\nallows the wpa_supplicant daemon to retrieve certificates from the system\ncredential store. When the daemon encounters a certificate path that starts\nFigure 9-13: Setting the credential\nwith keystore://, it connects to the IKeystoreService remote interface of the\nowner to Wi-Fi in the PKCS#12 import\nnative keystore service and retrieves the certificate bytes using the URI path dialog\nas the key.\nEAP-TLS configuration is similar to the PEAP one, as shown in\nListing 9-17.\nnetwork={\nssid=\"eap-ap\"\nkey_mgmt=WPA-EAP IEEE8021X\neap=TLS\nidentity=\"android1\"\nca_cert=\"keystore://CACERT_eapclient\"\nclient_cert=\"keystore://USRCERT_eapclient\"u\nengine_id=\"keystore\"v\nkey_id=\"USRPKEY_eapclient\"w\nengine=1\npriority=803\nproactive_key_caching=1\n}\nListing 9-17: EAP-TLS network configuration block in wpa_supplicant .conf\nNew here is the addition of a client certificate URI u, an engine ID v,\nand a key ID w. The client certificate is retrieved from the system creden-\ntial store, just like the CA certificate. The engine ID refers to the OpenSSL\nengine that should be used for cryptographic operations when connecting\nto the SSID configured in the network block. The wpa_supplicant has native\n246 Chapter 9\nsupport for configurable OpenSSL\nnetwork={\nengines, and is often used with an\nssid=\"eap-ap\"\nPKCS#11 engine in order to use keys\nkey_mgmt=WPA-EAP IEEE8021Xu\neap=PEAPv stored in a smart card or other hard-\nidentity=\"android1\"w ware device.\nanonymous_identity=\"anon\" As discussed in Chapter 7,\npassword=\"password\"x Android’s keystore engine uses keys\nca_cert=\"keystore://CACERT_eapclient\"y\nstored in the system credential store.\nphase2=\"auth=MSCHAPV2\"z\nIf a device supports hardware-backed\nproactive_key_caching=1\ncredential storage, the keystore engine\n}\ncan transparently take advantage of it\nListing 9-16: PEAP network configuration block in wpa_supplicant .conf by virtue of the intermediate keymaster\nHAL module. The key ID in Listing 9-17\nHere, the key management mode is set to WPA-EAP IEEE8021X u, the\nreferences the alias of the private key to\nEAP method to PEAP v, and Phase 2 authentication to MSCHAPv2 z.\nuse for authentication.\nCredentials, namely the identity w and password x, are stored in plaintext\nAs of version 4.3, Android allows\nin the configuration file, as they are in PSK mode.\nyou to select the owner of private\nOne notable difference from a general-purpose wpa_supplicant.conf is\nkeys and certificates when importing\nthe format of the CA certificate path y. The CA certificate path (ca_cert)\nthem. Previously, all imported keys\nis used when validating the server certificate, and in Android ca_cert is in a\nwere owned by the system user, but if\nURI-like format with the keystore scheme. This Android-specific extension\nyou set the Credential use parameter\nallows the wpa_supplicant daemon to retrieve certificates from the system\nto Wi-Fi in the import dialog (see\ncredential store. When the daemon encounters a certificate path that starts\nFigure 9-13), the key owner is set to Figure 9-13: Setting the credential\nwith keystore://, it connects to the IKeystoreService remote interface of the\nthe wifi user (UID 1010), and the key owner to Wi-Fi in the PKCS#12 import\nnative keystore service and retrieves the certificate bytes using the URI path can only be accessed by system com- dialog\nas the key.\nponents that run as the wifi user, like\nEAP-TLS configuration is similar to the PEAP one, as shown in\nwpa_supplicant.\nListing 9-17.\nBecause Android does not support client authentication when using the\nEAP-TTLS authentication method, the configuration only contains a CA\nnetwork={\ncertificate reference v, as shown in Listing 9-18. The password u is stored\nssid=\"eap-ap\"\nin plaintext.\nkey_mgmt=WPA-EAP IEEE8021X\neap=TLS\nidentity=\"android1\" network={\nca_cert=\"keystore://CACERT_eapclient\" ssid=\"eap-ap\"\nclient_cert=\"keystore://USRCERT_eapclient\"u key_mgmt=WPA-EAP IEEE8021X\nengine_id=\"keystore\"v eap=TTLS\nkey_id=\"USRPKEY_eapclient\"w identity=\"android1\"\nengine=1 anonymous_identity=\"anon\"\npriority=803 password=\"pasword\"u\nproactive_key_caching=1 ca_cert=\"keystore://CACERT_eapclient\"v\n} phase2=\"auth=GTC\"\nproactive_key_caching=1\n}\nListing 9-17: EAP-TLS network configuration block in wpa_supplicant .conf\nNew here is the addition of a client certificate URI u, an engine ID v, Listing 9-18: EAP-TTLS network configuration block in wpa_supplicant .conf\nand a key ID w. The client certificate is retrieved from the system creden-\nThe EAP-PWD method does not depend on TLS to establish a\ntial store, just like the CA certificate. The engine ID refers to the OpenSSL\nsecure channel and thus requires no certificate configuration, as shown\nengine that should be used for cryptographic operations when connecting\nin Listing 9-19. Credentials are stored in plaintext (u and v), as with\nto the SSID configured in the network block. The wpa_supplicant has native\nother configurations that use passwords.\nEnterprise Security 247\nnetwork={\nssid=\"eap-ap\"\nkey_mgmt=WPA-EAP IEEE8021X\neap=PWD\nidentity=\"android1\"u\npassword=\"password\"v\nproactive_key_caching=1\n}\nListing 9-19: EAP-PWD network configuration block in wpa_supplicant .conf\nTo sum up, configurations for all EAP methods that use a password for\nauthentication store credential information in plaintext in the wpa_supplicant\n.conf file. When using EAP-TLS, which relies on client authentication, the cli-\nent key is stored in the system keystore, and thus offers the highest level of\ncredential protection.\nAdding an EAP Network with WifiManager\nWhile Android supports a number of WPA Enterprise authentication meth-\nods, setting them up properly might challenge some users because of the\nnumber of parameters that need to be configured and the need to install\nand select authentication certificates. Because Android’s official API for\nmanaging Wi-Fi networks, called WifiManager, did not support EAP configu-\nrations prior to Android 4.3, the only way to set up an EAP network was to\nadd it via the system Settings app and configure it manually. Android 4.3\n(API level 18) extended the WifiManager API to allow for programmatic EAP\nconfiguration, thus enabling automatic network provisioning in enterprise\nenvironments. In this section, we’ll show how to use WifiManager to add an\nEAP-TLS network and discuss the underlying implementation.\nWifiManager allows an app that holds the CHANGE_WIFI_STATE permis-\nsion (protection level dangerous) to add a Wi-Fi network by initializing\na WifiConfiguration instance with the network’s SSID, authentication algo-\nrithms, and credentials, and pass it to the addNetwork() method of WifiManager.\nAndroid 4.3 extends this API by adding an enterpriseConfig field of type\nWifiEnterpriseConfig to the WifiConfiguration class, which allows you to con-\nfigure the EAP authentication method to use, client and CA certificates,\nthe Phase 2 authentication method (if any), and additional credentials such\nas username and password. Listing 9-20 shows how to use this API to add a\nnetwork that uses EAP-TLS for authentication.\nX509Certificate caCert = getCaCert();\nPrivateKey clientKey = getClientKey();\nX509Certificate clientCert = getClientCert();\nWifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();\nenterpriseConfig.setCaCertificate(caCert);u\nenterpriseConfig.setClientKeyEntry(clientKey, clientCert);v\nenterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);w\nenterpriseConfig.setPhase2Method(WifiEnterpriseConfig.Phase2.NONE);x\nenterpriseConfig.setIdentity(\"android1\");y\n248 Chapter 9\nWifiConfiguration config = new WifiConfiguration();\nconfig.enterpriseConfig = enterpriseConfig;z\nconfig.SSID = \"\\\"eap-ap\\\"\";\nconfig.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.IEEE8021X);{\nconfig.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_EAP);|\nint netId = wm.addNetwork(config);}\nif (netId != -1) {\nboolean success = wm.saveConfiguration();~\n}\nListing 9-20: Adding an EAP-TLS network using WifiManager\nIn order to set up EAP-TLS authentication, we first need to obtain the\nCA certificate used to verify the server’s identity, and the client’s private key\nand certificate. Because these are typically distributed as a PKCS#12 file,\nwe can use a KeyStore of type PKCS12 to extract them (not shown). (Android\nwill automatically import the specified keys and certificates into the system\nkeystore when you add an EAP profile that uses them, so you don’t need\nto import the PKCS#12 file.) After we have the CA certificate and client\ncredentials, we set them to our WifiEnterpriseConfig instance using the\nsetCaCertificate() u and setClientKeyEntry() v methods. We then set the\nEAP method to Eap.TLS w and the Phase 2 method to NONE x, as EAP-TLS\nauthenticates users as part of establishing an SSL connection (Phase 1).\nAndroid also requires us to set the\nidentity y even though it might\nnot be used by the authentication\nserver. After we’ve configured the\nWifiEnterpriseConfig object, we can\nadd it to the main WifiConfiguration\ninstance z. The set of key management\nprotocols also needs to be configured\n({ and |) because it defaults to WPA\nPSK. Finally, we can add the network }\nand save the configuration ~, which\nupdates the wpa_supplicant.conf file to\ninclude the newly configured network.\nAndroid automatically generates\naliases for the configured private key\nand certificates, and then imports the\nPKI credentials into the system key-\nstore. The aliases are based on the AP\nname, key management scheme, and\nEAP authentication method. A pro-\ngrammatically configured network is\nautomatically shown in the Wi-Fi\nscreen of the system Settings applica-\ntion, and might look like Figure 9-14\nFigure 9-14: An EAP-TLS network\nfor the example shown in Listing 9-20.\nadded using WifiManager\nEnterprise Security 249\nsummary\nAndroid supports a Device Adminis tration API that allows device adminis-\ntration apps to configure a security policy, which can include requirements\nfor lockscreen password complexity, device encryption, and camera usage.\nDevice administrators are often used with corporate accounts, such as those\nfor Microsoft Exchange and Google Apps, in order to limit access to corpo-\nrate data based on the policy and device settings. The Device Administration\nAPI also provides features that enable remote device locking and data wipe.\nAndroid devices can connect to various types of VPNs, including PPTP,\nL2TP/IPSec, and SSL-based VPNs. Support for PPTP and L2TP/IPSec\nis built into the platform and can only be extended through OS updates.\nAndroid 4.0 adds support for application-based VPNs, which allows third-\nparty applications to implement custom VPN solutions.\nIn addition to the widely used pre-shared key Wi-Fi authentication\nmode, Android supports various WPA Enterprise configurations, namely\nPEAP, EAP-TLS, EAP-TTLS, and EAP-PWD. Certificates and private keys\nfor EAP authentication methods that use SSL to establish a secure channel\nor authenticate users are stored in the system keystore and can use hard-\nware protection when available. Wi-Fi networks that use EAP for authenti-\ncation can be automatically provisioned using the WifiManager API in recent\nAndroid versions, beginning with Android 4.3.\n250 Chapter 9",
    "question": "What are the key enterprise features of Android and how do they contribute to device security and management?",
    "summary": "Android has evolved from a consumer-focused platform to one that supports enterprise features like device administration, which allows for security policies and device management. It also provides robust support for various VPN protocols, including PPTP, L2TP/IPSec, and SSL-based solutions, with recent versions enabling programmatic EAP authentication for Wi-Fi. Android's enterprise features include managing corporate data access, enforcing security policies, and allowing remote device management through the Device Administration API and WifiManager."
  },
  {
    "start": 148,
    "end": 150,
    "text": "10\nDE vICE sECURIT Y\nUntil now, we’ve focused on how Android implements\nsandboxing and privilege separation in order to iso-\nlate applications from one another and the core OS.\nIn this chapter, we look at how Android ensures OS\nintegrity and protects device data from attackers that\nhave physical access to a device. We start with a brief\ndescription of Android’s bootloader and recovery OS,\nthen discuss Android’s verified boot feature, which guarantees that the\nsystem partition is not modified by malicious programs. Next we look at\nhow Android encrypts the userdata partition, which hosts OS configuration\nfiles and application data. This guarantees that the device can’t be booted\nwithout the decryption password and that user data can’t be extracted even\nby direct access to the device’s flash memory. We then show how Android’s\nscreen locking functionality is implemented, and how unlock patterns,\nPINs, and passphrases are hashed and stored on the device.\nWe’ll also discuss secure USB debugging, which authenticates hosts that\nconnect to the Android Debug Bridge (ADB) daemon over USB and requires\nusers to explicitly allow access for each host. Because ADB access over\nUSB allows execution of privileged operations such as application instal-\nlation, full backup, and filesystem access (including full access to external\nstorage), this feature helps prevent unauthorized access to device data\nand applications on devices that have ADB debugging enabled. Finally, we\ndescribe the implementation and archive encryption format of Android’s\nfull backup feature.\nControlling Os Boot-Up and Installation\nGiven physical access to a device, an attacker can access or modify user and\nsystem data not only via higher-level OS constructs such as files and directo-\nries, but also by accessing memory or raw disk storage directly. Such direct\naccess can be achieved by physically interfacing with the device’s electronic\ncomponents by, for example, disassembling the device and connecting to\nhidden hardware debug interfaces or desoldering flash memory and read-\ning the contents with a specialized device.\nNOTE Such hardware attacks are beyond the scope of this book; see Chapter 10 of the\nAndroid Hacker’s Handbook (Wiley, 2014) for an introduction to this topic.\nA less intrusive, but still powerful way to gain access to this data is\nto use the device update mechanism to modify system files and remove\naccess restrictions, or boot an alternative operating system that allows\ndirect access to storage devices. Most consumer Android devices are\nlocked down by default so that those techniques are either not possible\nor require possession of a code signing key, typically available only to\nthe device manufacturer.\nIn the next sections, we briefly discuss how Android’s bootloader and\nrecovery OS regulate access to boot images and device update mechanisms.\n(We’ll explore bootloader and recovery functionality in more detail in\nChapter 13.)\nBootloader\nA bootloader is a specialized, hardware-specific program that executes when\na device is first powered on (coming out of reset for ARM devices). Its pur-\npose is to initialize device hardware, optionally provide a minimal device\nconfiguration interface, and then find and start the operating system.\nBooting a device typically requires going through different stages,\nwhich may involve a separate bootloader for each stage—but we’ll refer to\na single, aggregate bootloader that includes all boot stages, for the sake of\nsimplicity. Android bootloaders are typically proprietary and specific to\nthe system on a chip (SoC) that the device is built upon. Device and SoC\nmanufacturers provide different functionality and levels of protection in\ntheir bootloaders, but most bootloaders support a fastboot, or more gener-\nally, download mode, which allows for the writing (usually called flashing) of\nraw partition images to the device’s persistent storage, as well as booting\n252 Chapter 10\ntransient system images (without flashing them to the device). Fastboot\nmode is enabled by a special hardware key combination applied while the\ndevice is booting, or by sending the reboot bootloader command via ADB.\nIn order to ensure device integrity, consumer devices are shipped with\nlocked bootloaders, which either disallow flashing and booting system\nimages completely or allow it only for images that have been signed by the\ndevice manufacturer. Most consumer devices allow for unlocking the boot-\nloader, which removes fastboot restrictions and image signature checks.\nUnlocking the bootloader typically requires formatting the userdata parti-\ntion, thus ensuring that a malicious OS image cannot get access to existing\nuser data.\nOn some devices, unlocking the bootloader is an irreversible proce-\ndure, but most devices provide a way to relock the bootloader and return\nit to its original state. This is typically implemented by storing a bootloader\nstate flag on a dedicated system partition (typically called param or misc) that\nhosts various device metatdata. Relocking the bootloader simply resets the\nvalue of this flag.\nRecovery\nA more flexible way to update a device is via its recovery OS. The recovery\nOS, or simply recovery, is a minimal Linux-based OS that includes a kernel,\nRAM disk with various low-level tools, and a minimal UI that is typically\noperated using the device’s hardware buttons. The recovery is used to apply\npost-ship updates, generally delivered in the form of over-the-air (OTA)\nupdate packages. OTA packages include the new versions (or a binary\npatch) of updated system files and a script that applies the update. As we\nlearned in Chapter 3, OTA files are also code signed with the private key\nof the device manufacturer. The recovery includes the public part of that\nkey and verifies OTA files before applying them. This ensures that only\nOTA files that originate from a trusted party can modify the device OS.\nThe recovery OS is stored on a dedicated partition, just like the main\nAndroid OS. Therefore, it can be replaced by putting the bootloader into\ndownload mode and flashing a custom recovery image, which replaces the\nembedded public key, or does not verify OTA signatures at all. Such a recov-\nery OS allows the main OS to be completely replaced with a build produced\nby a third party. A custom recovery OS can also allow unrestricted root\naccess via ADB, as well as raw partition data acquisition. While the userdata\npartition could be encrypted (see “Disk Encryption” on page 258), mak-\ning direct data access impossible, it is trivial to install a malicious program\n(rootkit) on the system partition while in recovery mode. The rootkit can\nthen enable remote access to the device when the main OS is booted and\nthus allow access to user data that is transparently decrypted when the\nmain OS boots. Verified boot (discussed in the next section) can prevent\nthis, but only if the device verifies the boot partition using an unmodifiable\nverification key, stored in hardware.\nAn unlocked bootloader allows booting or flashing custom system\nimages and direct access to system partitions. While Android security\nDevice Security 253",
    "question": "What measures does Android use to ensure OS integrity and protect data from physical attacks?",
    "summary": "This chapter discusses Android's methods for ensuring OS integrity and protecting device data from physical attackers. It covers the bootloader and recovery OS, which control access to system images and device updates. The chapter also explains how Android encrypts user data, uses screen locking to secure the device, and implements secure USB debugging to prevent unauthorized access. Additionally, it describes Android's full backup encryption and how it manages device boot-up and installation security."
  },
  {
    "start": 151,
    "end": 153,
    "text": "features such as verified boot and disk encryption can limit the damage\nthat a malicious system image flashed via an unlocked bootloader can do,\ncontrolling access to the bootloader is integral to protecting an Android\ndevice. Therefore the bootloader should only be unlocked on test or devel-\nopment devices, or relocked and returned to its original state immediately\nafter modifying the system.\nverified Boot\nAndroid’s verified boot implementation is based on the dm-verity device-\nmapper block integrity checking target.1 Device-mapper2 is a Linux kernel\nframework that provides a generic way to implement virtual block devices.\nIt’s the basis of Linux’s Logical Volume Manager (LVM), and it’s used to\nimplement full-disk encryption (using the dm-crypt target), RAID arrays,\nand even distributed replicated storage.\nDevice-mapper works by essentially mapping a virtual block device\nto one or more physical block devices and optionally modifying trans-\nferred data in transit. For example, dm-crypt (which is also the basis of\nAndroid’s userdata partition encryption, as discussed in “Disk Encryption”\non page 258) decrypts read physical blocks and encrypts written blocks\nbefore committing them to disk. Thus, disk encryption is transparent to\nusers of the virtual dm-crypt block device. Device-mapper targets can be\nstacked on top of each other, making it possible to implement complex data\ntransformations.\ndm-verity Overview\nBecause dm-verity is a block integrity checking target, it transparently\nverifies the integrity of each device block as it’s being read from disk. If\nthe block checks out, the read succeeds; if not, the read generates an I/O\nerror as if the block were physically corrupted.\nUnder the hood, dm-verity is implemented using a precalculated hash\ntree (also called a Merkle tree) that includes the hashes of all device blocks.\nThe leaf nodes of the tree include hashes of physical device blocks, while\nintermediate nodes are hashes of their child nodes (hashes of hashes). The\nroot node is called the root hash and is based on all hashes in lower levels,\nas shown in Figure 10-1. Thus, a change even in a single device block will\nresult in a change of the root hash, and in order to verify that a hash tree is\ngenuine we only need to verify its root hash.\nAt runtime, dm-verity calculates the hash of each block when it’s read\nand verifies it by traversing the precalculated hash tree. Because reading\ndata from a physical device is already a time-consuming operation, the\n1. Milan Broz, “dm-verity: device-mapper block integrity checking target,” https://\ncode.google.com/p/cryptsetup/wiki/DMVerity\n2. Red Hat, Inc., “Device-Mapper Resource Page,” https://www.sourceware.org/dm/\n254 Chapter 10\nlatency added by hashing and verification is relatively low. Furthermore,\nonce verified, disk blocks are cached, and subsequent reads of the same\nblock do not trigger integrity verification.\nRoot Hash\nHash123 HashXYZ\nHash1 Hash2 Hash3 HashX HashY HashZ\nBlock1 Block2 Block3 ... BlockX BlockY BlockZ\nFigure 10-1: dm-verity hash tree\nBecause dm-verity depends on a precalculated hash tree over all blocks\nof a device, the underlying device must be mounted read-only in order for\nverification to be possible. Most filesystems record mount times and other\nmetadata in their superblock, so even if no files are changed at runtime,\nblock integrity checks will fail if the underlying block device is mounted\nread-write. Even though this can be seen as a limitation, it works well for\ndevices or partitions that hold system files, which are only changed by OS\nupdates. Any other change indicates either OS or disk corruption, or that a\nmalicious program is trying to modify the OS or masquerade as a system file.\nUltimately, dm-verity’s read-only requirement fits well with Android’s\nsecurity model, which hosts only application data on a read-write partition\nand keeps OS files on the read-only system partition.\nAndroid Implementation\nThe dm-verity device-mapper target was originally developed in order to\nimplement verified boot in Chrome OS and was integrated into the main-\nline Linux kernel in version 3.4. It’s enabled with the CONFIG_DM_VERITY kernel\nconfiguration item.\nLike Chrome OS, Android 4.4 also uses the dm-verity target, but the\ncryptographic verification of the root hash and mounting of verified parti-\ntions are implemented differently. The RSA public key used for verification\nis embedded in the boot partition under the verity_key filename and is used\nto verify the dm-verity mapping table, which holds the locations of the tar-\nget device and the offset of the hash table, as well as the root hash and salt.\nThe mapping table and its signature are part of the verity metadata\nblock, which is written to disk directly after the last filesystem block of the\ntarget device. A partition is marked as verifiable by adding the verify flag\nto the Android-specific fs_mgr_flags field of the device’s fstab file. When\nAndroid’s filesystem manager encounters the verify flag in fstab, it loads\nDevice Security 255\nthe verity metadata from the block device specified in fstab and verifies its\nsignature using the included verity key. If the signature check succeeds, the\nfilesystem manager parses the dm-verity mapping table and passes it to the\nLinux device-mapper, which uses the information contained in the map-\nping table in order to create a virtual dm-verity block device. This virtual\nblock device is then mounted at the mount point specified in fstab in place\nof the corresponding physical device. As a result, all reads from the under-\nlying physical device are transparently verified against the pre-generated\nhash tree. Modifying or adding files, or even remounting the partition as\nread-write results in an integrity verification and an I/O error.\nNOTE Because dm-verity is a kernel feature, in order for its integrity protection to be effec-\ntive, the kernel that the device boots needs to be trusted. On Android, this requires\nverifying the boot partition, which also contains the root filesystem RAM disk (initrd)\nand the verity public key. Kernel or boot image verification is a device-specific process,\nwhich is typically implemented in the device bootloader and relies on an unmodifiable\nsignature verification key stored in hardware.\nEnabling Verified Boot\nThe official Android documentation describes the procedure required\nto enable verified boot on Android as a multi-step process, which involves\ngenerating a hash tree, creating a dm-verity mapping table for the hash\ntree, signing the table, and generating and writing a verity metadata block\nto the target device.3 In this section, we briefly describe the key steps of this\nprocess.\nA dm-verity hash tree is generated with the veritysetup program, which\nis part of the cryptsetup cryptographic volume management tools package.\nThe veritysetup program can operate directly on block devices or gener-\nate a hash tree using a filesystem image, and write the hash table to a file.\nAndroid’s dm-verity implementation expects that the hash tree data to be\nstored on the same device as the target filesystem, so an explicit hash offset\nthat points to a location after the verity metadata block must be specified\nwhen invoking veritysetup. Figure 10-2 shows the layout of a disk partition\nprepared for use with dm-verity.\nVerity\nMetadata Hash Tree Data\nBlock\n256 Chapter 10\nSuperblock Block\nN\nSuperblock\nFilesystem Data\nBlock\n1\nFigure 10-2: Layout of a disk partition prepared for dm-verity verification\nGenerating the hash tree produces the root hash, which is used to build\nthe dm-verity mapping table for the target device. A sample mapping table\nis shown in Listing 10-1.\n3. Google, “dm-verity on boot,” https://source.android.com/devices/tech/security/dm-verity.html\n1u /dev/block/mmcblk0p21v /dev/block/mmcblk0p21w 4096x 4096y\n204800z 204809{ sha256|\n1F951588516c7e3eec3ba10796aa17935c0c917475f8992353ef2ba5c3f47bcb}\n5f061f591b51bf541ab9d89652ec543ba253f2ed9c8521ac61f1208267c3bfb1~\nListing 10-1: Android dm-verity device mapping table\nAs shown in the listing, the table is a single line (split across multiple\nlines for readability) that, besides the root hash }, contains the dm-verity\nversion u, name of the underlying data and hash device (v and w), data\nand hash block sizes (x and y), data and hash disk offsets (z and {),\nhash algorithm |, and salt ~.\nThe mapping table is signed using a 2048-bit RSA key, and along with\nthe resulting PKCS#1 v1.5 signature, is used to form the 32 KB verity\nmetadata block. Table 10-1 shows the contents and size of each field of\nthe metadata block.\nTable 10-1: Verity Metadata Block Contents\nField Description Size Value\nMagic number Used by fs_mgr as a 4 bytes 0xb001b001\nsanity check\nVersion Metadata block version 4 bytes Currently 0\nSignature Mapping table signature 256 bytes\n(PKCS#1 v1 .5)\nMapping table length Mapping table length 4 bytes\nin bytes\nMapping table dm-verity mapping table variable\nPadding Zero-byte padding to variable\n32k byte length\nThe RSA public key used for verification needs to be in mincrypt for-\nmat (a minimalistic cryptographic library, also used by the stock recovery\nwhen verifying OTA file signatures), which is a serialization of mincrypt’s\nRSAPublicKey structure. The interesting thing about this structure is that it\ndoesn’t simply include the key’s modulus and public exponent values, but\ncontains pre-computed values used by mincrypt’s RSA implementation\n(based on Montgomery reduction). The public key is included in the root\nof the boot image under the verity_key filename.\nThe last step needed to enable verified boot is to modify the device’s\nfstab file in order to enable block integrity verification for the system parti-\ntion. This is simply a matter of adding the verify flag, as shown in Listing 10-2\n(example fstab file for Nexus 4).\n/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,barrier=1 wait,verify\nListing 10-2: fstab entry for a dm-verity-formatted partition verified\nDevice Security 257",
    "question": "How does Android's verified boot system use dm-verity to ensure the integrity of system files and prevent unauthorized modifications?",
    "summary": "Verified boot and disk encryption in Android help prevent damage from malicious system images by ensuring data integrity. The bootloader should only be unlocked on test devices or relocked immediately after modifications. Android uses dm-verity, a block integrity checking system, which relies on a precalculated hash tree to verify the authenticity of device blocks, and requires the underlying device to be mounted read-only for effective protection."
  },
  {
    "start": 154,
    "end": 166,
    "text": "When the device boots, Android automatically creates a virtual dm-verity\ndevice based on the fstab entry and the information in the mapping table\n(contained in the metadata block), and mounts it at /system as shown in\nListing 10-3.\n# mount|grep system\n/dev/block/dm-0 /system ext4 ro,seclabel,relatime,data=ordered 0 0\nListing 10-3: dm-verity virutal block device mounted at /system\nNow, any modifications to the system partition will result in read errors\nwhen reading the corresponding file(s). Unfortunately, system modifications\nby file-based OTA updates, which modify file blocks without updating verity\nmetadata, also invalidate the hash tree. As mentioned in the official docu-\nmentation, in order to be compatible with dm-verity-based verified boot,\nOTA updates should operate at the block level, ensuring that both file\nblocks and the hash tree and metadata are updated. This requires chang-\ning the current OTA update infrastructure, which is probably one of the\nreasons verified boot has yet to be deployed to production devices.\nDisk Encryption\nAndroid 3.0 introduced disk encryption along with device administrator\npolicies (see Chapter 9 for details) that can enforce mandatory device\nencryption as one of the several “enhancements for the enterprise”\nincluded in that release. Disk encryption has been available in all sub-\nsequent versions with relatively few changes until version 4.4, which intro-\nduced a new key derivation function (scrypt). This section describes how\nAndroid implements disk encryption and how encryption keys and meta-\ndata are stored and managed.\nNOTE The Android Compatibility Definition requires that “IF the device has lockscreen, the\ndevice MUST support full-disk encryption.” 4\nDisk encryption uses an encryption algorithm to convert every bit of data\nthat goes to disk to ciphertext, ensuring that data cannot be read from the\ndisk without the decryption key. Full-disk encryption (FDE) promises that\neverything on disk is encrypted, including operating system files, cache,\nand temporary files. In practice, a small part of the OS, or a separate OS\nloader, must be kept unencrypted so that it can obtain the decryption key\nand then decrypt and mount the disk volume(s) used by the main OS. The\ndisk decryption key is usually stored encrypted and requires an additional\nkey encryption key (KEK) in order to be decrypted. The KEK can either\nbe stored in a hardware module, such as a smart card or a TPM, or derived\n4. Google, Android 4.4 Compatibility Definition, “9.9. Full-Disk Encryption,” https://static\n.googleusercontent.com/media/source.android.com/en//compatibility/4.4/android-4.4-cdd.pdf\n258 Chapter 10\nfrom a passphrase obtained from the user on each boot. When stored in a\nhardware module, the KEK can also be protected by a user-supplied PIN or\npassword.\nAndroid’s FDE implementation encrypts only the userdata partition,\nwhich stores system configuration files and application data. The boot and\nsystem partitions, which store the kernel and OS files, are not encrypted,\nbut system can optionally be verified using the dm-verity device-mapper\ntarget as described earlier in “Verified Boot” on page 254. Android’s disk\nencryption is not enabled by default, and the disk encryption process must\nbe triggered either by the user or by a device policy on managed devices.\nWe examine Android’s disk encryption implementation in the following\nsections.\nCipher Mode\nAndroid’s disk encryption uses dm-crypt,5 currently the standard disk\nencryption subsystem in the Linux kernel. Like dm-verity, dm-crypt is a\ndevice-mapper target that maps an encrypted physical block device to\na virtual device-mapper device. All data access to the virtual device is\ndecrypted (for reads) or encrypted (for writes) transparently.\nThe encryption mechanism employed in Android uses a randomly\ngenerated 128-bit key together with AES in CBC mode. As we learned in\nChapter 5, CBC mode requires an initialization vector (IV) that needs to\nbe both random and unpredictable in order for encryption to be secure.\nThis presents a problem when encrypting block devices, because blocks\nare accessed non-sequentially, and therefore each sector (or device block)\nrequires a separate IV.\nAndroid uses the encrypted salt-sector initialization vector (ESSIV)\nmethod with the SHA-256 hash algorithm (ESSIV:SHA256) in order to\ngenerate per-sector IVs. ESSIV employs a hash algorithm to derive a sec-\nondary key s from the disk encryption key K, called a salt. It then uses the\nsalt as an encryption key and encrypts the sector number SN of each sec-\ntor to produce a per-sector IV. In other words, IV(SN) = AES(SN), where\ns\ns = SHA256(K).\nBecause the IV of each sector depends on a secret piece of information\n(the disk encryption key), per-sector IVs cannot be deduced by an attacker.\nHowever, ESSIV does not change CBC’s malleability property and does not\nensure the integrity of encrypted blocks. In fact, it’s been demonstrated\nthat an attacker who knows the original plaintext stored on disk can manip-\nulate stored data and even inject a backdoor on volumes that use CBC for\ndisk encryption.6\n5. Milan Broz, “dm-crypt: Linux kernel device-mapper crypto target,” https://code.google.com/\np/cryptsetup/wiki/DMCrypt\n6. Jakob Lell, “Practical malleability attack against CBC-Encrypted LUKS partitions,” http://\nwww.jakoblell.com/blog/2013/12/22/practical-malleability-attack-against-cbc-encrypted-luks-partitions/\nDevice Security 259\naLTERNaTIvE CIPER mODEs: XTs\nThis particular attack against the ESSIV mode can be avoided by switching to a\ntweakable encryption cipher mode such as XTS (XEX-based tweaked-codebook\nmode with ciphertext stealing), which uses a combination of the sector address\nand index of the cipher block inside the sector to derive a unique “tweak” (vari-\nable parameter) for each sector .\nUsing a distinct tweak for each sector has the same effect as encrypting\neach sector with a unique key: the same plaintext will result in different cipher-\ntext when stored in different sectors, but has much better performance than\nderiving a separate key (or IV) for each sector . However, while better than the\nCBC ESSIV mode, XTS is still susceptible to data manipulation in some cases\nand does not provide ciphertext authentication .\nAs of this writing, Android does not support the XTS mode for disk encryp-\ntion . However, the underlying dm-crypt device-mapper target supports XTS,\nand it can easily be enabled with some modifications to Android’s volume dae-\nmon (vold) implementation .\nKey Derivation\nThe disk encryption key (called the “master key” in Android source code) is\nencrypted with another 128-bit AES key (KEK), derived from a user-supplied\npassword. In Android versions 3.0 to 4.3, the key derivation function used\nwas PBKDF2 with 2,000 iterations and a 128-bit random salt value. The\nresulting encrypted master key and the salt are stored, along with other\nmetadata like the number of failed decryption attempts, in a footer struc-\nture occupying the last 16 KB of the encrypted partition, called a crypto\nfooter. Storing an encrypted key on disk instead of using a key derived from\nthe user-supplied password directly allows for changing the decryption\npassword quickly, because the only thing that needs to be re-encrypted with\nthe key derived from the new password is the master key (16 bytes).\nWhile using a random salt makes it impossible to use precomputed\ntables to speed up key cracking, the number of iterations (2,000) used for\nPBKDF2 is not sufficiently large by today’s standards. (The keystore key\nderivation process uses 8,192 iterations as discussed in Chapter 7. Backup\nencryption uses 10,000 iterations, as discussed later in “Android Backup” on\npage 283.) Additionally, PBKDF2 is an iterative algorithm, based on stan-\ndard and relatively easy to implement hash functions, which makes it pos-\nsible for PBKDF2 key derivation to be parallelized, taking full advantage of\nthe processing power of multi-core devices such as GPUs. This allows even\nfairly complex alphanumeric passphrases to be brute-forced in a matter of\ndays, or even hours.\nIn order to make it harder to brute-force disk encryption passwords,\nAndroid 4.4 introduced support for a new key derivation function called\n260 Chapter 10\nscrypt.7 Scrypt employs a key derivation algorithm specifically designed to\nrequire large amounts of memory, as well as multiple iterations (such an\nalgorithm is called memory hard). This makes it harder to mount brute-\nforce attacks on specialized hardware such as ASICs or GPUs, which typi-\ncally operate with a limited amount of memory.\nScrypt can be tuned by specifying the variable parameters N, r, and p,\nwhich influence the required CPU resources, memory amount, and par-\nallelization cost, respectively. The values used in Android by default are\nN = 32768 (215), r = 8, and p = 2. They can be changed by setting the value of\nthe ro.crypto.scrypt_params system property using the N_factor:r_factor:p_factor\nformat; for example, 15:3:1 (the default). The value of each parameter is\ncomputed by raising 2 to the power of the respective factor. Android 4.4\ndevices automatically update the key derivation algorithm in the crypto\nfooter from PBKDF2 to scrypt and re-encrypt the master key using a scrypt-\nderived encryption key. When the encrypted master key is updated, the N,\nr, and p parameters that were used for KEK derivation are written to the\ncrypto footer.\nNOTE On the same desktop machine, brute-forcing a 4-digit PIN (using a naive, single-\nthreaded algorithm that generates all possible PINs starting from 0000) takes about\n5 milliseconds per PIN when using PBKDF2, and about 230 milliseconds per PIN\nwhen using scrypt as the KEK derivation function. In other words, brute-forcing\nPBKDF2 is almost 50 times cheaper (that is, faster) compared to scrypt.\nDisk Encryption Password\nAs discussed in the previous section, the KEK used to encrypt the disk\nencryption key is derived from a user-supplied password. When you first\nstart the device encryption process, you’re asked to either confirm your\ndevice unlock PIN or password, or set one if you haven’t already or you’re\nusing the pattern screen lock (see Figure 10-3). The entered password\nor PIN is then used to derive the master key encryption key, and you’re\nrequired to enter the password or PIN each time you boot the device, and\nthen once more to unlock the screen after it starts.\nAndroid doesn’t have a dedicated setting to manage the encryption pass-\nword after the device is encrypted, and changing the screen lock password or\nPIN will also silently change the device encryption password. This is most\nprobably a usability-driven decision: most users would be confused by having\nto remember and enter two different passwords at different times and would\nprobably quickly forget the less frequently used, and possibly more complex,\ndisk encryption password. While this design is good for usability, it effectively\nforces users to use a simple disk encryption password, because they have to\nenter it each time they unlock the device, usually dozens of times a day. No\none wants to enter a complex password that many times, and thus most users\nopt for a simple numeric PIN (unless a device policy requires otherwise).\n7. C. Percival and S. Josefsson, The scrypt Password-Based Key Derivation Function, http://tools.ietf\n.org/html/draft-josefsson-scrypt-kdf-01/\nDevice Security 261\nAdditionally, passwords are limited to\n16 characters (a limit that is hardwired\nin the framework and not configu-\nrable), so using a passphrase is not an\noption.\nWhat’s the problem with using the\nsame password for both disk encryp-\ntion and the lockscreen? After all,\nto get to the data on the phone you\nneed to guess the lockscreen password\nanyway, so why bother with a separate\none for disk encryption? The reason\nis that the two passwords protect your\nphone against two different types of\nattack. Most screen lock attacks would\nbe online, brute-force ones: essen-\ntially someone trying out different\npasswords on a running device when\nthey get brief access to it. After a few\nunsuccessful attempts, Android will\nlock the screen for 30 seconds (rate\nlimiting), and even wipe the device if\nthere are more failed unlock attempts Figure 10-3: Device encryption screen\n(if required by device policy). Thus,\neven a relatively short screen-lock\nPIN offers adequate protection against online attacks in most cases (see\n“Brute-Force Attack Protection” on page 276 for details).\nOf course, if someone has physical access to the device or a disk image\nof it, they can extract password hashes and crack them offline without wor-\nrying about rate-limiting or device wiping. This, in fact, is the scenario that\nfull disk encryption is designed to protect against: when a device is stolen\nor confiscated, the attacker can either brute-force the actual device, or copy\nits data and analyze it even after the device is returned or disposed of. As\nmentioned earlier in “Key Derivation” on page 260, the encrypted master\nkey is stored on disk, and if the password used to derive its encryption key is\nbased on a short numeric PIN, it can be brute-forced in minutes8 (or even\nseconds on pre-4.4 devices that use PBKDF2 for key derivation). A remote\nwipe solution could prevent this attack by deleting the master key, which\nonly takes a moment and renders the device useless, but this is often not an\noption because the device might be offline or turned off.\nChanging the Disk Encryption Password\nThe user-level part of disk encryption is implemented in the cryptfs module\nof Android’s volume management daemon (vold). crypfs has commands for\n8. Demonstrated by viaForensics in the “Into The Droid” talk, presented at DEF CON 20.\nSlides are available at https://www.defcon.org/images/defcon-20/dc-20-presentations/Cannon/\nDEFCON-20-Cannon-Into-The-Droid.pdf\n262 Chapter 10\nboth creating and mounting an encrypted volume, and for verifying and\nchanging the master key encryption password. Android system services\ncommunicate with cryptfs by sending commands to vold through a local\nsocket (also named vold), and vold sets system properties that describe the\ncurrent state of the encryption or mount process based on the received\ncommand. (This results in a fairly complex boot procedure, described in\ndetail in “Enabling Encryption” below and “Booting an Encrypted Device”\non page 265.)\nAndroid does not provide a UI to change only the disk encryption\npassword, but one can do so by communicating directly with the vold dae-\nmon using the vdc command-line utility. However, access to the vold control\nsocket is limited to the root user and members of the mount group, and fur-\nthermore, cryptfs commands are only available to the root and system users. If\nyou’re using an engineering build, or your device provides root access via a\n“superuser” app (see Chapter 13), you can send the cryptfs command shown\nin Listing 10-4 to vold in order to change the disk encryption password.\n# vdc cryptfs changepw <newpass>\n200 0 0\nListing 10-4: Changing the disk encryption password using vdc\nNOTE If you change your lockscreen password, the disk encryption password will be changed\nautomatically. (This does not apply to secondary users on multi-user devices.)\nEnabling Encryption\nAs mentioned in the previous section, the user-level part of Android’s\ndisk encryption is implemented by a dedicated cryptfs module of the vold\ndaemon. cryptfs provides the checkpw, restart, cryptocomplete, enablecrypto,\nchangepw, verifypw, getfield, and setfield commands, which the framework\nsends at various points of the encryption or encrypted volume mount pro-\ncess. In addition to the permissions set on the vold local socket, crypfs explic-\nitly checks the identity of the command sender, and only allows access to the\nroot and system users.\nControlling Device Encryption Using System Properties\nThe vold daemon sets a number of system properties in order to trigger the\nvarious stages of device encryption or mounting and to communicate the\ncurrent encryption state to framework services. The ro.crypto.state property\nholds the current encryption state, which is set to encrypted when the data\npartition has been successfully encrypted, and to unencrypted when it has\nnot yet been encrypted. The property can also be set to unsupported if the\ndevice does not support disk encryption. The vold daemon also sets various\npredefined values to the vold.decrypt property in order to signal the current\nstate of device encryption or mounting. The vold.encrypt_progress property\nholds the current encryption progress (from 0 to 100), or an error string if\nan error occurred during device encryption or mounting.\nDevice Security 263\nThe ro.crypto.fs_crypto_blkdev system property contains the name of the\nvirtual device allocated by the device mapper. After successfully decrypting\nthe disk encryption key, this virtual device is mounted at /data in place of the\nunderlying physical volume, as shown in Listing 10-5 (with output split for\nreadability).\n# mount|grep '/data'\n/dev/block/dm-0 /data ext4 rw,seclabel,nosuid,nodev,noatime,\nerrors=panic,user_xattr,barrier=1,nomblk_io_submit,data=ordered 0 0\nListing 10-5: Encrypted virtual block device mounted at /data\nUnmounting /data\nThe Android framework expects /data to be available, but it needs to be\nunmounted in order to be encrypted. This creates a catch-22 situation, which\nAndroid solves by unmounting the physical userdata partition and mounting\nan on-memory filesystem (tempfs) in its place while performing encryption.\nSwitching partitions at runtime in turn requires stopping and restarting cer-\ntain system services, which vold triggers by setting the value of the vold.decrypt\nsystem property to trigger_restart_framework, trigger_restart_min_framework, or\ntrigger_shutdown_framework. These values trigger different parts of init.rc, as\nshown in Listing 10-6.\n--snip--\non post-fs-datau\nchown system system /data\nchmod 0771 /data\nrestorecon /data\ncopy /data/system/entropy.dat /dev/urandom\n--snip--\non property:vold.decrypt=trigger_reset_mainv\nclass_reset main\non property:vold.decrypt=trigger_load_persist_props\nload_persist_props\non property:vold.decrypt=trigger_post_fs_dataw\ntrigger post-fs-data\non property:vold.decrypt=trigger_restart_min_frameworkx\nclass_start main\non property:vold.decrypt=trigger_restart_frameworky\nclass_start main\nclass_start late_start\non property:vold.decrypt=trigger_shutdown_frameworkz\nclass_reset late_start\nclass_reset main\n--snip-\nListing 10-6: vold .decrypt triggers in init .rc\n264 Chapter 10\nTriggering the Encryption Process\nWhen the user starts the encryption process via the system Settings UI with\nSecurity4Encrypt phone, the Settings app calls MountService, which in turn\nsends the cryptfs enablecrypto inplace password command to vold, where password\nis the lockscreen password. In turn, vold unmounts the userdata partition\nand sets vold.decrypt to trigger_shutdown_framework (z in Listing 10-6), which\nshuts down most system services except for those that are part of the core\nservice class. The vold daemon then unmounts /data, mounts a tempfs file-\nsystem in its place, and then sets vold.encrypt_progress to 0 and vold.decrypt\nto trigger_restart_min_framework (x in Listing 10-6). This starts a few more\nsystem services (in the main class) that are required for showing the encryp-\ntion progress UI.\nUpdating the Crypto Footer and Encrypting Data\nNext, vold sets up the virtual dm-crypt device and writes the crypto footer.\nThe footer can be written to the end of the userdata partition or to a dedi-\ncated partition or file, and its location is specified in the fstab file as the\nvalue of the encryptable flag. For example, on the Nexus 5 the crypto footer\nis written to the dedicated partition metadata, as shown in Listing 10-7 as u\n(with the single line broken for readability). When the crypto footer is writ-\nten at the end of the encrypted partition, the encryptable flag is set to the\nstring footer.\n--snip--\n/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4\nnoatime,nosuid,nodev,barrier=1,data=ordered,nomblk_io_submit,noauto_da_alloc,errors=panic\nwait,check,encryptable=/dev/block/platform/msm_sdcc.1/by-name/metadatau\n--snip--\nListing 10-7: The encryptable fstab flag specifies the location of the crypto footer\nThe crypto footer contains the encrypted disk encryption key (master\nkey), the salt used for KEK derivation, and other key derivation parameters\nand metadata. Its flags field is set to CRYPT_ENCRYPTION_IN_PROGRESS (0x2) to\nsignal that device encryption has started but not been completed.\nFinally, each block is read from the physical userdata partition and writ-\nten to the virtual dm-crypt device, which encrypts read blocks and writes\nthem to disk, thus encrypting the userdata partition in place. If encryption\ncompletes without errors, vold clears the CRYPT_ENCRYPTION_IN_PROGRESS flag\nand reboots the device.\nBooting an Encrypted Device\nBooting an encrypted device requires asking the user for the disk encryption\npassword. Rather then use a specialized bootloader UI, Android sets the vold.\ndecrypt system property to 1 and then starts a minimal set of system services in\norder to show a standard Android UI. As with device encryption, this again\nrequires mounting a tmpfs filesystem at /data in order to allow core system\nDevice Security 265\nservices to start. When the core framework is up, Android detects that vold.\ndecrypt is set to 1 and starts the userdata partition mount process.\nObtaining the Disk Encryption Password\nThe first step in this process is to check whether the partition has been suc-\ncessfully encrypted by sending the cryptfs cryptocomplete command to vold,\nwhich in turn checks whether the crypto footer is properly formatted and\nthat the CRYPT_ENCRYPTION_IN_PROGRESS flag is not set. If the partition is found\nto be successfully encrypted, the framework launches the password entry UI\nshown in Figure 10-4 provided by CryptKeeper, part of the system Settings app.\nThis activity acts as a home screen (launcher), and because it has higher pri-\nority than the default launcher, it’s started first after the device boots.\nIf the device is unencrypted, CryptKeeper disables itself and finishes,\nwhich causes the system activity manager to launch the default home screen\napplication. If the device is encrypted or in the process of being encrypted\n(that is, the vold.crypt property is not empty or set to trigger_restart_framework),\nthe CryptKeeper activity starts and hides the status and system bars. In addi-\ntion, CryptKeeper ignores hardware back button presses, thus disallowing navi-\ngation away from the password input UI.\nIf the encrypted device is corrupted, or the encryption process inter-\nrupted and the userdata partition left only partially encrypted, the device\ncannot be booted. In this case, CryptKeeper displays the UI shown in Fig-\nure 10-5, allowing the user to trigger a factory reset, which reformats the\nuserdata partition.\nFigure 10-4: Device encryption pass- Figure 10-5: UI shown if device\nword input UI encryption fails\n266 Chapter 10\nDecrypting and Mounting /data\nWhen the user enters their password, CryptKeeper sends the cryptfs checkpw\ncommand to vold by calling the decryptStorage() method of the system\nMountService. This instructs vold to check whether the entered password\nis correct by trying to mount the encrypted partition at a temporary\nmount point and then unmounting it. If the procedure succeeds, vold\nsets the name of the virtual block device allocated by the device-mapper\nas the value of ro.crypto.fs_crypto_blkdev property and returns control to\nMountService, which in turn sends the cryptfs restart command, instructing\nvold to restart all system services in the main class (v in Listing 10-6). This\nallows the tempfs filesystem to be unmounted, and the newly allocated vir-\ntual dm-crypt block device to be mounted at /data.\nStarting All System Services\nAfter the encrypted partition is mounted and prepared, vold sets vold.decrypt\nto trigger_post_fs_data (w in Listing 10-6), thus triggering the post-fs-data u\nsection of init.rc. The commands in this section set up file and directory\npermissions, restore SELinux contexts, and create required directories\nunder /data if necessary.\nFinally, post-fs-data sets the vold.post_fs_data_done property to 1, which\nvold polls periodically. When vold detects a value of 1, it sets the vold.decrypt\nproperty to trigger_restart_framework (y in Listing 10-6), which restarts all\nservices in the main class, and starts all delayed services (class late_start). At\nthis point, the framework is fully initialized and the device boots using the\ndecrypted view of the userdata partition mounted at /data. From this point\non, all data written by applications or the system is automatically encrypted\nbefore being committed to disk.\nLImITaTIONs Of DIsk ENCRYPTION\nDisk encryption only protects data at rest; that is, when the device is turned off .\nBecause disk encryption is transparent and implemented at the kernel level,\nafter an encrypted volume is mounted, it is indistinguishable from a plaintext\nvolume to user-level processes . Therefore disk encryption does not protect data\nfrom malicious programs running on the device . Applications that deal with\nsensitive data should not rely solely on full-disk encryption, but should imple-\nment their own, file-based encryption instead . The file encryption key should\nbe encrypted with a KEK derived from a user-supplied password, or some\nunchangeable hardware property if the data needs to be bound to the device .\nTo ensure file integrity, encrypted data must be authenticated using either an\nauthenticated encryption scheme like GCM, or an additional authentication\nfunction such as HMAC .\nDevice Security 267\nscreen security\nOne way to control access to an Android\ndevice is by requiring user authentica-\ntion in order to access the system UI\nand applications. User authentication\nis implemented by showing a lockscreen\neach time the device boots or its screen\nis turned on. The lockscreen on a single-\nuser device, configured to require a\nnumeric PIN to unlock, might look like\nFigure 10-6.\nIn early Android versions, the lock-\nscreen was only designed to protect\naccess to the device’s UI. As the plat-\nform evolved, the lockscreen has been\nextended with features that display\nwidgets that show up-to-date device\nor application state, allow switching\nbetween users on multi-user devices,\nand the ability to unlock the system\nkeystore. Similarly, the screen unlock\nPIN or password is now used to derive\nthe credential storage encryption key\n(for software implementations), as well Figure 10-6: PIN lockscreen\nas the disk encryption key KEK.\nLockscreen Implementation\nAndroid’s lockscreen (or keyguard) is implemented like regular Android\napplications: with widgets laid out on a window. It’s special because its win-\ndow lives on a high window layer that other applications cannot draw on top\nof or control. Additionally, the keyguard intercepts the normal navigation\nbuttons, which makes it impossible to bypass and thus “locks” the device.\nThe keyguard window layer is not the highest layer, however; dialogs\noriginating from the keyguard itself, and the status bar, are drawn over\nthe keyguard. You can see a list of the currently shown windows using the\nHierarchy Viewer tool available with the ADT. When the screen is locked,\nthe active window is the Keyguard window, as shown in Figure 10-7.\nNOTE Prior to Android 4.0, third-party applications could show windows in the keyguard\nlayer, which allowed applications to intercept the Home button and implement\n“kiosk”-style applications. However, because this functionality was abused by certain\nmalware applications, since Android 4.0 adding windows to the keyguard layer\nrequires the INTERNAL_SYSTEM_WINDOW signature permission, which is available only to\nsystem applications.\n268 Chapter 10\nFigure 10-7: Keyguard window position in Android’s\nwindow stack\nFor a long time, the keyguard was an implementation detail of Android’s\nwindow system and was not separated into a dedicated component. With\nthe introduction of lockscreen widgets, dreams (that is, screensavers), and\nsupport for multiple users, the keyguard gained quite a lot of new functional-\nity and was eventually extracted in a dedicated system application, Keyguard, in\nAndroid 4.4. The Keyguard app lives in the com.android.systemui process, along\nwith the core Android UI implementation.\nThe UI for each unlock method (discussed next) is implemented as a\nspecialized view component. This component is hosted by a dedicated view\ncontainer class called KeyguardHostView, along with keyguard widgets and\nother helper UI components. For example, the PIN unlock view shown in\nFigure 10-6 is implemented in the KeyguardPINView class, and password unlock\nis implemented by the KeyguardPasswordView class. The KeyguardHostView class\nautomatically selects and displays the appropriate keyguard view for the cur-\nrently configured unlock method and device state. Unlock views delegate\npassword checks to the LockPatternUtils class, which is responsible for compar-\ning user input to saved unlock credentials, as well as for persisting password\nchanges to disk and updating authentication-related metadata.\nBesides the implementations of keyguard unlock views, the Keyguard\nsystem application includes the exported KeyguardService service, which\nexposes a remote AIDL interface, IKeyguardService. This service allows its\nclients to check the current state of the keyguard, set the current user,\nlaunch the camera, and hide or disable the keyguard. Operations that\nchange the state of the keyguard are protected by a system signature per-\nmission, CONTROL_KEYGUARD.\nKeyguard Unlock Methods\nStock Android provides several keyguard unlock methods (also called secu-\nrity modes in Android’s source code). Of these, five can be directly selected\nin the Choose screen lockscreen: Slide, Face Unlock, Pattern, PIN, and\nPassword, as shown in Figure 10-8.\nDevice Security 269\nThe Slide unlock method requires no user authentication and its\nsecurity level is therefore equivalent to selecting None. Both states\nare represented internally by setting the current security mode to the\nKeyguardSecurityModel.SecurityMode.None enum value. As of this writing, Face\nUnlock is the only implementation of the SecurityMode.Biometric security\nmode and is internally referred to as “weak biometric” (a “strong bio-\nmetric” could be implemented with fingerprint or iris recognition in a\nfuture version). Unlock methods that are not compatible with the current\ndevice security policy (the top three in Figure 10-8) are disabled and can-\nnot be selected. The security policy can be set either explicitly by a device\nadministrator, or implicitly by enabling a security-related OS feature such\nas credential storage or full-disk encryption.\nThe Pattern unlock method (SecurityMode.Pattern) is Android-specific\nand requires drawing a predefined pattern on a 3×3 grid to unlock the\ndevice, as shown in Figure 10-9.\nFigure 10-8: Directly selectable Figure 10-9: Configuring the Pattern\nkeyguard unlock methods unlock method\nThe PIN (SecurityMode.PIN) and Password (SecurityMode.Password) unlock\nmethods are implemented similarly, but differ by the scope of allowed char-\nacters: only numeric (0-9) for the PIN, or alphanumeric for Password are\nallowed.\n270 Chapter 10\nThe SecurityMode enum defines three more unlock methods that are not\ndirectly selectable in the Choose screen lockscreen: SecurityMode.Account,\nSecurityMode.SimPin, and SecurityMode.SimPuk. The SecurityMode.Account\nmethod is available only on devices that support Google accounts (Google\nexperience devices) and is not an independent unlock method. It can\nonly be used as a fallback method for another security mode. Similarly,\nSecurityMode.SimPin and SecurityMode.SimPuk are not lockscreen unlock meth-\nods per se; they’re only available if the device’s SIM card requires a PIN\nbefore use. Because the SIM card remembers the PIN authentication sta-\ntus, the PIN or PUK must be entered only once—when the device boots\n(or if the SIM card state is otherwise reset). We’ll delve deeper into the\nimplementation of each lockscreen security mode in the next sections.\nFace Unlock\nFace Unlock is a relatively new unlock\nmethod introduced in Android 4.0. It\nuses the device’s front-facing camera to\nregister an image of the owner’s face\n(see Figure 10-10) and relies on image\nrecognition technology to recognize\nthe face captured when unlocking the\ndevice. Although improvements to Face\nUnlock’s accuracy have been made\nsince its introduction, it’s considered\nthe least secure of all unlock methods,\nand even the setup screen warns users\nthat “someone who looks similar to you\ncould unlock your phone.” In addition,\nFace Unlock requires a backup unlock\nmethod—either a pattern or a PIN, to\nhandle situations when face recogni-\ntion is not possible (such as poor light-\ning, camera malfunction, and so on).\nThe Face Unlock implementation is\nbased on facial recognition technology\ndeveloped by the PittPatt (Pittsburgh\nPattern Recognition) company, which Figure 10-10: Face Unlock setup\nGoogle acquired in 2011. The code screen\nremains proprietary and no details are\navailable about the format of the stored\ndata or the recognition algorithms employed. As of this writing, the imple-\nmentation of Face Unlock resides in the com.android.facelock package.\nDevice Security 271\nPattern Unlock\nAs shown in Figure 10-9, the code for pattern unlock is entered by join-\ning at least four points on a 3×3 matrix. Each point can be used only once\n(crossed points are disregarded) and the maximum number of points is\nnine. Internally, the pattern is stored as a byte sequence, with each point\nrepresented by its index, where 0 is top left and 8 is bottom right. Thus the\npattern is similar to a PIN with a minimum of four and maximum of nine\ndigits, which uses only nine distinct digits (0 to 8). However, because points\ncannot be repeated, the number of variations in an unlock pattern is con-\nsiderably lower compared to those of a nine-digit PIN.\nThe hash for the pattern lock is stored in /data/system/gesture.key (/data/\nsystem/users/<user ID>/gesture.key on multi-user devices) as an unsalted SHA-1\nvalue. By simply dumping this file, we can easily see that the contents of the\ngesture.key file for the pattern in Figure 10-9 (represented as 00010204060708\nin hexadecimal) shown in Listing 10-8 matches the SHA-1 hash of the pat-\ntern byte sequence, which is 6a062b9b3452e366407181a1bf92ea73e9ed4c48 for\nthis example.\n# od -t x1 /data/system/gesture.key\n0000000 6a 06 2b 9b 34 52 e3 66 40 71 81 a1 bf 92 ea 73\n0000020 e9 ed 4c 48\nListing 10-8: Contents of the /data/system/gesture .key file\nBecause a random salt value isn’t used when calculating the hash,\neach pattern is always hashed to the same value, which makes it relatively\neasy to generate a precomputed table of all possible patterns and their\nrespective hashes. (Such tables are readily available online.) This allows\nfor instant recovery of the pattern once the gesture.key file is obtained.\nHowever, the file is owned by the system user and its permissions are set\nto 0600, so recovery is not usually possible on production devices. The\nentered pattern is checked against the saved hash using the checkPattern()\nmethod of the LockScreenUtils class, and the pattern hash is calculated and\npersisted using the saveLockPattern() method of that class. Saving the pat-\ntern also sets the current password quality value to DevicePolicyManager\n.PASSWORD_QUALITY_SOMETHING.\nAnother unfortunate property of the pattern unlock method is that\nbecause capacitive touch screens are operated directly using a finger (not\nwith a stylus or a similar tool), drawing the unlock pattern multiple times\nleaves a distinct trace on a touch screen, making it vulnerable to the so\ncalled “smudge attack.” Using appropriate lighting and cameras, finger\nsmudges on the screen can be detected, and the unlock pattern can be\ninferred with a very high probability. For these reasons, the pattern unlock\nmethod’s security level is considered very low. In addition, because the\nnumber of combinations is limited, the unlock pattern is a poor source\nof entropy and is disallowed when the user’s unlock credential is used\n272 Chapter 10\nto derive an encryption key, such as\nthose used for system’s keystore and\ndevice encryption.\nLike Face Unlock, the pattern\nunlock method supports a backup\nunlock mechanism that is only made\navailable after the user enters an invalid\npattern more than five times. Backup\nauthentication must be manually acti-\nvated by pressing the Forgot Pattern\nbutton shown at the bottom of the lock-\nscreen. After the button is pressed, the\ndevice goes into the SecurityMode.Account\nsecurity mode and displays the screen\nshown in Figure 10-11.\nThe user can enter the creden-\ntials of any Google account registered\non the device to unlock it, and then\nreset or change the unlock method.\nTherefore, having a Google account\nwith an easy to guess (or shared) pass-\nword registered on the device could\nbe a potential backdoor to the device’s Figure 10-11: Google account unlock\nlockscreen. mode\nNOTE As of this writing, Google accounts that have been configured to require two-factor\nauthentication cannot be used to unlock the device.\nPIN and Password Unlock\nThe PIN and password methods are essentially equivalent: they compare\nthe hash of the user’s input to a salted hash stored on the device and unlock\nit if the values match. The hash of the PIN or password is a combination\nof the SHA-1 and MD5 hash values of the user input, salted with a 64-bit\nrandom value. The calculated hash is stored in the /data/misc/password.key\n(/data/system/users/<user ID>/password.key on multi-user devices) file as a\nhexadecimal string and may look like Listing 10-9.\n# cat /data/system/password.key && echo\n9B93A9A846FE2FC11D49220FC934445DBA277EB0AF4C9E324D84FFC0120D7BAE1041FAAC\nListing 10-9: Contents of the /data/misc/password .key file\nThe salt used for calculating the hash values was saved in the secure\ntable of the system’s SettingsProvider content provider under the lockscreen\n.password_salt key in Android versions prior to 4.2, but was moved to a dedi-\ncated database, along with other lockscreen-related metadata in order to\nDevice Security 273\nsupport multiple users per device. As of Android 4.4, the database is located\nin /data/system/locksettings.db and is accessed via the ILockSettings AIDL\ninterface of the LockSettingsService.\nAccessing the service requires the ACCESS_KEYGUARD_SECURE_STORAGE signature\npermission, which is only allowed to system applications. The locksettings.db\ndatabase has a single table, also called locksettings, which may contain data\nlike Listing 10-10 for a particular user (the user column contains the Android\nuser ID).\nsqlite> select name, user, value from locksettings where user=0;\nname |user|value\n--snip--\nlockscreen.password_salt |0 |6909501022570534487u\n--snip--\nlockscreen.password_type_alternate|0 |0v\nlockscreen.password_type |0 |131072w\nlockscreen.passwordhistory |0 |5BFE43E89C989972EF0FA0EC00BA30F356EE7B\n7C7BF8BC08DEA2E067FF6C18F8CD7134B8,EE29A531FE0903C2144F0618B08D1858473C50341A7\n8DEA85D219BCD27EF184BCBC2C18Cx\nListing 10-10: Contents of /data/system/locksettings .db for the owner user\nHere, the lockscreen.password_salt setting u stores the 64-bit (represented\nas a Java long type) salt value, and the lockscreen.password_type_alternate set-\nting v contains the type of the backup (also called alternate) unlock method\ntype (0 means none) for the current unlock method. lockscreen.password_type w\nstores the currently selected password type, represented by the value of the\ncorresponding PASSWORD_QUALITY constant defined in the DevicePolicyManager\nclass. In this example, 131072 (0x00020000 in hexadecimal) corresponds to\nthe PASSWORD_QUALITY_NUMERIC constant, which is the password quality provided\nby a numeric PIN. Finally, lockscreen.passwordhistory x contains the password\nhistory, saved as a sequence of previous PIN or password hashes, separated by\ncommas. The history is only saved if the history length has been set to a value\ngreater than zero using one of the setPasswordHistoryLength() methods of the\nDevicePolicyManager class. When password history is available, entering a new\npassword that is the same as any password in the history is forbidden.\nThe password hash can be easily calculated by concatenating the pass-\nword or PIN string (1234 for this example) with the salt value formatted as a\nhexadecimal string (5fe37a926983d657 for this example) and calculating the\nSHA-1 and MD5 hashes of the resulting string, as shown in Listing 10-11.\n$ SHA1=`echo -n '12345fe37a926983d657'|sha1sum|cut -d- -f1|tr '[a-z]' '[A-Z]'`u\n$ MD5=`echo -n '12345fe37a926983d657'|md5sum|cut -d- -f1|tr '[a-z]' '[A-Z]'`v\n$ echo \"$SHA1$MD5\"|tr -d ' 'w\n9B93A9A846FE2FC11D49220FC934445DBA277EB0AF4C9E324D84FFC0120D7BAE1041FAAC\nListing 10-11: Calculating a PIN or password hash using sha1sum and md5sum\nIn this example the hashes are calculated using the sha1sum u and md5sum\nv commands. When concatenated w, the output of the two commands pro-\nduces the string contained in the password.key file shown in Listing 10-9.\n274 Chapter 10\nNote that while using a random hash makes it impossible to use a single\nprecalculated table for brute-forcing the PIN or password of any device, cal-\nculating the password or hash requires a single hash invocation, so generat-\ning a targeted hash table for a particular device (assuming the salt value is\nalso available) is still relatively cheap. Additionally, while Android calculates\nboth the SHA-1 and MD5 hashes of the PIN or password, this provides no\nsecurity value, as it is sufficient to target the shorter hash (MD5) in order to\nuncover the PIN or password.\nThe entered password is checked against the stored hash using the\nLockPatternUtils.checkPassword() method, and the hash of a user-supplied\npassword is calculated and persisted using the one of the saveLockPassword()\nmethods of that class. Calling saveLockPassword() updates the password.key\nfile for the target (or current) user. Like gesture.key, this file is owned by the\nsystem user and has permissions 0600. In addition to updating the password\nhash, saveLockPassword() calculates the complexity of the entered password\nand updates the value column corresponding to the lockscreen.password_type\nkey (w in Listing 10-10) in locksettings.db with the calculated complexity\nvalue. If password history is enabled, saveLockPassword() also adds the PIN\nor password hash to the locksettings table (x in Listing 10-11).\nRecall that when the device is encrypted, the PIN or password is used\nto derive a KEK that encrypts the disk encryption key. Therefore, changing\nthe PIN or password of the owner user also re-encrypts the disk encryp-\ntion key by calling the changeEncryptionPassword() method of the system’s\nMountService. (Changing the PIN or password of a secondary user does not\naffect the disk encryption key.)\nPIN and PUK Unlock\nThe PIN and PUK security modes are not lockscreen unlock methods per se\nbecause they depend on the state of the device’s SIM card and are only shown\nif the SIM card is in a locked state. A SIM card can require users to enter a\npreconfigured PIN code in order to unlock the card and get access to any\nnetwork authentication keys stored inside, which are required to register with\nthe mobile network and place non-emergency calls.\nBecause a SIM card retains its unlock state until reset, the PIN code\ntypically must be entered only when the device first boots. If an incorrect\ncode is entered more than three times, the SIM card locks and requires the\nuser to enter a separate code to unlock it called the PIN unlock key (PUK), or\npersonal unblocking code (PUC).\nWhen the lockscreen is shown, Android checks the state of the SIM\ncard, and if it’s State.PIN_REQUIRED (defined in the IccCardConstants class), it\nshows the SIM unlock keyguard view shown in Figure 10-12. When the user\nenters a SIM unlock PIN, it’s passed to the supplyPinReportResult() method\nof the ITelephony interface (implemented in the TeleService system appli-\ncation), which in turn passes it to the device’s baseband processor (the\ndevice component that implements mobile network communication, also\nsometimes referred to as the modem or radio) via the radio interface dae-\nmon (rild). Finally, the baseband processor, which is directly connected to\nDevice Security 275\nthe SIM, sends the PIN to the SIM card\nand receives a status code in exchange.\nThe status code is passed back to the\nunlock view via the same route. If the\nstatus code indicates that the SIM card\naccepted the PIN and no screen lock is\nconfigured, the home screen (launcher)\nis displayed next. If, on the other hand,\na screen lock has been configured, it’s\nshown after unlocking the SIM card, and\nthe user must enter their credentials in\norder to unlock the device.\nIf the SIM card is locked (that is, in\nthe PUK_REQUIRED state), Android shows a\nPUK entry screen and allows the user to\nset up a new PIN after they unlock the\ncard. The PUK and new PIN are passed\nto the supplyPukReportResult() method of\nthe ITelephony interface, which delivers\nthem to the SIM card. If a screen lock is\nconfigured, it is shown when the PUK is\nvalidated and the new PIN configured.\nFigure 10-12: SIM unlock screen\nThe Keyguard system application\nmonitors SIM state changes by register-\ning for the TelephonyIntents.ACTION_SIM_\nSTATE_CHANGED broadcast and shows the\nlockscreen if the card becomes locked\nor permanently disabled. Users can\ntoggle the SIM card’s PIN protection\nby navigating to Settings4Security4\nSet up SIM card lock and using the\nLock SIM card checkbox.\nBrute-Force Attack Protection\nBecause complex passwords can be\ntricky to input on a touch screen key-\nboard, users typically use relatively\nshort unlock credentials, which can\neasily be guessed or brute-forced.\nAndroid protects against brute-force\nattacks executed directly on the device\n(online attacks) by requiring users to\nwait 30 seconds after each five sub-\nsequent failed authentication attempts,\nas shown in Figure 10-13. This tech-\nnique is referred to as rate limiting. Figure 10-13: Rate limiting after five\nsubsequent failed authentication\nattempts\n276 Chapter 10\nTo further deter brute-force attacks, password complexity, expiration,\nand history rules can be set and enforced using the DevicePolicyManager\nAPI, as discussed in Chapter 9. If the device stores or allows access to\nsensitive corporate data, device administrators can also set a threshold\nfor the allowed failed authentication attempts using the DevicePolicyManager\n.setMaximumFailedPasswordsForWipe() method. When the threshold is reached,\nall user data on the device is automatically deleted, preventing attackers\nfrom gaining unauthorized access to it.\nsecure UsB Debugging\nOne reason for Android’s success is the low entry barrier to application\ndevelopment; apps can be developed on any OS, in a high-level language,\nwithout the need to invest in developer tools or hardware (when using the\nAndroid emulator). Developing software for embedded or other dedicated\ndevices has traditionally been difficult, because it’s usually hard (or in some\ncases impossible) to inspect a program’s internal state or otherwise interact\nwith the device in order to debug programs.\nSince its earliest versions, Android has included a powerful device\ninteraction toolkit that allows interactive debugging and inspecting device\nstate, called the Android Debug Bridge (ADB). ADB is typically turned off\non consumer devices, but can be turned on via the system UI in order to\nenable app development and debugging on the device. Because ADB pro-\nvides privileged access to the device’s filesystem and applications, it can be\nused to obtain unauthorized access to data. In the following sections, we’ll\ndiscuss ADB’s architecture, then discuss the steps recent Android versions\nhave taken to restrict access to ADB.\nADB Overview\nADB keeps track of all devices (or emulators) connected to a host, and\noffers various services to its clients (command line clients, IDEs, and so on).\nIt consists of three main components: the ADB server, the ADB daemon\n(adbd), and the default command-line client (adb). The ADB server runs\non the host machine as a background process and decouples clients from\nthe actual devices or emulators. It monitors device connectivity and sets\ntheir state appropriately (CS_CONNECTED, CS_OFFLINE, CS_RECOVERY, and so on).\nThe ADB daemon runs on an Android device (or emulator) and pro-\nvides the actual services client use. It connects to the ADB server through\nUSB or TCP/IP, and receives and processes commands from it. The adb\ncommand-line client lets you send commands to a particular device. In prac-\ntice, it is implemented in the same binary as the ADB server and thus shares\nmuch of its code. Figure 10-14 shows an overview of ADB’s architecture.\nDevice Security 277\nHost (PC) Android Device\nADB Client 1\n(adb command)\nADB Client 2\n(Eclipse ADT)\nTCP\nlocalhost:5037\nADB Server (adb) USB or TCP adbd\nFigure 10-14: ADB architecture\nNOTE In addition to the native implementation in the adb command and the Java-based one\nin the Android Development Tools (ADT) Eclipse plugin, various third-party imple-\nmentations of the ADB protocol are also available, including a Python client 9 and\nan ADB server implemented in JavaScript,10 which can be embedded in the Chrome\nbrowser as an extension.\nThe client talks to the local ADB server via TCP (typically via\nlocalhost:5037) using text-based commands, and receives OK or FAIL\nresponses in return. Some commands, like enumerating devices, port for-\nwarding, or daemon restart are handled by the local daemon, while oth-\ners (like shell or log access) require a connection to the target Android\ndevice. Device access is generally accomplished by forwarding input and\noutput streams to/from the host. The transport layer that implements\nthis uses simple messages with a 24-byte header, which contains a com-\nmand identifier, two arguments, the length and CRC32 of the optional\npayload that follows, and a magic value, which simply flips all bits of the\ncommand. The message structure is defined in system/core/adb/adb.h and\nis shown in Listing 10-12 for reference. Messages are in turn encapsulated\nin packets, which are sent over the USB or TCP link to the ADB server\nrunning on the device.\nstruct amessage {\nunsigned command; /* command identifier constant */\nunsigned arg0; /* first argument */\nunsigned arg1; /* second argument */\nunsigned data_length; /* length of payload (0 is allowed) */\n9. Anthony King, “PyAdb: basic ADB core for python using TCP,” https://github.com/cybojenix/\nPyAdb/\n10. Kenny Root, “adb-on-chrome: ADB (Android Debug Bridge) server as a Chrome exten-\nsion,” https://github.com/kruton/adb-on-chrome/\n278 Chapter 10\nunsigned data_check; /* checksum of data payload */\nunsigned magic; /* command ^ 0xffffffff */\n};\nListing 10-12: ADB message structure\nWe won’t discuss the ADB protocol in more detail other than to note\nthe authentication commands added to the protocol in order to implement\nsecure USB debugging. (For more details on ADB, see the protocol descrip-\ntion in the system/core/adb/protocol.txt file in Android’s source tree.)\nNOTE You can enable trace logs for all ADB services by setting the ADB_TRACE environment\nvariable to 1 on the host and the persist.adb.trace_mask system property on the\ndevice. Selected services can be traced by setting the value of ADB_TRACE or persist\n.adb.trace_mask to a comma- or space-separated (columns or semi-columns as a sepa-\nrator are also supported) list of service tags. See system/core/adb/adb.c for the full\nlist of supported tags.\nThe Need for Secure ADB\nIf you’ve done any development, you know that “debugging” is usually the\nexact opposite of “secure.” Debugging typically involves inspecting (and\nsometimes even changing) internal program state, dumping encrypted\ncommunication data to log files, universal root access, and other scary but\nnecessary activities. Debugging is hard enough without having to bother\nwith security, so why further complicate things by adding additional secu-\nrity layers? Android debugging, as provided by the ADB, is quite versatile\nand gives you almost complete control over a device when enabled. This fea-\nture is, of course, very welcome when developing or testing an application\n(or the OS itself), but it can also be used for other purposes.\nHere’s a selective list of things ADB lets you do:\n• Copy files to and from the device\n• Debug apps running on the device (using JWDP or gdbserver)\n• Execute shell commands on the device\n• Get the system and apps logs\n• Install and remove apps\nIf debugging is enabled on a device, you can do all of the above and\nmore (for example, inject touch events or input text in the UI) simply by\nconnecting the device to a computer with a USB cable. Because ADB does\nnot depend on the device’s screen lock, you don’t have to unlock the device\nin order to execute ADB commands, and on most devices that provide\nroot access, connecting via ADB allows you to access and change every file,\nincluding system files and password databases. Worse, you don’t actually\nneed a computer with development tools in order to access an Android\ndevice via ADB; another Android device and a USB On-The-Go (OTG)\ncable are sufficient. Android tools that can extract as much data as possible\nDevice Security 279\nfrom another device in a very short time are readily available.11 If the device\nis rooted, such tools can extract all of your credentials, disable or brute-\nforce the screen lock, and even log into your Google account. But even with-\nout root, anything on external storage, most notably photos, is accessible, as\nare your contacts and text messages.\nSecuring ADB\nAndroid 4.2 was the first version to try to make ADB access harder by hid-\ning the Developer options settings screen, requiring you to use a “secret\nknock” (tapping the build number seven times) in order to enable it. While\nnot a very effective access protection method, it makes sure that most users\ndon’t accidentally enable ADB access. This is, of course, only a stop-gap\nmeasure, and as soon as you man-\nage to turn USB debugging on, your\ndevice is once again vulnerable.\nAndroid 4.2.2 introduced a proper\nsolution with the so-called secure USB\ndebugging feature. “Secure” here\nrefers to the fact that only hosts that\nare explicitly authorized by the user\ncan now connect to the adbd daemon\non the device and execute debugging\ncommands. Thus if someone tries to\nconnect a device to another one via USB\nin order to access ADB, they must first\nunlock the target device and authorize\naccess from the debug host by clicking\nOK in the confirmation dialog shown\nin Figure 10-15.\nYou can make your decision persis-\ntent by checking the Always allow from\nthis computer checkbox and debug-\nging will work just as before, as long as\nyou’re on the same machine.\nNaturally, this secure USB debug-\nging is only effective if you have a rea- Figure 10-15: USB debugging autho-\nsonably secure lockscreen password in rization dialog\nplace.\nNOTE On tablets with multi-user support, the confirmation dialog is only shown to the\nprimary (owner) user.\n11. Kyle Osborn, “p2p-adb Framework,” https://github.com/kosborn/p2p-adb/\n280 Chapter 10\nSecure ADB Implementation\nThe ADB host authentication functionality is enabled by default when the\nro.adb.secure system property is set to 1, and there is no way to disable it via\nthe system interface. When a device connects to a host, it is initially in the\nCS_UNAUTHORIZED state and only goes into the CS_DEVICE state after the host has\nauthenticated. Hosts use RSA keys in order to authenticate to the ADB dae-\nmon on the device, typically following this three-step process:\n1. When a host tries to connect, the device sends an A_AUTH message with\nan argument of type ADB_AUTH_TOKEN that includes a 20-byte random\nvalue (read from /dev/urandom/).\n2. The host responds with an A_AUTH message with an argument of type\nADB_AUTH_SIGNATURE, which includes a SHA1withRSA signature of the ran-\ndom token with one of the host’s private keys.\n3. The device tries to verify the received signature, and if signature veri-\nfication succeeds, it responds with an A_CNXN packet and goes into the\nCS_DEVICE state. If verification fails, either because the signature value\ndoesn’t match, or because there is no corresponding public key to verify\nwith, the device sends another ADB_AUTH_TOKEN with a new random value\nso that the host can try authenticating again (slowing down if the num-\nber of failures goes over a certain threshold).\nSignature verification typically fails the first time you connect the device\nto a new host because it doesn’t yet have the host’s key. In that case the host\nsends its public key in an A_AUTH message with an ADB_AUTH_RSAPUBLICKEY argu-\nment. The device takes the MD5 hash of that key and displays it in the Allow\nUSB debugging confirmation dialog shown in Figure 10-15. Since adbd is a native\ndaemon, the key must be passed to the main Android OS in order for its hash\nto be displayed on screen. This is accomplished by simply writing the key to a\nlocal socket (also named adbd), which the adbd daemon monitors.\nWhen you enable ADB debugging from the developer settings screen, a\nthread that listens to that adbd socket is started. When the thread receives a\nmessage starting with PK, it treats it as a public key, parses it, calculates the\nMD5 hash and displays the confirmation dialog (implemented in a dedi-\ncated activity, UsbDebuggingActivity, part of the SystemUI package). If you tap\nOK, the activity sends a simple OK response to adbd, which uses the key to\nverify the authentication message. If you check the Always allow from this\ncomputer checkbox, the public key is written to disk and automatically used\nfor signature verification the next time you connect to the same host.\nNOTE As of version 4.3, Android allows you to clear all saved host authentication keys.\nThis functionality can be triggered by selecting Settings4Developer options4Revoke\nUSB debugging authorizations.\nDevice Security 281",
    "question": "What are the key security mechanisms and challenges associated with Android's disk encryption and verified boot systems?",
    "summary": "Android uses dm-verity to verify the integrity of the system partition during boot, requiring OTA updates to modify both file blocks and the hash tree. Disk encryption is implemented using dm-crypt and AES in CBC mode, with the key derived from a user password, and later replaced by scrypt for better security. The encryption process involves mounting an encrypted volume, which requires unmounting /data first, and is managed through system properties and the vold daemon. ADB debugging is secured by requiring host authentication with RSA keys, preventing unauthorized access to the device."
  },
  {
    "start": 167,
    "end": 185,
    "text": "The UsbDeviceManager class provides public methods for allowing and\ndenying USB debugging, clearing cached authentication keys, as well as\nfor starting and stopping the adbd daemon. Those methods are made avail-\nable to other applications via the IUsbManager AIDL interface of the system\nUsbService. Calling IUsbManager methods that modify device state requires the\nMANAGE_USB system signature permission.\nADB Authentication Keys\nAlthough we described the ADB authentication protocol above, we haven’t\nsaid much about the actual keys used in the process: 2048-bit RSA keys gen-\nerated by the local ADB server. These keys are typically stored in $HOME/\n.android (%USERPOFILE%\\.android on Windows) as adbkey (private key)\nand adbkey.pub (public key). The default key directory can be overridden by\nsetting the ANDROID_SDK_HOME environment variable. If the ADB_VENDOR_KEYS envi-\nronment variable is set, the directory it points to is also searched for keys. If\nno keys are found in any of the above locations, a new key pair is generated\nand saved.\nThe private key file (adbkey), which is only stored on the host, is in stan-\ndard OpenSSL PEM format. The public key file (adbkey.pub) contains the\nBase 64–encoded mincrypt-compatible representation of the public key,\nwhich is basically a serialization of mincrypt’s RSAPublicKey structure (see\n“Enabling Verified Boot” on page 256), followed by a user@host user identi-\nfier, separated by space. The user identifier doesn’t seem to be used as of\nthis writing and is only meaningful on Unix-based OSes; on Windows, it is\nalways unknown@unknown.\nKeys are stored on the device in the /data/misc/adb/adb_keys/ file, and\nnew authorized keys are appended to the same file as you accept them.\nRead-only “vendor keys” are stored in the /adb_keys file, but it doesn’t seem\nto exist on current Nexus devices. Public keys are in the same format as on\nthe host, making it easy to load in libmincrypt, which adbd links statically.\nListing 10-13 shows some sample adb_keys. The file is owned by the system\nuser, its group is set to shell, and its permissions to 0640.\n# cat data/misc/adb/adb_keys\nQAAAAJs1UDFt17wyV+Y2GNGF+EgWoiPfsByfC4frNd3s64w3IGt25fKERnl7O8/A+iVPGv1W\n--snip--\nyZ61cFd7R6ohLFYJRPB6Dy7tISUPRpb+NF4pbQEAAQA= unknown@unknown\nQAAAAKFLvP+fp1cB4Eq/6zyV+hnm1S1eV9GYd7cYe+tmwuQZFe+O4vpeow6huIN8YbBRkr7\n--snip--\nm7+bGd6F0hRkO82gopy553xywXU7rI/aMl6FBAEAAQA= user1@host2\nListing 10-13: Contents of the adb_keys file\nVerifying the Host Key Fingerprint\nWhile the USB debugging confirmation dialog helpfully displays a key fin-\ngerprint to let you verify that you’re connected to the expected host, the\nadb client doesn’t have a handy command to print the fingerprint of the\n282 Chapter 10\nhost key. Although it may seem that there’s little room for confusion (after\nall, there is only one cable plugged in to a single machine) when running a\ncouple of VMs, things can get a little fuzzy. Listing 10-14 shows one way to\ndisplay the host key’s fingerprint in the same format used by the confirma-\ntion dialog shown in Figure 10-15 (run in $HOME/.android or specify the\nfull path to the public key file).\n$ cut -d' ' -f1 adbkey.pub|openssl base64 -A -d -a | \\\nopenssl md5 -c|cut -d' ' -f2|tr '[a-z]' '[A-Z]'\n69:D4:AC:0D:AF:6B:17:88:BA:6B:C4:BE:0C:F7:75:9A\nListing 10-14: Displaying the host key’s fingerprint\nandroid Backup\nAndroid includes a backup framework that allows application data to be\nbacked up to Google’s cloud storage and supports full backup of installed\nAPK files, application data, and external storage files to a host machine\nconnected via USB. While device backup is not exactly a security feature,\nbackups allow application data to be extracted from the device, which can\npresent a security issue.\nAndroid Backup Overview\nAndroid’s backup framework was publicly announced in Android 2.2, but\nit was probably available internally earlier. The framework lets applications\ndeclare special components called backup agents, which are called by the sys-\ntem when creating a backup for an application and when restoring its data.\nWhile the backup framework did support pluggable backup transports\ninternally, initially the only transport that was usable in practice was a pro-\nprietary one that stores application data in Google’s cloud storage.\nCloud Backup\nBecause backups are associated with a user’s Google account, when they\ninstall an application that has a backup agent on a new device, the applica-\ntion’s data can be automatically restored if the user has registered the same\nGoogle account as the one used when the backup was created. Backup and\nrestore is managed by the system and cannot typically be triggered or con-\ntrolled by users (though developer commands that trigger cloud backup are\naccessible via the Android shell). By default, backups are triggered periodi-\ncally, and restore only when an app is first installed on a device.\nLocal Backup\nAndroid 4.0 added a new, local backup transport that lets users save back-\nups to a file on their desktop computer as well. Local backup (also called\nfull backup) requires ADB debugging to be enabled and authorized because\nDevice Security 283\nbackup data is streamed to the host\ncomputer using the same method that\nADB (via adb pull) employs to transfer\ndevice files to a host.\nFull backup is started by executing\nthe adb backup command in a shell. This\ncommand starts a new Java process on\nthe device, which binds to the system’s\nBackupManagerService and requests a\nbackup with the parameters specified\nto adb backup. The BackupManagerService\nin turn starts a confirmation activity\nlike the one shown in Figure 10-16,\nprompting the user to authorize the\nbackup and specify a backup encryp-\ntion password if desired. If the device\nis already encrypted, the user must enter\nthe device encryption password to pro-\nceed. This password will be used to\nencrypt the backup as well, because\nusing a dedicated backup encryp-\ntion password is not supported. The\nfull backup process is started when Figure 10-16: Backup confirmation\nthe user presses the Back up my data dialog\nbutton.\nFull backup calls the backup agent of each target package in\norder to obtain a copy of its data. If a backup agent is not defined, the\nBackupManagerService uses an internal FullBackupAgent class, which copies\nall of the package’s files. Full backup honors the allowBackup attribute of\nthe <application> tag in the package’s AndroidManifest.xml file, and will not\nextract package data if allowBackup is set to false.\nIn addition to application data, full backup can include user-installed\nand system application APK files, as well as external storage contents, with\nsome limitations: full backup doesn’t back up protected (with DRM) apps,\nand skips some system settings such as mobile network APNs and Wi-Fi\naccess points’ connection details.\nBackups are restored using the adb restore command. Backup restore\nis quite limited and doesn’t allow any options to be specified, as it can only\nperform a full restore.\nBackup File Format\nAndroid backup files start with a few lines of text, followed by binary data.\nThese lines are the backup header and they specify the backup format and\nencryption parameters (if a backup password was specified) used to create\nthe backup. The header of an unencrypted backup is shown in Listing 10-15.\n284 Chapter 10\nANDROID BACKUPu\n1v\n1w\nnonex\nListing 10-15: Unencrypted backup header\nThe first line u is the file magic (format identifier), the second v is\nthe backup format version (1 up till Android 4.4.2, 2 in later versions; ver-\nsion 2 denotes a change in the key derivation method, which now takes into\naccount multibyte password characters), the third w is a compression flag\n(1 if compressed), and the last x is the encryption algorithm used (none or\nAES-256).\nThe actual backup data is a compressed and optionally encrypted tar\nfile that includes a backup manifest file, followed by the application APK\n(if any), and app data (files, databases, and shared preferences). The data\nis compressed using the deflate algorithm and can be decompressed using\nOpenSSL’s zlib command, as shown in Listing 10-16.\n$ dd if=mybackup.ab bs=24 skip=1|openssl zlib -d > mybackup.tar\nListing 10-16: Uncompressing an Android backup using OpenSSL\nAfter the backup is uncompressed, you can view its contents or extract\nit with the standard tar command, as shown in Listing 10-17.\n$ tar tvf mybackup.tar\n-rw------- 1000/1000 1019 apps/org.myapp/_manifestu\n-rw-r--r-- 1000/1000 1412208 apps/org.myapp/a/org.myapp-1.apkv\n-rw-rw---- 10091/10091 231 apps/org.myapp/f/share_history.xmlw\n-rw-rw---- 10091/10091 0 apps/org.myapp/db/myapp.db-journalx\n-rw-rw---- 10091/10091 5120 apps/org.myapp/db/myapp.db\n-rw-rw---- 10091/10091 1110 apps/org.myapp/sp/org.myapp_preferences.xmly\nListing 10-17: Viewing the contents of an uncompressed backup using tar\nInside the tar file, app data is stored in the apps/ directory, which con-\ntains a subdirectory for each backed-up package. Each package directory\nincludes a _manifest file u in its root, the APK file (if requested) in a/ v,\napp files in f/ w, databases in db/ x, and shared preferences in sp/ y. The\nmanifest contains the app’s package name and version code, the platform’s\nversion code, a flag indicating whether the archive contains the app APK,\nand the app’s signing certificate.\nThe BackupManagerService uses this information when restoring an app\nin order to check whether it’s been signed with the same certificate as the\ncurrently installed one. If the certificates don’t match, it will skip installing\nthe APK, except for system packages, which might be signed with a differ-\nent (manufacturer-owned) certificate on different devices. Additionally,\nBackupManagerService expects the files to be in the order shown in Listing 10-17\nDevice Security 285\nand restore will fail if they are out for order. For example, if the manifest\nstates that the backup includes an APK, the BackupManagerService will try to\nread and install the APK first, before restoring the app’s files. This restore\norder is required because you cannot restore files for an app you don’t have\ninstalled. However, BackupManagerService will not search for the APK in the\narchive, and if it is not right after the manifest, all other files will be skipped.\nIf the user requested external storage backup (by passing the -shared\noption to adb backup), there will also be a shared/ directory in the archive,\ncontaining external storage files.\nBackup Encryption\nIf the user supplied an encryption password when requesting the backup,\nthe backup file is encrypted with a key derived from the password. The\npassword is used to generate a 256-bit AES key using 10,000 rounds of\nPBKDF2 with a randomly generated 512-bit salt. This key is then used to\nencrypt another, randomly generated 256-bit AES bit master key, which is\nin turn used to encrypt the actual archive data in CBC mode (using the\nAES/CBC/PKCS5Padding Cipher transformation). A master key checksum is\nalso calculated and saved in the backup file header. In order to generate\nthe checksum, the generated raw master key is converted to a Java charac-\nter array by casting each byte to char, with the result treated as a password\nstring, and run through the PBKDF2 function to effectively generate\nanother AES key, whose bytes are used as the checksum.\nNOTE Because an AES key is essentially a random byte sequence, the raw key usually con-\ntains several bytes that don’t map to printable characters. Because PKCS#5 does not\nspecify the actual encoding of a password string, Android’s encryption checksum gen-\neration method produces implementation and version-dependent results.\nThe checksum is used to verify whether the user-supplied decryption\npassword is correct before actually decrypting the backup data. When\nthe master key is decrypted, its checksum is calculated using the method\ndescribed above and then compared to the checksum in the archive header.\nIf the checksums don’t match, the password is considered incorrect, and the\nrestore process is aborted. Listing 10-18 shows an example backup header\nfor an encrypted archive.\nANDROID BACKUP\n1\n1\nAES-256u\n68404C30DF8CACA5FA004F49BA3A70...v\n909459ADCA2A60D7C2B117A6F91E3D...w\n10000x\n789B1A01E3B8FA759C6459AF1CF1F0FD y\n8DC5E483D3893EC7F6AAA56B97A6C2...z\nListing 10-18: Encrypted backup header\n286 Chapter 10\nHere, AES-256 u is the backup encryption algorithm used, the next\nline v is the user password salt as a hexadecimal string, followed by the\nmaster key checksum salt w, the number of PBKDF2 rounds used to\nderive a key x, and the user key IV y. The final line z is the master key\nblob, which contains the archive data encryption IV, the actual master\nkey and its checksum, all encrypted with the key derived from the user-\nsupplied password. Listing 10-19 shows the detailed format of the master\nkey blob.\nbyte Nivu\nbyte[Niv] IVv\nbyte Nmkw\nbyte [Nmk] MKx\nbyte Ncky\nbyte [Nck] MKckz\nListing 10-19: Master key blob format\nThe first field u is the IV length, followed by the IV value v, the master\nkey (MK) length w, and the actual master key x. The last two fields store\nthe master key checksum hash length y, and the master key checksum hash\nitself z.\nControlling Backup Scope\nAndroid’s security model guarantees that each application runs within its\nown sandbox and that its files cannot be accessed by other applications or\nthe device user, unless the application explicitly allows access. Therefore,\nmost applications do not encrypt their data before storing it to disk. However,\nboth legitimate users and attackers that have somehow obtained the device\nunlock password can easily extract applications data using Android’s full\nbackup feature. For this reason, applications that store sensitive data should\neither encrypt it or provide an explicit backup agent that limits exportable\ndata in order to guarantee that sensitive data cannot be easily extracted\nvia backup.\nAs mentioned in “Android Backup Overview” on page 283, if applica-\ntion data backup isn’t needed or desirable, applications can disallow it com-\npletely by setting their allowBackup attribute to false in AndroidManifest.xml,\nas shown in Listing 10-20.\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\npackage=\"org.example.app\"\nandroid:versionCode=\"1\"\nandroid:versionName=\"1.0\" >\n--snip--\n<application\nandroid:icon=\"@drawable/ic_launcher\"\nandroid:label=\"@string/app_name\"\nandroid:theme=\"@style/AppTheme\"\nandroid:allowBackup=\"false\">\nDevice Security 287\n--snip--\n</application>\n</manifest>\nListing 10-20: Disallowing application data backup in AndroidManifest .xml\nsummary\nAndroid employs various measures in order to protect user data and appli-\ncations, and ensure the integrity of the operating system. On production\ndevices, the bootloader is locked, and the recovery OS only allows OTA\nupdates signed by the device manufacturer to be installed, thus ensuring\nthat only authorized OS builds can be booted or flashed to a device. When\nenabled, dm-verity-based verified boot guarantees that the system partition\nis not modified by checking the hash value of each device block against a\ntrusted hash tree, which prevents the installation of malicious programs\nsuch as rootkits on the system partition. Android can also encrypt the\nuserdata partition, making it harder to extract applications data by directly\naccessing storage devices.\nAndroid supports various screen lock methods and applies rate limit-\ning to unsuccessful authentication attempts, thus deterring online attacks\nagainst a booted device. The type and complexity of the unlock PIN or\npassword can be specified and enforced by device administrator applica-\ntions. A device policy that wipes the device after too many unsuccessful\nauthentication attempts is also supported. Secure USB debugging requires\ndebug hosts to be explicitly authorized by the user and added to a whitelist,\nthus preventing information extraction via USB.\nFinally, full device backups can be encrypted with a key derived from\na user-supplied password, making it harder to access device data that has\nbeen extracted into a backup. To achieve a higher level of device secu-\nrity, all supported security measures should be enabled and configured\naccordingly.\n288 Chapter 10\n11\nNfC aND sECURE E LEmENTs\nThis chapter gives a brief overview of near field com-\nmunication (NFC) and secure elements (SEs), and\nexplains how they’re integrated into mobile devices.\nWhile NFC has many uses, we focus on its card emula-\ntion mode, which is used to provide an interface to an\nSE integrated into a mobile device. Secure elements offer protected storage\nfor private data, such as authentication keys, and provide a secure execution\nenvironment that can protect security-critical code. We’ll describe which\ntypes of SEs Android supports and introduce the APIs that Android appli-\ncations can use to communicate with SEs. Finally, we’ll discuss host-based\ncard emulation (HCE) and its Android implementations, and demonstrate\nhow to implement an HCE application.\nNFC Overview\nNFC is a technology that allows devices that are in close proximity (usually\n10 centimeters or less) to establish radio communication with each other\nand exchange data. NFC is not a single standard, but is based on a set of\nstandards that define radio frequencies, communication protocols, and\ndata exchange formats. NFC builds upon radio-frequency identification\n(RFID) technology and operates at the 13.56 MHz frequency, allowing vari-\nous data transmission rates such as 106kbps, 212kbps, and 424kbps.\nNFC communication involves two devices: an initiator and a target. In\nactive mode, both the initiator and the target have their own power supplies\nand each can transmit a radio signal in order to communicate with the\nother party. In passive mode, the target device does not have its own power\nsource and is activated and powered by the electromagnetic field emitted\nby the initiator.\nWhen communicating in passive mode, the initiator is often called\na reader, and the target a tag. The reader can be a dedicated device or be\nembedded in a general purpose device, such as a personal computer or a\nmobile phone. Tags come in various shapes and sizes and range from simple\nstickers with very limited amount of memory to contactless smart cards,\nwhich have an embedded CPU.\nNFC devices can operate in three different modes: reader/writer (R/W),\npeer-to-peer (P2P), and card emulation (CE). In R/W mode, a device acts\nas an active initiator and can read and write data to external tags. In P2P\nmode, two NFC devices can actively exchange data using a bidirectional\ncommunication protocol. The CE mode allows an NFC device to emulate\na tag or a contactless smart card. Android supports all three modes with\nsome limitations. We give an overview of Android’s NFC architecture and\nshow how to use each mode in the next section.\nandroid NFC support\nNFC support in Android was introduced in version 2.3 and the related\narchitecture and features remained largely unchanged until version 4.4,\nwhich introduced HCE support.\nAndroid’s NFC implementation resides in the NfcService system service,\npart of the Nfc system application (package com.android.nfc). It wraps the\nnative libraries required to drive each supported NFC controller; implements\naccess control, tag discovery, and dispatch; and controls card emulation.\nAndroid doesn’t expose a low-level API to the functionality of NfcService,\nbut instead offers an event-driven framework that allows interested applica-\ntions to register for NFC events. This event-driven approach is used in all\nthree NFC operating modes.\nReader/Writer Mode\nNFC-enabled Android applications can’t directly set the device in R/W\nmode. Instead, they declare the type of tags they’re interested in, and\nAndroid’s tag dispatch system selects and starts the matching application\nwhen it discovers a tag.\nThe tag dispatch system both uses the tag technology (discussed shortly)\nand parses tag contents in order to decide which application to dispatch the\ntag to. The tag dispatch system uses three intent actions to notify applications\n290 Chapter 11\nabout the discovered tag: ACTION_NDEF_DISCOVERED, ACTION_TECH_DISCOVERED, and\nACTION_TAG_DISCOVERED. The ACTION_NDEF_DISCOVERED intent has the highest\npriority and is sent when Android discovers a tag that is formatted using\nthe standard NFC Data Exchange Format (NDEF)1 and that contains a\nrecognized data type. The ACTION_TECH_DISCOVERED intent is sent when the\nscanned tag does not contain NDEF data or the data format is not recog-\nnized by applications that can handle the discovered tag technology. If no\napplications can handle ACTION_NDEF_DISCOVERED or ACTION_TECH_DISCOVERED, the\nNfcService sends the generic ACTION_TAG_DISCOVERED intent. Tag dispatch events\nare delivered only to activities, and therefore cannot be processed in the\nbackground without user interaction.\nRegistering for Tag Dispatch\nApplications register for NFC events using the standard intent filter sys-\ntem by declaring the intents that an NFC-enabled activity supports in\nAndroidManifest.xml, as shown in Listing 11-1.\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\npackage=\"com.example.nfc\" ...>\n--snip--\n<uses-permission android:name=\"android.permission.NFC\" />u\n--snip--\n<application ...>\n<activity\nandroid:name=\".NfcActivity\"v\nandroid:launchMode=\"singleTop\" >\n<intent-filter>\n<action android:name=\"android.nfc.action.NDEF_DISCOVERED\"/>w\n<category android:name=\"android.intent.category.DEFAULT\"/>\n<data android:mimeType=\"text/plain\" />\n</intent-filter>\n<intent-filter>\n<action android:name=\"android.nfc.action.TECH_DISCOVERED\" />x\n</intent-filter>\n<intent-filter>\n<action android:name=\"android.nfc.action.TAG_DISCOVERED\" />y\n</intent-filter>\n<meta-data\nandroid:name=\"android.nfc.action.TECH_DISCOVERED\"z\nandroid:resource=\"@xml/filter_nfc\" >\n</meta-data>\n</activity>\n--snip--\n1. The NDEF format and its implementation using various tag technologies are described\nin the NFC Forum specification, available on its website: http://nfc-forum.org/our-work/\nspecifications-and-application-documents/specifications/nfc-forum-technical-specifications/\nNFC and Secure Elements 291\n</application>\n</manifest>\nListing 11-1: Manifest file of an NFC-enabled application\nAs you can see in this listing, the application first requests the\nandroid.permission.NFC permission u, which is required to access the\nNFC controller, and then declares an activity that handles NFC events,\nNfcActivity v. The activity registers three intent filters; one for each tag\ndiscovery event. The application declares that it can handle NDEF data\nwith the text/plain MIME type by specifying the mimeType attribute of the\n<data> tag in the NDEF_DISCOVERED intent filter w. NfcActivity also declares\nthat it can handle the TECH_DISCOVERED intent x, which is sent if the scanned\ntag uses one of the technologies specified in the associated metadata XML\nresource file z. Finally, the application requests that it be notified about all\ndiscovered NFC tags by adding the catch-all TAG_DISCOVERED intent filter y.\nIf more than one activity that supports the scanned tag is found, Android\nshows a selection dialog, allowing the user to select which activity should\nhandle the tag. Applications already in the foreground can short-circuit this\nselection by calling the NfcAdapter.enableForegroundDispatch() method. Such\nan application will be given priority over all other matching applications\nand will automatically receive the NFC intent when it’s in the foreground.\nTag Technologies\nA tag technology is an abstract term that describes a concrete NFC tag. The\ntag technology is determined by the communication protocol the tag uses,\nits internal structure, or the features it offers. For example, a tag that uses the\nNFC-A protocol (based on ISO 14443-3A)2 for communication matches the\nNfcA technology, and a tag that contains NDEF-formatted data matches\nthe Ndef technology, regardless of the underlying communication protocol.\n(See the TagTechnology class reference documentation3 for a full list of tag\ntechnologies supported by Android.)\nAn activity that specifies the TECH_DISCOVERED intent filter must provide\nan XML resource file that in turn specifies the concrete technologies it sup-\nports with a <tech-list> element. An activity is considered a match for a tag\nif one of the tech lists it declares is a subset of the technologies supported\nby the tag. Multiple tech lists can be declared in order to match different\ntags, as shown in Listing 11-2.\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n<tech-list>u\n<tech>android.nfc.tech.IsoDep</tech>\n2. Official versions of all ISO standards can be purchased on its website, http://www.iso.org/\niso/home/store/catalogue_ics.htm. Draft versions of standards can usually be obtained from the\nwebsite of the standard working group.\n3. Google, Android API Reference, “TagTechnology,” https://developer.android.com/reference/\nandroid/nfc/tech/TagTechnology.html\n292 Chapter 11\n<tech>android.nfc.tech.NfcA</tech>\n</tech-list>\n<tech-list>v\n<tech>android.nfc.tech.NfcF</tech>\n</tech-list>\n</resources>\nListing 11-2: Declaring technologies to match using tech lists\nHere, the first tech list u will match tags that provide a communica-\ntion interface compatible with ISO 14443-4 (ISO-DEP), and which are\nimplemented using the NFC-A technology (usually used by NXP contact-\nless smart cards); the second tech list v matches tags that use the NFC-F\ntechnology (typically Felica cards). Because both tech lists are defined inde-\npendently, our example NfcActivity (see Listing 11-1) will be notified when\neither a contactless NXP smart card or a Felica card or tag is scanned.\nReading a Tag\nAfter the tag dispatch system selects an activity to handle the scanned tag, it\ncreates an NFC intent object and passes it to the selected activity. The activ-\nity can then use the EXTRA_TAG extra to obtain a Tag object representing the\nscanned tag and call its methods in order to read or write to the tag. (Tags\nthat contain NDEF data also provide the EXTRA_NDEF_MESSAGES extra, which\ncontains an array of NDEF messages parsed from the tag.)\nA concrete Tag object representing the underlying tag technology can\nbe obtained using the static get() method of the corresponding technol-\nogy class, as shown in Listing 11-3. If the Tag object does not support the\nrequested technology, the get() method returns null.\nprotected void onNewIntent(Intent intent) {\nsetIntent(intent);\nTag tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);\nIsoDep isoDep = IsoDep.get(tag);\nif (isoDep != null) {\nisoDep.connect();\nbyte[] command = {...};\nbyte[] response = isoDep.transceive(command);\n--snip--\n}\n}\nListing 11-3: Obtaining a concrete Tag instance from the NFC intent\nUsing Reader Mode\nIn addition to the intent-based tag dispatch system, Android 4.4 adds a\nnew method that activities can use to obtain a live Tag object, called reader\nmode. Reader mode guarantees that while the target activity is in the\nforeground, all other operation modes supported by the NFC controller\nNFC and Secure Elements 293\n(such as peer-to-peer and card emulation) are disabled. This mode is help-\nful when scanning an active NFC device, such as another Android device in\nhost-based emulation mode, which could trigger point-to-point communica-\ntion and thus take control away from the current foreground activity.\nActivities can enable reader mode by calling the enableReaderMode()\nmethod of the NfcAdapter class,4 as shown in Listing 11-4.\npublic class NfcActivity extends Activity implements NfcAdapter.ReaderCallback {\nprivate NfcAdapter adapter;\n--snip--\n@Override\npublic void onResume() {\nsuper.onResume();\nif (adapter != null) {\nadapter.enableReaderMode(this, this, NfcAdapter.FLAG_READER_NFC_Au\n| NfcAdapter.FLAG_READER_SKIP_NDEF_CHECK, null);\n}\n}\n@Override\npublic void onTagDiscovered(Tag tag) {v\nIsoDep isoDep = IsoDep.get(tag);\nif (isoDep != null) {\nisoDep.connect();\nbyte[] command = {...};\nbyte[] response = isoDep.transceive(command);\n--snip--\n}\n}\n--snip--\n}\nListing 11-4: Enabling reader mode and obtaining a Tag object using ReaderCallback\nIn this case, the activity enables reader mode when it comes to the\nforeground by calling the enableReaderMode() method u (the activity should\ndisable reader mode using the matching disableReaderMode() method when\nit leaves the foreground), and obtains a Tag instance directly (without an\nintermediate intent) via the onTagDiscovered() callback v. The Tag object is\nthen used in the same way as in intent-based dispatch.\nPeer-to-Peer Mode\nAndroid implements a limited NFC P2P mode data exchange between\ndevices using the proprietary NDEF push and the standard Simple NDEF\nExchange Protocol (SNEP) protocols.5 Android devices can exchange a\n4. Google, Android API Reference, “NfcAdapter,” https://developer.android.com/reference/android/\nnfc/NfcAdapter.html\n5. NFC Forum, “NFC Forum Technical Specifications,” http://nfc-forum.org/our-work/\nspecifications-and-application-documents/specifications/nfc-forum-technical-specifications/\n294 Chapter 11\nsingle NDEF message with any device that supports either of these proto-\ncols, but the P2P mode is typically used with another Android device in\norder to implement the so-called Android Beam feature.\nIn addition to NDEF messages, Android Beam allows for the transfer of\nlarger data objects, such as photos and videos, which cannot fit in a single\nNDEF message by creating a temporary Bluetooth connection between\ndevices. This process is called NFC handover and was added in Android 4.1.\nNDEF message exchange in P2P mode is enabled by calling the\nsetNdefPushMessage() or setNdefPushMessageCallback() methods of the\nNfcAdapter class. (See the official NFC API guide6 for more details and\nsample code.)\nCard Emulation Mode\nAs mentioned in “NFC Overview” on page 289, CE mode allows an\nAndroid device to emulate a contactless smart card or an NFC tag. In\nCE mode, the device receives commands over NFC, processes them, and\nsends replies, again over NFC. The component responsible for process-\ning commands can be either a hardware secure element (as discussed\nin the next section) connected to the device’s NFC controller, or an\nAndroid application running on the device (when in host-based card\nemulation, HCE).\nIn the following sections, we’ll discuss secure elements in mobile\ndevices, and the Android APIs that applications can use to communicate\nwith SEs. We’ll also describe how Android implements HCE and demon-\nstrate how to create an application that enables card emulation.\nsecure Elements\nA secure element (SE) is a tamper-resistant smart card chip capable of run-\nning smart card applications (called applets or cardlets) with a certain level\nof security and isolation. A smart card is essentially a minimal computing\nenvironment on a single chip, complete with a CPU, ROM, EEPROM, RAM,\nand I/O port. Recent cards also include cryptographic co-processors that\nimplement common algorithms such as AES and RSA.\nSmart cards use various techniques to implement tamper resistance,\nmaking it quite hard to extract data by disassembling or analyzing the\nchip. Modern smart cards come pre-programmed with a multi-application\nOS that takes advantage of the hardware’s memory protection features to\nensure that each application’s data is only available to itself. Application\ninstallation and (optionally) access is controlled by requiring the use of\ncryptographic keys for each operation.\n6. Google, Android API Guides, “NFC Basics,” https://developer.android.com/guide/topics/\nconnectivity/nfc/nfc.html#p2p\nNFC and Secure Elements 295\nThe SE can be integrated in mobile devices as a Universal Integrated\nCircuit Card (UICC, commonly known as a SIM card) embedded in the\nhandset or connected to a SD card slot. If the device supports NFC, the SE\nis usually connected to (or embedded into) the NFC controller, making it\npossible to communicate with the SE wirelessly.\nSmart cards have been around since the 1970s and are now used in app-\nlications ranging from pre-paid phone calls and transit ticketing to credit\ncards and VPN credential storage. Because an SE installed in a mobile\ndevice has equivalent or superior capabilities to that of a smart card, it\ncan theoretically be used for any application that physical smart cards are\ncurrently used for. Additionally, because an SE can host multiple applica-\ntions, it has the potential to replace the bunch of cards people use daily\nwith a single device. Furthermore, because the SE can be controlled by the\ndevice’s OS, access to it can be restricted by requiring additional authenti-\ncation (PIN, passphrase, or code signature) to enable it.\nOne of the main applications of SEs in mobile devices is that of emu-\nlating contactless payment cards, and the goal of enabling mobile pay-\nments has indeed been the driving force behind SE deployment. Aside\nfrom financial applications, mobile SEs could be used to emulate other\ncontactless cards that are in wide use, such as access cards, loyalty cards,\nand so on.\nMobile SEs could also be used to enhance the security of apps that deal\nwith sensitive information or algorithms: The security-critical part of the\napp, such as credential storage or license verification, can be implemented\ninside the SE in order to guarantee that it’s impervious to reverse engineer-\ning and information extraction. Other apps that can benefit from being\nimplemented in the SE are One Time Password (OTP) generators and, of\ncourse, credential storage (for shared secret keys, or private keys in a PKI).\nWhile it’s possible to implement SE-enabled apps today with stan-\ndard tools and technologies, using them in practice on current commer-\ncial Android devices isn’t straightforward. We’ll discuss this in detail in\n“Android SE Execution Environment” on page 302, but let’s first explore\nthe types of SEs available on mobile devices, and the level of support they\nhave in Android.\nSE Form Factors in Mobile Devices\nFigure 11-1 shows a simplified block diagram of the components of an\nAndroid device as they relate to NFC and SE support, including the embed-\nded SE (eSE) and the UICC. We’ll refer to the components in this diagram\nin our discussion of secure elements and host-based card emulation in the\nrest of this chapter.\nIn the following subsections, we briefly review the types of SEs available\non Android devices, how they’re connected to other device components,\nand the methods the OS uses to communicate with each type of SE.\n296 Chapter 11\nAndroid Device\nApplication Processor\nHCE\nApp App\nApp\nAndroid OS\nA NFC-A A\nContactless n n Baseband\nte 13.56 MHz te UICC\nReader n n n n Processor\na NFC-B a\nSWP\nNFC Controller\neSE\n(PN544) S2C\nNFC Chip (PN65N)\nFigure 11-1: Android NFC and SE components\nUICC\nMost mobile devices today have some kind of UICC. Although UICCs are\nsmart cards that can host applications, because the UICC has tradition-\nally only been connected to the baseband processor (not the application\nprocessor that runs the main device OS), they can’t be accessed directly\nfrom Android. All communication goes through the Radio Interface Layer\n(RIL), which is essentially a proprietary IPC interface to the baseband.\nCommunication with the UICC SE is carried out using extended AT\ncommands (AT+CCHO, AT+CCHC, AT+CGLA as defined by 3GPP TS 27.007),7 which\nthe current Android telephony manager does not support. The SEEK for\nAndroid project8 provides patches to implement the needed commands,\nallowing for communication with the UICC via the SmartCard API, which\nis a reference implementation of the SIMalliance Open Mobile API specifi-\ncation9 (discussed in “Using the OpenMobile API” on page 308). However,\nas with most components that talk directly to the hardware in Android,\n7. 3GPP, AT command set for User Equipment (UE), http://www.3gpp.org/ftp/Specs/html-info/\n27007.htm\n8. “Secure Element Evaluation Kit for the Android platform,” https://code.google.com/p/\nseek-for-android/\n9. SIMalliance Limited, Open Mobile API Specification v2.05, http://www.simalliance.org/en?t=/\ndocumentManager/sfdoc.file.supply&fileID=1392314878580\nNFC and Secure Elements 297\nthe RIL consists of an open source part (rild), and a proprietary library\n(libXXX-ril.so). In order to support communication with the UICC secure\nelement, support must be added both to the rild and to the underlying pro-\nprietary library. The choice of whether to add that support is left to hard-\nware vendors.\nAs of this writing, the SmartCard API has not been integrated into main-\nline Android (although the AOSP source tree includes an empty packages/\napps/SmartCardService/ directory). However, Android devices from major\nvendors ship with an implementation of the SmartCard API, which allows\ncommunication from the UICC to third-party applications (subject to vari-\nous access restrictions).\nThe Single Wire Protocol (SWP) offers an alternative way to use the\nUICC as an SE. SWP is used to connect the UICC to a NFC controller,\nallowing the NFC controller to expose the UICC to external readers when\nin card emulation mode. The NFC controllers built into recent Nexus\ndevices (such as the Broadcom BCM20793M in the Nexus 5) support SWP,\nbut this functionality is disabled by default. (It can be enabled by changing\nthe configuration file of the libnfc-brcm library on the Nexus 5.) A standard\nAPI to switch between the UICC, the embedded SE (if available), and HCE\nwhen in card emulation mode is currently not exposed, but the “off-host”\nrouting functionality available in Android 4.4 can theoretically route com-\nmands to the UICC (see “APDU Routing” on page 311 for details).\nmicroSD-Based SE\nAnother form factor for an SE is an Advanced Security SD card (ASSD),10 which\nis basically an SD card with an embedded SE chip. When connected to an\nAndroid device with an SD card slot, running a SEEK-patched Android\nversion, the SE can be accessed via the SmartCard API. However, Android\ndevices with an SD card slot are becoming the exceptions rather than the\nnorm, so it’s unlikely that ASSD Android support will make it to the main-\nstream. Additionally, even when available, recent Android versions treat SD\ncards as secondary storage devices and allow access to them only via a very\nhigh-level, restrictive API.\nEmbedded SE\nAn embedded SE (eSE) is not a distinct device but is usually integrated with\nthe NFC controller and housed in the same enclosure. An example of an\neSE is NXP’s PN65N chip, which combines the PN544 NFC radio controller\nwith the P5CN072 SE (part of the SmartMX series).\nThe first mainstream Android device to feature an embedded SE was the\nNexus S, which also introduced NFC support to Android and was built using\nthe PN65N controller. Its successors, the Galaxy Nexus and the Nexus 4, also\n10. SD Association, “Advanced Security SD Card: ASSD,” https://www.sdcard.org/developers/\noverview/ASSD/\n298 Chapter 11\ncame equipped with an eSE. However, recent Google-branded devices, such\nas the Nexus 5 and Nexus 7 (2013), have deprecated the eSE in favor of\nhost-based card emulation and do not include an eSE.\nThe embedded SE is connected to the NFC controller through a\nSignalIn/SignalOut connection (S2C), standardized as NFC Wired\nInterface (NFC-WI),11 and has three modes of operation: off, wired,\nand virtual. In off mode, there’s no communication with the SE. In wired\nmode, the SE is visible to the Android OS as if it were a contactless smart\ncard connected to the NFC reader. In virtual mode, the SE is visible to\nexternal readers as if the phone were a contactless smart card. These modes\nare mutually exclusive, so we can communicate with the SE either via the\ncontactless interface (that is, from an external reader), or through the\nwired interface (that is, from an Android app). The next section shows how\nto use the wired mode to communicate with the eSE from an Android app.\nAccessing the Embedded SE\nAs of this writing, no public Android SDK API allows communication with\nthe embedded SE, but recent Android versions include an optional library\ncalled nfc_extras, which offers a stable interface to the eSE. This section\ndemonstrates how to configure Android to allow eSE access to certain\nAndroid applications, as well as how to use the nfc_extras library.\nCard emulation, and consequently, internal APIs for accessing the\nembedded SE were introduced in Android 2.3.4 (the version that intro-\nduced Google Wallet). Those APIs are hidden from SDK applications and\nusing them required system signature permissions (WRITE_SECURE_SETTINGS or\nNFCEE_ADMIN) in Android 2.3.4 and subsequent 2.3.x releases, as well as in the\ninitial Android 4.0 release (API Level 14). A signature permission is quite\nrestrictive because it allows only parties that control the platform signature\nkeys to distribute apps that can use the eSE.\nAndroid 4.0.4 (API Level 15) lifted this restriction by replacing the\nsignature permission with signing certificate whitelisting at the OS level.\nWhile this still requires modifying core OS files, and thus vendor coopera-\ntion, there is no need to sign SE applications with the vendor key, which\ngreatly simplifies distribution. Additionally, since the whitelist is maintained\nin a file, it can easily be updated using an OTA to add support for more SE\napplications.\nGranting Access to the eSE\nThe new whitelisting access control approach is implemented by the\nNfceeAccessControl class and enforced by the system NfcService. The\nNfceeAccessControl class reads the whitelist from /etc/nfcee_access.xml, which\nis an XML file that stores a list of signing certificates and package names\nthat are allowed to access the eSE. Access can be granted both to all apps\n11. ECMA International, ECMA-373: Near Field Communication Wired Interface (NFC-WI),\nhttp://www.ecma-international.org/publications/files/ECMA-ST/ECMA-373.pdf\nNFC and Secure Elements 299\nsigned by a particular certificate’s private key (if no package name is speci-\nfied), or to a single package (app) only. Listing 11-5 shows how the contents\nof the nfcee_access.xml file might appear:\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources xmlns:xliff=\"urn:oasis:names:tc:xliff:document:1.2\">\n<signer android:signature=\"308204a830820390a003020102020900b399...\">u\n<package android:name=\"com.example.nfc\">v\n</package>\n</signer>\n</resources>\nListing 11-5: Contents of the nfcee_access .xml file\nThis configuration allows SE access to the com.example.nfc package v\nif it is signed by the specified signing certificate u. On production devices,\nthis file usually contains only the Google Wallet app signing certificate, thus\nrestricting eSE access to Google Wallet.\nNOTE As of April 2014, Google Wallet is supported only on Android 4.4 and later, and uses\nHCE rather than the eSE.\nAfter an application’s signing certificate has been added to nfcee_access\n.xml, no permissions other than the standard NFC permission are required\nto access the eSE. In addition to whitelisting the app’s signing certificate,\nthe nfc_extras library must be explicitly added to the app’s manifest and\nmarked as required with the <uses-library> tag in order to enable eSE\naccess (because the library is optional, it’s not loaded by default), as\nshown in Listing 11-6 at u.\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\npackage=\"com.example.nfc\" ...>\n--snip--\n<uses-permission android:name=\"android.permission.NFC\" />\n<application ...>\n--snip--\n<uses-library\nandroid:name=\"com.android.nfc_extras\"u\nandroid:required=\"true\" />\n</application>\n</manifest>\nListing 11-6: Adding the nfc_extras library to AndroidManifest .xml\nUsing the NfcExecutionEnvironment API\nAndroid’s eSE access API isn’t based on a standard smart card communica-\ntion API, such as JSR 17712 or the Open Mobile API, but instead offers a very\n12. Oracle, “JSR 177: Security and Trust Services API for J2METM,” https://jcp.org/en/jsr/\ndetail?id=177\n300 Chapter 11\nbasic communication interface, implemented in the NfcExecutionEnvironment\nclass. The class has only three public methods, as shown in Listing 11-7.\npublic class NfcExecutionEnvironment {\npublic void open() throws EeIOException {...}\npublic void close() throws IOException {...}\npublic byte[] transceive(byte[] in) throws IOException {...}\n}\nListing 11-7: NfcExecutionEnvironment API\nThis simple interface is sufficient to communicate with the SE, but in order\nto use it you first need to obtain an instance of the NfcExecutionEnvironment class.\nAn instance can be obtained from the NfcAdapterExtras class, which is in\nturn accessed via its static get() method, as shown in Listing 11-8.\nNfcAdapterExtras adapterExtras =\nNfcAdapterExtras.get(NfcAdapter.getDefaultAdapter(context));u\nNfcExecutionEnvironment nfceEe =\nadapterExtras.getEmbeddedExecutionEnvironment();v\nnfcEe.open();w\nbyte[] emptySelectCmd = { 0x00, (byte) 0xa4, 0x04, 0x00, 0x00 };\nbyte[] response = nfcEe.transceive(emptySelectCmd);x\nnfcEe.close();y\nListing 11-8: Using the NfcExecutionEnvironment API\nHere, we first obtain an NfcAdapterExtras instance u, and then call its\ngetEmbeddedExecutionEnvironment() method in order to obtain an interface to\nthe eSE v. To be able to communicate with the eSE, we first open a connec-\ntion w, and then use the transceive() method to send a command and get a\nresponse x. Finally, we close the connection using the close() method y.\neSE-Related Broadcasts\nAn SE-enabled app needs to be notified of NFC events such as RF field detec-\ntion, as well as of events pertaining to the eSE and the applets installed on it,\nsuch as applet selection via the NFC interface, in order to be able to change\nstate accordingly. Because disclosure of such events to malicious applica-\ntions can lead to leaking of sensitive information and denial of service attacks,\naccess to eSE-related events must be limited to trusted applications only.\nIn Android, global events are implemented by using broadcasts, and\napplications can create and register broadcast receivers that receive the\nbroadcasts the app is interested in. Access to eSE-related broadcasts can\nbe controlled with standard Android signature-based permissions, but this\napproach has the disadvantage that only apps signed with the platform\ncertificate can receive eSE events, thus limiting SE-enabled apps to those\ncreated by the device manufacturer or mobile network operator (MNO).\nTo avoid this limitation, Android uses the same mechanism employed to\nNFC and Secure Elements 301\ncontrol eSE access; namely, whitelisting application certificates, in order\nto control the scope of applications that can receive eSE-related broadcasts.\nAny application whose signing certificate (and optionally package name) is\nregistered in nfcee_access.xml can receive eSE-related broadcasts by register-\ning a receiver like the one shown in Listing 11-9.\n<receiver android:name=\"com.example.nfc.SEReceiver\" >\n<intent-filter>\n<action android:name=\"com.android.nfc_extras.action.RF_FIELD_ON_DETECTED\" />u\n<action android:name=\"com.android.nfc_extras.action.RF_FIELD_OFF_DETECTED\" />v\n<action android:name=\"com.android.nfc_extras.action.APDU_RECEIVED\" />w\n<action android:name=\"com.android.nfc_extras.action.AID_SELECTED\" />x\n<action android:name=\"com.android.nfc_extras.action.MIFARE_ACCESS_DETECTED\" />y\n<action android:name=\"com.android.nfc_extras.action.EMV_CARD_REMOVAL\" />z\n<action android:name=\"com.android.nfc.action.INTERNAL_TARGET_DESELECTED\" />{\n<action android:name=\"android.intent.action.MASTER_CLEAR_NOTIFICATION\" />|\n</intent-filter>\n</receiver>\nListing 11-9: Declaring a broadcast receiver for eSE-related events in AndroidManifest .xml\nAs you can see, Android offers notifications for lower-level commu-\nnication events, such as RF field detection uv, APDU reception w, and\napplet selection x, as well as for higher-level events, such as MIFARE sec-\ntor access y and EMV card removal z. (APDUs are Application Protocol\nData Units, the basic building block of smart card protocols; see “SE\nCommunication Protocols” on page 303. The APDU_RECIEVED broadcast is\nnot implemented, because in practice the NFC controller routes incom-\ning APDUs directly to the eSE, which makes them invisible to the OS.)\nSE-enabled apps register for these broadcasts in order to be able to change\ntheir internal state or start a related activity when each event occurs (for\nexample, to start a PIN entry activity when an EMV applet is selected).\nThe INTERNAL_TARGET_DESELECTED broadcast { is sent when card emulation is\ndeactivated, and the MASTER_CLEAR_NOTIFICATION broadcast | is sent when the\ncontents of the eSE are cleared. (Pre-HCE versions of Google Wallet offered\nusers the option to clear the eSE remotely if their device was lost or stolen.)\nAndroid SE Execution Environment\nThe Android SE is essentially a smart card in a different package, so most\nstandards and protocols originally developed for smart cards apply. Let’s\nbriefly review the most important ones.\nSmart cards have traditionally been filesystem-oriented and the main\nrole of their OS has been to handle file access and enforce access permis-\nsions. Newer cards support a virtual machine running on top of the native\nOS that allows for the execution of “platform independent” applications\ncalled applets, which use a well-defined runtime library to implement their\nfunctionality. While different implementations of this paradigm exist, by\nfar the most popular one is the Java Card runtime environment ( JCRE).\nApplets are implemented in a restricted version of the Java language and\n302 Chapter 11\nuse a limited runtime library, which offers basic classes for I/O, message\nparsing, and cryptographic operations. While the JCRE specification13 fully\ndefines the applet runtime environment, it does not specify how to load, ini-\ntialize, and delete applets on actual physical cards (tools are only provided\nfor the JCRE emulator).\nBecause one of the main applications of smart cards are various payment\nservices, the application loading and initialization process (often referred\nto as card personalization) needs to be controlled, and only authorized enti-\nties should be able to alter the state of the card and installed applications.\nVisa originally developed a specification for securely managing applets,\ncalled Open Platform, which is now maintained and developed by the\nGlobalPlatform (GP) organization under the name GlobalPlatform Card\nSpecification.14 The gist of this specification is that each GP-compliant\ncard has a mandatory Issuer Security Domain (ISD) component (informally\nreferred to as the Card Manager) that offers a well-defined interface for card\nand application life cycle management. Executing ISD operations requires\nauthentication using cryptographic keys saved on the card, and thus only\nan entity that knows those keys can change the state of the card (one of\nOP_READY, INITIALIZED, SECURED, CARD_LOCKED, or TERMINATED) or manage applets.\nAdditionally, the GP card specification defines various secure communica-\ntion protocols (called Secure Channels) that offer authentication, confiden-\ntiality, and message integrity when communicating with the card.\nSE Communication Protocols\nAs discussed in “Using the NfcExecutionEnvironment API” on\npage 300, Android’s interface for communicating with the SE is the\nbyte[] transceive(byte[] command) method of the NfcExecutionEnvironment\nclass. The messages exchanged using this API are in practice APDUs,\nand their structure is defined in the ISO/IEC 7816-4: Organization, security\nand commands for interchange standard.15 The reader (also known as a Card\nAcceptance Device, or CAD) sends command APDUs (sometimes referred to\nas C-APDUs) to the card, composed of a mandatory four-byte header with a\ncommand class (CLA), instruction (INS), and two parameters (P1 and P2).\nThis is followed by the optional command data length (Lc), the actual data,\nand finally the maximum number of response bytes expected, if any (Le).\nThe card returns a response APDU (R-APDU ) with a mandatory status word\n(SW, consisting of two bytes: SW1 and SW2) and optional response data.\nHistorically, command APDU data has been limited to 255 bytes (total\nAPDU length 261 bytes) and response APDU data to 256 bytes (total APDU\nlength 258 bytes). Recent cards and readers support extended APDUs with\ndata length up to 65536 bytes, but extended APDUs are not always usable,\n13. Oracle, “Java Card Classic Platform Specification 3.0.4,” http://www.oracle.com/technetwork/\njava/javacard/specs-jsp-136430.html\n14. GlobalPlatform, “Card Specifications,” http://www.globalplatform.org/specificationscard.asp\n15. A summary of ISO 7816 and other smart card-related standards is available on CardWerk’s\nwebsite: http://www.cardwerk.com/smartcards/smartcard_standards.aspx\nNFC and Secure Elements 303\nmostly for reasons of compatibility. The lower-level communication between\nthe reader and the card is carried out by one of several transmission proto-\ncols, the most widely used of which are T=0 (byte-oriented) and T=1 (block-\noriented). Both are defined in ISO 7816-3: Cards with contacts — Electrical\ninterface and transmission protocols. The APDU exchange is not completely\nprotocol-agnostic, because T=0 cannot directly send response data, but only\nnotify the reader of the number of available bytes. Additional command\nAPDUs (GET RESPONSE) need to be sent in order to retrieve the response data.\nThe original ISO 7816 standards were developed for contact cards, but\nthe same APDU-based communication model is used for contactless cards\nas well. It’s layered on top of the wireless transmission protocol defined by\nISO/IEC 14443-4, which behaves much like T=1 for contact cards.\nQuerying the eSE Execution Environment\nAs discussed in “Embedded SE” on page 298, the eSE in the Galaxy Nexus\nis a chip from NXP’s SmartMX series. It runs a Java Card–compatible\noperating system and comes with a GlobalPlatform-compliant ISD. The\nISD is configured to require authentication for most card management\noperations, and the authentication keys are, naturally, not publicly avail-\nable. Additionally, a number of subsequent failed authentication attempts\n(usually 10) will lock the ISD and make it impossible to install or remove\napplets, so trying to brute-force the authentication keys is not an option.\nHowever, the ISD does provide some information about itself and the run-\ntime environment on the card without requiring authentication in order to\nmake it possible for clients to adjust their behavior dynamically and be com-\npatible with different cards.\nBecause both Java Card and GlobalPlatform define a multi-application\nenvironment, each application needs a unique identifier called the Application\nIdentifier (AID). The AID consists of a 5-byte Registered Application Provider\nIdentifier (RID, also called a Resource Identifier) and a Proprietary Identifier\neXtension (PIX), which can be up to 11 bytes long. Thus, the length of\nan AID can be 5 to 16 bytes long. Before being able to send commands to\na particular applet, it needs to be made active, or selected, by issuing the\nSELECT (CLA=00, INS=A4) command with its AID. As all applications, the ISD\nis also identified by an AID, which varies between card manufacturers and\nGP implementations. We can find out the AID of the ISD by sending an\nempty SELECT command, which both selects the ISD and returns informa-\ntion about the card and the ISD configuration. An empty SELECT is simply\na select without an AID specified, so the SELECT command APDU becomes\n00 A4 04 00 00. If we send this command using the transcieve() method of\nthe NfcExecutionEnvironment class (Listing 11-8 at x), the returned response\nmight look like Listing 11-10 at v (u is the SELECT command).\n--> 00A4040000u\n<-- 6F658408A000000003000000A5599F6501FF9F6E06479100783300734A06072A86488\n304 Chapter 11\n6FC6B01600C060A2A864886FC6B02020101630906072A864886FC6B03640B06092A86488\n6FC6B040215650B06092B8510864864020103660C060A2B060104012A026E0102 9000v\nListing 11-10: Galaxy Nexus eSE’s response to empty SELECT\nThe response includes a successful status (0x9000) and a long string of\nbytes. The format of this data is defined in “APDU Command Reference,”\nChapter 9 of the GlobalPlatform Card Specification and, as with most things\nin the smart card world, is in tag-length-value (TLV) format. In TLV, each\nunit of data is described by a unique tag, followed by its length in bytes,\nand finally the actual data. Most structures are recursive, so the data can\nhost another TLV structure, which in turns wraps another, and so on. The\nstructure shown in Listing 11-10 is called File Control Information (FCI) and\nin this case it wraps a Security Domain Management Data structure, which\ndescribes the ISD. When parsed, the FCI might look like Listing 11-11.\nSD FCI: Security Domain FCI\nAID: a0 00 00 00 03 00 00 00u\nRID: a0 00 00 00 03 (Visa International [US])\nPIX: 00 00 00\nData field max length: 255\nApplication prod. life cycle data: 479100783300\nTag allocation authority (OID): globalPlatform 01\nCard management type and version (OID): globalPlatform 02020101\nCard identification scheme (OID): globalPlatform 03\nGlobal Platform version: 2.1.1v\nSecure channel version: SC02 (options: 15)w\nCard config details: 06092B8510864864020103x\nCard/chip details: 060A2B060104012A026E0102y\nListing 11-11: Parsed FCI of the ISD on the eSE in Galaxy Nexus\nHere, the AID of the ISD is A0 00 00 00 03 00 00 00 u, the version\nof the GlobalPlatform implementation is 2.1.1 v, the supported Secure\nChannel protocol is SC02 w, and the last two fields of the structure contain\nsome proprietary data about the card configuration (x and y). The only\nother GP command that doesn’t require authentication is GET DATA, which\ncan be used to return additional data about the ISD configuration.\nUICC as a Secure Element\nAs discussed in “SE Form Factors in Mobile Devices” on page 296, the UICC\nin a mobile device can be used as a general-purpose SE when accessed\nusing the Open Mobile API or a similar programming interface. This sec-\ntion gives a brief overview of UICCs and the applications they typically host,\nand then shows how to access the UICC via the Open Mobile API.\nSIM Cards and UICCs\nThe predecessor of the UICC is the SIM card, and UICCs are still collo-\nquially referred to as “SIM cards.” SIM stands for Subscriber Identity Module\nNFC and Secure Elements 305\nand refers to a smart card that securely stores the subscriber identifier and\nthe associated key used to identify and authenticate a device to a mobile\nnetwork. SIMs were initially used on GSM networks and the original GSM\nstandards were later extended to support 3G and LTE. Because SIMs are\nsmart cards, they conform to ISO-7816 standards regarding physical char-\nacteristics and electrical interface. The first SIM cards were the same size as\n“regular” smart cards (Full-size, FF), but by far the most popular sizes today\nare Mini-SIM (2FF) and Micro-SIM (3FF), with Nano-SIM (4FF), which was\nintroduced in 2012, also gaining market share.\nOf course, not every smart card that fits in the SIM slot can be used in\na mobile device, so the next question is: What makes a smart card a SIM\ncard? Technically, it’s conformance to mobile communication standards\nsuch as 3GPP TS 11.11 and certification by the SIMalliance. In practice, it\nis the ability to run an application that allows it to communicate with the\nphone (referred to as Mobile Equipment or Mobile Station in related standards)\nand connect to a mobile network. While the original GSM standard did\nnot distinguish between the physical smart card and the software required\nto connect to the mobile network, with the introduction of 3G standards,\na clear distinction has been made. The physical smart card is referred to\nas a Universal Integrated Circuit Card (UICC), and different mobile network\napplications that run on it have been defined: GSM, CSIM, USIM, ISIM,\nand so on. A UICC can host and run more than one network application\n(hence the name universal), and thus can be used to connect to different\nnetworks. While network application functionality depends on the specific\nmobile network, their core features are quite similar: store network param-\neters securely and identify to the network, as well as authenticate the user\n(optionally) and store user data.\nUICC Applications\nLet’s take GSM as an example and briefly review how a network applica-\ntion works. For GSM, the main network parameters are network identity\n(International Mobile Subscriber Identity, IMSI; tied to the SIM), phone\nnumber (MSISDN, used for routing calls and changeable), and a shared\nnetwork authentication key Ki. To connect to the network, the phone needs\nto authenticate and negotiate a session key. Both authentication and session\nkeys are derived using Ki, which is also known to the network and looked\nup by IMSI. The phone sends a connection request that includes its IMSI,\nwhich the network uses to find the corresponding Ki. The network then\nuses the Ki to generate a challenge (RAND), expected challenge response\n(SRES), and session key Kc. When those parameters have been generated,\nthe network sends RAND to the phone and the GSM application running\non the SIM card comes into play: the mobile passes the RAND to the SIM\ncard, which generates its own SRES and Kc. The SRES is sent to the network\nand if it matches the expected value, encrypted communication is estab-\nlished using the session key Kc.\nAs you can see, the security of this protocol hinges solely on the secrecy\nof the Ki. Because all operations involving the Ki are implemented inside\n306 Chapter 11\nthe SIM card, and it never comes in direct contact with the phone or the\nnetwork, the scheme is kept reasonably secure. Of course, security depends\non the encryption algorithms used as well, and major weaknesses that allow\nintercepted GSM calls to be decrypted using off-the-shelf hardware were found\nin the original versions of the A5/1 stream cipher (which was initially secret).\nIn Android, network authentication is implemented by the baseband\nprocessor (more on this in “Accessing the UICC” below) and is never directly\nvisible to the main OS.\nUICC Application Implementation and Installation\nWe’ve seen that UICCs need to run applications; now let’s see how those\napplications are implemented and installed. Initial smart cards were based\non a filesystem model, where files (called elementary files, or EF ) and direc-\ntories (called dedicated files, or DF ) were named with a two-byte identifier.\nThus, developing “an application” involved selecting an ID for the DF that\nhosts the application’s files (called ADF ), and specifying the formats and\nnames of the EFs that store data. For example, the GSM application is\nunder the 7F20 ADF, and the USIM ADF hosts the EF_imsi, EF_keys, EF_sms,\nand other required files.\nBecause practically all UICCs in use today are based on Java Card\ntechnology and implement GlobalPlatform card specifications, all net-\nwork applications are implemented as Java Card applets and emulate the\nlegacy file-based structure for backward compatibility. Applets are installed\naccording to GlobalPlatform specifications by authenticating to the ISD\nand issuing LOAD and INSTALL commands.\nOne application management feature specific to SIM cards is support\nfor OTA updates via binary SMS. This functionality is not used by all car-\nriers, but it allows carriers to remotely install applets on SIM cards they’ve\nissued. OTA is implemented by wrapping card commands (APDUs) in SMS\nT-PDUs (transport protocol data units), which the phone forwards to the\nUICC. In most UICCs, this is the only way to load applets on the card, even\nduring initial personalization.\nThe major use case for this OTA functionality is to install and maintain\nSIM Toolkit (STK) applications that can interact with the handset via stan-\ndard “proactive” commands (which in reality are implemented via polling),\nand to display menus or even open web pages and send SMS. Android sup-\nports STK with a dedicated STK system app, which is automatically disabled\nif the UICC card has no STK applets installed.\nAccessing the UICC\nAs we discussed in “UICC Applications” on page 306, mobile network–\nrelated functionality in Android, including UICC access, is implemented\nby the baseband software. The main OS (Android) is limited in what it can\ndo with the UICC by the features the baseband exposes. Android supports\nSTK applications and can look up and store contacts on the SIM, so it’s\nclear that it has internal support for communicating to the SIM. However,\nthe Android security overview explicitly states that “low-level access to the\nNFC and Secure Elements 307\nSIM card is not available to third-party apps.”16 How can we use the SIM\ncard (UICC) as an SE then? Some Android builds from major vendors,\nmost notably Samsung, provide an implementation of the SIMalliance\nOpen Mobile API, and an open source implementation (for compatible\ndevices) of the API is available from the SEEK for Android project. The\nOpen Mobile API aims to provide a unified interface for accessing SEs on\nAndroid, including the UICC.\nTo understand how the Open Mobile API works and the cause of its lim-\nitations, let’s review how access to the SIM card is implemented in Android.\nOn Android devices, all mobile network functionality (dialing, sending SMS,\nand so on) is provided by the baseband processor (also referred to as modem\nor radio). Android applications and system services communicate with the\nbaseband only indirectly via the Radio Interface Layer (RIL) daemon (rild).\nThe rild in turn talks to the actual hardware by using a manufacturer-\nprovided RIL HAL library, which wraps the proprietary interface that the\nbaseband provides. The UICC card is typically connected only to the base-\nband processor (though sometimes also to the NFC controller via SWP),\nand thus all communication needs to go through the RIL.\nWhile the proprietary RIL implementation can always access the UICC\nin order to perform network identification and authentication, as well as\nread and write contacts and access STK applications, support for transpar-\nent APDU exchange is not always available. As we mentioned in “UICC” on\npage 297, the standard way to provide this feature is to use extended AT\ncommands such AT+CSIM (Generic SIM access) and AT+CGLA (Generic UICC\nLogical Channel Access), but some vendors implement APDU exchange\nusing proprietary extensions, so support for the necessary AT commands\ndoesn’t automatically provide UICC access.\nSEEK for Android implements a resource manager service\n(SmartCardService) that can connect to any supported SE (eSE, ASSD,\nor UICC) and extensions to the Android telephony framework that allow\nfor transparent APDU exchange with the UICC. Because access through\nthe RIL is hardware- and HAL-dependent, you need both a compatible\ndevice and a build that includes the SmartCardService and related framework\nextensions, such as those found in most recent Samsung Galaxy devices.\nUsing the OpenMobile API\nThe OpenMobile API is relatively small and defines classes that represent\nthe card reader that an SE is connected to (Reader), a communication ses-\nsion with an SE (Session), and a basic (channel 0, as per ISO 7816-4) or logi-\ncal channel with the SE (Channel). The Channel class allows applications to\nexchange APDUs with the SE using the transmit() method. The entry point\nto the API is the SEService class, which connects to the remote resource\nmanager service (SmartcardService) and provides a method that returns a list\n16. Google, Android Security Overview, “SIM Card Access,” https://source.android.com/devices/tech/\nsecurity/#sim-card-access\n308 Chapter 11\nof Reader objects available on the device. (For more information about the\nOpenMobile API and the architecture of the SmartcardService, refer to the\nSEEK for Android Wiki.17)\nIn order to be able to use the OpenMobile API, applications need to\nrequest the org.simalliance.openmobileapi.SMARTCARD permission and add the\norg.simalliance.openmobileapi extension library to their manifest as shown in\nListing 11-12.\n<manifest ...>\n--snip--\n<uses-permission android:name=\"org.simalliance.openmobileapi.SMARTCARD\" />\n<application ...>\n<uses-library\nandroid:name=\"org.simalliance.openmobileapi\"\nandroid:required=\"true\" />\n--snip--\n</application>\n</manifest>\nListing 11-12: AndroidManifest .xml configuration required to use the OpenMobile API\nListing 11-13 demonstrates how an application can use the OpenMobile\nAPI to connect and send a command to the first SE on the device.\nContext context = getContext();\nSEService.CallBack callback = createSeCallback();\nSEService seService = new SEService(context, callback);u\nReader[] readers = seService.getReaders();v\nSession session = readers[0].openSession();w\nChannel channel = session.openLogicalChannel(aid);x\nbyte[] command = { ... };\nbyte[] response = channel.transmit(command);y\nListing 11-13: Sending a command to the first SE using the OpenMobile API\nHere, the application first creates an SEService u instance, which con-\nnects to the SmartCardService asynchronously and notifies the application\nvia the serviceConnected() method (not shown) of the SEService.CallBack\ninterface when the connection is established. The app can then get a list of\nthe available SE readers using the getReaders() method v, and then open\na session to the selected reader using the openSession() method w. If the\ndevice does not contain an eSE (or another form of SE besides the UICC),\nor the SmartCardService hasn’t been configured to use it, the list of readers\ncontains a single Reader instance that represents the built-in UICC reader in\nthe device. When the app has an open Session with the target SE, it calls the\nopenLogicalChannel() method x in order to obtain a Channel, which it then\nuses to send APDUs and receive responses using its transmit() method y.\n17. SEEK for Android, “SmartCardAPI,” https://code.google.com/p/seek-for-android/wiki/\nSmartcardAPI\nNFC and Secure Elements 309\nsoftware Card Emulation\nSoftware card emulation (also referred to as host-based card emulation or HCE)\nallows commands received by the NFC controller to be delivered to the\napplication processor (main OS), and to be processed by regular Android\napplications, instead of by applets installed on a hardware SE. Responses\nare then sent back to the reader via NFC, allowing an app to act as a virtual\ncontactless smart card.\nBefore being officially added to the Android API, HCE was first avail-\nable as an experimental feature of the CyanogenMod Android distribu-\ntion.18 Beginning with version 9.1, CyanogenMod integrated a set of\npatches (developed by Doug Yeager) that unlock the HCE functionality\nof the popular PN544 NFC controller and provide a framework interface\nto HCE. In order to support HCE, two new tag technologies (IsoPcdA and\nIsoPcdB, representing external contactless readers based on NFC Type A\nand Type B technology, respectively) were added to the NFC framework.\n(The letters Pcd stand for Proximity Coupling Device, which is just another\ntechnical term for contactless reader.)\nThe IsoPcdA and IsoPcdB classes reversed the role of Tag objects in the\nAndroid NFC API: because the external contactless reader is presented as\na “tag,” “commands” you send from the phone are actually replies to the\nreader-initiated communication. Unlike the rest of Android’s NFC stack, this\narchitecture was not event driven and required applications to handle block-\ning I/O while waiting for the reader to send its next command. Android 4.4\nintroduced a standard, event-driven framework for developing HCE applica-\ntions, which we discuss next.\nAndroid 4.4 HCE Architecture\nUnlike the R/W and P2P mode, which are only available to activities, HCE\napplications can work in the background and are implemented by defining\na service that processes commands received from the external reader and\nreturns responses. Such HCE services extend the HostApduService abstract\nframework class and implement its onDeactivated() and processCommand()\nmethods. HostApduService itself is a very thin mediator class that enables two-\nway communication with the system NfcService by using Messenger objects.19\nFor example, when the NfcService receives an APDU that needs to be\nrouted (APDU routing is discussed in the next section) to a HCE ser-\nvice, it sends a MSG_COMMAND_APDU to HostApduService, which then extracts the\nAPDU from the message and passes it to its concrete implementation by\ncalling the processCommand() method. If processCommand() returns an APDU,\nHostApduService encapsulates it in a MSG_RESPONSE_APDU message and sends it\nto the NfcService, which in turn forwards it to the NFC controller. If the\nconcrete HCE service cannot return a response APDU immediately, it\n18. CyanogenMod, http://www.cyanogenmod.org/\n19. Google, Android API Reference, “Messenger,” https://developer.android.com/reference/android/\nos/Messenger.html\n310 Chapter 11\nreturns null and sends the response later (when it is available) by calling\nthe sendResponseApdu(), which sends the response to the NfcService wrapped\nin a MSG_RESPONSE_APDU message.\nAPDU Routing\nWhen the device is in card emulation mode, the NFC controller receives all\nAPDUs coming from external readers and decides whether to send them\nto a physical SE (if any), or to an HCE service based on its internal APDU\nrouting table. The routing table is AID-based and is populated using the\nmetadata SE-enabled applications and HCE services declared in their\napplication manifests. When the external reader sends a SELECT command\nthat is not directly routed to the SE, the NFC controller forwards it to the\nNfcService, which extracts the target AID from the command and searches\nthe routing table for a matching HCE service by calling the resolveAidPrefix()\nmethod of the RegisteredAidCache class.\nIf a matching service is found, NfcService binds to it and obtains a\nMessenger instance, which it then uses to send subsequent APDUs (wrapped\nin MSG_COMMAND_APDU messages, as discussed in the previous section). For this\nto work, the app’s HCE service needs to be declared in AndroidManifest.xml\nas shown in Listing 11-14.\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\npackage=\"com.example.hce\" ...>\n--snip--\n<uses-permission android:name=\"android.permission.NFC\" />\n<application ...>\n--snip--\n<service\nandroid:name=\".MyHostApduService\"u\nandroid:exported=\"true\"\nandroid:permission=\"android.permission.BIND_NFC_SERVICE\" >v\n<intent-filter>\n<action\nandroid:name=\"android.nfc.cardemulation.action.HOST_APDU_SERVICE\" />w\n</intent-filter>\n<meta-data\nandroid:name=\"android.nfc.cardemulation.host_apdu_service\"x\nandroid:resource=\"@xml/apduservice\" />\n</service>\n--snip--\n</application>\n</manifest>\nListing 11-14: Declaring a HCE service in AndroidManifest .xml\nThe application declares its HCE service u as usual, using the <service>\ntag, but there are a few additional requirements. First, the service must\nbe protected with the BIND_NFC_SERVICE system signature permission v, to\nNFC and Secure Elements 311\nguarantee that only system apps (in practice, only the NfcService) can bind\nto it. Next, the service needs to declare an intent filter that matches the\nandroid.nfc.cardemulation.action.HOST_APDU_SERVICE action w so that it can be\nidentified as a HCE service when scanning installed packages, and be bound\nto when a matching APDU is received. Finally, the service must have an XML\nresource metadata entry under the name android.nfc.cardemulation.host_apdu_\nservice x, which points to an XML resource file listing the AIDs that the\nservice can handle. The contents of this file is used to build the AID routing\ntable, which the NFC stack consults when it receives a SELECT command.\nSpecifying Routing for HCE Services\nFor HCE applications, the XML file must include a <host-apdu-service> root\nelement as shown in Listing 11-15.\n<host-apdu-service\nxmlns:android=\"http://schemas.android.com/apk/res/android\"\nandroid:description=\"@string/servicedesc\"\nandroid:requireDeviceUnlock=\"false\">u\n<aid-group android:description=\"@string/aiddescription\"v\nandroid:category=\"other\">w\n<aid-filter android:name=\"A0000000010101\"/>x\n</aid-group>\n</host-apdu-service>\nListing 11-15: HCE service AID metadata file\nThe <host-apdu-service> tag has a description attribute and a\nrequireDeviceUnlock attribute u, which specifies whether the corresponding\nHCE service should be activated when the device is locked. (The device’s\nscreen must be on for NFC to work.) The root element contains one or\nmore <aid-group> entries v, which each have a category attribute w and con-\ntain one or more <aid-filter> x tags that specify an AID in their name attri-\nbute (A0000000010101 in this example).\nAn AID group defines a set of AIDs that is always handled by a par-\nticular HCE service. The NFC framework guarantees that if a single AID\nis handled by an HCE service, then all other AIDs in the group are also\nhandled by the same service. If two or more HCE services define the same\nAID, the system shows a selection dialog letting the user choose which\napplication should handle the incoming SELECT command. When an app is\nchosen, all subsequent commands are routed to it after the user confirms\nthe selection by tapping on the dialog shown in Figure 11-2.\nEach AID group is associated with a category (specified with the category\nattribute), which allows the system to set a default handler per category,\nrather than per AID. An application can check if a particular service is the\ndefault handler for a category by calling the isDefaultServiceForCategory()\nmethod of the CardEmulation class, and get the selection mode for a category\nby calling the getSelectionModeForCategory() method. As of this writing, only\ntwo categories are defined: CATEGORY_PAYMENT and CATEGORY_OTHER.\n312 Chapter 11\nAndroid enforces a single active payment category in order to ensure\nthat the user has explicitly selected which app should handle payment\ntransactions. The default app for the payment category is selected in the\nTap & pay screen of the system Settings app, as shown in Figure 11-3. (See\nthe official HCE documentation20 for more on payment applications.)\nFigure 11-2: HCE application selec- Figure 11-3: Selecting the default pay-\ntion confirmation dialog ment application in the Tap & pay\nscreen\nSpecifying Routing for SE Applets\nIf a device supports HCE and also has a physical SE, a SELECT command\nsent by an external reader can target either an HCE service, or an applet\ninstalled on the SE. Because Android 4.4 directs all AIDs not listed in the\nAID routing table to the host, the AIDs of applets installed on the SE must\nbe explicitly added to the NFC controller’s routing table. This is accom-\nplished with the same mechanism used for registering HCE services: by\nadding a service entry to the application’s manifest, and linking it to a meta-\ndata XML file that specifies a list of AIDs that should be routed to the SE.\nWhen the route is established, command APDUs are sent directly to the SE\n(which processes them and returns a response via the NFC controller), so\nthe service is used only as a marker and provides no functionality.\n20. Google, Host-based Card Emulation, “Payment Applications,” https://developer.android.com/\nguide/topics/connectivity/nfc/hce.html#PaymentApps\nNFC and Secure Elements 313\nThe Android SDK includes a helper service (OffHostApduService) that\ncan be used to list AIDs that should be routed directly to the SE. This\nOffHostApduService class defines some useful constants, but is otherwise\nempty. An application can extend it and declare the resulting service com-\nponent in its manifest as shown in Listing 11-16.\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\npackage=\"com.example.hce\" ...>\n--snip--\n<uses-permission android:name=\"android.permission.NFC\" />\n<application ... >\n--snip--\n<service android:name=\".MyOffHostApduService\"\nandroid:exported=\"true\"\nandroid:permission=\"android.permission.BIND_NFC_SERVICE\">\n<intent-filter>\n<action\nandroid:name=\"android.nfc.cardemulation.action.OFF_HOST_APDU_SERVICE\"/>u\n</intent-filter>\n<meta-data\nandroid:name=\"android.nfc.cardemulation.off_host_apdu_service\"v\nandroid:resource=\"@xml/apduservice\"/>\n</service>\n--snip--\n</application>\n</manifest>\nListing 11-16: Declaring an off-host APDU service in AndroidManifest .xml\nThe service declaration is similar to that of Listing 11-14, except that\nthe declared intent action is android.nfc.cardemulation.action.OFF_HOST_\nAPDU_SERVICE u and the XML metadata name is android.nfc.cardemulation\n.off_host_apdu_service v. The metadata file is also slightly different, as shown\nin Listing 11-17.\n<offhost-apdu-service\nxmlns:android=\"http://schemas.android.com/apk/res/android\"\nandroid:description=\"@string/servicedesc\">u\n<aid-group android:description=\"@string/se_applets\"\nandroid:category=\"other\">v\n<aid-filter android:name=\"F0000000000001\"/>w\n<aid-filter android:name=\"F0000000000002\"/>x\n</aid-group>\n</offhost-apdu-service>\nListing 11-17: Off-host APDU service metadata file\nAs you can see, the format is the same as that of an HCE service,\nbut the root element of the file is <offhost-apdu-service> u instead of\n<host-apdu-service>. Another subtle difference is that <offhost-apdu-service>\ndoes not support the requireDeviceUnlock attribute, because transactions are\nsent directly to the SE and therefore the host cannot intervene regardless\n314 Chapter 11\nof the state of the lockscreen. The AIDs of the applets residing on the SE\n(w and x) are included in a <aid-group> v. Those AIDs are sent directly to\nthe NFC controller, which saves them in its internal routing table in order\nto be able to send matching APDUs directly to the SE, without interacting\nwith the Android OS. If the received APDU is not in the NFC controller’s\nrouting table, it forwards it to the NfcService, which sends it to the matching\nHCE service, or returns an error if no matches are found.\nWriting an HCE Service\nWhen the HCE service of an application has been declared in its manifest\nas shown in Listing 11-14, HCE functionality can be added by extending the\nHostApduService base class and implementing its abstract methods as shown\nin Listing 11-18.\npublic class MyHostApduService extends HostApduService {\n--snip--\nstatic final int OFFSET_CLA = 0;u\nstatic final int OFFSET_INS = 1;\nstatic final int OFFSET_P1 = 2;\nstatic final int OFFSET_P2 = 3;\n--snip--\nstatic final short SW_SUCCESS = (short) 0x9000;v\nstatic final short SW_CLA_NOT_SUPPORTED = 0x6E00;\nstatic final short SW_INS_NOT_SUPPORTED = 0x6D00;\n--snip--\nstatic final byte[] SELECT_CMD = { 0x00, (byte) 0xA4,\n0x04, 0x00, 0x06, (byte) 0xA0,\n0x00, 0x00, 0x00, 0x01, 0x01, 0x01 };w\nstatic final byte MY_CLA = (byte) 0x80;x\nstatic final byte INS_CMD1 = (byte) 0x01;\nstatic final byte INS_CMD2 = (byte) 0x02;\nboolean selected = false;\npublic byte[] processCommandApdu(byte[] cmd, Bundle extras) {\nif (!selected) {\nif (Arrays.equals(cmd, SELECT_CMD)) {y\nselected = true;\nreturn toBytes(SW_SUCCESS);\n}\n--snip--\n}\nif (cmd[OFFSET_CLA] != MY_CLA) {z\nreturn toBytes(SW_CLA_NOT_SUPPORTED);\n}\nbyte ins = cmd[OFFSET_INS];{\nswitch (ins) {\ncase INS_CMD1:|\nNFC and Secure Elements 315\nbyte p1 = cmd[OFFSET_P1];\nbyte p2 = cmd[OFFSET_P2];\n--snip--\nreturn toBytes(SW_SUCCESS);\ncase INS_CMD2:\n--snip--\nreturn null;}\ndefault:\nreturn toBytes(SW_INS_NOT_SUPPORTED);\n}\n}\n@Override\npublic void onDeactivated(int reason) {\n--snip--\nselected = false;~\n}\n--snip--\n}\nListing 11-18: Implementing a HostApduService\nHere, the example HCE service first declares a few constants that will\nbe helpful when accessing APDU data u and returning a standard status\nresult v. The service defines the SELECT command that is used to activate\nit, including the AID w. The next few constants x declare the instruction\nclass (CLA) and instructions that the service can handle.\nWhen the HCE service receives an APDU, it passes it to the\nprocessCommandApdu() method as a byte array, which the service analyzes.\nIf the service hasn’t been selected yet, the processCommandApdu() method\nchecks if the APDU contains a SELECT command y, and sets the selected\nflag if it does. If the APDU contains some other command, the code checks\nto see if it has a class byte (CLA) the services supports z, and then extracts\nthe instruction byte (INS) included in the command {. If the command\nAPDU contains the INS_CMD1 instruction |, the service extracts the P1 and\nP2 parameters, possibly parses the data included in the APDU (not shown),\nsets some internal state, and returns a success status.\nIf the command includes INS_CMD2, which in our example maps to a\nhypothetical operation that requires some time to process (for example,\nasymmetric key generation), the service starts a worker thread (not shown),\nand returns null } in order not to block the main thread of the application.\nWhen the worker thread completes execution, it can return its result using the\ninherited sendResponseApdu() (defined in the parent HostApduService class). When\nanother service or SE applet is selected, the system calls the onDeactivated()\nmethod, which should release any used resources before returning, but in\nour example simply sets the selected flag to false ~.\n316 Chapter 11\nBecause an HCE service essentially parses command APDUs and\nreturns responses, the programming model is very similar to that of\nJava Card applets. However, because a HCE service lives inside a regular\nAndroid application, it does not execute in a constrained environment\nand can take advantage of all available Android features. This makes it\neasy to implement complex functionality, but also impacts the security of\nHCE apps, as discussed next.\nSecurity of HCE Applications\nBecause any Android application can declare an HCE service and receive\nand process APDUs, the system guarantees that a malicious application\ncannot inject rogue APDU commands into an HCE service by requiring the\nBIND_NFC_SERVICE system signature permission in order to bind to HCE ser-\nvices. Additionally, Android’s sandboxing model ensures that other applica-\ntions cannot access sensitive data stored by the HCE application by reading\nits files or calling any data access APIs it might expose without permission\n(assuming such APIs have been properly secured, of course).\nNevertheless, a malicious application that manages to obtain root\nprivileges on a device (for example, by exploiting a privilege escalation\nvulnerability) can both inspect and inject APDUs targeted at an HCE ser-\nvice, and read its private data. The HCE application can take some mea-\nsures to detect this situation, for example by inspecting the identity and\nsigning certificate of the caller of its processCommandApdu() method, but such\nmeasures can ultimately be defeated given unconstrained access to the\nOS. Like all applications that store sensitive data, HCE applications should\nalso take steps to protect stored data, such as by encrypting it on disk or by\nstoring it in the system credential store in the case of cryptographic keys.\nAnother way to protect both the code and data of HCE applications is to\nforward all received commands to a remote server, over an encrypted chan-\nnel, and relay only its replies. However, because most of these measures are\nimplemented in software, they can ultimately be disabled or bypassed by a\nsufficiently sophisticated malicious application with root access.\nIn contrast, hardware security elements offer physical tamper resis-\ntance, reduced attack surface due to their constrained functionality, and\ntight control over installed applets. Therefore, physical SEs are much harder\nto attack and provide much stronger protection of sensitive data used in\ntypical card emulation scenarios like contactless payments, even when the\ndefault security guarantees of the host OS have been bypassed.\nNOTE For a detailed discussion of the difference in security level of card emulation applica-\ntions when implemented in secure elements as opposed to in software using HCE, see\nthe “HCE vs embedded secure element” blog post series by Cem Paya (who worked on the\noriginal eSE-backed Google Wallet implementation).21\n21. Cem Paya, Random Oracle, “HCE vs embedded secure element,” parts I to VI, http://\nrandomoracle.wordpress.com/2014/03/08/hce-vs-embedded-secure-element-comparing-risks-part-i/\nNFC and Secure Elements 317\nsummary\nAndroid supports the three NFC modes: reader/writer, point-to-point, and\ncard emulation. In reader/writer mode, Android devices can access NFC\ntags, contactless cards, and NFC emulation devices, while the point-to-point\nmode provides simple data exchange functionality. The card emulation\nmode can be backed either by a physical secure element (SE) such as a\nUICC, one that is integrated with the NFC controller (embedded SE), or\nby regular Android applications since Android 4.4. Hardware security ele-\nments provide the highest security by offering physical tamper resistance\nand stringent control over SE application (typically implemented as Java\nCard applets) management. However, because the authentication keys\nrequired to install an application on an SE are typically controlled by a\nsingle entity (such as the device manufacturer or MNO), distributing SE\napplications can be problematic. Host-based card emulation (HCE), intro-\nduced in Android 4.4, makes it easy to develop and distribute applications\nthat work in card emulation mode, but it relies solely on the OS to enforce\nsecurity and therefore offers weaker protection of sensitive application code\nand data.\n318 Chapter 11",
    "question": "What are the key security measures and methods Android employs to protect user data, ensure system integrity, and manage secure element (SE) access and communication?",
    "summary": "The UsbDeviceManager class allows and denies USB debugging, clears authentication keys, and manages the adbd daemon. It is accessed via the IUsbManager AIDL interface, requiring the MANAGE_USB permission. ADB uses 2048-bit RSA keys stored in $HOME/.android, which are used for secure communication. Android includes a backup framework that can back up and restore data to/from a host via USB, with encryption options. The backup file format includes a header with encryption and compression details, followed by a compressed tar file containing the backup data. Android also supports NFC and secure elements (SEs) for secure data storage and communication, including host-based card emulation (HCE) which allows apps to emulate contactless smart cards. HCE provides a basic API for interacting with SEs, but lacks the same level of security as hardware-based SEs. Android's security model ensures that only authorized apps can access SEs, and that sensitive data is protected through encryption and access controls."
  },
  {
    "start": 186,
    "end": 203,
    "text": "12\nsELINUX\nWhile previous chapters mentioned Security-Enhanced\nLinux (SELinux) and its Android integration, our\ndiscussion of Android’s security model up until now\nhas focused on Android’s “traditional” sandbox imple-\nmentation, which relies heavily on Linux’s default\ndiscretionary access control (DAC). The Linux DAC is lightweight and\nwell understood, but it has certain disadvantages, most notably the coarse\ngranularity of DAC permissions, the potential for misconfigured programs\nto leak data, and the inability to apply fine-grained privilege constraints to\nprocesses that run as the root user. (While POSIX capabilities, which are\nimplemented as an extension to the traditional DAC in Linux, offer a way\nto grant only certain privileges to root processes, the granularity of POSIX\ncapabilities is fairly coarse and the granted privileges extend to all objects\naccessed by the process.)\nMandatory access control (MAC), as implemented by SELinux, seeks to\novercome these limitations of Linux’s DAC by enforcing a systemwide,\nmore finely grained security policy that can be changed only by the system\nadministrator, and not by unprivileged users and programs. This chapter\nfirst gives a brief overview of the architecture and concepts used in SELinux\nand then describes the major modifications made to SELinux in order to\nsupport Android. Finally, we give an overview of the SELinux policy that’s\ndeployed in the current version of Android.\nsELinux Introduction\nSELinux is a mandatory access control mechanism for the Linux kernel,\nimplemented as a Linux security module. The Linux Security Modules\n(LSM) framework allows third-party access control mechanisms to be\nlinked into the kernel and to modify the default DAC implementation.\nLSM is implemented as a series of security function hooks (upcalls) and\nrelated data structures that are integrated into the various modules of the\nLinux kernel responsible for access control.\nSome of the main kernel services that have LSM hooks inserted are pro-\ngram execution, file and inode operations, netlink messaging, and socket\noperations. If no security module is installed, Linux uses its built-in DAC\nmechanism to regulate access to kernel objects managed by these services. If a\nsecurity module is installed, Linux consults it in addition to the DAC in order\nto reach a final security decision when access to a kernel object is requested.\nBesides providing hooks into major kernel services, the LSM framework\nalso extends the procfs virtual filesystem (/proc) to include per-process and\nper-task (thread) security attributes, and adds support for using filesystem\nextended attributes as persistent security attribute storage. SELinux was the\nfirst LSM module integrated into the Linux kernel and has been officially\navailable since version 2.6 (previous SELinux implementations were distrib-\nuted as a set of patches). Since the integration of SELinux, other security\nmodules have also been accepted into the mainline kernel, which as of this\nwriting includes AppArmor, Smack, and TOMOYO Linux as well. These\nmodules provide alternative MAC implementations and are based on differ-\nent security models than those of SELinux.\nWe’ll explore the SELinux security model and architecture in the\nnext sections.\nSELinux Architecture\nWhile the SELinux architecture is quite complex, at a high level it consists\nof four main components: object managers (OM), an access vector cache\n(AVC), a security server, and a security policy, as shown in Figure 12-1.\nWhen a subject asks to perform an action on an SELinux object (for\nexample, when a process tries to read a file), the associated object manager\nqueries the AVC to see if the attempted action is allowed. If the AVC con-\ntains a cached security decision for the request, the AVC returns it to the\nOM, which enforces the decision by allowing or denying the action (steps 1,\n2, and 5 in Figure 12-1). If the cache does not contain a matching security\ndecision, the AVC contacts the security server, which makes a security deci-\nsion based on the currently loaded policy and returns it to the AVC, which\ncaches it. The AVC in turn returns it to the OM, which ultimately enforces\n320 Chapter 12\nthe decision (steps 1, 2, 3, 4, and 5 in Figure 12-1). The security server is\npart of the kernel, while the policy is loaded from userspace via a series of\nfunctions contained in the supporting userspace library.\nLinux Kernel\n1. action: write 5. allow/deny write\nSubject Object Object\n(process) Manager (file, dir, etc.)\n2. query permission\nAccess Vector Cache\n(AVC)\n3. query permission\n4. search policy Security\nSecurity Server\nPolicy\nFigure 12-1: SELinux components\nThe OM and AVC can reside either in kernel space (when the OM is\nmanaging kernel-level objects) or userspace (when the OM is part of a so-\ncalled SELinux-aware application, which has built-in MAC support).\nMandatory Access Control\nSELinux’s MAC model is based on three main concepts: subjects, objects,\nand actions. In this model, subjects are the active actors that perform\nactions on objects, and the action is carried out only if the security policy\nallows it.\nIn practice, subjects are usually running processes (a process can also\nbe an object), and objects are OS-level resources managed by the kernel,\nsuch as files and sockets. Both subjects and objects have a set of security\nattributes (collectively known as the security context, discussed in the next\nsection), which the OS queries in order to decide whether the requested\naction should be allowed or not. When SELinux is enabled, subjects cannot\nbypass or influence policy rules; therefore, the policy is mandatory.\nNOTE The MAC policy is only consulted if the DAC allows access to a resource. If the DAC\ndenies access (for example, based on file permissions), the denial is taken as the final\nsecurity decision.\nSELinux supports two forms of MAC: type enforcement (TE) and multi-\nlevel security (MLS). MLS is typically used to enforce different levels of access\nto restricted information and is not used in Android. The type enforcement\nSELinux 321\nimplemented in SELinux requires that all subjects and objects have an asso-\nciated type and SELinux uses this type to enforce the rules of its security\npolicy.\nIn SELinux, a type is simply a string that’s defined in the policy and\nassociated with objects or subjects. Subject types reference processes or\ngroups of processes and are also referred to as domains. Types referring to\nobjects usually specify the role an object plays within the policy, such as\nsystem file, application data file, and so on. The type (or domain) is an inte-\ngral part of the security context, as discussed in “Security Contexts” below.\nSELinux Modes\nSELinux has three modes of operation: disabled, permissive, and enforcing.\nWhen SELinux is disabled, no policy is loaded and only the default DAC\nsecurity is enforced. In permissive mode, the policy is loaded and object\naccess is checked, but access denial is only logged—not enforced. Finally, in\nenforcing mode, the security policy is both loaded and enforced, with viola-\ntions logged.\nIn Android, the SELinux mode can be checked and changed with the\ngetenforce and setenforce commands, as shown in Listing 12-1. However,\nthe mode set with setenforce is not persistent and will be reset to the default\nmode when the device reboots.\n# getenforce\nEnforcing\n# setenforce 0\n# getenforce\nPermissive\nListing 12-1: Using the getenforce and setenforce commands\nAdditionally, even when SELinux is in enforcing mode, the policy can\nspecify permissive mode per domain (process) using the permissive state-\nment. (See “Object Class and Permission Statements” on page 326 for an\nexample.)\nSecurity Contexts\nIn SELinux, a security context (also referred to as a security label, or just label)\nis a string with four fields delimited with colons: username, role, type, and\nan optional MLS security range. An SELinux username is typically associ-\nated with a group or class of users; for example, user_u for unprivileged\nusers and admin_u for administrators.\nUsers can be associated with one or more roles in order to implement\nrole-based access control, where each role is associated with one or more\ndomain types. The type is used to group processes in a domain or to spec-\nify an object logical type.\n322 Chapter 12\nThe security range (or level) is used to implement MLS and specifies\nthe security levels a subject is allowed to access. As of this writing, Android\nonly uses the type field of the security context, and the user and security\nrange are always set to u and s0. The role is set to either r for domains (pro-\ncesses) or to the built-in object_r role for objects.\nThe security context of processes can be displayed by specifying the\n-Z option to the ps command, as shown in Listing 12-2 (in the LABEL column).\n# ps -Z\nLABEL USER PID PPID NAME\nu:r:init:s0u root 1 0 /init\nu:r:kernel:s0 root 2 0 kthreadd\nu:r:kernel:s0 root 3 2 ksoftirqd/0\n--snip--\nu:r:healthd:s0v root 175 1 /sbin/healthd\nu:r:servicemanager:s0w system 176 1 /system/bin/\nservicemanager\nu:r:vold:s0x root 177 1 /system/bin/vold\nu:r:init:s0 nobody 178 1 /system/bin/rmt_storage\nu:r:netd:s0 root 179 1 /system/bin/netd\nu:r:debuggerd:s0 root 180 1 /system/bin/debuggerd\nu:r:rild:s0 radio 181 1 /system/bin/rild\n--snip--\nu:r:platform_app:s0 u0_a12 950 183 com.android.systemui\nu:r:media_app:s0 u0_a5 1043 183 android.process.media\nu:r:radio:s0 radio 1141 183 com.android.phone\nu:r:nfc:s0 nfc 1163 183 com.android.nfc\nu:r:untrusted_app:s0 u0_a7 1360 183 com.google.android.gms\n--snip--\nListing 12-2: Process security contexts in Android\nSimilarly, the context of files can be viewed by passing the -Z to the ls\ncommand, as shown in Listing 12-3.\n# ls -Z\ndrwxr-xr-x root root u:object_r:cgroup:s0 acct\ndrwxrwx--- system cache u:object_r:cache_file:s0 cache\n-rwxr-x--- root root u:object_r:rootfs:s0 charger\n--snip--\ndrwxrwx--x system system u:object_r:system_data_file:s0 data\n-rw-r--r-- root root u:object_r:rootfs:s0 default.prop\ndrwxr-xr-x root root u:object_r:device:s0 dev\nlrwxrwxrwx root root u:object_r:rootfs:s0 etc -> /system/etc\n-rw-r--r-- root root u:object_r:rootfs:s0 file_contexts\ndr-xr-x--- system system u:object_r:sdcard_external:s0 firmware\n-rw-r----- root root u:object_r:rootfs:s0 fstab.hammerhead\n-rwxr-x--- root root u:object_r:rootfs:s0 init\n--snip--\nListing 12-3: File and directory security contexts in Android\nSELinux 323\nSecurity Context Assignment and Persistence\nWe’ve established that all subject and objects have a security context, but\nhow is the context assigned and persisted? For objects (which are usually\nassociated with a file on the filesystem), the security context is persistent\nand is usually stored as an extended attribute in the file’s metadata.\nExtended attributes are not interpreted by the filesystem and can con-\ntain arbitrary data (though any such data is usually limited in size). The\next4 filesystem, the default in most Linux distributions and current versions\nof Android, supports extended attributes in the form of name-value pairs,\nwhere the name is a null-terminated string. SELinux uses the security.selinux\nname to store the security context of file objects. The security context of\nobjects can be set explicitly as part of a filesystem initialization (also called\nlabeling), or be implicitly assigned when an object is created. Objects typi-\ncally inherit the type label of their parent (for example, newly created files\nin a directory inherit the label of the directory). However, if the security\npolicy allows, objects can receive a label that’s different from that of their\nparent, a process referred to as type transition.\nLike objects, subjects (processes) inherit the security context of their\nparent process, or they can change their context via domain transition, if\nallowed by the security policy. The policy can specify automatic domain\ntransition as well, which automatically sets the domain of newly started\nprocesses based on the domain of their parent and the type of the executed\nbinary. For example, because all system daemons are started by the init\nprocess, which has the u:r:init:s0 security context (u in Listing 12-2), they\nwould normally inherit this context, but Android’s SELinux policy uses\nautomatic domain transitions to set a dedicated domain to each daemon as\nneeded (v, w, and x in Listing 12-2).\nSecurity Policy\nThe SELinux security policy is used by the security server in the kernel to\nallow or disallow access to kernel objects at runtime. For performance rea-\nsons, the policy is typically in a binary form generated by compiling a number\nof policy source files. The policy source files are written in a dedicated policy\nlanguage, which consists of statements and rules. Statements define policy\nentities such as types, users, and roles. Rules allow or deny access to objects\n(access vector rules); specify the type of transitions allowed (type enforce-\nment rules); and designate how default users, roles, and types are assigned\n(default rules). A thorough discussion of SELinux’s policy grammar is\nbeyond the scope of this book, but the following sections will introduce\nsome of the most widely used statements and rules.\nPolicy Statements\nThe SELinux policy language supports various types of statements, but type,\nattribute, and permission statements make up the bulk of a security policy.\nWe introduce these three types of statements in the following sections.\n324 Chapter 12\nType and Attribute Statements\ntype and attribute statements declare types and their attributes, as shown in\nListing 12-4.\nattribute file_type;u\nattribute domain;v\ntype system_data_file, file_type, data_file_type;w\ntype untrusted_app, domain;x\nListing 12-4: type and attribute statements\nHere, the first u and second v statements declare the file_type and\ndomain attributes, and the next statement w declares the system_data_file\ntype and associates it with the file_type and data_file_type attributes. The\ncode at x declares the untrusted_app type and associates it with the domain\nattribute (which marks all types used for processes).\nDepending on its granularity, an SELinux policy can have dozens\nor even hundreds of type and attribute declarations spread across mul-\ntiple source files. However, because access to all kernel objects needs to be\nchecked against the policy at runtime, a large policy can have a negative\nimpact on performance. The effect on performance is especially apparent\nwhen running on devices with limited computing resources, and that is\nwhy Android strives to keep its SELinux policy relatively small.\nUser and Role Statements\nThe user statement declares an SELinux user identifier, associates it with its\nrole(s), and optionally specifies its default security level and the range of\nsecurity levels that the user can access. Listing 12-5 shows the declarations\nof the default and only user identifier in Android.\nuser u roles { r } level s0 range s0 - mls_systemhigh;\nListing 12-5: Declarations of the default SELinux user identifier in Android\nAs you can see in Listing 12-5, the u user is associated with the r role\n(inside the braces), which in turn is declared using the role statement u as\nshown in Listing 12-6.\nrole r;u\nrole r types domain;v\nListing 12-6: Declaration of the default SELinux role in Android\nThe second statement v associates the r role with the domain attribute,\nwhich marks it as a role assigned to processes (domains).\nSELinux 325\nObject Class and Permission Statements\nThe permissive statement allows a named domain to run in permissive mode\n(a mode that only logs MAC policy violations but doesn’t actually enforce\nthe policy, as discussed next), even if SELinux is running in enforcing\nmode. As we will see in “Enforcing Domains” on page 342, most domains\nin Android’s current base policy are permissive. For example, processes in\nthe adbd domain (in practice adbd daemon processes) run in permissive\nmode, as shown in Listing 12-7 u.\ntype adbd, domain;\npermissive adbd;u\n--snip--\nListing 12-7: Setting a named domain to permissive mode\nThe class statement defines an SELinux object class, as shown in\nListing 12-8. Object classes and their associated permissions are deter-\nmined by the respective object manager implementations in the Linux\nkernel, and are static within a policy. Object classes are usually defined in\nthe security_classes policy source file.\n--snip--\n# file-related classes\nclass filesystem\nclass file\nclass dir\nclass fd\nclass lnk_file\nclass chr_file\nclass blk_file\nclass sock_file\nclass fifo_file\n--snip--\nListing 12-8: Object class declarations in the security_classes file\nSELinux permissions (also referred to as access vectors) are usually\ndefined and associated with object classes in a policy source file called\naccess_vectors. Permissions can be either class-specific (defined with the\nclass keyword) or inheritable by one or more object classes, in which case\nthey’re defined with the common keyword. Listing 12-9 shows the definition of\nthe set of permissions common to all file objects u, and the association of the\ndir class (which represents directories) with all common file permissions\n(using the inherits keyword), and a set of directory-specific permissions\n(add_name, remove_name, and so on) v.\n--snip--\ncommon file\n{\nioctl\nread\n326 Chapter 12\nwrite\ncreate\ngetattr\nsetattr\nlock\n--snip--\n}u\n--snip--\nclass dir\ninherits file\n{\nadd_name\nremove_name\nreparent\nsearch\nrmdir\n--snip--\n}v\n--snip--\nListing 12-9: Permission definitions in the access_vectors file\nType Transition Rules\nType enforcement rules and access vector rules (discussed in “Domain\nTransition Rules” on page 328 and “Access Vector Rules” on page 329)\ntypically make the bulk of an SELinux policy. In turn, the most commonly\nused type of enforcement rule is the type_transition rule, which specifies when\ndomain and type transitions are allowed. For example, the wpa_supplicant\ndaemon, which manages Wi-Fi connections in Android, uses the type transi-\ntion rule shown in Listing 12-10 at x in order to associate the control sock-\nets it creates in the /data/misc/wifi/ directory with the wpa_socket type. In\nthe absence of this rule, the sockets would inherit the type of their parent\ndirectory: wifi_data_file.\n# wpa - wpa supplicant or equivalent\ntype wpa, domain;\npermissive wpa;u\ntype wpa_exec, exec_type, file_type;\ninit_daemon_domain(wpa)v\nunconfined_domain(wpa)w\ntype_transition wpa wifi_data_file:sock_file wpa_socket;x\nListing 12-10: Type transitions in the wpa domain (from wpa_supplicant .te)\nHere, wpa, wifi_data_file:sock_file, and wpa_socket are the source type\n(in this case, the domain of the wpa_supplicant process), the target type and\nclass (the type and class of the object before the transition), and the type of\nthe object after the transition, respectively.\nSELinux 327\nNOTE In order to be able to create the socket file and change its label, the wpa domain\nneeds additional permissions on the parent directory and the socket file itself—the\ntype_transition rule alone is not sufficient. However, because the wpa domain is both\npermissive u and unconfined (granted most permissions by default) w, the transition\nis allowed without explicitly allowing each required permission.\nDomain Transition Rules\nIn Android, native system daemons like wpa_supplicant are started by the init\nprocess, and therefore inherit its security context by default. However, most\ndaemons are associated with a dedicated domain and use domain transitions\nto switch their domain when started. This is typically accomplished using\nthe init_daemon_domain() macro (v in Listing 12-10), which under the hood is\nimplemented using the type_transition keyword, just like type transitions.\nThe binary SELinux policy build process uses the m4 macro preprocessor1\nto expand macros before merging all source files in order to create the\nbinary policy file. The init_daemon_domain() macro takes one parameter (the\nnew domain of the process) and is defined in the te_macros file using two\nother macros: domain_trans() and domain_auto_trans(), which are used to\nallow transition to a new domain and to execute the transition automati-\ncally, respectively. Listing 12-11 shows the definitions of these three macros\n(u, v, and w). The lines beginning with the allow keyword are access vec-\ntor (AV) rules, which we discuss in the next section.\n# domain_trans(olddomain, type, newdomain)\ndefine(`domain_trans', `\nallow $1 $2:file { getattr open read execute };\nallow $1 $3:process transition;\nallow $3 $2:file { entrypoint read execute };\nallow $3 $1:process sigchld;\ndontaudit $1 $3:process noatsecure;\nallow $1 $3:process { siginh rlimitinh };\n')u\n# domain_auto_trans(olddomain, type, newdomain)\ndefine(`domain_auto_trans', `\ndomain_trans($1,$2,$3)\ntype_transition $1 $2:process $3;\n')v\n# init_daemon_domain(domain)\ndefine(`init_daemon_domain', `\ndomain_auto_trans(init, $1_exec, $1)\ntmpfs_domain($1)\n')w\n--snip--\nListing 12-11: Domain transition macros definition in the te_macros file\n1. Free Software Foundation, Inc., “GNU M4 - GNU Project - Free Software Foundation\n(FSF),” https://www.gnu.org/software/m4/\n328 Chapter 12\nAccess Vector Rules\nAV rules define what privileges processes have at runtime by specifying the\nset of permissions they have over their target objects. Listing 12-12 shows\nthe general format of an AV rule.\nrule_name source_type target_type : class perm_set;\nListing 12-12: Format of AV rules\nThe rule_name can be allow, dontaudit, auditallow, or neverallow. To form\na rule, the source_type and target_type elements are replaced with one or\nmore previously defined type or attribute identifiers, where source_type is the\nidentifier of a subject (process), and target_type is the identifier of an object\nthe process is trying to access. The class element is replaced with the object\nclass of the target, and perm_set specifies the set of permissions that the\nsource process has over the target object. You can specify multiple types,\nclasses, and permissions by enclosing them in braces ({}). In addition, some\nrules support use of the wildcard (*) and complement (~) operators, which\nallow you to specify that all types should be included or that all types except\nthose explicitly listed should be included, respectively.\nallow Rules\nThe most commonly used rule is allow, which specifies the operations that\na subject (process) of the specified source type is allowed to perform on\nan object of the target type and class specified in the rule. Let’s take the\nSELinux policy for the vold daemon (see Listing 12-13) as an example to\nillustrate how to use the allow rule.\ntype vold, domain;\ntype vold_exec, exec_type, file_type;\ninit_daemon_domain(vold)\n--snip--\nallow vold sdcard_type:filesystem { mount remount unmount };u\n--snip--\nallow vold self:capability { sys_ptrace kill };v\n--snip--\nListing 12-13: allow rules for the vold domain (from vold .te)\nIn this listing, rule u allows the vold daemon (which runs in the vold\ndomain) to mount, unmount, and remount filesystems of type sdcard_type.\nRule v allows the daemon to use the CAP_SYS_PTRACE (which allows ptrace()\nto be called on any process) and CAP_KILL (which allows signals to be sent to\nany process) Linux capabilities, which correspond to the permission set\nspecified in the rule (inside the {}). In rule v, the self keyword means that\nthe target domain is the same as the source, which in this case is vold.\nSELinux 329\nauditallow Rules\nThe auditallow rule is used with allow to record audit events when an opera-\ntion is allowed. This is useful because by default, SELinux logs only access\ndenied events. However, auditallow itself doesn’t grant access, and there-\nfore a matching allow rule must be used in order to grant the necessary\npermissions.\ndontaudit Rules\nThe dontaudit rule is used to suppress the auditing of denial messages\nwhen a specified event is known to be safe. For example, the rule at u in\nListing 12-14 specifies that no audit log be created if the installd daemon is\ndenied the CAP_SYS_ADMIN capability. However, dontaudit rules can mask pro-\ngram errors and the use of dontaudit is discouraged.\ntype installd, domain;\n--snip--\ndontaudit installd self:capability sys_admin;u\n--snip--\nListing 12-14: dontaudit rule for the installd domain (from installd .te)\nneverallow Rules\nThe neverallow rule says that the declared operation should never be allowed,\neven if an explicit allow rule that allows it exists. For example, the rule\nshown in Listing 12-15 forbids all domains but the init domain to load the\nSELinux policy.\n--snip--\nneverallow { domain -init } kernel:security load_policy;\nListing 12-15: neverallow rule that forbids domains other than init from loading the SELinux\npolicy (from domain .te)\nNOTE This section provides only a brief overview of SELinux, focusing on the features used\nin Android. For a more detailed discussion of the architecture and implementation of\nSELinux, as well its policy language, see the SELinux Notebook.2\nandroid Implementation\nAs discussed in Chapters 1 and 2, Android’s sandboxing security model\nrelies heavily on the use of separate Linux UIDs for system daemons and\napplications. Process isolation and access control is ultimately enforced by\n2. Richard Haines, The SELinux Notebook: The Foundations, 3rd edition, 2012, http://www\n.freetechbooks.com/efiles/selinuxnotebook/The_SELinux_Notebook_The_Foundations_3rd_Edition.pdf\n330 Chapter 12\nthe Linux kernel based on process UID and GIDs. Because SELinux is also\npart of the Linux kernel, SELinux is a natural candidate for hardening the\nAndroid sandboxing model using a MAC policy.\nAs SELinux is integrated into the mainline Linux kernel, it would\nseem that enabling it in Android should be a simple matter of configuring\nthe kernel and designing an appropriate MAC policy. However, because\nAndroid introduces some unique extensions to the Linux kernel and its\nuserspace structure is quite different from that of desktop and server Linux\ndistributions, several changes in both kernel and userspace were needed in\norder to integrate and enable SELinux into Android. While the initial work\nrequired to integrate SELinux was started by Google, most of the required\nchanges were implemented in the Security Enhancements for Android\nproject (formally Security-Enhanced Android, or SEAndroid),3 and were\nlater integrated into the mainline Android source tree. The following sec-\ntions survey these major changes. For a comprehensive list of changes and the\nrationale behind them, see the Security Enhanced (SE) Android: Bringing Flexible\nMAC to Android paper by the original authors of the SEAndroid project.4\nKernel Changes\nRecall from earlier that SELinux is a security module that implements\nthe various LSM hooks inserted in kernel services related to object access\ncontrol. Android’s Binder IPC mechanism is also implemented as a kernel\ndriver, but because its implementation originally did not contain any LSM\nhooks, its runtime behavior could not be controlled by an SELinux policy.\nIn order to add SELinux support to Binder, LSM hooks were inserted into\nthe Binder driver, and support for the binder object class and related per-\nmissions was added to SELinux code.\nSELinux security hooks are declared in include/linux/security.h, and\nListing 12-16 shows the Binder-related declarations added to support Android.\n--snip--\nint security_binder_set_context_mgr(struct task_struct *mgr);u\nint security_binder_transaction(struct task_struct *from,\nstruct task_struct * to);v\nint security_binder_transfer_binder(struct task_struct *from,\nstruct task_struct *to);w\nint security_binder_transfer_file(struct task_struct *from,\nstruct task_struct *to, struct file *file);x\n--snip--\nListing 12-16: Binder security hooks declarations in include/linux/security .h\n3. Security Enhancements for Android, https://bitbucket.org/seandroid/manifests/\n4. Craig Smalley, Security Enhanced (SE) Android: Bringing Flexible MAC to Android, http://\nwww.internetsociety.org/sites/default/files/02_4.pdf\nSELinux 331\nThe first hook u controls what process can become the binder context\nmanager, and the second one v controls the ability of a process to invoke\na binder transaction. The next two functions are used to regulate who can\ntransfer a Binder reference to another process w, and transfer an open file\nto another process x using Binder.\nIn order to allow the SELinux policy to set restrictions for Binder,\nsupport for the binder object class and its permissions (impersonate, call,\nset_context_mgr, and transfer) was also added to the kernel, as shown in\nListing 12-17.\n--snip--\nstruct security_class_mapping secclass_map[] = {\n--snip--\n{\"binder\", {\"impersonate\", \"call\", \"set_context_mgr\", \"transfer\", NULL} },\n{ NULL }\n};\nListing 12-17: Binder object class and permission declaration in selinux/include/classmap .h\nUserspace Changes\nIn addition to kernel changes, a number of userspace modifications and\nextensions were also required in order to integrate SELinux into Android.\nAmong these, the most important ones are support for filesystem labeling\nin the core C library (bionic); extensions to init and the core native dae-\nmons and executables; framework-level SELinux APIs; and modifications\nto core framework services to make them SELinux-aware. This section\ndescribes each change and how it’s integrated into the Android runtime.\nLibraries and Tools\nBecause SELinux uses extended attributes to store the security contexts of\nfilesystem objects, wrapper functions for the system calls used to manage\nextended attributes (listxattr(), getxattr(), setxattr(), and so on) were first\nadded to Android’s C library in order to be able to get and set the security\nlabels of files and directories.\nIn order to be able to take advantage of SELinux features from user-\nspace, SEAndroid added an Android-compatible port of the libselinux\nlibrary, as well as a set of utility commands to manage labeling, the security\npolicy, and to switch the SELinux mode between enforcing and permissive.\nLike most Android command-line utilities, SELinux tools are implemented\nin the toolbox binary and are installed as symbolic links to it. Table 12-1\nsummarizes the added or modified command-line tools.\n332 Chapter 12\nTable 12-1: SELinux Command-Line Utilities\nCommand Description\nchcon Changes a file’s security context\ngetenforce Gets the current SELinux mode\ngetsebool Gets policy Boolean values\nid Displays a process’s security context\nload_policy Loads a policy file\nls -Z Displays the security context of a file\nps -Z Displays the security context of running processes\nrestorecon Restores the security context of a file(s)\nruncon Runs a program in the specified security context\nsetenforce Sets the enforcing mode\nsetsebool Sets the value of a policy Boolean\nSystem Initialization\nAs in traditional Linux systems, in Android all userspace daemons and\nprograms are started by the init process, the first process the kernel starts\n(PID=1). However, unlike other Linux-based systems, Android’s initializa-\ntion scripts (init.rc and its variants) are not interpreted by a general-purpose\nshell, but by init itself. Each initialization script contains built-in commands\nthat are executed by init as it reads the script. SEAndroid extends Android’s\ninit language with a number of new commands required to initialize SELinux\nand set the security contexts of services and files, as summarized in Table 12-2.\nTable 12-2: init Built-in Commands for SELinux Support\ninit Built-In Command Description\nseclabel Sets the security context of a service\nrestorecon Restores the security context of a file or directory\nsetcon Set the security context of the init process\nsetenforce Sets the enforcing mode\nsetsebool Sets the value of a policy Boolean\nWhen init starts, it loads the SELinux policy from the /sepolicy binary\npolicy file, and then sets the enforcing mode based on the value of the\nro.boot.selinux system property (which init sets based on the value of the\nandroidboot.selinux kernel command-line parameter). When the property\nvalue is permissive, SELinux goes into permissive mode; when set to any\nother value or not set at all, the mode is set to enforcing.\nSELinux 333\nNext, init loads and parses the init.rc file and executes the commands\nspecified there. Listing 12-18 shows an excerpt of init.rc, focusing on the\nparts responsible for SELinux initialization.\n--snip--\non early-init\n--snip--\nsetcon u:r:init:s0u\nstart ueventd\n--snip--\non post-fs-data\nchown system system /data\nchmod 0771 /data\nrestorecon /datav\n--snip--\nservice ueventd /sbin/ueventd\nclass core\ncritical\nseclabel u:r:ueventd:s0w\n--snip--\non property:selinux.reload_policy=1x\nrestart ueventd\nrestart installd\n--snip--\nListing 12-18: SELinux initialization in init .rc\nIn this example, init sets its own security context using the setcon\ncommand u before starting the core system daemons. Because a child\nprocess inherits the security context of its parent, init explicitly sets the\nsecurity context of the ueventd daemon (the first daemon to be started) to\nu:r:ueventd:s0 w using the seclabel command. Most other native services\nhave their domain set automatically by type transition rules defined in the\npolicy (as in Listing 12-10). (The seclabel command is only used to set the\nsecurity contexts of processes that start very early in the system initializa-\ntion process.)\nWhen writable filesystems are mounted, init uses the restorecon com-\nmand to restore the default labels of their mount points, because a factory\nreset could have cleared their labels. Listing 12-18 shows the command v\nthat labels the userdata partition’s mount point—/data.\nFinally, because a policy reload can be triggered by setting the selinux\n.reload_policy system property to 1 x, init restarts the ueventd and installd\ndaemons when this property is set so that the new policy can take effect.\nLabeling Files\nRecall that persistent SELinux objects, such as files, have a persistent security\ncontext that is typically saved in a file’s extended attribute. In Android, the\ninitial security context of all files is defined in a text file called file_contexts,\nwhich might look like Listing 12-19.\n334 Chapter 12\n/ u:object_r:rootfs:s0u\n/adb_keys u:object_r:rootfs:s0\n/default.prop u:object_r:rootfs:s0\n/fstab\\..* u:object_r:rootfs:s0\n--snip--\n/dev(/.*)? u:object_r:device:s0v\n/dev/akm8973.* u:object_r:akm_device:s0\n/dev/accelerometer u:object_r:accelerometer_device:s0\n--snip--\n/system(/.*)? u:object_r:system_file:s0w\n/system/bin/ash u:object_r:shell_exec:s0\n/system/bin/mksh u:object_r:shell_exec:s0\n--snip--\n/data(/.*)? u:object_r:system_data_file:s0x\n/data/backup(/.*)? u:object_r:backup_data_file:s0\n/data/secure/backup(/.*)? u:object_r:backup_data_file:s0\n--snip--\nListing 12-19: Contents of the file_contexts file\nAs you can see, the file contains a list of paths (sometimes using wild-\ncard characters) and their associated security contexts, each on a new\nline. The file_contexts file is consulted at various times during Android’s\nbuild and bootup process. For example, because on-memory filesystems\nsuch as Android’s root filesystem (mounted at /) and the device filesystem\n(mounted at /dev) are not persistent, all files are usually associated with the\nsame security context as specified in the genfs_contexts file, or assigned using\nthe context= mount option. In order to assign individual security contexts\nto specific files in such filesystems, init uses the restorecon command to\nlook up the security context of each file in file_contexts (u for the root file-\nsystem, and v as the default for the device filesystem) and sets it accord-\ningly. When building Android from source, the make_ext4fs command also\nconsults file_contexts in order to set the initial contexts of files on the system\n(mounted at /system w) and userdata partition (mounted at /data x) images.\nThe security contexts of data partitions’ mount points are also restored\non each boot (as shown in Listing 12-18) in order to make sure they’re\nin a consistent state. Finally, Android’s recovery OS also includes a copy of\nfile_contexts, which is used to set the correct labels of files created by the\nrecovery during system updates. This guarantees that the system remains\nin a securely labeled stated across updates and avoids the need for full rela-\nbeling after each update.\nLabeling System Properties\nAndroid uses global system properties that are visible to all processes for\nvarious purposes such as communicating hardware state, starting or stop-\nping system services, triggering disk encryption, and even reloading the\nSELinux policy. Access to read-only system properties isn’t restricted, but\nbecause changing the values of key read-write properties alters the behav-\nior of the system, write access to these properties is restricted and allowed\nonly to system processes running under privileged UIDs, such as system and\nSELinux 335\nradio. SEAndroid augments this UID-based access control by adding MAC\nrules that regulate write access to system properties based on the domain of\nthe process attempting property modification. In order for this to work, sys-\ntem properties (which are not native SELinux objects) must be associated\nwith security contexts. This is accomplished by listing the security contexts\nof properties in a property_contexts file, much the same way that file_contexts\nspecifies the security labels of files. The file is loaded into memory by the\nproperty_service (part of init), and the resulting security context lookup table\nis used to determine whether a process should be allowed access to a spe-\ncific property based on the security contexts of both the process (subject)\nand the property (object). The SELinux policy defines a new property_service\nobject class, with a single permission, set, which is used to specify access\nrules, as shown in Listing 12-20.\ntype vold, domain;\n--snip--\nallow vold vold_prop:property_service set;u\nallow vold powerctl_prop:property_service set;v\nallow vold ctl_default_prop:property_service set;w\n--snip--\nListing 12-20: System property access rules in vold .te\nIn this listing, the vold domain is allowed to set system properties of\ntype vold_prop u, powerctl_prop v, and ctl_default_prop w.\nThese types are associated with actual properties based on the property\nname in property_contexts, as shown in Listing 12-21.\n--snip--\nvold. u:object_r:vold_prop:s0u\nsys.powerctl u:object_r:powerctl_prop:s0v\nctl. u:object_r:ctl_default_prop:s0w\n--snip--\nListing 12-21: Association of property names with their security contexts in property_contexts\nThe effect of this policy is that vold can set the values of all properties\nwhose name starts with vold. u, sys.powerctl v, or ctl. w.\nLabeling Application Processes\nRecall from Chapter 2 that all app processes in Android are forked from\nthe zygote process in order to reduce memory usage and improve application\nstartup time. The system_server process, which runs as the system user and\nhosts most system services, is also forked from zygote, albeit via a slightly dif-\nferent interface.\nThe zygote process, which runs as root, is responsible for setting each\napp process’s DAC credentials (UID, GID, and supplementary GIDs), as\nwell as its capabilities and resource limits. In order to support SELinux,\nzygote has been extended to check the security context of its clients (imple-\nmented in the ZygoteConnection class) and set the security context of each\n336 Chapter 12\napp process that it forks. The security context is determined according\nto the assignment rules specified in the seapp_contexts configuration file,\naccording to the app’s UID, its package name, a flag that marks the system\nserver process, and an SELinux-specific string attribute called seinfo. The\nseapp_contexts configuration file contains security context assignment rules\n(one per line) that consist of input selector attributes and output attributes.\nIn order for a rule to be matched, all input selectors should match (logical\nAND). Listing 12-22 shows the contents of the seapp_contexts file in the refer-\nence Android SELinux policy as of version 4.4.3.\nNOTE The seapp_contexts, like all files in the reference policy, can be found in the\nexternal/sepolicy/ directory of Android’s source tree. See the file’s comments for\nthe full list of input selectors, the selector matching precedence rules, and outputs.\nisSystemServer=true domain=systemu\nuser=system domain=system_app type=system_data_filev\nuser=bluetooth domain=bluetooth type=bluetooth_data_file\nuser=nfc domain=nfc type=nfc_data_file\nuser=radio domain=radio type=radio_data_file\nuser=_app domain=untrusted_app type=app_data_file levelFrom=nonew\nuser=_app seinfo=platform domain=platform_app type=platform_app_data_filex\nuser=_app seinfo=shared domain=shared_app type=platform_app_data_filey\nuser=_app seinfo=media domain=media_app type=platform_app_data_file\nuser=_app seinfo=release domain=release_app type=platform_app_data_file\nuser=_isolated domain=isolated_appz\nuser=shell domain=shell type=shell_data_file\nListing 12-22: Contents of the seapp_contexts file\nThe first line u in this listing specifies the domain of the system server\n(system), because the isSystemServer selector (which can be used only once)\nis set to true. Because Android uses a fixed SELinux user identifier, role and\nsecurity level, the resulting security context becomes u:r:system:s0.\nThe second assignment rule v matches the user selector against the\ntarget process’s username, which is derived from its UID. If a process runs\nas one of the built-in Android Linux users (system, radio, nfc, and so on, as\ndefined in android_filesystem_config.h), the associated name is used when\nmatching the user selector. Isolated services are given the _isolated user-\nname string, and any other process is given the _app username string. Thus,\nsystem apps that match this selector are assigned the system_app domain.\nThe type attribute specifies the object type that’s assigned to files owned\nby the target process. Because in this case the type is system_data_file, the\nsecurity context of system files becomes u:object_r:system_data_file:s0.\nRule w matches all apps that execute under a non-system UID and\nassigns their processes to the untrusted_app domain. The private app data\ndirectory of each untrusted app is recursively assigned the app_data_file\nobject type, which results in the u:object_r:app_data_file:s0 security context.\nThe security context of the data directory is set by the installd daemon when\nit creates it as part of the app install process (see Chapter 3).\nSELinux 337\nRules x and y use the seinfo selector to differentiate between non-\nsystem apps and assign them to different domains: apps processes that\nmatch seinfo=platform are assigned the platform_app domain, and those\nmatching seinfo=shared are assigned the shared_app domain. (As we’ll see\nin the next section, an app’s seinfo attribute is determined by its signing\ncertificate, so in effect, rules x and y use each app’s signing certificate\nas a process domain selector.)\nFinally, rule z assigns the isolated_app domain to all isolated services.\n(Isolated services run under a UID separate from their hosting app’s UID\nand cannot access any system services.)\nMiddleware MAC\nThe seinfo attribute introduced in the previous section is part of an\nSEAndroid feature called middleware MAC (MMAC), which is a higher-\nlevel access control scheme, separate from the kernel-level MAC (imple-\nmented in the SELinux LSM module).\nThe MMAC was designed to provide MAC restrictions over Android’s\npermission model, which works at the framework level and cannot be eas-\nily mapped to the default kernel-level MAC. The original implementation\nincludes an install-time MAC feature, which restricts the permissions that\ncan be granted to each package based on its package name and signing\ncertificate, regardless of a user’s permission grant decision. That is, even if\na user decides to grant an app all the permissions it requests, the install can\nstill be blocked by the MMAC if the policy doesn’t allow certain permissions\nto be granted.\nSEAndroid’s MMAC implementation also includes an intent MMAC fea-\nture that uses a policy to control which intents can be exchanged between\napplications. Another SEAndroid feature is the content provider MMAC,\nwhich defines a policy for content provider data access. However, the original\nSEAndroid MMAC implementation has been merged in mainline Android\nonly partially, and the only supported feature is seinfo assignment based on\nthe app signing certificate.\nNOTE As of version 4.3, Android has an experimental intent firewall feature that\nrestricts what intents can be sent and received using “firewall”-style rules. This\nfeature is similar to SEAndroid’s intent MMAC but is not integrated with the\nSELinux implementation.\nThe MMAC configuration file is called mac_permission.xml and resides\nin the /system/etc/security/ directory on the device. Listing 12-23 shows the\ntemplate used to generate this file, typically stored as external/sepolicy/\nmac_permission.xml in Android’s source tree.\n338 Chapter 12\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<policy>\n<!-- Platform dev key in AOSP -->\n<signer signature=\"@PLATFORM\" >u\n<seinfo value=\"platform\" />\n</signer>\n<!-- Media dev key in AOSP -->\n<signer signature=\"@MEDIA\" >v\n<seinfo value=\"media\" />\n</signer>\n<!-- shared dev key in AOSP -->\n<signer signature=\"@SHARED\" >w\n<seinfo value=\"shared\" />\n</signer>\n<!-- release dev key in AOSP -->\n<signer signature=\"@RELEASE\" >x\n<seinfo value=\"release\" />\n</signer>\n<!-- All other keys -->\n<default>y\n<seinfo value=\"default\" />\n</default>\n</policy>\nListing 12-23: Template for the mac_permission .xml file\nHere, the @PLATFORM u, @MEDIA v, @SHARED w, and @RELEASE x\nmacros represent the four platform signing certificates used in Android\n(platform, media, shared, and release) and are replaced with their respective\ncertificates, encoded as hexadecimal strings, when building the SELinux\npolicy.\nWhen scanning each installed package, the system PackageManagerService\nmatches its signing certificate against the contents of the mac_permission.xml\nfile and assigns the specified seinfo value to the package if it finds a match.\nIf no match is found, it assigns the default seinfo value as specified by the\n<default> tag y.\nDevice Policy Files\nAndroid’s SELinux policy consists of a binary policy file and four support-\ning configuration files, which are used for process, app, system property,\nand file labeling, as well as for MMAC initialization. Table 12-3 shows where\neach of these files is located on a device and provides a brief description of\nthe file’s purpose and contents.\nSELinux 339\nTable 12-3: Android SELinux Policy Files\nPolicy File Description\n/sepolicy Binary kernel policy\n/file_contexts File security contexts, used for\nlabeling filesystems\n/property_contexts System property security contexts\n/seapp_contexts Used to derive security contexts of\napp processes and files\n/system/etc/security/mac_permissions.xml Maps app signing certificates to\nseinfo values\nNOTE SELinux-enabled Android releases before version 4.4.3 supported overriding the\ndefault policy files shown in Table 12-3 with their counterparts stored in the /data/\nsecurity/current/ and /data/system/ (for the MMAC configuration file) direc-\ntories in order to enable online policy updates without a full OTA update. However,\nAndroid 4.4.3 removed this feature because it could create discrepancies between the\nsecurity labels set on the filesystem and the labels referenced from the new policy. Policy\nfiles are now loaded only from the default, read-only locations shown in Table 12-3.\nPolicy Event Logging\nAccess denial and access grants that have matching auditallow rules are\nlogged to the kernel log buffer and can be viewed using dmesg, as shown in\nListing 12-24.\n# dmesg |grep 'avc:'\n--snip--\n<5>[18743.725707] type=1400 audit(1402061801.158:256): avc: denied { getattr\n} for pid=9574 comm=\"zygote\" path=\"socket:[8692]\" dev=\"sockfs\" ino=8692\nscontext=u:r:untrusted_app:s0 tcontext=u:r:zygote:s0 tclass=unix_stream_socket\n--snip--\nListing 12-24: SELinux access denials logged in the kernel log buffer\nHere, the audit log shows that a third-party application (source security\ncontext u:r:untrusted_app:s0) was denied access to the getattr permission\non the zygote Unix domain socket (target context u:r:zygote:s0, object class\nunix_stream_socket).\nandroid 4.4 sELinux Policy\nAndroid 4.2 was the first release to contain SELinux code, but SELinux was\ndisabled at compile time in release builds. Android 4.3 enabled SELinux\nin all builds, but its default mode was set to permissive. Additionally, all\ndomains were also individually set to permissive and were based on the\nunconfined domain, essentially allowing them full access (within the confines\nof DAC), even if the global SELinux mode was set to enforcing.\n340 Chapter 12\nAndroid 4.4 was the first version to ship with SELinux in enforcing\nmode, and it included enforcing domains for core system daemons. This\nsection gives an overview of Android’s SELinux policy, as deployed in ver-\nsion 4.4, and introduces some of the major domains that make up the policy.\nPolicy Overview\nThe source code of Android’s base SELinux policy is hosted in the external/\nsepolicy/ directory of the Android source tree. Besides the files introduced\nin this chapter so far (access_vectors, file_contexts, mac_permissions.xml, and so\non), the policy source consists mostly of type enforcement (TE) statements\nand rules split into multiple .te files, typically one for each defined domain.\nThese files are combined to produce the binary policy file sepolicy, which is\nincluded in the root of the boot image as /sepolicy.\nYou can examine the binary policy file using standard SELinux tools\nsuch as seinfo, sesearch, sedispol, and so on. For example, we can use the\nseinfo command to get a summary of the number of policy objects and\nrules, as shown in Listing 12-25.\n$ seinfo sepolicy\nStatistics for policy file: sepolicy\nPolicy Version & Type: v.26 (binary, mls)\nClasses: 84 Permissions: 249\nSensitivities: 1 Categories: 1024\nTypes: 267 Attributes: 21\nUsers: 1 Roles: 2\nBooleans: 1 Cond. Expr.: 1\nAllow: 1140 Neverallow: 0\nAuditallow: 0 Dontaudit: 36\nType_trans: 132 Type_change: 0\nType_member: 0 Role allow: 0\nRole_trans: 0 Range_trans: 0\nConstraints: 63 Validatetrans: 0\nInitial SIDs: 27 Fs_use: 14\nGenfscon: 10 Portcon: 0\nNetifcon: 0 Nodecon: 0\nPermissives: 42 Polcap: 2\nListing 12-25: Querying a binary policy file using the seinfo command\nAs you can see, the policy is fairly complex: it defines 84 classes, 267 types,\nand 1,140 allow rules.\nYou can get additional information about policy objects by specifying\nfiltering options to the seinfo command. For example, because all domains\nare associated with the domain attribute, the command shown in Listing 12-26\nlists all domains defined in the policy.\nSELinux 341\n$ seinfo -adomain -x sepolicy\ndomain\nnfc\nplatform_app\nmedia_app\nclatd\nnetd\nsdcardd\nzygote\n--snip--\nListing 12-26: Getting a list of all defined domains using the seinfo command\nYou can search for policy rules using the sesearch command. For\nexample, all allow rules that have the zygote domain as their source can\nbe displayed using the command shown in Listing 12-27.\n$ sesearch --allow -s zygote -d sepolicy\nFound 40 semantic av rules:\nallow zygote zygote_exec : file { read execute execute_no_trans entrypoint open } ;\nallow zygote init : process sigchld ;\nallow zygote rootfs : file { ioctl read getattr lock open } ;\nallow zygote rootfs : dir { ioctl read getattr mounton search open } ;\nallow zygote tmpfs : filesystem mount ;\nallow zygote tmpfs : dir { write create setattr mounton add_name search } ;\n--snip--\nListing 12-27: Searching for policy rules using the sesearch commands\nNOTE For details about building and customizing the SELinux policy, see the Validating\nSecurity-Enhanced Linux in Android document.5\nEnforcing Domains\nEven though SELinux is deployed in enforcing mode in Android 4.4, only\nthe domains assigned to a few core daemons are currently enforcing, namely:\ninstalld (responsible for creating application data directories), netd (respon-\nsible for managing network connections and routes), vold (responsible for\nmounting external storage and secure containers), and zygote. All of these\ndaemons run as root or are granted special capabilities because they need\nto perform administrative operations such as changing directory ownership\n(installd), manipulating packet filtering and routing rules (netd), mounting\nfilesystems (vold), and changing process credentials (zygote) on behalf of\nother processes.\nBecause they have elevated privileges, these daemons have been\nthe target of various privilege escalation exploits, which have allowed\nnon-privileged processes to obtain root access on a device. Therefore,\n5. Google, “Validating Security-Enhanced Linux in Android,” http://source.android.com/devices/\ntech/security/se-linux.html\n342 Chapter 12\nspecifying a restrictive MAC policy for the domains associated with these\nsystem daemons is an important step towards strengthening Android’s\nsandboxing security model and preventing similar exploits in the future.\nLet’s look at the type enforcement rules defined for the installd domain\n(in instald.te) to see how SELinux restricts what system daemons can access\n(see Listing 12-28).\ntype installd, domain;\ntype installd_exec, exec_type, file_type;\ninit_daemon_domain(installd)u\nrelabelto_domain(installd)v\ntypeattribute installd mlstrustedsubject;w\nallow installd self:capability { chown dac_override fowner fsetid setgid setuid };x\n--snip--\nallow installd dalvikcache_data_file:file create_file_perms;y\nallow installd data_file_type:dir create_dir_perms;z\nallow installd data_file_type:dir { relabelfrom relabelto };{\nallow installd data_file_type:{ file_class_set } { getattr unlink };|\nallow installd apk_data_file:file r_file_perms;}\n--snip--\nallow installd system_file:file x_file_perms;~\n--snip--\nListing 12-28: installd type enforcement policy (from installd .te)\nIn this listing, the installd daemon is first automatically transitioned\nto a dedicated domain (also named installd) when started u using the\ninit_daemon_domain() macro. It is then granted the relabelto permission so\nthat it can set the security labels of the files and directories it creates v.\nNext, the domain is associated with the mlstrustedsubject attribute w, which\nallows it to bypass MLS access rules. Because installd needs to set the owner\nof the files and directories it creates to that of their owner application, it’s\ngranted the chown, dac_override, and other capabilities pertaining to file\nownership x.\nAs part of the app install process, installd also triggers the DEX opti-\nmization process, which creates ODEX files in the /data/dalvik-cache/ direc-\ntory (security context u:object_r:dalvikcache_data_file:s0), which is why the\ninstaller daemon is granted permission to create files in that directory y.\nNext, because installd creates private data directories for applications in the\n/data/ directory, it is given permission to create and relabel directories (z\nand {), as well as get the attributes and delete files | under /data/ (which\nis associated with the data_file_type attribute). Because installd also needs\nto read downloaded APK files in order to perform DEX optimization, it’s\ngranted access to APK files stored under /data/app/ }, a directory associ-\nated with the apk_data_file type (security context u:object_r:apk_data_file:s0).\nFinally, installd is allowed to execute system commands (security context\nu:object_r:system_file:s0) ~ in order to start the DEX optimization process.\nListing 12-28 omits a few of them, but the remaining policy rules follow the\nSELinux 343\nsame principle: allow installd the least amount of privileges it needs to com-\nplete package installation. As a result, even if the daemon is compromised\nand a malicious program is executed under installd’s privileges, it would\nonly have access to a limited number of files and directories, and would be\ndenied any permissions not explicitly allowed by the MAC policy.\nNOTE While Android 4.4 has only four enforcing domains, as the platform evolves and\nthe base SELinux policy is refined, eventually all domains are likely to be deployed\nin enforcing mode. For example, as of this writing, in the base policy in the master\nbranch of the Android Open Source Project (AOSP), all domains are set to enforcing\nmode in release builds and the permissive domains are only used in development builds.\nEven if a domain is in enforcing mode, it can be allowed effectively\nunrestricted access if it’s derived from a base domain that is granted all or\nmost access permissions. In Android’s SELinux policy, such a domain is the\nunconfineddomain domain, which we discuss next.\nUnconfined Domains\nAndroid’s SELinux policy contains a base (also referred to as template)\ndomain called unconfineddomain, which is allowed almost all system privileges\nand is used as a parent for other policy domains. As of Android 4.4, the\nunconfineddomain is defined as shown in Listing 12-29.\nallow unconfineddomain self:capability_class_set *;u\nallow unconfineddomain kernel:security ~load_policy;v\nallow unconfineddomain kernel:system *;\nallow unconfineddomain self:memprotect *;\nallow unconfineddomain domain:process *;w\nallow unconfineddomain domain:fd *;\nallow unconfineddomain domain:dir r_dir_perms;\nallow unconfineddomain domain:lnk_file r_file_perms;\nallow unconfineddomain domain:{ fifo_file file } rw_file_perms;\nallow unconfineddomain domain:socket_class_set *;\nallow unconfineddomain domain:ipc_class_set *;\nallow unconfineddomain domain:key *;\nallow unconfineddomain fs_type:filesystem *;\nallow unconfineddomain {fs_type dev_type file_type}:{ dir blk_file lnk_file sock_file fifo_file\n} ~relabelto;\nallow unconfineddomain {fs_type dev_type file_type}:{ chr_file file } ~{entrypoint relabelto};\nallow unconfineddomain node_type:node *;\nallow unconfineddomain node_type:{ tcp_socket udp_socket rawip_socket } node_bind;\nallow unconfineddomain netif_type:netif *;\nallow unconfineddomain port_type:socket_class_set name_bind;\nallow unconfineddomain port_type:{ tcp_socket dccp_socket } name_connect;\nallow unconfineddomain domain:peer recv;\nallow unconfineddomain domain:binder { call transfer set_context_mgr };\nallow unconfineddomain property_type:property_service set;\nListing 12-29: unconfineddomain domain definition in Android 4.4\n344 Chapter 12\nAs you can see, the unconfineddomain domain is allowed all kernel capa-\nbilities u, full access to the SELinux security server v (except for load-\ning the MAC policy), all process-related permissions w, and so on. Other\ndomains “inherit” the permissions of this domain via the unconfined_domain()\nmacro, which assigns the unconfineddomain attribute to the domain passed\nas an argument. In Android 4.4’s SELinux policy, all permissive domains\nare also unconfined, and thus are granted practically unrestricted access\n(within the limits of the DAC).\nNOTE While the unconfineddomain still exists in AOSP’s master branch, it has been consider-\nably restricted and is no longer used as an unrestricted domain, but as the base policy\nfor system daemons and other privileged Android components. As more domains are\nswitched to enforcing mode and their policies are fine-tuned, unconfineddomain is\nexpected to be removed.\nApp Domains\nRecall that SEAndroid assigns several different domains to application pro-\ncesses based on their process UID or signing certificate. These application\ndomains are assigned common permissions by inheriting the base appdomain\nusing the app_domain() macro which, as defined in app.te, includes rules that\nallow the common operations all Android apps require. Listing 12-30 shows\nan excerpt from the app.te file.\n--snip--\nallow appdomain zygote:fd use;u\nallow appdomain zygote_tmpfs:file read;v\n--snip--\nallow appdomain system:fifo_file rw_file_perms;\nallow appdomain system:unix_stream_socket { read write setopt };\nbinder_call(appdomain, system)w\nallow appdomain surfaceflinger:unix_stream_socket { read write setopt };\nbinder_call(appdomain, surfaceflinger)x\nallow appdomain app_data_file:dir create_dir_perms;\nallow appdomain app_data_file:notdevfile_class_set create_file_perms;y\n--snip--\nListing 12-30: appdomain policy excerpt (from app .te)\nThis policy allows the appdomain to receive and use file descriptors from\nzygote u; read system properties managed by zygote v; communicate with\nthe system_server via pipes, local sockets, or Binder w; communicate with the\nsurfaceflinger daemon (responsible for drawing on screen) x; and create files\nand directories in its sandbox data directory y. The rest of the policy defines\nrules that allow other required permissions, such as network access, access\nto downloaded files, and Binder access to core system services. Operations\nSELinux 345\nthat apps do not typically require, such as raw block device access, kernel\nmemory access, and SELinux domain transitions, are explicitly prohibited\nusing neverallow rules.\nConcrete app domains such as untrusted_app (which is assigned to all\nnon-system applications according to the assignment rules in seapp_contexts\nshown in Listing 12-22) extend appdomain and add additional access rules, as\nrequired by the target application(s). Listing 12-31 shows an excerpt from\nuntrusted_app.te.\ntype untrusted_app, domain;\npermissive untrusted_app;u\napp_domain(untrusted_app)v\nnet_domain(untrusted_app)w\nbluetooth_domain(untrusted_app)x\nallow untrusted_app tun_device:chr_file rw_file_perms;y\nallow untrusted_app sdcard_internal:dir create_dir_perms;\nallow untrusted_app sdcard_internal:file create_file_perms;z\nallow untrusted_app sdcard_external:dir create_dir_perms;\nallow untrusted_app sdcard_external:file create_file_perms;{\nallow untrusted_app asec_apk_file:dir { getattr };\nallow untrusted_app asec_apk_file:file r_file_perms;|\n--snip--\nListing 12-31: untrusted_app domain policy excerpt (from untrusted_app .te)\nIn this policy file, the untrusted_app domain is set to permissive\nmode u, after which it inherits the policies of appdomain v, netdomain w,\nand bluetoothdomain x via the respective macros. The domain is then\nallowed access to tunnel devices (used for VPNs) y, external storage (SD\ncards, z and {), and encrypted application containers |. The rest of\nthe rules (not shown) grant access to sockets, pseudoterminals, and a\nfew other needed OS resources.\nAll other app domains (isolated_app, media_app, platform_app, release_app,\nand shared_app in version 4.4) also inherit from appdomain and add additional\nallow rules, either directly or by extending additional domains. In Android 4.4,\nall app domains are set to permissive mode.\nNOTE The SELinux policy in AOSP’s mater branch simplifies the app domain hierarchy by\nremoving the dedicated media_app, shared_app, and release_app domains and merg-\ning them into the untrusted_app domain. Additionally, only the system_app domain\nis unconfined.\n346 Chapter 12\nsummary\nAs of version 4.3, Android has integrated SELinux in order to reinforce the\ndefault sandbox model using the mandatory access control (MAC) available\nin the Linux kernel. Unlike the default discretionary access control (DAC),\nMAC offers a fine-grained object and permission model and a flexible secu-\nrity policy that cannot be overridden or changed by malicious processes (as\nlong as the kernel itself isn’t compromised).\nAndroid 4.4 is the first version to switch SELinux to enforcing mode\nin release builds, but all domains other than a few highly privileged core\ndaemons are set to permissive mode in order to maintain compatibility\nwith existing applications. Android’s base SELinux policy continues to be\nrefined with each release, and future releases will likely switch most domains\nto enforcing mode and remove the supporting unconfined domain, which\nis currently inherited by the majority of domains associated with privileged\nservices.\nSELinux 347",
    "question": "What is the role of SELinux in Android's security model and how does it differ from the traditional discretionary access control (DAC) approach?",
    "summary": "SELinux is a mandatory access control mechanism in Android that enhances the traditional discretionary access control (DAC) by enforcing a more granular security policy. It supports two forms of MAC: type enforcement (TE) and multi-level security (MLS), with TE being the primary method used in Android. SELinux operates in three modes: disabled, permissive, and enforcing, with Android using enforcing mode for most system daemons and permissive for others to maintain compatibility. The Android SELinux policy is designed to be flexible and secure, with domains and security contexts defined to restrict access to system resources and prevent privilege escalation. The policy is integrated into the Android source tree and includes various configuration files for labeling files, system properties, and app processes."
  },
  {
    "start": 204,
    "end": 204,
    "text": "13\nsYsTEm UPDaTEs\naND ROOT aCCE ss\nIn the preceding chapters, we introduced Android’s\nsecurity model and discussed how integrating SELinux\ninto Android has reinforced it. In this chapter, we take\na bit of a right turn and introduce methods that can\nbe used to circumvent Android’s security model.\nIn order to perform a full OS update or to restore the device to its\nfactory state, it’s necessary to escape the security sandbox and gain full\naccess to a device, because even the most privileged Android components\nare not given complete access to all system partitions and storage devices.\nAdditionally, while having full administrative (root) access at runtime is\nclearly against Android’s security design, executing with root privileges can\nbe useful in order to implement functionality not offered by Android, such\nas the addition of custom firewall rules or full (including system partitions)\ndevice backup. Indeed, the wide availability of custom Android builds (often\ncalled ROMs) and apps that allow users to extend or replace OS functionality\nusing root access (commonly known as root apps) has been one of the reasons\nfor Android’s success.\nIn this chapter, we explore the design of Android’s bootloader and\nrecovery OS, and show how they can be used to replace the system software",
    "question": "What methods are discussed in this chapter for bypassing Android’s security model to gain full system access?",
    "summary": "This chapter discusses methods to bypass Android's security model, which requires escaping the security sandbox to perform full system updates or factory resets. It also highlights the usefulness of root access for adding features not available in the standard Android environment. The chapter explores the design of Android's bootloader and recovery OS, explaining how they can be used to replace system software."
  },
  {
    "start": 205,
    "end": 214,
    "text": "of a device. We then show how root access is implemented on engineering\nbuilds and how Android production builds can be modified to allow execut-\ning code with superuser privileges by installing a “superuser” application.\nFinally, we discuss how custom Android distributions implement and con-\ntrol root access.\nBootloader\nA bootloader is a low-level program that is executed when a device is pow-\nered. Its main purpose is to initialize the hardware and find and start the\nmain operating system.\nAs briefly discussed in Chapter 10, Android bootloaders are usually\nlocked and only allow booting or installing an operating system image that\nhas been signed by the device manufacturer. This is an important step in\nestablishing a verified boot path, because it ensures that only trusted and\nunmodified system software can be installed on a device. However, while\nmost users are not interested in modifying the core OS of their devices,\ninstalling a third-party Android build is a valid user choice and may even\nbe the only way to run a recent version of Android on devices that have\nstopped receiving OS updates from their manufacturer. That is why most\nrecent devices provide a way to unlock the bootloader and install third-\nparty Android builds.\nNOTE While Android bootloaders are typically closed source, the bootloaders of most ARM\ndevices based on Qualcomm SoCs are derived from the Little Kernel (LK) bootloader,1\nwhich is open source.2\nIn the following sections, we’ll look at how to interact with Android\nbootloaders and how the bootloader can be unlocked on Nexus devices.\nWe then describe the fastboot protocol used to update devices via the\nbootloader.\nUnlocking the Bootloader\nThe bootloaders of Nexus devices are unlocked by issuing the oem unlock\ncommand when the device is in fastboot mode (discussed in the next sec-\ntion). Therefore, in order to unlock a device, it must first be started in\nfastboot mode, either by issuing the adb reboot bootloader command (if the\ndevice already allows ADB access), or by pressing a special key combination\nwhile the device is booting. For example, holding down the Volume down,\nVolume up, and Power buttons simultaneously on a powered-down Nexus 5\ninterrupts the normal boot process and brings up the fastboot screen\nshown in Figure 13-1.\n1. Code Aurora Forum, “(L)ittle (K)ernel based Android bootloader,” https://www.codeaurora.org/\nblogs/little-kernel-based-android-bootloader/\n2. Code Aurora Forum, https://www.codeaurora.org/cgit/quic/la/kernel/lk/\n350 Chapter 13\nThe bootloader has a simple UI that can be driven by the Volume\nup/down and Power buttons. It allows users to continue the boot process,\nrestart the device in fastboot or recovery mode, and power down the device.\nConnecting the device to a host machine via a USB cable allows addi-\ntional commands to be sent to the device using the fastboot command-line\ntool (part of the Android SDK). Issuing the fastboot oem unlock command\nbrings up the confirmation screen shown in Figure 13-2.\nFigure 13-1: Nexus 5 bootloader Figure 13-2: Nexus 5 bootloader\nscreen unlock screen\nThe confirmation screen warns that unlocking the bootloader allows\ninstallation of untested third-party OS builds and clears all user data.\nBecause a third-party OS build might not follow Android’s security model\nand might allow unrestricted access to data, clearing all user data is an\nimportant security measure; it ensures that existing user data cannot be\nextracted after the bootloader is unlocked.\nThe bootloader can be locked again by issuing the fastboot oem lock\ncommand. Relocking the bootloader returns it to its original state, and\nloading or booting third-party OS images is no longer possible. However,\nbesides a locked/unlocked flag, some bootloaders keep an additional, “tam-\npered” flag that is set when the bootloader is first unlocked. This flag allows\nthe bootloader to detect if it has ever been locked and disallow some opera-\ntions or show a warning even if it is in a locked state.\nSystem Updates and Root Access 351\nFastboot Mode\nWhile the fastboot command and protocol can be used to unlock the boot-\nloader, their original purpose was to make it easy to clear or overwrite\ndevice partitions by sending partition images to the bootloader, which\nare then written to the specified block device. This is particularly useful\nwhen porting Android to a new device (referred to as “device bring-up”)\nor restoring a device to factory state using partition images provided by the\ndevice manufacturer.\nAndroid Partition Layout\nAndroid devices typically have several partitions, which fastboot refers to by\nname (rather than by the corresponding Linux device file). A list of parti-\ntions and their names can be obtained by listing the files in the by-name/\ndirectory corresponding to the device’s SoC in /dev/block/platform/. For\nexample, because the Nexus 5 is based on Qualcomm SoC, which includes\na Mobile Station Modem (MSM) baseband processor, the corresponding\ndirectory is called msm_sdcc.1/ as shown in Listing 13-1 (timestamps omitted).\n# ls -l /dev/block/platform/msm_sdcc.1/by-name\nlrwxrwxrwx root root DDR -> /dev/block/mmcblk0p24\nlrwxrwxrwx root root aboot -> /dev/block/mmcblk0p6u\nlrwxrwxrwx root root abootb -> /dev/block/mmcblk0p11\nlrwxrwxrwx root root boot -> /dev/block/mmcblk0p19v\nlrwxrwxrwx root root cache -> /dev/block/mmcblk0p27w\nlrwxrwxrwx root root crypto -> /dev/block/mmcblk0p26\nlrwxrwxrwx root root fsc -> /dev/block/mmcblk0p22\nlrwxrwxrwx root root fsg -> /dev/block/mmcblk0p21\nlrwxrwxrwx root root grow -> /dev/block/mmcblk0p29\nlrwxrwxrwx root root imgdata -> /dev/block/mmcblk0p17\nlrwxrwxrwx root root laf -> /dev/block/mmcblk0p18\nlrwxrwxrwx root root metadata -> /dev/block/mmcblk0p14\nlrwxrwxrwx root root misc -> /dev/block/mmcblk0p15x\nlrwxrwxrwx root root modem -> /dev/block/mmcblk0p1y\nlrwxrwxrwx root root modemst1 -> /dev/block/mmcblk0p12\nlrwxrwxrwx root root modemst2 -> /dev/block/mmcblk0p13\nlrwxrwxrwx root root pad -> /dev/block/mmcblk0p7\nlrwxrwxrwx root root persist -> /dev/block/mmcblk0p16\nlrwxrwxrwx root root recovery -> /dev/block/mmcblk0p20z\nlrwxrwxrwx root root rpm -> /dev/block/mmcblk0p3\nlrwxrwxrwx root root rpmb -> /dev/block/mmcblk0p10\nlrwxrwxrwx root root sbl1 -> /dev/block/mmcblk0p2{\nlrwxrwxrwx root root sbl1b -> /dev/block/mmcblk0p8\nlrwxrwxrwx root root sdi -> /dev/block/mmcblk0p5\nlrwxrwxrwx root root ssd -> /dev/block/mmcblk0p23\nlrwxrwxrwx root root system -> /dev/block/mmcblk0p25|\nlrwxrwxrwx root root tz -> /dev/block/mmcblk0p4\nlrwxrwxrwx root root tzb -> /dev/block/mmcblk0p9\nlrwxrwxrwx root root userdata -> /dev/block/mmcblk0p28}\nListing 13-1: List of partitions on a Nexus 5\n352 Chapter 13\nAs you can see, the Nexus 5 has 29 partitions, most of which store\ndevice-specific and proprietary data, such as the Android bootloader in\naboot u, the baseband software in modem y, and the second stage bootloader\nin sbl1 {. The Android OS is hosted in the boot v partition, which stores\nthe kernel and the rootfs RAM disk image, and the system partition |, which\nstores all other system files. User files are stored in the userdata partition },\nand temporary files, such as downloaded OTA images and recovery OS com-\nmands and logs, are stored in the cache partition w. Finally, the recovery OS\nimage resides in the recovery partition z.\nThe Fastboot Protocol\nThe fastboot protocol works over USB and is driven by the host. That is,\ncommunication is initiated by the host, which uses USB bulk transfers to\nsend text-based commands and data to the bootloader. The USB client (boot-\nloader) responds with a status string such as OKAY or FAIL; an information\nmessage starting with INFO; or DATA, which signifies that the bootloader\nis ready to accept data from the host. When all data is received, the boot-\nloader responds with one of the OKAY, FAIL, or INFO messages describing\nthe final status of the command.\nFastboot Commands\nThe fastboot command-line utility implements the fastboot protocol, and\nallows you to get a list of connected devices that support fastboot (using\nthe devices command), obtain information about the bootloader (with the\ngetvar command), reboot the device in various modes (with continue, reboot,\nreboot-bootloader), and erase or format a partition.\nThe fastboot command supports various ways to write a disk image to a\npartition. A single named partition can be flashed using the flash partition\nimage-filename command, and multiple partition images contained in a ZIP\nfile can be flashed at once using the update ZIP-filename command.\nThe flashall command automatically flashes the contents of the boot.img,\nsystem.img, and recovery.img files in its working directory to the boot, system,\nand recovery partitions of the device, respectively. Finally, the flash:raw boot\nkernel ramdisk command automatically creates a boot image from the speci-\nfied kernel and RAM disk and flashes it to the boot partition. In addition\nto flashing partition images, fastboot can also be used to boot an image\nwithout writing it to the device when invoked with the boot boot-image or\nboot kernel ramdisk commands.\nCommands that modify device partitions, such as the various flash vari-\nations, and commands that boot custom kernels, such as the boot command,\nare not allowed when the bootloader is locked.\nSystem Updates and Root Access 353\nListing 13-2 shows an example fastboot session.\n$ fastboot devicesu\n004fcac161ca52c5 fastboot\n$ fastboot getvar version-bootloaderv\nversion-bootloader: MAKOZ10o\nfinished. total time: 0.001s\n$ fastboot getvar version-basebandw\nversion-baseband: M9615A-CEFWMAZM-2.0.1700.98\nfinished. total time: 0.001s\n$ fastboot boot custom-recovery.imgx\ndownloading 'boot.img'...\nOKAY [ 0.577s]\nbooting...\nFAILED (remote: not supported in locked device)\nfinished. total time: 0.579s\nListing 13-2: Example fastboot session\nHere, the first command u lists the serial numbers of devices con-\nnected to the host, which are currently in fastboot mode. The commands\nat v and w obtain the bootloader and baseband version strings, respectively.\nFinally, the command at x tries to boot a custom recovery image but fails\nbecause the bootloader is currently locked.\nRecovery\nThe recovery OS—also called recovery console or simply, recovery—is a minimal\nOS that is used for tasks that cannot be executed directly from Android, such\nas factory reset (erasing the userdata partition) or applying OTA updates.\nLike the bootloader’s fastboot mode, the recovery OS can be started\neither by pressing a specific key combination while the device boots, or via\nADB by using the adb reboot recovery command. Some bootloaders also pro-\nvide a menu interface (see Figure 13-1) that can be used to start the recov-\nery. In the following sections, we take a look at the “stock” Android recovery\nthat ships with Nexus devices and is included in AOSP, and then introduce\ncustom recoveries, which offer much richer functionality but require an\nunlocked bootloader in order to be installed or booted.\nStock Recovery\nAndroid’s stock recovery implements the minimal functionality needed to\nsatisfy the “Updatable Software” section of the Android Compatibility Definition\nDocument (CDD), which requires that “device implementations MUST include\na mechanism to replace the entirety of the system software…” and that “the\nupdate mechanism used MUST support updates without wiping user data.”3\n3. Google, Android Compatibility Definition, https://static.googleusercontent.com/media/\nsource.android.com/en//compatibility/android-cdd.pdf\n354 Chapter 13\nThat said, the CDD doesn’t specify the concrete update mechanism that\nshould be used, so different approaches to system updates are possible and\nthe stock recovery implements both OTA updates and tethered updates. For\nOTA updates, the main OS downloads the update file and then instructs the\nrecovery to apply it. In the case of tethered updates, users download the\nupdate package on their PC and push it to the recovery using the adb sideload\notafile.zip command. The actual update process for both approaches is the\nsame; only the method of obtaining the OTA package differs.\nThe stock recovery has a simple menu interface (shown in Figure 13-3)\nthat is operated using the device’s hardware buttons, usually the Power but-\nton and Volume up/down. However, the menu is hidden by default and\nneeds to be activated by pressing a dedicated key combination. On Nexus\ndevices, the recovery menu can usually be displayed by holding down the\nPower and Volume down buttons simultaneously for a few seconds.\nThe system recovery menu has four options: reboot, apply update from\nADB, factory reset, and wipe cache partition. The apply update from ADB option\nstarts the ADB server on the device and enables the tethered update (side-\nload) mode. However, as you can see, there is no option for applying an OTA\nupdate because once the user chooses to apply an OTA update from the\nmain OS (see Figure 13-4), it is applied automatically, without further user\ninteraction. Android accomplishes this by sending control commands to the\nrecovery, which are automatically executed when the recovery starts. (We dis-\ncuss the mechanisms used to control the recovery in the next section.)\nFigure 13-3: Stock recovery menu\nFigure 13-4: Applying a system update\nfrom the main OS\nSystem Updates and Root Access 355\nControlling the Recovery\nThe main OS controls the recovery via the android.os.RecoverySystem API,\nwhich communicates with the recovery by writing option strings, each on a\nnew line, to the /cache/recovery/command file. The contents of the command\nfile are read by the recovery binary (located at /sbin/recovery in the recovery\nOS), which is automatically started from init.rc when the recovery boots.\nThe options modify the behavior of the recovery binary and cause it to wipe\nthe specified partition, apply an OTA update, or simply reboot. Table 13-1\nshows the options supported by the stock recovery binary.\nTable 13-1: Options for the Stock recovery Binary\nrecovery Option Description\n--send_intent=<string> Save and communicate the specified intent\naction back to the main OS when finished\n--update_package=<OTA package path> Verify and install the specified OTA package\n--wipe_data Erase the userdata and cache partitions,\nthen reboot\n--wipe_cache Erase the cache partition, then reboot\n--show_text Message to display\n--just_exit Exit and reboot\n--locale Locale to use for recovery messages and UI\n--stages Set the current stage of the recovery process\nIn order to ensure that the specified command(s) are always com-\npleted, the recovery binary copies its arguments to the bootloader control\nblock (BCB), which is hosted on the misc partition (x in Listing 13-1). The\nBCB is used to communicate the current state of the recovery process to\nthe bootloader. The format of the BCB is specified in the bootloader_message\nstructure, shown in Listing 13-3.\nstruct bootloader_message {\nchar command[32];u\nchar status[32];v\nchar recovery[768];w\nchar stage[32];x\nchar reserved[224];y\n};\nListing 13-3: BCB format structure definition\nIf a device is rebooted or powered down in the middle of the recovery\nprocess, the next time it is started the bootloader inspects the BCB and\nstarts the recovery again if the BCB contains the boot-recovery command. If\nthe recovery process completes successfully, the recovery binary clears the\nBCB before exiting (sets all bytes to zero), and on the next reboot the boot-\nloader starts the main Android OS.\n356 Chapter 13\nIn Listing 13-3, the command at u is the command to the bootloader\n(usually boot-recovery); v is a status file written by the bootloader after per-\nforming a platform-specific action; w contains the options for the recovery\nbinary (--update_package, --wipe-data, and so on); and x is a string describ-\ning the install stage of OTA packages that require multiple restarts, for\nexample 2/3 if the installation requires three reboots. The last field y is\nreserved and not used as of this writing.\nSideloading an OTA Package\nBesides being downloaded by the main OS, an OTA package can be directly\npassed to the recovery from a host PC. In order to enable this update mode,\nthe user must choose the apply update from ADB option from the recovery\nmenu first. This starts a trimmed down version of the standard ADB dae-\nmon, which supports only the sideload command. Executing adb sideload\nOTA-package-file on the host transfers the OTA file to /tmp/update.zip on the\ndevice and installs it (see “Applying the Update” on page 359).\nOTA Signature Verification\nAs we learned in Chapter 3, OTA packages are code signed, with the signa-\nture applied over the whole file (unlike JAR and APK files, which include\na separate signature for each file in the archive). When the OTA process\nis started from the main Android OS, the OTA package (ZIP file) is first\nverified using the verifyPackage() method of the RecoverySystem class. This\nmethod receives both the path to the OTA package and a ZIP file con-\ntaining a list of X.509 certificates that are allowed to sign OTA updates as\nparameters. If the OTA package is signed with the private key correspond-\ning to any of the certificates in the ZIP file, the OTA is considered valid and\nthe system reboots into recovery in order to apply it. If no certificate ZIP file\nis specified, the system default, /system/etc/security/otacerts.zip, is used.\nThe recovery verifies the OTA package that it is instructed to apply\nindependently of the main OS in order to ensure that the OTA package\nhas not been replaced before starting the recovery. The verification is per-\nformed with a set of public keys built into the recovery image. When build-\ning the recovery, these keys are extracted from the specified set of OTA\nsigning certificates, converted to mincrypt format using the DumpPublicKey\ntool, and written to the /res/keys file. When RSA is used as the signature\nalgorithm, the keys are mincrypt’s RSAPublicKey structures, serialized as C\nliterals (as they would appear in a C source file), optionally preceded by a\nversion identifier that specifies the hash used when signing the OTA pack-\nage and the RSA key public exponent of the key. The keys file may look like\nListing 13-4.\n{64,0xc926ad21,{1795090719,...,3599964420},{3437017481,...,1175080310}},u\nv2 {64,0x8d5069fb,{393856717,...,2415439245},{197742251,...,1715989778}},v\n--snip--\nListing 13-4: Contents of the /res/keys file in the recovery OS\nSystem Updates and Root Access 357\nHere, the first line u is a serialized version 1 key (implicit if a version\nidentifier is not specified), which has a public exponent e=3 and can be\nused to verify signatures created using SHA-1; the second line v contains a\nversion 2 key that has a public exponent e=65537 and is also used with SHA-1\nsignatures. The currently supported signature algorithms are 2048-bit RSA\nwith SHA-1 (key versions 1 and 2) or SHA-256 (key versions 3 and 4), and\nECDSA with SHA-256 (key version 5, available in AOSP’s mater branch)\nand 256-bit EC keys using the NIST P-256 curve.\nStarting the System Update Process\nIf the signature of the OTA package verifies, the recovery applies the sys-\ntem update by executing the update command included in the OTA file.\nThe update command is saved in the META-INF/com/google/android/ direc-\ntory of the recovery image as update-binary u, as shown in Listing 13-5.\n.\n|-- META-INF/\n| |-- CERT.RSA\n| |-- CERT.SF\n| |-- com/\n| | |-- android/\n| | | |-- metadata\n| | | `-- otacert\n| | `-- google/\n| | `-- android/\n| | |-- update-binaryu\n| | `-- updater-scriptv\n| `-- MANIFEST.MF\n|-- patch/\n| |-- boot.img.p\n| `-- system/\n|-- radio.img.p\n|-- recovery/\n| |-- etc/\n| | `-- install-recovery.sh\n| `-- recovery-from-boot.p\n`-- system/\n|-- etc/\n| |-- permissions/\n| | `-- com.google.android.ble.xml\n| `-- security/\n| `-- cacerts/\n|-- framework/\n`-- lib/\nListing 13-5: Contents of a system update OTA package\nThe recovery extracts update-binary from the OTA file to /tmp/update_binary\nand starts it, passing it three parameters: the recovery API version (version 3 as\nof this writing); the file descriptor of a pipe that update-binary uses to com-\nmunicate progress and messages back to the recovery; and the path to the\nOTA package. The update-binary process in turn extracts the updater script,\n358 Chapter 13\nincluded as META-INF/com/google/android/updater-script v in the OTA pack-\nage, and evaluates it. The updater script is written in a dedicated scripting\nlanguage called edify (since version 1.6; previous versions used an older vari-\nant called amend). The edify language supports simple control structures\nsuch as if and else, and is extensible via functions, which can also act as\ncontrol structures (by deciding which of their arguments to evaluate). The\nupdater script includes a sequence of function calls that trigger the opera-\ntions necessary to apply the update.\nApplying the Update\nThe edify implementation defines and registers various functions that are\nused for copying, deleting, and patching files; formatting and mounting\nvolumes; setting file permissions and SELinux labels; and more. Table 13-2\nshows a summary of the most often used edify functions.\nTable 13-2: Summary of Important edify Functions\nFunction Name Description\nabort Aborts the install process with an error message .\napply_patch Safely applies a binary patch . Ensures that the\npatched file has the expected hash value, before\nreplacing the original . Can also patch disk\npartitions .\napply_patch_check Checks if a file has the specified hash value .\nassert Checks if a condition is true .\ndelete/delete_recursive Deletes a file/all files in a directory .\nfile_getprop Gets a system property from the specified\nproperty file .\nformat Formats a volume with the specified filesystem .\ngetprop Gets a system property .\nmount Mounts a volume at the specified path .\npackage_extract_dir Extracts the specified ZIP directory to a path on\nthe filesystem .\npackage_extract_file Extracts the specified ZIP file to a path on the\nfilesystem or returns it as a blob .\nrun_program Executes the specified program in a subprocess\nand waits for it to finish .\nset_metadata/set_metadata_recursive Sets the owner, group, permission bits, file\ncapabilities, and SELinux label on file/all files\nin a directory .\nshow_progress Reports back progress to the parent process .\nsymlink Creates a symbolic link(s) to a target, deleting\nexisting symbolic link files first .\nui_print Sends a message back to the parent process .\numount Unmounts a mounted volume .\nwrite_raw_image Writes a raw image to the specified disk partition .\nSystem Updates and Root Access 359\nListing 13-6 shows the (abbreviated) contents of a typical system update\nedify script.\nmount(\"ext4\", \"EMMC\", \"/dev/block/platform/msm_sdcc.1/by-name/system\", \"/system\");\nfile_getprop(\"/system/build.prop\", \"ro.build.fingerprint\") == \"google/...:user/release-keys\" ||\nfile_getprop(\"/system/build.prop\", \"ro.build.fingerprint\") == \"google/...:user/release-keys\" ||\nabort(\"Package expects build fingerprint of google/...:user/release-keys; this device has \" +\ngetprop(\"ro.build.fingerprint\") + \".\");\ngetprop(\"ro.product.device\") == \"hammerhead\" ||\nabort(\"This package is for \\\"hammerhead\\\" devices; this is a \\\"\" +\ngetprop(\"ro.product.device\") + \"\\\".\");u\n--snip--\napply_patch_check(\"/system/app/BasicDreams.apk\", \"f687...\", \"fdc5...\") ||\nabort(\"\\\"/system/app/BasicDreams.apk\\\" has unexpected contents.\");v\nset_progress(0.000063);\n--snip--\napply_patch_check(\"EMMC:/dev/block/platform/msm_sdcc.1/by-name/boot:8835072:21...:8908800:a3...\")\n|| abort(\"\\\"EMMC:/dev/block/...\\\" has unexpected contents.\");w\n--snip--\nui_print(\"Removing unneeded files...\");\ndelete(\"/system/etc/permissions/com.google.android.ble.xml\",\n--snip--\n\"/system/recovery.img\");x\nui_print(\"Patching system files...\");\napply_patch(\"/system/app/BasicDreams.apk\", \"-\",\nf69d..., 32445,\nfdc5..., package_extract_file(\"patch/system/app/BasicDreams.apk.p\"));y\n--snip--\nui_print(\"Patching boot image...\");\napply_patch(\"EMMC:/dev/block/platform/msm_sdcc.1/by-name/boot:8835072:2109...:8908800:a3bd...\",\n\"-\", a3bd..., 8908800,\n2109..., package_extract_file(\"patch/boot.img.p\"));z\n--snip--\ndelete(\"/system/recovery-from-boot.p\",\n\"/system/etc/install-recovery.sh\");\nui_print(\"Unpacking new recovery...\");\npackage_extract_dir(\"recovery\", \"/system\");{\nui_print(\"Symlinks and permissions...\");\nset_metadata_recursive(\"/system\", \"uid\", 0, \"gid\", 0, \"dmode\", 0755, \"fmode\", 0644,\n\"capabilities\", 0x0, \"selabel\", \"u:object_r:system_file:s0\");|\n--snip--\nui_print(\"Patching radio...\");\napply_patch(\"EMMC:/dev/block/platform/msm_sdcc.1/by-name/modem:43058688:7493...:46499328:52a...\",\n\"-\", 52a5..., 46499328,\n7493..., package_extract_file(\"radio.img.p\"));}\n--snip--\nunmount(\"/system\");~\nListing 13-6: Contents of updater-script in a full system update OTA package\n360 Chapter 13\nCopying and Patching Files\nThe updater script first mounts the system partition, then checks to see if\nthe device model and its current build are what it expects u. This check\nis required because trying to install a system update over an incompatible\nbuild can leave a device in an unusable state. (This is often called a “soft\nbrick,” because it can usually be recovered by reflashing all partitions with\na working build; a “hard brick” cannot be recovered.)\nBecause an OTA update usually does not contain complete system files,\nonly binary patches against the previous version of each changed file (pro-\nduced using bsdiff),4 applying an update can succeed only if each file-to-\nbe-patched is the same as the one used to produce the respective patch. To\nensure this, the updater script checks that the hash value of each file-to-be-\npatched is one it expects using the apply_patch_check function v.\nIn addition to system files, the update process also patches partitions\nthat don’t contain a filesystem, such as the boot and modem partitions. To\nguarantee that patching such partitions will succeed, the updater script\nchecks the contents of target partitions as well and aborts if they are not in\nthe expected state w. When all system files and partitions have been veri-\nfied, the updater script deletes unnecessary files, as well as files that will be\nreplaced completely instead of being patched x. The script then goes on\nto patch all system files y and partitions z. It then removes any previous\nrecovery patches and unpacks the new recovery in /system/ {.\nSetting File Ownership, Permissions, and Security Labels\nThe next step is to set the user, owner, permissions, and file capabilities of\nall created or patched files and directories using the set_metadata_recursive\nfunction |. As of version 4.3, Android supports SELinux (see Chapter 12),\nso all files must be properly labeled in order for access rules to be effective.\nThat is why the set_metadata_recursive function has been extended to set the\nSELinux security label (the last parameter, u:object_r:system_file:s0 in |) of\nfiles and directories.\nFinishing the Update\nNext, the updater script patches the device’s baseband software }, which\nis typically stored in the modem partition. The final step of the script is to\nunmount the system partition ~.\nAfter the update-binary process exits, the recovery wipes the cache parti-\ntion if it was started with the –wipe_cache option and copies the execution\nlogs to /cache/recovery/ so that they are accessible from the main OS. Finally,\nif no errors are reported, the recovery clears the BCB and reboots into the\nmain OS.\n4. Colin Percival, “Binary diff/patch utility,” http://www.daemonology.net/bsdiff/\nSystem Updates and Root Access 361\nIf the update process is aborted due to an error, the recovery reports\nthis to the user, and prompts them to reboot the device in order to try\nagain. Because the BCB has not been cleared, the device automatically\nreboots in recovery mode, and the update process is started from scratch.\nUpdating the Recovery\nIf you examine the entire updater script in Listing 13-6 in detail, you’ll\nnotice that while it patches the boot z and modem } partitions and unpacks\na patch for the recovery partition { (which hosts the recovery OS), it does\nnot apply the unpacked patch. This is by design. Because an update can\nbe interrupted at any moment, the update process needs to be restarted\nfrom the same state the next time the device is powered on. If, for example,\npower is interrupted while writing to the recovery partition, updating the\nrecovery OS would change that initial state and might leave the system in an\nunusable condition. Therefore, the recovery OS is updated from the main\nOS only when the main OS update has completed and the main OS boots\nsuccessfully.\nThe update is triggered by the flash_recovery service in Android’s init.rc\nfile, as shown in Listing 13-7.\n--snip--\nservice flash_recovery /system/etc/install-recovery.shu\nclass main\noneshot\n--snip--\nListing 13-7: Definition of the flash_recovery service in init .rc\nAs you can see, this service simply starts the /system/etc/install-recovery.sh\nshell script u. The shell script, along with a patch file for the recovery parti-\ntion, is copied by the OTA updater script ({ in Listing 13-6) if the recov-\nery requires an update. The contents of install-recovery.sh might look like\nListing 13-8.\n#!/system/bin/sh\nif ! applypatch -c EMMC:/dev/block/platform/msm_sdcc.1/by-name/recovery:9506816:3e90...; thenu\nlog -t recovery \"Installing new recovery image\"\napplypatch -b /system/etc/recovery-resource.dat \\\nEMMC:/dev/block/platform/msm_sdcc.1/by-name/boot:8908800:a3bd... \\\nEMMC:/dev/block/platform/msm_sdcc.1/by-name/recovery \\\n3e90... 9506816 a3bd...:/system/recovery-from-boot.pv\nelse\nlog -t recovery \"Recovery image already installed\"w\nfi\nListing 13-8: Contents of install-recovery .sh\nThe script uses the applypatch command to check whether the recovery OS\nneeds to be patched by checking the hash value of the recovery partition u.\nIf the hash of the device’s recovery partition matches the hash of the version\n362 Chapter 13\nagainst which the patch was created, the script applies the patch v. If the\nrecovery has already been updated or has an unknown hash, the script logs\na message and exits w.\nCustom Recoveries\nA custom recovery is a recovery OS build created by a third party (not\nthe device manufacturer). Because it is created by a third party, a cus-\ntom recovery is not signed with the manufacturer’s keys, and therefore\na device’s bootloader needs to be unlocked in order to boot or flash it.\nA custom recovery can be booted without installing it on the device with\nthe fastboot boot custom-recovery.img command, or it may be permanently\nflashed using the fastboot flash recovery custom-recovery.img command.\nA custom recovery provides advanced functionality that is typically not\navailable in stock recoveries, such as full partition backup and restore, a\nroot shell with a full set of device management utilities, support for mount-\ning external USB devices, and so on. A custom recovery can also disable\nOTA package signature checking, which allows for installing third-party OS\nbuilds or modification, such as framework or theme customizations.\nVarious custom recoveries are\navailable, but as of this writing, by\nfar the most full-featured and actively\nmaintained is the Team Win Recovery\nProject (TWRP).5 It is based on the\nAOSP stock recovery and is also an\nopen source project.6 TWRP has a\ntheme-able, touch screen interface\nthat is very similar to the native\nAndroid UI. It supports encrypted\npartition backups, installing system\nupdates from USB devices, and backup\nand restore to/from external devices,\nand it has an integrated file manager.\nThe startup screen of TWRP ver-\nsion 2.7 is shown in Figure 13-5.\nLike the stock AOSP recovery,\ncustom recoveries can be controlled\nfrom the main OS. In addition to pass-\ning parameters via the /cache/recovery/\ncommand file, custom recoveries usually\nallow some (or all) of their extended\nfeatures to be triggered from the main\nOS. For example, TWRP supports a Figure 13-5: TWRP recovery startup\nminimal scripting language, which screen\n5. TeamWin, “TWRP 2.7,” http://teamw.in/project/twrp2/\n6. TeamWin, “Team Win Recovery Project (TWRP),” https://github.com/TeamWin/\nTeam-Win-Recovery-Project/\nSystem Updates and Root Access 363\ndescribes what recovery actions should be executed upon booting the recov-\nery. This allows Android apps to queue recovery commands via a convenient\nGUI interface. For example, requesting a compressed backup of the boot,\nuserdata, and system partitions generates the script shown in Listing 13-9.\n# cat /cache/recovery/openrecoveryscript\nbackup DSBOM 2014-12-14--01-54-59\nListing 13-9: TWRP backup script example\nwaRNING Permanently flashing a custom recovery that has an option to ignore OTA package\nsignatures might allow the system software of your device to be replaced and back-\ndoored given brief physical access to the devices. Therefore, it is not recommended to\nflash a custom recovery on a device you use daily and which stores personal or sensi-\ntive information.\nRoot access\nAndroid’s security model applies the principle of least privilege and strives\nto isolate system and app processes from each other by running each pro-\ncess as a dedicated user. However, Android is also based on a Linux kernel,\nwhich implements a standard Unix-style DAC (unless SELinux is enabled;\nsee Chapter 12).\nOne of the greatest shortcomings of this DAC security model is that a\ncertain system user, typically called root (UID=0), also known as the superuser,\nis given absolute power over the system. Root can read, write, and change\nthe permission bits of any file or directory; kill any process; mount and\nunmount volumes; and so on. While such unconstrained permissions are\nnecessary for managing a traditional Linux system, having superuser access\non an Android device allows one to effectively bypass Android’s sandbox,\nand read or write the private files of any application.\nRoot access also allows changing the system configuration by modifying\npartitions that are designed to be read-only, starting or stopping system ser-\nvices at will, and removing or disabling core system applications. This can\nadversely affect the stability of a device, or even render it unusable, which is\nwhy root access is typically not allowed on production devices.\nFurthermore, Android tries to limit the number of system processes that\nexecute as root, because a programming error in any such process can open\nthe doors to privilege escalation attacks, which could result in third-party\napplications gaining root access. With the deployment of SELinux in enforc-\ning mode, processes are limited by the global security policy, and therefore\ncompromising a root process does not necessarily grant unrestricted access\nto a device but could still allow access to sensitive data or allow modifying\nsystem behavior. Additionally, even a process constrained by SELinux could\nexploit a kernel vulnerability in order to circumvent the security policy or\notherwise obtain unrestricted root access.\n364 Chapter 13\nWith all that said, root access could be very convenient for debugging\nor reverse engineering applications on development devices. Additionally,\nwhile allowing root access to third-party applications does compromise\nAndroid’s security model, it also allows various system customizations that\nare typically not available on production devices to be performed.\nBecause one of Android’s biggest selling points has always been its\nease of customization, the demand for ever greater flexibility via modifying\nthe core OS (also called modding), has always been high, especially during\nAndroid’s early years. Besides customizing the system, having root access on\nan Android device allows for the implementation of applications that are\nnot possible without modifying the framework and adding system services,\nsuch as firewalls, full device backup, network sharing, and so on.\nIn the following sections, we describe how root access is implemented\nin development (engineering) Android builds and custom Android builds\n(ROMs), and how it can be added to production builds. We then show how\napps that require superuser access (typically called root apps) can request\nand use root privileges in order to execute processes as root.\nRoot Access on Engineering Builds\nAndroid’s build system can produce several build variants for a particular\ndevice that differ by the number of applications and utilities included, as\nwell as by the values of several key system properties that modify system\nbehavior. Some of these build variants allow root access from the Android\nshell, as we’ll show in the following sections.\nStarting ADB as Root\nCommercial devices use the user build variant (the current build variant is\nset as the value of the ro.build.type system property), which doesn’t include\ndiagnostics and development tools, disables the ADB daemon by default,\ndisallows debugging of applications that don’t explicitly set the debuggable\nattribute to true in their manifests, and disallows root access via the shell.\nThe userdebug build variant is very close to user, but it also includes some\nadditional modules (those with the debug module tag), allows debugging of\nall apps, and enables ADB by default.\nEngineering, or eng, builds include most available modules, allow debug-\nging, enable ADB by default, and set the ro.secure system property to 0, which\nchanges the behavior of the ADB daemon running on a device. When set\nto 1 (secure mode), the adbd process, which initially runs as root, drops all\ncapabilities from its capability bounding set with the exception of CAP_SETUID\nand CAP_SETGID (which are required to implement the run-as utility). It then\nadds several supplementary GIDs that are required to access network inter-\nfaces, external storage, and system logs, and finally changes its UID and\nGID to AID_SHELL (UID=2000). On the other hand, when ro.secure is set to 0\n(the default for engineering builds), the adbd daemon continues to run as\nroot and has the full capability bounding set. Listing 13-10 shows the pro-\ncess IDs and capabilities for the adbd process on a user build.\nSystem Updates and Root Access 365\n$ getprop ro.build.type\nuser\n$ getprop ro.secure\n1\n$ ps|grep adb\nshell 200 1 4588 220 ffffffff 00000000 S /sbin/adbd\n$ cat /proc/200/status\nName: adbd\nState: S (sleeping)\nTgid: 200\nPid: 200\nPpid: 1\nTracerPid: 0\nUid: 2000 2000 2000 2000u\nGid: 2000 2000 2000 2000v\nFDSize: 32\nGroups: 1003 1004 1007 1011 1015 1028 3001 3002 3003 3006w\n--snip--\nCapInh: 0000000000000000\nCapPrm: 0000000000000000\nCapEff: 0000000000000000\nCapBnd: fffffff0000000c0x\n--snip--\nListing 13-10: adbd process details on a user build\nAs you can see, the process’s UID u and GID v are both set to 2000\n(AID_SHELL), and the adbd process has a number of supplementary GIDs\nadded w. Finally, the process’s capability bounding set, which determines\nwhat capabilities child processes are allowed, is set to 0x0000000c0\n(CAP_SETUID|CAP_SETGID) x. This capability setting guarantees that, on user\nbuilds, processes started from Android’s shell are limited to the CAP_SETUID\nand CAP_SETGID capabilities, even if the executed binary has the SUID bit set,\nor its file capabilities permit additional privileges.\nIn contrast, on an eng or userdebug build, the ADB daemon can execute\nas root, as shown in Listing 13-11.\n# getprop ro.build.type\nuserdebugu\n# getprop ro.secure\n1v\n# ps|grep adb\nroot 19979 1 4656 264 ffffffff 0001fd1c S /sbin/adbd\nroot@maguro:/ # cat /proc/19979/status\nName: adbd\nState: S (sleeping)\nTgid: 19979\nPid: 19979\nPpid: 1\nTracerPid: 0\nUid: 0 0 0 0w\nGid: 0 0 0 0x\nFDSize: 256\n366 Chapter 13\nGroups:y\n--snip--\nCapInh: 0000000000000000\nCapPrm: ffffffffffffffffz\nCapEff: ffffffffffffffff{\nCapBnd: ffffffffffffffff|\n--snip--\nListing 13-11: adbd process details on an eng build\nHere, the adbd process runs with UID w and GID x 0 (root), has no\nsupplementary groups y, and has the full set of Linux capabilities (z, {,\nand |). However, as you can see at v, the ro.secure system property is set to 1,\nwhich suggests that adbd should not be running as root.\nWhile the ADB daemon does drop its root privileges on userdebug builds\n(as in this example, u), it can be manually restarted in insecure mode by\nissuing the adb root command from a host, as shown in Listing 13-12.\n$ adb shell id\nuid=2000(shell) gid=2000(shell)u groups=1003(graphics),1004(input),1007\n(log),1009(mount),1011(adb),1015(sdcard_rw),1028(sdcard_r),3001(net_bt_\nadmin),3002(net_bt),3003(inet),3006(net_bw_stats) context=u:r:shell:s0\n$ adb rootv\nrestarting adbd as root\n$ adb shell ps|grep adb\nroot 2734 1 4644 216 ffffffff 0001fbec R /sbin/adbdw\n$ adb shell id\nuid=0(root) gid=0(root) context=u:r:shell:s0x\nListing 13-12: Restarting adbd as root on userdebug builds\nHere, the adbd daemon is initially running as shell (UID=2000), and\nany shells started from the host also have UID=2000 and GID=2000 u.\nIssuing the adb root command v (which internally sets the service.adb.root\nsystem property to 1) restarts the ADB daemon as root w, and any subse-\nquently started shells have UID and GUID=0 x.\nNOTE Because this particular device has SELinux enabled, even though the UID and GID\nof the shell change, its security context (security label) stays the same: u:r:shell:s0\nin both u and x. Therefore, even after obtaining a root shell via ADB, all processes\nstarted from the shell are still bound by the permissions granted to the shell domain\n(unless allowed to transition to another domain by the MAC policy; see Chapter 12\nfor details). In practice, as of Android 4.4, the shell domain is unconfined, so when\nrunning as root, processes in this domain are allowed almost full control over the device.\nUsing the su Command\nOn userdebug builds, root access can also be obtained without restarting\nADB as root. This can be accomplished using the su (short for substitute user,\nalso referred to as switch user and superuser) command, which is installed\nwith the SUID bit set, thus allowing calling processes to obtain a root\nSystem Updates and Root Access 367\nshell or execute a command as the specified UID (including UID=0). The\ndefault su implementation is very basic and only allows the root and shell\nusers to use it, as shown in Listing 13-13.\nint main(int argc, char **argv)\n{\n--snip--\nmyuid = getuid();\nif (myuid != AID_ROOT && myuid != AID_SHELL) {u\nfprintf(stderr,\"su: uid %d not allowed to su\\n\", myuid);\nreturn 1;\n}\nif(argc < 2) {\nuid = gid = 0;v\n} else {\n--snip--\n}\nif(setgid(gid) || setuid(uid)) {w\nfprintf(stderr,\"su: permission denied\\n\");\nreturn 1;\n}\n--snip--\nexeclp(\"/system/bin/sh\", \"sh\", NULL);x\nfprintf(stderr, \"su: exec failed\\n\");\nreturn 1;\n}\nListing 13-13: Default su implementation for userdebug builds\nThe main function first checks whether the calling UID is AID_ROOT (0)\nor AID_SHELL (2000) u, and exits if called by a user with a different UID. It\nthen sets the process UID and GID to 0 (v and w), and finally starts the\nAndroid shell x. Any commands executed from this shell inherit its privi-\nleges by default, thus allowing superuser access to the device.\nRoot access on Production Builds\nAs we learned in “Root Access on Engineering Builds” on page 365, com-\nmercial Android devices are usually based on the user build variant. This\nmeans that the ADB daemon is running as the shell user, and no su command\nis installed on the device.\nThis is a secure configuration, and most users should be able to achieve\ntheir device configuration and customization tasks with the tools provided\nby the platform, or with third-party applications such as custom launchers,\n368 Chapter 13\nkeyboards, or VPN clients. However, operations that modify the look and\nfeel or core configuration of Android are not possible, and neither is low-\nlevel access to the underlying Linux OS. Such operations can only be per-\nformed by running certain commands with root privileges, which is why\nmany power users seek to enable root access on their devices.\nObtaining root access on an Android device is commonly known as root-\ning and can be fairly simple on devices that have an unlockable bootloader\nor nearly impossible on devices that don’t allow bootloader unlocking and\ntake additional measures to prevent system partition modifications. In the\nnext sections, we describe the typical rooting process and introduce some\nof the most popular “superuser” apps that enable and manage root access.\nRooting by Changing the boot or system Image\nOn some Android devices, given an unlocked bootloader, a user build can\neasily be turned into an engineering or userdebug build by simply flashing a\nnew boot image (often called a kernel, or custom kernel), which changes the\nvalues of the ro.secure and ro.debuggable system properties. Changing these\nproperties allows the ADB daemon to execute as root and enables root\naccess via the Android shell, as described in“Root Access on Engineering\nBuilds” on page 365. However, most current Android user builds disable\nthis behavior at compile time (by not defining the ALLOW_ADBD_ROOT macro)\nand the values of the ro.secure and ro.debuggable system properties are\nignored by the adbd daemon.\nAnother way to enable root access is to unpack the system image, add\na SUID su binary or a similar utility, and overwrite the system partition with\nthe new system image. This would typically allow root access not only from\nthe shell, but from third-party applications as well. However, several secu-\nrity enhancements in Android 4.37 and later versions disallow apps from\nexecuting SUID programs by dropping all capabilities from the bounding\nset of Zygote-spawned processes, and mounting the system partition with the\nnosetuid flag.\nAdditionally, on Android versions that set SELinux to enforcing mode,\nexecuting a process with root privileges does not typically change its secu-\nrity context, and such a process is still limited by the MAC policy. For these\nreasons, enabling root access on a recent Android version may not be as\nsimple as changing a few system properties or copying a SUID binary to\nthe device. Of course, replacing the boot or system image allows SELinux to\nbe disabled and any security mitigation to be reverted, thus relaxing the\ndevice’s security level and enabling root access. However, such a radical\napproach is not unlike replacing the whole OS and may prevent the device\nfrom receiving system updates from the device manufacturer. This is unde-\nsirable in most cases, and several root methods that try to coexist with the\nstock OS of the device have been developed.\n7. Google, “Security Enhancements in Android 4.3,” http://source.android.com/devices/tech/\nsecurity/enhancements43.html\nSystem Updates and Root Access 369\nRooting by Flashing an OTA Package\nAn OTA package can add or modify system files, without replacing the\nwhole OS image, and is therefore a good candidate for adding root access\nto a device. Most popular superuser apps are distributed as a combination\nof an OTA package, which needs to be installed once, and a companion\nmanager application, which can be updated online.\nSuperSU\nWe’ll use the SuperSU OTA package8 and app9 (developed by Jorrit “Chainfire”\nJongma) to demonstrate how this approach works. SuperSU is currently the\nmost popular superuser application and is actively maintained, keeping in\nstep with the latest modifications to the Android platform. The SuperSU\nOTA package is similar in structure to a full system update package but\ncontains only a small number of files, as shown in Listing 13-14.\n.\n|-- arm/u\n| |-- chattr\n| |-- chattr.pie\n| `-- su\n|-- common/\n| |-- 99SuperSUDaemonv\n| |-- install-recovery.shw\n| `-- Superuser.apkx\n|-- META-INF/\n| |-- CERT.RSA\n| |-- CERT.SF\n| |-- com/\n| | `-- google/\n| | `-- android/\n| | |-- update-binaryy\n| | `-- updater-scriptz\n| `-- MANIFEST.MF\n`-- x86/{\n|-- chattr\n|-- chattr.pie\n`-- su\nListing 13-14: Contents of the SuperSU OTA package\nThe package contains a few native binaries compiled for the ARM u\nand x86 { platforms, scripts for starting and installing the SuperSU dae-\nmon (v and w), the APK file of the management GUI application x, and\ntwo updater scripts (y and z) that apply the OTA package.\nIn order to understand how SuperSU enables root access, we need to\nfirst examine its install process. To do so, let’s analyze the contents of the\n8. Jorrit “Chainfire” Jongma, “CF-Root download page,” http://download.chainfire.eu/supersu/\n9. Jorrit “Chainfire” Jongma, “Google Play Apps: SuperSU,” https://play.google.com/store/apps/\ndetails?id=eu.chainfire.supersu&hl=en\n370 Chapter 13\nupdate-binary script y, shown in Listing 13-15. (SuperSU uses a regular shell\nscript instead of a native binary, so updater-script is simply a placeholder.)\n#!/sbin/sh\n--snip--\nui_print \"- Mounting /system, /data and rootfs\"u\nmount /system\nmount /data\nmount -o rw,remount /system\n--snip--\nmount -o rw,remount /\n--snip--\nui_print \"- Extracting files\"v\ncd /tmp\nmkdir supersu\ncd supersu\nunzip -o \"$ZIP\"\n--snip--\nui_print \"- Placing files\"\nmkdir /system/bin/.ext\ncp $BIN/su /system/xbin/daemonsuw\ncp $BIN/su /system/xbin/su\n--snip--\ncp $COM/Superuser.apk /system/app/Superuser.apkx\ncp $COM/install-recovery.sh /system/etc/install-recovery.shy\ncp $COM/99SuperSUDaemon /system/etc/init.d/99SuperSUDaemon\necho 1 > /system/etc/.installed_su_daemon\n--snip--\nui_print \"- Setting permissions\"\nset_perm 0 0 0777 /system/bin/.extz\nset_perm 0 0 $SUMOD /system/bin/.ext/.su\nset_perm 0 0 $SUMOD /system/xbin/su\n--snip--\nset_perm 0 0 0755 /system/xbin/daemonsu\n--snip--\nch_con /system/bin/.ext/.su{\nch_con /system/xbin/su\n--snip--\nch_con /system/xbin/daemonsu\n--snip--\nui_print \"- Post-installation script\"\n/system/xbin/su --install|\nui_print \"- Unmounting /system and /data\"}\numount /system\numount /data\nui_print \"- Done !\"\nexit 0\nListing 13-15: SuperSU OTA install script\nSystem Updates and Root Access 371\nThe update script first mounts the rootfs filesystem and the system and\nuserdata partitions in read-write mode u, and then it extracts v and copies\nthe included files to their intended locations on the filesystem. The su and\ndaemonsu native binaries w are copied to /system/xbin/, which is the usual\nlocation of extra native binaries (binaries that are not necessary for run-\nning the Android OS). The root access management application is copied\nto /system/app/ x and is automatically installed by the package manager\nwhen the device reboots. Next, the update script copies the install-recovery.sh\nscript to /system/etc/ y.\nNOTE As discussed in “Updating the Recovery” on page 362, this script is typically used\nto update the recovery image from the main OS, so you might be wondering why the\nSuperSU install is trying to update the recovery of the device. SuperSU uses this script\nto start some of its components at boot time, which we’ll discuss shortly.\nThe next step of the OTA package install process is to set the per-\nmissions z and SELinux security labels { of the installed binaries\n(ch_con is a shell function that calls the chcon SELinux utility and sets the\nu:object_r:system_file:s0 label). Finally, the script calls the su command with\nthe --install option | in order to perform some post-install initialization,\nand then unmounts /system and /data }. When the script exits successfully,\nthe recovery reboots the device into the main Android OS.\nHow SuperSU Is Initialized\nTo understand how SuperSU is initialized, let’s look at the contents of the\ninstall-recovery.sh script (see Listing 13-16, with comments omitted), which is\nautomatically executed by init on boot.\n#!/system/bin/sh\n/system/xbin/daemonsu --auto-daemon &u\n/system/etc/install-recovery-2.shv\nListing 13-16: Contents of SuperSU’s install-recovery .sh script\nThe script first executes the daemonsu binary u, which starts a daemon\nprocess with root privileges. The next step executes the install-recovery-2.sh\nscript v, which may be used to perform additional initialization, necessary\nfor other root apps. Using a daemon in order to allow apps to execute code\nwith root privileges is required in Android 4.3 and later, because all apps\n(which are forked from zygote) have their capability bounding set zeroed\nout, thus preventing them from executing privileged operations, even if\nthey manage to start a process as root. Additionally, as of Android 4.4,\nSELinux is in enforcing mode, so any processes started by an application\ninherit its security context (typically untrusted_app), and therefore are sub-\nject to the same MAC restrictions as the app itself.\nSuperSU gets around these security restrictions by having apps use\nthe su binary to execute commands as root, which in turn pipes those\ncommands via a Unix domain socket to the daemonsu daemon, which\n372 Chapter 13\nultimately executes the received commands as root within the u:r:init:s0\nSELinux context. The processes in play are illustrated in Listing 13-17.\n$ ps -Z\nLABEL USER PID PPID NAME\nu:r:init:s0 root 1 0 /initu\n--snip--\nu:r:zygote:s0 root 187 1 zygotev\n--snip--\nu:r:init:s0 root 209 1 daemonsu:mount:masterw\nu:r:init:s0 root 210 209 daemonsu:masterx\n--snip--\nu:r:init:s0 root 3969 210 daemonsu:10292y\n--snip--\nu:r:untrusted_app:s0 u0_a292 13637 187 com.example.appz\nu:r:untrusted_app:s0 u0_a209 15256 187 eu.chainfire.supersu{\n--snip--\nu:r:untrusted_app:s0 u0_a292 16831 13637 su|\nu:r:init:s0 root 16835 3969 /system/bin/sleep}\nListing 13-17: Processes started when an app requests root access via SuperSU\nHere, the com.example.app app z (whose parent process is zygote v)\nrequests root access by passing a command to the su binary using its\n-c option. As you can see, the su process | executes as the same user\n(u0_a292, UID=10292) and in the same SELinux domain (untrusted_app)\nas the requesting app. However, the process } of the command the app\nrequested to be executed as root (sleep\nin this example) indeed executes as\nroot in the init SELinux domain (secu-\nrity context u:r:init:s0). If we trace its\nparent PID (PPID, in the fourth col-\numn), we find that the sleep process is\nstarted by the daemonsu:10292 pro-\ncess y, which is a daemonsu instance\ndedicated to our example app (with\nUID=10292). The daemonsu:10292\nprocess y inherits its init SELinux\ndomain from the daemonsu:master\ninstance x, which is in turn started by\nthe first daemonsu instance w. This is the\ninstance started via the install-recovery.sh\nscript (see Listing 13-16), and it runs\nwithin the domain of its parent—the init\nprocess u (PID=1).\nThe eu.chainfire.supersu process {\nbelongs to the SuperSU management\napplication, which shows the root access\ngrant dialog shown in Figure 13-6.\nFigure 13-6: SuperSU root access\nrequest grant dialog\nSystem Updates and Root Access 373\nSuperuser access can be granted one time only, for a certain period of\ntime, or permanently. SuperSU keeps an internal whitelist of apps that have\nbeen granted root access and does not show the grant dialog if the request-\ning app is already in the whitelist.\nNOTE SuperSU has a companion library, libsuperuser,10 which makes it easier to write\nroot apps by providing Java wrappers for the different patterns of calling the su binary.\nThe author of SuperSU also provides a comprehensive guide to writing root apps\ncalled How-To SU.11\nRoot Access on Custom ROMs\nCustom ROMs that provide root access don’t have to go through install-recovery\n.sh in order to start their superuser daemon (equivalent to SuperSU’s\ndaemonsu) because they can customize the startup process at will. For\nexample, the popular CyanogenMod open source Android distribution\nstarts its su daemon from init.superuser.rc, as shown in Listing 13-18.\nservice su_daemon /system/xbin/su --daemonu\noneshot\non property:persist.sys.root_access=0v\nstop su_daemon\non property:persist.sys.root_access=2w\nstop su_daemon\non property:persist.sys.root_access=1x\nstart su_daemon\non property:persist.sys.root_access=3y\nstart su_daemon\nListing 13-18: Startup script for the su daemon in CyanogenMod\nThis init script defines the su_daemon service u, which can be started\nor stopped by changing the value of the persist.sys.root_access persistent system\nproperty (v through y). The value of this property also determines whether\nroot access should be granted only to apps, ADB shells, or both. Root access is\ndisabled by default and can be configured via CyanogenMod’s Development\noptions, as shown in Figure 13-7.\nwaRNING While SuperSU and custom ROMs that allow root access take certain measures to\nregulate what apps are allowed to execute commands as root (usually by adding them\nto a whitelist), an implementation flaw could allow apps to bypass these measures and\nobtain root access without user confirmation. Therefore, root access should be disabled\non everyday-use devices and used only when necessary for development or debugging.\n10. Jorrit “Chainfire” Jongma, libsuperuser, https://github.com/Chainfire/libsuperuser/\n11. Jorrit “Chainfire” Jongma, “How-To SU Guidelines for problem-free su usage,” http://\nsu.chainfire.eu/\n374 Chapter 13\nFigure 13-7: CyanogenMod root access\noptions\nRooting via Exploits\nOn production devices that don’t have an unlockable bootloader, root\naccess can be obtained by exploiting a privilege escalation vulnerability,\nwhich allows an app or shell process to start a root shell (also called soft root)\nand modify the system. The exploits are typically packaged into “one-click”\napps or scripts, which try to persist root access by installing a su binary\nor modifying system configuration. For example, the so-called towelroot\nexploit (which is distributed as an Android app) takes advantage of a vul-\nnerability in the Linux kernel (CVE-2014-3153) to obtain root access and\ninstalls SuperSU in order to persist it. (Root access can also be persisted\nby overwriting the recovery partition with a custom recovery, thus allowing\nthe installation of arbitrary software, including superuser applications.\nHowever, some devices have additional protections that prevent modifica-\ntions to the boot, system, and recovery partitions, so permanent root access\nmight not be possible.)\nNOTE See Chapter 3 of the Android Hacker’s Handbook (Wiley, 2014) for a detailed\ndescription of the major privilege-escalation vulnerabilities that have been used to\nobtain root access in various Android versions. Chapter 12 of the same book intro-\nduces the main exploit-mitigation techniques that have been implemented in Android\nin order to prevent privilege-escalation attacks and generally harden the system.\nSystem Updates and Root Access 375",
    "question": "How does root access work on Android devices, and what are the different methods for enabling it on engineering builds, production builds, and custom Android distributions?",
    "summary": "The text explains how root access is implemented on Android devices, focusing on unlocking bootloaders, using fastboot to update devices, and the role of custom recoveries. It also discusses the security implications of root access, including how it can be granted through superuser applications and how custom ROMs manage it. Finally, it covers methods for obtaining root access on production devices, such as exploiting vulnerabilities, and highlights the risks involved."
  },
  {
    "start": 215,
    "end": 215,
    "text": "summary\nIn order to allow for updating the system software or returning a device to\nits factory state, Android devices allow unrestricted, low-level access to their\nstorage via the bootloader. The bootloader typically implements a manage-\nment protocol, usually fastboot, that allows for transferring and flashing\npartition images from a host machine. Bootloaders on production devices\nare usually locked and allow flashing only of signed images. However, most\nbootloaders can be unlocked, thus allowing flashing images from third parties.\nAndroid uses a dedicated partition to store a second, minimal OS,\ncalled a recovery, which is used to apply OTA update packages or clear all\ndata on the device. Like bootloaders, recoveries on production devices typi-\ncally allow applying only those OTA packages signed by the device manu-\nfacturer. If the bootloader is unlocked, a custom recovery, which allows\ninstalling updates signed by third parties or completely forgoes signature\nverification, can be booted or permanently installed.\nEngineering or debug builds of Android allow root access via the\nAndroid shell, but root access is typically disabled on production devices.\nRoot access on such devices can be enabled by installing a third-party OTA\npackage that includes a “superuser” daemon and a companion applica-\ntion that allow controlled root access to applications. Third-party Android\nbuilds (ROMs) typically allow root access out of the box, although it can\nalso be disabled via the system settings interface.\n376 Chapter 13",
    "question": "What are the different ways to gain root access on Android devices and how do bootloaders and recoveries affect this ability?",
    "summary": "Android devices provide low-level storage access through the bootloader for system updates or factory resets, usually allowing only signed images. Most bootloaders can be unlocked to permit flashing of third-party images, including custom recoveries that bypass manufacturer-signed updates. Additionally, engineering builds grant root access, while production devices typically disable it, though third-party OTA packages can enable it."
  },
  {
    "start": 216,
    "end": 216,
    "text": "INDEX\nNumbers cache, 194–195\noverview, 194\n2FA (two-factor authentication), 207\nGoogle accounts\nClientLogin protocol,\nA 209–210\nA_AUTH messages, 281 Google Account Manager,\nabort function, 359 206–209\nAbstractAccountAuthenticator class, Google Login Service,\n194, 202, 203 206–209\naccept() method, 152 Google Play Services, 211–213\nACCESS_ALL_EXTERNAL_STORAGE\nOAuth 2.0, 210–212\npermission, 26 overview, 206\naccess control lists (ACLs), 7 multi-user support\nACCESS_KEYGUARD_SECURE_STORAGE\noverview, 201–202\npermission, 274 per-user account\nACCESS_SURFACE_FLINGER permission, 27 databases, 202\naccess vectors (AVs), 326 shared accounts, 202–203\nrules, 329–330 overview, 192–193\nallow rule, 329 AccountManager class, 94, 112, 192, 193\nauditallow rule, 330 ACCOUNT_MANAGER permission, 194\ndontaudit rule, 330 AccountManagerService\nneverallow rule, 330 listing and authenticating\nAccountAuthenticatorCache class, accounts, 196\n194, 195 managing accounts, 196–197\nAccountAuthenticator.xml file, 195 overview, 193\naccount management requesting authentication token\nAccountManager class, 193 access, 198\nusing account credentials, 197\nAccountManagerService\nlisting and authenticating accounts database\naccounts, 196 password security, 201\nmanaging accounts, 196–197 table access, 200–201\noverview, 193 table schema, 199–200\nrequesting authentication accounts.db file, 99\ntoken access, 198 ACLs (access control lists), 7\nusing account credentials, 197 ACTION_ADD_DEVICE_ADMIN intent\naccounts database action, 219\npassword security, 201 ACTION_DEVICE_ADMIN_ENABLED intent\ntable access, 200–201 action, 224\ntable schema, 199–200 ACTION_GET_RESTRICTION_ENTRIES intent\nauthenticator modules action, 94\nadding, 203–205 ACTION_NDEF_DISCOVERED intent\naction, 291\nACTION_PACKAGE_ADDED broadcast, 72 addAccount() method, 196, 203\nACTION_PASSWORD_FAILED broadcast, 221 addNetwork() method, 248\nACTION_PASSWORD_SUCCEEDED addPermission() method, 43\nbroadcast, 221 addProvider() method, 118, 143\nACTION_SET_NEW_PASSWORD action, 221 ADT (Android Development Tools)\nACTION_START_ENCRYPTION intent Eclipse plugin, 278\naction, 223 Advanced Security SD (ASSD)\nACTION_TAG_DISCOVERED intent action, 291 cards, 298\nACTION_TECH_DISCOVERED intent AEAD (Authenticated Encryption\naction, 291 with Associated Data), 125\n<active-password> tag, 221 AES algorithm, 120, 125, 132, 138,\nactivities 139, 141, 175, 286–287\napp architecture, 11 AIA (Authority Information\npermissions, 44–45 Access), 162\nenforcement, 36 AID (Application Identifier), 304–\nActivityManagerService, 49 305, 312–314\nADB (Android Debug Bridge), 17, 64, <aid-group> tag, 312, 315\n277–283 AIDL (Android Interface Definition\nauthentication keys, 282 Language), 6\ndaemon overview, 277–279 airplane mode, 92\nimplementation, 281–282 --algo parameter, 77\nneed for secure, 279–280 algorithm parameter, 120\nroot access aliases() method, 135\non engineering builds, allowBackup attribute, 284, 287\n365–367 allow rule, 329\non production builds, 368–369 always-on VPN configuration,\nsecuring, 280 235–236\nverifying host key fingerprint, Android Beam feature, 295\n282–283 Android Debug Bridge. See ADB\nADB_AUTH_RSAPUBLICKEY argument, 281 Android Development Tools (ADT)\nADB_AUTH_SIGNATURE argument, 281 Eclipse plugin, 278\nADB_AUTH_TOKEN argument, 281 Android Interface Definition\nadbd (ADB) daemon, 277–278. See Language (AIDL), 6\nalso ADB AndroidKeyStoreProvider, 188–189\nadb install command, 61, 76–78 Android Mainlining Project, 2\nadb push command, 76 AndroidManifest.xml file\nadb reboot bootloader command, 350 overview, 11\nadb reboot recovery command, 354 permission requests in, 14, 15, 23\nadb restore command, 284 protected broadcasts in, 38\nadb shell command, 110 verifying packages and, 67\nadb sideload OTA-package-file Android Master Key, 67\ncommand, 357 Android Open Source Project\nADB_TRACE environment variable, 279 (AOSP), 39, 344\nADB_VENDOR_KEYS environment AndroidOpenSSL provider,\nvariable, 282 140–142, 156\naddAccountExplicitly() method, 196, Android Runtime (ART), 69\n203, 204 ANDROID_SDK_HOME environment\naddAccountFromCredentials() variable, 282\nmethod, 202 Android Secure External Caches\n(ASEC) containers, 76, 81\n378 Index\nANNSI intermediate CA incident, 167 components, 11\nAOSP (Android Open Source services, 11–12\nProject), 39, 344 system, 10\nAPDU_RECIEVED broadcast, 302 user-installed, 11\nAPDUs (Application Protocol Data Binder\nUnits), 302–305, 311–315 accessing objects, 8–9\nspecifying routing capability-based security, 7\nfor SE applets, 313–315 death notification, 9\nfor HCE services, 312–314 implementation, 5–6\nAPKs object identity, 7\ncode signing and, 16 overview, 5\nDalvik VM and, 3 reference counting, 9\nappdomain domain, 345–346 security, 6–7\napp_domain() macro, 345 tokens, 7–8\napp ID, 12 Dalvik VM, 3–4\napplication-based VPNs, 236–239 framework libraries, 10\ndeclaring, 237–238 inter-process communication,\nestablishing connection, 238 4–5\nnotifying user about connection, Java runtime libraries, 4\n238–239 JCA\npreparing, 238 dynamic provider registration,\nApplication Identifier (AID), 304– 118–119\n305, 312–314 overview, 116–117\nApplication Protocol Data Units. provider implementation,\nSee APDUs 117–118\napplication/vnd.android.package static provider\n-archive MIME type, 52 registration, 118\napply_patch_check function, 359, 361 Linux kernel, 2\napplypatch command, 362 native userspace layer, 2–3\napply_patch function, 359 system services, 4\napps ART (Android Runtime), 69\nactivities, 11 ASEC (Android Secure External\nbroadcast receivers, 12 Caches) containers, 76, 81\ncomponents of, 11 asec mount command, 81\ncontent providers, 12 asec path command, 81\nmulti-user support, 92 asec unmount command, 81\nsandboxing, 12–14 ASSD (Advanced Security SD)\nservices, 11–12 cards, 298\nsystem, 10 assert function, 359\nuser-installed, 11, 63 assigning permissions, 26–28\nuser management asymmetric encryption, 122, 123\napplication sharing, 101–104 AT commands, 297\ndata directories, 100–101 attribute statement, 325\noverview, 99 auditallow rule, 330, 340\nARC4 algorithm, 138, 139, 141, 229 AUTHENTICATE_ACCOUNTS permission,\narchitecture 196, 204\napps Authenticated Encryption with\nactivities, 11 Associated Data\nbroadcast receivers, 12 (AEAD), 125\ncontent providers, 12\nIndex 379\nauthenticator modules bootloader program, 252–253,\naccount management and, 192 350–354\nadding, 203–205 fastboot mode, 352–354\ncache, 194–195 commands, 353–354\noverview, 194 partition layout, 352–353\nAuthority Information Access protocol, 353\n(AIA), 162 unlocking, 18, 350–352\nauthtokens table, 199, 201 Bouncy Castle KeyStore (BKS),\nAVs. See access vectors 134, 139\nBouncy Castle provider, 137–140\nB broadcasts\npermissions, 45–46\nbackdoors, 83\npermissions enforcement, 37\nbackup framework, 283–288\nreceivers, 12\ncloud backup, 283\nuser management and, 95–96\ncontrolling scope, 287–288\nBROADCAST_STICKY permission, 37\nencryption, 286–287\nbrute-force attacks, 276–277\nfile format, 284–286\nlocal backup, 283–284\nC\nBackupManagerService, 284, 285–286\nBCB (bootloader control block), 356 CA (certificate authority)\nBIND_DEVICE_ADMIN permission, 45, 224 defined, 147\nBinder handling compromises, 163\naccessing objects, 8–9 installing certificates, 183–184\ncapability-based security, 7 private, 148\ndeath notification, 9 camera, disabling, 223\nimplementation, 5–6 CAMERA permission, 25\nkeystore service and, 174 CameraService, 223\nobject identity, 7 capability-based security, 7\noverview, 5 CAP_CHOWN capability, 65\npermissions and, 34 CAP_DAC_OVERRIDE capability, 65\nreference counting, 9 CAP_KILL capability, 329\nsecurity, 6–7 CAP_NET_ADMIN capability, 31\ntokens, 7–8 CAP_NET_RAW capability, 31\nBIND_NFC_SERVICE permission, 311, 317 CAP_SETGID capability, 365–366\n--bind parameter, 106 CAP_SETUID capability, 365–366\nBKS (Bouncy Castle KeyStore), CAP_SYS_ADMIN capability, 330\n134, 139 CAP_SYS_PTRACE capability, 329\nblacklisting certificates card emulation (CE) mode, 290, 295\nAndroid, 164–166 category attribute, 312\nhandling CA key CBC (Cipher-block chaining),\ncompromises, 163 124, 259\nhandling EE key compromises, CDD (Compatibility Definition\n163–164 Document), 105\nblock cipher modes, 124–125 CDP (CRL Distribution Point), 162\nBLOWFISH algorithm, 138, 139 CE (card emulation) mode, 290, 295\nBluetooth, 92 certificate authority. See CA\nBOOT_COMPLETED broadcast, 37 CertificateException, 162, 170\nbootloader control block (BCB), 356 CertificateFactory class, 135–136, 138\ncertificate revocation list (CRL), 150\n380 Index\ncertificates Cipher class\nAndroid, 164–166 block cipher modes, 124–125\nblacklisting obtaining instance of, 125–126\nhandling CA key overview, 123\ncompromises, 163 supported algorithms, 138, 141\nhandling EE key using, 126–127\ncompromises, 163–164 Cipher feedback (CFB), 124\ncertificate pinning, 168–170 cipher mode, 259–260\ndeleting, 185 cipher suites, 146\ndirect trust and private CAs, 148 ciphertext, 123, 124\nEAP credentials, 172–173 classes.dex file, 52\ninstalling CA, 183–184 class keyword, 326\nmanagement of class statement, 326–327\nAndroid 4.x system trust store, clearPassword() method, 197, 200\n157–158 client credentials, passing and\nsystem trust store APIs, querying, 32\n161–162 ClientLogin protocol, 209–210\nsystem trust stores, 156–157 clone() method, 106\nusing system trust store, CLONE_NEWNS flag, 106, 108, 110\n158–161 CN (common name), 146\nPKI, 148–150 codePath attribute, 71\npublic key, 146–147 code signing, 16\nrevocation of, 150–151 COM (Common Object Model), 5\nCertPathBuilder class, 136, 138 common keyword, 326\nCertPath class, 135–136, 153 common name (CN), 146\nCertPathTrustManagerParameters Common Object Model (COM), 5\nclass, 153 Common Object Request Broker\nCertPathValidator class, 136, 138 Architecture (CORBA), 5\nCERT.SF file, 58 Comodo attack, 167\nCertStore class, 138 compareSignatures() method, 74\nCFB (Cipher feedback), 124 Compatibility Definition Document\nChallenge-Handshake (CDD), 105\nAuthentication Protocol CONFIG_ANDROID_PARANOID_NETWORK\n(CHAP), 229 permission, 31\nchangeEncryptionPassword() CONFIG_DM_VERITY kernel configuration\nmethod, 275 item, 255\nCHANGE_WIFI_STATE permission, 248 config_multiuserMaximumUsers system\nChannel class, 308–309 resource, 88\nCHAP (Challenge-Handshake confirmCredentials() method, 197\nAuthentication Conscrypt provider, 141\nProtocol), 229 ContainerEncryptionParams class, 78, 79\nchcon utility, 333 content providers\ncheckPassword() method, 275 app architecture, 12\ncheckPattern() method, 272 defined, 6\ncheckPermission() method, 35, 42 permissions\ncheckServerTrusted() method, 162, 169 dynamic, 47–49\nchoosePrivateKeyAlias() method, enforcement, 36\n182, 186 static, 46–47\nCipher-block chaining (CBC), CONTROL_KEYGUARD permission, 269\n124, 259 -c option, 373\nIndex 381\ncopyResource() method, 79 cryptography\nCORBA (Common Object Request Android providers\nBroker Architecture), 5 AndroidOpenSSL, 140–142\nCounter (CTR) mode, 124 Bouncy Castle, 137–140\ncreated attribute, 98 Crypto, 137\ncreateInstallIntent() method, 181 OpenSSL and, 142\ncreateSecureContainer() method, 82 overview, 137\ncredentials Spongy Castle, 143–144\naccess control to keystore, 186–187 custom providers, 142–143\nAndroid implementation hashes, 18\naccess restrictions, 176 JCA architecture\nframework integration, 180 dynamic provider registration,\nkey blobs, 176 118–119\nkeymaster module, 176–177 overview, 116–117\nkeystore service, 174–176 provider implementation,\nNexus 4 hardware-backed 117–118\nimplementation, 178–180 static provider\nAndroidKeyStoreProvider, 188–189 registration, 118\nEAP credentials JCA engine classes\nauthentication keys and algorithm names, 120\ncertificates, 172–173 CertificateFactory class,\noverview, 172 135–136\nsystem credential store, CertPathBuilder class, 136\n173–174 CertPath class, 135–136\nKeyChain API CertPathValidator class, 136\ndeleting keys and user Cipher class, 123–127\ncertificates, 185 KeyAgreement class, 132–133\ninstalling CA certificate, KeyFactory class, 129–130\n183–184 KeyGenerator class, 131–132\nKeyChain class, 181–182 Key interface, 128\noverview, 181, 185–186 KeyPairGenerator class, 131\nsupported algorithms, 185 KeyPair interface, 129\nusing private key, 182 KeySpec interface, 129\noverview, 187 KeyStore class, 133–135\npassing and querying, 32 Mac class, 127\nCRL (certificate revocation list), 150 MessageDigest class, 120–121\nCRL Distribution Point (CDP), 162 obtaining engine class\nCRYPT_ENCRYPTION_IN_PROGRESS flag, 265 instance, 119\ncryptfs checkpw command, 267 overview, 119\ncryptfs enablecrypto inplace PBEKey interface, 128–129\ncommand, 265 PrivateKey interface, 129\ncryptfs module, 262–263 PublicKey interface, 129\nCryptKeeper class, 266 SecretKeyFactory class, 130–131\ncrypto footer, 260, 265 SecretKey interface, 128–129\nCryptographically Secure Pseudo SecureRandom class, 120–121\nRandom Number Signature class, 122–123\nGenerator (CSPRNG), Crypto provider, 137\n120, 121 CSP (cryptographic service\ncryptographic service provider provider), 115\n(CSP), 115\n382 Index\nCSPRNG (Cryptographically Secure device administrator, 223–227\nPseudo Random Number implementing, 224\nGenerator), 120, 121 managed devices, 226\nctl_default_prop type, 336 setting device owner, 224–225\nCTR (Counter) mode, 124 policy enforcement, 221–223\nCyanogenMod Android distribution, policy persistence, 220–221\n310, 374 privilege management, 218–219\ndevice administrators, 216, 223–227\nD implementing, 224\nmanaged devices, 226\nDAC (discretionary access control),\nsetting device owner, 224–225\n17, 319–320, 364\nDeviceAdminReceiver class, 224\ndaemons\nDevice-mapper framework, 254\nnative daemon-level enforcement,\ndevice_policies.xml file, 99, 220, 221\n31–33\nDevicePolicyManager class, 217, 220,\nsecurity model and, 12\n226, 274\ndaemonsu binary, 372 DevicePolicyManagerService, 217–219\nDalvik Executable (DEX), 3, 63\ndevice security, 251–288\nDalvik VM, 3–4\nbackup framework, 283–288\ndangerous protection level, 25\ncloud backup, 283\ndata_file_type attribute, 325 controlling scope, 287–288\ndeath notification, 9\nencryption, 286–287\ndebuggable flag, 14\nfile format, 284–286\ndebugging, USB, 277–283\nlocal backup, 283–284\nauthentication keys, 282\ndisk encryption, 258–268\ndaemon overview, 277–279\nbooting encrypted devices,\nimplementation, 281–282\n265–267\nneed for secure, 279–280\nchanging password, 262–263\nsecuring, 280\ncipher mode, 259–260\nverifying host key fingerprint,\nenabling, 263–265\n282–283\nkey derivation, 260–261\nDECRYPT_MODE, 126, 127\npassword, 261–262\ndecryptStorage() method, 267 OS boot-up and installation\ndelayed provider selection, 116\ncontrol, 252–254\ndelete_all() method, 177 bootloader program, 252–253\ndeleteEntry() method, 135 recovery OS, 253–254\ndelete function, 359 screen security, 268–277\ndelete_keypair() method, 177 brute-force attack protection,\ndelete_recursive function, 359 276–277\nderivation mode, 112\nkeyguard unlock methods,\nDES algorithm, 138, 139, 140\n269–277\ndescription attribute, 312\nlockscreen implementation,\ndevelopment permissions, 39–40\n268–269\nDEVICE_ADMIN_ENABLED broadcast, 46\nsecure USB debugging, 277–283\nDeviceAdminInfo class, 216\nauthentication keys, 282\nDevice Administration API, 216–228\ndaemon overview, 277–279\naccount integration, 226–228\nimplementation, 281–282\nGoogle Apps, 227–228\nneed for, 279–280\nMicrosoft Exchange\nActiveSync, 226–227\nIndex 383\ndevice security, secure USB enabling, 263–265\ndebugging (continued) controlling encryption\nsecuring, 280 using system properties,\nverifying host key fingerprint, 263–264\n282–283 triggering encryption\nverified boot feature, 254–258 process, 265\nenabling, 256–258 unmounting /data, 264\nimplementation, 255–256 updating crypto footer, 265\noverview, 254–255 key derivation, 260–261\ndevice storage encryption, 223 limitations of, 267\ndex2oat command, 69 password for, 261–262\nDEX (Dalvik Executable), 3, 63 changing, 262–263\ndexopt command, 65 distinguished name (DN), 146\nDH (Diffie-Hellman), 132, 139 dm-crypt device-mapper target, 254,\ndigest() method, 122 259, 265\nDigiNotar attack, 167 dm-verity device-mapper block\nDigital Signature Algorithm (DSA), integrity checking target,\n137, 139, 141, 177 254–258\n<disable-camera> tag, 217 enabling, 256–258\n<disable-keyguard-features> tag, 217 implementation, 255–256\ndisableReaderMode() method, 294 overview, 254–255\nDISALLOW_CONFIG_BLUETOOTH DN (distinguished name), 146\nrestriction, 92 doFinal() method, 125\nDISALLOW_CONFIG_CREDENTIALS domain attribute, 325\nrestriction, 92 domain_auto_trans() macro, 328\nDISALLOW_CONFIG_WIFI restriction, 92 domain_trans() macro, 328\nDISALLOW_INSTALL_APPS restriction, dontaudit rule, 330\n92, 93 doPhase() method, 133\nDISALLOW_INSTALL_UNKNOWN_SOURCES DownloadManager service, 66\nrestriction, 92 DSA (Digital Signature Algorithm),\nDISALLOW_MODIFY_ACCOUNTS restriction, 137, 139, 141, 177\n92, 196\nDISALLOW_REMOVE_USER restriction, 92 E\nDISALLOW_SHARE_LOCATION restriction,\nEAP (Extensible Authentication\n92, 93\nProtocol), 242–250\nDISALLOW_UNINSTALL_APPS restriction,\n92, 93\nadding networks with WifiManager,\n248–250\nDISALLOW_USB_FILE_TRANSFER\nAndroid Wi-Fi architecture,\nrestriction, 92\n244–245\ndiscretionary access control (DAC),\nauthentication keys and\n17, 319–320, 364\ncertificates, 172–173\ndisk encryption, 258–268\nauthentication methods, 243–244\nbooting encrypted devices,\nEAP-PWD, 244\n265–267\nEAP-TLS, 244\ndecrypting and mounting\nEAP-TTLS, 244\n/data, 267\nPEAP, 243\nobtaining password, 267\ncredentials management, 245–248\nstarting all system\noverview, 172\nservices, 267\nsystem credential store, 173–174\ncipher mode, 259–260\n384 Index\nEAP-PWD (EAP Using Only a content provider permission\nPassword), 244, 247 enforcement, 36\nEAP-TLS (EAP-Transport Layer dynamic enforcement, 34–36\nSecurity), 172, 244, 246, protected broadcasts, 37\n248, 249 service permission\nEAP-TTLS (EAP-Tunneled Transport enforcement, 36\nLayer Security), 244, 247 sticky broadcasts, 37\nEAS (Exchange ActiveSync) account kernel-level, 30–31\nintegration, 226–227 native daemon-level, 31–33\nECB (Electronic Code Book), 124 enforcePermission() method, 35, 42\nECDSA (Elliptic Curve DSA), 60, 177 enterprise security, 215–250\nEC (Elliptic Curve), 131 Device Administration API,\nedify functions, 359 216–228\neditProperties() method, 197 account integration, 226–228\nEE (end entity) device administrator, 223–227\ndefined, 149 policy enforcement, 221–223\nhandling compromises, 163–164 policy persistence, 220–221\neffective user ID (EUID), 6 privilege management,\nElectronic Code Book (ECB), 124 218–219\nElectronic Frontier Foundation, 167 EAP framework, 242–250\nElliptic Curve DSA (ECDSA), 60, 177 adding networks with\nElliptic Curve (EC), 131 WifiManager API, 248–250\nembedded secure elements (eSEs), Android Wi-Fi architecture,\n298–302 244–245\nbroadcasts, 301–302 authentication methods,\ngranting access to, 299–300 243–244\nNfcExecutionEnvironment class, credentials management,\n300–301 245–248\nemulated external storage, 104 VPNs, 227–250\nEMULATED_STORAGE_SOURCE environment application-based, 236–239\nvariable, 107, 110 L2TP, 229–230\nEMULATED_STORAGE_TARGET environment legacy, 231–236\nvariable, 108, 110 multi-user support, 239–242\nenableForegroundDispatch() PPTP, 229\nmethod, 292 SSL-based, 230–231\nenableReaderMode() method, 294 Xauth, 230\nencrypted salt-sector initialization EntropyMixer service, 121\nvector (ESSIV), 259, 260 eSEs. See embedded secure elements\n<encrypted-storage> tag, 217 ESSIV (encrypted salt-sector\nencryption. See also disk encryption initialization vector),\nbackup, 286–287 259, 260\ndevice storage, 223 establish() method, 238\nENCRYPT_MODE, 126 EUID (effective user ID), 6\nend entity. See EE EV (Extended Validation)\nenforcement, permissions certificates, 148\nframework-level Exchange ActiveSync (EAS) account\nactivity permission integration, 226–227\nenforcement, 36 <expire-password> tag, 217\nbroadcast permission ext4 filesystem, 80, 324\nenforcement, 37\nIndex 385\nExtended Validation (EV) Filesystem in Userspace (FUSE), 105\ncertificates, 148 file_type attribute, 325\nExtensible Authentication Protocol. FLAG_ADMIN flag, 98\nSee EAP FLAG_GRANT_PERSISTABLE_URI_PERMISSION\nExtensible Authentication Protocol- flag, 48\nTransport Layer Security FLAG_GRANT_READ_URI_PERMISSION flag, 48\n(EAP-TLS), 172, 244, 246, FLAG_GRANT_WRITE_URI_PERMISSION flag, 48\n248, 249 FLAG_GUEST flag, 98\nExtensible Authentication Protocol- FLAG_INITIALIZED flag, 98\nTunneled Transport Layer FLAG_PRIMARY flag, 98\nSecurity (EAP-TTLS), FLAG_RESTRICTED flag, 98\n244, 247 flags attribute, 71, 98, 220\nExtensible Authentication Protocol FLAG_UPDATED_SYSTEM_APP flag, 76\nUsing Only a Password Flame, 53\n(EAP-PWD), 244, 247 <force-lock> tag, 216\nexternal storage fork() system call, 28\nAndroid implementation, format function, 359\n106–111 framework\nLinux mount features, 105–106 credential storage\noverview, 104–105 implementation, 180\npermissions, 111–112 libraries making up, 10\nEXTERNAL_STORAGE environment permissions enforcement at\nvariable, 110 framework-level\nEXTRA_CERTIFICATE key, 183 activity permission\nenforcement, 36\nF broadcast permission\nenforcement, 37\nFace Unlock method, 271\ncontent provider permission\nfactory reset, 18\nenforcement, 36\nfailedAttempts attribute, 98 dynamic enforcement, 34–36\nfastboot boot command, 353, 363 protected broadcasts, 37\nfastboot command-line utility, 353 service permission\nfastboot devices command, 353 enforcement, 36\nfastboot flashall command, 353 sticky broadcasts, 37\nfastboot flash command, 353, 363 ft attribute, 71\nfastboot flash:raw command, 353 FullBackupAgent class, 284\nfastboot mode, 252–253, 352–354\nfull-disk encryption (FDE), 258–259\ncommands, 353–354\nFUSE (Filesystem in Userspace), 105\npartition layout, 352–353\nprotocol, 353\nG\nfastboot oem lock command, 351\nfastboot oem unlock command, 351 GCM (Galois/Counter Mode), 125\nfastboot update command, 353 GCM (Google Client Messaging), 166\nfastboot update ZIP-filename generateCertificate() method, 136\ncommand, 353 generateCertPath() method, 136\nFAT filesystem, 80 GENERATE_KEYPAIR command, 178\nFDE (full-disk encryption), 258–259 generate_keypair() method, 177\nFile Control Information (FCI), 305 generateKeyPair() method, 131\nfile_getprop function, 359 generatePublic() method, 130\n386 Index\ngenerateSecret() method, 133 Google accounts\nGeneric Routing Encapsulation ClientLogin protocol, 209–210\n(GRE), 229 Google Account Manager,\ngetAccountCredentialsForCloning() 206–209\nmethod, 202 Google Login Service, 206–209\nGET_ACCOUNTS permission, 196 Google Play Services, 211–213\ngetAlgorithm() method, 128 OAuth 2.0, 210–211\ngetApplicationRestrictions() overview, 206\nmethod, 94 Google Apps account integration,\ngetAuthToken() method, 197, 200 227–228\ngetCallingPid() method, 36 Google Client Messaging (GCM), 166\ngetCallingUid() method, 36 Google experience devices, 191\ngetCertificateChain() method, 183 Google Login Service (GLS), 206–209\ngetCertificate() method, 186 Google Play, 25\ngetDeviceOwner() method, 225 Google Services Framework\ngetDeviceOwnerName() method, 225 (GSF), 206\ngetEmbeddedExecutionEnvironment() Google Wallet, 299–300, 302\nmethod, 301 GPS (Google Play Services), 211–213\ngetEncoded() method, 128, 130 GrantedPermission class, 35\ngetEncryptionStatus() method, 223 grantPermission() method, 48\ngetenforce utility, 333 grants table, 199\ngetEntry() method, 189 GRE (Generic Routing\ngetExternalFilesDir() method, 111 Encapsulation), 229\ngetExternalStorageDirectory() GSF (Google Services\nmethod, 110 Framework), 206\ngetFormat() method, 128 guest user, 94–95\ngetInstance() method, 119\nget_keypair_public() method, 177 H\ngetKeySpec() method, 130\nHAL (Hardware Abstraction Layer),\nget() method, 293\n177, 244–245\ngetModulus() method, 129\nhardware security module (HSM), 135\ngetPassword() method, 196, 200, 201\nHCE. See host-based card emulation\ngetPrivateExponent() method, 129\nHMAC algorithm, 82\ngetPrivateKey() method, 183, 186\ngetprop function, 359\nHostApduService, 310, 315, 316\ngetReaders() method, 309 <host-apdu-service> tag, 312\nhost-based card emulation (HCE;\ngetsebool utility, 333\nsoftware card emulation),\ngetSelectionModeForCategory()\n311–318\nmethod, 312\nAndroid 4.4 architecture, 310–311\ngetUserData() method, 196\nAPDU routing, 311–315\ngetvar command, 353\nspecifying for HCE services,\nGID, associating permissions with, 27\n312–314\nGlobalPlatform Card Specification,\nspecifying for SE applets,\n303, 304–305\n313–315\nglobal proxy settings, 222\napplication security, 317–318\nGLOBAL_SEARCH permission, 47\nwriting services, 315–317\nGLS (Google Login Service),\nhostname verification, 154\n206–209\nGoogle Account Manager, 206–209 HostnameVerifier class, 154\nIndex 387\nHSM (hardware security INTERNAL_SYSTEM_WINDOW permission, 268\nmodule), 135 INTERNAL_TARGET_DESELECTED\nHttpClient class, 159 broadcast, 302\nHTTPS (Hypertext Transfer Protocol Internet Key Exchange (IKE), 230\nSecure), 151 INTERNET permission, 23\nHttpsURLConnection class, 151, 154, Internet Protocol Security (IPSec)\n156, 159 protocol, 229–230\nInternet Security Association and\nI Key Management Protocol\n(ISAKMP), 230\nIAccountAuthenticator interface, invalidateAuthToken() method, 197\n194, 203\nIPC (inter-process communication)\nicon attribute, 98 architecture and, 4–5\nid attribute, 98 security model, 15–16\nid utility, 333 IPSec Extended Authentication\nIKE (Internet Key Exchange), 230\n(Xauth), 230\nIKeyguardService, 269\nIPSec (Internet Protocol Security)\nIMPORT_KEYPAIR command, 178 protocol, 229–230\nimport_keypair() method, 177 isAdminActive() method, 224\ninherits keyword, 326 ISAKMP (Internet Security\ninit_daemon_domain() macro, 328 Association and\ninitialization vector (IV), 124, 175\nKey Management\ninitSign() method, 123 Protocol), 230\ninsertProviderAt() method, 118, 143 isBoundKeyAlgorithm() method, 185\nINSTALL_ACTION intent, 63\nisDefaultServiceForCategory()\nInstallAppProgress activity, 67 method, 312\ninstallCaCert() method, 226 isDeviceOwnerApp() method, 225\ninstalld daemon, 342–344 isDeviceOwner() method, 225\ninstaller attribute, 71 isKeyAlgorithmSupported() method, 185\ninstallExistingPackageAsUser() Issuer Security Domain (ISD)\nmethod, 102\ncomponent (Card\nINSTALL_FAILED_INVALID_APK error, 79 Manager), 303\nINSTALL_FAILED_SHARED_USER_INCOMPATIBLE isSystemServer selector, 337\nerror, 40\nit attribute, 71\nINSTALL_FAILED_UID_CHANGED error, 40 ITelephony interface, 275–276\nINSTALL_FAILED_USER_RESTRICTED error, 93 IV (initialization vector), 124, 175\nINSTALL_FAILED_VERIFICATION_FAILURE --iv parameter, 77\nerror, 85\nINSTALL_FORWARD_LOCK flag, 82\nJ\nINSTALL_NON_MARKET_APPS setting, 66\nINSTALL_PACKAGES permission, 67 jarsigner command, 57, 58\ninstallPackageWithVerification Java Card runtime environment\nAndEncryption() method, ( JCRE), 302–303\n64, 77 Java Cryptography Architecture ( JCA)\nINSTALL_PARSE_FAILED_INCONSISTENT_ algorithm names, 120\nCERTIFICATES error, 74 architecture\nINTERACT_ACROSS_USERS_FULL dynamic provider registration,\npermission, 96 118–119\nINTERACT_ACROSS_USERS permission, overview, 116–117\n45, 96\n388 Index\nprovider implementation, peer authentication, 152–154\n117–118 providers for, 137\nstatic provider registration, 118 secure sockets, 152\nCertificateFactory class, 135–136 Java Virtual Machine ( JVM), 3\nCertPath class, 135–136 JCA. See Java Cryptography\nCertPathValidator class, 136 Architecture\nCipher class JCRE (Java Card runtime\nblock cipher modes, 124–125 environment), 302–303\nobtaining instance of, 125–126 JSSE. See Java Secure Socket Extension\noverview, 123 --just_exit option, 356\nusing, 126–127 JVM (Java Virtual Machine), 3\nengine classes, 119\nobtaining instance of, 119 K\nKeyAgreement class, 132–133\nKDF (key-derivation function), 133\nKeyFactory class, 129–130\nKEK (key-encryption key), 179, 258,\nKeyGenerator class, 131–132\n260, 261\nKey interface, 128\nkernel-level permissions\nKeyPairGenerator class, 131\nenforcement, 30–31\nKeyPair interface, 129\nKeySpec interface, 129 KeyAgreement class, 132–133, 139, 141\nkey blobs, 175, 176\nKeyStore class, 133–135\nMac class, 127 KeyChain API, 226\ndeleting keys and user\nMessageDigest class, 121–122\ncertificates, 185\nPBEKey interface, 128–129\ninstalling CA certificate, 183–184\nPrivateKey interface, 129\nPublicKey interface, 129 KeyChain class, 181–182\noverview, 181, 185–186\nSecretKeyFactory class, 130–131\nsupported algorithms, 185\nSecretKey interface, 128–129\nusing private key, 182\nSecureRandom class, 120–121\nSignature class, 122–123\nKeyChainBroadcastReceiver, 185, 187\nJava runtime libraries, 4 KeyChain class, 181–182\nJava Secure Socket Extension ( JSSE) KeyChainService class, 185\nkey derivation, 260–261\nAndroid implementation, 155–156\nkey-derivation function (KDF), 133\ncertificate blacklisting\nkey-encryption key (KEK), 179, 258,\nAndroid, 164–166\n260, 261\nhandling CA key\ncompromises, 163 KeyFactory class, 129–130, 137, 139, 141\nhandling EE key KeyGenerator class, 131–132, 139\nkeyguard customizations,\ncompromises, 163–164\ndisabling, 223\ncertificate management and\nvalidation KeyguardHostView class, 269\nAndroid 4.x system trust store, KeyguardPINView class, 269\n157–158\nKeyguardService, 269\nkeyguard unlock methods, 269–277\nsystem trust store APIs,\nFace Unlock, 271\n161–162\nPassword unlock, 270, 273–275\nsystem trust stores, 156–157\nPattern unlock, 270, 272–273\nusing system trust store,\nPIN unlock, 270–271, 273–276\n158–161\nPUK unlock, 271, 275–276\nhostname verification, 154\nSlide unlock, 270\noverview, 151–152\nIndex 389\nKey interface, 128 LockSettingsService, 274\nKeyManager class, 153 Logical Volume Manager (LVM), 254\nKeyManagerFactory class, 152 login attempt notifications, 221\nkeymaster module, 176–177 -l option, 111\nKeyPairGenerator class, 131, 139, 141, low memory killer, 2\n188, 189 LRU (least recently used), 96\nKeyPairGeneratorSpec class, 189 ls command, 323, 333\nKeyPair interface, 129 LSM (Linux Security Modules)\n--key parameter, 77 framework, 320\nKeySpec interface, 129 LVM (Logical Volume Manager), 254\nKeyStore class, 133–135, 139, 152, 158,\n181, 188 M\n-keystore option, 58\nkeystore service, 174–176 --macalgo parameter, 78\nkey stretching, 129 Mac class, 127, 139, 141\n--mackey parameter, 78\nMAC (mandatory access control), 1,\nL\n17, 319–320, 321–322, 331\nL2TP (Layer 2 Tunneling Protocol), MAC (Message Authentication\n229–230 Code), 127, 176\nlabels. See security contexts MANAGE_ACCOUNTS permission, 196, 197\nlastAttemptMs attribute, 98 MANAGE_CA_CERTIFICATES permission,\nlastLoggedIn attribute, 98 161, 226\nleast recently used (LRU), 96 MANAGE_DEVICE_ADMINS permission, 219\nlegacy VPNs, 231–236 MANAGE_USERS permission, 95\naccessing credentials, 234 mandatory access control, 1, 17,\nalways-on, 235–236 319–320, 321–322, 331\nimplementation, 231–233 MANIFEST.MF file, 53, 58\nprofile and credential storage, marking packets, 240, 242\n233–234 MASTER_CLEAR_NOTIFICATION\n<limit-password> tag, 216 broadcast, 302\nlink to death, 9 master key, 175\nLinux kernel, 2. See also SELinux MediaContainerService, 68, 79, 82\nadvanced routing, 239–240 @MEDIA macro, 339\nDevice-mapper framework, 254 Message Authentication Code\nLogical Volume Manager, 254 (MAC), 127, 176\nLinux Security Modules (LSM) MessageDigest class, 121–122, 137,\nframework, 320 139, 141\nload_policy utility, 333 META-INF directory, 52\n--locale option, 356 microSD-based secure elements, 298\nlocation, multi-user support, 92 microSD cards, 80\nlock down functionality, 22, 222 Microsoft Exchange ActiveSync\nLOCKDOWN_VPN file, 235 (EAS) account\nLockdownVpnTracker class, 235 integration, 226–227\nlockNow() method, 222 Microsoft Point-to-Point Encryption\nLockPatternUtils class, 269, 275 (MPPE) protocol, 229\nlockscreen, multi-user support, 90. middleware MAC (MMAC), 338–339\nSee also keyguard unlock MITM attack, 166\nmethods mkuserdata command, 69, 100\nLockScreenUtils class, 272 MLS (multi-level security), 321–323\n390 Index\nmMacAlgorithm field, 78 VPNs, 239–242\nmMacKey field, 78 implementation, 240–241\nMMAC (middleware MAC), 338–339 Linux advanced routing,\nmMacTag field, 78 239–240\nModecfg (mode-configuration), 230\nMODIFY_AUDIO_SETTINGS permission, 27 N\nmountEmulatedStorage() function, 110\nmount function, 359 name attribute, 71\nmount() method, 106, 108 nativeLibraryPath attribute, 71\nnative userspace layer, 2–3\nmountSecureContainer() method, 82\nMountService, 265, 267, 275 NDEF_DISCOVERED intent, 292\nNDEF (NFC Data Exchange Format),\nMPPE (Microsoft Point-to-Point\n291–294\nEncryption) protocol, 229\nnear-field communication. See NFC\nMS_BIND flag, 106\nMSG_COMMAND_APDU broadcast, 310 NET_ADMIN permission, 26\nnetd daemon, 233, 235, 342\nMS_SHARED flag, 106\nnetfilter kernel framework, 239–240\nMS_SLAVE flag, 108\nmtpd daemon, 231–232\nNetworkManagementService, 240\nnetwork security\nmulti-level security (MLS), 321–323\ncertificate pinning, 168–170\nmulti-user support\ncertificate revocation, 150–151\naccount management\nConvergence and, 167–168\noverview, 201–202\ndirect trust and private CAs, 148\nper-user account\nissues with current PKI system,\ndatabases, 202\n166–167\nshared accounts, 202–203\nJSSE\napp management\nAndroid 4.x system trust store,\napplication sharing, 101–104\n157–158\ndata directories, 100–101\nAndroid implementation,\noverview, 99\n155–156\nbroadcasts and, 95–96\ncertificate blacklisting,\ncommand-line tools, 95\n162–165\nexternal storage\nhostname verification, 154\nAndroid implementation,\noverview, 151–152\n106–111\npeer authentication, 152–154\nLinux mount features,\nsecure sockets, 152\n105–106\nsystem trust store APIs,\noverview, 104–105\n161–162\npermissions, 111–112\nsystem trust stores overview,\nfeatures of, 112\n156–157\nmetadata\nusing system trust store,\nuser list file, 96–97\n158–161\nuser metadata files, 97–98\nPKI, 148–150\nuser system directory, 99\npublic key certificates, 146–147\noverview, 87–89\nneverallow rule, 330\nsecurity model, 16–17\nnextBytes() method, 121\nuser types\nnextSerialNumber attribute, 97\nguest user, 94–95\nNexus devices, 104\nprimary user, 90–91\ncredential storage, 178–180\nrestricted profiles, 92–93\nstock recovery, 354–355\nsecondary users, 91–92\nIndex 391\nNfcActivity class, 292–293 onTagDiscovered() method, 294\nNfcAdapter class, 292, 294, 295 opaque binary blob (OBB) files, 65\nNfcAdapterExtras class, 301 OpenID Connect, 209\nNFC Data Exchange Format (NDEF), openLogicalChannel() method, 309\n291–294 OpenMobile API, 308–309\nNfceeAccessControl class, 299 openSession() method, 309\nNFCEE_ADMIN permission, 299 OpenSSL\nNfcExecutionEnvironment class, 300– Android keystore engine, 180\n301, 303 converting to PKCS#8 format, 60\nNFC (near-field communication), 92, cryptography providers and, 142\n289–318. See also secure enc command, 77\nelements openssl enc command, 77\nAndroid support for, 290–295 OpenVPN application, 230–231,\ncard emulation mode, 295 238–239\npeer-to-peer mode, 294–295 Optimized DEX files, 4, 63\nreader/writer mode, 290–294 OS boot-up and installation control,\nhost-based card emulation, 252–254\n311–318 bootloader program, 252–253\nAndroid 4.4 architecture, recovery OS, 253–254\n310–311 OTA (over-the-air), 17\nAPDU routing, 311–315 flashing packages, 370–375\napplication security, 317–318 sideloading packages, 357\nwriting services, 315–317 signature verification, 357–358\noverview, 289–290 SIM card updates, 307\nNfcService, 290–291, 299, 310–311 update packages, 253, 258, 355–\nnormal protection level, 24–25 356, 358–359\nnosetuid flag, 369 OTP (one-time password), 207, 296\nNoSuchAlgorithmException, 119 Output feedback (OFB), 124\nNoSuchProviderException, 119 over-the-air. See OTA\nO P\nOAuth 2.0, 210–212 P2P (point-to-point) connections, 172\nOBB (opaque binary blob) files, 65 package_extract_dir function, 359\nobjects, Binder package_extract_file function, 359\naccessing, 8–9 PACKAGE_INSTALLED broadcast, 37\nidentity of, 7 PackageInstallerActivity, 66, 67\nOCSP (Online Certificate Status package management\nProtocol), 151 Android Application Package\nOFB (Output feedback), 124 Format, 51–86\nOffHostApduService class, 314 APK install process\n<offhost-apdu-service> element, 314 active components, 63–67\nOFF_HOST_APDU_SERVICE intent, 314 Android 4.1 forward locking\nonDeactivated() method, 310, 316 implementation, 82\nonDisabled() method, 224 encrypted apps and Google\nonEnabled() method, 224 Play, 82–83\none-time password (OTP), 207, 296 forward locking, 79–80\nOnline Certificate Status Protocol installing encrypted APKs,\n(OCSP), 151 76–79\nonPasswordExpiring() method, 223 installing local package, 66–76\n392 Index\nlocation of application broadcast, 45–46\npackages and data, 62–63 content provider\nupdating package, 72–76 dynamic, 47–49\ncode signing static, 46–47\nin Android, 59–61 custom, 42–43\nin Java, 54–59 enforcement of\npackage verification framework-level, 33–37\nAndroid support for, 84–85 kernel-level, 30–31\nGoogle Play implementation, native daemon-level, 31–33\n85–86 external storage, 111–112\nPackageManagerService, 35, 68, 77, 84, management of, 21–23\n85, 95, 100, 102, 194, 339 overview, 21–22\nPACKAGE_NEEDS_VERIFICATION action, 84 pending intents, 49–50\nPACKAGE_REMOVED broadcast, 187 PID assignment and, 28–30\nPACKAGE_REPLACED broadcast, 75 private components, 43–44\npackage-restrictions.xml file, 99, 101 protection levels\npackages. See APKs dangerous, 25\npackages.xml file, 63 defined, 24\nPACKAGE_VERIFICATION_AGENT permission, normal, 24–25\n84, 85 signature, 26\nPACKAGE_VERIFIED broadcast, 85 signatureOrSystem, 26\nPACKAGE_VERIFIER_ENABLE setting, 84 public components, 43–44\npadding, 123 requesting, 22\nPAP (Password Authentication security model, 14–15\nProtocol), 229 service, 44–45\npartial attribute, 98 shared user ID, 40–42\npassword expiration timeout, 223 system\n<password-owner> tag, 221 development permissions,\nPASSWORD_QUALITY_ALPHANUMERIC 39–40\nconstant, 220, 221 overview, 37–39\nPASSWORD_QUALITY constant, 274 signature permissions, 39\nPASSWORD_QUALITY_NUMERIC constant, 274 viewing list of known, 22\nPassword unlock method, 270, when granted, 104\n273–275 permissive statement, 326\nPattern unlock method, 270, 272–273 PFX (Personal Information\nPBEKey interface, 128–129 Exchange Syntax), 134\nPBKDF2 algorithm, 260–262, 262, 286 phishing applications, 83\nPEAP (Protected Extensible PID (process ID)\nAuthentication Protocol), assignment of, 28–30\n243, 246 Binder and, 6\npeekAuthToken() method, 196 pinHash attribute, 98\npeer authentication, 152–154 PIN unlock key (PUK) unlock\npeer-to-peer (P2P) mode, 290, method, 271, 275–276\n294–295 PIN unlock method, 270–271, 273–\npending intents, 49–50 275, 275–276\nPERMISSION_DENIED response, 34 PittPatt (Pittsburgh Pattern\nPERMISSION_GRANTED response, 34 Recognition) company, 271\npermissions PKCS#12 files, 172\nactivity, 44–45 PKCS (Public Key Cryptography\nassigning, 26–28 Standard), 125\nIndex 393\nPKI (Public Key Infrastructure) custom, 142–143\ncertificate revocation, 150–151 OpenSSL and, 142\ndirect trust and private CAs, 148 overview, 137\noverview, 148–150 Spongy Castle, 143–144\npublic key certificates, 146–147 ps command, 323, 333\nPKIX (X.509-based PKI), 138, 152 public components, 43–44\nPKPE (Public Key Pinning Extension public key certificates, 146–147\nfor HTTP), 168 Public Key Cryptography Standard\nplatform keys (PKCS), 125\nsecurity model, 16 Public Key Infrastructure. See PKI\nsystem apps and, 39 PublicKey interface, 129\n@PLATFORM macro, 339 Public-Key-Pin header, 168\nplatform signing key, 10 Public Key Pinning Extension for\npm command, 61 HTTP (PKPE), 168\npm create-user command, 95 Public-Key-Pins-Report-Only header, 169\npm get-max-users command, 95 PUK (PIN unlock key) unlock\npm install command, 76, 78 method, 271, 275–276\npm list users command, 95\npoint-to-point (P2P) connections, 172 Q\n<policies> tag, 220\nQSEE (Qualcomm’s Secure Execution\npowerctl_prop type, 336\nEnvironment), 178\nPPP (Point-to-Point Protocol), 229\nPPTP (Point-to-Point Tunneling\nProtocol), 229 R\nprepare() method, 238\nracoon daemon, 231–232, 234\nprimary user, 90–91\nradio-frequency identification\nprivate CAs, 148\n(RFID) technology, 290\nPrivateKeyEntry, 133\nRandom Number Generator\nPrivateKey interface, 129\n(RNG), 120\nprivate keys, using, 182\nRA (registration authority), 149\nprocessCommandApdu() method, 317\nRC4 algorithm, 138, 139, 141, 229\nprocessCommand() method, 310\nREAD_CONTACTS permission, 47\nprocess ID. See PID\nreader/writer (R/W) mode, 290–294\nprocess isolation, 5\nreader mode, 293–294\nprotected broadcasts, 37\nreading tags, 293\nProtected Extensible Authentication\nregistering for tag dispatch,\nProtocol (PEAP), 243, 246\n291–292\nprotection levels\ntag technologies, 292–293\ndangerous, 25\nREAD_EXTERNAL_STORAGE permission, 111\ndefined, 24\nREAD_LOGS permission, 39\nnormal, 24–25\nread-only partition, 10\nsignature, 10, 26\nREAD_SMS permission, 25\nsignatureOrSystem, 26, 63\nread-write partition, 11\nProvider class, 118\nrecovery binary, 356–357\nproviders\nrecovery OS, 253–254, 354–364\nAndroidKeyStoreProvider, 188–189\ncustom recoveries, 363–364\ncryptography\nstock recovery, 354–363\nAndroidOpenSSL, 140–142\napplying updates, 359–360\nBouncy Castle, 137–140\ncontrolling, 356–357\nCrypto, 137\ncopying and patching files, 361\n394 Index\nfinishing updates, 361–362 root access, 364–376\nOTA signature verification, engineering builds, 365–368\n357–358 starting ADB as root, 365–367\nsetting file ownership, using su command, 367–368\npermissions, and security production builds, 368–376\nlabels, 361 changing boot or system\nsideloading OTA image, 369\npackages, 357 flashing OTA packages,\nstarting system update 370–375\nprocess, 358–359 via exploits, 375–376\nupdating recovery, 362–363 root user, 65\nRecoverySystem class, 357 ro.secure property, 369\nreference counting, 9 RPC (remote procedure calls), 5\nreference implementation (RI), 138 RSA algorithm, 55, 120, 139, 141, 255,\nregistration authority (RA), 149 257, 357\nrelabelto permission, 343 runcon utility, 333\n@RELEASE macro, 339 run_program function, 359\nremote procedure calls (RPC), 5 runtime libraries, 4\nremoveAccount() method, 197, 201 R/W mode. See reader/writer mode\nremoveActiveAdmin() method, 224\nremoveProvider() method, 118 S\nrequesting permissions, 22\nS2C (SignalIn/SignalOut\nRequests for Comments (RFCs), 125\nconnection), 299\nrequireDeviceUnlock attribute, 312\nresetPassword() method, 221, 222 salt attribute, 98\nsame origin policy, 16\n<reset-password> tag, 216\nsandboxing, app, 12–14\nresource attribute, 194\nSA (Security Association), 230\nresourcePath attribute, 71\nResources class, 52 saveLockPassword() method, 275\nrestorecon command, 333, 335 saveLockPattern() method, 272\nrestrictedAccountType attribute, scanPackageLI() method, 68, 75\n94, 203 SCM_CREDENTIALS control message, 32\nscreen security, 268–277\nrestricted profiles\nbrute-force attack protection,\naccess to online accounts, 94\n276–277\napplying restrictions, 93–94\nkeyguard unlock methods,\nuser restrictions, 92\n269–277\nrevokePermission() method, 48\nFace Unlock, 271\nrevokeUriPermission() method, 48\nPassword unlock, 270,\nRFCs (Requests for Comments), 125\n273–275\nRFID (radio-frequency identification)\nPattern unlock, 270, 272–273\ntechnology, 290\nPIN unlock, 270–271, 273–\nrild (radio interface) daemon, 275\n275, 275–276\nRI (reference implementation), 138\nPUK unlock, 271, 275–276\nRNG (Random Number\nSlide unlock, 270\nGenerator), 120\nlockscreen implementation,\nro.crypto.fs_crypto_blkdev property,\n268–269\n264, 267\nscrypt key derivation function, 261\nro.crypto.state property, 263\nSD card, 104\nro.debuggable property, 369\nseclabel command, 333, 334\nIndex 395\nsecondary users, 91–92 seinfo command, 341\nSecretKeyEntry, 133 seinfo tag, 30, 68, 338–339\nSecretKeyFactory class, 130–131, 140 self keyword, 329\nSecretKey interface, 128–129 SELinux (Security-Enhanced Linux),\nsecure elements (SEs), 179, 295–309. 319–347\nSee also host-based card access vector rules, 329–330\nemulation allow rule, 329\nembedded, 298–301 auditallow rule, 330\nbroadcasts, 301–302 dontaudit rule, 330\ngranting access to, 299–300 neverallow rule, 330\nNfcExecutionEnvironment class, Android 4.4 policy, 340–347\n300–301 app domains, 345–347\nexecution environment, 302–305 enforcing domains, 342–344\nquerying, 304–305 overview, 341–342\nmicroSD-based SEs, 298 unconfined domains,\nUICCs, 297–298, 305–309 344–345\naccessing, 307–308 architecture of, 320–321\napplication implementation defined, 17\nand installation, 307 domain transition rules, 328\napplications, 306–307 implementation, 330–340\nSIM cards and, 305–306 device policy files, 339–340\nusing OpenMobile API, kernel changes, 331–332\n308–309 policy event logging, 340\nSecureRandom class, 120–121, 137, 142 userspace changes, 332–339\nSecure Socket Layer. See SSL mandatory access control,\nSecurity Association (SA), 230 319–323\nsecurity contexts (labels), 322–323 modes, 322\nassignment and persistence, 324 security contexts (labels), 322–323\nlabeling assignment and\napplication processes, persistence, 324\n336–338 security model, 17\nfiles, 334–335 security policy, 324–328\nsystem properties, 335–336 object class and permission\nSecurity-Enhanced Linux. statements, 326–327\nSee SELinux type and attribute\nSecurityException, 36 statements, 325\nsecurity model user and role statements, 325\napplication sandboxing, 12–14 type transition rules, 327–328\ncode signing, 16 sendBroadcast() method, 37, 45\nIPC, 15–16 --send_intent option, 356\nmulti-user support, 16–17 sendResponseApdu() method, 316\noverview, 12 serialNumber attribute, 98\npermissions, 14–15 Server Name Indication (SNI), 156\nplatform keys, 16 Service Provider Interface (SPI), 117\nSELinux, 17 services\nsystem updates, 17–18 app architecture, 11–12\nverified boot, 18–20 permissions enforcement, 36\nsecurity.properties file, 118 SEs. See secure elements\nsedispol command, 341 sesearch command, 341, 342\nSEEK for Android project, 297, 308 SEService class, 308–309\n396 Index\nsetActiveAdmin() method, 219 signature files, 54\nsetAuthToken() method, 196 signatureOrSystem protection level,\nsetCameraDisabled() method, 223 26, 63\nsetcon command, 333 signature permissions, 39\nsetDefaultSSLSocketFactory() signature protection level, 10, 26\nmethod, 154 SIGN_DATA command, 178\nsetDeviceOwner() method, 225 sign_data() method, 177\nsetenforce command, 333 SIMalliance Open Mobile API\n<set-global-proxy> tag, 216 specification, 297\nsetGrant() method, 187 SIM cards. See also UICCs\nset-group-ID (SGID), 12 multi-user support, 91\nsetKeyguardDisabledFeatures() UICCs and, 305–306\nmethod, 223 unlocking, 18\nsetMaximumFailedPasswordsForWipe() Simple NDEF Exchange Protocol\nmethod, 222 (SNEP) protocol, 294\nsetMaximumTimeToLock() method, 222 SIM Toolkit (STK) applications, 307\nset_metadata function, 359 Single Wire Protocol (SWP), 298\nset_metadata_recursive function, Slide unlock method, 270\n359, 361 SmartCard API, 297–298\nsetNdefPushMessageCallback() SMARTCARD permission, 309\nmethod, 295 SmartcardService, 308–309\nsetNdefPushMessage() method, 295 SNEP (Simple NDEF Exchange\nsetPasswordExpirationTimeout() Protocol) protocol, 294\nmethod, 223 SNI (Server Name Indication), 156\nsetPassword() method, 196, 200 SoC (system on a chip), 178\nsetsebool command, 333 software card emulation. See host-\nsetSeed() method, 121 based card emulation\nsetSSLSocketFactory() method, 154 SO_PEERCRED socket option, 32\nsetStorageEncryption() method, 223 SPI (Service Provider Interface), 117\nsetUserData() method, 196 Spongy Castle provider, 143–144\nset-user-ID (SUID), 12 spyware, 83\nSGID (set-group-ID), 12 SQLite, 99\nSHA-1 algorithm, 137, 139, 141, 358 SSLContext class, 151\nSHA1PRNG algorithm, 137, 142 SSLEngine class, 151\nSHA1withDSA algorithm, 137 SSL Observatory project, 167\nSHA-256 algorithm, 117, 120, 127, SSL (Secure Socket Layer)\n139, 141, 259, 358 certificate revocation, 150–151\nshared_accounts table, 200, 202 direct trust and private CAs, 148\n@SHARED macro, 339 PKI, 148–150\nshared user ID, 40–42 public key certificates, 146–147\nsharedUserId attribute, 71 SSL-based VPNs, 230–231\nsharpening, 69 SSLServerSocket class, 152\nshow_progress function, 359 SSLSocket class, 152\n--show_text option, 356 SSLSocketFactory class, 154\n-sigfile option, 57 --stages option, 356\nSignalIn/SignalOut connection startActivityForResult() method,\n(S2C), 299 36, 44\nsignapk tool, 58, 60 startActivity() method, 36, 44\nSignature class, 73, 122–123, 137, sticky broadcasts, 37\n140, 142 STK (SIM Toolkit) applications, 307\nIndex 397\nstore() method, 135 TE (type enforcement), 321–322, 341\nStrictJarFile class, 67 Timestamping Authority (TSA), 57\nsu command, 367–368, 372–373 TLS (Transport Layer Security), 145\nSUID (set-user-ID), 12 TOFU (Trust on First Use), 72, 167\nSuperSU application, 370–372 tokens, Binder, 7–8\ninitializing, 372–374 towelroot exploit, 375\nsuperuser, 64 TPMs (Trusted Platform\nsupplyPinReportResult() method, 275 Modules), 179\nsupplyPukReportResult() method, 276 transceive() method, 303\nsurfaceflinger daemon, 345 translateKey() method, 130\nSWP (Single Wire Protocol), 298 transmit() method, 308\nsymlink function, 359 Transport Layer Security (TLS), 145\nsymmetric encryption, 123 trust anchors, 148\nsystem Trust Assertions for Certificate Keys\napps, 10 (TACK), 168–169\ncredential store, 173–174 TrustedCertificateEntry class, 133\npermissions TrustedCertificateStore class, 157, 187\ndevelopment permissions, Trusted Platform Modules\n39–40 (TPMs), 179\noverview, 37–39 TrustManager class, 153\nsignature permissions, 39 TrustManagerFactory class, 152, 159\nservices, 4 Trust on First Use (TOFU), 72, 167\nsystem_data_file type, 325 trustStore property, 156\nsystem on a chip (SoC), 178 TrustZone, 179\nsystem partition, 10 TSA (Timestamping Authority), 57\nsystem trust stores two-factor authentication (2FA), 207\nAndroid 4.x, 157–158 TWRP (Team Win Recovery\nAPIs, 161–162 Project), 363\noverview, 156–157 TYPE_ANY, 176\nusing, 158–161 type enforcement (TE), 321–322, 341\nsystem updates, 17–18, 349–364 TYPE_GENERIC, 176\nbootloader program, 350–354 TYPE_KEY_PAIR, 176\nfastboot mode, 352–354 TYPE_MASTER_KEY, 176\nunlocking, 350–352 type statement, 325\nrecovery OS, 354–364 type_transition rule, 327–328\ncustom recoveries, 363–364\nstock recovery, 354–363 U\nueventd daemon, 334\nT\nUICCs (Universal Integrated Circuit\nTACK (Trust Assertions for Cards), 180, 296, 297–298,\nCertificate Keys), 168–169 305–309\nTAG_DISCOVERED intent, 292 accessing, 307–308\n--tag parameter, 78 application implementation and\nTeam Win Recovery Project installation, 307\n(TWRP), 363 applications, 306–307\nTECH_DISCOVERED intent, 292 SIM cards and, 305–306\n<tech-list> element, 292 using OpenMobile API, 308–309\ntethering, 91\n398 Index\nUIDs external storage\nassociating permissions with, 27 Android implementation,\nLinux UIDs and, 88 106–111\nmulti-user support, 16 Linux mount features,\nsharing, 14 105–106\nui_print function, 359 overview, 104–105\numount function, 359 permissions, 111–112\nunconfineddomain domain, 344–345 metadata\nuninstallCaCert() method, 226 user list file, 96–97\nUniversal Integrated Circuit Cards. user metadata files, 97–98\nSee UICCs user system directory, 99\nUnknown Sources multi-user support\nmulti-user support and, 91, 92 features of, 112\nPackageInstaller and, 63, 66 overview, 87–89\nunshare() method, 106 user types\nUnsupportedOperationException, 203 guest user, 94–95\nuntrusted_app type, 325, 346 primary user, 90–91\nUNWRAP_MODE, 126 restricted profiles, 92–93\nupdateCredentials() method, 197 secondary users, 91–92\nupdate() method, 122 UserManager API, 88\n--update_package option, 356 UserManagerService, 95\nUPDATE_PINS broadcast, 170 USER_STARTED broadcast, 96\nupdates. See system updates USER_STARTING broadcast, 96\nUSB user statement, 325\nmulti-user support, 92 USER_STOPPED broadcast, 96\nsecure debugging, 277–283 USER_STOPPING broadcast, 96\nauthentication keys, 282 USES_ENCRYPTED_STORAGE constant,\ndaemon overview, 277–279 217, 223\nimplementation, 281–282 <uses-policies> tag, 218\nneed for, 279–280 USES_POLICY_DISABLE_CAMERA constant,\nsecuring, 280 217, 223\nverifying host key fingerprint, USES_POLICY_DISABLE_KEYGUARD_FEATURES\n282–283 constant, 217, 223\nUsbDebuggingActivity, 281 USES_POLICY_EXPIRE_PASSWORD constant,\nUsbDeviceManager class, 282 217, 223\nUSE_CREDENTIALS permission, 197, 198 USES_POLICY_FORCE_LOCK constant,\nuserdata partition, 11 216, 222\ndecrypting and mounting, 267 USES_POLICY_LIMIT_PASSWORD constant,\nunmounting for encryption, 264 216, 221\nuserId attribute, 71 USES_POLICY_RESET_PASSWORD constant,\nuser-installed apps, 11 216, 218, 222\nuserlists.xml file, 97 USES_POLICY_SETS_GLOBAL_PROXY\nuser management constant, 216, 222\napp management USES_POLICY_WATCH_LOGIN constant, 216,\napplication sharing, 101–104 221, 222\ndata directories, 100–101 USES_POLICY_WIPE_DATA constant,\noverview, 99 216, 222\nbroadcasts and, 95–96 ut attribute, 71\ncommand-line tools, 95\nIndex 399\nV W\nvalidate() method, 136 wakelocks, 2\nVerificationParams class, 78 <watch-login> tag, 216\nverified boot feature, 18–20, 254–258 WebView control, 210\nenabling, 256–258 Wi-Fi\nimplementation, 255–256 EAP credentials\noverview, 254–255 authentication keys and\nVERIFY_DATA command, 179 certificates, 172–173\nverify_data() method, 177 overview, 172\nverify flag, 255 system credential store,\nverify() method, 123, 154 173–174\nverifyPackage() method, 357 EAP framework, 242–250\nverifyPendingInstall() method, 85 adding networks with\nverity metadata block, 257 WifiManager API, 248–250\nversion attribute, 71, 97 Android Wi-Fi architecture,\nVFS (Virtual Filesystem), 105 244–245\nvirtual private networks. See VPNs authentication methods,\nvold daemon, 263, 267, 342 243–244\nvold_prop type, 336 credentials management,\nVPNs (virtual private networks), 245–248\n227–250 multi-user support and, 91\napplication-based, 236–239 user restrictions, 92\ndeclaring, 237–238 WifiConfiguration class, 248\nestablishing connection, 238 wifi_data_file type, 327\nnotifying user about WifiEnterpriseConfig class, 249\nconnection, 238–239 WifiManager API, 248–250\npreparing, 238 WifiManager class, 245\nconfiguration screen for, 91 Wi-Fi Protected Access II (WPA2), 242\nEAP credentials Wi-Fi Protected Access (WPA), 242\nauthentication keys and WifiService, 245\ncertificates, 172–173 WifiStateMachine class, 245\noverview, 172 WiMAX, 91\nsystem credential store, --wipe_cache option, 356, 361\n173–174 <wipe-data> tag, 216\nL2TP, 229–230 wipeData() method, 222\nlegacy, 231–236 --wipe_data option, 356\naccessing credentials, 234 wiping user data, 222\nalways-on, 235–236 -w option, 60\nimplementation, 231–233 WPA2 (Wi-Fi Protected Access II), 242\nprofile and credential storage, wpa_socket type, 327\n233–234 wpa_supplicant daemon, 244–246, 327\nmulti-user support, 239–242 WPA (Wi-Fi Protected Access), 242\nimplementation, 240–241 WRAP_MODE, 126\nLinux advanced routing, WRITE_CONTACTS permission, 47\n239–240 WRITE_EXTERNAL_STORAGE permission, 23,\nPPTP, 229 104, 111\nSSL-based, 230–231 write_raw_image function, 359\nXauth, 230 WRITE_SECURE_SETTINGS permission,\nVpnService class, 236–238 39, 299\n400 Index\nX\nX.509-based PKI (PKIX), 138, 152\nX.509 certificates, 130, 135, 138, 141,\n143, 146, 357\nX509ExtendedKeyManager interface, 153\nX509KeyManager interface, 153\nX509_NAME_hash_old() function, 157\nX509TrustManagerExtensions class, 169\nX509TrustManager interface, 153\nXauth (IPSec Extended\nAuthentication), 230\nXTS (XEX-based tweaked-codebook\nmode with ciphertext\nstealing), 260\nZ\nZIP format, 52, 353\n-Z option, 323, 333\nZygoteConnection class, 336\nzygote process, 28, 107, 336, 342, 345\nIndex 401\nAndroid Security Internals is set in New Baskerville, Futura, TheSansMono\nCondensed, and Dogma. The book was printed and bound by Lake Book\nManufacturing in Melrose Park, Illinois. The paper is 60# Husky Opaque\nOffset Smooth, which is certified by the Sustainable Forestry Initiative (SFI).\nThe book uses a layflat binding, in which the pages are bound together\nwith a cold-set, flexible glue and the first and last pages of the resulting book\nblock are attached to the cover. The cover is not actually glued to the book’s\nspine, and when open, the book lies flat and the spine doesn’t crack.",
    "question": "What is the key topic or concept discussed in the provided text?",
    "summary": "Android Security Internals is a book that explores the security mechanisms within the Android operating system. It covers topics such as encryption, authentication, and access control, providing an in-depth look at how Android secures data and user interactions. The book is printed using environmentally certified paper and uses a layflat binding for easy readability."
  },
  {
    "start": 217,
    "end": 217,
    "text": "Updates\nVisit http://www.nostarch.com/androidsecurity/ for updates, errata, and\nother information.\nMore no-nonsense books from nO starcH press\niOs applicatiOn secUrity Black Hat pytHOn metasplOit\nthe definitive Guide for python programming for the penetration tester’s Guide\nHackers and developers Hackers and pentesters by david kennedy, jim o’gorman,\nby david thiel by justin seitz devon kearns, and mati aharoni\njanuary 2015, 352 pp., $49.95 november 2014, 216 pp., $34.95 july 2011, 328 pp., $49.95\nisbn 978-1-59327-601-0 isbn 978-1-59327-590-7 isbn 978-1-59327-288-3\npractical malware tHe practice Of netwOrk tHe ida prO BOOk,\nanalysis secUrity mOnitOrinG 2nd editiOn\nthe Hands-On Guide to dissecting Understanding incident detection the Unofficial Guide to the world’s\nmalicious software and response most popular disassembler\nby michael sikorski and by richard bejtlich by chris eagle\nandrew honig july 2013, 376 pp., $49.95 july 2011, 672 pp., $69.95\nfebruary 2012, 800 pp., $59.95 isbn 978-1-59327-509-9 isbn 978-1-59327-289-0\nisbn 978-1-59327-290-6\nphone: email:\n800.420.7240 or sales@nostarch.com\n415.863.9900 web:\nwww.nostarch.com\nAndroid Security\nA Deep Dive into Android Security\nInternals\nThere are more than one billion Android About the online account management\ndevices in use today, each one a potential framework and how Google accounts\ntarget. Unfortunately, many fundamental integrate with Android\nAndroid security features have been little\nAbout the implementation of verified boot,\nmore than a black box to all but the most\ndisk encryption, lockscreen, and other\nelite security professionals—until now.\ndevice security features\nIn Android Security Internals, top Android\nHow Android’s bootloader and recovery OS\nsecurity expert Nikolay Elenkov takes us\nare used to perform full system updates,\nunder the hood of the Android security sys­\nand how to obtain root access\ntem. Elenkov describes Android security archi­\ntecture from the bottom up, delving into the\nWith its unprecedented level of depth and\nimple mentation of major security­related\ndetail, Android Security Internals is a must­\ncomponents and subsystems, like Binder IPC,\nhave for any security­minded Android\npermissions, cryptographic providers, and\ndeveloper.\ndevice administration.\nYou’ll learn: About the Author\nHow Android permissions are declared,\nused, and enforced Nikolay Elenkov has been working on\nenter prise security–related projects for\nHow Android manages application more than 10 years. He became interested\npackages and employs code signing to in Android shortly after the initial public\nverify their authenticity release and has been developing Android\napplications since version 1.5. His work\nHow Android implements the Java Cryp ­\nhas led to the discovery and correction\ntog raphy Architecture (JCA) and Java Secure\nof significant Android security flaws. He\nSocket Extension (JSSE) frameworks\nwrites about Android security on his highly\nAbout Android’s credential storage system regarded blog, http://nelenkov.blogspot.com/.\nand APIs, which let applications store\ncryptographic keys securely\nElenkov\nTHE FINEST IN GEEK ENTERTAINMENT™\nwww.nostarch.com\n$49.95 ($51.95 CDN) Shelve In: ComputerS/SeCurIty Nikolay Elenkov\nForeword by Jon Sawyer\nAndroid\nSecurity\nInternals\nCovers Android 4.4\nAn In-Depth Guide to\nAndroid’s Security Architecture\n“I LIE FLAT.” This book uses a durable binding that won’t snap shut.\nSFI-00000",
    "question": "What is the main focus of the book \"Android Security Internals\"?",
    "summary": "Android Security Internals is a comprehensive guide that explores the inner workings of Android's security system, including key components like permissions, cryptography, and verified boot. Written by top Android security expert Nikolay Elenkov, it provides essential insights for developers and security professionals. The book covers Android 4.4 and includes detailed information on device security features and how they integrate with Google accounts."
  }
]