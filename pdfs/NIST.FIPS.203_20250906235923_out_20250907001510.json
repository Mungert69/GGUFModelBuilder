[
  {
    "input": "What is FIPS 203 and what does it standardize in the field of computer security?",
    "summary": "FIPS 203 is a U.S. federal standard for a lattice-based key-encapsulation mechanism in cryptography. It was published by the National Institute of Standards and Technology on August 13, 2024. The standard is available for free at the provided DOI link.",
    "output": "FIPS 203\nFederal Information Processing Standards Publication\nModule-Lattice-Based\nKey-Encapsulation Mechanism Standard\nCategory: Computer Security Subcategory: Cryptography\nInformation Technology Laboratory\nNational Institute of Standards and Technology\nGaithersburg, MD 20899-8900\nThis publication is available free of charge from:\nhttps://doi.org/10.6028/NIST.FIPS.203\nPublished August 13, 2024\nU.S. Department of Commerce\nGina M. Raimondo, Secretary\nNational Institute of Standards and Technology\nLaurie E. Locascio, NIST Director and Under Secretary of Commerce for Standards and Technology"
  },
  {
    "input": "What is ML-KEM and what cryptographic problem does its security rely on?",
    "summary": "This document outlines the FIPS 203 standard for a lattice-based key-encapsulation mechanism called ML-KEM, which is secure against quantum computing attacks. It describes the three parameter sets (ML-KEM-512, ML-KEM-768, and ML-KEM-1024) and the process of establishing a shared secret key between two parties. The standard also includes information on implementation, security requirements, and how to obtain and cite the publication.",
    "output": "Foreword\nThe Federal Information Processing Standards (FIPS) Publication Series of the National Institute of Stan-\ndards and Technology is the official series of publications relating to standards and guidelines developed\nunder 15 U.S.C. 278g-3, and issued by the Secretary of Commerce under 40 U.S.C. 11331.\nComments concerning this Federal Information Processing Standard publication are welcomed and should\nbe submitted using the contact information in the “Inquiries and Comments” clause of the announcement\nsection.\nKevin M. Stine, Director\nInformation Technology Laboratory\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nAbstract\nA key-encapsulation mechanism (KEM) is a set of algorithms that, under certain conditions, can be\nused by two parties to establish a shared secret key over a public channel. A shared secret key that\nis securely established using a KEM can then be used with symmetric-key cryptographic algorithms\nto perform basic tasks in secure communications, such as encryption and authentication. This\nstandard specifies a key-encapsulation mechanism called ML-KEM. The security of ML-KEM is\nrelated to the computational difficulty of the Module Learning with Errors problem. At present,\nML-KEM is believed to be secure, even against adversaries who possess a quantum computer.\nThis standard specifies three parameter sets for ML-KEM. In order of increasing security strength\nand decreasing performance, these are ML-KEM-512, ML-KEM-768, and ML-KEM-1024.\nKeywords: computer security; cryptography; encryption; Federal Information Processing Stan-\ndards; key-encapsulation mechanism; lattice-based cryptography; post-quantum; public-key\ncryptography.\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nFederal Information Processing Standards Publication 203\nPublished: August 13, 2024\nEffective: August 13, 2024\nAnnouncing the\nModule-Lattice-Based Key-Encapsulation\nMechanism Standard\nFederal Information Processing Standards (FIPS) publications are developed by the National\nInstitute of Standards and Technology (NIST) under 15 U.S.C. 278g-3 and issued by the Secretary\nof Commerce under 40 U.S.C. 11331.\n1. Name of Standard. Module-Lattice-Based Key-Encapsulation Mechanism Standard (FIPS\n203).\n2. Category of Standard. Computer Security. Subcategory. Cryptography.\n3. Explanation. A cryptographic key (or simply “key”) is represented in a computer as a string of\nbits. A shared secret key is a cryptographic key that is computed jointly by two parties (e.g.,\nAlice and Bob) using a set of algorithms. Under certain conditions, these algorithms ensure\nthat both parties will produce the same key and that this key is secret from adversaries. Such\na shared secret key can then be used with symmetric-key cryptographic algorithms (specified\nin other NIST standards) to perform tasks such as encryption and authentication of digital\ninformation.\nThis standard specifies a set of algorithms for establishing a shared secret key. While there\nare many methods for establishing a shared secret key, the particular method described in\nthis standard is a key-encapsulation mechanism (KEM).\nIn a KEM, the computation of the shared secret key begins with Alice generating a decapsu-\nlation key and an encapsulation key. Alice keeps the decapsulation key private and makes\nthe encapsulation key available to Bob. Bob then uses Alice’s encapsulation key to generate\none copy of a shared secret key along with an associated ciphertext. Bob then sends the\nciphertext to Alice. Finally, Alice uses the ciphertext from Bob along with Alice’s private\ndecapsulation key to compute another copy of the shared secret key.\nThe security of the particular KEM specified in this standard is related to the computational\ndifficulty of solving certain systems of noisy linear equations, specifically the Module Learn-\ning With Errors (MLWE) problem. At present, it is believed that this particular method of\nestablishing a shared secret key is secure, even against adversaries who possess a quantum\ncomputer. In the future, additional KEMs may be specified and approved in FIPS publications\nor in NIST Special Publications.\n4. Approving Authority. Secretary of Commerce.\n5. Maintenance Agency. Department of Commerce, National Institute of Standards and Tech-\nnology, Information Technology Laboratory (ITL).\ni\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n6. Applicability. Federal Information Processing Standards apply to information systems used or\noperated by federal agencies or by a contractor of an agency or other organization on behalf\nof an agency. They do not apply to national security systems as defined in 44 U.S.C. 3552.\nThis standard, or other FIPS or NIST Special Publications that specify alternative mechanisms,\nshall be used wherever the establishment of a shared secret key (or shared secret from which\nkeying material can be generated) is required for federal applications, including the use of\nsuch a key with symmetric-key cryptographic algorithms, in accordance with applicable Office\nof Management and Budget and agency policies.\nThe adoption and use of this standard are available to private and commercial organizations.\n7. Implementations. A key-encapsulation mechanism may be implemented in software, firmware,\nhardware, or any combination thereof. For every computational procedure that is specified\nin this standard, a conforming implementation may replace the given set of steps with any\nmathematically equivalent set of steps. In other words, different procedures that produce\nthe correct output for every input are permitted.\nNIST will develop a validation program to test implementations for conformance to the\nalgorithms in this standard. Information about validation programs is available at https:\n//csrc.nist.gov/projects/cmvp. Example values will be available at https://csrc.nist.gov/proj\nects/cryptographic-standards-and-guidelines/example-values.\n8. Other Approved Security Functions. Implementations that comply with this standard\nshall employ cryptographic algorithms that have been approved for protecting Federal\nGovernment-sensitive information. Approved cryptographic algorithms and techniques\ninclude those that are either:\n(a) Specified in a Federal Information Processing Standards (FIPS) publication,\n(b) Adopted in a FIPS or NIST recommendation, or\n(c) Specified in the list of approved security functions in SP 800-140C.\n9. Export Control. Certain cryptographic devices and technical data regarding them are subject\nto federal export controls. Exports of cryptographic modules that implement this standard\nand technical data regarding them must comply with all federal laws and regulations and\nbe licensed by the Bureau of Industry and Security of the U.S. Department of Commerce.\nInformation about export regulations is available at https://www.bis.doc.gov.\n10. Patents. NIST has entered into two patent license agreements to facilitate the adoption of\nNIST’s announced selection of the PQC key-encapsulation mechanism CRYSTALS-KYBER. NIST\nand the licensing parties share a desire, in the public interest, the licensed patents be freely\navailable to be practiced by any implementer of the ML-KEM algorithm as published by NIST.\nML-KEM is the name given to the algorithm in this standard derived from CRYSTALS-KYBER.\nFor a summary and extracts from the license, please see https://csrc.nist.gov/csrc/media/P\nrojects/post-quantum-cryptography/documents/selected-algos-2022/nist-pqc-license-sum\nmary-and-excerpts.pdf. Implementation of the algorithm specified in the standard may be\ncovered by U.S. and foreign patents of which NIST is not aware.\nii\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n11. Implementation Schedule. This standard becomes effective immediately upon final publica-\ntion.\n12. Specifications. Federal Information Processing Standards (FIPS) 203, Module-Lattice-Based\nKey-Encapsulation Mechanism Standard (affixed).\n13. Qualifications. In applications, the security guarantees of a KEM only hold under certain\nconditions (see SP 800-227 [1]). One such condition is the secrecy of several values, including\nthe randomness used by the two parties, the decapsulation key, and the shared secret key\nitself. Users shall, therefore, guard against the disclosure of these values.\nWhile it is the intent of this standard to specify general requirements for implementing\nML-KEM algorithms, conformance to this standard does not ensure that a particular imple-\nmentation is secure. It is the responsibility of the implementer to ensure that any module\nthat implements a key establishment capability is designed and built in a secure manner.\nSimilarly, the use of a product containing an implementation that conforms to this standard\ndoes not guarantee the security of the overall system in which the product is used. The re-\nsponsible authority in each agency or department shall ensure that an overall implementation\nprovides an acceptable level of security.\nNIST will continue to follow developments in the analysis of the ML-KEM algorithm. As with\nits other cryptographic algorithm standards, NIST will formally reevaluate this standard every\nfive years.\nBoth this standard and possible threats that reduce the security provided through the use of\nthis standard will undergo review by NIST as appropriate, taking into account newly available\nanalysis and technology. In addition, the awareness of any breakthrough in technology or\nany mathematical weakness of the algorithm will cause NIST to reevaluate this standard and\nprovide necessary revisions.\n14. Waiver Procedure. The Federal Information Security Management Act (FISMA) does not allow\nfor waivers to Federal Information Processing Standards (FIPS) that are made mandatory by\nthe Secretary of Commerce.\n15. Where to Obtain Copies of the Standard. This publication is available by accessing https:\n//csrc.nist.gov/publications. Other computer security publications are available at the same\nwebsite.\n16. How to Cite This Publication. NIST has assigned NIST FIPS 203 as the publication identifier\nfor this FIPS, per the NIST Technical Series Publication Identifier Syntax. NIST recommends\nthat it be cited as follows:\nNational Institute of Standards and Technology (2024) Module-Lattice-Based Key-\nEncapsulation Mechanism Standard. (Department of Commerce, Washington,\nD.C.), Federal Information Processing Standards Publication (FIPS) NIST FIPS 203.\nhttps://doi.org/10.6028/NIST.FIPS.203\n17. Inquiries and Comments. Inquiries and comments about this FIPS may be submitted to\nfips-203-comments@nist.gov.\niii\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nFederal Information Processing Standards Publication 203\nSpecification for the\nModule-Lattice-Based Key-Encapsulation\nMechanism Standard\nTable of Contents\n1 Introduction 1\n1.1 Purpose and Scope 1\n1.2 Context 1\n2 Terms, Acronyms, and Notation 2\n2.1 Terms and Definitions 2\n2.2 Acronyms 4\n2.3 Mathematical Symbols 5\n2.4 Interpreting the Pseudocode 6\n2.4.1 Data Types 7\n2.4.2 Loop Syntax 7\n2.4.3 Arithmetic With Arrays of Integers 7\n2.4.4 Representations of Algebraic Objects 8\n2.4.5 Arithmetic With Polynomials and NTT Representations 9\n2.4.6 Matrices and Vectors 9\n2.4.7 Arithmetic With Matrices and Vectors 10\n2.4.8 Applying Algorithms to Arrays, Examples 11\n3 Overview of the ML-KEM Scheme 12\n3.1 Key-Encapsulation Mechanisms 12\n3.2 The ML-KEM Scheme 13\n3.3 Requirements for ML-KEM Implementations 15\n4 Auxiliary Algorithms 18\n4.1 Cryptographic Functions 18\n4.2 General Algorithms 20\n4.2.1 Conversion and Compression Algorithms 20\n4.2.2 Sampling Algorithms 22\n4.3 The Number-Theoretic Transform 24\niv\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n4.3.1 Multiplication in the NTT Domain 27\n5 The K-PKE Component Scheme 28\n5.1 K-PKE Key Generation 28\n5.2 K-PKE Encryption 29\n5.3 K-PKE Decryption 31\n6 Main Internal Algorithms 32\n6.1 Internal Key Generation 32\n6.2 Internal Encapsulation 32\n6.3 Internal Decapsulation 33\n7 The ML-KEM Key-Encapsulation Mechanism 35\n7.1 ML-KEM Key Generation 35\n7.2 ML-KEM Encapsulation 36\n7.3 ML-KEM Decapsulation 37\n8 Parameter Sets 39\nReferences 41\nAppendix A — Precomputed Values for the NTT 44\nAppendix B — SampleNTT Loop Bounds 46\nAppendix C — Differences From the CRYSTALS-KYBER Submission 47\nC.1 Differences Between CRYSTALS-KYBER and FIPS 203 Initial Public Draft 47\nC.2 Changes From FIPS 203 Initial Public Draft 47\nv"
  },
  {
    "input": "What is ML-KEM and why is it considered a secure alternative for key establishment in the context of quantum computing?",
    "summary": "This document outlines the Module-Lattice-Based Key-Encapsulation Mechanism (ML-KEM), a quantum-resistant alternative to traditional key-establishment schemes. It details the algorithms and parameter sets for ML-KEM, which is based on the Module Learning With Errors assumption and is approved for use in U.S. Federal Government communication systems. ML-KEM is derived from the CRYSTALS-KYBER KEM, a lattice-based mechanism selected by NIST for post-quantum cryptography standardization.",
    "output": "FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nList of Tables\nTable 1 Decapsulation failure rates for ML-KEM 15\nTable 2 Approved parameter sets for ML-KEM 39\nTable 3 Sizes (in bytes) of keys and ciphertexts of ML-KEM 39\nTable 4 While-loop limits and probabilities of occurrence for SampleNTT 46\nList of Figures\nFigure 1 A simple view of key establishment using a KEM 12\nList of Algorithms\nAlgorithm 1 ForExample() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8\nAlgorithm 2 SHAKE128example(str ,…,str ,𝑏 ,…,𝑏 ) . . . . . . . . . . . . . 19\n1 𝑚 1 ℓ\nAlgorithm 3 BitsToBytes(𝑏) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\nAlgorithm 4 BytesToBits(𝐵) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\nAlgorithm 5 ByteEncode (𝐹 ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n𝑑\nAlgorithm 6 ByteDecode (𝐵) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n𝑑\nAlgorithm 7 SampleNTT(𝐵) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\nAlgorithm 8 SamplePolyCBD (𝐵) . . . . . . . . . . . . . . . . . . . . . . . . . 23\n𝜂\nAlgorithm 9 NTT(𝑓) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\nAlgorithm 10 NTT −1(𝑓) ̂ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\nAlgorithm 11 MultiplyNTTs(𝑓, ̂ 𝑔)̂ . . . . . . . . . . . . . . . . . . . . . . . . . . 27\nAlgorithm 12 BaseCaseMultiply(𝑎 ,𝑎 ,𝑏 ,𝑏 ,𝛾) . . . . . . . . . . . . . . . . . . 27\n0 1 0 1\nAlgorithm 13 K-PKE.KeyGen(𝑑) . . . . . . . . . . . . . . . . . . . . . . . . . . . 29\nAlgorithm 14 K-PKE.Encrypt(ek ,𝑚,𝑟) . . . . . . . . . . . . . . . . . . . . . . . 30\nPKE\nAlgorithm 15 K-PKE.Decrypt(dk ,𝑐) . . . . . . . . . . . . . . . . . . . . . . . . 31\nPKE\nAlgorithm 16 ML-KEM.KeyGen_internal(𝑑,𝑧) . . . . . . . . . . . . . . . . . . . . 32\nAlgorithm 17 ML-KEM.Encaps_internal(ek,𝑚) . . . . . . . . . . . . . . . . . . . 33\nAlgorithm 18 ML-KEM.Decaps_internal(dk,𝑐) . . . . . . . . . . . . . . . . . . . . 34\nAlgorithm 19 ML-KEM.KeyGen() . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\nAlgorithm 20 ML-KEM.Encaps(ek) . . . . . . . . . . . . . . . . . . . . . . . . . . 37\nAlgorithm 21 ML-KEM.Decaps(dk,𝑐) . . . . . . . . . . . . . . . . . . . . . . . . 38\nvi\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n1. Introduction\n1.1 Purpose and Scope\nThis standard specifies the Module-Lattice-Based Key-Encapsulation Mechanism (ML-KEM). A\nkey-encapsulation mechanism (KEM) is a set of algorithms that can be used to establish a shared\nsecret key between two parties communicating over a public channel. A KEM is a particular type\nof key establishment scheme. Other NIST-approved key establishment schemes are specified\nin NIST Special Publication (SP) 800-56A, Recommendation for Pair-Wise Key-Establishment\nSchemes Using Discrete Logarithm-Based Cryptography [2], and SP 800-56B, Recommendation\nfor Pair-Wise Key Establishment Schemes Using Integer Factorization Cryptography [3].\nThe key establishment schemes specified in SP 800-56A and SP 800-56B are vulnerable to\nattacks that use sufficiently-capable quantum computers. ML-KEM is an approved alternative\nthat is presently believed to be secure, even against adversaries in possession of a large-scale\nfault-tolerant quantum computer. ML-KEM is derived from the round-three version of the\nCRYSTALS-KYBER KEM [4], a submission in the NIST Post-Quantum Cryptography Standardization\nproject. For the differences between ML-KEM and CRYSTALS-KYBER, see Appendix C.\nThis standard specifies the algorithms and parameter sets of the ML-KEM scheme. It aims\nto provide sufficient information to implement ML-KEM in a manner that can pass validation\n(see https://csrc.nist.gov/projects/cryptographic-module-validation-program). For\ngeneral definitions and properties of KEMs, including requirements for the secure use of KEMs\nin applications, see SP 800-227 [1].\nThis standard specifies three parameter sets for ML-KEM that offer different trade-offs in security\nstrength versus performance. All three parameter sets of ML-KEM are approved to protect\nsensitive, non-classified communication systems of the U.S. Federal Government.\n1.2 Context\nOver the past several years, there has been steady progress toward building quantum computers.\nIf large-scale quantum computers are realized, the security of many commonly used public-key\ncryptosystems will be at risk. This would include key-establishment schemes and digital signature\nschemes whose security depends on the difficulty of solving the integer factorization and discrete\nlogarithm problems (both over finite fields and elliptic curves). As a result, in 2016, NIST initiated\na public Post-Quantum Cryptography (PQC) Standardization process to select quantum-resistant\npublic-key cryptographic algorithms. A total of 82 candidate algorithms were submitted to NIST\nfor consideration.\nAfter three rounds of evaluation and analysis, NIST selected the first four algorithms for stan-\ndardization. These algorithms are intended to protect sensitive U.S. Government information\nwell into the foreseeable future, including after the advent of cryptographically-relevant quan-\ntum computers. This standard specifies a variant of the selected algorithm CRYSTALS-KYBER, a\nlattice-based key-encapsulation mechanism (KEM) designed by Peter Schwabe, Roberto Avanzi,\nJoppe Bos, Léo Ducas, Eike Kiltz, Tancrède Lepoint, Vadim Lyubashevsky, John Schanck, Gregor\nSeiler, Damien Stehlé, and Jintai Ding [4]. Throughout this standard, the KEM specified here will\nbe referred to as ML-KEM, as it is based on the Module Learning With Errors assumption.\n1"
  },
  {
    "input": "What is the difference between an encapsulation key and a decapsulation key in the context of a lattice-based key-encapsulation mechanism (KEM)?",
    "summary": "The text defines key terms and concepts related to lattice-based key-encapsulation mechanisms (KEM) in FIPS 203. It explains the roles of encapsulation and decapsulation keys, shared secrets, and cryptographic processes. It also outlines pseudocode conventions, including data types, loop syntax, and arithmetic operations on arrays, polynomials, and matrices.",
    "output": "FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n2. Terms, Acronyms, and Notation\n2.1 Terms and Definitions\napproved FIPS-approved and/or NIST-recommended. An algorithm or technique\nthat is either 1) specified in a FIPS or NIST recommendation, 2) adopted\nin a FIPS or NIST recommendation, or 3) specified in a list of NIST-approved\nsecurity functions.\n(KEM) ciphertext A bit string that is produced by encapsulation and used as an input to\ndecapsulation.\ncryptographic The set of hardware, software, and/or firmware that implements ap-\nmodule proved cryptographic functions (including key generation) that are con-\ntained within the cryptographic boundary of the module.\ndecapsulation The process of applying the Decaps algorithm of a KEM. This algorithm\naccepts a KEM ciphertext and the decapsulation key as input and pro-\nduces a shared secret key as output.\ndecapsulation key A cryptographic key produced by a KEM during key generation and used\nduring the decapsulation process. The decapsulation key must be kept\nprivate and must be destroyed after it is no longer needed. (See Section\n3.3.)\ndecryption key A cryptographic key that is used with a PKE in order to decrypt cipher-\ntexts into plaintexts. The decryption key must be kept private and must\nbe destroyed after it is no longer needed.\ndestroy An action applied to a key or other piece of secret data. After a piece\nof secret data is destroyed, no information about its value can be re-\ncovered.\nencapsulation The process of applying the Encaps algorithm of a KEM. This algorithm\naccepts the encapsulation key as input, requires private randomness,\nand produces a shared secret key and an associated ciphertext as out-\nput.\nencapsulation key A cryptographic key produced by a KEM during key generation and used\nduring the encapsulation process. The encapsulation key can be made\npublic. (See Section 3.3.)\nencryption key A cryptographic key that is used with a PKE in order to encrypt plaintexts\ninto ciphertexts. The encryption key can be made public.\nequivalent process Two processes are equivalent if the same output is produced when the\nsame values are input to each process (either as input parameters, as\nvalues made available during the process, or both).\nfresh random value An output that was produced by a random bit generator and has not\nbeen previously used.\n2\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nhash function A function on bit strings in which the length of the output is fixed.\nApproved hash functions (such as those specified in FIPS 180 [5] and\nFIPS 202 [6]) are designed to satisfy the following properties:\n1. (One-way) It is computationally infeasible to find any input that\nmaps to any new pre-specified output.\n2. (Collision-resistant) It is computationally infeasible to find any two\ndistinct inputs that map to the same output.\ninput checking Examination of a potential input to an algorithm for the purpose of\ndetermining whether it conforms to certain requirements.\nkey A bit string that is used in conjunction with a cryptographic algorithm,\nsuch as the encapsulation and decapsulation keys (of a KEM), the shared\nsecret key (produced by a KEM), and the encryption and decryption\nkeys (of a PKE). (See Section 3.3.)\nkey-encapsulation A set of three cryptographic algorithms (KeyGen, Encaps, and Decaps)\nmechanism (KEM) that can be used by two parties to establish a shared secret key over a\npublic channel.\nkey establishment A procedure that results in secret keying material that is shared among\ndifferent parties.\nkey pair A set of two keys with the property that one key can be made public\nwhile the other key must be kept private. In this standard, this could\nrefer to either the (encapsulation key, decapsulation key) key pair of a\nKEM or the (encryption key, decryption key) key pair of a PKE.\nlittle-endian The property of a byte string having its bytes positioned in order of\nincreasing significance. In particular, the leftmost (first) byte is the\nleast significant, and the rightmost (last) byte is the most significant.\nThe term “little-endian” may also be applied in the same manner to\nbit strings (e.g., the 8-bit string 11010001 corresponds to the byte\n20+21+23+27 =139).\nparty An individual person, organization, device, or process. In this specifica-\ntion, there are two parties (e.g., Party A and Party B, or Alice and Bob)\nwho jointly perform the key establishment process using a KEM.\npseudorandom A process (or data produced by a process) is said to be pseudorandom\nwhen the outcome is deterministic yet also appears random as long\nas the internal action of the process is hidden from observation. For\ncryptographic purposes, “effectively random” means “computationally\nindistinguishable from random within the limits of the intended security\nstrength.”\npublic channel A communication channel between two parties. Such a channel can be\nobserved and possibly also corrupted by third parties.\n3\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\npublic-key A set of three cryptographic algorithms (KeyGen, Encrypt, and Decrypt)\nencryption scheme that can be used by two parties to send secret data over a public channel.\n(PKE) Also known as an asymmetric encryption scheme.\nshared secret A secret value that has been computed during a key-establishment\nscheme, is known by both participants, and is used as input to a key-\nderivation method to produce keying material.\nshared secret key A shared secret that can be used directly as a cryptographic key in\nsymmetric-key cryptography. It does not require additional key deriva-\ntion. The shared secret key must be kept private and must be destroyed\nwhen no longer needed.\nsecurity category A number associated with the security strength of a post-quantum\ncryptographic algorithm, as specified by NIST (see [7]).\nsecurity strength A number associated with the amount of work (i.e., the number of op-\nerations) that is required to break a cryptographic algorithm or system.\nshall Used to indicate a requirement of this standard.\nshould Used to indicate a strong recommendation but not a requirement of\nthis standard. Ignoring the recommendation could lead to undesirable\nresults.\n2.2 Acronyms\nAES Advanced Encryption Standard\nCBD Centered Binomial Distribution\nFIPS Federal Information Processing Standard\nKEM Key-Encapsulation Mechanism\nLWE Learning with Errors\nMLWE Module Learning with Errors\nNIST National Institute of Standards and Technology\nNISTIR NIST Interagency or Internal Report\nNTT Number-Theoretic Transform\nPKE Public-Key Encryption\nPQC Post-Quantum Cryptography\nPRF Pseudorandom Function\nRBG Random Bit Generator\nSHA Secure Hash Algorithm\n4\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nSHAKE Secure Hash Algorithm KECCAK\nSP Special Publication\nXOF Extendable-Output Function\n2.3 Mathematical Symbols\n𝑛 Denotes the integer 256 throughout this document.\n𝑞 Denotes the prime integer 3329 = 28 ⋅13+1 throughout this document.\n𝜁 Denotes the integer 17, which is a primitive 𝑛-th root of unity modulo 𝑞.\n𝔹 The set {0,1,…,255} of unsigned 8-bit integers (bytes).\nℚ The set of rational numbers.\nℤ The set of integers.\nℤ The ring of integers modulo 𝑚 (i.e., the set {0,1,…,𝑚 − 1} equipped with\n𝑚\nthe operations of addition and multiplication modulo 𝑚.)\nℤ𝑛 The set of 𝑛-tuples over ℤ equipped with ℤ -module structure. As a data\n𝑚 𝑚 𝑚\ntype, this is the set of length-𝑛 arrays whose entries are in ℤ .\n𝑚\n𝑅 The ring ℤ [𝑋]/(𝑋𝑛 +1) consisting of polynomials of the form 𝑓 = 𝑓 +\n𝑞 𝑞 0\n𝑓 𝑋 +⋯+𝑓 𝑋255 , where 𝑓 ∈ ℤ for all 𝑗. The ring operations are addi-\n1 255 𝑗 𝑞\ntion and multiplication modulo 𝑋𝑛 +1.\n𝑇 The image of 𝑅 under the number-theoretic transform. Its elements are\n𝑞 𝑞\ncalled “NTT representations” of polynomials in 𝑅 . (See Section 4.3.)\n𝑞\nD (𝑅 ) A certain distribution of polynomials in 𝑅 with small coefficients, from\n𝜂 𝑞 𝑞\nwhich noise is sampled. The distribution is parameterized by 𝜂 ∈ {2,3}. (See\nSection 4.2.2.)\n𝑆∗ If 𝑆 is a set, this denotes the set of finite-length tuples (or arrays) of elements\nfrom the set 𝑆, including the empty tuple (or empty array).\n𝑆𝑘 If 𝑆 is a set, this denotes the set of 𝑘-tuples (or length-𝑘 arrays) of elements\nfrom the set 𝑆.\n𝑓 The coefficient of 𝑋𝑗 of a polynomial 𝑓 =𝑓 +𝑓 𝑋+⋯+𝑓 𝑋255 ∈𝑅 .\n𝑗 0 1 255 𝑞\n𝑓 ̂ The element of 𝑇 that is equal to the NTT representation of a polynomial\n𝑞\n𝑓 ∈ 𝑅 . (See Sections 2.4.4 and 4.3.)\n𝑞\n𝐯𝑇 , 𝐀𝑇 The transpose of a row or column vector 𝐯. In general, the transpose of a\nmatrix 𝐀.\n5\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n∘ Denotes linear-algebraic composition with coefficients in 𝑅 or 𝑇 (e.g.,\n𝑞 𝑞\n𝐀 ∘ 𝐯 denotes the vector resulting from applying matrix 𝐀 to vector 𝐯). (See\nSection 2.4.7.)\n× Denotes the operation on coefficient arrays that implements product in the\n𝑇\n𝑞\nring 𝑇 . (See Sections 2.4.5 and 4.3.1.)\n𝑞\n𝐴‖𝐵 The concatenation of two arrays or bit strings 𝐴 and 𝐵.\n𝐵[𝑖] The entry at index 𝑖 in the array 𝐵. All arrays have indices that begin at zero.\n𝐵[𝑘 ∶ 𝑚] The subarray (𝐵[𝑘],𝐵[𝑘 + 1],…,𝐵[𝑚 − 1]) of the array 𝐵.\n|𝐵| If 𝐵 is a number, this denotes the absolute value of 𝐵. If 𝐵 is an array, this\ndenotes its length.\n⌈𝑥⌉ The ceiling of 𝑥 (i.e., the smallest integer greater than or equal to 𝑥).\n⌊𝑥⌋ The floor of 𝑥 (i.e., the largest integer less than or equal to 𝑥).\n⌈𝑥⌋ The rounding of 𝑥 to the nearest integer. If 𝑥 = 𝑦+1/2 for some 𝑦 ∈ ℤ, then\n⌈𝑥⌋ = 𝑦+1.\n∶= Denotes that the left-hand side is defined to be the expression on the right-\nhand side.\n𝑟 mod 𝑚 The unique integer 𝑟′ in {0,1,…,𝑚 − 1} such that 𝑚 divides 𝑟 − 𝑟′ .\nBitRev (𝑟) Bit reversal of a seven-bit integer 𝑟. Specifically, if 𝑟 = 𝑟 +2𝑟 +4𝑟 +⋯+\n7 0 1 2\n64𝑟 with 𝑟 ∈ {0,1}, then BitRev (𝑟) = 𝑟 +2𝑟 +4𝑟 +⋯+64𝑟 .\n6 𝑖 7 6 5 4 0\n𝑠 ← 𝑥 In pseudocode, this notation means that the variable 𝑠 is assigned the value\nof the expression 𝑥.\n𝑠 ← $ − 𝔹ℓ In pseudocode, this notation means that the variable 𝑠 is assigned the value\nof an array of ℓ random bytes. The bytes must be freshly generated using\nrandomness from an approved RBG. (See Section 3.3.)\n⊥ A symbol indicating failure or the lack of output from an algorithm.\n2.4 Interpreting the Pseudocode\nThis section outlines the conventions of the pseudocode used to describe the algorithms in\nthis standard. All algorithms are understood to have access to two global integer constants:\n𝑛 = 256 and 𝑞 = 3329. There are also five global integer variables: 𝑘, 𝜂 , 𝜂 , 𝑑 , and 𝑑 . All\n1 2 𝑢 𝑣\nother variables are local. The five global variables are set to particular values when a parameter\nset is selected (see Section 8).\nWhen algorithms in this specification invoke other algorithms as subroutines, all arguments (i.e.,\ninputs) are passed by value. In other words, a copy of the inputs is created, and the subroutine\nis invoked with the copy. There is no “passing by reference.”\nPseudocode assignments are performed using the symbol “←.” For example, the statement\n𝑧 ←𝑦 means that the variable 𝑧 is assigned the value of variable 𝑦. Pseudocode comparisons\n6\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nare performed via the symbol “==.” For example, the expression 𝑥 == 𝑤 is a boolean value\nthat is TRUE if and only if the variables 𝑥 and 𝑤 have the same value.\nIn regular text (i.e., outside of the pseudocode), a different convention is applied. There, the\n“=” symbol is used both for assigning values and for comparisons, in keeping with standard\nmathematical notation. When emphasis is needed, assignments will be made with “∶=” instead.\nVariables will always have a valid value that is appropriate to their data type, with two exceptions:\n1. The outputs of a random bit generator (RBG) have the byte array data type but are also\nallowed to have the special value NULL. This value indicates that randomness generation\nfailed. This can only occur in ML-KEM.KeyGen and ML-KEM.Encaps.\n2. The outputs of ML-KEM.KeyGen and ML-KEM.Encaps have the byte array data type but\nare also allowed to have the special value ⊥. When ML-KEM.KeyGen or ML-KEM.Encaps\nreturn the value ⊥, this indicates that the algorithm failed due to a failure of randomness\ngeneration.\n2.4.1 Data Types\nFor variables that represent the input or output of an algorithm, the data type (e.g., bit, byte,\narray of bits) will be explicitly described at the start of the algorithm. For most local variables\nin the pseudocode, the data type is easily deduced from context. For all other variables, the\ndata type will be declared in a comment. In a single algorithm, the data type of a variable is\ndetermined the first time that the variable is used and will not be changed. Variable names can\nand will be reused across different algorithms, including with different data types.\nIn addition to standard atomic data types (e.g., bits, bytes) and data structures (e.g., arrays),\nintegers modulo 𝑚 (i.e., elements of ℤ ) will also be used as an abstract data type. It is implicit\n𝑚\nthat reduction modulo 𝑚 takes place whenever an assignment is made to a variable in ℤ . For\n𝑚\nexample, for 𝑧 ∈ ℤ and integers 𝑥 and 𝑦, the statement\n𝑚\n𝑧 ← 𝑥 +𝑦 (2.1)\nmeans that 𝑧 is assigned the value 𝑥 + 𝑦 mod 𝑚. The pseudocode is agnostic regarding how\nan integer modulo 𝑚 is represented in actual implementations or how modular reduction is\ncomputed.\n2.4.2 Loop Syntax\nThe pseudocode will make use of both “while” and “for” loops. The “while” syntax is self-\nexplanatory. In the case of “for” loops, the syntax will be in the style of the programming language\nC. Two simple examples are given in Algorithm 1. The standard mathematical expression (e.g.,\n∑ 𝑛 (𝑖 + 3)) will be used for simple summations instead of a “for” loop.\n𝑖←1\n2.4.3 Arithmetic With Arrays of Integers\nThis standard makes extensive use of arrays of integers modulo 𝑚 (i.e., elements of ℤℓ ). In a\n𝑚\ntypical case, the relevant values are 𝑚 = 𝑞 = 3329 and ℓ = 𝑛 = 256. Arithmetic with arrays in\n7\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nAlgorithm 1 ForExample()\nPerforms two simple “for” loops.\n1: for (𝑖 ← 0; 𝑖 < 10; 𝑖++)\n2: 𝐴[𝑖] ← 𝑖 ▷ 𝐴 is an integer array of length 10\n3: end for ▷ 𝐴 now has the value (0,1,2,3,4, 5,6,7, 8,9)\n4: 𝑗 ← 0\n5: for (𝑘 ← 256; 𝑘 > 1; 𝑘 ← 𝑘/2)\n6: 𝐵[𝑗] ← 𝑘 ▷ 𝐵 is an integer array of length 8\n7: 𝑗 ← 𝑗 + 1\n8: end for ▷ 𝐵 now has the value (256,128,64,32,16,8,4,2)\nℤℓ will be done as follows. Let 𝑎 ∈ ℤ and 𝑋,𝑌 ∈ ℤℓ . The statements\n𝑚 𝑚 𝑚\n𝑍 ← 𝑎⋅𝑋 (2.2)\n𝑊 ← 𝑋 +𝑌 (2.3)\nwill result in two arrays 𝑍,𝑊 ∈ ℤℓ , with the property that 𝑍[𝑖] = 𝑎⋅𝑋[𝑖] and 𝑊[𝑖] = 𝑋[𝑖]+𝑌 [𝑖]\n𝑚\nfor all 𝑖. Multiplication of arrays in ℤℓ will only be meaningful when 𝑚 = 𝑞 and ℓ = 𝑛 = 256, in\n𝑚\nwhich case it corresponds to multiplication in a particular ring. This operation will be described\nin (2.8).\n2.4.4 Representations of Algebraic Objects\nAn essential operation in ML-KEM is the number-theoretic transform (NTT), which maps a poly-\nnomial 𝑓 in a certain ring 𝑅 to its “NTT representation” 𝑓 î nan isomorphic ring 𝑇 . The rings 𝑅\n𝑞 𝑞 𝑞\nand 𝑇 and the NTT are discussed in detail in Section 4.3. This standard will represent elements\n𝑞\nof 𝑅 and 𝑇 in pseudocode using arrays of integers modulo 𝑞 as follows.\n𝑞 𝑞\nAn element 𝑓 of 𝑅 is a polynomial of the form\n𝑞\n𝑓 = 𝑓 + 𝑓 𝑋 + ⋯ + 𝑓 𝑋255 ∈ 𝑅 (2.4)\n0 1 255 𝑞\nand will be represented in pseudocode by the array\n(𝑓 ,𝑓 ,…,𝑓 ) ∈ ℤ256, (2.5)\n0 1 255 𝑞\nwhose entries contain the coefficients of 𝑓. Overloading notation, the array in (2.5) will also be\ndenoted by 𝑓. The 𝑖-th entry of the array 𝑓 will thus contain the 𝑖-th coefficient of the polynomial\n𝑓 (i.e., 𝑓[𝑖] = 𝑓 ).\n𝑖\nAn element (sometimes called “NTT representation”) 𝑔̂of 𝑇 is a tuple of 128 polynomials, each\n𝑞\nof degree at most one. Specifically,\n𝑔̂=( 𝑔̂ +𝑔 ̂ 𝑋, 𝑔 ̂ +𝑔 ̂ 𝑋, …, 𝑔 ̂ + 𝑔 ̂ 𝑋)∈𝑇 . (2.6)\n0,0 0,1 1,0 1,1 127,0 127,1 𝑞\n8\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nSuch an algebraic object will be represented in pseudocode by the array\n(𝑔̂ ,𝑔̂ ,𝑔̂ , 𝑔̂ ,…, 𝑔 ̂ , 𝑔 ̂ ) ∈ ℤ256. (2.7)\n0,0 0,1 1,0 1,1 127,0 127,1 𝑞\nOverloading notation, the array in (2.7) will also be denoted by 𝑔.̂ In this case, the mapping\nbetween array entries and coefficients is 𝑔[̂ 2𝑖] = 𝑔̂ and 𝑔[̂ 2𝑖 + 1] = 𝑔̂ for 𝑖 ∈ {0,1,…,127}.\n𝑖,0 𝑖,1\nConverting between a polynomial 𝑓 ∈ 𝑅 and its NTT representation 𝑓 ̂ ∈ 𝑇 will be done via the\n𝑞 𝑞\nalgorithms NTT (Algorithm 9) and NTT −1 (Algorithm 10). These algorithms act on arrays of\ncoefficients, as described above, and satisfy 𝑓 ̂ = NTT(𝑓) and 𝑓 = NTT −1(𝑓) ̂ .\n2.4.5 Arithmetic With Polynomials and NTT Representations\nThe algebraic operations of addition and scalar multiplication in 𝑅 and 𝑇 are done coordinate-\n𝑞 𝑞\nwise. For example, if 𝑎 ∈ ℤ and 𝑓 ∈ 𝑅 , the 𝑖-th coefficient of the polynomial 𝑎⋅𝑓 ∈ 𝑅 is\n𝑞 𝑞 𝑞\nequal to 𝑎 ⋅𝑓 mod 𝑞. In pseudocode, elements of both 𝑅 and 𝑇 are represented by coefficient\n𝑖 𝑞 𝑞\narrays (i.e., elements of ℤ256). The algebraic operations of addition and scalar multiplication are\n𝑞\nthus performed by addition and scalar multiplication of the corresponding coefficient arrays,\nas in (2.3) and (2.2). For example, the addition of two NTT representations in pseudocode is\nperformed by a statement of the form ℎ̂ ← 𝑓 + ̂ 𝑔,̂ where ℎ̂,𝑓, ̂ 𝑔 ̂ ∈ ℤ256 are coefficient arrays.\n𝑞\nThe algebraic operations of multiplication in 𝑅 and 𝑇 are treated as follows. For efficiency\n𝑞 𝑞\nreasons, multiplication in 𝑅 will not be used. The algebraic meaning of multiplication in 𝑇 is\n𝑞 𝑞\ndiscussed in Section 4.3.1. In pseudocode, it will be performed by the algorithm MultiplyNTTs\n(Algorithm 11). Specifically, if 𝑓, ̂ 𝑔 ̂ ∈ ℤ256 are a pair of arrays (each representing the NTT of some\n𝑞\npolynomial), then\nℎ̂ ← 𝑓 × ̂ 𝑔 ̂ means ℎ ̂ ← MultiplyNTTs(𝑓, ̂ 𝑔) ̂ . (2.8)\n𝑇\n𝑞\nThe result is an array ℎ̂ ∈ ℤ256 .\n𝑞\n2.4.6 Matrices and Vectors\nIn addition to arrays of integers modulo 𝑞, the pseudocode will also make use of arrays whose\nentries are themselves elements of ℤ256. For example, an element 𝐯 ∈ (ℤ256)3 will be a length-\n𝑞 𝑞\nthree array whose entries 𝐯[0], 𝐯[1], and 𝐯[2] are themselves elements of ℤ256 (i.e., arrays). One\n𝑞\ncan think of each of these entries as representing a polynomial in 𝑅 so that 𝐯 itself represents\n𝑞\nan element of the module 𝑅3 .\n𝑞\nWhen arrays are used to represent matrices and vectors whose entries are elements of 𝑅 , they\n𝑞\nwill be denoted with bold letters (e.g., 𝐯 for vectors and 𝐀 for matrices). When arrays are used\nto represent matrices and vectors whose entries are elements of 𝑇 , they will be denoted with a\n𝑞\n“hat” (e.g., 𝐯̂ and 𝐀̂ ). Unless an explicit transpose operation is performed, it is understood that\nvectors are column vectors. One can then view vectors as the special case of matrices with only\none column.\nConverting between matrices over 𝑅 and matrices over 𝑇 will be done coordinate-wise. For\n𝑞 𝑞\n9\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nexample, if 𝐯 ∈ (ℤ256)𝑘 , then the statement\n𝑞\n𝐯̂ ← NTT(𝐯) (2.9)\nwill result in 𝐯̂ ∈ (ℤ256)𝑘 such that 𝐯̂ [𝑖]= NTT(𝐯[𝑖]) for all 𝑖. This involves running NTT a total\n𝑞\nof 𝑘 times.\n2.4.7 Arithmetic With Matrices and Vectors\nThe following describes how to perform arithmetic with matrices over 𝑅 and 𝑇 with vectors as\n𝑞 𝑞\na special case.\nAddition and scalar multiplication are performed coordinate-wise, so the addition of matrices\nover 𝑅 and 𝑇 is straightforward. In the case of 𝑇 , scalar multiplication is done via (2.8). For\n𝑞 𝑞 𝑞\nexample, if 𝑓 ̂ ∈ ℤ256 and 𝐮̂, 𝐯̂ ∈ (ℤ256)𝑘 , then\n𝑞 𝑞\n𝐰 ̂ ←𝑓⋅ ̂ 𝐮 ̂ (2.10)\n𝐳 ̂ ← 𝐮 ̂+ 𝐯 ̂ (2.11)\nwill result in 𝐰̂ ,𝐳 ̂ ∈ (ℤ256 )𝑘 satisfying 𝐰̂ [𝑖]=𝑓 × ̂ 𝐮̂ [𝑖] and 𝐳[̂ 𝑖] = 𝐮̂ [𝑖] + 𝐯̂[𝑖] for all 𝑖. Here, the\n𝑞 𝑇\n𝑞\nmultiplication and addition of individual entries are performed using the appropriate arithmetic\nfor coefficient arrays of elements of 𝑇 (i.e., as in (2.3)).\n𝑞\nIt will also be necessary to multiply matrices with entries in 𝑇 , which is done by using standard\n𝑞\nmatrix multiplication with the base-case multiplication (i.e., multiplication of individual entries)\nbeing multiplication in 𝑇 . If 𝐀̂ and 𝐁̂ are two matrices with entries in 𝑇 , their matrix product\n𝑞 𝑞\nwill be denoted 𝐀̂ ∘𝐁̂ .Some example pseudocode statements involving matrix multiplication\nare given in (2.12), (2.13), and (2.14). In these examples, 𝐀̂ is a 𝑘 × 𝑘 matrix, while 𝐮̂ and 𝐯̂ are\nvectors of length 𝑘. All three of these objects are represented in pseudocode by arrays: a 𝑘 × 𝑘\narray for 𝐀̂ and length-𝑘 arrays for 𝐮̂ and 𝐯̂. The entries of 𝐀̂ , 𝐮̂, and 𝐯̂ are elements of ℤ256. In\n𝑞\n(2.12) and (2.13), the pseudocode statement on the left produces a new length-𝑘 vector whose\nentries are specified on the right. In (2.14), the pseudocode statement on the left computes a\ndot product. The result is in the base ring (i.e., 𝑇 ) and is represented by an element 𝑧 ̂ of ℤ256.\n𝑞 𝑞\n𝑘−1\n𝐰 ̂ ←𝐀̂ ∘ 𝐮 ̂ 𝐰̂[𝑖]=∑𝐀̂[𝑖,𝑗]× 𝐮 ̂[𝑗] (2.12)\n𝑇\n𝑞\n𝑗=0\n𝑘−1\n𝐲 ̂ ←𝐀̂⊺∘𝐮 ̂ 𝐲̂[𝑖]=∑𝐀̂[𝑗,𝑖]× 𝐮 ̂[𝑗] (2.13)\n𝑇\n𝑞\n𝑗=0\n𝑘−1\n𝑧̂ ←𝐮̂ ⊺∘𝐯̂ 𝑧̂=∑𝐮 ̂[𝑗]× 𝐯 ̂[𝑗] (2.14)\n𝑇\n𝑞\n𝑗=0\nThe multiplication × of individual entries above is performed using MultiplyNTTs, as described\n𝑇\n𝑞\nin (2.8).\n10\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n2.4.8 Applying Algorithms to Arrays, Examples\nIn the previous examples, arithmetic over ℤ was extended to arithmetic with arrays over ℤ\n𝑚 𝑚\nand then further extended to arithmetic with matrices whose entries are themselves arrays over\nℤ . Similarly, algorithms defined with a given data type as input will be applied to arrays and\n𝑚\nmatrices over that data type. When the pseudocode invokes such an algorithm on an array or\nmatrix input, it is implied that the algorithm is invoked repeatedly and applied to each entry of\nthe input.\nFor example, consider the function Compress ∶ℤ →ℤ defined in Section 4. It can be invoked\n𝑑 𝑞 2𝑑\non an array input 𝐹 ∈ ℤ256 with the statement\n𝑞\n𝐾 ← Compress (𝐹 ). (2.15)\n𝑑\nThe result will be an array 𝐾 ∈ ℤ256 such that 𝐾[𝑖] = Compress (𝐹 [𝑖]) for every 𝑖 ∈ {0,1,…,255}.\n2𝑑 𝑑\nThe computation (2.15) involves running the Compress algorithm 256 times.\nFor a second example, consider the algorithm NTT defined in Section 4.3. It takes an array 𝑓 ∈\nℤ256 (representing an element of 𝑅 ) as input and outputs another array 𝑓 ̂ ∈ ℤ256 (representing\n𝑞 𝑞 𝑞\nan element of 𝑇 ). If the NTT algorithm is invoked on a vector 𝐬 ∈ (ℤ256)𝑘 (representing an\n𝑞 𝑞\nelement of 𝑅𝑘) with the pseudocode statement\n𝑞\n𝐬 ̂ ← NTT(𝐬), (2.16)\nthe result is a vector 𝐬̂ ∈(ℤ256 )𝑘 such that 𝐬[̂ 𝑖] = NTT(𝐬[𝑖]) for all 𝑖 ∈ {0,1,…,𝑘−1}. The vector\n𝑞\n𝐬̂ represents an element of 𝑇𝑘 . The computation (2.16) involves running the NTT algorithm 𝑘\n𝑞\ntimes.\nFor a third example, consider line 2 of K-PKE.Encrypt in Section 5.2:\n𝐭 ̂← ByteDecode (ek [0 ∶ 384𝑘]). (2.17)\n12 PKE\nByteDecode is defined to receive a byte array of length 32⋅12 = 384 as input and produce\n12\nan integer array in ℤ256 as output. The computation (2.17) is run on the first 384𝑘 bytes of\n𝑞\nbyte array ek and results in 𝐭 ̂ ∈ (ℤ256 )𝑘 . ByteDecode will thus be applied 𝑘 times, once for\nPKE 𝑞 12\neach subarray ek [384 ⋅ 𝑗,384 ⋅ (𝑗 + 1)], and will result in an integer array 𝐭[̂ 𝑗] ∈ ℤ256 such that\nPKE 𝑞\n𝐭[̂ 𝑗] = ByteDecode (ek [384⋅𝑗,384⋅(𝑗+1)]) for each 𝑗 from 0 to 𝑘 − 1.\n12 PKE\n11"
  },
  {
    "input": "What is ML-KEM and how does it use the Module Learning with Errors (MLWE) problem to establish a shared secret key between two parties?",
    "summary": "ML-KEM is a key-encapsulation mechanism based on the CRYSTALS-KYBER scheme, using the Module Learning with Errors (MLWE) problem for its security. It involves three algorithms—KeyGen, Encaps, and Decaps—and uses parameter sets to balance security and efficiency. The ML-KEM scheme ensures correctness and provides theoretical security, with decapsulation failure rates listed in Table 1. Implementations must follow strict requirements, including controlled access to internal functions, proper randomness generation, and secure handling of intermediate data.",
    "output": "FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n3. Overview of the ML-KEM Scheme\nThis section gives a high-level overview of the ML-KEM scheme.\n3.1 Key-Encapsulation Mechanisms\nThe following is a high-level overview of key-encapsulation mechanisms (KEMs). For details, see\nSP 800-227 [1].\nA KEM is a cryptographic scheme that, under certain conditions, can be used to establish a shared\nsecret key between two communicating parties. This shared secret key can then be used for\nsymmetric-key cryptography.\nA KEM consists of three algorithms and a collection of parameter sets. The three algorithms are:\n1. A probabilistic key generation algorithm denoted by KeyGen\n2. A probabilistic ”encapsulation” algorithm denoted by Encaps\n3. A deterministic ”decapsulation” algorithm denoted by Decaps\nThe collection of parameter sets is used to select a trade-off between security and efficiency.\nEach parameter set in the collection is a list of specific (typically numerical) values, one for each\nparameter required by the three algorithms.\nAlice Bob\nKeyGen\ndecapsulation key encapsulation key\nDecaps ciphertext Encaps\nAlice’s copy of the Bob’s copy of the\nshared secret key shared secret key\n𝐾′ 𝐾\nFigure 1. A simple view of key establishment using a KEM\n12\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nIn the typical application, a KEM is used to establish a shared secret key between two parties\n(here referred to as Alice and Bob) as described in Figure 1. Alice begins by running KeyGen in\norder to generate a (public) encapsulation key and a (private) decapsulation key. Upon obtaining\nAlice’s encapsulation key, Bob runs the Encaps algorithm, which produces Bob’s copy 𝐾 of the\nshared secret key along with an associated ciphertext. Bob sends the ciphertext to Alice, and\nAlice completes the process by running the Decaps algorithm using her decapsulation key and\nthe ciphertext. This final step produces Alice’s copy 𝐾′ of the shared secret key.\nAfter completing this process, Alice and Bob would like to conclude that their outputs satisfy\n𝐾′ =𝐾 and that this value is a secure, random, shared secret key. However, these properties\nonly hold if certain important conditions are satisfied, as discussed in SP 800-227 [1].\n3.2 The ML-KEM Scheme\nML-KEM is a key-encapsulation mechanism based on CRYSTALS-KYBER [4], a scheme that was\ninitially described in [8]. The following is a brief and informal description of the computational\nassumption underlying ML-KEM and how the ML-KEM scheme is constructed.\nThe computational assumption. The security of ML-KEM is based on the presumed hardness\nof the so-called Module Learning with Errors (MLWE) problem [9], which is a generalization of\nthe Learning With Errors (LWE) problem introduced by Regev in 2005 [10]. The hardness of the\nMLWE problem is itself based on the presumed hardness of certain computational problems in\nmodule lattices [9]. This motivates the name of the scheme ML-KEM.\nIn the LWE problem, the input is a set of random “noisy” linear equations in some secret\nvariables 𝑥 ∈ ℤ𝑛, and the task is to recover 𝑥. The noise in the equations is such that standard\n𝑞\nalgorithms (e.g., Gaussian elimination) are intractable. The LWE problem naturally lends itself to\ncryptographic applications. For example, if 𝑥 is interpreted as a secret key, then one can encrypt\na one-bit plaintext value by sampling either an approximately correct linear equation (if the\nplaintext is zero) or a far-from-correct linear equation (if the plaintext is one). Plausibly, only a\nparty in possession of 𝑥 can distinguish these two cases. Encryption can then be delegated to\nanother party by publishing a large collection of noisy linear equations, which can be combined\nappropriately by the encrypting party. The result is an asymmetric encryption scheme.\nThe MLWE problem is similar to the LWE problem. An important difference is that, in MLWE, ℤ𝑛\n𝑞\nis replaced by a certain module 𝑅𝑘 , which is constructed by taking the 𝑘-fold Cartesian product\n𝑞\nof a certain polynomial ring 𝑅 . In particular, the secret in the MLWE problem is an element 𝐱 of\n𝑞\nthe module 𝑅𝑘 . The ring 𝑅 is discussed in detail in Section 4.3.\n𝑞 𝑞\nThe ML-KEM construction. At a high level, the construction of the scheme ML-KEM proceeds in\ntwo steps. First, the ideas discussed previously are used to construct a public-key encryption (PKE)\nscheme from the MLWE problem. Second, this PKE scheme is converted into a key-encapsulation\nmechanism using the so-called Fujisaki-Okamoto (FO) transform [11, 12]. Due to certain prop-\nerties of the FO transform, the resulting KEM provides security in a significantly more general\nattack model than the PKE scheme. As a result, ML-KEM is believed to satisfy so-called IND-CCA2\nsecurity [1, 4, 13, 14].\n13\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nThe specification of the ML-KEM algorithms in this standard will follow the same pattern. Specif-\nically, this standard will first describe a public-key encryption scheme called K-PKE (in Section 5)\nand then use the algorithms of K-PKE as subroutines when describing the algorithms of ML-KEM\n(in Sections 6 and 7). The cryptographic transformation from K-PKE to ML-KEM is crucial for\nachieving IND-CCA2 security. The scheme K-PKE is not IND-CCA2-secure and shall not be used as\na stand-alone scheme (see Section 3.3).\nA notable feature of ML-KEM is the use of the number-theoretic transform (NTT). The NTT\nconverts a polynomial 𝑓 ∈ 𝑅 to an alternative representation as a vector 𝑓 ô f linear polynomials.\n𝑞\nWorking with NTT representations enables significantly faster multiplication of polynomials.\nOther operations (e.g., addition, rounding, and sampling) can be done in either representation.\nML-KEM satisfies the essential KEM property of correctness. This means that in the absence\nof corruption or interference, the process in Figure 1 will result in 𝐾′ =𝐾 with overwhelming\nprobability. ML-KEM also comes with a proof of asymptotic theoretical security in a certain\nheuristic model [4]. Each of the parameter sets of ML-KEM comes with an associated security\nstrength that was estimated based on current cryptanalysis (see Section 8 for details).\nParameter sets and algorithms. Recall that a KEM consists of algorithms KeyGen, Encaps, and\nDecaps, along with a collection of parameter sets. In the case of ML-KEM, the three aforemen-\ntioned algorithms are:\n1. ML-KEM.KeyGen (Algorithm 19)\n2. ML-KEM.Encaps (Algorithm 20)\n3. ML-KEM.Decaps (Algorithm 21)\nThese algorithms are described and discussed in detail in Section 7.\nML-KEM comes equipped with three parameter sets:\n• ML-KEM-512 (security category 1)\n• ML-KEM-768 (security category 3)\n• ML-KEM-1024 (security category 5)\nThese parameter sets are described and discussed in detail in Section 8. The security categories\n1-5 are defined in SP 800-57, Part 1 [7]. Each parameter set assigns a particular numerical value\nto five integer variables: 𝑘, 𝜂 , 𝜂 , 𝑑 , and 𝑑 . The values of these variables in each parameter\n1 2 𝑢 𝑣\nset are given in Table 2 of Section 8. In addition to these five variable parameters, there are also\ntwo constants: 𝑛 = 256 and 𝑞 = 3329.\nDecapsulation failures. Provided that all inputs are well-formed and randomness generation is\nsuccessful, the key establishment procedure of ML-KEM will never explicitly fail, meaning that\nboth ML-KEM.Encaps and ML-KEM.Decaps will each output a 256-bit value. Moreover, if no\ncorruption or interference is present, the two 256-bit values produced by ML-KEM.Encaps and\nML-KEM.Decaps will be equal with overwhelming probability (i.e., 𝐾′ will equal 𝐾 in the process\ndescribed in Figure 1). The event that 𝐾′ ≠𝐾 under these conditions is called a decapsulation\n14\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nfailure. Formally, the decapsulation failure probability is defined to be the probability (conditioned\non no RGB failures) that the process\n1. (ek,dk)← ML-KEM.KeyGen() (3.1)\n2. (𝑐,𝐾) ← ML-KEM.Encaps(ek) (3.2)\n3. 𝐾′ ← ML-KEM.Decaps(dk,𝑐) (3.3)\nresults in 𝐾′ ≠ 𝐾. The probability is taken over uniformly random seeds 𝑑,𝑧 (sampled in\nML-KEM.KeyGen) and 𝑚 (sampled in ML-KEM.Encaps) and under the heuristic assumption that\nhash functions and XOFs behave like uniformly random functions. The decapsulation failure rates\nfor ML-KEM are listed in Table 1. For details, see Theorem 1 in [8] and the scripts in [15].\nTable 1. Decapsulation failure rates for ML-KEM\nParameter set Decapsulation failure rate\nML-KEM-512 2−138.8\nML-KEM-768 2−164.8\nML-KEM-1024 2−174.8\nTerminology for keys. A KEM involves three different types of keys: encapsulation keys, de-\ncapsulation keys, and shared secret keys. ML-KEM is built on top of the component public-key\nencryption scheme K-PKE, which has two additional key types: encryption keys and decryption\nkeys. In the literature, encapsulation keys and encryption keys are sometimes referred to as\n“public keys,” while decapsulation keys and decryption keys are sometimes referred to as “pri-\nvate keys.” In order to reduce confusion, this standard will not use the terms “public key” or\n“private key.” Instead, keys will be referred to only using the more specific terms, i.e., one of\n“encapsulation key”, “decapsulation key”, “encryption key”, “decryption key”, and “shared secret\nkey”.\n3.3 Requirements for ML-KEM Implementations\nThis section describes several requirements for cryptographic modules that implement ML-KEM.\nImplementation requirements specific to particular algorithms will be described in later sections.\nAdditional requirements, including requirements for using ML-KEM in specific applications,\nare given in SP 800-227 [1]. While conforming implementations must adhere to all of these\nrequirements, adherence does not guarantee that the result will be secure (see Point 13 in the\nannouncement).\nK-PKE is only a component. The public-key encryption scheme K-PKE described in Section 5 shall\nnot be used as a stand-alone cryptographic scheme. Instead, the algorithms that comprise K-PKE\nmay only be used as subroutines in the algorithms of ML-KEM. In particular, the algorithms\nK-PKE.KeyGen (Algorithm 13), K-PKE.Encrypt (Algorithm 14), and K-PKE.Decrypt (Algorithm 15)\nare not approved for use as a public-key encryption scheme.\n15\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nControlled access to internal functions. The key-encapsulation mechanism ML-KEM makes use\nof internal, “derandomized” functions ML-KEM.KeyGen_internal, ML-KEM.Encaps_internal, and\nML-KEM.Decaps_internal, specified in Section 6. The interfaces for these functions should not\nbe made available to applications other than for testing purposes. In particular, the sampling of\nrandom values required for key generation (as specified in ML-KEM.KeyGen) and encapsulation\n(as specified in ML-KEM.Encaps) shall be performed by the cryptographic module.\nEquivalent implementations. For every algorithm that is specified in this standard, a conforming\nimplementation may replace the given set of steps with any mathematically equivalent set of\nsteps. In other words, the specified algorithm may be replaced with a different procedure that\nproduces the correct output for every input (where “input” includes the specified input as well\nas all parameter values and all randomness).\nApproved usage of the shared secret key. If randomness generation is successful, the values\n𝐾 and 𝐾′ returned by ML-KEM.Encaps and ML-KEM.Decaps, respectively, are always 256-bit\nvalues. Under appropriate conditions (see Sections 3.1 and 3.2, and SP 800-227 [1]), these values\nmatch (i.e., 𝐾′ =𝐾) and can be used directly as a shared secret key for symmetric cryptography.\nIf further key derivation is needed, the final symmetric keys shall be derived from this 256-bit\nshared secret key in an approved manner, as specified in SP 800-108 and SP 800-56C [16, 17].\nAs discussed in Section 3.2, ML-KEM is an IND-CCA2-secure KEM. However, a combined KEM\nthat includes ML-KEM as a component might not meet IND-CCA2 security. Implementers should\nassess the security of any procedure in which the key derivation methods of SP 800-56C are\napplied to ML-KEM in combination with another key establishment procedure. More guidance\nregarding combined KEMs is given in SP 800-227 [1].\nRandomness generation. Two algorithms in this standard require the generation of randomness\nas an internal step: ML-KEM.KeyGen and ML-KEM.Encaps. In pseudocode, this randomness\ngeneration is denoted by a statement of the form 𝑚 ← $ − 𝔹32 . A fresh string of random bytes\nmust be generated for every such invocation. These random bytes shall be generated using an\napproved RBG, as prescribed in SP 800-90A, SP 800-90B, and SP 800-90C [18, 19, 20]. Moreover,\nthis RBG shall have a security strength of at least 128 bits for ML-KEM-512, at least 192 bits for\nML-KEM-768, and at least 256 bits for ML-KEM-1024.\nInput checking. The algorithms ML-KEM.Encaps and ML-KEM.Decaps require input checking.\nImplementers shall ensure that ML-KEM.Encaps and ML-KEM.Decaps are only executed on\ninputs that have been checked, as described in Section 7.\nDestruction of intermediate values. Data used in intermediate computation steps of KEM\nalgorithms could be used by an adversary to compromise security. Therefore, implementers\nshall ensure that intermediate data is destroyed as soon as it is no longer needed. In particular,\nfor ML-KEM.KeyGen, ML-KEM.Encaps, and ML-KEM.Decaps, only the designated output can be\nretained in memory after the algorithm terminates. All other data shall be destroyed prior to\n16\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nthe algorithm terminating.\nThere are two exceptions to this rule:\n1. The seed (𝑑,𝑧) generated in steps 1 and 2 of ML-KEM.KeyGen can be stored for later\nexpansion using ML-KEM.KeyGen_internal. As this seed can be used to compute the\ndecapsulation key, it is sensitive data and shall be treated with the same safeguards as a\ndecapsulation key (see SP 800-227 [1]).\n2. The matrix 𝐀̂ generated in steps 3-7 of K-PKE.KeyGen (as a subroutine of ML-KEM.KeyGen)\ncan be stored so that it need not be recomputed in later operations (e.g., ML-KEM.Decaps).\nThe same matrix 𝐀̂ is also generated in steps 4-8 of K-PKE.Encrypt (as a subroutine of\nML-KEM.Encaps or ML-KEM.Decaps); it can also then be stored. In either case, the matrix\n𝐀̂ is data that is easily computed from the public encapsulation key and thus does not\nrequire any special protections.\nNo floating-point arithmetic. Implementations of ML-KEM shall not use floating-point arithmetic,\nas rounding errors in floating-point operations may lead to incorrect results in some cases. In\nall pseudocode in this standard in which division is performed (e.g., 𝑥/𝑦) and 𝑦 may not divide\n𝑥, either ⌊𝑥/𝑦⌋, ⌈𝑥/𝑦⌉, or ⌈𝑥/𝑦⌋ is used. All of these can be computed without floating-point\narithmetic, as ordinary integer division 𝑥/𝑦 computes ⌊𝑥/𝑦⌋, and ⌈𝑥/𝑦⌉ = ⌊(𝑥 + 𝑦 − 1)/𝑦⌋ for\nnon-negative integers 𝑥 and positive integers 𝑦.\n17"
  },
  {
    "input": "What are the key cryptographic functions and their roles in the FIPS 203 module-lattice-based key-encapsulation mechanism?",
    "summary": "This document outlines the cryptographic functions and algorithms used in the lattice-based key-encapsulation mechanism (ML-KEM). It specifies hash functions like SHA3-256, SHA3-512, and XOFs like SHAKE128 and SHAKE256, along with wrapper functions to ensure consistency in byte array handling. Additionally, it describes conversion and compression algorithms for integers modulo $ m $, and sampling algorithms for generating polynomials with small coefficients, which are essential for the ML-KEM process. The Number-Theoretic Transform (NTT) is also detailed, emphasizing its role in efficiently transforming polynomials between rings.",
    "output": "FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n4. Auxiliary Algorithms\n4.1 Cryptographic Functions\nThe algorithms specified in this publication require the use of several cryptographic functions.\nEach function shall be instantiated by means of an approved hash function or an approved\neXtendable-Output Function (XOF), as prescribed below. The relevant hash functions and XOFs\nare described in detail in FIPS 202 [6]. They will be used as follows.\nSHA3-256 and SHA3-512 are hash functions with one variable-length input and one fixed-length\noutput. In this standard, invocations of these functions on an input 𝑀 will be denoted by\nSHA3-256(𝑀) and SHA3-512(𝑀), respectively. The inputs and outputs for both SHA3-256 and\nSHA3-512 are always byte arrays.\nSHAKE128 and SHAKE256 are XOFs with one variable-length input and one variable-length output.\nThis standard will adhere to the following conventions [6]:\n• The inputs and outputs for both SHAKE128 and SHAKE256 are always byte arrays.\n• When invoking SHAKE128 or SHAKE256, desired output length is always specified in bits.\nFor example, the expression\n𝑟 ∶= SHAKE128(𝑀,8 ⋅ 64) (4.1)\nimplies that 𝑀 is an array of bytes and that 𝑟 is an array of 64 bytes.\nThe aforementioned functions play several different roles in the algorithms specified in this\nstandard and will only be invoked using the wrapper functions defined below. Importantly, these\nwrappers will avoid any potential “byte array” versus “bit-length” confusion by only working with\nbytes and byte array lengths.\nPseudorandom function (PRF). The function PRF takes a parameter 𝜂 ∈ {2,3}, one 32-byte\ninput, and one 1-byte input. It produces one (64 ⋅ 𝜂)-byte output. It will be denoted by\nPRF ∶ {2,3}×𝔹32 ×𝔹 → 𝔹64𝜂, (4.2)\nand it shall be instantiated as\nPRF (𝑠,𝑏) ∶= SHAKE256(𝑠‖𝑏,8 ⋅ 64 ⋅ 𝜂), (4.3)\n𝜂\nwhere 𝜂 ∈ {2,3}, 𝑠 ∈ 𝔹32 , and 𝑏 ∈ 𝔹. Note that 𝜂 is only used to specify the desired output\nlength and not to perform domain separation.\nHash functions. The specification will also make use of three hash functions H, J and G, which\nare defined as follows.\nThe functions H and J each take one variable-length input and produce one 32-byte output. They\nwill be denoted by H ∶ 𝔹∗ → 𝔹32 and J ∶ 𝔹∗ → 𝔹32 , respectively, and shall be instantiated as\nH(𝑠) ∶= SHA3-256(𝑠) and J(𝑠) ∶= SHAKE256(𝑠,8 ⋅ 32) (4.4)\n18\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nwhere 𝑠 ∈ 𝔹∗ .\nThe function G takes one variable-length input and produces two 32-byte outputs. It will be\ndenoted by G ∶ 𝔹∗ → 𝔹32 × 𝔹32 . The two outputs of G will be denoted by (𝑎,𝑏) ← G(𝑐), where\n𝑎,𝑏 ∈ 𝔹32 , 𝑐 ∈𝔹∗ , and G(𝑐) = 𝑎‖𝑏. The function G shall be instantiated as\nG(𝑐) ∶= SHA3-512(𝑐). (4.5)\neXtendable-Output Function (XOF). This standard uses a XOF wrapper defined in terms of the\nincremental API for SHAKE128 in SP 800-185 [21]. This SHAKE128 API consists of three functions:\n• ctx ← SHAKE128.Init()\nInitializes a XOF “context” ctx.\n• ctx ← SHAKE128.Absorb(ctx,str)\nInjects data to be used in the “absorbing” phase of SHAKE128 and updates the context\naccordingly.\n• (ctx,𝐵) ← SHAKE128.Squeeze(ctx,8 ⋅ 𝑧)\nExtracts 𝑧 output bytes produced during the “squeezing” phase of SHAKE128 and updates\nthe context accordingly.\nWhile the above functions are constructed using the Keccak-𝑓 permutation rather than the XOF\nSHAKE128 directly, they are defined so that a single SHAKE128 call of the form\noutput ← SHAKE128(str ‖…‖str ,8𝑏 +…+8𝑏 ) (4.6)\n1 𝑚 1 ℓ\nis equivalent to performing Algorithm 2. This equivalence holds whether or not |str | and 𝑏 are\n𝑖 𝑗\nmultiples of the SHAKE128 block length.\nAlgorithm 2 SHAKE128example(str ,…,str ,𝑏 ,…,𝑏 )\n1 𝑚 1 ℓ\nPerforms a sequence of absorbing operations followed by a sequence of squeezing operations.\nInput: byte arrays str ,…,str .\n1 𝑚\nInput: positive integers 𝑏 ,…,𝑏 .\n1 ℓ\nOutput: a byte array of length ∑ ℓ 𝑏 .\n𝑗=1 𝑗\n1: ctx ← SHAKE128.Init() ▷ initialize context\n2: for (𝑖 ← 1; 𝑖 ≤ 𝑚; 𝑖++)\n3: ctx ← SHAKE128.Absorb(ctx,str ) ▷ absorb byte array str\n𝑖 𝑖\n4: end for\n5: for (𝑗 ←1; 𝑗 ≤ℓ; 𝑗++)\n6: (ctx,out ) ← SHAKE128.Squeeze(ctx,8⋅𝑏 ) ▷ squeeze 𝑏 -many bytes\n𝑗 𝑗 𝑗\n7: end for\n8: output ← out ‖…‖out ▷ return the concatenation of all the results\n1 ℓ\nIn this standard, the incremental API for SHAKE128 will only be invoked through a wrapper XOF,\n19\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nwhich is defined as follows.\n1. XOF.Init() = SHAKE128.Init().\n2. XOF.Absorb(ctx, str)= SHAKE128.Absorb(ctx,str).\n3. XOF.Squeeze(ctx,ℓ) = SHAKE128.Squeeze(ctx,8 ⋅ ℓ).\nNote that XOF.Squeeze requires the input length to be specified in bytes. This is consistent with\nthe convention that all wrapper functions treat inputs and outputs as byte arrays and measure\nthe lengths of all such arrays in terms of bytes.\n4.2 General Algorithms\nThis section specifies a number of algorithms that will be used as subroutines in ML-KEM.\n4.2.1 Conversion and Compression Algorithms\nThis section specifies several algorithms for converting between bit arrays, byte arrays, and arrays\nof integers modulo 𝑚. It also specifies a certain operation for compressing integers modulo 𝑞,\nand the corresponding decompression operation.\nAlgorithm 3 BitsToBytes(𝑏)\nConverts a bit array (of a length that is a multiple of eight) into an array of bytes.\nInput: bit array 𝑏 ∈ {0,1}8⋅ℓ .\nOutput: byte array 𝐵 ∈ 𝔹ℓ .\n1: 𝐵 ← (0,…,0)\n2: for (𝑖 ← 0; 𝑖 < 8ℓ; 𝑖++)\n3: 𝐵[⌊𝑖/8⌋] ← 𝐵[⌊𝑖/8⌋]+𝑏[𝑖]⋅2𝑖 mod 8\n4: end for\n5: return 𝐵\nAlgorithm 4 BytesToBits(𝐵)\nPerforms the inverse of BitsToBytes, converting a byte array into a bit array.\nInput: byte array 𝐵 ∈𝔹ℓ .\nOutput: bit array 𝑏 ∈ {0,1}8⋅ℓ .\n1: 𝐶 ←𝐵 ▷ copy 𝐵 into array 𝐶 ∈𝔹ℓ\n2: for (𝑖 ← 0; 𝑖 < ℓ; 𝑖++)\n3: for (𝑗 ← 0; 𝑗 < 8; 𝑗++)\n4: 𝑏[8𝑖+𝑗] ← 𝐶[𝑖] mod 2\n5: 𝐶[𝑖] ← ⌊𝐶[𝑖]/2⌋\n6: end for\n7: end for\n8: return 𝑏\n20\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nConverting between bits and bytes. The algorithms BitsToBytes (Algorithm 3) and BytesToBits\n(Algorithm 4) convert between bit arrays and byte arrays. The inputs to BitsToBytes and the\noutputs of BytesToBits are bit arrays, with each segment of eight bits representing a byte in\nlittle-endian order. As an example, the 8-bit string 11010001 corresponds to the byte 20 +21 +\n23+27 =139.\nCompression and decompression. Recall that 𝑞 = 3329, and that the bit length of 𝑞 is 12. For\n𝑑 < 12, define\nCompress ∶ ℤ ⟶ ℤ (4.7)\n𝑑 𝑞 2𝑑\n𝑥 ⟼ ⌈(2𝑑/𝑞) ⋅ 𝑥⌋ mod 2𝑑 .\nDecompress ∶ ℤ ⟶ ℤ (4.8)\n𝑑 2𝑑 𝑞\n𝑦 ⟼ ⌈(𝑞/2𝑑) ⋅ 𝑦⌋.\nThe input and output types of these functions are integers modulo 𝑚 (see Section 2.4.1). Division\nand rounding in the computation of these functions are performed in the set of rational numbers.\nFloating-point computations shall not be used.\nThe Compress and Decompress algorithms satisfy two important properties. First, decompression\nfollowed by compression preserves the input. That is, Compress (Decompress (𝑦)) = 𝑦 for\n𝑑 𝑑\nall 𝑦 ∈ ℤ and all 𝑑 < 12. Second, if 𝑑 is large (i.e., close to 12), compression followed by\n2𝑑\ndecompression does not significantly alter the value.\nEncoding and decoding. The algorithms ByteEncode (Algorithm 5) and ByteDecode (Algorithm\n6) will be used for conversion between integers modulo 𝑚 and bytes. The algorithm ByteEncode\nconverts an array of 𝑛 = 256 integers modulo 𝑚 into a corresponding array of bytes. ByteDecode\nperforms the inverse operation, converting an array of bytes into an array of integers modulo 𝑚.\nSpecifying the modulus 𝑚 is done as described below.\nFor the following description, it is convenient to view ByteDecode and ByteEncode as converting\nbetween integers and bits. The conversion between bits and bytes is straightforward and done\nusing BitsToBytes and BytesToBits. The valid range of values for the parameter 𝑑 is 1≤𝑑 ≤12.\nBit arrays are divided into 𝑑-bit segments. The operations are performed in two different ways,\ndepending on the value of 𝑑:\n• For 𝑑 satisfying 1 ≤ 𝑑 ≤ 11, the conversion is one-to-one. ByteDecode converts each\n𝑑\n𝑑-bit segment of its input into one integer modulo 2𝑑 , while ByteEncode performs the\n𝑑\ninverse operation.\n• For 𝑑 = 12, ByteDecode produces integers modulo 𝑞 as output, while ByteEncode\n12 12\nreceives integers modulo 𝑞 as input. Specifically, ByteDecode converts each 12-bit\n12\nsegment of its input into an integer modulo 212 = 4096 and then reduces the result\nmodulo 𝑞. This is no longer a one-to-one operation. Indeed, some 12-bit segments could\ncorrespond to an integer greater than 𝑞−1 = 3328 but less than 4096. However, this\ncannot occur for arrays produced by ByteEncode . These aspects of ByteDecode and\n12 12\n21\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nByteEncode will be important when considering checking of the ML-KEM encapsulation\n12\nkey in Section 7.\nAlgorithm 5 ByteEncode (𝐹 )\n𝑑\nEncodes an array of 𝑑-bit integers into a byte array for 1≤𝑑 ≤12.\nInput: integer array 𝐹 ∈ ℤ256 , where 𝑚 = 2𝑑 if 𝑑 <12, and 𝑚 = 𝑞 if 𝑑 =12.\n𝑚\nOutput: byte array 𝐵 ∈ 𝔹32𝑑 .\n1: for (𝑖 ← 0; 𝑖 < 256; 𝑖++)\n2: 𝑎←𝐹[𝑖] ▷𝑎∈ℤ\n𝑚\n3: for (𝑗 ← 0; 𝑗 < 𝑑; 𝑗++)\n4: 𝑏[𝑖⋅𝑑+𝑗] ← 𝑎 mod 2 ▷ 𝑏 ∈ {0,1}256⋅𝑑\n5: 𝑎←(𝑎−𝑏[𝑖⋅𝑑+𝑗])/2 ▷ note 𝑎 − 𝑏[𝑖 ⋅ 𝑑 + 𝑗] is always even\n6: end for\n7: end for\n8: 𝐵 ← BitsToBytes(𝑏)\n9: return 𝐵\nAlgorithm 6 ByteDecode (𝐵)\n𝑑\nDecodes a byte array into an array of 𝑑-bit integers for 1≤𝑑 ≤12.\nInput: byte array 𝐵 ∈ 𝔹32𝑑 .\nOutput: integer array 𝐹 ∈ ℤ256 , where 𝑚 = 2𝑑 if 𝑑 < 12 and 𝑚 = 𝑞 if 𝑑 = 12.\n𝑚\n1: 𝑏 ← BytesToBits(𝐵)\n2: for (𝑖 ← 0; 𝑖 < 256; 𝑖++)\n3: 𝐹 [𝑖] ← ∑ 𝑑−1 𝑏[𝑖 ⋅ 𝑑 + 𝑗] ⋅ 2𝑗 mod 𝑚\n𝑗←0\n4: end for\n5: return 𝐹\n4.2.2 Sampling Algorithms\nThe algorithms of ML-KEM require two sampling subroutines that are specified in Algorithms 7\nand 8. Both of these algorithms can be used to convert a stream of uniformly random bytes into\na sample from some desired distribution. In this standard, these algorithms will be invoked with\na stream of pseudorandom bytes as the input. It follows that the output will then be a sample\nfrom a distribution that is computationally indistinguishable from the desired distribution.\nUniform sampling of NTT representations. The algorithm SampleNTT (Algorithm 7) converts\na seed together with two indexing bytes into a polynomial in the NTT domain. If the seed is\nuniformly random, the resulting polynomial will be drawn from a distribution that is computa-\ntionally indistinguishable from the uniform distribution on 𝑇 . The output of SampleNTT is an\n𝑞\narray in ℤ256 that contains the coefficients of the sampled element of 𝑇 (see Section 2.4.4). See\n𝑞 𝑞\nAppendix B for a note on (optionally) safely bounding the algorithm’s while-loop iterations.\n22\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nAlgorithm 7 SampleNTT(𝐵)\nTakes a 32-byte seed and two indices as input and outputs a pseudorandom element of 𝑇 .\n𝑞\nInput: byte array 𝐵 ∈ 𝔹34 . ▷ a 32-byte seed along with two indices\nOutput: array 𝑎̂ ∈ℤ256 . ▷ the coefficients of the NTT of a polynomial\n𝑞\n1: ctx ← XOF.Init()\n2: ctx ← XOF.Absorb(ctx,𝐵) ▷ input the given byte array into XOF\n3: 𝑗 ←0\n4: while 𝑗 < 256 do\n5: (ctx,𝐶) ← XOF.Squeeze(ctx,3) ▷ get a fresh 3-byte array 𝐶 from XOF\n6: 𝑑 ←𝐶[0]+256⋅(𝐶[1] mod 16) ▷0≤𝑑 <212\n1 1\n7: 𝑑 ←⌊𝐶[1]/16⌋+16⋅𝐶[2] ▷0≤𝑑 <212\n2 2\n8: if 𝑑 <𝑞 then\n1\n9: 𝑎[̂ 𝑗] ← 𝑑 ▷ 𝑎 ̂ ∈ ℤ256\n1 𝑞\n10: 𝑗 ←𝑗+1\n11: end if\n12: if 𝑑 <𝑞 and 𝑗 <256 then\n2\n13: 𝑎[̂ 𝑗] ← 𝑑\n2\n14: 𝑗 ←𝑗+1\n15: end if\n16: end while\n17: return 𝑎̂\nSampling from the centered binomial distribution. ML-KEM makes use of a special distribution\nD (𝑅 ) of polynomials in 𝑅 with small coefficients. Such polynomials are sometimes referred\n𝜂 𝑞 𝑞\nto as “errors” or “noise.” The distribution is parameterized by an integer 𝜂 ∈ {2,3}. To sample a\npolynomial from D (𝑅 ), each of its coefficients is independently sampled from a certain cen-\n𝜂 𝑞\ntered binomial distribution (CBD) on ℤ . The algorithm SamplePolyCBD (Algorithm 8) samples\n𝑞\nthe coefficient array of a polynomial 𝑓 ∈ 𝑅 according to the distribution D (𝑅 ), provided that\n𝑞 𝜂 𝑞\nAlgorithm 8 SamplePolyCBD (𝐵)\n𝜂\nTakes a seed as input and outputs a pseudorandom sample from the distribution D (𝑅 ).\n𝜂 𝑞\nInput: byte array 𝐵 ∈ 𝔹64𝜂 .\nOutput: array 𝑓 ∈ ℤ256. ▷ the coefficients of the sampled polynomial\n𝑞\n1: 𝑏 ← BytesToBits(𝐵)\n2: for (𝑖 ← 0; 𝑖 < 256; 𝑖++)\n3: 𝑥←∑\n𝜂−1\n𝑏[2𝑖𝜂 + 𝑗] ▷0≤𝑥≤𝜂\n𝑗←0\n4: 𝑦←∑\n𝜂−1\n𝑏[2𝑖𝜂 + 𝜂 + 𝑗] ▷0≤𝑦≤𝜂\n𝑗←0\n5: 𝑓[𝑖] ← 𝑥−𝑦 mod 𝑞 ▷0≤𝑓[𝑖]≤𝜂 or 𝑞−𝜂 ≤𝑓[𝑖]≤𝑞−1\n6: end for\n7: return 𝑓\n23\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nits input is a stream of uniformly random bytes.\n4.3 The Number-Theoretic Transform\nThe Number-Theoretic Transform (NTT) can be viewed as a specialized, exact version of the\ndiscrete Fourier transform. In the case of ML-KEM, the NTT is used to improve the efficiency of\nmultiplication in the ring 𝑅 . Recall that 𝑅 is the ring ℤ [𝑋]/(𝑋𝑛 +1) of polynomials of the\n𝑞 𝑞 𝑞\nform 𝑓 =𝑓 +𝑓 𝑋+⋯+𝑓 𝑋255 (where 𝑓 ∈ ℤ for all 𝑗), with the ring operations defined\n0 1 255 𝑗 𝑞\nby arithmetic modulo 𝑋𝑛 +1.\nThe ring 𝑅 is isomorphic to another ring 𝑇 , which is a direct sum of 128 quadratic extensions\n𝑞 𝑞\nof ℤ . The NTT is a computationally efficient isomorphism between these two rings. When a\n𝑞\npolynomial 𝑓 ∈ 𝑅 is input, the NTT outputs an element 𝑓 ̂ ∶= NTT(𝑓) of the ring 𝑇 , where 𝑓 îs\n𝑞 𝑞\ncalled the “NTT representation” of 𝑓. The isomorphism property implies that\n𝑓 × 𝑔 = NTT −1(𝑓 × ̂ 𝑔) ̂ , (4.9)\n𝑅 𝑇\n𝑞 𝑞\nwhere × and × denote multiplication in 𝑅 and 𝑇 , respectively. Moreover, since 𝑇 is a\n𝑅 𝑇 𝑞 𝑞 𝑞\n𝑞 𝑞\nproduct of 128 rings that each consist of polynomials of degree at most one, the operation ×\n𝑇\n𝑞\nis much more efficient than the operation × . For these reasons, the NTT is considered to be\n𝑅\n𝑞\nan integral part of ML-KEM and not merely an optimization.\nAs the rings 𝑅 and 𝑇 have a vector space structure over ℤ , the most natural abstract data\n𝑞 𝑞 𝑞\ntype to represent elements from either of these rings is ℤ𝑛. For this reason, the choice of data\n𝑞\nstructure for the inputs and outputs of NTT and NTT −1 are length-𝑛 arrays of integers modulo\n𝑞. These arrays are understood to represent elements of 𝑇 or 𝑅 , respectively (see Section\n𝑞 𝑞\n2.4.4). Algorithms 9 and 10 describe an efficient means of computing NTT and NTT −1 in place.\nHowever, to clarify the distinction between the algebraic objects before and after the conversion,\nthe algorithms are written with explicit inputs and outputs. This is consistent with this standard’s\nconvention that all inputs are passed by copy.\nThe mathematical structure of the NTT. In ML-KEM, 𝑞 is the prime 3329 = 28⋅13+1, and\n𝑛 = 256. There are 128 primitive 256-th roots of unity and no primitive 512-th roots of unity in\nℤ . Note that 𝜁 =17∈ℤ is a primitive 256-th root of unity modulo 𝑞. Thus, 𝜁128 ≡ −1.\n𝑞 𝑞\nDefine BitRev (𝑖) to be the integer represented by bit-reversing the unsigned 7-bit value that\n7\ncorresponds to the input integer 𝑖 ∈ {0,…,127}.\nThe polynomial 𝑋256 +1 factors into 128 polynomials of degree 2 modulo 𝑞 as follows:\n127\n𝑋256+1 = ∏ (𝑋2−𝜁2BitRev\n7\n(𝑖)+1). (4.10)\n𝑖=0\nTherefore, 𝑅 ∶=ℤ [𝑋]/(𝑋256+1) is isomorphic to a direct sum of 128 quadratic extension\n𝑞 𝑞\n24\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nfields of ℤ , denoted 𝑇 . Specifically, this ring has the structure\n𝑞 𝑞\n127\n𝑇\n𝑞\n∶=⨁ℤ\n𝑞\n[𝑋]/(𝑋2−𝜁2BitRev\n7\n(𝑖)+1). (4.11)\n𝑖=0\nThus, the NTT representation 𝑓 ̂ ∈ 𝑇 of a polynomial 𝑓 ∈ 𝑅 is the vector that consists of the\n𝑞 𝑞\ncorresponding residues of degree at most one:\n𝑓 ̂ ∶= (𝑓 mod (𝑋2 −𝜁2BitRev\n7\n(0)+1),…,𝑓 mod (𝑋2 −𝜁2BitRev\n7\n(127)+1)) . (4.12)\nAs discussed in Section 2.4.4, the algorithms in this standard represent 𝑓 ̂as an array of 256\nintegers modulo 𝑞. Specifically,\n𝑓 mod (𝑋2 −𝜁2BitRev\n7\n(𝑖)+1) = 𝑓[ ̂ 2𝑖] + 𝑓[ ̂ 2𝑖 + 1]𝑋, (4.13)\nfor 𝑖 from 0 to 127.\nThe ML-KEM NTT algorithms. An algorithm for the ML-KEM NTT is described in Algorithm 9. An\nalgorithm for the inverse operation (NTT −1) is described in Algorithm 10. These two algorithms\nwill be used to transform elements of 𝑅 to elements of 𝑇 (using NTT) and vice versa (using\n𝑞 𝑞\nNTT −1). In addition, as discussed in Section 2.4.8, these algorithms represent the coordinate-\nwise transformation of structures over those rings. Specifically, they map matrices/vectors with\nentries in 𝑅 to matrices/vectors with entries in 𝑇 (using NTT) and vice versa (using NTT −1).\n𝑞 𝑞\nThe values 𝜁BitRev\n7\n(𝑖) mod 𝑞 for 𝑖 = 1,…,127 used in line 5 of Algorithm 9 and line 5 of Algorithm\n10 may be precomputed into an array. This array is given in Appendix A.\n25"
  },
  {
    "input": "What is the process for multiplying two elements in the NTT domain as described in the FIPS 203 module-lattice-based key-encapsulation mechanism?",
    "summary": "The NTT algorithm transforms a polynomial into its NTT representation and then back, using modular arithmetic. Multiplication in the NTT domain involves multiplying each coordinate's polynomials modulo a quadratic polynomial. Algorithm 11 performs this multiplication by using Algorithm 12 for each coordinate, which calculates the product of two degree-one polynomials under a quadratic modulus.",
    "output": "FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nAlgorithm 9 NTT(𝑓)\nComputes the NTT representation 𝑓 ô f the given polynomial 𝑓 ∈ 𝑅 .\n𝑞\nInput: array 𝑓 ∈ ℤ256. ▷ the coefficients of the input polynomial\n𝑞\nOutput: array 𝑓 ̂ ∈ ℤ256. ▷ the coefficients of the NTT of the input polynomial\n𝑞\n1: 𝑓 ̂ ←𝑓 ▷ will compute in place on a copy of input array\n2: 𝑖 ← 1\n3: for (len ← 128; len ≥2; len ← len/2)\n4: for (start ←0; start < 256; start ← start +2⋅ len)\n5: zeta ← 𝜁BitRev 7 (𝑖) mod 𝑞\n6: 𝑖 ← 𝑖+1\n7: for (𝑗 ← start; 𝑗 < start + len; 𝑗++)\n8: 𝑡 ← zeta ⋅ 𝑓[ ̂ 𝑗 + len] ▷ steps 8-10 done modulo 𝑞\n9: 𝑓[ ̂ 𝑗 + len] ← 𝑓[ ̂ 𝑗]−𝑡\n̂ ̂\n10: 𝑓[𝑗] ← 𝑓[𝑗]+𝑡\n11: end for\n12: end for\n13: end for\n14: return 𝑓 ̂\nAlgorithm 10 NTT −1(𝑓) ̂\nComputes the polynomial 𝑓 ∈ 𝑅 that corresponds to the given NTT representation 𝑓 ̂ ∈ 𝑇 .\n𝑞 𝑞\nInput: array 𝑓 ̂ ∈ ℤ256. ▷ the coefficients of input NTT representation\n𝑞\nOutput: array 𝑓 ∈ ℤ256. ▷ the coefficients of the inverse NTT of the input\n𝑞\n1: 𝑓 ← 𝑓 ̂ ▷ will compute in place on a copy of input array\n2: 𝑖 ← 127\n3: for (len ←2; len ≤ 128; len ←2⋅ len)\n4: for (start ←0; start < 256; start ← start +2⋅ len)\n5: zeta ← 𝜁BitRev 7 (𝑖) mod 𝑞\n6: 𝑖 ← 𝑖−1\n7: for (𝑗 ← start; 𝑗 < start + len; 𝑗++)\n8: 𝑡 ← 𝑓[𝑗]\n9: 𝑓[𝑗] ← 𝑡+𝑓[𝑗+ len] ▷ steps 9-10 done modulo 𝑞\n10: 𝑓[𝑗 + len]← zeta ⋅ (𝑓[𝑗 + len] − 𝑡)\n11: end for\n12: end for\n13: end for\n14: 𝑓 ←𝑓⋅3303 mod 𝑞 ▷ multiply every entry by 3303 ≡ 128−1 mod 𝑞\n15: return 𝑓\n26\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n4.3.1 Multiplication in the NTT Domain\nThe addition and scalar multiplication of elements of 𝑇 can be done using the corresponding\n𝑞\ncoordinate-wise arithmetic operations on the coefficient arrays (see Section 2.4.5). This section\ndescribes how to do the remaining ring operation (i.e., multiplication in 𝑇 ).\n𝑞\nRecall from (4.12) that 𝑓 ̂ ∈ 𝑇 is a vector of 128 degree-one residues modulo quadratic polyno-\n𝑞\nmials. Algebraically, multiplication in the ring 𝑇 consists of independent multiplication in each\n𝑞\nof the 128 coordinates with respect to the quadratic modulus of that coordinate. Specifically,\nthe 𝑖-th coordinate in 𝑇 of the product ℎ̂ =𝑓× ̂ 𝑔̂ is determined by the calculation\n𝑞 𝑇\n𝑞\nℎ̂[2𝑖]+ ℎ̂ [2𝑖+1]𝑋 =(𝑓[ ̂ 2𝑖]+ 𝑓[ ̂ 2𝑖+1]𝑋)(𝑔[̂2𝑖]+ 𝑔[̂2𝑖+1]𝑋) mod (𝑋2 −𝜁2BitRev\n7\n(𝑖)+1).\n(4.14)\nAlgorithm 11 MultiplyNTTs(𝑓, ̂ 𝑔) ̂\nComputes the product (in the ring 𝑇 ) of two NTT representations.\n𝑞\nInput: Two arrays 𝑓 ̂ ∈ ℤ256 and 𝑔 ̂ ∈ ℤ256 . ▷ the coefficients of two NTT representations\n𝑞 𝑞\nOutput: An array ℎ̂ ∈ ℤ256. ▷ the coefficients of the product of the inputs\n𝑞\n1: for (𝑖 ← 0; 𝑖 < 128; 𝑖++)\n2: (ℎ̂[2𝑖],ℎ̂ [2𝑖+1]) ← BaseCaseMultiply(𝑓[ ̂ 2𝑖],𝑓[ ̂ 2𝑖 + 1],𝑔[̂2𝑖], 𝑔[̂2𝑖 + 1],𝜁2BitRev 7 (𝑖)+1)\n3: end for\n4: return ℎ̂\nThus, one can compute the product of two elements of 𝑇 using the algorithm MultiplyNTTs (Al-\n𝑞\ngorithm 11), which uses BaseCaseMultiply (Algorithm 12) as a subroutine. The values 𝜁2BitRev 7 (𝑖)+1\nused in Algorithm 11 may be precomputed and stored in an array (see Appendix A). MultiplyNTTs\nalso enables linear-algebraic arithmetic with matrices and vectors whose entries are in 𝑇 (see\n𝑞\nSection 2.4.7).\nAlgorithm 12 BaseCaseMultiply(𝑎 ,𝑎 ,𝑏 ,𝑏 ,𝛾)\n0 1 0 1\nComputes the product of two degree-one polynomials with respect to a quadratic modulus.\nInput: 𝑎 ,𝑎 ,𝑏 ,𝑏 ∈ ℤ . ▷ the coefficients of 𝑎 + 𝑎 𝑋 and 𝑏 + 𝑏 𝑋\n0 1 0 1 𝑞 0 1 0 1\nInput: 𝛾 ∈ℤ . ▷ the modulus is 𝑋2 −𝛾\n𝑞\nOutput: 𝑐 ,𝑐 ∈ ℤ . ▷ the coefficients of the product of the two polynomials\n0 1 𝑞\n1: 𝑐 ←𝑎 ⋅𝑏 +𝑎 ⋅𝑏 ⋅𝛾 ▷ steps 1-2 done modulo 𝑞\n0 0 0 1 1\n2: 𝑐 ←𝑎 ⋅𝑏 +𝑎 ⋅𝑏\n1 0 1 1 0\n3: return (𝑐 , 𝑐 )\n0 1\n27"
  },
  {
    "input": "What is the role of the K-PKE component scheme in the context of the ML-KEM key-encapsulation mechanism?",
    "summary": "K-PKE is a component scheme used within the ML-KEM algorithm, providing key generation, encryption, and decryption functionalities. It relies on parameters like 𝑘, 𝜂, 𝑑, and 𝑑, which vary across different parameter sets. The algorithms operate in the NTT domain for efficiency, with the encryption key being public and the decryption key and seed remaining private. The decryption process uses the secret variables from the decryption key to recover the plaintext from the ciphertext.",
    "output": "FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n5. The K-PKE Component Scheme\nThis section describes the component scheme K-PKE. As discussed in Section 3.3, K-PKE is not\napproved for use in a stand-alone fashion. It serves only as a collection of subroutines for use in\nthe algorithms of the approved scheme ML-KEM, as described in Section 7.\nK-PKE consists of three algorithms:\n1. Key generation (K-PKE.KeyGen)\n2. Encryption (K-PKE.Encrypt)\n3. Decryption (K-PKE.Decrypt)\nWhen K-PKE is instantiated as part of ML-KEM, K-PKE inherits the parameter set selected for\nML-KEM. Each parameter set specifies numerical values for each parameter. While 𝑛 is always\n256 and 𝑞 is always 3329, the values of the remaining parameters 𝑘, 𝜂 , 𝜂 , 𝑑 , and 𝑑 vary\n1 2 𝑢 𝑣\namong the three parameter sets. Parameters and parameter sets are described in Section 8.\nThe algorithms in this section do not perform any input checking because they are only invoked as\nsubroutines of the main ML-KEM algorithms. The algorithms of ML-KEM themselves do perform\ninput checking as needed.\nEach of the algorithms of K-PKE is accompanied by a brief, informal description in text. For\nsimplicity, this description is written in terms of vectors and matrices whose entries are elements\nof 𝑅 . In the actual algorithm, most of the computations occur in the NTT domain in order to\n𝑞\nimprove the efficiency of multiplication. The relevant vectors and matrices will then have entries\nin 𝑇 . Linear-algebraic arithmetic with such vectors and matrices (e.g., line 18 of K-PKE.KeyGen)\n𝑞\nis performed as described in Sections 2.4.7 and 4.3.1. The encryption and decryption keys of\nK-PKE are also stored in the NTT form.\n5.1 K-PKE Key Generation\nThe key generation algorithm K-PKE.KeyGen of K-PKE (Algorithm 13) receives a seed as input and\noutputs an encryption key ek and a decryption key dk . As is typically the case for public-key\nPKE PKE\nencryption, the encryption key can be made public, while the decryption key and the randomness\nmust remain private. Indeed, the encryption key of K-PKE will serve as the encapsulation key of\nML-KEM (see ML-KEM.KeyGen below) and can thus be made public. Meanwhile, the decryption\nkey and seed of K-PKE.KeyGen must remain private as they can be used to perform decapsulation\nin ML-KEM.\nThe matrix 𝐀̂ generated in steps 3-7 of K-PKE.KeyGen can be stored, as specified in Section 3.3.\nThis allows later operations to use 𝐀̂ directly rather than re-expanding it from the public seed 𝜌.\nInformal description. The decryption key of K-PKE.KeyGen is a length-𝑘 vector 𝐬 of elements\nof 𝑅 (i.e., 𝐬 ∈ 𝑅𝑘). Roughly speaking, 𝐬 is a set of secret variables, while the encryption key is\n𝑞 𝑞\na collection of “noisy” linear equations (𝐀,𝐀𝐬 + 𝐞) in the secret variables 𝐬. The rows of the\nmatrix 𝐀 form the equation coefficients. This matrix is generated pseudorandomly using XOF\nwith only a seed stored in the encryption key. The secret 𝐬 and the “noise” 𝐞 are sampled from\n28\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nAlgorithm 13 K-PKE.KeyGen(𝑑)\nUses randomness to generate an encryption key and a corresponding decryption key.\nInput: randomness 𝑑 ∈ 𝔹32 .\nOutput: encryption key ek ∈ 𝔹384𝑘+32.\nPKE\nOutput: decryption key dk ∈ 𝔹384𝑘 .\nPKE\n1: (𝜌,𝜎) ← G(𝑑‖𝑘) ▷ expand 32+1 bytes to two pseudorandom 32-byte seeds1\n2: 𝑁 ←0\n3: for (𝑖 ← 0; 𝑖 < 𝑘; 𝑖++) ▷ generate matrix 𝐀̂ ∈ (ℤ256)𝑘×𝑘\n𝑞\n4: for (𝑗 ← 0; 𝑗 < 𝑘; 𝑗++)\n5: 𝐀̂[𝑖,𝑗] ← SampleNTT(𝜌‖𝑗‖𝑖) ▷ 𝑗 and 𝑖 are bytes 33 and 34 of the input\n6: end for\n7: end for\n8: for (𝑖 ← 0; 𝑖 < 𝑘; 𝑖++) ▷ generate 𝐬 ∈ (ℤ256)𝑘\n𝑞\n9: 𝐬[𝑖] ← SamplePolyCBD (PRF (𝜎,𝑁)) ▷ 𝐬[𝑖] ∈ ℤ256 sampled from CBD\n𝜂 1 𝜂 1 𝑞\n10: 𝑁 ←𝑁+1\n11: end for\n12: for (𝑖 ← 0; 𝑖 < 𝑘; 𝑖++) ▷ generate 𝐞 ∈ (ℤ256)𝑘\n𝑞\n13: 𝐞[𝑖] ← SamplePolyCBD (PRF (𝜎,𝑁)) ▷ 𝐞[𝑖] ∈ ℤ256 sampled from CBD\n𝜂 1 𝜂 1 𝑞\n14: 𝑁 ←𝑁+1\n15: end for\n16: 𝐬 ̂← NTT(𝐬) ▷ run NTT 𝑘 times (once for each coordinate of 𝐬)\n17: 𝐞 ̂← NTT(𝐞) ▷ run NTT 𝑘 times\n18: 𝐭̂← 𝐀̂ ∘ 𝐬̂ +𝐞̂ ▷ noisy linear system in NTT domain\n19: ek ← ByteEncode (𝐭)̂ ‖𝜌 ▷ run ByteEncode 𝑘 times, then append 𝐀̂-seed\nPKE 12 12\n20: dk ← ByteEncode (𝐬)̂ ▷ run ByteEncode 𝑘 times\nPKE 12 12\n21: return (ek ,dk )\nPKE PKE\ncentered binomial distributions using randomness expanded from another seed 𝜎 via PRF. Once\n𝐀, 𝐬, and 𝐞 are generated, the computation of the final part 𝐭 = 𝐀𝐬+𝐞 of the encryption key\ntakes place. The results are appropriately encoded into byte arrays and output.\nIn K-PKE.KeyGen, the choice of parameter set affects the length of the secret 𝐬 (via the parameter\n𝑘) and, as a consequence, the sizes of the noise vector 𝐞 and the pseudorandom matrix 𝐀. The\nchoice of parameter set also affects the noise distribution (via the parameter 𝜂 ) used to sample\n1\nthe entries of 𝐬 and 𝐞.\n5.2 K-PKE Encryption\nThe encryption algorithm K-PKE.Encrypt of K-PKE (Algorithm 14) takes an encryption key ek ,\nPKE\na 32-byte plaintext 𝑚, and randomness 𝑟 as input and produces a single output: a ciphertext 𝑐.\n1Byte 33 of the input to G is the module dimension 𝑘 ∈ {2,3,4} ⊂ 𝔹. This is included to establish domain separation\nbetween the three parameter sets. For implementations that use the seed in place of the private key, this ensures\nthat the expansion will produce an unrelated key if the seed is mistakenly expanded using a parameter set other\nthan the originally intended one.\n29\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nThe matrix 𝐀̂ generated in steps 4-8 of K-PKE.Encrypt can be stored, as specified in Section 3.3.\nThis allows later operations to use 𝐀̂ directly rather than re-expanding it from the public seed 𝜌.\nAlgorithm 14 K-PKE.Encrypt(ek ,𝑚,𝑟)\nPKE\nUses the encryption key to encrypt a plaintext message using the randomness 𝑟.\nInput: encryption key ek ∈ 𝔹384𝑘+32.\nPKE\nInput: message 𝑚 ∈ 𝔹32 .\nInput: randomness 𝑟 ∈ 𝔹32 .\nOutput: ciphertext 𝑐 ∈ 𝔹32(𝑑 𝑢 𝑘+𝑑 𝑣 ).\n1: 𝑁 ←0\n2: 𝐭 ̂ ← ByteDecode (ek [0 ∶ 384𝑘]) ▷ run ByteDecode 𝑘 times to decode 𝐭 ̂ ∈ (ℤ256 )𝑘\n12 PKE 12 𝑞\n3: 𝜌 ← ek [384𝑘 ∶ 384𝑘 + 32] ▷ extract 32-byte seed from ek\nPKE PKE\n4: for (𝑖 ← 0; 𝑖 < 𝑘; 𝑖++) ▷ re-generate matrix 𝐀̂ ∈ (ℤ256)𝑘×𝑘 sampled in Alg. 13\n𝑞\n5: for (𝑗 ← 0; 𝑗 < 𝑘; 𝑗++)\n6: 𝐀̂[𝑖,𝑗] ← SampleNTT(𝜌‖𝑗‖𝑖) ▷ 𝑗 and 𝑖 are bytes 33 and 34 of the input\n7: end for\n8: end for\n9: for (𝑖 ← 0; 𝑖 < 𝑘; 𝑖++) ▷ generate 𝐲 ∈ (ℤ256)𝑘\n𝑞\n10: 𝐲[𝑖] ← SamplePolyCBD (PRF (𝑟,𝑁)) ▷ 𝐲[𝑖] ∈ ℤ256 sampled from CBD\n𝜂 1 𝜂 1 𝑞\n11: 𝑁 ←𝑁+1\n12: end for\n13: for (𝑖 ← 0; 𝑖 < 𝑘; 𝑖++) ▷ generate 𝐞 ∈ (ℤ256)𝑘\n𝟏 𝑞\n14: 𝐞 [𝑖] ← SamplePolyCBD (PRF (𝑟,𝑁)) ▷ 𝐞 [𝑖] ∈ ℤ256 sampled from CBD\n𝟏 𝜂 2 𝜂 2 𝟏 𝑞\n15: 𝑁 ←𝑁+1\n16: end for\n17: 𝑒 ← SamplePolyCBD (PRF (𝑟,𝑁)) ▷ sample 𝑒 ∈ ℤ256 from CBD\n2 𝜂 2 𝜂 2 2 𝑞\n18: 𝐲̂ ← NTT(𝐲) ▷ run NTT 𝑘 times\n19: 𝐮 ← NTT −1(𝐀̂ ⊺ ∘ 𝐲̂ ) + 𝐞 ▷ run NTT −1 𝑘 times\n𝟏\n20: 𝜇 ← Decompress (ByteDecode (𝑚))\n1 1\n21: 𝑣 ← NTT −1(𝐭⊺̂ ∘𝐲̂ )+𝑒 +𝜇 ▷ encode plaintext 𝑚 into polynomial 𝑣\n2\n22: 𝑐 ← ByteEncode (Compress (𝐮)) ▷ run ByteEncode and Compress 𝑘 times\n1 𝑑 𝑑 𝑑 𝑑\n𝑢 𝑢 𝑢 𝑢\n23: 𝑐 ← ByteEncode (Compress (𝑣))\n2 𝑑 𝑑\n𝑣 𝑣\n24: return 𝑐 ← (𝑐 ‖𝑐 )\n1 2\nInformal description. The algorithm K-PKE.Encrypt begins by extracting the vector 𝐭 and the\nseed from the encryption key. The seed is then expanded to re-generate the matrix 𝐀 in the same\nmanner as was done in K-PKE.KeyGen. If 𝐭 and 𝐀 are derived correctly from an encryption key\nproduced by K-PKE.KeyGen, then they are equal to their corresponding values in K-PKE.KeyGen.\nRecall from the description of key generation that the pair (𝐀,𝐭 = 𝐀𝐬+𝐞) can be thought of as\na system of noisy linear equations in the secret variables 𝐬. One can generate an additional noisy\nlinear equation in the same secret variables — without knowing 𝐬 — by picking a random linear\n30\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\ncombination of the noisy equations in the system (𝐀,𝐭). One can then encode information in the\n“constant term” (i.e., the entry that is a linear combination of entries of 𝐭) of such a combined\nequation. This information can then be deciphered by a party in possession of 𝐬. For example,\none could encode a single bit by deciding whether or not to significantly alter the constant term,\nthus making either a nearly correct equation that corresponds to the decrypted bit value of 0 or a\nfar-from-correct equation that corresponds to the decrypted bit value of 1. In the case of K-PKE,\nthe constant term is a polynomial with 256 coefficients, so one can encode more information:\none bit in each coefficient.\nTo this end, K-PKE.Encrypt proceeds by generating a vector 𝐲 ∈ 𝑅𝑘 and noise terms 𝐞 ∈ 𝑅𝑘\n𝑞 𝟏 𝑞\nand 𝑒 ∈ 𝑅 , all of which are sampled from the centered binomial distribution using pseudoran-\n2 𝑞\ndomness expanded via PRF from the input randomness 𝑟. One then computes the “new noisy\nequation,” which is (up to some details) (𝐀⊺𝐲 + 𝐞 ,𝐭⊺𝐲 + 𝑒 ). An appropriate encoding 𝜇 of\n1 2\nthe input message 𝑚 is then added to the latter term in the pair. Finally, the resulting pair (𝐮,𝑣)\nis compressed, serialized into a byte array, and output as the ciphertext.\n5.3 K-PKE Decryption\nThe decryption algorithm K-PKE.Decrypt of K-PKE (Algorithm 15) takes a decryption key dk\nPKE\nand a ciphertext 𝑐 as input, requires no randomness, and outputs a plaintext 𝑚.\nInformal description. The algorithm K-PKE.Decrypt begins by recovering a pair (𝐮′,𝑣′) from the\nciphertext 𝑐 (see the description of K-PKE.Encrypt). Here, one can think of 𝐮′ as the coefficients\nof the equation and 𝑣′ as the constant term. The decryption key dk contains the vector of\nPKE\nsecret variables 𝐬. The decryption algorithm can thus use the decryption key to compute the\ntrue constant term 𝑣 = 𝐬⊺𝐮′ and calculate 𝑣′ −𝑣. The decryption algorithm ends by decoding\nthe plaintext message 𝑚 from 𝑣′ −𝑣 and outputting 𝑚.\nAlgorithm 15 K-PKE.Decrypt(dk ,𝑐)\nPKE\nUses the decryption key to decrypt a ciphertext.\nInput: decryption key dk ∈ 𝔹384𝑘 .\nPKE\nInput: ciphertext 𝑐 ∈ 𝔹32(𝑑 𝑢 𝑘+𝑑 𝑣 ).\nOutput: message 𝑚 ∈ 𝔹32 .\n1: 𝑐 ← 𝑐[0 ∶ 32𝑑 𝑘]\n1 𝑢\n2: 𝑐 ←𝑐[32𝑑 𝑘∶32(𝑑 𝑘+𝑑 )]\n2 𝑢 𝑢 𝑣\n3: 𝐮′ ← Decompress (ByteDecode (𝑐 )) ▷ run Decompress and ByteDecode 𝑘 times\n𝑑 𝑑 1 𝑑 𝑑\n𝑢 𝑢 𝑢 𝑢\n4: 𝑣′ ← Decompress (ByteDecode (𝑐 ))\n𝑑 𝑑 2\n𝑣 𝑣\n5: 𝐬 ̂← ByteDecode (dk ) ▷ run ByteDecode 𝑘 times\n12 PKE 12\n6: 𝑤 ← 𝑣′ − NTT −1(𝐬⊺̂ ∘ NTT(𝐮′)) ▷ run NTT 𝑘 times; run NTT −1 once\n7: 𝑚 ← ByteEncode (Compress (𝑤)) ▷ decode plaintext 𝑚 from polynomial 𝑣\n1 1\n8: return 𝑚\n31"
  },
  {
    "input": "What are the three main internal algorithms specified in the FIPS 203 module for lattice-based key-encapsulation mechanism and what is their purpose?",
    "summary": "The text describes the internal algorithms of the ML-KEM key-encapsulation mechanism, including key generation, encapsulation, and decapsulation. These algorithms are deterministic and use specific parameters like n, q, k, and others. They are designed to be used in constructing ML-KEM and are used for testing through the CAVP program. The decapsulation process includes an \"implicit rejection\" mechanism to handle mismatches in ciphertexts.",
    "output": "FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n6. Main Internal Algorithms\nThis section specifies three algorithms: ML-KEM.KeyGen_internal, ML-KEM.Encaps_internal,\nand ML-KEM.Decaps_internal. These three algorithms are all deterministic, meaning that their\noutput is completely determined by their input. No randomness is sampled inside of these\nalgorithms. These three algorithms will be used to construct ML-KEM in Section 7. The algorithms\nin this section make use of the parameters 𝑛, 𝑞, 𝑘, 𝑑 , and 𝑑 . The subroutines they invoke\n𝑢 𝑣\nadditionally make use of the parameters 𝜂 and 𝜂 . While 𝑛 is always 256 and 𝑞 is always 3329,\n1 2\nthe remaining parameters vary among the possible parameter sets (see Section 8).\nThe interfaces specified in this section will be used to test ML-KEM implementations through\nthe Cryptographic Algorithm Validation Program (CAVP). The key generation function in this\nsection may also be used to re-expand a key from a seed (see Section 3.3), including when\nobtaining assurance of private key possession via regeneration. As prescribed in Section 3.3, the\ninterfaces specified in this section should not be made available to applications other than for\ntesting purposes, and the random seeds (as specified in ML-KEM.KeyGen and ML-KEM.Encaps\nin Section 7) shall be generated by the cryptographic module.\n6.1 Internal Key Generation\nThe algorithm ML-KEM.KeyGen_internal (Algorithm 16) accepts two random seeds as input, and\nproduces an encapsulation key and a decapsulation key.\nInformal description. The core subroutine of ML-KEM.KeyGen_internal is the key generation\nalgorithm of K-PKE (Algorithm 13). The encapsulation key is simply the encryption key of K-PKE.\nThe decapsulation key consists of the decryption key of K-PKE, the encapsulation key, a hash\nof the encapsulation key, and a random 32-byte value. This random value will be used in the\n”implicit rejection” mechanism of the internal decapsulation algorithm (Algorithm 18).\nAlgorithm 16 ML-KEM.KeyGen_internal(𝑑,𝑧)\nUses randomness to generate an encapsulation key and a corresponding decapsulation key.\nInput: randomness 𝑑 ∈ 𝔹32 .\nInput: randomness 𝑧 ∈ 𝔹32 .\nOutput: encapsulation key ek ∈ 𝔹384𝑘+32 .\nOutput: decapsulation key dk ∈ 𝔹768𝑘+96 .\n1: (ek ,dk )← K-PKE.KeyGen(𝑑) ▷ run key generation for K-PKE\nPKE PKE\n2: ek ← ek ▷ KEM encaps key is just the PKE encryption key\nPKE\n3: dk ←(dk ‖ek‖H(ek)‖𝑧) ▷ KEM decaps key includes PKE decryption key\nPKE\n4: return (ek,dk)\n6.2 Internal Encapsulation\nThe algorithm ML-KEM.Encaps_internal (Algorithm 17) accepts an encapsulation key and a ran-\ndom byte array as input and outputs a ciphertext and a shared key.\n32\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nAlgorithm 17 ML-KEM.Encaps_internal(ek,𝑚)\nUses the encapsulation key and randomness to generate a key and an associated ciphertext.\nInput: encapsulation key ek ∈ 𝔹384𝑘+32 .\nInput: randomness 𝑚 ∈ 𝔹32 .\nOutput: shared secret key 𝐾 ∈ 𝔹32 .\nOutput: ciphertext 𝑐 ∈ 𝔹32(𝑑 𝑢 𝑘+𝑑 𝑣 ).\n1: (𝐾,𝑟) ← G(𝑚‖H(ek)) ▷ derive shared secret key 𝐾 and randomness 𝑟\n2: 𝑐 ← K-PKE.Encrypt(ek,𝑚,𝑟) ▷ encrypt 𝑚 using K-PKE with randomness 𝑟\n3: return (𝐾,𝑐)\nInformal description. The core subroutine of ML-KEM.Encaps_internal is the encryption algo-\nrithm of K-PKE, which is used to encrypt a random value 𝑚 into a ciphertext 𝑐. A copy of the\nshared secret key 𝐾 and the randomness used during encryption are derived from 𝑚 and the\nencapsulation key ek via hashing. Specifically, H is applied to ek, and the result is concatenated\nwith 𝑚 and then hashed using G. Finally, the algorithm outputs the shared secret key 𝐾 and the\nciphertext 𝑐.\n6.3 Internal Decapsulation\nThe algorithm ML-KEM.Decaps_internal (Algorithm 18) accepts a decapsulation key and a cipher-\ntext as input, does not use any randomness, and outputs a shared secret key.\nInformal description. The algorithm ML-KEM.Decaps_internal begins by parsing out the com-\nponents of the decapsulation key dk of ML-KEM. These components are an (encryption key,\ndecryption key) pair for K-PKE, a hash value ℎ, and a random value 𝑧. The decryption key of\nK-PKE is then used to decrypt the input ciphertext 𝑐 to get a plaintext 𝑚′ . The decapsulation\nalgorithm then re-encrypts 𝑚′ and computes a candidate shared secret key 𝐾′ in the same\nmanner as should have been done in encapsulation. Specifically, 𝐾′ and the encryption ran-\ndomness 𝑟′ are computed by hashing 𝑚′ and the encryption key of K-PKE, and a ciphertext 𝑐′ is\ngenerated by encrypting 𝑚′ using randomness 𝑟′ . Finally, decapsulation checks whether the\nresulting ciphertext 𝑐′ matches the provided ciphertext 𝑐. If it does not, the algorithm performs\nan “implicit rejection”: the value of 𝐾′ is changed to a hash of 𝑐 together with the random value\n𝑧 stored in the ML-KEM secret key (see the discussion of decapsulation failures in Section 3.2).\nIn either case, decapsulation outputs the resulting shared secret key 𝐾′ .\nThe “implicit reject” flag computed in step 9 (by comparing 𝑐 and 𝑐′ ) is a secret piece of interme-\ndiate data. As specified in the requirements in Section 3.3, this flag shall be destroyed prior to\nML-KEM.Decaps_internal terminating. In particular, returning the value of the flag as an output\nin any form is not permitted.\n33\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nAlgorithm 18 ML-KEM.Decaps_internal(dk,𝑐)\nUses the decapsulation key to produce a shared secret key from a ciphertext.\nInput: decapsulation key dk ∈ 𝔹768𝑘+96 .\nInput: ciphertext 𝑐 ∈ 𝔹32(𝑑 𝑢 𝑘+𝑑 𝑣 ).\nOutput: shared secret key 𝐾 ∈ 𝔹32 .\n1: dk ← dk[0 ∶ 384𝑘] ▷ extract (from KEM decaps key) the PKE decryption key\nPKE\n2: ek ← dk[384𝑘 ∶ 768𝑘 + 32] ▷ extract PKE encryption key\nPKE\n3: ℎ← dk[768𝑘 + 32 ∶ 768𝑘 + 64] ▷ extract hash of PKE encryption key\n4: 𝑧 ← dk[768𝑘 + 64 ∶ 768𝑘 + 96] ▷ extract implicit rejection value\n5: 𝑚′ ← K-PKE.Decrypt(dk ,𝑐) ▷ decrypt ciphertext\nPKE\n6: (𝐾′,𝑟′) ← G(𝑚′‖ℎ)\n7: 𝐾̄ ← J(𝑧‖𝑐)\n8: 𝑐′ ← K-PKE.Encrypt(ek ,𝑚′,𝑟′) ▷ re-encrypt using the derived randomness 𝑟′\nPKE\n9: if 𝑐 ≠𝑐′ then\n10: 𝐾′ ←𝐾̄ ▷ if ciphertexts do not match, “implicitly reject”\n11: end if\n12: return 𝐾′\n34\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n7. The ML-KEM Key-Encapsulation Mechanism\nThis section describes the three main algorithms of the ML-KEM scheme:\n1. Key generation (ML-KEM.KeyGen)\n2. Encapsulation (ML-KEM.Encaps)\n3. Decapsulation (ML-KEM.Decaps)\nTo instantiate ML-KEM, one must select a parameter set. Each parameter set is associated with\na particular trade-off between security and performance. The three possible parameter sets are\ncalled ML-KEM-512, ML-KEM-768, and ML-KEM-1024 and are described in detail in Table 2 of\nSection 8. Each parameter set assigns specific numerical values to the individual parameters 𝑛,\n𝑞, 𝑘, 𝜂 , 𝜂 , 𝑑 , and 𝑑 . While 𝑛 is always 256 and 𝑞 is always 3329, the remaining parameters\n1 2 𝑢 𝑣\nvary among the three parameter sets. Implementers shall ensure that the three algorithms of\nML-KEM listed above are only invoked with a valid parameter set, and that this parameter set is\nselected appropriately for the desired application. Moreover, implementers shall ensure that the\nparameter set used in any particular invocation of ML-KEM.Encaps or ML-KEM.Decaps matches\nthe parameter set associated to the provided inputs.\n7.1 ML-KEM Key Generation\nThe key generation algorithm ML-KEM.KeyGen for ML-KEM (Algorithm 19) accepts no input,\ngenerates randomness internally, and produces an encapsulation key and a decapsulation key.\nWhile the encapsulation key can be made public, the decapsulation key shall remain private.\nThe seed (𝑑,𝑧) generated in steps 1 and 2 of ML-KEM.KeyGen can be stored for later expan-\nsion using ML-KEM.KeyGen_internal (see Section 3.3). As the seed can be used to compute\nthe decapsulation key, it is sensitive data and shall be treated with the same safeguards as a\ndecapsulation key (see SP 800-227 [1]).\nAlgorithm 19 ML-KEM.KeyGen()\nGenerates an encapsulation key and a corresponding decapsulation key.\nOutput: encapsulation key ek ∈ 𝔹384𝑘+32 .\nOutput: decapsulation key dk ∈ 𝔹768𝑘+96 .\n1: 𝑑← $ − 𝔹32 ▷𝑑 is 32 random bytes (see Section 3.3)\n2: 𝑧← $ − 𝔹32 ▷𝑧 is 32 random bytes (see Section 3.3)\n3: if 𝑑 == NULL or 𝑧 == NULL then\n4: return ⊥ ▷ return an error indication if random bit generation failed\n5: end if\n6: (ek, dk)← ML-KEM.KeyGen_internal(𝑑,𝑧) ▷ run internal key generation algorithm\n7: return (ek,dk)\nSecure key establishment depends on the use of key pairs that have been properly generated\nvia ML-KEM.KeyGen. If the owner of a KEM key pair did not generate the key pair but instead\nreceived it from a trusted third party or other source, the owner may optionally perform certain\n35\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nchecks on the key pair. While these checks can detect certain corruptions, they do not guarantee\nthat the key pair was properly generated.\nKey pair check. To check a candidate key pair1 (ek,dk), perform the following checks:\n1. (Seed consistency) If a seed (𝑑,𝑧) is available, run ML-KEM.KeyGen_internal(𝑑,𝑧), and\nverify that the output is equal to (ek,dk).\n2. (Encapsulation key check) Check ek as specified in Section 7.2.\n3. (Decapsulation key check) Check dk as specified in Section 7.3.\n4. (Pair-wise consistency) Perform the following steps:\ni. Generate an array of 32 random bytes by performing 𝑚 ← $ − 𝔹32 .\nii. Perform (𝐾,𝑐) ← ML-KEM.Encaps_internal(ek,𝑚).\niii. Perform 𝐾′ ← ML-KEM.Decaps_internal(dk,𝑐).\niv. Reject unless 𝐾 == 𝐾′ .\nIt is important to note that this checking process does not guarantee that the key pair is a properly\nproduced output of ML-KEM.KeyGen.\n7.2 ML-KEM Encapsulation\nThe encapsulation algorithm ML-KEM.Encaps of ML-KEM (Algorithm 20) accepts an encapsula-\ntion key as input, generates randomness internally, and outputs a ciphertext and a shared key.\nThis algorithm requires input checking, as specified below.\nEncapsulation key check. To check a candidate encapsulation key ek, perform the following:\n1. (Type check) If ek is not an array of bytes of length 384𝑘 + 32 for the value of 𝑘 specified\nby the relevant parameter set, then input checking failed.\n2. (Modulus check) Perform the computation\ntest ← ByteEncode (ByteDecode (ek[0 ∶ 384𝑘])) (7.1)\n12 12\n(see Section 4.2.1). If test ≠ ek[0 ∶ 384𝑘], then input checking failed. This check ensures\nthat the integers encoded in the public key are in the valid range [0,𝑞 − 1].\nIf both checks pass, then ML-KEM.Encaps can be run with input ek ∶= ek. It is important to\nnote that this checking process does not guarantee that ek is a properly produced output of\nML-KEM.KeyGen.\nML-KEM.Encaps shall not be run with an encapsulation key that has not been checked as above.\nHowever, checking of the encapsulation key need not be performed by the encapsulating party,\n1In discussions of input checking, the “low overline” in the notation indicates that the input has not yet been\nchecked (e.g., ek has not yet been checked, while ek has passed the check).\n36\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nnor with every execution of ML-KEM.Encaps. Instead, assurance that these checks have been\nperformed can be acquired through other means (see SP 800-227 [1]).\nAlgorithm 20 ML-KEM.Encaps(ek)\nUses the encapsulation key to generate a shared secret key and an associated ciphertext.\nChecked input: encapsulation key ek ∈ 𝔹384𝑘+32 .\nOutput: shared secret key 𝐾 ∈ 𝔹32 .\nOutput: ciphertext 𝑐 ∈ 𝔹32(𝑑 𝑢 𝑘+𝑑 𝑣 ).\n1: 𝑚 ← $ − 𝔹32 ▷ 𝑚 is 32 random bytes (see Section 3.3)\n2: if 𝑚 == NULL then\n3: return ⊥ ▷ return an error indication if random bit generation failed\n4: end if\n5: (𝐾,𝑐) ← ML-KEM.Encaps_internal(ek,𝑚) ▷ run internal encapsulation algorithm\n6: return (𝐾,𝑐)\n7.3 ML-KEM Decapsulation\nThe decapsulation algorithm ML-KEM.Decaps of ML-KEM (Algorithm 21) accepts a decapsulation\nkey and an ML-KEM ciphertext as input, does not use any randomness, and outputs a shared\nsecret. This algorithm requires input checking, as specified below.\nDecapsulation input check. To check a candidate decapsulation key dk and ciphertext 𝑐, perform\nthe following checks:\n1. (Ciphertext type check) If 𝑐 is not a byte array of length 32(𝑑 𝑘 + 𝑑 ) for the values of 𝑑 ,\n𝑢 𝑣 𝑢\n𝑑 , and 𝑘 specified by the relevant parameter set, then input checking has failed.\n𝑣\n2. (Decapsulation key type check) If dk is not a byte array of length 768𝑘 + 96 for the value of\n𝑘 specified by the relevant parameter set, then input checking has failed.\n3. (Hash check) Perform the computation\ntest ← H(dk[384𝑘 ∶ 768𝑘+32])). (7.2)\nIf test ≠ dk[768𝑘 + 32 ∶ 768𝑘 + 64], then input checking has failed.\nIf all of the above checks pass, then ML-KEM.Decaps can be run with inputs dk ∶= dk and 𝑐 ∶= 𝑐. It\nis important to note that this checking process does not guarantee that dk is a properly produced\noutput of ML-KEM.KeyGen, nor that 𝑐 is a properly produced output of ML-KEM.Encaps.\nML-KEM.Decaps shall not be run with a decapsulation key or a ciphertext unless both have\nbeen checked. However, checking of the decapsulation key need not be performed by the\ndecapsulating party, nor with every execution of ML-KEM.Decaps. Instead, assurance that this\ncheck has been performed can be acquired through other means (see SP 800-227 [1]). Ciphertext\nchecking shall be performed with every execution of ML-KEM.Decaps.\n37\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nAlgorithm 21 ML-KEM.Decaps(dk,𝑐)\nUses the decapsulation key to produce a shared secret key from a ciphertext.\nChecked input: decapsulation key dk ∈ 𝔹768𝑘+96 .\nChecked input: ciphertext 𝑐 ∈ 𝔹32(𝑑 𝑢 𝑘+𝑑 𝑣 ).\nOutput: shared secret key 𝐾 ∈ 𝔹32 .\n1: 𝐾′ ← ML-KEM.Decaps_internal(dk,𝑐) ▷ run internal decapsulation algorithm\n2: return 𝐾′\n38"
  },
  {
    "input": "What are the three parameter sets approved for ML-KEM and their associated security strengths?",
    "summary": "The FIPS 203 standard defines three parameter sets for ML-KEM, each with specific values for key and ciphertext sizes. These parameter sets are associated with different security strengths and are designed to meet NIST's security categories. ML-KEM-768 is recommended as the default due to its balance of security and performance.",
    "output": "FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n8. Parameter Sets\nML-KEM is equipped with three parameter sets, each of the which comprises five individual\nparameters: 𝑘, 𝜂 , 𝜂 , 𝑑 , and 𝑑 . There are also two constants: 𝑛 = 256 and 𝑞 = 3329. The\n1 2 𝑢 𝑣\nfollowing is a brief and informal description of the roles played by the variable parameters in the\nalgorithms of K-PKE and ML-KEM. See Section 5 for details.\n• The parameter 𝑘 determines the dimensions of the matrix 𝐀̂ that appears in K-PKE.KeyGen\nand K-PKE.Encrypt. It also determines the dimensions of vectors 𝐬 and 𝐞 in K-PKE.KeyGen\nand the dimensions of vectors 𝐲 and 𝐞 in K-PKE.Encrypt.\n1\n• The parameter 𝜂 is required to specify the distribution for generating the vectors 𝐬 and 𝐞\n1\nin K-PKE.KeyGen and the vector 𝐲 in K-PKE.Encrypt.\n• The parameter 𝜂 is required to specify the distribution for generating the vectors 𝐞 and\n2 1\n𝑒 in K-PKE.Encrypt.\n2\n• The parameters 𝑑 and 𝑑 serve as parameters and inputs for the functions Compress,\n𝑢 𝑣\nDecompress, ByteEncode, and ByteDecode in K-PKE.Encrypt and K-PKE.Decrypt.\nThis standard approves the parameter sets given in Table 2. Each parameter set is associated\nwith a required security strength for randomness generation (see Section 3.3). The sizes of the\nML-KEM keys and ciphertexts for each parameter set are summarized in Table 3.\nTable 2. Approved parameter sets for ML-KEM\n𝑛 𝑞 𝑘 𝜂 𝜂 𝑑 𝑑 required RBG strength (bits)\n1 2 𝑢 𝑣\nML-KEM-512 256 3329 2 3 2 10 4 128\nML-KEM-768 256 3329 3 2 2 10 4 192\nML-KEM-1024 256 3329 4 2 2 11 5 256\nTable 3. Sizes (in bytes) of keys and ciphertexts of ML-KEM\nencapsulation key decapsulation key ciphertext shared secret key\nML-KEM-512 800 1632 768 32\nML-KEM-768 1184 2400 1088 32\nML-KEM-1024 1568 3168 1568 32\nA parameter set name can also be said to denote a (parameter-free) KEM. Specifically, ML-KEM-𝑥\ncan be used to denote the parameter-free KEM that results from instantiating the scheme\nML-KEM with the parameter set ML-KEM-𝑥.\nThe three parameter sets included in Table 2 were designed to meet certain security strength\ncategories defined by NIST in its original Call for Proposals [4, 22]. These security strength\ncategories are explained further in SP 800-57, Part 1 [7].\nUsing this approach, security strength is not described by a single number, such as “128 bits of\nsecurity.” Instead, each ML-KEM parameter set is claimed to be at least as secure as a generic\n39\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nblock cipher with a prescribed key size or a generic hash function with a prescribed output\nlength. More precisely, it is claimed that the computational resources needed to break ML-KEM\nare greater than or equal to the computational resources needed to break the block cipher or\nhash function when those computational resources are estimated using any realistic model of\ncomputation. Different models of computation can be more or less realistic and, accordingly,\nlead to more or less accurate estimates of security strength. Some commonly studied models\nare discussed in [23].\nConcretely, ML-KEM-512 is claimed to be in security category 1, ML-KEM-768 is claimed to be\nin security category 3, and ML-KEM-1024 is claimed to be in security category 5. For additional\ndiscussion of the security strength of MLWE-based cryptosystems, see [4].\nSelecting an appropriate parameter set. When initially establishing cryptographic protections\nfor data, the strongest possible parameter set should be used. This has a number of advantages,\nincluding reducing the likelihood of costly transitions to higher-security parameter sets in the\nfuture. At the same time, it should be noted that some parameter sets might have adverse\nperformance effects for the relevant application (e.g., the algorithm may be unacceptably slow,\nor objects such as keys or ciphertexts may be unacceptably large).\nNIST recommends using ML-KEM-768 as the default parameter set, as it provides a large security\nmargin at a reasonable performance cost. In cases where this is impractical or even higher\nsecurity is required, other parameter sets may be used.\n40\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nReferences\n[1] National Institute of Standards and Technology (2024) Recommendations for key-\nencapsulation mechanisms, (National Institute of Standards and Technology, Gaithers-\nburg, MD), NIST Special Publication (SP) 800-227. [Forthcoming; will be available at\nhttps://csrc.nist.gov/publications].\n[2] Barker EB, Chen L, Roginsky AL, Vassilev A, Davis R (2018) Recommendation for pair-wise\nkey-establishment schemes using discrete logarithm cryptography (National Institute of\nStandards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-56A Revi-\nsion 3. https://doi.org/10.6028/NIST.SP.800-56Ar3.\n[3] Barker EB, Chen L, Roginsky AL, Vassilev A, Davis R, Simon S (2019) Recommendation for\npair-wise key-establishment using integer factorization cryptography (National Institute\nof Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-56B\nRevision 2. https://doi.org/10.6028/NIST.SP.800-56Br2.\n[4] Avanzi R, Bos J, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schanck JM, Schwabe P, Seiler G,\nStehlé D (2020) CRYSTALS-Kyber algorithm specifications and supporting documentation,\nThird-round submission to the NIST’s post-quantum cryptography standardization process.\nAvailable at https://csrc.nist.gov/Projects/post-quantum-cryptography/post-quantum-cry\nptography-standardization/round-3-submissions.\n[5] National Institute of Standards and Technology (2015) Secure hash standard (SHS), (U.S.\nDepartment of Commerce, Washington, DC), Federal Information Processing Standards\nPublication (FIPS) 180-4. https://doi.org/10.6028/NIST.FIPS.180-4.\n[6] National Institute of Standards and Technology (2015) SHA-3 standard: Permutation-based\nhash and extendable-output functions, (U.S. Department of Commerce, Washington, DC),\nFederal Information Processing Standards Publication (FIPS) 202. https://doi.org/10.6028/\nNIST.FIPS.202.\n[7] Barker EB (2020) Recommendation for key management: Part 1 -General, (National Institute\nof Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-57 Part\n1, Rev. 5 [or as amended]. https://doi.org/10.6028/NIST.SP.800-57pt1r5.\n[8] Bos J, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schanck JM, Schwabe P, Seiler G, Stehlé\nD (2018) CRYSTALS-Kyber: A CCA-secure module-lattice-based KEM. 2018 IEEE European\nSymposium on Security and Privacy (EuroS&P), pp 353–367. https://doi.org/10.1109/Euro\nSP.2018.00032.\n[9] Langlois A, Stehlé D (2015) Worst-case to average-case reductions for module lattices.\nDesigns, Codes and Cryptography 75(3):565–599. https://doi.org/10.1007/s10623-014-9\n938-4.\n[10] Regev O (2005) On lattices, learning with errors, random linear codes, and cryptography.\nProceedings of the Thirty-Seventh Annual ACM Symposium on Theory of Computing STOC\n’05 (Association for Computing Machinery, New York, NY, USA), pp 84––93. https://doi.org/\n10.1145/1060590.1060603.\n41\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n[11] Fujisaki E, Okamoto T (2013) Secure integration of asymmetric and symmetric encryption\nschemes. Journal of Cryptology 26:80–101. https://doi.org/10.1007/s00145-011-9114-1.\n[12] Hofheinz D, Hövelmanns K, Kiltz E (2017) A modular analysis of the Fujisaki-Okamoto trans-\nformation. Theory of Cryptography, eds Kalai Y, Reyzin L (Springer International Publishing,\nCham), pp 341–371. https://doi.org/10.1007/978-3-319-70500-2_12.\n[13] Katz J, Lindell Y (2020) Introduction to Modern Cryptography (Chapman & Hall/CRC), 3rd Ed.\n[14] Almeida JB, Olmos SA, Barbosa M, Barthe G, Dupressoir F, Grégoire B, Laporte V, Léchenet JC,\nLow C, Oliveira T, Pacheco H, Quaresma M, Schwabe P, Strub PY (2024) Formally verifying Ky-\nber episode V: Machine-checked IND-CCA security and correctness of ML-KEM in EasyCrypt,\nCryptology ePrint Archive, Paper 2024/843. Available at https://eprint.iacr.org/2024/843.\n[15] Ducas L, Schanck J (2021) Security estimation scripts for Kyber and Dilithium, Github reposi-\ntory. Available at https://github.com/pq-crystals/security-estimates.\n[16] Chen L (2022) Recommendation for key derivation using pseudorandom functions, (National\nInstitute of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP)\n800-108r1-upd1, Includes updates as of February 2, 2024. https://doi.org/10.6028/NIST.SP.\n800-108r1-upd1.\n[17] Barker EB, Chen L, Davis R (2020) Recommendation for key-derivation methods in key-\nestablishment schemes (National Institute of Standards and Technology, Gaithersburg, MD),\nNIST Special Publication (SP) 800-56C Revision 2. https://doi.org/10.6028/NIST.SP.800-56C\nr2.\n[18] Barker EB, Kelsey JM (2015) Recommendation for random number generation using deter-\nministic random bit generators, (National Institute of Standards and Technology, Gaithers-\nburg, MD), NIST Special Publication (SP) 800-90A, Rev. 1. https://doi.org/10.6028/NIST.SP.\n800-90Ar1.\n[19] Sönmez Turan M, Barker EB, Kelsey JM, McKay KA, Baish ML, Boyle M (2018) Recom-\nmendation for the entropy sources used for random bit generation, (National Institute\nof Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-90B.\nhttps://doi.org/10.6028/NIST.SP.800-90B.\n[20] Barker E, Kelsey J, McKay K, Roginsky A, Turan MS (2024) Recommendation for random bit\ngenerator (RBG) constructions, (National Institute of Standards and Technology, Gaithers-\nburg, MD), NIST Special Publication (SP) 800-90C 4pd. https://doi.org/10.6028/NIST.SP.80\n0-90C.4pd.\n[21] Kelsey J, Chang S, Perlner R (2016) SHA-3 Derived Functions: cSHAKE, KMAC, TupleHash\nand ParallelHash, (National Institute of Standards and Technology, Gaithersburg, MD), NIST\nSpecial Publication (SP) 800-185 [or as amended]. https://doi.org/10.6028/NIST.SP.800-1\n85.\n[22] National Institute of Standards and Technology (2016) Submission requirements and eval-\nuation criteria for the post-quantum cryptography standardization process. Available at\nhttps://csrc.nist.gov/CSRC/media/Projects/Post-Quantum-Cryptography/documents/call-f\nor-proposals-final-dec-2016.pdf.\n42\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\n[23] Alagic G, Apon D, Cooper D, Dang Q, Dang T, Kelsey J, Lichtinger J, Liu YK, Miller C, Moody\nD, Peralta R, Perlner R, Robinson A, Smith-Tone D (2022) Status report on the third round\nof the NIST post-quantum cryptography standardization process (National Institute of\nStandards and Technology, Gaithersburg, MD), NIST Interagency or Internal Report (IR)\n8413. https://doi.org/10.6028/NIST.IR.8413-upd1.\n[24] CRYSTALS-Kyber submission team (2023) “Discussion about Kyber’s tweaked FO transform”,\nPQC-Forum Post. Available at https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/W\nFRDl8DqYQ4.\n[25] CRYSTALS-Kyber submission team (2023) “Kyber decisions, part 2: FO transform”, PQC-\nForum Post. Available at https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/C0D3W\n1KoINY/m/99kIvydoAwAJ.\n43\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nAppendix A — Precomputed Values for the NTT\nThe following 128 numbers are the values of 𝜁BitRev\n7\n(𝑖) mod 𝑞 for 𝑖 ∈ {0,…,127}. These numbers\nare used in Algorithms 9 and 10.\n{ 1 1729 2580 3289 2642 630 1897 848\n1062 1919 193 797 2786 3260 569 1746\n296 2447 1339 1476 3046 56 2240 1333\n1426 2094 535 2882 2393 2879 1974 821\n289 331 3253 1756 1197 2304 2277 2055\n650 1977 2513 632 2865 33 1320 1915\n2319 1435 807 452 1438 2868 1534 2402\n2647 2617 1481 648 2474 3110 1227 910\n17 2761 583 2649 1637 723 2288 1100\n1409 2662 3281 233 756 2156 3015 3050\n1703 1651 2789 1789 1847 952 1461 2687\n939 2308 2437 2388 733 2337 268 641\n1584 2298 2037 3220 375 2549 2090 1645\n1063 319 2773 757 2099 561 2466 2594\n2804 1092 403 1026 1143 2150 2775 886\n1722 1212 1874 1029 2110 2935 885 2154 }\n44\nFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nWhen implementing Algorithm 11, the values 𝜁2BitRev\n7\n(𝑖)+1 mod 𝑞 need to be computed. The\nfollowing array contains these values for 𝑖 ∈ {0,…,127}:\n{ 17 -17 2761 -2761 583 -583 2649 -2649\n1637 -1637 723 -723 2288 -2288 1100 -1100\n1409 -1409 2662 -2662 3281 -3281 233 -233\n756 -756 2156 -2156 3015 -3015 3050 -3050\n1703 -1703 1651 -1651 2789 -2789 1789 -1789\n1847 -1847 952 -952 1461 -1461 2687 -2687\n939 -939 2308 -2308 2437 -2437 2388 -2388\n733 -733 2337 -2337 268 -268 641 -641\n1584 -1584 2298 -2298 2037 -2037 3220 -3220\n375 -375 2549 -2549 2090 -2090 1645 -1645\n1063 -1063 319 -319 2773 -2773 757 -757\n2099 -2099 561 -561 2466 -2466 2594 -2594\n2804 -2804 1092 -1092 403 -403 1026 -1026\n1143 -1143 2150 -2150 2775 -2775 886 -886\n1722 -1722 1212 -1212 1874 -1874 1029 -1029\n2110 -2110 2935 -2935 885 -885 2154 -2154 }\n45"
  },
  {
    "input": "What is the recommended number of iterations for the while loop in SampleNTT and what is the probability of reaching that limit?",
    "summary": "SampleNTT uses a while loop to generate byte arrays from an XOF until all 256 coefficients of 𝑇 are within bounds. On average, this loop runs efficiently, but in some cases, it may require more iterations. Implementations should not set a loop limit unless necessary, as an incorrect limit can cause interoperability issues. If a limit is used, it should not be lower than the value in Table 4, which provides the number of iterations and the probability of exceeding them.",
    "output": "FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nAppendix B — SampleNTT Loop Bounds\nIn SampleNTT (Algorithm 7), the algorithm repeatedly generates byte arrays from the XOF to\ncreate an element of 𝑇 . If a generated byte array value is out of bounds for a coefficient of 𝑇 ,\n𝑞 𝑞\nthe algorithm tries again until all 256 coefficients are created. On average, this while loop will\nresolve within a reasonable number of iterations. However, there may be cases in which the\ngenerated byte arrays are consistently out of bounds and the algorithm may run for a higher\nnumber of iterations.\nImplementations should not bound this loop, if at all possible. An incorrect limit will cause\ninteroperability errors, and the chances for SampleNTT to iterate longer become exponentially\nrare. If an implementation does bound the number of iterations of SampleNTT, it shall not use a\nlimit lower than those presented in Table 4. The calculated probability of SampleNTT exceeding\nthe limit is included and calculated under standard assumptions about the output distributions\nof XOFs and hash functions.\nTable 4. While-loop limits and probabilities of occurrence for SampleNTT\nNumber of iterations Probability of reaching limit\n280 2−261\nIf a limit is used and the number of iterations exceeds the limit, then the algorithm shall destroy\nall intermediate results. If a return value or exception is produced, it shall be the same value for\nany execution in which the maximum number of iterations is exceeded.\n46"
  },
  {
    "input": "What are the key differences between CRYSTALS-Kyber and the ML-KEM scheme as specified in FIPS 203?",
    "summary": "This appendix outlines the key differences between CRYSTALS-Kyber and the ML-KEM scheme, focusing on input-output behavior of the main algorithms. The shared secret key in ML-KEM is fixed at 256 bits, unlike the variable-length key in CRYSTALS-Kyber. ML-KEM uses a modified Fujisaki-Okamoto transform, omitting the hash of the ciphertext in Encaps and adjusting Decaps accordingly. Additionally, the initial randomness in ML-KEM is used directly without hashing, and explicit input checks are included to ensure correct decoding of the encapsulation key.",
    "output": "FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM\nAppendix C — Differences From the CRYSTALS-Kyber Submission\nThis appendix lists the differences between CRYSTALS-KYBER (as described in [4]) and the ML-KEM\nscheme (specified in this document) that result in differing input-output behavior of the main\nalgorithms (i.e., KeyGen, Encaps, Decaps). Since a conforming implementation need only match\nthe input-output behavior of these three algorithms (see “Implementations” and Section 3.3\nbelow), the list does not include any of the numerous differences in how the main algorithms actu-\nally produce outputs from inputs (e.g., via different computational steps or different subroutines),\nnor any differences in presentation between this standard and [4].\nC.1 Differences Between CRYSTALS-Kyber and FIPS 203 Initial Pub-\nlic Draft\n• In the third-round specification [4], the shared secret key was treated as a variable-length\nvalue whose length depended on how it would be used in the relevant application. In this\nspecification, the length of the shared secret key is fixed to 256 bits. It can be used directly\nin applications as a symmetric key, or symmetric keys can be derived from it, as specified\nin Section 3.3.\n• The ML-KEM.Encaps and ML-KEM.Decaps algorithms in this specification use a different\nvariant of the Fujisaki-Okamoto transform (see [24, 25]) than the third-round specifica-\ntion [4]. Specifically, ML-KEM.Encaps no longer includes a hash of the ciphertext in the\nderivation of the shared secret, and ML-KEM.Decaps has been adjusted to match this\nchange.\n• In the third-round specification [4], the initial randomness 𝑚 in the ML-KEM.Encaps algo-\nrithm was first hashed before being used. Specifically, between lines 1 and 2 in Algorithm\n20, there was an additional step that performed the operation 𝑚 ← 𝐻(𝑚). The purpose\nof this step was to safeguard against the use of flawed randomness generation processes.\nAs this standard requires the use of NIST-approved randomness generation, this step is\nunnecessary and is not performed in ML-KEM.\n• This specification includes explicit input checking steps that were not part of the third-round\nspecification [4]. For example, ML-KEM.Encaps requires that the byte array containing the\nencapsulation key correctly decodes to an array of integers modulo 𝑞 without any modular\nreductions.\nC.2 Changes From FIPS 203 Initial Public Draft\nThe differences between CRYSTALS-KYBER and ML-KEM as described in Appendix C were included\nin the initial public draft (ipd) of FIPS 203, which was posted on August 24, 2023. Based on\ncomments submitted on the draft ML-KEM, domain separation was added to K-PKE.KeyGen to\nprevent the misuse of keys generated to target one security level from being used for a different\nsecurity level when saving a key as a seed.\nAdditionally, FIPS 203 ipd had inadvertently swapped the indices of matrix 𝐀̂ in K-PKE.KeyGen and\nK-PKE.Encrypt. This was changed back in the final version of ML-KEM to match CRYSTALS-KYBER.\n47"
  }
]