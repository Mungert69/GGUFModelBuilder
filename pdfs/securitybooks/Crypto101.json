[
  {
    "input": "Contents",
    "output": "Contents\nContents 4\nI Foreword 9\n1 Aboutthisbook 10\n2 Advancedsections 12\n3 Development 13\n4 Acknowledgments 14\nII Buildingblocks 16\n5 Exclusiveor 17\n5.1 Description . . . . . . . . . . . . . . . . . . . 17\n5.2 AfewpropertiesofXOR . . . . . . . . . . . . 18\n5.3 BitwiseXOR . . . . . . . . . . . . . . . . . . . 19\n5.4 One-timepads . . . . . . . . . . . . . . . . . . 19\n5.5 Attackson“one-timepads” . . . . . . . . . . . 21\n5.6 Remainingproblems . . . . . . . . . . . . . . 26\n6 Blockciphers 28\n6.1 Description . . . . . . . . . . . . . . . . . . . 28\n6.2 AES . . . . . . . . . . . . . . . . . . . . . . . . 33\n4\n6.3 DESand3DES . . . . . . . . . . . . . . . . . . 37\n6.4 Remainingproblems . . . . . . . . . . . . . . 40\n7 Streamciphers 41\n7.1 Description . . . . . . . . . . . . . . . . . . . 41\n7.2 Anaiveattemptwithblockciphers . . . . . . 41\n7.3 Blockciphermodesofoperation . . . . . . . . 48\n7.4 CBCmode . . . . . . . . . . . . . . . . . . . . 48\n7.5 AttacksonCBCmodewithpredictableIVs . . 50\n7.6 AttacksonCBCmodewiththekeyastheIV . . 52\n7.7 CBCbitflippingattacks . . . . . . . . . . . . . 53\n7.8 Padding . . . . . . . . . . . . . . . . . . . . . 56\n7.9 CBCpaddingattacks . . . . . . . . . . . . . . 57\n7.10 Nativestreamciphers . . . . . . . . . . . . . . 65\n7.11 RC4 . . . . . . . . . . . . . . . . . . . . . . . . 66\n7.12 Salsa20 . . . . . . . . . . . . . . . . . . . . . . 75\n7.13 Nativestreamciphersversusmodesofopera-\ntion. . . . . . . . . . . . . . . . . . . . . . . . 77\n7.14 CTRmode . . . . . . . . . . . . . . . . . . . . 78\n7.15 Streamcipherbitflippingattacks . . . . . . . 79\n7.16 Authenticatingmodesofoperation . . . . . . 80\n7.17 Remainingproblems . . . . . . . . . . . . . . 80\n8 Keyexchange 81\n8.1 Description . . . . . . . . . . . . . . . . . . . 81\n8.2 AbstractDiffie-Hellman. . . . . . . . . . . . . 82\n8.3 Diffie-Hellmanwithdiscretelogarithms . . . . 86\n8.4 Diffie-Hellmanwithellipticcurves . . . . . . . 87\n8.5 Remainingproblems . . . . . . . . . . . . . . 88\n9 Public-keyencryption 90\n9.1 Description . . . . . . . . . . . . . . . . . . . 90\n9.2 Whynotusepublic-keyencryptionforevery-\nthing? . . . . . . . . . . . . . . . . . . . . . . 91\n9.3 RSA . . . . . . . . . . . . . . . . . . . . . . . 92\n9.4 Ellipticcurvecryptography . . . . . . . . . . . 96\n5\n9.5 Remaining problem: unauthenticated en-\ncryption . . . . . . . . . . . . . . . . . . . . . 96\n10 Hashfunctions 98\n10.1 Description . . . . . . . . . . . . . . . . . . . 98\n10.2 MD5 . . . . . . . . . . . . . . . . . . . . . . . 100\n10.3 SHA-1 . . . . . . . . . . . . . . . . . . . . . . 101\n10.4 SHA-2 . . . . . . . . . . . . . . . . . . . . . . 102\n10.5 KeccakandSHA-3 . . . . . . . . . . . . . . . . 103\n10.6 Passwordstorage . . . . . . . . . . . . . . . . 104\n10.7 Lengthextensionattacks . . . . . . . . . . . . 108\n10.8 Hashtrees . . . . . . . . . . . . . . . . . . . . 110\n10.9 Remainingissues . . . . . . . . . . . . . . . . 110\n11 Messageauthenticationcodes 111\n11.1 Description . . . . . . . . . . . . . . . . . . . 111\n11.2 CombiningMACandmessage . . . . . . . . . 113\n11.3 Anaiveattemptwithhashfunctions . . . . . . 115\n11.4 HMAC . . . . . . . . . . . . . . . . . . . . . . 119\n11.5 One-timeMACs . . . . . . . . . . . . . . . . . 120\n11.6 Carter-WegmanMAC . . . . . . . . . . . . . . 123\n11.7 Authenticatedencryptionmodes . . . . . . . 124\n11.8 OCBmode . . . . . . . . . . . . . . . . . . . . 126\n11.9 GCMmode. . . . . . . . . . . . . . . . . . . . 128\n12 Signaturealgorithms 130\n12.1 Description . . . . . . . . . . . . . . . . . . . 130\n12.2 RSA-basedsignatures . . . . . . . . . . . . . . 131\n12.3 DSA . . . . . . . . . . . . . . . . . . . . . . . 131\n12.4 ECDSA . . . . . . . . . . . . . . . . . . . . . . 136\n12.5 Repudiableauthenticators . . . . . . . . . . . 136\n13 Keyderivationfunctions 137\n13.1 Description . . . . . . . . . . . . . . . . . . . 137\n13.2 Passwordstrength . . . . . . . . . . . . . . . 138\n13.3 PBKDF2 . . . . . . . . . . . . . . . . . . . . . 139\n13.4 bcrypt . . . . . . . . . . . . . . . . . . . . . . 139\n13.5 scrypt . . . . . . . . . . . . . . . . . . . . . . 139\n6\n13.6 HKDF . . . . . . . . . . . . . . . . . . . . . . 139\n14 Randomnumbergenerators 143\n14.1 Introduction . . . . . . . . . . . . . . . . . . . 143\n14.2 Truerandomnumbergenerators . . . . . . . 144\n14.3 Cryptographicallysecurepseudorandomgen-\nerators . . . . . . . . . . . . . . . . . . . . . . 146\n14.4 Yarrow . . . . . . . . . . . . . . . . . . . . . . 147\n14.5 BlumBlumShub . . . . . . . . . . . . . . . . 148\n14.6 Dual_EC_DRBG . . . . . . . . . . . . . . . . . 148\n14.7 MersenneTwister . . . . . . . . . . . . . . . . 155\nIIICompletecryptosystems 162\n15 SSLandTLS 163\n15.1 Description . . . . . . . . . . . . . . . . . . . 163\n15.2 Handshakes . . . . . . . . . . . . . . . . . . . 164\n15.3 Certificateauthorities . . . . . . . . . . . . . . 165\n15.4 Self-signedcertificates . . . . . . . . . . . . . 166\n15.5 Clientcertificates . . . . . . . . . . . . . . . . 166\n15.6 Perfectforwardsecrecy . . . . . . . . . . . . . 166\n15.7 Attacks . . . . . . . . . . . . . . . . . . . . . . 168\n15.8 HSTS . . . . . . . . . . . . . . . . . . . . . . . 171\n15.9 Certificatepinning . . . . . . . . . . . . . . . 172\n15.10Secureconfigurations . . . . . . . . . . . . . . 173\n16 OpenPGPandGPG 175\n16.1 Description . . . . . . . . . . . . . . . . . . . 175\n16.2 Theweboftrust . . . . . . . . . . . . . . . . . 176\n17 Off-The-RecordMessaging(OTR) 179\n17.1 Description . . . . . . . . . . . . . . . . . . . 179\n17.2 Keyexchange . . . . . . . . . . . . . . . . . . 180\n17.3 Dataexchange . . . . . . . . . . . . . . . . . . 184\n7\n8\nIV Appendices 185\nA Modulararithmetic 186\nA.1 Additionandsubtraction . . . . . . . . . . . . 186\nA.2 Primenumbers . . . . . . . . . . . . . . . . . 189\nA.3 Multiplication . . . . . . . . . . . . . . . . . . 190\nA.4 Divisionandmodularinverses . . . . . . . . . 191\nA.5 Exponentiation . . . . . . . . . . . . . . . . . 192\nA.6 Exponentiationbysquaring . . . . . . . . . . 193\nA.7 Montgomeryladderexponentiation . . . . . . 195\nA.8 Discretelogarithm . . . . . . . . . . . . . . . 200\nA.9 Multiplicativeorder . . . . . . . . . . . . . . . 201\nB Ellipticcurves 202\nB.1 Theellipticcurvediscretelogproblem . . . . 204\nC Side-channelattacks 205\nC.1 Timingattacks. . . . . . . . . . . . . . . . . . 205\nC.2 Powermeasurementattacks . . . . . . . . . . 205\nV Glossary 206\nIndex 212\nVI References 215\nBibliography 216"
  },
  {
    "input": "About this book",
    "output": "1\nAbout this book\nLotsofpeopleworkingincryptographyhaveno\ndeepconcernwithrealapplicationissues. They\nare trying to discover things clever enough to\nwritepapersabout.\nWhitfieldDiffie\nThisbookisintendedasanintroductiontocryptography\nfor programmers of any skill level. Itʼs a continuation of a\ntalkofthesamename,whichwasgivenbytheauthoratPy-\nCon2013.\nThe structure of this book is very similar: it starts with\nvery simple primitives, and gradually introduces new ones,\ndemonstratingwhytheyʼrenecessary. Eventually,allofthis\nisputtogetherintocomplete,practicalcryptosystems,such\nasTLS,GPGandOTR.\nThe goal of this book is not to make anyone a cryptog-\nrapher or a security researcher. The goal of this book is to\nunderstandhowcompletecryptosystemsworkfromabirdʼs\neyeview,andhowtoapplytheminrealsoftware.\nTheexercisesaccompanyingthisbookfocusonteaching\ncryptography by breaking inferior systems. That way, you\n10\nCHAPTER1. ABOUTTHISBOOK 11\nwonʼtjust“know”thatsomeparticularthingisbroken;youʼll\nknowexactlyhowitʼsbroken,andthatyou,yourself,armed\nwithlittlemorethansomesparetimeandyourfavoritepro-\ngramminglanguage, canbreakthem. Byseeing how these\nostensibly secure systems are actually completely broken,\nyou will understand why all these primitives and construc-\ntionsarenecessaryforcompletecryptosystems. Hopefully,\nthese exercises will also leave you with healthy distrust of\nDIYcryptographyinallitsforms.\nFor a long time, cryptography has been deemed the ex-\nclusive realm of experts. From the many internal leaks\nweʼveseenovertheyearsoftheinternalsofbothlargeand\nsmallcorporationsalike,ithasbecomeobviousthatthatap-\nproach is doing more harm than good. We can no longer\naffordtokeepthetwoworldsstrictlyseparate. Wemustjoin\nthem into one world where all programmers are educated\nin the basic underpinnings of information security, so that\nthey can work together with information security profes-\nsionalstoproducemoresecuresoftwaresystemsforevery-\none. Thatdoesnotmakepeoplesuchaspenetrationtesters\nandsecurityresearchersobsoleteorlessvaluable;quitethe\nopposite,infact. Bysensitizingallprogrammerstosecurity\nconcerns, the need for professional security audits will be-\ncomemoreapparent,notless.\nThis book hopes to be a bridge: to teach everyday pro-\ngrammersfromanyfieldorspecializationtounderstandjust\nenoughcryptographytodotheirjobs, ormaybejustsatisfy\ntheirappetite."
  },
  {
    "input": "Advanced sections",
    "output": "2\nAdvanced sections\nThisbookisintendedasapracticalguidetocryptographyfor\nprogrammers. Somesectionsgointomoredepththanthey\nneedtoinordertoachievethatgoal. Theyʼreinthebookany-\nway,justincaseyouʼrecurious;butIgenerallyrecommend\nskippingthesesections. Theyʼllbemarkedlikethis:\nThisisanoptional,in-depthsection. It\nalmost certainly wonʼt help you write bet-\ntersoftware,sofeelfreetoskipit. Itisonly\nheretosatisfyyourinnergeekʼscuriosity.\n12"
  },
  {
    "input": "Development",
    "output": "3\nDevelopment\nThe entire Crypto 101 project is publicly developed on\nGitHub under the crypto101 organization, including this\nbook.\nThis is an early pre-release of this book. All of your\nquestions, comments and bug reports are highly appreci-\nated. Ifyoudonʼtunderstandsomethingafterreadingit,or\nasentenceisparticularlyclumsilyworded,that’sabug and\nI would very much like to fix it! Of course, if I never hear\naboutyourissue,itʼsveryhardformetoaddress…\nThe copy of this book that you are reading right now is\nbased on the git commit with hash 64e8ccf, also known as\n0.6.0-95-g64e8ccf.\n13"
  },
  {
    "input": "Acknowledgments",
    "output": "4\nAcknowledgments\nThisbookwouldnothavebeenpossiblewithoutthesupport\nandcontributionsofmanypeople,evenbeforethefirstpub-\nlicrelease. Somepeoplereviewedthetext,somepeoplepro-\nvided technical review, and some people helped with the\noriginaltalk. Innoparticularorder:\n• Mywife,Ewa\n• BrianWarner\n• OskarŻabik\n• IanCordasco\n• ZookoWilcox-OʼHearn\n• NathanNguyen(@nathanhere)\nFollowing the public release, many more people con-\ntributed changes. Iʼd like to thank the following people in\nparticular(again,innoparticularorder):\n• coh2,forworkonillustrations\n14\nCHAPTER4. ACKNOWLEDGMENTS 15\n• TinnedTuna,forreviewworkontheXORsection(and\nothers)\n• dfc,forworkontypographyandalternativeformats\n• jvasile,forworkontypefacesandautomatedbuilds\n• hmmueller,formany,manynotesandsuggestions\n• postboy(IvanZuboff),formanyreportedissues\n• EdOverflow,formanycontributions\n• gliptak(GáborLipták)forworkonautomatingbuilds,\nas well as the huge number of people that contributed\nspelling,grammarandcontentimprovements. Thankyou!"
  },
  {
    "input": "Description",
    "output": "5\nExclusive or\n5.1 Description\nExclusive or, often called “XOR”, is a Boolean1 binary2 op-\nerator that is true when either the first input or the second\ninput,butnotboth,aretrue.\nAnother way to think of XOR is as something called a\n“programmable inverter”: one input bit decides whether\nto invert the other input bit, or to just pass it through un-\nchanged. “Inverting” bits is colloquially called “flipping”\nbits,atermweʼlluseoftenthroughoutthebook.\nInmathematicsandcryptographypapers,exclusiveoris\ngenerallyrepresentedbyacrossinacircle: ⊕. Weʼllusethe\nsamenotationinthisbook:\n1Usesonly“true”and“false”asinputandoutputvalues.\n2Takestwoparameters.\n17"
  },
  {
    "input": "A few properties of XOR",
    "output": "CHAPTER5. EXCLUSIVEOR 18\nThe inputs and output here are named as if weʼre using\nXOR as an encryption operation. On the left, we have the\nplaintext bit P . The i is just an index, since weʼll usually\ni\ndeal with more than one such bit. On top, we have the key\nbitk ,thatdecideswhetherornottoinvertP . Ontheright,\ni i\nwehavetheciphertextbit,C ,whichistheresultoftheXOR\ni\noperation.\n5.2 A few properties of XOR\nSinceweʼllbedealingwithXORextensivelyduringthisbook,\nweʼll take a closer look at some of its properties. If youʼre\nalready familiar with how XOR works, feel free to skip this\nsection.\nWesawthattheoutputofXORis1whenoneinputorthe\nother(butnotboth)is1:\n0⊕0 = 0 1⊕0 = 1\n0⊕1 = 1 1⊕1 = 0\nThereareafewusefularithmetictrickswecanderivefrom\nthat.\n1. YoucanapplyXORinanyorder: a⊕(b⊕c) = (a⊕b)⊕c\n2. Youcanfliptheoperandsaround: a⊕b = b⊕a\n3. Any bit XOR itself is 0: a ⊕ a = 0. If a is 0, then itʼs\n0⊕0 = 0;ifais1,thenitʼs1⊕1 = 0.\n4. AnybitXOR0isthatbitagain: a⊕0 = a. Ifais0,then\nitʼs0⊕0 = 0;ifais1,thenitʼs1⊕0 = 1."
  },
  {
    "input": "One-time pads",
    "output": "CHAPTER5. EXCLUSIVEOR 19\nTheserulesalsoimplya⊕b⊕a = b:\na⊕b⊕a = a⊕a⊕b (secondrule)\n= 0⊕b (thirdrule)\n= b (fourthrule)\nWeʼllusethispropertyoftenwhenusingXORforencryption;\nyoucanthinkofthatfirstXORwithaasencrypting,andthe\nsecondoneasdecrypting.\n5.3 Bitwise XOR\nXOR, as weʼve just defined it, operates only on single bits\nor Boolean values. Since we usually deal with values com-\nprised of many bits, most programming languages provide\na“bitwiseXOR”operator: anoperatorthatperformsXORon\ntherespectivebitsinavalue.\nPython,forexample,providesthe^(caret)operatorthat\nperforms bitwise XOR on integers. It does this by first ex-\npressingthosetwointegersinbinary3,andthenperforming\nXORontheirrespectivebits. Hencethename,bitwiseXOR.\n73⊕87 = 0b1001001⊕0b1010111\n1 0 0 1 0 0 1 (left)\n= ⊕ ⊕ ⊕ ⊕ ⊕ ⊕ ⊕\n1 0 1 0 1 1 1 (right)\n= 0 0 1 1 1 1 0\n= 0b0011110\n= 30\n5.4 One-time pads\nXORmayseemlikeanawfullysimple,eventrivialoperator.\nEven so, thereʼs an encryption scheme, called a one-time\n3Usually, numbers are already stored in binary internally, so this\ndoesnʼtactuallytakeanywork. Whenyouseeanumberprefixedwith\n“0b”,theremainingdigitsareabinaryrepresentation.\nCHAPTER5. EXCLUSIVEOR 20\npad, which consists of just that single operator. Itʼs called\naone-timepadbecauseitinvolvesasequence(the“pad”)of\nrandombits,andthesecurityoftheschemedependsononly\nusingthatpadonce. Thesequenceiscalledapadbecauseit\nwasoriginallyrecordedonaphysical,paperpad.\nThisschemeisuniquenotonlyinitssimplicity,butalso\nbecause it has the strongest possible security guarantee. If\nthebitsaretrulyrandom(andthereforeunpredictablebyan\nattacker),andthepadisonlyusedonce,theattackerlearns\nnothingabouttheplaintextwhentheyseeaciphertext.4\nSupposewecantranslateourplaintextintoasequenceof\nbits. We also have the pad of random bits, shared between\nthe sender and the (one or more) recipients. We can com-\nputetheciphertextbytakingthebitwiseXORofthetwose-\nquencesofbits.\nIf an attacker sees the ciphertext, we can prove that\ntheywilllearnzeroinformationabouttheplaintextwithout\nthe key. This property is called perfect security. The proof\ncan be understood intuitively by thinking of XOR as a pro-\ngrammableinverter,andthenlookingataparticularbitin-\nterceptedbyEve,theeavesdropper.\nLetʼs say Eve sees that a particular ciphertext bit c is 1.\ni\nShe has no idea if the matching plaintext bit p was 0 or 1,\ni\nbecause she has no idea if the key bit k was 0 or 1. Since\ni\nallofthekeybitsaretrulyrandom,bothoptionsareexactly\nequallyprobable.\n4Theattackerdoeslearnthatthemessageexists,and,inthissimple\nscheme,thelengthofthemessage. Whilethistypicallyisnʼttooimpor-\ntant,therearesituationswherethismightmatter,andtherearesecure\ncryptosystemstobothhidetheexistenceandthelengthofamessage."
  },
  {
    "input": "Attacks on “one-time pads”",
    "output": "CHAPTER5. EXCLUSIVEOR 21\n5.5 Attacks on “one-time pads”\nTheone-timepadsecurityguaranteeonlyholdsifitisused\ncorrectly. Firstofall,theone-timepadhastoconsistoftruly\nrandomdata. Secondly, theone-timepadcanonlybeused\nonce (hence the name). Unfortunately, most commercial\nproductsthatclaimtobe“one-timepads”aresnakeoil5,and\ndonʼtsatisfyatleastoneofthosetwoproperties.\nNotusingtrulyrandomdata\nThe first issue is that they use various deterministic con-\nstructs to produce the one-time pad, instead of using truly\nrandom data. That isnʼt necessarily insecure: in fact, the\nmost obvious example, a synchronous stream cipher, is\nsomethingweʼllseelaterinthebook. However,itdoesinval-\nidatethe“unbreakable”securitypropertyofone-timepads.\nTheenduserwouldbebetterservedbyamorehonestcryp-\ntosystem, instead of one that lies about its security proper-\nties.\nReusingthe“one-time”pad\nTheotherissueiswithkeyreuse,whichismuchmoreseri-\nous. Supposeanattackergetstwociphertextswiththesame\n“one-time” pad. The attacker can then XOR the two cipher-\n5“Snakeoil”isatermforallsortsofdubiousproductsthatclaimex-\ntraordinarybenefitsandfeatures,butdonʼtreallyrealizeanyofthem.\nCHAPTER5. EXCLUSIVEOR 22\ntexts,whichisalsotheXORoftheplaintexts:\nc ⊕c = (p ⊕k)⊕(p ⊕k) (definition)\n1 2 1 2\n= p ⊕k⊕p ⊕k (reorderterms)\n1 2\n= p ⊕p ⊕k⊕k (a⊕b = b⊕a)\n1 2\n= p ⊕p ⊕0 (x⊕x = 0)\n1 2\n= p ⊕p (x⊕0 = x)\n1 2\nAtfirstsight,thatmaynotseemlikeanissue. Toextractei-\nther p or p , youʼd need to cancel out the XOR operation,\n1 2\nwhich means you need to know the other plaintext. The\nproblemisthateventheresultoftheXORoperationontwo\nplaintexts contains quite a bit information about the plain-\ntextsthemselves. Weʼllillustratethisvisuallywithsomeim-\nages from a broken “one-time” pad process, starting with\nFigure5.1.\nCrib-dragging\nAclassicalapproachtobreakingmulti-timepadsystemsin-\nvolves “crib-dragging”, a process that uses small sequences\nthat are expected to occur with high probability. Those se-\nquences are called “cribs”. The name crib-dragging origi-\nnatedfromthefactthatthesesmall“cribs”aredraggedfrom\nlefttorightacrosseachciphertext, andfromtoptobottom\nacrosstheciphertexts,inthehopeoffindingamatchsome-\nwhere. Those matches form the sites of the start, or “crib”,\nifyouwill,offurtherdecryption.\nThe idea is fairly simple. Suppose we have several en-\ncrypted messages C encrypted with the same “one-time”\ni\npadK6. Ifwecouldcorrectlyguesstheplaintextforoneof\n6Weusecapitalletterswhenreferringtoanentiremessage, asop-\nposedtojustbitsofamessage.\nCHAPTER5. EXCLUSIVEOR 23\n(a)Firstplaintext. (b)Secondplaintext.\n(c)Firstciphertext. (d)Secondciphertext.\n(e)Reusedkey. (f)XORofciphertexts.\nFigure5.1: Twoplaintexts,there-usedkey,theirrespective\nciphertexts, and the XOR of the ciphertexts. Information\nabouttheplaintextsclearlyleaksthroughwhenweXORthe\nciphertexts.\nCHAPTER5. EXCLUSIVEOR 24\nthemessages,letʼssayC ,weʼdknowK:\nj\nC ⊕P = (P ⊕K)⊕P\nj j j j\n= K ⊕P ⊕P\nj j\n= K ⊕0\n= K\nSinceKisthesharedsecret,wecannowuseittodecryptall\noftheothermessages,justasifweweretherecipient:\nP = C ⊕K foralli\ni i\nSinceweusuallycanʼtguessanentiremessage,thisdoesnʼt\nactuallywork. However,wemightbeabletoguesspartsof\namessage.\nIfweguessafewplaintextbitsp correctlyforanyofthe\ni\nmessages,thatwouldrevealthekeybitsatthatpositionfor\nallofthemessages,sincek = c ⊕p . Hence,alloftheplain-\ni i\ntextbitsatthatpositionarerevealed: usingthatvaluefork,\nwecancomputetheplaintextbitsp = c ⊕kforalltheother\ni i\nmessages.\nGuessingpartsoftheplaintextisaloteasierthanguess-\ningtheentireplaintext. Supposeweknowthattheplaintext\nisin English. Therearesome sequencesthatweknow will\noccurverycommonly,forexample(the ␣ symboldenotesa\nspace):\n• ␣the␣andvariantssuchas.␣The␣\n• ␣of␣andvariants\n• ␣to␣andvariants\n• ␣and␣(novariants;onlyoccursinthemiddleofasen-\ntence)\n• ␣a␣andvariants\nCHAPTER5. EXCLUSIVEOR 25\nIfweknowmoreabouttheplaintext,wecanmakeeven\nbetterguesses. Forexample,ifitʼsHTTPservingHTML,we\nwouldexpecttoseethingslikeContent-Type,<a>,andso\non.\nThat only tells us which plaintext sequences are likely,\ngiving us likely guesses. How do we tell if any of those\nguessesarecorrect? Ifourguessiscorrect,weknowallthe\notherplaintextsatthatpositionaswell,usingthetechnique\ndescribed earlier. We could simply look at those plaintexts\nanddecideiftheylookcorrect.\nInpractice,thisprocessneedstobeautomatedbecause\ntherearesomanypossibleguesses. Fortunatelythatʼsquite\neasytodo. Forexample,averysimplebuteffectivemethod\nistocounthowoftendifferentsymbolsoccurintheguessed\nplaintexts: ifthemessagescontainEnglishtext,weʼdexpect\nto see a lot of letters e, t, a, o, i, n. If weʼre seeing binary\nnonsenseinstead, weknowthat the guesswasprobablyin-\ncorrect,orperhapsthatmessageisactuallybinarydata.\nThese small, highly probable sequences are called\n“cribs” because theyʼre the start of a larger decryption pro-\ncess. Supposeyourcrib,the,wassuccessfulandfoundthe\nfive-letter sequence t thr in another message. You can\nthen use a dictionary to find common words starting with\nthr, suchasthrough. Ifthatguesswerecorrect, itwould\nreveal four more bytes in all of the ciphertexts, which can\nbeusedtorevealevenmore. Similarly,youcanusethedic-\ntionarytofindwordsendingint.\nThis becomes even more effective for some plaintexts\nthat we know more about. If some HTTP data has the\nplaintext ent-Len in it, then we can expand that to\nContent-Length:,revealingmanymorebytes.\nWhilethistechniqueworksassoonastwomessagesare\nencrypted with the same key, itʼs clear that this becomes\neveneasierwithmoreciphertextsusingthesamekey,since\nallofthestepsbecomemoreeffective:\n• Wegetmorecribbingpositions."
  },
  {
    "input": "Remaining problems",
    "output": "CHAPTER5. EXCLUSIVEOR 26\n• Moreplaintextbytesarerevealedwitheachsuccessful\ncribandguess,leadingtomoreguessingoptionselse-\nwhere.\n• More ciphertexts are available for any given position,\nmaking guess validation easier and sometimes more\naccurate.\nThesearejustsimpleideasforbreakingmulti-timepads.\nWhile theyʼre already quite effective, people have invented\neven more effective methods by applying advanced, statis-\ntical models based on natural language analysis. This only\ndemonstrates further just how broken multi-time pads are.\n[MWES06]\n5.6 Remaining problems\nReal one-time pads, implemented properly, have an ex-\ntremely strong security guarantee. It would appear, then,\nthat cryptography is over: encryption is a solved problem,\nandwecanallgohome. Obviously,thatʼsnotthecase.\nOne-time pads are rarely used, because they are horri-\nbly impractical: the key is at least as large as all informa-\ntion youʼd like to transmit, put together. Plus, youʼd have to\nexchange those keys securely, ahead of time, with all peo-\nple youʼd like to communicate with. Weʼd like to communi-\ncatesecurelywitheveryoneontheInternet,andthatʼsavery\nlarge number of people. Furthermore, since the keys have\nto consist of truly random data for its security property to\nhold, key generation is fairly difficult and time-consuming\nwithoutspecializedhardware.\nOne-timepadsposeatrade-off. Itʼsanalgorithmwitha\nsolid information-theoretic security guarantee, which you\ncan not get from any other system. On the other hand, it\nalsohasextremelyimpracticalkeyexchangerequirements.\nHowever, as weʼll see throughout this book, secure sym-\nmetric encryption algorithms arenʼt the pain point of mod-\nerncryptosystems. Cryptographershavedesignedplentyof\nCHAPTER5. EXCLUSIVEOR 27\nthose, while practical key management remains one of the\ntoughestchallengesfacingmoderncryptography. One-time\npadsmaysolveaproblem,butitʼsthewrongproblem.\nWhile they may have their uses, theyʼre obviously not a\npanacea. We need something with manageable key sizes\nwhilemaintainingsecrecy. Weneedwaystonegotiatekeys\novertheInternetwithpeopleweʼvenevermetbefore."
  },
  {
    "input": "Description",
    "output": "6\nBlock ciphers\nFew false ideas have more firmly gripped the\nminds of so many intelligent men than the one\nthat,iftheyjusttried,theycouldinventacipher\nthatnoonecouldbreak.\nDavidKahn\n6.1 Description\nAblockcipher isanalgorithmthatencryptsblocksofafixed\nlength. The encryption function E transforms plaintext\nblocksP intociphertextblocksC byusingasecretkeyk:\nC = E(k,P)\nPlaintextandciphertextblocksaresequencesofbitsandal-\nways match in size. The block cipherʼs block size is a fixed\nsize. Keyspaceisthesetofallpossiblekeys.\nOnceweencryptplaintextblocksintociphertextblocks,\nthey are later decrypted to recover original plaintext block.\n28\nCHAPTER6. BLOCKCIPHERS 29\nThe original plaintext block P is produced using a decryp-\ntionfunctionD. IttakestheciphertextblockC andthekey\nk(thesameoneusedtoencrypttheblock)asinputs.\nP = D(k,C)\nOr,visuallyrepresentedinblocks:\nA block cipher is an example of a symmetric-key encryp-\ntion scheme, also known as a secret-key encryption scheme.\nThesamesecretkeyisusedforbothencryptionanddecryp-\ntion. Later in the book, we contrast this with public-key en-\ncryptionalgorithms,whichhaveadistinctkeyforencryption\nanddecryption.\nAblockcipherisakeyedpermutation. Itisapermutation\nbecause the block cipher maps each possible block to an-\nother block. It is also a keyed permutation because the key\ndeterminesexactlywhichblocksmaptowhich. Itisimpor-\ntant for the block cipher to be a permutation because the\nrecipientmustmapblocksbacktotheoriginalblocks.\nWe illustrate this by looking at a block cipher with an\nimpractical, tiny 4-bit block size. 24 = 16 possible blocks.\nSinceeachoftheblocksmaptoahexadecimaldigit,werep-\nresent the blocks by that digit. Figure 6.1 illustrates blocks\nthatthecipheroperateson.\nOnce we select a secret key, the block cipher uses it to\ndetermine the encryption of any given block. We illustrate\nthat relationship with an arrow. The tail of the arrow has\ntheblockencryptedwithE underkeyk andthearrowhead\nismappedtotheblock.\nIn Figure 6.2, note that the permutation is not just one\nbigcycle. Itcontainsalargecycleof7elements,andseveral\nCHAPTER6. BLOCKCIPHERS 30\nFigure 6.1: All 16 nodes operated on by the block cipher.\nEachnodeisdesignatedbyahexadecimaldigit.\nsmallercyclesof4,3and2elementseach. Itisalsoperfectly\npossiblethatanelementencryptstoitself. Thisistobe ex-\npected when selecting random permutations, which is ap-\nproximatelywhatablockcipherisdoing; itdoesnʼtdemon-\nstrateabugintheblockcipher.\nWhen you decrypt instead of encrypt, the block cipher\ncomputestheinversepermutation. InFigure6.3,wegetthe\nsame illustration. The difference between the illustrations\nisthatallarrowheadspointintheoppositedirection.\nThe key defines which blocks map to which blocks. A\ndifferent key would lead to a different set of arrows, as you\nCHAPTER6. BLOCKCIPHERS 31\nFigure 6.2: An encryption permutation made by a block ci-\npherunderaparticularkeyk.\ncanseeinFigure6.4.\nIn this illustration, youʼll even notice that there are two\npermutations of length 1: an element that maps to itself.\nThis is again something to be expected when selecting ran-\ndompermutations.\nKnowingabunchof(input,output)pairsforagivenkey\nshouldnʼt give you any information about any other (input,\noutput)pairsunderthatkey1. Aslongasweʼretalkingabout\nahypotheticalperfectblockcipher,thereʼsnoeasierwayto\ndecryptablockotherthanto“brute-force”thekey: i.e. just\ntryeverysingleoneofthemuntilyoufindtherightone.\n1The attentive reader may have noticed that this breaks in the ex-\ntremes: ifyouknowallbutoneofthepairs,thenyouknowthelastone\nbyexclusion.\nCHAPTER6. BLOCKCIPHERS 32\nFigure 6.3: The decryption permutation produced by the\nblock cipher under the same key k. It is the inverse of the\nencryptionpermutationinthatallarrowheadsreverse.\nOurtoyillustrationblockcipheronlyhas4bitblocks,or\n24 = 16possibilities. Real,modernblockciphershavemuch\nlargerblocksizes,suchas128bits,or2128(slightlymorethan\n1038.5) possible blocks. Mathematics tells us that there are\nn!(pronounced“nfactorial”)differentpermutationsofann\nelementset. Itʼsdefinedastheproductofallofthenumbers\nfrom1uptoandincludingn:\nn! = 1·2·3·...·(n−1)·n\nFactorials grow incredibly quickly. For example, 5! = 120,\n10! = 3628800,andtheratecontinuestoincrease. Thenum-\nberofpermutationsofthesetofblocksofacipherwitha128\nbitblocksizeis(2128)!. Just2128 islargealready(ittakes39\ndigitstowriteitdown),so(2128)!isamind-bogglinglyhuge\nnumber,impossibletocomprehend. Commonkeysizesare\nonlyintherangeof128to256bits,sothereareonlybetween\n2128and2256permutationsaciphercanperform. Thatʼsjust\na tiny fraction of all possible permutations of the blocks,"
  },
  {
    "input": "AES",
    "output": "CHAPTER6. BLOCKCIPHERS 33\nFigure 6.4: An encryption permutation produced by the\nblockcipherunderadifferentkey.\nbutthatʼsokay: thattinyfractionisstillnowherenearsmall\nenoughforanattackertojusttrythemall.\nOf course, a block cipher should be as easy to compute\nas possible, as long as it doesnʼt sacrifice any of the above\nproperties.\n6.2 AES\nThemostcommonblockcipherincurrentuseisAES.\nContrary to its predecessor DES (which weʼll look at in\nmore detail in the next chapter), AES was selected through\nCHAPTER6. BLOCKCIPHERS 34\napublic,peer-reviewedcompetitionfollowinganopencall\nfor proposals. This competition involved several rounds\nwhere all of the contestants were presented, subject to ex-\ntensivecryptanalysis,andvotedupon. TheAESprocesswas\nwell-receivedamongcryptographers,andsimilarprocesses\nare generally considered to be the preferred way to select\ncryptographicstandards.\nPriortobeingchosenastheAdvancedEncryptionStan-\ndard,thealgorithmwasknownasRijndael,anamederived\nfromthetwolastnamesoftheBelgiancryptographersthat\ndesigned it: Vincent Rijmen and Joan Daemen. The Rijn-\ndaelalgorithmdefinedafamilyofblockciphers,withblock\nsizes and key sizes that could be any multiple of 32 bits be-\ntween128 bits and256bits. [DR02]When Rijndaelbecame\nAES through the FIPS standardization process, the parame-\nterswererestrictedtoablocksizeof128bitsandkeyssizes\nof128,192and256bits. [fip01]\nTherearenopracticalattacksknownagainstAES.While\nthere have been some developments in the last few years,\nmost of them involve related-key attacks [BK09], some of\nthemonlyonreduced-roundversionsofAES[BDK+09].2\n2Symmetric algorithms usually rely on a round function to be re-\npeatedanumberoftimes. Typicallyeachinvocationinvolvesa“round\nkey”derivedfromthemainkey. Areduced-roundversionisintention-\nallyeasiertoattack.Theseattackscangiveinsightastohowresistantthe\nfullcipheris.\nArelatedkeyattackinvolvesmakingsomepredictionsabouthowAES\nwillbehaveunderseveraldifferentkeyswithsomespecificmathemati-\ncalrelation. Theserelationsarefairlysimple, suchasXORingwithan\nattacker-chosenconstant.Ifanattackerisallowedtoencryptanddecrypt\nalargenumberofblockswiththeserelatedkeys,theycanattempttore-\ncovertheoriginalkeywithsignificantlylesscomputationthanwouldor-\ndinarilybenecessarytocrackit.\nWhile a theoretically ideal block cipher wouldnʼt be vulnerable to a\nrelated key attack, these attacks arenʼt considered practical concerns.\nInpracticecryptographickeysaregeneratedviaacryptographicallyse-\ncure pseudorandom number generator, or a similarly secure key agree-\nmentschemeorkeyderivationscheme(weʼllseemoreaboutthoselater).\nTherefore, the odds of selecting two such related keys by accident is\nnonexistent. These attacks are interesting from an academic perspec-\nCHAPTER6. BLOCKCIPHERS 35\nAcloserlookatRijndael\nThisisanoptional,in-depthsection. It\nalmost certainly wonʼt help you write bet-\ntersoftware,sofeelfreetoskipit. Itisonly\nheretosatisfyyourinnergeekʼscuriosity.\nAES consists of several independent steps. At a high level,\nAESisasubstitution-permutationnetwork.\nKeyschedule\nAESrequiresseparatekeysforeachroundinthenextsteps.\nThekeyscheduleistheprocesswhichAESusestoderive128-\nbitkeysforeachroundfromonemasterkey.\nFirst, the keyisseparatedinto4 bytecolumns. Thekey\nis rotated and then each byte is run through an S-box (sub-\nstitution box) that maps it to something else. Each column\nisthenXORedwitharoundconstant. ThelaststepistoXOR\ntheresultwiththepreviousroundkey.\nThe other columns are then XORed with the previous\nroundkeytoproducetheremainingcolumns.\nSubBytes\nSubBytesisthestepthatappliestheS-box(substitutionbox)\ninAES.TheS-boxitselfsubstitutesabytewithanotherbyte,\nandthisS-boxisappliedtoeachbyteintheAESstate.\nItworksbytakingthemultiplicativeinverseovertheGa-\nloisfield,andthenapplyinganaffinetransformationsothat\ntherearenovaluesxsothatx⊕S(x) = 0orx⊕S(x) = 0xff.\nTo rephrase: there are no values of x that the substitution\nbox maps to x itself, or x with all bits flipped. This makes\ntive:theycanhelpprovideinsightintheworkingsofthecipher,guiding\ncryptographersindesigningfutureciphersandattacksagainstcurrent\nciphers.\nCHAPTER6. BLOCKCIPHERS 36\nthe cipher resistant to linear cryptanalysis, unlike the ear-\nlierDESalgorithm,whosefifthS-boxcausedserioussecurity\nproblems.3\nShiftRows\nAfterhavingappliedtheSubBytessteptothe16bytesofthe\nblock,AESshiftstherowsinthe4×4array:\n3Initsdefense, linearattackswerenotpubliclyknownbackwhen\nDESwasdesigned."
  },
  {
    "input": "DES and 3DES",
    "output": "CHAPTER6. BLOCKCIPHERS 37\nMixColumns\nMixColumnsmultiplieseachcolumnofthestatewithafixed\npolynomial.\nShiftRowsandMixColumnsrepresentthediffusionprop-\nertiesofAES.\nAddRoundKey\nAsthenameimplies,theAddRoundKeystepaddsthebytes\nfromtheroundkeyproducedbythekeyscheduletothestate\nofthecipher.\n6.3 DES and 3DES\nThe DES is one of the oldest block ciphers that saw\nwidespreaduse. ItwaspublishedasanofficialFIPSstandard\nin1977. Itisnolongerconsideredsecure,mainlyduetoits\ntinykeysizeof56bits. (TheDESalgorithmactuallytakesa64\nbitkeyinput,buttheremaining8bitsareonlyusedforpar-\nity checking, and are discarded immediately.) It shouldnʼt\nbeusedinnewsystems. Onmodernhardware,DEScanbe\nbruteforcedinlessthanaday. [Gmb08]\nCHAPTER6. BLOCKCIPHERS 38\nInanefforttoextendthelifeoftheDESalgorithm, ina\nwaythatallowedmuchofthespenthardwaredevelopment\neffort to be reused, people came up with 3DES: a scheme\nwhere input is first encrypted, then decrypted, then en-\ncryptedagain:\nC = E (k ,D (k ,E (k ,p)))\nDES 1 DES 2 DES 3\nThisschemeprovidestwoimprovements:\n• By applying the algorithm three times, the cipher be-\ncomeshardertoattackdirectlythroughcryptanalysis.\n• Byhavingtheoptionofusingmanymoretotalkeybits,\nspreadoverthethreekeys,thesetofallpossiblekeys\nCHAPTER6. BLOCKCIPHERS 39\nbecomesmuchlarger,makingbrute-forcingimpracti-\ncal.\nThethreekeyscouldallbechosenindependently(yield-\ning 168 key bits), or k = k (yielding 112 key bits), or\n3 1\nk = k = k ,which,ofcourse,isjustplainoldDES(with56\n1 2 3\nkey bits). In the last keying option, the middle decryption\nreverses the first encryption, so you really only get the ef-\nfectofthelastencryption. Thisisintendedasabackwards\ncompatibility mode for existing DES systems. If 3DES had\nbeen defined as E(k ,E(k ,E(k ,p))), it would have been\n1 2 3\nimpossible to use 3DES implementations for systems that\nrequiredcompatibilitywithDES.Thisisparticularlyimpor-\ntant for hardware implementations, where it is not always\npossible to provide a secondary, regular “single DES” inter-\nfacenexttotheprimary3DESinterface.\nSome attacks on 3DES are known, reducing their effec-\ntivesecurity. Whilebreaking3DESwiththefirstkeyingop-\ntion is currently impractical, 3DES is a poor choice for any\nmoderncryptosystem. Thesecuritymarginisalreadysmall,\nand continues to shrink as cryptographic attacks improve\nandprocessingpowergrows.\nFar better alternatives, such as AES, are available. Not\nonly are they more secure than 3DES, they are also gener-\nally much, much faster. On the same hardware and in the\nsamemodeofoperation(weʼllexplainwhatthatmeansinthe\nnextchapter),AES-128onlytakes12.6cyclesperbyte,while\n3DES takes up to 134.5 cycles per byte. [Dai] Despite being\nworsefromasecuritypointofview,itisliterallyanorderof\nmagnitudeslower.\nWhilemoreiterationsofDESmightincreasethesecurity\nmargin,theyarenʼtusedinpractice. Firstofall,theprocess\nhas never been standardized beyond three iterations. Also,\ntheperformanceonlybecomesworseasyouaddmoreitera-\ntions. Finally,increasingthekeybitshasdiminishingsecu-\nrity returns, only increasing the security level of the result-\ningalgorithmbyasmalleramountasthenumberofkeybits"
  },
  {
    "input": "Remaining problems",
    "output": "CHAPTER6. BLOCKCIPHERS 40\nincreases. While3DESwithkeyingoption1hasakeylength\nof 168 bits, the effective security level is estimated at only\n112bits.\nEventhough3DESissignificantlyworseintermsofper-\nformance and slightly worse in terms of security, 3DES is\nstilltheworkhorseofthefinancialindustry. Withaplethora\nof standards already in existence and new ones continuing\nto be created, in such an extremely technologically conser-\nvativeindustrywhereFortranandCobolstillreignsupreme\nonmassivemainframes,itwillprobablycontinuetobeused\nfor many years to come, unless there are some large crypt-\nanalyticbreakthroughsthatthreatenthesecurityof3DES.\n6.4 Remaining problems\nEvenwithblockciphers,therearestillsomeunsolvedprob-\nlems.\nFor example, we can only send messages of a very lim-\nitedlength: theblocklengthoftheblockcipher. Obviously,\nweʼdliketobeabletosendmuchlargermessages,or,ideally,\nstreams of indeterminate size. Weʼll address this problem\nwithastreamcipher(page41).\nAlthoughwehavereducedthekeysizedrastically(from\nthe total size of all data ever sent under a one-time pad\nscheme versus a few bytes for most block ciphers), we still\nneed to address the issue of agreeing on those few key\nbytes, potentially over an insecure channel. Weʼll address\nthis problem in a later chapter with a key exchange protocol\n(page81)."
  },
  {
    "input": "A naive attempt with block ciphers",
    "output": "7\nStream ciphers\n7.1 Description\nA stream cipher is a symmetric-key encryption algorithm that\nencrypts a stream of bits. Ideally, that stream could be as\nlong as weʼd like; real-world stream ciphers have limits, but\nthey are normally sufficiently large that they donʼt pose a\npracticalproblem.\n7.2 A naive attempt with block ciphers\nLetʼs try to build a stream cipher using the tools we already\nhave. Sincewealreadyhaveblockciphers,wecouldsimply\ndivideanincomingstreamintodifferentblocks,andencrypt\neachblock:\nabcdefgh ijklmno pqrstuvw ...\n| {z } | {z } | {z }\n↓ ↓ ↓\nz }| { z }| { z }| {\nAPOHGMMW PVMEHQOM MEEZSNFM ...\nThis scheme is called ECB mode (Electronic Code Book\nMode),anditisoneofthemanywaysthatblockcipherscan\n41\nCHAPTER7. STREAMCIPHERS 42\nbe used to construct stream ciphers. Unfortunately, while\nbeingverycommoninhome-growncryptosystems,itposes\nveryserioussecurityflaws. Forexample,inECBmode,iden-\nticalinputblockswillalwaysmaptoidenticaloutputblocks:\nabcdefgh abcdefgh abcdefgh ...\n| {z } | {z } | {z }\n↓ ↓ ↓\nz }| { z }| { z }| {\nAPOHGMMW APOHGMMW APOHGMMW ...\nAtfirst,thismightnotseemlikeaparticularlyseriousprob-\nlem. Assumingtheblockcipherissecure,itdoesnʼtlooklike\nan attacker would be able to decrypt anything. By dividing\ntheciphertextstreamupintoblocks,anattackerwouldonly\nbeabletoseethataciphertextblock,andthereforeaplain-\ntextblock,wasrepeated.\nWeʼllnowillustratethemanyflawsofECBmodewithtwo\nattacks. First, weʼll exploit the fact that repeating plaintext\nblocks result in repeating ciphertext blocks, by visually in-\nspectinganencryptedimage. Then,weʼlldemonstratethat\nattackerscanoftendecryptmessagesencryptedinECBmode\nbycommunicatingwiththepersonperformingtheencryp-\ntion.\nVisualinspectionofanencryptedstream\nTodemonstratethatthisis,infact,aseriousproblem,weʼll\nuse a simulated block cipher of various block sizes and ap-\nplyittoanimage1. Weʼllthenvisuallyinspectthedifferent\noutputs.\nBecause identical blocks of pixels in the plaintext will\nmaptoidenticalblocksofpixelsintheciphertext,theglobal\nstructureoftheimageislargelypreserved.\nAsyoucansee,thesituationappearstogetslightlybetter\nwithlargerblocksizes,butthefundamentalproblemstillre-\nmains: the macrostructure of the image remains visible in\n1This particular demonstration only works on uncompressed\nbitmaps. Forothermedia,theeffectisnʼtsignificantlylessdamning: itʼs\njustlessvisual.\nCHAPTER7. STREAMCIPHERS 43\n(a)Plaintextimage,2000by (b)ECBmodeciphertext,5pixel\n1400pixels,24bitcolordepth. (120bit)blocksize.\n(c)ECBmodeciphertext,30pixel (d)ECBmodeciphertext,100\n(720bit)blocksize. pixel(2400bit)blocksize.\n(e)ECBmodeciphertext,400\npixel(9600bit)blocksize.\n(f)Ciphertextunderidealized\nencryption.\nFigure 7.1: Plaintext image with ciphertext images under\nidealizedencryptionandECBmodeencryptionwithvarious\nblock sizes. Information about the macro-structure of the\nimage clearly leaks. This becomes less apparent as block\nsizesincrease,butonlyatblocksizesfarlargerthantypical\nblockciphers. Onlythefirstblocksize(Figure7.1f,ablock\nsizeof5pixelsor120bits)isrealistic.\nCHAPTER7. STREAMCIPHERS 44\nall but the most extreme block sizes. Furthermore, all but\nthesmallestoftheseblocksizesareunrealisticallylarge. For\nanuncompressedbitmapwiththreecolorchannelsof8bit\ndepth,eachpixeltakes24bitstostore. Sincetheblocksize\nofAESisonly128bits,thatwouldequateto 128 orjustover5\n24\npixelsperblock. Thatʼssignificantlyfewerpixelsperblock\nthan the larger block sizes in the example. But AES is the\nworkhorseofmodernblockciphers—itcanʼtbeatfault,cer-\ntainlynotbecauseofaninsufficientblocksize.\nWhenwelookatapictureofwhatwouldhappenwithan\nidealizedencryptionscheme,wenoticethatitlookslikeran-\ndom noise. Keep in mind that “looking like random noise”\ndoesnʼtmeansomethingisproperlyencrypted: itjustmeans\nthatwecanʼtinspectitusingmethodsthistrivial.\nEncryptionoracleattack\nIn the previous section, weʼve focused on how an attacker\ncan inspect a ciphertext encrypted using ECB mode. Thatʼs\na passive, ciphertext-only attack. Itʼs passive because the\nattacker doesnʼt really interfere in any communication;\ntheyʼresimplyexaminingaciphertext. Inthissection,weʼll\nstudy a different, active attack, where the attacker actively\ncommunicateswiththeirtarget. Weʼllseehowtheactiveat-\ntackcanenableanattackertodecryptciphertextsencrypted\nusingECBmode.\nTodothis,weʼllintroduceanewconceptcalledanoracle.\nFormally defined oracles are used in the study of computer\nscience,butforourpurposesitʼssufficienttojustsaythatan\noracle issomethingthatwillcomputesomeparticularfunc-\ntionforyou.\nInourcase,theoraclewillperformaspecificencryption\nfortheattacker,whichiswhyitʼscalledanencryptionoracle.\nGivensomedataAchosenbytheattacker,theoraclewillen-\ncrypt that data, followed by a secret suffix S, in ECB mode.\nOr,insymbols:\nC = ECB(E ,A∥S)\nk\nCHAPTER7. STREAMCIPHERS 45\nThesecretsuffix S isspecificto thissystem. The attackerʼs\ngoalistodecryptit. Weʼllseethatbeingabletoencryptother\nmessagessurprisinglyallowstheattackertodecryptthesuf-\nfix. This oracle might seem artificial, but is quite common\ninpractice. Asimpleexamplewouldbeacookieencrypted\nwithECB,wheretheprefixAisanameorane-mailaddress\nfield,controlledbytheattacker.\nYou can see why the concept of an oracle is important\nhere: the attacker would not be able to compute C them-\nselves, since they do not have access to the encryption key\nk or the secret suffix S. The goal of the oracle is for those\nvalues to remain secret, but weʼll see how an attacker will\nbeabletorecoverthesecretsuffixS (butnotthekeyk)any-\nway. The attacker does this by inspecting the ciphertext C\nformanycarefullychosenvaluesoftheattacker-chosenpre-\nfixA.\nAssumingthatanattackerwouldhaveaccesstosuchan\noraclemightseemlikeaveryartificialscenario. Itturnsout\nthatinpractice,alotofsoftwarecanbetrickedintobehaving\nlike one. Even if an attacker canʼt control the real software\nas precisely as they can query an oracle, the attacker gen-\nerally isnʼt thwarted. Time is on their side: they only have\nto convince the software to give the answer they want once.\nSystemswherepartofthemessageissecretandpartofthe\nmessagecanbeinfluencedbytheattackerareactuallyvery\ncommon,and,unfortunately,soisECBmode.\nDecryptingablockusingtheoracle\nThe attacker starts by sending in a plaintext A thatʼs just\nonebyteshorterthantheblocksize. Thatmeanstheblock\nthatʼs being encrypted will consist of those bytes, plus the\nfirstbyteofS,whichweʼllcalls . Theattackerremembers\n0\nthe encrypted block. They donʼt know the value of s yet,\n0\nbutnowtheydoknowthevalueofthefirstencryptedblock:\nE (A∥s ). Intheillustration,thisisblockC :\nk 0 R1\nThen, the attacker tries a full-size block, trying all pos-\nCHAPTER7. STREAMCIPHERS 46\nsible values for the final byte. Eventually, theyʼll find the\nvalue of s ; they know the guess is correct because the re-\n0\nsultingciphertextblockwillmatchtheciphertextblockC\nR1\ntheyrememberedearlier.\nThe attacker can repeat this for the penultimate byte.\nThey submit a plaintext A thatʼs two bytes shorter than the\nblocksize. Theoraclewillencryptafirstblockconsistingof\nthatAfollowedbythefirsttwobytesofthesecretsuffix,s s .\n0 1\nTheattackerremembersthatblock.\nSince the attacker already knows s , they try A∥s fol-\n0 0\nlowed by all possible values of s . Eventually theyʼll guess\n1\ncorrectly,which,again,theyʼllknowbecausetheciphertext\nblocksmatch:\nThe attacker can then rinse and repeat, eventually de-\ncryptinganentireblock. Thisallowsthemtobrute-forcea\nCHAPTER7. STREAMCIPHERS 47\nblockinp·battempts,wherepisthenumberofpossibleval-\nues for each byte (so, for 8-bit bytes, thatʼs 28 = 256) and b\nis the block size. This is much better than a regular brute-\nforceattack,whereanattackerhastotryallofthepossible\nblocks,whichwouldbe:\np·p...·p = pb\n| {z }\nbpositions\nFor a typical block size of 16 bytes (or 128 bits), brute forc-\ning would mean trying 25616 combinations. Thatʼs a huge,\n39-digit number. Itʼs so large that trying all of those combi-\nnations is considered impossible. An ECB encryption oracle\nallowsanattackertodoitinatmost256·16 = 4096tries,a\nfarmoremanageablenumber."
  },
  {
    "input": "CBC mode",
    "output": "CHAPTER7. STREAMCIPHERS 48\nConclusion\nIntherealworld,blockciphersareusedinsystemsthaten-\ncrypt large amounts of data all the time. Weʼve seen that\nwhenusingECBmode, anattackercanbothanalyzecipher-\ntextstorecognizerepeatingpatterns,andevendecryptmes-\nsageswhengivenaccesstoanencryptionoracle.\nEvenwhenweuseidealizedblockcipherswithunrealis-\ntic properties, such as block sizes of more than a thousand\nbits, an attacker ends up being able to decrypt the cipher-\ntexts. Real world block ciphers only have more limitations\nthan our idealized examples, such as much smaller block\nsizes.\nWe arenʼt even taking into account any potential weak-\nnesses in the block cipher. Itʼs not AES (or our test block\nciphers) that cause this problem, itʼs our ECB construction.\nClearly,weneedsomethingbetter.\n7.3 Block cipher modes of operation\nOneofthemorecommonwaysofproducingastreamcipher\nis to use a block cipher in a particular configuration. The\ncompound system behaves like a stream cipher. These con-\nfigurations are commonly called mode of operations. They\narenʼtspecifictoaparticularblockcipher.\nECB mode, which weʼve just seen, is the simplest such\nmodeofoperation. ThelettersECBstandforelectroniccode\nbook2. Forreasonsweʼvealreadygoneinto,ECBmodeisvery\nineffective. Fortunately,thereareplentyofotherchoices.\n7.4 CBC mode\nCBCmode,whichstandsforcipherblockchaining,isavery\ncommonmodeofoperationwhereplaintextblocksareXORed\n2Traditionally,modesofoperationseemtobereferredtobyathree-\nletteracronym.\nCHAPTER7. STREAMCIPHERS 49\nwith the previous ciphertext block before being encrypted\nbytheblockcipher.\nOfcourse,thisleavesuswithaproblemforthefirstplain-\ntext block: there is no previous ciphertext block to XOR it\nwith. Instead, we pick an IV: a random number that takes\ntheplaceofthe“first”ciphertextinthisconstruction. initial-\nizationvectorsalsoappearinmanyotheralgorithms. Anini-\ntialization vector should be unpredictable; ideally, they will\nbecryptographicallyrandom. Theydonothavetobesecret:\nIVsaretypicallyjustaddedtociphertextmessagesinplain-\ntext. It may sound contradictory that something has to be\nunpredictable,butdoesnʼthavetobesecret;itʼsimportantto\nrememberthatanattackermustnotbeabletopredictahead\nof time what a given IV will be. We will illustrate this later\nwithanattackonpredictableCBCIVs.\nThefollowingdiagramdemonstratesencryptioninCBC\nmode:"
  },
  {
    "input": "Attacks on CBC mode with predictable IVs",
    "output": "CHAPTER7. STREAMCIPHERS 50\nDecryption is the inverse construction, with block ci-\nphersindecryptionmodeinsteadofencryptionmode:\nWhileCBCmodeitselfisnotinherentlyinsecure(unlike\nECB mode), its particular use in TLS 1.0 was. This eventu-\nallyledtotheBEASTattack,whichweʼllcoverinmoredetail\ninthesectiononSSL/TLS.Theshortversionisthatinstead\nofusingunpredictableinitializationvectors,forexampleby\nchoosingrandomIVs,thestandardusedthepreviouscipher-\ntext block as the IV for the next message. Unfortunately, it\nturnsoutthatattackersfiguredouthowtoexploitthatprop-\nerty.\n7.5 Attacks on CBC mode with predictable\nIVs\nSuppose thereʼs a database that stores secret user informa-\ntion, like medical, payroll or even criminal records. In or-\nder to protect that information, the server that handles it\nencrypts it using a strong block cipher in CBC mode with a\nfixed key. For now, weʼll assume that that server is secure,\nandthereʼsnowaytogetittoleakthekey.\nCHAPTER7. STREAMCIPHERS 51\nMallory gets a hold of all of the rows in the database.\nPerhapsshediditthroughaSQLinjectionattack,ormaybe\nwith a little social engineering.3 Everything is supposed to\nremain secure: Mallory only has the ciphertexts, but she\ndoesnʼthavethesecretkey.\nMallorywantstofigureoutwhatAliceʼsrecordsays. For\nsimplicityʼs sake, letʼs say thereʼs only one ciphertext block.\nThat means Aliceʼs ciphertext consists of an IV and one ci-\nphertextblock.\nMallory can still try to use the application as a normal\nuser,meaningthattheapplicationwillencryptsomedataof\nMalloryʼschoosingandwriteittothedatabase. Supposethat\nthroughabugintheserver,MallorycanpredicttheIVthat\nwill be used for her ciphertext. Perhaps the server always\nusesthesameIVforthesameperson,oralwaysusesanall-\nzeroIV,or…\nMallorycanconstructherplaintextusingAliceʼsIVIV\nA\n(whichMallorycansee)andherownpredictedIVIV . She\nM\nmakes a guess G as to what Aliceʼs data could be. She asks\ntheservertoencrypt:\nP = IV ⊕IV ⊕G\nM M A\nThe server dutifully encrypts that message using the pre-\ndictedIVIV . Itcomputes:\nM\nC = E(k,IV ⊕P )\nM M M\n= E(k,IV ⊕(IV ⊕IV ⊕G))\nM M A\n= E(k,IV ⊕G)\nA\nThat ciphertext, C , is exactly the ciphertext block Alice\nM\nwouldhavehadifherplaintextblockwasG.So,depending\non what the data is, Mallory has figured out if Alice has a\n3Socialengineeringmeanstrickingpeopleintothingstheyshouldnʼt\nbedoing, likegivingoutsecretkeys, orperformingcertainoperations.\nItʼsusuallythemosteffectivewaytobreakotherwisesecurecryptosys-\ntems."
  },
  {
    "input": "Attacks on CBC mode with the key as the IV",
    "output": "CHAPTER7. STREAMCIPHERS 52\ncriminalrecordornot,orperhapssomekindofembarrass-\ning disease, or some other issue that Alice really expected\ntheservertokeepsecret.\nLessonslearned: donʼtletIVsbepredictable. Also,donʼt\nrollyourowncryptosystems. Inasecuresystem,Aliceand\nMalloryʼsrecordsprobablywouldnʼtbeencryptedusingthe\nsamekey.\n7.6 AttacksonCBCmodewiththekeyasthe\nIV\nMany CBC systems set the key as the initialization vector.\nThis seems like a good idea: you always need a shared se-\ncret key already anyway. It yields a nice performance ben-\nefit,becausethesenderandthereceiverdonʼthavetocom-\nmunicate the IV explicitly, they already know the key (and\ntherefore the IV) ahead of time. Plus, the key is definitely\nunpredictablebecauseitʼssecret: ifitwerepredictable,the\nattackercouldjustpredictthekeydirectlyandalreadyhave\nwon. Conveniently, many block ciphers have block sizes\nthatarethesamelengthorlessthanthekeysize,sothekey\nisbigenough.\nThis setup is completely insecure. If Alice sends a mes-\nsagetoBob,Mallory,anactiveadversarywhocanintercept\nand modify the message, can perform a chosen ciphertext\nattacktorecoverthekey.\nAlice turns her plaintext message P into three blocks\nP P P and encrypts it in CBC mode with the secret key k\n1 2 3\nand also uses k as the IV. She gets a three block ciphertext\nC = C C C ,whichshesendstoBob.\n1 2 3\nBefore the message reaches Bob, Mallory intercepts it.\n′\nShe modifies the message to be C = C ZC , where Z is a\n1 1\nblockfilledwithnullbytes(valuezero).\n′\nBob decrypts C , and gets the three plaintext blocks"
  },
  {
    "input": "CBC bit flipping attacks",
    "output": "CHAPTER7. STREAMCIPHERS 53\n′ ′ ′\nP ,P ,P :\n1 2 3\nP ′ = D(k,C )⊕IV\n1 1\n= D(k,C )⊕k\n1\n= P\n1\nP ′ = D(k,Z)⊕C\n2 1\n= R\nP ′ = D(k,C )⊕Z\n3 1\n= D(k,C )\n1\n= P ⊕IV\n1\nRissomerandomblock. Itsvaluedoesnʼtmatter.\nUnderthechosen-ciphertextattackassumption,Mallory\nrecovers that decryption. She is only interested in the first\nblock (P ′ = P ) and the third block (P ′ = P ⊕ IV). By\n1 1 3 1\nXORingthosetwotogether,shefinds(P ⊕IV)⊕P = IV.\n1 1\nBut,theIVisthekey,soMallorysuccessfullyrecoveredthe\nkeybymodifyingasinglemessage.\nLessonlearned: donʼtusethekeyasanIV.Partofthefal-\nlacyintheintroductionisthatitassumedsecretdatacould\nbe used for the IV, because it only had to be unpredictable.\nThatʼsnottrue: “secret”isjustadifferentrequirementfrom\n“not secret”, not necessarily a stronger one. It is not gener-\nally okay to use secret information where it isnʼt required,\nprecisely because if itʼs not supposed to be secret, the algo-\nrithmmayverywelltreatitasnon-secret,asisthecasehere.\nThere are plenty of systems where it is okay to use a secret\nwhere it isnʼt required. In some cases you might even get\na stronger system as a result, but the point is that it is not\ngenerallytrue,anddependsonwhatyouʼredoing.\n7.7 CBC bit flipping attacks\nAninterestingattackonCBCmodeiscalledabitflippingat-\ntack. Using a CBC bit flipping attack, attackers can modify\nCHAPTER7. STREAMCIPHERS 54\nciphertextsencryptedinCBCmodesothatitwillhaveapre-\ndictableeffectontheplaintext.\nThis may seem like a very strange definition of “attack”\nat first. The attacker will not even attempt to decrypt any\nmessages,buttheywilljustbeflippingsomebitsinaplain-\ntext. Wewilldemonstratethattheattackercanturntheabil-\nity to flip some bits in the plaintext into the ability to have\ntheplaintextsaywhatevertheywantittosay,and,ofcourse,\nthatcanleadtoveryseriousproblemsinrealsystems.\nSupposewehaveaCBCencryptedciphertext. Thiscould\nbe, for example, a cookie. We take a particular ciphertext\nblock,andweflipsomebitsinit. Whathappenstotheplain-\ntext?\nWhen we “flip some bits”, we do that by XORing with a\nsequence of bits, which weʼll call X. If the corresponding\nbit in X is 1, the bit will be flipped; otherwise, the bit will\nremainthesame.\nWhen we try to decrypt the ciphertext block with the\nflippedbits,wewillgetindecipherable4 nonsense. Remem-\n4Excusethepun.\nCHAPTER7. STREAMCIPHERS 55\nber how CBC decryption works: the output of the block ci-\npherisXORedwiththepreviousciphertextblocktoproduce\ntheplaintextblock. NowthattheinputciphertextblockC\ni\nhas been modified, the output of the block cipher will be\nsome random unrelated block, and, statistically speaking,\nnonsense. AfterbeingXORedwiththatpreviousciphertext\nblock, it will still be nonsense. As a result, the produced\nplaintextblockisstilljustnonsense. Intheillustration,this\n′\nunintelligibleplaintextblockisP .\ni\nHowever,intheblockafterthat,thebitsweflippedinthe\nciphertextwillbeflippedintheplaintextaswell! Thisisbe-\ncause, in CBC decryption, ciphertext blocks are decrypted\nby the block cipher, and the result is XORed with the previ-\nousciphertextblock. Butsincewemodifiedthepreviousci-\nphertextblockbyXORingitwithX,theplaintextblockP\ni+1\nwill also be XORed with X. As a result, the attacker com-\npletelycontrolsthatplaintextblockP ,sincetheycanjust\ni+1\nflipthebitsthatarenʼtthevaluetheywantthemtobe.\nTODO: add previous illustration, but mark the path X\ntakestoinfluencePprime{i+1}inredorsomething\nThismaynotsoundlikeahugedealatfirst. Ifyoudonʼt\nknowtheplaintextbytesofthatnextblock,youhavenoidea\nwhichbitstoflipinordertogettheplaintextyouwant.\nToillustratehowattackerscanturnthisintoapractical\nattack,letʼsconsiderawebsiteusingcookies. Whenyoureg-\nister, yourchosenusernameisputintoacookie. Theweb-\nsite encrypts the cookie and sends it to your browser. The\nnexttimeyourbrowservisitsthewebsite,itwillprovidethe\nencrypted cookie; the website decrypts it and knows who\nyouare.\nAnattackercanoftencontrolatleastpartoftheplaintext\nbeing encrypted. In this example, the user name is part of\nthe plaintext of the cookie. Of course, the website just lets\nyou provide whatever value for the user name you want at\nregistration, so the attacker can just add a very long string\nof Z bytes to their user name. The server will happily en-\ncryptsuchacookie,givingtheattackeranencryptedcipher-"
  },
  {
    "input": "Padding",
    "output": "CHAPTER7. STREAMCIPHERS 56\ntextthatmatchesaplaintextwithmanysuchZbytesinthem.\nTheplaintextgettingmodifiedwillthenprobablybepartof\nthatsequenceof Zbytes.\nAn attacker may have some target bytes that theyʼd like\ntoseeinthedecryptedplaintext, forexample, ;admin=1;.\nIn order to figure out which bytes they should flip (so, the\nvalueofX intheillustration), theyjustXORthefillerbytes\n(~ZZZ~…)withthattarget. BecausetwoXORoperationswith\nthe same value cancel each other out, the two filler values\n(~ZZZ~…)willcancelout,andtheattackercanexpecttosee\n;admin=1;popupinthenextplaintextblock:\nP ′ = P ⊕X\ni+1 i+1\n= P ⊕ZZZZZZZZZ⊕;admin = 1;\ni+1\n= ZZZZZZZZZ⊕ZZZZZZZZZ⊕;admin = 1;\n= ;admin = 1;\nThisattackisanotherdemonstrationofanimportantcrypto-\ngraphicprinciple: encryptionisnotauthentication! Itʼsvir-\ntually never sufficient to simply encrypt a message. It may\npreventanattackerfromreadingit,butthatʼsoftennoteven\nnecessaryfortheattackertobeabletomodifyittosaywhat-\nevertheywantitto. Thisparticularproblemwouldbesolved\nbyalsosecurelyauthenticatingthemessage. Weʼllseehow\nyou can do that later in the book; for now, just remember\nthatweʼregoingtoneedauthenticationinordertoproduce\nsecurecryptosystems.\n7.8 Padding\nSo far, weʼve conveniently assumed that all messages just\nhappened to fit exactly in our system of block ciphers, be\nit CBC or ECB. That means that all messages happen to be\namultipleoftheblocksize,which,inatypicalblockcipher\nsuchasAES,is16bytes. Ofcourse,realmessagescanbeof\narbitrary length. We need some scheme to make them fit.\nThatprocessiscalledpadding."
  },
  {
    "input": "CBC padding attacks",
    "output": "CHAPTER7. STREAMCIPHERS 57\nPaddingwithzeroes(orsomeotherpadbyte)\nOnewaytopadwouldbetosimplyappendaparticularbyte\nvalueuntiltheplaintextisoftheappropriatelength. Toundo\nthepadding,youjustremovethosebytes. Thisschemehas\nan obvious flaw: you canʼt send messages that end in that\nparticular byte value, or you will be unable to distinguish\nbetweenpaddingandtheactualmessage.\nPKCS#5/PKCS#7padding\nAbetter,andmuchmorepopularscheme,isPKCS#5/PKCS#7\npadding.\nPKCS#5, PKCS#7 and later CMS padding are all more or\nless the same idea5. Take the number of bytes you have to\npad, andpadthemwiththatmanytimesthebytewiththat\nvalue. Forexample, iftheblocksizeis8bytes, andthelast\nblockhasthethreebytes12 34 45,theblockbecomes12\n34 45 05 05 05 05 05afterpadding.\nIftheplaintexthappenedtobeexactlyamultipleofthe\nblocksize,anentireblockofpaddingisused. Otherwise,the\nrecipientwouldlookatthelastbyteoftheplaintext,treatit\nasapaddinglength,andalmostcertainlyconcludethemes-\nsagewasimproperlypadded.\nThisschemeisdescribedin[Hou].\n7.9 CBC padding attacks\nWecanrefineCBCbitflippingattackstotrickarecipientinto\ndecryptingarbitrarymessages!\nAsweʼvejustdiscussed, CBCmode requirespadding the\nmessagetoamultipleoftheblocksize. Ifthepaddingisin-\ncorrect, the recipient typically rejects the message, saying\n5Technically,PKCS#5paddingisonlydefinedfor8byteblocksizes,\nbuttheideaclearlygeneralizeseasily,anditʼsalsothemostcommonly\nusedterm.\nCHAPTER7. STREAMCIPHERS 58\nthatthepaddingwasinvalid. Wecanusethattinybitofin-\nformation about the padding of the plaintext to iteratively\ndecrypttheentiremessage.\nTheattackerwilldothis,oneciphertextblockatatime,\nby trying to get an entire plaintext block worth of valid\npadding. Weʼllseethatthistellsthemthedecryptionoftheir\ntarget ciphertext block, under the block cipher. Weʼll also\nseethatyoucandothisefficientlyanditeratively,justfrom\nthatlittleleakofinformationaboutthepaddingbeingvalid\nornot.\nIt may be helpful to keep in mind that a CBC padding\nattackdoesnotactuallyattackthepaddingforagivenmes-\nsage;insteadtheattackerwillbeconstructingpaddingstode-\ncryptamessage.\nTomountthisattack,anattackeronlyneedstwothings:\n1. Atargetciphertexttodecrypt\n2. Apaddingoracle: afunctionthattakesciphertextsand\ntellstheattackerifthepaddingwascorrect\nAs with the ECB encryption oracle, the availability of a\npadding oracle may sound like a very unrealistic assump-\ntion. The massive impact of this attack proves otherwise.\nFora long time, most systemsdid noteven attemptto hide\nif the padding was valid or not. This attack remained dan-\ngerousforalongtimeafteritwasoriginallydiscovered,be-\ncauseitturnsoutthatinmanysystemsitisextremelydiffi-\nculttoactuallyhideifpaddingisvalidornot. Wewillgointo\nthisprobleminmoredetailbothinthischapterandinlater\nchapters.\nIn this chapter, weʼll assume that PKCS#5/PKCS#7\npadding is being used, since thatʼs the most popular op-\ntion. The attack is general enough to work on other kinds\nofpadding,withminormodifications.\nCHAPTER7. STREAMCIPHERS 59\nDecryptingthefirstbyte\nTheattackerfillsablockwitharbitrarybytesR = r ,r ...r .\n1 2 b\nThey also pick a target block C from the ciphertext that\ni\ntheyʼd like to decrypt. The attacker asks the padding ora-\ncle if the plaintext of R∥C has valid padding. Statistically\ni\nspeaking,sucharandomplaintextprobablywonʼthavevalid\npadding: the odds are in the half-a-percent ballpark. If\nby pure chance the message happens to already have valid\npadding,theattackercansimplyskipthenextstep.\nNext, the attackertries to modify the messageso that it\ndoeshavevalidpadding. Theycandothatbyindirectlymod-\nifyingthelastbyteoftheplaintext: eventuallythatbytewill\nbe01,whichisalwaysvalidpadding. Inordertomodifythe\nlast byte of a plaintext block, the attacker modifies the last\nbyteofthepreviousciphertextblock. Thisworksexactlylike\nitdidwithCBCbitflippingattacks. Thatpreviousciphertext\nblock is the block R, so the byte being modified is the last\nbyteofR,r .\nb\nThe attacker tries all possible values for that last byte.\nThereareseveralwaysofdoingthat: modularaddition,XOR-\nCHAPTER7. STREAMCIPHERS 60\ningitwithallvaluesupto256,orevenpickingrandomly;the\nonlythingthatmattersisthattheattackertriesallofthem.\nEventually, the padding oracle will report that for some ci-\nphertextblockR,thedecryptedplaintextofR∥C hasvalid\ni\npadding.\nDiscoveringthepaddinglength\nTheoraclehasjusttoldtheattackerthatforourchosenvalue\nof R, the plaintext of R∥C has valid padding. Since weʼre\ni\nworkingwithPKCS#5padding,thatmeansthattheplaintext\nblockP endsinoneofthefollowingbytesequences:\ni\n• 01\n• 02 02\n• 03 03 03\n• …\nThefirstoption(01)ismuchmorelikelythantheothers,\nsinceitonlyrequiresonebytetohaveaparticularvalue. The\nattacker is modifying that byte to take every possible value,\nso it is quite likely that they happened to stumble upon 01.\nAll of the other valid padding options not only require that\nbyte to have some particular value, but also one or more\notherbytes. Foranattackertobeguaranteedamessagewith\navalid01padding,theyjusthavetotryeverypossiblebyte.\nForanattackertoendupwithamessagewithavalid02 02\npadding,theyhavetotryeverypossiblebyteandhappento\nhavepickedacombinationofC andRthatcausestheplain-\ntexttohavea02inthatsecond-to-lastposition. (Torephrase:\nthe second-to-last byte of the decryption of the ciphertext\nblock,XORedwiththesecond-to-lastbyteofR,is02.)\nIn order to successfully decrypt the message, we still\nneed to figure out which one of those options is the actual\nvalueofthepadding. Todothat,wetrytodiscoverthelength\nof the padding by modifying bytes starting at the left-hand\nCHAPTER7. STREAMCIPHERS 61\nsideofP untilthepaddingbecomesinvalidagain. Aswith\ni\neverythingelseinthisattack,wemodifythosebytesinP by\ni\nmodifying the equivalent bytes in our chosen block R. As\nsoonaspaddingbreaks,youknowthatthelastbyteyoumod-\nifiedwaspartofthevalidpadding,whichtellsyouhowmany\npaddingbytesthereare. SinceweʼreusingPKCS#5padding,\nthatalsotellsyouwhattheirvalueis.\nLetʼsillustratethiswithanexample. Supposeweʼvesuc-\ncessfully found some block R so that the plaintext of R∥C\ni\nhasvalidpadding. Letʼssaythatpaddingis03 03 03. Nor-\nmally,theattackerwouldnʼtknowthis;thepointofthispro-\ncedureistodiscoverwhatthatpaddingis. Supposetheblock\nsizeis8bytes. So, we(butnottheattacker)knowthatP is\ni\ncurrently:\np p p p p 030303\n0 1 2 3 4\nInthatequation,p ...aresomebytesoftheplaintext. Their\n0\nactual value doesnʼt matter: the only thing that matters is\nthat theyʼre not part of the padding. When we modify the\nfirstbyteofR,weʼllcauseachangeinthefirstbyteofP ,so\ni\n′\nthatp becomessomeotherbytep :\n0 0\n′\np p p p p 030303\n0 1 2 3 4\nAsyoucansee,thisdoesnʼtaffectthevalidityofthepadding.\nIt also does not affect p , p , p or p . However, when we\n1 2 3 4\ncontinuemodifyingsubsequentbytes,wewilleventuallyhit\nabytethatis partofthepadding. Forexample, letʼssaywe\nturnthatfirst03into02bymodifyingR. P nowlookslike\ni\nthis:\n′ ′ ′ ′ ′\np p p p p 020303\n0 1 2 3 4\nSince02 03 03isnʼtvalidPKCS#5padding,theserverwill\nrejectthemessage. Atthatpoint,weknowthatoncewemod-\nifysixbytes,thepaddingbreaks. Thatmeansthesixthbyte\nisthefirstbyteofthepadding. Sincetheblockis8byteslong,\nCHAPTER7. STREAMCIPHERS 62\nweknowthatthepaddingconsistsofthesixth,seventhand\neighth bytes. So, the padding is three bytes long, and, in\nPKCS#5,equalto03 03 03.\nA clever attacker whoʼs trying to minimize the number\nof oracle queries can leverage the fact that longer valid\npadding becomes progressively more rare. They can do\nthis by starting from the penultimate byte instead of the\nbeginning of the block. The advantage to this method is\nthatshortpaddings(whicharemorecommon)aredetected\nmorequickly. Forexample,ifthepaddingis0x01andanat-\ntackerstartsmodifyingthepenultimatebyte,theyonlyneed\nonequerytolearnwhatthepaddingwas. Ifthepenultimate\nbyte is changed to any other value and the padding is still\nvalid,thepaddingmustbe0x01. Ifthepaddingisnotvalid,\nthe padding must be at least 0x02 0x02. So, they go back\ntotheoriginalblockandstartmodifyingthethirdbytefrom\ntheback. Ifthatpasses,thepaddingwasindeed0x02 0x02,\notherwise the padding must be at least 0x03 0x03 0x03.\nThe process repeats until theyʼve found the correct length.\nThisisalittletrickiertoimplement;youcanʼtjustkeepmod-\nifyingthesameblock(ifitʼsmutable),andyouʼrewaitingfor\nthe oracle to fail instead of pass, which can be confusing.\nButotherthanbeingfasteratthecostofbeingslightlymore\ncomplex, this technique is equivalent to the one described\nabove.\nFor the next section, weʼll assume that it was just 01,\nsince that is the most common case. The attack doesnʼt re-\nallychangedependingonthelengthofthepadding. Ifyou\nguessmorebytesofpaddingcorrectly,thatjustmeansthat\ntherearefewerremainingbytesyouwillhavetoguessman-\nually. (Thiswillbecomeclearonceyouunderstandtherest\noftheattack.)\nDecryptingonebyte\nAtthispoint,theattackerhasalreadysuccessfullydecrypted\nthelastbyteofthetargetblockofciphertext! Actually,weʼve\nCHAPTER7. STREAMCIPHERS 63\ndecryptedasmanybytesaswehavevalidpadding;weʼrejust\nassumingtheworstcasescenariowherethereisonlyasin-\nglebyte. How? Theattackerknowsthatthelastbyteofthe\ndecryptedciphertextblockC (weʼllcallthatbyteD(C )[b]),\ni i\nXORedwiththeiterativelyfoundvaluer ,is01:\nb\nD(C )[b]⊕r = 01\ni b\nBymovingtheXORoperationtotheotherside,theattacker\ngets:\nD(C )[b] = 01⊕r\ni b\nTheattackerhasnowtrickedthereceiverintorevealingthe\nvalueofthelastbyteoftheblockcipherdecryptionofC .\ni\nDecryptingsubsequentbytes\nNext,theattackertricksthereceiverintodecryptingthenext\nbyte. Rememberthepreviousequation,wherewereasoned\nthatthelastbyteoftheplaintextwas01:\nD(C )[b]⊕r = 01\ni b\nNow, weʼd like to get that byte to say 02, to produce an al-\nmost valid padding: the last byte would be correct for a 2-\nbyte PKCS#5 padding (02 02), but that second-to-last byte\nprobablyisnʼt02yet. Todothat, weXORwith01tocancel\nthe 01 thatʼs already there (since two XORs with the same\nvalue cancel each other out), and then we XOR with 02 to\nget02:\nD(C )[b]⊕r ⊕01⊕02 = 01⊕01⊕02\ni b\n= 02\nSo, to produce a value of 02 in the final position of the de-\ncryptedplaintext,theattackerreplacesr with:\nb\nr ′ = r ⊕01⊕02\nb b\nCHAPTER7. STREAMCIPHERS 64\nThis accomplishes the goal of almost valid padding. Then,\ntheytryallpossiblevaluesforthesecond-to-lastbyte(index\nb − 1). Eventually, one of them will cause the message to\nhavevalidpadding. Sincewemodifiedtherandomblockso\nthat the final byte of the plaintext will be 02, the only byte\ninthesecond-to-lastpositionthatcancausevalidpaddingis\n02aswell. Usingthesamemathasabove,theattackerhas\nrecoveredthesecond-to-lastbyte.\nThen, itʼs just rinse and repeat. The last two bytes are\nmodified to create an almost-valid padding of 03 03, then\nthethirdbytefromtherightismodifieduntilthepaddingis\nvalid,andsoon. Repeatingthisforallthebytesintheblock\nmeans the attacker can decrypt the entire block; repeating\nitfordifferentblocksmeanstheattackercanreadtheentire\nmessage.\nThis attack has provento be very subtle and hardto fix.\nFirstofall,messagesshouldbeauthenticated,aswellasen-\ncrypted. Thatwouldcausemodifiedmessagestoberejected.\nHowever, many systems decrypt (and remove padding) be-\nfore authenticating the message; so the information about\nthe padding being valid or not has already leaked. We will\ndiscusssecurewaysofauthenticatingmessageslaterinthe\nbook.\nYou might consider just getting rid of the “invalid\npadding” message; declaring the message invalid without\nspecifying why it was invalid. That turns out to only be a\npartialsolutionforsystemsthatdecryptbeforeauthenticat-\ning. Those systems would typically reject messages with\naninvalidpaddingslightlyfaster thanmessageswithavalid\npadding. Afterall,theydidnʼthavetodotheauthentication\nstep: ifthepaddingisinvalid,themessagecanʼtpossiblybe\nvalid. Anattackthatleakssecretinformationthroughtiming\ndifferences is called a timing attack, which is a special case\nofaside-channelattack: attacksonthepracticalimplementa-\ntionofacryptosystemratherthanits“perfect”abstractrep-\nresentation. Wewilltalkaboutthesekindsofattacksmore\nlaterinthebook."
  },
  {
    "input": "Native stream ciphers",
    "output": "CHAPTER7. STREAMCIPHERS 65\nThat discrepancy was commonly exploited as well. By\nmeasuringhowlongittakestherecipienttorejectthemes-\nsage,theattackercantelliftherecipientperformedtheau-\nthenticationstep. Thattellsthemifthepaddingwascorrect\nornot,providingthepaddingoracletocompletetheattack.\nTheprincipallessonlearnedhereis,again,nottodesign\nyourowncryptosystems. Themainwaytoavoidthispartic-\nularproblemisbyperformingconstanttimeauthentication,\nand authenticating the ciphertext before decrypting it. We\nwill talk more about this in a later chapter on message au-\nthentication.\n7.10 Native stream ciphers\nInadditiontoblockciphersbeingusedinaparticularmode\nofoperation,therearealso“native”streamciphersalgorithms\nthataredesignedfromthegrounduptobeastreamcipher.\nThe most common type of stream cipher is called a syn-\nchronous stream cipher. These algorithms produce a long\nstream of pseudorandom bits from a secret symmetric key.\nThis stream, called the keystream, is then XORed with the\nplaintexttoproducetheciphertext. Decryptionistheiden-\ntical operation as encryption, just repeated: the keystream\nisproducedfromthekey,andisXORedwiththeciphertext\ntoproducetheplaintext.\nYoucanseehowthisconstructionlooksquitesimilarto\naone-time pad, exceptthat thetrulyrandomone-time pad\nhasbeenreplacedbyapseudorandomstreamcipher."
  },
  {
    "input": "RC4",
    "output": "CHAPTER7. STREAMCIPHERS 66\nThere are also asynchronous or self-synchronizing stream\nciphers, where the previously produced ciphertext bits are\nusedtoproducethecurrentkeystreambit. Thishasthein-\nterestingconsequencethatareceivercaneventuallyrecover\nif some ciphertext bits are dropped. This is generally not\nconsidered to be a desirable property anymore in modern\ncryptosystems, which instead prefer to send complete, au-\nthenticated messages. As a result, these stream ciphers are\nvery rare, and we donʼt talk about them explicitly in this\nbook. Whenever someone says “stream cipher”, itʼs safe to\nassumetheymeanthesynchronouskind.\nHistorically, native stream ciphers have had their issues.\nNESSIE,aninternationalcompetitionfornewcryptographic\nprimitives, forexample, didnotresultinanynewstreamci-\nphers,becausealloftheparticipantswerebrokenbeforethe\ncompetition ended. RC4, one of the most popular native\nstream ciphers, has had serious known issues for years. By\ncomparison,someoftheconstructionsusingblockciphers\nseembulletproof.\nFortunately, more recently, several new cipher algo-\nrithms provide new hope that we can get practical, secure\nandperformantstreamciphers.\n7.11 RC4\nByfarthemostcommonnativestreamcipherincommonuse\nondesktopandmobiledevicesisRC4.\nRC4issometimesalsocalledARCFOURorARC4,which\nstandsforallegedRC4. Whileitssourcecodehasbeenleaked\nand its implementation is now well-known, RSA Security\n(the company that authored RC4 and still holds the RC4\ntrademark) has never acknowledged that it is the real algo-\nrithm.\nIt quickly became popular because itʼs very simple and\nvery fast. Itʼs not just extremely simple to implement, itʼs\nalsoextremelysimpletoapply. Beingasynchronousstream\ncipher, thereʼs little that can go wrong; with a block cipher,\nCHAPTER7. STREAMCIPHERS 67\nyouʼd have to worry about things like modes of operation\nandpadding. Clockinginataround13.9cyclesperbyte,itʼs\ncomparabletoAES-128inCTR(12.6cyclesperbyte)orCBC\n(16.0cyclesperbyte)modes. AEScameoutafewyearsafter\nRC4;whenRC4wasdesigned,thestateoftheartwas3DES,\nwhichwasexcruciatinglyslowbycomparison(134.5 cycles\nperbyteinCTRmode). [Dai]\nAnin-depthlookatRC4\nThisisanoptional,in-depthsection. It\nalmost certainly wonʼt help you write bet-\ntersoftware,sofeelfreetoskipit. Itisonly\nheretosatisfyyourinnergeekʼscuriosity.\nOn the other hand, RC4 is incredibly simple, and it may be\nworthskimmingthissection.\nRC4 is, unfortunately, quite broken. To better under-\nstand just how broken, weʼll take a look at how RC4 works.\nThe description requires understanding modular addition;\nifyouarenʼtfamiliarwithit,youmaywanttoreviewtheap-\npendixonmodularaddition(page186).\nEverythinginRC4revolvesaroundastatearrayandtwo\nindexesintothatarray. Thearrayconsistsof256bytesform-\ningapermutation: thatis,allpossibleindexvaluesoccurex-\nactly once as a value in the array. That means it maps ev-\nerypossiblebytevaluetoeverypossiblebytevalue: usually\ndifferent, butsometimesthesameone. Weknowthatitʼsa\npermutationbecauseSstartsasone,andalloperationsthat\nmodifySalwaysswapvalues,whichobviouslykeepsitaper-\nmutation.\nRC4consistsoftwomajorcomponentsthatworkontwo\nindexesi,j andthestatearrayS:\n1. Thekeyschedulingalgorithm,whichproducesanini-\ntialstatearrayS foragivenkey.\nCHAPTER7. STREAMCIPHERS 68\n2. Thepseudorandomgenerator,whichproducestheac-\ntualkeystreambytesfromthestatearrayS whichwas\nproducedbythekeyschedulingalgorithm. Thepseu-\ndorandom generator itself modifies the state array as\nitproduceskeystreambytes.\nThekeyschedulingalgorithm\nThekeyschedulingalgorithmstartswiththeidentitypermu-\ntation. Thatmeansthateachbyteismappedtoitself.\nThen,thekeyismixedintothestate. Thisisdonebylet-\nting index i iterate over every element of the state. The j\nindexisfoundbyaddingthecurrentvalueofj(startingat0)\nwiththenextbyteofthekey,andthecurrentstateelement:\nOncej hasbeenfound,S[i]andS[j]areswapped:\nThisprocessisrepeatedforalltheelementsofS. Ifyou\nrunoutofkeybytes,youjustwraparoundonthekey. This\nexplains why RC4 accepts keys from anywhere between 1\nCHAPTER7. STREAMCIPHERS 69\nand256byteslong. Usually, 128bit(16byte)keysareused,\nwhichmeansthateachbyteinthekeyisused16times.\nOr,inPython:\nfrom itertools import cycle\ndef key_schedule(key):\ns = range(256)\nkey_bytes = cycle(ord(x) for x in key)\nj = 0\nfor i in range(256):\nj = (j + s[i] + next(key_bytes)) % 256\ns[i], s[j] = s[j], s[i]\nreturn s\nThepseudorandomgenerator\nThe pseudorandom generator is responsible for producing\npseudorandombytesfromthestateS. Thesebytesformthe\nkeystream,andareXORedwiththeplaintexttoproducethe\nciphertext. Foreachindexi,itcomputesj = j+S[i](jstarts\nat0). Then,S[i]andS[j]areswapped:\nTo produce the output byte, S[i] and S[j] are added to-\ngether. Their sum is used as an index into S; the value at\nCHAPTER7. STREAMCIPHERS 70\nS[S[i]+S[j]]isthekeystreambyteK :\ni\nWecanexpressthisinPython:\ndef pseudorandom_generator(s):\nj = 0\nfor i in cycle(range(256)):\nj = (j + s[i]) % 256\ns[i], s[j] = s[j], s[i]\nk = (s[i] + s[j]) % 256\nyield s[k]\nAttacks\nThisisanoptional,in-depthsection. It\nalmost certainly wonʼt help you write bet-\ntersoftware,sofeelfreetoskipit. Itisonly\nheretosatisfyyourinnergeekʼscuriosity.\nThesectionontheattacksonRC4isagooddealmorecom-\nplicatedthanRC4itself,soyoumaywanttoskipthisevenif\nyouʼvereadthisfar.\nThere are many attacks on RC4-using cryptosystems\nwhereRC4isnʼtreallytheissue,butarecausedbythingslike\nkey reuse or failing to authenticate the message. We wonʼt\ndiscuss these in this section. Right now, weʼre only talking\naboutissuesspecifictotheRC4algorithmitself.\nCHAPTER7. STREAMCIPHERS 71\nIntuitively,wecanunderstandhowanidealstreamcipher\nwould produce a stream of random bits. After all, if thatʼs\nwhatitdid,weʼdendupinasituationquitesimilartothatof\naone-timepad.\nFigure7.2: Aone-timepadscheme.\nFigure 7.3: A synchronous stream cipher scheme. Note\nsimilarity to the one-time pad scheme. The critical differ-\nence is that while the one-time pad k is truly random, the\ni\nkeystreamK isonlypseudorandom.\ni\nThestreamcipherisidealifthebestwaywehavetoattack\nitistotryallofthekeys, aprocesscalledbrute-forcingthe\nkey. If thereʼs an easier way, such as through a bias in the\noutputbytes,thatʼsaflawofthestreamcipher.\nThroughoutthehistoryofRC4,peoplehavefoundmany\nsuchbiases. Inthemid-nineties,AndrewRoosnoticedtwo\nsuchflaws:\n• Thefirstthreebytesofthekeyarecorrelatedwiththe\nfirstbyteofthekeystream.\n• The first few bytes of the state are related to the key\nwithasimple(linear)relation.\nCHAPTER7. STREAMCIPHERS 72\nForanidealstreamcipher,thefirstbyteofthekeystream\nshould tell me nothing about the key. In RC4, it gives me\nsomeinformationaboutthefirstthreebytesofthekey. The\nlatter seems less serious: after all, the attacker isnʼt sup-\nposedtoknowthestateofthecipher.\nAsalways,attacksnevergetworse. Theyonlygetbetter.\nAdiShamirandItsikMantinshowedthatthesecondbyte\nproduced by the cipher is twice as likely to be zero as it\nshould be. Other researchers showed similar biases in the\nfirst few bytes of the keystream. This sparked further re-\nsearch by Mantin, Shamir and Fluhrer, showing large bi-\nases in the first bytes of the keystream. [FMS01] They also\nshowed that knowing even small parts of the key would al-\nlowattackerstomakestrongpredictionsaboutthestateand\noutputs of the cipher. Unlike RC4, most modern stream\nciphers provide a way to combine a long-term key with a\nnonce (a number used once), to produce multiple different\nkeystreams from the same long-term key. RC4, by itself,\ndoesnʼt do that. The most common approach was also the\nsimplest: concatenate6thelong-termkeykwiththenoncen:\nk∥n, taking advantage of RC4ʼs flexible key length require-\nments. In this context, concatenation means the bits of n\nareappendedtothebitsofk. Thisschememeantattackers\ncould recover parts of the combined key, eventually allow-\ning them to slowly recover the long-term key from a large\namount of messages (around 224 to 226, or tens of millions\nofmessages).\nWEP, a standard for protecting wireless networks that\nwaspopularatthetime,washeavilyaffectedbythisattack,\nbecauseitusedthissimplisticnoncecombinationscheme. A\nschemewherethelong-termkeyandthenoncehadbeense-\ncurely combined (for example using a key derivation func-\ntion or a cryptographic hash function) wouldnʼt have had\n6Hereweuse∥astheoperatorforconcatenation. Othercommon\nsymbolsforconcatenationinclude+(forsomeprogramminglanguages,\nsuchasPython)and(cid:0)(forformallanguages).\nCHAPTER7. STREAMCIPHERS 73\nthis weakness. Many other standards including TLS were\nthereforenotaffected.\nAgain, attacks only get better. Andreas Klein showed\nmore extensive correlation between the key and the\nkeystream. [Kle08] Instead of tens of millions of messages\nwith the Fluhrer, Mantin, Shamir attacks, attackers now\nonlyneededseveraltensofthousandsofmessagestomake\ntheattackpractical. ThiswasappliedagainstWEPwithgreat\neffect.\nIn2013,ateamofresearchersatRoyalHollowayinLon-\ndon produced a combination of two independent practical\nattacks [ABP+]. These attacks proved to be very damning\nforRC4: whileRC4ʼsweaknesseshadbeenknownforalong\ntime,theyfinallydrovethepointhomeforeveryonethatit\nreallyshouldnʼtbeusedanymore.\nThefirstattackisbasedonsingle-bytebiasesinthefirst\n256bytesofthekeystream. Byperformingstatisticalanaly-\nsis on the keystreams produced by a large number of keys,\nthey were able to analyze the already well-known biases in\ntheearlykeystreambytesofRC4inmuchgreaterdetail.\nTODO: illustrate: http://www.isg.rhul.ac.uk/\ntls/RC4_keystream_dist_2_45.txt\nThe second attack is based on double byte biases any-\nwhere in the keystream. It turns out that adjacent bytes of\nthe keystream have an exploitable relation, whereas in an\nidealstreamcipher youwouldexpectthemtobecompletely\nindependent.\nCHAPTER7. STREAMCIPHERS 74\nByte pair Byte position (mod 256) i Probability\n(0,0) i = 1 2\n−16(1+2 −9)\n(0,0) i ̸∈ {1,255} 2 −16(1+2 −8)\n(0,1) i ̸∈ {0,1} 2 −16(1+2 −8)\n(0,i+1) i ̸∈ {0,255} 2 −16(1+2 −8)\n(i+1,255) i ̸= 254 2 −16(1+2 −8)\n(255,i+1) i ̸∈ {1,254} 2 −16(1+2 −8)\n(255,i+2) i ̸∈ {0,253,254,255} 2 −16(1+2 −8)\n(255,0) i = 254 2\n−16(1+2 −8)\n(255,1) i = 255 2\n−16(1+2 −8)\n(255,2) i ∈ {0,1} 2 −16(1+2 −8)\n(255,255) i ̸= 254 2 −16(1+2 −8)\n(129,129) i = 2 2\n−16(1+2 −8)\nThistablemayseemabitdauntingatfirst. Theprobabil-\nityexpressionintherightmostcolumnmaylookabitcom-\nplex, but thereʼs a reason itʼs expressed that way. Suppose\nthat RC4 was a good stream cipher, and all values occurred\nwithequalprobability. Thenyouʼdexpecttheprobabilityfor\nany given byte value to be 2 −8 since there are 28 different\nbyte values. If RC4 was a good stream cipher, two adjacent\nbyteswouldeachhaveprobability2\n−8,\nsoanygivenpairof\ntwobyteswouldhaveprobability2\n−8·2 −8\n= 2\n−16.\nHowever,\nRC4 isnʼt an ideal stream cipher, so these properties arenʼt\ntrue. By writing the probability in the 2\n−16(1\n+ 2\n−k)\nform,\nitʼseasiertoseehowmuchRC4deviatesfromwhatyouʼdex-\npectfromanidealstreamcipher.\nSo,letʼstrytoreadthefirstlineofthetable. Itsaysthat\nwhen the first byte i = 1 of any 256-byte chunk from the\ncipheris0, thenthebytefollowingitisslightlymorelikely\n(1 + 2\n−9\ntimes as likely, to be exact) to be 0 than for it to\nbe any other number. We can also see that when one of\nthekeystreambytesis255,youcanmakemanypredictions\nabout the next byte, depending on where it occurs in the\nkeystream. Itʼs more likely to be 0,1,2,255, or the position\ninthekeystreamplusoneortwo."
  },
  {
    "input": "Salsa20",
    "output": "CHAPTER7. STREAMCIPHERS 75\nTODO:demonstrateattacksuccess\nAgain, attacks only get better. These attacks have pri-\nmarily focused on the cipher itself, and havenʼt been fully\noptimizedforpracticalattackson,say,webservices. Theat-\ntackscanbegreatlyimprovedwithsomeextrainformation\nabouttheplaintextyouʼreattemptingtorecover. Forexam-\nple,HTTPcookiesareoftenbase-64orhexencoded.\nThereʼs no way around it: we need to stop using RC4.\nFortunately,weʼvealsodevelopedmanysecurealternatives.\nThecontinuingadvancesincryptanalysisofRC4helpedcon-\ntributetoasenseofurgencyregardingtheimprovementof\ncommonly available cryptographic primitives. Throughout\n2013inparticular,thisledtolargeimprovementsin,forex-\nample,browsercryptography(wewilldiscussbrowsercryp-\ntography,notablySSL/TLS,inalaterchapter).\n7.12 Salsa20\nSalsa20isanewerstreamcipher designedbyDanBernstein.\nBernstein is well-known for writing a lot of open source\n(publicdomain)software,mostofwhichiseitherdirectlyse-\ncurityrelatedorbuiltwithinformationsecurityverymuch\ninmind.\nThere are two minor variants of Salsa20, called\nSalsa20/12 and Salsa20/8, which are simply the same\nalgorithm except with 12 and 8 rounds7 respectively, down\nfrom the original 20. ChaCha is another, orthogonal tweak\nof the Salsa20 cipher, which tries to increase the amount\nof diffusion per round while maintaining or improving\nperformance. ChaCha doesnʼt have a “20” after it; spe-\ncific algorithms do have a number after them (ChaCha8,\nChaCha12, ChaCha20), which refers to the number of\nrounds.\n7Roundsarerepetitionsofaninternalfunction.Typicallyanumber\nofroundsarerequiredtomakeanalgorithmworkeffectively;attacksof-\ntenstartonreduced-roundversionsofanalgorithm.\nCHAPTER7. STREAMCIPHERS 76\nSalsa20 and ChaCha are among the state of the art of\nmodern stream ciphers. There are currently no publicly\nknown attacks against Salsa20, ChaCha, nor against any\nof their recommended reduced-round variants, that break\ntheirpracticalsecurity.\nBoth cipher families are also pretty fast. For long\nstreams, Salsa20 takes about 4 cycles per byte for the full-\nroundversion,about3cyclesperbyteforthe12-roundver-\nsionandabout2cyclesperbyteforthe8-roundversion,on\nmodernIntelprocessors[Ber]andmodernAMDprocessors\n[Dai]. ChaChais(onmostplatforms)slightlyfasterstill. To\nputthatintocomparison,thatʼsmorethanthreetimesfaster\nthan RC48, approximately three times faster than AES-CTR\nwitha128bitkeyat12.6cyclesperbyte,androughlyinthe\nballpark of AES GCM mode9 with specialized hardware in-\nstructions.\nSalsa20 has two particularly interesting properties.\nFirstly, it is possible to “jump” to a particular point in the\nkeystreamwithoutcomputingallpreviousbits. Thiscanbe\nuseful, for example, if a large file is encrypted, and youʼd\nlike to be able to do random reads in the middle of the file.\nWhilemanyencryptionschemesrequiretheentirefiletobe\ndecrypted,withSalsa20,youcanjustselecttheportionyou\nneed. Anotherconstructionthathasthispropertyisamode\nofoperationcalledCTRmode,whichweʼlltalkaboutlater.\nThis ability to “jump” also means that blocks from\nSalsa20 can be computed independently of one another,\nallowing for encryption or decryption to work in parallel,\nwhichcanincreaseperformanceonmulti-coreCPUs.\nSecondly, it is resistant to many side-channel attacks.\nThis is done by ensuring that no key material is ever used\n8The quoted benchmarks donʼt mention RC4 but MARC4, which\nstandsfor“modifiedallegedRC4”. TheRC4sectionexplainswhyitʼs“al-\nleged”,and“modified”meansitthrowsawaythefirst256bytesbecause\nofaweaknessinRC4.\n9GCMmodeisanauthenticatedencryptionmode,whichwewillsee\ninmoredetailinalaterchapter."
  },
  {
    "input": "Native stream ciphers versus modes of operation",
    "output": "CHAPTER7. STREAMCIPHERS 77\nto choose between different code paths in the cipher, and\nthateveryroundismadeupofafixed-numberofconstant-\ntime operations. The result is that every block is produced\nwith exactly the same number of operations, regardless of\nwhatthekeyis.\nBoth stream ciphers are based on an ARX design. One\nbenefit of ARX ciphers is that they are intrinsically con-\nstant time. There are no secret memory access patterns\nthatmightleakinformation,aswithAES.Theseciphersalso\nperform well on modern CPU architectures without need-\ning cipher-specific optimizations. They take advantage of\ngenericvectorinstructions,wheretheCPUperformsrelated\noperationsonmultiplepiecesofdatainasingleinstruction.\nAsaresult,ChaCha20performanceiscompetitivewithAES\nonmodernIntelCPUs,eventhoughthelatterhasspecialized\nhardware.\nHereisanexampleARXoperation:\nx ← x⊕(y⊞z) ≪ n\nTofindthenewvalueofx,firstweperformamodularaddi-\ntion (⊞) of y and z, then we XOR (⊕) the result with x and\nfinally we rotate left (≪) by n bits. This is the core round\nprimitiveofSalsa20.\n7.13 Native stream ciphers versus modes of\noperation\nSome texts only consider native stream ciphers to be stream\nciphers. Thisbookemphasizeswhatthefunctionalityofthe\nalgorithmis. Sincebothblockciphersinamodeofoperation\nandanativestreamciphertakeasecretkeyandcanbeusedto\nencryptastream,andthetwocanusuallyreplaceeachother\nin a cryptosystem, we just call both of them stream ciphers\nandaredonewithit.\nWewillfurtheremphasizethetightlinkbetweenthetwo\nwith CTR mode, a mode of operation which produces a syn-"
  },
  {
    "input": "CTR mode",
    "output": "CHAPTER7. STREAMCIPHERS 78\nchronousstreamcipher. Whiletherearealsomodesofopera-\ntion(likeOFBandCFB)thatcanproduceself-synchronizing\nstreamciphers,thesearefarlesscommon,andnotdiscussed\nhere.\n7.14 CTR mode\nCTRmode,shortforcountermode,isamodeofoperationthat\nworksbyconcatenatinganoncewithacounter. Thecounter\nisincrementedwitheachblock,andpaddedwithzeroesso\nthatthewholeisaslongastheblocksize. Theresultingcon-\ncatenatedstringisrunthroughablockcipher. Theoutputs\noftheblockcipherarethenusedasthekeystream.\nFigure 7.4: CTR mode: a single nonce N with a zero-padded\ncounter i is encrypted by the block cipher to produce a\nkeystream block; this block is XORed with the plaintext\nblockP toproducetheciphertextblockC .\ni i\nThis illustration shows a single input block N∥00...∥i,\nconsistingofnonceN,currentcountervalueiandpadding,\nbeing encrypted by the block cipher E using key k to pro-\nducekeystreamblockS ,whichisthenXORedwiththeplain-\ni\ntextblockP toproduceciphertextblockC .\ni i\nObviously,todecrypt,youdotheexactsamethingagain,\nsince XORing a bit with the same value twice always pro-\nducesthe original bit: p ⊕s ⊕s = p . As a consequence,\ni i i i\nCTR encryption and decryption is the same thing: in both\ncases you produce the keystream, and you XOR either the"
  },
  {
    "input": "Stream cipher bit flipping attacks",
    "output": "CHAPTER7. STREAMCIPHERS 79\nplaintext or the ciphertext with it in order to get the other\none.\nForCTRmodetobesecure,itiscriticalthatnoncesarenʼt\nreused. If they are, the entire keystream will be repeated,\nallowinganattackertomountmulti-timepadattacks.\nThisisdifferentfromaninitializationvector suchasthe\noneusedbyCBC.AnIVhastobeunpredictable. Anattacker\nbeingabletopredictaCTRnoncedoesnʼtreallymatter: with-\noutthesecretkey,theyhavenoideawhattheoutputofthe\nblockcipher(thesequenceinthekeystream)wouldbe.\nLikeSalsa20,CTRmodehastheinterestingpropertythat\nyoucanjumptoanypointinthekeystreameasily: justincre-\nmentthecountertothatpoint. TheSalsa20paragraphonthis\ntopic(page76)explainswhythatmightbeuseful.\nAnotherinterestingpropertyisthatsinceanykeystream\nblock can be computed completely separately from any\notherkeystreamblock,bothencryptionanddecryptionare\nveryeasytocomputeinparallel.\n7.15 Stream cipher bit flipping attacks\nSynchronousstreamciphers,suchasnativestreamciphersor\nablockcipherinCTRmode,arealsovulnerabletoabitflip-\nping attack. Itʼs similar to CBC bit flipping attacks in the\nsensethatanattackerflipsseveralbitsintheciphertext,and\nthatcausessomebitstobeflippedintheplaintext.\nThisattackisactuallymuchsimplertoperformonstream\nciphersthanitisonCBCmode. Firstofall,aflippedbitinthe\nciphertextresultsinthesamebitbeingflippedintheplain-\ntext,notthecorrespondingbitinthefollowingblock. Addi-\ntionally, it only affects that bit; in CBC bit flipping attacks,\nthe plaintext of the modified block is scrambled. Finally,\nsincetheattackerismodifyingasequenceofbytesandnot\nasequenceofblocks,theattacksarenotlimitedbythespe-\ncificblocksize. InCBCbitflippingattacks,forexample,an\nattacker can adjust a single block, but canʼt adjust the adja-\ncentblock."
  },
  {
    "input": "Remaining problems",
    "output": "CHAPTER7. STREAMCIPHERS 80\nTODOillustrate\nThisisyetanotherexampleofwhyauthenticationhasto\ngohandinhandwithencryption. Ifthemessageisproperly\nauthenticated, the recipient can simplyreject the modified\nmessages,andtheattackisfoiled.\n7.16 Authenticating modes of operation\nThereareothermodesofoperationthatprovideauthentica-\ntionaswellasencryptionatthesametime. Sincewehavenʼt\ndiscussedauthenticationatallyet,weʼllhandletheselater.\n7.17 Remaining problems\nWe now have tools that will encrypt large streams of data\nusing a small key. However, we havenʼt actually discussed\nhowweʼregoingtoagreeonthatkey. Asnotedinaprevious\nn(n−1)\nchapter,tocommunicatebetweennpeople,weneed\n2\nkeyexchanges. Thenumberofkeyexchangesgrowsabout\nas fast as the number of people squared. While the key to\nbeexchangedisalotsmallernowthanitwaswithone-time\npads,thefundamentalproblemoftheimpossiblylargenum-\nberofkeyexchangeshasnʼtbeensolvedyet. Wewilltackle\nthatprobleminthenextsection,whereweʼlllookatkeyex-\nchangeprotocols:protocolsthatallowustoagreeonasecret\nkeyoveraninsecuremedium.\nAdditionally, weʼve seen that encryption isnʼt enough to\nprovidesecurity: withoutauthentication,itʼseasyforattack-\nerstomodifythemessage,andinmanyflawedsystemseven\ndecryptmessages. Inafuturechapter,weʼlldiscusshowto\nauthenticatemessages,topreventattackersfrommodifying\nthem."
  },
  {
    "input": "Description",
    "output": "8\nKey exchange\n8.1 Description\nKey exchange protocols attempt to solve a problem that, at\nfirstglance,seemsimpossible. AliceandBob,whoʼvenever\nmet before, have to agree on a secret value. The chan-\nnel they use to communicate is insecure: weʼre assuming\nthateverythingtheysendacrossthechannelisbeingeaves-\ndroppedon.\nWeʼll demonstrate such a protocol here. Alice and Bob\nwillenduphavingasharedsecret,onlycommunicatingover\ntheinsecurechannel. DespiteEvehavingliterallyallofthe\ninformationAliceandBobsendtoeachother,shecanʼtuse\nanyofthatinformationtofigureouttheirsharedsecret.\nThatprotocoliscalledDiffie-Hellman,namedafterWhit-\nfieldDiffieandMartinHellman, thetwocryptographicpio-\nneers who discovered it. They suggested calling the proto-\ncolDiffie-Hellman-Merklekeyexchange,tohonorthecontri-\nbutionsof Ralph Merkle. While his contributions certainly\ndeservehonoring,thattermhasnʼtreallycaughton. Forthe\nbenefitofthereaderweʼllusethemorecommonterm.\n81"
  },
  {
    "input": "Abstract Diffie-Hellman",
    "output": "CHAPTER8. KEYEXCHANGE 82\nPractical implementations of Diffie-Hellman rely on\nmathematicalproblemsthatarebelievedtobeverycomplex\nto solve in the “wrong” direction, but easy to compute in\nthe “right” direction. Understanding the mathematical im-\nplementationisnʼtnecessarytounderstandtheprinciplebe-\nhindtheprotocol. Mostpeoplealsofinditaloteasiertoun-\nderstandwithoutthemathematicalcomplexity. So,weʼllex-\nplainDiffie-Hellmanintheabstractfirst,withoutanymath-\nematicalconstructs. Afterwards, weʼlllookattwopractical\nimplementations.\n8.2 Abstract Diffie-Hellman\nIn order to describe Diffie-Hellman, weʼll use an analogy\nbasedonmixingcolors. Wecanmixcolorsaccordingtothe\nfollowingrules:\n• Itʼsveryeasytomixtwocolorsintoathirdcolor.\n• Mixingtwoormorecolorsindifferentorderresultsin\nthesamecolor.\n• Mixingcolorsisone-way. Itʼsimpossibletodetermine\nif, let alone which, multiple colors were used to pro-\nduceagivencolor. Evenifyouknowitwasmixed,and\nevenifyouknowsomeofthecolorsusedtoproduceit,\nyouhavenoideawhattheremainingcolor(s)were.\nWeʼll demonstrate that with a mixing function like this\none,wecanproduceasecretcoloronlyknownbyAliceand\nBob. Later,weʼllsimplyhavetodescribetheconcreteimple-\nmentationofthosefunctionstogetaconcretekeyexchange\nscheme.\nToillustratewhythisremainssecureinthefaceofeaves-\ndroppers, weʼll walk through an entire exchange with Eve,\ntheeavesdropper,inthemiddle. Eveislisteningtoallofthe\nmessages sent across the network. Weʼll keep track of ev-\nerythingsheknowsandwhatshecancompute,andendup\nseeingwhyEvecanʼtcomputeAliceandBobʼssharedsecret.\nCHAPTER8. KEYEXCHANGE 83\nTo start the protocol, Alice and Bob have to agree on a\nbasecolor. Theycancommunicatethatacrossthenetwork:\nitʼsokayifEveinterceptsthemessageandfindsoutwhatthe\ncoloris. Typically,thisbasecolorisafixedpartoftheproto-\ncol; AliceandBobdonʼtneedtocommunicateit. Afterthis\nstep,Alice,BobandEveallhavethesameinformation: the\nbasecolor.\nAliceandBobbothpickarandomcolor,andtheymixit\nwiththebasecolor.\nAttheendofthisstep,AliceandBobknowtheirrespec-\ntive secret color, the mix of the secret color and the base\ncolor, and the base color itself. Everyone, including Eve,\nknowsthebasecolor.\nThen, Alice and Bob both send their mixed colors over\nthe network. Eve sees both mixed colors, but she canʼt fig-\nCHAPTER8. KEYEXCHANGE 84\nureoutwhateitherofAliceandBobʼssecretcolorsare. Even\nthough she knows the base, she canʼt “un-mix” the colors\nsentoverthenetwork.1\nAttheendofthisstep,AliceandBobknowthebase,their\nrespective secrets, their respective mixed colors, and each\notherʼs mixed colors. Eve knows the base color and both\nmixedcolors.\nOnce Alice and Bob receive each otherʼs mixed color,\ntheyaddtheirownsecretcolortoit. Sincetheorderofthe\nmixingdoesnʼtmatter,theyʼllbothendupwiththesamese-\ncret.\n1Whilethismightseemlikeaneasyoperationwithblack-and-white\napproximationsofcolormixing,keepinmindthatthisisjustafailureof\ntheillustration:ourassumptionwasthatthiswashard.\nCHAPTER8. KEYEXCHANGE 85\nEvecanʼtperformthatcomputation. Shecouldfinishthe\ncomputation with either Alice or Bobʼs secret color, since\nshe has both mixed colors, but she has neither of those se-\ncret colors. She can also try to mix the two mixed colors,\nwhichwouldhavebothAliceandBobʼssecretcolorsmixed\ninto them. However, that would have the base color in it\ntwice, resulting in a different color than the shared secret\ncolorthatAliceandBobcomputed,whichonlyhasthebase\ncolorinitonce."
  },
  {
    "input": "Diffie-Hellman with discrete logarithms",
    "output": "CHAPTER8. KEYEXCHANGE 86\n8.3 Diffie-Hellmanwithdiscretelogarithms\nThis section describes a practical implementation of the\nDiffie-Hellman algorithm, based on the discrete logarithm\nproblem. Itisintendedtoprovidesomemathematicalback-\nground,andrequiresmodulararithmetictounderstand. If\nyouareunfamiliarwithmodulararithmetic,youcaneither\nskip this chapter, or first read the mathematical background\nappendix(page186).\nDiscretelogDiffie-Hellmanisbasedontheideathatcom-\nputingyinthefollowingequationiseasy(atleastforacom-\nputer):\ny ≡ gx (mod p)\nHowever,computingxgiveny,gandpisbelievedtobevery\nhard. Thisiscalledthediscretelogarithmproblem,because\nasimilaroperationwithoutthemodulararithmeticiscalled\nalogarithm.\nThis is just a concrete implementation of the abstract\nDiffie-Hellman process we discussed earlier. The common\nbasecolorisalargeprimepandthebaseg. The“colormix-\ning” operation is the equation given above, where x is the\ninputvalueandyistheresultingmixedvalue.\nWhenAliceorBobselecttheirrandomnumbersr and\nA\nr ,theymixthemwiththebasetoproducethemixednum-\nB\nbersm andm :\nA B\nm ≡ grA (mod p)\nA\nm ≡ grB (mod p)\nB\nThese numbers are sent across the network where Eve can\nsee them. The premise of the discrete logarithm problem\nis that it is okay to do so, because figuring out r in m ≡ gr\n(mod p)issupposedlyveryhard.\nOnce Alice and Bob have each otherʼs mixed numbers,\nthey add their own secret number to it. For example, Bob"
  },
  {
    "input": "Diffie-Hellman with elliptic curves",
    "output": "CHAPTER8. KEYEXCHANGE 87\nwouldcompute:\ns ≡ (grA)rB (mod p)\nWhileAliceʼscomputationlooksdifferent,theygetthesame\nresult, because (grA)rB ≡ (grB)rA (mod p). This is the\nsharedsecret.\nBecauseEvedoesnʼthaver orr ,shecannotperform\nA B\ntheequivalentcomputation: sheonlyhasthebasenumber\ng and mixed numbers m\nA\n≡ grA (mod p) and m\nB\n≡ grB\n(mod p),whichareuselesstoher. Sheneedseitherr orr\nA B\n(orboth)tomakethecomputationAliceandBobdo.\nTODO:SaysomethingaboutactiveMITMattackswhere\ntheattackerpickssmoothvaluestoproduceweaksecrets?\n8.4 Diffie-Hellman with elliptic curves\nThis section describes a practical implementation of the\nDiffie-Hellman algorithm, based on the elliptic curve dis-\ncrete logarithm problem. It is intended to provide some\nmathematical background, and requires a (very basic) un-\nderstanding of the mathematics behind elliptic curve cryp-\ntography. Ifyouareunfamiliarwithellipticcurves,youcan\neither skip this chapter, or first read the mathematical back-\ngroundappendix(page202).\nOne of the benefits of the elliptic curve Diffie-Hellman\nvariant is that the required key size is much, much smaller\nthanthe variantbased onthe discretelog problem. This is\nbecausethefastestalgorithmsforbreakingthediscretelog\nproblem have a larger asymptotic complexity than their el-\nlipticcurvevariants. Forexample,thenumberfieldsievefor\ndiscretelogarithms,astateoftheartalgorithmforattacking\ndiscretelogarithm-basedDiffie-Hellman,hastimecomplex-\nity:\nh p i\nL 1/3, 3 64/9"
  },
  {
    "input": "Remaining problems",
    "output": "CHAPTER8. KEYEXCHANGE 88\nWhichismorethanpolynomial(butlessthanexponential)\ninthenumberofdigits. Ontheotherhand,thefastestalgo-\nrithmsthatcouldbeusedtobreaktheellipticcurvediscrete\nlogproblemallhavecomplexity:\n√\nL[1,1/2] = O( n)\nRelativelyspeaking,thatmeansthatitʼsmuchhardertosolve\ntheellipticcurveproblemthanitistosolvetheregulardis-\ncretelogproblem,usingstateoftheartalgorithmsforboth.\nTheflipsideofthatisthatforequivalentsecuritylevels,the\nellipticcurvealgorithmneedsmuchsmallerkeysizes[Lab]\n[InstitutefStandardsTechnology]2:\nSecurity level in Discrete log key Elliptic curve key\nbits bits bits\n56 512 112\n80 1024 160\n112 2048 224\n128 3072 256\n256 15360 512\n8.5 Remaining problems\nUsingDiffie-Hellman,wecanagreeonsharedsecretsacross\nan insecure Internet, safe from eavesdroppers. However,\nwhile an attacker may not be able to simply get the secret\nfrom eavesdropping, an active attacker can still break the\nsystem. If such an attacker, usually called Mallory, is in\nbetween Alice and Bob, she can still perform the Diffie-\nHellmanprotocoltwice: oncewithAlice,whereMallorypre-\ntendstobeBob,andoncewithBob,whereMallorypretends\ntobeAlice.\n2ThesefiguresareactuallyfortheRSAproblemversustheequivalent\nellipticcurveproblem, buttheirsecuritylevelsaresufficientlycloseto\ngiveyouanidea.\nCHAPTER8. KEYEXCHANGE 89\nThere are two shared secrets here: one between Alice\nand Mallory, and one between Mallory and Bob. The at-\ntacker(Mallory)canthensimplytakeallthemessagesthey\nget from one person and send them to the other, they can\nlook at the plaintext messages, remove messages, and they\ncanalsomodifytheminanywaytheychoose.\nTo make matters worse, even if one of the two partici-\npantswassomehowawarethatthiswasgoingon,theywould\nhavenowaytogettheotherpartytobelievethem. Afterall:\nMalloryperformedthesuccessfulDiffie-Hellmanexchange\nwiththeunwittingvictim,shehasallthecorrectsharedse-\ncrets. Bob has no shared secrets with Alice, just with Mal-\nlory;thereʼsnowayforhimtoprovethatheʼsthelegitimate\nparticipant. AsfarasAlicecantell,Bobjustchoseafewran-\ndomnumbers. ThereʼsnowaytolinkanykeythatBobhas\nwithanykeythatAlicehas.\nAttacks like these are called MITM attacks, because the\nattacker (Mallory) is in between the two peers (Alice and\nBob). Giventhatthenetworkinfrastructurethatwetypically\nuse to send messages is run by many different operators,\nthis kind of attack scenario is very realistic, and a secure\ncryptosystemwillhavetoaddressthemsomehow.\nWhile the Diffie-Hellman protocol successfully pro-\nduced a shared secret between two peers, there are clearly\nsome pieces of the puzzle still missing to build those cryp-\ntosystems. WeneedtoolsthathelpusauthenticateAliceto\nBob and vice versa, and we need tools that help guarantee\nmessage integrity, allowing the receiver to verify that the\nreceived messages are in fact the messages the sender in-\ntendedtosend."
  },
  {
    "input": "Description",
    "output": "9\nPublic-key encryption\n9.1 Description\nSofar,wehaveonlydonesecret-keyencryption. Suppose,that\nyou could have a cryptosystem that didnʼt involve a single\nsecretkey,butinsteadhadakeypair: onepublickey,which\nyou freely distribute, and a private one, which you keep to\nyourself.\nPeople can encrypt information intended for you by us-\ning your public key. The information is then impossible to\ndecipher without your private key. This is called public-key\nencryption.\nFor a long time, people thought this was impossible.\nHowever, starting in the 1970s, such algorithms started ap-\npearing. Thefirstpubliclyavailableencryptionschemewas\nproduced by three cryptographers from MIT: Ron Rivest,\nAdiShamirandLeonardAdleman. Thealgorithmtheypub-\nlished is still the most common one today, and carries the\nfirstlettersoftheirlastnames: RSA.\npublic-keyalgorithmsarenʼtlimitedtoencryption. Infact,\nyouʼve already seen a public-key algorithm in this book that\n90"
  },
  {
    "input": "Why not use public-key encryption for everything?",
    "output": "CHAPTER9. PUBLIC-KEYENCRYPTION 91\nisnʼt directly used for encryption. There are actually three\nrelatedclassesofpublic-keyalgorithms:\n1. Key exchange algorithms, such as Diffie-Hellman,\nwhichallowyoutoagreeonasharedsecretacrossan\ninsecuremedium.\n2. Encryptionalgorithms, suchastheonesweʼlldiscuss\ninthischapter,whichallowpeopletoencryptwithout\nhavingtoagreeonasharedsecret.\n3. Signature algorithms, which weʼll discuss in a later\nchapter,whichallowyoutosignanypieceofinforma-\ntionusingyourprivatekeyinawaythatallowsanyone\nelsetoeasilyverifyitusingyourpublickey.\n9.2 Why not use public-key encryption for\neverything?\nAt face value, it seems that public-key encryption algorithms\nobsolete all our previous secret-key encryption algorithms.\nWe could just use public key encryption for everything,\navoiding all the added complexityof having to do key agree-\nmentforoursymmetricalgorithms. However,whenwelook\natpracticalcryptosystems,weseethattheyʼrealmostalways\nhybridcryptosystems: whilepublic-keyalgorithmsplayavery\nimportant role, the bulk of the encryption and authentica-\ntionworkisdonebysecret-keyalgorithms.\nByfarthemostimportantreasonforthisisperformance.\nComparedtoourspeedystreamciphers(nativeorotherwise),\npublic-key encryption mechanisms are extremely slow. RSA\nis limited to at most its key size, which for 2048-bit means\n256bytes. Underthesecircumstancesencryptiontakes0.29\nmegacycles,anddecryptiontakesawhopping11.12megacy-\ncles. [Dai]Toputthisintoperspective,symmetrickeyalgo-\nrithmsworkwithinanorderofmagnitudeof10orsocycles\nper byte in either direction. This means it will take a sym-\nmetrickeyalgorithmapproximately3kilocyclesinorderto"
  },
  {
    "input": "RSA",
    "output": "CHAPTER9. PUBLIC-KEYENCRYPTION 92\ndecrypt256bytes,whichisabout4000timesfasterthanthe\nasymmetricversion. Thestateoftheartinsecuresymmet-\nricciphersisevenfaster: AES-GCMwithhardwareacceler-\nationorSalsa20/ChaCha20onlyneedabout2to4cyclesper\nbyte,furtherwideningtheperformancegap.\nThereareafewotherproblemswithmostpracticalcryp-\ntosystems. For example, RSA canʼt encrypt anything larger\nthanitsmodulus,whichisgenerallylessthanorequal4096\nbits,farsmallerthanthelargestmessagesweʼdliketosend.\nStill,themostimportantreasonisthespeedargumentgiven\nabove.\n9.3 RSA\nAs we already mentioned, RSA is one of the first practical\npublic-keyencryptionschemes. Itremainsthemostcommon\nonetothisday.\nEncryptionanddecryption\nRSA encryption and decryption relies on modular arith-\nmetic. Youmaywanttoreviewthemodulararithmeticprimer\n(page186)beforecontinuing.\nThis section describes the simplified math problem be-\nhindRSA,commonlyreferredtoas“textbookRSA”.Byitself,\nthisdoesnʼtproduceasecureencryptionscheme. Weʼllsee\nasecureconstructioncalledOAEPthatbuildsontopofitin\nalatersection.\nInordertogenerateakey,youpicktwolargeprimenum-\nbers p and q. These numbers have to be picked at random,\nand in secret. You multiply them together to produce the\nmodulus N, which is public. Then, you pick an encryption\nexponent e,whichisalsopublic. Usually,thisvalueiseither\n3or65537. Becausethosenumbershaveasmallnumberof\n1ʼsintheirbinaryexpansion,youcancomputetheexponen-\ntiationmoreefficiently. Puttogether,(N,e)isthepublickey.\nAnyonecanusethepublickeytoencryptamessageM into\nCHAPTER9. PUBLIC-KEYENCRYPTION 93\naciphertextC:\nC ≡ Me (mod N)\nThenextproblemisdecryption. Itturns outthat thereis a\nvalued,thedecryptionexponent,thatcanturnCbackintoM.\nThatvalueisfairlyeasytocomputeassumingthatyouknow\npandq,whichwedo. Usingd,youcandecryptthemessage\nlikeso:\nM ≡ Cd (mod N)\nThe security of RSA relies on that decryption operation be-\ningimpossiblewithoutknowingthesecretexponentd,and\nthat the secret exponent d is very hard (practically impos-\nsible) to compute from the public key (N,e). Weʼll see ap-\nproachesforbreakingRSAinthenextsection.\nBreakingRSA\nLike many cryptosystems, RSA relies on the presumed dif-\nficultyofaparticularmathematicalproblem. ForRSA,this\nis the RSA problem, specifically: to find the plaintext mes-\nsage M, given a ciphertext C, and public key (N,e) in the\nequation:\nC ≡ Me (mod N)\nTheeasiestwayweknowhowtodothatistofactorN back\nintop·q. Givenpandq,theattackercanjustrepeatthepro-\ncessthatthelegitimateownerofthekeydoesduringkeygen-\nerationinordertocomputetheprivateexponentd.\nFortunately, we donʼt have an algorithm that can factor\nsuch large numbers in reasonable time. Unfortunately, we\nalsohavenʼtprovenitdoesnʼtexist. Evenmoreunfortunate\nis that there is a theoretical algorithm, called Shorʼs algo-\nrithm, that would be able to factor such a number in rea-\nsonabletimeonaquantumcomputer. Rightnow,quantum\nCHAPTER9. PUBLIC-KEYENCRYPTION 94\ncomputers are far from practical, but it does appear that\nif someone in the future manages to build one thatʼs suffi-\ncientlylarge,RSAbecomesineffective.\nInthissection,wehaveonlyconsideredaprivatekeyre-\ncoveryattackthatattacksthepurelyabstractmathematical\nRSAproblembyfactoringthemodulus. Inthenextsection,\nwe will see all sorts of realistic attacks on RSA that rely on\nflaws in the implementation, rather than the mathematical\nproblemstatedabove.\nImplementationpitfalls\nRight now, there are no known practical complete breaks\nagainst RSA. Thatʼs not to say that systems employing RSA\narenʼt routinely broken. Like with most broken cryptosys-\ntems, there are plenty of cases where sound components,\nimproperly applied, result in a useless system. For a more\ncompleteoverviewofthethingsthatcangowrongwithRSA\nimplementations,pleasereferto[Bon99]and[AV96]. Inthis\nbook,weʼlljusthighlightafewinterestingones.\nPKCSv1.5padding\nSalt\nSalt1 is a provisioning system written in Python. It has\none major flaw: it has a module named crypt. Instead of\nreusing existing complete cryptosystems, it implements its\nown,usingRSAandAESprovidedbyathirdpartypackage.\nFor a long time, Salt used a public exponent (e) of 1,\nwhich meant the encryption phase didnʼt actually do any-\nthing: Pe ≡ P1 ≡ P (mod N). This meant that the result-\ningciphertextwasinfactjusttheplaintext. Whilethisissue\nhasnowbeenfixed,thisonlygoestoshowthatyouprobably\n1So,thereʼsSalttheprovisioningsystem,saltsthethingsusedinbro-\nken password stores, NaCl pronounced “salt” the cryptography library,\nandNaClwhichrunsnativecodeinsomebrowsers,andprobablyabunch\nIʼmforgetting.Canwestopnamingthingsafterit?\nCHAPTER9. PUBLIC-KEYENCRYPTION 95\nshouldnʼtimplementyourowncryptography. Saltcurrently\nalso supports SSH as a transport, but the aforementioned\nDIYRSA/AESsystemremains, andis at time of writing still\ntherecommendedandthedefaulttransport.\nOAEP\nOAEP,shortforoptimalasymmetricencryptionpadding,is\nthestateoftheartinRSApadding. ItwasintroducedbyMi-\nhirBellareandPhillipRogawayin1995. [BR95]. Itsstructure\nlookslikethis:\nThethingthateventuallygetsencryptedisX∥Y, which\nis n bits long, where n is the number of bits of N, the RSA\nmodulus. IttakesarandomblockRthatʼskbitslong,where\nkisaconstantspecifiedbythestandard. Themessageisfirst\npaddedwithzeroestoben−k bitslong. Ifyoulookatthe\nabove“ladder”,everythingonthelefthalfisn−kbitslong,\nandeverythingontherighthalfisk bitslong. Therandom\nblockRandzero-paddedmessageM∥000...arecombined\nusing two“trapdoor” functions, G andH. A trapdoorfunc-\ntion is a function thatʼs very easy to compute in one direc-\ntionandveryhardtoreverse. Inpractice,thesearecrypto-\ngraphichashfunctions;weʼllseemoreaboutthoselater.\nAsyoucantellfromthediagram,Gtakeskbitsandturns\ntheminton−k bits,andH istheotherwayaround,taking\nn−kbitsandturningthemintokbits.\nTheresultingblocksX andY areconcatenated,andthe\nresultisencryptedusingthestandardRSAencryptionprim-\nitive,toproducetheciphertext."
  },
  {
    "input": "Remaining problem: unauthenticated encryption",
    "output": "CHAPTER9. PUBLIC-KEYENCRYPTION 96\nTo see how decryption works, we reverse all the steps.\nTherecipientgetsX∥Y whendecryptingthemessage. They\nknowk,sinceitisafixedparameteroftheprotocol,sothey\ncansplitupX∥Y intoX (thefirstn−kbits)andY (thefinal\nkbits).\nIn the previous diagram, the directions are for padding\nbeingapplied. Reversethearrowsonthesideoftheladder,\nandyoucanseehowtorevertthepadding:\nTODO:reversearrows\nWewanttogettoM,whichisinM∥000.... Thereʼsonly\nonewaytocomputethat,whichis:\nM∥000... = X ⊕G(R)\nComputingG(R)isalittleharder:\nG(R) = G(H(X)⊕Y)\nAsyoucansee,atleastforsomedefinitionsofthefunctions\nH and G, we need all of X and all of Y (and hence the en-\ntireencryptedmessage)inordertolearnanythingaboutM.\nTherearemanyfunctionsthatwouldbeagoodchoiceforH\nandG; basedoncryptographichashfunctions, whichweʼll\ndiscussinmoredetaillaterinthebook.\n9.4 Elliptic curve cryptography\nTODO:This\n9.5 Remaining problem: unauthenticated\nencryption\nMost public-key encryption schemes can only encrypt small\nchunksofdataatatime,muchsmallerthanthemessageswe\nwanttobeabletosend. Theyarealsogenerallyquiteslow,\nmuchslowerthantheirsymmetriccounterparts. Therefore\nCHAPTER9. PUBLIC-KEYENCRYPTION 97\npublic-keycryptosystemsarealmostalwaysusedinconjunc-\ntionwithsecret-keycryptosystems.\nWhenwediscussedstreamciphers,oneoftheremaining\nissuesthatwewerefacingwasthatwestillhadtoexchange\nsecretkeyswithalargenumberofpeople. Withpublic-key\ncryptosystems such as public encryption and key exchange\nprotocols, weʼve now seen two ways that we can solve that\nproblem. That means that we can now communicate with\nanyone, using only public information, completely secure\nfromeavesdroppers.\nSofarweʼveonlybeentalkingaboutencryptionwithout\nany form of authentication. That means that while we can\nencrypt and decrypt messages, we cannot verify that the\nmessageiswhatthesenderactuallysent.\nWhileunauthenticatedencryptionmayprovidesecrecy,\nwe have already seen that without authentication an active\nattackercangenerallymodifyvalidencryptedmessagessuc-\ncessfully, despite the fact that they donʼt necessarily know\nthecorrespondingplaintext. Acceptingthesemessagescan\noften lead to secret information being leaked, meaning we\ndonʼt even get secrecy. The CBC padding attacks weʼve al-\nreadydiscussedillustratethis.\nAs a result it has become evident that we need ways to\nauthenticateaswellasencryptoursecretcommunications.\nThis is done by adding extra information to the message\nthatonlythesendercouldhavecomputed. Justlikeencryp-\ntion, authenticationcomesinbothprivate-key(symmetric)\nand public-key (asymmetric) forms. Symmetric authenti-\ncation schemes are typically called message authentication\ncodes,whilethepublic-keyequivalentistypicallycalledasig-\nnature.\nFirst, we will introduce a new cryptographic primitive:\nhash functions. These can be used to produce both signa-\nture schemes as well as message authentication schemes.\nUnfortunately, they are also very often abused to produce\nentirelyinsecuresystems."
  },
  {
    "input": "Description",
    "output": "10\nHash functions\n10.1 Description\nHash functions are functions that take an input of indeter-\nminatelengthandproduceafixed-lengthvalue,alsoknown\nasa“digest”.\nSimplehashfunctionshavemanyapplications. Hashta-\nbles, a common data structure, rely on them. These sim-\nplehashfunctionsreallyonlyguaranteeonething: fortwo\nidenticalinputs,theyʼllproduceanidenticaloutput. Impor-\ntantly,thereʼsnoguaranteethattwoidenticaloutputsimply\nthat the inputs were the same. That would be impossible:\nthereʼs only a finite amount of digests, since theyʼre fixed\nsize, but thereʼs an infinite amount of inputs. A good hash\nfunctionisalsoquicktocompute.\nSince this is a book on cryptography, weʼre particularly\ninterested in cryptographic hash functions. Cryptographic\nhashfunctionscanbeusedtobuildsecure(symmetric)mes-\nsage authentication algorithms, (asymmetric) signature al-\ngorithms, and various other tools such as random number\ngenerators. Weʼll see some of these systems in detail in fu-\nturechapters.\n98\nCHAPTER10. HASHFUNCTIONS 99\nCryptographichashfunctionshavemuchstrongerprop-\nerties than regular hash functions, such as one that you\nmight find in a hash table. For a cryptographic hash func-\ntion,wewantittobeimpossiblyhardto:\n1. modifyamessagewithoutchangingthehash.\n2. generateamessagethathasagivenhash.\n3. findtwodifferentmessageswiththesamehash.\nThefirstpropertyimpliesthatcryptographichashfunc-\ntions will exhibit something known as the “avalanche ef-\nfect”. Changing even a single bit in the input will produce\nanavalancheofchangesthroughtheentiredigest: eachbit\nof the digest will have approximately 50% chance of flip-\nping. Thatdoesnʼtmeanthateverychangewillcauseapprox-\nimately half of the bits to flip, but the cryptographic hash\nfunctiondoesguaranteethattheoddsofthathappeningare\nextremely large. More importantly it is impossibly hard to\nfindsuchcollisionsornear-collisions.\nThe second property, which states that it should be dif-\nficult to find a message m that has a given hash value h, is\ncalledpre-imageresistance. Thismakesahashfunctionaone-\nway function: itʼs very easy to compute a hash for a given\nmessage,butitʼsveryhardtocomputeamessageforagiven\nhash.\nThethirdpropertytalksaboutfindingmessageswiththe\nsame hash value, comes in two flavors. In the first one,\nthereʼs a given message m, and it should be difficult to find\n′\nanothermessagem withthesamehashvalue: thatʼscalled\nsecondpre-imageresistance. Thesecondoneisstronger,stat-\n′\ningthatitshouldbehardtofindanytwomessagesm,m that\nhave the same hash value. This is called collision resistance.\nBecausecollisionresistanceisastrongerformofsecondpre-\nimage resistance, theyʼre sometimes also called weak and\nstrongcollisionresistance.\nTheseconceptsareoftennamedfromthepointofview\nofanattack,ratherthantheresistancetoanattack. Forex-"
  },
  {
    "input": "MD5",
    "output": "CHAPTER10. HASHFUNCTIONS 100\nample,youʼlloftenhearaboutacollisionattack,whichisan\nattackthatattemptstogenerateahashcollision,orasecond\npre-imageattack,whichattemptstofindasecondpre-image\nthathashestothesamevalueasagivenpre-image,etcetera.\nTODO:Maybelinktohttp://www.cs.ucdavis.edu/\n~rogaway/papers/relates.pdfforfurtherreading\n10.2 MD5\nMD5 is a hash function designed by Ronald Rivest in 1991\nas an extension of MD4. This hash function outputs 128-\nbit digests. Over the course of the years, the cryptographic\ncommunityhasrepeatedlyuncoveredMD5ʼsweaknesses. In\n1993, Bert den Boer and Antoon Bosselaers published a pa-\nperdemonstrating“pseudo-collisions”forthecompression\nfunctionofMD5. [dBB93]Dobbertinexpandeduponthisre-\nsearch and was able to produce collisions for the compres-\nsionfunction. In2004,basedonDobbertinʼswork,Xiaoyun\nWang,DengguoFeng,XuejiaLaiandHongboYushowedthat\nMD5 is vulnerable to real collision attacks. [LWdW05] The\nlaststrawcamewhenXiaoyunWangetal. managedtogen-\neratecollidingX.509certificatesandthenpresentedadistin-\nguishingattackonHMAC-MD5. [LWdW05][WYW+09]\nNowadays, it is not recommended to use MD5 for gen-\nerating digital signatures, but it is important to note that\nHMAC-MD5isstillasecureformofmessageauthentication;\nhowever,itprobablyshouldnʼtbeimplementedinnewcryp-\ntosystems.\nFive steps are required to compute an MD5 message di-\ngest:\n1. Add padding. First, 1 bit is appended to the message\nandthen0bitsareaddedtotheenduntilthelengthis\n448 (mod 512).\n2. Filluptheremaining64bitswiththethelengthofthe\noriginal message modulo 264, so that the entire mes-\nsageisamultipleof512bits."
  },
  {
    "input": "SHA-1",
    "output": "CHAPTER10. HASHFUNCTIONS 101\n3. Initialize the state as four 32-bit words, A, B, C and\nD. These are initialized with constants defined in the\nspec.\n4. Processtheinputin512bitblocks;foreachblock,run\nfour“rounds”consistingof16similaroperationseach.\nThe operations all consist of shifts, modular addition,\nand a specific nonlinear function, different for each\nround.\nOnce done, A∥B∥C∥D is the output of the hash. This\npadding style combined with the concatenation at the end\nis what makes MD5 vulnerable to length extension attacks;\nmoreonthatlater.\nIn Python one can use the hashlib module to create an\nMD5digestasfollows:\nimport hashlib\nhashlib.md5(b”crypto101”).hexdigest()\n10.3 SHA-1\nSHA-1 is another hash function from the MD4 family de-\nsignedbytheNSA,whichproducesa160-bitdigest. Justlike\nMD5,SHA-1isnolongerconsideredsecurefordigitalsigna-\ntures. Many software companies and browsers, including\nGoogle Chrome, have started to retire support of the signa-\nturealgorithmofSHA-1. OnFebruary23, 2017researchers\nfromCWIAmsterdamandGooglemanagedtoproduceacol-\nlisiononthefullSHA-1function. [SBK+]Inthepastmethods\ntocausecollisionsonreducedversionsofSHA-1havebeen\npublished,includingonebyXiaoyunWang. “TheSHAppen-\ning”demonstratedfreestartcollisionsforSHA-1. Afreestart\ncollision allows one to pick the initial value known as the\ninitializationvector atthestartofthecompressionfunction.\n[SKP15]\nOnce again the hashlib Python module can be used to\ngenerateaSHA-1hash:"
  },
  {
    "input": "SHA-2",
    "output": "CHAPTER10. HASHFUNCTIONS 102\nimport hashlib\nhashlib.sha1(b”crypto101”).hexdigest()\n10.4 SHA-2\nSHA-2isafamilyofhashfunctionsincludingSHA-224,SHA-\n256, SHA-384, SHA-512, SHA-512/224 and SHA-512/256 and\ntheirdigestsizes224,256,384,512,224and256respectively.\nThese hash functions are based on the Merkle–Damgård\nconstructionandcanbeusedfordigitalsignatures,message\nauthenticationandrandomnumbergenerators. SHA-2not\nonlyperformsbetter thanSHA-1, italso providesbetter se-\ncurity,becauseofitsincreaseincollisionresistance.\nSHA-224 and SHA-256 were designed for 32-bit proces-\nsorregisters,whileSHA-384andSHA-512for64-bitregisters.\nThe32-bitregistervariantswillthereforerunfasterona32-\nbitCPUandthe64-bitvariantswillperformbetterona64-bit\nCPU. SHA-512/224 and SHA-512/256 are truncated versions\nofSHA-512allowinguseof64-bitwordswithanoutputsize\nequivalenttothe32-bitregistervariants(i.e.,224and256di-\ngestsizesandbetterperformanceona64-bitCPU).\nThefollowingisatablethatgivesagoodoverviewofthe\nSHA-2family:\nHash func- Message Block Word Digest\ntion size size size size\nSHA-224 <264 512 32 224\nSHA-256 <264 512 32 256\nSHA-384 <2128 1024 64 384\nSHA-512 <2128 1024 64 512\nSHA- <2128 1024 64 224\n512/224\nSHA- <2128 1024 64 256\n512/256\nYou can hash an empty string with the hashlib module"
  },
  {
    "input": "Keccak and SHA-3",
    "output": "CHAPTER10. HASHFUNCTIONS 103\nandcomparedigestsizesasfollows:\n>>> import hashlib\n>>> len(hashlib.sha224(b””).hexdigest())\n56\n>>> len(hashlib.sha256(b””).hexdigest())\n64\n>>> len(hashlib.sha384(b””).hexdigest())\n96\n>>> len(hashlib.sha512(b””).hexdigest())\n128\nAttacksonSHA-2\nSeveral (pseudo-)collision and preimage attacks have been\ndemonstratedusingSHA-256andSHA-512withlessrounds.\nItisimportanttonotethatbyremovingacertainamountof\nrounds one canʼt attack the entire algorithm. For instance,\nSomitra Kumar Sanadhya and Palash Sarkar were able to\ncausecollisionswithSHA-256using24of64rounds(remov-\ningthelast40rounds). [SS08]\n10.5 Keccak and SHA-3\nKeccak is a family of sponge functions designed by Guido\nBertoni, Joan Daemen, Gilles Van Assche and Michaël\nPeeters,whichwonNISTʼsSecureHashAlgorithmCompeti-\ntionin2012. Keccakhassincebeenstandardizedinformof\ntheSHA3-224,SHA3-256,SHA3-384andSHA3-512hashfunc-\ntions.\nAlthoughSHA-3soundslikeitmightcomefromthesame\nfamilyasSHA-2,thetwoaredesignedverydifferently. SHA-\n3isveryefficientinhardware[Hua],butisrelativelyslowin\nsoftware in comparison to SHA-2. [ECR] Later in the book,\nyouwillfindthesecurityaspectsofSHA-3,suchasprevent-\ninglengthextensionattacks.\nTheSHA-3hashfunctionswereintroducedinPythonver-\nsion3.6andcanbeusedasfollows:"
  },
  {
    "input": "Password storage",
    "output": "CHAPTER10. HASHFUNCTIONS 104\nimport hashlib\nhashlib.sha3_224(b”crypto101”).hexdigest()\nhashlib.sha3_256(b”crypto101”).hexdigest()\nhashlib.sha3_384(b”crypto101”).hexdigest()\nhashlib.sha3_512(b”crypto101”).hexdigest()\n10.6 Password storage\nOneofthemostcommonusecasesforcryptographichash\nfunctions, and unfortunately one which is also completely\nandutterlybroken,ispasswordstorage.\nSupposeyouhaveaservicewherepeopleloginusinga\nusernameandapassword. Youʼdhavetostorethepassword\nsomewhere,sothatnexttimetheuserlogsin,youcanverify\nthepasswordtheysupplied.\nStoringthepassworddirectlyhasseveralissues. Besides\nan obvious timing attack in the string comparison, if the\npassword database were to be compromised, an attacker\nwouldbeabletojustgoaheadandreadallofthepasswords.\nSincemanyusersre-usepasswords,thatʼsacatastrophicfail-\nure. Mostuserdatabasesalsocontaintheire-mailaddresses,\nsoitwouldbeveryeasytohi-jackabunchofyouruserʼsac-\ncountsthatareunrelatedtothisservice.\nHashfunctionstotherescue\nAn obvious approach would be to hash the password using\na cryptographically secure hash function. Since the hash\nfunction is easy to compute, whenever the user provides\ntheirpassword,youcanjustcomputethehashvalueofthat,\nandcomparethattowhatyoustoredinthedatabase.\nIfanattackerweretostealtheuserdatabase,theycould\nonly see the hash values, and not the actual passwords.\nSince the hash function is impossible for an attacker to in-\nverse,theywouldnʼtbeabletoturnthosebackintotheorig-\ninalpasswords. Orsopeoplethought.\nCHAPTER10. HASHFUNCTIONS 105\nRainbowtables\nIt turns out that this reasoning is flawed. The amount of\npasswords that people actually use is very limited. Even\nwith very good password practices, theyʼre strings some-\nwhere between 10 and 20 characters, consisting mostly of\nthingsthatyoucantypeoncommonkeyboards. Inpractice\nthough,peopleuseevenworsepasswords: thingsbasedon\nrealwords(password,swordfish),consistingoffewsym-\nbolsandfewsymboltypes(1234),orwithpredictablemod-\nificationsoftheabove(passw0rd).\nTomakemattersworse,hashfunctionsarethesameev-\nerywhere. Ifauserre-usesthesamepasswordontwosites,\nandbothofthemhashthepasswordusingMD5,thevalues\nin the password database will be the same. It doesnʼt even\nhave to be per-user: many passwords are extremely com-\nmon(password),somanyuserswillusethesameone.\nKeep in mind that a hash function is easy to evaluate.\nWhat if we simply try many of those passwords, creating\nhugetablesmappingpasswordstotheirhashvalues?\nThatʼsexactlywhatsomepeopledid,andthetableswere\njustaseffectiveasyouʼdexpectthemtobe,completelybreak-\ning any vulnerable password store. Such tables are called\nrainbowtables. Thisisbecausetheyʼreessentiallysortedlists\nofhashfunctionoutputs. Thoseoutputswillbemoreorless\nrandomly distributed. When written down in hexadecimal\nformats,thisremindedsomepeopleofcolorspecifications\nlike the ones used in HTML, e.g. #52f211, which is lime\ngreen.\nSalts\nThe reasonrainbow tableswere so incrediblyeffective was\nbecause everyone was using one of a handful of hash func-\ntions. Thesamepasswordwouldresultinthesamehashev-\nerywhere.\nThisproblemwasgenerallysolvedbyusingsalts. Bymix-\nCHAPTER10. HASHFUNCTIONS 106\ning(appendingorprepending1)thepasswordwithsomeran-\ndomvaluebeforehashingit,youcouldproducecompletely\ndifferent hash values out of the same hash function. It ef-\nfectivelyturnsahashfunctionintoawholefamilyofrelated\nhashfunctions, withvirtuallyidenticalsecurityandperfor-\nmance properties, except with completely different output\nvalues.\nThesalt valueisstorednexttothepasswordhashinthe\ndatabase. Whentheuserauthenticatesusingthepassword,\nyou just combine the salt with the password, hash it, and\ncompareitagainstthestoredhash.\nIf you pick a sufficiently large (say, 160 bits/32 bytes),\ncryptographically random salt, youʼve completely defeated\nahead-of-time attacks like rainbow tables. In order to suc-\ncessfully mount a rainbow table attack, an attacker would\nhave to have a separate table for each of those salt values.\nSince even a single table was usually quite large, storing a\nlarge amount of them would be impossible. Even if an at-\ntacker would be able to store all that data, theyʼd still have\ntocomputeitfirst. Computingasingletabletakesadecent\namount of time; computing 2160 different tables is impossi-\nble.\nMany systems used a single salt for all users. While\nthatpreventedanahead-of-timerainbowtableattack,itstill\nallowed attackers to attack all passwords simultaneously,\nonce they knew the value of the salt. An attacker would\nsimply compute a single rainbow table for that salt, and\ncompare the results with the hashed passwords from the\ndatabase. Whilethiswouldhavebeenpreventedbyusinga\ndifferentsaltforeachuser,systemsthatuseacryptographic\nhashwithaper-usersalt arestillconsideredfundamentally\nbrokentoday;theyarejustharder tocrack,butnotatallse-\ncure.\n1WhileyoucouldalsodothiswithXOR,itʼsneedlesslymoreerror-\nprone,anddoesnʼtprovidebetterresults. Unlessyouzero-padboththe\npasswordandthesalt,youmightbetruncatingeitherone.\nCHAPTER10. HASHFUNCTIONS 107\nPerhaps the biggest problem with salts is that many\nprogrammers were suddenly convinced they were doing\nthe right thing. Theyʼd heard of broken password storage\nschemes,andtheyknewwhattodoinstead,sotheyignored\nall talk about how a password database could be compro-\nmised. They werenʼt the ones storing passwords in plain-\ntext, or forgetting to salt their hashes, or re-using salts for\ndifferent users. It was all of those other people that didnʼt\nknow what they were doing that had those problems. Un-\nfortunately,thatʼsnottrue. Perhapsthatʼswhybrokenpass-\nwordstorageschemesarestillthenorm.\nModernattacksonweakpasswordsystems\nToamodernattack,saltsquitesimplydonʼthelp. Modernat-\ntackstakeadvantageofthefactthatthehashfunctionbeing\nusediseasytocompute. Usingfasterhardware,inparticular\nvideocards,wecansimplyenumerateallofthepasswords,\nregardlessofsalt.\nTODO: more concrete performance numbers about\nGPUs\nSalts may make precomputed attacks impossible, but\nthey do very little against an attacker that actually knows\nthesalt. Oneapproachyoumightbeinclinedtotakeistoat-\ntempt to hide the salt from the attacker. This typically isnʼt\nveryuseful:ifanattackercanmanagetoaccessthedatabase,\nattemptstohidethesalt areunlikelytobesuccessful. Like\nmanyineffectivehome-growncryptoschemes,thisonlypro-\ntects against an incredibly improbable event. It would be\nmuchmoreusefultojustuseagoodpasswordstoretobegin\nwith,thantryingtofixabrokenone.\nSowheredowegofromhere?\nInordertoprotectpasswords,youneeda(low-entropy)key\nderivation function (page 137). Weʼll discuss them in more\ndetailinafuturechapter."
  },
  {
    "input": "Length extension attacks",
    "output": "CHAPTER10. HASHFUNCTIONS 108\nWhile key derivation functions can be built using cryp-\ntographic hash functions, they have very different perfor-\nmanceproperties. Thisisacommonpattern: whilecrypto-\ngraphichashfunctionsareincrediblyimportantprimitives\nfor building secure tools (such as key derivation functions\nor message authentication algorithms), they are routinely\nabused as those tools themselves. In the rest of this chap-\nter, we will see other examples of how cryptographic hash\nfunctionscanbeusedandabused.\n10.7 Length extension attacks\nIn many hash functions, particularly the previous genera-\ntions,theinternalstatekeptbythehashfunctionisusedas\nthe digest value. In some poorly engineered systems, that\ncausesacriticalflaw: ifanattackerknowsH(M ), itʼsvery\n1\nsimple to compute H(M ∥M ), without actually knowing\n1 2\nthevalueofM . SinceyouknowH(M ),youknowthestate\n1 1\nofthehashfunctionafteritʼshashedM . Youcanusethatto\n1\nreconstructthehashfunction,andaskittohashmorebytes.\nSetting the hash functionʼs internal state to a known state\nyougotfromsomewhereelse(suchasH(M ))iscalledfixa-\n1\ntion.\nFor most real-world hash functions, itʼs a little bit more\ncomplicatedthanthat. Theycommonlyhaveapaddingstep\nthatanattackerneedstorecreate. MD5andSHA-1havethe\nsamepaddingstep. Itʼsfairlysimple,soweʼllgothroughit:\n1. Adda1bittothemessage.\n2. Addzerobitsuntilthelengthis448 (mod 512).\n3. Take the total length of the message, before padding,\nandadditasa64-bitinteger.\nFortheattackertobeabletocomputeH(M ∥M )given\n1 2\nH(M ),theattackerneedstofakethatpadding,aswell. The\n1\nattackerwillactuallycomputeH(M ∥G∥M ),whereGisthe\n1 2\nCHAPTER10. HASHFUNCTIONS 109\nglue padding, called that way because it glues the two mes-\nsages together. The hard part is knowing the length of the\nmessageM .\n1\nIn many systems, the attacker can actually make fairly\neducatedguessesaboutthelengthofM ,though. Asanex-\n1\nample, considerthecommon(broken)exampleofasecret-\nprefix authentication code. People send messages M , au-\ni\nthenticatedusingA = H(S∥M ),whereSisasharedsecret.\ni i\nWeʼllsee(andbreak)thisMACalgorithminafuturesection.\nItʼsveryeasyfortherecipienttocomputethesamefunc-\ntion,andverifythecodeiscorrect. Anychangetothemes-\nsageM willchangethevalueofA drastically,thankstothe\ni i\navalancheeffect. Unfortunately,itʼsquiteeasyforattackers\nto forge messages. Since the MAC is usually sent together\nwiththeoriginalmessage,theattackerknowsthelengthof\nthe original message. Then, the attacker only has to guess\natthelengthofthesecret,whichisoftenfixedaspartofthe\nprotocol, and, even if it isnʼt, the attacker will probably get\nin a hundred tries or less. Contrast this with guessing the\nsecretitself,whichisimpossibleforanyreasonablychosen\nsecret.\nThere are secure authentication codes that can be de-\nsigned using cryptographic hash functions: this one just\nisnʼtit. Weʼllseebetteronesinalaterchapter.\nSome hash functions, particularly newer ones such as\nSHA-3 competition finalists, do not exhibit this property.\nThe digest is computed from the internal state, instead of\nusingtheinternalstatedirectly.\nThis makes the SHA-3-era hash functions not only a bit\nmore fool-proof, but also enables them to produce simpler\nschemes for message authentication. (Weʼll elaborate on\nthoseinalaterchapter.) Whilelengthextensionattacksonly\naffected systems where cryptographic hash functions were\nbeingabusedinthefirstplace,thereʼssomethingtobesaid\nforpreventingthemanyway. Peoplewillendupmakingmis-\ntakes,wemightaswellmitigatewherewecan.\nTODO:saywhythispreventsmeetinthemiddleattacks?"
  },
  {
    "input": "Remaining issues",
    "output": "CHAPTER10. HASHFUNCTIONS 110\n10.8 Hash trees\nHashtreesaretrees2whereeachnodeisidentifiedbyahash\nvalue, consisting of its contents and the hash value of its\nancestor. The root node, not having an ancestor, simply\nhashesitsowncontents.\nThis definition is very wide: practical hash trees are\noften more restricted. They might be binary trees3, or\nperhaps only leaf nodes carry data of their own, and par-\nent nodes only carry derivative data. Particularly these re-\nstrictedkindsareoftencalledMerkletrees.\nSystemsliketheseortheirvariantsareusedbymanysys-\ntems, particularly distributed systems. Examples include\ndistributed version control systems such as Git, digital cur-\nrencies such as Bitcoin, distributed peer-to-peer networks\nlikeBittorrent,anddistributeddatabasessuchasCassandra.\n10.9 Remaining issues\nWeʼvealreadyillustratedthathashfunctions,bythemselves,\ncanʼt authenticate messages, because anyone can compute\nthem. Also, weʼve illustrated that hash functions canʼt be\nused to secure passwords. Weʼll tackle both of these prob-\nlemsinthefollowingchapters.\nWhile this chapter has focused heavily on what hash\nfunctions can’t do, it canʼt be stressed enough that they are\nstill incredibly important cryptographic primitives. They\njust happen to be commonly abused cryptographic primi-\ntives.\n2Directedgraphs,whereeachnodeexcepttheroothasexactlyone\nancestor.\n3Eachnon-leafnodehasnomorethantwochildren"
  },
  {
    "input": "Description",
    "output": "11\nMessage authentication\ncodes\n11.1 Description\nAMACisasmallbitofinformationthatcanbeusedtocheck\ntheauthenticityandtheintegrityofamessage. Thesecodes\nare often called “tags”. A MAC algorithm takes a message\nofarbitrarylengthandasecretkeyoffixedlength,andpro-\nducesthetag. TheMACalgorithmalsocomeswithaverifi-\ncationalgorithmthattakesamessage,thekeyandatag,and\ntellsyouifthetagwasvalidornot. (Itisnotalwayssufficient\ntojustrecomputeatagandcheckiftheyarethesame;many\nsecure MAC algorithms are randomized, and will produce\ndifferenttagseverytimeyouapplythem.)\nNote that we say “message” here instead of “plaintext”\nor “ciphertext”. This ambiguity is intentional. In this book\nweʼremostlyinterestedinMACsasawaytoachieveauthenti-\ncatedencryption,sothemessagewillalwaysbeaciphertext.\nThat said, thereʼs nothing wrong with a MAC being applied\nto a plaintext message. In fact, we will be seeing examples\n111\nCHAPTER11. MESSAGEAUTHENTICATIONCODES 112\nof secure authenticated encryption schemes that explicitly\nallow for authenticated (but not encrypted) information to\nbesentalongwiththeauthenticatedciphertext.\nOften,whenyoujustwanttotalkabouttheauthenticity\nand integrity of a particular message, it may be more prac-\nticaltouseasignaturealgorithm,whichweʼlltalkaboutina\nlaterchapter. Fornow,allyouneedtoknowisthattheterm\n“signature”isnormallyreservedforasymmetricalgorithms,\nwhereasthischapterdealswithsymmetricalgorithms.\nSecureMACs\nWe havenʼt quite defined yet exactly which properties we\nwantfromasecureMAC.\nWe will be defending against an active attacker. The\nattacker will be performing a chosen message attack. That\nmeans that an attacker will ask us the tag for any number\nofmessagesm ,andweʼllanswertruthfullywiththeappro-\ni\npriatetagt .\ni\nAn attacker will then attempt to produce an existential\nforgery, a fancy way of saying that they will produce some\nnewvalidcombinationof(m,t). Theobvioustargetforthe\n′\nattacker is the ability to produce valid tags t for new mes-\n′\nsages m of their choosing. We will also consider the MAC\ninsecure if an attacker can compute a new, different valid\n′\ntagt foramessagem thatwepreviouslygavethemavalid\ni\ntagfor.\nWhydoesaMACtakeasecretkey?\nIf youʼve had to deal with verifying the integrity of a mes-\nsage before, you may have used checksums (like CRC32 or\nAdler32)orevencryptographichashes(liketheSHAfamily)\ninordertocomputeachecksumforthemessage(depending\non the algorithm and who youʼre talking to, they may have\ncalledit“hash”or“digest”,too).\nLetʼssaythatyouʼredistributingasoftwarepackage. You\nhave some tarballs with source code in them, and maybe"
  },
  {
    "input": "Combining MAC and message",
    "output": "CHAPTER11. MESSAGEAUTHENTICATIONCODES 113\nsomebinarypackagesforpopularoperatingsystems. Then\nyouputsome(cryptographicallysecure!) hashesrightnext\ntothem,sothatanyonewhodownloadsthemcanverifythe\nhashes and be confident that they downloaded what they\nthinktheydownloaded.\nOf course, this scheme is actually totally broken. Com-\nputing those hashes is something everyone can do. Youʼre\neven relying on that fact for your user to be able to verify\ntheirdownload. Thatalsomeansthatanattackerthatmod-\nifiedanyofthedownloadscanjustcomputethehashagain\nforthemodifieddownloadandsavethatvalue. Auserdown-\nloading the modified file will compute its hash and com-\npare it against the modified hash, and conclude that the\ndownload worked. The scheme provided no help whatso-\never against an attacker modifying the download, either as\nstored,orintransit.\nInordertodothissecurely,youwouldeitherapplyasig-\nnature algorithm to the binaries directly, or by signing the\ndigests,aslongasthehashfunctionusedtoproducethedi-\ngest is secure against second-preimage attacks. The impor-\ntantdifferenceisthatproducingasignature(usingeithera\npre-sharedkeywithyourusers, or, preferably, apublic-key\nsignature algorithm) is not something that an attacker can\ndo. Onlysomeonewhohasthesecretkeyscandothat.\n11.2 Combining MAC and message\nAs weʼve mentioned before, unauthenticated encryption is\nbad. ThatʼswhyweintroducedMACs. Ofcourse,foraMAC\ntobeuseful,ithastomakeittotherecipient. Sinceweʼreex-\nplicitly talking about authenticating encryption, now, weʼll\nstopusingtheword“message”andinsteadusethelessam-\nbiguous“plaintext”and“ciphertext”.\nThere are three common ways to combine a ciphertext\nwithaMAC.\n1. Authenticate and encrypt. You authenticate and en-\nCHAPTER11. MESSAGEAUTHENTICATIONCODES 114\ncrypt the plaintext separately. This is how SSH does\nit. Insymbols: C = E(K ,P),t = MAC(K ,P),and\nC M\nyousendbothciphertextC andtagt.\n2. Authenticate, then encrypt. You authenticate the\nplaintext and then encrypt the combination of the\nplaintext and the authentication tag. This is how TLS\nusually does it. In symbols: t = MAC(K ,P), C =\nM\nE(K ,P∥t), and you only send C. (You donʼt need to\nC\nsendt,becauseitʼsalreadyanencryptedpartofC.)\n3. Encrypt,thenauthenticate. Youencrypttheplaintext,\ncomputetheMACofthatciphertext. ThisishowIPSec\ndoesit. Insymbols:C = E(K ,P),t = MAC(K ,C),\nC M\nandyousendbothC andt.\nAll of these options were studied and compared exten-\nsively. [Kra01][BN07]Wenowknowthatoutofallofthese,\nencrypt-then-authenticate is unequivocally the best option.\nItʼs so emphatically the best option that Moxie Marlinspike,\nawell-respectedinformationsecurityresearcher,hasaprin-\nciple called “The Cryptographic Doom Principle” for any\nsystem that does not follow this pattern [Mar11]. Moxie\nclaims that any system that does anything before checking\nthe MAC is doomed. Both authenticate-and-encrypt and\nauthenticate-then-encryptrequireyoutodecryptsomething\nbeforeyoucanverifytheauthentication.\nAuthenticate-then-encrypt\nAuthenticate-then-encryptisapoorchoice, butitʼsasubtle\npoorchoice. Itcanstillbeprovablysecure, butonlyunder\ncertainconditions. [Kra01]\nAt first sight, this scheme appears to work. Sure, you\nhave to decrypt before you can do anything, but to many\ncryptographers,includingthedesignersofTLS,thisdidnot\nappeartoposeaproblem.\nIn fact, prior to rigorous comparative study of differ-\nent composition mechanisms, many preferred this setup."
  },
  {
    "input": "A naive attempt with hash functions",
    "output": "CHAPTER11. MESSAGEAUTHENTICATIONCODES 115\nIn a critique of IPSec, Schneier and Ferguson, two vet-\neran cryptographers, considered IPSecʼs use of encrypt-\nthen-authenticatewasaflaw,preferringTLSʼsauthenticate-\nthen-encrypt. [FS99] While they may have had a plausible\n(albeit mostly heuristic) argument for the time, this criti-\ncism is completely superseded by the provable security of\nencrypt-then-authenticateschemes. [Kra01][BN07]\nTODO:ExplainVaudenayCBCattack[Vau]\nAuthenticate-and-encrypt\nAuthenticate-and-encrypt has some serious problems.\nSince the tag authenticates the plaintext and that tag is\npart of the transmitted message, an attacker will be able\nto recognize two plaintext messages are the same because\ntheirtagswillalsobethesame. Thisessentiallyleadstothe\nsame problem we saw with ECB mode, where an attacker\ncanidentifyidenticalblocks. Thatʼsaseriousproblem,even\niftheycanʼtdecryptthoseblocks.\nTODO:ExplainhowthisworksinSSH(seeMoxieʼsDoom\narticle)\n11.3 A naive attempt with hash functions\nMany ways of constructing MACs involve hash functions.\nPerhaps one of the simplest ways you could imagine doing\nthatistojustprefixthemessagewiththesecretkeyandhash\nthewholething:\nt = H(k∥m)\nThis scheme is most commonly called “Prefix-MAC”, be-\ncause it is a MAC algorithm that works by using the secret\nkeyasaprefix.\nThe cryptographically secure hash function H guaran-\nteesafewthingsthatareimportanttoushere:\nCHAPTER11. MESSAGEAUTHENTICATIONCODES 116\n• The tag t will be easy to compute; the hash function\nH itself is typically very fast. In many cases we can\ncompute the common key part ahead of time, so we\nonlyhavetohashthemessageitself.\n• Given any number of tags, there is no way for an at-\ntackerto“invert”thehashfunctiontorecoverk,which\nwouldallowthemtoforgearbitrarymessages.\n• Given any number of tags, there is no way for an at-\ntacker to “rewind” the hash function to recover H(k),\nwhich may allow them to forge almost arbitrary mes-\nsages.\nOne small caveat: weʼre assuming that the secret key k\nhasenoughentropy. Otherwise,wehavethesameissuethat\nwe had for password storage using hash functions: an at-\ntackercouldjusttryeverysinglekuntiloneofthemmatches.\nOnce theyʼve done that, theyʼve almost certainly found the\ncorrect k. Thatʼs not really a failure of the MAC though: if\nyoursecretkeycontainssolittleentropythatitʼsfeasiblefor\nanattackertotryallofthem,youʼvealreadylost,nomatter\nwhichMACalgorithmyoupick.\nBreakingprefix-MAC\nDespite being quite common, this MAC is actually com-\npletely insecure for most (cryptographically secure!) hash\nfunctionsH,includingSHA-2.\nAswesawinthechapteronhashfunctions,manyhash\nfunctions, such as MD5, SHA-0, SHA-1 and SHA-2, pad the\nmessage with a predictable padding before producing the\noutput digest. The output digest is the same thing as the\ninternal state of the hash function. Thatʼs a problem: the\nattackercanusethosepropertiestoforgemessages.\nFirst,theyusethedigestastheinternalstateofthehash\nfunction. Thatstatematchesthestateyougetwhenyouhash\nk∥m∥p,wherek isthesecretkey,misthemessage,andpis\nCHAPTER11. MESSAGEAUTHENTICATIONCODES 117\nthat predictable padding. Now, the attacker gets the hash\nfunctiontoconsumesomenewbytes: theattackerʼschosen\n′\nmessagem. Theinternalstateofthehashfunctionisnow\nwhatyougetwhenyoufeeditk∥m∥p∥m ′ . Then,theattacker\ntellsthehashfunctiontoproduceadigest. Again,thehash\nfunction appends a padding, so weʼre now at k∥m∥p∥m ′∥p ′ .\nThe attacker outputs that digest as the tag. That is exactly\nthe same thing as what happens when you try to compute\nthetagforthemessagem∥p∥m ′ underthesecretkeyk. So,\ntheattackerhassuccessfullyforgedatagforanewmessage,\nand,byourdefinition,theMACisinsecure.\nThis attack is called a length extension attack, because\nyouareextendingavalidmessage. Thepaddinginthemid-\ndlep,whichstartedoutasthepaddingfortheoriginalmes-\nsagebuthasbecomejustsomedatainthemiddle,iscalled\ngluepadding,becauseitgluestheoriginalmessagemandthe\n′\nattackerʼsmessagem together.\nThis attack might sound a little academic, and far from\na practical problem. We may have proven that the MAC is\ninsecure by our definition, but the only tags the attacker\ncansuccessfullyforgeareforverylimitedmodificationsof\nrealmessages. Specifically,theattackercanonlyforgetags\nfor a message that consists of a message we sent, followed\nby some binary junk, followed by something the attacker\nchooses. However, it turns out that for many systems, this\nis plenty to result in real breaks. Consider the following\nPython code that parses a sequence of key-value pairs that\nlooklikek1=v1&k2=v2&...:1\ndef parse(s):\npairs = s.split(”&”)\nparsed = {}\nfor pair in pairs:\nkey, value = pair.split(”=”)\n(continuesonnextpage)\n1Irealizetherearebrieferwaystowritethatfunction.Iamtryingto\nmakeitcomprehensibletomostprogrammers;notpleasingtoadvanced\nPythonistas.\nCHAPTER11. MESSAGEAUTHENTICATIONCODES 118\n(continuedfrompreviouspage)\nparsed[key] = value\nreturn parsed\nTheparsingfunctiononlyremembersthelastvaluefora\ngivenkey: previousvaluesinthedictionaryareoverwritten.\nAsaresult, anattackermountingalengthextensionattack\ncaneffectivelycontroltheparseddictionaryentirely.\nIfyouʼrethinkingthatthiscodehasmanyissues;sure,it\ndoes. Forexample,itdoesnʼthandleescapingcorrectly. But\nevenifitdid,thatwouldnʼtreallyfixthelengthextensionat-\ntackproblem. Mostparsingfunctionswillperfectlyhappily\nlive with that binary junk in the middle. Hopefully it con-\nvincesyouthatthereisinfactaprettygoodchancethatan\nattackercanproducemessageswithvalidtagsthatsaysome-\nthingentirelydifferentfromwhatyouintended.\nThe prefix-MAC construction is actually secure with\nmany current (SHA-3-era) hash functions, such as Keccak\nand BLAKE(2). The specifications for these hash functions\neven recommend it as a secure and fast MAC. They use\nvarious techniques to foil length extension attacks: for ex-\nample, BLAKE keeps track of the number of bits that have\nbeenhashedsofar,whileBLAKE2hasafinalizationflagthat\nmarksaspecificblockasthelast.\nVariants\nIssueswithprefix-MAChastemptedpeopletocomeupwith\nall sorts of clever variations. For example, why not add\nthe key to the end instead of the beginning (t = H(m∥k),\nor “suffix-MAC”, if you will)? Or maybe we should append\nthe key to both ends for good measure (t = H(k∥m∥k),\n“sandwich-MAC”perhaps?)?\nForwhatitʼsworth,bothoftheseareatleastbetterthan\nprefix-MAC,butbothofthesehaveseriousissues. Forexam-\nple, a suffix-MAC system is more vulnerable to weaknesses\nintheunderlyinghashfunction;asuccessfulcollisionattack"
  },
  {
    "input": "HMAC",
    "output": "CHAPTER11. MESSAGEAUTHENTICATIONCODES 119\nbreakstheMAC.Sandwich-MAChasother,morecomplexis-\nsues.\nCryptographyhasproducedmuchstrongerMACs,which\nweʼllseeinthenextfewsections. Therearenogoodreasons\nnottousethem.\n11.4 HMAC\nHMACisastandardtoproduceaMACwithacryptographic\nhashfunctionasaparameter. Itwasintroducedin1996ina\npaperbyBellare, Canetti andKrawczyk. Manyprotocolsat\nthetimeimplementedtheirownattemptatmessageauthen-\nticationusinghashfunctions. Mostoftheseattemptsfailed.\nThegoalofthatpaperspecificallywastoproduceaprovably\nsecureMACthatdidnʼtrequireanythingbeyondasecretkey\nandahashfunction.\nOne of the nice features of HMAC is that it has a fairly\nstrongsecurityproof. Aslongastheunderlyinghashfunc-\ntionisapseudorandomfunction,HMACitselfisalsoapseu-\ndorandom function. The underlying hash function doesnʼt\nevenhavetobecollisionresistantforHMACtobeasecure\nMAC. [Bel06] This proof was introduced after HMAC itself,\nand matched real-world observations: even though MD5\nand to a lesser extent SHA-0 had serious collision attacks,\nHMACconstructionsbuiltfromthosehashfunctionsstillap-\npearedtobeentirelysecure.\nThe biggest difference between HMAC and prefix-MAC\noritsvariantsisthatthemessagepassesthroughahashfunc-\ntion twice, and is combined with the key before each pass.\nVisually,HMAClookslikethis:\nTheonlysurprisingthinghereperhapsarethetwocon-\nstants p (the inner padding, one hash functionʼs block\ninner\nlength worth of 0x36 bytes) and p (the outer padding,\nouter\noneblocklengthworthof 0x5cbytes). Thesearenecessary\nforthesecurityproofofHMACtowork;theirparticularval-\nues arenʼt very important, as long as the two constants are\ndifferent."
  },
  {
    "input": "One-time MACs",
    "output": "CHAPTER11. MESSAGEAUTHENTICATIONCODES 120\nThetwopadsareXORedwiththekeybeforeuse. There-\nsult is either prepended to the original message (for the in-\nner padding p ) or to the intermediate hash output (for\ninner\nthe outer padding p ). Because theyʼre prepended, the\nouter\ninternalstateofthehashfunctionafterprocessingthepre-\nfixes can be computed ahead of time, shaving a few cycles\nofftheMACcomputationtime.\n11.5 One-time MACs\nSo far, weʼve always assumed that MAC functions can be\nused with a single key to produce secure MACs for a very\nlarge number of messages. By contrast, one-time MACs are\nCHAPTER11. MESSAGEAUTHENTICATIONCODES 121\nMAC functions that can only securely be used once with a\nsingle key. That might sound like a silly idea, since weʼve\nalready talked about regular secure MACs. An algorithm\nthatonlyworksoncejustseemsobjectivelyworse. However,\ntheyhaveseveralbigadvantages:\n• They can be incredibly fast to evaluate, even for very\nlargemessages.\n• Theyhaveacompellingsecurityproofbasedonthein-\nformationcontentofthetag.\n• Aconstructionexiststoturnaone-timeMACintoase-\ncure multiple-use MAC, removing the principal prob-\nlem.\nAtypicalsimpleexampleofsuchone-timeMACsconsists\nof a simplemultiplication and addition modulo some large\nprime p. In this case, the secret key consists of two truly\nrandomnumbersaandb,bothbetween1andp.\nt ≡ m·a+b (mod p)\nThissimpleexampleonlyworksforone-blockmessagesm,\nandsomeprimepslightlybiggerthanthebiggestm. Itcan\nbe extended to support bigger messages M consisting of\nblocksm byusingamessage-specificpolynomialP:\ni\nt ≡ (m ·an+···+m ·a)+b (mod p)\n| n {z 1 }\nP(M,a)\nThis might look like a lot of computation, but this polyno-\nmialcanbeefficientlyevaluatedbyiterativelyfactoringout\nthecommonfactora(alsoknownasHornerʼsrule):\nP(M,a) ≡ a·(a·(a·(···)+m )+m )+b (mod p)\n2 1\nBy computing each multiplication modulo p, the numbers\nwillremainconvenientlysmall.\nCHAPTER11. MESSAGEAUTHENTICATIONCODES 122\nInmanyways,aone-timeMACistoauthenticationwhat\na one-time pad is to encryption. The security argument is\nsimilar: as long as the key is only used once, an attacker\nlearnsnoinformationaboutthekeyorthemessage,because\nthey are being irreversibly mixed. This demonstrates that\nthe MAC is secure against attackers trying to produce exis-\ntential forgeries, even when that attacker has infinite com-\nputationalpower.\nAlsolikeaone-timepad,thesecurityargumentrelieson\ntwoveryimportantpropertiesaboutthekeysa,b:\n• Theyhavetobetrulyrandom.\n• Theyhavetobeusedatmostonce.\nRe-usingaandb\nWeʼll illustrate that our example MAC is insecure if it is\nusedtoauthenticatetwomessagesm ,m withthesamekey\n1 2\n(a,b):\nt ≡ m ·a+b (mod p)\n1 1\nt ≡ m ·a+b (mod p)\n2 2\nAn attacker can reconstruct a,b with some simple modular\narithmetic:2\nt −t ≡ (m ·a+b)−(m ·a+b) (mod p)\n1 2 1 2\n⇓ (removeparentheses)\nt −t ≡ m ·a+b−m ·a−b (mod p)\n1 2 1 2\n⇓ (band−bcancelout)\nt −t ≡ m ·a−m ·a (mod p)\n1 2 1 2\n⇓ (factorouta)\nt −t ≡ a·(m −m ) (mod p)\n1 2 1 2\n⇓ (flipsides,multiplybyinverseof(m −m ))\n1 2\na ≡ (t −t )(m −m ) −1 (mod p)\n1 2 1 2\n2Forarefresheronmodulararithmetic,includinganexplanationof\nthemodularinverse,pleaserefertotheappendix(page186)."
  },
  {
    "input": "Carter-Wegman MAC",
    "output": "CHAPTER11. MESSAGEAUTHENTICATIONCODES 123\nPluggingaintoeithertheequationfort ort getsb:\n1 2\nt ≡ m ·a+b (mod p)\n1 1\n⇓ (reorderterms)\nb ≡ t −m ·a (mod p)\n1 1\nAs you can see, as with one-time pads, re-using the key\neven once leads to a complete failure of the cryptosystem\ntopreserveprivacyorintegrity,asthecasemaybe. Asare-\nsult,one-timeMACsareabitdangeroustousedirectly. For-\ntunately, this weakness can be solved with a construction\ncalledaCarter-WegmanMAC,whichweʼllseeinthenextsec-\ntion.\n11.6 Carter-Wegman MAC\nAs weʼve already stated, the obvious problem with one-time\nMACs is their limited practicality. Fortunately, it turns out\nthat there is a construction, called a Carter-Wegman MAC,\nthatturnsanysecureone-timeMACintoasecuremany-time\nMACwhilepreservingmostoftheperformancebenefit.\nTheideabehindaCarter-WegmanMACisthatyoucanuse\na one-time MAC O to produce a tag for the bulk of the data,\nand then encrypt a nonce n with a pseudorandom function\nF,suchasablockcipher,toprotectthatone-timetag:\nCW((k ,k ),n,M) = F(k ,n)⊕O(k ,M)\n1 2 1 2\nAslongasF isasecurepseudorandomfunction,thenonceʼs\nencryption is totally unpredictable. In the eyes of an at-\ntacker,thatmeanstheXORoperationwillrandomlyflipthe\nbits of the one-time MAC tag O(k ,M). Because this masks\n2\ntherealvalueoftheone-timeMAC tag, theattackercannot\nperformthealgebraictrickswesawforone-timeMACsrecov-\neringthekeywhenitisusedmorethanonce.\nKeep in mind that while Carter-Wegman MACs take two\ndistinctkeysk andk ,andthatCarter-WegmanMACsarere-\n1 2\nlatedtoone-timeMACs,someofwhichalsotaketwodistinct"
  },
  {
    "input": "Authenticated encryption modes",
    "output": "CHAPTER11. MESSAGEAUTHENTICATIONCODES 124\nkeys a and b, they are not the same two keys. The Carter-\nWegmanMACʼsk istheonlykeypassedtothefastone-time\n2\nMACO. Ifthatfastone-timeMACisourearlierexamplethat\ntakestwokeysaandb,thatk wouldhavetogetsplitupinto\n2\nthosetwokeys. TheCarter-WegmanMACkeywouldthenbe\n(k ,k ) = (k ,(a,b)).\n1 2 1\nYoucantellhowaCarter-WegmanMACexploitstheben-\nefitsofbothkindsofMACsbyconsideringthetwotermsof\ntheequationseparately. InF(k ,n),F isjustaregularpseu-\n1\ndorandomfunction, suchasablockcipher. Itisquiteslow\nbycomparisontotheone-timeMAC.However,itsinput,the\nnonce, isverysmall. Theunpredictableoutputoftheblock\nciphermaskstheoutputoftheone-timeMAC.Inthesecond\nterm,O(k ,M),thelargeinputmessageM isonlyhandled\n2\nbytheveryfastone-timeMACO.\nThese constructions, in particular Poly1305-AES, cur-\nrently represent some of the state of the art in MAC func-\ntions. The paper ([BHK+99]) and RFC([BHK+])for an older,\nrelatedMACfunctioncalledUMACmayalsobegoodsources\nof extra background information, since they go into ex-\ntensive details of the hows and whys of a practical Carter-\nWegmanMAC.\n11.7 Authenticated encryption modes\nSo far, weʼve always clearly distinguished encryption from\nauthentication,andexplainedtheneedforboth. Themajor-\nityofsecureconnectionsthataresetupeverydayhavethat\ndistinctionaswell: theytreatencryptionandauthentication\nasfundamentallydifferentsteps.\nAlternatively, we could make authentication a funda-\nmentalpartofthemodeofoperation. Afterall,weʼvealready\nseenthatunauthenticatedencryptionisvirtuallyneverwhat\nyou want; it is, at best, something you occasionally have to\nlivewith. Itmakessensetouseconstructionsthatnotonly\nguaranteetheprivacyofanarbitrarystream,butalsoitsin-\ntegrity.\nCHAPTER11. MESSAGEAUTHENTICATIONCODES 125\nAsweʼvealreadyseen,manyofthemethodsofcompos-\ning authentication and encryption are inherently insecure.\nBy doing that in a fixed, secure way such as a properly de-\nsigned authenticated encryption mode, an application de-\nvelopernolongerhastomakethatchoice,whichmeansthey\nalsocanʼtinadvertentlymakethewrongchoice.\nAEAD\nAEADisafeatureofcertainmodesofauthenticatedencryp-\ntion. Such modes of operation are called AEAD modes. It\nstartswiththepremisethatmanymessagesactuallyconsist\noftwoparts:\n• Theactualcontentitself\n• Metadata: dataabout thecontent\nIn many cases the metadata should be plaintext, but\nthecontentitselfshouldbeencrypted. Theentiremessage\nshouldbeauthenticated: itshouldnotbepossibleforanat-\ntackertomesswiththemetadataandhavetheresultingmes-\nsagestillbeconsideredvalid.\nConsiderane-mailalternativeasanexamplecryptosys-\ntem. The metadataaboutthe contentmightcontainthe in-\ntendedrecipient. Wedefinitelywanttoencryptandauthen-\nticate the content itself, so that only the recipient can read\nit. The metadata, however, has to be in plaintext: the e-\nmailserversperformingthemessagedeliveryhavetoknow\nwhichrecipienttosendthemessageto.\nMany systems would leave this metadata unauthenti-\ncated,allowingattackerstomodifyit. Inourcase,thatlooks\nlikeitmayjustleadtomessagesbeingdeliveredtothewrong\ninbox. Thatalsomeansthatanattackercanforcee-mailto\nbedeliveredtothewrongperson,ornotdeliveredatall.\nAEAD modes address this issue by providing a specified\nwaytoaddmetadatatoencryptedcontent,sothatthewhole\noftheencryptedcontentandthemetadataisauthenticated,\nandnotthetwopiecesseparately:"
  },
  {
    "input": "OCB mode",
    "output": "CHAPTER11. MESSAGEAUTHENTICATIONCODES 126\n11.8 OCB mode\nThisisanoptional,in-depthsection. It\nalmost certainly wonʼt help you write bet-\ntersoftware,sofeelfreetoskipit. Itisonly\nheretosatisfyyourinnergeekʼscuriosity.\nUsually, you will want to use a much more high level cryp-\ntosystem,suchasOpenPGP,NaClorTLS.\nOCBmodeisanAEADmodeofoperation. Itisoneofthe\nearliestdevelopedAEADmodes.\nAsyoucansee,mostofthisschemelooksquitesimilarto\nECBmode. ThenameOCBisquitesimilartoelectroniccode-\nbook, as well. OCB does not share the security issues ECB\nmode has, however, as there are several important differ-\nences, such as the offsets ∆ introduced in each individual\ni\nblockencryption.\nBeinganAEADmode,OCBmodeprovidesacryptograph-\nically secure authentication tag t, which is built from X, a\nvery simple (not cryptographically secure by itself) check-\nsum of the plaintext. Thereis also another, separatetagt ,\na\nwhichauthenticatestheAEADassociateddata. Thatassoci-\nateddatatagt iscomputedasfollows:\na\nThisdesignhasanumberofinterestingproperties. For\nexample, it is very fast: only requiring roughly one block\ncipher operation per encrypted or associate data block, as\nwell as one additional block cipher operation for the final\ntag. Theoffsets(∆ )arealsoextremelyeasytocompute. The\ni\nCHAPTER11. MESSAGEAUTHENTICATIONCODES 127\nchecksumblockXisjustalloftheplaintextblocksP XORed\ni\ntogether. Finally, OCB mode is easy to compute in parallel;\nonlythefinalauthenticationtagisdependentonallthepre-\ncedinginformation.\nOCBmodealsocomeswithabuilt-inpaddingscheme: it\nbehaves slightly differently when the plaintexts or authen-\nticationtextisnotexactlyamultipleoftheblocksize. This\nmeansthat,unlikewithPKCS#5/PKCS#7padding,thereisnʼt\nanentireblockof“wasted”paddingiftheplaintexthappens\ntobeamultipleoftheblocksize.\nDespite having several interesting properties going for\nit, OCB mode has not received as much attention as some\nof the alternatives; one of the main reasons being that it\nis patent encumbered. Even though a number of patent li-\ncensesareavailable,includingafree-of-chargeoneforopen\nsource software, this does not appear to have significantly\nimpactedhowmuchOCBmodeisusedinthefield. [Rog]"
  },
  {
    "input": "GCM mode",
    "output": "CHAPTER11. MESSAGEAUTHENTICATIONCODES 128\n11.9 GCM mode\nThisisanoptional,in-depthsection. It\nalmost certainly wonʼt help you write bet-\ntersoftware,sofeelfreetoskipit. Itisonly\nheretosatisfyyourinnergeekʼscuriosity.\nUsually, you will want to use a much more high level cryp-\ntosystem,suchasOpenPGP,NaClorTLS.\nGCM mode is an AEAD mode with an unfortunate case\nof RAS (redundant acronym syndrome) syndrome: GCM it-\nself stands for “Galois Counter Mode”. It is formalized in a\nNISTSpecialPublication[gcm07]androughlyboilsdownto\nacombinationofclassicalCTRmodewithaCarter-Wegman\nCHAPTER11. MESSAGEAUTHENTICATIONCODES 129\nMAC.ThatMACcanbeusedbyitselfaswell,whichiscalled\nGMAC.\nAuthentication\nGCMmode(andbyextensionGMAC)"
  },
  {
    "input": "Description",
    "output": "12\nSignature algorithms\n12.1 Description\nAsignaturealgorithmisthepublic-keyequivalentofames-\nsageauthenticationcode. Itconsistsofthreeparts:\n1. akeygenerationalgorithm,whichcanbesharedwith\notherpublic-keyalgorithms\n2. asignaturegenerationalgorithm\n3. asignatureverificationalgorithm\nSignaturealgorithmscanbebuiltusingencryptionalgo-\nrithms. Usingtheprivatekey,weproduceavaluebasedon\nthe message, usually using a cryptographic hash function.\nAnyone can then use the public key to retrieve that value,\ncompute what the value should be from the message, and\ncomparethetwotoverify. Theobviousdifferencebetween\nthis and public-key encryption is that in signing, the private\nkey is used to produce the message (in this case the signa-\nture)andthepublickeyisusedtointerpretit, whichisthe\noppositeofhowencryptionanddecryptionwork.\n130"
  },
  {
    "input": "DSA",
    "output": "CHAPTER12. SIGNATUREALGORITHMS 131\nTheaboveexplanationglossesovermanyimportantde-\ntails. Weʼlldiscussrealschemesinmoredetailbelow.\n12.2 RSA-based signatures\nPKCS#1v1.5\nTODO(see#48)\nPSS\nTODO(see#49)\n12.3 DSA\nThe Digital Signature Algorithm (DSA) is a US Federal Gov-\nernment standard for digital signatures. It was first pro-\nposedbytheNationalInstituteofStandardsandTechnology\n(NIST)in1991, tobeusedintheDigitalSignatureStandard\n(DSS).ThealgorithmisattributedtoDavidW.Kravitz,afor-\nmertechnicaladvisorattheNSA.\nDSAkeygenerationhappensintwosteps. Thefirststep\nis a choice of parameters, which can be shared between\nusers. The second step is the generation of public and pri-\nvatekeysforasingleuser.\nParametergeneration\nWe start by picking an approved cryptographic hash func-\ntion H. We also pick a key length L and a prime length N.\nWhiletheoriginalDSSspecifiedthatLbebetween512and\n1024,NISTnowrecommendsalengthof3072forkeyswitha\nsecuritylifetimebeyond2030. AsLincreases,soshouldN.\nNext we choose a prime q of length N bits; N must be\nlessthanorequaltothelengthofthehashoutput. Wealso\npickanL-bitprimepsuchthatp−1isamultipleofq.\nCHAPTER12. SIGNATUREALGORITHMS 132\nThe last part is the most confusing. We have to find a\nnumber g whose multiplicative order (page 201) (mod p) is\nq. Theeasywaytodothisistosetg ≡ 2(p−1)/q (mod p). We\ncantryanothernumbergreaterthan2,andlessthanp−1,\nifgcomesouttoequal1.\nOncewehaveparameters(p,q,g),theycanbesharedbe-\ntweenusers.\nKeygeneration\nArmedwithparameters,itʼstimetocomputepublicandpri-\nvatekeysforanindividualuser. First,selectarandomxwith\n0 < x < q. Next,calculateywherey ≡ gx (mod p). Thisde-\nliversapublickey(p,q,g,y),andprivatekeyx.\nSigningamessage\nInordertosignamessage, thesignerpicksarandomk be-\ntween0andq. Pickingthatkturnsouttobeafairlysensitive\nand involved process; but weʼll go into more detail on that\nlater. Withkchosen,theythencomputethetwopartsofthe\nsignaturer,softhemessagem:\nr ≡ (gk (mod p)) (mod q)\ns ≡ k −1(H(m)+xr) (mod q)\nIf either of these happen to be 0 (a rare event, with 1 in q\nodds,andqbeingaprettylargenumber),pickadifferentk.\nTODO:Talkaboutk-1,themodularinverse(see#52)\nVerifyingasignature\nVerifyingthesignatureisalotmorecomplex. Giventhemes-\nsagemandsignature(r,s):\nw ≡ s −1 (mod q)\nu ≡ wH(m) (mod q)\n1\nCHAPTER12. SIGNATUREALGORITHMS 133\nu ≡ wr (mod q)\n2\nv ≡ (gu1yu2 (mod p)) (mod q)\nIf the signature is valid that final result v will be equal to r,\nthesecondpartofthesignature.\nThetroublewithk\nWhilethereisnothingwrongwithDSAdoneright, itʼsvery\neasy to get it wrong. Furthermore, DSA is quite sensitive:\neven a small implementation mistake results in a broken\nscheme.\nInparticular,thechoiceofthesignatureparameterk is\ncritical. The requirements for this number are among the\nstrictestofallrandomnumbersincryptographicalgorithms.\nForexample,manyalgorithmsrequireanonce. Anoncejust\nhas to be unique: you can use it once, and then you can\nnever use it again. It doesnʼt have to be secret. It doesnʼt\nevenhavetobeunpredictable. Anoncecanbeimplemented\nby a simple counter, or a monotonic clock. Many other al-\ngorithms, such as CBC mode, use an initialization vector. It\ndoesnʼthavetobeunique: itonlyhastobeunpredictable. It\nalsodoesnʼthavetobesecret: initializationvectorsaretypi-\ncallytackedontotheciphertext. DSAʼsrequirementsforthe\nkvalueareacombinationofallofthese:\n• Ithastobeunique.\n• Ithastobeunpredictable.\n• Ithastobesecret.\nMuddle with any of these properties, and an attacker\ncan probably retrieve your secret key, even with a modest\namountofsignatures. Forexample,anattackercanrecover\nthe secret key knowing only a few bits of k, plus a large\namountofvalidsignatures. [NS00]\nCHAPTER12. SIGNATUREALGORITHMS 134\nIt turns out that many implementations of DSA donʼt\neven get the uniqueness part right, happily reusing k val-\nues. That allows a direct recovery of the secret key using\nbasicarithmetic. Sincethisattackismuchsimplertounder-\nstand, very commonly applicable, and equally devastating,\nweʼlldiscussitindetail.\nSupposethatanattackerseesmultiplesignatures(r ,s ),\ni i\nfordifferentmessagesm ,allwiththesamek. Theattacker\ni\npicksanytwosignatures(r ,s )and(r ,s )ofmessagesm\n1 1 2 2 1\nandm respectively. Writingdowntheequationsfors and\n2 1\ns :\n2\ns ≡ k −1(H(m )+xr ) (mod q)\n1 1 1\ns ≡ k −1(H(m )+xr ) (mod q)\n2 2 2\nThe attacker can simplify this further: r and r must be\n1 2\nequal,followingthedefinition:\nr ≡ gk (mod q)\ni\nSincethesignerisreusingk,andthevalueofronlydepends\nonk,allr willbeequal. Sincethesignerisusingthesame\ni\nkey,xisequalinthetwoequationsaswell.\nSubtractthetwos equationsfromeachother, followed\ni\nbysomeotherarithmeticmanipulations:\ns −s ≡ k −1(H(m )+xr)−k −1(H(m )+xr) (mod q)\n1 2 1 2\n≡ k −1((H(m )+xr)−(H(m )+xr)) (mod q)\n1 2\n≡ k −1(H(m )+xr−H(m )−xr) (mod q)\n1 2\n≡ k −1(H(m )−H(m )) (mod q)\n1 2\nThisgivesusthesimple,directsolutionfork:\nk ≡ (H(m )−H(m ))(s −s ) −1 (mod q)\n1 2 1 2\nThe hash values H(m ) and H(m ) are easy to compute.\n1 2\nTheyʼre not secret: the messages being signed are public.\nCHAPTER12. SIGNATUREALGORITHMS 135\nThe two values s and s are part of the signatures the at-\n1 2\ntacker saw. So, the attacker can compute k. That doesnʼt\ngivehimtheprivatekeyxyet,though,ortheabilitytoforge\nsignatures.\nLetʼs write the equation for s down again, but this time\nthinking of k as something we know, and x as the variable\nweʼretryingtosolvefor:\ns ≡ k −1(H(m)+xr) (mod q)\nAll(r,s)thatarevalidsignaturessatisfythisequation,sowe\ncan just take any signature we saw. Solve for x with some\nalgebra:\nsk ≡ H(m)+xr (mod q)\nsk−H(m) ≡ xr (mod q)\nr −1(sk−H(m)) ≡ x (mod q)\nAgain, H(m) is public, plus the attacker needed it to com-\npute k, anyway. Theyʼve already computed k, and s is\npluckedstraightfromthesignature. Thatjustleavesuswith\nr\n−1\n(mod q)(readas: “themodularinverseofrmoduloq”),\nbut that can be computed efficiently as well. (For more in-\nformation,seetheappendixonmodulararithmetic;keepin\nmind that q is prime, so the modular inverse can be com-\nputed directly.) That means that the attacker, once theyʼve\ndiscovered the k of any signature, can recover the private\nkeydirectly.\nSo far, weʼve assumed that the broken signer would al-\nwaysusethesamek. Tomakemattersworse,asigneronly\nhas to re-use k once in any two signatures that the attacker\ncanseefortheattacktowork. Asweʼveseen,ifkisrepeated,\nther valuesrepeataswell. Sincer isapartofthesignature,\ni i\nitʼsvery easy to see when the signer has made this mistake.\nSo,evenifreusingkissomethingthesigneronlydoesrarely"
  },
  {
    "input": "Repudiable authenticators",
    "output": "CHAPTER12. SIGNATUREALGORITHMS 136\n(becausetheirrandomnumbergeneratorisbroken, forex-\nample),doingitonceisenoughfortheattackertobreakthe\nDSAscheme.\nInshort,reusingthek parameterofaDSAsigningoper-\nationmeansanattackerrecoverstheprivatekey.\nTODO: Debian http://rdist.root.org/2009/05/\n17/the-debian-pgp-disaster-that-almost-was/\n12.4 ECDSA\nTODO:explain(see#53)\nAswithregularDSA,thechoiceofkisextremelycritical.\nThereareattacksthatmanagetorecoverthesigningkeyus-\ning a few thousand signatures when only a few bits of the\nnonceleak. [MHMP13]\n12.5 Repudiable authenticators\nSignaturesliketheoneswedescribedaboveprovideaprop-\nertycallednon-repudiation. Inshort,itmeansthatyoucanʼt\nlaterdenybeingthesenderofthesignedmessage. Anyone\ncan verify that the signature was made using your private\nkey,somethingonlyyoucoulddo.\nThatmaynotalwaysbeausefulfeature;itmaybemore\nprudenttohaveaschemewhereonlytheintendedrecipient\ncan verify the signature. An obvious way to design such a\nschemewouldbetomakesurethattherecipient(or,infact,\nanyoneelse)couldhavecomputedanidenticalvalue.\nSuchmessagescanberepudiated;suchaschemeisoften\ncalled“deniableauthentication”. Whileitauthenticatesthe\nsendertotheintendedrecipient, thesendercanlaterdeny\n(tothirdparties)havingsentthemessage. Equivalently,the\nrecipientcanʼtconvinceanyoneelsethatthesendersentthat\nparticularmessage."
  },
  {
    "input": "Description",
    "output": "13\nKey derivation functions\n13.1 Description\nA key derivation function is a function that derives one or\nmoresecretvalues(thekeys)fromonesecretvalue.\nManykeyderivationfunctionscanalsotakea(usuallyop-\ntional)saltparameter. Thisparametercausesthekeyderiva-\ntionfunctiontonotalwaysreturnthesameoutputkeysfor\nthe same input secret. As with other cryptosystems, salts\narefundamentallydifferentfromthesecretinput: saltsgen-\nerallydonothavetobesecret,andcanbere-used.\nKey derivation functions can be useful, for example,\nwhen a cryptographic protocol starts with a single secret\nvalue, such as a shared password or a secret derived using\nDiffie-Hellman key exchange, but requires multiple secret\nvalues to operate, such as encryption and MAC keys. An-\notherusecaseofkeyderivationfunctionsisincryptograph-\nicallysecurerandomnumbergenerators,whichweʼllseein\nmore detail in a following chapter, where they are used to\nextract randomness with high entropy density from many\nsourcesthateachhavelowentropydensity.\n137"
  },
  {
    "input": "Password strength",
    "output": "CHAPTER13. KEYDERIVATIONFUNCTIONS 138\nThere are two main categories of key derivation func-\ntions,dependingontheentropycontentofthesecretvalue,\nwhich determines how many different possible values the\nsecretvaluecantake.\nIfthesecretvalueisauser-suppliedpassword,forexam-\nple, it typically contains very little entropy. There are very\nfew values the password will take. As weʼve already estab-\nlishedinaprevioussectiononpasswordstorage(page104),that\nmeansitisnecessarythatthekeyderivationfunctionishard\ntocompute. Thatmeansitrequiresanon-trivialamountof\ncomputingresources,suchasCPUcyclesormemory. Ifthe\nkey derivation function were easy to compute, an attacker\ncouldsimplyenumerateallpossiblevaluesofthesharedse-\ncret,sincetherearefewpossibilities,andthencomputethe\nkeyderivationfunctionforallofthem. Asweʼveseeninthat\nprevioussectiononpasswordstorage,thisishowmostmod-\nernattacksonpasswordstoreswork. Usinganappropriate\nkeyderivationfunctionwouldpreventtheseattacks. Inthis\nchapter,weʼllseescrypt,aswellasotherkeyderivationfunc-\ntionsinthiscategory.\nOn the other hand, the secret value could also have a\nhighentropycontent. Forexample, itcouldbeasharedse-\ncret derived from a Diffie-Hellman key agreement protocol,\noranAPIkeyconsistingofcryptographicallyrandombytes\n(weʼlldiscusscryptographicallysecurerandomnumbergen-\nerationinthenextchapter). Inthatcase,itisnʼtnecessaryto\nhaveakeyderivationfunctionthatʼshardtocompute: even\nifthekeyderivationfunctionistrivialtocompute,thereare\ntoomanypossiblevaluesthesecretcantake,soanattacker\nwouldnotbeabletoenumeratethemall. Weʼllseethebest-\nof-breed of this kind of key derivation function, HKDF, in\nthischapter.\n13.2 Password strength\nTODO:NISTSpecialPublication800-63"
  },
  {
    "input": "HKDF",
    "output": "CHAPTER13. KEYDERIVATIONFUNCTIONS 139\n13.3 PBKDF2\n13.4 bcrypt\n13.5 scrypt\n13.6 HKDF\nTheHKDF,definedinRFC5869[KE]andexplainedindetail\nin a related paper [Kra10], is a key derivation function de-\nsignedforhighentropyinputs,suchassharedsecretsfroma\nDiffie-Hellmankeyexchange. Itisspecificallynot designed\ntobesecureforlow-entropyinputssuchaspasswords.\nHKDFexiststogivepeopleanappropriate,off-the-shelf\nkey derivation function. Previously, key derivation was of-\ntensomethingthatwasdoneadhocforaparticularstandard.\nUsuallytheseadhocsolutionsdidnothavetheextraprovi-\nsionsHKDFdoes,suchassaltsortheoptionalinfoparame-\nter(whichweʼlldiscusslaterinthissection);andthatʼsonly\nin the best case scenario where the KDF wasnʼt fundamen-\ntallybrokentobeginwith.\nHKDFisbasedonHMAC.LikeHMAC,itisagenericcon-\nstruction that uses hash functions, and can be built using\nanycryptographicallysecurehashfunctionyouwant.\nAcloserlookatHKDF\nThisisanoptional,in-depthsection. It\nalmost certainly wonʼt help you write bet-\ntersoftware,sofeelfreetoskipit. Itisonly\nheretosatisfyyourinnergeekʼscuriosity.\nHKDF consists of two phases. In the first phase, called the\nextraction phase, a fixed-length key is extracted from the in-\nCHAPTER13. KEYDERIVATIONFUNCTIONS 140\nputentropy. Inthesecondphase,calledtheexpansionphase,\nthatkeyisusedtoproduceanumberofpseudorandomkeys.\nTheextractionphase\nThe extraction phase is responsible for extracting a small\namount of data with a high entropy content from a poten-\ntiallylargeamountofdatawithasmallerentropydensity.\nTheextractionphasejustusesHMACwithasalt:\ndef extract(salt, data):\nreturn hmac(salt, data)\nThe salt value is optional. If the salt is not specified, a\nstringofzeroesequaltothelengthofthehashfunctionʼsout-\nputisused. Whilethesaltistechnicallyoptional,thedesign-\nersstressitsimportance,becauseitmakestheindependent\nusesofthekeyderivationfunction(forexample,indifferent\napplications, or with different users) produce independent\nresults. Evenafairlylow-entropysaltcanalreadycontribute\nsignificantly to the security of the key derivation function.\n[KE][Kra10]\nTheextractionphaseexplainswhyHKDFisnotsuitable\nfor deriving keys from passwords. While the extraction\nphaseisverygoodatconcentrating entropy,itisnotcapable\nofamplifying entropy. Itisdesignedforcompactingasmall\namount of entropy spread out over a large amount of data\nintothesameamountofentropyinasmallamountofdata,\nbut is not designed for creating a set of keys that are diffi-\ncult to compute in the face of a small amount of available\nentropy. Therearealsonoprovisionsformakingthisphase\ncomputationallyintensive. [KE]\nInsomecases,itispossibletoskiptheextractionphase,\nif the shared secret already has all the right properties,\nfor example, if it is a pseudorandom string of sufficient\nlength, and with sufficient entropy. However, sometimes\nthisshouldnotbedoneatall,forexamplewhendealingwith\na Diffie-Hellman shared secret. The RFC goes into slightly\nCHAPTER13. KEYDERIVATIONFUNCTIONS 141\nmoredetailonthetopicofwhetherornottoskipthisstep;\nbutitisgenerallyinadvisable. [KE]\nTheexpansionphase\nIntheexpansionphase,therandomdataextractedfromthe\ninputsintheextractionphaseisexpandedintoasmuchdata\nasisrequired.\nTheexpansionstepisalsoquitesimple: chunksofdata\nare produced using HMAC, this time with the extracted se-\ncret, not with the public salt, until enough bytes are pro-\nduced. ThedatabeingHMACedisthepreviousoutput(start-\ning with an empty string), an “info” parameter (by default\nalsotheemptystring),andacounterbytethatcountswhich\nblockiscurrentlybeingproduced.\ndef expand(key, info=””):\n”””Expands the key, with optional info.”””\noutput = ””\nfor byte in map(chr, range(256)):\noutput = hmac(key, output + info + byte)\nyield output\ndef get_output(desired_length, key, info=””):\n”””Collects output from the expansion step(cid:0)\n,→until enough\nhas been collected; then returns that output.\n,→”””\noutputs, current_length = [], 0\nfor output in expand(key, info):\noutputs.append(output)\ncurrent_length += len(output)\nif current_length >= desired_length:\nbreak\nelse:\n# This block is executed when the for(cid:0)\n,→loop *isn't*\n# terminated by the ``break`` statement,\n,→ which\n(continuesonnextpage)\nCHAPTER13. KEYDERIVATIONFUNCTIONS 142\n(continuedfrompreviouspage)\n# happens when we run out of ``expand``(cid:0)\n,→outputs\n# before reaching the desired length.\nraise RuntimeError(”Desired length too(cid:0)\n,→long”)\nreturn ””.join(outputs)[:desired_length]\nLike the salt in the extraction phase, the “info” parame-\nterisentirelyoptional,butcanactuallygreatlyincreasethe\nsecurityoftheapplication. The“info”parameterisintended\nto contain some application-specific context in which the\nkey derivation function is being used. Like the salt, it will\ncause the key derivation function to produce different val-\nuesindifferentcontexts,furtherincreasingitssecurity. For\nexample,theinfoparametermaycontaininformationabout\nthe user being dealt with, the part of the protocol the key\nderivationfunctionisbeingexecutedfororthelike. [KE]"
  },
  {
    "input": "Introduction",
    "output": "14\nRandom number\ngenerators\nThegenerationofrandomnumbersistooimpor-\ntanttobelefttochance.\nRobertR.Coveyou\n14.1 Introduction\nMany cryptographic systems require random numbers. So\nfar,weʼvejustassumedthattheyʼreavailable. Inthischapter,\nweʼllgomoreindepthabouttheimportanceandmechanics\nofrandomnumbersincryptographicsystems.\nProducingrandomnumbersisafairlyintricateprocess.\nLike with so many other things in cryptography, itʼs quite\neasytogetitcompletelywrongbuthaveeverythinglookcom-\npletelyfinetotheuntrainedeye.\nThere are three categories of random number genera-\ntionthatweʼllconsiderseparately:\n• Truerandomnumbergenerators\n143"
  },
  {
    "input": "True random number generators",
    "output": "CHAPTER14. RANDOMNUMBERGENERATORS 144\n• Cryptographicallysecurepseudorandomnumbergen-\nerators\n• Pseudorandomnumbergenerators\n14.2 True random number generators\nAnyonewhoconsidersarithmeticalmethodsof\nproducingrandomdigitsis, ofcourse, inastate\nofsin.\nJohnvonNeumann\nJohn von Neumann, father of the modern model of\ncomputing, made an obvious point. We canʼt expect to\nproduce random numbers using predictable, deterministic\narithmetic. Weneedasourceofrandomnessthatisnʼtacon-\nsequenceofdeterministicrules.\nTrue random number generators get their randomness\nfrom physical processes. Historically, many systems have\nbeen used for producing such numbers. Systems like dice\nare still in common use today. However, for the amount of\nrandomnessweneedforpracticalcryptographicalgorithms,\nthesearetypicallyfartooslow,andoftenquiteunreliable.\nWeʼve since come up with more speedy and reliable\nsources of randomness. There are several categories of\nphysicalprocessesthatareusedforhardwarerandomnum-\nbergeneration:\n• Quantumprocesses\n• Thermalprocesses\n• Oscillatordrift\n• Timingevents\nKeepinmindthatnotalloftheseoptionsnecessarilygen-\nerate high-quality, truly random numbers. Weʼll elaborate\nfurtheronhowtheycanbeappliedsuccessfullyanyway.\nCHAPTER14. RANDOMNUMBERGENERATORS 145\nRadioactivedecay\nOne example of a quantum physical process used to pro-\nduce random numbers is radioactive decay. We know that\nradioactive substances will slowly decay over time. Itʼs im-\npossible to know when the next atom will decay; that pro-\ncess is entirely random. Detecting when such a decay has\noccurred,however,isfairlyeasy. Bymeasuringthetimebe-\ntweenindividualdecays,wecanproducerandomnumbers.\nShotnoise\nShotnoiseisanotherquantumphysicalprocessusedtopro-\nducerandomnumbers. Shotnoiseisbasedonthefactthat\nlightandelectricityarecausedbythemovementofindivisi-\nblelittlepackets: photonsinthecaseoflight,andelectrons\ninthecaseofelectricity.\nNyquistnoise\nAn example of a thermal process used to produce random\nnumbers is Nyquist noise. Nyquist noise is the noise that\noccurs from charge carriers (typically electrons) traveling\nthrough a medium with a certain resistance. That causes\na tiny current to flow through the resistor (or, alternatively\nput,causesatinyvoltagedifferenceacrosstheresistor).\nr\n4k T∆\nB f\ni =\nR\np\nv = 4k TR∆\nB f\nTheseformulasmayseemalittlescarytothosewhohavenʼt\nseen the physics behind them before, but donʼt worry too\nmuch: understandingthemisnʼtreallynecessarytogoalong\nwith the reasoning. These formulas are for the root mean\nsquare. If youʼve never heard that term before, you can\nroughlypretendthatmeans“average”. ∆f isthebandwidth,"
  },
  {
    "input": "Cryptographically secure pseudorandom generators",
    "output": "CHAPTER14. RANDOMNUMBERGENERATORS 146\nT is the temperature of the system in Kelvins, k is Boltz-\nB\nmannʼsconstant.\nAs you can see from the formula, Nyquist noise is ther-\nmal, or temperature-dependent. Fortunately, an attacker\ngenerallycanʼtusethatpropertytobreakthegenerator: the\ntemperatureatwhichitwouldbecomeineffectiveissolow\nthat the system using it has probably already failed at that\npoint.\nBy evaluating the formula, we can see that Nyquist\nnoise is quite small. At room temperature with reasonable\nassumptions (10 kHz bandwidth and a 1kΩ resistor), the\nNyquistvoltageisintheorderofseveralhundrednanovolts.\nEven if you round up liberally to a microvolt (a thousand\nnanovolts),thatʼsstillathousandthofathousandthofavolt,\nandevenatinyAAbatteryproduces1.5V.\nWhile the formulas describe the root mean square, the\nvalueyoucanmeasurewillberandomlydistributed. Byre-\npeatedlymeasuringit,wecanproducehigh-qualityrandom\nnumbers. For most practical applications, thermal noise\nnumbersarequitehighqualityandrelativelyunbiased.\nTODO:weʼveneveractuallyexplainedthewordentropy;\n“resistanceanattackerperceives”isnecessaryinagooddef-\ninition\nTODO:explainsynchronousstreamciphersasCSPRNGs\n14.3 Cryptographically secure pseudoran-\ndom generators\nWhileweʼllseeseveralexamplesofcryptographicallysecure\npseudorandomgeneratorsinthenextfewsections,keepin\nmind that they are all just algorithms that could be used.\nAs an application developer, you should never be making a\nchoicebetweenoneofthem.\nInstead,inthefewcasesyoureallywanttopickarandom\nnumber manually, you should always use the cryptographi-\ncallysecurerandomnumbergeneratorprovidedbyyourop-"
  },
  {
    "input": "Yarrow",
    "output": "CHAPTER14. RANDOMNUMBERGENERATORS 147\neratingsystem: /dev/urandomon*NIX(Linux,BSDs,and\nOSX),orCryptGenRandomonWindows. Pythonprovides\nhandy interfaces to these in the form of os.urandom and\nrandom.SystemRandom.\nWhile they can be implemented securely, try to avoid\nusing userspace cryptographically secure random number\ngeneratorssuchastheoneinOpenSSL.Therearefarmore\nthingsthatcangowrongwiththem,usuallyinvolvingtheir\ninternal state: either they remain uninitialized, poorly ini-\ntialized, or end up re-using the same state in different lo-\ncations. In all of these cases, the resulting cryptosystem is\ncompletelyandutterlybroken.\nTODO: talk about the FUD in the Linux man page for\nurandom\nThisisanoptional,in-depthsection. It\nalmost certainly wonʼt help you write bet-\ntersoftware,sofeelfreetoskipit. Itisonly\nheretosatisfyyourinnergeekʼscuriosity.\nSince this is a specific cryptograph-\nically secure pseudorandom number generator algo-\nrithm, you donʼt actually need to know how it works to\nwritegoodsoftware. Justuse~urandom~.\n14.4 Yarrow\nThisisanoptional,in-depthsection. It\nalmost certainly wonʼt help you write bet-\ntersoftware,sofeelfreetoskipit. Itisonly\nheretosatisfyyourinnergeekʼscuriosity.\nTheYarrowalgorithmisacryptographicallysecurepseudo-\nrandomnumbergenerator.\nTODO:actuallyexplainYarrow"
  },
  {
    "input": "Dual_EC_DRBG",
    "output": "CHAPTER14. RANDOMNUMBERGENERATORS 148\nThisalgorithmis used as the CSPRNGforFreeBSD,and\nwas inherited by Mac OS X. On both of these operating\nsystems, itʼs used to implement /dev/random. Unlike on\nLinux,/dev/urandomisjustanaliasfor/dev/random.\n14.5 Blum Blum Shub\nTODO:explainthis,andwhyitʼsgood(provable),butwhywe\ndonʼtuseit(slow)\n14.6 Dual_EC_DRBG\nThisisanoptional,in-depthsection. It\nalmost certainly wonʼt help you write bet-\ntersoftware,sofeelfreetoskipit. Itisonly\nheretosatisfyyourinnergeekʼscuriosity.\nDual_EC_DRBG is a NIST standard for a cryptographically\nsecure pseudorandom bit generator. It sparked a large\namount of controversy: despite being put forth as an offi-\ncial, federal cryptographic standard, it quickly became evi-\ndentthatitwasnʼtverygood.\nCryptanalysiseventuallydemonstratedthatthestandard\ncouldcontainabackdoorhiddenintheconstantsspecified\nbythestandard,potentiallyallowinganunspecifiedattacker\ntocompletelybreaktherandomnumbergenerator.\nSeveralyearsafterwards,leakeddocumentssuggesteda\nbackdoorinanunnamedNISTstandardreleasedinthesame\nyearasDual_EC_DRBG,fuelingthesuspicionsfurther. This\nledtoanofficialrecommendationfromthestandardsbody\ntostopusingthestandard,whichwaspreviouslyunheardof\nundersuchcircumstances.\nCHAPTER14. RANDOMNUMBERGENERATORS 149\nBackground\nFor a long time, the official standards produced by NIST\nlacked good, modern cryptographically secure pseudoran-\ndom number generators. It had a meager choice, and the\nonesthathadbeenstandardizedhadseveralseriousflaws.\nNISThopedtoaddressthisissuewithanewpublication\ncalled SP 800-90, that contained several new cryptographi-\ncallysecurepseudorandomnumbergenerators. Thisdocu-\nment specified a number of algorithms, based on different\ncryptographicprimitives:\n1. Cryptographichashfunctions\n2. HMAC\n3. Blockciphers\n4. Ellipticcurves\nRight off the bat, that last one jumps out. Using elliptic\ncurves for random number generation was unusual. Stan-\ndardsliketheseareexpectedtobestate-of-the-art,whilestill\nstaying conservative. Elliptic curves had been considered\nbefore in an academic context, but that was a far cry from\nbeingsuggestedasastandardforcommonuse.\nThere is a second reason elliptic curves seem strange.\nHMAC and block ciphers are obviously symmetric algo-\nrithms. Hashfunctionshavetheirapplicationsinasymmet-\nric algorithms such as digital signatures, but arenʼt them-\nselves asymmetric. Elliptic curves, on the other hand, are\nexclusivelyusedforasymmetricalgorithms: signatures,key\nexchange,encryption.\nThatsaid,thechoicedidnʼtcomeentirelyoutoftheblue.\nAchoiceforacryptographicallysecurepseudorandomnum-\nber generator with a strong number-theoretical basis isnʼt\nunheard of: Blum Blum Shub is a perfect example. Those\ngenerators are typically much slower than the alternatives.\nDual_EC_DRBG,forexample, isthreeordersofmagnitude\nCHAPTER14. RANDOMNUMBERGENERATORS 150\nslower than its peers presented in the same standard. The\nidea is that the extra confidence inspired by the stronger\nmathematicalguaranteesisworththeperformancepenalty.\nFor example, weʼre fairly confident that factoring numbers\nis hard, but weʼre a lot less sure about our hash functions\nand ciphers. RSA came out in 1977 and has stood the test\noftimequitewellsincethen. DEScameouttwoyearslater,\nand is now considered completely broken. MD4 and MD5\ncameoutoveradecadelater,andarecompletelybrokenas\nwell.\nTheproblemis,though,thatthestandarddidnʼtactually\nprovide the security proof. The standard specifies the gen-\nerator but then merely suggests that it would be at least as\nhardassolvingtheellipticcurvediscretelogproblem. Blum\nBlum Shub, by contrast, has a proof that shows that break-\ningitisatleastashardassolvingthequadraticresiduosity\nproblem. The best algorithm we have for that is factoring\nnumbers,whichweʼrefairlysureisprettyhard.\nThe omission of the proof is a bit silly, because thereʼs\nno reason youʼd use a pseudorandom number generator as\nslowasDual_EC_DRBGunlessyouhadproofthatyouwere\ngettingsomethinginreturnfortheperformancehit.\nCryptographerslaterdidthehomeworkthatNISTshould\nhave provided in the specification [SS06] [BGjosteen07].\nThoseanalysesquicklyhighlightedafewissues.\nAquickoverviewofthealgorithm\nThealgorithmconsistsoftwoparts:\n1. Generatingpseudorandompointsontheellipticcurve,\nwhichareturnedintotheinternalstateofthegenera-\ntor;\n2. Turningthosepointsintopseudorandombits.\nWeʼll illustrate this graphically, with an illustration\nbased on the work by Shumow and Ferguson, two cryptog-\nCHAPTER14. RANDOMNUMBERGENERATORS 151\nrapherswhohighlightedsomeofthemajorissueswiththis\nalgorithm:\nThroughout the algorithm, ϕ is a function that takes a\ncurvepointandturnsitintoaninteger. Thealgorithmneeds\ntwogivenpointsonthecurve: P andQ. Thesearefixed,and\ndefinedin thespecification. The algorithmhas aninternal\nstates. Whenproducinganewblockofbits,thealgorithm\nturnssintoadifferentvaluerusingtheϕfunctionandellip-\nticcurvescalarmultiplicationwithP:\nr = ϕ(sP)\nThatvalue,r,isusedbothforproducingtheoutputbitsand\nupdatingtheinternalstateofthegenerator. Inordertopro-\nduce the output bits, a different elliptic curve point, Q, is\nused. TheoutputbitsareproducedbymultiplyingrwithQ,\nandrunningtheresultthroughatransformationθ:\no = θ(ϕ(rQ))\nInordertoperformthestateupdate,r ismultipliedwithP\nagain,andtheresultisconvertedtoaninteger. Thatinteger\nisusedasthenewstates.\ns = ϕ(rP)\nIssuesandquestionmarks\nFirstofall, ϕisextremelysimple: itjusttakesthexcoordi-\nnateofthecurvepoint,anddiscardsthey coordinate. That\nCHAPTER14. RANDOMNUMBERGENERATORS 152\nmeansthatitʼsquiteeasyforanattackerwhoseestheoutput\nvalueofϕtofindpointsthatcouldhaveproducedthatvalue.\nInitself,thatʼsnotnecessarilyabigdeal;but,asweʼllsee,itʼs\nonefactorthatcontributestothepossibilityofabackdoor.\nAnotherflawwasshownwherepointswereturnedinto\npseudorandom bits. The θ function simply discards the 16\nmost significant bits. Previous designs discarded signifi-\ncantlymore: for256-bitcurvessuchasthese,theydiscarded\nsomewhereintherangeof120and175bits.\nFailing to discard sufficient bits gave the generator a\nsmallbias. Thenext-bitpropertywasviolated,givingattack-\ners a better than 50% chance of guessing the next bit cor-\nrectly. Granted, that chance was only about one in a thou-\nsandbetterthan50%;butthatʼsstillunacceptableforwhatʼs\nsupposed to be the state-of-the-art in cryptographically se-\ncurepseudorandomnumbergenerators.\nDiscarding only those 16 bits has another consequence.\nBecauseonly16bitswerediscarded, weonlyhavetoguess\n216 possibilities to find possible values of ϕ(rQ) that pro-\nducedtheoutput. Thatisaverysmallnumber: wecansim-\nplyenumerateallofthem. Thosevaluesaretheoutputsof\nϕ, whichas wesawjust returnsthexcoordinateof a point.\nSince we know it came from a point on the curve, we just\nhave to check if our guess is a solution for the curve equa-\ntion:\ny2 ≡ x3+ax+b (mod p)\nThe constants a,b,p are specified by the curve. Weʼve just\nguessed a value for x, leaving only one unknown, y. We\ncan solve that quite efficiently. We compute th√e right hand\nsideandseeifitʼsaperfectsquare: y2 ≡ q ≡ x3+ax+b\n√\n(mod p). Ifitis,A = (x, q) = (x,y)isapointonthecurve.\nThisgivesusanumberofpossiblepointsA,oneofwhichis\nrQusedtoproducetheoutput.\nThisisnʼtabigdealatfacevalue. Tofindthestateofthe\nalgorithm,anattackerneedstofindr,sotheycancompute\nCHAPTER14. RANDOMNUMBERGENERATORS 153\ns. Theystillneedtosolvetheellipticcurvediscretelogprob-\nlemtofindrfromrQ,givenQ. Weʼreassumingthatproblem\nishard.\nKeepinmindthatellipticcurvesareprimitivesusedfor\nasymmetric encryption. That problem is expected to be\nhardtosolveingeneral, butwhatifwehavesomeextrain-\nformation? WhatifthereʼsasecretvalueesothateQ = P?\nLetʼsputourselvesintheshoesofanattackerknowinge.\nWerepeatourmathfromearlier. OneofthosepointsAwe\njustfoundistherQweʼrelookingfor. Wecancompute:\nϕ(eA) ≡ ϕ(erQ) ≡ ϕ(rP) (mod p)\nThat last step is a consequence of the special relationship\nbetweene,P,Q. Thatʼsprettyinteresting, becauseϕ(rP)is\nexactly the computation the algorithm does to compute s,\nthenewstateofthealgorithm! Thatmeansthatanattacker\nthatknowsecan,quiteefficiently,computethenewstates\nfromanyoutputo,allowingthemtopredictallfuturevalues\nofthegenerator!\nThisassumesthattheattackerknowswhichAistheright\nA. Becauseonly16bitswerediscardedthereareonly16bits\nleftforustoguess. Thatgivesus216candidatexcoordinates.\nExperimentally, we find that roughly half of the possible x\ncoordinates correspond to points on the curve, leaving us\nwith215possiblecurvepointsA,oneofwhichisrQ. Thatʼsa\nprettysmallnumberforabitofcomputer-aidedarithmetic:\nplenty small for us to try all options. We can therefore say\nthatanattackerthatdoesknowthesecretvalueemostdefi-\nnitelycanbreakthegenerator.\nSo,weʼvenowshownthatifthereisamagicaleforwhich\neQ = P, and you can pick P and Q (and you donʼt have to\nexplainwhereyougotthemfrom),thatyoucouldbreakthe\ngenerator. Howdoyoupicksuchvalues?\nTo demonstrate just how possible it is, the researchers\nstarted from the NIST curveʼs P and p values, but came up\n′\nwiththeirownQ. TheydidthisbystartingwithP,pickinga\n′\nrandomd(keepingitsecret),andsettingQ = dP. Thetrick\nCHAPTER14. RANDOMNUMBERGENERATORS 154\n′\nisthatthereʼsanefficientalgorithmforcomputingeineQ =\n′\nP ifyouknowthedinQ = dP. Thisistheeweneedforour\nearlierattack. Whentheytriedthisout,theydiscoveredthat\ninall cases(thatis, formanyrandomd), seeing 32 bytesof\noutputwasenoughtodeterminethestates.\nAll of this, of course, only demonstrates that it is possi-\nble for the specified values of P and Q to be special values\nwithasecretbackdoor. Itdoesnʼtprovideanyevidencethat\ntheactual valueshaveabackdoorinthem. However, given\nthat the standard never actually explains how they got the\nmagical value for Q, it doesnʼt really inspire a lot of con-\nfidence. Typically, cryptographic standards use “nothing-\nup-my-sleeve”numbers,suchasthevalueofsomeconstant\nsuchasπorthenaturallogarithmbase,e.\nIf someone does know the backdoor, the consequences\nareobviouslydevastating. Weʼvealreadyarguedforthene-\ncessityofcryptographicallysecurepseudorandomnumber\ngenerators: having a broken one essentially means that all\ncryptosystemsthatusethisgeneratorarecompletelyandut-\nterlydefeated.\nThere are two ways one might try to fix this particular\nalgorithm:\n• Make the θ function more complex to invert, rather\nthan just discarding 16 bits. This makes it harder to\nfind candidate points, and hence, harder to perform\ntheattack. Oneobviouswaywouldbetodiscardmore\nbits. Another option would be to use a cryptographi-\ncallysecurehash,oracombinationofboth.\n• GeneraterandomQeverytimeyoustartthealgorithm,\npossiblybypickingarandomdandsettingQ = dP. Of\ncourse,dhastobesufficientlylargeandtrulyrandom:\nifθisunchanged,andthereareonlyafewvaluesdcan\nhave,theattackercanjustperformtheaboveattackfor\nallvaluesofd."
  },
  {
    "input": "Mersenne Twister",
    "output": "CHAPTER14. RANDOMNUMBERGENERATORS 155\nBothofthesearereallyjustband-aidsolutions;itwould\nbe a much better idea to just use a different algorithm al-\ntogether. These suggestions donʼt resolve the issue that itʼs\nslow,exotic,andnowaretractedstandard.\nAftermath\nTODO:TalkaboutRSAguyʼscomments+snowdenleaks\n14.7 Mersenne Twister\nMersenneTwisterisaverycommonpseudorandomnumber\ngenerator. Ithasmanyniceproperties,suchashighperfor-\nmance,ahugeperiod1of219937−1 ≈ 4·106001,anditpasses\nall but the most demanding randomness tests. Despite all\nofthesewonderfulproperties,itisnot cryptographicallyse-\ncure.\nAnin-depthlookattheMersenneTwister\nThisisanoptional,in-depthsection. It\nalmost certainly wonʼt help you write bet-\ntersoftware,sofeelfreetoskipit. Itisonly\nheretosatisfyyourinnergeekʼscuriosity.\nTo demonstrate why Mersenne Twister isnʼt cryptographi-\ncally secure, weʼll take a look at how the algorithm works.\nFortunately,itʼsnotverycomplex.\nThe standard Mersenne Twister algorithm operates on\nan internal state array S consisting of 624 unsigned 32-bit\nintegers, and an index i pointing to the current integer. It\nconsistsofthreesteps:\n1Theperiodofapseudorandomnumbergeneratorishowmanyran-\ndomnumbersitproducesbeforetheentiresequencerepeats.\nCHAPTER14. RANDOMNUMBERGENERATORS 156\n1. Anoptionalinitializationfunction,whichproducesan\ninitialstatefromasmallrandomvaluecalledaseed.\n2. A state generation function, which produces a new\nstatefromtheoldstate.\n3. Anextractionfunction,alsocalledthetempering func-\ntion,thatproducesarandomnumberfromthecurrent\nelementofthestate(theelementpointedatbythein-\ndexi).\nWhenevertheextractionfunctioniscalled,theindexto\nthecurrentintegerisincremented. Whenallofthecurrent\nelements of the state have been used to produce a number,\nthestateinitializationfunctioniscalledagain. Thestateini-\ntializationfunctionisalsocalledrightbeforethefirstnum-\nberisextracted.\nSo,torecap: thestateisregenerated,thentheextraction\nfunctiongoesovereachoftheelementsinthestate,untilit\nrunsout. Thisprocessrepeatsindefinitely.\nTODO:illustrate\nWeʼll look at each of the parts briefly. The exact work-\nings of them is outside the scope of this book, but weʼll\nlook at them just long enough to get some insight into why\nMersenne Twister is unsuitable as a cryptographically se-\ncurerandomnumbergenerator.\nTheinitializationfunction\nTheinitializationfunctioncreatesaninstanceofMersenne\nTwisterʼs state array, from a small initial random number\ncalledaseed.\nThearraystartswiththeseeditself. Then,eachnextel-\nement is produced from a constant, the previous element,\nand the index of the new element. Elements are produced\nuntilthereare624ofthem.\nHereʼsthePythonsourcecode:\nCHAPTER14. RANDOMNUMBERGENERATORS 157\ndef uint32(n):\nreturn 0xFFFFFFFF & n\ndef initialize_state(seed):\nstate = [seed]\nfor i in range(1, 624):\nprev = state[-1]\nelem = 0x6c078965 * (prev ^ (prev >>(cid:0)\n,→30)) + i\nstate.append(uint32(elem))\nreturn state\nFor those of you who havenʼt worked with Python or its\nbitwiseoperators:\n• >>and<<areright-shiftandleft-shift\n• &isbinaryAND:0&0 = 0&1 = 1&0 = 0,and1&1 = 1.\n• ^isbinaryXOR,^=XORsandassignstheresulttothe\nname on the left-hand side, so x ^= k is the same\nthingasx = x ^ k.\nREVIEW:Bitwisearithmeticappendix?\nThestateregenerationfunction\nThestateregenerationfunctiontakesthecurrentstate and\nproducesanewstate. Itiscalledrightbeforethefirstnum-\nberisextracted,andeverytimeall624elementsofthestate\nhavebeenusedup.\nThePythonsourcecodeforthisfunctionisfairlysimple.\nNote that it modifies the state array in place, instead of re-\nturninganewone.\ndef regenerate(s):\nfor i in range(624):\ny = s[i] & 0x80000000\n(continuesonnextpage)\nCHAPTER14. RANDOMNUMBERGENERATORS 158\n(continuedfrompreviouspage)\ny += s[(i + 1) % 624] & 0x7fffffff\nz = s[(i + 397) % 624]\ns[i] = z ^ (y >> 1)\nif y % 2:\ns[i] ^= 0x9908b0df\nThe%inanexpressionlikes[(i + n) % 624]means\nthatanextelementofthestateislookedat,wrappingaround\ntothestartofthestatearrayifthereisnonextelement.\nThe values 0x80000000 and 0x7fffffff have a spe-\ncific meaning when interpreted as sequences of 32 bits.\n0x80000000hasonlythefirstbitset;0x7fffffffhasev-\nery bit except the first bit set. Because these are bitwise\nANDʼedtogether(&),thiseffectivelymeansthatafterthefirst\ntwo lines in the loop, y consists of the first bit of the cur-\nrentstateelementandallthesubsequentbitsofthenextel-\nement.\nThetemperingfunction\nThetemperingfunctionisappliedtothecurrentelementof\nthe state before returning it as the produced random num-\nber. Itʼs easier to just show the code instead of explaining\nhowitworks:\n_TEMPER_MASK_1 = 0x9d2c5680\n_TEMPER_MASK_2 = 0xefc60000\ndef temper(y):\ny ^= uint32(y >> 11)\ny ^= uint32((y << 7) & _TEMPER_MASK_1)\ny ^= uint32((y << 15) & _TEMPER_MASK_2)\ny ^= uint32(y >> 18)\nreturn y\nItmaynotbeobvious,especiallyifyouʼrenotusedtobi-\nnary arithmetic, but this function is bijective or one-to-one:\nCHAPTER14. RANDOMNUMBERGENERATORS 159\neach32bitintegerinputmapstoexactlyoneoutput,andvice\nversa: foreach32bitintegerwegetasanoutputtherewas\nexactlyone32bitintegeritcouldhavecomefrom. Because\nitusesrightandleftshifts,itmightlooklikeitthrowsaway\ndata at first glance, and hence canʼt possibly be reversible.\nItʼstruethatthoseshiftsthrowsomebitsaway,however,the\ncriticaloperationhereistheinlineXOR(^=): thoseshiftsare\njustusedtocomputemasksthatthevaluetobetemperedis\nXORʼd with. The XOR operations themselves are reversible,\nandbecauseeachindependentoperationisreversible,their\ncompositionistoo.\nBecause the tempering function is one-to-one, there is\nan inverse function: a function that gives you the untem-\nperedequivalentofanumber. Itmaynotbeobvioustoyou\nhowtoconstructthatfunctionunlessyouʼreabitwisearith-\nmeticwizard,butthatʼsokay;intheworstcasescenariowe\ncouldstillbrute-forceit. Supposewejusttryeverysingle32\nbitinteger,andremembertheresultinatable. Then,when\nwegetaresult,welookitupinthetable,andfindtheorigi-\nnal. Thattablewouldhavetobeatleast232·32bitsinlength,\noragood17gigabytes;big,butnotimpossiblyso.\nFortunately,thereʼsamuchsimplermethodtocompute\nthe inverse of the temper function. Weʼll see why thatʼs in-\nterestingwhenweevaluatethecryptographicsecurityofthe\nMersenne Twister in the next section. For those interested\nintheresult,theuntemperingfunctionlookslikethis:\ndef untemper(y):\ny ^= y >> 18\ny ^= ((y << 15) & _TEMPER_MASK_2)\ny = _undo_shift_2(y)\ny = _undo_shift_1(y)\nreturn y\ndef _undo_shift_2(y):\nt = y\n(continuesonnextpage)\nCHAPTER14. RANDOMNUMBERGENERATORS 160\n(continuedfrompreviouspage)\nfor _ in range(5):\nt <<= 7\nt = y ^ (t & _TEMPER_MASK_1)\nreturn t\ndef _undo_shift_1(y):\nt = y\nfor _ in range(2):\nt >>= 11\nt ^= y\nreturn t\nCryptographicsecurity\nRemember that for cryptographic security, it has to be im-\npossible to predict future outputs or recover past outputs\ngiven present outputs. The Mersenne Twister doesnʼt have\nthatproperty.\nItʼs clear that pseudorandom number generators, both\nthosecryptographicallysecureandthosethatarenʼt,areen-\ntirelydefinedbytheirinternalstate. Afterall,theyaredeter-\nministicalgorithms: theyʼrejusttryingveryhardtopretend\nnottobe. Therefore,youcouldsaythattheprincipaldiffer-\nence between cryptographically secure and ordinary pseu-\ndorandomnumbergeneratorsisthatthecryptographically\nsecureonesshouldnʼtleakinformationabouttheirinternal\nstate,whereasitdoesnʼtmatterforregularones.\nRememberthatinMersenneTwister,arandomnumber\nisproducedbytakingthecurrentelementofthestate,apply-\ningthetemperingfunction,andreturningtheresult. Weʼve\nalso seen that the tempering function has an inverse func-\ntion. So, if I can see the output of the algorithm and apply\ntheinverseofthetemperingfunction,Iʼverecoveredoneel-\nCHAPTER14. RANDOMNUMBERGENERATORS 161\nementoutofthe624inthestate.\nSuppose that I happen to be the only person seeing the\noutputs of the algorithm, and you begin at the start of the\nstate, such as with a fresh instance of the algorithm, that\nmeans that I can clone the state by just having it produce\n624randomnumbers.\nEvenifanattackerdoesnʼtseeall624numbers,theycan\noften still recreate future states, thanks to the simple rela-\ntionsbetweenpaststatesandfuturestatesproducedbythe\nstateregenerationfunction.\nAgain, this is not a weakness of Mersenne Twister. Itʼs\ndesignedtobefastandhavestrongrandomnessproperties.\nItisnotdesignedtobeunpredictable,whichisthedefining\npropertyofacryptographicallysecurepseudorandomnum-\nbergenerator."
  },
  {
    "input": "Complete cryptosystems",
    "output": "Part III\nComplete cryptosystems\n162"
  },
  {
    "input": "Description",
    "output": "15\nSSL and TLS\n15.1 Description\nSSL,shortforSecureSocketLayer,isacryptographicproto-\ncoloriginallyintroducedbyNetscapeCommunications1 for\nsecuringtrafficontheWeb. Thestandardisnowsuperseded\nbyTLS(TransportLayerSecurity), astandardpublicizedin\nRFCsbytheIETF.ThetermSSLisstillcommonlyused,even\nwhen the speaker actually means a TLS connection. From\nnowon, thisbookwillonlyusethetermTLS,unlesswere-\nallymeantheoldSSLstandard.\nItsfirstandforemostgoalistotransportbytessecurely,\nover the Internet or any other insecure medium. [DR] Itʼs\na hybrid cryptosystem: it uses both symmetric and asym-\nmetricalgorithmsinunison. Forexample,asymmetricalgo-\nrithmssuchassignaturealgorithmscanbeusedtoauthenti-\ncatepeers,whilepublickeyencryptionalgorithmsorDiffie-\nHellmanexchangescanbeusedtonegotiatesharedsecrets\nandauthenticatecertificates. Onthesymmetricside,stream\n1Forthosetooyoungtoremember,Netscapeisacompanythatused\ntomakebrowsers.\n163"
  },
  {
    "input": "Handshakes",
    "output": "CHAPTER15. SSLANDTLS 164\nciphers(bothnativeonesandblockciphersinamodeofoper-\nation)areusedtoencrypttheactualdatabeingtransmitted,\nandMACalgorithmsareusedtoauthenticatethatdata.\nTLS is the worldʼs most common cryptosystem, and\nhenceprobablyalsothemoststudied. Overtheyears,many\nflawshavebeendiscoveredinSSLandTLS,despitemanyof\nthe worldʼs top cryptographers contributing to and examin-\ning the standard2. As far as we know, the current versions\nofTLSaresecure,oratleastcanbeconfiguredtobesecure.\n15.2 Handshakes\nTODO:explainamodernTLShandshake\nDowngradeattacks\nSSL2.0madethemistakeofnotauthenticatinghandshakes.\nThis made it easy to mount downgrade attacks. A down-\ngradeattackisaman-in-the-middleattackwhereanattacker\nmodifies the handshake messages that negotiate which ci-\nphersuite is being used. That way, he can force the clients\ntosetuptheconnectionusinganinsecureblockcipher,for\nexample.\nDue to cryptographic export restrictions at the time,\nmany ciphers were only 40 or 56 bit. Even if the attacker\ncouldnʼt break the best encryption both client and server\nsupported, he could probably break the weakest, which is\nallthatisnecessaryforadowngradeattacktosucceed.\nThisisoneofthemanyreasonsthatthereisanexplicit\nRFC[TP]prohibitingnewTLSimplementationsfromhaving\nSSLv2.0support.\n2IncaseIhavenʼtdriventhispointhomeyet: itonlygoestoshow\nthatdesigningcryptosystemsishard, andyouprobablyshouldnʼtdoit\nyourself."
  },
  {
    "input": "Certificate authorities",
    "output": "CHAPTER15. SSLANDTLS 165\n15.3 Certificate authorities\nTLScertificatescanbeusedtoauthenticatepeers, buthow\ndo we authenticate the certificate? My bank may very well\nhave a certificate claiming to be that particular bank, but\nhow do I know itʼs actually my bank, and not just someone\npretending to be my bank? Why should I trust this partic-\nular certificate? As weʼve seen when we discussed these al-\ngorithms, anyone can generate as many key pairs as theyʼd\nlike. Thereʼs nothing stopping someone from generating a\nkeypairpretendingtobeyourbank.\nWhen someone actually tries to use a certificate to im-\npersonate a bank, real browsers donʼt believe them. They\nnotify the user that the certificate is untrusted. They do\nthisusingthestandardTLStrustmodelofcertificateauthor-\nities. TLS clients come with a list of trusted certificate au-\nthorities,commonlyshippedwithyouroperatingsystemor\nyour browser. These are special, trusted certificates, that\narecarefullyguardedbytheirowners.\nFor a fee, these owners will use their certificate author-\nitytosignothercertificates. Theideaisthatthecertificate\nauthoritywouldnʼtsignacertificateforFacebookorabank\noranyoneelse,unlessyoucouldproveyouʼreactuallythem.\nWhen a TLS client connects to a server, that server pro-\nvides a certificate chain. Typically, their own certificate is\nsignedbyanintermediaryCAcertificate,whichissignedby\nanother,andanother,andonethatissignedbyatrustedroot\ncertificate authority. Since the client already has a copy of\nthatrootcertificate,theycanverifythesignaturechainstart-\ningwiththeroot.\nYourfakecertificatedoesnʼthaveachainleadinguptoa\ntrustedrootcertificate,sothebrowserrejectsit.\nTODO:Explainwhythisisatotalracket"
  },
  {
    "input": "Perfect forward secrecy",
    "output": "CHAPTER15. SSLANDTLS 166\n15.4 Self-signed certificates\n15.5 Client certificates\nIn TLS, certificates are usually only used to identify the\nserver. This satisfies a typical use case: users want to com-\nmunicate securely with their banks and e-mail providers,\nand the certificate authenticates the service theyʼre talking\nto. The service usually authenticates the user using pass-\nwords,and,occasionally,two-factorauthentication.\nIn public-key schemes weʼve seen so far, all peers typi-\ncallyhadoneormorekeypairsoftheirown. Thereʼsnorea-\nsonuserscanʼthavetheirowncertificates,andusethemto\nauthenticate to the server. The TLS specification explicitly\nsupportsclientcertificates. Thisfeatureisonlyrarelyused,\neventhoughitclearlyhasveryinterestingsecuritybenefits.\nThemainreasonforthatisprobablyrootedinthepoor\nuserexperience. Therearenosystemsthatrelyonclientcer-\ntificatesthatareeasytousefornon-technicalpeople. Since\nthere are few such systems, even tech-savvy people donʼt\nknowaboutthem,whichmeansnewsystemsarenʼtcreated.\nClientcertificatesareagreatsolutionforwhenyoucon-\ntrolbothendsofthewireandwanttosecurelyauthenticate\nbothpeersinaTLSconnection. Byproducingyourowncer-\ntificateauthority,youcanevensigntheseclientcertificates\ntoauthenticatethem.\n15.6 Perfect forward secrecy\nHistorically, the most common way to agree on the pre-\nmaster secret is for the client to select a random number\nandencryptit,typicallyusingRSA.Thishasafewniceprop-\nerties. For example, it means the server can make do with\nlessentropy: sincetherandombitsarehandedtotheserver\nby the client, the server doesnʼt need to produce any cryp-\ntographically random bits. It also makes the handshake\nCHAPTER15. SSLANDTLS 167\nslightlyfaster,sincethereʼsnoneedforback-and-forthcom-\nmunicationtoagreeonasharedsecret.\nHowever,ithasonemajorflaw. Supposeanattackergets\naccesstotheserverʼsprivatekey. Perhapstheymanagedto\nfactor the modulus of the RSA key, or perhaps they broke\nin and stole it, or perhaps they used legal force to get the\nownertohandoverthekey. Regardlessofhowtheyacquired\nit,gettingaccesstothekeyallowstheattackertodecryptall\npast communication. The key allows them to decrypt the\nencrypted pre-master secrets, which allows them to derive\nallofthesymmetricencryptionkeys,andthereforedecrypt\neverything.\nThereareobviousalternativestothisscheme. Weʼveal-\nreadyseenDiffie-Hellmankeyexchange,allowingtwopeers\ntoagreeonsecretkeysoveraninsecuremedium. TLSallows\nfor peers to agree on the pre-master secret using a Diffie-\nHellman exchange, either based on discrete logs or elliptic\ncurves.\nAssuming both peers discard the keys after use like\ntheyʼre supposed to, getting access to the secret keys\nwouldnʼt allow an attacker to decrypt previous communi-\ncation. That property is called perfect forward secrecy. The\nterm “perfect” is a little contested, but the term “forward”\nmeans that communications canʼt be decrypted later if the\nlong-termkeys(suchastheserverʼsprivatekey)fallintothe\nwronghands.\nOf course, this is only true if Diffie-Hellman exchanges\nare secure. If an attacker has a significant mathematical\nand computational advantage over everyone else, such as\nan algorithm for solving the discrete log problem more ef-\nficiently than thought possible, combined with many data\ncentersfilledwithnumber-crunchingcomputers, itʼspossi-\nblethattheyʼllbreakthekeyexchangeitself."
  },
  {
    "input": "Attacks",
    "output": "CHAPTER15. SSLANDTLS 168\n15.7 Attacks\nAswithmostattacks,attacksonTLScanusuallybegrouped\nintotwodistinctcategories:\n1. Attacks on the protocol itself, such as subverting the\nCAmechanism;\n2. Attacksonaparticularimplementationorcipher,such\nascryptanalyticattacksexploitingweaknessesinRC4,\nortimingattacksinaparticularAESimplementation.\nUnfortunately,SSL/TLShashadmanysuccessfulattacks\ninbothcategories. Thissectionisparticularlyaboutthelat-\nter.\nCRIMEandBREACH\nCRIME3 isanattackbytheauthorsofBEAST.Itʼsaninnova-\ntivesidechannelattackthatreliesonTLScompressionleak-\ning information about secrets in the plaintext. In a related\nattack called BREACH4, the attackers accomplish the same\neffectusingHTTPcompression. Thatwaspredictedbythe\nauthorsoftheoriginalpaper,buttheBREACHauthorswere\nthefirsttodemonstrateitasapracticalattack. TheBREACH\nattackwasmorepracticallyapplicable,though: HTTPcom-\npression is significantly more common than TLS compres-\nsion.\nBoth of these rely on encryption of a compressed plain-\ntext,andtheirmechanismsarevirtuallyidentical: onlythe\nspecific details related to HTTP compression or TLS com-\npressionarerelevant. ThelargestdifferenceisthatwithTLS\ncompression,theentirestreamcanbeattacked;withHTTP\ncompression, only the body is compressed, so HTTP head-\nersaresafe. Sincetheattacksareotherwiseextremelysimi-\nlar,weʼlljusttalkabouthowtheattackworksintheabstract,\n3CompressionRatioInfo-leakMadeEasy\n4BrowserReconnaissanceandExfiltrationviaAdaptiveCompression\nofHypertext\nCHAPTER15. SSLANDTLS 169\nbyexplaininghowattackerscanlearninformationaboutthe\nplaintextifitiscompressedbeforeencryption.\nThe most common algorithm used to compress both\nHTTPandTLS[Hol]iscalledDEFLATE.Theexactmechan-\nicsofDEFLATEarenʼttooimportant,buttheimportantfea-\nture is that byte sequences that occur more than once can\nbeefficientlystored. Whenabytesequencerecurs5,instead\nof recording the same sequence, a reference is provided to\ntheprevioussequence: insteadofrepeatingthesequence,it\nsays“gobackandlookatthethingIwroteNbytesago”.\nSuppose an attacker can control the plaintext. For ex-\nample, the attacker injects an invisible iframe6 or some\nJavaScript code that fires off many requests. The attacker\nneeds some way to inject their guess of the secret so that\ntheirguessoccursintheplaintext,suchasthequeryparam-\neters7. Usually, they can prefix their guess with something\nknown. Suppose theyʼre trying to intercept an authentica-\ntiontokenbeingsuppliedinthebodyofthewebpage:\n<input type=”hidden”\nname=”csrf-token”\nvalue=”TOKEN_VALUE_HERE”>\n…theycanprefixtheguesswiththeknownpartofthat.\nIn this case, itʼs a CSRF token; a random token selected by\ntheserverandgiventotheclient. Thistokenisintendedto\npreventmaliciousthirdpartywebsitesfromusingtheambi-\nent authority present in the browser (such as session cook-\nies)tomakeauthenticatedrequests. WithoutaCSRFtoken,\nathirdpartywebsitemightjustmakearequesttothevulner-\nablewebsite;thewebbrowserwillprovidethestoredcookie,\nandthevulnerablewebsitewill mistakethatforanauthen-\nticatedrequest.\n5Withinlimits;specificallywithinaslidingwindow,usually32kBbig.\nOtherwise, the pointers would grow bigger than the sequences theyʼre\nmeanttocompress.\n6Aniframeisawebpageembeddedwithinapage.\n7The key-value pairs in a URL after the question mark, e.g. the\nx=1&y=2inhttp://example.test/path?x=1&y=2.\nCHAPTER15. SSLANDTLS 170\nThe attacker makes guesses at the value of the token,\nstarting with the first byte, and moving on one byte at a\ntime.8 Whentheyguessabytecorrectly,theciphertextwill\nbe just a little shorter: the compression algorithm will no-\nticethatitʼsseenthispatternbefore,andbeabletocompress\nthe plaintext before encrypting. The plaintext, and hence\nthecompressedciphertext, willthereforebesmaller. They\ncandothisdirectlywhentheconnectionisusingastreamci-\npher orasimilarconstructionsuchasCTRmode,sincethey\nproduceciphertextsthatareexactlyaslongastheplaintexts.\nIftheconnectionisusingablock-orientedmodesuchasCBC\nmode,thedifferencemightgetlostintheblockpadding. The\nattacker can solve that by simply controlling the prefix so\nthatthedifferenceinciphertextsizewillbeanentireblock.\nOncetheyʼveguessedonebytecorrectly,theycanmove\nontothenextbyte,untiltheyrecovertheentiretoken.\nThis attack is particularly interesting for a number of\nreasons. Not only is it a completely new class of attack,\nwidelyapplicabletomanycryptosystems, butcompressing\ntheplaintextpriortoencryptionwasactivelyrecommended\nby existing cryptographic literature. It doesnʼt require any\nparticularly advanced tools: you only need to convince the\nusertomakerequeststoavulnerablewebsite,andyouonly\nneedtobeabletomeasurethesizeoftheresponses. Itʼsalso\nextremelyeffective: theresearchersthatpublishedBREACH\nreport being able to extract secrets, such as CSRF tokens,\nwithinoneminute.\nInordertodefendagainstCRIME,disableTLScompres-\nsion. Thisisgenerallydoneinmostsystemsbydefault. In\nordertodefendagainstBREACH,thereareanumberofpos-\nsibleoptions:\n• Donʼtallowtheusertoinjectarbitrarydataintothere-\nquest.\n• Donʼtputsecretsintheresponsebodies.\n8Theymaybeabletomovemorequicklythanjustonebyteatatime,\nbutthisisthesimplestwaytoreasonabout."
  },
  {
    "input": "HSTS",
    "output": "CHAPTER15. SSLANDTLS 171\n• Regenerate secrets such as CSRF tokens liberally, for\nexample,eachrequest.\nItʼs a bad idea to simply unconditionally turn off HTTP\ncompression. While it does successfully stop the attack,\nHTTP compression is a critical tool for making the Web\nfaster.\nWeb apps that consist of a static front-end (say, using\nHTML5, JS, CSS) and that only operate using an API, say,\nJSON over REST, are particularly easy to immunize against\nthisattack. Justdisablecompressiononthechannelthatac-\ntually contains secrets. It makes things slower, of course,\nbut at least the majority of data can still be served over a\nCDN.\n15.8 HSTS\nHSTS is a way for web servers to communicate that what\ntheyʼresayingshouldonlyeverbetransferredoverasecure\ntransport. Inpractice,theonlysecuretransportthatisever\nusedforHTTPisTLS.\nUsing HSTS is quite simple; the web server just adds\nan extra Strict-Transport-Security header to the\nresponse. The header value contains a maximum age\n(max-age), which determines how long into the future the\nbrowser can trust that this website will be HSTS-enabled.\nThis is typically a large value, such as a year. Browsers\nsuccessfully remembering that a particular host is HSTS-\nenabledisveryimportanttotheeffectivenessofthescheme,\nasweʼllseeinabit. Optionally,theHSTSheadercaninclude\ntheincludeSubDomainsdirective,whichdetailsthescope\noftheHSTSpolicy. [HJB]\nThereareseveralthingsthataconformingwebbrowser\nwill do when communicating with an HSTS-enabled web-\nsite:\n• Whenever there is any attempt to make any connec-\ntiontothiswebsite,itwillalwaysbedoneoverHTTPS."
  },
  {
    "input": "Certificate pinning",
    "output": "CHAPTER15. SSLANDTLS 172\nThebrowserdoesthiscompletelybyitself,beforemak-\ningtherequesttothewebsite.\n• If there is an issue setting up a TLS connection, the\nwebsite will not be accessible, instead of simply dis-\nplayingawarning.\nEssentially, HSTS is a way for websites to communicate\nthattheyonlysupportsecuretransports. Thishelpsprotect\nthe users against all sorts of attacks including both passive\neavesdroppers(thatwerehopingtoseesomecredentialsac-\ncidentally sent in plaintext), and active man-in-the-middle\nattackssuchasSSLstripping.\nHSTS also defends against mistakes on the part of the\nweb server. For example, a web server might accidentally\npullinsomeexecutablecode,suchassomeJavaScript,over\nan insecure connection. An active attacker that can inter-\ncept and modify that JavaScript would then have complete\ncontroloverthe(supposedlysecure)website.\nAswithmanyTLSimprovements,HSTSisnotapanacea:\nit is just one tool in a very big toolbox of stuff that we have\nto try and make TLS more secure. HSTS only helps to en-\nsurethatTLSis actuallyused; it doesabsolutelynothingto\npreventattacksagainstTLSitself.\nHSTS can suffer from a chicken-or-egg problem. If a\nbrowserhasnevervisitedaparticularHSTS-enabledwebsite\nbefore, itʼs possible that the browser doesnʼt know that the\nwebsite is HSTS-enabled yet. Therefore, the browser may\nstill attempt a regular HTTP connection, vulnerable to an\nSSLstrippingattack. Somebrowsershaveattemptedtomit-\nigatethisissuebyhavingbrowserscomepre-loadedwitha\nlistofHSTSwebsites.\n15.9 Certificate pinning\nCertificate pinning is an idea thatʼs very similar to HSTS,\ntaken a little further: instead of just remembering that a"
  },
  {
    "input": "Secure configurations",
    "output": "CHAPTER15. SSLANDTLS 173\nparticularserverpromisestosupportHTTPS,weʼllremem-\nberinformationabouttheircertificates(inpractice,weʼllre-\nmember a hash of the public key). When we connect to a\nserverthatwehavesomestoredinformationabout,weʼllver-\nifytheircertificates,makingitmuchharderforanimpostor\ntopretendtobethewebsiteweʼreconnectingtousingadif-\nferentcertificate.\nBrowsersoriginallyimplementedcertificatepinningby\ncoming shipped with a list of certificates from large, high-\nprofile websites. For example, Google included whitelisted\ncertificatesforalloftheirservicesintheirChromebrowser.\n15.10 Secure configurations\nIn this section, we are only talking about configuration op-\ntions such as which ciphers to use, TLS/SSL versions, etc.\nWeʼrespecificallynottalkingaboutTLSconfigurationsinthe\nsenseoftrustmodels,keymanagement,etc.\nThereareseveralissueswithconfiguringTLSsecurely:\n1. Often,thedefaultsareunsafe,andpeopleareunaware\nthattheyshouldbechanged.\n2. The things that constitute a secure TLS configuration\ncan change rapidly, because cryptanalysis and practi-\ncalattacksarecontinuouslyimproving.\n3. Old clients that still need to be supported sometimes\nmeanthatyouhavetohangontobrokenconfiguration\noptions.\nA practical example of some of these points coming to-\ngether is the BEAST attack. That attack exploited weak-\nnesses in CBC ciphersuites in TLSv1.0, which were parts\nof the default ciphersuite specifications everywhere. Many\npeople recommended defending against it by switching to\nRC4. RC4 was already considered cryptographically weak,\nlatercryptanalysisshowedthatRC4wasevenmorebroken\nCHAPTER15. SSLANDTLS 174\nthanpreviouslysuspected. Theattackhadbeenknownfor\nyearsbeforebeingpracticallyexploited;itwasalreadyfixed\ninTLSv1.1in2006,yearsbeforetheBEASTpaperbeingpub-\nlished. However,TLSv1.1hadnotseenwideadoption.\nGood advice necessarily changes over time, and itʼs im-\npossibletodosoinapersistentmediumsuchasabook. In-\nstead, you should look at continuously updated third party\nsourcessuchasQualysSSLLabs. Theyprovidetestsforboth\nSSLclientsandservers,andextensiveadviceonhowtoim-\nproveconfigurations.\nThat said, there are certainly some general things we\nwantfromaTLSconfiguration.\nTODO: say stuff we generally want from TLS configura-\ntions\nTODO: http://tools.ietf.org/html/\ndraft-agl-tls-chacha20poly1305-01"
  },
  {
    "input": "Description",
    "output": "16\nOpenPGP and GPG\n16.1 Description\nOpenPGPisanopenstandardthatdescribesamethodforen-\ncryptingandsigningmessages. GPGisthemostpopularim-\nplementation of that standard1, available under a free soft-\nwarelicense.\nUnlikeTLS,whichfocusesondatainmotion, OpenPGP\nfocuses on data at rest. A TLS session is active: bytes fly\nback and forth as the peers set up the secure channel. An\nOpenPGP interaction is, by comparison, static: the sender\ncomputes the entire message up front using information\nshared ahead of time. In fact, OpenPGP doesnʼt insist that\nanything is sent at all: for example, it can be used to sign\nsoftwarereleases.\nLikeTLS,OpenPGPisahybridcryptosystem. Usershave\nkey pairs consisting of a public key and a private key. Pub-\nlickeyalgorithmsareusedbothforsigningandencryption.\nSymmetrickeyalgorithmsareusedtoencryptthemessage\n1GPG2alsoimplementsS/MIME,whichisunrelatedtotheOpenPGP\nstandard.ThischapteronlydiscussesOpenPGP.\n175"
  },
  {
    "input": "The web of trust",
    "output": "CHAPTER16. OPENPGPANDGPG 176\nbody; the symmetric key itself is protected using public-key\nencryption. Thisalsomakesiteasytoencryptamessagefor\nmultiplerecipients: onlythesecretkeyhastobeencrypted\nmultipletimes.\n16.2 The web of trust\nEarlier, we saw that TLS typically uses trusted root certifi-\ncatestoestablishthataparticularpeeriswhotheyclaimto\nbe. OpenPGPdoesnotoperateusingsuchtrustedroots. In-\nstead,itreliesonasystemcalledtheWebofTrust: afriend-\nof-a-friend honor system that relies on physical meetings\nwherepeopleverifyidentities.\nThe simplest case is a directly trusted key. If we meet\nupinperson,wecanverifyeachotherʼsidentities. Perhaps\nwe know each other, or perhaps weʼd check some form of\nidentification. Then,wesigneachotherʼskeys.\nBecauseIknowthekeyisyours,Iknowthatyoucanread\nthemessagesencryptedbyit,andtheotherwayaround. Pro-\nvidedyoudonʼtshareyourkey,Iknowthatonlyyoucanread\nthose messages. No-one can replace my copy of your key,\nbecausetheywouldnʼtbeabletoforgemysignatureonit.\nThereʼsadirecttrustlinkbetweenthetwoofus,andwe\ncancommunicatesecurely.\nA slightly more complicated case is when a friend of\nyours would like to send me a message. Weʼve never met:\nheʼsneversignedmykey,norhaveIsignedtheirs. However,\nI have signed your key, and vice versa. Youʼve signed your\nfriendʼskey,andviceversa. Yourfriendcanchoosetolever-\nageyourassertionthatIʼmindeedthepersoninpossession\nofthatkeyyousigned,andusethattocommunicatewithme\nsecurely.\nYou might wonder how your friend would ever see sig-\nnaturesthatyouplacedonmykey. Thisisbecausekeysand\nsignaturesaretypicallyuploadedtoanetworkofkeyservers,\nmakingthemfreelyavailabletotheworld.\nCHAPTER16. OPENPGPANDGPG 177\nThe above system can be extended to multiple layers\nof friends. It relies in no small part in communities being\nlinkedbysignatures,whichiswhymanycommunityevents\nincludekeysigningparties, wherepeoplesigneachotherʼs\nkeys. For large events, such as international programming\nconferences, this system is very effective. The main weak-\nnessinthissystemare“islands”oftrust: individualsorsmall\ngroupswithnoconnectionstotherestoftheweb.\nOf course, this is only the default way to use OpenPGP.\nThereʼsnothingstoppingyoufromshippingaparticularpub-\nlickeyasapartofasoftwarepackage,andusingthattosign\nmessagesorverifymessages. Thisisanalogoustohowyou\nmightwanttoshipakeywithaclientcertificate,oracustom\nCHAPTER16. OPENPGPANDGPG 178\nrootCAcertificate,withTLS."
  },
  {
    "input": "Description",
    "output": "17\nOff-The-Record\nMessaging (OTR)\n17.1 Description\nOTR messaging is a protocol for securing instant messaging\ncommunication between people [BGB04]. It intends to be\nthe online equivalent of a private, real-life conversation. It\nencryptsmessages,preventingeavesdroppersfromreading\nthem. Italsoauthenticatespeerstoeachother,sotheyknow\nwhotheyʼretalkingto. Despiteauthenticatingpeers,itisde-\nsigned to be deniable: participants can later deny to third\npartiesanythingtheysaidtoeachother. Itisalsodesigned\nto have perfect forward secrecy: even a compromise of a\nlong-termpublickeypairdoesnʼtcompromiseanyprevious\nconversations.\nThe deniability and perfect forward secrecy prop-\nerties are very different from those of other systems\nsuch as OpenPGP. OpenPGP intentionally guarantees non-\nrepudiability. Itʼsagreatpropertyifyouʼresigningsoftware\npackages, talking on mailing lists or signing business in-\n179"
  },
  {
    "input": "Key exchange",
    "output": "CHAPTER17. OFF-THE-RECORDMESSAGING(OTR) 180\nvoices, buttheauthorsofOTRarguethatthosearenʼtdesir-\nablepropertiesfortheonlineequivalentofone-on-onecon-\nversations. Furthermore, OpenPGPʼs static model of com-\nmunication makes the constant key renegotiation to facili-\ntateOTRʼsperfectforwardsecrecyimpossible.\nOTR is typically configured opportunistically, which\nmeansthatitwillattempttosecureanycommunicationbe-\ntween two peers, if both understand the protocol, without\ninterferingwithcommunicationwheretheotherpeerdoes\nnot. The protocol is supported in many different instant\nmessagingclientseitherdirectly,orwithaplugin. Because\nit works over instant messages, it can be used across many\ndifferentinstantmessagingprotocols.\nApeercansignalthattheywouldliketospeakOTRwith\nan explicit message, called the OTR Query message. If the\npeerisjustwillingtospeakOTRbutdoesnʼtrequireit,they\ncan optionally invisibly add that information to a plaintext\nmessage. Thathappenswithacleversystemofwhitespace\ntags: a bunchof whitespacesuch as spaces andtab charac-\nters are used to encode that information. An OTR-capable\nclient can interpret that tag and start an OTR conversation;\nan client that isnʼt OTR-capable just displays some extra\nwhitespace.\nOTRusesmanyoftheprimitivesweʼveseensofar:\n• Symmetrickeyencryption(AESinCTRmode)\n• Messageauthenticationcodes(HMACwithSHA-1)\n• Diffie-Hellmankeyexchange\nOTRalsoutilizesanothermechanism,calledtheSMP,to\ncheckifpeersarrivedatthesamesharedsecret.\n17.2 Key exchange\nInOTR,AKEreliesheavilyonDiffie-Hellmankeyexchange,\nextended with a significant number of extra, interlocking\nCHAPTER17. OFF-THE-RECORDMESSAGING(OTR) 181\nchecks. TheDiffie-Hellmanexchangeitselfusesafixed1536-\nbitprimewithafixedgeneratorg.\nWesupposethattwoparticipants,namedAliceandBob\nwanttocommunicateandarewillingtoexchangesensitive\ndata with each other. Alice and Bob have a long-term DSA\nauthentication key pair each, which weʼll call (p ,s ) and\nA A\n(p ,s )respectively.\nB B\nTheprotocolalsoreliesonanumberofotherprimitives:\n• A 128-bit block cipher. In OTR, this is always AES. In\nthissection,weʼllcallblockcipherencryptionandde-\ncryptionE andD,respectively.\n• Ahashfunction,H. InOTR,thisisSHA1.\n• Amessageauthenticationcode,M. InOTR,thisisHMAC-\nSHA1.\n• Asigningfunction,S.\nCommitmessage\nInitially Alice and Bob are in a protocol state where they\nwait for the peer to initiate an OTR connection, and adver-\ntisetheirowncapabilityofspeakingOTR.\nLetʼssupposethatBobchoosestoinitiateanOTRconver-\nsationwithAlice. HisclientsendsanOTRCommitMessage,\nandthentransitionstoastatewherehewaitsforareplyfrom\nfromAliceʼsclient.\nTosendacommitmessage,aclientpicksarandom128-\nbit value r and a random 320-bit (or larger) Diffie-Hellman\nsecretx. ItthensendsE(r,gx)andH(gx)tothepeer.\nKeymessage\nAliceʼs client has received Bobʼs clientʼs advertisement to\nstartanOTRsession. Herclientreplieswithakeymessage,\nwhichinvolvescreatinganewDiffie-Hellmankeypair. She\npicksa320-bit(orlarger)Diffie-Hellmansecrety andsends\ngy toBob.\nCHAPTER17. OFF-THE-RECORDMESSAGING(OTR) 182\nRevealSignatureMessage\nNowthatAlicehassentherpublicDiffie-Hellmankey, Bob\ncancompletehispartoftheDiffie-Hellmanprotocol. Alice\ncanʼtcontinueyet,becauseshehasnʼtseenBobʼspublickey.\nWhenwediscussedDiffie-Hellman,wenotedthatitdoes\nnot authenticate the peer. Bob can compute a secret, but\ndoesnʼt know heʼs talking to Alice. As with TLS and other\nsystemsusingDiffie-Hellman, thisproblemissolvedbyau-\nthenticatingthekeyexchange.\nAfterverifyingthatAliceʼspublickeyisavalidvalue,Bob\ncomputesthesharedsecrets = (gy)x. Usingakeyderivation\n′\nfunction, hederivesseveralkeysfroms: twoAESkeysc,c,\n′ ′\nandfourMACkeysm ,m ,m ,m .\n1 1 2 2\nHe chooses an identification number i for his current\nB\nDiffie-Hellmankeypair(x,gx). Thiswillbeimportantonce\nAlice and Bob generate new key pairs, which they will do\nlateronintheOTRprotocol.\nBobcomputes:\nM = M (gx,gy,p ,i )\nB m1 B B\nX = (p ,i ,S(p ,M ))\nB B B B B\nHesendsAlicer,E (X ),M (E (X )).\nc B m2 c B\nSignatureMessage\nAlicecannowconfirmsheʼstalkingtoBobdirectly,because\nBobsignedtheauthenticatorfortheexchangeM withhis\nB\nlong-termDSAkey.\nAlice can now also compute the shared secret: Bob has\nsentherr,whichwaspreviouslyusedtoencryptBobʼsDiffie-\nHellman public key. She then computes H(gx) herself, to\ncompare it against what Bob sent. By completing her side\noftheDiffie-Hellmanexchange(s = (gx)y), shederivesthe\n′ ′ ′\nsame keys: c,c,m ,m ,m ,m . Using m , she can verify\n1 1 2 2 2\nM (E (X )). Oncethatmessageisverified,shecansafely\nm2 c B\ndecryptitusinghercomputedc.\nCHAPTER17. OFF-THE-RECORDMESSAGING(OTR) 183\nShe can then also compute M = M (gx,gy,p ,i ),\nB m1 B B\nand verifies that it is the same as Bob sent. By verifying\nthe signed portion S(p ,M ) against Bobʼs public key, she\nB B\nhasnowunambiguouslytiedthecurrentinteractiontoBobʼs\nlong-termauthenticationkey.\nShe then computes the same values Bob computed to\ntie his long-term key to the short-term handshake, so that\nBob can also authenticate her. She chooses an identifica-\ntionnumberi forhercurrentDHkeypair(y,gy),computes\nA\nM\nA\n= M m′(gy,gx,p\nA\n,i\nA\n) and X\nA\n= p\nA\n,i\nA\n,S(p\nA\n,M\nA\n). Fi-\n1\nnally,shesendsBobE c′(X\nA\n),M m′(E\nc\n(X\nB\n)).\n2\nAuthenticatingAlice\nNow Bob can also authenticate Alice, again by mirroring\nsteps. First, he verifies M m′(E\nc\n(X\nB\n)). This allows him to\n2\ncheckthatAlicesawthesameX hesent.\nB\nOncehedecryptsE c′(X\nA\n),hehasaccesstoX\nA\n,whichis\nAliceʼslong-termpublickeyinformation. Hecanthencom-\npute M\nA\n= M m′(gy,gx,p\nA\n,i\nA\n) to compare it with the ver-\n1\nsion Alice sent. Finally, he verifies S(p ,M ) with Aliceʼs\nA A\npublickey.\nWhathaveweaccomplished?\nIfallcheckssucceedthenAliceandBobhavecompletedan\nauthenticated Diffie-Hellman exchange and have a shared\nsecretthatonlythetwoofthemknow.\nNow that youʼve seen both sides of the authenticated\nhandshake, you can see why so many different keys are de-\nrived from the Diffie-Hellman secret. Keys marked with a\nprime(′)areformessagesoriginatingfromthesecondpeer\n(the one responding to the advertisement, in our case, Al-\nice);keyswithoutaprimearefortheinitiatingpeer(inour\ncase,Bob)."
  },
  {
    "input": "Data exchange",
    "output": "CHAPTER17. OFF-THE-RECORDMESSAGING(OTR) 184\n17.3 Data exchange\nTODO: Explain (https://otr.cypherpunks.ca/\nProtocol-v3-4.0.0.html),#33"
  },
  {
    "input": "Addition and subtraction",
    "output": "A\nModular arithmetic\nModular arithmetic is used for many public key cryptosys-\ntems, including public-key encryption algorithms like RSA\nandkeyexchangeprotocolslikeDiffie-Hellman.\nModulararithmeticissomethingmostpeopleactuallyal-\nready understand, they just donʼt know itʼs called that. We\ncan illustrate the principles of modular arithmetic using a\nclock.\nFor simplicityʼs sake, our demonstration 12-hour clock\nonlyshowshours,notminutesorseconds. Alsounlikereal\nclocks,thehourhandisneverhalfwayinbetweentwohours:\nitalwaysshowsanexacthour,suchas2or9.\nA.1 Addition and subtraction\nItobviouslymakessensetoaddhoursonourclock: ifitʼs2\noʼclocknow,andyouʼdliketoknowwhattimeitisfivehours\nfromnow,youcanadd5,andendupwith7,asyoucansee\ninFigure1.2.\n186\nAPPENDIXA. MODULARARITHMETIC 187\nFigure1.1: Aclock,pointingto2.\nFigure1.2: 2+5 = 7,ontheclock.\nAPPENDIXA. MODULARARITHMETIC 188\nSimilarly, we can subtract times. If itʼs 10 oʼclock now,\nandyouʼdliketoknowwhattimeitwastwohoursago, you\nsubtract2andendupwith8.\nFigure1.3: 10−2 = 8,ontheclock.\nThe “weird” part is when you cross the boundary at 12.\nAs far as the clock is concerned, thereʼs no real difference\nbetween 12 and 0. If itʼs 10 oʼclock now, itʼll be 2 oʼclock in\nfour hours. If itʼs 2 oʼclock now, it was 9 oʼclock five hours\nago.\nThisisanexampleofwhatʼscalled“modulararithmetic”.\nThe modulus, in this case, is 12. We can write the above\nequationsas:\n(10+4) mod 12 = 2\n(2−5) mod 12 = 9\nIn these equations, the mod is an operator, giving the re-\nmainderafterdivision. Whenwearedealingwithmodular"
  },
  {
    "input": "Prime numbers",
    "output": "APPENDIXA. MODULARARITHMETIC 189\narithmetic, where all operations are affected by the modu-\nlus instead of a simple single operation, weʼll instead write\n(mod 12)attheendoftheequationandusean≡signinstead\nofanequalssign(=):\n10+4 ≡ 2 (mod 12)\n2−5 ≡ 9 (mod 12)\nThis is read as “ten plus four is equivalent to two, modulo\ntwelve” and “two minus five is equivalent to nine, modulo\ntwelve”. Thatmightseemlikeatrivialnotationalhacknow,\nbutthedifferencewillbecomeapparentoncewestartapply-\ning tricks for doing more complex modular computations,\nlikemultiplicationandexponentiation.\nIngeneral, wecalltwonumbersequivalentmodulosome\nmodulusifdividingthembythemodulusleavesthesamere-\nmainder. Wecanillustratethiswithourpreviousexamples:\n10+4 = 14leavesaremainderof2whendividedby12,soit\nis equivalent to 2 modulo 12. For negative numbers, weʼll\nalways use positive remainders. For example, 2 − 5 ≡ 9\n(mod 12). This is exactly the way a clock works as well: if\nitʼs2oʼclocknow,thenfivehoursagowas“nineoʼclock”,not\n“minusthreeoʼclock”.\nA.2 Prime numbers\nPrimenumbersarewonderfulkindsofnumbersthatcome\nback in many branches of mathematics. Anything I say\nabout them probably wonʼt do them justice; but weʼre in a\npracticalbookaboutappliedcryptography,soweʼllonlysee\nafewproperties.\nAprimenumberisanumberthatisdivisibleonlybytwo\nnumbers: 1anditself. Forexample,3isaprimenumber,but\n4isnot,becauseitcanbedividedby2.\nAnynumbercanbewrittenasaproductofprimefactors:\na bunch of prime numbers multiplied together. That prod-\nuct is called a prime factorization. For example, 30 can be"
  },
  {
    "input": "Multiplication",
    "output": "APPENDIXA. MODULARARITHMETIC 190\nfactorizedinto2,3and5:\n30 = 2·3·5\nSometimes,aprimenumberwilloccurmorethanonceina\nfactorization. Forexample,thefactorizationof360has2in\nitthreetimes,andthreeinittwice:\n360 = 23·32·5\nThe factorization of any prime number is just that prime\nnumberitself.\nModernmathematicsnolongerconsiders1tobeaprime\nnumber, even though it is only divisible by 1 and itself (1\nagain). Under this convention, every number not only has\nafactorization,butthatfactorizationisunique. Otherwise,4\ncouldbefactorednotonlyas2·2,butalsoas2·2·1,2·2·1·1,\nand so on. The uniqueness of factorization helps in some\nimportantproofsinnumbertheory.\nAlso, 0 is not a prime number, as it is divisible by many\nnumbers: allnumbersexcept0itself.\nTwo numbers are called coprime when their greatest\ncommondivisoris1,or,toputitinanotherway,theydonʼt\nshareanyprimefactors. Sincetheonlyprimefactoraprime\nhasisitself,thatmeansthatallprimenumbersarealsoco-\nprime. More generally, a prime is coprime to any number\nthatisnʼtamultipleofthatprime.\nA.3 Multiplication\nYoumightrememberyouwerefirsttaughtmultiplicationas\nrepeatedaddition:\nn·x = x+x+...+x\n| {z }\nntimes\nModular multiplication is no different. You can compute\nmodular multiplication by adding the numbers together,"
  },
  {
    "input": "Division and modular inverses",
    "output": "APPENDIXA. MODULARARITHMETIC 191\nandtakingthemoduluswheneverthesumgetslargerthan\nthe modulus. You can also just do regular multiplication,\nandthentakethemodulusattheend.\nA.4 Division and modular inverses\nDivisionisdefinedastheinverseofmultiplication. So,a·b ≡\nc (mod m),then c ≡ a (mod m).\nb\nForexample,5·6 ≡ 2 (mod 7);so: 2 ≡ 5 (mod 7). This\n6\nis because 5 · 6 = 30, which leaves a remainder of 2 when\ndividedby7.\nUsually,insteadofusingdivisiondirectly,weʼllmultiply\nusingsomethingcalledamodularinverse. Themodularin-\nverseofaisanumber,thatwhenyoumultiplyitwitha,you\nget1. Thisisjustliketheinverseofanumberinregulararith-\nmetic: x· 1 = 1.\nx\nLikeinregulararithmetic,notallnumbershavemodular\ninverses. Thisistheequivalentofdividingbyzeroinregular\narithmetic.\nTherearetwoalgorithmsthatareusedtocomputemod-\nular inverses: the extended Euclidean algorithm, and with\nthehelpofEulerʼstheorem.\nTheextendedEuclideantheorem\nTODO:explain,andhowyoucangetmodularinverseswith\nit\nUsingEulerʼstheorem\nEulerʼs theorem states that if two numbers a and n are co-\nprime,then:\naϕ(n) ≡ 1 (mod n)\nInthatequation,ϕisEulerʼstotientfunction,whichcounts\ntheamountofnumbersthatarecoprimeto(andlessthanor"
  },
  {
    "input": "Exponentiation",
    "output": "APPENDIXA. MODULARARITHMETIC 192\nequalto)itsargument. Asanexample,thetotientof10is4,\nas1,3,7,and9donothavecommonprimefactorswith10.\nWecanuseEulerʼstheoremtofindthemultiplicativein-\nverseofa. Ifwejustmultiplybothsidesoftheequationby\na\n−1,weget:\naϕ(n)−1 ≡ a −1 (mod n)\nThat gives us a direct formula for computing a\n−1.\nUnfortu-\nnately, this is still generally less interesting than using the\nextendedEuclideanalgorithm,fortworeasons:\n1. It requires computing the totient function, which is\nharder than running the extended Euclidean algo-\nrithminthefirstplace,unlessyouhappentoknowthe\nprimefactorsofn.\n2. Modular exponentiation is computationally expen-\nsive.\nOne exception to that rule is for prime moduli. Since a\nprimeiscoprimetoeveryothernumber,andsincethereare\np−1numberssmallerthanp,ϕ(p) = p−1. So,foraprime\nmodulus,themodularinverseofaissimply:\na −1 ≡ aϕ(p)−1 ≡ ap−2 (mod p)\nThisstillrequiresustobeabletoefficientlyraiseatoapower\nusingmodulararithmetic. Weʼlldiscusshowyoucandothat\nefficientlyinthenextsection.\nA.5 Exponentiation\nLikemultiplicationistaughtasrepeatedaddition,exponen-\ntiationcanbethoughtofasrepeatedmultiplication:\nan = a| ·a· {z...·a}\nntimes"
  },
  {
    "input": "Exponentiation by squaring",
    "output": "APPENDIXA. MODULARARITHMETIC 193\nAs with multiplication, itʼs possible to compute modular\nexponentiation by performing regular exponentiation, and\nthen taking the modulus at the end. However, this is very\ninefficient, particularly for large n: the product quickly be-\ncomesfartoolarge.\nFortunately,itispossibletocomputemodularexponen-\ntiation much more efficiently. This is done by splitting the\nproblem up into smaller sub-problems. For example, in-\nsteadofcomputing220 directlyyoucouldsplititup:\n220 = (210)2\n210 issomethingyoucancomputeonyourhands: startat2,\nwhich is 21, and then keep multiplying by two. Every time\nyou multiply by two, the exponent goes up by 1, so by the\ntimeyouʼvecountedallyourfingers(assumingyouhaveten\nofthem),youʼredone. Theresultis1024. So:\n220 ≡ (210 mod 15)2 (mod 15)\n≡ (1024 mod 15)2 (mod 15)\n≡ 42 (mod 15)\n≡ 16 (mod 15)\n≡ 1 (mod 15)\nA.6 Exponentiation by squaring\nA particularly efficient way to do it on computers is split-\nting the exponent up into a sum of powers of two. This\nis called exponentiation by squaring, or sometimes also bi-\nnary exponentiation. Suppose we want to compute 3209\n(mod 19). First,wesplitup209intoasumofpowersoftwo.\nThis process is essentially just writing 209 down in binary:\n0b11010001. Thatʼsverypracticalifthecomputationisbe-\ning performed by a computer, because thatʼs typically how\nAPPENDIXA. MODULARARITHMETIC 194\nthecomputerhadthenumberstoredinthefirstplace.\n209= 1·27 +1·26 +0·25 +1·24 +0·23+0·22+0·21+1·20\n= 1·128+1·64+0·32+1·16+0·8 +0·4 +0·2 +1·1\n= 128 +64 +16 +1\nWeusethatexpansionintoasumofpowersoftwotorewrite\ntheequation:\n3209 = 3128+64+16+1\n= 3128·364·316·31\nNow,weneedtocomputethoseindividualpowersof3: 1,16,\n64and128. Anicepropertyofthisalgorithmisthatwedonʼt\nactually have to compute the big powers separately from\nscratch. We can use previously computed smaller powers\ntocomputethelargerones. Forexample,weneedboth3128\n(mod 19)and364 (mod 19),butyoucanwritetheformerin\ntermsofthelatter:\n3128 mod 19 = (364 mod 19)2 (mod 19)\nLetʼs compute all the powers of 3 we need. For sake of\nbrevity,wewonʼtwritetheseoutentirely,butrememberthat\nalltricksweʼvealreadyseentocomputethesestillapply:\n316 ≡ 17 (mod 19)\n364 ≡ (316)4 ≡ 174 ≡ 16 (mod 19)\n3128 ≡ (364)2 ≡ 162 ≡ 9 (mod 19)\nFillingthesebackintoouroldequation:\n3209 = 3128·364·316·31 (mod 19)\n≡ 9·16·17·3 (mod 19)\nThistrickisparticularlyinterestingwhentheexponentisa\nvery large number. That is the case in many cryptographic\napplications. Forexample,inRSAdecryption,theexponent"
  },
  {
    "input": "Montgomery ladder exponentiation",
    "output": "APPENDIXA. MODULARARITHMETIC 195\nistheprivatekeyd, whichisusuallymorethanathousand\nbits long. Keep in mind that this method will still leak tim-\ninginformation,soitʼsonlysuitableforofflinecomputation.\nModularexponentiationcanalsobecomputedusingatech-\nnique called a Montgomery ladder, which weʼll see in the\nnextsection.\nManyprogramminglanguagesprovideaccesstospecific\nmodularexponentiationfunctions. Forexample,inPython,\npow(e, x, m)performsefficientmodularexponentiation.\nHowever,theexpression(e ** x) % mwillstillusethein-\nefficientmethod.\nA.7 Montgomery ladder exponentiation\nAs we mentioned before, the exponentiation by squaring\nalgorithm is simple and fast, but the time it takes to com-\npletedependsonthevalueoftheexponent. Thatʼsbad,be-\ncausetheexponentisusuallyasecretvalue,suchasaDiffie-\nHellmansecretortheprivateexponentdinRSA.\nThe Montgomery ladder is an algorithm that resolves\nthis by guaranteeing the same number of operations irre-\nspectiveoftheparticularvalueoftheexponent. Itwasorigi-\nnallyappliedforefficientscalarmultiplicationsoverelliptic\ncurves,butthemathematicsworksformanyothersystems:\nspecifically,foranyabeliangroup. [JY02]\nDerivingtheladder\nThisisanoptional,in-depthsection. It\nalmost certainly wonʼt help you write bet-\ntersoftware,sofeelfreetoskipit. Itisonly\nheretosatisfyyourinnergeekʼscuriosity.\nThis section involves a good deal of\narithmetictricks. Youmightwanttogetoutsomepaper\nandpenciltofollowalong.\nAPPENDIXA. MODULARARITHMETIC 196\nLike with exponentiation by squaring, we start by looking\natthebinaryexpansionofPtheexponentk. Generally,anyk\ncan be written as a sum ( ) of some powers of two (2i). If\n2j appearsinthebinaryexpansion, weʼllsaythatk = 1; if\nj\nitdoesnʼt,weʼllsaythatk = 0. Thatgivesus:\nj\nXt−1\nk = 2ik\ni\ni=0\nThat definition might look scary, but all youʼre really doing\nhereisdefiningk asbitofkatpositioni. Thesumgoesover\ni\nallthebits: ifk istbitslong,andwestartindexingat0,the\nindexofthehighestbitist−1,andtheindexofthelowest\nbitis0. Forexample,thebinaryexpansionofthenumber6\nis0b110. Thatnumberisthreebitslong,sot = 3. So:\nXt−1\n6 = 2ik\ni\ni=0\nX2\n= 2ik\ni\ni=0\n= k ·22+k ·21+k ·20\n2 1 0\n= 1·22+1·21+0·20\nSo,(k ,k ,k ) = (1,1,0).\n2 1 0\nThenextfewstepsdonʼtmakealotofsenseuntilyousee\nthemcometogetherattheend, sobearwithmeandcheck\nthatthemathworksout. Weʼlldefinearelatedsum,L :\nj\nXt−1\nL =\n2i−jk\nj i\ni=j\nAPPENDIXA. MODULARARITHMETIC 197\nForexample,L (stillwithk = 6)becomes:\n1\nX2\nL =\n2i−1k\n1 i\ni=1\n= 21·k +20·k\n| {z }2 | {z }1\ni=2 i=1\n= 2·1+1·1\n= 3\nEssentially,L isjustkshiftedtotherightbyj bits. Shifting\nj\ntotherightbyonebitisthesamethingasflooringdivision\nbytwo,justlikeright-shiftingbyadecimaldigitisthesame\nthingasflooringdivisionby10. Forexample: 73,shiftedone\ndecimal digit to the right is 7; 0b101 (5) shifted one binary\ndigit (bit) to the right is 0b10 (2). Analogously, shifting left\nistheinverseoperation, andisequivalenttomultiplying by\ntwo.\nNext, weʼll perform a little arithmetical hocus pocus.\nFirstofall:\nL = 2·L +k\nj j+1 j\nWhile you can verify this arithmetically, the easiest way to\ncheckthisistothinkofitintermsofrightandleftshifts. If\nyoushiftktotherightbyj positions,that\nk = 0b110010111\nL = L = 0b1100101\nj 2\nL = L = 0b110010\nj+1 3\n2·L = 2·L = 0b1100100\nj+1 3\nYou can visually verify that L is indeed L , shifted one to\n2 3\ntheleft(whichisthesamethingasmultiplyingbytwo),plus\nthatonebitk that“felloff”whenshiftingright. k isthelast\nj j\nbitofL ;inthiscaseithappenstobe1,butitcouldequally\nj\nwellhavebeen0.\nAPPENDIXA. MODULARARITHMETIC 198\nWedefineanotherverysimplefunctionH :\nj\nH = L +1 ⇐⇒ L = H −1\nj j j j\nStartingfromourpreviousresult:\nL = 2·L +k\nj j+1 j\n⇓ (L = H −1)\nj+1 j+1\nL = L +k +H −1\nj j+1 j j+1\n⇓ (L = H −1)\nj+1 j+1\nL = 2·H +k −2\nj j+1 j\nWecancombinethesetoproduceaninductivewaytocom-\nputeL andH :\nj j\n(\n2L ifk = 0,\nj+1 j\nL =\nj\nL +H ifk = 1.\nj+1 j+1 j\n(\nL +H ifk = 0,\nj+1 j+1 j\nH =\nj\n2H ifk = 1.\nj+1 j\nRemember that weʼre doing this to compute gk. Letʼs write\ntheexponentiationout:\n( (cid:0) (cid:1)\ngLj =\ng2Lj+1 = gLj+1 2 ifk\nj\n= 0,\ngLj+1+Hj+1 = gLj+1 ·gHj+1 ifk\nj\n= 1.\n(\ngHj = gLj+1+Hj+ (cid:0) 1 = gL (cid:1) j+1 ·gHj+1 ifk j = 0,\ng2Hj+1 = gHj+1 2 ifk\nj\n= 1.\nRemember that L is k right-shifted by j bits, so L is k\nj 0\nshifted right by 0 bits, or just k itself. That means gk, the\nnumber weʼre trying to compute, is the same thing as gL0.\nBystartingatgLt−1 (graisedtothepoweroftheleftmostbit\nof k) and iteratively making our way down to gL0 = gk, we\nhaveanelegantinductivemethodforcomputinggkbasedon\ntwosimplerecursiverules.\nAPPENDIXA. MODULARARITHMETIC 199\nTheimportantpartaboutthisalgorithmistheconstant\nnumberofoperations. Ifk\nj\n= 0,computinggLj involvesone\nsquaringandgHj involvesonemultiplication; ifk\nj\n= 1, itʼs\ntheotherwayaround. Nomatterwhatanyofthebitsofkare,\nyouneedonesquaringoperationandonemultiplicationper\nbit.\nImplementingtheMontgomeryladderinPython\nThe Python implementation of this algorithm, applied to\nmodularexponentiation,issurprisinglyterse:\ndef montgomery(x, exponent, modulus):\nx1, x2 = x, x ** 2\nhigh_bit, *remaining_bits = bits(exponent)\nfor bit in remaining_bits:\nif bit == 0:\nx2 = x1 * x2\nx1 = x1 ** 2\nelse:\nx1 = x1 * x2\nx2 = x2 ** 2\nx1, x2 = x1 % modulus, x2 % modulus\nreturn x1\nThis code block doesnʼt show the definition of bits: it\nproduces the binary expansion of its argument. Python\ndoesnʼt provide that by default; bin is close, but that pro-\nducesastring: bin(100)evaluatesto0b1100100. Thea,\n*b = bits(...)constructassignsthefirstiteminbits(.\n..)toa,andallremainingbitstob,effectivelyjustskipping\nthefirstbit.\nTheimportantthingtonotehereisthatnomatterwhat\ntheparticularvalueoftheexponentis,thereisonesquaring,\nonemultiplication,andonemodulooperationperbit. Keep\nin mind that this doesnʼt necessarily make the entire algo-\nrithm take constant time, because the individual squaring\nand multiplication operations are not necessarily constant\ntime."
  },
  {
    "input": "Discrete logarithm",
    "output": "APPENDIXA. MODULARARITHMETIC 200\nA.8 Discrete logarithm\nJustlikesubtractionistheinverseofaddition, anddivision\nistheinverseofmultiplication,logarithmsaretheinverseof\nexponentiation. Inregulararithmetic,bx = y,ifx = log y.\nb\nThis is pronounced “b raised to the power x is y”, and “the\nlogarithmofy withrespecttobisx”. Theequivalentofthis\ninmodulararithmeticiscalleda“discretelogarithm”.\nAs with division, if you start from the definition as the\ninverseof a differentoperator, itʼseasyto come upwith ex-\namples. For example, since 36 ≡ 9 (mod 15), we can de-\nfine6 ≡ log 9 (mod 15). Unlikemodularinverses,comput-\n3\ning discrete logarithms is generally hard. There is no for-\nmalproofthatcomputingdiscretelogarithmsisintrinsically\ncomplex; we just havenʼt found any efficient algorithms to\ndo it. Because this field has gotten extensive research and\nwestilldonʼthaveveryfastgeneralalgorithms,weconsider\nit safe to base the security of protocols on the assumption\nthatcomputingdiscretelogsishard.\nThere is one theoretical algorithm for computing dis-\ncretelogarithmsefficiently. However,itrequiresaquantum\ncomputer, which is a fundamentally different kind of com-\nputerfromtheclassicalcomputersweusetoday. Whilewe\ncanbuildsuchcomputers,wecanonlybuildverysmallones.\nThe limited size of our quantum computers strongly limits\nwhichproblemswecansolve. Sofar,theyʼremuchmorein\nthe realm of the kind of arithmetic a child can do in their\nhead, than ousting the top of the line classical computers\nfromtheperformancethrone.\nThe complexity of computing discrete logarithms, to-\ngether with the relative simplicity of computing its inverse,\nmodular exponentiation, is the basis for many public key\ncryptosystems. CommonexamplesincludetheRSAencryp-\ntion primitive, and the Diffie-Hellman key exchange proto-\ncol.\nWhile cryptosystems based on the discrete logarithm\nproblem are currently considered secure with appropri-"
  },
  {
    "input": "Multiplicative order",
    "output": "APPENDIXA. MODULARARITHMETIC 201\nate parameter choices, there are certainly ways that could\nchangeinthefuture. Forexample:\n• Theoretical breakthroughs in number theory could\nmake discrete logarithms significantly easier to com-\nputethanwecurrentlythink.\n• Technological breakthroughs in quantum computing\ncouldleadtolargeenoughquantumcomputers.\n• Technological breakthroughs in classical computing\nas well as the continuous gradual increases in perfor-\nmance and decreases in cost could increase the size\nof some problems that can be tackled using classical\ncomputers.\nDiscrete logarithm computation is tightly linked to the\nproblemofnumberfactorization. Theyarestillareasofac-\ntivemathematicalresearch;thelinksbetweenthetwoprob-\nlems are still not thoroughly understood. That said, there\naremanysimilaritiesbetweenthetwo:\n• Both are believed to be hard to compute on classical\ncomputers,butneitherhasaproofofthatfact.\n• They can both be efficiently computed on quantum\ncomputersusingShorʼsalgorithm.\n• Mathematical advances in one are typically quickly\nturnedintomathematicaladvancesintheother.\nA.9 Multiplicative order\nGivenintegeraandpositiveintegerbwithgcd(a,b) = 1,the\nmultiplicativeorderofa (mod b)isthesmallestpositiveinte-\ngerksuchthatak = 1 (mod b)."
  },
  {
    "input": "Elliptic curves",
    "output": "B\nElliptic curves\nLikemodulararithmetic,ellipticcurvearithmeticisusedfor\nmany public key cryptosystems. Many cryptosystems that\ntraditionally work with modular arithmetic, such as Diffie-\nHellmanandDSA,haveanellipticcurvecounterpart.\nEllipticcurvesarecurveswiththefollowingform:\ny2 = x3+ax+b\nThis is called the “short Weierstrass form”, and is the most\ncommonformwhentalkingaboutellipticcurvesingeneral.\nThere are several other forms which mostly have applica-\ntionsincryptography,notablytheEdwardsform:\nx2+y2 = 1+dx2y2\nWecandefineadditionofpointsonthecurve.\nTODO: Move the Abelian group thing somewhere else,\nsinceitappliestoourfieldsthingaswell\nAllofthisputtogetherformsomethingcalledanAbelian\ngroup. Thatʼs a scary-sounding mathematical term that al-\nmost everyone already understands the basics of. Specifi-\ncally,ifyouknowhowtoaddintegers(...−2,−1,0,1,2,...)\n202\nAPPENDIXB. ELLIPTICCURVES 203\ntogether, you already know an Abelian group. An Abelian\ngroupsatisfiesfiveproperties:\n1. If a and b are members of the Abelian group and ⋆ is\ntheoperator,thena⋆bisalsoamemberofthatAbelian\ngroup. Indeed,anytwointegersaddedtogetheralways\ngetyouanotherinteger. Thispropertyiscalledclosure,\nor, we say that the group is closed under addition (or\nwhateverthenameisoftheoperationweʼvedefined).\n2. Ifa,bandcaremembersoftheAbeliangroup,theor-\nder of operations doesnʼt matter; to put it differently:\nwe can move the brackets around. In equation form:\n(a⋆b)⋆c = a⋆(b⋆c). Indeed,theorderinwhichyou\naddintegerstogetherdoesnʼtmatter; theywillalways\nsumuptothesamevalue. Thispropertyiscalledasso-\nciativity,andthegroupissaidtobeassociative.\n3. Thereʼsexactlyoneidentityelementi,forwhicha⋆i =\ni ⋆ a = a. For integer addition, thatʼs zero: a + 0 =\n0+a = aforalla.\n4. For each element a, thereʼs exactly one inverse ele-\nmentb,forwhicha⋆b = b⋆a = i,whereiistheiden-\ntityelement. Indeed,forintegeraddition,a+(−a) =\n(−a)+a = 0foralla.\n5. Theorderofelementsdoesnʼtmatterfortheresultof\ntheoperation. Forallelementsa,b,a⋆b = b⋆a. This\nisknownascommutativity,andthegroupissaidtobe\ncommutative.\nThefirstfourpropertiesarecalledgrouppropertiesand\nmakesomethingagroup;thelastpropertyiswhatmakesa\ngroupAbelian.\nWecanseethatourellipticcurve,withthepointatinfin-\nityandtheadditionoperator,formsanAbeliangroup:\n1. If P and Q are two points on the elliptic curve, then\nP +Qisalsoalwaysapointonthecurve."
  },
  {
    "input": "The elliptic curve discrete log problem",
    "output": "APPENDIXB. ELLIPTICCURVES 204\n2. IfP,Q,andRareallpointsonthecurve,thenP+(Q+\nR) = (P +Q)+R,sotheellipticcurveisassociative.\n3. Thereʼsanidentityelement,ourpointatinfinityO. For\nallpointsonthecurveP,P +O = O+P = P.\n4. Each element has an inverse element. This is easiest\nexplainedvisuallyTODO:Explainvisually\n5. Theorderofoperationsdoesnʼtmatter,P+Q = Q+P\nforallP,Qonthecurve.\nB.1 The elliptic curve discrete log problem\nTODO:explainfully\nAs with the regular discrete log problem, the elliptic\ncurve discrete log problem doesnʼt actually have a formal\nproofthattheoperationis“hard”toperform: wejustknow\nthat there is no publicly available algorithm to do it effi-\nciently. Itʼs possible, however unlikely, that someone has\na magicalalgorithm that makesthe problemeasy, and that\nwould break elliptic curve cryptography completely. Itʼs\nfar more likely that we will see a stream of continuous\nimprovements, which coupled with increased computing\npowereventuallyeatawayatthesecurityofthealgorithm."
  },
  {
    "input": "Power measurement attacks",
    "output": "C\nSide-channel attacks\nC.1 Timing attacks\nAEScachetiming\nhttp://tau.ac.il/~tromer/papers/cache.pdf\nEllipticcurvetimingattacks\nTODO:Explainwhytheedwardsformisgreat?\nC.2 Power measurement attacks\nTODO:Saysomethinghere.\n205"
  },
  {
    "input": "Glossary",
    "output": "Part V\nGlossary\n206\nAPPENDIXC. SIDE-CHANNELATTACKS 207\nAEAD AuthenticatedEncryptionwithAssociatedData\nAEADmode Classofblockcipher modeofoperationthatpro-\nvidesauthenticatedencryption,aswellasauthenticat-\ningsomeunencryptedassociateddata\nAES AdvancedEncryptionStandard\nAKE authenticatedkeyexchange\nARX add,rotate,XOR\nasymmetric-keyalgorithm Seepublic-keyalgorithm\nasymmetric-keyencryption Seepublic-keyencryption\nBEAST BrowserExploitAgainstSSL/TLS\nblockcipher Symmetric encryption algorithm that en-\ncryptsanddecryptsblocksoffixedsize\nCarter-WegmanMAC Reusable message authentication code\nschemebuiltfromaone-timeMAC.Combinesbenefits\nofperformanceandeaseofuse\nCBC cipherblockchaining\nCBCmode Cipher block chaining mode; common mode\nof operation where the previous ciphertext block is\nXORed with the plaintext block during encryption.\nTakesaninitializationvector, whichassumestherole\nofthe“blockbeforethefirstblock”\nCDN contentdistributionnetwork\ncross-siterequestforgery Kind of attack where a mali-\nciouswebsitetricksthebrowserintomakingrequests\nto another website. Can be prevented by properly au-\nthenticatingrequestsinsteadofrelyingonambientau-\nthoritysuchassessioncookies\nAPPENDIXC. SIDE-CHANNELATTACKS 208\nCSPRNG cryptographically secure pseudorandom number\ngenerator\nCSRF cross-siterequestforgery\nCTRmode Countermode;anoncecombinedwithacounter\nproducesasequenceofinputstotheblockcipher;the\nresultingciphertextblocksarethekeystream\nDES DataEncryptionStandard\nECBmode Electronic code book mode; mode of operation\nwhere plaintext is separated into blocks that are en-\ncrypted separately under the same key. The default\nmode in many cryptographic libraries, despite many\nsecurityissues\nencryptionoracle Anoraclethatwillencryptsomedata\nFIPS FederalInformationProcessingStandards\nGCM GaloisCounterMode\nGCMmode Galois counter mode; AEAD mode combining\nCTRmodewithaCarter-WegmanMAC\nGMAC message authentication code part of GCM mode used\nseparately\nHKDF HMAC-based (Extract-and-Expand) Key Derivation\nFunction\nHMAC Hash-basedMessageAuthenticationCode\nHSTS HTTPStrictTransportSecurity\ninitializationvector Data used to initialize some algo-\nrithms such as CBC mode. Generally not required to\nbesecret,butrequiredtobeunpredictable. Compare\nnonce,salt\nIV initializationvector\nAPPENDIXC. SIDE-CHANNELATTACKS 209\nKDF keyderivationfunction\nkeyagreement Seekeyexchange\nkeyexchange Theprocessofexchangingkeysacrossanin-\nsecuremediumusingaparticularcryptographicproto-\ncol. Typicallydesignedtobesecureagainsteavesdrop-\npers. Alsoknownaskeyagreement\nkeyspace Thesetofallpossiblekeys\nMAC messageauthenticationcode\nmessageauthenticationcode Small piece of information\nused to verify authenticity and integrity of a message.\nOftencalledatag\nMITM man-in-the-middle\nmodeofoperation\nmodesofoperation Generic construction that encrypts\nanddecryptsstreams,builtfromablockcipher\nnonce Number used once. Used in many cryptographic\nprotocols. Generallydoesnothavetobesecretorun-\npredictable,butdoeshavetobeunique. Compareini-\ntializationvector,salt\nOCB offsetcodebook\nOCBmode Offset codebook mode; high-performance\nAEADmode,unfortunatelyencumberedbypatents\none-timeMAC messageauthenticationcode thatcanonlybe\nusedsecurelyforasinglemessage. Mainbenefitisin-\ncreasedperformanceoverre-usableMAC\noracle A “black box” that will perform some computation\nforyou\nOTR off-the-record\nAPPENDIXC. SIDE-CHANNELATTACKS 210\nOTRmessaging Off-the-record messaging, messaging pro-\ntocol that intends to mimic the properties of a real-\nlifeprivateconversation. Piggy-backsontoexistingin-\nstantmessagingprotocols\nPRF pseudorandomfunction\nPRNG pseudorandomnumbergenerator\nPRP pseudorandompermutation\npublic-keyalgorithm Algorithm that uses a pair of two re-\nlated but distinct keys. Also known as asymmetric-key\nalgorithm. Examplesincludepublic-keyencryptionand\nmostkeyexchangeprotocols\npublic-keyencryption Encryption using a pair of distinct\nkeys for encryption and decryption. Also known as\nasymmetric-key encryption. Contrast with secret-key\nencryption\nRSA RivestShamirAdleman\nsalt Randomdatathatisaddedtoacryptographicprimitive\n(usually a one-way function such as a cryptographic\nhashfunctionorakeyderivationfunction)Customizes\nsuchfunctionstoproducedifferentoutputs(provided\nthesaltisdifferent). Canbeusedtoprevente.g. dictio-\nnaryattacks. Typicallydoesnothavetobesecret,but\nsecrecymayimprovesecuritypropertiesofthesystem.\nComparenonce,initializationvector\nsecret-keyencryption Encryption that uses the same key\nfor both encryption and decryption. Also known as\nsymmetric-keyencryption. Contrastwithpublic-keyen-\ncryption\nSMP socialistmillionaireprotocol\nstreamcipher Symmetric encryption algorithm that en-\ncryptsstreamsofarbitrarysize\nAPPENDIXC. SIDE-CHANNELATTACKS 211\nsubstitution-permutationnetwork Generic design for\nblock ciphers where the block is enciphered by\nrepeatedsubstitutionsandpermutations\nsymmetric-keyencryption Seesecret-keyencryption"
  },
  {
    "input": "Index",
    "output": "Index\nA\nAEAD,207\nAEAD mode,207\nAES,207\nAKE,207\nARX,207\nasymmetric-key algorithm,207\nasymmetric-key encryption,207\nB\nBEAST,207\nblock cipher,207\nC\nCarter-Wegman MAC,207\nCBC,207\nCBC mode,207\nCDN,207\ncross-site request forgery,207\nCSPRNG,208\nCSRF,208\nCTR mode,208\nD\nDES,208\n212\nAPPENDIXC. SIDE-CHANNELATTACKS 213\nE\nECB mode,208\nencryption oracle,208\nF\nFIPS,208\nG\nGCM,208\nGCM mode,208\nGMAC,208\nH\nHKDF,208\nHMAC,208\nHSTS,208\nI\ninitialization vector,208\nIV,208\nK\nKDF,209\nkey agreement,209\nkey exchange,209\nkeyspace,209\nM\nMAC,209\nmessage authentication code,209\nMITM,209\nmode of operation,209\nmodes of operation,209\nN\nnonce,209\nAPPENDIXC. SIDE-CHANNELATTACKS 214\nO\nOCB,209\nOCB mode,209\none-time MAC,209\noracle,209\nOTR,209\nOTR messaging,210\nP\nPRF,210\nPRNG,210\nPRP,210\npublic-key algorithm,210\npublic-key encryption,210\nR\nRSA,210\nS\nsalt,210\nsecret-key encryption,210\nSMP,210\nstream cipher,210\nsubstitution-permutation network,211\nsymmetric-key encryption,211"
  },
  {
    "input": "Bibliography",
    "output": "Bibliography\n[fip01] Specification for the Advanced Encryption\nStandard (AES). Federal Information Process-\ning Standards Publication 197, 2001. URL:\nhttp://csrc.nist.gov/publications/\nfips/fips197/fips-197.pdf.\n[gcm07] NIST special publication 800-38d: recom-\nmendation for block cipher modes of opera-\ntion: Galois/Counter Mode (GCM) and GMAC.\nNovember 2007. URL: http://csrc.nist.\ngov/publications/nistpubs/800-38D/\nSP-800-38D.pdf.\n[ABP+] Nadhem AlFardan, Dan Bernstein, Kenny Pater-\nson, Bertram Poettering, and Jacob Schuldt. On\nthe security of RC4 in TLS and WPA. URL: http:\n//www.isg.rhul.ac.uk/tls/.\n[AV96] Ross Anderson and Serge Vaudenay. Minding\nyour pʼs and qʼs. In In Advances in Cryptology\n- ASIACRYPT’96, LNCS 1163, 26–35. Springer-\nVerlag, 1996. URL: http://www.cl.cam.ac.\nuk/~rja14/Papers/psandqs.pdf.\n[BK12] Elaine Barker and John Kelsey. Nist spe-\ncial publication 800-90a recommendation\nfor random number generation using deter-\nministic random bit generators. 2012. URL:\n216\nAPPENDIXC. SIDE-CHANNELATTACKS 217\nhttp://csrc.nist.gov/publications/\nnistpubs/800-90A/SP800-90A.pdf.\n[Bel06] Mihir Bellare. New proofs for NMAC and HMAC:\nsecurity without collision-resistance. 2006. URL:\nhttp://cseweb.ucsd.edu/~mihir/papers/\nhmac-new.html.\n[BCK96] Mihir Bellare, Ran Canetti, and Hugo\nKrawczyk. Keying hash functions for mes-\nsage authentication. In 1–15. Springer-Verlag,\n1996. URL: http://www.ssrc.ucsc.edu/\nPaperArchive/bellare-lncs96.pdf.\n[BN07] Mihir Bellare and Chanathip Namprempre. Au-\nthenticated encryption: relations among no-\ntions and analysis of the generic composition\nparadigm. 2007. URL: http://cseweb.ucsd.\nedu/~mihir/papers/oem.pdf.\n[BR95] Mihir Bellare and Phillip Rogaway. Optimal\nAsymmetric Encryption – How to encrypt with\nRSA. Advances in Cryptology - EUROCRYPT ‘94\n- Lecture Notes in Computer Science, 1995. URL:\nhttp://www-cse.ucsd.edu/users/mihir/\npapers/oae.pdf.\n[Ber] D. J. Bernstein. Snuffle 2005: the Salsa20 en-\ncryption function. URL: http://cr.yp.to/\nsnuffle.html#speed.\n[BDK+09] Alex Biryukov, Orr Dunkelman, Nathan Keller,\nDmitry Khovratovich, and Adi Shamir. Key re-\ncovery attacks of practical complexity on AES\nvariants with up to 10 rounds. Cryptology ePrint\nArchive, Report 2009/374, 2009. URL: http://\neprint.iacr.org/2009/374.\n[BK09] AlexBiryukovandDmitryKhovratovich.Related-\nkeycryptanalysisofthefullAES-192andAES-256.\nAPPENDIXC. SIDE-CHANNELATTACKS 218\nCryptology ePrint Archive, Report 2009/317, 2009.\nURL:http://eprint.iacr.org/2009/317.\n[BHK+] John Black, Shai Halevi, Hugo Krawczyk, Ted\nKrovetz, and Phillip Rogaway. RFC 4418: UMAC:\nMessage Authentication Code using Universal\nHashing. URL: https://www.ietf.org/rfc/\nrfc4418.txt.\n[BHK+99] John Black, Shai Halevi, Hugo Krawczyk, Ted\nKrovetz, and Phillip Rogaway. UMAC: Fast and\nSecure Message Authentication. 1999. URL:\nhttp://www.cs.ucdavis.edu/~rogaway/\npapers/umac-full.pdf.\n[Bon99] Dan Boneh. Twenty years of attacks on the RSA\ncryptosystem. Notices of the AMS, 46:203–213,\n1999. URL: http://crypto.stanford.edu/\ndabo/papers/RSA-survey.pdf.\n[BGB04] NikitaBorisov,IanGoldberg,andEricBrewer.Off-\nthe-recordcommunication,or,whynottousePGP.\nWPES‘04: Proceedingsofthe2004ACMworkshopon\nPrivacyintheelectronicsociety,2004.URL:https:\n//otr.cypherpunks.ca/otr-wpes.pdf.\n[BGjosteen07] Daniel R. L. Brown and Kristian Gjøsteen.\nA security analysis of the nist sp 800-90 ellip-\ntic curve random number generator. Cryptology\nePrintArchive,Report2007/048,2007.URL:http:\n//eprint.iacr.org/2007/048.pdf.\n[DR02] Joan Daemen and Vincent Rijmen. The design of\nRijndael: AES — the Advanced Encryption Standard.\nSpring er-Ver lag,2002.ISBN3-540-42580-2.\n[Dai] WeiDai.Crypto++5.6.0benchmarks.URL:http:\n//www.cryptopp.com/benchmarks.html.\nAPPENDIXC. SIDE-CHANNELATTACKS 219\n[dBB93] Bert den Boer and Antoon Bosselaers. Collisions\nfor the compression function of MD5. In Tor\nHelleseth, editor, Advances in Cryptology - EU-\nROCRYPT 1993, volume 765 of Lecture Notes\nin Computer Science, 293–304. Lofthus,N, 1993.\nURL: https://www.cosic.esat.kuleuven.\nbe/publications/article-143.pdf.\n[DR] T.DierksandE.Rescorla.RFC5246: thetransport\nlayer security (TLS) protocol, version 1.2. URL:\nhttps://tools.ietf.org/html/rfc5246.\n[ECR] ECRYPT. Measurements of SHA-3 finalists, in-\ndexed by machine. URL: https://bench.cr.\nyp.to/results-sha3.html.\n[FS99] Niels Ferguson and Bruce Schneier. A crypto-\ngraphicevaluationofipsec.1999.URL:https://\nwww.schneier.com/paper-ipsec.pdf.\n[FMS01] Scott Fluhrer, Itsik Mantin, and Adi\nShamir. Weaknesses in the key schedul-\ning algorithm of RC4. In 1–24. 2001. URL:\nhttp://www.wisdom.weizmann.ac.il/\n~itsik/RC4/Papers/Rc4_ksa.ps.\n[Gmb08] SciEngines GmbH. Break DES in less than\na single day. 2008. URL: http://www.\nsciengines.com/company/news-a-events/\n74-des-in-1-day.html.\n[HJB] J.Hodges,C.Jackson,andA.Barth.RFC6797: http\nstrict transport security (HSTS). URL: https://\ntools.ietf.org/html/rfc6797.\n[Hol] S.Hollenbeck.RFC3749: transportlayersecurity\nprotocol compression methods. URL: https://\ntools.ietf.org/html/rfc3749.\nAPPENDIXC. SIDE-CHANNELATTACKS 220\n[Hou] R.Housley.RFC5652: cryptographicmessagesyn-\ntax (CMS). URL: https://tools.ietf.org/\nhtml/rfc5652#section-6.3.\n[Hua] Sinan Huang. Hardware evaluation of SHA-3 can-\ndidates. URL: https://theses.lib.vt.edu/\ntheses/available/etd-05172011-141328/\nunrestricted/Huang_S_T_2011.pdf.\n[JY02] Marc Joye and Sung-Ming Yen. The montgomery\npoweringladder.2002.URL:http://cr.yp.to/\nbib/2003/joye-ladder.pdf.\n[Kle08] Andreas Klein. Attacks on the RC4 stream cipher.\nDes.CodesCryptography,48(3):269–286,September\n2008. URL: http://cage.ugent.be/~klein/\npapers/RC4-en.pdf, doi:10.1007/s10623-008-\n9206-6.\n[Kra01] Hugo Krawczyk. The order of encryption\nand authentication for protecting commu-\nnications (or: how secure is SSL?). 2001.\nURL: http://www.iacr.org/archive/\ncrypto2001/21390309.pdf.\n[Kra10] HugoKrawczyk.Cryptographicextractionandkey\nderivation: the HKDF scheme. Cryptology ePrint\nArchive, Report 2010/264, 2010. URL: http://\neprint.iacr.org/2010/264.\n[KE] Hugo Krawczyk and Pasi Eronen. RFC 5869:\nHMAC-based extract-and-expand key derivation\nfunction (HKDF). URL: https://tools.ietf.\norg/html/rfc5869.\n[Lab] RSA Laboratories. What key size should be used?\nURL: http://www.emc.com/emc-plus/\nrsa-labs/standards-initiatives/\nkey-size.htm.\nAPPENDIXC. SIDE-CHANNELATTACKS 221\n[LWdW05] Arjen Lenstra, Xiaoyun Wang, and Benne\nde Weger. Colliding x.509 certificates. Cryptol-\nogy ePrint Archive, Report 2005/067, 2005. URL:\nhttp://eprint.iacr.org/2005/067.\n[Mar11] Moxie Marlinspike. The cryptographic\ndoom principle. 2011. URL: http:\n//www.thoughtcrime.org/blog/\nthe-cryptographic-doom-principle/.\n[MWES06] Joshua Mason, Kathryn Watkins, Jason Eis-\nner, and Adam Stubblefield. A natural lan-\nguage approach to automated cryptanalysis\nof two-time pads. In Proceedings of the 13th\nACM conference on Computer and Communica-\ntions Security, CCS ʻ06, 235–244. New York, NY,\nUSA, 2006. ACM. URL: http://www.cs.jhu.\nedu/~jason/papers/mason+al.ccs06.pdf,\ndoi:10.1145/1180405.1180435.\n[MHMP13] Elke De Mulder, Michael Hutter, Mark E. Mar-\nson, and Peter Pearson. Using Bleichenbacherʼs\nsolution to the hidden number problem to attack\nnonce leaks in 384-bit ECDSA. Cryptology ePrint\nArchive, Report 2013/346, 2013. URL: http://\neprint.iacr.org/2013/346.pdf.\n[NS00] Phong Q. Nguyen and Igor E. Shparlinski. The\ninsecurityoftheDigitalSignatureAlgorithmwith\npartially known nonces. Journal of Cryptology,\n15:151–176, 2000. URL: ftp://ftp.ens.fr/\npub/dmi/users/pnguyen/PubDSA.ps.gz.\n[Rog] Philip Rogaway. OCB - An Authenticated-\nEncryption Scheme - Licensing. URL:\nhttp://www.cs.ucdavis.edu/~rogaway/\nocb/license.htm.\nAPPENDIXC. SIDE-CHANNELATTACKS 222\n[SS08] SomitraKumarSanadhyaandPalashSarkar.New\ncollisionattacksagainstupto24-stepSHA-2.2008.\nURL:http://eprint.iacr.org/2008/270.\n[SS06] Berry Schoenmakers and Andrey Sidorenko.\nCryptanalysis of the dual elliptic curve\npseudorandom generator. 2006. URL:\nhttp://www.cosic.esat.kuleuven.be/\nwissec2006/papers/21.pdf.\n[SBK+] Marc Stevens, Elie Bursztein, Pierre Karpman,\nAnge Albertini, and Yarik Markov. The first colli-\nsion for full SHA-1. URL: https://shattered.\nit/static/shattered.pdf.\n[SKP15] Marc Stevens, Pierre Karpman, and Thomas\nPeyrin.FreestartcollisionforfullSHA-1.Cryptol-\nogy ePrint Archive, Report 2015/967, 2015. URL:\nhttp://eprint.iacr.org/2015/967.\n[TP] S. Turner and T. Polk. RFC 6176: prohibiting se-\ncuresocketslayer(SSL)version2.0.URL:https:\n//tools.ietf.org/html/rfc6176.\n[Vau] Serge Vaudenay. Security flaws induced by CBC\npadding applications to SSL, IPSec, WTLS… URL:\nhttp://www.iacr.org/cryptodb/archive/\n2002/EUROCRYPT/2850/2850.pdf.\n[WFLY04] Xiaoyun Wang, Dengguo Feng, Xuejia Lai, and\nHongbo Yu. Collisions for hash functions MD4,\nMD5,HAVAL-128andRIPEMD.CryptologyePrint\nArchive, Report 2004/199, 2004. URL: http://\neprint.iacr.org/2004/199.\n[WYW+09] Xiaoyun Wang, Hongbo Yu, Wei Wang,\nHaina Zhang, and Tao Zhan. Cryptanalysis on\nHMAC/NMAC-MD5 and MD5-MAC. In Advances\nin Cryptology - EUROCRYPT 2009, 28th Annual\nAPPENDIXC. SIDE-CHANNELATTACKS 223\nInternational Conference on the Theory and Appli-\ncations of Cryptographic Techniques, volume 5479\nof Lecture Notes in Computer Science, 121–133.\n2009. URL: http://www.iacr.org/archive/\neurocrypt2009/54790122/54790122.pdf,\ndoi:10.1007/978-3-642-01001-9_7.\n[InstitutefStandardsTechnology] National Institute for\nStandards and Technology. Sp800-57: rec-\nommendation for key management – part 1:\ngeneral (revised). URL: http://csrc.nist.\ngov/publications/nistpubs/800-57/\nsp800-57_part1_rev3_general.pdf."
  }
]