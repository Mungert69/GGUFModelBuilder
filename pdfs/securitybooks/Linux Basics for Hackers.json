[
  {
    "input": "Title Page",
    "output": "LINUX BASICS FOR HACKERS\nGetting Started with Networking, Scripting, and Security\nin Kali\nby OccupyTheWeb\nSan Francisco"
  },
  {
    "input": "Copyright Page",
    "output": "LINUX BASICS FOR HACKERS. Copyright © 2019 by OccupyTheWeb.\nAll rights reserved. No part of this work may be reproduced or transmitted in any form or by any\nmeans, electronic or mechanical, including photocopying, recording, or by any information storage or\nretrieval system, without the prior written permission of the copyright owner and the publisher.\nISBN-10: 1-59327-855-1\nISBN-13: 978-1-59327-855-7\nPublisher: William Pollock\nProduction Editors: Serena Yang and Meg Sneeringer\nCover Illustration: Josh Ellingson\nInterior Design: Octopod Studios\nDevelopmental Editor: Liz Chadwick\nTechnical Reviewer: Cliff Janzen\nCopyeditor: Barton D. Reed\nCompositors: Serena Yang and Meg Sneeringer\nProofreader: Paula L. Fleming\nIndexer: JoAnne Burek\nFor information on distribution, translations, or bulk sales, please contact No Starch Press, Inc.\ndirectly:\nNo Starch Press, Inc.\n245 8th Street, San Francisco, CA 94103\nphone: 1.415.863.9900; info@nostarch.com\nwww.nostarch.com\nLibrary of Congress Cataloging-in-Publication Data\nNames: OccupyTheWeb, author.\nTitle: Linux basics for hackers : getting started with networking, scripting,\nand security in Kali / OccupyTheWeb.\nDescription: First edition. | San Francisco : No Starch Press, Inc., [2018].\nIdentifiers: LCCN 2018030544 (print) | LCCN 2018032646 (ebook) | ISBN\n9781593278564 (epub) | ISBN 159327856X (epub) | ISBN 9781593278557 (print)\n| ISBN 1593278551 (print) | ISBN 9781593278564 (ebook) | ISBN 159327856X\n(ebook)\nSubjects: LCSH: Penetration testing (Computer security) | Kali Linux. |\nHackers. | Operating systems (Computers)\nClassification: LCC QA76.9.A25 (ebook) | LCC QA76.9.A25 O325 2018 (print) |\nDDC 005.8--dc23\nLC record available at https://lccn.loc.gov/2018030544\nNo Starch Press and the No Starch Press logo are registered trademarks of No Starch Press, Inc.\nOther product and company names mentioned herein may be the trademarks of their respective\nowners. Rather than use a trademark symbol with every occurrence of a trademarked name, we are\nusing the names only in an editorial fashion and to the benefit of the trademark owner, with no\nintention of infringement of the trademark.\nThe information in this book is distributed on an “As Is” basis, without warranty. While every\nprecaution has been taken in the preparation of this work, neither the author nor No Starch Press, Inc.\nshall have any liability to any person or entity with respect to any loss or damage caused or alleged to\nbe caused directly or indirectly by the information contained in it."
  },
  {
    "input": "Dedication",
    "output": "I dedicate this book to my three incredible daughters.\nYou mean the world to me."
  },
  {
    "input": "About the Author",
    "output": "About the Author\nOccupyTheWeb (OTW) is the pseudonym for the founder and primary\nwriter for the hacker and pentester training website, https://www.hackers-\narise.com/. He is a former college professor and has over 20 years of\nexperience in the information technology industry. He has trained hackers\nthroughout the US, including branches of the US military (Army, Air Force,\nand Navy) and the US intelligence community (CIA, NSA, and DNI). He is\nalso an avid mountain biker and snow boarder."
  },
  {
    "input": "About the Technical Reviewer",
    "output": "About the Technical Reviewer\nSince the early days of Commodore PET and VIC-20, technology has been\na constant companion (and sometimes an obsession!) to Cliff Janzen. Cliff\ndiscovered his career passion when he moved to information security in 2008\nafter a decade of IT operations. Since then, Cliff has had the great fortune to\nwork with and learn from some of the best people in the industry including\nOccupyTheWeb and the fine people at No Starch during the production of\nthis book. He is happily employed as a security consultant, doing everything\nfrom policy review to penetration tests. He feels lucky to have a career that is\nalso his favorite hobby and a wife that supports him."
  },
  {
    "input": "BRIEF CONTENTS",
    "output": "BRIEF CONTENTS\nAcknowledgments\nIntroduction\nChapter 1: Getting Started with the Basics\nChapter 2: Text Manipulation\nChapter 3: Analyzing and Managing Networks\nChapter 4: Adding and Removing Software\nChapter 5: Controlling File and Directory Permissions\nChapter 6: Process Management\nChapter 7: Managing User Environment Variables\nChapter 8: Bash Scripting\nChapter 9: Compressing and Archiving\nChapter 10: Filesystem and Storage Device Management\nChapter 11: The Logging System\nChapter 12: Using and Abusing Services\nChapter 13: Becoming Secure and Anonymous\nChapter 14: Understanding and Inspecting Wireless Networks\nChapter 15: Managing the Linux Kernel and Loadable Kernel Modules\nChapter 16: Automating Tasks with Job Scheduling\nChapter 17: Python Scripting Basics for Hackers\nIndex"
  },
  {
    "input": "CONTENTS IN DETAIL",
    "output": "CONTENTS IN DETAIL\nACKNOWLEDGMENTS\nINTRODUCTION\nWhat’s in This Book\nWhat Is Ethical Hacking?\nPenetration Testing\nMilitary and Espionage\nWhy Hackers Use Linux\nLinux Is Open Source\nLinux Is Transparent\nLinux Offers Granular Control\nMost Hacking Tools Are Written for Linux\nThe Future Belongs to Linux/Unix\nDownloading Kali Linux\nVirtual Machines\nInstalling VirtualBox\nSetting Up Your Virtual Machine\nInstalling Kali on the VM\nSetting Up Kali\n1\nGETTING STARTED WITH THE BASICS\nIntroductory Terms and Concepts\nA Tour of Kali\nThe Terminal\nThe Linux Filesystem\nBasic Commands in Linux\nFinding Yourself with pwd\nChecking Your Login with whoami\nNavigating the Linux Filesystem\nGetting Help\nReferencing Manual Pages with man\nFinding Stuff\nSearching with locate\nFinding Binaries with whereis\nFinding Binaries in the PATH Variable with which\nPerforming More Powerful Searches with find\nFiltering with grep\nModifying Files and Directories\nCreating Files\nCreating a Directory\nCopying a File\nRenaming a File\nRemoving a File\nRemoving a Directory\nGo Play Now!\nExercises\n2\nTEXT MANIPULATION\nViewing Files\nTaking the Head\nGrabbing That Tail\nNumbering the Lines\nFiltering Text with grep\nHacker Challenge: Using grep, nl, tail, and head\nUsing sed to Find and Replace\nViewing Files with more and less\nControlling the Display with more\nDisplaying and Filtering with less\nSummary\nExercises\n3\nANALYZING AND MANAGING NETWORKS\nAnalyzing Networks with ifconfig\nChecking Wireless Network Devices with iwconfig\nChanging Your Network Information\nChanging Your IP Address\nChanging Your Network Mask and Broadcast Address\nSpoofing Your MAC Address\nAssigning New IP Addresses from the DHCP Server\nManipulating the Domain Name System\nExamining DNS with dig\nChanging Your DNS Server\nMapping Your Own IP Addresses\nSummary\nExercises\n4\nADDING AND REMOVING SOFTWARE\nUsing apt to Handle Software\nSearching for a Package\nAdding Software\nRemoving Software\nUpdating Packages\nUpgrading Packages\nAdding Repositories to Your sources.list File\nUsing a GUI-based Installer\nInstalling Software with git\nSummary\nExercises\n5\nCONTROLLING FILE AND DIRECTORY PERMISSIONS\nDifferent Types of Users\nGranting Permissions\nGranting Ownership to an Individual User\nGranting Ownership to a Group\nChecking Permissions\nChanging Permissions\nChanging Permissions with Decimal Notation\nChanging Permissions with UGO\nGiving Root Execute Permission on a New Tool\nSetting More Secure Default Permissions with Masks\nSpecial Permissions\nGranting Temporary Root Permissions with SUID\nGranting the Root User’s Group Permissions SGID\nThe Outmoded Sticky Bit\nSpecial Permissions, Privilege Escalation, and the Hacker\nSummary\nExercises\n6\nPROCESS MANAGEMENT\nViewing Processes\nFiltering by Process Name\nFinding the Greediest Processes with top\nManaging Processes\nChanging Process Priority with nice\nKilling Processes\nRunning Processes in the Background\nMoving a Process to the Foreground\nScheduling Processes\nSummary\nExercises\n7\nMANAGING USER ENVIRONMENT VARIABLES\nViewing and Modifying Environment Variables\nViewing All Environment Variables\nFiltering for Particular Variables\nChanging Variable Values for a Session\nMaking Variable Value Changes Permanent\nChanging Your Shell Prompt\nChanging Your PATH\nAdding to the PATH Variable\nHow Not to Add to the PATH Variable\nCreating a User-Defined Variable\nSummary\nExercises\n8\nBASH SCRIPTING\nA Crash Course in Bash\nYour First Script: “Hello, Hackers-Arise!”\nSetting Execute Permissions\nRunning HelloHackersArise\nAdding Functionality with Variables and User Input\nYour Very First Hacker Script: Scan for Open Ports\nOur Task\nA Simple Scanner\nImproving the MySQL Scanner\nCommon Built-in Bash Commands\nSummary\nExercises\n9\nCOMPRESSING AND ARCHIVING\nWhat Is Compression?\nTarring Files Together\nCompressing Files\nCompressing with gzip\nCompressing with bzip2\nCompressing with compress\nCreating Bit-by-Bit or Physical Copies of Storage Devices\nSummary\nExercises\n10\nFILESYSTEM AND STORAGE DEVICE MANAGEMENT\nThe Device Directory /dev\nHow Linux Represents Storage Devices\nDrive Partitions\nCharacter and Block Devices\nList Block Devices and Information with lsblk\nMounting and Unmounting\nMounting Storage Devices Yourself\nUnmounting with umount\nMonitoring Filesystems\nGetting Information on Mounted Disks\nChecking for Errors\nSummary\nExercises\n11\nTHE LOGGING SYSTEM\nThe rsyslog Logging Daemon\nThe rsyslog Configuration File\nThe rsyslog Logging Rules\nAutomatically Cleaning Up Logs with logrotate\nRemaining Stealthy\nRemoving Evidence\nDisabling Logging\nSummary\nExercises\n12\nUSING AND ABUSING SERVICES\nStarting, Stopping, and Restarting Services\nCreating an HTTP Web Server with the Apache Web Server\nStarting with Apache\nEditing the index.html File\nAdding Some HTML\nSeeing What Happens\nOpenSSH and the Raspberry Spy Pi\nSetting Up the Raspberry Pi\nBuilding the Raspberry Spy Pi\nConfiguring the Camera\nStarting to Spy\nExtracting Information from MySQL\nStarting MySQL\nInteracting with MySQL\nSetting a MySQL Password\nAccessing a Remote Database\nConnecting to a Database\nDatabase Tables\nExamining the Data\nPostgreSQL with Metasploit\nSummary\nExercises\n13\nBECOMING SECURE AND ANONYMOUS\nHow the Internet Gives Us Away\nThe Onion Router System\nHow Tor Works\nSecurity Concerns\nProxy Servers\nSetting Proxies in the Config File\nSome More Interesting Options\nSecurity Concerns\nVirtual Private Networks\nEncrypted Email\nSummary\nExercises\n14\nUNDERSTANDING AND INSPECTING WIRELESS NETWORKS\nWi-Fi Networks\nBasic Wireless Commands\nWi-Fi Recon with aircrack-ng\nDetecting and Connecting to Bluetooth\nHow Bluetooth Works\nBluetooth Scanning and Reconnaissance\nSummary\nExercises\n15\nMANAGING THE LINUX KERNEL AND LOADABLE KERNEL\nMODULES\nWhat Is a Kernel Module?\nChecking the Kernel Version\nKernel Tuning with sysctl\nManaging Kernel Modules\nFinding More Information with modinfo\nAdding and Removing Modules with modprobe\nInserting and Removing a Kernel Module\nSummary\nExercises\n16\nAUTOMATING TASKS WITH JOB SCHEDULING\nScheduling an Event or Job to Run on an Automatic Basis\nScheduling a Backup Task\nUsing crontab to Schedule Your MySQLscanner\ncrontab Shortcuts\nUsing rc Scripts to Run Jobs at Startup\nLinux Runlevels\nAdding Services to rc.d\nAdding Services to Your Bootup via a GUI\nSummary\nExercises\n17\nPYTHON SCRIPTING BASICS FOR HACKERS\nAdding Python Modules\nUsing pip\nInstalling Third-Party Modules\nGetting Started Scripting with Python\nVariables\nComments\nFunctions\nLists\nModules\nObject-Oriented Programming (OOP)\nNetwork Communications in Python\nBuilding a TCP Client\nCreating a TCP Listener\nDictionaries, Loops, and Control Statements\nDictionaries\nControl Statements\nLoops\nImproving Our Hacking Scripts\nExceptions and Password Crackers\nSummary\nExercises\nINDEX"
  },
  {
    "input": "ACKNOWLEDGMENTS",
    "output": "ACKNOWLEDGMENTS\nThis book could not have been written without the collaboration of several\nkey people.\nFirst, I want to thank and acknowledge Liz Chadwick for proposing this\nbook and being the primary editor of its content. Her persistence and\ndedication have made this book possible.\nSecond, I want to acknowledge Bill Pollock, publisher of No Starch\nPress, for believing in and backing this book.\nThird, I want to acknowledge the diligent efforts of my technical\nreviewer, Cliff Janzen, for making certain the technical content in this book\nis accurate.\nAny remaining errors or omissions are solely my fault.\nFinally, I want to thank and acknowledge all the dedicated professionals\nat No Starch Press for their efforts to bring to book to completion and to\nmarket. Thank you."
  },
  {
    "input": "INTRODUCTION",
    "output": "INTRODUCTION\nHacking is the most important skill set of the 21st century! I don’t make that\nstatement lightly. Events in recent years seem to reaffirm this statement with\nevery morning’s headline. Nations are spying on each other to gain secrets,\ncyber criminals are stealing billions of dollars, digital worms demanding\nransoms are being released, adversaries are influencing each other’s\nelections, and combatants are taking down each other’s utilities. These are\nall the work of hackers, and their influence over our increasingly digital\nworld is just beginning to be felt.\nI decided to write this book after working with tens of thousands of\naspiring hackers through Null-Byte, https://www.hackers-arise.com/, and\nnearly every branch of the US military and intelligence agencies (NSA, DIA,\nCIA, and FBI). These experiences have taught me that many aspiring\nhackers have had little or no experience with Linux, and this lack of\nexperience is the primary barrier to their starting the journey to becoming\nprofessional hackers. Almost all the best hacker tools are written in Linux, so\nsome basic Linux skills are a prerequisite to becoming a professional hacker.\nI have written this book to help aspiring hackers get over this barrier.\nHacking is an elite profession within the IT field. As such, it requires an\nextensive and detailed understanding of IT concepts and technologies. At\nthe most fundamental level, Linux is a requirement. I strongly suggest you\ninvest time and energy into using and understanding it if you want to make\nhacking and information security your career.\nThis book is not intended for the experienced hacker or the experienced\nLinux admin. Instead, it is intended for those who want to get started along"
  },
  {
    "input": "What’s in This Book",
    "output": "the exciting path of hacking, cybersecurity, and pentesting. It is also\nintended not as a complete treatise on Linux or hacking but rather a starting\npoint into these worlds. It begins with the essentials of Linux and extends\ninto some basic scripting in both bash and Python. Wherever appropriate, I\nhave tried to use examples from the world of hacking to teach Linux\nprinciples.\nIn this introduction, we’ll look at the growth of ethical hacking for\ninformation security, and I’ll take you through the process of installing a\nvirtual machine so you can install Kali Linux on your system without\ndisturbing the operating system you are already running.\nWhat’s in This Book\nIn the first set of chapters you’ll get comfortable with the fundamentals of\nLinux; Chapter 1 will get you used to the file system and the terminal, and\ngive you some basic commands. Chapter 2 shows you how to manipulate\ntext to find, examine, and alter software and files.\nIn Chapter 3 you’ll manage networks. You’ll scan for networks, find\ninformation on connections, and disguise yourself by masking your network\nand DNS information.\nChapter 4 teaches you to add, remove, and update software, and how to\nkeep your system streamlined. In Chapter 5, you’ll manipulate file and\ndirectory permissions to control who can access what. You’ll also learn some\nprivilege escalation techniques.\nChapter 6 teaches you how to manage services, including starting and\nstopping processes and allocating resources to give you greater control. In\nChapter 7 you’ll manage environment variables for optimal performance,\nconvenience, and even stealth. You’ll find and filter variables, change your\nPATH variable, and create new environment variables.\nChapter 8 introduces you to bash scripting, a staple for any serious\nhacker. You’ll learn the basics of bash and build a script to scan for target\nports that you might later infiltrate.\nChapters 9 and 10 give you some essential file system management\nskills, showing you how to compress and archive files to keep your system\nclean, copy entire storage devices, and get information on files and\nconnected disks."
  },
  {
    "input": "What Is Ethical Hacking?",
    "output": "The latter chapters dig deeper into hacking topics. In Chapter 11 you’ll\nuse and manipulate the logging system to get information on a target’s\nactivity and cover your own tracks. Chapter 12 shows you how to use and\nabuse three core Linux services: Apache web server, OpenSSH, and\nMySQL. You’ll create a web server, build a remote video spy, and learn\nabout databases and their vulnerabilities. Chapter 13 will show you how to\nstay secure and anonymous with proxy servers, the Tor network, VPNs, and\nencrypted email.\nChapter 14 deals with wireless networks. You’ll learn basic networking\ncommands, then crack Wi-Fi access points and detect and connect to\nBluetooth signals.\nChapter 15 dives deeper into Linux itself with a high level view of how\nthe kernel works and how its drivers can be abused to deliver malicious\nsoftware. In Chapter 16 you’ll learn essential scheduling skills in order to\nautomate your hacking scripts. Chapter 17 will teach you core Python\nconcepts, and you’ll script two hacking tools: a scanner to spy on TCP/IP\nconnections, and a simple password cracker.\nWhat Is Ethical Hacking?\nWith the growth of the information security field in recent years has come\ndramatic growth in the field of ethical hacking, also known as white hat (good\nguy) hacking. Ethical hacking is the practice of attempting to infiltrate and\nexploit a system in order to find out its weaknesses and better secure it. I\nsegment the field of ethical hacking into two primary components:\npenetration testing for a legitimate information security firm and working\nfor your nation’s military or intelligence agencies. Both are rapidly growing\nareas, and demand is strong.\nPenetration Testing\nAs organizations become increasingly security conscious and the cost of\nsecurity breaches rises exponentially, many large organizations are beginning\nto contract out security services. One of these key security services is\npenetration testing. A penetration test is essentially a legal, commissioned\nhack to demonstrate the vulnerability of a firm’s network and systems."
  },
  {
    "input": "Why Hackers Use Linux",
    "output": "Generally, organizations conduct a vulnerability assessment first to find\npotential vulnerabilities in their network, operating systems, and services. I\nemphasize potential, as this vulnerability scan includes a significant number of\nfalse positives (things identified as vulnerabilities that really are not). It is the\nrole of the penetration tester to attempt to hack, or penetrate, these\nvulnerabilities. Only then can the organization know whether the\nvulnerability is real and decide to invest time and money to close the\nvulnerability.\nMilitary and Espionage\nNearly every nation on earth now engages in cyber espionage and cyber\nwarfare. One only needs to scan the headlines to see that cyber activities are\nthe chosen method for spying on and attacking military and industrial\nsystems.\nHacking plays a crucial part in these military and intelligence-gathering\nactivities, and that will only be more true as time goes by. Imagine a war of\nthe future where hackers can gain access to their adversary’s war plans and\nknock out their electric grid, oil refineries, and water systems. These\nactivities are taking place every day now. The hacker thus becomes a key\ncomponent of their nation’s defense.\nWhy Hackers Use Linux\nSo why do hackers use Linux over other operating systems? Mostly because\nLinux offers a far higher level of control via a few different methods.\nLinux Is Open Source\nUnlike Windows, Linux is open source, meaning that the source code of the\noperating system is available to you. As such, you can change and manipulate\nit as you please. If you are trying to make a system operate in ways it was not\nintended to, being able to manipulate the source code is essential.\nLinux Is Transparent\nTo hack effectively, you must know and understand your operating system\nand, to a large extent, the operating system you are attacking. Linux is totally\ntransparent, meaning we can see and manipulate all its working parts.\nNot so with Windows. Microsoft tries hard to make it as difficult as\npossible to know the inner workings of its operating systems, so you never\nreally know what’s going on “under the hood,” whereas in Linux, you have a\nspotlight shining directly on each and every component of the operating\nsystem. This makes working with Linux more effective.\nLinux Offers Granular Control\nLinux is granular. That means that you have an almost infinite amount of\ncontrol over the system. In Windows, you can control only what Microsoft\nallows you to control. In Linux, everything can be controlled by the\nterminal, at the most miniscule level or the most macro level. In addition,\nLinux makes scripting in any of the scripting languages simple and effective.\nMost Hacking Tools Are Written for Linux\nWell over 90 percent of all hacking tools are written for Linux. There are\nexceptions, of course, such as Cain and Abel and Wikto, but those exceptions\nprove the rule. Even when hacking tools such as Metasploit or nmap are\nported for Windows, not all the capabilities transfer from Linux.\nThe Future Belongs to Linux/Unix\nThis might seem like a radical statement, but I firmly believe that the future\nof information technology belongs to Linux and Unix systems. Microsoft\nhad its day in the 1980s and 1990s, but its growth is slowing and stagnating.\nSince the internet began, Linux/Unix has been the operating system of\nchoice for web servers due to its stability, reliability, and robustness. Even\ntoday, Linux/Unix is used in two-thirds of web servers and dominates the\nmarket. Embedded systems in routers, switches, and other devices almost\nalways use a Linux kernel, and the world of virtualization is dominated by\nLinux, with both VMware and Citrix built on the Linux kernel.\nOver 80 percent of mobile devices run Unix or Linux (iOS is Unix, and\nAndroid is Linux), so if you believe that the future of computing lies in\nmobile devices such as tablets and phones (it would be hard to argue"
  },
  {
    "input": "Downloading Kali Linux",
    "output": "otherwise), then the future is Unix/Linux. Microsoft Windows has just 7\npercent of the mobile devices market. Is that the wagon you want to be\nhitched to?\nDownloading Kali Linux\nBefore getting started, you need to download and install Kali Linux on your\ncomputer. This is the Linux distribution we will be working with throughout\nthis book. Linux was first developed by Linus Torvalds in 1991 as an open\nsource alternative to Unix. Since it is open source, volunteer developers code\nthe kernel, the utilities, and the applications. This means that there is no\noverriding corporate entity overseeing development, and as a result,\nconventions and standardization are often lacking.\nKali Linux was developed by Offensive Security as a hacking operating\nsystem built on a distribution of Linux called Debian. There are many\ndistributions of Linux, and Debian is one of the best. You are probably most\nfamiliar with Ubuntu as a popular desktop distribution of Linux. Ubuntu is\nalso built on Debian. Other distributions include Red Hat, CentOS, Mint,\nArch, and SUSE. Although they all share the same Linux kernel (the heart of\nthe operating system that controls the CPU, RAM, and so on), each has its\nown utilities, applications, and choice of graphical interface (GNOME,\nKDE, and others) for different purposes. As a result, each of these\ndistributions of Linux looks and feels slightly different. Kali was designed for\npenetration testers and hackers and comes with a significant complement of\nhacking tools.\nI strongly recommend that you use Kali for this book. Although you can\nuse another distribution, you will likely have to download and install the\nvarious tools we will be using, which could mean many hours downloading\nand installing tools. In addition, if that distribution is not built on Debian,\nthere may be other minor differences. You can download and install Kali\nfrom https://www.kali.org/.\nFrom the home page, click the Downloads link at the top of the page.\nOn the Downloads page you’ll be faced with multiple download choices. It’s\nimportant to choose the right download. Along the left side of the table, you\nwill see the image name, which is the name of the version that the link\ndownloads. For instance, the first image name listing I see is Kali Linux 64"
  },
  {
    "input": "Virtual Machines",
    "output": "Bit, meaning it’s the full Kali Linux and is suitable for 64-bit systems—most\nmodern systems use a 64-bit Intel or AMD CPU. To determine what type of\nCPU is on your system, go to Control Panel ▸ System and Security ▸\nSystem, and it should be listed. If your system is 64-bit, download and\ninstall the 64-bit version of the full Kali (not Light or Lxde, or any of the\nother alternatives).\nIf you are running an older computer with a 32-bit CPU, you will need to\ninstall the 32-bit version, which appears lower on the page.\nYou have a choice of downloading via HTTP or Torrent. If you choose\nHTTP, Kali will download directly to your system just like any download,\nand it will be placed in your Downloads folder. The torrent download is the\npeer-to-peer download used by many file-sharing sites. You will need a\ntorrenting application like BitTorrent to do this. The Kali file will then\ndownload to the folder in which the torrenting application stores its\ndownloads.\nThere are other versions for other types of CPUs, such as the commonly\nused ARM architecture found in so many mobile devices. If you are using a\nRaspberry Pi, tablet, or other mobile device (phone users will likely prefer\nKali NetHunter), make certain you download and install the ARM\narchitecture version of Kali by scrolling down to Download ARM images\nand clicking Kali ARM Images.\nYou have Kali downloaded, but before you install anything, I want to talk\na bit about virtual machines. Generally, for the beginner, installing Kali into\na virtual machine is the best solution for learning and practicing.\nVirtual Machines\nVirtual machine (VM) technology allows you to run multiple operating\nsystems from one piece of hardware like your laptop or desktop. This means\nthat you can continue to run the Windows or MacOS operating system you\nare familiar with and run a virtual machine of Kali Linux inside that\noperating system. You don’t need to overwrite your existing OS to learn\nLinux.\nNumerous virtual machine applications are available from VMware,\nOracle, Microsoft, and other vendors. All are excellent, but here I will be\nshowing you how to download and install Oracle’s free VirtualBox.\nInstalling VirtualBox\nYou can download VirtualBox at https://www.virtualbox.org/, as shown in\nFigure 1. Click the Downloads link in the left menu, and select the\nVirtualBox package for your computer’s current operating system, which\nwill host VirtualBox VM. Make sure to download the latest version.\nFigure 1: VirtualBox home page\nWhen the download has completed, click the setup file, and you will be\ngreeted by a familiar Setup Wizard, shown in Figure 2.\nFigure 2: The Setup Wizard dialog\nClick Next, and you should be greeted with the Custom Setup screen, as\nin Figure 3.\nFigure 3: The Custom Setup dialog\nFrom this screen, simply click Next. Keep clicking Next until you get to\nthe Network Interfaces warning screen and then click Yes.\nClick Install to begin the process. During this process, you will likely be\nprompted several times about installing device software. These are the virtual\nnetworking devices necessary for your virtual machines to communicate.\nClick Install for each one.\nWhen the installation is complete, click Finish.\nSetting Up Your Virtual Machine\nNow let’s get you started with your virtual machine. VirtualBox should open\nonce it has installed—if not, open it—and you should be greeted by the\nVirtualBox Manager, as seen in Figure 4.\nFigure 4: The VirtualBox Manager\nSince we will be creating a new virtual machine with Kali Linux, click\nNew in the upper-left corner. This opens the Create Virtual Machine dialog\nshown in Figure 5.\nGive your machine a name (any name is okay, but I simply used Kali) and\nthen select Linux from the Type drop-down menu. Finally, select Debian\n(64-bit) from the third drop-down menu (unless you are using the 32-bit\nversion of Kali, in which case select the Debian 32-bit version). Click Next,\nand you’ll see a screen like Figure 6. Here, you need to select how much\nRAM you want to allocate to this new virtual machine.\nFigure 5: The Create Virtual Machine dialog\nFigure 6: Allocating memory\nAs a rule of thumb, I don’t recommend using more than 25 percent of\nyour total system RAM. That means if you have installed 4GB on your\nphysical or host system, then select just 1GB for your virtual machine, and if\nyou have 16GB on your physical system, then select 4GB. The more RAM\nyou give your virtual machine, the better and faster it will run, but you must\nalso leave enough RAM for your host operating system and any other virtual\nmachines you might want to run simultaneously. Your virtual machines will\nnot use any RAM when you are not using them, but they will use hard drive\nspace.\nClick Next, and you’ll get to the Hard Disk screen. Choose Create\nVirtual Hard Disk and click Create.\nIn the next screen, you can decide whether you want the hard drive you\nare creating to be allocated dynamically or at a fixed size. If you choose\nDynamically Allocated, the system will not take the entire maximum size\nyou allocate for the virtual hard disk until you need it, saving more unused\nhard disk space for your host system. I suggest you select dynamically\nallocated.\nClick Next, and you’ll choose the amount of hard drive space to allocate\nto the VM and the location of the VM (see Figure 7).\nFigure 7: Allocating hard drive space\nThe default is 8GB. I usually find that to be a bit small and recommend\nthat you allocate 20–25GB at a minimum. Remember, if you chose to\ndynamically allocate hard drive space, it won’t use the space until you need\nit, and expanding your hard drive after it has already been allocated can be\ntricky, so better to err on the high side.\nClick Create, and you’re ready to go!\nInstalling Kali on the VM\nAt this point, you should see a screen like Figure 8. Now you’ll need to\ninstall Kali. Note that on the left of the VirtualBox Manager, you should see\nan indication that Kali VM is powered off. Click the Start button (green\narrow icon).\nFigure 8: The VirtualBox welcome screen\nThe VirtualBox Manager will then ask where to find the startup disk.\nYou’ve already downloaded a disk image with the extension .iso, which\nshould be in your Downloads folder (if you used a torrent to download Kali,\nthe .iso file will be in the Downloads folder of your torrenting application).\nClick the folder icon to the right, navigate to the Downloads folder, and select\nthe Kali image file (see Figure 9)."
  },
  {
    "input": "Setting Up Kali",
    "output": "Figure 9: Selecting your startup disk\nThen click Start. Congratulations, you’ve just installed Kali Linux on a\nvirtual machine!\nSetting Up Kali\nKali will now open a screen like Figure 10, offering you several startup\nchoices. I suggest using the graphical install for beginners. Use your\nkeyboard keys to navigate the menu.\nIf you get an error when you’re installing Kali into your VirtualBox, it’s\nlikely because you don’t have virtualization enabled within your system’s\nBIOS. Each system and its BIOS is slightly different, so check with your\nmanufacturer or search online for solutions for your system and BIOS. In\naddition, on Windows systems, you will likely need to disable any competing\nvirtualization software such as Hyper-V. Again, an internet search for your\nsystem should guide you in doing so.\nFigure 10: Selecting the install method\nYou will next be asked to select your language. Make certain you select\nthe language you are most comfortable working in and then click Continue.\nNext, select your location, click Continue, and then select your keyboard\nlayout.\nWhen you click Continue, VirtualBox will go through a process of\ndetecting your hardware and network adapters. Just wait patiently as it does\nso. Eventually, you will be greeted by a screen asking you to configure your\nnetwork, as in Figure 11.\nFigure 11: Entering a hostname\nThe first item it asks for is the name of your host. You can name it\nanything you please, but I left mine with the default “kali.”\nNext, you will be asked for the domain name. It’s not necessary to enter\nanything here. Click Continue. The next screen, shown in Figure 12, is very\nimportant. Here, you are asked for the password you want to use for the root\nuser.\nFigure 12: Choosing a password\nThe root user in Linux is the all-powerful system administrator. You can\nuse any password you feel secure with. If this were a physical system that we\nwere using on the internet, I would suggest that you use a very long and\ncomplex password to limit the ability of an attacker to crack it. Since this is a\nvirtual machine that people can’t access without first accessing your host\noperating system, password authentication on this virtual machine is less\nimportant, but you should still choose wisely.\nClick Continue, and you will be asked to set your time zone. Do so and\nthen continue.\nThe next screen asks about partition disks (a partition is just what it\nsounds like—a portion or segment of your hard drive). Choose Guided –\nuse entire disk, and Kali will detect your hard drives and set up a\npartitioner automatically.\nKali will then warn you that all data on the disk you select will be erased .\n. . but don’t worry! This is a virtual disk, and the disk is new and empty, so\nthis won’t actually do anything. Click Continue.\nKali will now ask whether you want all files in one partition or if you\nwant to have separate partitions. If this were a production system, you\nprobably would select separate partitions for /home, /var, and /tmp, but\nconsidering that we will be using this as a learning system in a virtual\nenvironment, it is safe for you to simply select All files in one partition.\nNow you be will be asked whether to write your changes to disk. Select\nFinish partitioning and write changes to disk. Kali will prompt you once\nmore to see if you want to write the changes to disk; select Yes and click\nContinue (see Figure 13).\nFigure 13: Writing changes to disk\nKali will now begin to install the operating system. This could take a\nwhile, so be patient. Now is the time to take your bathroom break and get\nyour favorite beverage.\nOnce the installation is complete, you will be prompted as to whether you\nwant to use a network mirror. This really is not necessary, so click No.\nThen Kali will prompt you as to whether you want to install GRUB\n(Grand Unified Bootloader), shown in Figure 14. A bootloader enables you to\nselect different operating systems to boot into, which means when you boot\nyour machine, you can boot into either Kali or another operating system.\nSelect Yes and click Continue.\nFigure 14: Installing GRUB\nOn the next screen, you will be prompted as to whether you want to\ninstall the GRUB bootloader automatically or manually. For reasons as yet\nunclear, if you choose the second option, Kali will tend to hang and display a\nblank screen after installation. Select Enter device manually, as shown in\nFigure 15.\nFigure 15: Entering your device manually\nOn the following screen, select the drive where the GRUB bootloader\nshould be installed (it will likely be something like /dev/sda). Click through to\nthe next screen, which should tell you that the installation is complete.\nCongratulations! You’ve installed Kali. Click Continue. Kali will attempt\nto reboot, and you will see a number of lines of code go across a blank, black\nscreen before you are eventually greeted with Kali 2018’s login screen, as\nshown in Figure 16.\nFigure 16: The Kali login screen\nLog in as root, and you will be asked for your password. Enter whatever\npassword you selected for your root user.\nAfter logging in as root, you will be greeted with the Kali Linux desktop,\nas in Figure 17.\nFigure 17: The Kali home screen\nYou are now ready to begin your journey into the exciting field of\nhacking! Welcome!"
  },
  {
    "input": "Introductory Terms and Concepts",
    "output": "1\nGETTING STARTED WITH THE BASICS\nBy our very nature, hackers are doers. We want to touch and play with\nthings. We also want to create and, sometimes, break things. Few of us want\nto read long tomes of information technology theory before we can do what\nwe love most: hacking. With that in mind, this chapter is designed to give\nyou some fundamental skills to get you up and running in Kali . . . now!\nIn this chapter, we won’t go into any one concept in great detail—we’ll\ncover just enough to let you play and explore in the operating system of\nhackers: Linux. We will save more in-depth discussions for later chapters.\nIntroductory Terms and Concepts\nBefore we begin our journey through the wonderful world of Linux Basics for\nHackers, I want to introduce a few terms that should clarify some concepts\ndiscussed later in this chapter.\nBinaries This term refers to files that can be executed, similar to\nexecutables in Windows. Binaries generally reside in the /usr/bin or\nusr/sbin directory and include utilities such as ps, cat, ls, and cd (we’ll\ntouch on all of four of these in this chapter) as well as applications such as\nthe wireless hacking tool aircrack-ng and the intrusion detection system\n(IDS) Snort.\nCase sensitivity Unlike Windows, Linux is case sensitive. This means\nthat Desktop is different from desktop, which is different from DeskTop.\nEach of these would represent a different file or directory name. Many\npeople coming from a Windows environment can find this frustrating. If\nyou get the error message “file or directory not found” and you are sure\nthe file or directory exists, you probably need to check your case.\nDirectory This is the same as a folder in Windows. A directory provides\na way of organizing files, usually in a hierarchical manner.\nHome Each user has their own /home directory, and this is generally\nwhere files you create will be saved by default.\nKali Kali Linux is a distribution of Linux specifically designed for\npenetration testing. It has hundreds of tools preinstalled, saving you the\nhours it would take to download and install them yourself. I will be using\nthe latest version of Kali at the time of this writing: Kali 2018.2, first\nreleased in April 2018.\nroot Like nearly every operating system, Linux has an administrator or\nsuperuser account, designed for use by a trusted person who can do\nnearly anything on the system. This would include such things as\nreconfiguring the system, adding users, and changing passwords. In\nLinux, that account is called root. As a hacker or pentester, you will often\nuse the root account to give yourself control over the system. In fact,\nmany hacker tools require that you use the root account.\nScript This is a series of commands run in an interpretive environment\nthat converts each line to source code. Many hacking tools are simply\nscripts. Scripts can be run with the bash interpreter or any of the other\nscripting language interpreters, such as Python, Perl, or Ruby. Python is\ncurrently the most popular interpreter among hackers.\nShell This is an environment and interpreter for running commands in\nLinux. The most widely used shell is bash, which stands for Bourne-again\nshell, but other popular shells include the C shell and Z shell. I will be\nusing the bash shell exclusively in this book.\nTerminal This is a command line interface (CLI).\nWith those basics behind us, we will attempt to methodically develop the\nessential Linux skills you’ll need to become a hacker or penetration tester. In"
  },
  {
    "input": "A Tour of Kali",
    "output": "this first chapter, I’ll walk you through getting started with Kali Linux.\nA Tour of Kali\nOnce you start Kali, you’ll be greeted with a login screen, as shown in Figure\n1-1. Log in using the root account username root and the default password\ntoor.\nFigure 1-1: Logging into Kali using the root account\nYou should now have access to your Kali desktop (see Figure 1-2). We’ll\nquickly look at two of the most basic aspects of the desktop: the terminal\ninterface and file structure.\nFigure 1-2: The Kali desktop\nThe Terminal\nThe first step in using Kali is to open the terminal, which is the command\nline interface we’ll use in this book. In Kali Linux, you’ll find the icon for the\nterminal at the bottom of the desktop. Double-click this icon to open the\nterminal or press CTRL-ALT-T. Your new terminal should look like the one\nshown in Figure 1-3.\nFigure 1-3: The Kali terminal\nThis terminal opens the command line environment, known as the shell,\nwhich enables you to run commands on the underlying operating systems\nand write scripts. Although Linux has many different shell environments, the\nmost popular is the bash shell, which is also the default shell in Kali and\nmany other Linux distributions.\nTo change your password, you can use the command passwd.\nThe Linux Filesystem\nThe Linux filesystem structure is somewhat different from that of Windows.\nLinux doesn’t have a physical drive (such as the C: drive) at the base of the\nfilesystem but uses a logical filesystem instead. At the very top of the\nfilesystem structure is /, which is often referred to as the root of the\nfilesystem, as if it were an upside-down tree (see Figure 1-4). Keep in mind\nthat this is different from the root user. These terms may seem confusing at\nfirst, but they will become easier to differentiate once you get used to Linux.\nFigure 1-4: The Linux filesystem\nThe root (/) of the filesystem is at the top of the tree, and the following\nare the most important subdirectories to know:\n/root The home directory of the all-powerful root user\n/etc Generally contains the Linux configuration files—files that control\nwhen and how programs start up\n/home The user’s home directory\n/mnt Where other filesystems are attached or mounted to the filesystem\n/media Where CDs and USB devices are usually attached or mounted to\nthe filesystem\n/bin Where application binaries (the equivalent of executables in\nMicrosoft Windows) reside\n/lib Where you’ll find libraries (shared programs that are similar to\nWindows DLLs)\nWe’ll spend more time with these key directories throughout this book.\nUnderstanding these first-level directories is important to navigating\nthrough the filesystem from the command line.\nIt’s also important to know before you start that you should not log in as\nroot when performing routine tasks, because anyone who hacks your system\n(yes, hackers sometimes get hacked) when you’re logged in as root would\nimmediately gain root privileges and thus “own” your system. Log in as a\nregular user when starting regular applications, browsing the web, running"
  },
  {
    "input": "Basic Commands in Linux",
    "output": "tools like Wireshark, and so on.\nBasic Commands in Linux\nTo begin, let’s look at some basic commands that will help you get up and\nrunning in Linux.\nFinding Yourself with pwd\nUnlike when you’re working in a graphical user interface (GUI)\nenvironment like Windows or macOS, the command line in Linux does not\nalways make it apparent which directory you’re presently in. To navigate to a\nnew directory, you usually need to know where you are currently. The\npresent working directory command, pwd, returns your location within the\ndirectory structure.\nEnter pwd in your terminal to see where you are:\nkali >pwd\n/root\nIn this case, Linux returned /root, telling me I’m in the root user’s\ndirectory. And because you logged in as root when you started Linux, you\nshould be in the root user’s directory, too, which is one level below the top\nof the filesystem structure (/).\nIf you’re in another directory, pwd will return that directory name instead.\nChecking Your Login with whoami\nIn Linux, the one “all-powerful” superuser or system administrator is named\nroot, and it has all the system privileges needed to add users, change\npasswords, change privileges, and so on. Obviously, you don’t want just\nanyone to have the ability to make such changes; you want someone who can\nbe trusted and has proper knowledge of the operating system. As a hacker,\nyou usually need to have all those privileges to run the programs and\ncommands you need (many hacker tools won’t work unless you have root\nprivileges), so you’ll want to log in as root.\nIf you’ve forgotten whether you’re logged in as root or another user, you\ncan use the whoami command to see which user you’re logged in as:\nkali >whoami\nroot\nIf I had been logged in as another user, such as my personal account,\nwhoami would have returned my username instead, as shown here:\nkali >whoami\nOTW\nNavigating the Linux Filesystem\nNavigating the filesystem from the terminal is an essential Linux skill. To\nget anything done, you need to be able to move around to find applications,\nfiles, and directories located in other directories. In a GUI-based system, you\ncan visually see the directories, but when you’re using the command line\ninterface, the structure is entirely text based, and navigating the filesystem\nmeans using some commands.\nChanging Directories with cd\nTo change directories from the terminal, use the change directory command,\ncd. For example, here’s how to change to the /etc directory used to store\nconfiguration files:\nkali >cd /etc\nroot@kali:/etc#\nThe prompt changes to root@kali:/etc, indicating that we’re in the /etc\ndirectory. We can confirm this by entering pwd:\nroot@kali:/etc# pwd\n/etc\nTo move up one level in the file structure (toward the root of the file\nstructure, or /), we use cd followed by double dots (..), as shown here:\nroot@kali:/etc# cd ..\nroot@kali:/# pwd\n/\nroot@kali:/#\nThis moves us up one level from /etc to the / root directory, but you can\nmove up as many levels as you need. Just use the same number of double-dot\npairs as the number of levels you want to move:\nYou would use .. to move up one level.\nYou would use .. .. to move up two levels.\nYou would use .. .. .. to move up three levels, and so on.\nSo, for example, to move up two levels, enter cd followed by two sets of\ndouble dots with a space in between:\nkali >cd .. ..\nYou can also move up to the root level in the file structure from anywhere\nby entering cd /, where / represents the root of the filesystem.\nListing the Contents of a Directory with ls\nTo see the contents of a directory (the files and subdirectories), we can use\nthe ls (list) command. This is very similar to the dir command in Windows.\nkali >ls\nbin initrd.img media run var\nboot initrd.img.old mnt sbin vmlinuz\ndev lib opt srv vmlinuz.old\netc lib64 proc tmp\nhome lost+found root usr\nThis command lists both the files and directories contained in the\ndirectory. You can also use this command on any particular directory, not\njust the one you are currently in, by listing the directory name after the\ncommand; for example, ls /etc shows what’s in the /etc directory.\nTo get more information about the files and directories, such as their\npermissions, owner, size, and when they were last modified, you can add the\n-l switch after ls (the l stands for long). This is often referred to as long\nlisting. Let’s try it here:\nAs you can see, ls -l provides us with significantly more information,\nsuch as whether an object is a file or directory, the number of links, the\nowner, the group, its size, when it was created or modified, and its name.\nI typically add the -l switch whenever doing a listing in Linux, but to each\ntheir own. We’ll talk more about ls -l in Chapter 5.\nSome files in Linux are hidden and won’t be revealed by a simple ls or ls\n-l command. To show hidden files, add a lowercase –a switch, like so:\nkali >ls -la\nIf you aren’t seeing a file you expect to see, it’s worth trying ls with the a\nflag.\nGetting Help\nNearly every command, application, or utility has a dedicated help file in\nLinux that provides guidance for its use. For instance, if I needed help using\nthe best wireless cracking tool, aircrack-ng, I could simply type the aircrack-\nng command followed by the --help command:\nkali >aircrack-ng --help\nNote the double dash here. The convention in Linux is to use a double\ndash (--) before word options, such as help, and a single dash (-) before\nsingle-letter options, such as –h.\nWhen you enter this command, you should see a short description of the\ntool and guidance on how to use it. In some cases, you can use either -h or -?\nto get to the help file. For instance, if I needed help using the hacker’s best\nport-scanning tool, nmap, I would enter the following:\nkali >nmap -h\nUnfortunately, although many applications support all three options (--\nhelp, -h, and -?), there’s no guarantee the application you’re using will. So if\none option doesn’t work, try another.\nReferencing Manual Pages with man\nIn addition to the help switch, most commands and applications have a\nmanual (man) page with more information, such as a description and\nsynopsis of the command or application. You can view a man page by simply\ntyping man before the command, utility, or application. To see the man page\nfor aircrack-ng, for example, you would enter the following:\nThis opens the manual for aircrack-ng, providing you with more detailed\ninformation than the help screen. You can scroll through this manual file\nusing the ENTER key, or you can page up and down using the PG DN and PG\nUP keys, respectively. To exit, simply enter q (for quit), and you’ll return to\nthe command prompt."
  },
  {
    "input": "Finding Stuff",
    "output": "Finding Stuff\nUntil you become familiar with Linux, it can be frustrating to find your way\naround, but knowledge of a few basic commands and techniques will go a\nlong way toward making the command line much friendlier. The following\ncommands help you locate things from the terminal.\nSearching with locate\nProbably the easiest command to use is locate. Followed by a keyword\ndenoting what it is you want to find, this command will go through your\nentire filesystem and locate every occurrence of that word.\nTo look for aircrack-ng, for example, enter the following:\nkali >locate aircrack-ng\n/usr/bin/aircrack-ng\n/usr/share/applications/kali-aircrack-ng.desktop\n/usr/share/desktop-directories/05-1-01-aircrack-ng.directory\n--snip--\n/var/lib/dpkg/info/aircrack-ng.mg5sums\nThe locate command is not perfect, however. Sometimes the results of\nlocate can be overwhelming, giving you too much information. Also, locate\nuses a database that is usually only updated once a day, so if you just created\na file a few minutes or a few hours ago, it might not appear in this list until\nthe next day. It’s worth knowing the disadvantages of these basic commands\nso you can better decide when best to use each one.\nFinding Binaries with whereis\nIf you’re looking for a binary file, you can use the whereis command to locate\nit. This command returns not only the location of the binary but also its\nsource and man page if they are available. Here’s an example:\nkali >whereis aircrack-ng\naircarck-ng: /usr/bin/aircarck-ng /usr/share/man/man1/aircarck-ng.1.gz\nIn this case, whereis returned just the aircrack-ng binaries and man page,\nrather than every occurrence of the word aircrack-ng. Much more efficient\nand illuminating, don’t you think?\nFinding Binaries in the PATH Variable with which\nThe which command is even more specific: it only returns the location of the\nbinaries in the PATH variable in Linux. We’ll look more closely at the PATH\nvariable in Chapter 7, but for now it’s sufficient to know that PATH holds the\ndirectories in which the operating system looks for the commands you\nexecute at the command line. For example, when I enter aircrack-ng on the\ncommand line, the operating system looks to the PATH variable to see in which\ndirectories it should look for aircrack-ng:\nkali >which aircrack-ng\n/usr/bin/aircrack-ng\nHere, which was able to find a single binary file in the directories listed in\nthe PATH variable. At minimum, these directories usually include /usr/bin, but\nmay include /usr/sbin and maybe a few others.\nPerforming More Powerful Searches with find\nThe find command is the most powerful and flexible of the searching\nutilities. It is capable of beginning your search in any designated directory\nand looking for a number of different parameters, including, of course, the\nfilename but also the date of creation or modification, the owner, the group,\npermissions, and the size.\nHere’s the basic syntax for find:\nfind directory options expression\nSo, if I wanted to search for a file with the name apache2 (the open source\nweb server) starting in the root directory, I would enter the following:\nkali >find /➊ -type f➋ -name apache2➌\nFirst I state the directory in which to start the search, in this case / ➊.\nThen I specify which type of file to search for, in this case f for an ordinary\nfile ➋. Last, I give the name of the file I’m searching for, in this case apache2\n➌.\nMy results for this search are shown here:\nkali >find / -type f -name apache2\n/usr/lib/apache2/mpm-itk/apache2\n/usr/lib/apache2/mpm-event/apache2\n/usr/lib/apache2/mpm-worker/apache2\n/usr/lib/apache2/mpm-prefork/apache2\n/etc/cron.daily/apache2\n/etc/logrotate.d/apache2\n/etc/init.d/apache2\n/etc/default/apache2\nThe find command started at the top of the filesystem (/), went through\nevery directory looking for apache2 in the filename, and then listed all\ninstances found.\nAs you might imagine, a search that looks in every directory can be slow.\nOne way to speed it up is to look only in the directory where you would\nexpect to find the file(s) you need. In this case, we are looking for a\nconfiguration file, so we could start the search in the /etc directory, and\nLinux would only search as far as its subdirectories. Let’s try it:\nkali >find /etc -type f -name apache2\n/etc/init.d/apache2\n/etc/logrotate.d/apache2\n/etc/cron.daily/apache2\nThis much quicker search only found occurrences of apache2 in the /etc\ndirectory and its subdirectories. It’s also important to note that unlike some\nother search commands, find displays only exact name matches. If the file\napache2 has an extension, such as apache2.conf, the search will not find a\nmatch. We can remedy this limitation by using wildcards, which enable us to\nmatch multiple characters. Wildcards come in a few different forms: * . , ?\nand [].\nLet’s look in the /etc directory for all files that begin with apache2 and\nhave any extension. For this, we could write a find command using the\nfollowing wildcard:\nkali >find /etc -type f --name apache2.*\n/etc/apache2/apache2.conf\nWhen we run this command, we find that there is one file in the /etc\ndirectory that fits the apache2.* pattern. When we use a period followed by\nthe * wildcard, the terminal looks for any extension after the filename\napache2. This can be a very useful technique for finding files where you don’t\nknow the file extension.\nWhen I run this command, I find two files that start with apache2 in the\n/etc directory, including the apache2.conf file.\nA QUICK LOOK AT WILDCARDS\nLet’s say we’re doing a search on a directory that has the files cat, hat, what, and bat. The ?\nwildcard is used to represent a single character, so a search for ?at would find hat, cat, and bat\nbut not what, because at in this filename is preceded by two letters. The [] wildcard is used to\nmatch the characters that appear inside the square brackets. For example, a search for [c,b]at\nwould match cat and bat but not hat or what. Among the most widely used wildcards is the\nasterisk (*), which matches any character(s) of any length, from none to an unlimited number\nof characters. A search for *at, for example, would find cat, hat, what, and bat.\nFiltering with grep\nVery often when using the command line, you’ll want to search for a\nparticular keyword. For this, you can use the grep command as a filter to\nsearch for keywords.\nThe grep command is often used when output is piped from one\ncommand to another. I cover piping in Chapter 2, but for now, suffice it to\nsay that Linux (and Windows for that matter) allows us to take the output of\none command and send it as input to another command. This is called piping,\nand we use the | command to do it (the | key is usually above the ENTER key\non your keyboard).\nThe ps command is used to display information about processes running\non the machine. We cover this in more detail in Chapter 6, but for this\nexample, suppose I want to see all the processes running on my Linux\nsystem. In this case, I can use the ps (processes) command followed by the aux\nswitches to specify which process information to display, like so:\nkali >ps aux\nThis provides me with a listing of all the processes running in this system\n—but what if I just want to find one process to see if it is running?\nI can do this by piping the output from ps to grep and searching for a\nkeyword. For instance, to find out whether the apache2 service is running, I\nwould enter the following."
  },
  {
    "input": "Modifying Files and Directories",
    "output": "kali >ps aux | grep apache2\nroot 4851 0.2 0.7 37548 7668 ? Ss 10:14 0:00 /usr/sbin/apache2 -k start\nroot 4906 0.0 0.4 37572 4228 ? S 10:14 0:00 /usr/sbin/apache2 -k start\nroot 4910 0.0 0.4 37572 4228 ? Ss 10:14 0:00 /usr/sbin/apache2 -k start\n--snip--\nThis command tells Linux to display all my services and then send that\noutput to grep, which will look through the output for the keyword apache2\nand then display only the relevant output, thus saving me considerable time\nand my eyesight.\nModifying Files and Directories\nOnce you’ve found your files and directories, you’ll want to be able to\nperform actions on them. In this section, we look at how to create files and\ndirectories, copy files, rename files, and delete files and directories.\nCreating Files\nThere are many ways to create files in Linux, but for now we’ll just look at\ntwo simple methods. The first is cat, which is short for concatenate, meaning\nto combine pieces together (not a reference to your favorite domesticated\nfeline). The cat command is generally used for displaying the contents of a\nfile, but it can also be used to create small files. For creating bigger files, it’s\nbetter to enter the code in a text editor such as vim, emacs, leafpad, gedit, or\nkate and then save it as a file.\nConcatenation with cat\nThe cat command followed by a filename will display the contents of that\nfile, but to create a file, we follow the cat command with a redirect, denoted\nwith the > symbol, and a name for the file we want to create. Here’s an\nexample:\nkali >cat > hackingskills\nHacking is the most valuable skill set of the 21st century!\nWhen you press ENTER, Linux will go into interactive mode and wait for\nyou to start entering content for the file. This can be puzzling because the\nprompt disappears, but if you simply begin typing, whatever you enter will\ngo into the file (in this case, hackingskills). Here, I entered Hacking is the most\nvaluable skill set of the 21st century!. To exit and return to the prompt, I press\nCTRL-D. Then, when I want to see what’s in the file hackingskills, I enter the\nfollowing:\nkali >cat hackingskills\nHacking is the most valuable skill set of the 21st century!\nIf you don’t use the redirect symbol, Linux will spit back the contents of\nyour file.\nTo add, or append, more content to a file, you can use the cat command\nwith a double redirect (>>), followed by whatever you want to add to the end\nof the file. Here’s an example:\nkali >cat >> hackingskills\nEveryone should learn hacking\nLinux once again goes into interactive mode, waiting for content to\nappend to the file. When I enter Everyone should learn hacking and press CTRL-\nD, I am returned to the prompt. Now, when I display the contents of that\nfile with cat, I can see that the file has been appended with Everyone should\nlearn hacking, as shown here:\nkali >cat hackingskills\nHacking is the most valuable skill set of the 21st century! Everyone should\nlearn hacking\nIf I want to overwrite the file with new information, I can simply use the\ncat command with a single redirect again, as follows:\nkali >cat > hackingskills\nEveryone in IT security without hacking skills is in the dark\nkali >cat hackingskills\nEveryone in IT security without hacking skills is in the dark\nAs you can see here, Linux goes into interactive mode, and I enter the\nnew text and then exit back to the prompt. When I once again use cat to see\nthe content of the file, I see that my previous words have been overwritten\nwith the latest text.\nFile Creation with touch\nThe second command for file creation is touch. This command was originally\ndeveloped so a user could simply touch a file to change some of its details,\nsuch as the date it was created or modified. However, if the file doesn’t\nalready exist, this command creates that file by default.\nLet’s create newfile with touch:\nkali >touch newfile\nNow when I then use ls –l to see the long list of the directory, I see that a\nnew file has been created named newfile. Note that its size is 0 because there\nis no content in newfile.\nCreating a Directory\nThe command for creating a directory in Linux is mkdir, a contraction of\nmake directory. To create a directory named newdirectory, enter the following\ncommand:\nkali >mkdir newdirectory\nTo navigate to this newly created directory, simply enter this:\nkali >cd newdirectory\nCopying a File\nTo copy files, we use the cp command. This creates a duplicate of the file in\nthe new location and leaves the old one in place.\nHere, we’ll create the file oldfile in the root directory with touch and copy\nit to /root/newdirectory, renaming it in the process and leaving the original\noldfile in place:\nkali >touch oldfile\nkali >cp oldfile /root/newdirectory/newfile\nRenaming the file is optional and is done simply by adding the name you\nwant to give it to the end of the directory path. If you don’t rename the file\nwhen you copy it, the file will retain the original name by default.\nWhen we then navigate to newdirectory, we see that there is an exact copy\nof oldfile called newfile:\nkali >cd newdirectory\nkali >ls\nnewfile oldfile\nRenaming a File\nUnfortunately, Linux doesn’t have a command intended solely for renaming\na file, as Windows and some other operating systems do, but it does have the\nmv (move) command.\nThe mv command can be used to move a file or directory to a new location\nor simply to give an existing file a new name. To rename newfile to newfile2,\nyou would enter the following:\nkali >mv newfile newfile2\nkali >ls\noldfile newfile2\nNow when you list (ls) that directory, you see newfile2 but not newfile,\nbecause it has been renamed. You can do the same with directories.\nRemoving a File\nTo remove a file, you can simply use the rm command, like so:\nkali >rm newfile2\nIf you now do a long listing on the directory, you can confirm that the file\nhas been removed.\nRemoving a Directory\nThe command for removing a directory is similar to the rm command for\nremoving files but with dir (for directory) appended, like so:\nkali >rmdir newdirectory\nrmdir:failed to remove 'newdirectory': Directory not empty\nIt’s important to note that rmdir will not remove a directory that is not\nempty, but will give you a warning message that the “directory is not\nempty,” as you can see in this example. You must first remove all the"
  },
  {
    "input": "Exercises",
    "output": "contents of the directory before removing it. This is to stop you from\naccidentally deleting objects you didn’t intend to delete.\nIf you do want to remove a directory and its content all in one go, you\ncan use the -r switch after rm, like so:\nkali >rm -r newdirectory\nJust a word of caution, though: be wary of using the -r option with rm, at\nleast at first, because it’s very easy to remove valuable files and directories by\nmistake. Using rm -r in your home directory, for instance, would delete every\nfile and directory there—probably not what you were intending.\nGo Play Now!\nNow that you have some basic skills for navigating around the filesystem,\nyou can play with your Linux system a bit before progressing. The best way\nto become comfortable with using the terminal is to try out your newfound\nskills right now. In subsequent chapters, we will explore farther and deeper\ninto our hacker playground.\nEXERCISES\nBefore you move on to Chapter 2, try out the skills you learned from this chapter by\ncompleting the following exercises:\n1. Use the ls command from the root (/) directory to explore the directory structure of\nLinux. Move to each of the directories with the cd command and run pwd to verify where\nyou are in the directory structure.\n2. Use the whoami command to verify which user you are logged in as.\n3. Use the locate command to find wordlists that can be used for password cracking.\n4. Use the cat command to create a new file and then append to that file. Keep in mind\nthat > redirects input to a file and >> appends to a file.\n5. Create a new directory called hackerdirectory and create a new file in that directory named\nhackedfile. Now copy that file to your /root directory and rename it secretfile."
  },
  {
    "input": "2 TEXT MANIPULATION",
    "output": "2\nTEXT MANIPULATION\nIn Linux, nearly everything you deal with directly is a file, and most often\nthese will be text files; for instance, all configuration files in Linux are text\nfiles. So to reconfigure an application, you simply open the configuration\nfile, change the text, save the file, and then restart the application—your\nreconfiguration is complete.\nWith so many text files, manipulating text becomes crucial in managing\nLinux and Linux applications. In this chapter, you’ll use several commands\nand techniques for manipulating text in Linux.\nFor illustrative purposes, I’ll use files from the world’s best network\nintrusion detection system (NIDS), Snort, which was first developed by\nMarty Roesch and is now owned by Cisco. NIDSs are commonly used to\ndetect intrusions by hackers, so if you want to be a successful hacker, you\nmust be familiar with the ways NIDSs can deter attacks and the ways you\ncan abuse them to avoid detection.\nNOTE\nIf the version of Kali Linux you’re using doesn’t come preinstalled with Snort,\nyou can download the files from the Kali repository by entering apt-get install\nsnort."
  },
  {
    "input": "Viewing Files",
    "output": "Viewing Files\nAs demonstrated in Chapter 1, the most basic text display command is\nprobably cat, but it has its limitations. Use cat to display the Snort config file\n(snort.conf) found in/etc/snort (see Listing 2-1).\nkali >cat /etc/snort/snort.conf\nListing 2-1: Displaying snort.conf in the terminal window\nYour screen should now display the entire snort.conf file, which will\nstream until it comes to the end of the file, as shown here. This isn’t the\nmost convenient or practical way to view and work with this file.\n# include $SO_RULE_PATH/exploit.rules\n# include $SO_RULE_PATH/exploit.rules\n# include $SO_RULE_PATH/exploit.rules\n# include $SO_RULE_PATH/exploit.rules\n# include $SO_RULE_PATH/exploit.rules\n--snip--\n# event thresholding or suppressions commands...\nkali >\nIn the following two sections, I will show you the head and tail commands,\nwhich are two methods for displaying just part of a file’s content in order to\nmore easily view the key content.\nTaking the Head\nIf you just want to view the beginning of a file, you can use the head\ncommand. By default, this command displays the first 10 lines of a file. The\nfollowing command, for instance, shows you the first 10 lines of snort.conf:\nkali >head /etc/snort/snort.conf\n#--------------------------------------------------------------\n# VRT Rules Packages Snort.conf\n#\n# For more information visit us at:\n--snip--\n#Snort bugs:bugs@snort.org\nIf you want to see more or fewer than the default 10 lines, enter the\nquantity you want with the dash (-) switch after the call to head and before the\nfilename. For example, if you want to see the first 20 lines of the file, you\nwould enter the command shown at the top of Listing 2-2.\nkali >head -20 /etc/snort/snort.conf\n#-------------------------------------------------\n#VRT Rule Packages Snort.conf\n#\n#For more information visit us at:\n#.\n#.\n#.\n#Options : --enable-gre --enable-mpls --enable-targetbased\n--enable-ppm --enable-perfprofiling enable-zlib --enable-act\nlive-response --enable-normalizer --enable-reload --enable-react\nListing 2-2: Displaying the first 20 lines of snort.conf in the terminal window\nYou should see only the first 20 lines of snort.conf displayed in your\nterminal window.\nGrabbing That Tail\nThe tail command is similar to the head command, but it’s used to view the\nlast lines of a file. Let’s use it on snort.conf:\nkali >tail /etc/snort/snort.conf\n#include $SO_RULE_PATH/smtp.rules\n#include $SO_RULE_PATH/specific-threats.rules\n#include $SO_RULE_PATH/web-activex.rules\n#include $SO_RULE_PATH/web-client.rules\n#include $SO_RULE_PATH/web-iis.rules\n#include $SO_RULE_PATH/web-miscp.rules\n#Event thresholding and suppression commands. See threshold.conf\nNotice that this command displays some of the last include lines of the\nrules files, but not all of them, because similar to head, the default for tail is to\nshow 10 lines. You can display more lines by grabbing the last 20 lines of\nsnort.conf. As with the head command, you can tell tail how many lines to\ndisplay by entering a dash (-) and then the number of lines between the\ncommand and the filename, as shown in Listing 2-3.\nkali >tail -20 /etc/snort/snort.conf\n#include $SO_RULE_PATH/chat.rules\n#include $SO_RULE_PATH/chat.rules\n#include $SO_RULE_PATH/chat.rules"
  },
  {
    "input": "Filtering Text with grep",
    "output": "--snip--\n#Event thresholding or suppression commands. See theshold.conf\nListing 2-3: Displaying the last 20 lines of snort.conf in the terminal window\nNow we can view nearly all the include lines of the rules files on one\nscreen.\nNumbering the Lines\nSometimes—especially with very long files—we may want the file to display\nline numbers. Since snort.conf has more than 600 lines, line numbers would\nbe useful here. This makes it easier to reference changes and come back to\nthe same place within the file.\nTo display a file with line numbers, we use the nl (number lines)\ncommand. Simply enter the command shown in Listing 2-4.\nkali >nl /etc/snort/snort.conf\n612 #################################################################\n613 #dynamic library rules\n614 #include $SO_RULE_PATH/bad-traffic.rules\n615 #include $SO_RULE_PATH/chat.rules\n--snip--\n630 #include $SO_RULE_PATH/web-iis.rules\n631 #include $SO_RULE_PATH/web-misc.rules\nListing 2-4: Displaying line numbers in terminal output\nEach line now has a number, making referencing much easier.\nFiltering Text with grep\nThe command grep is probably the most widely used text manipulation\ncommand. It lets you filter the content of a file for display. If, for instance,\nyou want to see all lines that include the word output in your snort.conf file,\nyou could use cat and ask it to display only those lines (see Listing 2-5).\nkali >cat /etc/snort/snort.conf | grep output\n# 6) Configure output plugins\n# Step #6: Configure output plugins\n# output unified2: filename merged.log, limit 128, nostamp, mpls_event_types,\nvlan_event_types\noutput unified2: filename merged.log, limit 128, nostamp, mpls_event_types,\nvlan_event_types\n# output alert_unified2: filename merged.log, limit 128, nostamp\n# output log_unified2: filename merged.log, limit 128, nostamp\n# output alert_syslog: LOG_AUTH LOG_ALERT\n# output log_tcpdump: tcpdump.log\nListing 2-5: Displaying lines with instances of the keyword or phrase specified by grep\nThis command will first view snort.conf and then use a pipe (|) to send it\nto grep, which will take the file as input, look for lines with occurrences of the\nword output, and display only those lines. The grep command is a very\npowerful and essential command for working in Linux, because it can save\nyou hours of searching for every occurrence of a word or command in a file.\nHacker Challenge: Using grep, nl, tail, and head\nLet’s say you want to display the five lines immediately before a line that says\n# Step #6: Configure output plugins using at least four of the commands you just\nlearned. How would you do it? (Hint: there are many more options to these\ncommands than those we’ve discussed. You can learn more commands by\nusing the built-in Linux command man. For example, man tail will show the\nhelp file for the tail command.)\nThere are many ways to solve this challenge; here, I show you which lines\nto change to do it one way, and your job is to find another method.\nStep 1\nkali >nl/etc/snort.conf | grep output\n34 # 6) Configure output plugins\n512 # Step #6: Configure output plugins\n518 # output unified2: filename merged.log, limit 128, nostamp,\nmpls_event_types, vlan_event_types\n521 # output alert_unified2: filename snort.alert, limit 128, nostamp\n522 # output log_unified2: filename snort.log, limit 128, nostamp\n525 # output alert_syslog: LOG_AUTH LOG_ALERT\n528 # output log_tcpdump: tcpdump.log\nWe can see that the line # Step #6: Configure output plugins is line 512, and\nwe know we want the five lines preceding line 512 as well as line 512 itself\n(that is, lines 507 to 512).\nStep 2\nkali >tail -n+507 /etc/snort/snort.conf | head -n 6\nnested_ip inner, \\"
  },
  {
    "input": "Using sed to Find and Replace",
    "output": "whitelist $WHITE_LIST_PATH/white_list.rules, \\\nblacklist $BLACK_LIST_PATH/black_list.rules\n###################################################\n# Step #6: Configure output plugins\nHere, we use tail to start at line 507 and then output into head, and we\nreturn just the top six lines, giving us the five lines preceding the Step #6 line,\nwith that line included.\nUsing sed to Find and Replace\nThe sed command lets you search for occurrences of a word or a text pattern\nand then perform some action on it. The name of the command is a\ncontraction of stream editor, because it follows the same concept as a stream\neditor. In its most basic form, sed operates like the Find and Replace function\nin Windows.\nSearch for the word mysql in the snort.conf file using grep, like so:\nkali >cat /etc/snort/snort.conf | grep mysql\ninclude $RULE_PATH/mysql.rules\n#include $RULE_PATH/server-mysql.rules\nYou should see that the grep command found two occurrences of mysql.\nLet’s say you want sed to replace every occurrence of mysql with MySQL\n(remember, Linux is case sensitive) and then save the new file to snort2.conf.\nYou could do this by entering the command shown in Listing 2-6.\nkali >sed s/mysql/MySQL/g /etc/snort/snort.conf > snort2.conf\nListing 2-6: Using sed to find and replace keywords or phrases\nThe s command performs the search: you first give the term you are\nsearching for (mysql) and then the term you want to replace it with (MySQL),\nseparated by a slash (/). The g command tells Linux that you want the\nreplacement performed globally. Then the result is saved to a new file\nnamed snort2.conf.\nNow, when you use grep with snort2.conf to search for mysql, you’ll see that\nno instances were found, but when you search for MySQL, you’ll see two\noccurrences."
  },
  {
    "input": "Viewing Files with more and less",
    "output": "kali >cat snort2.conf | grep MySQL\ninclude $RULE_PATH/MySQL.rules\n#include $RULE_PATH/server-MySQL.rules\nIf you wanted to replace only the first occurrence of the term mysql, you\nwould leave out the trailing g command.\nkali >sed s/mysql/MySQL/ snort.conf > snort2.conf\nYou can also use the sed command to find and replace any specific\noccurrence of a word rather than all occurrences or just the first occurrence.\nFor instance, if you want to replace only the second occurrence of the word\nmysql, simply place the number of the occurrence (in this case, 2) at the end\nof the command:\nkali >sed s/mysql/MySQL/2 snort.conf > snort2.conf\nThis command affects only the second occurrence of mysql.\nViewing Files with more and less\nAlthough cat is a good utility for displaying files and creating small files, it\ncertainly has its limitations when displaying large files. When you use cat\nwith snort.conf, the file scrolls through every page until it comes to the end,\nwhich is not very practical if you want to glean any information from it.\nFor working with larger files, we have two other viewing utilities: more and\nless.\nControlling the Display with more\nThe more command displays a page of a file at a time and lets you page down\nthrough it using the ENTER key. It’s the utility that the man pages use, so\nlet’s look at it first. Open snort.conf with the more command, as shown in\nListing 2-7.\nkali >more /etc/snort/snort.conf\n--snip--\n# Snort build options:\n# Options: --enable-gre --enable-mpls --enable-targetbased\n--enable-ppm --enable-perfprofiling enable-zlib --enable-active\n-response --enable-normalizer --enable-reload --enable-react\n--enable-flexresp3\n#\n--More--(2%)\nListing 2-7: Using more to display terminal output one page at a time\nNotice that more displays only the first page and then stops, and it tells us\nin the lower-left corner how much of the file is shown (2 percent in this\ncase). To see additional lines or pages, press ENTER. To exit more, enter q (for\nquit).\nDisplaying and Filtering with less\nThe less command is very similar to more, but with additional functionality—\nhence, the common Linux aficionado quip, “Less is more.” With less, you\ncan not only scroll through a file at your leisure, but you can also filter it for\nterms. As in Listing 2-8, open snort.conf with less.\nkali >less /etc/snort/snort.conf\n--snip--\n# Snort build options:\n# Options: --enable-gre --enable-mpls --enable-targetbased\n--enable-ppm --enable-perfprofiling enable-zlib --enable-active\n-response --enable-normalizer --enable-reload --enable-react\n/etc/snort/snort.conf\nListing 2-8: Using less to both display terminal output a page at a time and filter results\nNotice in the bottom left of the screen that less has highlighted the path\nto the file. If you press the forward slash (/) key, less will let you search for\nterms in the file. For instance, when you first set up Snort, you need to\ndetermine how and where you want to send your intrusion alert output. To\nfind that section of the configuration file, you could simply search for output,\nlike so:\n# Snort build options:\n# Options: --enable-gre --enable-mpls --enable-targetbased\n--enable-ppm --enable-perfprofiling enable-zlib --enable-active\n-response --enable-normalizer --enable-reload --enable-react\n/output\nThis will immediately take you to the first occurrence of output and\nhighlight it. You can then look for the next occurrence of output by typing n\n(for next)."
  },
  {
    "input": "Exercises",
    "output": "# Step #6: Configure output plugins\n# For more information, see Snort Manual, Configuring Snort - Output Modules\n#####################################################################\n#unified2\n# Recommended for most installs\n# output unified2: filename merged.log, limit 128, nostamp, mpls_event_types,\nvlan_event_types\noutput unified2: filename snort.log, limit 128, nostamp, mpls_event_types,\nvlan_event_types\n# Additional configuration for specific types of installs\n# output alert_unified2: filename snort.alert, limit 128, nostamp\n# output log_unified2: filename snort.log, limit 128, nostamp\n# syslog\n# output alert_syslog: LOG_AUTH LOG_ALERT\n:\nAs you can see, less took you to the next occurrence of the word output\nand highlighted all the search terms. In this case, it went directly to the\noutput section of Snort. How convenient!\nSummary\nLinux has numerous ways of manipulating text, and each way comes with its\nown strengths and weaknesses. We’ve touched on a few of the most useful\nmethods in this chapter, but I suggest you try each one out and develop your\nown feel and preferences. For example, I think grep is indispensable, and I\nuse less widely, but you might feel different.\nEXERCISES\nBefore you move on to Chapter 3, try out the skills you learned from this chapter by\ncompleting the following exercises:\n1. Navigate to /usr/share/wordlists/metasploit. This is a directory of multiple wordlists that\ncan be used to brute force passwords in various password-protected devices using\nMetasploit, the most popular pentesting and hacking framework.\n2. Use the cat command to view the contents of the file passwords.lst.\n3. Use the more command to display the file passwords.lst.\n4. Use the less command to view the file passwords.lst.\n5. Now use the nl command to place line numbers on the passwords in passwords.lst. There\nshould be 88,396 passwords.\n6. Use the tail command to see the last 20 passwords in passwords.lst.\n7. Use the cat command to display passwords.lst and pipe it to find all the passwords that\ncontain 123."
  },
  {
    "input": "Analyzing Networks with ifconfig",
    "output": "3\nANALYZING AND MANAGING NETWORKS\nUnderstanding networking is crucial for any aspiring hacker. In many\nsituations, you’ll be hacking something over a network, and a good hacker\nneeds to know how to connect to and interact with that network. For\nexample, you may need to connect to a computer with your Internet\nProtocol (IP) address hidden from view, or you may need to redirect a\ntarget’s Domain Name System (DNS) queries to your system; these kinds of\ntasks are relatively simple but require a little Linux network know-how. This\nchapter shows you some essential Linux tools for analyzing and managing\nnetworks during your network-hacking adventures.\nAnalyzing Networks with ifconfig\nThe ifconfig command is one of the most basic tools for examining and\ninteracting with active network interfaces. You can use it to query your\nactive network connections by simply entering ifconfig in the terminal. Try it\nyourself, and you should see output similar to Listing 3-1.\nkali >ifconfig\n➊eth0Linkencap:EthernetHWaddr 00:0c:29:ba:82:0f\n➋inet addr:192.168.181.131 ➌Bcast:192.168.181.255 ➍Mask:255.255.255.0\n--snip--\n➎lo Linkencap:Local Loopback\ninet addr:127.0.0.1 Mask:255.0.0.0\n--snip--\n➏wlan0 Link encap:EthernetHWaddr 00:c0:ca:3f:ee:02"
  },
  {
    "input": "Checking Wireless Network Devices with iwconfig",
    "output": "Listing 3-1: Using ifconfig to get network information\nAs you can see, the command ifconfig shows some useful information\nabout the active network interfaces on the system. At the top of the output is\nthe name of the first detected interface, eth0 ➊, which is short for Ethernet0\n(Linux starts counting at 0 rather than 1). This is the first wired network\nconnection. If there were more wired Ethernet interfaces, they would show\nup in the output using the same format (eth1, eth2, and so on).\nThe type of network being used (Ethernet) is listed next, followed by HWaddr\nand an address; this is the globally unique address stamped on every piece of\nnetwork hardware—in this case, the network interface card (NIC), usually\nreferred to as the media access control (MAC) address.\nThe second line contains information on the IP address currently\nassigned to that network interface (in this case, 192.168.181.131 ➋); the Bcast\n➌, or broadcast address, which is the address used to send out information to\nall IPs on the subnet; and finally the network mask (Mask ➍), which is used to\ndetermine what part of the IP address is connected to the local network.\nYou’ll also find more technical info in this section of the output, but it’s\nbeyond the scope of this Linux networking basics chapter.\nThe next section of the output shows another network connection called\nlo ➎, which is short for loopback address and is sometimes called localhost. This\nis a special software address that connects you to your own system. Software\nand services not running on your system can’t use it. You would use lo to test\nsomething on your system, such as your own web server. The localhost is\ngenerally represented with the IP address 127.0.0.1.\nThe third connection is the interface wlan0 ➏. This appears only if you\nhave a wireless interface or adapter, as I do here. Note that it also displays\nthe MAC address of that device (HWaddr).\nThis information from ifconfig enables you to connect to and manipulate\nyour local area network (LAN) settings, an essential skill for hacking.\nChecking Wireless Network Devices with iwconfig\nIf you have a wireless adapter, you can use the iwconfig command to gather"
  },
  {
    "input": "Changing Your Network Information",
    "output": "crucial information for wireless hacking such as the adapter’s IP address, its\nMAC address, what mode it’s in, and more. The information you can glean\nfrom this command is particularly important when you’re using wireless\nhacking tools like aircrack-ng.\nUsing the terminal, let’s take a look at some wireless devices with iwconfig\n(see Listing 3-2).\nkali >iwconfig\nwlan0 IEEE 802.11bg ESSID:off/any\nMode:Managed Access Point: Not Associated Tx-Power=20 dBm\n--snip--\nlo no wireless extensions\neth0 no wireless extensions\nListing 3-2: Using iwconfig to get information on wireless adapters\nThe output here tells us that the only network interface with wireless\nextensions is wlan0, which is what we would expect. Neither lo nor eth0 has\nany wireless extensions.\nFor wlan0, we learn what 802.11 IEEE wireless standards our device is\ncapable of: b and g, two early wireless communication standards. Most\nwireless devices now include n as well (n is the latest standard).\nWe also learn from iwconfig the mode of the wireless extension (in this\ncase, Mode:Managed, in contrast to monitor or promiscuous mode). We’ll need\npromiscuous mode for cracking wireless passwords.\nNext, we can see that the wireless adapter is not connected (Not Associated)\nto an access point (AP) and that its power is 20 dBm, which represents the\nstrength of signal. We’ll spend more time with this information in Chapter\n14.\nChanging Your Network Information\nBeing able to change your IP address and other network information is a\nuseful skill because it will help you access other networks while appearing as\na trusted device on those networks. For example, in a denial-of-service (DoS)\nattack, you can spoof your IP so that that the attack appears to come from\nanother source, thus helping you evade IP capture during forensic analysis.\nThis is a relatively simple task in Linux, and it’s done with the ifconfig\ncommand.\nChanging Your IP Address\nTo change your IP address, enter ifconfig followed by the interface you want\nto reassign and the new IP address you want assigned to that interface. For\nexample, to assign the IP address 192.168.181.115 to interface eth0, you\nwould enter the following:\nkali >ifconfig eth0 192.168.181.115\nkali >\nWhen you do this correctly, Linux will simply return the command\nprompt and say nothing. This is a good thing!\nThen, when you again check your network connections with ifconfig, you\nshould see that your IP address has changed to the new IP address you just\nassigned.\nChanging Your Network Mask and Broadcast Address\nYou can also change your network mask (netmask) and broadcast address\nwith the ifconfig command. For instance, if you want to assign that same eth0\ninterface with a netmask of 255.255.0.0 and a broadcast address of\n192.168.1.255, you would enter the following:\nkali >ifconfig eth0 192.168.181.115 netmask 255.255.0.0 broadcast 192.168.1.255\nkali >\nOnce again, if you’ve done everything correctly, Linux responds with a\nnew command prompt. Now enter ifconfig again to verify that each of the\nparameters has been changed accordingly.\nSpoofing Your MAC Address\nYou can also use ifconfig to change your MAC address (or HWaddr). The MAC\naddress is globally unique and is often used as a security measure to keep\nhackers out of networks—or to trace them. Changing your MAC address to\nspoof a different MAC address is almost trivial and neutralizes those security\nmeasures. Thus, it’s a very useful technique for bypassing network access\ncontrols.\nTo spoof your MAC address, simply use the ifconfig command’s down\noption to take down the interface (eth0 in this case). Then enter the ifconfig\ncommand followed by the interface name (hw for hardware, ether for\nEthernet) and the new spoofed MAC address. Finally, bring the interface\nback up with the up option for the change to take place. Here’s an example:\nkali >ifconfig eth0 down\nkali >ifconfig eth0 hw ether 00:11:22:33:44:55\nkali >ifconfig eth0 up\nNow, when you check your settings with ifconfig, you should see that\nHWaddr has changed to your new spoofed IP address!\nAssigning New IP Addresses from the DHCP Server\nLinux has a Dynamic Host Configuration Protocol (DHCP) server that runs\na daemon—a process that runs in the background—called dhcpd, or the dhcp\ndaemon. The DHCP server assigns IP addresses to all the systems on the\nsubnet and keeps log files of which IP address is allocated to which machine\nat any one time. This makes it a great resource for forensic analysts to trace\nhackers with after an attack. For that reason, it’s useful to understand how\nthe DHCP server works.\nUsually, to connect to the internet from a LAN, you must have a DHCP-\nassigned IP. Therefore, after setting a static IP address, you must return and\nget a new DHCP-assigned IP address. To do this, you can always reboot\nyour system, but I’ll show you how to retrieve a new DHCP without having\nto shut your system down and restart it.\nTo request an IP address from DHCP, simply call the DHCP server with\nthe command dhclient followed by the interface you want the address\nassigned to. Different Linux distributions use different DHCP clients, but\nKali is built on Debian, which uses dhclient. Therefore, you can assign a new\naddress like this:\nkali >dhclient eth0\nThe dhclient command sends a DHCPDISCOVER request from the network\ninterface specified (here, eth0). It then receives an offer (DHCPOFFER) from the\nDHCP server (192.168.181.131 in this case) and confirms the IP assignment"
  },
  {
    "input": "Manipulating the Domain Name System",
    "output": "to the DHCP server with a dhcp request.\nkali >ifconfig\neth0Linkencap:EthernetHWaddr 00:0c:29:ba:82:0f\ninet addr:192.168.181.131 Bcast:192.168.181.131 Mask:255.255.255.0\nDepending on the configuration of the DHCP server, the IP address\nassigned in each case might be different.\nNow when you enter ifconfig, you should see that the DHCP server has\nassigned a new IP address, a new broadcast address, and new netmask to\nyour network interface eth0.\nManipulating the Domain Name System\nHackers can find a treasure trove of information on a target in its Domain\nName System (DNS). DNS is a critical component of the internet, and\nalthough it’s designed to translate domain names to IP addresses, a hacker\ncan use it to garner information on the target.\nExamining DNS with dig\nDNS is the service that translates a domain name like hackers-arise.com to the\nappropriate IP address; that way, your system knows how to get to it.\nWithout DNS, we would all have to remember thousands of IP addresses for\nour favorite websites—no small task even for a savant.\nOne of the most useful commands for the aspiring hacker is dig, which\noffers a way to gather DNS information about a target domain. The stored\nDNS information can be a key piece of early reconnaissance to obtain before\nattacking. This information could include the IP address of the target’s\nnameserver (the server that translates the target’s name to an IP address), the\ntarget’s email server, and potentially any subdomains and IP addresses.\nFor instance, enter dig hackers-arise.com and add the ns option (short for\nnameserver). The nameserver for hackers-arise.com is displayed in the ANSWER\nSECTION of Listing 3-3.\nkali >dig hackers-arise.com ns\n--snip--\n;; QUESTION SECTION:\n;hackers-arise.com. IN NS\n;; ANSWER SECTION:\nhackers-arise.com. 5 IN NS ns7.wixdns.net.\nhackers-arise.com. 5 IN NS ns6.wixdns.net.\n;; ADDITIONAL SECTION:\nns6.wixdns.net. 5 IN A 216.239.32.100\n--snip--\nListing 3-3: Using dig and its ns option to get information on a domain nameserver\nAlso note in the ADDITIONAL SECTION that this dig query reveals the IP address\n(216.239.32.100) of the DNS server serving hackers-arise.com.\nYou can also use the dig command to get information on email servers\nconnected to a domain by adding the mx option (mx is short for mail exchange\nserver). This information is critical for attacks on email systems. For\nexample, info on the www.hackers-arise.com email servers is shown in the\nAUTHORITY SECTION of Listing 3-4.\nkali >dig hackers-arise.com mx\n--snip--\n;; QUESTION SECTION:\n;hackers-arise.com. IN MX\n;; AUTHORITY SECTION:\nhackers-arise.com. 5 IN SOA ns6.wixdns.net. support.wix.com 2016052216 10800\n3600 604 800 3600\n--snip--\nListing 3-4: Using dig and its mx option to get information on a domain mail exchange server\nThe most common Linux DNS server is the Berkeley Internet Name\nDomain (BIND). In some cases, Linux users will refer to DNS as BIND, but\ndon’t be confused: DNS and BIND both map individual domain names to\nIP addresses.\nChanging Your DNS Server\nIn some cases, you may want to use another DNS server. To do so, you’ll\nedit a plaintext file named /etc/resolv.conf on the system. Open that file in a\ntext editor—I’m using Leafpad. Then, on your command line, enter the\nprecise name of your editor followed by the location of the file and the\nfilename. For example,\nkali >leafpad /etc/resolv.conf\nwill open the resolv.conf file in the /etc directory in my specified graphical text\neditor, Leafpad. The file should look something like Figure 3-1.\nFigure 3-1: A typical resolv.conf file in a text editor\nAs you can see on line 3, my nameserver is set to a local DNS server at\n192.168.181.2. That works fine, but if I want to add or replace that DNS\nserver with, say, Google’s public DNS server at 8.8.8.8, I’d add the following\nline in the /etc/resolv.conf file to specify the nameserver:\nnameserver 8.8.8.8\nThen I would just need to save the file. However, you can also achieve\nthe same result exclusively from the command line by entering the\nfollowing:\nkali >echo \"nameserver 8.8.8.8\"> /etc/resolv.conf\nThis command echoes the string nameserver 8.8.8.8 and redirects it (>) to\nthe file /etc/resolv.conf, replacing the current content. Your /etc/resolv.conf file\nshould now look like Figure 3-2.\nFigure 3-2: Changing the resolv.conf file to specify Google’s DNS server\nIf you open the /etc/resolv.conf file now, you should see that it points the\nDNS requests to Google’s DNS server rather than your local DNS server.\nYour system will now go out to the Google public DNS server to resolve\ndomain names to IP addresses. This can mean domain names take a little\nlonger to resolve (probably milliseconds). Therefore, to maintain speed but\nkeep the option of using a public server, you might want to retain the local\nDNS server in the resolv.conf file and follow it with a public DNS server. The\noperating system queries each DNS server listed in the order it appears in\n/etc/resolv.conf, so the system will only refer to the public DNS server if the\ndomain name can’t be found in the local DNS server.\nNOTE\nIf you’re using a DHCP address and the DHCP server provides a DNS setting,\nthe DHCP server will replace the contents of the file when it renews the DHCP\naddress.\nMapping Your Own IP Addresses\nA special file on your system called the hosts file also performs domain name–\nIP address translation. The hosts file is located at /etc/hosts, and kind of as\nwith DNS, you can use it to specify your own IP address–domain name\nmapping. In other words, you can determine which IP address your browser\ngoes to when you enter www.microsoft.com (or any other domain) into the\nbrowser, rather than let the DNS server decide. As a hacker, this can be\nuseful for hijacking a TCP connection on your local area network to direct\ntraffic to a malicious web server with a tool such as dnsspoof.\nFrom the command line, type in the following command (you can\nsubstitute your preferred text editor for leafpad):\nkali >leafpad /etc/hosts\nYou should now see your hosts file, which will look something like Figure\n3-3.\nFigure 3-3: A default Kali Linux hosts file"
  },
  {
    "input": "Exercises",
    "output": "By default, the hosts file contains only a mapping for your localhost, at\n127.0.0.1, and your system’s hostname (in this case, Kali, at 127.0.1.1). But\nyou can add any IP address mapped to any domain you’d like. As an example\nof how this might be used, you could map www.bankofamerica.com to your\nlocal website, at 192.168.181.131.\n127.0.0.1 localhost\n127.0.1.1 kali\n192.168.181.131 bankofamerica.com\n# The following lines are desirable for IPv6 capable hosts\n::1 localhost ip6-localhost ip6-loopback\nff02::1 ip6-allnodes\nff02::2 ip6-allrouters\nMake certain you press TAB between the IP address and the domain key—\nnot the spacebar.\nAs you get more involved in your hacking endeavors and learn about tools\nlike dnsspoof and Ettercap, you’ll be able to use the hosts file to direct any\ntraffic on your LAN that visits www.bankofamerica.com to your web server at\n192.168.181.131.\nPretty easy, right?\nSummary\nAny hacker needs some basic Linux networking skills to connect, analyze,\nand manage networks. As you progress, these skills will become more and\nmore useful for doing reconnaissance, spoofing, and connecting to target\nsystems.\nEXERCISES\nBefore you move on to Chapter 4, try out the skills you learned from this chapter by\ncompleting the following exercises:\n1. Find information on your active network interfaces.\n2. Change the IP address on eth0 to 192.168.1.1.\n3. Change your hardware address on eth0.\n4. Check whether you have any available wireless interfaces active.\n5. Reset your IP address to a DHCP-assigned address.\n6. Find the nameserver and email server of your favorite website.\n7. Add Google’s DNS server to your /etc/resolv.conf file so your system refers to that server\nwhen it can’t resolve a domain name query with your local DNS server."
  },
  {
    "input": "Using apt to Handle Software",
    "output": "4\nADDING AND REMOVING SOFTWARE\nOne of the most fundamental tasks in Linux—or any operating system—is\nadding and removing software. You’ll often need to install software that\ndidn’t come with your distribution or remove unwanted software so it\ndoesn’t take up hard drive space.\nSome software requires other software to run, and you’ll sometimes find\nthat you can download everything you need at once in a software package,\nwhich is a group of files—typically libraries and other dependencies—that\nyou need for a piece of software to run successfully. When you install a\npackage, all the files within it are installed together, along with a script to\nmake loading the software simpler.\nIn this chapter, we examine three key methods for adding new software:\napt package manager, GUI-based installation managers, and git.\nUsing apt to Handle Software\nIn Debian-based Linux distributions, which include Kali and Ubuntu, the\ndefault software manager is the Advanced Packaging Tool, or apt, whose\nprimary command is apt-get. In its simplest and most common form, you can\nuse apt-get to download and install new software packages, but you can also\nupdate and upgrade software with it.\nSearching for a Package\nBefore downloading a software package, you can check whether the package\nyou need is available from your repository, which is a place where your\noperating system stores information. The apt tool has a search function that\ncan check whether the package is available. The syntax is straightforward:\napt-cache search keyword\nNote that we use the apt-cache command to search the apt cache, or the\nplace it stores the package names. So if you were searching for the intrusion\ndetection system Snort, for example, you would enter the command shown\nin Listing 4-1.\nkali >apt-cache search snort\nfwsnort - Snort-to-iptables rule translator\nippl - IP protocols logger\n--snip--\nsnort - flexible Network Intrusion Detection System\nsnort-common - flexible Network Intrusion Detection System - common files\n--snip--\nListing 4-1: Searching the system with apt-cache for Snort\nAs you can see, numerous files have the keyword snort in them, but near\nthe middle of the output we see snort – flexible Network Intrusion Detection\nSystem. That’s what we are looking for!\nAdding Software\nNow that you know the snort package exists in your repository, you can use\napt-get to download the software.\nTo install a piece of software from your operating system’s default\nrepository in the terminal, use the apt-get command, followed by the\nkeyword install and then the name of the package you want to install. The\nsyntax looks like this:\napt-get install packagename\nLet’s try this out by installing Snort on your system. Enter apt-get install\nsnort as a command statement, as shown in Listing 4-2.\nkali >apt-get install snort\nReading package lists... Done\nBuilding dependency tree\nReading state information... Done\nSuggested packages:\nsnort-doc\nThe following NEW packages will be installed:\nsnort\n--snip--\nInstall these packages without verification [Y/n]?\nListing 4-2: Installing Snort with apt-get install\nThe output you see tells you what is being installed. If everything looks\ncorrect, go ahead and enter y when prompted, and your software installation\nwill proceed.\nRemoving Software\nWhen removing software, use apt-get with the remove option, followed by the\nname of the software to remove (see Listing 4-3).\nkali >apt-get remove snort\nReading package lists... Done\nBuilding dependency tree\nReading state information... Done\nThe following packages were automatically installed and are no longer\nrequired:\nlibdaq0 libprelude2 oinkmaster snort-common-libraries snort-rules-default\n--snip--\nDo you want to continue [Y/n]?\nListing 4-3: Removing Snort with apt-get remove\nAgain, you’ll see the tasks being done in real time and you will be asked\nwhether you want to continue. You can enter y to uninstall, but you might\nwant to keep Snort since we’ll be using it again. The remove command doesn’t\nremove the configuration files, which means you can reinstall the same\npackage in the future without reconfiguring.\nIf you do want to remove the configuration files at the same time as the\npackage, you can use the purge option, as shown in Listing 4-4.\nkali >apt-get purge snort\nReading package lists... Done\nBuilding dependency tree\nReading state information... Done\nThe following packages were automatically installed and are no longer required:\nlibdaq0 libprelude2 oinkmaster snort-common-libraries snort-rules-default\n--snip--\nDo you want to continue [Y/n]?\nListing 4-4: Removing Snort and the accompanying configuration files with apt-get purge\nSimply enter Y at the prompt to continue the purge of the software\npackage and the configuration files.\nYou may have noticed the line The following packages were automatically\ninstalled and are no longer required in the output. To keep things small and\nmodular, many Linux packages are broken into software units that many\ndifferent programs might use. When you installed Snort, you installed\nseveral dependencies or libraries with it that Snort requires in order to run.\nNow that you’re removing Snort, those other libraries or dependencies are\nno longer required, so they are removed, too.\nUpdating Packages\nSoftware repositories will be periodically updated with new software or new\nversions of existing software. These updates don’t reach you automatically,\nso you have to request them in order to apply these updates to your own\nsystem. Updating isn’t the same as upgrading: updating simply updates the list\nof packages available for download from the repository, whereas upgrading\nwill upgrade the package to the latest version in the repository.\nYou can update your individual system by entering the apt-get command\nfollowed by the keyword update. This will search through all the packages on\nyour system and check whether updates are available. If so, the updates are\ndownloaded (see Listing 4-5).\nkali >apt-get update\nGet:1 http://mirrors.ocf.berkeley.edu/kali kali-rolling InRelease [30.5kb]\nGet:2 http://mirrors.ocf.berkeley.edu/kali kali-rolling/main amd64 Packages [14.9MB]\nGet:3 http://mirrors.ocf.berkeley.edu/kali kali-rolling non-free amd64 Packages\n[163kb]\nGet:4 http://mirrors.ocf.berkeley.edu/kali kali-rolling/contrib amd64 Packages [107\nkB]\nFetched 15.2 MB in 1min 4s (236 kB/s)\nReading package lists... Done\nListing 4-5: Updating all out-of-date packages with apt-get update\nThe list of available software in the repository on your system will be\nupdated. If the update is successful, your terminal will state Reading package"
  },
  {
    "input": "Adding Repositories to Your sources.list File",
    "output": "lists... Done, as you can see in Listing 4-5. Note that the name of the\nrepository and the values—time, size, and so on—might be different on your\nsystem.\nUpgrading Packages\nTo upgrade the existing packages on your system, use apt-get upgrade. Because\nupgrading your packages may make changes to your software, you must be\nlogged in as root or use the sudo command before entering apt-get upgrade.\nThis command will upgrade every package on your system that apt knows\nabout, meaning only those stored in the repository (see Listing 4-6).\nUpgrading can be time-consuming, so you might not be able to use your\nsystem for a while.\nkali >apt-get upgrade\nReading package lists... Done\nBuilding dependency tree... Done\nCalculating upgrade... Done\nThe following packages were automatically installed and no longer required:\n--snip--\nThe following packages will be upgraded:\n--snip--\n1101 upgraded, 0 newly installed, 0 to remove and 318 not upgraded.\nNeed to get 827 MB of archives.\nAfter this operation, 408 MB disk space will be freed.\nDo you want to continue? [Y/n]\nListing 4-6: Upgrading all out-of-date packages with apt-get upgrade\nYou should see in the output that your system estimates the amount of\nhard drive space necessary for the software package. Go ahead and enter Y if\nyou want to continue and have enough hard drive space for the upgrade.\nAdding Repositories to Your sources.list File\nThe servers that hold the software for particular distributions of Linux are\nknown as repositories. Nearly every distribution has its own repositories of\nsoftware—developed and configured for that distribution—that might not\nwork well, or at all, with other distributions. Although these repositories\noften contain the same or similar software, they aren’t identical, and they\nsometimes have different versions of the same software or entirely different\nsoftware.\nYou will, of course, be using the Kali repository, which has a large\namount of security and hacking software. But because Kali specializes in\nsecurity and hacking, it doesn’t include some specialty software and tools and\neven some run-of-the-mill software. It’s worth adding a backup repository or\ntwo that your system can search through in case it doesn’t find it a specific\nsoftware in the Kali repository.\nThe repositories your system will search for software are stored in the\nsources.list file, and you can alter this file to define from which repositories\nyou want to download software. I often add the Ubuntu repositories after\nthe Kali repositories in my sources.list file; that way, when I request to\ndownload a new software package, my system will first look in the Kali\nrepository, and if the software package isn’t there, it will look in the Ubuntu\nrepository.\nYou can find the sources.list file at /etc/apt/sources.list and open it with any\ntext editor. I’ll again be using Leafpad. To open the sources.list file, enter the\nfollowing into your terminal, replacing leafpad with the name of your editor:\nkali >leafpad /etc/apt/sources.list\nAfter entering this command, you should see a window like the one in\nFigure 4-1, with a list of Kali’s default repositories.\nFigure 4-1: Kali’s default repositories in sources.list\nMany Linux distributions divide repositories into separate categories. For\ninstance, Ubuntu breaks out its repository categories as follows:\nmain Contains supported open source software\nuniverse Contains community-maintained open source software"
  },
  {
    "input": "Using a GUI-based Installer",
    "output": "multiverse Contains software restricted by copyright or other legal\nissues\nrestricted Contains proprietary device drivers\nbackports Contains packages from later releases\nI don’t recommend using testing, experimental, or unstable repositories\nin your sources.list because they can download problematic software to your\nsystem. Software that isn’t fully tested might break your system.\nWhen you ask to download a new software package, the system looks\nsequentially through your repositories listed in sources.list and stops when it\nfinds the desired package. Check first that the repository is compatible for\nyour system. Kali, like Ubuntu, is built on Debian, so these repositories work\npretty well with each of these systems.\nTo add a repository, just edit the sources.list file by adding the name of the\nrepository to the list and then save the file. Say, for example, you want to\ninstall Oracle Java 8 on Kali. No apt package for Oracle Java 8 is available as\npart of the default Kali sources, but a quick search online shows that the fine\nfolk at WebUpd8 have created one. If you add their repository to the\nsources, you can then install Oracle Java 8 with the apt-get install oracle-\njava8-installer command. At the time of writing, you would need to add the\nfollowing repository locations to sources.list in order to add the necessary\nrepositories:\ndeb http://ppa.launchpad.net/webupd8team/java/ubuntu trusty main\ndeb-src http://ppa.launchpad.net/webupd8team/java/ubuntu precise main\nUsing a GUI-based Installer\nNewer versions of Kali no longer include a GUI-based software installation\ntool, but you can always install one with the apt-get command. The two most\ncommon GUI-based installation tools are Synaptic and Gdebi. Let’s install\nSynaptic and use it to install our Snort package:\nkali >apt-get install synaptic\nReading package lists... Done\nBuilding dependency tree\nReading state information... Done\n--snip--\nProcessing triggers for menu (2.1.47)...\nkali >\nOnce you have Synaptic installed, you can start it from Settings ▸\nSynaptic Package Manager, which should open a window like the one in\nFigure 4-2.\nFigure 4-2: The Synaptic Package Manager interface\nNow you can search for the package you’re looking for. Simply click the\nSearch tab to open a search window. Because you are looking for Snort\nagain, enter snort into the search window and click Search. Scroll down the\nsearch results to find the package you’re looking for. Check the box next to\nsnort and then click the Apply tab, as shown in Figure 4-3. Synaptic will now\ndownload and install Snort from the repository along with any necessary\ndependencies."
  },
  {
    "input": "Installing Software with git",
    "output": "Figure 4-3: Downloading Snort from the Synaptic Package Manager\nInstalling Software with git\nSometimes the software you want isn’t available in any of the repositories—\nespecially if it’s brand new—but it may be available on github\n(https://www.github.com/), a site that allows developers to share their software\nwith others to download, use, and provide feedback. For instance, if you\nwant bluediving, a Bluetooth hacking and pentesting suite, and can’t find it\nin the Kali repository, you can search github for the software by entering\nbluediving into the search bar. If it exists on github, you should see the\nrepository for it in the search results.\nOnce you’ve found the software on github, you can install it from the\nterminal by entering the git clone command followed by its github URL. For\ninstance, bluediving is located at https://www.github.com/balle/bluediving.git.\nTo clone it into your system, enter the command shown in Listing 4-7.\nkali >git clone https://www.github.com/balle/bluediving.git\nCloning into 'bluediving'..."
  },
  {
    "input": "Exercises",
    "output": "remote: Counting objects: 131, Done.\nremote: Total 131 (delta 0), reused 0 (delta 0), pack-reused 131\nReceiving objects: 100% (131/131), 900.81 KiB | 646.00 KiB/s, Done.\nResolving deltas: 100% (9/9), Done.\nChecking connectivity... Done.\nListing 4-7: Cloning bluediving with git clone\nThe git clone command copies all the data and files from that location\nonto your system. You can check to see that they’ve been successfully\ndownloaded by using the long listing command ls –l on the target directory,\nlike so:\nkali >ls -l\nIf you’ve successfully cloned bluediving to your system, you should see\nthe following output:\ntotal 80\ndrwxr-xr-x 7 root root 4096 Jan 10 22:19 bluediving\ndrwxr-xr-x 2 root root 4096 Dec 5 11:17 Desktop\ndrwxr-xr-x 2 root root 4096 Dec 5 11:17 Documents\ndrwxr-xr-x 2 root root 4096 Dec 5 11:17 Downloads\ndrwxr-xr-x 2 root root 4096 Dec 5 11:17 Music\n--snip--\nAs you can see, bluediving has been successfully cloned to the system, and\na new directory named bluediving has been created for its files.\nSummary\nIn this chapter, you learned a few of the many ways to download and install\nnew software on your Linux system. Software package managers (like apt),\nGUI-based installers, and git clones are the most common and crucial\nmethods for an aspiring hacker to know. You’ll soon find yourself becoming\nfamiliar with each of them.\nEXERCISES\nBefore you move on to Chapter 5, try out the skills you learned from this chapter by\ncompleting the following exercises:\n1. Install a new software package from the Kali repository.\n2. Remove that same software package.\n3. Update your repository.\n4. Upgrade your software packages.\n5. Select a new piece of software from github and clone it to your system."
  },
  {
    "input": "Different Types of Users",
    "output": "5\nCONTROLLING FILE AND DIRECTORY\nPERMISSIONS\nNot every user of a single operating system should have the same level of\naccess to files and directories. Like any professional or enterprise-level\noperating system, Linux has methods for securing file and directory access.\nThis security system allows the system administrator—the root user—or the\nfile owner to protect their files from unwanted access or tampering by\ngranting select users permissions to read, write, or execute files. For each file\nand directory, we can specify the permission status for the file’s owner, for\nparticular groups of users, and for all other users. This is a necessity in a\nmultiuser, enterprise-level operating system. The alternative would be quite\nchaotic.\nIn this chapter, I’ll show you how to check for and change permissions on\nfiles and directories for select users, how to set default file and directory\npermissions, and how to set special permissions. Finally, you will see how a\nhacker’s understanding of permissions might help them exploit a system.\nDifferent Types of Users\nAs you know, in Linux, the root user is all-powerful. The root user can do\nbasically anything on the system. Other users on the system have more\nlimited capabilities and permissions and almost never have the access that"
  },
  {
    "input": "Granting Permissions",
    "output": "the root user has.\nThese other users are usually collected into groups that generally share a\nsimilar function. In a commercial entity, these groups might be finance,\nengineering, sales, and so on. In an IT environment, these groups might\ninclude developers, network administrators, and database administrators.\nThe idea is to put people with similar needs into a group that is granted\nrelevant permissions; then each member of the group inherits the group\npermissions. This is primarily for the ease of administering permissions and,\nthus, security.\nThe root user is part of the root group by default. Each new user on the\nsystem must be added to a group in order to inherit the permissions of that\ngroup.\nGranting Permissions\nEach and every file and directory must be allocated a particular level of\npermission for the different identities using it. The three levels of permission\nare as follows:\nr Permission to read. This grants permission only to open and view a file.\nw Permission to write. This allows users to view and edit a file.\nx Permission to execute. This allows users to execute a file (but not\nnecessarily view or edit it).\nIn this way, the root user can grant users a level of permission depending\non what they need the files for. When a file is created, typically the user who\ncreated it is the owner of the file, and the owning group is the user’s current\ngroup. The owner of the file can grant various access privileges to it. Let’s\nlook at how to change permissions to pass ownership to individual users and\nto groups.\nGranting Ownership to an Individual User\nTo move ownership of a file to a different user so that they have the ability\nto control permissions, we can use the chown (or change owner) command:\nkali >chown ➊bob ➋/tmp/bobsfile"
  },
  {
    "input": "Checking Permissions",
    "output": "Here, we give the command, the name of the user we are giving\nownership to, and then the location and name of the relevant file. This\ncommand grants the user account for Bob ➊ ownership of bobsfile ➋.\nGranting Ownership to a Group\nTo transfer ownership of a file from one group to another, we can use the\nchgrp (or change group) command.\nHackers are often more likely to work alone than in groups, but it’s not\nunheard of for several hackers or pentesters work together on a project, and\nin that case, using groups is necessary. For instance, you might have a group\nof pentesters and a group of security team members working on the same\nproject. The pentesters in this example are the root group, meaning they\nhave all permissions and access. The root group needs access to the hacking\ntools, whereas the security folk only need access to defensive tools such as an\nintrusion detection system (IDS). Let’s say the root group downloads and\ninstalls a program named newIDS; the root group will need to change the\nownership to the security group so the security group can use it at will. To\ndo so, the root group would simply enter the following command:\nkali >chgrp ➊security ➋newIDS\nThis command passes the security group ➊ ownership of newIDS ➋.\nNow you need to know how to check whether these allocations have\nworked. You’ll do that by checking a file’s permissions.\nChecking Permissions\nWhen you want to find out what permissions are granted to what users for a\nfile or directory, use the ls command with the –l (long) switch to display the\ncontents of a directory in long format—this list will contain the permissions.\nIn Listing 5-1, I use the ls –l command on the file /usr/share/hashcat (one of\nmy favorite password-cracking tools) in order to see what we can learn about\nthe files there.\nkali >ls –l /usr/share/hashcat\ntotal 32952\n➊ ➋ ➌ ➍ ➎ ➏ ➐\ndrwxr-xr-x 5 root root 4096 Dec 5 10:47 charsets\n-rw-r--r-- 1 root root 33685504 June 28 2018 hashcat.hcstat\n-rw-r--r-- 1 root root 33685504 June 28 2018 hashcat.hctune\ndrwxr -xr-x 2 root root 4096 Dec 5 10:47 masks\ndrwxr -xr-x 2 root root 4096 Dec 5 10:47 OpenCL\ndrwxr -xr-x 3 root root 4096 Dec 5 10:47 rules\nListing 5-1: Checking a file’s permissions with the long listing command\nOn each line, we get information about:\n➊ The file type\n➋ The permissions on the file for owner, groups, and users, respectively\n➌ The number of links (This topic is beyond the scope of the book.)\n➍ The owner of the file\n➎ The size of the file in bytes\n➏ When the file was created or last modified\n➐ The name of the file\nFor now, let’s focus on the seemingly incomprehensible strings of letters\nand dashes on the left edge of each line. They tell us whether an item is a file\nor directory and what permissions, if any, are on it.\nThe first character tells you the file type, where d stands for a directory\nand a dash (–) indicates a file. These are the two most common file types.\nThe next section defines the permissions on the file. There are three sets\nof three characters, made of some combination of read (r), write (w), and\nexecute (x), in that order. The first set represents the permissions of the\nowner; the second, those of the group; and the last, those of all other users.\nRegardless of which set of three letters you’re looking at, if you see an r\nfirst, that user or group of users has permission to open and read that file or\ndirectory. A w as the middle letter means they can write to (modify) the file\nor directory, and an x at the end means they can execute (or run) the file or\ndirectory. If any r, w, or x is replaced with a dash (-), then the respective\npermission hasn’t been given. Note that users can have permission to execute\nonly either binaries or scripts.\nLet’s use the third line of output in Listing 5-1 as an example:"
  },
  {
    "input": "Changing Permissions",
    "output": "-rw-r--r-- 1 root root 33685504 June 28 2018 hashcat.hcstat\nThe file is called, as we know from the right end of the line, hashcat.hcstat.\nAfter the initial – (which indicates it’s a file), the permissions rw- tell us that\nthe owner has read and write permissions but not execute permission.\nThe next set of permissions (r--) represents those of the group and shows\nthat the group has read permission but not write or execute permissions.\nAnd, finally, we see that the rest of the users also have only read permission\n(r--).\nThese permissions aren’t set in stone. As a root user or file owner, you\ncan change them. Next, we’ll do just that.\nChanging Permissions\nWe can use the Linux command chmod (or change mode) to change the\npermissions. Only a root user or the file’s owner can change permissions.\nIn this section, we use chmod to change permissions on hashcat.hcstat using\ntwo different methods. First we use a numerical representation of\npermissions, and then we use a symbolic representation.\nChanging Permissions with Decimal Notation\nWe can use a shortcut to refer to permissions by using a single number to\nrepresent one rwx set of permissions. Like everything underlying the\noperating system, permissions are represented in binary, so ON and OFF\nswitches are represented by 1 and 0, respectively. You can think of the rwx\npermissions as three ON/OFF switches, so when all permissions are granted,\nthis equates to 111 in binary.\nA binary set like this is then easily represented as one digit by converting\nit into octal, an eight-digit number system that starts with 0 and ends with 7.\nAn octal digit represents a set of three binary digits, meaning we can\nrepresent an entire rwx set with one digit. Table 5-1 contains all possible\npermission combinations and their octal and binary representatives.\nTable 5-1: Octal and Binary Representations of Permissions\nBinaryOctalrwx\n000 0 ---\n001 1 --x\n010 2 -w-\n011 3 -wx\n100 4 r--\n101 5 r-x\n110 6 rw-\n111 7 rwx\nUsing this information, let’s go through some examples. First, if we want\nto set only the read permission, we could consult Table 5-1 and locate the\nvalue for read:\nr w x\n4 - -\nNext, if we want to set the permission to wx, we could use the same\nmethodology and look for what sets the w and what sets the x:\nr w x\n- 2 1\nNotice in Table 5-1 that the octal representation for -wx is 3, which not so\ncoincidently happens to be the same value we get when we add the two\nvalues for setting w and x individually: 2 + 1 = 3.\nFinally, when all three permissions are on, it looks like this:\nr w x\n4 2 1\nAnd 4 + 2 + 1 = 7. Here, we see that in Linux, when all the permission\nswitches are on, they are represented by the octal equivalent of 7.\nSo, if we wanted to represent all permissions for the owner, group, and all\nusers, we could write it as follows:\n7 7 7\nHere’s where the shortcut comes in. By passing chmod three octal digits\n(one for each rwx set), followed by a filename, we can change permissions on\nthat file for each type of user. Enter the following into your command line:\nkali >chmod 774 hashcat.hcstat\nLooking at Table 5-1, we can see that this statement gives the owner all\npermissions, the group all permissions, and everyone else (other) only the\nread permission.\nNow we can see whether those permissions have changed by running ls -\nl on the directory and looking at the hashcat.hcstat line. Navigate to the\ndirectory and run that command now:\nkali >ls -l\ntotal 32952\ndrwxr-xr-x 5 root root 4096 Dec 5 10:47 charsets\n➊ -rwxrwxr-- 1 root root 33685504 June 28 2018 hashcat.hcstat\n-rw-r--r-- 1 root root 33685504 June 28 2018 hashcat.hctune\ndrwxr -xr-x 2 root root 4096 Dec 5 10:47 masks\ndrwxr -xr-x 2 root root 4096 Dec 5 10:47 OpenCL\ndrwxr -xr-x 3 root root 4096 Dec 5 10:47 rules\nYou should see -rwxrwxr-- on the left side of the hashcat.hcstat line ➊. This\nconfirms that the chmod call successfully changed permissions on the file to\ngive both the owner and the group the ability to execute the file.\nChanging Permissions with UGO\nAlthough the numeric method is probably the most common method for\nchanging permissions in Linux, some people find chmod’s symbolic method\nmore intuitive—both methods work equally well, so just find the one that\nsuits you. The symbolic method is often referred to as the UGO syntax,\nwhich stands for user (or owner), group, and others.\nUGO syntax is very simple. Enter the chmod command and then the users\nyou want to change permissions for, providing u for user, g for group, or o for\nothers, followed by one of three operators:\n- Removes a permission\n+ Adds a permission\n= Sets a permission\nAfter the operator, include the permission you want to add or remove\n(rwx) and, finally, the name of the file to apply it to.\nSo, if you want to remove the write permission from the user that the file\nhashcat.hcstat belongs to, you could enter the following:\nkali >chmod u-w hashcat.hcstat\nThis command says to remove (-) the write (w) permission from\nhashcat.hcstat for the user (u).\nNow when you check the permissions with ls –l again, you should see\nthat the hashcat.hcstat file no longer has write permission for the user:\nkali >ls -l\ntotal 32952\ndrwxr-xr-x 5 root root 4096 Dec 5 10:47 charsets\n-r-xr-xr-- 1 root root 33685504 June 28 2018 hashcat.hcstat\n-rw-r--r-- 1 root root 33685504 June 28 2018 hashcat.hctune\ndrwxr -xr-x 2 root root 4096 Dec 5 10:47 masks\ndrwxr -xr-x 2 root root 4096 Dec 5 10:47 OpenCL\ndrwxr -xr-x 3 root root 4096 Dec 5 10:47 rules\nYou can also change multiple permissions with just one command. If you\nwant to give both the user and other users (not including the group) execute\npermission, you could enter the following:\nchmod u+x, o+x hashcat.hcstat\nThis command tells Linux to add the execute permission for the user as\nwell as the execute permission for others for the hashcat.hcstat file.\nGiving Root Execute Permission on a New Tool\nAs a hacker, you’ll often need to download new hacking tools, but Linux\nautomatically assigns all files and directories default permissions of 666 and\n777, respectively. This means that, by default, you won’t be able to execute a\nfile immediately after downloading it. If you try, you’ll usually get a message\nthat says something like “Permission denied.” For these cases, you’ll need to\ngive yourself root and execute permissions using chmod in order to execute the\nfile.\nFor example, say we download a new hacker tool called newhackertool and\nplace it into the root user’s directory (/).\nkali >ls -l"
  },
  {
    "input": "Setting More Secure Default Permissions with Masks",
    "output": "total 80\ndrwxr-xr-x 7 root root 4096 Dec 5 11.17 Desktop\ndrwxr-xr-x 7 root root 4096 Dec 5 11.17 Documents\ndrwxr-xr-x 7 root root 4096 Dec 5 11.17 Downloads\ndrwxr-xr-x 7 root root 4096 Dec 5 11.17 Music\n-rw-r--r-- 1 root root 1072 Dec 5 11.17 newhackertool➊\ndrwxr-xr-x 7 root root 4096 Dec 5 11.17 Pictures\ndrwxr-xr-x 7 root root 4096 Dec 5 11.17 Public\ndrwxr-xr-x 7 root root 4096 Dec 5 11.17 Templates\ndrwxr-xr-x 7 root root 4096 Dec 5 11.17 Videos\nWe can see newhackertool at ➊, along with the rest of the contents of the\nroot directory. We can see that our newhackertool doesn’t have execute\npermission for anyone. This makes it impossible to use. It might seem\nstrange that by default, Linux won’t let you execute a file you downloaded,\nbut overall this setting makes your system more secure.\nWe can give ourselves permission to execute newhackertool by entering the\nfollowing:\nkali >chmod 766 newhackertool\nNow, when we perform a long listing on the directory, we can see that\nour newhackertool has execute permission for the owner:\nkali >chmod 766 newhackertool\nkali >ls -l\ntotal 80\n--snip--\ndrwxr-xr-x 7 root root 4096 Dec 5 11.17 Music\n-rwxrw-rw- 1 root root 1072 Dec 5 11.17 newhackertool\ndrwxr-xr-x 7 root root 4096 Dec 5 11.17 Pictures\n--snip--\nAs you now understand, this grants us (as the owner) all permissions,\nincluding execute, and grants the group and everyone else only read and\nwrite permissions (4 + 2 = 6).\nSetting More Secure Default Permissions with Masks\nAs you have seen, Linux automatically assigns base permissions—usually 666\nfor files and 777 for directories. You can change the default permissions\nallocated to files and directories created by each user with the umask (or\nunmask) method. The umask method represents the permissions you want to"
  },
  {
    "input": "Special Permissions",
    "output": "remove from the base permissions on a file or directory to make them more\nsecure.\nThe umask is a three-digit decimal number corresponding to the three\npermissions digits, but the umask number is subtracted from the permissions\nnumber to give the new permissions status. This means that when a new file\nor directory is created, its permissions are set to the default value minus the\nvalue in umask, as shown in Figure 5-1.\nFigure 5-1: How a umask value of 022 affects the permissions on new files and directories\nFor example, if the umask is set to 022, a new file with the original default\npermissions of 666 will now have the permissions 644, meaning the owner has\nboth read and write permissions, and the group and all other users have only\nread permission.\nIn Kali, as with most Debian systems, the umask is preconfigured to 022,\nmeaning the Kali default is 644 for files and 755 for directories.\nThe umask value is not universal to all users on the system. Each user can\nset a personal default umask value for the files and directories in their personal\n.profile file. To see the current value when logged on as the user, simply\nenter the command umask and note what is returned. To change the umask\nvalue for a user, edit the file /home/username/.profile and, for example, add\numask 007 to set it so only the user and members of the user’s group have\npermissions.\nSpecial Permissions\nIn addition to the three general-purpose permissions, rwx, Linux has three\nspecial permissions that are slightly more complicated. These special\npermissions are set user ID (or SUID), set group ID (or SGID), and sticky bit. I’ll\ndiscuss each in turn in the next three sections.\nGranting Temporary Root Permissions with SUID\nAs you should know by now, a user can execute a file only if they have\npermission to execute that particular file. If the user only has read and/or\nwrite permissions, they cannot execute. This may seem straightforward, but\nthere are exceptions to this rule.\nYou may have encountered a case in which a file requires the permissions\nof the root user during execution for all users, even those who are not root.\nFor example, a file that allows users to change their password would need\naccess to the /etc/shadow file—the file that holds the users’ passwords in\nLinux—which requires root user privileges in order to execute. In such a\ncase, you can temporarily grant the owner’s privileges to execute the file by\nsetting the SUID bit on the program.\nBasically, the SUID bit says that any user can execute the file with the\npermissions of the owner but those permissions don’t extend beyond the use\nof that file.\nTo set the SUID bit, enter a 4 before the regular permissions, so a file with a\nnew resulting permission of 644 is represented as 4644 when the SUID bit is set.\nSetting the SUID on a file is not something a typical user would do, but if\nyou want to do so, you’ll use the chmod command, as in chmod 4644 filename.\nGranting the Root User’s Group Permissions SGID\nSGID also grants temporary elevated permissions, but it grants the permissions\nof the file owner’s group, rather than of the file’s owner. This means that,\nwith an SGID bit set, someone without execute permission can execute a file if\nthe owner belongs to the group that has permission to execute that file.\nThe SGID bit works slightly differently when applied to a directory: when\nthe bit is set on a directory, ownership of new files created in that directory\ngoes to the directory creator’s group, rather than the file creator’s group.\nThis is very useful when a directory is shared by multiple users. All users in\nthat group can execute the file(s), not just a single user.\nThe SGID bit is represented as 2 before the regular permissions, so a new\nfile with the resulting permissions 644 would be represented as 2644 when the\nSGID bit is set. Again, you would use the chmod command for this—for\nexample, chmod 2644 filename.\nThe Outmoded Sticky Bit\nThe sticky bit is a permission bit that you can set on a directory to allow a\nuser to delete or rename files within that directory. However, the sticky bit is\na legacy of older Unix systems, and modern systems (like Linux) ignore it. As\nsuch, I will not discuss it further here, but you should be familiar with the\nterm because you might hear it in the Linux world.\nSpecial Permissions, Privilege Escalation, and the\nHacker\nAs a hacker, these special permissions can be used to exploit Linux systems\nthrough privilege escalation, whereby a regular user gains root or sysadmin\nprivileges and the associated permissions. With root privileges, you can do\nanything on the system.\nOne way to do this is to exploit the SUID bit. A system administrator or\nsoftware developer might set the SUID bit on a program to allow that program\naccess to files with root privileges. For instance, scripts that need to change\npasswords often have the SUID bit set. You, the hacker, can use that\npermission to gain temporary root privileges and do something malicious,\nsuch as get access to the passwords at /etc/shadow.\nLet’s look for files with the SUID bit set on our Kali system to try this out.\nBack in Chapter 1, I introduced you to the find command. We’ll use its\npower to find files with the SUID bit set.\nAs you’ll remember, the find command is powerful, but the syntax is bit\nmore complicated than some of the other location commands, such as locate\nand which. Take a moment to review the find syntax in Chapter 1, if you need\nto.\nIn this case, we want to find files anywhere on the filesystem, for the root\nuser or other sysadmin, with the permissions 4000. To do this, we can use the\nfollowing find command:\nkali >find / -user root -perm -4000\nWith this command, we ask Kali to start looking at the top of the\nfilesystem with the / syntax. It then looks everywhere below / for files that\nare owned by root, specified with user root, and that have the SUID permission\nbit set (-perm -4000).\nWhen we run this command, we get the output shown in Listing 5-2.\n/usr/bin/chsh\n/usr/bin/gpasswd\n/usr/bin/pkexec\n/usr/bin/sudo\n/usr/bin/passwd\n/usr/bin/kismet_capture\n--snip--\nListing 5-2: Finding files with the SUID bit set\nThe output reveals numerous files that have the SUID bit set. Let’s navigate\nto the /usr/bin directory, where many of these files reside, and then run a\nlong listing on that directory and scroll down to the sudo file, as shown in\nListing 5-3.\nkali >cd /usr/bin\nkali >ls -l\n--snip--\n-rwxr-xr-x 1 root root 176272 Jul 18 2018 stunnel4\n-rwxr-xr-x 1 root root 26696 Mar 17 2018 sucrack\n➊ -rwsr-xr-x 1 root root 140944 Jul 5 2018 sudo\n--snip--\nListing 5-3: Identifying files with the SUID bit set\nNote that at ➊, the first set of permissions—for the owner—has an s in\nplace of the x. This is how Linux represents that the SUID bit is set. This\nmeans that anyone who runs the sudo file has the privileges of the root user,\nwhich can be a security concern for the sysadmin and a potential attack\nvector for the hacker. For instance, some applications need to access the\n/etc/shadow file to successfully complete their tasks. If the attacker can gain\ncontrol of that application, they can use that application’s access to the\npasswords on a Linux system.\nLinux has a well-developed system of security that protects files and\ndirectories from unauthorized access. The aspiring hacker needs to have a\nbasic understanding of this system not only to protect their files but also to\nexecute new tools and files. In some cases, hackers can exploit the SUID and\nSGID permissions to escalate privileges from a regular user to a root user."
  },
  {
    "input": "Exercises",
    "output": "Summary\nLinux’s use of permissions to protect a user’s or group’s files and directories\nfrom other users in the system can be used for offensive and defensive\npurposes. You should now know how to manage these permissions and how\nto exploit weak points in this security system—in particular, SUID and SGID\nbits.\nEXERCISES\nBefore you move on to Chapter 6, put the knowledge you learned from this chapter to the test\nby completing the following exercises:\n1. Select a directory and run a long listing on it. Note the permissions on the files and\ndirectories.\n2. Select a file you don’t have permission to execute and give yourself execute permissions\nusing the chmod command. Try using both the numeral method (777) and the UGO\nmethod.\n3. Choose another file and change its ownership using chown.\n4. Use the find command to find all files with the SGID bit set."
  },
  {
    "input": "Viewing Processes",
    "output": "6\nPROCESS MANAGEMENT\nAt any given time, a Linux system typically has hundreds, or sometimes even\nthousands, of processes running simultaneously. A process is simply a program\nthat’s running and using resources. It includes a terminal, web server, any\nrunning commands, any databases, the GUI interface, and much more. Any\ngood Linux administrator—and particularly a hacker—needs to understand\nhow to manage their processes to optimize their systems. For example, once\na hacker takes control of a target system, they might want to find and stop a\ncertain process, like an antivirus application or firewall. To do so, the hacker\nwould first need to know how to find the process. The hacker might also\nwant to set a scanning script to run periodically to find vulnerable systems,\nso we’ll also look at how to schedule such a script.\nIn this chapter, you’ll learn to manage those processes. First, you’ll learn\nto view and find processes and how to discover which processes are using the\nmost resources. Then, you’ll learn to manage processes by running them in\nthe background, prioritizing them, and killing them if necessary (no blood\ninvolved). Finally, you’ll learn to schedule processes to run on specified days\nand dates and at specific times.\nViewing Processes\nIn most cases, the first step in managing processes is to view what processes\nare running on your system. The primary tool for viewing processes—and\none of the Linux administrator’s best friends—is the ps command. Run it in\nyour command line to see what processes are active:\nkali >ps\nPID TTY TIME CMD\n39659 pts/0 00:00:01 bash\n39665 pts/0 00:00:00 ps\nThe Linux kernel, the inner core of the operating system that controls\nnearly everything, assigns a unique process ID (PID) to each process\nsequentially, as the processes are created. When working with these\nprocesses in Linux, you often need to specify their PIDs, so it is far more\nimportant to note the PID of the process than the name of the process.\nAlone, the ps command doesn’t really provide you with much\ninformation. Running the ps command without any options lists the\nprocesses started (said to be invoked) by the currently logged-in user (in our\ncase, root) and what processes are running on that terminal. Here, it simply\nsays that the bash shell is open and running and that we ran the ps command.\nWe want and need far more information than that, particularly on those\nprocesses run by other users and by the system in the background. Without\nthis information, we know very little of what is actually taking place on our\nsystem.\nRunning the ps command with the options aux will show all processes\nrunning on the system for all users, as shown in Listing 6-1. Note that you\ndon’t prefix these options with a dash (-) and that everything is in lowercase;\nbecause Linux is case-sensitive, using uppercase options woud give you\nsignificantly different results.\nkali >ps aux\nUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND\nRoot 1 0.0 0.4 202540 6396 ? Ss Apr24 0:46 /sbin/init\nRoot 2 0.0 0.0 0 0 ? S Apr24 0:00 [kthreadd]\nRoot 3 0.0 0.0 0 0 ? S Apr24 0:26 [ksoftirqd/0]\n--snip--\nroot 39706 0.0 0.2 36096 3204 pts/0 R+ 15:05 0:00 ps aux\nListing 6-1: Using the aux options to see processes for all users\nAs you can see, this command now lists so many processes, they likely run\noff the bottom of your screen. The first process is init, listed in the final\ncolumn, and the last process is the command we ran to display, ps aux. Many\nof the details (PID, %CPU, TIME, COMMAND, and so on) may be different on your\nsystem but should have the same format. For our purposes, here are the most\nimportant columns in this output:\nUSER The user who invoked the process\nPID The process ID\n%CPU The percent of CPU this process is using\n%MEM The percent of memory this process is using\nCOMMAND The name of the command that started the process\nIn general, to perform any action on a process, we must specify its PID.\nLet’s see how to use this identifier to our advantage.\nFiltering by Process Name\nWhen we inquire about or perform an action on processes, we usually don’t\nwant all of the processes displayed on the screen. It’s simply a problem of too\nmuch information. Most often, we want to find information on a single\nprocess. To do so, we can use the filtering command grep, which I introduced\nin Chapter 1.\nTo demonstrate, we’ll use the Metasploit exploitation framework, the\nmost widely used exploitation framework and nearly every hacker’s good\nfriend. This comes installed on your Kali system, so start Metasploit with the\nfollowing:\nkali >msfconsole\nOnce the exploitation framework has been started, let’s see whether we\ncan find it in the list of processes. To do so, use the ps aux command and\nthen pipe it (|) to grep looking for the string msfconsole, as in Listing 6-2.\nkali >ps aux | grep msfconsole\nroot 39756 0.0 0.0 4304 716 pts/2 Ss+ 15:13 0:00 sh -c service\npostgresql start && msfdb init & msfconsole\nroot 39759 35.1 15.2 4304 227888 pts/2 Sl+ 15:13 1:36 ruby /usr/bin/\nmsfconsole\nroot 39892 0.0 0.0 4304 940 pts/2 S+ 15:18 0:00 grep msfconsole\nListing 6-2: Filtering a ps search to find a particular process\nFrom the filtered output in this listing, you should see all the processes\nthat match the term msfconsole. The PostgreSQL database, which is the\ndatabase Metasploit uses, is shown first, then the msfconsole program itself\nfrom /usr/bin/msfconsole. Finally, you should see the grep command you used\nto look for msfconsole. Notice that the output did not include the column\nheader list from ps. Since the keyword, msfconsole, is not in the header, it is\nnot displayed. Even so, the results are displayed in the same format.\nFrom this, you can learn some important information. If, for example,\nyou need to know how many resources Metasploit is using, you can consult\nthe third column (the CPU column), to see that it’s using 35.1 percent of\nyour CPU, and consult the fourth column to see that it’s using 15.2 percent\nof your system memory. That’s quite a bit. It’s a demanding beast!\nFinding the Greediest Processes with top\nWhen you enter the ps command, the processes are displayed in the order\nthey were started, and since the kernel assigns PIDs in the order they have\nstarted, what you see are processes ordered by PID number.\nIn many cases, we want to know which processes are using the most\nresources. This is where the top command comes in handy because it displays\nthe processes ordered by resources used, starting with the largest. Unlike the\nps command, which gives us a one-time snapshot of the processes, top\nrefreshes the list dynamically—by default, every 10 seconds. You can watch\nand monitor those resource-hungry processes, as shown in Listing 6-3.\nkali >top\ntop - 15:31:17 up 2 days, ^;50, 4 users, load average: 0.00, 0.04, 0.09\nTasks: 176 total, 1 running, 175 sleeping, 0 stopped, 0 zombie\n%Cpu(s): 1.3 us, 0.7 sy, ).) ni, 97.4 id, 0.0 wa, 0.0 hi 0.0 si 0.0\nKiB Mem : 1491220 total, 64848 free, 488272 used, 938100 buff/cache\nKiB Swap : 1046524 total, 1044356 free, 2168 used. 784476 avail MEM\nPID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND\n39759 root 20 0 893180 247232 11488 S 0.7 16.6 1:47.88 ruby\n39859 root 20 0 27308 16796 14272 S 0.3 1.2 1:47.88 postgres\n39933 root 20 0 293936 61500 29108 S 0.7 4.1 1:47.88 Xorg\n--snip--\nListing 6-3: Finding the greediest processes with top\nSystem administrators often keep top running in a terminal to monitor use\nof process resources. As a hacker, you may want to do the same, especially if\nyou have multiple tasks running on your system. While you have top"
  },
  {
    "input": "Managing Processes",
    "output": "running, pressing the H or ? key will bring up a list of interactive commands,\nand pressing Q will quit top. You’ll use top again soon to manage your\nprocesses in “Changing Process Priority with nice” on page 65 and “Killing\nProcesses” on page 66.\nManaging Processes\nHackers often need to multiprocess, and an operating system like Kali is\nideal for this. The hacker may have a port scanner running while running a\nvulnerability scanner and an exploit simultaneously. This requires that the\nhacker manage these processes efficiently to best use system resources and\ncomplete the task. In this section, I'll show you how to manage multiple\nprocesses.\nChanging Process Priority with nice\nYou don’t often hear the word nice used in the context of hackers, but here\nyou will. The nice command is used to influence the priority of a process to\nthe kernel. As you saw when we ran the ps command, numerous processes\nrun on the system at once, and all of them are contending for the available\nresources. The kernel will have final say over the priority of a process, but\nyou can use nice to suggest that a process should be elevated in priority.\nThe idea behind the use of the term nice is that, when you use it, you’re\ndetermining how “nice” you’ll be to other users: if your process is using most\nof the system resources, you aren’t being very nice.\nThe values for nice range from –20 to +19, with zero being the default\nvalue (see Figure 6-1). A high nice value translates to a low priority, and a\nlow nice value translates to a high priority (when you’re not being so nice to\nother users and processes). When a process is started, it inherits the nice\nvalue of its parent process. The owner of the process can lower the priority\nof the process but cannot increase its priority. Of course, the superuser or\nroot user can arbitrarily set the nice value to whatever they please.\nFigure 6-1: Niceness priority values\nWhen you start a process, you can set the priority level with the nice\ncommand and then alter the priority after the process has started running\nwith the renice command. The syntax for these two commands is slightly\ndifferent and can be confusing. The nice command requires that you\nincrement the nice value, whereas the renice command wants an absolute value\nfor niceness. Let’s look at an example to demonstrate this.\nSetting the Priority When Starting a Process\nFor demonstration purposes, let’s assume we have a process named\nslowprocess that’s located at /bin/slowprocess. If we wanted it to speed up its\ncompletion, we could start the process with the nice command:\nkali >nice -n -10 /bin/slowprocess\nThis command would increment the nice value by -10, increasing its\npriority and allocating it more resources.\nOn the other hand, if we want to be nice to our fellow users and processes\nand give slowprocess a lower priority, we could increment its nice value\npositively by 10:\nkali >nice -n 10 /bin/slowprocess\nGive this a try on a process you have currently running and then run ps to\nsee how it changes, if at all.\nChanging the Priority of a Running Process with renice\nThe renice command takes absolute values between –20 and 19 and sets the\npriority to that particular level, rather than increasing or decreasing from the\nlevel at which it started. In addition, renice requires the PID of the process\nyou are targeting rather than the name. So, if slowprocess is using an\ninordinate amount of resources on your system and you want to give it a\nlower priority, thus allowing other processes a higher priority and more\nresources, you could renice the slowprocess (which has a PID of 6996) and give\nit a much higher nice value, like so:\nkali >renice 20 6996\nAs with nice, only the root user can renice a process to a negative value to\ngive it higher priority, but any user can be nice and reduce priority with\nrenice.\nYou can also use the top utility to change the nice value. With the top\nutility running, simply press the R key and then supply the PID and the nice\nvalue. Listing 6-4 shows the top utility running. When I press the R key and\nsupply the PID and nice value, I get the following output:\nListing 6-4: Changing a nice value when top is in use\nWhen I press the R key, I’m asked for the PID ➊ with the text renice PID\n[value] to value. The output should then change to reflect the new priorities.\nKilling Processes\nAt times, a process will consume way too many system resources, exhibit\nunusual behavior, or—at worst—freeze. A process that exhibits this type of\nbehavior is often referred to as a zombie process. For you, probably the most\nproblematic symptom will be wasted resources used by the zombie that\ncould be better allocated to useful processes.\nWhen you identify a problematic process, you may want to stop it with\nthe kill command. There are many different ways to kill a program, and\neach has its own kill number.\nThe kill command has 64 different kill signals, and each does something\nslightly different. Here, we focus on a few you will likely find most useful.\nThe syntax for the kill command is kill-signal PID, where the signal switch is\noptional. If you don’t provide a signal flag, it defaults to SIGTERM. Table 6-1\nlists the common kill signals\nTable 6-1: Commonly Used Kill Signals\nSignalNumberDescription\nname for\noption\nSIGHUP 1 This is known as the Hangup (HUP) signal. It stops the\ndesignated process and restarts it with the same PID.\nSIGINT 2 This is the Interrupt (INT) signal. It is a weak kill signal that\nisn’t guaranteed to work, but it works in most cases.\nSIGQUIT 3 This is known as the core dump. It terminates the process\nand saves the process information in memory, and then it\nsaves this information in the current working directory to a\nfile named core. (The reasons for doing this are beyond the\nscope of this book.)\nSIGTERM 15 This is the Termination (TERM) signal. It is the kill\ncommand’s default kill signal.\nSIGKILL 9 This is the absolute kill signal. It forces the process to stop\nby sending the process’s resources to a special device,\n/dev/null.\nUsing the top command, you can identify which processes are using too\nmany resources; often, those processes will be legitimate, but there may be\nmalicious processes taking resources that you’ll want to kill.\nIf you just want to restart a process with the HUP signal, enter the -1\noption with kill, like so:\nkali >kill -1 6996\nIn the case of a zombie or a malicious process, you likely want to send the\nkill -9 signal, the absolute kill signal, to the process. This makes certain that\nthe process is terminated.\nkali >kill -9 6996\nIf you don’t know a process’s PID, you can use the killall command to\nkill the process. This command takes the name of the process, instead of the\nPID, as an argument.\nFor example, you could terminate a hypothetical zombieprocess like this:\nkali >killall -9 zombieprocess\nFinally, you can also terminate a process in the top command. Simply\npress the K key and then enter the PID of the offending process.\nRunning Processes in the Background\nIn Linux, whether you’re working from the command line or the GUI,\nyou’re working within a shell. All commands that run are executed from\nwithin that shell, even if they run from the graphical interface. When you\nexecute a command, the shell waits until the command is completed before\noffering another command prompt.\nAt times, you may want a process to run in the background, rather than\nhaving to wait for it to complete in that terminal. For instance, say we want\nto work on a script in a text editor and so have called our text editor (leafpad)\nby entering the following:\nkali >leafpad newscript\nIn this case, the bash shell will open the leafpad text editor to create\nnewscript. While we work in the text editor, the terminal is occupied with\nrunning the text editor. If we return to the terminal, we should see that it is\nrunning our text editor and that we have no new prompt to allow us to enter\nmore commands.\nWe could, of course, open another terminal to run more commands, but\na better option to save resources and screen real estate is to start the text\neditor running in the background. Running a process in the background\nsimply means that it will continue to run without needing the terminal. In\nthis way, the terminal is freed up for other duties.\nTo start the text editor in the background, just append an ampersand (&)\nto the end of the command, like so:\nkali >leafpad newscript &"
  },
  {
    "input": "Scheduling Processes",
    "output": "Now, when the text editor opens, the terminal returns a new command\nprompt so we can enter other commands on our system while also editing\nour newscript. This is effective for any process that may run for a significant\nlength of time when you want use the terminal. As a hacker, you’ll find this\nuseful for running multiple terminals with multiple tasks, to save resources\nand screen space.\nMoving a Process to the Foreground\nIf you want to move a process running in the background to the foreground,\nyou can use the fg (foreground) command. The fg command requires the\nPID of the process you want to return to the foreground, as shown next.\nkali >fg 1234\nIf you don’t know the PID, you can use the ps command to find it.\nScheduling Processes\nBoth Linux system administrators and hackers often need to schedule\nprocesses to run at a particular time of day. A system administrator might\nwant to schedule a system backup to run every Saturday night at 2 AM, for\nexample. A hacker might want to set a script to run to perform\nreconnaissance on a regular basis, finding open ports or vulnerabilities. In\nLinux, you can accomplish this in at least two ways: with at and crond.\nThe at command is a daemon—a background process—useful for\nscheduling a job to run once at some point in the future. The crond is more\nsuited for scheduling tasks to occur every day, week, or month, and we’ll\ncover this in detail in Chapter 16.\nWe use the at daemon to schedule the execution of a command or set of\ncommands in the future. The syntax is simply the at command followed by\nthe time to execute the process. The time argument can be provided in\nvarious formats. Table 6-2 contains the most common at time formats.\nTable 6-2: Time Formats Accepted by the at Command\nTime format Meaning"
  },
  {
    "input": "Exercises",
    "output": "at 7:20pm Scheduled to run at 7:20 PM on the current day\nat 7:20pm June 25 Scheduled to run at 7:20 PM on June 25\nat noon Scheduled to run at noon on the current day\nat noon June 25 Scheduled to run at noon on June 25\nat tomorrow Scheduled to run tomorrow\nat now + 20 minutes Scheduled to run in 20 minutes from the current time\nat now + 10 hours Scheduled to run in 10 hours from the current time\nat now + 5 days Scheduled to run in five days from the current date\nat now + 3 weeks Scheduled to run in three weeks from the current date\nat 7:20pm 06/25/2019Scheduled to run at 7:20 PM on June 25, 2019\nWhen you enter the at daemon with the specified time, at goes into\ninteractive mode and you are greeted with an at> prompt. Here is where you\nenter the command you want executed at the specified time:\nkali >at 7:20am\nat >/root/myscanningscript\nThis code snippet will schedule myscanningscript to execute today at 7:20\nAM.\nSummary\nManaging processes in Linux is a key skill for every Linux user and hacker.\nYou must be able to view, find, kill, prioritize, and schedule processes to\nmanage your Linux instance optimally. A hacker often will need to find\nprocesses on the target they want to kill, such as the antivirus software or a\nfirewall. They will also need to manage multiple processes in an attack and\nprioritize them.\nEXERCISES\nBefore you move on to Chapter 7, try out the skills you learned from this chapter by\ncompleting the following exercises:\n1. Run the ps command with the aux options on your system and note which process is first\nand which is last.\n2. Run the top command and note the two processes using the greatest amount of your\nresources.\n3. Use the kill command to kill the process that uses the most resources.\n4. Use the renice command to reduce the priority of a running process to +19.\n5. Create a script called myscanning (the content is not important) with a text editor and\nthen schedule it to run next Wednesday at 1 AM."
  },
  {
    "input": "7 MANAGING USER ENVIRONMENT VARIABLES",
    "output": "7\nMANAGING USER ENVIRONMENT VARIABLES\nTo get the most from your Linux hacking system, you need to understand\nenvironment variables and be adept at managing them for optimal\nperformance, convenience, and even stealth. Among the areas that Linux\nnewcomers find problematic, however, managing the user environment\nvariables might be the most difficult to master. Technically, there are two\ntypes of variables: shell and environment. Environment variables are system-\nwide variables built into your system and interface that control the way your\nsystem looks, acts, and “feels” to the user, and they are inherited by any child\nshells or processes. Shell variables, on the other hand, are typically listed in\nlowercase and are only valid in the shell they are set in. To avoid over-\nexplanation, I just cover some of the most basic and useful skills for\nenvironment and shell variables in this chapter and don’t go too deeply into\nthe differences between them.\nVariables are simply strings in key-value pairs. Generally, each pair will\nlook like KEY=value. In cases where there are multiple values, they will look\nlike KEY=value1:value2. As with most things in Linux, if there are spaces in the\nvalue, it needs to be contained in quotation marks. In Kali Linux, your\nenvironment is your bash shell. Each user, including root, has a default set of\nenvironment variables that determine how the system looks, acts, and feels.\nYou can change the values for these variables to make your system work\nmore efficiently, tailor your work environment to best meet your individual\nneeds, and potentially cover your tracks if you need to."
  },
  {
    "input": "Viewing and Modifying Environment Variables",
    "output": "Viewing and Modifying Environment Variables\nYou can view all your default environment variables by entering env into your\nterminal from any directory, like so:\nkali >env\nXDG_VTNR=7\nSSHAGENT_PID=922\nXDG_SESSION_ID=2\nXDG_GREETER_DATA_DIR=/var/lib/lightdm/data/root\nGLADE_PIXMAP_PATH=:echo\nTERM=xterm\nSHELL=/bin/bash\n--snip--\nUSER=root\n--snip--\nPATH=/usr/local/sbin :usr/local/bin:/usr/sbin:/sbin/bin\n--snip--\nHOME=/root\n--snip--\nEnvironment variables are always uppercase, as in HOME, PATH, SHELL, and so\non. These are only the default environment variables that come on your\nsystem. A user can also create their own variables, and as you will see, we\nneed a different command to include those in the output.\nViewing All Environment Variables\nTo view all environment variables, including shell variables, local variables,\nand shell functions such as any user-defined variables and command aliases,\nuse the set command. This command will list all environment variables\nunique to your system, which in most cases will give you an output so long\nyou won’t be able to view it all on a single screen. You can request to view\neach variable, line by line, in a more accessible fashion using set and piping it\nto the more command, as follows:\nkali >set | more\nBASH=/bin/bash\nBASHOPTS=checkwinsize:cmdlist:complete_fullquote:expand_aliases:extglob.....\nBASH_ALIASES=()\nBASH_ARGC=()\nBASH_ARGV=()\n--snip--\nNow the list of variables will fill up one screen, line by line, and then\nstop. When you press ENTER, the terminal advances to the next line, taking\nyou to the next variable, so you can scroll through by pressing or holding\nENTER. As you might recall from Chapter 2, whenever you use the more\ncommand for output, you can enter q to quit (or exit) and return to the\ncommand prompt.\nFiltering for Particular Variables\nAlthough using set with more gives more manageable results than looking\nthrough the huge chunk of variable names you get with set alone, it can still\nbe rather tedious if you’re looking for a particular variable. Instead, you can\nuse the filtering command grep to find your variable of interest.\nLet’s use the variable HISTSIZE as an example. This variable contains the\nmaximum number of commands your command history file will store. These\ncommands are any ones you’ve previously typed into your command prompt\nin this session and can be recalled with your up- and down-arrow keys. Note\nthat HISTSIZE doesn’t store the commands themselves, just the number of\nthem that can be stored.\nPipe your set output with grep to find the HISTSIZE variable, like so:\nkali >set | grep HISTSIZE\nHISTSIZE=1000\nAs you can see, this command finds the variable HISTSIZE and displays its\nvalue. The default value of this variable is probably set to 1000 on your\nsystem. This indicates that the terminal will store your last 1,000 commands\nby default.\nChanging Variable Values for a Session\nNow let’s see how to change a variable’s value. As noted, the HISTSIZE variable\ncontains the value of the number of commands to store in the history file.\nSometimes, you won’t want your system to save past commands—perhaps\nbecause you don’t want to leave any evidence of your activity on your own\nsystem or a target system. In that case, you can set the HISTSIZE variable to 0 so\nthe system won’t store any of your past commands. Because this variable has\na single value, to change it, you assign it a new value in the familiar way\nshown in Listing 7-1.\nkali >HISTSIZE=0\nListing 7-1: Changing the value of HISTSIZE\nNow, when you try to use the up- and down-arrow keys to recall your\ncommands, nothing happens because the system no longer stores them. This\nis stealthy, although it can be inconvenient.\nMaking Variable Value Changes Permanent\nWhen you change an environment variable, that change only occurs in that\nparticular environment; in this case, that environment is the bash shell\nsession. This means that when you close the terminal, any changes you made\nare lost, with values set back to their defaults. If you want to make the\nchanges permanent, you need to use the export command. This command\nwill export the new value from your current environment (the bash shell) to\nthe rest of the system, making it available in every environment until you\nchange and export it again.\nVariables are strings, so if you run on the cautious side, it isn’t a bad idea\nto save the contents of a variable to a text file before you modify it. For\nexample, since we’re about to change the PS1 variable, which controls the\ninformation you display in the prompt, first run the following command to\nsave the existing values to a text file in the current user’s home directory:\nkali >echo $HISTSIZE> ~/valueofHISTSIZE.txt\nThis way, you can always undo your changes. If you want to be even\nmore cautious and create a text file with all the current settings, you can save\nthe output of the set command to a text file with a command like this one:\nkali >set> ~/valueofALLon01012017.txt\nAfter you’ve changed a variable, as we did in Listing 7-1, you can make\nthe change permanent by entering export and then the name of the variable\nyou changed, as shown here:\nkali >export HISTSIZE\nNow the HISTSIZE variable will still be set to 0 when you leave this\nenvironment and enter another environment. If you want to reset the HISTSIZE"
  },
  {
    "input": "Changing Your Shell Prompt",
    "output": "variable to 1,000, simply enter this:\nkali >HISTSIZE=1000\nkali >export HISTSIZE\nThis code snippet will set your HISTSIZE variable’s value to 1,000 and\nexport it to all your environments.\nChanging Your Shell Prompt\nYour shell prompt, another environment variable, provides you with useful\ninformation such as the user you’re operating as and the directory in which\nyou’re currently working. The default shell prompt in Kali takes the\nfollowing format:\nusername@hostname:current_directory\nIf you’re working as the root user, this translates to the following default\nprompt:\nroot@kali:current_directory\nYou can change the name in the default shell prompt by setting the value\nfor the PS1 variable. The PS1 variable has a set of placeholders for information\nyou want to display in the prompt, including the following:\n\\u The name of the current user\n\\h The hostname\n\\W The base name of the current working directory\nThis is very useful if you happen to have shells on multiple systems or are\nlogged on as multiple accounts. By setting different \\u and \\h values for\ndifferent shells or accounts, you can tell at a glance who you are and what\nyour current system is.\nLet’s have a little fun and change the prompt in your terminal. For\nexample, you could enter the following:\nkali >PS1=\"World's Best Hacker: #\"\nWorld's Best Hacker: #"
  },
  {
    "input": "Changing Your PATH",
    "output": "Now, every time you use this terminal, you’ll be reminded that you are\nthe “World’s Best Hacker.” But any subsequent terminal you open will still\nhave the default command prompt, because the PS1 variable only holds values\nfor your terminal session. Remember, until you export a variable, it is only\ngood for that session. If you really like this new command prompt and want\nto see it in every terminal, you need to export it, like so:\nkali >export PS1\nThis will make the change permanent across all sessions.\nHow about a little more fun? Say you really want your terminal to look\nlike a Windows cmd prompt. In this case, you could change the prompt name\nto C: and keep the \\w to have the prompt show your current directory, as\nshown in Listing 7-2.\nkali >export PS1='C:\\w> '\nC:/tmp>\nListing 7-2: Changing the prompt and showing the current directory\nHaving your prompt show your current directory can be generally useful,\nparticularly to a beginner, so it’s something to consider when you change\nyour PS1 variable.\nChanging Your PATH\nOne of the most important variables in your environment is your PATH\nvariable, which controls where on your system your shell will look for\ncommands you enter, such as cd, ls, and echo. Most commands are located in\nthe sbin or bin subdirectory, like /usr/local/sbin or usr/local/bin. If the bash\nshell doesn’t find the command in one of the directories in your PATH variable,\nit will return the error command not found, even if that command does exist in a\ndirectory not in your PATH.\nYou can find out which directories are stored in your PATH variable by\nusing echo on its contents, like so:\nkali >echo $PATH\n/usr/local/sbin:usr/local/bin:/usr/sbin:/sbin/bin\nThese are the directories where your terminal will search for any\ncommand. When you enter ls, for example, the system knows to look in\neach of these directories for the ls command, and when it finds ls, the\nsystem executes it.\nEach directory is separated by a colon (:), and don’t forget to add the $\ncontent symbol to PATH.\nAdding to the PATH Variable\nYou can probably see why it’s important to know what is in your PATH\nvariable: if you downloaded and installed a new tool—let’s say newhackingtool\n—into the /root/newhackingtool directory, you could only use commands from\nthat tool when you’re in that directory because that directory is not in the\nPATH variable. Every time you wanted to use that tool, you would first have to\nnavigate to /root/newhackingtool, which is a bit inconvenient if you want to\nuse the tool often.\nTo be able to use this new tool from any directory, you need to add the\ndirectory holding this tool to your PATH variable.\nTo add newhackingtool to your PATH variable, enter the following:\nkali >PATH=$PATH:/root/newhackingtool\nThis assigns the original PATH variable plus the /root/newhackingtool\ndirectory to the new PATH variable, so the variable contains everything it did\nbefore, plus the new tool directory.\nIf you examine the contents of the PATH variable again, you should see that\nthis directory has been appended to the end of PATH, as shown here:\nkali >echo $PATH\n/usr/local/sbin:usr/local/bin:/usr/sbin:/sbin/bin:/root/newhackingtool\nNow you can execute newhackingtool applications from anywhere on your\nsystem, rather than having to navigate to its directory. The bash shell will\nlook in all directories listed for your new tool!\nNOTE\nAdding to PATH can be a useful technique for directories you use often, but be"
  },
  {
    "input": "Creating a User-Defined Variable",
    "output": "careful not to add too many directories to your PATH variable. Because the system\nwill have to search through each and every directory in PATH to find commands,\nadding a lot of directories could slow down your terminal and your hacking.\nHow Not to Add to the PATH Variable\nOne mistake commonly made by new Linux users is assigning a new\ndirectory, such as /root/newhackingtool, directly to the PATH variable in this\nway:\nkali >PATH=/root/newhackingtool\nkali >echo $PATH\n/root/newhackingtool\nIf you use this command, your PATH variable will only contain the\n/root/newhackingtool directory and no longer contain the system binaries\ndirectories such as /bin, /sbin, and others that hold critical commands. When\nyou then go to use any of the system commands, you’ll receive the error\ncommand not found, as shown next, unless you first navigate to the system\nbinaries directory when you execute the command:\nkali >cd\nbash: cd: command not found\nRemember that you want to append to the PATH variable, not replace it. If\nyou’re in doubt, save the contents of the variable somewhere before you\nmodify it.\nCreating a User-Defined Variable\nYou can create your own custom, user-defined variables in Linux by simply\nassigning a value to a new variable that you name. This may be useful when\nyou are doing some more advanced shell scripting or find you’re often using\na long command that you get tired of typing over and over.\nThe syntax is straightforward: enter the name of your variable, followed\nby the assignment symbol (=), and then the value to put in the variable, as\nshown here:\nkali >MYNEWVARIABLE=\"Hacking is the most valuable skill set in the 21st century\""
  },
  {
    "input": "Exercises",
    "output": "This assigns a string to the variable MYNEWVARIABLE. To see the value in that\nvariable, use the echo command and the $ content symbol with the variable\nname, as we did earlier:\nkali >echo $MYNEWVARIABLE\nHacking is the most valuable skill set in the 21st century\nJust like our system environment variables, user-defined variables must be\nexported to persist to new sessions.\nIf you want to delete this new variable, or any variable, use the unset\ncommand. Always think before deleting a system variable, though, because\nyour system will probably operate much differently afterward.\nkali >unset MYNEWVARIABLE\nkali >echo $MYNEWVARIABLE\nkali >\nAs you can see, when you enter unset MYNEWVARIABLE, you delete the variable\nalong with its value. If you use echo on that same variable, Linux will now\nreturn a blank line.\nSummary\nYou might find environment variables foreign, but it’s worth getting to\nknow them. They control how your working environment in Linux looks,\nacts, and feels. You can manage these variables to tailor your environment to\nyour needs by changing them, exporting them, and even creating your own.\nIn some cases, they may be useful for covering your tracks as a hacker.\nEXERCISES\nBefore you move on to Chapter 8, try out the skills you learned from this chapter by\ncompleting the following exercises:\n1. View all of your environment variables with the more command.\n2. Use the echo command to view the HOSTNAME variable.\n3. Find a method to change the slash (/) to a backslash (\\) in the faux Microsoft cmd PS1\nexample (see Listing 7-2).\n4. Create a variable named MYNEWVARIABLE and put your name in it.\n5. Use echo to view the contents of MYNEWVARIABLE.\n6. Export MYNEWVARIABLE so that it’s available in all environments.\n7. Use the echo command to view the contents of the PATH variable.\n8. Add your home directory to the PATH variable so that any binaries in your home\ndirectory can be used in any directory.\n9. Change your PS1 variable to “World’s Greatest Hacker:”."
  },
  {
    "input": "A Crash Course in Bash",
    "output": "8\nBASH SCRIPTING\nAny self-respecting hacker must be able to write scripts. For that matter, any\nself-respecting Linux administrator must be able to script. Hackers often\nneed to automate commands, sometimes from multiple tools, and this is\nmost efficiently done through short programs they write themselves.\nIn this chapter, we build a few simple bash shell scripts to start you off\nwith scripting. We’ll add capabilities and features as we progress, eventually\nbuilding a script capable of finding potential attack targets over a range of IP\naddresses.\nTo become an elite hacker, you also need the ability to script in one of the\nwidely used scripting languages, such as Ruby (Metasploit exploits are\nwritten in Ruby), Python (many hacking tools are Python scripts), or Perl\n(Perl is the best text-manipulation scripting language). I give a brief\nintroduction to Python scripting in Chapter 17.\nA Crash Course in Bash\nA shell is an interface between the user and the operating system that enables\nyou to manipulate files and run commands, utilities, programs, and much\nmore. The advantage of a shell is that you perform these tasks immediately\nfrom the computer and not through an abstraction, like a GUI, which allows\nyou to customize your task to your needs. A number of different shells are\navailable for Linux, including the Korn shell, the Z shell, the C shell, and the"
  },
  {
    "input": "Your First Script: “Hello, Hackers-Arise!”",
    "output": "Bourne-again shell, more widely known as bash.\nBecause the bash shell is available on nearly all Linux and UNIX\ndistributions (including macOS and Kali), we’ll be using the bash shell,\nexclusively.\nThe bash shell can run any system commands, utilities, or applications\nyour usual command line can run, but it also includes some of its own built-\nin commands. Table 8-1 later in the chapter gives you a reference to some\nuseful commands that reside within the bash shell.\nIn earlier chapters, you used the cd, pwd, set, and umask commands. In this\nsection, you will be using two more commands: the echo command, first used\nin Chapter 7, which displays messages to the screen, and the read command,\nwhich reads in data and stores it somewhere else. Just learning these two\ncommands alone will enable you to build a simple but powerful tool.\nYou’ll need a text editor to create shell scripts. You can use whichever\nLinux text editor you like best, including vi, vim, emacs, gedit, kate, and so\non. I’ll be using Leafpad in these tutorials, as I have in previous chapters.\nUsing a different editor should not make any difference in your script or its\nfunctionality.\nYour First Script: “Hello, Hackers-Arise!”\nFor your first script, we will start with a simple program that returns a\nmessage to the screen that says \"Hello, Hackers-Arise!\" Open your text editor,\nand let’s go.\nTo start, you need to tell your operating system which interpreter you\nwant to use for the script. To do this, enter a shebang, which is a combination\nof a hash mark and an exclamation mark, like so:\n#!\nYou then follow the shebang (#!) with /bin/bash to indicate that you want\nthe operating system to use the bash shell interpreter. As you’ll see in later\nchapters, you could also use the shebang to use other interpreters, such as\nPerl or Python. Here, you want to use the bash interpreter, so enter the\nfollowing:\n#! /bin/bash\nNext, enter the echo command, which tells the system to simply repeat (or\necho) back to your monitor whatever follows the command.\nIn this case, we want the system to echo back to us \"Hello, Hackers-Arise!\",\nas done in Listing 8-1. Note that the text or message we want to echo back\nmust be in double quotation marks.\n#! /bin/bash\n# This is my first bash script. Wish me luck.\necho \"Hello, Hackers-Arise!\"\nListing 8-1: Your “Hello, Hackers-Arise!” script\nHere, you also see a line that’s preceded by a hash mark (#). This is a\ncomment, which is a note you leave to yourself or anyone else reading the\ncode to explain what you’re doing in the script. Programmers use comments\nin every coding language. These comments are not read or executed by the\ninterpreter, so you don’t need to worry about messing up your code. They\nare visible only to humans. The bash shell knows a line is a comment if it\nstarts with the # character.\nNow, save this file as HelloHackersArise with no extension and exit your\ntext editor.\nSetting Execute Permissions\nBy default, a newly created bash script is not executable even by you, the\nowner. Let’s look at the permissions on our new file in the command line by\nusing cd to move into the directory and then entering ls -l. It should look\nsomething like this:\nkali >ls -l\n--snip--\n-rw-r--r-- 1 root root 42 Oct 22 14:32 HelloHackersArise\n--snip--\nAs you can see, our new file has rw-r--r-- (644) permissions. As you\nlearned in Chapter 5, this means the owner of this file only has read (r) and\nwrite (w) permissions, but no execute (x) permissions. The group and all\nother users have only read permissions. We need to give ourselves execute\npermissions in order to run this script. We change the permissions with the\nchmod command, as you saw in Chapter 5. To give the owner, the group, and\nall others execute permissions, enter the following:\nkali >chmod 755 HelloHackersArise\nNow when we do a long listing on the file, like so, we can see that we\nhave execute permissions:\nkali >ls -l\n--snip--\n-rwx r-x r-x 1 root root 42 Oct 22 14:32 HelloHackersArise\n--snip--\nThe script is now ready to execute!\nRunning HelloHackersArise\nTo run our simple script, enter the following:\nkali >./HelloHackersArise\nThe ./ before the filename tells the system that we want to execute this\nscript in the file HelloHackersArise from the current directory. It also tells the\nsystem that if there is another file in another directory named\nHelloHackersArise, please ignore it and only run HelloHackersArise in the\ncurrent directory. It may seem unlikely that there’s another file with this\nname on your system, but it’s good practice to use the ./ when executing\nfiles, as this localizes the file execution to the current directory and many\ndirectories will have duplicate filenames, such as start and setup.\nWhen we press ENTER, our very simple script returns our message to the\nmonitor:\nHello, Hackers-Arise!\nSuccess! You just completed your first shell script!\nAdding Functionality with Variables and User Input\nSo, now we have a simple script. All it does is echo back a message to\nstandard output. If we want to create more advanced scripts, we will likely\nneed to add some variables.\nA variable is an area of storage that can hold something in memory. That\n“something” might be some letters or words (strings) or numbers. It’s known\nas a variable because the values held within it are changeable; this is an\nextremely useful feature for adding functionality to a script.\nIn our next script, we will add functionality to prompt the user for their\nname, place whatever they input into a variable, then prompt the user for the\nchapter they’re at in this book, and place that keyboard input into a variable.\nAfter that, we’ll echo a welcome message that includes their name and the\nchapter back to the user.\nOpen a new file in your text editor and enter the script shown in Listing\n8-2.\n➊ #! /bin/bash\n➋ # This is your second bash script. In this one, you prompt /\n# the user for input, place the input in a variable, and /\n# display the variable contents in a string.\n➌ echo \"What is your name?\"\nread name\n➍ echo \"What chapter are you on in Linux Basics for Hackers?\"\nread chapter\n➎ echo \"Welcome\" $name \"to Chapter\" $chapter \"of Linux Basics for Hackers!\"\nListing 8-2: A simple script making use of variables\nWe open with #! /bin/bash to tell the system we want to use the bash\ninterpreter for this script ➊. We then add a comment that describes the\nscript and its functionality ➋. After that, we prompt the user for their name\nand ask the interpreter to read the input and place it into a variable we call\nname ➌. Then we prompt the user to enter the chapter they are currently\nworking through in this book, and we again read the keyboard input into a\nvariable, this time called chapter ➍.\nIn the final line, we construct a line of output that welcomes the reader by\ntheir name to the chapter they are on ➎. We use the echo command and\nprovide the text we want to display on the screen in double quotes. Then, to\nfill in the name and chapter number the user entered, we add the variables"
  },
  {
    "input": "Your Very First Hacker Script: Scan for Open Ports",
    "output": "where they should appear in the message. As noted in Chapter 7, to use the\nvalues contained in the variables, you must precede the variable name with\nthe $ symbol.\nSave this file as WelcomeScript.sh. The .sh extension is the convention for\nscript files. You might have noticed we didn’t include the extension earlier;\nit’s not strictly required, and if you leave the extension off, the file will save\nas a shell script file by default.\nNow, let’s run this script. Don’t forget to give yourself execute\npermission with chmod first; otherwise, the operating system will scold you\nwith a Permission denied message.\nkali >./WelcomeScript.sh\nWhat is your name?\nOccupytheWeb\nWhat chapter are you on in Linux Basics for Hackers?\n8\nWelcome OccupytheWeb to Chapter 8 of Linux Basics for Hackers!\nAs you can see, your script took input from the user, placed it into\nvariables, and then used those inputs to make a greeting for the user.\nThis is a simple script, but it taught you how to use variables and take\ninput from the keyboard. These are both crucial concepts in scripting that\nyou will need to use in more complex scripts in future.\nYour Very First Hacker Script: Scan for Open Ports\nNow that you have some basic scripting skills, let’s move to some slightly\nmore advanced scripting that has real-world application to hacking. We’ll\nuse an example from the world of black hat hacking. Black hat hackers are\nthose with malicious intentions, such as stealing credit card numbers or\ndefacing websites. White hat hackers are those with good intentions, such as\nhelping software developers or system administrators make their systems\nmore secure. Gray hat hackers are those who tend to move between these\ntwo extremes.\nBefore you continue, you need to become familiar with a simple yet\nessential tool named nmap that comes installed on Kali by default. You’ve\nlikely heard the name; nmap is used to probe a system to see whether it is\nconnected to the network and finds out what ports are open. From the open\nports discovered, you can surmise what services are running on the target\nsystem. This is a crucial skill for any hacker or system administrator.\nIn its simplest form, the syntax for running an nmap scan looks like this:\nnmap <type of scan><target IP><optionally, target port>\nNot too difficult. The simplest and most reliable nmap scan is the TCP\nconnect scan, designated with the -sT switch in nmap. So, if you wanted to\nscan IP address 192.168.181.1 with a TCP scan, you would enter the\nfollowing:\nnmap -sT 192.168.181.1\nTo take things a step further, if you wanted to perform a TCP scan of\naddress 192.168.181.1, looking to see whether port 3306 (the default port for\nMySQL) was open, you could enter this:\nnmap -sT 192.168.181.1 -p 3306\nHere, -p designates the port you want to scan for. Go ahead and try it out\nnow on your Kali system.\nOur Task\nAt the time of this writing, there is a hacker serving time in US federal\nprison by the name of Max Butler, also known as Max Vision throughout the\nhacker world. Max was a kind of gray hat hacker. By day, he was an IT\nsecurity professional in Silicon Valley, and by night, he was stealing and\nselling credit card numbers on the black market. At one time, he ran the\nworld’s largest credit card black market, CardersMarket. Now, Max is\nserving a 13-year prison term while at the same time assisting the Computer\nEmergency Response Team (CERT) in Pittsburgh with defending against\nhackers.\nA few years before Max was caught, he realized that the Aloha Point of\nSale (POS) system used by many small restaurants had a technical support\nbackdoor built into it. In this case, the backdoor enabled tech support to\nassist their clients. Aloha tech support could access the end user’s system\nthrough port 5505 to provide assistance when the user called for help. Max\nrealized that if he found a system connected to the internet with the Aloha\nPOS system, he could access the system with sysadmin privileges through\nport 5505. Max was able to enter many of these systems and steal tens of\nthousands of credit card numbers.\nEventually, Max wanted to find every system that had port 5505 open so\nthat he could go from stealing thousands of credit card numbers to stealing\nmillions. Max decided to write a script that would scan millions of IP\naddresses looking for systems with port 5505 open. Of course, most systems\ndo not have port 5505 open so, if they did, it was likely they were running\nthe doomed Aloha POS. He could run this script while at work during the\nday, then by night hack into those systems identified as having port 5505\nopen.\nOur task is to write a script that will be nearly identical to Max’s script,\nbut rather than scan for port 5505 as Max did, our script will scan for\nsystems connected to the ubiquitous online database MySQL. MySQL is an\nopen source database used behind millions of websites; we’ll be working with\nMySQL in Chapter 12. By default, MySQL uses port 3306. Databases are\nthe “Golden Fleece” that nearly every black hat hacker is seeking, as they\noften contain credit card numbers and personally identifiable information\n(PII) that is very valuable on the black market.\nA Simple Scanner\nBefore we write the script to scan public IPs across the internet, let’s take on\nmuch a smaller task. Instead of scanning the globe, let’s first write a script to\nscan for port 3306 on a local area network to see whether our script actually\nworks. If it does, we can easily edit it to do the much larger task.\nIn your text editor, enter the script shown in Listing 8-3.\n➊ #! /bin/bash\n➋ # This script is designed to find hosts with MySQL installed\nnmap ➌-sT 192.168.181.0/24 ➍-p 3306 ➎>/dev/null ➏-oG MySQLscan\n➐ cat MySQLscan | grep open > MySQLscan2 ➑\ncat MySQLscan2\nListing 8-3: The simplified scanner script\nWe start with the shebang and the interpreter to use ➊. Let’s follow this\nwith a comment to explain what the script does ➋.\nNow let’s use the nmap command to request a TCP scan ➌ on our LAN,\nlooking for port 3306 ➍. (Note that your IP addresses may differ; in your\nterminal, use the ifconfig command on Linux or the ipconfig command on\nWindows to determine your IP address.) To stay stealthy, we also send the\nstandard nmap output that would usually appear on the screen to a special\nplace in Linux, where it disappears ➎. We’re doing this on a local machine,\nso it doesn’t matter so much, but if you were to use the script remotely,\nyou’d want to hide the nmap output. We then send the output of the scan to\na file named MySQLscan in a grep-able format ➏, meaning a format that\ngrep can work on.\nThe next line displays the MySQLscan file we stored the output in and\nthen pipes that output to grep to filter for lines that include the keyword open\n➐. Then we put those lines into a file named MySQLscan2 ➑.\nFinally, you display the contents of the file MySQLscan2. This final file\nshould only include lines of output from nmap with hosts that have port\n3306 open. Save this file as MySQLscanner.sh and give yourself execute\npermissions with chmod 755.\nExecute the script, like so:\nkali >./MySQLscanner.sh\nhost: 192.168.181.69 () Ports: 3306/open/tcp//mysql///\nAs we can see, this script was able to identify the only IP address on my\nLAN with MySQL running. Your results may differ, depending on whether\nany ports are running MySQL installations on your local network, of course.\nImproving the MySQL Scanner\nNow we want to adapt this script to make it applicable to more than just\nyour own local network. This script would be much easier to use if it could\nprompt the user for the range of IP addresses they wanted to scan and the\nport to look for, and then use that input. Remember, you learned how to\nprompt the user and put their keyboard input into a variable in “Adding\nFunctionality with Variables and User Input” on page 84.\nLet’s take a look at how you could use variables to make this script more\nflexible and efficient.\nAdding Prompts and Variables to Our Hacker Script\nIn your text editor, enter the script shown in Listing 8-4.\n#! /bin/bash\n➊ echo \"Enter the starting IP address : \"\n➋ read FirstIP\n➌ echo \"Enter the last octet of the last IP address : \"\nread LastOctetIP\n➍ echo \"Enter the port number you want to scan for : \"\nread port\n➎ nmap -sT $FirstIP-$LastOctetIP -p $port >/dev/null -oG MySQLscan\n➏ cat MySQLscan | grep open > MySQLscan2\n➐ cat MySQLscan2\nListing 8-4: Your advanced MySQL port scanner\nThe first thing we need to do is replace the specified subnet with an IP\naddress range. We’ll create a variable called FirstIP and a second variable\nnamed LastOctetIP to create the range as well as a variable named port for the\nport number (the last octet is the last group of digits after the third period in\nthe IP address. In the IP address 192.168.1.101, the last octet is 101).\nNOTE\nThe name of the variable is irrelevant, but best practice is to use a variable\nname that helps you remember what the variable holds.\nWe also need to prompt the user for these values. We can do this by\nusing the echo command that we used in Listing 8-1.\nTo get a value for the FirstIP variable, echo \"Enter the starting IP address : \"\nto the screen, asking the user for the first IP address they want to scan ➊.\nUpon seeing this prompt on the screen, the user will enter the first IP\naddress, so we need to capture that input from the user.\nWe can do this with the read command followed by the name of the\nvariable we want to store the input in ➋. This command will put the IP\naddress entered by the user into the variable FirstIP. Then we can use that\nvalue in FirstIP throughout our script.\nWe’ll do the same for the LastOctetIP ➌ and port ➍ variables by prompting\nthe user to enter the information and then using a read command to capture\nit.\nNext, we need to edit the nmap command in our script to use the variables\nwe just created and filled. To use the value stored in the variable, we simply\npreface the variable name with $, as in $port, for example. So at ➎, we scan a\nrange of IP addresses, starting with the first user-input IP through the\nsecond user-input IP, and look for the particular port input by the user.\nWe’ve used the variables in place of the subnet to scan and the port to\ndetermine what to scan for. The redirect symbol > tells the standard nmap\noutput, which usually goes to the screen, to instead go to /dev/null (/dev/null\nis simply a place to send output so that it disappears). Then, we send the\noutput in a grep-able format to a file we named MySQLscan.\nThe next line remains the same as in our simple scanner: it outputs the\ncontents of the MySQLscan file, pipes it to grep, where it is filtered for lines\nthat include the keyword open, and then sends that output to a new file\nnamed MySQLscan2 ➏. Finally, we display the contents of the MySQLscan2\nfile ➐.\nIf everything works as expected, this script will scan IP addresses from the\nfirst input address to the last input address, searching for the input port and\nthen reporting back with just the IP addresses that have the designated port\nopen. Save your script file as MySQLscannerAdvanced, remembering to give\nyourself execute permission.\nA Sample Run\nNow we can run our simple scanner script with the variables that determine\nwhat IP address range and port to scan without having to edit the script\nevery time we want to run a scan:\nkali >./MySQLscannerAdvanced.sh\nEnter the starting IP address :"
  },
  {
    "input": "Common Built-in Bash Commands",
    "output": "192.168.181.0\nEnter the last IP address :\n192.168.181.255\nEnter the port number you want to scan for :\n3306\nHost: 192.168.181.254 ()Ports:3306/open/tcp//mysql//\nThe script prompts the user for the first IP address, the last IP address,\nand then the port to scan for. After collecting this info, the script performs\nthe nmap scan and produces a report of all the IP addresses in the range that\nhave the specified port open. As you can see, even the simplest of scripting\ncan create a powerful tool. You’ll learn even more about scripting in Chapter\n17.\nCommon Built-in Bash Commands\nAs promised, Table 8-1 gives you a list of some useful commands built into\nbash.\nTable 8-1: Built-in Bash Commands\nCommandFunction\n: Returns 0 or true\n. Executes a shell script\nbg Puts a job in the background\nbreak Exits the current loop\ncd Changes directory\ncontinue Resumes the current loop\necho Displays the command arguments\neval Evaluates the following expression\nexec Executes the following command without creating a new process\nexit Quits the shell\nexport Makes a variable or function available to other programs\nfg Brings a job to the foreground\ngetopts Parses arguments to the shell script"
  },
  {
    "input": "Exercises",
    "output": "jobs Lists background (bg) jobs\npwd Displays the current directory\nread Reads a line from standard input\nreadonly Declares as variable as read-only\nset Lists all variables\nshift Moves the parameters to the left\ntest Evaluates arguments\n[ Performs a conditional test\ntimes Prints the user and system times\ntrap Traps a signal\ntype Displays how each argument would be interpreted as a command\numask Changes the default permissions for a new file\nunset Deletes values from a variable or function\nwait Waits for a background process to complete\nSummary\nScripting is an essential skill for any hacker or system administrator. It\nenables you to automate tasks that would normally take hours of your time,\nand once the script is saved, it can be used over and over again. Bash\nscripting is the most basic form of scripting, and you will advance to Python\nscripting with even more capabilities in Chapter 17.\nEXERCISES\nBefore you move on to Chapter 9, try out the skills you learned from this chapter by\ncompleting the following exercises:\n1. Create your own greeting script similar to our HelloHackersArise script.\n2. Create a script similar to MySQLscanner.sh but design it to find systems with Microsoft’s\nSQL Server database at port 1433. Call it MSSQLscanner.\n3. Alter that MSSQLscanner script to prompt the user for a starting and ending IP address\nand the port to search for. Then filter out all the IP addresses where those ports are\nclosed and display only those that are open."
  },
  {
    "input": "What Is Compression?",
    "output": "9\nCOMPRESSING AND ARCHIVING\nHackers often need to download and install new software, as well as send and\ndownload multiple scripts and large files. These tasks are easier if these files\nare compressed and combined into a single file. If you come from the\nWindows world, you will probably recognize this concept from the .zip\nformat, which combines and compresses files to make them smaller for\ntransferring over the internet or removable media. There are many ways to\ndo this in Linux, and we look at a few of the most common tools for doing so\nin this chapter. We also look at the dd command, which allows you to copy\nentire drives, including deleted files on those drives.\nWhat Is Compression?\nThe interesting subject of compression could fill an entire book by itself, but\nfor this book we only need a rudimentary understanding of the process.\nCompression, as the name implies, makes data smaller, thereby requiring less\nstorage capacity and making the data easier to transmit. For your purposes as\na beginning hacker, it will suffice to categorize compression as either lossy or\nlossless.\nLossy compression is very effective in reducing the size of files, but the\nintegrity of the information is lost. In other words, the file after compression\nis not exactly the same as the original. This type of compression works great\nfor graphics, video, and audio files, where a small difference in the file is"
  },
  {
    "input": "Tarring Files Together",
    "output": "hardly noticeable—.mp3, .mp4, .png, and .jpg are all lossy compression\nalgorithms. If a pixel in a .png file or a single note in an .mp3 file is changed,\nyour eye or ear is unlikely to notice the difference—though, of course, music\naficionados will say that they can definitely tell the difference between an\n.mp3 and an uncompressed .flac file. The strengths of lossy compression are\nits efficiency and effectiveness. The compression ratio is very high, meaning\nthat the resulting file is significantly smaller than the original.\nHowever, lossy compression is unacceptable when you’re sending files or\nsoftware and data integrity is crucial. For example, if you are sending a script\nor document, the integrity of the original file must be retained when it is\ndecompressed. This chapter focuses on this lossless type of compression,\nwhich is available from a number of utilities and algorithms. Unfortunately,\nlossless compression is not as efficient as lossy compression, as you might\nimagine, but for the hacker, integrity is often far more important than\ncompression ratio.\nTarring Files Together\nUsually, the first thing you do when compressing files is to combine them\ninto an archive. In most cases, when archiving files, you’ll use the tar\ncommand. Tar stands for tape archive, a reference to the prehistoric days of\ncomputing when systems used tape to store data. The tar command creates a\nsingle file from many files, which is then referred to as an archive, tar file, or\ntarball.\nFor instance, say you had three script files like the ones we used in\nChapter 8, named hackersarise1, hackersarise2, and hackersarise3. If you\nnavigate to the directory that holds them and perform a long listing, you can\nclearly see the files and the details you’d expect, including the size of the\nfiles, as shown here:\nkali >ls -l\n-rwxr-xr-x 1 root root 22311 Nov 27 2018 13:00 hackersarise1.sh\n-rwxr-xr-x 1 root root 8791 Nov 27 2018 13:00 hackersarise2.sh\n-rwxr-xr-x 1 root root 3992 Nov 27 2018 13:00 hackersarise3.sh\nLet’s say you want to send all three of these files to another hacker you’re\nworking with on a project. You can combine them and create a single archive\nfile using the command in Listing 9-1.\nkali >tar -cvf HackersArise.tar hackersarise1 hackersarise2 hackersarise3\nhackersarise1\nhackersarise2\nhackersarise3\nListing 9-1: Creating a tarball of three files\nLet’s break down this command to better understand it. The archiving\ncommand is tar, and we’re using it here with three options. The c option\nmeans create, v (which stands for verbose and is optional) lists the files that\ntar is dealing with, and f means write to the following file. This last option\nwill also work for reading from files. Then we give the new archive the\nfilename you want to create from the three scripts: HackersArise.tar.\nIn full, this command will take all three files and create a single file,\nHackersArise.tar, out of them. When you do another long listing of the\ndirectory, you will see that it also contains the new .tar file, as shown next:\nkali >ls -l\n--snip--\n-rw-r--r-- 1 root root 40960 Nov 27 2018 13:32 HackersArise.tar\n--snip--\nkali >\nNote the size of the tarball here: 40,960 bytes. When the three files are\narchived, tar uses significant overhead to perform this operation: whereas the\nsum of the three files before archiving was 35,094 bytes, after archiving, the\ntarball had grown to 40,960 bytes. In other words, the archiving process has\nadded over 5,000 bytes. Although this overhead can be significant with small\nfiles, it becomes less and less significant with larger and larger files.\nWe can display those files from the tarball, without extracting them, by\nusing the tar command with the -t content list switch, as shown next:\nkali >tar -tvf HackersArise.tar\n-rwxr-xr-x 1 root root 22311 Nov 27 2018 13:00 hackersarise1.sh\n-rwxr-xr-x 1 root root 8791 Nov 27 2018 13:00 hackersarise2.sh\n-rwxr-xr-x 1 root root 3992 Nov 27 2018 13:00 hackersarise3.sh\nHere, we see our three original files and their original sizes. You can then\nextract those files from the tarball using the tar command with the -x (extract)\nswitch, as shown next:\nkali >tar -xvf HackersArise.tar\nhackersarise1.sh\nhackersarise2.sh"
  },
  {
    "input": "Compressing Files",
    "output": "hackersarise3.sh\nBecause you’re still using the –v switch, this command will show which\nfiles are being extracted in the output. If you want to extract the files and do\nso “silently,” meaning without showing any output, you can simply remove\nthe -v (verbose) switch, as shown here:\nkali >tar -xf HackersArise.tar\nThe files have been extracted into the current directory; you can do a\nlong listing on the directory to double-check. Note that by default, if an\nextracted file already exists, tar will remove the existing file and replace it\nwith the extracted file.\nCompressing Files\nNow we have one archived file, but that file is bigger than the sum of the\noriginal files. What if you want to compress those files for ease of transport?\nLinux has several commands capable of creating compressed files. We will\nlook at these:\ngzip, which uses the extension .tar.gz or .tgz\nbzip2, which uses the extension .tar.bz2\ncompress, which uses the extension .tar.z\nThese all are capable of compressing our files, but they use different\ncompression algorithms and have different compression ratios. Therefore,\nwe’ll look at each one and what it’s capable of.\nIn general, compress is the fastest, but the resultant files are larger; bzip2 is\nthe slowest, but the resultant files are the smallest; and gzip falls somewhere\nin between. The main reason you, as a budding hacker, should know all\nthree methods is that when accessing other tools, you will run into various\ntypes of compression. Therefore, this section shows you how to deal with\nthe main methods of compression.\nCompressing with gzip\nLet’s try gzip (GNU zip) first, as it is the most commonly used compression\nutility in Linux. You can compress your HackersArise.tar file by entering the\nfollowing (making sure you’re in the directory that holds the archived file):\nkali >gzip HackersArise.*\nNotice that we used the wildcard * for the file extension; this tells Linux\nthat the command should apply to any file that begins with HackersArise with\nany file extension. You will use similar notation for the following examples.\nWhen we do a long listing on the directory, we can see that HackersArise.tar\nhas been replaced by HackersArise.tar.gz, and the file size has been\ncompressed to just 3,299 bytes!\nkali >ls -l\n--snip--\n-rw-r--r-- 1 root root 3299 Nov 27 2018 13:32 HackersArise.tar.gz\n--snip--\nWe can then decompress that same file by using the gunzip command,\nshort for GNU unzip.\nkali >gunzip HackersArise.*\nOnce uncompressed, the file is no longer saved with the .tar.gz extension\nbut with the .tar extension instead. Also, notice that it has returned to its\noriginal size of 40,960 bytes. Try doing a long list to confirm this. It’s worth\nnoting that gzip can also be used to extract .zip files.\nCompressing with bzip2\nAnother of the other widely used compression utilities in Linux is bzip2,\nwhich works similarly to gzip but has better compression ratios, meaning that\nthe resulting file will be even smaller. You can compress your\nHackersArise.tar file by entering the following:\nkali >bzip2 HackersArise.*\nWhen you do a long listing, you can see that bzip2 has compressed the file\ndown to just 2,081 bytes! Also note that the file extension is now .tar.bz2.\nTo uncompress the compressed file, use bunzip2, like so:\nkali >bunzip2 HackersArise.*\nkali >"
  },
  {
    "input": "Creating Bit-by-Bit or Physical Copies of Storage Devices",
    "output": "When you do, the file returns to its original size, and its file extension\nreturns to .tar.\nCompressing with compress\nFinally, you can use the command compress to compress the file. This is\nprobably the least commonly used compression utility, but it’s easy to\nremember. To use it, simply enter the command compress followed by the\nfilename, like so:\nkali >compress HackersArise.*\nkali >ls -l\n--snip--\n-rw-r--r-- 1 root root 5476 Nov 27 2018 13:32 HackersArise.tar.Z\nNote that the compress utility reduced the size of the file to 5,476 bytes,\nmore than twice the size of bzip2. Also note that the file extension now is\n.tar.Z (with an uppercase Z).\nTo decompress the same file, use uncompress:\nkali >uncompress HackersArise.*\nYou can also use the gunzip command with files that have been compressed\nwith compress.\nCreating Bit-by-Bit or Physical Copies of Storage\nDevices\nWithin the world of information security and hacking, one Linux archiving\ncommand stands above the rest in its usefulness. The dd command makes a\nbit-by-bit copy of a file, a filesystem, or even an entire hard drive. This\nmeans that even deleted files are copied (yes, it’s important to know that\nyour deleted files may be recoverable), making for easy discovery and\nrecovery. Deleted files will not be copied with most logical copying utilities,\nsuch as cp.\nOnce a hacker has owned a target system, the dd command will allow\nthem to copy the entire hard drive or a storage device to their system. In\naddition, those people whose job it is to catch hackers—namely, forensic\ninvestigators—will likely use this command to make a physical copy of the\nhard drive with deleted files and other artifacts that might be useful for\nfinding evidence against the hacker.\nIt’s critical to note that the dd command should not be used for typical\nday-to-day copying of files and storage devices because it is very slow; other\ncommands do the job faster and more efficiently. It is, though, excellent\nwhen you need a copy of a storage device without the filesystem or other\nlogical structures, such as in a forensic investigation.\nThe basic syntax for the dd command is as follows:\ndd if=inputfile of=outputfile\nSo, if you wanted to make a physical copy of your flash drive, assuming\nthe flash drive is sdb (we’ll discuss this designation more in Chapter 10), you\nwould enter the following:\nkali >dd if=/dev/sdb of=/root/flashcopy\n1257441=0 records in\n1257440+0 records out\n7643809280 bytes (7.6 GB) copied, 1220.729 s, 5.2 MB/s\nLet’s break down this command: dd is your physical “copy” command; if\ndesignates your input file, with /dev/sdb representing your flash drive in the\n/dev directory; of designates your output file; and /root/flashcopy is the name\nof the file you want to copy the physical copy to. (For a more complete\nexplanation of the Linux system designation of drives within the /dev\ndirectory, see Chapter 10.)\nNumerous options are available to use with the dd command, and you can\ndo a bit of research on these, but among the most useful are the noerror\noption and the bs (block size) option. As the name implies, the noerror option\ncontinues to copy even if errors are encountered. The bs option allows you\nto determine the block size (the number of bytes read/written per block) of\nthe data being copied. By default, it is set to 512 bytes, but it can be changed\nto speed up the process. Typically, this would be set to the sector size of the\ndevice, most often 4KB (4,096 bytes). With these options, your command\nwould look like this:\nkali >dd if=/dev/media of=/root/flashcopy bs=4096 conv:noerror\nAs mentioned, it’s worth doing a little more research on your own, but"
  },
  {
    "input": "Exercises",
    "output": "this is a good introduction to the command and its common usages.\nSummary\nLinux has a number of commands to enable you to combine and compress\nyour files for easier transfer. For combining files, tar is the command of\nchoice, and you have at least three utilities for compressing files—gzip, bzip2,\nand compress—all with different compression ratios. The dd command goes\nabove and beyond. It enables you to make a physical copy of storage devices\nwithout the logical structures such as a filesystem, allowing you to recover\nsuch artifacts as deleted files.\nEXERCISES\nBefore you move on to Chapter 10, try out the skills you learned from this chapter by\ncompleting the following exercises:\n1. Create three scripts to combine, similar to what we did in Chapter 8. Name them\nLinux4Hackers1, Linux4Hackers2, and Linux4Hackers3.\n2. Create a tarball from these three files. Name the tarball L4H. Note how the size of the\nsum of the three files changes when they are tarred together.\n3. Compress the L4H tarball with gzip. Note how the size of the file changes. Investigate\nhow you can control overwriting existing files. Now uncompress the L4H file.\n4. Repeat Exercise 3 using both bzip2 and compress.\n5. Make a physical, bit-by-bit copy of one of your flash drives using the dd command."
  },
  {
    "input": "10 FILESYSTEM AND STORAGE DEVICE MANAGEMENT",
    "output": "10\nFILESYSTEM AND STORAGE DEVICE\nMANAGEMENT\nIf you are coming from a Windows environment, the way that Linux\nrepresents and manages storage devices will look rather different to you.\nYou’ve already seen that the filesystem has no physical representation of the\ndrive, like the C:, D:, or E: system in Windows, but rather has a file tree\nstructure with / at the top, or root, of it. This chapter takes a look at how\nLinux represents storage devices such as hard drives, flash drives, and other\nstorage devices.\nWe first look how additional drives and other storage devices are\nmounted upon that filesystem, leading up to the / (root) directory. Mounting\nin this context simply means attaching drives or disks to the filesystem to\nmake them accessible to the operating system (OS). For you as a hacker, it’s\nnecessary to understand the file and storage device management system,\nboth on your own system and, often, the system of your target. Hackers\ncommonly use external media to load data, hacking tools, or even their OS.\nOnce you’re on your target system, you need to understand what you’re\nworking with, where to find confidential or other critical files, how to mount\na drive to the target, and whether and where you can put those files on your\nsystem. We cover all of these topics, plus how to manage and monitor\nstorage devices, in this chapter.\nWe begin with the directory known as /dev, which you’ve probably\nalready noticed in the directory structure: dev is short for device, and every"
  },
  {
    "input": "The Device Directory /dev",
    "output": "device in Linux is represented by its own file within the /dev directory. Let’s\nstart out by working with /dev.\nThe Device Directory /dev\nLinux has a special directory that contains files representing each attached\ndevice: the appropriately named /dev directory. As your first introduction,\nnavigate to the /dev directory and then perform a long listing on it. You\nshould see something like Listing 10-1.\nkali >cd /dev\nkali >ls -l\ntotal 0\ncrw------- 1 root root 10,175 May 16 12:44 agpgart\ncrw------- 1 root root 10,235 May 16 12:44 autofs\ndrwxr-xr-x 1 root root 160 May 16 12:44 block\n--snip--\nlrwxrwxrwx 1 root root 3 May 16 12:44 cdrom -> sr0\n--snip--\ndrwxr-xr-x 2 root root 60 May 16 12:44 cpu\n--snip--\nListing 10-1: A long listing of the /dev directory\nThe devices are displayed in alphabetical order by default. You may\nrecognize some of the devices, such a cdrom and cpu, but others have rather\ncryptic names. Each device on your system is represented by a file in the /dev\ndirectory, including devices you’ve probably never used or even realized\nexisted. On the off chance you do, there is a device file waiting to be used for\nit.\nIf you scroll down this screen a bit, you should see more listings of\ndevices. Of particular interest are the devices sda1, sda2, sda3, sdb, and sdb1,\nwhich are the hard drive and its partitions and a USB flash drive and its\npartitions.\n--snip--\nbrw-rw---- 1 root root 8, 0 May 16 12:44 sda\nbrw-rw---- 1 root root 8, 1 May 16 12:44 sda1\nbrw-rw---- 1 root root 8, 2 May 16 12:44 sda2\nbrw-rw---- 1 root root 8, 5 May 16 12:44 sda5\nbrw-rw---- 1 root root 8, 16 May 16 12:44 sdb\nbrw-rw---- 1 root root 8, 17 May 16 12:44 sdb1\n--snip--\nLet’s take a closer look at these.\nHow Linux Represents Storage Devices\nLinux uses logical labels for drives that are then mounted on the filesystem.\nThese logical labels will vary depending on where the drives are mounted,\nmeaning the same hard drive might have different labels at different times,\ndepending on where and when it’s mounted.\nOriginally, Linux represented floppy drives (remember those?) as fd0 and\nhard drives as hda. You will still occasionally see these drive representations\non legacy Linux systems, but today most floppy drives are gone (thank\ngoodness). Even so, old legacy hard drives that used an IDE or E-IDE\ninterface are still represented in the form hda. Newer Serial ATA (SATA)\ninterface drives and Small Computer System Interface (SCSI) hard drives are\nrepresented as sda. Drives are sometimes split up into sections known as\npartitions, which are represented in the labeling system with numbers, as\nyou’ll see next.\nWhen systems have more than one hard drive, Linux simply names them\nserially by incrementing the last letter in alphabetical order, so the first drive\nis sda, and the second drive is sdb, the third drive is sdc, and so on (see Table\n10-1). The serial letter after sd is often referred to as the major number.\nTable 10-1: Device-Naming System\nDevice fileDescription\nsda First SATA hard drive\nsdb Second SATA hard drive\nsdc Third SATA hard drive\nsdd Fourth SATA hard drive\nDrive Partitions\nSome drives can be split into partitions in order to manage and separate\ninformation. For instance, you may want to separate your hard drive so that\nyour swap file, home directory, and / directory are all on separate partitions—\nyou might want to do this for a number of reasons, including to share\nresources and to relax the default permissions. Linux labels each partition\nwith a minor number that comes after the drive designation. This way, the\nfirst partition on the first SATA drive would be sda1. The second partition\nwould then be sda2, the third sda3, and so on, as illustrated in Table 10-2.\nTable 10-2: Partition-Labeling System\nPartitionDescription\nsda1 The first partition (1) on the first (a) SATA drive\nsda2 The second (2) partition on the first (a) drive\nsda3 The third (3) partition on the first (a) drive\nsda4 The fourth (4) partition on the first (a) drive\nAt times, you may want to view the partitions on your Linux system to\nsee which ones you have and how much capacity is available in each. You can\ndo this by using the fdisk utility. Using the -l switch with fdisk lists all the\npartitions of all the drives, as shown in Listing 10-2.\nkali >fdisk -l\nDisk /dev/sda: 20GiB, 21474836480 bytes, 41943040 sectors\nUnits: sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x7c06cd70\nDevice Boot Start End Sectors Size Id Type\n/dev/sda1 * 2048 39174143 39172096 18.7G 83 Linux\n/dev/sda2 39176190 41940991 2764802 1.3G 5 Extended\n/dev/sda5 39176192 41940991 2764800 1.3G 82 Linux swap / Solaris\nDisk /dev/sdb: 29.8 GiB, 31999393792 bytes, 62498816 sectors\nUnits: sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0xc3072e18\nDevice Boot Start End Sectors Size Id Type\n/dev/sdb1 32 62498815 62498784 29.8G 7 HPFS/NTFS/exFAT\nListing 10-2: Listing partitions with fdisk\nAs you can see in Listing 10-2, the devices sda1, sda2, and sda5 are listed\nin the first stanza. These three devices make up the virtual disk from my\nvirtual machine, which is a 20GB drive with three partitions, including the\nswap partition (sda5), which acts like virtual RAM—similar to page files in\nWindows—when RAM capacity is exceeded.\nIf you scan down Listing 10-2 to the third stanza, you see a second device\noutput designated sdb1—the b label tells us that this drive is separate from\nthe first three devices. This is my 64GB flash drive. Note that fdisk indicates\nthat it is an HPFS/NTFS/ExFAT filesystem type. These file types—High\nPerformance File System (HPFS), New Technology File System (NTFS),\nand Extended File Allocation Table (exFAT)—are not native to Linux\nsystems but rather to macOS and Windows systems. It’s worth being able to\nrecognize file types native to different systems when you investigate. The\nfilesystem might indicate what kind of machine the drive was formatted on,\nwhich can be valuable information. Kali is able to utilize USB flash drives\ncreated on many different operating systems.\nAs you saw in Chapter 1, the Linux filesystem is structured significantly\ndifferently than are Windows and other proprietary operating systems. On\ntop of this, the way files are stored and managed is different in Linux, too.\nNew versions of Windows use an NTFS filesystem, whereas older Windows\nsystems use File Allocation Table (FAT) systems. Linux uses a number of\ndifferent types of filesystems, but the most common are ext2, ext3, and ext4.\nThese are all iterations of the ext (or extended) filesystem, with ext4 being the\nlatest.\nCharacter and Block Devices\nSomething else to note about the naming of device files in the /dev directory\nis that the first position contains either c or b. You can see this in Listing 10-\n1 at the start of most of the entries, and it looks something like this:\ncrw------- 1 root root 10,175 May 16 12:44 agpgart\nThese letters represent the two ways that devices transfer data in and out.\nThe c stands for character, and these devices are known, as you might expect,\nas character devices. External devices that interact with the system by sending\nand receiving data character by character, such as mice or keyboards, are\ncharacter devices.\nThe b stands for the second type: block devices. They communicate in\nblocks of data (multiple bytes at a time) and include devices like hard drives\nand DVD drives. These devices require higher-speed data throughput and"
  },
  {
    "input": "Mounting and Unmounting",
    "output": "therefore send and receive data in blocks (many characters or bytes at a\ntime). Once you know whether a device is a character or block device, you\ncan easily get more information about it, as you’ll see next.\nList Block Devices and Information with lsblk\nThe Linux command lsblk, short for list block, lists some basic information\nabout each block device listed in /dev. The result is similar to the output\nfrom fdisk -l, but it will also display devices with multiple partitions in a kind\nof tree, showing each device with its partitions as branches, and does not\nrequire root privileges to run. In Listing 10-3, for example, we see sda, with\nits branches sda1, sda2, and sda5.\nkali >lsblk\nName MAJ:MIN RM SIZE RO TYPE MOUNTPOINT\nfd0 2:0 1 4K 0 disk\nsda1 8:0 0 20G 0 disk\n|-sda1 8:1 0 18.7G 0 part /\n|-sda2 8:2 0 1K 0 part\n|-sda5 8:5 0 1.3G 0 part [SWAP]\nsdb 8:16 1 29.8G 0 disk\n|-sdb1 8.17 1 29.8G 0 disk /media\nsr0 11:0 1 2.7G 0 rom\nListing 10-3: Listing block device information with lsblk\nThe output includes the floppy drive as fd0 and DVD drive as sr0, even\nthough neither is on my system—this is simply a holdover from legacy\nsystems. We can also see information on the mount point of the drive—this is\nthe position at which the drive was attached to the filesystem. Note that the\nhard drive sda1 is mounted at / and the flash drive is mounted at /media.\nYou’ll see more on the significance of this in the next section.\nMounting and Unmounting\nMost modern operating systems, including most new versions of Linux,\nautomount storage devices when they’re attached, meaning the new flash\ndrive or hard drive is automatically attached to the filesystem. For those new\nto Linux, mounting might be a foreign subject.\nA storage device must be first physically connected to the filesystem and\nthen logically attached to the filesystem in order for the data to be made\navailable to the operating system. In other words, even if the device is\nphysically attached to the system, it is not necessarily logically attached and\navailable to the operating system. The term mount is a legacy from the early\ndays of computing when storage tapes (before hard drives) had to be\nphysically mounted to the computer system—think of those big computers\nwith spinning tape drives you might have seen old sci-fi movies.\nAs mentioned, the point in the directory tree where devices are attached\nis known as the mount point. The two main mount points in Linux are /mnt\nand /media. As a general rule, internal hard drives are mounted at /mnt, and\nexternal USB devices such as flash drives and external USB hard drives are\nmounted at /media, though technically any directory can be used.\nMounting Storage Devices Yourself\nIn some versions of Linux, you need to mount a drive manually in order to\naccess its content, so this is a skill worth learning. To mount a drive on the\nfilesystem, use the mount command. The mount point for the device should be\nan empty directory; if you mount a device on a directory that has\nsubdirectories and files, the mounted device will cover the contents of the\ndirectory, making them invisible and unavailable. So, to mount the new hard\ndrive sdb1 at the /mnt directory, you would enter the following:\nkali >mount /dev/sdb1 /mnt\nThat hard drive should then be available for access. If you want to mount\nthe flash drive sdc1 at the /media directory, you would enter this:\nkali >mount /dev/sdc1 /media\nThe filesystems that are mounted on a system are kept in a file at /etc/fstab\n(short for filesystem table), which is read by the system at every bootup.\nUnmounting with umount\nIf you’re coming from a Mac or Windows background, you’ve probably\nunmounted a drive without knowing it. Before you remove a flash drive from\nyour system, you “eject” it to keep from causing damage to the files stored\non the device. Eject is just another word for unmount."
  },
  {
    "input": "Monitoring Filesystems",
    "output": "Similar to the mount command, you can unmount a second hard drive by\nentering the umount command followed by the file entry of the device in the\n/dev directory, such as /dev/sdb. Note that the command is not spelled\nunmount but rather umount (no n).\nkali >umount /dev/sdb1\nYou cannot unmount a device that is busy, so if the system is reading or\nwriting to the device, you will just receive an error.\nMonitoring Filesystems\nIn this section, we look at some commands for monitoring the state of the\nfilesystem—a skill necessary for any hacker or system administrator. We’ll\nget some info about mounted disks and then check for and fix errors. Storage\ndevices are particularly error prone, so it’s worth learning this skill.\nGetting Information on Mounted Disks\nThe command df (for disk free) will provide us with basic information on any\nhard disks or mounted devices, such as CD, DVD, and flash drives,\nincluding how much space is being used and how much is available (see\nListing 10-4). Without any options, df defaults to the first drive on your\nsystem (in this case, sda). If you want to check a different drive, simply follow\nthe df command with the drive representation you want to check (for\nexample, df sdb).\nkali >df\nFilesystem 1K-Blocks Used Available Use% Mounted on\nrootfs 19620732 17096196 1504788 92% /\nudev 10240 0 10240 0% /dev\n--snip--\n/dev/sdb1 29823024 29712544 110480 99% /media/USB3.0\nListing 10-4: Getting information on disks and mounted devices with df\nThe first line of output here shows category headers, and then we get the\ninformation. The disk space is given in 1KB blocks. On the second line, we\nsee that rootfs has 19,620,732 one-kilobyte blocks, of which it is using\n17,096,196 (or about 92 percent), leaving 1,504,788 available. The df\ncommand also tells us that this filesystem is mounted on the top of the\nfilesystem /.\nIn the last line, you can see my USB flash drive. Note that it is designated\n/dev/sdb1, is nearly 100 percent full, and is mounted at /media/USB3.0.\nAs a recap, my virtual disk on this system is designated sda1, which breaks\ndown as follows:\nsd SATA hard drive\na First hard drive\n1 First partition on that drive\nMy 64GB flash drive is designated as sdb1, and my external drive as sdc1.\nChecking for Errors\nThe fsck command (short for filesystem check) checks the filesystem for errors\nand repairs the damage, if possible, or else puts the bad area into a bad blocks\ntable to mark it as bad. To run the fsck command, you need to specify the\nfilesystem type (the default is ext2) and the device file to check. It’s\nimportant to note that you must unmount the drive before running a\nfilesystem check. If you fail to unmount the mounted device, you will receive\nthe error message shown in Listing 10-5.\nkali >fsck\nfsck from util-linux 2.20.1\ne2fsck 1.42.5 (29-Jul-2012)\n/dev/sda1 is mounted\ne2fsck: Cannot continue, aborting.\nListing 10-5: Trying (and failing) to run an error check on a mounted drive\nSo, the first step when performing a filesystem check is to unmount the\ndevice. In this case, I will unmount my flash drive to do a filesystem check:\nkali >umount /dev/sdb1\nI can add the -p option to have fsck automatically repair any problems\nwith the device, like so:\nkali >fsck -p /dev/sdb1"
  },
  {
    "input": "Exercises",
    "output": "With the device unmounted, I can now check for any bad sectors or other\nproblems with the device, as follows:\nkali >fsck -p /dev/sdb1\nfsck from util-linux 2.30.2\nexfatfsck 1.2.7\nChecking file system on /dev/sdb1.\nFile system version 1.0\nSector size 512 bytes\nCluster size 32 KB\nVolume size 7648 MB\nUsed space 1265 MB\nAvailable space 6383 MB\nTotally 20 directories and 111 files.\nFile system checking finished. No errors found.\nSummary\nUnderstanding how Linux designates and manages its devices is crucial for\nany Linux user and hacker. Hackers will need to know what devices are\nattached to a system and how much space is available. Because storage\ndevices often develop errors, we can check and repair those errors with fsck.\nThe dd command is capable of making a physical copy of a device, including\nany deleted files.\nEXERCISES\nBefore you move on to Chapter 11, try out the skills you learned from this chapter by\ncompleting the following exercises:\n1. Use the mount and umount commands to mount and unmount your flash drive.\n2. Check the amount of disk space free on your primary hard drive.\n3. Check for errors on your flash drive with fsck.\n4. Use the dd command to copy the entire contents of one flash drive to another, including\ndeleted files.\n5. Use the lsblk command to determine basic characteristics of your block devices."
  },
  {
    "input": "The rsyslog Logging Daemon",
    "output": "11\nTHE LOGGING SYSTEM\nFor any Linux user, it’s crucial to be knowledgeable in the use of the log\nfiles. Log files store information about events that occur when the operating\nsystem and applications are run, including any errors and security alerts.\nYour system will log information automatically based on the series of rules\nthat I will show you how to configure in this chapter.\nAs a hacker, the log files can be a trail to your target’s activities and\nidentity. But it can also be a trail to your own activities on someone else’s\nsystem. A hacker therefore needs to know what information they can gather,\nas well as what can be gathered about their own actions and methods in\norder to hide that evidence.\nOn the other side, anyone securing Linux systems needs to know how to\nmanage the logging functions to determine whether a system has been\nattacked and then decipher what actually happened and who did it.\nThis chapter shows you how to examine and configure log files, as well as\nhow to remove evidence of your activity and even disable logging altogether.\nFirst, we’ll look at the daemon that does the logging.\nThe rsyslog Logging Daemon\nLinux uses a daemon called syslogd to automatically log events on your\ncomputer. Several variations of syslog, including rsyslog and syslog-ng, are used\non different distributions of Linux, and even though they operate very\nsimilarly, some minor differences exist. Since Kali Linux is built on Debian,\nand Debian comes with rsyslog by default, we focus on that utility in this\nchapter. If you want to use other distributions, it’s worth doing a little\nresearch on their logging systems.\nLet’s take a look at rsyslog on your system. We’ll search for all files related\nto rsyslog. First, open a terminal in Kali and enter the following:\nkali >locate rsyslog\n/etc/rsyslog.conf\n/etc/rsyslog.d\n/etc/default/rsyslog\n/etc/init.d/rsyslog\n/etc/logcheck/ignore.d.server/rsyslog\n/etc/logrotate.d/rsyslog\n/etc/rc0.d/K04rsyslog\n--snip--\nAs you can see, numerous files contain the keyword rsyslog—some of\nwhich are more useful than others. The one we want to examine is the\nconfiguration file rsyslog.conf.\nThe rsyslog Configuration File\nLike nearly every application in Linux, rsyslog is managed and configured by\na plaintext configuration file located, as is generally the case in Linux, in the\n/etc directory. In the case of rsyslog, the configuration file is located at\n/etc/rsyslog.conf. Open that file with any text editor, and we’ll explore what’s\ninside (here, I use Leafpad):\nkali >leafpad /etc/rsyslog.conf\nYou should see something like Listing 11-1.\n/etc/rsyslog.conf Configuration file for rsyslog.\n# For more information see\n# /usr/share/doc/rsyslog-doc/html/rsyslog_conf.html\n#################\n#### MODULES ####\n#################\nmodule(load=\"imuxsock\") # provides support for local system logging\nmodule(load=\"imklog\") # provides kernel logging support\n#module(load=\"immark\") # provides --MARK-- message capability\n# provides UDP syslog reception\n#module(load=\"imudp\")\n#input(type=\"imudp\" port=\"514\")\n# provides TCP syslog reception\n#module(load=\"imtcp\")\n#input(type=\"imtcp\" port=\"514\")\n###########################\n#### GLOBAL DIRECTIVES ####\n###########################\nListing 11-1: A snapshot of the rsyslog.conf file\nAs you can see, the rsyslog.conf file comes well documented with numerous\ncomments explaining its use. Much of this information will not be useful to\nyou at this moment, but if you navigate down to below line 50, you’ll find\nthe Rules section. This is where you can set the rules for what your Linux\nsystem will automatically log for you.\nThe rsyslog Logging Rules\nThe rsyslog rules determine what kind of information is logged, what\nprograms have their messages logged, and where that log is stored. As a\nhacker, this allows you to find out what is being logged and where those logs\nare written so you can delete or obscure them. Scroll to line 50 and you\nshould see something like Listing 11-2.\n###############\n#### RULES ####\n###############\n#\n# First some standard log files. Log by facility.\n#\nauth,authpriv.* /var/log/auth.log\n*.*;auth,authpriv.none -/var/log/syslog\n#cron.* /var/log/cron.log\ndaemon.* -/var/log/daemon.log\nkern.* -/var/log/kern.log\n1pr.* -/var/log/lpr.log\nmail.* -/var/log/mail.log\nuser.* -/var/log/user.log\n#\n# Logging for the mail system. Split it up so that\n# it is easy to write scripts to parse these files.\n#\nmail.info -/var/log/mail.info\nmail.warn -/var/log/mail.warn\nmail.err /var/log/mail.err\nListing 11-2: Finding the logging rules in rsyslog.conf\nEach line is a separate logging rule that says what messages are logged\nand where they’re logged to. The basic format for these rules is as follows:\nfacility.priority action\nThe facility keyword references the program, such as mail, kernel, or lpr,\nwhose messages are being logged. The priority keyword determines what\nkind of messages to log for that program. The action keyword, on the far\nright, references the location where the log will be sent. Let’s look at each\nsection more closely, beginning with the facility keyword, which refers to\nwhatever software is generating the log, whether that’s the kernel, the mail\nsystem, or the user.\nThe following is a list of valid codes that can be used in place of the\nfacility keyword in our configuration file rules:\nauth/authpriv Security/authorization messages\ncron Clock daemons\ndaemon Other daemons\nkern Kernel messages\nlpr Printing system\nmail Mail system\nuser Generic user-level messages\nAn asterisk wildcard (*) in place of a word refers to all facilities. You can\nselect more than one facility by listing them separated by a comma.\nThe priority tells the system what kinds of messages to log. Codes are\nlisted from lowest priority, starting at debug, to highest priority, ending at\npanic. If the priority is *, messages of all priorities are logged. When you\nspecify a priority, messages of that priority and higher are logged. For\ninstance, if you specify a priority code of alert, the system will log messages\nclassified as alert and higher priority, but it won’t log messages marked as\ncrit or any priority lower than alert.\nHere’s the full list of valid codes for priority:\ndebug\ninfo\nnotice\nwarning\nwarn\nerror\nerr\ncrit\nalert\nemerg\npanic\nThe codes warning, warn, error, err, emerg, and panic have all been deprecated\nand should not be used.\nThe action is usually a filename and location where the logs should be\nsent. Note that generally, log files are sent to the /var/log directory with a\nfilename that describes the facility that generated them, such as auth. This\nmeans, for example, that logs generated by the auth facility would be sent to\n/var/log.auth.log.\nLet’s look at some examples of log rules:\nmail.* /var/log/mail\nThis example will log mail events of all (*) priorities to /var/log/mail.\nkern.crit /var/log/kernel\nThis example will log kernel events of critical (crit) priority or higher to\n/var/log/kernel.\n*.emerg *\nThis last example will log all events of the emergency (emerg) priority to all\nlogged-on users. With these rules, the hacker can determine where the log\nfiles are located, change the priorities, or even disable specific logging rules."
  },
  {
    "input": "Automatically Cleaning Up Logs with logrotate",
    "output": "Automatically Cleaning Up Logs with logrotate\nLog files take up space, so if you don’t delete them periodically, they will\neventually fill your entire hard drive. On the other hand, if you delete your\nlog files too frequently, you won’t have logs to investigate at some future\npoint in time. You can use logrotate to determine the balance between these\nopposing requirements by rotating your logs.\nLog rotation is the process of regularly archiving log files by moving them\nto some other location, leaving you with a fresh log file. That archived\nlocation will then get cleaned up after a specified period of time.\nYour system is already rotating log files using a cron job that employs the\nlogrotate utility. You can configure the logrotate utility to choose the\nregularity of your log rotation with the /etc/logrotate.conf text file. Let’s open\nit with a text editor and take a look:\nkali >leafpad /etc/logrotate.conf\nYou should see something like Listing 11-3.\n# see \"man logrotate\" for details\n# rotate log files weekly\n➊ weekly\n# keep 4 weeks worth of backlogs\n➋ rotate 4\n➌ # create new (empty) log files after rotating old ones\ncreate\n➍ # uncomment this if you want your log files compressed\n#compress\n# packages drop log rotation information into this directory\ninclude /etc/logrotate.d\n# no packages own wtmp, or btmp -- we'll rotate them here\n/var/log/wtmp {\nmissingok\nmonthly\ncreate 0664 root utmp\nrotate 1\n}\nListing 11-3: The logrotate configuration file\nFirst, you can set the unit of time your rotate numbers refer to ➊. The\ndefault here is weekly, meaning any number after the rotate keyword always\nrefers to weeks.\nFurther down, you can see the setting for how often to rotate logs—the\ndefault setting is to rotate logs every four weeks ➋. This default\nconfiguration will work for most people, but if you want to keep your logs\nlonger for investigative purposes or shorter to clear them out quicker, this is\nthe setting you should change. For instance, if you check your log files every\nweek and want to save storage space, you could change this setting to rotate\n1. If you have plenty of storage for your logs and want to keep a semi-\npermanent record for forensic analysis later, you could change this setting to\nrotate 26 to keep your logs for six months or rotate 52 to keep them for one\nyear.\nBy default, a new empty log file is created when old ones are rotated out\n➌. As the comments in the configuration file advise, you can also choose to\ncompress your rotated log files ➍.\nAt the end of each rotation period, the log files are renamed and pushed\ntoward the end of the chain of logs as a new log file is created, replacing the\ncurrent log file. For instance, /var/log.auth will become /var/log.auth.1, then\n/var/log.auth.2, and so on. If you rotate logs every four weeks and keep four\nset of backups, you will have /var/log.auth.4, but no /var/log.auth.5, meaning\nthat /var/log.auth.4 will be deleted rather than being pushed to\n/var/log/auth.5. You can see this by using the locate command to find\n/var/log/auth.log log files with a wildcard, as shown here:\nkali >locate /var/log/auth.log.*\n/var/log/auth.log.1\n/var/log/auth.log.2\n/var/log/auth.log.3\n/var/log/auth.log.4\nFor more details on the many ways to customize and use the logrotate\nutility, see the man logrotate page. This is an excellent resource to learn about\nthe functions you can use and the variables you can change to customize how\nyour logs are handled. Once you become more familiar with Linux, you’ll\nget a better sense of how often you need to log and what options you prefer,\nso it’s worth revisiting the logrotate.conf file."
  },
  {
    "input": "Remaining Stealthy",
    "output": "Remaining Stealthy\nOnce you’ve compromised a Linux system, it’s useful to disable logging and\nremove any evidence of your intrusion in the log files to reduce the chances\nof detection. There are many ways to do this, and each carries its own risks\nand level of reliability.\nRemoving Evidence\nFirst, you’ll want to remove any logs of your activity. You could simply open\nthe log files and precisely remove any logs detailing your activity, line by\nline, using the file deletion techniques you learned in Chapter 2. However,\nthis could be time-consuming and leave time gaps in the log files, which\nwould look suspicious. Also, deleted files can generally be recovered by a\nskilled forensic investigator.\nA better and more secure solution is to shred the log files. With other file\ndeletion systems, a skilled investigator is still able to recover the deleted files,\nbut suppose there was a way to delete the file and overwrite it several times,\nmaking it much harder to recover. Lucky for us, Linux has a built-in\ncommand, appropriately named shred, for just this purpose.\nTo understand how the shred command works, take a quick look at the\nhelp screen by entering the following command:\nkali >shred --help\nUsage: shred [OPTION]...FILE...\nOverwrite the specified FILE(s) repeatedly in order to make it harder\nfor even very expensive hardware probing to recover data\n--snip--\nAs you can see from the full output on your screen, the shred command\nhas many options. In its most basic form, the syntax is simple:\nshred <FILE>\nOn its own, shred will delete the file and overwrite it several times—by\ndefault, shred overwrites four times. Generally, the more times the file is\noverwritten, the harder it is to recover, but keep in mind that each overwrite\ntakes time, so for very large files, shredding may become time-consuming.\nTwo useful options to include are the -f option, which changes the\npermissions on the files to allow overwriting if a permission change is\nnecessary, and the –n option, which lets you choose how many times to\noverwrite the files. As an example, we’ll shred the log files in /var/log/auth.log\n10 times using the following command:\nkali >shred -f -n 10 /var/log/auth.log.*\nWe need the –f option to give us permission to shred auth files, and we\nfollow the –n option with the desired number of times to overwrite. After the\npath of the file we want to shred, we include the wildcard asterisk so we’re\nshredding not just the auth.log file, but also any logs that have been created\nwith logrotate, such as auth.log.1, auth.log.2, and so on.\nNow try to open a log file:\nkali >leafpad /var/log/auth.log.1\nOnce you’ve shredded a file, you’ll see that the contents are\nindecipherable gibberish, as shown in Figure 11-1.\nFigure 11-1: A shredded log file\nNow if the security engineer or forensic investigator examines the log\nfiles, they will find nothing of use because none of it is recoverable!\nDisabling Logging\nAnother option for covering your tracks is to simply disable logging. When a\nhacker takes control of a system, they could immediately disable logging to\nprevent the system from keeping track of their activities. This, of course,\nrequires root privileges.\nTo disable all logging, the hacker could simply stop the rsyslog daemon.\nStopping any service in Linux uses the same syntax, shown here (you’ll see\nmore on this in Chapter 12):\nservice servicename start|stop|restart"
  },
  {
    "input": "Exercises",
    "output": "So, to stop the logging daemon, you could simply enter the following\ncommand:\nkali >service rsyslog stop\nNow Linux will stop generating any log files until the service is restarted,\nenabling you to operate without leaving behind any evidence in the log files!\nSummary\nLog files track nearly everything that happens on your Linux system. They\ncan be an invaluable resource in trying to analyze what has occurred,\nwhether it be a malfunction or a hack. For the hacker, log files can be\nevidence of their activities and identity. However, an astute hacker can\nremove and shred these files and disable logging entirely, thus leaving no\nevidence behind.\nEXERCISES\nBefore you move on to Chapter 12, try out the skills you learned from this chapter by\ncompleting the following exercises:\n1. Use the locate command to find all the rsyslog files.\n2. Open the rsyslog.conf file and change your log rotation to one week.\n3. Disable logging on your system. Investigate what is logged in the file /var/log/syslog when\nyou disable logging.\n4. Use the shred command to shred and delete all your kern log files."
  },
  {
    "input": "Starting, Stopping, and Restarting Services",
    "output": "12\nUSING AND ABUSING SERVICES\nIn Linux terminology, a service is an application that runs in the background\nwaiting for you to use it. Your Linux system has dozens of services\npreinstalled. Of these, the most well known is the ubiquitous Apache Web\nServer, which is used for creating, managing, and deploying web servers, but\nthere are so many more. For the purposes of this chapter on services, I have\nselected just four that are of particular importance to the hacker: Apache\nWeb Server, OpenSSH, MySQL, and PostgreSQL.\nIn this chapter, you’ll learn how to set up a web server with Apache,\nphysically spy with OpenSSH, access data with MySQL, and store your\nhacking information with PostgreSQL\nStarting, Stopping, and Restarting Services\nBefore we begin to work with these four crucial services, let’s start by\nexamining how to start, stop, and restart services in Linux.\nSome services can be stopped and started via the GUI in Kali Linux,\nmuch as you would on an operating system like Windows or Mac. However,\nsome services require use of the command line, which we’ll look at here.\nHere is the basic syntax for managing services:\nservice servicename start|stop|restart\nTo start the apache2 service (web server or HTTP service), you would"
  },
  {
    "input": "Creating an HTTP Web Server with the Apache Web Server",
    "output": "enter the following:\nkali >service apache2 start\nTo stop the Apache web server, enter:\nkali >service apache2 stop\nUsually, when you make a configuration change to an application or\nservice by altering its plaintext configuration file, you need to restart the\nservice to capture the new configuration. Thus, you would enter the\nfollowing:\nkali >service apache2 restart\nNow that you understand how to start, stop, and restart services from the\ncommand line, let’s move on to the four most critical Linux services to\nhackers.\nCreating an HTTP Web Server with the Apache Web\nServer\nThe Apache Web Server is probably the most commonly used service on\nLinux systems. Apache is found on over 60 percent of the world’s web\nservers, so any self-respecting Linux admin should be familiar with it. As a\nhacker aspiring to hack websites, it’s critical to understand the inner\nworkings of Apache, websites, and the backend databases of these sites. You\ncan also use Apache to set up your own web server, from which you could\nserve up malware via cross-site scripting (XSS) to anyone who visits your\nsite, or you could clone a website and redirect traffic to your site via abuse of\nthe Domain Name System (DNS). In either of these cases, a basic\nknowledge of Apache is required.\nStarting with Apache\nIf you have Kali running on your system, Apache is already installed. Many\nother Linux distros have it installed by default as well. If you don’t have\nApache installed, you can download and install it from the repositories by\nentering the following:\nkali >apt-get install apache2\nThe Apache Web Server is often associated with the MySQL database\n(which we will look at in the next section) and these two services are very\noften paired with a scripting language such as Perl or PHP to develop web\napplications. This combination of Linux, Apache, MySQL, and PHP or Perl\nforms a powerful and robust platform for the development and deployment\nof web-based applications, known collectively as LAMP. These are the most\nwidely used tools for developing websites in the Linux world—and they’re\nvery popular in the Microsoft world too, where they’re generally referred to\nas WAMP, with the W standing for Windows.\nThe first step, of course, is to start our Apache daemon. In Kali, go to\nApplications ▸ Services ▸ HTTPD and click Apache start. You can\naccomplish the same from the command line by entering the following:\nkali >services apache2 start\nNow that Apache is running, it should be able to serve up its default web\npage. Enter http://localhost/ in your favorite web browser to bring up the web\npage, which should look something like Figure 12-1.\nFigure 12-1: The Apache2 Web Server default page\nAs you can see, Apache displays “It works” as its default web page. Now\nthat you know your Apache Web Server is working, let’s customize it!\nEditing the index.html File\nApache’s default web page is at /var/www/html/index.html. You can edit the\nindex.html file to serve up whatever information you want, so let’s create our\nown. For this, you can use any text editor you please; I’ll be using Leafpad.\nOpen up /var/www/html/index.html and you should see something like\nListing 12-1.\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n\"http://www.w3.org/TR/xhtm11/DTD/xhtm11-transiti\n<html xmlns=\"http://www.w3.org/1999/xhtml>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" I>\n➊ <title>Apache2 Debian Default Page: It works</title>\n<style type=\"text/css\" media=\"screen\">\n* {\nmargin: Opx Opx Opx Opx;\npadding: Opx Opx Opx Opx;\n}\nbody, html {\npadding: 3px 3px 3px 3px;\nbackground-color: #D8DBE2;\nfont-family: Verdana, sans-serif;\nfont-size: 11pt;\ntext-align: center;\n}\ndiv.main_page {\nposition: relative;\ndisplay: table;\nListing 12-1: The Apache Web Server index.html file\nNote here that the default web page has exactly the text that was\ndisplayed when we opened our browser to localhost, but in HTML format\n➊. All we need to do is edit or replace this file to have our web server display\nthe information we want.\nAdding Some HTML\nNow that we have the web server up and running and the index.html file\nopen, we can add whatever text we’d like the web server to serve up. We will\ncreate some simple HTML blocks.\nLet’s create this page. In a new file in your text editor, enter the code\nshown in Listing 12-2.\n<html>"
  },
  {
    "input": "OpenSSH and the Raspberry Spy Pi",
    "output": "<body>\n<h1>Hackers-Arise Is the Best! </h1>\n<p> If you want to learn hacking, Hackers-Arise.com </p>\n<p> is the best place to learn hacking!</p>\n</body>\n</html>\nListing 12-2: Some simple HTML to add to the index.html file\nOnce you have entered the text exactly as it appears in Listing 12-2, save\nthis file as /var/www/html/index.html and close your text editor. Your text\neditor will then prompt you that the file already exists. That’s okay. Just\noverwrite the existing /var/www/html/index.html file.\nSeeing What Happens\nHaving saved our /var/www/html/index.html file, we can check to see what\nApache will serve up. Navigate your browser once again to http://localhost,\nand you should see something like Figure 12-2.\nFigure 12-2: New Hackers-Arise website\nApache has served up our web page just as we created it!\nOpenSSH and the Raspberry Spy Pi\nSSH is an acronym for Secure Shell and is basically what enables us to\nconnect securely to a terminal on a remote system—a replacement for the\ninsecure telnet that was so common years ago. When we’re building a web\nserver, SSH enables us to create an access list (a list of users who can use this\nservice), authenticate users with encrypted passwords, and encrypt all\ncommunication. This reduces the chance of unwanted users using the\nremote terminal (due to the added authentication process) or intercepting\nour communication (due to encryption). Probably the most widely used\nLinux SSH service is OpenSSH, which is installed on nearly every Linux\ndistribution, including Kali.\nSystem administrators often use SSH to manage remote systems, and\nhackers often use SSH to connect to compromised remote systems, so we’ll\ndo the same here. In this example, we use SSH to set up a remote Raspberry\nPi system for spying, something I call the “Raspberry Spy Pi.” For this,\nyou’ll need a Raspberry Pi and the attendant Raspberry Pi camera module.\nBefore we do that, though, start OpenSSH on your Kali system with the\nnow familiar command:\nkali >service ssh start\nWe’ll be using SSH to build and control a remote spying Raspberry Pi. If\nyou’re not already familiar with it, the Raspberry Pi is a tiny but powerful,\ncredit card–sized computer that works great as a remote spying tool. We will\nemploy a Raspberry Pi with a camera module to use as a remote spying\ndevice. You can purchase a Raspberry Pi at nearly any electronics retailer,\nincluding Amazon, for less than $50, and you can get the camera module for\nabout $15.\nHere, we’ll use the Raspberry Spy Pi on the same network as our Kali\nsystem, which allows us to use private, internal IP addresses. Of course,\nwhen hacking in the real world, you’d probably want to set it up on another\nremote network, but that would be a touch more difficult and beyond the\nscope of this book.\nSetting Up the Raspberry Pi\nMake certain that your Raspberry Pi is running the Raspbian operating\nsystem; this is simply another Linux distribution specifically ported for the\nRaspberry Pi CPU. You can find download and installation instructions for\nRaspbian at https://www.raspberrypi.org/downloads/raspbian/. Nearly\neverything you’ve learned in this book applies to the Raspbian OS on the\nRaspberry Pi as well as Kali, Ubuntu, and other Linux distributions.\nOnce you have your Raspbian OS downloaded and installed, you’ll need\nto connect your Raspberry Pi to a monitor, mouse, and keyboard and then\nconnect it to the internet. If this is all new to you, check out the instructions\nat https://www.raspberrypi.org/learning/hardware-guide/. With everything set\nup, log in with the username pi and the password raspberry.\nBuilding the Raspberry Spy Pi\nThe first step is to make certain that SSH is running and enabled on the\nRaspberry Spy Pi. SSH is usually off by default, so to enable it, go to the\nPreferences menu and launch Raspberry Pi Configuration. Then go to the\nInterfaces tab and, next to SSH, click Enabled (if it is not already checked)\nand click OK.\nWhen SSH is enabled, you can start it on your Raspberry Spy Pi by\nopening a terminal and entering the following:\nkali >service ssh start\nNext you need to attach your camera module. If you’re using a Raspberry\nPi version 3 board, there’s only one place to connect it. Switch the Pi off,\nattach the module to the camera port, and then switch it on again. Note that\nthe camera is very fragile and must never come into contact with the\ngeneral-purpose input/output (GPIO) pins; otherwise, it might short and\ndie.\nNow, with the SSH service up and running, place the Raspberry Spy Pi\nsomewhere within your home, school, or some other location you want to\nspy on. It must, of course, be connected to the local area network, either by\nEthernet cable or, ideally, via Wi-Fi. (The new Raspberry Pi 3 and\nRaspberry Pi Zero both have built-in Wi-Fi.)\nNow, you need to obtain the IP address of your Raspberry Pi. As you\nlearned in Chapter 3, you can get a Linux device’s IP address by using\nifconfig:\npi >ifconfig\nThe IP address of my Pi is 192.168.1.101, but make certain you are using\nthe IP address of your Raspberry Spy Pi wherever my address appears in this\nchapter. Now, from your Kali system, you should be able to connect directly\nto and control your Raspberry Spy Pi and use it as a remote spying system.\nIn this simple example, your system will need to be on the same network as\nthe Pi.\nTo connect to the remote Raspberry Spy Pi via SSH from your Kali\nsystem, enter the following, remembering to use your own Pi’s IP address:\nkali >ssh pi@192.168.1.101\npi@192.168.1.101's password:\nThe programs included with the Debian GNU/Linux system are free software;\nthe exact distribution terms for each program are described in the\nindividual files in /usr/share/doc/*/copyright.\nDebian GNU/Linux comes with ABSOLUTELY NO WARRANTY, the extent\npermitted by applicable law\nlast login: Tues Jan. 1 12:01:01 2018\npi@raspberyypi:: $\nThe Spy Pi will then prompt you for a password. In this case, the default\npassword is raspberry, unless you’ve changed it.\nConfiguring the Camera\nNext, we need to configure the camera. To do so, start the Raspberry Pi\nconfiguration tool by entering the following command:\npi >sudo raspi-config\nThis should start a graphical menu like the one shown in Figure 12-3.\nFigure 12-3: The Raspberry Pi configuration tool\nScroll down to 6 Enable Camera and press ENTER. Now, scroll to the\nbottom of this menu and select Finish and press ENTER, as shown in Figure\n12-4.\nFigure 12-4: Finishing the configuration\nWhen the configuration tool asks if you want to reboot, as shown in\nFigure 12-5, select Yes and press ENTER again.\nFigure 12-5: Reboot the Pi to enable the changes.\nNow your Raspberry Spy Pi camera should be enabled and ready for\nspying!\nStarting to Spy\nOnce your Raspberry Spy Pi has rebooted and you have logged in to it via\nSSH from your Kali terminal, you are ready to start using it to spy by taking\nstill pictures.\nThe Raspbian operating system has an application named raspistill that\nwe will be using to take pictures from our little Raspberry Spy Pi. Enter\nraspistill into the terminal to see the tool’s help screen and all of its\noptions:\npi@raspberrypi: raspistill\nraspistill Camera App v1.3.8\nRuns camera for specific time, and takes JPG capture at end if requested\nusage: raspistill [options]\nImage parameter commands\n--snip--\nLet’s now use the Raspberry Spy Pi to take some remote spying pictures!\nThe raspistill command has numerous options you should explore, but here\nwe’ll simply use the defaults. To take a picture and save it as a JPEG, enter\nthe following:"
  },
  {
    "input": "Extracting Information from MySQL",
    "output": "pi@raspberrypi: raspistill -v -o firstpicture.jpg\nraspistill Camera App v1.3.8\nwidth 2592, Height 1944, quality 85, filename firstpicture.jpg\nTime delay 5000, Raw no\n--snip--\nWe use the –v option to give us verbose output and the –o option to tell\nraspistill we’re about to give it a filename to use; then we give the filename.\nWhen we do a long listing on the Raspberry Spy Pi, we can see the file\nfirstpicture.jpg, as shown here:\npi@raspberrypi: ls -l\ntotal 2452\ndrwxr-xr-x 2 pi pi 4096 Mar 18 2019 Desktop\ndrwxr-xr-x 2 pi pi 4096 Mar 18 2019 Documents\ndrwxr-xr-x 2 pi pi 4096 Mar 18 2019 Downloads\n-rw-r--r-- 1 pi pi 2472219 Mar 18 2019 firstpicture.jpg\ndrwxr-xr-x 2 pi pi 4096 Mar 18 2019 Music\ndrwxr-xr-x 2 pi pi 4096 Mar 18 2019 Pictures\n--snip--\nWe've taken our very first spy picture on our remote Raspberry Spy Pi\nusing SSH! Feel free to explore this versatile weapon further.\nExtracting Information from MySQL\nMySQL is the most widely used database behind database-driven web\napplications. In our modern era of Web 2.0 technologies, where nearly every\nwebsite is database driven, this means MySQL holds the data for most of the\nweb.\nDatabases are the “golden fleece” for hackers. They contain critical\ninformation about users as well as confidential information such as credit\ncard numbers. For this reason, hackers are most often targeting databases.\nLike Linux, MySQL is open source and general public licensed (GPL),\nand you’ll find it preinstalled on nearly every Linux distribution.\nBeing free, open source, and powerful, MySQL has become the database\nof choice for many web applications, including popular websites such as\nWordPress, Facebook, LinkedIn, Twitter, Kayak, Walmart.com, Wikipedia,\nand YouTube.\nOther popular content management systems (CMSs) such as Joomla,\nDrupal, and Ruby on Rails all use MySQL, too. You get the idea. If you\nwant to develop or attack the backend databases of web applications, you\nshould know MySQL. Let’s get started.\nStarting MySQL\nFortunately, Kali has MySQL already installed (if you’re using another\ndistribution, you can download and install MySQL from the software\nrepository or directly from https://www.mysql.com/downloads/).\nTo start your MySQL service, enter the following into the terminal:\nkali >service mysql start\nNext, you need to authenticate yourself by logging in. Enter the\nfollowing and, when prompted for a password, just press ENTER:\nkali >mysql -u root -p\nEnter password:\nWelcome to MySQL monitor. Commands end with ; or \\g.\nYour MySQL connection id is 4\nServer version: 5.6.30-1 (Debian)\nCopyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement\nmysql >\nIn the default configuration of MySQL, the root user’s password is\nempty. Obviously, this is a major security vulnerability, and you should\nremedy this by adding a password after your first login. Note that usernames\nand passwords for your operating system and MySQL are separate and\ndistinct. Let’s change the password for the MySQL root user now in order\nto be safe.\nPAST AND FUTURE OF MYSQL\nMySQL was first developed by MySQL AB of Sweden in 1995 and then was purchased by Sun\nMicrosystems in 2008, which in turn was purchased by Oracle in 2009—so MySQL is now\nowned by Oracle. Oracle is the world’s largest database software publisher, so the open source\ncommunity has significant trepidations about Oracle’s commitment to keeping MySQL open\nsource. As a result, there is now a fork of the MySQL database software called “Maria” that is\ncommitted to keeping this software and its subsequent versions open source. As a Linux admin\nor hacker, you should keep an eye on Maria.\nInteracting with MySQL\nSQL is an interpreted programming language for interfacing with a\ndatabase. The database is often a relational database, meaning data is stored\nin multiple tables that interact and each table has values in one or more\ncolumns and rows.\nThere are several implementations of SQL, each with its own commands\nand syntax, but here are a few common commands:\nselect Used to retrieve data\nunion Used to combine the results of two or more select operations\ninsert Used to add new data\nupdate Used to modify existing data\ndelete Used to delete data\nYou can supply conditions to each command in order to be more specific\nabout what you want to do. For example, the line\nselect user, password from customers where user='admin';\nwill return the values for the user and password fields for any user whose\nuser value is equal to “admin” in the customers table.\nSetting a MySQL Password\nLet’s see what users are already in our MySQL system by entering the\nfollowing. (Note that commands in MySQL are terminated with a\nsemicolon.)\nmysql >select user, host, password from mysql.user;\n+----------------------------------------------------------------------------\n| user | host | password\n+----------------------------------------------------------------------------\n|root |localhost |\n|root |aphrodite.kali.org |\n|root |127.0.0.1 |\n--snip--\nThis shows that the root users have no password set. Let’s assign a\npassword to root. To do so we’ll first select a database to work with. MySQL\non your system will come with some databases already set up. Use the show\ndatabases; command to see all the available databases:\nmysql >show databases;\n+-------------------------------+\n| Database |\n+-------------------------------+\n| information_schema |\n| mysql |\n| performance_schema |\n+-------------------------------+\n3 rows in set (0.23 sec)\nMySQL comes with three databases by default, two of which\n(information_schema and performance_schema) are administrative databases that we\nwon’t use here. We’ll use the non-administrative database, mysql, which is\nincluded for your own purposes. To begin using the mysql database, enter:\nmysql >use mysql;\nReading table information for completion of table and column names\nYou can turn off this feature to get a quicker startup with -A\nDatabase changed\nThis command connects us to mysql. Now, we can set the password for the\nroot user to hackers-arise with the following command:\nmysql >update user set password = PASSWORD(\"hackers-arise\") where user = 'root';\nThis command will update the user by setting the user’s root password to\nhackers-arise.\nAccessing a Remote Database\nTo access a MySQL database on the localhost, we use the following syntax:\nkali >mysql -u <username> -p\nThis command defaults to using the MySQL instance on the localhost if\nit isn’t given a hostname or IP address. To access a remote database, then,\nwe need to provide the hostname or IP address of the system that is hosting\nthe MySQL database. Here’s an example:\nkali >mysql -u root -p 192.168.1.101\nThis will connect us to the MySQL instance at 192.168.1.101 and\nprompt us for a password. For demonstration purposes, I am connecting to a\nMySQL instance on my local area network (LAN). If you have a system on\nyour network with MySQL installed, use its IP address here. I will assume\nyou’ve managed to bypass the password and have logged in to system as root\n(you already know that by default, the mysql database has no password).\nThis opens up the MySQL command line interface, which provides us\nwith the mysql > prompt. As well as this command line interface, MySQL has\nGUI interfaces—both native (MySQL Workbench) and third party (Navicat\nand TOAD for MySQL). For you as a hacker, the command line interface\nmay be the best opportunity for exploiting the MySQL database, so we’ll\nfocus on that here. It’s unlikely that as an unauthorized entrant to the\ndatabase, you will be presented with an easy-to-use GUI.\nNOTE\nThis screen reminds us that all commands must end in a semicolon or \\g (unlike\nMicrosoft’s SQL Server) and that we can get help by entering help; or \\h.\nNow that we’re logged in as the system admin, we can navigate\nunimpeded through the database. If we had logged in as a regular user, our\nnavigation would be limited by the permissions provided by the system\nadministrator for that user.\nConnecting to a Database\nWith access to the system, we want to snoop around. Our next step is to find\nout whether there are any databases worth accessing. Here is the command\nto find which databases are on the accessed system:\nmysql >show databases;\n+-------------------------------+\n| Database |\n+-------------------------------+\n| information schema |\n| mysql |\n| creditcardnumbers |\n| performance_schema |\n+-------------------------------+\n4 rows in set (0.26 sec)\nAha! We’ve found a database worth exploring named creditcardnumbers.\nLet’s connect to it.\nIn MySQL, as in other database management systems (DBMS), we can\nconnect to the database we are interested in by entering use databasename ;.\nmysql >use creditcardnumbers;\nDatabase changed\nThe Database changed response indicates that we are now connected to the\ncreditcardnumbers database.\nOf course, it should go without saying that it’s unlikely a database admin\nwould be so accommodating as to name a database something as easily\nrecognizable as creditcardnumbers, so you may need to do a bit of exploring to\nfind a database of interest.\nDatabase Tables\nWe are now connected to the creditcardnumbers database and can do a bit of\nexploring to see what information it might hold. Data in a database is\norganized into tables, and each table might hold a different set of related\ndata. We can find out what tables are in this database by entering the\nfollowing command:\nmysql >show tables;\n+-----------------------------------+\n| Tables_in_creditcardnumbers |\n+-----------------------------------+\n| cardnumbers |\n+-----------------------------------+\n1 row in set (0.14 sec)\nHere, we can see that this database has just one table in it, called\ncardnumbers. Generally, databases will have numerous tables in them, so it’s\nlikely you’ll have to do a bit more snooping. In this sample database, we are\nfortunate to be able to focus our attention on this single table to extract the\nhacker’s golden fleece!\nNow that we have a table we want to examine, we need to understand the\nstructure of that table. Once we know how the table is laid out, we can\nextract the relevant information.\nYou can see the structure of the table using the describe statement, like so:\nmysql >describe cardnumbers;\n+---------------+--------------+---------+-----------+---------+---------+\n| Field | Type | Null | Key | Default | Extra |\n+---------------+--------------+---------+-----------+---------+---------+\n| customers | varchar(15) | YES | | NULL | |\n| address | varchar(15) | YES | | NULL | |\n| city | varchar(15) | YES | | NULL | |\n| state | varchar(15) | YES | | NULL | |\n| cc | int(12) | NO | | 0 | |\n+---------------+--------------+---------+-----------+---------+---------+\nMySQL responds with the critical information on the structure of our\ntable of interest. We can see the name of each field as well as the data type it\nholds (often the text type varchar or integer type int). We can also see\nwhether it will accept NULL values; the key, if any exists (the key links tables);\nany default values a field might have; and any extra information at the end,\nsuch as notes.\nExamining the Data\nTo actually see the data in the table, we use the SELECT command. The SELECT\ncommand requires you to know the following information:\nThe table that holds the data you want to view\nThe columns within that table that hold the data you want to view\nWe lay this out in the following format:\nSELECT columns FROM table\nAs a handy shortcut to look at data from all the columns, we can use an\nasterisk as a wildcard instead of typing out every column name we want to\nlook at. So, to see a dump of all the data from the cardnumbers table, we enter\nthe following:\nmysql >SELECT * FROM cardnumbers;\n+-----------+---------------+-------------+---------+--------------+\n| customers | address | city | state | cc |\n+-----------+---------------+-------------+---------+--------------+\n| Jones | 1 Wall St | NY | NY | 12345678 |\n| Sawyer | 12 Piccadilly | London | UK | 234567890 |\n| Doe | 25 Front St | Los Angeles | CA | 4567898877 |\n+-----------+---------------+-------------+---------+--------------+\nAs you can see, MySQL has displayed all the information from the\ncardnumbers table to our screen. We have found the hacker’s golden fleece!\nPostgreSQL with Metasploit\nPostgreSQL, or just Postgres, is another open source relational database\noften used in very large, internet-facing applications due to its ability to scale\neasily and handle heavy workloads. It was first released in July 1996 and is\nmaintained by a substantial group of developers known as the PostgreSQL\nGlobal Development Group.\nPostgreSQL is also installed by default in Kali, but if you are using\nanother Linux distribution, it will likely be in your repository and you can\ninstall it by entering the following command:\nkali >apt-get postgres install\nAs a hacker, you will find PostgreSQL particularly important because it is\nthe default database of the most widely used penetration testing and hacking\nframework, Metasploit. Metasploit uses PostgreSQL to store its modules, as\nwell as the results of scans and exploits, for ease of use in a penetration test\nor hack. For that reason, we will be using PostgreSQL here in the context of\nMetasploit.\nAs with nearly all the services in Linux, we can start PostgreSQL by\nentering service application start, like so:\nkali >service postgresql start\nWith PostgreSQL up and running, let’s start Metasploit:\nkali >msfconsole\nNote that when Metasploit has completed starting up, you will see an msf\n> prompt.\nTeaching you how to use Metasploit for hacking and exploitation\npurposes is beyond the scope of this book, but here we’ll set up the database\nthat Metasploit will store its information in.\nWith Metasploit running, we can set up PostgreSQL with the following\ncommand so that it stores data from any Metasploit activity on your system:\nmsf >msfdb init\n[*] exec :msfdb init\nCreating database use 'msf'\nEnter password for new role\nEnter it again:\nCreating databases 'msf' and 'msf_test'\nCreating configuration file /usr/share/metasploit-framework/config/database.yml\nCreating initial database schema\nNext, we need to log in to Postgres as root. Here, we precede the\ncommand with su, the “switch user” command, to obtain root privileges:\nmsf >su postgres\n[*] su postgres\npostgres@kali:/root$\nWhen you log in to Postgres, you will see that the prompt has changed to\npostgres@kali:/root$, representing the application, the hostname, and the user.\nIn the next step, we need to create a user and password, like so:\npostgres@kali:/root$ createuser msf_user -P\nEnter Password for new role:\nEnter it again:\nWe create the username msf_user using the –P option with the createuser\ncommand. Then enter your desired password twice. Next, you need to\ncreate the database and grant permissions for msf_user. Name the database\nhackers_arise_db, as shown here:\npostgres@kali:/root$ createdb --owner=msf_user hackers_arise_db\npostgres@kali:/root$ exit\nWhen you exit from Postgres with the exit command, the terminal will\nfall back into the msf > prompt.\nNext, we have to connect our Metasploit console, msfconsole, to our\nPostgreSQL database by defining the following:\nThe user\nThe password\nThe host\nThe database name"
  },
  {
    "input": "Exercises",
    "output": "In our case, we can connect msfconsole to our database with the\nfollowing command:\nmsf >db_connect msf_user:password@127.0.0.1/hackers_arise_db\nYou will, of course, need to provide the password you used earlier. The\nIP address is that of your local system (localhost), so you can use 127.0.0.1\nunless you built this database on a remote system.\nLastly, we can check the status of the PostgreSQL database to make sure\nit’s connected:\nmsf >db_status\n[*] postgresql connected to msf\nAs you can see, Metasploit responds that the PostgreSQL database is\nconnected and ready to use. Now when we do a system scan or run exploits\nwith Metasploit, the results will be stored in our PostgreSQL database. In\naddition, Metasploit now stores its modules in our Postgres database,\nmaking searches for the right module much easier and faster!\nSummary\nLinux has numerous services that run in the background until the user needs\nthem. The Apache Web Server is the most widely used, but a hacker should\nbe familiar with MySQL, SSH, and PostgreSQL for various tasks, too. In\nthis chapter, we covered the absolute basics of getting started with these\nservices. Once you’re comfortable with your Linux system, I urge you to go\nout and explore each of these services further.\nEXERCISES\nBefore you move on to Chapter 13, try out the skills you learned from this chapter by\ncompleting the following exercises:\n1. Start your apache2 service through the command line.\n2. Using the index.html file, create a simple website announcing your arrival into the\nexciting world of hacking.\n3. Start your SSH service via the command line. Now connect to your Kali system from\nanother system on your LAN.\n4. Start your MySQL database service and change the root user password to hackers-arise.\nChange to the mysql database.\n5. Start your PostgreSQL database service. Set it up as described in this chapter to be used\nby Metasploit."
  },
  {
    "input": "How the Internet Gives Us Away",
    "output": "13\nBECOMING SECURE AND ANONYMOUS\nToday, nearly everything we do on the internet is tracked. Whoever is doing\nthe tracking—whether it be Google tracking our online searches, website\nvisits, and email or the National Security Agency (NSA) cataloging all our\nactivities—our every online move is being recorded, indexed, and then\nmined for someone’s benefit. The average individual—and the hacker, in\nparticular—needs to understand how to limit this tracking and remain\nrelatively anonymous on the web to limit this ubiquitous surveillance.\nIn this chapter, we look at how you can navigate the World Wide Web\nanonymously (or as close as you can get) using four methods:\nThe Onion Network\nProxy servers\nVirtual private networks\nPrivate encrypted email\nNo one method is sure to keep your activities safe from prying eyes, and\ngiven enough time and resources, anything can be tracked. However, these\nmethods will likely make the tracker’s job much more difficult.\nHow the Internet Gives Us Away\nTo begin, let’s discuss at a high level some of the ways our activities on the\ninternet are tracked. We won’t go into all tracking methods, or into too\nmuch detail about any one method, as that would be beyond the scope of\nthis book. Indeed, such a discussion could take up an entire book on its own.\nFirst, your IP address identifies you as you traverse the internet. Data\nsent from your machine is generally tagged with your IP address, making\nyour activities easy to track. Second, Google and other email services will\n“read” your email, looking for keywords to more efficiently serve you ads.\nAlthough there are many more sophisticated methods that are far more time\nand resource intensive, these are the ones we try to prevent in this chapter.\nLet’s start by taking a look at how IP addresses give us away on the internet.\nWhen you send a packet of data across the internet, it contains the IP\naddresses of the source and destination for the data. In this way, the packet\nknows where it is going and where to return the response. Each packet hops\nthrough multiple internet routers until it finds its destination and then hops\nback to the sender. For general internet surfing, each hop is a router the\npacket passes through to get to its destination. There can be as many as 20–\n30 hops between the sender and the destination, but usually any packet will\nfind its way to the destination in fewer than 15 hops.\nAs the packet traverses the internet, anyone intercepting the packet can\nsee who sent it, where it has been, and where it’s going. This is one way\nwebsites can tell who you are when arrive and log you in automatically, and\nit’s also how someone can track where you’ve been on the internet.\nTo see what hops a packet might make between you and the destination,\nyou can use the traceroute command, as shown next. Simply enter traceroute\nand the destination IP address or domain, and the command will send out\npackets to the destination and trace the route of those packets.\nkali >traceroute google.com\ntraceroute to google.com (172.217.1.78), 30 hops max, 60 bytes packets\n1 192.168.1.1 (192.168.1.1) 4.152 ms 3.834 ms 32.964 ms\n2 10.0.0.1 (10.0.0.1) 5.797 ms 6.995 ms 7.679 ms\n3 96.120.96.45 (96.120.96.45) 27.952 ms 30.377 ms 32.964 ms\n--snip--\n18 lgal15s44-in-f14.le100.net (172.217.1.78) 94.666 ms 42.990 ms 41.564 ms\nAs you can see, www.google.com is 18 hops across the internet from me.\nYour results will likely be different because your request would be coming\nfrom a different location and because Google has many servers across the\nglobe. In addition, packets don’t always take the same route across the"
  },
  {
    "input": "The Onion Router System",
    "output": "internet, so you might send another packet from your address to the same\nsite and receive a different route. Let’s see how we can disguise all this with\nthe Tor network.\nThe Onion Router System\nIn the 1990s, the US Office of Naval Research (ONR) set out to develop a\nmethod for anonymously navigating the internet for espionage purposes.\nThe plan was to set up a network of routers that was separate from the\ninternet’s routers, that could encrypt the traffic, and that only stored the\nunencrypted IP address of the previous router—meaning all other router\naddresses along the way were encrypted. The idea was that anyone watching\nthe traffic could not determine the origin or destination of the data. This\nresearch became known as “The Onion Router (Tor) Project” in 2002, and\nit’s now available to anyone to use for relatively safe and anonymous\nnavigation on the web.\nHow Tor Works\nPackets sent over Tor are not sent over the regular routers so closely\nmonitored by so many but rather are sent over a network of over 7,000\nrouters around the world, thanks to volunteers who allow their computers to\nbe used by Tor. On top of using a totally separate router network, Tor\nencrypts the data, destination, and sender IP address of each packet. At each\nhop, the information is encrypted and then decrypted by the next hop when\nit’s received. In this way, each packet contains information about only the\nprevious hop along the path and not the IP address of the origin. If someone\nintercepts the traffic, they can see only the IP address of the previous hop,\nand the website owner can see only the IP address of the last router that sent\nthe traffic (see Figure 13-1). This ensures relative anonymity across the\ninternet.\nFigure 13-1: How Tor uses encrypted traffic data\nTo enable the use of Tor, just install the Tor browser from\nhttps://www.torproject.org/. Once installed, it will look something like Figure\n13-2, and you can use it like any old internet browser. By using this browser,\nyou’ll be navigating the internet through a separate set of routers and will be\nable to visit sites without being tracked by Big Brother. Unfortunately, the\ntradeoff is that surfing via the Tor browser can be a lot slower; because there\nare not nearly as many routers, the bandwidth is limited in this network.\nFigure 13-2: The landing page for the Tor browser\nIn addition to being capable of accessing nearly any website on the\ntraditional internet, the Tor browser is capable of accessing the dark web.\nThe websites that make up the dark web require anonymity, so they allow\naccess only through the Tor browser, and they have addresses ending in\n.onion for their top-level domain (TLD). The dark web is infamous for illegal\nactivity, but a number of legitimate services are also available there. A word\nof caution, however: when accessing the dark web, you may come across\nmaterial that many will find offensive.\nSecurity Concerns\nThe intelligence and spy services of the United States and other nations\nconsider the Tor network a threat to national security, believing such an\nanonymous network enables foreign governments and terrorists to\ncommunicate without being watched. As a result, a number of robust,\nambitious research projects are working to break the anonymity of Tor.\nTor’s anonymity has been broken before by these authorities and will\nlikely be broken again. The NSA, as one instance, runs its own Tor routers,"
  },
  {
    "input": "Proxy Servers",
    "output": "meaning that your traffic may be traversing the NSA’s routers when you use\nTor. If your traffic is exiting the NSA’s routers, that’s even worse, because\nthe exit router always knows your destination. The NSA also has a method\nknown as traffic correlation, which involves looking for patterns in incoming\nand outgoing traffic, that has been able to break Tor’s anonymity. Though\nthese attempts to break Tor won’t affect Tor’s effectiveness at obscuring\nyour identity from commercial services, such as Google, they may limit the\nbrowser’s effectiveness in keeping you anonymous from spy agencies.\nProxy Servers\nAnother strategy for achieving anonymity on the internet is to use proxies,\nwhich are intermediate systems that act as middlemen for traffic: the user\nconnects to a proxy, and the traffic is given the IP address of the proxy\nbefore it’s passed on (see Figure 13-3). When the traffic returns from the\ndestination, the proxy sends the traffic back to the source. In this way, traffic\nappears to come from the proxy and not the originating IP address.\nFigure 13-3: Running traffic through a proxy server\nOf course, the proxy will likely log your traffic, but an investigator would\nhave to get a subpoena or search warrant to obtain the logs. To make your\ntraffic even harder to trace, you can use more than one proxy, in a strategy\nknown as a proxy chain, which we’ll look at a little later in this chapter.\nKali Linux has an excellent proxying tool called proxychains that you can\nset up to obscure your traffic. The syntax for the proxychains command is\nstraightforward, as shown here:\nkali >proxychains <the command you want proxied> <arguments>\nThe arguments you provide might include an IP address. For example, if\nyou wanted to use proxychains to scan a site with nmap anonymously, you would\nenter the following:\nkali >proxychains nmap -sT - Pn <IP address>\nThis would send the nmap –sS stealth scan command to the given IP\naddress through a proxy. The tool then builds the chain of proxies itself, so\nyou don’t have to worry about it.\nSetting Proxies in the Config File\nIn this section, we set a proxy for the proxychains command to use. As with\nnearly every application in Linux/Unix, configuration of proxychains is\nmanaged by the config file—specifically /etc/proxychains.conf. Open the config\nfile in your text editor of choice with the following command (replacing\nleafpad with your chosen editor if necessary):\nkali >leafpad /etc/proxychains.conf\nYou should see a file like the one shown in Listing 13-1.\n# proxychains.conf VER 3.1\n# HTTP, SOCKS4, SOCKS5 tunneling proxifier with DNS.\n# The option below identifies how the ProxyList is treated.\n# only one option should be uncommented at time,\n# otherwise the last appearing option will be accepted\n#\n# dynamic_chain\n#\n# Dynamic - Each connection will be done via chained proxies\n# all proxies chained in the order as they appear in the list\n# at least one proxy must be online to play in chain\n# (dead proxies are skipped)\n# otherwise EINTR is returned to the app strict chain\n# Strict - Each connection will be done via chained proxies\n# all proxies chained in the order as they appear in the list\n# all proxies must be online to play in chain\n# otherwise EINTR is returned to the app M\n--snip--\nListing 13-1: The proxychains.conf file\nScroll down this file to line 61, and you should see the ProxyList section, as\nshown in Listing 13-2.\n[ProxyList]\n# add proxy here...\n# meanwhile\n# defaults set to \"tor\"\nsocks4 127.0.0.1 9050\nListing 13-2: The section of the config file for adding proxies\nWe can add proxies by entering the IP addresses and ports of the proxies\nwe want to use in this list. For now, we’ll use some free proxies. You can find\nfree proxies by googling “free proxies” or using the site\nhttp://www.hidemy.name, as shown in Figure 13-4. Note, however, that using\nfree proxies in real-life hacking activity is not a good idea. I’ll cover this in\nmore detail later in the chapter. The example used here is just for\neducational purposes.\nFigure 13-4: Free proxies from http://www.hidemy.name\nFill in the details in the form or just click search; then add one of the\nresulting proxies to your proxychains.conf file using the following format:\nType IPaddress Port\nHere’s an example:\n[ProxyList]\n# add proxy here...\nsocks4 114.134.186.12 22020\n# meanwhile\n# defaults set to \"tor\"\n# socks4 127.0.0.1 9050\nIt’s important to note that proxychains defaults to using Tor if you don’t\nenter any proxies of your own. The last line in Listing 13-2 directs proxychains\nto send traffic first through the host at 127.0.0.1 on port 9050 (the default\nTor configuration). If you’re not adding your own proxies and want to use\nTor, leave this as it is. If you are not using Tor, you’ll need to comment out\nthis line (add a # before it).\nAs much as I like Tor, as mentioned, it is usually very slow. Also, because\nthe NSA has broken Tor, I am much less likely to depend on it for\nanonymity. I therefore comment out this line and add my own set of proxies.\nLet’s test it out. In this example, I am going to open the browser Firefox\nand have it navigate to https://www.hackers-arise.com/ anonymously by\nsending the traffic through a proxy.\nThe command is as follows:\nkali >proxychains firefox www.hackers-arise.com\nThis successfully opens https://www.hackers-arise.com/ in Firefox through\nmy chosen proxy and returns the results to me. To anyone tracing this\ntraffic, it appears that it was my proxy that navigated to https://www.hackers-\narise.com/ rather than my IP address.\nSome More Interesting Options\nNow that we have proxychains working, let’s look at some other options we\ncan configure through the proxychains.conf file. As we now have it set up, we\nare simply using a single proxy. However, we can put in multiple proxies and\nuse all of them, we can use a limited number from the list, or we can have\nproxychains change the order randomly. Let’s try all these options.\nAdding More Proxies\nFirst, let’s add some more proxies to our list. Go back to\nhttp://www.hidemy.name and find some more proxy IP addresses. Then add a\nfew more of these proxies to your proxychains.conf file, like so:\n[ProxyList]\n# add proxy here...\nsocks4 114.134.186.12 22020\nsocks4 188.187.190.59 8888\nsocks4 181.113.121.158 335551\nNow save this config file and try running the following command:\nkali >proxychains firefox www.hackers-arise.com\nYou won’t notice any difference, but your packet is now traveling through\nseveral proxies.\nDynamic Chaining\nWith multiple IPs in our proxychain.conf file, we can set up dynamic chaining,\nwhich runs our traffic through every proxy on our list and, if one of the\nproxies is down or not responding, automatically goes to the next proxy in\nthe list without throwing an error. If we didn’t set this up, a single failing\nproxy would break our request.\nGo back into your proxychains configuration file, find the dynamic_chain line\n(line 10), and uncomment it, as shown next. Also make sure you comment\nout the strict_chain line if it isn’t already.\n# dynamic_chain\n#\n# Dynamic – Each connection will be done via chained proxies\n# all proxies chained in the order as they appear in the list\n# at least one proxy must be online to play in chain\n--snip--\nThis will enable dynamic chaining of our proxies, thus allowing for\ngreater anonymity and trouble-free hacking. Save the config file and feel free\nto try it out.\nRandom Chaining\nOur final proxy trick is the random chaining option, where proxychains will\nrandomly choose a set of IP addresses from our list and use them to create\nour proxy chain. This means that each time we use proxychains, the proxy will\nlook different to the target, making it harder to track our traffic from its\nsource. This option is also considered “dynamic” because if one of the\nproxies is down, it will skip to the next one.\nGo back inside the /etc/proxychains.conf file and comment out the lines\ndynamic_chain and strict_chain by adding a # at the start of each line; then\nuncomment the random_chain line. We can only use one of these three options\nat a time, so make certain you comment out the other options before using\nproxychains.\nNext, find and uncomment the line with chain_len and then give it a\nreasonable number. This line determines how many of the IP addresses in\nyour chain will be used in creating your random proxy chain.\n# dynamic_chain\n#\n# Dynamic – Each connection will be done via chained proxies\n# all proxies chained in the order as they appear in the list\n# at least one proxy must be online to play in chain\n#\n# strict_chain\n#\n# Strict - Each connection will be done via chained proxies\n# all proxies chained in the order as they appear in the list\n# all proxies must be online to play in chain\n# otherwise EINTR is returned to the app\n#\nrandom_chain\n# Random - Each connection will be done via random proxy\n# (or proxy chain, see chain_len) from the list.\n# this option is good to test your IDS :)\n# Makes sense only if random_chain\nchain_len = 3\nHere, I have uncommented chain_len and given it a value of 3, meaning\nproxychains will now use three proxies from my list in the /etc/proxychains.conf\nfile, choosing them randomly and moving onto the next one if a proxy is\ndown. Note that although this method certainly enhances your anonymity, it\nalso increases the latency of your online activities.\nNow that you know how to use proxychains, you can do your hacking with\nrelative anonymity. I say “relative” because there is no surefire way to remain\nanonymous with the NSA and FSB spying on our online activities—but we\ncan make detection much harder with the help of proxychains.\nSecurity Concerns\nAs a last note on proxy security, be sure to choose your proxies wisely:\nproxychains is only as good as the proxies you use. If you are intent on\nremaining anonymous, do not use a free proxy, as mentioned earlier. Hackers\nuse paid-for proxies that can be trusted. In fact, the free proxies are likely\nselling your IP address and browsing history. As Bruce Schneier, the famous\ncryptographer and security expert, once said, “If something is free, you’re\nnot the customer; you’re the product.” In other words, any free product is\nlikely gathering your data and selling it. Why else would they offer a proxy\nfor free?\nAlthough the IP address of your traffic leaving the proxy will be"
  },
  {
    "input": "Virtual Private Networks",
    "output": "anonymous, there are other ways for surveillance agencies to identify you.\nFor instance, the owner of the proxy will know your identity and, if\npressured enough by espionage or law enforcement agencies with\njurisdiction, may offer up your identity to protect their business. It’s\nimportant to be aware of the limitations of proxies as a source of anonymity.\nVirtual Private Networks\nUsing a virtual private network (VPN) can be an effective way to keep your\nweb traffic relatively anonymous and secure. A VPN is used to connect to an\nintermediary internet device such as a router that sends your traffic to its\nultimate destination tagged with the IP address of the router.\nUsing a VPN can certainly enhance your security and privacy, but it’s not\na guarantee of anonymity. The internet device you connect to must record\nor log your IP address to be able to properly send the data back to you, so\nanyone able to access these records can uncover information about you.\nThe beauty of VPNs is that they are simple and easy to work with. You\ncan open an account with a VPN provider and then seamlessly connect to\nthe VPN each time you log on to your computer. You would use your\nbrowser as usual to navigate the web, but it will appear to anyone watching\nthat your traffic is coming from the IP address and location of the internet\nVPN device and not your own. In addition, all traffic between you and the\nVPN device is encrypted, so even your internet service provider can’t see\nyour traffic.\nAmong other things, a VPN can be effective in evading government-\ncontrolled content and information censors. For instance, if your national\ngovernment limits your access to websites with a particular political message,\nyou can likely use a VPN based outside your country in order to access that\ncontent. Some media corporations, such as Netflix, Hulu, and HBO, limit\naccess to their content to IP addresses originating from their own nation.\nUsing a VPN based in a nation that those services allow can often get you\naround those access limitations.\nSome of the best and most popular commercial VPN services, according\nto CNET, are the following:\nIPVanish"
  },
  {
    "input": "Encrypted Email",
    "output": "NordVPN\nExpressVPN\nCyberGhost\nGolden Frog VPN\nHide My Ass (HMA)\nPrivate Internet Access\nPureVPN\nTorGuard\nBuffered VPN\nMost of these VPN services charge $50–$100 per year, and many offer a\nfree 30-day trial. To find out more about how to set up a VPN, choose one\nfrom the list and visit the website. You should find download, installation,\nand usage instructions that are pretty easy to follow.\nThe strength of a VPN is that all your traffic is encrypted when it leaves\nyour computer, thus protecting you against snooping, and your IP address is\ncloaked by the VPN IP address when you visit a site. As with a proxy server,\nthe owner of the VPN has your originating IP address (otherwise they\ncouldn’t send your traffic back to you). If they are pressured by espionage\nagencies or law enforcement, they might give up your identity. One way to\nprevent that is to use only VPNs that promise not to store or log any of this\ninformation (and hope they are being truthful). In this way, if someone\ninsists that the VPN service provider turn over its data on its users, there is\nno data.\nEncrypted Email\nFree commercial email services such as Gmail, Yahoo!, and Outlook Web\nMail (formerly Hotmail) are free for a reason: they are vehicles for tracking\nyour interests and serving up advertisements. As mentioned already, if a\nservice is free, you are the product, not the customer. In addition, the servers\nof the email provider (Google, for example) have access to the unencrypted\ncontents of your email, even if you’re using HTTPS.\nOne way to prevent eavesdropping on your email is to use encrypted\nemail. ProtonMail, shown in Figure 13-5, encrypts your email from end to"
  },
  {
    "input": "Summary",
    "output": "end or browser to browser. This means that your email is encrypted on\nProtonMail servers—even the ProtonMail administrators can’t read your\nemail.\nProtonMail was founded by a group of young scientists at the CERN\nsupercollider facility in Switzerland. The Swiss have a long and storied\nhistory of protecting secrets (remember those Swiss bank accounts you’ve\nheard so much about?), and ProtonMail’s servers are based in the European\nUnion, which has much stricter laws regarding the sharing of personal data\nthan does the United States. ProtonMail does not charge for a basic account\nbut offers premium accounts for a nominal fee. It is important to note that\nwhen exchanging email with non-ProtonMail users, there is the potential for\nsome or all of the email not to be encrypted. See the ProtonMail support\nknowledge base for full details.\nFigure 13-5: The ProtonMail login screen\nSummary\nWe are constantly being surveilled by commercial firms and national\nintelligence agencies. To keep your data and web travels secure, you need to"
  },
  {
    "input": "Exercises",
    "output": "implement at least one of the security measures discussed in this chapter. By\nemploying them in combination, you can minimize your footprint on the\nweb and keep your data much more secure.\nEXERCISES\nBefore you move on to Chapter 14, try out the skills you learned from this chapter by\ncompleting the following exercises:\n1. Run traceroute to your favorite website. How many hops appear between you and your\nfavorite site?\n2. Download and install the Tor browser. Now, browse anonymously around the web just\nas you would with any other browser and see if you notice any difference in speed.\n3. Try using proxychains with the Firefox browser to navigate to your favorite website.\n4. Explore commercial VPN services from some of the vendors listed in this chapter.\nChoose one and test a free trial.\n5. Open a free ProtonMail account and send a secure greeting to\noccupytheweb@protonmail.com."
  },
  {
    "input": "Wi-Fi Networks",
    "output": "14\nUNDERSTANDING AND INSPECTING WIRELESS\nNETWORKS\nThe ability to scan for and connect to other network devices from your\nsystem is crucial to becoming a successful hacker, and with wireless\ntechnologies like Wi-Fi (IEEE 802.1) and Bluetooth becoming the standard,\nfinding and controlling Wi-Fi and Bluetooth connections is key. If someone\ncan hack a wireless connection, they can gain entry to a device and access to\nconfidential information. The first step, of course, is to learn how to find\nthese devices.\nIn Chapter 3, we looked at some basic networking commands in Linux,\nincluding some of the fundamentals of wireless networking, with a promise\nof more wireless networking to come in Chapter 14. As promised, here we\nexamine two of the most common wireless technologies in Linux: Wi-Fi and\nBluetooth.\nWi-Fi Networks\nWe’ll start with Wi-Fi. In this section, I’ll show you how to find, examine,\nand connect to Wi-Fi access points. Before doing so, let’s spend a bit of time\ngoing over some basic Wi-Fi terms and technologies to help you better\nunderstand the output from a lot of the queries we’ll make in this chapter:\nAP (access point) This is the device wireless users connect to for\ninternet access.\nESSID (extended service set identifier) This is the same as the SSID,\nwhich we discussed in Chapter 3, but it can be used for multiple APs in a\nwireless LAN.\nBSSID (basic service set identifier) This is the unique identifier of\neach AP, and it is the same as the MAC address of the device.\nSSID (service set identifier) This is the name of the network.\nChannels Wi-Fi can operate on any one of 14 channels (1–14). In the\nUnited States, Wi-Fi is limited to channels 1–11.\nPower The closer you are to the Wi-Fi AP, the greater the power, and\nthe easier the connection is to crack.\nSecurity This is the security protocol used on the Wi-Fi AP that is being\nread from. There are three primary security protocols for Wi-Fi. The\noriginal, Wired Equivalent Privacy (WEP), was badly flawed and easily\ncracked. Its replacement, Wi-Fi Protected Access (WPA), was a bit more\nsecure. Finally, WPA2-PSK, which is much more secure and uses a\npreshared key (PSK) that all users share, is now used by nearly all Wi-Fi\nAPs (except enterprise Wi-Fi).\nModes Wi-Fi can operate in one of three modes: managed, master, or\nmonitor. You’ll learn what these modes mean in the following section.\nWireless range In the United States, a Wi-Fi AP must legally broadcast\nits signal at an upper limit of 0.5 watts. At this power, it has a normal\nrange of about 300 feet (100 meters). High-gain antennas can extend this\nrange to as much as 20 miles.\nFrequency Wi-Fi is designed to operate on 2.4GHz and 5GHz. Modern\nWi-Fi APs and wireless network cards often use both.\nBasic Wireless Commands\nIn Chapter 3, you were introduced to the basic Linux networking command\nifconfig, which lists each activated network interface on your system along\nwith some basic statistics, including (most importantly) the IP address of\neach interface. Let’s take another look at your results from running ifconfig\nand focus on the wireless connections this time.\nkali >ifconfig\neth0Linkencap:EthernetHWaddr 00:0c:29:ba:82:0f\ninet addr:192:168.181.131 Bcast:192.168.181.255 Mask:255.255.255.0\n--snip--\nlo Linkencap:Local Loopback\ninet addr:127.0.0.1 Mask:255.0.0.0\n--snip--\n➊ wlan0 Link encap:EthernetHWaddr 00:c0:ca:3f:ee:02\nThe Wi-Fi interface here is shown as wlan0 ➊. In Kali Linux, Wi-Fi\ninterfaces are usually designated as wlanX, with X representing the number\nof that interface. In other words, the first Wi-Fi adapter on your system\nwould be labeled wlan0, the second wlan1, and so on.\nIf you just want to see your Wi-Fi interfaces and their statistics, Linux has\na specific command that’s similar to ifconfig but dedicated to wireless. That\ncommand is iwconfig. When you enter it, only your wireless interfaces and\ntheir key data are displayed:\nkali >iwconfig\nlo no wireless extensions\nwlan0 IEEE 802.11bg ESSID:off/any\nMode:Managed Access Point:Not-Associated Tx-Power=20 dBm\nRetry short limit:7 RTS thr:off Fragment thr:off\nEncryption key:off\nPower Management:off\neth0 no wireless extensions\nHere, we see just the wireless interfaces, also known as network cards, and\nkey data about them, including the wireless standard utilized, whether the\nESSID is off, and the mode. The mode has three settings: managed, which\nmeans it is ready to join or has joined an AP; master, which means it is ready\nto act as or already is an AP; and monitor, which we’ll discuss a little later in\nthe chapter. We can also see whether any client has associated with it and\nwhat its transmit power is, among other things. You can tell from this\nexample that wlan0 is in the mode required to connect to a Wi-Fi network\nbut is not connected to any yet. We will revisit this command again once the\nwireless interface is connected to a Wi-Fi network.\nIf you are not certain which Wi-Fi AP you want to connect to, you can\nsee all the wireless access points your network card can reach using the iwlist\ncommand. The syntax for iwlist is as follows:\niwlist interface action\nYou can perform multiple actions with iwlist. For our purposes, we’ll use\nthe scan action to see all the Wi-Fi APs in your area. (Note that with a\nstandard antenna, your range will be 300–500 feet, but this can be extended\nwith an inexpensive high-gain antenna.)\nkali >iwlist wlan0 scan\nwlan0 Scan completed:\nCell 01 - Address:88:AD:43:75:B3:82\nChannel:1\nFrequency:2.412GHz (Channel 1)\nQuality=70/70 Signal level =-38 dBm\nEncryption key:off\nESSID:\"Hackers-Arise\"\n--snip--\nThe output from this command should include all Wi-Fi APs within\nrange of your wireless interface, along with key data about each AP, such as\nthe MAC address of the AP, the channel and frequency it is operating on, its\nquality, its signal level, whether its encryption key is enabled, and its ESSID.\nYou will need the MAC address of the target AP (BSSID), the MAC\naddress of a client (another wireless network card), and the channel the AP is\noperating on in order to perform any kind of hacking, so this is valuable\ninformation.\nAnother command that is very useful in managing your Wi-Fi\nconnections is nmcli (or the network manager command line interface). The\nLinux daemon that provides a high-level interface for the network interfaces\n(including the wireless ones) is known as the network manager. Generally,\nLinux users are familiar with this daemon from its graphical user interface\n(GUI), but it can also be used from the command line.\nThe nmcli command can be used to view the Wi-Fi APs near you and\ntheir key data, as we did with iwlist, but this command gives us a little more\ninformation. We use it in the format nmcli dev networktype, where dev is short\nfor devices and the type (in this case) is wifi, like so:\nkali >nmcli dev wifi\n* SSID MODE CHAN RATE SIGNAL BARS SECURITY\nHackers-Arise Infra 1 54 Mbits/s 100 WPA1 WPA2\nXfinitywifi Infra 1 54 Mbits/s 75 WPA2\nTPTV1 Infra 11 54 Mbits/s 44 WPA1 WPA2\n--snip--\nIn addition to displaying the Wi-Fi APs within range and key data about\nthem, including the SSID, the mode, the channel, the rate of transfer, the\nsignal strength, and the security protocols enabled on the device, nmcli can be\nused connect to APs. The syntax to connect to an AP is as follows:\nnmcli dev wifi connect AP-SSID password APpassword\nSo, based on the results from our first command, we know there is an AP\nwith an SSID of Hackers-Arise. We also know it has WPA1 WPA2 security\n(this means that the AP is capable of using both the older WPA1 and the\nnewer WPA2), which means we will have to provide the password to connect\nto the network. Fortunately, as it’s our AP, we know the password is\n12345678, so we can enter the following:\nkali >nmcli dev wifi connect Hackers-Arise password 12345678\nDevice 'wlan0' successfully activated with '394a5bf4-8af4-36f8-49beda6cb530'.\nTry this on a network you know, and then when you have successfully\nconnected to that wireless AP, run iwconfig again to see what has changed.\nHere’s my output from connecting to Hackers-Arise:\nkali >iwconfig\nlo no wireless extensions\nwlan0 IEEE 802.11bg ESSID:\"Hackers-Arise\"\nMode:Managed Frequency:2.452GHz Access Point:00:25:9C:97:4F:48\nBit Rate=12 Mbs Tx-Power=20 dBm\nRetry short limit:7 RTS thr:off Fragment thr:off\nEncryption key:off\nPower Management:off\nLink Quality=64/70 Signal level=-46 dBm\nRx invalid nwid:0 Rx invalid crypt:0 Rx invalid frag:0\nTx excessive reties:0 Invalid misc:13 Missed beacon:0\neth0 no wireless extensions\nNote that now iwconfig has indicated that the ESSID is \"Hackers-Arise\" and\nthat the AP is operating at a frequency of 2.452GHz. In a Wi-Fi network, it\nis possible for multiple APs to all be part of the same network, so there may\nbe many APs that make up the Hackers-Arise network. The MAC address\n00:25:9C:97:4F:48 is, as you might expect, the MAC of the AP I am\nconnected to. What type of security a Wi-Fi network uses, whether it is\nrunning at 2.4GHz or 5GHz, what its ESSID is, and what the AP’s MAC\naddress is are all critical pieces of information that are necessary for Wi-Fi\nhacking. Now that you know the basic commands, let’s get into some\nhacking.\nWi-Fi Recon with aircrack-ng\nOne of the most popular exploits for new hackers to try is cracking Wi-Fi\naccess points. As mentioned, before you can even consider attacking a Wi-Fi\nAP, you need the MAC address of the target AP (BSSID), the MAC address\nof a client, and the channel the AP is operating on.\nWe can get all that information and more using the tools of the aircrack-\nng suite. I’ve mentioned this suite of Wi-Fi hacking tools a few times before,\nand now it’s time to actually use it. This suite of tools is included in every\nversion of Kali, so you don’t need to download or install anything.\nTo use these tools effectively, you first need to put your wireless network\ncard into monitor mode so that the card can see all the traffic passing its way.\nNormally, a network card captures only traffic destined specifically for that\ncard. Monitor mode is similar to promiscuous mode on wired network cards.\nTo put your wireless network card in monitor mode, use the airmon-ng\ncommand from the aircrack-ng suite. The syntax for this command is\nsimple:\nairmon-ng start|stop|restart interface\nSo, if you want to put your wireless network card (designated wlan0) into\nmonitor mode, you would enter the following:\nkali >airmon-ng start wlan0\nFound three processes that could cause trouble\nIf airodump-ng, aireplay-ng, or airtun-ng stops working after\na short period of time, you may want to run 'airmon-ng check kill'\n--snip--\nPHY INTERFACE DRIVER Chipset\nphy0 wlan0 rt18187 Realtek Semiconductor Corop RTL8187\n(mac8311 monitor mode vif enabled for [phy0]wlan0 on [phy0]wlan0mon)\n--snip--\nThe stop and restart commands, respectively, stop monitor mode and\nrestart monitor mode if you run into trouble.\nWith your wireless card in monitor mode, you can access all the wireless\ntraffic passing by you within the range of your wireless network adapter and\nantenna (standard is about 300–500 feet). Note that airmon-ng will rename\nyour wireless interface: mine has been renamed “wlan0mon,” though yours\nmay be different. Make certain to note the new designated name of your\nwireless because you’ll need that information in the next step.\nNow we’ll use another tool from the aircrack-ng suite to find key data\nfrom the wireless traffic. The airodump-ng command captures and displays the\nkey data from broadcasting APs and any clients connected to those APs or\nwithin the vicinity. The syntax here is straightforward: simply plug in airdump-\nng, followed by the interface name you got from running airmon-ng just now.\nWhen you issue this command, your wireless card will pick up crucial\ninformation (listed next) from all the wireless traffic of the APs nearby:\nBSSID The MAC address of the AP or client\nPWR The strength of the signal\nENC The encryption used to secure the transmission\n#Data The data throughput rate\nCH The channel the AP is operating on\nESSID The name of the AP\nkali >airodump-ng wlan0mon\nCH 9][ Elapsed: 28 s ][ 2018-02-08 10:27\nBSSID PWR Beacons #Data #/s CH MB ENC CIPHER AUTH ESSID\n01:01:AA:BB:CC:22 -1 4 26 0 10 54e WPA2 CCMP PSK Hackers-Arise\n--snip--\nBSSID Station PWR Rate Lost Frames Probe\n(not associated) 01:01:AA:BB:CC:22\n01:02:CC:DD:03:CF A0:A3:E2:44:7C:E5\nNote that airodump-ng splits the output screen into an upper and lower\nportion. The upper portion has information on the broadcasting APs,\nincluding the BSSID, the power of the AP, how many beacon frames have\nbeen detected, the data throughput rate, how many packets have traversed\nthe wireless card, the channel (1–14), the theoretical throughput limit, the\nencryption protocol, the cipher used for encryption, the authentication type,\nand the ESSID (commonly referred to as SSID). In the client portion, the"
  },
  {
    "input": "Detecting and Connecting to Bluetooth",
    "output": "output tells us that one client is not associated, meaning it has been detected\nbut is not connected to any AP, and that another is associated with a station,\nmeaning it’s connected to the AP at that address.\nNow you have all the information you need to crack the AP! Although it’s\nbeyond the scope of this book, to crack the wireless AP, you need the client\nMAC address, the AP MAC address, the channel the target is operating on,\nand a password list.\nSo to crack the Wi-Fi password, you would open three terminals. In the\nfirst terminal, you would enter commands similar to the following, filling in\nthe client and AP MAC addresses and the channel:\nairodump-ng -c 10 --bssid 01:01:AA:BB:CC:22 -w Hackers-ArisePSK wlan0mon\nThis command captures all the packets traversing the AP on channel 10\nusing the -c option.\nIn another terminal, you can use the aireplay-ng command to knock off\n(deauthenticate) anyone connected to the AP and force them to\nreauthenticate to the AP, as shown next. When they reauthenticate, you can\ncapture the hash of their password that is exchanged in the WPA2-PSK\nfour-way handshake. The password hash will appear in the upper-right\ncorner of the airodump-ng terminal.\naireplay-ng --deauth 100 -a 01:01:AA:BB:CC:22-c A0:A3:E2:44:7C:E5 wlan0mon\nFinally, in the final terminal, you can use a password list (wordlist.dic) to\nfind the password in the captured hash (Hackers-ArisePSK.cap), as shown\nhere:\naircrack-ng -w wordlist.dic -b 01:01:AA:BB:CC:22 Hacker-ArisePSK.cap\nDetecting and Connecting to Bluetooth\nThese days, nearly every gadget, mobile device, and system has Bluetooth\nbuilt in, including our computers, smartphones, iPods, tablets, speakers,\ngame controllers, keyboards, and many other devices. Being able to hack\nBluetooth can lead to the compromise of any information on the device,\ncontrol of the device, and the ability to send unwanted info to and from the\ndevice, among other things.\nTo exploit the technology, we need to understand how it works. An in-\ndepth understanding of Bluetooth is beyond the scope of this book, but I will\ngive you some basic knowledge that will help you scan for and connect to\nBluetooth devices in preparation for hacking them.\nHow Bluetooth Works\nBluetooth is a universal protocol for low-power, near-field communication\noperating at 2.4–2.485GHz using spread spectrum, frequency hopping at\n1,600 hops per second (this frequency hopping is a security measure). It was\ndeveloped in 1994 by Ericsson Corp. of Sweden and named after the 10th-\ncentury Danish king Harald Bluetooth (note that Sweden and Denmark\nwere a single country in the 10th century).\nThe Bluetooth specification has a minimum range of 10 meters, but there\nis no limit to the upper range manufacturers may implement in their devices.\nMany devices have ranges as large as 100 meters. With special antennas, that\nrange can be extended even farther.\nConnecting two Bluetooth devices is referred to as pairing. Pretty much\nany two Bluetooth devices can connect to each other, but they can pair only\nif they are in discoverable mode. A Bluetooth device in discoverable mode\ntransmits the following information:\nName\nClass\nList of services\nTechnical information\nWhen the two devices pair, they exchange a secret or link key. Each\nstores this link key so it can identify the other in future pairings.\nEvery device has a unique 48-bit identifier (a MAC-like address) and\nusually a manufacturer-assigned name. These will be useful pieces of data\nwhen we want to identify and access a device.\nBluetooth Scanning and Reconnaissance\nLinux has an implementation of the Bluetooth protocol stack called BlueZ\nthat we’ll use to scan for Bluetooth signals. Most Linux distributions,\nincluding Kali Linux, have it installed by default. If yours doesn’t, you can\nusually find it in your repository using the following command:\nkali >apt-get install bluez\nBlueZ has a number of simple tools we can use to manage and scan\nBluetooth devices, including the following:\nhciconfig This tool operates very similarly to ifconfig in Linux, but for\nBluetooth devices. As you can see in Listing 14-1, I have used it to bring\nup the Bluetooth interface and query the device for its specs.\nhcitool This inquiry tool can provide us with device name, device ID,\ndevice class, and device clock information, which enables the devices to\nwork synchronously.\nhcidump This tool enables us to sniff the Bluetooth communication,\nmeaning we can capture data sent over the Bluetooth signal.\nThe first scanning and reconnaissance step with Bluetooth is to check\nwhether the Bluetooth adapter on the system we’re using is recognized and\nenabled so we can use it to scan for other devices. We can do this with the\nbuilt-in BlueZ tool hciconfig, as shown in Listing 14-1.\nkali >hciconfig\nhci0: Type: BR/EDR Bus: USB\nBD Address: 10:AE:60:58:F1:37 ACL MTU: 310:10 SCO MTU: 64:8\nUP RUNNING PSCAN INQUIRY\nRX bytes:131433 acl:45 sco:0 events:10519 errors:0\nTX bytes:42881 acl:45 sco:0 commands:5081 errors:0\nListing 14-1: Scanning for a Bluetooth device\nAs you can see, my Bluetooth adapter is recognized with a MAC address\nof 10:AE:60:58:F1:37. This adapter has been named hci0. The next step is to\ncheck that the connection is enabled, which we can also do with hciconfig by\nproviding the name and the up command:\nkali >hciconfig hci0 up\nIf the command runs successfully, we should see no output, just a new\nprompt.\nGood, hci0 is up and ready! Let’s put it to work.\nScanning for Bluetooth Devices with hcitool\nNow that we know our adapter is up, we can use another tool in the BlueZ\nsuite called hcitool, which is used to scan for other Bluetooth devices within\nrange.\nLet’s first use the scanning function of this tool to look for Bluetooth\ndevices that are sending out their discover beacons, meaning they’re in\ndiscovery mode, with the simple scan command shown in Listing 14-2.\nkali >hcitool scan\nScanning...\n72:6E:46:65:72:66 ANDROID BT\n22:C5:96:08:5D:32 SCH-I535\nListing 14-2: Scanning for Bluetooth devices in discovery mode\nAs you can see, on my system, hcitool found two devices, ANDROID BT\nand SCH-I535. Yours will likely provide you with different output\ndepending on what devices you have around. For testing purposes, try\nputting your phone or other Bluetooth device in discovery mode and see if it\ngets picked up in the scan.\nNow let’s gather more information about the detected devices with the\ninquiry function inq:\nkali >hcitool inq\nInquiring...\n24:C6:96:08:5D:33 clock offset:0x4e8b class:0x5a020c\n76:6F:46:65:72:67 clock offset:0x21c0 class:0x5a020c\nThis gives us the MAC addresses of the devices, the clock offset, and the\nclass of the devices. The class indicates what type of Bluetooth device you\nfound, and you can look up the code and see what type of device it is by\ngoing to the Bluetooth SIG site at https://www.bluetooth.org/en-\nus/specification/assigned-numbers/service-discovery/.\nThe tool hcitool is a powerful command line interface to the Bluetooth\nstack that can do many, many things. Listing 14-3 shows the help page with\nsome of the commands you can use. Take a look at the help page yourself to\nsee the full list.\nkali >hcitool --help\nhcitool - HCI Tool ver 4.99\nUsage:\nhcitool [options] <command> [command parameters]\nOptions:\n--help Display help\n-i dev HCI device\nCommands\ndev Display local devices\ninq Inquire remote devices\nscan Scan for remote devices\nname Get name from remote devices\n--snip--\nListing 14-3: Some hcitool commands\nMany Bluetooth-hacking tools you’ll see around simply use these\ncommands in a script, and you can easily create your own tool by using these\ncommands in your own bash or Python script—we’ll look at scripting in\nChapter 17.\nScanning for Services with sdptool\nService Discovery Protocol (SDP) is a Bluetooth protocol for searching for\nBluetooth services (Bluetooth is suite of services), and, helpfully, BlueZ\nprovides the sdptool tool for browsing a device for the services it provides. It\nis also important to note that the device does not have to be in discovery\nmode to be scanned. The syntax is as follows:\nsdptool browse MACaddress\nListing 14-4 shows me using sdptool to search for services on one of the\ndevices detected earlier in Listing 14-2.\nkali >sdptool browse 76:6E:46:63:72:66\nBrowsing 76:6E:46:63:72:66...\nService RecHandle: 0x10002\nService Class ID List:\n\"\"(0x1800)\nProtocol Descriptor List:\n\"L2CAP\" (0x0100)\nPSM: 31\n\"ATT\" (0x0007)\nuint16: 0x1\nuint16: 0x5\n--snip--\nListing 14-4: Scanning with sdptool"
  },
  {
    "input": "Summary",
    "output": "Here, we can see that the sdptool tool was able to pull information on all\nthe services this device is capable of using. In particular, we see that this\ndevice supports the ATT Protocol, which is the Low Energy Attribute\nProtocol. This can provide us more clues as to what the device is and possibly\npotential avenues to interact with it further.\nSeeing Whether the Devices Are Reachable with l2ping\nOnce we’ve gathered the MAC addresses of all nearby devices, we can send\nout pings to these devices, whether they’re in discovery mode or not, to see\nwhether they are in reach. This lets us know whether they are active and\nwithin range. To send out a ping, we use the l2ping command with the\nfollowing syntax:\nl2ping MACaddress\nListing 14-5 shows me pinging the Android device discovered in Listing\n14-2.\nkali >l2ping 76:6E:46:63:72:66 -c 4\nPing: 76:6E:46:63:72:66 from 10:AE:60:58:F1:37 (data size 44)...\n44 bytes 76:6E:46:63:72:66 id 0 time 37.57ms\n44 bytes 76:6E:46:63:72:66 id 1 time 27.23ms\n44 bytes 76:6E:46:63:72:66 id 2 time 27.59ms\n--snip--\nListing 14-5: Pinging a Bluetooth device\nThis output indicates that the device with the MAC address\n76:6E:46:63:72:66 is within range and reachable. This is useful knowledge,\nbecause we must know whether a device is reachable before we even\ncontemplate hacking it.\nSummary\nWireless devices represent the future of connectivity and hacking. Linux has\ndeveloped specialized commands for scanning and connecting to Wi-Fi APs\nin the first step toward hacking those systems. The aircrack-ng suite of\nwireless hacking tools includes both airmon-ng and airodump-ng, which enable us\nto scan and gather key information from in-range wireless devices. The"
  },
  {
    "input": "Exercises",
    "output": "BlueZ suite includes hciconfig, hcitool, and other tools capable of scanning\nand information gathering, which are necessary for hacking the Bluetooth\ndevices within range. It also includes many other tools worth exploring.\nEXERCISES\nBefore you move on to Chapter 15, try out the skills you learned from this chapter by\ncompleting the following exercises:\n1. Check your network devices with ifconfig. Note any wireless extensions.\n2. Run iwconfig and note any wireless network adapters.\n3. Check to see what Wi-Fi APs are in range with iwlist.\n4. Check to see what Wi-Fi APs are in range with nmcli. Which do you find more useful\nand intuitive, nmcli or iwlist?\n5. Connect to your Wi-Fi AP using nmcli.\n6. Bring up your Bluetooth adapter with hciconfig and scan for nearby discoverable\nBluetooth devices with hcitool.\n7. Test whether those Bluetooth devices are within reachable distance with l2ping."
  },
  {
    "input": "15 MANAGING THE LINUX KERNEL AND LOADABLE KERNEL MODULES",
    "output": "15\nMANAGING THE LINUX KERNEL AND LOADABLE\nKERNEL MODULES\nAll operating systems are made up of at least two major components. The\nfirst and most important of these is the kernel. The kernel is at the center of\nthe operating system and controls everything the operating system does,\nincluding managing memory, controlling the CPU, and even controlling\nwhat the user sees on the screen. The second element of the operating\nsystem is often referred to as user land and includes nearly everything else.\nThe kernel is designed to be a protected or privileged area that can only\nbe accessed by root or other privileged accounts. This is for good reason, as\naccess to the kernel can provide nearly unfettered access to the operating\nsystem. As a result, most operating systems provide users and services access\nonly to user land, where the user can access nearly anything they need\nwithout taking control of the operating system.\nAccess to the kernel allows the user to change how the operating systems\nworks, looks, and feels. It also allows them to crash the operating system,\nmaking it unworkable. Despite this risk, in some cases, the system admin\nmust very carefully access the kernel for operational and security reasons.\nIn this chapter, we’ll examine how to alter the way the kernel works and\nadd new modules to the kernel. It probably goes without saying that if a\nhacker can alter the target’s kernel, they can control the system.\nFurthermore, an attacker may need to alter how the kernel functions for\nsome attacks, such as a man-in-the middle (MITM) attack, where the hacker"
  },
  {
    "input": "What Is a Kernel Module?",
    "output": "places themselves between a client and server and can eavesdrop on or alter\nthe communication. First, we’ll take a closer look at the kernel structure and\nits modules.\nWhat Is a Kernel Module?\nThe kernel is the central nervous system of your operating system,\ncontrolling everything it does, including managing interactions between\nhardware components and starting the necessary services. The kernel\noperates between the user applications you see and the hardware that runs\neverything, like the CPU, memory, and hard drive.\nLinux is a monolithic kernel that enables the addition of kernel modules.\nAs such, modules can be added and removed from the kernel. The kernel\nwill occasionally need updating, which might entail installing new device\ndrivers (such as video cards, Bluetooth devices, or USB devices), filesystem\ndrivers, and even system extensions. These drivers must be embedded in the\nkernel to be fully functional. In some systems, to add a driver, you have to\nrebuild, compile, and reboot the entire kernel, but Linux has the capability\nof adding some modules to the kernel without going through that entire\nprocess. These modules are referred to as loadable kernel modules, or LKMs.\nLKMs have access to the lowest levels of the kernel by necessity, making\nthem an incredibly vulnerable target for hackers. A particular type of\nmalware known as a rootkit embeds itself into the kernel of the operating\nsystems, often through these LKMs. If malware embeds itself in the kernel,\nthe hacker can take complete control of the operating system.\nIf a hacker can get the Linux admin to load a new module to the kernel,\nthe hacker not only can gain control over the target system but, because\nthey’re operating at the kernel level of the operating system, can control\nwhat the target system is reporting in terms of processes, ports, services,\nhard drive space, and almost anything else you can think of.\nSo, if a hacker can successfully tempt a Linux admin into installing a\nvideo or other device driver that has a rootkit embedded in it, the hacker can\ntake total control of the system and kernel. This is the way some of the most\ninsidious rootkits take advantage of Linux and other operating systems.\nUnderstanding LKMs is absolutely key to being an effective Linux admin\nand being a very effective and stealthy hacker."
  },
  {
    "input": "Kernel Tuning with sysctl",
    "output": "Let’s take a look at how the kernel can be managed for good and ill.\nChecking the Kernel Version\nThe first step to understanding the kernel is to check what kernel your\nsystem is running. There are at least two ways to do this. First, we can enter\nthe following:\nkali >uname -a\nLinux Kali 4.6.0-kalil-amd64 #1 SMP Debian 4.6.4-lkalil (2016-07-21) x86_64\nThe kernel responds by telling us the distribution our OS is running is\nLinux Kali, the kernel build is 4.6.4, and the architecture it’s built for is the\nx86_64 architecture. It also tells us it has symmetric multiprocessing (SMP)\ncapabilities (meaning it can run on machines with multiple cores or\nprocessers) and was built on Debian 4.6.4 on July 21, 2016. Your output may\nbe different, depending on which kernel was used in your build and the CPU\nin your system. This information can be required when you install or load a\nkernel driver, so it’s useful to understand how to get it.\nOne other way to get this information, as well as some other useful\ninformation, is to use the cat command on the /proc/version file, like so:\nkali >cat /proc/version\nLinux version 4.6.0-kalil-amd64 (devel@kali.org) (gcc version 5.4.0 20160909\n(Debian 5.4.0-6) ) #1 SMP Debian 4.6.4-lkalil (2016-07-21)\nHere you can see that the /proc/version file returned the same information.\nKernel Tuning with sysctl\nWith the right commands, you can tune your kernel, meaning you can\nchange memory allocations, enable networking features, and even harden\nthe kernel against outside attacks.\nModern Linux kernels use the sysctl command to tune kernel options. All\nchanges you make with sysctl remain in effect only until you reboot the\nsystem. To make any changes permanent, you have to edit the configuration\nfile for sysctl directly at /etc/sysctl.conf.\nA word of warning: you need to be careful when using sysctl because\nwithout the proper knowledge and experience, you can easily make your\nsystem unbootable and unusable. Make sure you’ve considered what you’re\ndoing carefully before making any permanent changes.\nLet’s take a look at the contents of sysctl now. By now, you should\nrecognize the options we give with the command shown here:\nkali >sysctl -a | less\ndev.cdrom.autoclose = 1\ndev.cdrom.autoeject = 0\ndev.cdrom.check_media = 0\ndev.cdrom.debug = 0\n--snip--\nIn the output, you should see hundreds of lines of parameters that a\nLinux administrator can edit to optimize the kernel. There are a few lines\nhere that are useful to you as a hacker. As an example of how you might use\nsysctl, we’ll look at enabling packet forwarding.\nIn the man-in-the middle (MITM) attack, the hacker places themselves\nbetween communicating hosts to intercept information. The traffic passes\nthrough the hacker’s system, so they can view and possibly alter the\ncommunication. One way to achieve this routing is to enable packet\nforwarding.\nIf you scroll down a few pages in the output or filter for “ipv4” (sysctl -a |\nless | grep ipv4), you should see the following:\nnet.ipv4.ip_dynaddr = 0\nnet.ipv4.ip_early_demux = 0\nnet.ipv4.ip_forward = 0\nnet.ipv4.ip_forward_use_pmtu = 0\n--snip--\nThe line net.ipv4.ip_forward = 0 is the kernel parameter that enables the\nkernel to forward on the packets it receives. In other words, the packets it\nreceives, it sends back out. The default setting is 0, which means that packet\nforwarding is disabled.\nTo enable IP forwarding, change the 0 to a 1 by entering the following:\nkali >sysctl -w net.ipv4.ip_forward=1\nRemember that that sysctl changes take place at runtime but are lost\nwhen the system is rebooted. To make permanent changes to sysctl, you\nneed to edit configuration file /etc/sysctl.conf. Let’s change the way the kernel"
  },
  {
    "input": "Managing Kernel Modules",
    "output": "handles IP forwarding for MITM attacks and make this change permanent.\nTo enable IP forwarding, open the /etc/sysctl.conf file in any text editor and\nuncomment the line for ip_forward. Open /etc/sycstl.conf with any text editor\nand take a look:\n#/etc/sysctl.conf - Configuration file for setting system variables\n# See /etc/sysctl.d/ for additional system variables.\n# See sysctl.conf (5) for information.\n#\n#kernel.domainname = example.com\n# Uncomment the following to stop low-level messages on console.\n#kernel.printk = 3 4 1 3\n##############################################################3\n# Functions previously found in netbase\n#\n# Uncomment the next two lines to enable Spoof protection (reverse-path\n# Turn on Source Address Verification in all interfaces to\n# prevent some spoofing attacks.\n#net.ipv4.conf.default.rp_filter=1\n#net.ipv4.conf.all.rp_filter=1\n# Uncomment the next line to enable TCP/IP SYN cookies\n#\n# Note: This may impact IPv6 TCP sessions too\n#net.ipv4.tcp_syncookies=1\nSee http://lwn.net/Articles/277146/\n# Uncomment the next line to enable packet forwarding for IPv4\n➊ #net.ipv4.ip_forward=1\nThe relevant line is at ➊; just remove the comment (#) here to enable IP\nforwarding.\nFrom an operating system–hardening perspective, you could use this file\nto disable ICMP echo requests by adding the line\nnet.ipv4.icmp_echo_ignore_all=1 to make it more difficult—but not impossible—\nfor hackers to find your system. After adding the line, you will need to run\nthe command sysctl -p.\nManaging Kernel Modules\nLinux has at least two ways to manage kernel modules. The older way is to\nuse a group of commands built around the insmod suite—insmod stands for\ninsert module and is intended to deal with modules. The second way, using\nthe modprobe command, we will employ a little later in this chapter. Here, we\nuse the lsmod command from the insmod suite to list the installed modules in\nthe kernel:\nkali >lsmod\nModule Size Used by\nnfnetlink_queue 20480 0\nnfnetlink_log 201480 0\nnfnetlink 16384 2 nfnetlink_log, nfnetlink_queue\nbluetooth 516096 0\nrfkill 0 2 bluetooth\n--snip--\nAs you can see, the lsmod command lists all the kernel modules as well as\ninformation on their size and what other modules may use them. So, for\ninstance, the nfnetlink module—a message-based protocol for communicating\nbetween the kernel and user space—is 16,384 bytes and used by both the\nnfnetlink_log module and the nf_netlink_queue module.\nFrom the insmod suite, we can load or insert a module with insmod and\nremove a module with rmmod, which stands for remove module. These\ncommands are not perfect and may not take into account module\ndependencies, so using them can leave your kernel unstable or unusable. As a\nresult, modern distributions of Linux have now added the modprobe command,\nwhich automatically loads dependencies and makes loading and removing\nkernel modules less risky. We’ll cover modprobe in a moment. First, let’s see\nhow to get more information about our modules.\nFinding More Information with modinfo\nTo learn more about any of the kernel modules, we can use the modinfo\ncommand. The syntax for this command is straightforward: modinfo followed\nby the name of the module you want to learn about. For example, if you\nwanted to retrieve basic information on the bluetooth kernel module you saw\nwhen you ran the lsmod command earlier, you could enter the following:\nkali >modinfo bluetooth\nfilename: /lib/modules/4.6.0-kali-amd64/kernel/net/bluetooth/bluetooth.ko\nalias: net-pf-31\nlicense: GPL\nversion: 2.21\ndescription:Bluetooth Core ver 2.21\nauthor: Marcel Holtman <marcel@holtmann.org>\nsrcversion: FCFDE98577FEA911A3DAFA9\ndepends: rfkill, crc16\nintree: Y\nvermagic: 4.6.0-kali1-amd64 SMP mod_unload modversions\nparm: disable_esco: Disable eSCO connection creation (bool)\nparm: disable_ertm: Disable enhanced retransmission mode (bool)\nAs you can see, the modinfo command reveals significant information about\nthis kernel module which is necessary to use Bluetooth on your system. Note\nthat among many other things, it lists the module dependencies: rfkill and\ncrc16. Dependencies are modules that must be installed for the bluetooth\nmodule to function properly.\nTypically, this is useful information when troubleshooting why a\nparticular hardware device is not working. Besides noting things like the\ndependencies, you can get information about the version of the module and\nthe version of the kernel the module was developed for and then make sure\nthey match the version you are running.\nAdding and Removing Modules with modprobe\nMost newer distributions of Linux, including Kali Linux, include the modprobe\ncommand for LKM management. To add a module to your kernel, you\nwould use the modprobe command with the -a (add) switch, like so:\nkali >modprobe -a <module name>\nTo remove a module, use the -r (remove) switch with modprobe followed by\nthe name of the module:\nkali >modprobe -r <module to be removed>\nA major advantage of using modprobe instead of insmod is that modprobe\nunderstands dependencies, options, and installation and removal procedures\nand it takes all of these into account before making changes. Thus, it is easier\nand safer to add and remove kernel modules with modprobe.\nInserting and Removing a Kernel Module\nLet’s try inserting and removing a test module to help you familiarize\nyourself with this process. Let’s imagine that you just installed a new video"
  },
  {
    "input": "Summary",
    "output": "card and you need to install the drivers for it. Remember, drivers for devices\nare usually installed directly into the kernel to give them the necessary access\nto function properly. This also makes drivers fertile ground for malicious\nhackers to install a rootkit or other listening device.\nLet’s assume for demonstration purposes (don’t actually run these\ncommands) that we want to add a new video driver named\nHackersAriseNewVideo. You can add it to your kernel by entering the\nfollowing:\nkali >modprobe -a HackersAriseNewVideo\nTo test whether the new module loaded properly, you can run the dmesg\ncommand, which prints out the message buffer from the kernel, and then\nfilter for “video” and look for any alerts that would indicate a problem:\nkali >dmesg | grep video\nIf there are any kernel messages with the word “video” in them, they will\nbe displayed here. If nothing appears, there are no messages containing that\nkeyword.\nThen, to remove this same module, you can enter the same command but\nwith the -r (remove) switch:\nkali >modprobe -r HackersAriseNewVideo\nRemember, the loadable kernel modules are a convenience to a Linux\nuser/admin, but they are also a major security weakness and one that\nprofessional hackers should be familiar with. As I said before, the LKMs can\nbe the perfect vehicle to get your rootkit into the kernel and wreak havoc!\nSummary\nThe kernel is crucial to the overall operation of the operating system, and as\nsuch, it is a protected area. Anything that’s inadvertently added to the kernel\ncan disrupt the operating system and even take control of it.\nLKMs enable the system administrator to add modules directly into the\nkernel without having to rebuild the entire kernel each time they want to\nadd a module."
  },
  {
    "input": "Exercises",
    "output": "If a hacker can convince the system admin to add a malicious LKM, the\nhacker can take complete control of the system, often without the system\nadmin even being aware.\nEXERCISES\nBefore you move on to Chapter 16, try out the skills you learned from this chapter by\ncompleting the following exercises:\n1. Check the version of your kernel.\n2. List the modules in your kernel.\n3. Enable IP forwarding with a sysctl command.\n4. Edit your /etc/sysctl.conf file to enable IP forwarding. Now, disable IP forwarding.\n5. Select one kernel module and learn more about it using modinfo."
  },
  {
    "input": "16 AUTOMATING TASKS WITH JOB SCHEDULING",
    "output": "16\nAUTOMATING TASKS WITH JOB SCHEDULING\nLike anyone using Linux, the hacker often has jobs, scripts or other tasks,\nthat they want to run periodically. You might, for example, want to schedule\nautomatic regular file backups of your system, or maybe you want to rotate\nlog files as we did in Chapter 11. The hacker, on the other hand, may also\nwant to have their system run the MySQLscanner.sh script from Chapter 8\nevery night or while they’re at work or school. These are all examples of\nscheduling automatic jobs. Scheduling jobs allows you to run tasks without\nhaving to think about it, and you can schedule jobs to run when you’re\notherwise not using your system so you have plenty of free resources.\nThe Linux admin—or the hacker for that matter—may also want to set\ncertain scripts or services to start automatically when their system boots up.\nIn Chapter 12, we looked at using the PostgreSQL database in association\nwith the hacker/pentest framework Metasploit. Rather than manually\nstarting the PostgreSQL database every time before starting Metasploit, you\ncan have PostgreSQL—or any service or script—start automatically when\nthe system boots up.\nIn this chapter, you’ll learn more about how to use the cron daemon and\ncrontab to set up scripts to run automatically, even while the system is\nunattended. You’ll also learn how to set up startup scripts that automatically\nrun whenever the system is booted, which will provide you with the\nnecessary services that you’ll need to run during your busy day of hacking."
  },
  {
    "input": "Scheduling an Event or Job to Run on an Automatic Basis",
    "output": "Scheduling an Event or Job to Run on an Automatic\nBasis\nThe cron daemon and the cron table (crontab) are the most useful tools for\nscheduling regular tasks. The first, crond, is a daemon that runs in the\nbackground. The cron daemon checks the cron table for which commands to\nrun at specified times. We can alter the cron table to schedule a task or job to\nexecute regularly on a particular day or date, at a particular time daily, or\nevery so many weeks or months.\nTo schedule these tasks or jobs, enter them into the cron table file, located\nat /etc/crontab. The cron table has seven fields: the first five are used to\nschedule the time to run the task, the sixth field specifies the user, and the\nseventh field is used for the absolute path to the command you want to\nexecute. If we were using the cron table to schedule a script, we could simply\nput the absolute path to the script in the seventh field.\nEach of the five time fields represents a different element of time: the\nminute, hour, day of the month, month, and day of the week, in that order.\nEvery element of time must be represented numerically, so March is\nrepresented as 3 (you cannot simply input “March”). Days of the week begin\nat 0, which is Sunday, and end at 7, which is also Sunday. Table 16-1\nsummarizes this.\nTable 16-1: Time Representations for Use in the crontab\nFieldTime unit Representation\n1 Minute 0–59\n2 Hour 0–23\n3 Day of the month1–31\n4 Month 1–12\n5 Day of the week 0–7\nSo, if we had written a script to scan the globe for vulnerable open ports\nand wanted it to run every night at 2:30 AM, Monday through Friday, we\ncould schedule it in the crontab file. We will walk through the process of how\nto get this information into the crontab shortly, but first let’s discuss the\nformat we need to follow, shown in Listing 16-1.\nM H DOM MON DOW USER COMMAND\n30 2 * * 1-5 root /root/myscanningscript\nListing 16-1: The format for scheduling commands\nThe crontab file helpfully labels the columns for you. Note that the first\nfield provides the minute (30), the second field provides the hour (2), the fifth\nfield provides the days (1-5, or Monday through Friday), the sixth field\ndefines the user (root), and the seventh field is the path to the script. The\nthird and fourth fields contain asterisks (*) because we want this script to run\nevery day Monday through Friday regardless of the day of the month or the\nmonth.\nIn Listing 16-1, the fifth field defines a range for the day of the week by\nusing a dash (-) between the numbers. If you want to execute a script on\nmultiple noncontiguous days of the week, you can separate those days with\ncommas (,). Thus, Tuesday and Thursday would be 2,4.\nTo edit crontab, you can run the crontab command followed by the -e (edit)\noption:\nkali >crontab -e\nSelect an editor. To change later, run 'select-editor'.\n1. /bin/nano <----easiest\n2. /usr/bin/mcedit\n3. /usr/bin/vim.basic\n4. /usr/bin/vim.gtk\n5. /usr/bin/vim.tiny\nChoose 1-5 [1]:\nThe first time you run this command, it will ask which editor you would\nlike to use. The default is /bin/nano, the 1 option. If you choose this option,\nit will open directly to crontab.\nAnother option, and often a better one for the newcomer to Linux, is to\nopen crontab directly in your favorite text editor, which you can do like so:\nkali >leafpad /etc/crontab\nI’ve used this command to open crontab in Leafpad. You can see a snippet\nof the file in Listing 16-2.\n# /etc/crontab: system-wide crontab\n# Unlike any other crontab, you don't have to run the 'crontab'\n# command to install the new version when you edit this file\n# and files in /etc/cron.d. These files also have username fields,\n# which no other crontabs do.\nSHELL=/bin/sh\nPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\n# m h dom mon dow user command\n17 * * * * root cd / && run-parts --report /etc/cron.hourly\n25 6 * * * root test -x /usr/sbin/anacron II ( cd / && run-parts\n47 6 * * 7 root test -x /usr/sbin/anacron II ( cd / && run-parts\n52 6 1 * * root test -x /usr/sbin/anacron II ( cd / && run-parts\n#\nListing 16-2: The crontab file in use in a text editor\nNow, to set a new regularly scheduled task, you simply need to enter a\nnew line and save the file.\nScheduling a Backup Task\nLet’s view this utility first from the system administrator’s perspective. As a\nsystem administrator, you’d often want to run backups of all your files after\nhours, while the system is not being used and resources are readily available.\n(System backups tend to require system resources that are in short demand\nduring business hours.) The ideal time might be in the middle of the night\non the weekend. Rather than having to log in at 2 AM on Saturday\nnight/Sunday morning (I’m sure you have other priorities at that time), you\ncould schedule the backup to start automatically at that time, even though\nyou’re not at your computer.\nNote that the hour field uses a 24-hour clock rather than using AM and\nPM, so 1 PM is, for example, 13:00. Also, note that the days of the week\n(DOW) start with Sunday (0) and end with Saturday (6).\nTo create a job, you simply need to edit the crontab file by adding a line in\nthe prescribed format. So, say you wanted to create a regular backup job\nusing a user account named “backup.” You would write a script for backing\nup the system and save it as systembackup.sh in the /bin directory, then\nschedule this backup to run every Saturday night/Sunday morning at 2 AM\nby adding the following line to crontab:\n00 2 * * 0 backup /bin/systembackup.sh\nNote that the * wildcard is used to indicate “any,” and using it in place of\na digit for the day of the month, month, or day of the week is read as “all”\ndays or months. If you read across this line, it says\n1. At the top of the hour (00),\n2. Of the second hour (2),\n3. Of any day of the month (*),\n4. Of any month (*),\n5. On Sunday (0),\n6. As the backup user,\n7. Execute the script at /bin/systembackup.sh.\nThe cron daemon will then execute that script every Sunday morning at 2\nAM, every month.\nIf you only wanted the backup to run on the 15th and 30th of every\nmonth, regardless of what days of the week those dates fell on, you could\nrevise the entry in crontab to appear as follows:\n00 2 15,30 * * backup /root/systembackup.sh\nNote that the day of the month (DOM) field now has 15,30. This tells the\nsystem to run the script only on the 15th and 30th of every month, so around\nevery two weeks. When you want to specify multiple days, hours, or months,\nyou need to list them separated by a comma, as we did here.\nNext, let’s assume the company requires you to be especially vigilant with\nits backups. It can’t afford to lose even a day of data in the event of power\noutage or system crash. You would then need to back up the data every\nweeknight by adding the following line:\n00 23 * * 1-5 backup /root/systembackup.sh\nThis job would run at 11 PM (hour 23), every day of the month, every\nmonth, but only on Monday through Friday (days 1–5). Especially note that\nwe designated the days Monday through Friday by providing an interval of\ndays (1-5) separated by a dash (-). This could have also been designated as\n1,2,3,4,5; either way works perfectly fine.\nUsing crontab to Schedule Your MySQLscanner\nNow that you understand the basics of scheduling a job with the crontab\ncommand, let’s schedule the MySQLscanner.sh script, which seeks out open\nMySQL ports, that you built in Chapter 8. This scanner searches for systems\nrunning MySQL by looking for open port 3306.\nTo enter your MySQLscanner.sh to the crontab file, edit the file to provide\nthe particulars of this job, just as we did with the system backups. We’ll\nschedule it to run during the day while you’re at work so it doesn’t take up\nresources when you’re using your home system. To do this, enter the\nfollowing line in your crontab:\n00 9 * * * user /usr/share/MySQLsscanner.sh\nWe’ve set up the job to run at 00 minutes, at the ninth hour, every day of\nthe month (*), every month (*), every day of the week (*), and to run it as a\nregular user. We simply need to save this crontab file to schedule the job.\nNow, let’s say you wanted to be particularly careful and only run this\nscanner on weekends and at 2 AM when it’s less likely that anyone is watching\nthe network traffic. You also only want it to run in the summer, June\nthrough August. Your job would now look like this:\n00 2 * 6-8 0,6 user /usr/share/MySQLsscanner.sh\nYou would add this to your crontab like so:\n# /etc/crontab: system-wide crontab\n# Unlike any other crontab, you don't have to run the 'crontab'\n# command to install the new version when you edit this file\n# and files in /etc/cron.d. These files also have username fields,\n# which none of the other crontabs do.\nSHELL=/bin/sh\nPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\n# m h dom mon dow user command\n17 * * * * root cd / && run-parts --report /etc/cron.hourly\n25 6 * * * root test -x /usr/sbin/anacron II ( cd / && run-parts --report\n/etc/cron.daily )\n47 6 * * 7 root test -x /usr/sbin/anacron II ( cd / && run-parts --report\n/etc/cron.weekly )\n52 6 1 * * root test -x /usr/sbin/anacron II ( cd / && run-parts --report\n/etc/cron.monthly )\n00 2 * 6-8 0,6 user /usr/share/MySQLsscanner.sh\nNow, your MySQLscanner.sh will only run on weekends in June, July, and\nAugust at 2 AM."
  },
  {
    "input": "Using rc Scripts to Run Jobs at Startup",
    "output": "crontab Shortcuts\nThe crontab file has some built-in shortcuts you can use instead of a\nspecifying the time, day, and month every time. These include the following:\n@yearly\n@annually\n@monthly\n@weekly\n@daily\n@midnight\n@noon\n@reboot\nSo, if you wanted the MySQL scanner to run every night at midnight,\nyou could add the following line to the crontab file:\n@midnight user /usr/share/MySQLsscanner.sh\nUsing rc Scripts to Run Jobs at Startup\nWhenever you start your Linux system, a number of scripts are run to set up\nthe environment for you. These are known as the rc scripts. After the kernel\nhas initialized and loaded all its modules, the kernel starts a daemon known\nas init or init.d. This daemon then begins to run a number of scripts found\nin /etc/init.d/rc. These scripts include commands for starting many of the\nservices necessary to run your Linux system as you expect.\nLinux Runlevels\nLinux has multiple runlevels that indicate what services should be started at\nbootup. For instance, runlevel 1 is single-user mode, and services such as\nnetworking are not started in runlevel 1. The rc scripts are set to run\ndepending on what runlevel is selected:\n0 Halt the system\n1 Single-user/minimal mode\n2–5 Multiuser modes\n6 Reboot the system\nAdding Services to rc.d\nYou can add services for the rc.d script to run at startup using the update-rc.d\ncommand. This command enables you to add or remove services from the\nrc.d script. The syntax for update-rc.d is straightforward; you simply list the\ncommand followed by the name of the script and then the action to perform,\nlike so:\nkali >update-rc.d <name of the script or service> <remove|defaults|disable|enable>\nAs an example of how you can use update-rc.d, let’s assume you always\nwant the PostgreSQL database to start upon system boot so that your\nMetasploit framework can use it to store pentesting and hacking results. You\nwould use update-rc.d to add a line to your rc.d script to have it up and\nrunning every time you boot your system.\nBefore you do that, let’s check whether PostgreSQL is running on your\nsystem already. You can do so using the ps command and piping it to a filter\nlooking for PostgreSQL using grep, like so:\nkali >ps aux | grep postgresql\nroot 3876 0.0 0.0 12720 964pts/1 S+ 14.24 0.00 grep postgresql\nThis output tells us that the only process ps found running for\nPostgreSQL was the very command we ran looking for it, so there is no\nPostgreSQL database running on this system presently.\nNow, let’s update our rc.d to have PostgreSQL run automatically at\nbootup:\nkali >update-rc.d postgresql defaults\nThis adds the line to the rc.d file. You need to reboot the system for the\nchange to take place. Once you’ve done that, let’s again use the ps command\nwith grep to look for a PostgreSQL process:\nkali >ps aux | grep postgresql"
  },
  {
    "input": "Adding Services to Your Bootup via a GUI",
    "output": "postgresql 757 0.0 0.1 287636 25180 ? S March 14\n0.00 /usr/lib/postgresql/9.6/bin/postgresql -D\n/var/lib/postgresql/9.6/main\n-c config_file=/etc/postgresql/9.6/main/postgresql.conf\nroot 3876 0.0 0.0 12720 964pts/1 S+ 14.24 0.00 grep postgresql\nAs you can see, PostgreSQL is running without you ever entering any\ncommands manually. It automatically starts when your system boots up,\nready and waiting to be used with your Metasploit!\nAdding Services to Your Bootup via a GUI\nIf you’re more comfortable working from a GUI to add services at startup,\nyou can download the rudimentary GUI-based tool rcconf from the Kali\nrepository, like so:\nkali >apt-get install rcconf\nOnce it has completed its installation, you can start rcconf by entering the\nfollowing:\nkali >rcconf\nThis will open a simple GUI like the one in Figure 16-1. You can then\nscroll through the available services, select the ones you want to start upon\nbootup, and click OK."
  },
  {
    "input": "Exercises",
    "output": "Figure 16-1: The rcconf GUI for adding services to startup\nIn this figure, you can see the PostgreSQL service listed second from last.\nPress the spacebar to select this service, press TAB to highlight <Ok>, and then\npress ENTER. The next time you boot Kali, PostgreSQL will start\nautomatically.\nSummary\nBoth system administrators and hackers often need to schedule services,\nscripts, and utilities to run at regular intervals. Linux enables you to schedule\nnearly any script or utility to run on a regular basis using the cron daemon,\nwhich runs these jobs from the cron table. In addition, you can have services\nstart automatically at bootup by using the command update-rc.d or the GUI-\nbased tool rcconf to update the rc.d scripts.\nEXERCISES\nBefore you move on to Chapter 17, try out the skills you learned from this chapter by\ncompleting the following exercises:\n1. Schedule your MySQLscanner.sh script to run every Wednesday at 3 PM.\n2. Schedule your MySQLscanner.sh script to run every 10th day of the month in April, June,\nand August.\n3. Schedule your MySQLscanner.sh script to run every Tuesday through Thursday at 10\nAM.\n4. Schedule your MySQLscanner.sh script to run daily at noon using the shortcuts.\n5. Update your rc.d script to run PostgreSQL every time your system boots.\n6. Download and install rcconf and add the PostgreSQL and MySQL databases to start at\nbootup."
  },
  {
    "input": "17 PYTHON SCRIPTING BASICS FOR HACKERS",
    "output": "17\nPYTHON SCRIPTING BASICS FOR HACKERS\nBasic scripting skills are critical to becoming a master hacker. Without\nhaving developed some basic scripting skills, a beginner hacker who simply\nuses tools created by someone else will be condemned to the realm of script\nkiddies. This means that you will be limited to using tools developed by\nsomeone else, which decreases your probability of success and increases your\nprobability of detection by antivirus (AV) software, intrusion detection\nsystems (IDSs), and law enforcement. With some scripting skills, you can\nelevate yourself to the upper echelon of the master hackers!\nIn Chapter 8, we covered bash scripting basics and built some simple\nscripts, including MySQLScanner.sh, which finds systems running the\nubiquitous MySQL database system. In this chapter, we begin looking at the\nscripting language most widely used by hackers: Python. Many of the most\npopular hacker tools are written in Python, including sqlmap, scapy, the\nSocial-Engineer Toolkit (SET), w3af, and many more.\nPython has some important features that make it particularly well-suited\nfor hacking, but probably most importantly, it has a huge variety of libraries\n—prebuilt modules of code that can be imported externally and reused—that\nprovide some powerful functionality. Python ships with over 1,000 modules\nbuilt in, and many more are available in various other repositories.\nBuilding hacking tools is possible in other languages too, such as bash,\nPerl, and Ruby, but Python’s modules make building these tools much\neasier."
  },
  {
    "input": "Adding Python Modules",
    "output": "Adding Python Modules\nWhen you install Python, you also install its set of standard libraries and\nmodules that provide an extensive range of capabilities, including built-in\ndata types, exception handling, numeric and math modules, file handling,\ncryptographic services, internet data handling, and interaction with internet\nprotocols (IPs).\nDespite all the power offered by these standard libraries and modules,\nyou may need or want additional third-party modules. The third-party\nmodules available for Python are extensive and are probably the reason most\nhackers prefer Python for scripting. You can find a comprehensive list of\nthird-party modules at PyPI (the Python Package Index, shown in Figure\n17-1) at http://www.pypi.org/.\nFigure 17-1: The Python Package Index\nUsing pip\nPython has a package manager specifically for installing and managing\nPython packages known as pip (Pip Installs Packages). Since we are working\nwith Python 3 here, you will need pip for Python 3 to download and install\npackages. You can download and install pip from the Kali repository by\nentering the following:\nkali >apt-get install python3-pip\nNow, to download modules from PyPI, you can simply enter this:\nkali >pip3 install <package name>\nWhen you download these packages, they are automatically placed in the\n/usr/local//lib/<python-version>/dist-packages directory. So, for instance, if you\nhad used pip to install the Python implementation of the SNMP protocol\nfor Python 3.6, you would find it at /usr/local/lib/python3.6/pysnmp. If you\naren’t sure where a package has been placed on your system (sometimes\ndifferent distributions of Linux use different directories), you can enter pip3\nfollowed by show and the package name, as shown here:\nkali >pip3 show pysnmp\nName: pysnmp\nVersion: 4.4.4\nSummary: SNMP library for Python\nHome-page: https://github.com/etingof/pysnmp\nAuthor: Ilya Etingof <etingof@gmail.com>\nAuthor-email: etingof@gmail.com\nLicense: BSD\nLocation: usr/local/lib/python3.6/dist-packages\nRequires: ptsmi, pyansl, pycryptodomex\nYou can see this gives you a lot of information about the package,\nincluding the directory that holds it.\nAs an alternative to using pip, you can download a package directly from\nthe site (make certain that is downloaded to the proper directory), unpack it\n(see Chapter 9 on how to unpack software), and then run the following:\nkali >python setup.py install\nThis will install any unpacked packages that haven’t yet been installed.\nInstalling Third-Party Modules\nTo install a third-party module created by another member of the Python\ncommunity (as opposed to an officially released Python package), you can\nsimply use wget to download it from wherever it is being stored online,\nuncompress the module, and then run the python setup.py install command.\nAs an example, let’s download and install the Python module for the port-\nscanning tool we used in Chapter 8, nmap, from its online repository at\nhttps://xael.org.\nFirst, we need to download the module from xael.org:\nkali >wget http://xael.org/norman/python/python-nmap/python-nmap-0.3.4.tar.gz\n--2014-12-28 17:48:32-- http://xael.org/norman/python/python-nmap/python-nmap-\n0.3.4.tar.gz\nResolving xael.org (xael.org)...194.36.166.10\nConnecting to xael.org (xael.org)|194.36.166.10|:80...connected.\n--snip--\n2018-21-28 17.48:34 (113 KB/s) - 'python-nmap-0.3.4.tar.gz' saved\n[40307/40307]\nHere, you can see we use the wget command and the full URL for the\npackage. After the package has downloaded, you need to uncompress it with\ntar, as you learned in Chapter 9:\nkali >tar -xzf python-nmap-0.3.4.tar.gz\nThen change directories to the newly created directory:\nkali >cd python-nmap-.03.4/\nFinally, in that directory, install the new module by entering the\nfollowing:\nkali >~/python-nmap-0.3.4 >python setup.py install\nrunning install\nrunning build\nrunning build_py\ncreating build\n--snip--\nrunning install_egg_info\nwriting /usr/local/lib/python2.7/dist-packages/python_nmap-0.3.4.egg.info\nInnumerable other modules can be obtained this way as well. Once\nyou’ve installed this nmap module, you can use it in your Python scripts by\nimporting the module. More on this later. Now let’s get started on some"
  },
  {
    "input": "Getting Started Scripting with Python",
    "output": "scripting.\nGetting Started Scripting with Python\nNow that you know how to install modules in Python, I want to cover some\nof the basic concepts and terminology of Python, then the basic syntax. After\nthat, you’ll write some scripts that will be useful to hackers everywhere and\nthat I hope will demonstrate the power of Python.\nJust as with bash or any other scripting language, we can create Python\nscripts using any text editor. For this chapter, to keep things simple, I advise\nyou to use a simple text editor such as Leafpad, but it’s useful to know that a\nnumber of integrated development environments, or IDEs, are available for use\nwith Python. An IDE is like a text editor with other capabilities built in, such\nas color-coding, debugging, and compiling capabilities. Kali has the IDE\nPyCrust built in, but there are many more IDEs available to download, of\nwhich the best is arguably JetBrain’s PyCharm. This is an excellent IDE with\na lot of enhancements that make learning Python easier and quicker. There\nis a professional version for purchase and a community edition that is free.\nYou can find them at https://www.jetbrains.com/pycharm/.\nOnce you’ve completed this chapter, if you want to keep learning Python,\nPyCharm is an excellent tool that will help you in your development. For\nnow, we will use a basic text editor like Leafpad to keep things simple.\nNote that learning any programming language takes time and a lot of\nhard work. Be patient with yourself—attempt to master each of the small\nscripts I provide before moving on.\nFORMATTING IN PYTHON\nOne difference between Python and some other scripting languages is that formatting is\ncritically important in Python. The Python interpreter uses the formatting to determine how\ncode is grouped. The particulars of the formatting are less important than simply being\nconsistent, particularly with your indentation levels.\nIf you have a group of code lines that you start with double indentation, for example, you\nmust be consistent with the double indentation throughout the entire block in order for\nPython to recognize that these code lines belong together. This is different from scripting in\nother programming languages, where formatting is optional and a best practice, but not\nrequired. You’ll notice this as you go through and practice; it’s something to always keep in\nmind!\nVariables\nNow, on to some more practical concepts in Python. A variable is one of the\nmost basic data types in programming, and you encountered it earlier in\nChapter 8 with bash scripting. In simple terms, a variable is a name\nassociated with a particular value such that whenever you use that name in\nyour program, it will invoke the associated value.\nThe way it works is that the variable name points to data stored in a\nmemory location, which may contain any kind of value, such as an integer,\nreal number, string, floating-point number, Boolean (true or false\nstatement), list, or dictionary. We’ll briefly cover all of these in this chapter.\nTo become familiar with the basics, let’s create a simple script, shown in\nListing 17-1, in Leafpad and save it as hackers-arise_greetings.py.\n#! /usr/bin/python3\nname=\"OccupyTheWeb\"\nprint (\"Greetings to \" + name + \" from Hackers-Arise. The Best Place to Learn\nHacking!\")\nListing 17-1: Your first Python program\nThe first line simply tells your system that you want it to use the Python\ninterpreter to run this program, rather than any other language. The second\nline defines a variable called name and assigns a value to it (in this case,\n\"OccupyTheWeb\"). You should change this value to your own name. The value of\nthis variable is in the string character data format, meaning the content is\nenclosed in quotation marks and is treated like text. You can put numbers in\nstrings, too, and they will be treated like text, in that you won’t be able to use\nthem in numerical calculations.\nThe third line creates a print() statement concatenating Greetings to with\nthe value in the name variable, followed by the text from Hackers-Arise. The Best\nPlace to Learn Hacking! A print() statement will display whatever you pass to it\nwithin the parentheses on your screen.\nNow, before you can run this script, you need to give yourself permission\nto execute it. We need the chmod command to do that. (For more information\non Linux permissions, see Chapter 5).\nkali >chmod 755 hackers-arise_greetings.py\nJust as you did in Chapter 8 with bash scripting, to execute your script,\nprecede the script name with a period and forward slash. Your current\ndirectory is not in the $PATH variable for security reasons, so we need to\nprecede the script name with ./ to tell the system to look in the current\ndirectory for the filename and execute it.\nTo run this particular script, enter the following:\nkali >./hackers-arise_greetings.py\nGreetings to OccupyTheWeb from Hackers-Arise. The Best Place to Learn Hacking!\nIn Python, each variable type is treated like a class. A class is a kind of\ntemplate for creating objects. See “Object-Oriented Programming (OOP)”\non page 192 for more information. In the following script, I have attempted\nto demonstrate a few of the types of variables. Variables can hold more than\njust strings. Listing 17-2 shows some variables containing different data\ntypes.\n#! /usr/bin/python3\nHackersAriseStringVariable = \"Hackers-Arise Is the Best Place to Learn\nHacking\"\nHackersAriseIntegerVariable = 12\nHackersAriseFloatingPointVariable = 3.1415\nHackersAriseList = [1,2,3,4,5,6]\nHackersAriseDictionary = {'name' : 'OccupyTheWeb', 'value' : 27)\nprint (HackersAriseStringVariable)\nprint (HackersAriseIntegerVariable)\nprint (HackersAriseFloatingPointVariable)\nListing 17-2: A series of data structures associated with variables\nThis creates five variables that contain different data types: a string,\ntreated as text; an integer, which is a number type without decimals that can\nbe used in numerical operations; a float, which is a number type with\ndecimals that can also be used in numerical operations; a list, which is a\nseries of values stored together; and a dictionary, which is an unordered set\nof data where each value is paired with a key, meaning each value in the\ndictionary has a unique identifying key. This is useful for when you want to\nrefer to or change a value by referring to a key name. For example, say you\nhave a dictionary called fruit_color configured like the following:\nfruit_color = {'apple' : 'red', 'grape' : 'green', orange : 'orange'}\nIf later in your script you want get the fruit_color of the grape, you simply\ncall it by its key:\nprint (fruit_color['grape'])\nYou could also change values for particular keys; for example, here we\nchange the color of the apple:\nfruit_color['apple'] : 'green'\nWe will discuss lists and dictionaries in more detail later in the chapter.\nCreate this script in any text editor, save it as secondpythonscript.py, and\nthen give yourself permission to execute it, like so:\nkali >chmod 755 secondpythonscript.py\nWhen we run this script, it prints the values of the string variable, the\ninteger variable, and the floating-point number variable, like so:\nkali >./secondpythonscript.py\nHackers-Arise Is the Best Place to Learn Hacking\n12\n3.1415\nNOTE\nIn Python, there is no need to declare a variable before assigning a value to it, as\nin some other programming languages.\nComments\nLike any other programming and scripting language, Python has the\ncapability for adding comments. Comments are simply parts of your code—\nwords, sentences, and even paragraphs—that explain what the code is meant\nto do. Python will recognize comments in your code and ignore them.\nAlthough comments are not required, they’re incredibly helpful for when\nyou come back to your code two years later and can’t remember what it\nshould do. Programmers often use comments to explain what a certain block\nof code does or to explain the logic behind choosing a particular method of\ncoding.\nComments are ignored by the interpreter. This means that any lines\ndesignated as comments are skipped by the interpreter, which simply\ncontinues until it encounters a legitimate line of code. Python uses the #\nsymbol to designate the start of single-line comment. If you want to write\nmultiline comments, you can use three double quotation marks (\"\"\") at the\nstart and end of the comment section.\nAs you can see in the following script, I have added a short, multiline\ncomment to our simple hackers-arise_greetings.py script.\n#! /usr/bin/python3\n\"\"\"\nThis is my first Python script with comments. Comments are used to help explain code\nto\nourselves and fellow programmers. In this case, this simple script creates a greeting\nfor\nthe user.\n\"\"\"\nname = \"OccupyTheWeb\"\nprint (\"Greetings to \"+name+\" from Hackers-Arise. The Best Place to Learn Hacking!\")\nWhen we execute the script again, nothing changes compared to the last\ntime it was executed, as you can see here:\nkali >./hackers-arise_greetings.py\nGreetings to OccupyTheWeb from Hackers-Arise. The Best Place to Learn Hacking!\nIt runs exactly the same as it did in Listing 17-1, but now we have some\ninfo about our script when we return to the code at a later time.\nFunctions\nFunctions in Python are bits of code that perform a particular action. The\nprint() statement you used earlier, for example, is a function that displays\nwhatever values you pass to it. Python has a number of built-in functions you\ncan immediately import and use. Most of them are available on your default\ninstallation of Python in Kali Linux, although many more are available from"
  },
  {
    "input": "Lists",
    "output": "the downloadable libraries. Let’s take a look at just a few of the thousands of\nfunctions available to you:\nexit() exits from a program.\nfloat() returns its argument as a floating-point number. For example,\nfloat(1) would return 1.0.\nhelp() displays help on the object specified by its argument.\nint() returns the integer portion of its argument (truncates).\nlen() returns the number of elements in a list or dictionary.\nmax() returns the maximum value from its argument (a list).\nopen() opens the file in the mode specified by its arguments.\nrange() returns a list of integers between two values specified by its\narguments.\nsorted() takes a list as an argument and returns it with its elements in\norder.\ntype() returns the type of its argument (for example, int, file, method,\nfunction).\nYou can also create your own functions to perform custom tasks. Since\nthere are so many already built into the language, it’s always worth checking\nwhether a function already exists before going through the effort of building\nit yourself. There are many ways to do this check. One is to look at the\nofficial Python documentation available at https://docs.python.org. Choose the\nversion you are working with and then select Library Reference.\nLists\nMany programming languages use arrays as a way to store multiple separate\nobjects. An array is a list of values that can be retrieved, deleted, replaced, or\nworked with in various ways by referencing a particular value in the array by\nits position in the list, known as its index. It’s important to note that Python,\nlike many other programming environments, begins counting indexes at 0,\nso the first element in a list is index 0, the second is index 1, the third is\nindex 3, and so on. So, for instance, if we wanted to access the third value in\nthe array, we could do so with array[2]. In Python, there are a few"
  },
  {
    "input": "Modules",
    "output": "implementations of arrays, but probably the most common implementation\nis known as lists.\nLists in Python are iterable, which means that the list can provide\nsuccessive elements when you run all the way through it (see “Loops” on\npage 198). This is useful because quite often when we use lists, we are\nlooking through them to find a certain value, to print out values one by one,\nor to take values from one list and put them into another list.\nSo, let’s imagine we need to display the fourth element in our list\nHackersAriseList from Listing 17-2. We can access that element and print it by\ncalling the list’s name, HackersAriseList, followed by the index of the element\nwe want to access enclosed in square brackets.\nTo test this, add the following line to the bottom of your\nsecondpythonscript.py script to print the element at index 3 in HackersAriseList:\n--snip--\nprint (HackersAriseStringVariable)\nprint (HackersAriseIntegerVariable)\nprint (HackersAriseFloatingPointVariable)\nprint (HackersAriseList[3])\nWhen we run this script again, we can see that the new print statement\nprints 4 alongside the other output:\nkali >./secondpythonscript.py\nHackers-Arise Is the Best Place to Learn Hacking\n12\n3.1415\n4\nModules\nA module is simply a section of code saved into a separate file so you can use\nit as many times as you need in your program without having to type it all\nout again. If you want to use a module or any code from a module, you need\nto import it. As discussed earlier, using standard and third-party modules is\none of the key features that makes Python so powerful for the hacker. If we\nwanted to use the nmap module we installed earlier, we would add the"
  },
  {
    "input": "Object-Oriented Programming (OOP)",
    "output": "following line to our script:\nimport nmap\nLater in this chapter, we will use two very useful modules: socket and\nftplib.\nObject-Oriented Programming (OOP)\nBefore we delve deeper into Python, it’s probably worth taking a few\nminutes to discuss the concept of object-oriented programming (OOP).\nPython, like most programming languages today (C++, Java, and Ruby, to\nname a few) adheres to the OOP model.\nFigure 17-2 shows the basic concept behind OOP: the language’s main\ntool is the object, which has properties in the form of attributes and states, as\nwell as methods that are actions performed by or on the object.\nFigure 17-2: Illustration of object-oriented programming\nThe idea behind OOP-based programming languages is to create objects\nthat act like things in the real world. For example, a car is an object that has\nproperties, such as its wheels, color, size, and engine type; it also has\nmethods, which are the actions the car takes, such as accelerating and\nlocking the doors. From the perspective of natural human language, an\nobject is a noun, a property is an adjective, and a method is generally a verb.\nObjects are members of a class, which is basically a template for creating\nobjects with shared initial variables, properties, and methods. For instance,\nsay we had a class called cars; our car (a BMW) would be a member of the\nclass of cars. This class would also include other objects/cars, such as\nMercedes and Audi, as shown in Figure 17-3."
  },
  {
    "input": "Network Communications in Python",
    "output": "Figure 17-3: OOP classes and objects\nClasses may also have subclasses. Our car class has a BMW subclass, and\nan object of that subclass might be the model 320i.\nEach object would have properties (make, model, year, and color) and\nmethods (start, drive, and park), as shown in Figure 17-4.\nFigure 17-4: OOP properties and methods\nIn OOP languages, objects inherit the characteristics of their class, so the\nBMW 320i would inherit the start, drive, and park methods from class car.\nThese OOP concepts are crucial to understanding how Python and other\nOOP languages work, as you will see in the scripts in the following sections.\nNetwork Communications in Python\nBefore we move on to more Python concepts, let’s use what you’ve learned\nso far to write a couple of hacking scripts to do with network connections.\nBuilding a TCP Client\nWe’ll create a network connection in Python using the socket module. I’ve\nalready mentioned that Python comes with a library of modules for a\nmultitude of tasks. In this case, we will need the socket module to create a\nTCP connection. Let’s see it in action.\nTake a look at the script in Listing 17-3 named\nHackersAriseSSHBannerGrab.py (I know, it’s a long name, but bear with me\nhere). A banner is what an application presents when someone or something\nconnects to it. It’s kind of like an application sending a greeting announcing\nwhat it is. Hackers use a technique known as banner grabbing to find out\ncrucial information about what application or service is running on a port.\n#! /usr/bin/python3\n➊ import socket\n➋ s = socket.socket()\n➌ s.connect((\"192.168.1.101\", 22))\n➍ answer = s.recv(1024)\n➎ print (answer)\ns.close\nListing 17-3: A banner-grabbing Python script\nFirst, we import the socket module ➊ so we can use its functions and\ntools. Here, we’re going to use the networking tools from the socket module\nto take care of interfacing a connection over the network for us. A socket\nprovides a way for two computer nodes to communicate with each other.\nUsually, one is a server and one is a client.\nThen we create a new variable, s, and associate it with the socket class\nfrom the socket module ➋. This way, we don’t have to reference the full\nsocket.socket() syntax whenever we want to use the socket class—we can simply\nuse the s variable name.\nWe then use the connect() method from the socket module ➌ to make a\nnetwork connection to a particular IP and port. Remember that methods are\nfunctions that are available for a particular object. The syntax is\nobject .method (for example, socket.connect). In this case, I’m connecting to IP\naddress 192.168.1.101, which is the IP address of a machine on my network,\nand port 22, which is the default SSH port. You can test this on another\ninstance of Linux or Kali. Most have port 22 open by default.\nOnce you make the connection, there are a number of things you can do.\nHere, we use the receive method recv to read 1024 bytes of data from the\nsocket ➍ and store them in a variable named answer; these 1024 bytes will\ncontain the banner information. Then we print the contents of that variable\nto the screen with the print() function ➎ to see what data has been passed\nover that socket, allowing us to spy on it! On the final line, we close the\nconnection.\nSave this script as HackersAriseSSHBannerGrab.py and then change its\npermissions using the chmod command so that you can execute it.\nLet’s run this script to connect to another Linux system (you might use\nan Ubuntu system or even another Kali system) on port 22. If SSH is\nrunning on that port, we should be able to read the banner into our answer\nvariable and print it to the screen, as shown here:\nkali >./HackersAriseSSHBannerGrab.py\nSSH-2.0-OpenSSH_7.3p1 Debian-1\nWe have just created a simple banner-grabbing Python script! We can\nuse this script to find out what application, version, and operating system are\nrunning at that IP address and port. This gives us key information a hacker\nneeds before attacking a system. This is essentially what the website\nShodan.io does for nearly every IP address on the planet, and it catalogs and\nindexes this information for us to search.\nCreating a TCP Listener\nWe just created a TCP client that can make a connection to another\nTCP/IP address and port and then spy on the information being\ntransmitted. That socket can also be used to create a TCP listener, to listen\nto connections from outsiders to your server. Let’s try doing that next.\nIn the Python script shown in Listing 17-4, you’ll create a socket on any\nport of your system that, when someone connects to that socket, collects key\ninformation about the connector’s system. Enter the script and save it as\ntcp_server.py. Make sure to give yourself execute permissions with chmod.\n#! /usr/bin/python3\nimport socket\n➊ TCP_IP = \"192.168.181.190\"\nTCP_PORT = 6996\nBUFFER_SIZE = 100\n➋ s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n➌ s.bind((TCP_IP, TCP_PORT))\n➍ s.listen (1)\n➎ conn, addr = s.accept()\nprint ('Connection address: ', addr )\nwhile 1:\ndata=conn.recv(BUFFER_SIZE)\nif not data:break\nprint (\"Received data: \", data)\nconn.send(data) #echo\nconn.close\nListing 17-4: A TCP-listening Python script\nWe declare that we want the script to run with the Python interpreter\nand then import the socket module as before, so we can use its capabilities.\nWe then define variables to hold information for the TCP/IP address, the\nport to listen on, and the buffer size of the data we want to capture from the\nconnecting system ➊.\nWe define the socket ➋ and bind the socket to the IP address and port ➌\nusing the variables we just created. We tell the socket to listen using the\nlisten() method from the socket library ➍.\nWe then capture the IP address and port of the connecting system using\nthe socket library’s accept method, and we print that information to the\nscreen so the user can see it ➎. Notice the while 1: syntax here; we’ll discuss\nthis more later in the chapter, but for now just know that it is used to run the\nindented code that comes after it indefinitely, meaning Python keeps\nchecking for data until the program is stopped.\nFinally, we place the information from the connecting system into a\nbuffer, print it, and then close the connection.\nNow, go to another computer on your network and use a browser to\nconnect to the 6996 port designated in our script. Run the tcp_server.py\nscript, and you should be able to connect and collect key information about"
  },
  {
    "input": "Dictionaries, Loops, and Control Statements",
    "output": "that system, including the IP address and port of the connecting system, as\nshown here:\nkali >./tcp_server.py\nConnection Address: ('192.168.181.190', 45368)\nReceived data: Get /HTTP/1.1\nHost:192.168.181.190:6996\nUser -Agent:Mozilla/5.0 (X11; Linux x86_64; rv:45.0) Gec\n--snip---\nThis is critical information for a hacker to gather before deciding on an\nexploit. Exploits (or hacks) are very specific to the operating system,\napplication, and even language being used, so the hacker needs to know as\nmuch information as possible about the target before proceeding. This act of\ngathering information prior to a hack is often referred to as reconnaissance.\nYou just developed a tool that will gather key reconnaissance information on\na potential target, very similar to the popular hacker tool p0F!\nDictionaries, Loops, and Control Statements\nLet’s keep expanding your understanding of Python and then use everything\nyou’ve learned so far to build a password cracker for an FTP server.\nDictionaries\nDictionaries hold information as unordered pairs, where each pair contains a\nkey and an associated value. We can use a dictionary to store a list of items\nand give each item a label so we can use and refer to that item individually.\nWe might use a dictionary to store, for example, user IDs and their\nassociated names, or to store known vulnerabilities associated with a specific\nhost. Dictionaries in Python act like associative arrays in other languages.\nLike lists, dictionaries are iterable, meaning we use a control structure\nsuch as a for statement to go through the entire dictionary, assigning each\nelement of the dictionary to a variable until we come to the end of the\ndictionary.\nAmong other things, you might use this structure in building a password\ncracker that iterates through each password stored in a dictionary until one\nworks or until the cracker comes to the end of the dictionary.\nThe syntax for creating a dictionary is as follows:\ndict = {key1:value1, key2:value2, key3:value3...}\nNote that for dictionaries, you use curly brackets and separate items with\na comma. You can include as many key-value pairs as you like.\nControl Statements\nControl statements allows your code to make decisions based on some\ncondition. There are a number of ways in Python to control the flow of the\nscript.\nLet’s look at some of these structures in Python.\nThe if Statement\nThe if structure in Python, as in many other programming languages\nincluding bash, is used to check whether a condition is true or not and run\ndifferent sets of code for each scenario. The syntax looks like this:\nif conditional expression\nrun this code if the expression is true\nThe if statement contains a condition that might be something like if\nvariable < 10, for example. If the condition is met, the expression evaluates to\ntrue, and then the code that follows, known as the control block, is executed. If\nthe statement evaluates to false, then the statements in the control block are\nskipped over and not executed.\nIn Python, the control block must be indented. This indentation\nidentifies the control block to the interpreter. The next statement that is not\nindented is outside the control block and therefore not part of the if\nstatement, and this is how Python knows where to skip to if the condition is\nnot met.\nif...else\nThe if...else structure in Python looks like this:\nif conditional expression\n*** # run this code when the condition is met\nelse\n*** # run this code when the condition is not met\nAs before, first the interpreter checks the condition in the if expression. If\nit evaluates to true, the interpreter executes the statements in the control\nblock. If the conditional statement evaluates to false, the control block\nfollowing the else statement is executed instead.\nFor example, here we have a code snippet that checks the value of a user\nID; if it is 0 (the root user in Linux is always UID 0), then we print the\nmessage “You are the root user.” Else, if it is any other value, we print the\nmessage “You are NOT the root user.”\nif userid == 0\nprint (\"You are the root user\")\nelse\nprint (\"You are NOT the root user\")\nLoops\nLoops are another very useful structure in Python. Loops enable the\nprogrammer to repeat a code block multiple times, depending on a value or\na condition. The two most widely used are while and for.\nThe while Loop\nThe while loop evaluates a Boolean expression (an expression that can\nevaluate only to true or false) and continues execution while the expression\nevaluates to true. For example, we could create a code snippet that prints\neach number from 1 to 10 and then exits the loop, like so:\ncount = 1\nwhile (count <= 10):\nprint (count)\ncount += 1\nThe indented control block then runs for as long as the condition is true.\nThe for Loop\nThe for loop can assign values from a list, string, dictionary, or other iterable\nstructure to an index variable each time through the loop, allowing us to use\neach item in the structure one after the other. For example, we can use a for\nloop to attempt passwords until we find a match, like so:"
  },
  {
    "input": "Improving Our Hacking Scripts",
    "output": "for password in passwords:\nattempt = connect (username, password)\nif attempt == \"230\"\nprint (\"Password found: \" + password)\nsys.exit (0)\nIn this code snippet, we create a for statement that continues through a\nlist of passwords we have provided and attempts to connect with a username\nand password. If the connection attempt receives a 230 code, which is the\ncode for a successful connection, the program prints \"Password found:\" and\nthen the password. It then exits. If it does not get a 230, it will continue\nthrough each of the remaining passwords until it receives a 230 or until it\nexhausts the list of passwords.\nImproving Our Hacking Scripts\nNow with a bit more background in Python looping structures and\nconditional statements, let’s return to our banner-grabbing script and add\nsome capabilities.\nWe’ll add a list of ports that we want to grab the banner from, rather than\njust listening on one port, and then loop through the list using a for\nstatement. In this way, we can search for and grab banners for multiple ports\nand display them to the screen.\nFirst, let’s create a list and put additional ports in it. Open\nHackersAriseSSHBannerGrab.py, and we’ll work from there. Listing 17-5\nshows the full code. Note that the grayed-out lines have stayed the same; the\nblack lines are the ones you need to change or add. We’ll try to grab banners\nfor ports 21 (ftp), 22 (ssh), 25 (smtp), and 3306 (mysql).\n#! /usr/bin/python3\nimport socket\n➊ Ports = [21,22,25,3306]\n➋ for i in range (0,4):\ns = socket.socket()\n➌ Ports = Port[i]\nprint ('This Is the Banner for the Port')\nprint (Ports)\n➍ s.connect ((\"192.168.1.101\", Port))\nanswer = s.recv (1024)\nprint (answer)\ns.close ()\nListing 17-5: Improving the banner grabber\nWe create a list called Ports ➊ and add four elements, each representing a\nport. Then we create a for statement that iterates through that list four\ntimes, since it has four items ➋.\nRemember that when you’re using a for loop, the code associated with the\nloop must be indented beneath the for statement.\nWe need to alter the program to reflect the use of a variable from the list\non each iteration through. To do so, we create a variable named Port and\nassign it to the value from the list at each iteration ➌. Then we use that\nvariable in our connection ➍.\nWhen the interpreter comes to that statement, it will attempt to connect\nto whichever port is assigned to the variable at the IP address.\nNow, if you run this script on a system with all the ports listed open and\nenabled, you should see something like Listing 17-6.\nkali >./HackersArisePortBannerGrab.py\nThis is the Banner for the Port\n21\n220 (vsFTPd 2.3.4)\nThis Is the Banner for the Port\n22\nSSH-2.0-OpenSSH_4.7p1 Debian-8ubuntu1\nThis Is the Banner for the Port\n25\n220 metasploitable.localdomain ESMTP Postfix (Ubuntu)\nThis Is the Banner for the Port\n3306\n5.0.51a-3ubuntu5\nListing 17-6: Output for the port banner grabber"
  },
  {
    "input": "Exceptions and Password Crackers",
    "output": "Note that the script has found port 21 open with vsFTPd 2.3.4 running\non it, port 22 open with OpenSSH 4.7 running on it, port 25 with Postfix,\nand port 3306 with MySQL 5.0.51a.\nWe have just successfully built a multiport banner-grabbing tool in\nPython to perform reconnaissance on a target system. The tool tells us\nwhich service is running on the port and the version of that service! This is\nkey information a hacker needs before proceeding with an attack.\nExceptions and Password Crackers\nAny code you write will be at risk of errors or exceptions. In programming\nterms, an exception is anything that disrupts the normal flow of your code—\nusually an error caused by incorrect code or input. To deal with possible\nerrors, we use exception handling, which is simply code that handles a\nparticular problem, presents an error message, or even uses an exception for\ndecision making. In Python, we have the try/except structure to handle these\nerrors or exceptions.\nA try block tries to execute some code, and if an error occurs, the except\nstatement handles that error. In some cases, we can use the try/except\nstructure for decision making, similar to if...else. For instance, we can use\ntry/except in a password cracker to try a password and, if an error occurs due\nto the password not matching, move to the next password with the except\nstatement. Let’s try that now.\nEnter the code in Listing 17-7 and save it as ftpcracker.py; we’ll go\nthrough it in a moment. This script asks the user for the FTP server number\nand the username of whichever FTP account they want to crack. It then\nreads in an external text file containing a list of possible passwords and tries\neach one in an effort to crack into the FTP account. The script does this\nuntil it either succeeds or runs out of passwords.\n#! /usr/bin/python3\nimport ftplib\n➊ server = input(FTP Server: \")\n➋ user = input(\"username: \")\n➌ Passwordlist = input (\"Path to Password List > \")\n➍ try:\nwith open(Passwordlist, 'r') as pw:\nfor word in pw:\n➎ word = word.strip ('\\r').strip('\\n')\n➏ try:\nftp = ftplib.FTP(server)\nftp.login(user, word)\n➐ print (Success! The password is ' + word)\n➑ except:\nprint('still trying...')\nexcept:\nprint ('Wordlist error')\nListing 17-7: FTP password cracker Python script\nWe’re going to use tools from the ftplib module for the FTP protocol, so\nfirst we import that. Next, we create a variable named server and another\nvariable named user, which will store some commands for user input. Your\nscript will prompt the user to enter the IP address of the FTP server ➊ and\nthe username for the account ➋ the user is trying break into.\nThen we ask the user for the path to the password list ➌. You can find\nnumerous password lists in Kali Linux by entering locate wordlist in a\nterminal.\nWe then begin the try block of code that will use the password list\nprovided by the user to attempt to crack the password for the username\nsupplied by the user.\nNote that we use a new Python function called strip() ➎. This function\nremoves the first and last character of a string (in this case, the Passwordlist).\nThis is necessary if the passwords in this list have a preceding whitespace or\ncomma. The strip() function removes these and leaves just the string of\ncharacters of the potential password. If we don’t strip the whitespace, we\nmight get a false negative."
  },
  {
    "input": "Summary",
    "output": "Then, we use a second try ➏ block. Here, we use the ftplib module to first\nconnect to the server using the IP address the user supplied and then try the\nnext password from the password list on that account.\nIf the combination of the username and password results in an error, the\nblock exits and goes to the except clause ➑, where it prints still trying and\nthen returns to the top of the for clause and grabs the next password from\nthe password list to try.\nIf the combination succeeds, the successful password is printed to the\nscreen ➐. The final line picks up any other situations that would otherwise\nresult in errors. An example would be if the user input something the\nprogram couldn’t process, such as bad path to the wordlist or a missing\nwordlist.\nNow, let's run this script against the FTP server at 192.168.1.101 and see\nwhether we can crack the password of the root user. I am using a password\nlist named bigpasswordlist.txt in my working directory. You may need to\nprovide the entire path to whichever password list you are using if it is not in\nyour working directory (for example, /usr/share/bigpasswordlist.txt).\nkali >./ftpcracker.py\nFTP Server: 192.168.1.101\nusername: root\nPath to PasswordList >bigpasswordlist.txt\nstill trying...\nstill trying...\nstill trying...\n--snip--\nSuccess! The password is toor\nAs you can see, ftpcracker.py successfully found the password for the user\nroot and presented it onscreen.\nSummary\nTo graduate beyond script-kiddie status, a hacker must master a scripting\nlanguage, and Python is generally a good first choice for its versatility and\nrelatively small learning curve. The majority of hacking tools are written in\nPython, including sqlmap, scapy, and many others. Here, you have learned\nsome Python fundamentals you can use to build some useful, yet simple"
  },
  {
    "input": "Exercises",
    "output": "hacker tools, including a banner grabber and an FTP password cracker. To\nlearn more Python, I strongly recommend No Starch Press’s excellent book\nAutomate the Boring Stuff with Python (2015) by Al Sweigart.\nEXERCISES\nTry out the skills you learned from this chapter by completing the following exercises:\n1. Build the SSH banner-grabbing tool from Listing 17-5 and then edit it to do a banner\ngrab on port 21.\n2. Rather than hardcoding the IP address into the script, edit your banner-grabbing tool so\nthat it prompts the user for the IP address.\n3. Edit your tcp_server.py to prompt the user for the port to listen on.\n4. Build the FTPcracker in Listing 17-7 and then edit it to use a wordlist for user variable\n(similar what we did with the password) rather than prompting the user for input.\n5. Add an except clause to the banner-grabbing tool that prints “no answer” if the port is\nclosed."
  },
  {
    "input": "INDEX",
    "output": "INDEX\nSymbols & Numbers\n\"\"\" (comment) characters, 190\n# (comment) character, 83\n#! (shebang) characters, 82\n--help command, 8–9\n-? (help) command, 9\n-h (help) command, 8–9\n. (execute) command, 84, 90\n.. (move up level) command option, 7\n/ (forward) command, 25\n32-bit/64-bit CPU types, xxv\n: (return true) command, 84, 90\n[ (conditional test) command, 91\nA\naccess. See also permissions\nnetwork, 31, 32\nremote databases, 132–133\nrestricted internet, 148–149\naccess lists. See also wordlists, 125\naccess points (AP), 31, 154, 155–156, 157\nAdvanced Packaging Tool (apt), 40–44\naircracking suite, 9, 157–159\naireplay-ng command, 159\nairmon-ng command, 157–158\nairodump-ng command, 158–159\nanonymity\nIP address tracking, 140–141\nwith proxy servers, 143–148\nwith Tor network, 141–143\nwith VPNs, 148–149\nApache Web Server service, 122–125\napt (Advanced Packaging Tool), 40–44\napt-cache command, 40\napt-get command, 40–43\narchiving, 94–96, 115\nARM architecture, xxvi\narrays, 191\nat daemon, 69\nautomount, 106\nB\nbackground processes, 68–69\nbackup scheduling task, 176–177\nbad blocks table, 108\nbanner-grabbing, 194–195, 199–201\nbanners, 194\nbash (Bourne-again shell)\ncommon commands, 90–91\noverview, 2, 4, 72, 82\nBcast (broadcast address), 30\nbg (background) command, 90\n/bin directories, 5, 76\nbinaries\ndefined, 2\nin Linux filesystem, 5\nsearch commands, 10\nBIND (Berkeley Internet Name Domain), 34\nblack hat hackers, 86\nblock devices, 105–106\nBluetooth, 159–164\noverview, 159–160\nscanning, 160–164\nBluetooth SIG site, 162\nBlueZ protocol stack, 160–161\nbootloader, xxxiv\nbreak command, 90\nbroadcast address\nchanging, 32\ninformation, 30\nbroadcast command option, 32\nBSSID (basic service set identifier), 154, 158–159\nbunzip2 command, 97\nButler, Max “Max Vision”, 86–87\nbzip2 command, 97\nC\ncase sensitivity, 2\ncat (concatenation) command, 13–14, 22, 167\ncd (change directory) command, 7\nchannels (CH), Wi-Fi, 154, 158, 158–159\ncharacter devices, 105\nchgrp (change group) command, 51\nchmod (change mode) command, 52–55, 56, 58\nchown (change owner) command, 50\nclasses and subclasses, 193–194\ncommand directories, 76–77\ncommand line interface (CLI), 2\ncomment characters, 83, 190\ncompress command, 97\ncompression, 93–94, 96–97\nconcatenation, 13–14, 22, 67\nconfiguration files, 5\nconnect method, 194–195\ncontinue command, 90\ncontrol statements, 197–199\ncopy commands\nbit by bit, 98–99\nfile, 15\ncp (copy file) command, 15\nCPU types, xxv\ncreateuser command, 137\ncron daemon, 174\ncron table, 174–178\ncrond command, 69, 174\ncrontab command, 175–176\nD\ndaemons, 32, 69\ndark web, 142\ndatabases. See also MySQL databases\nhacking, 87, 130\ndb_status command, 137\ndd command, 98–99\nDebian distribution, xxv\ndeleted file copy, 98–99\ndenial-of-service (DoS) attacks, 31\ndescribe command, 134\n/dev directory, 102–106\ndevice drivers, as hacking target, 171\ndf (disk free) command, 107–108\ndhclient command, 33\ndhcp daemon, 32\nDHCPDISCOVER request, 33\nDHCPOFFER request, 33\nDHSCP servers, 32–33, 35\ndict statement, 197\ndictionaries, 197\ndig command, 33–34\ndirectories. See also filesystems\nchanging, 7\ncreating, 15\nLinux filesystem, 5\nlisting content, 7–8, 51–52\nnaming, 2\nand PATH variable, 76–77\npermissions, 51–52\npresent working, 6\nremoving, 16\nsearching, 11–12\ndisk space, xxix, 107–108\ndmesg command, 171\nDNS (Domain Name System), 33–35\nchanging servers, 34–35\ninformation, 33–34\nE\neavesdropping, 150, 166\necho command, 35, 83, 90\nemail encryption services, 150\nencryption\nemail, 150\nwith VPNs, 149\nwireless security (ENC), 158\nenv (environment) command, 72\nenvironment variables. See also shell variables\nchanging values, 73–74\ncommand directories, 76–77\nconcepts, 71–72\nshell prompt, 75–76\nuser-defined, 77–78\nviewing, 72–73\nespionage, xxiii, 141, 148, 149\nESSID (extended service set identifier), 154, 158–159\n/etc/apt/sources.list file, 43\n/etc/crontab file, 174–176\n/etc directory, 5\n/etc/fstab file, 107\n/etc/hosts file, 36\n/etc/init.d/rc file, 179\n/etc/logrotate.conf file, 115–117\n/etc/proxychains.conf file, 144\n/etc/resolv.conf file, 34–35\n/etc/rsyslog.conf file, 112–115\n/etc/shadow file, 57\n/etc/sysctl.conf file, 167, 168\neth0 interface, 30\nethical hacking, xxii–xxiii\neval (evaluate expression) command, 90\nexception handling, 201\nexec command, 90\nexecute permissions, 55–56, 57–58, 83–84\nexit command, 90\nexploits, 196–197\nexport command, 74, 75–76, 90\nF\nfdisk utility, 104\nfg (foreground) command, 68–69, 90\nfile content. See text\nfile types, 104–105\nfiles. See also log files; text\narchiving, 94–96\ncompressing, 96–97\ncopying, 15, 97–98\ncreating, 13–15\nlisting, 7–8, 51–52\nmoving, 15–16\nnaming, 2\nownership, 50–51\nremoving, 16\nrenaming, 15–16\nsearching for, 10–12\nfilesystems\nLinux structure, 4–5\nmonitoring, 107–109\nnavigating, 6–8\nsearching, 9–12\nstorage devices in, 102–106, 107\nfiltering with keywords, 12–13, 22–23, 63–64, 73\nfind command, 11–12, 59\nflash drives, 104–105, 106\nfor loop, 199\nfrequency, Wi-Fi, 154\nfsck (filesystem check) command, 108–109\nftplib module, 201–202\nG\ngetopts command, 91\ngit clone command, 46–47\ngithub, 46\nGoogle internet tracking, 140\nGrand Unified Bootloader (GRUB), xxxiv–xxxv\ngray hat hackers, 86–87\ngrep command, 12–13, 22, 24, 63, 73\nGRUB (Grand Unified Bootloader), xxxiv–xxxv\ngzip command, 96–97\nH\nhacking\nmalicious, 86–87\nas profession, xxi–xxiii\nand scripting skills, 183\nhard drive partitions, xxxiii\nhciconfig command, 161\nhcidump command, 161\nhcitool command, 161–162\nhead (view file) command, 20–21, 23\nhelp commands, 8–9\nhidden file switch, 8\nhistory file size, 73–74\nHISTSIZE (history file) variable, 73\nhome directory, 2, 5\nhosts file, 36\nhtml code example, 124–125\nHTTP vs. Torrent, xxv–xxvi\nHWaddr. See MAC address\nI\nIDEs (integrated development environments), 187\nif statement, 197–198\nifconfig command, 29–30, 31–32, 154–155\nif...else statement, 198\nimport statement, 192\nindex.html file, 124–125\ninit daemon, 179\ninsmod (insert module) suite, 169\nIP forwarding, 168–169\nIP (Internet Protocol) addresses\nanalyzing, 29–30\nchanging, 31\ndomain name mapping, 36\nrequesting new, 32–33\nscanner script, 87–88\ntracking, 140–141\n.iso file extension, xxx\niterable lists, 191\niwconfig command, 30–31, 155, 157\niwlist command, 155–156\nJ\njob scheduling, 173–178\njobs command, 91\nK\nKali\ndesktop, 3–5\ndownloads, xxv–xxvi\ninstallation, xxix–xxxi\nlogin, xxxv–xxxvi\noverview, 2\nsetup, xxxi–xxxv\nkernel, 62, 165–166, 167–169\nkernel modules. See also loadable kernel modules, 166, 169–171\nKEY statements, 72\nkill command, 67–68\nkill signals, 67\nkillall command, 67–68\nL\nl2ping command, 163–164\nLAMP tools, 123\nless command, 25–26\n/lib directory, 5\nlibraries, 5\nLinux\nadvantages of, xxiv\ncase sensitivity, 2\ndistributions, xxv\nrunlevels, 179\nLKMs. See loadable kernel modules (LKMs)\nlo (loopback address) information, 30\nloadable kernel modules (LKMs). See also kernel modules, 166, 169–171,\n171–172\nlocalhost, 30\nlocate command, 10\nlog files, 115–118\nrotating, 115–117\nshredding, 117–118\nlogging systems\nconcepts, 111\nconfiguration and rules, 112–115\ndisabling, 118–119\nlogin checking, 6\nlogrotate utility, 115–117\nloopback address, 30\nloops, 198–199\nlossy vs. lossless compression, 94\nls (list) command, 7–8, 51–52\nlsblk (list block) command, 105–106\nlsmod (list modules) command, 169\nM\nMAC address\ndisplaying, 30, 156\nspoofing, 32\nman-in-the-middle (MITM) attacks, 166, 168\nman (manual) command, 9, 23\nmanaged mode, 31\nmanual pages, 9\nMask information, 30\nmaster mode, 155\n/media directory, 5, 106–107\nmessage logging. See logging systems\nMetasploit, 63, 136–137\nmethods, 193–194, 195\nmilitary hacking, xxiii\nMITM (man-in-the-middle) attacks, 166, 168\nmkdir (make directory) command, 15\n/mnt directory, 5, 106\nmobile devices, xxiv–xxv, xxvi\nmodinfo command, 170\nmodprobe command, 169, 170–171\nmonitor mode, 155, 157–158\nmore command, 25\nmount points, 106\nmounting/unmounting devices, 106–107\nmv (move/rename) file command, 16\nMySQL databases, 130–135\naccessing, 132–133\nconnecting to, 133–134\ninformation, 131–132\ntables, 134–135\nMySQL Scanner script\ncode example, 87–90\nscheduling, 177–178\nmysql service, 130–135\nN\nnameservers, 33–35\nNational Security Agency (NSA), 139, 143\nnetmask command option, 32\nnetwork cards, 155, 157\nnetwork connection scripts, 194–197\nnetwork intrusion detection system (NIDS), 19\nnetwork manager, 156\nnetwork mask\nchanging, 32\ndisplay, 30\nnetworks. See also Wi-Fi networks\nanalyzing, 29–31\nchanging information, 31–33\nnfnetlink module, 169\nnice (process priority) command, 65–66\nNIDS (network intrusion detection system), 19\nnl (number lines) command, 22, 23\nnmap (network map) command, 86, 87–88\nnmcli (network manager command line interface) command, 156\nO\nobject-oriented programming (OOP), 192–194\nobjects, 193–194, 195\noctal digits, 53\n.onion addresses, 142\nOnion Router system, 141–143\nOOP. See object-oriented programming (OOP)\nopen source code, xxiv, xxv\nOpenSSH service, 125–126\nP\npacket forwarding, 168–169\npairing Bluetooth, 160\npartitions\ndefined, xxxiii\nlabeling system, 103–104\npasswd command, 4\npasswords\nchanging, 4\ncracking, 31, 159, 201–203\nroot user, xxxii–xxxiii, 132–133\nPATH variable, 76–77\npenetration testing, xxiii\npermissions, 49–59\nchanging, 52–57\nchecking, 51–52\nconcepts, 49–50\ngranting, 50–51, 83–84\nspecial, 57–59\nPID (process ID), 62, 63\npip (Pip Installs Packages) manager, 184–185\npiping, 12–13\nports\nbanner-grabbing script, 199–201\nconnecting to, 194–195\nscanning, 86–90\nPostgreSQL (Postgres) databases, 135–137\npostgresql service, 136–137\npower (PWR) and Wi-Fi, 154, 158, 158–159\npriority\nmessage logging, 114–115\nprocesses, 64–66\nprivilege escalation, 58\n/proc/version file, 167\nprocess ID (PID), 62, 63\nprocesses, 61–69\nbackground and foreground, 68–69\nconcepts, 61–62\ninformation on, 12–13, 62–64\nkilling, 66–68\nmanaging priority of, 64–66\nscheduling, 69\n.profile file, 57\npromiscuous mode, 31\nproperties, 193\nProtonMail, 150\nproxy servers, 143–148\nchoosing, 148\nconcepts, 143–144\nsetting up, 144–148\nproxychains command, 143–148\nps (processes) command, 12–13, 62–63\nPS1 (shell prompt) variable, 75–76\nPSK (pre-shared key), 154\npwd (present working directory) command, 6\nPython language\ncomments, 190\nfunctions, 190–191\ninstalling, 184–186\nlearning, 183–184, 187, 203\nlists, 191–192\nmodules, 192\nvariables, 187–190\nPython Package Index (PyPI), 184\nR\nRaspberry Pi\narchitecture, xxvi\nSpy project, 125–129\nRaspbian operating system, 126, 129\nraspistill application, 129\nrc scripts, 178–180\nrcconf tool, 180–181\nread command, 85, 91\nreadonly command, 91\nreconnaissance, 160–164, 197\nrenice command, 65, 66\nrepositories, 40, 43–44, 185\nresource usage, 64\nrm (remove) command, 16\nrmdir (remove directory) command, 16\nrmmod (remove module) command, 169\n/root directory, 5\nroot user\ndefined, 2\npasswords, xxxii–xxxiii, 130–131, 132\nprivileges, 5, 6, 50, 65, 66\nrootkits, 166, 171\nrsyslog daemon, 112, 119\nrunlevels, 179\nS\n/sbin directories, 76\nscheduling\nwith at, 69\nwith crond, 174–178\nat startup, 178–181\nscript variables, 84–85, 89\nscripts\nconcepts, 2, 81\nexamples, 86–90\nexecuting (running), 83–84\nscheduling, 174–178\nwriting, 82–85\nSDP (Service Discovery Protocol), 163\nsdptool command, 163\nsecurity. See also permissions\nand loadable kernel modules, 171–172\nand surveillance, 142–143, 148, 149\nWi-Fi protocol, 154\nsed (stream editor) command, 23–24\nSELECT command, 135\nservice command, 119, 122\nService Discovery Protocol (SDP), 163\nservices\ndefined, 121\nscheduling at startup, 179–181\nstarting, stopping, restarting, 122\nset command, 72–73, 91\nSGID bit, 58–59\n.sh file extension, 85\nshebang (#!), 82\nshell prompt, 75–76\nshell variables, 71–72\nshells, 2, 82\nshift command, 91\nshow command, 134\nshred command, 117–118\nSnort, 19–20, 20\nsocket module, 194–196\nsoftware managers and installers, 40, 45–46\nsoftware packages\ndefined, 39\ninstalling, 40–41\nremoving, 41–42\nupdating and upgrading, 42–43\nsources.list file, 43–44\nspy camera project, 125–129\nSQL (Structured Query Language) commands, 131\nSSH (Secure Shell), 125–126\nSSID (service set identifier), 154\nsticky bit permission bit, 58\nstorage devices, 102–109\nmonitoring and checking, 107–109\nmounting and unmounting, 106–107\nrepresentation of, 102–106\nstrip() function, 202\nsu (switch user) command, 136\nSUID bit, 57–59\nsurveillance concerns, 142–143, 148, 149\nSynaptic Package Manager, 45–46\nsysctl command, 167–169\nsyslogd daemon, 112\nsystem administrator. See root user\nT\ntail (view file) command, 21–22, 23\ntar (archive) command, 94–96\n.tar file extension, 95\ntarballs/tar files, 94–96\nTCP client script, 194–195\nTCP connect scan, 86, 88–90\nTCP listening script, 195–197\nterminals, 2, 4, 68\ntest command, 91\ntext\nconcatenating to file, 13–14\ndisplaying, 20–23, 24–26\nfind and replace, 23–24\ntext editors, 82, 187\n.tgz file extension, 96\ntimes command, 91\ntop (resource usage) command, 64, 66\nTor network, 141–143\ntorrent downloads, xxv–xxvi\ntouch command, 14–15\ntraceroute command, 140\ntrap command, 91\ntry/except statements, 201–202\ntype command, 91\nU\nUGO (user, group, and others) syntax, 54–55\numask (unmask) values, 56–57, 91\numount (unmount) command, 107\nuname command, 167\nuncompress command, 97\nunset command, 72–73, 78, 91\nupdate-rc.d command, 179\nUSB flash drives, 104–105, 106\nuse command, 134\nuser-defined variables, 77–78\nuser land, 165\nuser types, 50\nV\nvariables. See also environment variables\nPython, 187–190\nscript, 84–85, 89\nshell, 71–72\nvirtual machines, concepts and installation, xxvi–xxvii\nvirtual private networks (VPNs), 148–149\nVirtualBox\ninstallation and setup, xxvi–xxix\ninstalling Kali on, xxix–xxxi\nvirtualization software, xxxi\nVPNs (virtual private networks), 148–149\nvulnerability assessments, xxiii\nW\nwait command, 91\nweb server services, 122–125\nWEP (Wired Equivalent Privacy) protocol, 154\nwget command, 185–186\nwhereis command, 10\nwhich command, 10\nwhile loops, 198\nwhite hat hacking, xxiii\nwhoami command, 6\nWi-Fi networks, 154–159\nbasic commands, 154–157\nhacking, 157–159\nwildcards, 12\nWindows vs. Linux, xxiv–xxv, 101\nwireless network devices, 30–31, 153\nwireless range, 154\nwlan0 interface, 30, 31, 155\nwordlists, 27, 159, 202\nWPA (Wi-Fi Protected Access) protocol, 154\nWPA2-PSK protocol, 154\nZ\nzombie processes, 66, 67\nASPIRING HACKER? START HERE.\nCOVERS KALI LINUX AND PYTHON 3\nIf you’re getting started along the exciting path of hacking, cybersecurity,\nand pentesting, Linux Basics for Hackers is an excellent first step. Using Kali\nLinux, an advanced penetration testing distribution of Linux, you’ll learn the\nbasics of using the Linux operating system and acquire the tools and\ntechniques you’ll need to take control of a Linux environment.\nFirst, you’ll learn how to install Kali on a virtual machine and get an\nintroduction to basic Linux concepts. Next, you’ll tackle broader Linux\ntopics like manipulating text, controlling file and directory permissions, and\nmanaging user environment variables. You’ll then focus in on foundational\nhacking concepts like security and anonymity and learn scripting skills with\nbash and Python.\nPractical tutorials and exercises throughout will reinforce and test your skills\nas you learn how to:\n• Cover your tracks by changing your network information and\nmanipulating the rsyslog logging utility\n• Write a tool to scan for network connections, and connect and listen to\nwireless networks\n• Keep your internet activity stealthy using Tor, proxy servers, VPNs, and\nencrypted email\n• Write a bash script to scan open ports for potential targets\n• Use and abuse services like MySQL, Apache web server, and OpenSSH\n• Build your own hacking tools, such as a remote video spy camera and a\npassword cracker\nHacking is complex, and there is no single way in. Why not start at the\nbeginning with Linux Basics for Hackers?\nABOUT THE AUTHOR\nOccupyTheWeb is an infosec consultant, forensic investigator, and trainer\nwith more than 20 years in the industry. He maintains the Hackers-Arise\ntraining site (https://www.hackers-arise.com/) and trains US military personnel,\nDepartment of Defense contractors, and federal employees in information\nsecurity and hacking.\nTHE FINEST IN GEEK ENTERTAINMENT™\nwww.nostarch.com"
  }
]