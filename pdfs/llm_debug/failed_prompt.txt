Below is a JSON array of document chunks, each with an "index" and "text".

★ **Task:** Return the **index of the FIRST CHUNK that begins the NEXT major section / heading / chapter / topic.**
That is, imagine the window as `[current‑section … | next‑section …]`; your answer is the index where the divider `|` sits.
⚠️ Do **NOT** return the index of the last chunk in the current section.
⚠️ Do **NOT** return the number of chunks.

Prefer to group *more* chunks rather than splitting on minor transitions (page numbers, pictures, charts etc.).
• A heading‑like chunk (ALL‑CAPS line, "Chapter …", numbered title) **does not by itself mark a boundary**. Treat the heading and its immediate introductory paragraph(s) as one unit. Only mark a boundary when the following chunk clearly shifts topic.

[BEGIN_EXAMPLES]
Example 1:
[
  {"index": 1, "text": "Copyright"},
  {"index": 2, "text": "Table of Contents"},
  {"index": 3, "text": "Preface"},
  {"index": 4, "text": "Chapter 1: Getting Started"},
  {"index": 5, "text": "Chapter 1 content…"}
]
✔ Correct response: **4**  (chunk 4 is the first of Chapter 1)

Example 2:
[
  {"index": 1, "text": "Chapter 1: The Basics"},
  {"index": 2, "text": "More on chapter 1"},
  {"index": 3, "text": "Still more on chapter 1"},
  {"index": 4, "text": "Chapter 2: Advanced Topics"},
  {"index": 5, "text": "Content on chapter 2"}
]
✔ Correct response: **4**

Example 3:
[
  {"index": 1, "text": "Section 2.4: Analysis of Results"},
  {"index": 2, "text": "Detailed explanation of the experimental setup …"},
  {"index": 3, "text": "Figure 2‑7: Distribution of sample values"},
  {"index": 4, "text": "Continuation of analysis and discussion …"},
  {"index": 5, "text": "Section 2.5: Limitations"}
]
✔ Correct response: **5**  (chunk 5 is the first chunk of the next real section; the figure caption at chunk 3 does **not** define a boundary)

✖ Wrong response : **3** (that is figure not a boundary)

Counter‑example (#4):
[
  {"index": 1, "text": "Chapter 1 intro"},
  {"index": 2, "text": "Chapter 1 body"},
  {"index": 3, "text": "Chapter 1 summary"},
  {"index": 4, "text": "Chapter 2: Advanced"},
  {"index": 5, "text": "Chapter 2 body"}
]
✔ Correct response: **4**
✖ Wrong response : **3** (that is the last chunk of Chapter 1, NOT the first of Chapter 2)

Counter‑example (#5 – heading travels with intro):
[
  {"index": 1, "text": "CHAPTER 2: INTRODUCTION"},
  {"index": 2, "text": "This chapter covers the basics of …"},
  {"index": 3, "text": "More details on the basics …"},
  {"index": 4, "text": "CHAPTER 3: ADVANCED TOPICS"}
]
✔ Correct response: **4**
✖ Wrong response : **2** or **3** (heading + intro are one unit)
[END_EXAMPLES]

Now decide the boundary for the real data below. Respond with a single integer from **1** to **20** — no explanation, no extra text.

[BEGIN_CHUNKS]
[
  {
    "index": 1,
    "text": "Hash Crack. Copyright © 2017 Netmux LLC\nAll rights reserved. Without limiting the rights under the copyright reserved above, no part of this\npublication may be reproduced, stored in, or introduced into a retrieval system, or transmitted in any\nform or by any means (electronic, mechanical, photocopying, recording, or otherwise) without prior\nwritten permission.\nISBN-10: 1975924584\nISBN-13: 978-1975924584\nNetmux and the Netmux logo are registered trademarks of Netmux, LLC.\nOther product and company names mentioned herein may be the trademarks\nof their respective owners. Rather than use a trademark symbol with every\noccurrence of a trademarked name, we are using the names only in an\neditorial fashion and to the benefit of the trademark owner, with no intention\nof infringement of the trademark.\nThe information in this book is distributed on an “As Is” basis, without\nwarranty. While every precaution has been taken in the preparation of this\nwork, neither the author nor Netmux LLC, shall have any liability to any\nperson or entity with respect to any loss or damage caused or alleged to be\ncaused directly or indirectly by the information contained in it.\nWhile every effort has been made to ensure the accuracy and legitimacy of\nthe references, referrals, and links (collectively “Links”) presented in this\nbook/ebook, Netmux is not responsible or liable for broken Links or missing\nor fallacious information at the Links. Any Links in this book to a specific\nproduct, process, website, or service do not constitute or imply an\nendorsement by Netmux of same, or its producer or provider. The views and\nopinions contained at any Links do not necessarily express or reflect those of\nNetmux."
  },
  {
    "index": 2,
    "text": "TABLE OF CONTENTS\nIntro\nRequired Software\nCore Hash Cracking Knowledge\nCracking Methodology\nBasic Cracking Playbook\nCheat Sheets\nExtract Hashes\nPassword Analysis\nDictionary / Wordlist\nRules & Masks\nForeign Character Sets\nAdvanced Attacks\nCracking Concepts\nCommon Hash Examples\nAppendix\n-Terms\n-Online Resources\n-John The Ripper Menu\n-Hashcat Menu\n-Hash Cracking Benchmarks\n-Hash Cracking Speed"
  },
  {
    "index": 3,
    "text": "INTRO\nThis manual is meant to be a reference guide for cracking tool usage and\nsupportive tools that assist network defenders and pentesters in password\nrecovery (cracking). This manual will not be covering the installation of these\ntools, but will include references to their proper installation, and if all else\nfails, Google. Updates and additions to this manual are planned yearly as\nadvancements in cracking evolve. Password recovery is a battle against math,\ntime, cost, and human behavior; and much like any battle, the tactics are\nconstantly evolving.\nACKNOWLEDGEMENTS\nThis community would not enjoy the success and diversity without the\nfollowing community members and contributors:\nAlexander ‘Solar Designer’ Peslvak, John The Ripper Team, & Community\nJens ‘atom’ Steube, Hashcat Team, & Devoted Hashcat Forum Community\nJeremi ‘epixoip’ Gosney\nKorelogic & the Crack Me If You Can Contest\nRobin ‘DigiNinja’ Wood (Pipal & CeWL)\nCynoSure Prime Team\nChris ‘Unix-ninja’ Aurelio\nPer Thorsheim (PasswordsCon)\nBlandyuk & Rurapenthe (HashKiller Contest)\nPeter ‘iphelix’ Kacherginsky (PACK)\nRoyce ‘tychotithonus’ Williams\n‘Waffle’\nAnd many, many, many more contributors. If a name was excluded from the\nabove list please reach out and the next version will give them their due\ncredit.\nLastly, the tools, research, and resources covered in the book are the result of\npeople’s hard work. As such, I HIGHLY encourage all readers to DONATE\nto help assist in their efforts. A portion of the proceeds from this book will be\ndistributed to the various researchers/projects.\nSuggestions or comments, send your message to hashcrack@netmux.com"
  },
  {
    "index": 4,
    "text": "REQUIRED SOFTWARE\nIn order to follow many of the techniques in this manual, you will want to\ninstall the following software on your Windows or *NIX host. This book\ndoes not cover how to install said software and assumes you were able to\nfollow the included links and extensive support websites.\nHASHCAT v3.6 (or newer)\nhttps://hashcat.net/hashcat/\nJOHN THE RIPPER (v1.8.0 JUMBO)\nhttp://www.openwall.com/john/\nPACK V0.0.4 (Password Analysis and Cracking Toolkit)\nhttp://thesprawl.org/projects/pack/\nHashcat-utils v1.7\nhttps://hashcat.net/wiki/doku.php?id=hashcat_utils\nAdditionally you will need dictionaries/wordlists and highly recommend the\nbelow sources:\nWEAKPASS DICTIONARY\nhttps://weakpass.com/wordlist\nCRACKSTATION DICTIONARY\nhttps://crackstation.net/buy-crackstation-wordlist-password-cracking-\ndictionary.htm\nSKULL SECURITY WORDLISTS\nhttps://wiki.skullsecurity.org/index.php?title=Passwords\nThroughout the manual, generic names have been given to the various inputs\nrequired in a cracking commands structure. Legend description is below:\nCOMMAND STRUCTURE LEGEND\nhashcat = Generic representation of the various Hashcat binary names\njohn = Generic representation of the John the Ripper binary names\n#type = Hash type; which is an abbreviation in John or a number in Hashcat\nhash.txt = File containing target hashes to be cracked\ndict.txt = File containing dictionary/wordlist\nrule.txt = File containing permutation rules to alter dict.txt input\npasswords.txt = File containing cracked password results\noutfile.txt = File containing results of some functions output\nLastly, as a good reference for testing various hash types to place into your\n“hash.txt” file, the below sites contain all the various hashing algorithms and\nexample output tailored for each cracking tool:\nHASHCAT HASH FORMAT EXAMPLES\nhttps://hashcat.net/wiki/doku.php?id=example_hashes\nJOHN THE RIPPER HASH FORMAT EXAMPLES\nhttp://pentestmonkey.net/cheat-sheet/john-the-ripper-hash-formats\nhttp://openwall.info/wiki/john/sample-hashes"
  },
  {
    "index": 5,
    "text": "CORE HASH CRACKING KNOWLEDGE\nENCODING vs HASHING vs ENCRYPTING\nEncoding = transforms data into a publicly known scheme for usability\nHashing = one-way cryptographic function nearly impossible to reverse\nEncrypting = mapping of input data and output data reversible with a key\nCPU vs GPU\nCPU = 2-72 cores mainly optimized for sequential serial processing\nGPU = 1000’s of cores with 1000’s of threads for parallel processing\nCRACKING TIME = KEYSPACE / HASHRATE\nKeyspace: charset^length (?a?a?a?a = 95^4 = 81,450,625)\nHashrate: hashing function / hardware power (bcrypt / GTX1080 = 13094\nH/s)\nCracking Time: 81,450,625 / 13094 H/s = 6,220 seconds\n*Keyspace displayed and Hashrate vary by tool and hardware used\nSALT = random data that’s used as additional input to a one-way function\nITERATIONS = the number of times an algorithm is run over a given hash\nHASH IDENTIFICATION: there isn’t a foolproof method for identifying\nwhich hash function was used by simply looking at the hash, but there are\nreliable clues (i.e. $6$ sha512crypt). The best method is to know from where\nthe hash was extracted and identify the hash function for that software.\nDICTIONARY/WORDLIST ATTACK = straight attack uses a\nprecompiled list of words, phrases, and common/unique strings to attempt to\nmatch a password.\nBRUTE-FORCE ATTACK = attempts every possible combination of a\ngiven character set, usually up to a certain length.\nRULE ATTACK = generates permutations against a given wordlist by\nmodifying, trimming, extending, expanding, combining, or skipping words.\nMASK ATTACK = a form of targeted brute-force attack by using\nplaceholders for characters in certain positions (i.e. ?a?a?a?l?d?d).\nHYBRID ATTACK = combines a Dictionary and Mask Attack by taking\ninput from the dictionary and adding mask placeholders (i.e. dict.txt ?d?d?d).\nCRACKING RIG = from a basic laptop to a 64 GPU cluster, this is the\nhardware/ platform on which you perform your password hash attacks.\nEXPECTED RESULTS\nKnow your cracking rig’s capabilities by performing benchmark testing and\ndon’t assume you can achieve the same results posted by forum members\nwithout using the exact same dictionary, attack plan, or hardware setup.\nCracking success largely depends on your ability to use resources efficiently\nand make calculated trade-offs based on the target hash.\nDICTIONARY/WORDLIST vs BRUTE-FORCE vs ANALYSIS\nDictionaries and brute-force are not the end all be all to crack hashes. They\nare merely the beginning and end of an attack plan. True mastery is\neverything in the middle, where analysis of passwords, patterns, behaviors,\nand policies affords the ability to recover that last 20%. Experiment with your\nattacks and research and compile targeted wordlists with your new\nknowledge. Do not rely heavily on dictionaries because they can only help\nyou with what is “known” and not the unknown."
  },
  {
    "index": 6,
    "text": "CRACKING METHODOLOGY\nFollowing is basic cracking methodology broken into steps, but the process is\nsubject to change based on current/future target information uncovered\nduring the cracking process.\n1-EXTRACT HASHES\nPull hashes from target, identify hashing function, and properly format output\nfor your tool of choice.\n2-FORMAT HASHES\nFormat your hashes based on your tool’s preferred method. See tool\ndocumentation for this guidance. Hashcat, for example, on each line takes\n<user>:<hash> OR just the plain <hash>.\n3-EVALUATE HASH STRENGTH\nUsing the Appendix table “Hash Cracking Speed (Slow-Fast)” assess your\ntarget hash and it’s cracking speed. If it’s a slow hash, you will need to be\nmore selective at what types of dictionaries and attacks you perform. If it’s a\nfast hash, you can be more liberal with your attack strategy.\n4-CALCULATE CRACKING RIG CAPABILITIES\nWith the information from evaluating the hash strength, baseline your\ncracking rig’s capabilities. Perform benchmark testing using John The Ripper\nand/or Hashcat’s built-in benchmark ability on your rig.\njohn --test\nhashcat -b\nBased on these results you will be able to better assess your attack options by\nknowing your rigs capabilities against a specific hash. This will be a more\naccurate result of a hash’s cracking speed based on your rig. It will be useful\nto save these results for future reference.\n5-FORMULATE PLAN\nBased on known or unknown knowledge begin creating an attack plan.\nIncluded on the next page is a “Basic Cracking Playbook” to get you started.\n6-ANALYZE PASSWORDS\nAfter successfully cracking a sufficient amount of hashes analyze the results\nfor any clues or patterns. This analysis may aid in your success on any\nremaining hashes.\n7-CUSTOM ATTACKS\nBased on you password analysis create custom attacks leveraging those\nknown clues or patterns. Examples would be custom mask attacks or rules to\nfit target users’ behavior or preferences.\n8-ADVANCED ATTACKS\nExperiment with Princeprocessor, custom Markov-chains, maskprocessor, or\ncustom dictionary attacks to shake out those remaining stubborn hashes. This\nis where your expertise and creativity really come into play.\n9-REPEAT\nGo back to STEP 4 and continue the process over again, tweaking\ndictionaries, mask, parameters, and methods. You’re in the grind at this point\nand need to rely on skill and luck."
  },
  {
    "index": 7,
    "text": "BASIC CRACKING PLAYBOOK\nThis is only meant as a basic guide to processing hashes and each scenario\nwill obviously be unique based on external circumstances. For this attack\nplan we will assume we know the password hashes are raw MD5 and assume\nwe have already captured some plain text passwords of users. If we had no\nknowledge of plain text passwords we would most likely skip to\nDICTIONARY/WORDLIST attacks. Lastly, since MD5 is a “Fast” hash we\ncan be more liberal with our attack plan.\n1-CUSTOM WORDLIST\nFirst compile your known plain text passwords into a custom wordlist file.\nPass this to your tool of choice as a straight dictionary attack.\nhashcat -a 0 -m 0 -w 4 hash.txt custom_list.txt\n2-CUSTOM WORDLIST + RULES\nRun your custom wordlist with permutation rules to crack slight variations.\nhashcat -a 0 -m 0 -w 4 hash.txt custom_list.txt -r best64.rule --loopback\n3 -DICTIONARY/WORDLIST\nPerform a broad dictionary attack, looking for common passwords and leaked\npasswords in well known dictionaries/wordlists.\nhashcat -a 0 -m 0 -w 4 hash.txt dict.txt\n4-DICTIONARY/WORDLIST + RULES\nAdd rule permutations to the broad dictionary attack, looking for subtle\nchanges to common words/phrases and leaked passwords.\nhashcat -a 0 -m 0 -w 4 hash.txt dict.txt -r best64.rule --loopback\n5-CUSTOM WORDLIST + RULES\nAdd any newly discovered passwords to your custom wordlist and run an\nattack again with permutation rules, looking any other subtle variations.\nawk -F “:” ‘{print $2}’ hashcat.potfile >> custom_list.txt\nhashcat -a 0 -m 0 -w 4 hash.txt custom_list.txt -r dive.rule --loopback\n6-MASK\nNow we will use mask attacks included with Hashcat to search the keyspace\nfor common password lengths and patterns, based on the RockYou dataset.\nhashcat -a 3 -m 0 -w 4 hash.txt rockyou-1-60.hcmask\n7-HYBRID DICTIONARY + MASK\nUsing a dictionary of your choice, conduct hybrid attacks looking for larger\nvariations of common words or known passwords by appending/prepending\nmasks to those candidates.\nhashcat -a 6 -m 0 -w 4 hash.txt dict.txt rockyou-1-60.hcmask\nhashcat -a 7 -m 0 -w 4 hash.txt rockyou-1-60.hcmask dict.txt\n8-CUSTOM WORDLIST + RULES\nAdd any newly discovered passwords back to your custom wordlist and run\nan attack again with permutation rules looking any other subtle variations.\nawk -F “:” ‘{print $2}’ hashcat.potfile >> custom_list.txt\nhashcat -a 0 -m 0 -w 4 hash.txt custom_list.txt -r dive.rule --loopback\n9-COMBO\nUsing a dictionary of your choice, perform a combo attack by individually\ncombining the dictionary’s password candidates together to form new\ncandidates.\nhashcat -a 1 -m 0 -w 4 hash.txt dict.txt dict.txt\n10-CUSTOM HYBRID ATTACK\nAdd any newly discovered passwords back to your custom wordlist and\nperform a hybrid attack against those new acquired passwords.\nawk -F “:” ‘{print $2}’ hashcat.potfile >> custom_list.txt\nhashcat -a 6 -m 0 -w 4 hash. txt custom_list.txt rockyou-1-60.hcmask\nhashcat -a 7 -m 0 -w 4 hash. txt rockyou-1-60.hcmask custom_list.txt\n11-CUSTOM MASK ATTACK\nBy now the easier, weaker passwords may have fallen to cracking, but still\nsome remain. Using PACK (on pg.51) create custom mask attacks based on\nyour currently cracked passwords. Be sure to sort out masks that match the\nprevious rockyou-1-60.hcmask list.\nhashcat -a 3 -m 0 -w 4 hash.txt custom_masks.hcmask\n12-BRUTE-FORCE\nWhen all else fails begin a standard brute-force attack, being selective as to\nhow large a keyspace your rig can adequately brute-force. Above 8 characters\nthis is typically pointless due to hardware limitations and password entropy/\ncomplexity.\nhashcat -a 3 -m 0 -w 4 hash.txt -i ?a?a?a?a?a?a?a?a"
  },
  {
    "index": 8,
    "text": "JOHN THE RIPPER CHEAT SHEET\nATTACK MODES\nBRUTEFORCE ATTACK\njohn --format=#type hash. txt\nDICTIONARY ATTACK\njohn --format=#type --wordlist=dict.txt hash.txt\nMASK ATTACK\njohn --format=#type --mask=?l?l?l?l?l?l hash.txt -min-len=6\nINCREMENTAL ATTACK\njohn --incremental hash.txt\nDICTIONARY + RULES ATTACK\njohn --format=#type --wordlist=dict.txt --rules\nRULES\n--rules=Single\n--rules=Wordlist\n--rules=Extra\n--rules=Jumbo\n--rules=KoreLogic\n--rules=All\nINCREMENT\n--incremental=Digits\n--incremental=Lower\n--incremental=Alpha\n--incremental=Alnum\nPARALLEL CPU or GPU\nLIST OpenCL DEVICES\njohn --list=opencl-devices\nLIST OpenCL FORMATS\njohn --list=formats --format=opencl\nMULTI-GPU (example 3 GPU’s)\njohn --format=<OpenCLformat> hash.txt --wordlist=dict.txt --rules --\ndev=<#> --fork=3\nMULTI-CPU (example 8 cores)\njohn --wordlist=dict.txt hash.txt --rules --dev=<#> --fork=8\nMISC\nBENCHMARK TEST\njohn --test\nSESSION NAME\njohn hash.txt --session=example_name\nSESSION RESTORE\njohn --restore=example_name\nSHOW CRACKED RESULTS\njohn hash.txt --pot=<john potfile> --show\nWORDLIST GENERATION\njohn --wordlist=dict.txt --stdout --external:[filter name] > out.txt\nBASIC ATTACK METHODOLOGY\n1- DEFAULT ATTACK\njohn hash.txt\n2- DICTIONARY + RULES ATTACK\njohn --wordlist=dict.txt --rules\n3- MASK ATTACK\njohn --mask=?l?l?l?l?l?l hash.txt -min-len=6\n4- BRUTEFORCE INCREMENTAL ATTACK\njohn --incremental hash.txt\nHASHCAT CHEAT SHEET\nATTACK MODES\nDICTIONARY ATTACK\nhashcat -a 0 -m #type hash.txt dict.txt\nDICTIONARY + RULES ATTACK\nhashcat -a 0 -m #type hash.txt dict.txt -r rule.txt\nCOMBINATION ATTACK\nhashcat -a 1 -m #type hash.txt dict1.txt dict2.txt\nMASK ATTACK\nhashcat -a 3 -m #type hash.txt ?a?a?a?a?a?a\nHYBRID DICTIONARY + MASK\nhashcat -a 6 -m #type hash.txt dict.txt ?a?a?a?a\nHYBRID MASK + DICTIONARY\nhashcat -a 7 -m #type hash.txt ?a?a?a?a dict.txt\nRULES\nRULEFILE -r\nhashcat -a 0 -m #type hash.txt dict.txt -r rule.txt\nMANIPULATE LEFT -j\nhashcat -a 1 -m #type hash.txt left_dict.txt right_dict.txt -j <option>\nMANIPULATE RIGHT -k\nhashcat -a 1 -m #type hash.txt left_dict.txt right_dict.txt -k <option>\nINCREMENT\nDEFAULT INCREMENT\nhashcat -a 3 -m #type hash.txt ?a?a?a?a?a --increment\nINCREMENT MINIMUM LENGTH\nhashcat -a 3 -m #type hash.txt ?a?a?a?a?a --increment-min=4\nINCREMENT MAX LENGTH\nhashcat -a 3 -m #type hash.txt ?a?a?a?a?a?a --increment-max=5\nMISC\nBENCHMARK TEST (HASH TYPE)\nhashcat -b -m #type\nSHOW EXAMPLE HASH\nhashcat -m #type --example-hashes\nDISABLE PASSWORD LENGTH LIMIT (Max Length 256)\nhashcat -a 0 -m #type --length-limit-disable hash.txt dict.txt\nSESSION NAME\nhashcat -a 0 -m #type --session <uniq_name> hash.txt dict.txt\nSESSION RESTORE\nhashcat -a 0 -m #type --restore --session <uniq_name> hash.txt dict.txt\nSHOW KEYSPACE\nhashcat -a 0 -m #type --keyspace hash.txt dict.txt -r rule.txt\nOUTPUT RESULTS FILE -o\nhashcat -a 0 -m #type -o results.txt hash.txt dict.txt\nCUSTOM CHARSET -1 -2 -3 -4\nhashcat -a 3 -m #type hash.txt -1 ?l?u -2 ?l?d?s ?l?2?a?d?u?l\nADJUST PERFORMANCE -w\nhashcat -a 0 -m #type -w <1-4> hash.txt dict.txt\nBASIC ATTACK METHODOLOGY\n1- DICTIONARY ATTACK\nhashcat -a 0 -m #type hash.txt dict.txt\n2- DICTIONARY + RULES\nhashcat -a 0 -m #type hash.txt dict.txt -r rule.txt\n3- HYBRID ATTACKS\nhashcat -a 6 -m #type hash.txt dict.txt ?a?a?a?a\n4- BRUTEFORCE\nhashcat -a 3 -m #type hash.txt ?a?a?a?a?a?a?a?a\nHASH TYPES (SORTED ALPHABETICAL)\n6600 1Password, agilekeychain\n8200 1Password, cloudkeychain\n14100 3DES (PT = $salt, key = $pass)\n11600 7-Zip\n6300 AIX {smd5}\n6400 AIX {ssha256}\n6500 AIX {ssha512}\n6700 AIX {ssha1}\n5800 Android PIN\n8800 Android FDE < v4.3\n12900 Android FDE (Samsung DEK)\n1600 Apache $apr1$\n125 ArubaOS\n12001 Atlassian (PBKDF2-HMAC-SHA1)\n13200 AxCrypt\n13300 AxCrypt in memory SHA1\n3200 bcrypt $2*$, Blowfish(Unix)\n600 BLAKE2-512\n12400 BSDiCrypt, Extended DES\n11300 Bitcoin/Litecoin wallet.dat\n12700 Blockchain, My Wallet\n15200 Blockchain, My Wallet, V2\n15400 ChaCha20\n2410 Cisco-ASA\n500 Cisco-IOS $1$\n5700 Cisco-IOS $4$\n9200 Cisco-IOS $8$\n9300 Cisco-IOS $9$\n2400 Cisco-PIX\n8100 Citrix Netscaler\n12600 ColdFusion 10+\n10200 Cram MD5\n11500 CRC32\n14000 DES (PT = $salt, key = $pass)\n1500 descrypt, DES(Unix), Traditional DES\n8300 DNSSEC (NSEC3)\n124 Django (SHA-1)\n10000 Django (PBKDF2-SHA256)\n1100 Domain Cached Credentials (DCC), MS Cache\n2100 Domain Cached Credentials 2 (DCC2), MS Cache 2\n15300 DPAPI masterkey file v1 and v2\n7900 Drupal7\n12200 eCryptfs\n141 EPiServer 6.x < v4\n1441 EPiServer 6.x > v4\n15600 Ethereum Wallet, PBKDF2-HMAC-SHA256\n15700 Ethereum Wallet, PBKDF2-SCRYPT\n15000 FileZilla Server >= 0.9.55\n7000 Fortigate (FortiOS)\n6900 GOST R 34.11-94\n11700 GOST R 34.11-2012 (Streebog) 256-bit\n11800 GOST R 34.11-2012 (Streebog) 512-bit\n7200 GRUB 2\n50 HMAC-MD5 (key = $pass)\n60 HMAC-MD5 (key = $salt)\n150 HMAC-SHA1 (key = $pass)\n160 HMAC-SHA1 (key = $salt)\n1450 HMAC-SHA256 (key = $pass)\n1460 HMAC-SHA256 (key = $salt)\n1750 HMAC-SHA512 (key = $pass)\n1760 HMAC-SHA512 (key = $salt)\n5100 Half MD5\n5300 IKE-PSK MD 5\n5400 IKE-PSK SHA1\n2811 IPB (Invison Power Board)\n7300 IPMI2 RAKP HMAC-SHA1\n14700 iTunes Backup < 10.0\n14800 iTunes Backup >= 10.0\n4800 iSCSI CHAP authentication, MD5(Chap)\n15500 JKS Java Key Store Private Keys (SHA1)\n11 Joomla < 2.5.18\n400 Joomla > 2.5.18\n15100 Juniper/NetBSD sha1crypt\n22 Juniper Netscreen/SSG (ScreenOS)\n501 Juniper IVE\n13400 Keepass 1 (AES/Twofish) and Keepass 2 (AES)\n7500 Kerberos 5 AS-REQ Pre-Auth etype 23\n13100 Kerberos 5 TGS-REP etype 23\n6800 Lastpass + Lastpass sniffed\n3000 LM\n8600 Lotus Notes/Domino 5\n8700 Lotus Notes/Domino 6\n9100 Lotus Notes/Domino 8\n14600 LUKS\n900 MD4\n0 MD5\n10 md5($pass.$salt)\n20 md5($salt.$pass)\n30 md5(unicode($pass).$salt)\n40 md5($salt.unicode($pass))\n3710 md5($salt.md5($pass))\n3800 md5($salt.$pass.$salt)\n3910 md5(md5($pass).md5($salt))\n4010 md5($salt.md5($salt.$pass))\n4110 md5($salt.md5($pass.$salt))\n2600 md5(md5($pass))\n4400 md5(sha1($pass))\n4300 md5(strtoupper(md5($pass)))\n500 md5crypt $1$, MD5(Unix)\n9400 MS Office 2007\n9500 MS Office 2010\n9600 MS Office 2013\n9700 MS Office <= 2003 $0\n9710 MS Office <= 2003 $0\n9720 MS Office <= 2003 $0\n9800 MS Office <= 2003 $3\n9810 MS Office <= 2003 $3\n9820 MS Office <= 2003 $3\n12800 MS-AzureSync PBKDF2-HMAC-SHA256\n131 MSSQL(2000)\n132 MSSQL(2005)\n1731 MSSQL(2012)\n1731 MSSQL(2014)\n3711 Mediawiki B type\n2811 MyBB\n11200 MySQL CRAM (SHA1)\n200 MySQL323\n300 MySQL4.1/MySQL5\n1000 NTLM\n5500 NetNTLMv1\n5500 NetNTLMv1 + ESS\n5600 NetNTLMv2\n101 nsldap, SHA-1(Base64), Netscape LDAP SHA\n111 nsldaps, SSHA-1(Base64), Netscape LDAP SSHA\n13900 OpenCart\n21 osCommerce\n122 OSX V10.4, OSX V10.5, OSX V10.6\n1722 OSX V10.7\n7100 OSX V10.8, OSX V10.9, OSX v10.10\n112 Oracle S: Type (Oracle 11+)\n3100 Oracle H: Type (Oracle 7+)\n12300 Oracle T: Type (Oracle 12+)\n11900 PBKDF2-HMAC-MD5\n12000 PBKDF2-HMAC-SHA1\n10900 PBKDF2-HMAC-SHA256\n12100 PBKDF2-HMAC-SHA512\n10400 PDF 1.1 - 1.3 (Acrobat 2 - 4)\n10410 PDF 1.1 - 1.3 (Acrobat 2 - 4), collider #1\n10420 PDF 1.1 - 1.3 (Acrobat 2 - 4), collider #2\n10500 PDF 1.4 - 1.6 (Acrobat 5 - 8)\n10600 PDF 1.7 Level 3 (Acrobat 9)\n10700 PDF 1.7 Level 8 (Acrobat 10 - 11)\n400 phpBB3\n400 phpass\n2612 PHPS\n5200 Password Safe v3\n9000 Password Safe v2\n133 PeopleSoft\n13500 PeopleSoft Token\n99999 Plaintext\n12 PostgreSQL\n11100 PostgreSQL CRAM (MD5)\n11000 PrestaShop\n4522 PunBB\n8500 RACF\n12500 RAR3-hp\n13000 RAR5\n9900 Radmin2\n7600 Redmine\n6000 RipeMD160\n7700 SAP CODVN B (BCODE)\n7800 SAP CODVN F/G (PASSCODE)\n10300 SAP CODVN H (PWDSALTEDHASH) iSSHA-1\n8900 scrypt\n1300 SHA-224\n1400 SHA-256\n1411 SSHA-256(Base64), LDAP {SSHA256}\n5000 SHA-3(Keccak)\n10800 SHA-384\n1700 SHA-512\n100 SHA1\n14400 SHA1(CX)\n110 sha1($pass.$salt)\n120 sha1($salt.$pass)\n130 sha1(unicode($pass).$salt)\n140 sha1($salt.unicode($pass))\n4500 sha1(sha1($pass))\n4520 sha1($salt.sha1($pass))\n4700 sha1(md5($pass))\n4900 sha1($salt.$pass.$salt)\n1410 sha256($pass.$salt)\n1420 sha256($salt.$pass)\n1440 sha256($salt.unicode($pass))\n1430 sha256(unicode($pass).$salt)\n7400 sha256crypt $5$, SHA256(Unix)\n1710 sha512($pass.$salt)\n1720 sha512($salt.$pass)\n1740 sha512($salt.unicode($pass))\n1730 sha512(unicode($pass).$salt)\n1800 sha512crypt $6$, SHA512(Unix)\n11400 SIP digest authentication (MD5)\n121 SMF (Simple Machines Forum)\n1711 SSHA-512(Base64), LDAP {SSHA512}\n10100 SipHash\n14900 Skip32\n23 Skype\n8000 Sybase ASE\n62XY TrueCrypt\nX 1 = PBKDF2-HMAC-RipeMD160\nX 2 = PBKDF2-HMAC-SHA512\nX 3 = PBKDF2-HMAC-Whirlpool\nX 4 = PBKDF2-HMAC-RipeMD160 + boot-mode\nY 1 = XTS 512 bit pure AES\nY 1 = XTS 512 bit pure Serpent\nY 1 = XTS 512 bit pure Twofish\nY 2 = XTS 1024 bit pure AES\nY 2 = XTS 1024 bit pure Serpent\nY 2 = XTS 1024 bit pure Twofish\nY 2 = XTS 1024 bit cascaded AES-Twofish\nY 2 = XTS 1024 bit cascaded Serpent-AES\nY 2 = XTS 1024 bit cascaded Twofish-Serpent\nY 3 = XTS 1536 bit all\n2611 vBulletin < V3.8.5\n2711 vBulletin > V3.8.5\n137XY VeraCrypt\nX 1 = PBKDF2-HMAC-RipeMD160\nX 2 = PBKDF2-HMAC-SHA512\nX 3 = PBKDF2-HMAC-Whirlpool\nX 4 = PBKDF2-HMAC-RipeMD160 + boot-mode\nX 5 = PBKDF2-HMAC-SHA256\nX 6 = PBKDF2-HMAC-SHA256 + boot-mode\nY 1 = XTS 512 bit pure AES\nY 1 = XTS 512 bit pure Serpent\nY 1 = XTS 512 bit pure Twofish\nY 2 = XTS 1024 bit pure AES\nY 2 = XTS 1024 bit pure Serpent\nY 2 = XTS 1024 bit pure Twofish\nY 2 = XTS 1024 bit cascaded AES-Twofish\nY 2 = XTS 1024 bit cascaded Serpent-AES\nY 2 = XTS 1024 bit cascaded Twofish-Serpent\nY 3 = XTS 1536 bit all\n8400 WBB3 (Woltlab Burning Board)\n2500 WPA/WPA2\n2501 WPA/WPA2 PMK\n6100 Whirlpool\n13600 WinZip\n13800 Windows 8+ phone PIN/Password\n400 Wordpress\n21 xt:Commerce\nTERMINAL COMMAND CHEAT SHEET\nCtrl + u\ndelete everything from the cursor to the beginning of the line\nCtrl + w\ndelete the previous word on the command line before the cursor\nCtrl + l\nclear the terminal window\nCtrl + a\njump to the beginning of the command line\nCtrl + e\nmove your cursor to the end of the command line\nCtrl + r\nsearch command history in reverse, continue pressing key\nsequence to continue backwards search. Esc when done or\ncommand found.\nFILE MANIPULATION CHEAT SHEET\nExtract all lowercase strings from each line and output to wordlist.\nsed ’s/[^a-z]*//g’ wordlist.txt > outfile.txt\nExtract all uppercase strings from each line and output to wordlist.\nsed ’s/[^A-Z]*//g’ wordlist.txt > outfile.txt\nExtract all lowercase/uppercase strings from each line and output to wordlist.\nsed ’s/[^a-Z]*//g’ wordlist.txt > outfile.txt\nExtract all digits from each line in file and output to wordlist.\nsed ’s/[^0-9]*//g’ wordlist.txt > outfile.txt\nWatch hashcat potfile or designated output file live.\nwatch -n .5 tail -50 <hashcat.potfile or outfile.txt>\nPull 100 random samples from wordlist/passwords for visual analysis.\nshuf -n 100 file.txt\nPrint statistics on length of each string and total counts per length.\nawk ‘{print length}’ file.txt | sort -n | uniq -c\nRemove all duplicate strings and count how many times they are present;\nthen sort by their count in descending order.\nuniq -c file.txt | sort -nr\nCommand to create quick & dirty custom wordlist with length 1-15 character\nwords from a designated website into a sorted and counted list.\ncurl -s http://www.netmux.com | sed -e 's/<[^>]*>//g' | tr \" \"\n\"\\n\" | tr -dc '[:alnum:]\\n\\r' | tr ‘[:upper:]’ ‘[:lower:]’ | cut -c 1-\n15 | sort | uniq -c | sort -nr\nMD5 each line in a file (Mac OSX).\nwhile read line; do echo -n $line | md5; done < infile.txt > outfile.txt\nMD5 each line in a file (*Nix).\nwhile read line; do echo -n $line | md5sum; done < infile.txt | awk -F “ “\n‘{print $1}’ > outfile.txt\nRemove lines that match from each file and only print remaining from\nfile2.txt.\ngrep -vwF -f file1.txt file2.txt\nTake two ordered files, merge and remove duplicate lines and maintain\nordering.\nnl -ba -s ‘: ‘ file1.txt >> outfile.txt\nnl -ba -s ‘: ‘ file2.txt >> outfile.txt\nsort -n outfile.txt | awk -F “:” ‘{print $2}’ | awk ‘!seen[$0]++’ > final.txt\nExtract strings of a specific length into a new file/wordlist.\nawk ‘length == 8’ file.txt > 81en-out.txt\nConvert alpha characters on each line in file to lowercase characters.\ntr [A-Z] [a-z] < infile.txt > outfile.txt\nConvert alpha characters on each line in file to uppercase characters.\ntr [a-z] [A-Z] < infile.txt > outfile.txt\nSplit a file into separate files by X number of lines per outfile.\nsplit -d -l 3000 infile.txt outfile.txt\nReverse the order of each character of each line in the file.\nrev infile.txt > outfile.txt\nSort each line in the file from shortest to longest.\nawk ‘{print length,$0}’ “” $0; }’ infile.txt | sort -n | cut -d ‘ ‘ -f2-\nSort each line in the file from longest to shortest.\nawk ‘{print length,$0}’ “” $0; }’ infile.txt | sort -r -n | cut -d ‘ ‘ -f2-\nSubstring matching by converting to HEX and then back to ASCII.\n(Example searches for 5 character strings from file1.txt found as a substring\nin 20 character strings in file2.txt)\nstrings file1.txt | xxd -u -ps -c 5 | sort -u > out1.txt\nstrings file2.txt | xxd -u -ps -c 20 | sort -u > out2.txt\ngrep -Ff out1.txt out2.txt | xxd -r -p > results.txt\nClean dictionary/wordlist of newlines and tabs.\ncat dict.txt | tr -cd “[:print :][/n/t]\\n” > outfile.txt"
  },
  {
    "index": 9,
    "text": "SYSTEM HASH EXTRACTION\nWINDOWS\nMETERPRETER HASHDUMP\nPost exploitation dump local SAM database:\nmeterpreter> run post/windows/gather/hashdump\nCREDDUMP\nhttps://github.com/Neohapsis/creddump7\nThree modes of attack: cachedump, lsadump, pwdump\nDUMP DOMAIN CACHED CREDENTIALS\nSave Windows XP/Vista/7 registry hive tables\nC:\\WIND0WS\\system32>reg.exe save HKLM\\SAM sam_backup.hiv\nC:\\WIND0WS\\system32>reg.exe save HKLM\\SECURITY\nsec_backup.hiv\nC:\\WIND0WS\\system32>reg.exe save HKLM\\system sys_backup.hiv\nRun creddump tools against the saved hive files:\ncachedump.py <system hive> <security hive> <Vista/7>\n(Vista/7)\ncachedump.py sys_backup.hiv sec_backup.hiv true\n(XP)\ncachedump.py sys_backup.hiv sec_backup.hiv false\nDUMP LSA SECRETS\nlsadump.py sys_backup.hiv sec_backup.hiv\nDUMP LOCAL PASSWORD HASHES\npwdump.py sys_backup.hiv sec_backup.hiv\nMIMIKATZ\nPost exploitation commands must be executed from SYSTEM level\nprivileges.\nmimikatz # privilege::debug\nmimikatz # token::whoami\nmimikatz # token::elevate\nmimikatz # lsadump::sam\nSave Windows XP/Vista/7 registry tables\nC:\\WIND0WS\\system32>reg.exe save HKLM\\SAM sam_backup.hiv\nC:\\WIND0WS\\system32>reg.exe save HKLM\\SECURITY\nC:\\WIND0WS\\system32>reg.exe save HKLM\\system\nmimikatz # lsadump::sam SystemBkup.hiv SamBkup.hiv\n*NIX\nRequires root level privileges.\ncat /etc/shadow\nExample *NIX sha512crypt hash\nroot:$6$52450745$k5ka2p8bFuSmoVTltz0yyuaREkkKBcCNqoDKzYiDL9RaE8yMnPgh2XzzF0NDrUhgrcLwg78xslw5pJiypEdFX\nMAC OSX 10.5-10.7\nManual OSX Hash Extraction\ndscl localhost -read /Search/Users/<username>|grep GeneratedUID|cut -\nc15-cat /var/db/shadow/hash/<GUID> | cut -c169-216 > osx_hash.txt\nMAC OSX 10.8-10.12\nManual OSX Hash Extraction\nsudo defaults read /var/db/dslocal/nodes/Default/users/<username>.plist\nShadowHashData|tr -dc ‘ 0-9a-f’|xxd -p -r|plutil -convert xml1 - -o -\nScripted OSX Hash Extraction\nHASHCAT\nhttps://gist.github.com/nueh/8252572\nsudo plist2hashcat.py\n/var/db/dslocal/nodes/Default/users/<username>.plist\nJOHN\nhttps://github.com/truongkma/ctf-tools/blob/master/John/run/ml2john.py\nsudo ml2john.py /var/db/dslocal/nodes/Default/users/<username>.plist\nPCAP HASH EXTRACTION\nLOCAL NETWORK AUTHENTICATION\nPCREDZ\nExtracts network authentication hashes from pcaps.\nSingle pcap file:\nPcredz -f example.pcap\nMultiple pcap files in a directory:\nPcredz -d /path/to/pcaps\nInterface to listen on and collect:\nPcredz -i eth0\nWPA/WPA2 PSK AUTHENTICATION\nCapture the 4-way WPA/WPA2 authentication handshake.\nAIRMON-NG / AIRODUMP-NG / AIREPLAY-NG\nStep 1: Create monitoring interface mon0 Ex) interface wlan0\nairmon-ng start wlan0\nStep 2: Capture packets to file on target AP channel Ex) channel 11\nairodump-ng mon0 --write capture.cap -c 11\nStep 3: Start deauth attack against BSSID Ex) bb:bb:bb:bb:bb:bb\naireplay-ng --deauth 0 -a bb:bb:bb:bb:bb:bb mon0\nStep 4: Wait for confirmation to appear at top of terminal:\nCH 11 ][ Elapsed: 25 s ][ <DATE / TIME) ][ WPA handshake: **\nStep 5: Extract handshake into JOHN or HASHCAT format:\nJOHN FORMAT EXTRACT\nStepl: cap2hccap.bin -e ‘<ESSID>’ capture.cap capture_out.hccap\nStep2: hccap2john capture_out.hccap > jtr_capture\nHASHCAT FORMAT EXTRACT\ncap2hccapx.bin capture.cap capture_out.hccapx\nMISC WLAN TOOLS\nHCXTOOLS: capture and convert packets from wlan devices for use with\nHashcat.\nhttps://github.com/ZerBea/hcxtools\nDATABASE HASH EXTRACTION\nSQL queries require administrative privileges.\nORACLE 10g R2\nSELECT username, password FROM dba_users WHERE\nusername=‘<username>’;\nORACLE 11g R1\nSELECT name, password, spare4 FROM sys.user$ WHERE\nname=‘<username>’;\nMySQL4.1 / MySQL5+\nSELECT User, Password FROM mysql.user INTO OUTFILE\n‘/tmp/hash.txt’ ;\nMSSQL(2012), MSSQL(2014)\nSELECT SL.name,SL.password_hash FROM sys.sql_logins AS SL;\nPOSTGRES\nSELECT username, passwd FROM pg_shadow;\nMISCELLANEOUS HASH EXTRACTION\nJohn The Ripper Jumbo comes with various programs to extract hashes:\nNAME DESCRIPTION\n1password2john.py 1Password vault hash extract\n7z2john.py 7zip encrypted archive hash extract\nandroidfde2john.py Android FDE convert disks/images into JTR\nformat\naix2john.py AIX shadow file /etc/security/passwd\napex2john.py Oracle APEX hash formating\nbitcoin2john.py Bitcoin old wallet hash extraction (check\nbtcrecover)\nblockchain2john.py Blockchain wallet extraction\ncisco2john.pl Cisco config file ingestion/ extract\ncracf2john.py CRACF program crafc.txt files\ndmg2john.py Apple encrypted disk image\necryptfs2john.py eCryptfs disk encryption software\nefs2john.py Windows Encrypting File System (EFS) extract\nencfs2john.py EncFS encrypted filesystem userspace\ngpg2john PGP symmetrically encrypted files\nhccap2john Convert pcap capture WPA file to JTR format\nhtdigest2john.py HTTP Digest authentication\nikescan2john.py IKE PSK SHA256 authentication\nkdcdump2john.py Key Distribution Center (KDC) servers\nkeepass2john Keepass file hash extract\nkeychain2john.py Processes input Mac OS X keychain files\nkeyring2john Processes input GNOME Keyring files\nkeystore2john.py Output password protected Java KeyStore files\nknown_hosts2john.py SSH Known Host file\nkwallet2john.py KDE Wallet Manager tool to manage the\npasswords\nldif2john.pl LDAP Data Interchange Format (LDIF)\nlion2john.pl Converts an Apple OS X Lion plist file\nlion2john-alt.pl\nlotus2john.py Lotus Notes ID file for Domino\nluks2john Linux Unified Key Setup (LUKS) disk\nencryption\nmcafee_epo2john.py McAfee ePolicy Orchestrator password\ngenerator\nml2john.py Convert Mac OS X 10.8 and later plist hash\nmozilla2john.py Mozilla Firefox, Thunderbird, SeaMonkey\nextract\nodf2john.py Processes OpenDocument Format ODF files\noffice2john.py Microsoft Office [97-03, 2007, 2010, 2013)\nhashes\nopenbsd_softraid2john.py OpenBSD SoftRAID hash\nopenssl2john.py OpenSSL encrypted files\npcap2john.py PCAP extraction of various protocols\npdf2john.py PDF encrypted document hash extract\npfx2john PKCS12 files\nputty2john PuTTY private key format\npwsafe2john Password Safe hash extract\nracf2john IBM RACF binary database files\nradius2john.pl RADIUS protocol shared secret\nrar2john RAR 3.x files input into proper format\nsap2john.pl Converts password hashes from SAP systems\nsipdump2john.py Processes sipdump output files into JTR format\nssh2john SSH private key files\nsshng2john.py SSH-ng private key files\nstrip 2john.py Processes STRIP Password Manager database\nsxc2john.py Processes SXC files\ntruecrypt_volume2john TrueCrypt encrypted disk volume\nuaf2john Convert OpenVMS SYSUAF file to unix-style\nfile\nvncpcap2john TightVNC/RealVNCpcapsvs c3.3, 3.7 and 3.8\nRFB\nwpapcap2john Converts PCAP or IVS2 files to JtR format\nzip2john Processes ZIP files extracts hash into JTR format"
  },
  {
    "index": 10,
    "text": "PASSWORD ANALYSIS\nHISTORICAL PASSWORD ANALYSIS TIPS\n-The average password length is 7-9 characters.\n-The average English word is 5 characters long.\n-The average person knows 50,000 to 150,000 words.\n-50% chance a user’s password will contain one or more vowels.\n-Women prefer personal names in their passwords, and men prefer hobbies.\n-Most likely to be used symbols: ~, !, @, #, $, %, &, *, and ?\n-If a number, it’s usually a 1 or 2, sequential, and will likely be at the end.\n-If more than one number it will usually be sequential or personally relevant.\n-If a capital letter, it’s usually the beginning, followed by a vowel.\n-66% of people only use 1 - 3 passwords for all online accounts.\n-One in nine people have a password based on the common Top 500 list.\n-Western countries use lowercase passwords and Eastern countries prefer\ndigits.\n20-60-20 RULE\n20-60-20 rule is a way to view the level of difficulty typically demonstrated\nby a large password dump, having characteristics that generally err on the\nside of a Gaussian Curve, mirroring the level of effort to recover said\npassword dump.\n20% of passwords are easily guessed dictionary words or known common\npasswords.\n60% of passwords are moderate to slight variations of the earlier 20%.\n20% of passwords are hard, lengthy, complex, or of unique characteristics.\nEXAMPLE HASHES & PASSWORDS\nThis is an example list of passwords to help convey the variation and\ncommon complexities seen with typical password creation. It also shows\nindividual user biases to aid in segmenting your attacks to be tailored toward\na specific user.\nCRACKING TIPS FOR EACH PASSWORD\n*This List of passwords will be referenced throughout the book and the List\ncan also be found online at: https://github.com/netmux/HASH-CRACK\nPASSWORD PATTERN ANALYSIS\nA password can contain many useful bits of information related to it’s creator\nand their tendencies/patterns, but you have to break down the structure to\ndecipher the meaning. This analysis process could be considered a sub-\ncategory of Text Analytics’ and split into three pattern categories I’m calling:\nBasic Pattern, Macro-Pattern, & Micro-Pattern.\n*Refer to EXAMPLE HASH & PASSWORDS chapter (pg.29) for numbered\nexamples.\nBasic Pattern : visually obvious when compared to similar groupings (i.e.\nlanguage and base word/words & digits). Let’s look at Alice’s passwords\n(2,5):\nR0b3 rt2017! Jennifer1981!\n-Each password uses a name: R0b3rt & Jennifer\n-Ending in a 4 digit date with common special character: 2017! & 1981!\n!TIP! This type of basic pattern lends itself to a simple dictionary and L33T\nspeak rule appending dates or hybrid mask attack appending Dict+ ?d?d?d?d?\ns\nMacro-Pattern : statistics about the passwords underlying structure such as\nlength and character set. Let’s look at Craig’s passwords (6,9):\n7482Sacrifice Solitaire7482\n-Length structure can be summed up as: 4 Digits + 7 Alpha & 7 Alpha + 4\nDigits\n-Uses charsets ?l?u?d , so we may be able to ignore special characters.\n-Basic Pattern preference for the numbers 7482 and Micro-Pattern for\ncapitalizing words beginning in “S”.\n!TIP! You can assume this user is ‘unlikely’ to have a password less than 12\ncharacters (+-1 char) and the 4 digit constant lowers the work to 8 chars.\nThese examples lend themselves to a Hybrid Attack (Dict + 7482) or (7482 +\nDict).\nMicro-Pattern : subtlety and context which expresses consistent case\nchanges, themes, and personal data/interest. Let’s look at Bob’s passwords\n(1,4)\nBlueParrot345 RedFerret789\n-Each password begins with a color: Blue & Red\n-Second word is a type of animal: Parrot & Ferret\n-Consistent capitalization of all words\n-Lastly, ending in a 3 digit sequential pattern: 345 & 789\n!TIP! This pattern lends itself to a custom combo dictionary and rule or\nhybrid mask attack appending sequential digits ?d?d?d\nSo when analyzing passwords be sure to group passwords and look for\npatterns such as language, base word/digit, length, character sets, and subtle\nthemes with possible contextual meaning or password policy restrictions.\nWESTERN COUNTRY PASSWORD ANALYSIS\nPassword Length Distribution based on large corpus of English website\ndumps:\n7=15% 8=27% 9=15% 10=12% 11=4.8% 12=4.9% 13=.6%\nCharacter frequency analysis of a large corpus of English texts:\netaoinshrdlcumwfgypbvkjxqz\nCharacter frequency analysis of a large corpus of English password dumps:\naeionrlstmcdyhubkgpjvfwzxq\nTop Western password masks out of a large corpus of English website\ndumps:\nEASTERN COUNTRY PASSWORD ANALYSIS\nPassword Length Distribution based on large corpus of Chinese website\ndumps:\n7=21% 8=22% 9=12% 10=12% 11=4.2% 12=.9% 13=.5%\nCharacter frequency analysis of a large corpus of Chinese texts:\naineohglwuyszxqcdjmbtfrkpv\nCharacter frequency analysis of a large corpus of Chinese password dumps:\ninauhegoyszdjmxwqbctlpfrkv\nTop Eastern password masks out of a large corpus of Chinese website dumps:\nPASSWORD MANAGER ANALYSIS\nApple Safari Password Generator\n-default password 15 characters with “-” & four groups of three random\nu=ABCDEFGHJKLMNPQRSTUVWXYZ l=abcdefghkmnopqrstuvwxy and\nd=3456789\nExample) X9z-2Qp-3qm-WGN\nXXX-XXX-XXX-XXX where X = ?u?l?d\nDashlane\n-default password 12 characters using just letters and digits.\nExample) Up0k9ZAj54Kt\nXXXXXXXXXXXX where X = ?u?l?d\nKeePass\n-default password 20 characters using uppercase, lowercase, digits, and\nspecial.\nExample) $Zt={EcgQ.Umf)R,C7XF\nXXXXXXXXXXXXXXXXXXXX where X = ?u?l?d?s\nLastPass\n-default password 12 characters using at least one digit, uppercase and\nlowercase.\nExample) msfNdkG29n38\nXXXXXXXXXXXX where X = ?u?l?d\nRoboForm\n-default password 15 characters using uppercase, lowercase, digits, and\nspecial with a minimum of 5 digits.\nExample) 871v2%%4F0w31zJ\nXXXXXXXXXXXXXXX where X = ?u?l?d?s\nSymantec Norton Identity Safe\n-default password 8 characters using uppercase, lowercase, and digits.\nExample) Ws81f0Zg\nXXXXXXXX where X = ?u?l?d\nTrue Key\n-default password 16 characters using uppercase, lowercase, digits, and\nspecial.\nExample) 1B1H:9N+@>+sgWs\nXXXXXXXXXXXXXXXX where X = ?u?l?d?s\n1Password v6\n-default password 24 characters using uppercase, lowercase, digits, and\nspecial.\nExample) cTmM7Tzm6iPhCdpMu. * V ] , VP\nXXXXXXXXXXXXXXXXXXXXXXXX where X = ?u?l?d?s\nPACK (Password Analysis and Cracking Kit)\nhttp://thesprawl.org/projects/pack/\nSTATSGEN\nGenerate statistics about the most common length, percentages, character-set\nand other characteristics of passwords from a provided list.\npython statsgen.py passwords.txt\nSTATSGEN OPTIONS\n-o <file.txt> output stats and masks to file\n--hiderare hide stats of passwords with less than 1% of\noccurrence\n--minlength= minimum password length for analysis\n--maxlength= maximum password length for analysis\n--charset= password char filter: loweralpha, upperalpha,\nnumeric, special\n--simplemask= password mask filter: string, digit, special\nSTATSGEN EXAMPLES\nOutput stats of passwords.txt to file example.mask:\npython statsgen.py passwords.txt -o example.mask\nHide less than 1% occurrence; only analyze passwords 7 characters and\ngreater:\npython statsgen.py passwords.txt --hiderare --minlength=7 -o example.mask\nStats on passwords with only numeric characters:\npython statsgen.py passwords.txt --charset=numeric\nZXCVBN (LOW-BUDGET PASSWORD STRENGTH\nESTIMATION)\nA realistic password strength (entropy) estimator developed by Dropbox.\nhttps://github.com/dropbox/zxcvbn\nPIPAL (THE PASSWORD ANALYSER)\nPassword analyzer that produces stats and pattern frequency analysis.\nhttps://digi.ninja/projects/pipal.php\npipal.rb -o outfile.txt passwords.txt\nPASSPAT (PASSWORD PATTERN IDENTIFIER)\nKeyboard pattern analysis tool for passwords.\nhttps://digi.ninja/projects/passpat.php\npasspat.rb --layout us passwords.txt\nCHARACTER FREQUENCY ANALYSIS\nCharacter frequency analysis is the study of the frequency of letters or groups\nof letters in a corpus/text. This is the basic building block of Markov chains.\nCharacter-Frequency-CLI-Tool\nTool to analyze a large list of passwords and summarize the character\nfrequency. https://github.com/jcchurch/Character-Frequency-CLI-Tool\ncharfreq.py <options> passwords.txt\nOptions: -w Window size to analyze, default=l\n-r Rolling window size\n-s Skip spaces, tabs, newlines\nONLINE PASSWORD ANALYSIS RESOURCES\nWEAKPASS\nAnalyzes public password dumps and provides efficient dictionaries for\ndownload.\nhttp://weakpass.com/\nPASSWORD RESEARCH\nImportant password security and authentication research papers in one place.\nhttp://www.passwordresearch.com/\nTHE PASSWORD PROJECT\nCompiled analysis of larger password dumps using PIPAL and PASSPAL\ntools.\nhttp://www.thepasswordproject.com/leaked_password_lists_and_dictionaries"
  },
  {
    "index": 11,
    "text": "DICTIONARY / WORDLIST\nDOWNLOAD RESOURCES\nWEAKPASS\nhttp://weakpass.com/wordlist\nCRACKSTATION DICTIONARY\nhttps://crackstation.net/buy-crackstation-wordlist-password-cracking-\ndictionary.htm\nHAVE I BEEN PWNED\n*You’ll have to crack the SHA1’s\nhttps://haveibeenpwned.com/passwords\nSKULL SECURITY WORDLISTS\nhttps://wiki.skullsecurity.org/index.php?title=Passwords\nCAPSOP\nhttps://wordlists.capsop.com/\nUNIX-NINJA DNA DICTIONARY\n*Dictionary link at bottom of article*\nhttps://www.unix-ninja.com/p/Password_DNA\nPROBABLE-WORDLIST\nhttps://github.com/berzerk0/Probable-Wordlists\nEFF-WORDLIST\nLong-list (7,776 words) & Short-list (1,296 words)\nhttps://www.eff.org/files/2016/07/18/eff_large_wordlist.txt\nhttps://www.eff.org/files/2016/09/08/eff_short_wordlist_1.txt\nRAINBOW TABLES\n*Rainbow Tables are for the most part obsolete but provided here for\nreference*\nhttp://project-rainbowcrack.com/table.htm\nWORDLIST GENERATION\nJOHN THE RIPPER\nGenerate wordlist that meets complexity specified in the complex filter.\njohn --wordlist=dict.txt --stdout --external : [filter name] > outfile.txt\nSTEMMING PROCESS\nStripping characters from a password list to reach the “stem” or base\nword/words of the candidate password. Commands are from “File\nManipulation Cheat Sheet”.\nExtract all lowercase strings from each line and output to wordlist.\nsed ’s/[^a-z]*//g’ passwords.txt > outfile.txt\nExtract all uppercase strings from each line and output to wordlist.\nsed ’s/[^A-Z]*//g’ passwords.txt > outfile.txt\nExtract all lowercase/uppercase strings from each line and output to wordlist.\nsed ’s/[^a-Z]*//g’ passwords.txt > outfile.txt\nExtract all digits from each line in file and output to wordlist.\nsed ’s/[^0-9]*//g’ passwords.txt > outfile.txt\nHASHCAT UTILS\nhttps://hashcat.net/wiki/doku.php?id=hashcat_utils\nCOMBINATOR\nCombine multiple wordlists with each word appended to the other.\ncombinator.bin dict1.txt dict2.txt > combined_dict.txt\ncombinator3.bin dict1.txt dict2.txt dict3.txt > combined_dict.txt\nCUTB\nCut the specific length off the existing wordlist and pass it to STDOUT.\ncutb.bin offset [length] < infile.txt > outfile.txt\nExample to cut first 4 characters in a wordlist and place into a file:\ncutb.bin 0 4 < dict.txt > outfile.txt\nRLI\nCompares a file against another file or files and removes all duplicates.\nrli dict1.txt outfile.txt dict2.txt\nREQ\nDictionary candidates are passed to stdout if it matches an specified\npassword group criteria/requirement. Groups can be added together (i.e.\n1 + 2 = 3 )\n1 = LOWER (abcdefghijklmnoprstuvwxyz)\n2 = UPPER (ABCDEFGHIJKLMNOPRSTUVWXYZ)\n4 = DIGIT (0123465789)\n8 = OTHER (All other characters not matching 1,2, or 4)\nThis example would stdout all candidates matching upper and lower\ncharacters\nreq.bin 3 < dict.txt\nCOMBIPOW\nCreates “unique combinations” of a custom dictionary; dictionary\ncannot be greater than 64 lines; option -1 limits candidates to 15\ncharacters.\ncombipow.bin dict.txt\ncombipow.bin -1 dict.txt\nEXPANDER\nDictionary into stdin is parsed and split into all its single chars (up to 4)\nand sent to stdout.\nexpander.bin < dict.txt\nLEN\nEach candidate in a dictionary is checked for length and sent to stdout.\nlen.bin <min len> <max len> < dict.txt\nThis example would send to stdout all candidates 5 to 10 chars long.\nlen.bin 5 10 < dict.txt\nMORPH\nAuto generates insertion rules for the most frequent chains of characters\nmorph.bin dict.txt depth width pos_min pos_max\nPERMUTE\nDictionary into stdin parsed and run through “The Countdown\nQuickPerm Algorithm”\npermute.bin < dict.txt\nCRUNCH\nWordlist generator can specify a character set and generate all possible\ncombinations and permutations.\nhttps://sourceforge.net/projects/crunch-wordlist/\ncrunch <min length> <max length> <character set> -o outfile.txt\ncrunch 8 8 0123456789ABCDEF -o crunch_wordlist.txt\nTARGETED WORDLISTS\nCeWL\nCustom wordlist generator scrapes & compiles keywords from websites.\nhttps://digi.ninja/projects/cewl.php\nExample scan depth of 2 and minimum word length of 5 output to\nwordlist.txt\ncewl -d 2 -m 5 -w wordlist.txt http://<target website>\nSMEEGESCRAPE\nText file and website scraper which generates custom wordlists from content.\nhttp://www.smeegesec.com/2014/01/smeegescrape-text-scraper-and-\ncustom.html\nCompile unique keywords from text file and output into wordlist.\nSmeegeScrape.py -f file.txt -o wordlist.txt\nScrape keywords from target website and output into wordlist.\nSmeegeScrape.py -u http://<target website> -si -o wordlist.txt\nGENERATE PASSWORD HASHES\nUse the below methods to generate hashes for specific algorithms.\nHASHCAT\nhttps://github.com/hashcat/hashcat/tree/master/tools\ntest.pl passthrough <#type> <#> dict.txt\nMDXFIND\nhttps://hashes.org/mdxfind.php\necho | mdxfind -z -h ‘<#type>’ dict.txt\nLYRICPASS (Song Lyrics Password Generator)\nhttps://github.com/initstring/lyricpass\nGenerator using song lyrics from chosen artist to create custom\ndictionary.\npython lyricpass.py “Artist Name” artist-dict.txt\nCONVERT WORDLIST ENCODING\nHASHCAT\nForce internal wordlist encoding from X\nhashcat -a 0 -m #type hash.txt dict.txt --encoding-from=utf-8\nForce internal wordlist encoding to X\nhashcat -a 0 -m #type hash.txt dict.txt --encoding-to=iso-8859-15\nICONV\nConvert wordlist into language specific encoding\niconv -f <old_encode> -t <new_encode> < dict.txt | sponge dict.txt.enc\nCONVERT HASHCAT $HEX OUTPUT\nExample of converting $HEX[] entries in hashcat.potfile to ASCII\ngrep ‘$HEX’ hashcat.pot | awk -F “:” {‘print $2’} |perl -ne ‘ i f ($_ =~\nm/\\$HEX\\ [([A-Fa-f0-9]+)\\]/) {print pack (“H*”, $1), “\\n”}’\nEXAMPLE CUSTOM DICTIONARY CREATION\n1-Create a custom dictionary using CeWL from www.netmux.com website:\ncewl -d 2 -m 5 -w custom_dict.txt http://www.netmux.com\n2-Combine the new custom_dict.txt with the Google 10,000 most common\nEnglish words: https://github.com/first20hours/google-10000-english\ncat google-1000.txt >> custom_dict.txt\n3-Combine with Top 196 passwords from “Probable Wordlists”:\ngithub.com/berzerk0/Probable-Wordlists/blob/master/Real-Passwords\ncat Topl96-probable.txt >> custom_dict.txt\n4-Combo the Topl96-probable.txt together using Hashcat-util\n“combinator.bin” and add it to our custom_dict.txt\ncombinator.bin Topl96-probable.txt Topl96-probable.txt >>\ncustom_dict.txt\n5-Run the best64.rule from Hashcat on Top196-probable.txt and send that\noutput into our custom dictionary:\nhashcat -a 0 Topl96-probable.txt -r best64.rule --stdout >>\ncustom_dict.txt\nCan you now come up with an attack that can crack this hash?\ne4821dl6a298092638ddb7cadc26d32f\n*Answer in the Appendix"
  },
  {
    "index": 12,
    "text": "RULES & MASKS\nRULE FUNCTIONS\nFollowing are compatible between Hashcat, John The Ripper, &\nPasswordPro https://hashcat.net/wiki/doku.php?id=rule_based_attack\nRULES TO REJECT PLAINS\nhttps://hashcat.net/wiki/doku.php?id=rule_based_attack\nIMPLEMENTED SPECIFIC FUNCTIONS\nFollowing functions are not compatible with John The Ripper &\nPasswordPro\nRULE ATTACK CREATION\nEXAMPLE RULE CREATION & OUTPUT\nBelow we apply basic rules to help explain the expected output when using\nrules.\nMASKPROCESSOR HASHCAT-UTIL\nhttps://github.com/hashcat/maskprocessor\nMaskprocessor can be used to generate a long list of rules very quickly.\nExample rule creation of prepend digit and special char to dictionary\ncandidates (i.e. ^l ^! , ^2 ^@ , . . . ) :\nmp64.bin ‘^?d ^?s’ -o rule.txt\nExample creating rule with custom charset appending lower, uppercase chars\nand all digits to dictionary candidates (i.e. $a $Q $1 , $e $ A $2, . . . ) :\nmp64.bin -1 aeiou -2 QAZWSX ‘$?1 $?2 $?d’\nGENERATE RANDOM RULES ATTACK (i.e. “Raking”)\nhashcat -a 0 -m #type -g <#rules> hash.txt dict.txt\nGENERATE RANDOM RULES FILE USING HASHCAT-UTIL\ngenerate-rules.bin <#rules> <seed> | ./cleanup-rules.bin [1=CPU,2=GPU] >\nout.txt\ngenerate-rules.bin 1000 42 | ./cleanup-rules.bin 2 > out.txt\nSAVE SUCCESSFUL RULES/METRICS\nhashcat -a 0 -m #type --debug-mode=l --debug-file=debug.txt hash.txt -r\nrule.txt\nSEND RULE OUTPUT TO STDOUT / VISUALLY VERIFY RULE\nOUTPUT\nhashcat dict.txt -r rule.txt --stdout\njohn --wordlist=dict.txt --rules=example --stdout\nPACK (Password Analysis and Cracking Kit) RULE CREATION\nhttp://thesprawl.org/projects/pack/\nRULEGEN\nAdvanced techniques for reversing source words and word mangling rules\nfrom already cracked passwords by continuously recycling/expanding\ngenerated rules and words. Outputs rules in Hashcat format.\nhttp://thesprawl.org/research/automatic-password-rule-analysis-generation/\n**Ensure you install ‘AppleSpell’ ‘aspell* module using packet manager**\npython rulegen.py --verbose --password P@ssw0rdl23\nRULEGEN OPTIONS\n-b rockyou Output base name. The following files will be\ngenerated: basename.words, basename.rules and\nbasename.stats\n-w wiki.dict Use a custom wordlist for rule analysis.\n-q, --quiet Don’t show headers.\n--threads=THREADS Parallel threads to use for processing.\nFine tune source word generation::\n--maxworddist=10 Maximum word edit distance (Levenshtein)\n--maxwords=5 Maximum number of source word candidates to\nconsider\n--morewords Consider suboptimal source word candidates\n--simplewords Generate simple source words for given passwords\nFine tune rule generation::\n--maxrulelen=10 Maximum number of operations in a single rule\n--maxrules=5 Maximum number of rules to consider\n--morerules Generate suboptimal rules\n--simplerules Generate simple rules insert,delete,replace\n--bruterules Bruteforce reversal and rotation rules (slow)\nFine tune spell checker engine::\n--providers=aspell,myspell\nComma-separated list of provider engines\nDebugging options::\n-v, --verbose Show verbose information.\n-d, --debug Debug rules.\n--password Process the last argument as a password not a file.\n--word=Password Use a custom word for rule analysis\n--hashcat Test generated rules with hashcat-cli\nRULEGEN EXAMPLES\nAnalysis of a single password to automatically detect rules and potential\nsource word used to generate a sample password:\npython rulegen.py --verbose --password P@ssw0rdl23\nAnalyze passwords.txt and output results:\npython rulegen.py passwords.txt -q\nanalysis.word - unsorted and non-uniqued source words\nanalysis-sorted.word - occurrence sorted and unique source words\nanalysis.rule - unsorted and non-uniqued rules\nanalysis-sorted.rule - occurrence sorted and unique rules\nHASHCAT INCLUDED RULES Approx # Rules\nIncisive-leetspeak.rule 15,487\nInsidePro-HashManager.rule 6,746\nInsidePro-PasswordsPro.rule 3,254\nT0XlC-insert_00-99_1950-2050_toprules_0_F.rule 4,019\nT0XlC-insert_space_and_special_0_F.rule 482\nT0XlC-insert_top_100_passwords_l_G.rule 1,603\nT0XlC.rule 4,088\nT0XlCv1.rule 11,934\nbest64.rule 77\ncombinator.rule 59\nd3ad0ne.rule 34,101\ndive.rule 99,092\ngenerated.rule 14,733\ngenerated2.rule 65,117\nleetspeak.rule 29\noscommerce.rule 256\nrockyou-30000.rule 30,000\nspecific.rule 211\ntoggles1.rule 15\ntoggles2.rule 120\ntoggles3.rule 575\ntoggles4.rule 1,940\ntoggles5.rule 4,943\nunix-ninja-leetspeak.rule 3,073\nJOHN INCLUDED RULES Approx # Rules\nAll (Jumbo + KoreLogic) 7,074,300\nExtra 17\nJumbo (Wordlist + Single + Extra + NT + 226\nOldOffice)\nKoreLogic 7,074,074\nLoopback (NT + Split) 15\nNT 14\nOldOffice 1\nSingle 169\nSingle-Extra (Single + Extra + OldOffice) 187\nSplit 1\nWordlist 25\nhttp://www.openwall.com/john/doc/RULES.shtml\nCUSTOM RULE PLANS\nMASK ATTACK CREATION\nDEBUG / VERIFY MASK OUTPUT\nhashcat -a 3 ?a?a?a?a --stdout\njohn --mask=?a?a?a?a --stdout\nHASHCAT MASK ATTACK CREATION\nExample usage:\nhashcat -a 3 -m #type hash.txt <mask>\nExample brute-force all possible combinations 7 characters long:\nhashcat -a 3 -m #type hash.txt ?a?a?a?a?a?a?a\nExample brute-force all possible combinations 1 - 7 characters long:\nhashcat -a 3 -m #type hash.txt -i ?a?a?a?a?a?a?a\nExample brute-force uppercase first letter, 3 unknown middle\ncharacters, and ends in 2 digits (i.e. Passl2):\nhashcat -a 3 -m #type hash.txt ?u?a?a?a?d?d\nExample brute-force known first half word “secret” and unknown\nending:\nhashcat -a 3 -m #type hash.txt secret?a?a?a?a\nExample hybrid mask (leftside) + wordlist (rightside) (i.e. 123!Password)\nhashcat -a 7 -m #type hash.txt ?a?a?a?a dict.txt\nExample wordlist (leftside) + hybrid mask (rightside) (i.e. Passwordl23!)\nhashcat -a 6 -m #type hash.txt dict.txt ?a?a?a?a\nHASHCAT CUSTOM CHARSETS\nFour custom buffer charsets to create efficient targeted mask attacks defined\nas: -1 -2 -3 -4\nExample custom charset targeting passwords that only begin in\na,A,b,B,or c,C , 4 unknown middle characters, and end with a digit (i.e.\nal7z#q7): hashcat -a 3 -m #type hash.txt -1 abcABC ?l?a?a?a?a?d\nExample custom charset targeting passwords that only begin in\nuppercase or lowercase, 4 digits in the middle, and end in special\ncharacter !,@,$ (i.e. W7462! or f1234$):\nhashcat -a 3 -m #type hash.txt -1 ?u?l -2 !@$ ?l?d?d?d?d?2\nExample using all four custom charsets at once (i.e. pow!12er):\nhashcat -a 3 -m #type hash.txt -1 qwer -2 poiu -3 123456 -4 !@#$% ?2?2?1?\n4?3?3? 1?1\nJOHN MASK ATTACK CREATION\nExample usage:\njohn --format=#type hash.txt --mask=<mask>\nExample brute-force all possible combinations up to 7 characters long:\njohn --format=#type hash.txt --mask=?a?a?a?a?a?a?a\nExample brute-force uppercase first letter, 3 unknown middle\ncharacters, and ends in 2 digits (i.e. Passl2):\njohn --format=#type hash.txt --mask=?u?a?a?a?d?d\nExample brute-force known first half word “secret” and unknown\nending:\njohn --format=#type hash.txt --mask=secret?a?a?a?a\nExample mask (leftside) + wordlist (rightside) (i.e. 123!Password)\njohn --format=#type hash.txt --wordlist=dict.txt --mask=?a?a?a?a?w\nExample wordlist (leftside) + mask (rightside) (i.e. Password123!)\njohn --format=#type hash.txt --wordlist=dict.txt --mask=?w?a?a?a?a\nJOHN CUSTOM CHARSETS\nNine custom buffer charsets to create efficient targeted mask attacks defined\nas: -1 -2 -3 -4 -5 -6 -7 -8 -9\nExample custom charset targeting passwords that only begin in\na,A,b,B,or c,C , 4 unknown middle characters, and end with a digit (i.e.\na17z#q7):\njohn --format=#type hash.txt -1=abcABC --mask=?l?a?a?a?a?d\nExample custom charset targeting passwords that only begin in\nuppercase or lowercase, 4 digits in the middle, and end in special\ncharacter !,@,$ (i.e. W7462! or f1234$):\njohn --format=#type hash.txt -1=?u?l -2=!@$ --mask=?l?d?d?d?d?2\nExample using four custom charsets at once (i.e. pow!12er):\njohn --format=#type hash.txt -1=qwer -2=poiu -3=123456 -4=!@#$%, --\nmask=?2?2?l?4? 3?3?1?1\nHASHCAT MASK CHEAT SHEET\nJOHN MASK CHEAT SHEET\nMASK FILES\nHashcat allows for the creation of mask f i l es by placing custom masks, one\nper line, in a text f i l e with “.hcmask” extension.\nHASHCAT BUILT-IN MASK FILES Approx # Masks\n8char-11-1u-1d-1s-compliant.hcmask 40,824\n8char-11-1u-1d-1s-noncompliant.hcmask 24,712\nrockyou-1-60.hcmask 836\nrockyou-2-1800.hcmask 2,968\nrockyou-3-3600.hcmask 3,971\nrockyou-4-43200.hcmask 7,735\nrockyou-5-86400.hcmask 10,613\nrockyou-6-864000.hcmask 17,437\nrockyou-7-2592000.hcmask 25,043\nWESTERN COUNTRY TOP MASKS\nEASTERN COUNTRY TOP MASKS\nPACK (Password Analysis and Cracking Kit) MASK\nCREATION\nhttp://thesprawl.org/projects/pack/\nMASKGEN\nMaskGen allows you to automatically generate pattern-based mask attacks\nfrom known passwords and filter by length and desired cracking time.\npython maskgen.py example.mask\nMASKGEN OPTIONS\nIndividual Mask Filter Options:\nMask Sorting Options:\nCheck mask coverage:\nMiscellaneous options:\nMASKGEN EXAMPLES\nGather stats about cracked passwords.txt and hide the less than 1%\nresults:\npython statsgen.py --hiderare passwords.txt\nSave masks stats to a .mask file for further analysis:\npython statsgen.py --hiderare passwords.txt -o example.mask\nAnalyze example.mask results, number of masks, estimated time to\ncrack, etc...\npython maskgen.py example.mask\nCreate 24 hour (86400 seconds) mask attack based on cracking speed of\na single GTX 1080 against MD5 hashes 24943.1 MH/s(based on appendix\ntable).\n!Substitute your GPU’s cracking speed against MD5 (c/s)!.\npython maskgen.py example.mask --targettime=86400 --optindex --\npps=24943000000 -q\nOutput 24 hour mask attack to a .hcmask file for use in Hashcat:\npython maskgen.py example.mask --targettime=86400 --optindex --\npps=24943000000 -q -o example.hcmask\nUse your new example.hcmask file with Hashcat in mask attack mode:\nhashcat -a 3 -m #type hash.txt example.hcmask\nTIME TABLE CHEAT SHEET\nPOLICYGEN\nGenerate a collection of masks following the password complexity in order to\nsignificantly reduce the cracking time.\npython policygen.py [options] -o example.hcmask\nPOLICYGEN OPTIONS\nPassword Policy:\nDefine the minimum (or maximum) password strength policy that\nyou would like to test\nPOLICYGEN EXAMPLES\nGenerate mask attack for password policy 8 character length requiring\nat least 1 lowercase, 1 uppercase, 1 digit, and 1 special character:\npython policygen.py --minlength 8 --maxlength 8 --minlower 1 --minupper 1\n--mindigit 1 --minspecial 1 -o example.hcmask\nGenerate mask attack and estimate time of completion based on GTX\n1080 against MD5 hashes 24943.1 MH/s(based on appendix table) for\npassword policy 8 character length requiring at least 1 lowercase, 1\nuppercase, 1 digit, and 1 special character:\npython policygen.py --minlength 8 --maxlength 8 --minlower 1 --minupper 1\n--mindigit 1 --minspecial 1 -o example.hcmask --pps=24943000000\nCUSTOM MASK PLANS\nDATE YYMMDD MASK\nhashcat -a 3 -m #type hash.txt -1 12 -2 90 -3 01 -4 123 ?l?2?3?d?4?d\nDATE YYYYMMDD MASK\nhashcat -a 3 -m #type hash.txt -1 12 -2 90 -3 01 -4 123 ?l?2?d?d?3?d? 4?d\n3 SEQUENTIAL NUMBERS MASK + SPECIAL\nhashcat -a 3 -m #type hash.txt -1 147 -2 258 -3 369 ?l?2?3?s"
  },
  {
    "index": 13,
    "text": "FOREIGN CHARACTER SETS\nUTF8 POPULAR LANGUAGES\n*Incremental four character password examples\nArabic\nUTF8 (d880-ddbf)\nhashcat -a 3 -m #type hash.txt --hex-charset -1 d8d9dadbdcdd -2\n80818283848586\n8788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0ala2a3a4a5a6a7a8a9aaabacadae\nafb0blb2b3b4b5b6b7b8b9babbbcbdbebf -i ?1?2?1?2?1?2?1?2\nBengali\nUTF8 (e0a680-e0adbf)\nhashcat -a 3 -m #type hash.txt --hex-charset -1 e0 -2 a6a7a8a9aaabacad -3\n8081\n82838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0ala2a3a4a5a6a7a8a9\naaabacadaeafb0blb2b3b4b5b6b7b8b9babbbcbdbebf -i ?1?2?3?1?2?3?1?2?3?\n1?2?3\nChinese (Common Characters)\nUTF8 (e4b880-e4bbbf)\nhashcat -a 3 -m #type hash.txt --hex-charset -1 e4 -2 b8b9babb -3\n808182838485\n868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0ala2a3a4a5a6a7a8a9aaabacad\naeafb0blb2b3b4b5b6b7b8b9babbbcbdbebf -i ?1?2?3?1?2?3?1?2?3?1?2?3\nJapanese (Katakana & Hiragana)\nUTF8 (e38180-e3869f)\nhashcat -a 3 -m #type hash.txt --hex-charset -1 e3 -2 818283848586 -3\n80818283\n8485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0ala2a3a4a5a6a7a8a9aaab\nacadaeafb0blb2b3b4b5b6b7b8b9babbbcbdbebf -i ?1?2?3?1?2?3?1?2?3?1?2?\n3\nRussian\nUTF8 (d080-d4bf)\nhashcat -a 3 -m #type hash.txt --hex-charset -1 d0dld2d3d4 -2\n8081828384858687\n88898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0ala2a3a4a5a6a7a8a9aaabacadaeaf\nb0blb2b3b4b5b6b7b8b9babbbcbdbebf -i ?1?2?1?2?1?2?1?2\nHASHCAT BUILT-IN CHARSETS\nGerman\nhashcat -a 3 -m #type hash.txt -1 charsets/German.hcchr -i ?1?1?1?1\nFrench\nhashcat -a 3 -m #type hash.txt -1 charsets/French.hcchr -i ?1?1?1?1\nPortuguese\nhashcat -a 3 -m #type hash.txt -1 charsets/Portuguese.hcchr -i ?1?1?1?1\nSUPPORTED LANGUAGE ENCODINGS\nhashcat -a 3 -m #type hash.txt -1 charsets/<language>.hcchr -i ?1?1?1?1\nBulgarian, Castilian, Catalan, English, French, German, Greek, Greek\nPolytonic, Italian, Lithuanian, Polish, Portuguese, Russian, Slovak, Spanish\nJOHN UTF8 & BUILT-IN CHARSETS\nOPTIONS:\n--encoding=NAME input encoding (eg. UTF-8, ISO- 8859-1).\n--input-encoding=NAME input encoding (alias for --encoding)\n--internal-encoding=NAME encoding used in rules/masks (see\ndoc/ENCODING)\n- -target-encoding=NAME output encoding (used by format)\nExample LM hashes from Western Europe, using a UTF-8 wordlist:\njohn --format=lm hast.txt --encoding=utf8 --target:cp850 --wo:spanish.txt\nExample using UTF-8 wordlist with internal encoding for rules\nprocessing:\njohn --format=#type hash.txt --encoding=utf8 --internal=CP1252 --\nwordlist=french.1st --rules\nExample mask mode printing all possible “Latin-1” words of length 4:\njohn --stdout --encoding=utf8 --internal=8859-1 --mask:?1?1?1?1\nSUPPORTED LANGUAGE ENCODINGS\nUTF-8, ISO-8859-1 (Latin), ISO-8859-2 (Central/Eastern Europe), ISO-\n8859-7 (Latin/Greek), ISO-8859-15 (Western Europe), CP437 (Latin),\nCP737 (Greek), CP850 (Western Europe), CP852 (Central Europe), CP858\n(Western Europe), CP866 (Cyrillic), CP1250 (Central Europe), CP1251\n(Russian), CP1252 (Default Latin1), CP1253 (Greek) and K0I8-R (Cyrillic).\nHASHCAT ?b BYTE CHARSET\nIf your unsure as to position of a foreign character set contained within your\ntarget password, you can attempt the ?b byte charset in a mask using a sliding\nwindow. For example if we have a password 6 characters long:\n?b = 256 byte = 0x00 - 0xff\nhashcat -a 3 -m #type ?b?a?a?a?a?a\nhash.txt ?a?b?a?a?a?a\n?a?a?b?a?a?a\n?a?a?a?b?a?a\n?a?a?a?a?b?a\n?a?a?a?a?a?b\nCONVERT ENCODING\nHASHCAT\nForce internal wordlist encoding from X\nhashcat -a 0 -m #type hash.txt dict.txt --encoding-from=utf-8\nForce internal wordlist encoding to X\nhashcat -a o -m #type hash.txt dict.txt --encoding-to=iso-8859-15\nICONV\nConvert wordlist into language specific encoding\niconv -f <old_encode> -t <new_encode> < dict.txt | sponge dict.txt.enc\nCONVERT HASHCAT $HEX OUTPUT\nExample of converting $HEX[] entries in hashcat.pot f i l e to ASCII\ngrep ‘$HEX’ hashcat.pot | awk -F “:” {‘print$2’} |perl -ne ‘ i f ($_ =~\nm/\\$HEX\\[([A-Fa-f0-9]+)\\]/) {print pack(“H*”, $1), “\\n”}’"
  },
  {
    "index": 14,
    "text": "ADVANCED ATTACKS\nPRINCE ATTACK\nPRINCE (PRobability INfinite Chained Elements) Attack takes one input\nwordlist and builds “chains” of combined words automatically.\nHASHCAT PRINCEPROCESSOR\nhttps://github.com/hashcat/princeprocessor\nAttack slow hashes:\npp64.bin dict.txt | hashcat -a 0 -m #type hash.txt\nAmplified attack for fast hashes:\npp64.bin --case-permute dict.txt | hashcat -a 0 -m #type hash.txt -r rule.txt\nExample PRINCE attack producing minimum 8 char candidates with 4\nelements piped directly into Hashcat with rules attack.\npp64.bin --pw-min=8 --limit=4 dict.txt|hashcat -a 0 -m # hash.txt -r\nbest64.rule\nPRINCECEPTION ATTACK (epixoip)\nPiping the output of one PRINCE attack into another PRINCE attack.\npp64.bin dict.txt | pp64.bin | hashcat -a 0 -m #type hash.txt\nJOHN BUILT-IN PRINCE ATTACK\njohn --prince=dict.txt hash.txt\nMASK PROCESSOR\nMask attack generator with a custom configurable charset and ability to limit\nconsecutive and repeating characters to decrease attack keyspace.\nhttps://github.com/hashcat/maskprocessor\nLimit 4 consecutive identical characters in the password string “-q”\noption:\nmp64.bin -q 4 ?d?d?d?d?d?d?d?d | hashcat -a 0 -m #type hash.txt\nLimit 4 identical characters in the password string “-r” option:\nmp64.bin -r 4 ?d?d?d?d?d?d?d?d | hashcat -a 0 -m #type hash.txt\nLimit 2 consecutive and 2 identical characters in the password string:\nmp64.bin -r 2 -q 2 ?d?d?d?d?d?d?d?d | hashcat -a 0 -m #type hash.txt\nCustom charset limiting 2 consecutive and 2 identical characters in the\npassword string:\nmp64.bin -r 2 -q 2 -1 aeiuo -2 TGBYHN ?l?2?l?2?d?d?d?d | hashcat -a 0 -m\n#type hash.txt\nCUSTOM MARKOV MODEL / STATSPROCESSOR\nWord-generator based on the per-position markov-attack.\nhttps://github.com/hashcat/statsprocessor\nHCSTATGEN\nCreate custom Markov models using hashcat-util hcstatgen.bin based on\ncracked target passwords. The util hcstatgen makes a 32MB file each time no\nmatter how small/large the password list provided. Highly recommended you\nmake custom Markov models for different target sets.\nhcstatgen.bin outfile.hcstat < passwords.txt\nSTATSPROCESSOR\nIs a high-performance word-generator based on a user supplied per-position\nMarkov model (hcstat file) using mask attack notation.\nStep 1: Create your custom Markov model\nhcstatgen.bin out.hcstat < passwords.txt\nStep 2.1: Supply your new Markov model to Hashcat as mask or rule\nattack.\nhashcat -a 3 -m #type hash.txt --markov-hcstat=out.hcstat ?a?a?a?a?a?a\nhashcat -a 0 -m #type hash.txt dict.txt -r rule.txt --markov-hcstat=out.hcstat\nStep 2.2: OR Supply your new Markov model with sp64 and pipe into\nHashcat.\nsp64.bin --pw-min 3 --pw-max 5 out.hcstat ?1?1?1?1?1?1 | hashcat -a 0 -m\n#type hash.txt\nKEYBOARD WALK PROCESSOR\nKeyboard-walk generator with configurable base chars, keymappings and\nroutes. https://github.com/hasheat/kwprocessor\nExample keyboard walk with tiny charset in english mapping and with 2-10\nadjacent keys piping out results into a hashcat attack:\nkwp.bin basechar/tiny.base keymaps/en.keymap routes/2-to-10-max-3 -0\n-z | hashcat -a 0 -m #type hash.txt\nExample keyboard walk with full charset in english mapping and with 3x3\nadjacent keys piping out results into a hashcat attack:\n./kwp basechars/full.base keymaps/en.keymap routes/3-to-3-\nexhaustive.route | hashcat -a 0 -m #type hash.txt\n[FULL LIST OF OPTIONS]\nMDXFIND / MDSPLIT\nhttps://hashes.org/mdxfind.php\n(credit ‘Waffle’)\nMDXFIND is a program which allows you to run large numbers of unsolved\nhashes of any type, using many algorithms concurrently, against a large\nnumber of plaintext words and rules, very quickly. It’s main purpose was to\ndeal with large lists (20 million, 50 million, etc) of unsolved hashes and run\nthem against new dictionaries as you acquire them.\nSo when would you use MDXFIND on a pentest? If you dump a database\ntied to website authentication and the hashes are not cracking by standard\nattack plans. The hashes may be generated in a unique nested hashing series.\nIf you are able to view the source code of said website to view the custom\nhashing function you can direct MDXFIND to replicate that hashing series. If\nnot, you can still run MDXFIND using some of the below ‘Generic Attack\nCommands’. MDXFIND is tailored toward intermediate to expert level\npassword cracking but is extremely powerful and flexible.\nExample website SHA1 custom hashing function performing multiple\niterations:\n$hash = sha1($password . $salt);\nfor ($i = 1; $i <= 65000; ++$i)\n{\n$hash = sha1($hash . $salt);\n}\nMDXFIND\nCOMMAND STRUCTURE THREE METHODS 1-STDOUT 2-STDIN 3-\nFile\n1- Reads hashes coming from cat (or other) commands stdout.\ncat hash.txt | mdxfind -h <regex #type> -i <#iterations> dict.txt > out.txt\n2- Takes stdin from outside attack sources in place of dict.txt when using the\noptions variable ‘-f’ to specify hash.txt file location and variable ‘stdin’.\nmp64.bin ?d?d?d?d?d?d | mdxfind -h <regex #type> -i <#iterations> -f\nhash.txt stdin > out.txt\n3- Specify file location ‘-f’ with no external stdout/stdin sources.\nmdxfind -h <regex #type> -i <#iterations> -f hash.txt dict.txt > out.txt\n[FULL LIST OF OPTIONS]\n-a Do email address munging\n-b Expand each word into unicode, best effort\n-c Replace each special char (<>&, etc) with XML equivalents\n-d De-duplicate wordlists, best effort...but best to do ahead of time\n-e Extended search for truncated hashes\n-p Print source (filename) of found plain-texts\n-q Internal iteration counts for SHA1MD5X, and others. For example, if\nyou have a hash that is SHA1(MD5(MD5(MD5(MD5($pass)))))),\nyou would set -q to 5.\n-g Rotate calculated hashes to attempt match to input hash\n-s File to read salts from\n-u File to read Userid/Usernames from\n-k File to read suffixes from\n-n Number of digits to append to passwords. Other options, like: -n 6x\nwould append 6 digit hex values, and 8i would append all ipv4\ndotted-quad IP-addresses.\n-i The number of iterations for each hash\n-t The number of threads to run\n-f file to read hashes from, else stdin\n-1 Append CR/LF/CRLF and print in hex\n-r File to read rules from\n-v Do not mark salts as found.\n-w Number of lines to skip from first wordlist\n-y Enable directory recursion for wordlists\n-z Enable debugging information/hash results\n-h The hash types: 459 TOTAL HASHES SUPPORTED\nGENERIC ATTACK PLANS\nThis is a good general purpose MDXFIND command to run your hashes\nagainst if you suspect them to be “non-standard” nested hashing sequences.\nThis command says “Run all hashes against dict.txt using 10 iterations except\nones having a salt, user, or md5x value in the name.” It’s smart to skip\nsalted/user hash types in MDXFIND unless you are confident a salt value has\nbeen used.\ncat hash.txt | mdxfind -h ALL -h ‘!salt,!user,!md5x’ -i 10 dict.txt >\nout.txt\nThe developer of MDXFIND also recommends running the below command\noptions as a good general purpose attack:\ncat hash.txt | mdxfind -h <^md5$,^sha1$,^md5md5pass$,^md5sha1$’ -i\n5 dict.txt > out.txt\nAnd you could add a rule attack as well:\ncat hash.txt | mdxfind -h <^md5$,^sha1$,^md5md5pass$,^md5sha1$’ -i\n5 dict.txt -r best64.rule > out.txt\nGENERAL NOTES ABOUT MDXFIND\n-Can do multiple hash types/files all during a single attack run.\ncat sha1/*.txt sha256/*.txt md5/*.txt salted/*.txt | mdxfind\n-Supports 459 different hash types/sequences\n-Can take input from special ‘stdin’ mode\n-Supports VERY large hashlists (l00mil) and 10kb character passwords\n-Supports using hashcat rule files to integrate with dictionary\n-Option ‘-z’ outputs ALL viable hashing solutions and file can grow very\nlarge\n-Supports including/excluding hash types by using simple regex parameters\n-Supports multiple iterations (up to 4 billion times) by tweaking -i parameter\nfor instance:\nMD5X01 is the same as md5($Pass)\nMD5x02 is the same as md5(md5($pass))\nMD5X03 is the same as md5(md5(md5($pass)))\n. . .\nMD5xl0 is the same as\nmd5(md5(md5(md5(md5(md5(md5(md5(md5(md5($pass))))))))))\n-Separate out -usernames -email -ids -salts to create custom attacks\n-If you are doing brute-force attacks, then hashcat is probably better route\n-When MDXfind finds any solution, it outputs the kind of solution found,\nfollowed by the hash, followed by the salt and/or password. For example:\nMD5X01 000012273bc5cab48bf3852658b259ef:lEb0TBK3\nMD5X05 033blll073e5f64ee59f0be9d6b8a561:08061999\nMD5X09 aadb9dlb23729a3e403d7fc62d507df7:1140\nMD5X09 326d921d591162eed302ee25a09450ca:1761974\nMDSPLIT\nWhen cracking large lists of hashes from multiple file locations, MDSPLIT\nwill help match which files the cracked hashes were found in, while also\noutputing them into separate files based on hash type. Additionally it will\nremove the found hashes from the original hash file.\nCOMMAND STRUCTURE TWO METHODS 1-STDOUT 2-STDIN 3-File\n1- Matching MDXFIND results files with their original hash_orig.txt files.\ncat hashes_out/out_results.txt | mdsplit hashes_orig/hash_orig.txt\nOR perform matching against a directory of original hashes and their results.\ncat hashes_out/* | mdsplit hashes_orig/*\n2- Piping MDXFIND directly into MDSPLIT to sort in real-time results.\ncat *.txt | mdxfind -h ALL -h ‘!salt,!user,!md5x’ -i 10 dict.txt | mdsplit\n*.txt\n3- Specifying a file location in MDXFIND to match results in real-time.\nmdxfind -h ALL -f hashes.txt -i 10 dict.txt | mdsplit hashes.txt\nGENERAL NOTES ABOUT MDSPLIT\n-MDSPLIT will append the final hash solution to the end of the new\nfilename. For example, if we submitted a ‘hashes.txt’ and the solution to the\nhashes was “MD5x01” then the results file would be ‘hashes.MD5x01’. If\nmultiple hash solutions are found then MDSPLIT knows how to deal with\nthis, and will then remove each of the solutions from hashes.txt, and place\nthem into ‘hashes.MD5x01’, ‘hashes.MD5x02’, ‘hashes.SHA1’... and so on.\n-MDSPLIT can handle sorting multiple hash files, types, and their results all\nat one time. Any solutions will be automatically removed from all of the\nsource files by MDSPLIT, and tabulated into the correct solved files. For\nexample:\ncat dirl/*.txt dir2/*.txt dir3/*.txt | mdxfind -h ‘^md5$,^sha1$,^sha256$’ -i 10\ndict.txt | mdsplit dirl/*.txt dir2/*.txt dir3/*.txt\nDISTRIBUTED / PARALLELIZATION CRACKING\nHASHCAT\nhttps://hashcat.net/forum/thread-3047.html\nStep 1: Calculate keyspace for attack (Example MD5 Brute Force x\n3nodes)\nhashcat -a 3 -m 0 ?a?a?a?a?a?a --keyspace\n81450625\nStep 2: Distribute work through keyspace division (s)kip and (l)imit\n81450625 / 3 = 27150208.3\nNode1# hashcat -a 3 -m 0 hash.txt ?a?a?a?a?a?a -s 0 -1 27150208\nNode2# hashcat -a 3 -m 0 hash.txt ?a?a?a?a?a?a -s 27150208 -1 27150208\nNode3# hashcat -a 3 -m 0 hash.txt ?a?a?a?a?a?a -s 54300416 -1 27150209\nJOHN\nhttp://www.openwall.com/john/doc/OPTIONS.shtml\nManual distribution using Options --node & --fork to 3 similar CPU\nnodes utilizing 8 cores:\nNode# john --format=<#> hash.txt --wordlist=dict.txt --rules=All --fork=8 --\nnode=1-8/24\nNode2# john --format=<#> hash.txt --wordlist=dict.txt --rules=All --fork=8 --\nnode=9-16/24\nNode3# john --format=<#> hash.txt --wordlist=dict.txt --rules=All --fork=8 --\nnode=17-24/24\nOther John Options for parallelization:\nOption 1:Enable OpenMP through uncommenting in Makefile\nOption 2:Create additional incremental modes in john.conf\nOption 3:Utilize built-in MPI parallelization\nPASSWORD GUESSING FRAMEWORK\nhttps://github.com/RUB-SysSec/Password-Guessing-Framework\nhttps://www.password-guessing.org/\nPassword Guessing Framework is an open source tool to provide an\nautomated and reliable way to compare password guessers. It can help to\nidentify individual strengths and weaknesses of a guesser, it’s modes of\noperation, or even the underlying guessing strategies. Therefore, it gathers\ninformation about how many passwords from an input f i l e (password leak)\nhave been cracked in relation to the amount of generated guesses. Subsequent\nto the guessing process an analysis of the cracked passwords is performed.\nOTHER CREATIVE ADVANCED ATTACKS\nRandom creative password attacks using the power of stdin and stdout. Not\nimplying they’re useful but to demonstrate the power of mixing and\nmatching. Go forth and create something useful.\nPRINCE-MDXFIND ATTACK\npp64.bin dict.txt | mdxfind -h ALL -f hash.txt -i 10 stdin > out.txt\nHASHCAT-UTIL COMBONATOR PRINCE\ncombinator.bin dict.txt dict.txt | pp64.bin | hashcat -a 0 -m #type hash.txt -r\nbest64.rule\ncombinator3.bin dict.txt dict.txt dict.txt | pp64.bin | hashcat -a 0 -m #type\nhash.txt -r rockyou-30000.rule\nHASHCAT STDOUT ATTACKS PRINCE\nhashcat -a 0 dict.txt -r dive.rule --stdout | pp64.bin | hashcat -a 0 -m #type\nhash.txt\nhashcat -a 6 dict.txt ?a?a?a?a --stdout | pp64.bin --pw-min=8 | hashcat -a 0 -m\n#type hash.txt\nhashcat -a 7 ?a?a?a?a dict.txt --stdout | pp64.bin --pw-min=8 | hashcat -a 0 -m\n#type hash.txt\nhashcat -a 6 dict.txt rockyou-1-60.hcmask --stdout | pp64.bin --pw-min=8 --\npw-max=14 I hashcat -a 0 -m #type hash.txt\nhashcat -a 7 rockyou-1-60.hcmask dict.txt --stdout | pp64.bin --pw-min=8 --\npw-max=14 I hashcat -a 0 -m #type hash.txt\nDISTRIBUTED CRACKING SOFTWARE\nHASHTOPUSSY\nhttps://bitbucket.org/seinlc/hashtopussy/\nHASHSTACK\nhttps://sagitta.pw/software/\nDISTHC\nhttps://github.com/unix-ninja/disthc\nCRACKLORD\nhttp://jmmcatee.github.io/cracklord/\nHASHTOPUS\nhttp://hashtopus.org/Site/\nHASHVIEW\nhttp://www.hashview.io/\nCLORTHO\nhttps://github.com/ccdes/clortho\nONLINE HASH CRACKING SERVICES\nGPUHASH\nhttps://gpuhash.me/\nCRACKSTATION\nhttps://crackstation.net/\nONLINE HASH CRACK\nhttps://www.onlinehashcrack.com/\nHASH HUNTERS\nhttp://www.hashhunters.net/"
  },
  {
    "index": 15,
    "text": "Information in this chapter is an attempt to summarize a few of the basic and\nmore complex concepts in password cracking. This allows all skill levels to\ngrasp these concepts without needing a Linguistics or Mathematics Degree.\nIt’s an almost impossible task to condense into one paragraph, but the\nfollowing is an attempt. For a deeper understanding, I highly encourage you\nto read the Resource links included below each section.\nPASSWORD ENTROPY vs CRACK TIME\nPassword entropy is a measure of how random/unpredictable a password\ncould have been, so it does not really relate to the password itself, but to a\nselection process. When judging human generated passwords for entropy, it\nfrankly isn’t an accurate measurement. Thisis true mainly because humans\nlike to use memorable words/sequences and thus a myriad of attacks account\nfor that behavior. however, entropy is good for measuring randomly\ngenerated passwords from password managers, such as 1Password or\nKeepass, in that each default character set used can be calculated. Password\nentropy is measured in bits and uses the following formula where C=Size of\nCharacter set & L=Length of password: log(C) / log(2) * L\nTo calculate the time to crack, just use the benchmarking function on your\nfavorite cracking software against your mode of hash to obtain cracks per\nsecond. The table below estimates password length using an MD4 hashing\nfunction against an 8 GPU x Nvidia GTX1080 system:\n*Table only truly matters for randomly generated passwords\nResources\nPassword Complexity versus Password Entropy\nhttps://blogs.technet.microsoft.com/msftcam/2015/05/19/password-\ncomplexity-versus-password-entropy/\nWHAT IS A CRYPTOGRAPHIC HASH?\nA cryptographic hash function is a subclass of the general hash function\nwhich possesses properties lending its use in cryptography. Cryptographic\nhash functions are mathematical algorithms which map data of any size to a\nstring containing a fixed length, and should make it infeasible to reverse. For\ninstance, the string “password,” when mapped using the MD5 hash function,\nreturns a fixed length 32 character string\n“5f4dcc3b5aa765d61d8327deb882cf99”. The 32 character string cannot\ntheoretically be reversed with any other mapped input data except\n“password”. The current method of recreating this input data “password” is\nthrough a dictionary/mask/brute-force attack of all possible inputs matching\nthe hashed value; also called a pre-image attack. Generally speaking, hash\nfunctions should possess the below characteristics:\n-Be computationally infeasible to find two different sets of input data with the\nsame hash value (also called a collision).\n-The hash value should be “quick” to compute (i.e. > ~1 second).\n-It should be difficult to generate the input data Just by looking at the hash\nvalue.\n-One simple change to the input data should drastically change the resultant\nhash value.\nResources\nHow Hash Algorithms Work\nhttp://www.metamorphosite.com/one-way-hash-encryption-sha1-data-\nsoftware\nMARKOV CHAINS\nMarkov Chains are created, for our password cracking purposes, by statistical\nanalysis of a large list of passwords/words (i.e. the RockYou password\ndataset). The resultant analysis of these words and their per-position character\nfrequency/probability are stored in a table. This table is referenced when\nperforming brute-force/mask attacks to prevent having to generate password\ncandidates in a sequential order, which is very inefficient. Instead, the most\ncommon characters are attempted first in order of preceding character\nprobability. So let’s see sequential brute-force ?a?a?a?a with out Markov\nChains applied:\nNow the same brute-force attack with Markov Chains applied:\nMarkov Chains predict the probability of the next character in a password\nbased on the previous characters, or context characters. It’s that simple.\nResources\nFast Dictionary Attacks on Passwords Using Time-Space Tradeoff\nhttp://www.cs.utexas.edu/~shmat/shmat_ccs05pwd.pdf\nOMEN: Faster Password Guessing Using an Ordered Markov\nEnumerator\nhttps://hal.inria.fr/hal-01112124/document\nPROBABILISTIC CONTEXT-FREE GRAMMARS (PCFG)\nA Probabilistic Context Free Grammar (PCFG) consists of terminal and\nnonterminal variables. Each feature to be modeled has a production rule that\nis assigned a probability, estimated from a training set of RNA structures.\nProduction rules are recursively applied until only terminal residues are left.\nThe notion supporting PCFGs is that passwords are constructed with template\nstructures and terminals that fit into those structures. For example, the\npassword candidate ‘passwordl23!’ is 8 letters, 3 digits, 1 special and would\nbe noted as ‘L D S ’. A password’s probability of occurring is the\n8 3 1\nprobability of its structure, multiplied by those of its underlying terminals.\nResources\nPassword Cracking Using Probabilistic Context-Free Grammars\nhttps://sites.google.com/site/reusablesec/Home/password-cracking-\ntools/probablistic_cracker\nNext Gen PCFG Password Cracking\nhttps://github.com/lakiw/pcfg_cracker\nNEURAL NETWORKS\nArtificial Neural Networks or Neural Networks (NN) is a machine-learning\ntechnique composed of nodes called Artificial Neurons, just like the brain\npossesses. Such systems use Machine Learning to approximate highly\ndimensional functions and progressively learn through examples of training\nset data, or in our case a large password dump. They have shown initial\npromise to be effective at generating original yet representative password\ncandidates. Advantages to NN’s for password cracking are the low overhead\nfor storing the final NN model, approximately 500kb, and the ability to\ncontinually learn over time through retraining or transfer learning.\nResources\nFast, Lean, and Accurate: Modeling Password Guessability Using Neural\nNetworks (USENIX ‘16)\nhttps://www.usenix.org/system/files/conference/usenixsecurity16/sec16_paper_melicher.pdf\nhttps://github.com/cupslab/neural_network_cracking"
  },
  {
    "index": 16,
    "text": "COMMON HASH EXAMPLES\nMD5, NTLM, NTLMv2, LM, MD5crypt, SHA1, SHA256, bcrypt, PDF\n1.4 - 1.6 (Acrobat 5-8), Microsoft OFFICE 2013, RAR3-HP, Winzip,\n7zip, Bitcoin/Litecoin, MAC OSX v10.5-v10.6, MySQL 4.1-5+, Postgres,\nMSSQL(2012)-MSSQL(2014), Oracle 11g, Cisco TYPE 4 5 8 9, WPA\nPSK / WPA2 PSK\nMDS\nHASHCAT\nHASH FORMAT\n8743b52063cd84097a65dl633f5c74f5\nBRUTE FORCE ATTACK\nhashcat -m 0 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 0 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 0 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\n8743b52063cd84097a65dl633f5c74f5\nBRUTE FORCE ATTACK\njohn --format=raw-md5 hash.txt\nWORDLIST ATTACK\njohn --format=raw-md5 wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=raw-md5 wordlist=dict.txt --rules hash.txt\nNTLM (PWDUMP)\nHASHCAT\nHASH FORMAT\nb4b9b02e6f09a9bd760f388b67351e2b\nBRUTE FORCE ATTACK\nhashcat -m 1000 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 1000 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 1000 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\nb4b9b02e6f09a9bd760f388b67351e2b\nBRUTE FORCE ATTACK\njohn --format=nt hash.txt\nWORDLIST ATTACK\njohn --format=nt wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=nt wordlist=dict.txt --rules hash.txt\nNTLM V2\nHASHCAT\nHASH FORMAT\nusername::N46iSNekpT:08ca45b7d7ea58ee:88dcbe4446168966al53a0064958dac6:5c7830315\nC7830310000000000000b45c67103d07d7b95acdl2ffall230e0000000052920b85f78d013c31cdb\n3b92f5d765c783030\nBRUTE FORCE ATTACK\nhashcat -m 5600 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 5600 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 5600 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\nusername:$NETNTLMv2$NTLMV2TESTWORKGROUP$1122334455667788$07659A550D5E9D02996DFD9\n5C87EC1D5$0101000000000000006CF6385B74CA01B3610B02D99732DD000000000200120057004F\n0052004B00470052004F00550050000100200044004100540041002E00420049004E0043002D0053\n004500430055005200490000000000\nBRUTE FORCE ATTACK\njohn --format=netntlmv2 hash.txt\nWORDLIST ATTACK\njohn --format=netntlmv2 wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=netntlmv2 wordlist=dict.txt --rules hash.txt\nLM\nHASHCAT\nHASH FORMAT\n299bdl28cll01fd6\nBRUTE FORCE ATTACK\nhashcat -m 3000 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 3000 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 3000 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\n$LM$a9c604d244c4e99d\nBRUTE FORCE ATTACK\njohn --format=lm hash.txt\nWORDLIST ATTACK\njohn --format=lm wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=lm wordlist=dict.txt --rules hash.txt\nMD5CRYPT\nHASHCAT\nHASH FORMAT\n$1$28772684$iEwNOgGugq09.bIz5sk8k/\nBRUTE FORCE ATTACK\nhashcat -m 500 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 500 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 500 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\n$l$28772684$iEwNOgGugq09.bIz5sk8k/\nBRUTE FORCE ATTACK\njohn --format=md5crypt hash.txt\nWORDLIST ATTACK\njohn --format=md5crypt wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=md5crypt wordlist=dict.txt --rules hash.txt\nSHA1\nHASHCAT\nHASH FORMAT\nb89eaac7e61417341b710b727768294d0e6a277b\nBRUTE FORCE ATTACK\nhashcat -m 100 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 100 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 100 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\nb89eaac7e61417341b710b727768294d0e6a277b\nBRUTE FORCE ATTACK\njohn --format=raw-sha1 hash.txt\nWORDLIST ATTACK\njohn --format=raw-sha1 wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=raw-sha1 wordlist=dict.txt --rules hash.txt\nSHA256\nHASHCAT\nHASH FORMAT\n127e6fbfe24a750e72930c220a8el38275656b8e5d8f48a98c3c92df2caba935\nBRUTE FORCE ATTACK\nhashcat -m 1400 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 1400 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 1400 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\n127e6fbfe24a750e72930c220a8el38275656b8e5d8f48a98c3c92df2caba935\nBRUTE FORCE ATTACK\njohn --format=raw-sha256 hash.txt\nWORDLIST ATTACK\njohn --format=raw-sha256 wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=raw-sha256 wordlist=dict.txt --rules hash.txt\nBCRYPT\nHASHCAT\nHASH FORMAT\n$2a$05$LhayLxezLhKlLhWvKxCyLOj0jlu.Kj0jZ0pEmml34uzrQlFvQDLF6\nBRUTE FORCE ATTACK\nhashcat -m 3200 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 3200 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 3200 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\n$2a$05$LhayLxezLhKlLhWvKxCyLOj0jlu.Kj0jZ0pEmml34uzrQlFvQDLF6\nBRUTE FORCE ATTACK\njohn --format=bcrypt hash.txt\nWORDLIST ATTACK\njohn --format=bcrypt wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=bcrypt wordlist=dict.txt --rules hash.txt\nPDF 1.4 - 1.6 (ACROBAT 5-8)\nHASHCAT\nHASH FORMAT\n$pdf$2*3*128*-1028*l*16*da42eel5d4b3e08fe5b9ecea0e02ad0f*32*c9b59d72c7c670c42eeb\n4fcald2cal5000000000000000000000000000000000*32*c4ff3e868dc87604626c2b8c259297al\n4d58c6309c70b00afdfblfbbal0ee571\nEXTRACT HASH\npdf2hashcat.py example.pdf > hash.txt\nBRUTE FORCE ATTACK\nhashcat -m 10500 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 10500 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 10500 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\n$pdf$Standard*badadle86442699427116d3e5d5271bc80a27814fc5e80f815efeef839354c5f*2\n89ece9b5ce451a5d7064693dab3badfl01112131415161718191alblcldlelf*16*34blb6e593787\naf681a9b63fa8bf563b*l*l*0*l*4*128*-4*3*2\nEXTRACT HASH\npdf2john.py example.pdf > hash.txt\nBRUTE FORCE ATTACK\njohn --format=pdf hash.txt\nWORDLIST ATTACK\njohn --format=pdf wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=pdf wordlist=dict.txt --rules hash.txt\nMICROSOFT OFFICE 2013\nHASHCAT\nHASH FORMAT\nexample.docx:$office$*2013*100000*256*16*7dd611d7eb4c899f74816dldec817b3b*948dc0\nb2c2c6c32fl4b5995a543ad037*0b7ee0e48e935f937192a59de48a7d561ef2691d5c8a3ba87ec2d\n04402a94895\nEXTRACT HASH\noffice2hashcat.py example.docx > hash.txt\nBRUTE FORCE ATTACK\nhashcat -m 9600 -a 3 --username hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 9600 -a 0 --username hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 9600 -a 0 --username hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\nexample.docx:$office$*2013*100000*256*16*7dd611d7eb4c899f74816dldec817b3b*948dc0b2c2c6c32f14b5995a543ad037*0b7ee0e48e935f937192a59de48a7d561ef2691d5c8a3ba87ec2d\n04402a94895\nEXTRACT HASH\noffice2john.py example.docx > hash.txt\nBRUTE FORCE ATTACK\njohn --format=office2013 hash.txt\nWORDLIST ATTACK\njohn --format=office2013 wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=office2013 wordlist=dict.txt --rules hash.txt\nRAR3-HP (ENCRYPTED HEADER)\nHASHCAT\nHASH FORMAT\n$RAR3$*0*45109af8ab5f297a*adbf6c5385d7a40373e8f77d7b89d317\n#!Ensure to remove extraneous rar2john output to match above hash!#\nEXTRACT HASH\nrar2john.py example.rar > hash.txt\nBRUTE FORCE ATTACK\nhashcat -m 12500 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 12500 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 12500 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\nexample.rar:$RAR3$*l*20e041a232b4b7f0*5618c5f0*1472*2907*0*/Path/To/\nexample.rar*138*33:1::example.txt\nEXTRACT HASH\nrar2john.py example.rar > hash.txt\nBRUTE FORCE ATTACK\njohn --format=rar hash.txt\nWORDLIST ATTACK\njohn --format=rar wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=rar wordlist=dict.txt --rules hash.txt\nWINZIP\nHASHCAT\nHASH FORMAT\n$zip2$*0*3*0*b5d2b7bf57ad5e86a55c400509c672bd*d218*0**ca3d736d03a34165cfa9*$/\nzip2$\n#!Ensure to remove extraneous zip2john output to match above hash!#\nEXTRACT HASH\nzip2john.py example.zip > hash.txt\nBRUTE FORCE ATTACK\nhashcat -m 13600 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 13600 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 13600 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\nexample.zip:$zip2$*0*3*0*5b0a8bl53fb94bf719abb81a80e90422*8e91*9*0b76bf50al5\n938ce9c*3f37001e241el96195al*$/zip2$:: : ::example.zip\nEXTRACT HASH\nzip2john.py example.zip > hash.txt\nBRUTE FORCE ATTACK\njohn --format=ZIP hash.txt\nWORDLIST ATTACK\njohn --format=ZIP wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=ZIP wordlist=dict.txt --rules hash.txt\n7-ZIP\nHASHCAT\nHASH FORMAT\n$7z$0$19$0$salt$8$f6196259a7326e3f0000000000000000$185065650$112$98$f3bc2a88062c\n419a25acd40c0c2d75421cf23263f69c51bl3f9blaada41a8a09f9adeae45d67c60b56aad338f20c\n0dcc5eb811c7a61128ee0746f922cdb9c59096869f341c7a9cblac7bb7d771f546b82cf4e6flla5e\nCd4b61751e4d8de66dd6e2dfb5b7dl022d2211e2d66eal703f96\n#!Ensure to remove extraneous 7zip2john output to match above hash!#\nEXTRACT HASH\n7z2john.py example.7z > hash.txt\nBRUTE FORCE ATTACK\nhashcat -m 11600 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 11600 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 11600 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\nexample.7z:$7z$0$19$0$salt$8$f6196259a7326e3f0000000000000000$185065650$112$98$f\n3bc2a88062c419a25acd40c0c2d75421cf23263f69c51bl3f9blaada41a8a09f9adeae45d67c60b5\n6aad338f20c0dcc5eb811c7a61128ee0746f922cdb9c59096869f341c7a9cblac7bb7d771f546b82\nCf4e6flla5ecd4b61751e4d8de66dd6e2dfb5b7dl022d2211e2d66eal703f96\nEXTRACT HASH\n7z2john.py example.7z > hash.txt\nBRUTE FORCE ATTACK\njohn --format=7z hash.txt\nWORDLIST ATTACK\njohn --format=7z wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=7z wordlist=dict.txt --rules hash.txt\nBITCOIN / LITECOIN\nHASHCAT\nHASH FORMAT\n$bitcoin$96$d011alb6a8d675b7a36d0cd2efaca32a9f8dcld57d6d01a58399ea04e703e8bbb448\n99039326f7a00fl71a7bbc854a54$16$1563277210780230$158555$96$628835426818227243334\n570448571536352510740823233055715845322741625407685873076027233865346542174$66$6\n25882875480513751851333441623702852811440775888122046360561760525\nEXTRACT HASH\nbitcoin2john.py wallet.dat > hash.txt\nBRUTE FORCE ATTACK\nhashcat -m 11300 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 11300 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 11300 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\n$bitcoin$96$d011alb6a8d675b7a36d0cd2efaca32a9f8dcld57d6d01a58399ea04e703e8bbb448\n99039326f7a00fl71a7bbc854a54$16$1563277210780230$158555$96$628835426818227243334\n570448571536352510740823233055715845322741625407685873076027233865346542174$66$6\n25882875480513751851333441623702852811440775888122046360561760525\nEXTRACT HASH\nbitcoin2john.py wallet.dat > hash.txt\nBRUTE FORCE ATTACK\njohn --format=bitcoin hash.txt\nWORDLIST ATTACK\njohn --format=bitcoin wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=bitcoin wordlist=dict.txt --rules hash.txt\nMAC OS X 10.8-10.12\nHASHCAT\nHASH FORMAT\nusername:$ml$35714$50973de90d336b5258f01e48ab324aa9ac81ca7959ac470d3d9c4395af624\n398$631a0ef84081b37cfe594a5468cf3a63173cd2ec25047b89457ed300f2b41b30a0792a39912f\nC5f3f7be8f74b7269ee3713172642de96ee482432a8dl2bf291a\nEXTRACT HASH\nsudo plist2hashcat.py /var/db/dslocal/nodes/Default/users/<username>.plist\nBRUTE FORCE ATTACK\nhashcat -m 122 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 122 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 122 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\nusername:$pbkdf2-hmac-\nsha512$31724.019739e90d326b5258f01e483bl24aa9ac81ca7959acb\n70c3d9c4297af924398.631a0bf84081b37dae594a5468cf3a63183cd2ec25047b89457ed300f2bf\n1b40a0793a39512fc5a3f7ae8f74b7269ee3723172642de96eee82432a8dllbf365e:\n501:20 : HOST\nNAME:/bin/bash:/var/db/dslocal/nodes/Default/users/username.plist\nEXTRACT HASH\nsudo ml2john.py /var/db/dslocal/nodes/Default/users/<username>.plist\nBRUTE FORCE ATTACK\njohn --format=xsha hash.txt\nWORDLIST ATTACK\njohn --format=xsha wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=xsha wordlist=dict.txt --rules hash.txt\nMYSQL4.1 / MYSQL5+ (DOUBLE SHA1)\nHASHCAT\nHASH FORMAT\nFCF7C1B8749CF99D88E5F34271D636178FB5D130\nEXTRACT HASH\nSELECT user,password FROM mysql.user INTO OUTFILE ‘/tmp/hash.txt’;\nBRUTE FORCE ATTACK\nhashcat -m 300 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 300 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 300 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\n*FCF7C1B8749CF99D88E5F34271D636178FB5D130\nEXTRACT HASH\nSELECT user,password FROM mysql.user INTO OUTFILE ‘/tmp/hash.txt’;\nBRUTE FORCE ATTACK\njohn --format=mysql-sha1 hash.txt\nWORDLIST ATTACK\njohn --format=mysql-sha1 wordlist=dict.txt hash.txt\nPOSTGRESQL\nHASHCAT\nHASH FORMAT\na6343a68d964ca596d9752250d54bb8a:postgres\nEXTRACT HASH\nSELECT username, passwd FROM pg_shadow;\nBRUTE FORCE ATTACK\nhashcat -m 12 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 12 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 12 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\na6343a68d964ca596d9752250d54bb8a:postgres\nEXTRACT HASH\nSELECT username, passwd FROM pg_shadow;\nBRUTE FORCE ATTACK\njohn --format=postgres hash.txt\nWORDLIST ATTACK\njohn --format=postgres wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=postgres wordlist=dict.txt --rules hash.txt\nMSSQL(2012), MSSQL(2014)\nHASHCAT\nHASH FORMAT\n0x02000102030434ealbl7802fd95ea6316bd61d2c94622ca3812793e8fbl672487b5c904a45a31b\n2ab4a78890d563d2fcf5663e46fe797d71550494be50cf4915d3f4d55ec375\nEXTRACT HASH\nSELECT SL.name,SL.password_hash FROM sys.sql_logins AS SL;\nBRUTE FORCE ATTACK\nhashcat -m 1731 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 1731 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 1731 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\n0x02000102030434ealbl7802fd95ea6316bd61d2c94622ca3812793e8fbl672487b5c904a45a31b\n2ab4a78890d563d2fcf5663e46fe797d71550494be50cf4915d3f4d55ec375\nEXTRACT HASH\nSELECT SL.name,SL.password_hash FROM sys.sql_logins AS SL;\nBRUTE FORCE ATTACK\njohn --format=mssql12 hash.txt\nWORDLIST ATTACK\njohn --format=mssql12 wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=mssql12 wordlist=dict.txt --rules hash.txt\nORACLE 11G\nHASHCAT\nHASH FORMAT\nac5fle62d21fd0529428b84d42e8955b04966703:38445748184477378130\nEXTRACT HASH\nSELECT SL.name,SL.password_hash FROM sys.sql_logins AS SL;\nBRUTE FORCE ATTACK\nhashcat -m 112 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 112 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 112 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\nac5fle62d21fd0529428b84d42e8955b04966703:38445748184477378130\nEXTRACT HASH\nSELECT SL.name,SL.password_hash FROM sys.sql_logins AS SL;\nBRUTE FORCE ATTACK\njohn --format=oraclell hash.txt\nWORDLIST ATTACK\njohn --format=oraclell wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=oraclell wordlist=dict.txt --rules hash.txt\nCISCO TYPE 4 (SHA256)\nHASHCAT\nHASH FORMAT\n2btjjy78REtmYkkW0csHUbDZOstRXoWdX1mGrmmfeHI\nBRUTE FORCE ATTACK\nhashcat -m 5700 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 5700 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 5700 -a 0 hash.txt dict.txt -r rule.txt\nCISCO TYPE 5 (MD5)\nHASHCAT\nHASH FORMAT\n$l$28772684$iEwN0gGugq09.bIz5sk8k/\nBRUTE FORCE ATTACK\nhashcat -m 500 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 500 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 500 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\n$1$28772684$iEwN0gGugq09.bIz5sk8k/\nBRUTE FORCE ATTACK\njohn --format=md5crypt hash.txt\nWORDLIST ATTACK\njohn --format=md5crypt wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=md5crypt wordlist=dict.txt --rules hash.txt\nCISCO TYPE 8 (PBKDF2+SHA256)\nHASHCAT\nHASH FORMAT\n$8$TnGX/fE4KGH0VU$pEhnEvxrvaynpi8j4f.EMHr6M.FzU8xnZnBr/tJdFWk\nBRUTE FORCE ATTACK\nhashcat -m 9200 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 9200 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 9200 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\n$8$TnGX/fE4KGH0VU$pEhnEvxrvaynpi8j4f.EMHr6M.FzU8xnZnBr/tJdFWk\nBRUTE FORCE ATTACK\njohn --format=pbkdf2-hmac-sha256 hash.txt\nWORDLIST ATTACK\njohn --format=pbkdf2-hmac-sha256 wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=pbkdf2-hmac-sha256 wordlist=dict.txt --rules hash.txt\nCISCO TYPE 9 (SCRYPT)\nHASHCAT\nHASH FORMAT\n$9$2MJBozw/9R3UsU$21FhcKvpghcyw8deP25G0fyZaagyU0GBymkryv0dfo6\nBRUTE FORCE ATTACK\nhashcat -m 9300 -a 3 hash.txt ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 9300 -a 0 hash.txt dict.txt\nWORDLIST + RULE ATTACK\nhashcat -m 9300 -a 0 hash.txt dict.txt -r rule.txt\nJOHN\nHASH FORMAT\n$9$2MJBozw/9R3UsU$21FhcKvpghcyw8deP25G0fyZaagyU0GBymkryv0dfo6\nBRUTE FORCE ATTACK\njohn --format=scrypt hash.txt\nWORDLIST ATTACK\njohn --format=scrypt wordlist=dict.txt hash.txt\nWORDLIST + RULE ATTACK\njohn --format=scrypt wordlist=dict.txt --rules hash.txt\nWPA PSK / WPA2 PSK\nHASHCAT\nHASH FORMAT\n*Capture 4-way authentication handshake > capture.cap\ncap2hccapx.bin capture.cap capture_out.hccapx\nBRUTE FORCE ATTACK\nhashcat -m 2500 -a 3 capture_out.hccapx ?a?a?a?a?a?a\nWORDLIST ATTACK\nhashcat -m 2500 -a 3 capture_out.hccapx dict.txt\nWORDLIST + RULE ATTACK\nhashcat -a 0 capture_out.hccapx dict.txt -r rule.txt\nJOHN\nHASH FORMAT\n*Capture 4-way authentication handshake > capture.cap\ncap2hccap.bin -e ‘<ESSID>’ capture.cap capture_out.hccap\nhccap2john capture_out.hccap > jtr_capture\nBRUTE FORCE ATTACK\njohn --format=wpapsk jtr_capture\nWORDLIST ATTACK\njohn --format=wpapsk wordlist=dict.txt jtr_capture\nWORDLIST + RULE ATTACK\njohn --format=wpapsk wordlist=dict.txt --rules jtr_capture"
  },
  {
    "index": 17,
    "text": "APPENDIX\nTERMS\nBRUTE-FORCE ATTACK - the act of trying every possible\ncombination of a given keyspace or character set for a given length\nDICTIONARY - a collection of commons words, phrases, keyboard\npatterns, generated passwords, or leaked passwords, also known as a\nwordlist\nDICTIONARY ATTACK - using a file containing common or known\npassword combinations or words in an attempt to match a given hashing\nfunction’s output by running said words through the same target\nhashing function\nHASH - the fixed bit result of a hash function\nHASH FUNCTION - maps data of arbitrary size to a bit string of a fixed\nsize (a hash function) which is designed to also be a one-way function,\nthat is, a function which is infeasible to invert\nITERATIONS - the number of times an algorithm is run over a given\nhash\nKEYSPACE - the number of possible combinations for a given character\nset to the power of it’s length (i.e. charset^length)\nMASK ATTACK - using placeholder representations to try all\ncombinations of a given keyspace, similar to brute-force but more\ntargeted and efficient\nPASSWORD ENTROPY - an estimation of how difficult a password will\nbe to crack given its character set and length"
  },
  {
    "index": 18,
    "text": "PLAINTEXT - unaltered text that hasn’t been obscured or\nalgorithmically altered through a hashing function\nRAKING - generating random password rules/candidates in an attempt\nto discover a previously unknown matching password pattern\nRAINBOW TABLE - a precomputed table of a targeted cryptographic\nhash function of a certain minimum and maximum character length\nRULE ATTACK - similar to a programming language for generating\ncandidate passwords based on some input such as a dictionary\nSALT - random data that used as additional input to a one-way function\nWORDLIST - a collection of commons words, phrases, keyboard\npatterns, generated passwords, or leaked passwords, also known as a\ndictionary\nTIME TABLE\n60 seconds 1 minute\n3,600 seconds 1 hour\n86,400 seconds 1 day\n604,800 seconds 1 week\n1,209,600 seconds 1 fortnight\n2,419,200 seconds 1 month (30days)\n31,536,000 seconds 1 year\nONLINE RESOURCES\nJOHN\nhttp://openwall.info/wiki/john\nhttp://openwall.info/wiki/john/sample-non-hashes\nhttp://pentestmonkey.net/cheat-sheet/john-the-ripper-hash-formats\nhttps://countuponsecurity.com/2015/06/14/jonh-the-ripper-cheat-sheet/\nhttps://xinn.org/blog/JtR-AD-Password-Auditing.html\nhttps://www.owasp.org/images/a/af/2011-Supercharged-Slides-Redman-\nOWASP-Feb.pdf\nHASHCAT\nhttps://hashcat.net/wiki/\nhttps://hashcat.net/wiki/doku.php?id=hashcat_utils\nhttps://hashcat.net/wiki/doku.php?id=statsprocessor\nhttp://www.netmux.com/blog/ultimate-guide-to-cracking-foreign-character-\npasswords-using-has\nhttp://www.netmux.com/blog/cracking-12-character-above-passwords\nCRACKING RIGS\nhttp://www.netmux.com/blog/how-to-build-a-password-cracking-rig\nhttps://www.unix-\nninja.com/p/Building_a_Password_Cracking_Rig_for_Hashcat_-_Part_III\nEXAMPLE HASH GENERATION\nhttps://www.onlinehashcrack.com/hash-generator.php\nhttps://www.tobtu.com/tools.php\nhttp://hash.online-convert.com/\nhttps://www.tools4noobs.com/online_tools/hash/\nhttps://quickhash.com/\nhttp://bitcoinvalued.com/tools.php\nhttp://www.sha1-online.com/\nhttp://www.freeformatter.com/hmac-generator.html\nhttp://openwall.info/wiki/john/Generating-test-hashes\nOTHER\nhttp://blog.thireus.com/cracking-story-how-i-cracked-over-122-million-sha1-\nand-md5-hashed-passwords/\nhttp://www.utf8-chartable.de/\nhttp://thesprawl.org/projects/pack/\nhttps://blog.gotmilk.com/2011/06/dictionaries-wordlists/\nhttp://wpengine.com/unmasked/\nhttps://www.unix-ninja.com/p/A_cheat-sheet_for_password_crackers\nhttps://room362.com/post/2017/05-06-2017-password-magic-numbers/\nhttp://www.netmux.com/blog/how-to-build-a-password-cracking-rig\nhttp://passwordchart.com/\nhttp://www.vigilante.pw\nNETMUX\nhttp://www.netmux.com\nhttp://www.hashcrack.io\nhttps://github.com/netmux\nhttps://twitter.com/netmux\nhttps://www.instagram.com/netmux/\n***ANSWER TO CUSTOM DICTIONARY CREATION HASH:\ne4821dl6a298092638ddb7cadc26d32f = letmein123456Netmux\n10 CRACK COMMANDMENTS\n1. Thou shalt know hash types and their origin/function\n2. Thou shalt know cracking software strengths & weaknesses\n3. Thou shalt study & apply password analysis techniques\n4 Thou shalt be proficient at hash extraction methods\n5. Thou shalt create custom/targeted dictionaries\n6. Thou shalt know thy cracking rigs capabilities\n7. Thou shalt understand basic human psychology/behavior\n8. Thou shalt create custom masks, rules, and Markov chains"
  },
  {
    "index": 19,
    "text": "9. Thou shalt continually experiment with new techniques\n10. Thou shalt support thy fellow cracking community members\nJOHN THE RIPPER HELP MENU\nJohn the Ripper password cracker, version 1.8.0-jumbo-1 [darwinl5.6.0 64-\nbit AVX2-autoconf]\nCopyright (c) 1996-2014 by Solar Designer and others\nHomepage: http://www.openwall.com/john/\nUsage: john [OPTIONS] [PASSWORD-FILES]\n--single[=SECTION] “single crack” mode\n--wordlist[=FILE] --stdin wordlist mode, read words from FILE\nor stdin\n--pipe like --stdin, but bulk reads, and allows\nrules\n--loopback[=FILE] like --wordlist, but fetch words from a\n.pot file\n--dupe-suppression suppress all dupes in wordlist (and\nforce preload)\n--encoding=NAME input encoding (eg. UTF-8, ISO-8859-\n1). See also doc/ENCODING and --\nlist=hidden-options.\n--rules[=SECTION] enable word mangling rules for\nwordlist modes\n--incremental[=MODE] “incremental” mode [using section\nMODE]\n--mask=MASK mask mode using MASK\n--markov[=OPTIONS] “Markov” mode (see doc/MARKOV)\n--external=MODE external mode or word filter\n--stdout[=LENGTH] just output candidate passwords [cut\nat LENGTH]\n--restore[=NAME] restore an interrupted session [called\nNAME]\n--session=NAME give a new session the NAME\n--status[=NAME] print status of a session [called\nNAME]\n--make-charset=FILE make a charset file. It will be\noverwritten\n--show[=LEFT] show cracked passwords [if =LEFT,\nthen uncracked]\n--test[=TIME] run tests and benchmarks for TIME\nseconds each\n--users=[-]LOGIN|UID[,..] [do not] load this (these) user(s) only\n--groups=[-]GID[,..] load users [not] of this (these)\ngroup(s) only\n--shells=[-]SHELL[,..] load users with[out] this (these)\nshell(s) only\n--salts=[-]COUNT[:MAX] load salts with[out] COUNT [to\nMAX] hashes\n--save-memory=LEVEL enable memory saving, at LEVEL 1..3\n--node=MIN[-MAX]/TOTAL this node’s number range out of\nTOTAL count\n--fork=N fork N processes\n--pot=NAME pot file to use\n--list=WHAT list capabilities, see --list=help or\ndoc/OPTIONS\n--devices=N[,..] devices) set OpenCL device(s) (list using --\nlist=opencl-\n--format=NAME force hash type NAME:\n7z 7z-opencl AFS agilekeychain agilekeychain-opencl aix-smd5 aix-ssha1\naix-ssha256 aix-ssha512 asa-md5 bcrypt bcrypt-opencl bfegg Bitcoin\nblackberry-es10 Blockchain blockchain-opencl bsdicrypt chap Citrix_NS10\nClipperz cloudkeychain cq CRC32 crypt dahua descrypt descrypt-opencl\nDjango django-scrypt dmd5 dmg dmg-opencl dominosec dragonfly3-32\ndragonfly3-64 dragonfly4-32 dragonfly4-64 Drupal7 dummy dynamic_n\neCryptfs EFS eigrp EncFS encfs-opencl EPI EPiServer fde FormSpring\nFortigate gost gpg gpg-opencl HAVAL-128-4 HAVAL-256-3 hdaa HMAC-\nMD5 HMAC-SHA1 HMAC-SHA224 HMAC-SHA256 HMAC-SHA384\nHMAC-SHA512 hMailServer hsrp IKE ipb2 KeePass keychain keychain-\nopencl keyring keyring-opencl keystore known_hosts krb4 krb5 krb5-18\nkrb5pa-md5 krb5pa-md5-opencl krb5pa-sha1 krb5pa-sha1-opencl kwallet\nLastPass LM lotus5 lotus5-opencl lotus85 LUKS MD2 md4-gen md5crypt\nmd5crypt-opencl md5ns mdc2 MediaWiki MongoDB Mozilla mscash\nmscash2 mscash2-opencl MSCHAPv2 mschapv2-naive mssql mssql05\nmssqll2 mysql mysql-sha1 mysql-sha1-opencl mysqlna net-md5 net-sha1\nnethalflm netlm netlmv2 netntlm netntlm-naive netntlmv2 nk nsldap NT nt-\nopencl nt2 ntlmv2-opencl o51ogon o51ogon-opencl ODF ODF-AES-opencl\nODF-opencl Office office2007-opencl office2010-opencl office2013-opencl\noldoffice oldoffice-opencl OpenBSD-SoftRAID openssl-enc OpenVMS\noracle oraclell osc Panama PBKDF2-HMAC-SHA1 PBKDF2-HMAC-\nSHA1-opencl PBKDF2-HMAC-SHA256 PBKDF2-HMAC-SHA256-opencl\nPBKDF2-HMAC-SHA512 pbkdf2-hmac-sha512-opencl PDF PFX phpass\nphpass-opencl PHPS pix-md5 PKZIP po postgres PST PuTTY pwsafe\npwsafe-opencl RACF RAdmin RAKP RAKP-opencl rar rar-opencl RAR5\nRAR5-opencl Raw-Blake2 Raw-Keccak Raw-Keccak-256 Raw-MD4 Raw-\nMD4-opencl Raw-MD5 Raw-MD5-opencl Raw-MD5u Raw-SHA Raw-\nSHA1 Raw-SHA1-Linkedin Raw-SHA1-ng Raw-SHA1-opencl Raw-\nSHA224 Raw-SHA256 Raw-SHA256-ng Raw-SHA256-opencl Raw-\nSHA384 Raw-SHA512 Raw-SHA512-ng Raw-SHA512-opencl ripemd-128\nripemd-160 rsvp Salted-SHA1 sapb sapg scrypt sha1-gen sha1crypt\nsha1crypt-opencl sha256crypt sha256crypt-opencl sha512crypt sha512crypt-\nopencl Siemens-S7 SIP skein-256 skein-512 skey Snefru-128 Snefru-256\nSSH SSH-ng ssha-opencl SSHA512 STRIP strip-opencl SunMD5 sxc sxc-\nopencl Sybase-PROP sybasease tc_aes_xts tc_ripemdl60 tc_sha512\ntc_whirlpool tcp-md5 Tiger tripcode VNC vtp wbb3 whirlpool whirlpool0\nwhirlpooll WoWSRP wpapsk wpapsk-opencl xsha xsha512 XSHA512-\nopencl ZIP zip-opencl"
  },
  {
    "index": 20,
    "text": "HASHCAT HELP MENU\nhashcat 3.6 - advanced password recovery\nUsage: hashcat [options]... hash|hash-file|hccapxfile [dictionary|mask|\ndirectory]...\n- [ Options ] -\nIf you still have no idea what just happened, try the following pages:\n* https://hashcat.net/wiki/#howtos_videos_papers_articles_etc_in_the_wild\n* https://hashcat.net/faq/"
  }
]
[END_CHUNKS]
Reply with the index only: